LavaPack.loadBundle([
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash.isequalwith/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash.isequalwith/index.js
      return function (require, module, exports) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * This method is like `_.isEqual` except that it accepts `customizer` which
 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
 * are handled by the method instead. The `customizer` is invoked with up to
 * six arguments: (objValue, othValue [, index|key, object, other, stack]).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 *
 * function customizer(objValue, othValue) {
 *   if (isGreeting(objValue) && isGreeting(othValue)) {
 *     return true;
 *   }
 * }
 *
 * var array = ['hello', 'goodbye'];
 * var other = ['hi', 'goodbye'];
 *
 * _.isEqualWith(array, other, customizer);
 * // => true
 */
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  var result = customizer ? customizer(value, other) : undefined;
  return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = isEqualWith;

      };
    };
  }
}, {package:"lodash.isequalwith",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash.isequalwith/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/entry.js", {"../wantlist":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/wantlist/index.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/entry.js
      return function (require, module, exports) {
'use strict'

const WantlistEntry = require('../wantlist').Entry
const CID = require('cids')
const assert = require('assert')

module.exports = class BitswapMessageEntry {
  constructor (cid, priority, cancel) {
    assert(CID.isCID(cid), 'needs valid cid')
    this.entry = new WantlistEntry(cid, priority)
    this.cancel = Boolean(cancel)
  }

  get cid () {
    return this.entry.cid
  }

  set cid (cid) {
    this.entry.cid = cid
  }

  get priority () {
    return this.entry.priority
  }

  set priority (val) {
    this.entry.priority = val
  }

  get [Symbol.toStringTag] () {
    const cidStr = this.cid.toBaseEncodedString()

    return `BitswapMessageEntry ${cidStr} <cancel: ${this.cancel}, priority: ${this.priority}>`
  }

  equals (other) {
    return (this.cancel === other.cancel) &&
           this.entry.equals(other.entry)
  }
}

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/entry.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint-decoder/src/index.js", {"../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/varint-decoder/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const varint = require('varint')

module.exports = (buf) => {
  if (!Buffer.isBuffer(buf)) {
    throw new Error('arg needs to be a buffer')
  }

  let result = []

  while (buf.length > 0) {
    const num = varint.decode(buf)
    result.push(num)
    buf = buf.slice(varint.decode.bytes)
  }

  return result
}

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"varint-decoder",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint-decoder/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/index.js", {"./crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/crypto.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const multihash = require('multihashes')
const crypto = require('./crypto')

module.exports = Multihashing

/**
 * Hash the given `buf` using the algorithm specified
 * by `func`.
 *
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
function Multihashing (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  Multihashing.digest(buf, func, length, (err, digest) => {
    if (err) {
      return callback(err)
    }

    callback(null, multihash.encode(digest, func, length))
  })
}

/**
 * The `buffer` module for easy use in the browser.
 *
 * @type {Buffer}
 */
Multihashing.Buffer = Buffer // for browser things

/**
 * Expose multihash itself, to avoid silly double requires.
 */
Multihashing.multihash = multihash

/**
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
Multihashing.digest = function (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  let cb = callback
  if (length) {
    cb = (err, digest) => {
      if (err) {
        return callback(err)
      }

      callback(null, digest.slice(0, length))
    }
  }

  let hash
  try {
    hash = Multihashing.createHash(func)
  } catch (err) {
    return cb(err)
  }

  hash(buf, cb)
}

/**
 * @param {string|number} func
 *
 * @returns {function} - The to `func` corresponding hash function.
 */
Multihashing.createHash = function (func) {
  func = multihash.coerceCode(func)
  if (!Multihashing.functions[func]) {
    throw new Error('multihash function ' + func + ' not yet supported')
  }

  return Multihashing.functions[func]
}

/**
 * Mapping of multihash codes to their hashing functions.
 * @type {Object}
 */
Multihashing.functions = {
  // sha1
  0x11: crypto.sha1,
  // sha2-256
  0x12: crypto.sha2256,
  // sha2-512
  0x13: crypto.sha2512,
  // sha3-512
  0x14: crypto.sha3512,
  // sha3-384
  0x15: crypto.sha3384,
  // sha3-256
  0x16: crypto.sha3256,
  // sha3-224
  0x17: crypto.sha3224,
  // shake-128
  0x18: crypto.shake128,
  // shake-256
  0x19: crypto.shake256,
  // keccak-224
  0x1A: crypto.keccak224,
  // keccak-256
  0x1B: crypto.keccak256,
  // keccak-384
  0x1C: crypto.keccak384,
  // keccak-512
  0x1D: crypto.keccak512,
  // murmur3-128
  0x22: crypto.murmur3128,
  // murmur3-32
  0x23: crypto.murmur332,
  // dbl-sha2-256
  0x56: crypto.dblSha2256
}

// add blake functions
crypto.addBlake(Multihashing.functions)

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/wantlist/entry.js", {"assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/wantlist/entry.js
      return function (require, module, exports) {
'use strict'

const assert = require('assert')
const CID = require('cids')

class WantListEntry {
  constructor (cid, priority) {
    assert(CID.isCID(cid), 'must be valid CID')

    // Keep track of how many requests we have for this key
    this._refCounter = 1

    this.cid = cid
    this.priority = priority || 1
  }

  inc () {
    this._refCounter += 1
  }

  dec () {
    this._refCounter = Math.max(0, this._refCounter - 1)
  }

  hasRefs () {
    return this._refCounter > 0
  }

  // So that console.log prints a nice description of this object
  get [Symbol.toStringTag] () {
    const cidStr = this.cid.toBaseEncodedString()
    return `WantlistEntry <key: ${cidStr}, priority: ${this.priority}, refs: ${this._refCounter}>`
  }

  equals (other) {
    return (this._refCounter === other._refCounter) &&
      this.cid.equals(other.cid) &&
      this.priority === other.priority
  }
}

module.exports = WantListEntry

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/wantlist/entry.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/bignumber.js/bignumber.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/bignumber.js/bignumber.js
      return function (require, module, exports) {
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v8.1.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2019 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    hasSymbol = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol',

    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                    // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',      // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if only one character,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.$|[+-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return 0, else return Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, Infinity or 0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return Infinity if either is Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return 0 if either is 0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return Infinity if either Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '1e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (hasSymbol) {
      P[Symbol.toStringTag] = 'BigNumber';

      // Node.js v10.12.0+
      P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;
    }

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

      };
    };
  }
}, {package:"bignumber.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/bignumber.js/bignumber.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/moving-average/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/moving-average/index.js
      return function (require, module, exports) {
'use strict'

const exp = Math.exp

exports =
module.exports =
function MovingAverage (timespan) {
  if (typeof timespan !== 'number') { throw new Error('must provide a timespan to the moving average constructor') }

  if (timespan <= 0) { throw new Error('must provide a timespan > 0 to the moving average constructor') }

  let ma     // moving average
  let v = 0  // variance
  let d = 0  // deviation
  let f = 0  // forecast

  let previousTime

  let ret = {}

  function alpha (t, pt) {
    return 1 - (exp(-(t - pt) / timespan))
  }

  ret.push =
  function push (time, value) {
    if (previousTime) {
      // calculate moving average
      const a = alpha(time, previousTime)
      const diff = value - ma
      const incr = a * diff
      ma = a * value + (1 - a) * ma
      // calculate variance & deviation
      v = (1 - a) * (v + diff * incr)
      d = Math.sqrt(v)
      // calculate forecast
      f = ma + a * diff
    } else {
      ma = value
    }
    previousTime = time
  }

  // Exponential Moving Average

  ret.movingAverage =
  function movingAverage () {
    return ma
  }

  // Variance
  ret.variance =
  function variance () {
    return v
  }

  ret.deviation =
  function deviation () {
    return d
  }

  ret.forecast =
  function forecast () {
    return f
  }

  return ret
}

      };
    };
  }
}, {package:"moving-average",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/moving-average/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/encode.js", {"safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/encode.js
      return function (require, module, exports) {
'use strict'

const Buffer = require('safe-buffer').Buffer

module.exports = encode

const poolSize = 10 * 1024

function encode (opts) {
  opts = Object.assign({
    fixed: false
  }, opts || {})

  // Only needed for varint
  const varint = require('varint')
  let pool = opts.fixed ? null : createPool()
  let used = 0

  let ended = false

  return (read) => (end, cb) => {
    if (end) ended = end
    if (ended) return cb(ended)

    read(null, (end, data) => {
      if (end) ended = end
      if (ended) return cb(ended)

      if (!ended && !Buffer.isBuffer(data)) {
        ended = new Error('data must be a buffer')
        return cb(ended)
      }

      const dataLength = ended ? 0 : data.length

      let encodedLength
      if (opts.fixed) {
        encodedLength = Buffer.alloc(4)
        encodedLength.writeInt32BE(dataLength, 0) // writes exactly 4 bytes
      } else {
        varint.encode(dataLength, pool, used)
        used += varint.encode.bytes
        encodedLength = pool.slice(used - varint.encode.bytes, used)

        if (pool.length - used < 100) {
          pool = createPool()
          used = 0
        }
      }

      if (ended) {
        return cb(null, encodedLength)
      }

      cb(null, Buffer.concat([
        encodedLength,
        data
      ], (opts.fixed ? 4 : varint.encode.bytes) + dataLength))
    })
  }
}

function createPool () {
  return Buffer.alloc(poolSize)
}

      };
    };
  }
}, {package:"pull-length-prefixed",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/encode.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/decode.js", {"pull-pushable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-pushable/index.js","pull-reader":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-reader/index.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/decode.js
      return function (require, module, exports) {
'use strict'

const varint = require('varint')
const Reader = require('pull-reader')
const Buffer = require('safe-buffer').Buffer
const pushable = require('pull-pushable')

exports.decode = decode
exports.decodeFromReader = decodeFromReader

const MSB = 0x80
const isEndByte = (byte) => !(byte & MSB)
const MAX_LENGTH = ((1024 * 1024) * 4)

function decode (opts) {
  let reader = new Reader()
  let p = pushable((err) => {
    reader.abort(err)
  })

  return (read) => {
    reader(read)

    // this function has to be written without recursion
    // or it blows the stack in case of sync stream
    function next () {
      let doNext = true
      let decoded = false

      const decodeCb = (err, msg) => {
        decoded = true
        if (err) {
          p.end(err)
          doNext = false
        } else {
          p.push(msg)
          if (!doNext) {
            next()
          }
        }
      }

      while (doNext) {
        decoded = false
        _decodeFromReader(reader, opts, decodeCb)
        if (!decoded) {
          doNext = false
        }
      }
    }

    next()

    return p
  }
}

// wrapper to detect sudden pull-stream disconnects
function decodeFromReader (reader, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  _decodeFromReader(reader, opts, function onComplete (err, msg) {
    if (err) {
      if (err === true) return cb(new Error('Unexpected end of input from reader.'))
      return cb(err)
    }
    cb(null, msg)
  })
}

function _decodeFromReader (reader, opts, cb) {
  opts = Object.assign({
    fixed: false,
    maxLength: MAX_LENGTH
  }, opts || {})

  if (opts.fixed) {
    readFixedMessage(reader, opts.maxLength, cb)
  } else {
    readVarintMessage(reader, opts.maxLength, cb)
  }
}

function readFixedMessage (reader, maxLength, cb) {
  reader.read(4, (err, bytes) => {
    if (err) {
      return cb(err)
    }

    const msgSize = bytes.readInt32BE(0) // reads exactly 4 bytes
    if (msgSize > maxLength) {
      return cb(new Error('size longer than max permitted length of ' + maxLength + '!'))
    }

    readMessage(reader, msgSize, cb)
  })
}

function readVarintMessage (reader, maxLength, cb) {
  let rawMsgSize = []
  if (rawMsgSize.length === 0) readByte()

  // 1. Read the varint
  function readByte () {
    reader.read(1, (err, byte) => {
      if (err) {
        return cb(err)
      }

      rawMsgSize.push(byte)

      if (byte && !isEndByte(byte[0])) {
        readByte()
        return
      }

      const msgSize = varint.decode(Buffer.concat(rawMsgSize))
      if (msgSize > maxLength) {
        return cb(new Error('size longer than max permitted length of ' + maxLength + '!'))
      }

      readMessage(reader, msgSize, (err, msg) => {
        if (err) {
          return cb(err)
        }

        rawMsgSize = []

        if (msg.length < msgSize) {
          return cb(new Error('Message length does not match prefix specified length.'))
        }
        cb(null, msg)
      })
    })
  }
}

function readMessage (reader, size, cb) {
  reader.read(size, (err, msg) => {
    if (err) {
      return cb(err)
    }

    cb(null, msg)
  })
}

      };
    };
  }
}, {package:"pull-length-prefixed",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/decode.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/record.proto.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/record.proto.js
      return function (require, module, exports) {
'use strict'
module.exports = `// Record represents a dht record that contains a value
// for a key value pair
message Record {
  // The key that references this record
  bytes key = 1;

  // The actual value this record is storing
  bytes value = 2;

  // Note: These fields were removed from the Record message
  // hash of the authors public key
  // optional bytes author = 3;
  // A PKI signature for the key+value+author
  // optional bytes signature = 4;

  // Time the record was received, set by receiver
  optional string timeReceived = 5;
}`

      };
    };
  }
}, {package:"libp2p-record",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/record.proto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/utils.js
      return function (require, module, exports) {
'use strict'

/**
 * Convert a JavaScript date into an `RFC3339Nano` formatted
 * string.
 *
 * @param {Date} time
 * @returns {string}
 */
module.exports.toRFC3339 = (time) => {
  const year = time.getUTCFullYear()
  const month = String(time.getUTCMonth() + 1).padStart(2, '0')
  const day = String(time.getUTCDate()).padStart(2, '0')
  const hour = String(time.getUTCHours()).padStart(2, '0')
  const minute = String(time.getUTCMinutes()).padStart(2, '0')
  const seconds = String(time.getUTCSeconds()).padStart(2, '0')
  const milliseconds = time.getUTCMilliseconds()
  const nanoseconds = milliseconds * 1000 * 1000

  return `${year}-${month}-${day}T${hour}:${minute}:${seconds}.${nanoseconds}Z`
}

/**
 * Parses a date string formatted as `RFC3339Nano` into a
 * JavaScript Date object.
 *
 * @param {string} time
 * @returns {Date}
 */
module.exports.parseRFC3339 = (time) => {
  const rfc3339Matcher = new RegExp(
    // 2006-01-02T
    '(\\d{4})-(\\d{2})-(\\d{2})T' +
    // 15:04:05
    '(\\d{2}):(\\d{2}):(\\d{2})' +
    // .999999999Z
    '\\.(\\d+)Z'
  )
  const m = String(time).trim().match(rfc3339Matcher)

  if (!m) {
    throw new Error('Invalid format')
  }

  const year = parseInt(m[1], 10)
  const month = parseInt(m[2], 10) - 1
  const date = parseInt(m[3], 10)
  const hour = parseInt(m[4], 10)
  const minute = parseInt(m[5], 10)
  const second = parseInt(m[6], 10)
  const millisecond = parseInt(m[7].slice(0, -6), 10)

  return new Date(Date.UTC(year, month, date, hour, minute, second, millisecond))
}

      };
    };
  }
}, {package:"libp2p-record",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/selectors/index.js", {"./public-key":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/selectors/public-key.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/selectors/index.js
      return function (require, module, exports) {
'use strict'

module.exports = {
  pk: require('./public-key')
}

      };
    };
  }
}, {package:"libp2p-record",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/selectors/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer-split/index.js", {"buffer-indexof":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer-indexof/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer-split/index.js
      return function (require, module, exports) {
var bufferIndexOf = require('buffer-indexof');

module.exports = function(buf,splitBuf,includeDelim){
  
  var search = -1
  , lines = []
  , move = includeDelim?splitBuf.length:0
  ;

  while((search = bufferIndexOf(buf,splitBuf)) > -1){
    lines.push(buf.slice(0,search+move));
    buf = buf.slice(search+splitBuf.length,buf.length);
  }

  lines.push(buf);
        
  return lines;
}





      };
    };
  }
}, {package:"buffer-split",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer-split/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/validators/index.js", {"./public-key":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/validators/public-key.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/validators/index.js
      return function (require, module, exports) {
'use strict'

module.exports = {
  pk: require('./public-key')
}

      };
    };
  }
}, {package:"libp2p-record",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/validators/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/consts.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/consts.js
      return function (require, module, exports) {
'use strict'

/**
 * @typedef {number} MessageType
 */

/**
 * @enum {MessageType}
 */
exports.Types = {
  NEW: 0,
  IN_MESSAGE: 1,
  OUT_MESSAGE: 2,
  IN_CLOSE: 3,
  OUT_CLOSE: 4,
  IN_RESET: 5,
  OUT_RESET: 6
}

exports.MAX_MSG_SIZE = 1 << 20 // 1MB

      };
    };
  }
}, {package:"pull-mplex",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/consts.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/util/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/util/index.js
      return function (require, module, exports) {
'use strict'

/**
 * @private
 * @param {EventEmitter} that
 * @param {Channel} chan
 * @param {number} id
 */
function emitStream (that, chan, id) {
  that.emit('stream', chan, id)
}

/**
 * @private
 * @param {EventEmitter} that
 * @param {Error} error
 */
function emitError (that, error) {
  that.emit('error', error)
}

module.exports.emitError = emitError
module.exports.emitStream = emitStream

      };
    };
  }
}, {package:"pull-mplex",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/util/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/node_modules/looper/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/node_modules/looper/index.js
      return function (require, module, exports) {


module.exports = function (fn) {
  var active = false, called = 0
  return function () {
    called = true
    if(!active) {
      active = true
      while(called) {
        called = false
        fn()
      }
      active = false
    }
  }
}









      };
    };
  }
}, {package:"looper",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/node_modules/looper/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/coder.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","pull-through":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-through/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/coder.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const varint = require('varint')
const through = require('pull-through')
const debug = require('debug')

const log = debug('pull-plex:coder')
log.err = debug('pull-plex:coder:err')

const PULL_LENGTH = 10 * 1024
const empty = Buffer.alloc(0)

/**
 * Creates a Through PullStream that will varint encode all
 * messages passed through it.
 *
 * @returns {PullStream} A through stream that varint encodes all messages
 */
exports.encode = () => {
  let pool = Buffer.allocUnsafe(PULL_LENGTH)
  let used = 0

  return through(function (msg) {
    const oldUsed = used
    varint.encode(msg[0] << 3 | msg[1], pool, used)
    used += varint.encode.bytes
    varint.encode(msg[2] ? msg[2].length : 0, pool, used)
    used += varint.encode.bytes
    this.queue(pool.slice(oldUsed, used)) // send header

    if (PULL_LENGTH - used < 100) {
      pool = Buffer.allocUnsafe(PULL_LENGTH)
      used = 0
    }

    this.queue(msg[2] ? msg[2] : empty)
  })
}

/**
 * @typedef {number} States
 */

/**
 * @enum {States}
 */
const States = {
  PARSING: 0,
  READING: 1
}

/**
 * Creates a Through PullStream that will varint decodes all
 * messages passed through it.
 *
 * @returns {PullStream} A through stream that varint decodes all messages
 */
exports.decode = () => {
  let state = States.PARSING

  const tryDecode = (msg) => {
    let offset = 0
    let length = 0
    try {
      let h = varint.decode(msg)
      offset += varint.decode.bytes
      length = varint.decode(msg, offset)
      offset += varint.decode.bytes
      return [h, offset, length]
    } catch (err) {
      log.err(err) // ignore if data is empty
    }
    return []
  }

  const decode = (msg) => {
    const [h, offset, length] = tryDecode(msg)
    // If there is a header, process it
    if (h !== void 0) {
      const message = {
        id: h >> 3,
        type: h & 7,
        data: []
      }

      state = States.READING
      return [msg.slice(offset), message, length]
    }

    // There was no header, return the message
    return [msg]
  }

  const read = (msg, data, length) => {
    // If we're done reading, start parsing the message
    if (length <= 0) {
      state = States.PARSING
      return [0, msg, data]
    }

    // Read more data
    let left = length - msg.length
    if (left < 0) { left = 0 }
    const size = length - left
    if (msg.length > 0) {
      const buff = Buffer.isBuffer(msg) ? msg : Buffer.from(msg)
      data.push(buff.slice(0, size))
    }

    // If we finished reading, start parsing
    if (left <= 0) { state = States.PARSING }
    return [left, msg.slice(size), data]
  }

  let length = 0
  let message = null
  let accumulating = false
  let array = []
  return through(function (msg) {
    var ps = this
    function more () {
      if (msg && msg.length) {
        // Reading is done for this message, start processing it
        if (States.PARSING === state) {
          if (accumulating) {
            array.push(msg)
            msg = Buffer.concat(array)
          }

          [msg, message, length] = decode(msg)
          if (!message) {
            if (!accumulating) {
              array.push(msg)
            }
            accumulating = true
            return
          }

          array = []
          accumulating = false
        }

        // We're not done reading the message, keep reading it
        if (States.READING === state) {
          [length, msg, message.data] = read(msg, message.data, length)

          // If we read the whole message, add it to the queue
          if (length <= 0 && States.PARSING === state) {
            message.data = Buffer.concat(message.data)
            ps.queue(message)
            message = null
            length = 0
          }
        }

        more()
      }
    }
    more()
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"pull-mplex",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/coder.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/channel.js", {"./consts":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/consts.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/util/index.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","looper":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/node_modules/looper/index.js","pull-pushable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-pushable/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/channel.js
      return function (require, module, exports) {
'use strict'

const pushable = require('pull-pushable')
const looper = require('looper')
const nextTick = require('async/nextTick')
const EE = require('events')
const debug = require('debug')

const { Types } = require('./consts')
const { emitError } = require('./util')

const log = debug('pull-plex:chan')
log.err = debug('pull-plex:chan:err')

/**
 * Creates a pull-stream sink for the given Channel
 * @private
 * @param {Channel} channel
 * @returns {function} The sink function
 */
function channelSink (channel) {
  return function (read) {
    const next = looper(function () {
      read(null, function (end, data) {
        // stream already ended
        if (channel._endedLocal) { return }

        channel._endedLocal = end || false

        // source ended, close the stream
        if (end === true) {
          return channel.endChan()
        }

        // source errored, destroy stream
        if (end || channel._destroy) {
          channel.destroyChan()
          channel.emit('error', end || channel._destroy)
          channel.destroy()
          return
        }

        // just send
        channel.sendMsg(data)
        next()
      })
    })

    next()
  }
}

/**
 * @fires Channel#close
 * @fires Channel#error
 */
class Channel extends EE {
  /**
   * @constructor
   * @param {Object} opts
   * @param {number} opts.id
   * @param {boolean} opts.initiator
   * @param {string} opts.name
   * @param {boolean} opts.open
   * @param {Mplex} opts.plex
   */
  constructor (opts) {
    super()

    opts = { initiator: false, ...opts }

    this._id = opts.id
    this._name = opts.name
    this._plex = opts.plex
    this._open = opts.open
    this._initiator = opts.initiator
    this._endedRemote = false // remote stream ended
    this._endedLocal = false // local stream ended
    this._destroy = false

    this.MSG = this._initiator
      ? Types.OUT_MESSAGE
      : Types.IN_MESSAGE

    this.END = this._initiator
      ? Types.OUT_CLOSE
      : Types.IN_CLOSE

    this.RESET = this._initiator
      ? Types.OUT_RESET
      : Types.IN_RESET

    this._log('new channel', this._name)

    this._msgs = pushable((err) => {
      this._log('source closed', err)
      if (err && typeof err !== 'boolean') {
        nextTick(emitError, this, err)
      }
      // this.endChan() // Do not uncomment this, it will end the channel too early
    })

    this._source = this._msgs
    this.sink = channelSink(this)
  }

  get source () {
    return this._source
  }

  get id () {
    return this._id
  }

  get open () {
    return this._open
  }

  set open (open) {
    this._open = open
  }

  get name () {
    return this._name
  }

  get destroyed () {
    return this._endedRemote && this._endedLocal
  }

  /**
   * A convenience wrapper for the log that adds useful metadata to logs
   * @private
   * @param {string} name The name of the operation being logged
   * @param {Buffer|string} data Logged with the metadata. Must be `.toString` capable. Default: `''`
   */
  _log (name, data) {
    if (!log.enabled) return
    log({
      op: name,
      name: this._name,
      id: this._id,
      endedLocal: this._endedLocal,
      endedRemote: this._endedRemote,
      initiator: this._initiator,
      data: (data && data.toString()) || ''
    })
  }

  /**
   * Pushes `data` into the channel
   * @param {Buffer} data
   */
  push (data) {
    this._log('push')
    this._msgs.push(data)
  }

  /**
   * Closes the channel for writing
   * @param {Error} err
   */
  close (err) {
    this._log('close', err)
    if (!this._endedRemote) {
      this._endedRemote = err || true
      this._msgs.end(this._endedRemote)
      this.emit('close', err)
      this.plex = null
    }
  }

  /**
   * Closes the channel with the given error
   * @param {Error} err Default: `'channel destroyed!'`
   */
  destroy (err) {
    this._log('destroy', err)
    this._destroy = err || 'channel destroyed!'
    this.close(this._destroy)
  }

  /**
   * Opens the channel if it's not already open. Attempting
   * to open an already opened channel is ignored.
   * @param {string} name
   */
  openChan (name) {
    if (this.open) { return } // chan already open

    this.open = true
    this._plex.push([
      this._id,
      Types.NEW,
      name !== this._id.toString() ? name : this._id.toString()
    ])
  }

  /**
   * Pushes `data` wrapped in a `Message` into the channel.
   * If the channel is not open, it will be opened automatically.
   *
   * @param {Buffer} data
   */
  sendMsg (data) {
    this._log('sendMsg', data)

    if (!this.open) {
      this.openChan(this.name)
    }

    this._plex.push([
      this._id,
      this.MSG,
      data
    ])
  }

  /**
   * Ends the channel by sending an END `Message`.
   * If the channel is not open, no action will be taken.
   */
  endChan () {
    this._log('endChan')

    if (!this.open) {
      return
    }

    this._plex.push([
      this._id,
      this.END
    ])
  }

  /**
   * Destroys the channel by sending a RESET `Message`.
   * If the channel is not open, no action will be taken.
   */
  destroyChan () {
    this._log('destroyChan')

    if (!this.open) {
      return
    }

    this._plex.push([
      this._id,
      this.RESET
    ])
  }
}

module.exports = Channel

      };
    };
  }
}, {package:"pull-mplex",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/channel.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-through/index.js", {"looper":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/looper/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-through/index.js
      return function (require, module, exports) {
var looper = require('looper')

module.exports = function (writer, ender) {
  return function (read) {
    var queue = [], ended, error

    function enqueue (data) {
      queue.push(data)
    }

    writer = writer || function (data) {
      this.queue(data)
    }

    ender = ender || function () {
      this.queue(null)
    }

    var emitter = {
      emit: function (event, data) {
        if(event == 'data') enqueue(data)
        if(event == 'end')  ended = true, enqueue(null)
        if(event == 'error') error = data
      },
      queue: enqueue
    }
    var _cb
    return function (end, cb) {
      ended = ended || end
      if(end)
        return read(end, function () {
          if(_cb) {
            var t = _cb; _cb = null; t(end)
          }
          cb(end)
        })

      _cb = cb
      looper(function pull (next) {
        //if it's an error
        if(!_cb) return
        cb = _cb
        if(error) _cb = null, cb(error)
        else if(queue.length) {
          var data = queue.shift()
          _cb = null,cb(data === null, data)
        }
        else {
          read(ended, function (end, data) {
             //null has no special meaning for pull-stream
            if(end && end !== true) {
              error = end; return next()
            }
            if(ended = ended || end)  ender.call(emitter)
            else if(data !== null) {
              writer.call(emitter, data)
              if(error || ended)
                return read(error || ended, function () {
                  _cb = null; cb(error || ended)
                })
            }
            next(pull)
          })
        }
      })
    }
  }
}


      };
    };
  }
}, {package:"pull-through",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-through/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/server.js", {"./":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","http":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-http/index.js","https":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/https-browserify/index.js","url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/url/url.js","ws":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/server.js
      return function (require, module, exports) {
var ws = require('./')
var WebSocket = require('ws')
var url = require('url')
var http = require('http')
var https = require('https')

var EventEmitter = require('events').EventEmitter
module.exports = !WebSocket.Server ? null : function (opts, onConnection) {
    var emitter = new EventEmitter()
    var server
    if (typeof opts === 'function'){
      onConnection = opts
      opts = null
    }
    opts = opts || {}

    if(onConnection)
      emitter.on('connection', onConnection)

    function proxy (server, event) {
      return server.on(event, function () {
        var args = [].slice.call(arguments)
        args.unshift(event)
        emitter.emit.apply(emitter, args)
      })
    }

    var server = opts.server ||
      (opts.key && opts.cert ? https.createServer(opts) : http.createServer())

    var wsServer = new WebSocket.Server({
      server: server,
      perMessageDeflate: false,
      verifyClient: opts.verifyClient
    })

    proxy(server, 'listening')
    proxy(server, 'request')
    proxy(server, 'close')

    wsServer.on('connection', function (socket) {
      var stream = ws(socket)
      stream.remoteAddress = socket.upgradeReq.socket.remoteAddress
      emitter.emit('connection', stream)
    })

    emitter.listen = function (addr, onListening) {
      if(onListening)
        emitter.once('listening', onListening)
      server.listen(addr.port || addr)
      return emitter
    }

    emitter.close = function (onClose) {
      server.close(onClose)
      wsServer.close()
      return emitter
    }

    emitter.address = server.address.bind(server)
    return emitter
  }






      };
    };
  }
}, {package:"pull-ws",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/server.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/connection.js", {"pull-defer/duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/duplex.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/connection.js
      return function (require, module, exports) {
'use strict'

const defer = require('pull-defer/duplex')

module.exports = class Connection {
  constructor (conn, info) {
    this.peerInfo = null
    this.conn = defer()

    if (conn) {
      this.setInnerConn(conn, info)
    } else if (info) {
      this.info = info
    }
  }

  get source () {
    return this.conn.source
  }

  get sink () {
    return this.conn.sink
  }

  getPeerInfo (callback) {
    if (this.info && this.info.getPeerInfo) {
      return this.info.getPeerInfo(callback)
    }

    if (!this.peerInfo) {
      return callback(new Error('Peer Info not set yet'))
    }

    callback(null, this.peerInfo)
  }

  setPeerInfo (peerInfo) {
    if (this.info && this.info.setPeerInfo) {
      return this.info.setPeerInfo(peerInfo)
    }

    this.peerInfo = peerInfo
  }

  getObservedAddrs (callback) {
    if (this.info && this.info.getObservedAddrs) {
      return this.info.getObservedAddrs(callback)
    }
    callback(null, [])
  }

  setInnerConn (conn, info) {
    this.conn.resolve(conn)
    if (info) {
      this.info = info
    } else {
      this.info = conn
    }
  }
}

      };
    };
  }
}, {package:"interface-connection",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/connection.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/web-socket.js", {"ws":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/web-socket.js
      return function (require, module, exports) {

module.exports = 'undefined' === typeof WebSocket ? require('ws') : WebSocket

      };
    };
  }
}, {package:"pull-ws",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/web-socket.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/ws-url.js", {"relative-url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/relative-url/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/ws-url.js
      return function (require, module, exports) {
var rurl = require('relative-url')
var map = {http:'ws', https:'wss'}
var def = 'ws'
module.exports = function (url, location) {
  return rurl(url, location, map, def)
}



      };
    };
  }
}, {package:"pull-ws",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/ws-url.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/duplex.js", {"./sink":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/sink.js","./source":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/source.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/duplex.js
      return function (require, module, exports) {
var source = require('./source')
var sink = require('./sink')

module.exports = duplex

function duplex (ws, opts) {
  var req = ws.upgradeReq || {}
  if(opts && opts.binaryType)
    ws.binaryType = opts.binaryType
  else if(opts && opts.binary)
    ws.binaryType = 'arraybuffer'
  return {
    source: source(ws, opts && opts.onConnect),
    sink: sink(ws, opts),

    //http properties - useful for routing or auth.
    headers: req.headers,
    url: req.url,
    upgrade: req.upgrade,
    method: req.method
  };
};


      };
    };
  }
}, {package:"pull-ws",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/duplex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/limited-peer-list.js", {"./peer-list":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/peer-list.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/limited-peer-list.js
      return function (require, module, exports) {
'use strict'

const PeerList = require('./peer-list')

/**
 * Like PeerList but with a length restriction.
 */
class LimitedPeerList extends PeerList {
  /**
   * Create a new limited peer list.
   *
   * @param {number} limit
   */
  constructor (limit) {
    super()
    this.limit = limit
  }

  /**
   * Add a PeerInfo if it fits in the list
   *
   * @param {PeerInfo} info
   * @returns {bool}
   */
  push (info) {
    if (this.length < this.limit) {
      return super.push(info)
    }
    return false
  }
}

module.exports = LimitedPeerList

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/limited-peer-list.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/message/dht.proto.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/message/dht.proto.js
      return function (require, module, exports) {
'use strict'

module.exports = `// can't use, because protocol-buffers doesn't support imports
// so we have to duplicate for now :(
// import "record.proto";

message Record {
  // adjusted for javascript
  optional bytes key = 1;
  optional bytes value = 2;
  optional bytes author = 3;
  optional bytes signature = 4;
  optional string timeReceived = 5;
}

message Message {
  enum MessageType {
    PUT_VALUE = 0;
    GET_VALUE = 1;
    ADD_PROVIDER = 2;
    GET_PROVIDERS = 3;
    FIND_NODE = 4;
    PING = 5;
  }

  enum ConnectionType {
    // sender does not have a connection to peer, and no extra information (default)
    NOT_CONNECTED = 0;

    // sender has a live connection to peer
    CONNECTED = 1;

    // sender recently connected to peer
    CAN_CONNECT = 2;

    // sender recently tried to connect to peer repeatedly but failed to connect
    // ("try" here is loose, but this should signal "made strong effort, failed")
    CANNOT_CONNECT = 3;
  }

  message Peer {
    // ID of a given peer.
    optional bytes id = 1;

    // multiaddrs for a given peer
    repeated bytes addrs = 2;

    // used to signal the sender's connection capabilities to the peer
    optional ConnectionType connection = 3;
  }

  // defines what type of message it is.
  optional MessageType type = 1;

  // defines what coral cluster level this query/response belongs to.
  // in case we want to implement coral's cluster rings in the future.
  optional int32 clusterLevelRaw = 10;

  // Used to specify the key associated with this message.
  // PUT_VALUE, GET_VALUE, ADD_PROVIDER, GET_PROVIDERS
  // adjusted for javascript
  optional bytes key = 2;

  // Used to return a value
  // PUT_VALUE, GET_VALUE
  // adjusted Record to bytes for js
  optional bytes record = 3;

  // Used to return peers closer to a key in a query
  // GET_VALUE, GET_PROVIDERS, FIND_NODE
  repeated Peer closerPeers = 8;

  // Used to return Providers
  // GET_VALUE, ADD_PROVIDER, GET_PROVIDERS
  repeated Peer providerPeers = 9;
}`

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/message/dht.proto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/hashlru/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/hashlru/index.js
      return function (require, module, exports) {
module.exports = function (max) {

  if (!max) throw Error('hashlru must have a max value, of type number, greater than 0')

  var size = 0, cache = Object.create(null), _cache = Object.create(null)

  function update (key, value) {
    cache[key] = value
    size ++
    if(size >= max) {
      size = 0
      _cache = cache
      cache = Object.create(null)
    }
  }

  return {
    has: function (key) {
      return cache[key] !== undefined || _cache[key] !== undefined
    },
    remove: function (key) {
      if(cache[key] !== undefined)
        cache[key] = undefined
      if(_cache[key] !== undefined)
        _cache[key] = undefined
    },
    get: function (key) {
      var v = cache[key]
      if(v !== undefined) return v
      if((v = _cache[key]) !== undefined) {
        update(key, v)
        return v
      }
    },
    set: function (key, value) {
      if(cache[key] !== undefined) cache[key] = value
      else update(key, value)
    },
    clear: function () {
      cache = Object.create(null)
      _cache = Object.create(null)
    }
  }
}








      };
    };
  }
}, {package:"hashlru",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/hashlru/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-queue/index.js", {"eventemitter3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-queue/node_modules/eventemitter3/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/p-queue/index.js
      return function (require, module, exports) {
'use strict';
const EventEmitter = require('eventemitter3');

// Port of lower_bound from http://en.cppreference.com/w/cpp/algorithm/lower_bound
// Used to compute insertion index to keep queue sorted after insertion
function lowerBound(array, value, comp) {
	let first = 0;
	let count = array.length;

	while (count > 0) {
		const step = (count / 2) | 0;
		let it = first + step;

		if (comp(array[it], value) <= 0) {
			first = ++it;
			count -= step + 1;
		} else {
			count = step;
		}
	}

	return first;
}

class PriorityQueue {
	constructor() {
		this._queue = [];
	}

	enqueue(run, options) {
		options = {
			priority: 0,
			...options
		};

		const element = {
			priority: options.priority,
			run
		};

		if (this.size && this._queue[this.size - 1].priority >= options.priority) {
			this._queue.push(element);
			return;
		}

		const index = lowerBound(this._queue, element, (a, b) => b.priority - a.priority);
		this._queue.splice(index, 0, element);
	}

	dequeue() {
		return this._queue.shift().run;
	}

	get size() {
		return this._queue.length;
	}
}

module.exports = class PQueue extends EventEmitter {
	constructor(options) {
		super();

		options = {
			carryoverConcurrencyCount: false,
			intervalCap: Infinity,
			interval: 0,
			concurrency: Infinity,
			autoStart: true,
			queueClass: PriorityQueue,
			...options
		};

		if (!(typeof options.concurrency === 'number' && options.concurrency >= 1)) {
			throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${options.concurrency}\` (${typeof options.concurrency})`);
		}

		if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {
			throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options.intervalCap}\` (${typeof options.intervalCap})`);
		}

		if (!(Number.isFinite(options.interval) && options.interval >= 0)) {
			throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options.interval}\` (${typeof options.interval})`);
		}

		this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
		this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
		this._intervalCount = 0;
		this._intervalCap = options.intervalCap;
		this._interval = options.interval;
		this._intervalId = null;
		this._intervalEnd = 0;
		this._timeoutId = null;

		this.queue = new options.queueClass(); // eslint-disable-line new-cap
		this._queueClass = options.queueClass;
		this._pendingCount = 0;
		this._concurrency = options.concurrency;
		this._isPaused = options.autoStart === false;
		this._resolveEmpty = () => {};
		this._resolveIdle = () => {};
	}

	get _doesIntervalAllowAnother() {
		return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
	}

	get _doesConcurrentAllowAnother() {
		return this._pendingCount < this._concurrency;
	}

	_next() {
		this._pendingCount--;
		this._tryToStartAnother();
	}

	_resolvePromises() {
		this._resolveEmpty();
		this._resolveEmpty = () => {};

		if (this._pendingCount === 0) {
			this._resolveIdle();
			this._resolveIdle = () => {};
		}
	}

	_onResumeInterval() {
		this._onInterval();
		this._initializeIntervalIfNeeded();
		this._timeoutId = null;
	}

	_intervalPaused() {
		const now = Date.now();

		if (this._intervalId === null) {
			const delay = this._intervalEnd - now;
			if (delay < 0) {
				// Act as the interval was done
				// We don't need to resume it here,
				// because it'll be resumed on line 160
				this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;
			} else {
				// Act as the interval is pending
				if (this._timeoutId === null) {
					this._timeoutId = setTimeout(() => {
						this._onResumeInterval();
					}, delay);
				}

				return true;
			}
		}

		return false;
	}

	_tryToStartAnother() {
		if (this.queue.size === 0) {
			// We can clear the interval ("pause")
			// because we can redo it later ("resume")
			clearInterval(this._intervalId);
			this._intervalId = null;

			this._resolvePromises();

			return false;
		}

		if (!this._isPaused) {
			const canInitializeInterval = !this._intervalPaused();
			if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
				this.emit('active');
				this.queue.dequeue()();
				if (canInitializeInterval) {
					this._initializeIntervalIfNeeded();
				}

				return true;
			}
		}

		return false;
	}

	_initializeIntervalIfNeeded() {
		if (this._isIntervalIgnored || this._intervalId !== null) {
			return;
		}

		this._intervalId = setInterval(() => this._onInterval(), this._interval);
		this._intervalEnd = Date.now() + this._interval;
	}

	_onInterval() {
		if (this._intervalCount === 0 && this._pendingCount === 0) {
			clearInterval(this._intervalId);
			this._intervalId = null;
		}

		this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;
		while (this._tryToStartAnother()) {} // eslint-disable-line no-empty
	}

	async add(fn, options) {
		return new Promise((resolve, reject) => {
			const run = async () => {
				this._pendingCount++;
				this._intervalCount++;

				try {
					resolve(await fn());
				} catch (error) {
					reject(error);
				}

				this._next();
			};

			this.queue.enqueue(run, options);
			this._tryToStartAnother();
		});
	}

	async addAll(fns, options) {
		return Promise.all(fns.map(fn => this.add(fn, options)));
	}

	start() {
		if (!this._isPaused) {
			return;
		}

		this._isPaused = false;
		while (this._tryToStartAnother()) {} // eslint-disable-line no-empty
	}

	pause() {
		this._isPaused = true;
	}

	clear() {
		this.queue = new this._queueClass();
	}

	async onEmpty() {
		// Instantly resolve if the queue is empty
		if (this.queue.size === 0) {
			return;
		}

		return new Promise(resolve => {
			const existingResolve = this._resolveEmpty;
			this._resolveEmpty = () => {
				existingResolve();
				resolve();
			};
		});
	}

	async onIdle() {
		// Instantly resolve if none pending and if nothing else is queued
		if (this._pendingCount === 0 && this.queue.size === 0) {
			return;
		}

		return new Promise(resolve => {
			const existingResolve = this._resolveIdle;
			this._resolveIdle = () => {
				existingResolve();
				resolve();
			};
		});
	}

	get size() {
		return this.queue.size;
	}

	get pending() {
		return this._pendingCount;
	}

	get isPaused() {
		return this._isPaused;
	}
};

      };
    };
  }
}, {package:"p-queue",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-queue/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/k-bucket/index.js", {"events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","randombytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/randombytes/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/k-bucket/index.js
      return function (require, module, exports) {
/*
index.js - Kademlia DHT K-bucket implementation as a binary tree.

The MIT License (MIT)

Copyright (c) 2013-2018 Tristan Slominski

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/
'use strict'

const randomBytes = require('randombytes')
const { EventEmitter } = require('events')

/**
 * @param  {Uint8Array} array1
 * @param  {Uint8Array} array2
 * @return {Boolean}
 */
function arrayEquals (array1, array2) {
  if (array1 === array2) {
    return true
  }
  if (array1.length !== array2.length) {
    return false
  }
  for (let i = 0, length = array1.length; i < length; ++i) {
    if (array1[i] !== array2[i]) {
      return false
    }
  }
  return true
}

function createNode () {
  return { contacts: [], dontSplit: false, left: null, right: null }
}

function ensureInt8 (name, val) {
  if (!(val instanceof Uint8Array)) {
    throw new TypeError(name + ' is not a Uint8Array')
  }
}

/**
 * Implementation of a Kademlia DHT k-bucket used for storing
 * contact (peer node) information.
 *
 * @extends EventEmitter
 */
class KBucket extends EventEmitter {
  /**
   * `options`:
   *   `distance`: _Function_
   *     `function (firstId, secondId) { return distance }` An optional
   *     `distance` function that gets two `id` Uint8Arrays
   *     and return distance (as number) between them.
   *   `arbiter`: _Function_ _(Default: vectorClock arbiter)_
   *     `function (incumbent, candidate) { return contact; }` An optional
   *     `arbiter` function that givent two `contact` objects with the same `id`
   *     returns the desired object to be used for updating the k-bucket. For
   *     more details, see [arbiter function](#arbiter-function).
   *   `localNodeId`: _Uint8Array_ An optional Uint8Array representing the local node id.
   *     If not provided, a local node id will be created via `randomBytes(20)`.
   *     `metadata`: _Object_ _(Default: {})_ Optional satellite data to include
   *     with the k-bucket. `metadata` property is guaranteed not be altered by,
   *     it is provided as an explicit container for users of k-bucket to store
   *     implementation-specific data.
   *   `numberOfNodesPerKBucket`: _Integer_ _(Default: 20)_ The number of nodes
   *     that a k-bucket can contain before being full or split.
   *     `numberOfNodesToPing`: _Integer_ _(Default: 3)_ The number of nodes to
   *     ping when a bucket that should not be split becomes full. KBucket will
   *     emit a `ping` event that contains `numberOfNodesToPing` nodes that have
   *     not been contacted the longest.
   *
   * @param {Object=} options optional
   */
  constructor (options = {}) {
    super()

    this.localNodeId = options.localNodeId || randomBytes(20)
    this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20
    this.numberOfNodesToPing = options.numberOfNodesToPing || 3
    this.distance = options.distance || KBucket.distance
    // use an arbiter from options or vectorClock arbiter by default
    this.arbiter = options.arbiter || KBucket.arbiter
    this.metadata = Object.assign({}, options.metadata)

    ensureInt8('option.localNodeId as parameter 1', this.localNodeId)

    this.root = createNode()
  }

  /**
   * Default arbiter function for contacts with the same id. Uses
   * contact.vectorClock to select which contact to update the k-bucket with.
   * Contact with larger vectorClock field will be selected. If vectorClock is
   * the same, candidat will be selected.
   *
   * @param  {Object} incumbent Contact currently stored in the k-bucket.
   * @param  {Object} candidate Contact being added to the k-bucket.
   * @return {Object}           Contact to updated the k-bucket with.
   */
  static arbiter (incumbent, candidate) {
    return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate
  }

  /**
   * Default distance function. Finds the XOR
   * distance between firstId and secondId.
   *
   * @param  {Uint8Array} firstId  Uint8Array containing first id.
   * @param  {Uint8Array} secondId Uint8Array containing second id.
   * @return {Number}              Integer The XOR distance between firstId
   *                               and secondId.
   */
  static distance (firstId, secondId) {
    let distance = 0
    let i = 0
    const min = Math.min(firstId.length, secondId.length)
    const max = Math.max(firstId.length, secondId.length)
    for (; i < min; ++i) {
      distance = distance * 256 + (firstId[i] ^ secondId[i])
    }
    for (; i < max; ++i) distance = distance * 256 + 255
    return distance
  }

  /**
   * Adds a contact to the k-bucket.
   *
   * @param {Object} contact the contact object to add
   */
  add (contact) {
    ensureInt8('contact.id', (contact || {}).id)

    let bitIndex = 0
    let node = this.root

    while (node.contacts === null) {
      // this is not a leaf node but an inner node with 'low' and 'high'
      // branches; we will check the appropriate bit of the identifier and
      // delegate to the appropriate node for further processing
      node = this._determineNode(node, contact.id, bitIndex++)
    }

    // check if the contact already exists
    const index = this._indexOf(node, contact.id)
    if (index >= 0) {
      this._update(node, index, contact)
      return this
    }

    if (node.contacts.length < this.numberOfNodesPerKBucket) {
      node.contacts.push(contact)
      this.emit('added', contact)
      return this
    }

    // the bucket is full
    if (node.dontSplit) {
      // we are not allowed to split the bucket
      // we need to ping the first this.numberOfNodesToPing
      // in order to determine if they are alive
      // only if one of the pinged nodes does not respond, can the new contact
      // be added (this prevents DoS flodding with new invalid contacts)
      this.emit('ping', node.contacts.slice(0, this.numberOfNodesToPing), contact)
      return this
    }

    this._split(node, bitIndex)
    return this.add(contact)
  }

  /**
   * Get the n closest contacts to the provided node id. "Closest" here means:
   * closest according to the XOR metric of the contact node id.
   *
   * @param  {Uint8Array} id  Contact node id
   * @param  {Number=} n      Integer (Default: Infinity) The maximum number of
   *                          closest contacts to return
   * @return {Array}          Array Maximum of n closest contacts to the node id
   */
  closest (id, n = Infinity) {
    ensureInt8('id', id)

    if ((!Number.isInteger(n) && n !== Infinity) || n <= 0) {
      throw new TypeError('n is not positive number')
    }

    let contacts = []

    for (let nodes = [ this.root ], bitIndex = 0; nodes.length > 0 && contacts.length < n;) {
      const node = nodes.pop()
      if (node.contacts === null) {
        const detNode = this._determineNode(node, id, bitIndex++)
        nodes.push(node.left === detNode ? node.right : node.left)
        nodes.push(detNode)
      } else {
        contacts = contacts.concat(node.contacts)
      }
    }

    return contacts
      .map(a => [this.distance(a.id, id), a])
      .sort((a, b) => a[0] - b[0])
      .slice(0, n)
      .map(a => a[1])
  }

  /**
   * Counts the total number of contacts in the tree.
   *
   * @return {Number} The number of contacts held in the tree
   */
  count () {
    // return this.toArray().length
    let count = 0
    for (const nodes = [ this.root ]; nodes.length > 0;) {
      const node = nodes.pop()
      if (node.contacts === null) nodes.push(node.right, node.left)
      else count += node.contacts.length
    }
    return count
  }

  /**
   * Determines whether the id at the bitIndex is 0 or 1.
   * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
   *
   * @param  {Object} node     internal object that has 2 leafs: left and right
   * @param  {Uint8Array} id   Id to compare localNodeId with.
   * @param  {Number} bitIndex Integer (Default: 0) The bit index to which bit
   *                           to check in the id Uint8Array.
   * @return {Object}          left leaf if id at bitIndex is 0, right leaf otherwise.
   */
  _determineNode (node, id, bitIndex) {
    // **NOTE** remember that id is a Uint8Array and has granularity of
    // bytes (8 bits), whereas the bitIndex is the _bit_ index (not byte)

    // id's that are too short are put in low bucket (1 byte = 8 bits)
    // (bitIndex >> 3) finds how many bytes the bitIndex describes
    // bitIndex % 8 checks if we have extra bits beyond byte multiples
    // if number of bytes is <= no. of bytes described by bitIndex and there
    // are extra bits to consider, this means id has less bits than what
    // bitIndex describes, id therefore is too short, and will be put in low
    // bucket
    const bytesDescribedByBitIndex = bitIndex >> 3
    const bitIndexWithinByte = bitIndex % 8
    if ((id.length <= bytesDescribedByBitIndex) && (bitIndexWithinByte !== 0)) {
      return node.left
    }

    const byteUnderConsideration = id[bytesDescribedByBitIndex]

    // byteUnderConsideration is an integer from 0 to 255 represented by 8 bits
    // where 255 is 11111111 and 0 is 00000000
    // in order to find out whether the bit at bitIndexWithinByte is set
    // we construct (1 << (7 - bitIndexWithinByte)) which will consist
    // of all bits being 0, with only one bit set to 1
    // for example, if bitIndexWithinByte is 3, we will construct 00010000 by
    // (1 << (7 - 3)) -> (1 << 4) -> 16
    if (byteUnderConsideration & (1 << (7 - bitIndexWithinByte))) {
      return node.right
    }

    return node.left
  }

  /**
   * Get a contact by its exact ID.
   * If this is a leaf, loop through the bucket contents and return the correct
   * contact if we have it or null if not. If this is an inner node, determine
   * which branch of the tree to traverse and repeat.
   *
   * @param  {Uint8Array} id The ID of the contact to fetch.
   * @return {Object|Null}   The contact if available, otherwise null
   */
  get (id) {
    ensureInt8('id', id)

    let bitIndex = 0

    let node = this.root
    while (node.contacts === null) {
      node = this._determineNode(node, id, bitIndex++)
    }

    // index of uses contact id for matching
    const index = this._indexOf(node, id)
    return index >= 0 ? node.contacts[index] : null
  }

  /**
   * Returns the index of the contact with provided
   * id if it exists, returns -1 otherwise.
   *
   * @param  {Object} node    internal object that has 2 leafs: left and right
   * @param  {Uint8Array} id  Contact node id.
   * @return {Number}         Integer Index of contact with provided id if it
   *                          exists, -1 otherwise.
   */
  _indexOf (node, id) {
    for (let i = 0; i < node.contacts.length; ++i) {
      if (arrayEquals(node.contacts[i].id, id)) return i
    }

    return -1
  }

  /**
   * Removes contact with the provided id.
   *
   * @param  {Uint8Array} id The ID of the contact to remove.
   * @return {Object}        The k-bucket itself.
   */
  remove (id) {
    ensureInt8('the id as parameter 1', id)

    let bitIndex = 0
    let node = this.root

    while (node.contacts === null) {
      node = this._determineNode(node, id, bitIndex++)
    }

    const index = this._indexOf(node, id)
    if (index >= 0) {
      const contact = node.contacts.splice(index, 1)[0]
      this.emit('removed', contact)
    }

    return this
  }

  /**
   * Splits the node, redistributes contacts to the new nodes, and marks the
   * node that was split as an inner node of the binary tree of nodes by
   * setting this.root.contacts = null
   *
   * @param  {Object} node     node for splitting
   * @param  {Number} bitIndex the bitIndex to which byte to check in the
   *                           Uint8Array for navigating the binary tree
   */
  _split (node, bitIndex) {
    node.left = createNode()
    node.right = createNode()

    // redistribute existing contacts amongst the two newly created nodes
    for (const contact of node.contacts) {
      this._determineNode(node, contact.id, bitIndex).contacts.push(contact)
    }

    node.contacts = null // mark as inner tree node

    // don't split the "far away" node
    // we check where the local node would end up and mark the other one as
    // "dontSplit" (i.e. "far away")
    const detNode = this._determineNode(node, this.localNodeId, bitIndex)
    const otherNode = node.left === detNode ? node.right : node.left
    otherNode.dontSplit = true
  }

  /**
   * Returns all the contacts contained in the tree as an array.
   * If this is a leaf, return a copy of the bucket. `slice` is used so that we
   * don't accidentally leak an internal reference out that might be
   * accidentally misused. If this is not a leaf, return the union of the low
   * and high branches (themselves also as arrays).
   *
   * @return {Array} All of the contacts in the tree, as an array
   */
  toArray () {
    let result = []
    for (const nodes = [ this.root ]; nodes.length > 0;) {
      const node = nodes.pop()
      if (node.contacts === null) nodes.push(node.right, node.left)
      else result = result.concat(node.contacts)
    }
    return result
  }

  /**
   * Updates the contact selected by the arbiter.
   * If the selection is our old contact and the candidate is some new contact
   * then the new contact is abandoned (not added).
   * If the selection is our old contact and the candidate is our old contact
   * then we are refreshing the contact and it is marked as most recently
   * contacted (by being moved to the right/end of the bucket array).
   * If the selection is our new contact, the old contact is removed and the new
   * contact is marked as most recently contacted.
   *
   * @param  {Object} node    internal object that has 2 leafs: left and right
   * @param  {Number} index   the index in the bucket where contact exists
   *                          (index has already been computed in a previous
   *                          calculation)
   * @param  {Object} contact The contact object to update.
   */
  _update (node, index, contact) {
    // sanity check
    if (!arrayEquals(node.contacts[index].id, contact.id)) {
      throw new Error('wrong index for _update')
    }

    const incumbent = node.contacts[index]
    const selection = this.arbiter(incumbent, contact)
    // if the selection is our old contact and the candidate is some new
    // contact, then there is nothing to do
    if (selection === incumbent && incumbent !== contact) return

    node.contacts.splice(index, 1) // remove old contact
    node.contacts.push(selection) // add more recent contact version
    this.emit('updated', incumbent, selection)
  }
}

module.exports = KBucket

      };
    };
  }
}, {package:"k-bucket",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/k-bucket/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/index.js", {"./crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/crypto.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const multihash = require('multihashes')
const crypto = require('./crypto')

module.exports = Multihashing

/**
 * Hash the given `buf` using the algorithm specified
 * by `func`.
 *
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
function Multihashing (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  Multihashing.digest(buf, func, length, (err, digest) => {
    if (err) {
      return callback(err)
    }

    callback(null, multihash.encode(digest, func, length))
  })
}

/**
 * The `buffer` module for easy use in the browser.
 *
 * @type {Buffer}
 */
Multihashing.Buffer = Buffer // for browser things

/**
 * Expose multihash itself, to avoid silly double requires.
 */
Multihashing.multihash = multihash

/**
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
Multihashing.digest = function (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  let cb = callback
  if (length) {
    cb = (err, digest) => {
      if (err) {
        return callback(err)
      }

      callback(null, digest.slice(0, length))
    }
  }

  let hash
  try {
    hash = Multihashing.createHash(func)
  } catch (err) {
    return cb(err)
  }

  hash(buf, cb)
}

/**
 * @param {string|number} func
 *
 * @returns {function} - The to `func` corresponding hash function.
 */
Multihashing.createHash = function (func) {
  func = multihash.coerceCode(func)
  if (!Multihashing.functions[func]) {
    throw new Error('multihash function ' + func + ' not yet supported')
  }

  return Multihashing.functions[func]
}

/**
 * Mapping of multihash codes to their hashing functions.
 * @type {Object}
 */
Multihashing.functions = {
  // sha1
  0x11: crypto.sha1,
  // sha2-256
  0x12: crypto.sha2256,
  // sha2-512
  0x13: crypto.sha2512,
  // sha3-512
  0x14: crypto.sha3512,
  // sha3-384
  0x15: crypto.sha3384,
  // sha3-256
  0x16: crypto.sha3256,
  // sha3-224
  0x17: crypto.sha3224,
  // shake-128
  0x18: crypto.shake128,
  // shake-256
  0x19: crypto.shake256,
  // keccak-224
  0x1A: crypto.keccak224,
  // keccak-256
  0x1B: crypto.keccak256,
  // keccak-384
  0x1C: crypto.keccak384,
  // keccak-512
  0x1D: crypto.keccak512,
  // murmur3-128
  0x22: crypto.murmur3128,
  // murmur3-32
  0x23: crypto.murmur332,
  // dbl-sha2-256
  0x56: crypto.dblSha2256
}

// add blake functions
crypto.addBlake(Multihashing.functions)

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-times/index.js", {"p-map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-map/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/p-times/index.js
      return function (require, module, exports) {
'use strict';
const pMap = require('p-map');

const pTimes = async (count, mapper, options) =>
	pMap(new Array(count).fill(), (element, index) => mapper(index), options);

module.exports = pTimes;
// TODO: Remove this for the next major release
module.exports.default = pTimes;

      };
    };
  }
}, {package:"p-times",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-times/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/xor-distance/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/xor-distance/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
module.exports = dist

function dist (a, b) {
  if (a.length !== b.length) throw new Error('Inputs should have the same length')
  var result = Buffer.allocUnsafe(a.length)
  for (var i = 0; i < a.length; i++) result[i] = a[i] ^ b[i]
  return result
}

dist.compare = function compare (a, b) {
  if (a.length !== b.length) throw new Error('Inputs should have the same length')
  for (var i = 0; i < a.length; i++) {
    if (a[i] === b[i]) continue
    return a[i] < b[i] ? -1 : 1
  }
  return 0
}

dist.gt = function gt (a, b) {
  return dist.compare(a, b) === 1
}

dist.lt = function lt (a, b) {
  return dist.compare(a, b) === -1
}

dist.eq = function eq (a, b) {
  return dist.compare(a, b) === 0
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"xor-distance",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xor-distance/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/run.js", {"../peer-distance-list":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/peer-distance-list.js","../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js","./path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/path.js","./workerQueue":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/workerQueue.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/run.js
      return function (require, module, exports) {
'use strict'

const PeerDistanceList = require('../peer-distance-list')
const EventEmitter = require('events')
const promisify = require('promisify-es6')

const Path = require('./path')
const WorkerQueue = require('./workerQueue')
const utils = require('../utils')

/**
 * Manages a single run of the query.
 */
class Run extends EventEmitter {
  /**
   * Creates a Run.
   *
   * @param {Query} query
   */
  constructor (query) {
    super()

    this.query = query

    this.running = false
    this.workers = []

    // The peers that have been queried (including error responses)
    this.peersSeen = new Set()
    // The errors received when querying peers
    this.errors = []
    // The closest K peers that have been queried successfully
    // (this member is initialized when the worker queues start)
    this.peersQueried = null
  }

  /**
   * Stop all the workers
   */
  stop () {
    if (!this.running) {
      return
    }

    this.running = false
    for (const worker of this.workers) {
      worker.stop()
    }
  }

  /**
   * Execute the run with the given initial set of peers.
   *
   * @param {Array<PeerId>} peers
   * @returns {Promise}
   */

  async execute (peers) {
    const paths = [] // array of states per disjoint path

    // Create disjoint paths
    const numPaths = Math.min(this.query.dht.disjointPaths, peers.length)
    for (let i = 0; i < numPaths; i++) {
      paths.push(new Path(this, this.query.makePath(i, numPaths)))
    }

    // Assign peers to paths round-robin style
    peers.forEach((peer, i) => {
      paths[i % numPaths].addInitialPeer(peer)
    })

    // Execute the query along each disjoint path
    await this.executePaths(paths)

    const res = {
      // The closest K peers we were able to query successfully
      finalSet: new Set(this.peersQueried.peers),
      paths: []
    }

    // Collect the results from each completed path
    for (const path of paths) {
      if (path.res && (path.res.pathComplete || path.res.queryComplete)) {
        path.res.success = true
        res.paths.push(path.res)
      }
    }

    return res
  }

  /**
   * Execute all paths through the DHT.
   *
   * @param {Array<Path>} paths
   * @returns {Promise<void>}
   */
  async executePaths (paths) {
    this.running = true

    this.emit('start')
    try {
      await Promise.all(paths.map(path => path.execute()))
    } finally {
      // Ensure all workers are stopped
      this.stop()
      // Completed the Run
      this.emit('complete')
    }

    // If all queries errored out, something is seriously wrong, so callback
    // with an error
    if (this.errors.length === this.peersSeen.size) {
      throw this.errors[0]
    }
  }

  /**
   * Initialize the list of queried peers, then start a worker queue for the
   * given path.
   *
   * @param {Path} path
   * @returns {Promise<void>}
   */
  async workerQueue (path) {
    await this.init()
    await this.startWorker(path)
  }

  /**
   * Create and start a worker queue for a particular path.
   *
   * @param {Path} path
   * @returns {Promise<void>}
   */
  async startWorker (path) {
    const worker = new WorkerQueue(this.query.dht, this, path, this.query._log)
    this.workers.push(worker)
    await worker.execute()
  }

  /**
   * Initialize the list of closest peers we've queried - this is shared by all
   * paths in the run.
   *
   * @returns {Promise<void>}
   */
  async init () {
    if (this.peersQueried) {
      return
    }

    // We only want to initialize the PeerDistanceList once for the run
    if (this.peersQueriedPromise) {
      await this.peersQueriedPromise
      return
    }

    // This promise is temporarily stored so that others may await its completion
    this.peersQueriedPromise = (async () => {
      const dhtKey = await promisify(cb => utils.convertBuffer(this.query.key, cb))()
      this.peersQueried = new PeerDistanceList(dhtKey, this.query.dht.kBucketSize)
    })()

    // After PeerDistanceList is initialized, clean up
    await this.peersQueriedPromise
    delete this.peersQueriedPromise
  }

  /**
   * If we've queried K peers, and the remaining peers in the given `worker`'s queue
   * are all further from the key than the peers we've already queried, then we should
   * stop querying on that `worker`.
   *
   * @param {WorkerQueue} worker
   * @returns {Promise<Boolean>}
   */
  async continueQuerying (worker) {
    // If we haven't queried K peers yet, keep going
    if (this.peersQueried.length < this.peersQueried.capacity) {
      return true
    }

    // Get all the peers that are currently being queried.
    // Note that this function gets called right after a peer has been popped
    // off the head of the closest peers queue so it will include that peer.
    const running = worker.queue.workersList().map(i => i.data)

    // Check if any of the peers that are currently being queried are closer
    // to the key than the peers we've already queried
    const someCloser = await promisify(cb => this.peersQueried.anyCloser(running, cb))()

    // Some are closer, the worker should keep going
    if (someCloser) {
      return true
    }

    // None are closer, the worker can stop
    return false
  }
}

module.exports = Run

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/run.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/index.js", {"../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/constants.js","../message":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/message/index.js","../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js","./handlers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/index.js","pull-length-prefixed":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/index.js
      return function (require, module, exports) {
'use strict'

const pull = require('pull-stream')
const lp = require('pull-length-prefixed')

const Message = require('../message')
const handlers = require('./handlers')
const utils = require('../utils')
const c = require('../constants')

module.exports = (dht) => {
  const log = utils.logger(dht.peerInfo.id, 'rpc')

  const getMessageHandler = handlers(dht)
  /**
   * Process incoming DHT messages.
   *
   * @param {PeerInfo} peer
   * @param {Message} msg
   * @param {function(Error, Message)} callback
   * @returns {void}
   *
   * @private
   */
  function handleMessage (peer, msg, callback) {
    // update the peer
    dht._add(peer, (err) => {
      if (err) {
        log.error('Failed to update the kbucket store')
        log.error(err)
      }

      // get handler & exectue it
      const handler = getMessageHandler(msg.type)

      if (!handler) {
        log.error(`no handler found for message type: ${msg.type}`)
        return callback()
      }

      handler(peer, msg, callback)
    })
  }

  /**
   * Handle incoming streams from the Switch, on the dht protocol.
   *
   * @param {string} protocol
   * @param {Connection} conn
   * @returns {undefined}
   */
  return function protocolHandler (protocol, conn) {
    conn.getPeerInfo((err, peer) => {
      if (err) {
        log.error('Failed to get peer info')
        log.error(err)
        return
      }

      log('from: %s', peer.id.toB58String())

      pull(
        conn,
        lp.decode(),
        pull.filter((msg) => msg.length < c.maxMessageSize),
        pull.map((rawMsg) => {
          let msg
          try {
            msg = Message.deserialize(rawMsg)
          } catch (err) {
            log.error('failed to read incoming message', err)
            return
          }

          return msg
        }),
        pull.filter(Boolean),
        pull.asyncMap((msg, cb) => handleMessage(peer, msg, cb)),
        // Not all handlers will return a response
        pull.filter(Boolean),
        pull.map((response) => {
          let msg
          try {
            msg = response.serialize()
          } catch (err) {
            log.error('failed to send message', err)
            return
          }
          return msg
        }),
        pull.filter(Boolean),
        lp.encode(),
        conn
      )
    })
  }
}

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-handshake/index.js", {"pull-cat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-cat/index.js","pull-pair":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-pair/index.js","pull-pushable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-pushable/index.js","pull-reader":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-reader/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-handshake/index.js
      return function (require, module, exports) {
var Reader = require('pull-reader')
var Writer = require('pull-pushable')
var cat = require('pull-cat')
var pair = require('pull-pair')

function once (cb) {
  var called = 0
  return function (a, b, c) {
    if(called++) return
    cb(a, b, c)
  }
}

function isFunction (f) {
  return 'function' === typeof f
}

module.exports = function (opts, _cb) {
  if(isFunction(opts)) _cb = opts, opts = {}
  _cb = once(_cb || function noop () {})
  var reader = Reader(opts && opts.timeout || 5e3)
  var writer = Writer(function (err) {
    if(err) _cb(err)
  })

  var p = pair()

  return {
    handshake: {
      read: reader.read,
      abort: function (err) {
        writer.end(err)
        reader.abort(err, function (err) {
        })
        _cb(err)
      },
      write: writer.push,
      rest: function () {
        writer.end()
        return {
          source: reader.read(),
          sink: p.sink
        }
      }
    },
    sink: reader,
    source: cat([writer, p.source])
  }
}

      };
    };
  }
}, {package:"pull-handshake",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-handshake/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/exchange.js", {"../support":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/support.js","./crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/crypto.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/exchange.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')
const waterfall = require('async/waterfall')

const support = require('../support')
const crypto = require('./crypto')

const log = debug('libp2p:secio')
log.error = debug('libp2p:secio:error')

// step 2. Exchange
// -- exchange (signed) ephemeral keys. verify signatures.
module.exports = function exchange (state, callback) {
  log('2. exchange - start')

  log('2. exchange - writing exchange')
  waterfall([
    (cb) => crypto.createExchange(state, cb),
    (ex, cb) => {
      support.write(state, ex)
      support.read(state.shake, cb)
    },
    (msg, cb) => {
      log('2. exchange - reading exchange')
      crypto.verify(state, msg, cb)
    },
    (cb) => crypto.generateKeys(state, cb)
  ], (err) => {
    if (err) { return callback(err) }

    log('2. exchange - finish')
    callback()
  })
}

      };
    };
  }
}, {package:"libp2p-secio",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/exchange.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/finish.js", {"../etm":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/etm.js","./crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/crypto.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","pull-handshake":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-handshake/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js","pull-stream/sources/error":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/error.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/finish.js
      return function (require, module, exports) {
'use strict'

const pull = require('pull-stream/pull')
const pullError = require('pull-stream/sources/error')
const handshake = require('pull-handshake')
const debug = require('debug')

const log = debug('libp2p:secio')
log.error = debug('libp2p:secio:error')

const etm = require('../etm')
const crypto = require('./crypto')

// step 3. Finish
// -- send expected message to verify encryption works (send local nonce)
module.exports = function finish (state, callback) {
  log('3. finish - start')

  const proto = state.protocols
  const stream = state.shake.rest()
  const shake = handshake({ timeout: state.timeout }, (err) => {
    if (err) {
      throw err
    }
  })

  pull(
    stream,
    etm.createUnboxStream(proto.remote.cipher, proto.remote.mac),
    shake,
    etm.createBoxStream(proto.local.cipher, proto.local.mac),
    stream
  )

  shake.handshake.write(state.proposal.in.rand)
  shake.handshake.read(state.proposal.in.rand.length, (err, nonceBack) => {
    const fail = (err) => {
      log.error(err)
      state.secure.resolve({
        source: pullError(err),
        sink (read) {
        }
      })
      callback(err)
    }

    if (err) return fail(err)

    try {
      crypto.verifyNonce(state, nonceBack)
    } catch (err) {
      return fail(err)
    }

    log('3. finish - finish')

    // Awesome that's all folks.
    state.secure.resolve(shake.handshake.rest())
    callback()
  })
}

      };
    };
  }
}, {package:"libp2p-secio",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/finish.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/propose.js", {"../support":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/support.js","./crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/crypto.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/propose.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')
const waterfall = require('async/waterfall')

const support = require('../support')
const crypto = require('./crypto')

const log = debug('libp2p:secio')
log.error = debug('libp2p:secio:error')

// step 1. Propose
// -- propose cipher suite + send pubkeys + nonce
module.exports = function propose (state, callback) {
  log('1. propose - start')

  log('1. propose - writing proposal')
  support.write(state, crypto.createProposal(state))

  waterfall([
    (cb) => support.read(state.shake, cb),
    (msg, cb) => {
      log('1. propose - reading proposal', msg)
      crypto.identify(state, msg, cb)
    },
    (cb) => crypto.selectProtocols(state, cb)
  ], (err) => {
    if (err) {
      return callback(err)
    }

    log('1. propose - finish')
    callback()
  })
}

      };
    };
  }
}, {package:"libp2p-secio",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/propose.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/utils.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js","mafmt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mafmt/src/index.js","multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/utils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const multiaddr = require('multiaddr')
const Id = require('peer-id')
const crypto = require('libp2p-crypto')
const mafmt = require('mafmt')

function cleanUrlSIO (ma) {
  const protos = ma.protos()
  const ipProto = protos[0].name
  const tcpProto = protos[1].name
  const wsProto = protos[2].name
  const stringTuples = ma.stringTuples()
  const tcpPort = stringTuples[1][1]

  if (tcpProto !== 'tcp' || (wsProto !== 'ws' && wsProto !== 'wss')) {
    throw new Error('invalid multiaddr: ' + ma.toString())
  }

  let host = stringTuples[0][1]
  if (ipProto === 'ip6') {
    host = '[' + host + ']'
  }

  let proto = wsProto === 'wss' ? 'https' : 'http'
  let port =
    (wsProto === 'ws' && tcpPort === 80) || (wsProto === 'wss' && tcpPort === 443)
      ? '' : tcpPort

  return proto + '://' + host + (port ? ':' + port : '')
}

const types = {
  string: v => typeof v === 'string',
  object: v => typeof v === 'object',
  multiaddr: v => {
    if (!types.string(v)) return
    try {
      multiaddr(v)
      return true
    } catch (e) {
      return false
    }
  },
  function: v => typeof v === 'function'
}

function validate (def, data) {
  if (!Array.isArray(data)) throw new Error('Data is not an array')
  def.forEach((type, index) => {
    if (!types[type]) {
      console.error('Type %s does not exist', type) // eslint-disable-line no-console
      throw new Error('Type ' + type + ' does not exist')
    }
    if (!types[type](data[index])) throw new Error('Data at index ' + index + ' is invalid for type ' + type)
  })
}

function Protocol (log) {
  if (!log) log = () => {}
  const self = this
  self.requests = {}
  self.addRequest = (name, def, handle) => {
    self.requests[name] = {
      def,
      handle
    }
  }
  self.handleSocket = (socket) => {
    socket.r = {}
    Object.keys(self.requests).forEach((request) => {
      const r = self.requests[request]
      socket.on(request, function () {
        const data = [...arguments]
        try {
          validate(r.def, data)
          data.unshift(socket)
          r.handle.apply(null, data)
        } catch (e) {
          log(e)
          log('peer %s has sent invalid data for request %s', socket.id || '<server>', request, data)
        }
      })
    })
  }
}

function getIdAndValidate (pub, id, cb) {
  Id.createFromPubKey(Buffer.from(pub, 'hex'), (err, _id) => {
    if (err) {
      return cb(new Error('Crypto error'))
    }
    if (_id.toB58String() !== id) {
      return cb(new Error('Id is not matching'))
    }

    return cb(null, crypto.keys.unmarshalPublicKey(Buffer.from(pub, 'hex')))
  })
}

exports = module.exports
exports.cleanUrlSIO = cleanUrlSIO
exports.validate = validate
exports.Protocol = Protocol
exports.getIdAndValidate = getIdAndValidate
exports.validateMa = (ma) => mafmt.WebSocketStar.matches(multiaddr(ma))

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-websocket-star",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/listener.js", {"./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/errors/index.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/utils.js","async/series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/series.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","interface-connection":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/index.js","libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js","multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js","once":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/once/once.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js","pull-stream/throughs/through":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/through.js","socket.io-client":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/index.js","socket.io-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-pull-stream/src/index.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/listener.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const debug = require('debug')
const log = debug('libp2p:websocket-star:listener')
const multiaddr = require('multiaddr')
const io = require('socket.io-client')
const sp = require('socket.io-pull-stream')
const uuid = require('uuid')
const series = require('async/series')
const EE = require('events').EventEmitter
const Connection = require('interface-connection').Connection
const once = require('once')
const setImmediate = require('async/setImmediate')
const utils = require('./utils')
const cleanUrlSIO = utils.cleanUrlSIO
const crypto = require('libp2p-crypto')
const pull = require('pull-stream/pull')
const through = require('pull-stream/throughs/through')
const ERRORS = require('./errors')

const noop = once(() => {})

const sioOptions = {
  transports: ['websocket'],
  'force new connection': true
}

/**
  * Listener for signalling server
  * @class
  * @param {Object} options - Options for the listener
  * @param {PeerId} options.id - Id for the crypto challenge
  * @param {function} options.handler - Incomming connection handler
  */
class Listener extends EE {
  constructor (options) {
    super()
    this.id = options.id
    this.log = log.bind(log, 'listener#offline')
    this.canCrypto = Boolean(options.id)
    this._handler = options.handler || noop
    this.listeners_list = options.listeners || {}
    this.flag = options.flag
    this.conns = []
    this.connected = false
  }

  // "private" functions
  /**
    * Connects to the signalling server
    * @param {function} cb - callback
    * @returns {undefined}
    * @private
    */
  _up (cb) {
    cb = cb ? once(cb) : noop
    if (this.io) {
      return cb()
    }

    this.log = log.bind(log, 'listener#' + this.server)
    this.log('dialing to signalling server')
    const _io = this.io = io.connect(this.server, sioOptions)

    sp(_io, { codec: 'buffer' })
    _io.once('error', cb)
    _io.once('connect_error', cb)
    _io.once('connect', cb)

    const proto = new utils.Protocol(this.log)

    proto.addRequest('ws-peer', ['multiaddr'], (socket, peer) => this.emit('peer', peer))
    proto.addRequest('ss-incomming', ['string', 'multiaddr', 'function'], this._incommingDial.bind(this))
    proto.handleSocket(_io)
  }

  /**
    * Disconnects from signalling server
    * @returns {undefined}
    * @private
    */
  _down () {
    if (!this.io) {
      return
    }

    this.io.disconnect()
    this.emit('close')
    delete this.io
  }

  /**
    * Performs a cryptoChallenge
    * @param {function} callback - callback
    * @returns {undefined}
    * @private
    */
  _cryptoChallenge (callback) {
    if (!this.io) {
      return callback(new Error('Not connected'))
    }

    const pubKeyStr = this.canCrypto ? crypto.keys.marshalPublicKey(this.id.pubKey).toString('hex') : ''

    const maStr = this.ma.toString()

    this.io.emit('ss-join', maStr, pubKeyStr, (err, sig, peers) => {
      if (err) { return callback(err) }

      if (sig) {
        if (!this.canCrypto) {
          this._down()
          return callback(new Error("Can't sign cryptoChallenge: No id provided"))
        }

        this.log('performing cryptoChallenge')

        this.id.privKey.sign(Buffer.from(sig), (err, signature) => {
          if (err) {
            return callback(err)
          }
          this.signature = signature.toString('hex')
          this._join(callback)
        })
      } else {
        if (!this.flag) {
          this._down()
          return callback(new Error('Tried to listen on a server with crypto challenge disabled!\n    This is prohibited by default and can lead to security issues!\n    Please set "allowJoinWithDisabledChallenge" to true in the constructor options (but only if you know what you are doing)!'))
        }
        this.signature = '_'
        callback(null, null, peers)
      }
    })
  }

  /**
    * Performs a cryptoChallenge when no signature is found
    * @param {function} cb - callback
    * @returns {undefined}
    * @private
    */
  _crypto (cb) {
    cb = cb ? once(cb) : noop

    this.log('joining')

    if (!this.io) {
      return cb(new Error('Not connected'))
    }

    if (this.signature) {
      this._join(cb)
    } else {
      this._cryptoChallenge(cb)
    }
  }

  /**
    * Emits ss-join with the multiaddr and signature
    *
    * @param {function} cb - callback
    * @returns {undefined}
    * @private
    */
  _join (cb) {
    this.io.emit('ss-join', this.ma.toString(), this.signature, cb)
  }

  /**
    * Handles incomming dials
    * @listens ss-incomming
    * @param {socket.io_client} socket
    * @param {string} dialId - Unique id for this dial
    * @param {string} dialFrom - Multiaddr as string
    * @param {function} cb - callback
    * @returns {undefined}
    * @private
    */
  _incommingDial (socket, dialId, dialFrom, cb) {
    this.log('dial#' + dialId + ' incomming from', dialFrom)
    const ma = multiaddr(dialFrom)
    const source = this.io.createSource(dialId + '.dialer')
    const sink = this.io.createSink(dialId + '.listener')

    cb()

    const conn = new Connection(
      {
        sink: sink,
        source: source
      }, {
        getObservedAddrs: (cb) => cb(null, [ma])
      }
    )
    this.emit('connection', conn)
    this._handler(conn)
  }

  // public functions
  /**
    * Listens on a multiaddr
    * @param {Multiaddr} ma
    * @param {function} callback
    * @returns {undefined}
    */
  listen (ma, callback) {
    this.ma = ma
    this.server = cleanUrlSIO(ma)
    this.listeners_list[this.server] = this
    callback = callback ? once(callback) : noop

    if (this.connected) { // listener was .close()'d yet not all conns disconnected. we're still connected, so don't do anything
      this.closing = false
      return setImmediate(() => callback())
    }

    series([
      (cb) => this._up(cb),
      (cb) => this._crypto((err, ignore, peers) => cb(err, peers))
    ], (err, [ignore, peers]) => {
      if (err) {
        // Error connecting to WebSocket
        if (err.description && err.description.code === 'ENOTFOUND') {
          const hostname = err.description.hostname

          err = Object.assign(new Error(`WebSocket connection failed on ${hostname}`), {
            code: ERRORS.ERR_WS_STAR_WEBSOCKET_CONNECTION
          })
        }

        this.log('error', err)
        if (!(err instanceof Error)) err = new Error(err)
        this._down()
        this.emit('error', err)
        this.emit('close')
        return callback(err)
      }

      this.log('success')
      this.connected = true

      this.io.on('reconnect', () => {
        // force to get a new signature
        this.signature = null
        this._crypto((err, ignore, reconnectPeers) => {
          if (err) {
            this.log('reconnect error', err)
            this.emit('error', err)
          } else {
            this.log('reconnected')
            for (const p of (reconnectPeers || [])) {
              this.emit('peer', p)
            }
          }
        })
      })

      this.emit('listening')
      for (const p of (peers || [])) {
        this.emit('peer', p)
      }
      callback()
    })
  }

  /**
    * Gets the addresses the listener listens on
    * @param {function} callback
    * @returns {undefined}
    */
  getAddrs (callback) {
    setImmediate(() => callback(null, this.ma ? [this.ma] : []))
  }

  get activeConnections () {
    this.conns = this.conns.filter(c => c.sink || c.source)
    return Boolean(this.conns.length)
  }

  maybeClose () {
    if (!this.activeConnections && this.closing) {
      this.connected = false
      this.closing = false
      this.log('no more connections and listener is offline - closing')
      this._down()
    }
  }

  close (callback) {
    callback = callback ? once(callback) : noop

    this.closing = true // will close once the last connection quits
    this.maybeClose()

    callback()
  }

  stateWatch (sink, source) {
    let cstate = { sink: true, source: true }
    const watch = (name) => through(v => v, e => {
      cstate[name] = false
      if (!cstate.sink && !cstate.source) {
        this.maybeClose()
      }
    })

    this.conns.push(cstate)

    return {
      sink: pull(
        watch('sink'),
        sink
      ),
      source: pull(
        source,
        watch('source')
      )
    }
  }

  // called from transport
  /**
    * Dials a peer
    * @param {Multiaddr} ma - Multiaddr to dial to
    * @param {Object} options
    * @param {function} callback
    * @returns {undefined}
    */
  dial (ma, options, callback) {
    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    const _ma = multiaddr(ma)

    const conn = new Connection(null)

    const dialId = uuid()
    const dlog = this.log.bind(log, 'dial#' + dialId)

    callback = callback ? once(callback) : noop

    let io = this.io

    if (!io) {
      return callback(new Error('Not listening'))
    }

    const sink = io.createSink(dialId + '.dialer')

    dlog('dialing', ma.toString())

    // "multiaddr", "multiaddr", "string", "function" - dialFrom, dialTo, dialId, cb
    io.emit('ss-dial', this.ma.toString(), ma.toString(), dialId, err => {
      if (err) return callback(err instanceof Error ? err : new Error(err))
      dlog(err ? 'error: ' + err.toString() : 'success')
      const source = io.createSource(dialId + '.listener')

      conn.setInnerConn(this.stateWatch(sink, source), { getObservedAddrs: (cb) => cb(null, [_ma]) })
      callback(null, conn)
    })

    return conn
  }
}

module.exports = Listener

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-websocket-star",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/listener.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/get-browser-rtc/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/get-browser-rtc/index.js
      return function (require, module, exports) {
// originally pulled out of simple-peer

module.exports = function getBrowserRTC () {
  if (typeof window === 'undefined') return null
  var wrtc = {
    RTCPeerConnection: window.RTCPeerConnection || window.mozRTCPeerConnection ||
      window.webkitRTCPeerConnection,
    RTCSessionDescription: window.RTCSessionDescription ||
      window.mozRTCSessionDescription || window.webkitRTCSessionDescription,
    RTCIceCandidate: window.RTCIceCandidate || window.mozRTCIceCandidate ||
      window.webkitRTCIceCandidate
  }
  if (!wrtc.RTCPeerConnection) return null
  return wrtc
}

      };
    };
  }
}, {package:"get-browser-rtc",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/get-browser-rtc/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/readable-browser.js", {"./lib/_stream_duplex.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_passthrough.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/_stream_readable.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_transform.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_writable.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_writable.js","./lib/internal/streams/end-of-stream.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","./lib/internal/streams/pipeline.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/pipeline.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/readable-browser.js
      return function (require, module, exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/readable-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/url.js", {"debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/node_modules/debug/src/browser.js","parseuri":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/parseuri/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/url.js
      return function (require, module, exports) {

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || (typeof location !== 'undefined' && location);
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}

      };
    };
  }
}, {package:"socket.io-client",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/url.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/socket.js", {"./on":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/on.js","component-bind":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/component-bind/index.js","component-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/component-emitter/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/node_modules/debug/src/browser.js","has-binary2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/has-binary2/index.js","parseqs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/parseqs/index.js","socket.io-parser":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/index.js","to-array":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/to-array/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/socket.js
      return function (require, module, exports) {

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var parseqs = require('parseqs');
var hasBin = require('has-binary2');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.flags = {};
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  if (!this.io.reconnecting) this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  this.flags = {};

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({type: parser.CONNECT, query: query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  var sameNamespace = packet.nsp === this.nsp;
  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';

  if (!sameNamespace && !rootNamespaceError) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags.compress = compress;
  return this;
};

/**
 * Sets the binary flag
 *
 * @param {Boolean} whether the emitted data contains binary
 * @return {Socket} self
 * @api public
 */

Socket.prototype.binary = function (binary) {
  this.flags.binary = binary;
  return this;
};

      };
    };
  }
}, {package:"socket.io-client",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/socket.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/node_modules/debug/src/browser.js", {"./debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/node_modules/debug/src/debug.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/node_modules/debug/src/browser.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"debug",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/node_modules/debug/src/browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/index.js", {"./binary":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/binary.js","./is-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/is-buffer.js","component-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/component-emitter/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/node_modules/debug/src/browser.js","isarray":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/node_modules/isarray/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/index.js
      return function (require, module, exports) {

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

var ERROR_PACKET = exports.ERROR + '"encode error"';

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    var payload = tryStringify(obj.data);
    if (payload !== false) {
      str += payload;
    } else {
      return ERROR_PACKET;
    }
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

function tryStringify(str) {
  try {
    return JSON.stringify(str);
  } catch(e){
    return false;
  }
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an encoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  } else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  } else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) {
    return error('unknown packet type ' + p.type);
  }

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var start = i + 1;
    while (str.charAt(++i) !== '-' && i != str.length) {}
    var buf = str.substring(start, i);
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    var start = i + 1;
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      if (i === str.length) break;
    }
    p.nsp = str.substring(start, i);
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    var start = i + 1;
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      if (i === str.length) break;
    }
    p.id = Number(str.substring(start, i + 1));
  }

  // look up json data
  if (str.charAt(++i)) {
    var payload = tryParse(str.substr(i));
    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
    if (isPayloadValid) {
      p.data = payload;
    } else {
      return error('invalid payload');
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch(e){
    return false;
  }
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(msg) {
  return {
    type: exports.ERROR,
    data: 'parser error: ' + msg
  };
}

      };
    };
  }
}, {package:"socket.io-parser",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/manager.js", {"./on":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/on.js","./socket":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/socket.js","backo2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/backo2/index.js","component-bind":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/component-bind/index.js","component-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/component-emitter/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/node_modules/debug/src/browser.js","engine.io-client":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/engine.io-client/lib/index.js","indexof":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/indexof/index.js","socket.io-parser":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/manager.js
      return function (require, module, exports) {

/**
 * Module dependencies.
 */

var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    if (timeout === 0) {
      openSub.destroy(); // prevents a race condition with the 'open' event
    }

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

      };
    };
  }
}, {package:"socket.io-client",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/manager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/tryEach.js", {"./eachSeries":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/eachSeries.js","./internal/slice":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/slice.js","./internal/wrapAsync":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/wrapAsync.js","lodash/noop":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/noop.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/tryEach.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = tryEach;

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _eachSeries = require('./eachSeries');

var _eachSeries2 = _interopRequireDefault(_eachSeries);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _slice = require('./internal/slice');

var _slice2 = _interopRequireDefault(_slice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * It runs each task in series but stops whenever any of the functions were
 * successful. If one of the tasks were successful, the `callback` will be
 * passed the result of the successful task. If all tasks fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name tryEach
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection containing functions to
 * run, each function is passed a `callback(err, result)` it must call on
 * completion with an error `err` (which can be `null`) and an optional `result`
 * value.
 * @param {Function} [callback] - An optional callback which is called when one
 * of the tasks has succeeded, or all have failed. It receives the `err` and
 * `result` arguments of the last attempt at completing the `task`. Invoked with
 * (err, results).
 * @example
 * async.tryEach([
 *     function getDataFromFirstWebsite(callback) {
 *         // Try getting the data from the first website
 *         callback(err, data);
 *     },
 *     function getDataFromSecondWebsite(callback) {
 *         // First website failed,
 *         // Try getting the data from the backup website
 *         callback(err, data);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     Now do something with the data.
 * });
 *
 */
function tryEach(tasks, callback) {
    var error = null;
    var result;
    callback = callback || _noop2.default;
    (0, _eachSeries2.default)(tasks, function (task, callback) {
        (0, _wrapAsync2.default)(task)(function (err, res /*, ...args*/) {
            if (arguments.length > 2) {
                result = (0, _slice2.default)(arguments, 1);
            } else {
                result = res;
            }
            error = err;
            callback(!err);
        });
    }, function () {
        callback(error, result);
    });
}
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/tryEach.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/handler.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/constants.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","pull-handshake":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-handshake/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/handler.js
      return function (require, module, exports) {
'use strict'

const pull = require('pull-stream/pull')
const handshake = require('pull-handshake')
const constants = require('./constants')
const PROTOCOL = constants.PROTOCOL
const PING_LENGTH = constants.PING_LENGTH

const debug = require('debug')
const log = debug('libp2p-ping')
log.error = debug('libp2p-ping:error')

function mount (swarm) {
  swarm.handle(PROTOCOL, (protocol, conn) => {
    const stream = handshake({ timeout: 0 })
    const shake = stream.handshake

    // receive and echo back
    function next () {
      shake.read(PING_LENGTH, (err, buf) => {
        if (err === true) {
          // stream closed
          return
        }
        if (err) {
          return log.error(err)
        }

        shake.write(buf)
        return next()
      })
    }

    pull(
      conn,
      stream,
      conn
    )

    next()
  })
}

function unmount (swarm) {
  swarm.unhandle(PROTOCOL)
}

exports = module.exports
exports.mount = mount
exports.unmount = unmount

      };
    };
  }
}, {package:"libp2p-ping",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/handler.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/ping.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/constants.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/util.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","pull-handshake":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-handshake/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js","pull-stream/sources/empty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/ping.js
      return function (require, module, exports) {
'use strict'

const EventEmitter = require('events').EventEmitter
const pull = require('pull-stream/pull')
const empty = require('pull-stream/sources/empty')
const handshake = require('pull-handshake')
const constants = require('./constants')
const util = require('./util')
const rnd = util.rnd
const debug = require('debug')
const log = debug('libp2p-ping')
log.error = debug('libp2p-ping:error')

const PROTOCOL = constants.PROTOCOL
const PING_LENGTH = constants.PING_LENGTH

class Ping extends EventEmitter {
  constructor (swarm, peer) {
    super()

    this._stopped = false
    this.peer = peer
    this.swarm = swarm
  }

  start () {
    log('dialing %s to %s', PROTOCOL, this.peer.id.toB58String())

    this.swarm.dial(this.peer, PROTOCOL, (err, conn) => {
      if (err) {
        return this.emit('error', err)
      }

      const stream = handshake({ timeout: 0 })
      this.shake = stream.handshake

      pull(
        stream,
        conn,
        stream
      )

      // write and wait to see ping back
      const self = this
      function next () {
        let start = new Date()
        let buf = rnd(PING_LENGTH)
        self.shake.write(buf)
        self.shake.read(PING_LENGTH, (err, bufBack) => {
          let end = new Date()
          if (err || !buf.equals(bufBack)) {
            const err = new Error('Received wrong ping ack')
            return self.emit('error', err)
          }

          self.emit('ping', end - start)

          if (self._stopped) {
            return
          }
          next()
        })
      }

      next()
    })
  }

  stop () {
    if (this._stopped || !this.shake) {
      return
    }

    this._stopped = true

    pull(
      empty(),
      this.shake.rest()
    )
  }
}

module.exports = Ping

      };
    };
  }
}, {package:"libp2p-ping",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/ping.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-floodsub/src/index.js", {"./config":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-floodsub/src/config.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","async/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/map.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","libp2p-pubsub":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-pubsub/src/index.js","pull-length-prefixed":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-floodsub/src/index.js
      return function (require, module, exports) {
'use strict'

const pull = require('pull-stream')
const lp = require('pull-length-prefixed')
const assert = require('assert')

const BaseProtocol = require('libp2p-pubsub')
const { message, utils } = require('libp2p-pubsub')
const config = require('./config')

const multicodec = config.multicodec
const ensureArray = utils.ensureArray
const setImmediate = require('async/setImmediate')
const asyncMap = require('async/map')
const noop = () => {}

/**
 * FloodSub (aka dumbsub is an implementation of pubsub focused on
 * delivering an API for Publish/Subscribe, but with no CastTree Forming
 * (it just floods the network).
 */
class FloodSub extends BaseProtocol {
  /**
   * @param {Object} libp2p
   * @constructor
   */
  constructor (libp2p) {
    super('libp2p:floodsub', multicodec, libp2p)

    /**
     * List of our subscriptions
     * @type {Set<string>}
     */
    this.subscriptions = new Set()
  }

  /**
   * Dial a received peer.
   * @override
   * @param {PeerInfo} peerInfo peer info
   * @param {Connection} conn connection to the peer
   * @param {function} callback
   */
  _onDial (peerInfo, conn, callback) {
    super._onDial(peerInfo, conn, (err) => {
      if (err) return callback(err)
      const idB58Str = peerInfo.id.toB58String()
      const peer = this.peers.get(idB58Str)
      if (peer && peer.isWritable) {
        // Immediately send my own subscriptions to the newly established conn
        peer.sendSubscriptions(this.subscriptions)
      }
      setImmediate(() => callback())
    })
  }

  /**
   * Overriding the implementation of _processConnection should keep the connection and is
   * responsible for processing each RPC message received by other peers.
   * @override
   * @param {string} idB58Str peer id string in base58
   * @param {Connection} conn connection
   * @param {PeerInfo} peer peer info
   * @returns {undefined}
   *
   */
  _processConnection (idB58Str, conn, peer) {
    pull(
      conn,
      lp.decode(),
      pull.map((data) => message.rpc.RPC.decode(data)),
      pull.drain(
        (rpc) => this._onRpc(idB58Str, rpc),
        (err) => this._onConnectionEnd(idB58Str, peer, err)
      )
    )
  }

  _onRpc (idB58Str, rpc) {
    if (!rpc) {
      return
    }

    this.log('rpc from', idB58Str)
    const subs = rpc.subscriptions
    const msgs = rpc.msgs

    if (msgs && msgs.length) {
      this._processRpcMessages(utils.normalizeInRpcMessages(rpc.msgs))
    }

    if (subs && subs.length) {
      const peer = this.peers.get(idB58Str)
      if (peer) {
        peer.updateSubscriptions(subs)
        this.emit('floodsub:subscription-change', peer.info, peer.topics, subs)
      }
    }
  }

  _processRpcMessages (msgs) {
    msgs.forEach((msg) => {
      const seqno = utils.msgId(msg.from, msg.seqno)
      // 1. check if I've seen the message, if yes, ignore
      if (this.seenCache.has(seqno)) {
        return
      }

      this.seenCache.put(seqno)

      // 2. emit to self
      this._emitMessages(msg.topicIDs, [msg])

      // 3. propagate msg to others
      this._forwardMessages(msg.topicIDs, [msg])
    })
  }

  _emitMessages (topics, messages) {
    topics.forEach((topic) => {
      if (!this.subscriptions.has(topic)) {
        return
      }

      messages.forEach((message) => {
        this.emit(topic, message)
      })
    })
  }

  _forwardMessages (topics, messages) {
    this.peers.forEach((peer) => {
      if (!peer.isWritable || !utils.anyMatch(peer.topics, topics)) {
        return
      }

      peer.sendMessages(utils.normalizeOutRpcMessages(messages))

      this.log('publish msgs on topics', topics, peer.info.id.toB58String())
    })
  }

  /**
   * Unmounts the floodsub protocol and shuts down every connection
   * @override
   * @param {Function} callback
   * @returns {undefined}
   *
   */
  stop (callback) {
    super.stop((err) => {
      if (err) return callback(err)
      this.subscriptions = new Set()
      callback()
    })
  }

  /**
   * Publish messages to the given topics.
   * @override
   * @param {Array<string>|string} topics
   * @param {Array<any>|any} messages
   * @param {function(Error)} callback
   * @returns {undefined}
   *
   */
  publish (topics, messages, callback) {
    assert(this.started, 'FloodSub is not started')
    callback = callback || noop

    this.log('publish', topics, messages)

    topics = ensureArray(topics)
    messages = ensureArray(messages)

    const from = this.libp2p.peerInfo.id.toB58String()

    const buildMessage = (msg, cb) => {
      const seqno = utils.randomSeqno()
      this.seenCache.put(utils.msgId(from, seqno))

      const message = {
        from: from,
        data: msg,
        seqno: seqno,
        topicIDs: topics
      }

      // Emit to self if I'm interested
      this._emitMessages(topics, [message])

      this._buildMessage(message, cb)
    }

    asyncMap(messages, buildMessage, (err, msgObjects) => {
      if (err) return callback(err)

      // send to all the other peers
      this._forwardMessages(topics, msgObjects)

      callback(null)
    })
  }

  /**
   * Subscribe to the given topic(s).
   * @override
   * @param {Array<string>|string} topics
   * @returns {undefined}
   */
  subscribe (topics) {
    assert(this.started, 'FloodSub is not started')

    topics = ensureArray(topics)

    topics.forEach((topic) => this.subscriptions.add(topic))

    this.peers.forEach((peer) => sendSubscriptionsOnceReady(peer))
    // make sure that FloodSub is already mounted
    function sendSubscriptionsOnceReady (peer) {
      if (peer && peer.isWritable) {
        return peer.sendSubscriptions(topics)
      }
      const onConnection = () => {
        peer.removeListener('connection', onConnection)
        sendSubscriptionsOnceReady(peer)
      }
      peer.on('connection', onConnection)
      peer.once('close', () => peer.removeListener('connection', onConnection))
    }
  }

  /**
   * Unsubscribe from the given topic(s).
   * @override
   * @param {Array<string>|string} topics
   * @returns {undefined}
   */
  unsubscribe (topics) {
    // Avoid race conditions, by quietly ignoring unsub when shutdown.
    if (!this.started) {
      return
    }

    topics = ensureArray(topics)

    topics.forEach((topic) => this.subscriptions.delete(topic))

    this.peers.forEach((peer) => checkIfReady(peer))
    // make sure that FloodSub is already mounted
    function checkIfReady (peer) {
      if (peer && peer.isWritable) {
        peer.sendUnsubscriptions(topics)
      } else {
        setImmediate(checkIfReady.bind(peer))
      }
    }
  }
}

module.exports = FloodSub

      };
    };
  }
}, {package:"libp2p-floodsub",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-floodsub/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/latency-monitor/index.js", {"./dist/LatencyMonitor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/latency-monitor/dist/LatencyMonitor.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/latency-monitor/index.js
      return function (require, module, exports) {
/* eslint-disable strict */

'use strict';


Object.defineProperty(exports, '__esModule', {
    value: true
});

exports.default = require('./dist/LatencyMonitor').default;

      };
    };
  }
}, {package:"latency-monitor",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/latency-monitor/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/errors.js", {"err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/errors.js
      return function (require, module, exports) {
'use strict'

const errCode = require('err-code')

module.exports = {
  CONNECTION_FAILED: (err) => errCode(err, 'CONNECTION_FAILED'),
  DIAL_ABORTED: () => errCode('Dial was aborted', 'DIAL_ABORTED'),
  ERR_BLACKLISTED: () => errCode('Dial is currently blacklisted for this peer', 'ERR_BLACKLISTED'),
  DIAL_SELF: () => errCode('A node cannot dial itself', 'DIAL_SELF'),
  INVALID_STATE_TRANSITION: (err) => errCode(err, 'INVALID_STATE_TRANSITION'),
  NO_TRANSPORTS_REGISTERED: () => errCode('No transports registered, dial not possible', 'NO_TRANSPORTS_REGISTERED'),
  PROTECTOR_REQUIRED: () => errCode('No protector provided with private network enforced', 'PROTECTOR_REQUIRED'),
  UNEXPECTED_END: () => errCode('Unexpected end of input from reader.', 'UNEXPECTED_END'),
  maybeUnexpectedEnd: (err) => {
    if (err === true) {
      return module.exports.UNEXPECTED_END()
    }
    return err
  }
}

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/errors.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/get-peer-info.js", {"multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/get-peer-info.js
      return function (require, module, exports) {
'use strict'

const PeerId = require('peer-id')
const PeerInfo = require('peer-info')
const multiaddr = require('multiaddr')

/**
 * Helper method to check the data type of peer and convert it to PeerInfo
 *
 * @param {PeerInfo|Multiaddr|PeerId} peer
 * @param {PeerBook} peerBook
 * @throws {InvalidPeerType}
 * @returns {PeerInfo}
 */
function getPeerInfo (peer, peerBook) {
  let peerInfo

  // Already a PeerInfo instance,
  // add to the peer book and return the latest value
  if (PeerInfo.isPeerInfo(peer)) {
    return peerBook.put(peer)
  }

  // Attempt to convert from Multiaddr instance (not string)
  if (multiaddr.isMultiaddr(peer)) {
    const peerIdB58Str = peer.getPeerId()
    try {
      peerInfo = peerBook.get(peerIdB58Str)
    } catch (err) {
      peerInfo = new PeerInfo(PeerId.createFromB58String(peerIdB58Str))
    }
    peerInfo.multiaddrs.add(peer)
    return peerInfo
  }

  // Attempt to convert from PeerId
  if (PeerId.isPeerId(peer)) {
    const peerIdB58Str = peer.toB58String()
    try {
      return peerBook.get(peerIdB58Str)
    } catch (err) {
      throw new Error(`Couldnt get PeerInfo for ${peerIdB58Str}`)
    }
  }

  throw new Error('peer type not recognized')
}

module.exports = getPeerInfo

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/get-peer-info.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/plaintext.js", {"async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/plaintext.js
      return function (require, module, exports) {
'use strict'

const setImmediate = require('async/setImmediate')

/**
 * An encryption stub in the instance that the default crypto
 * has not been overriden for the Switch
 */
module.exports = {
  tag: '/plaintext/1.0.0',
  encrypt (myId, conn, remoteId, callback) {
    if (typeof remoteId === 'function') {
      callback = remoteId
      remoteId = undefined
    }

    setImmediate(() => callback())
    return conn
  }
}

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/plaintext.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/observer.js", {"events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","pull-stream/throughs/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/map.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/observer.js
      return function (require, module, exports) {
'use strict'

const map = require('pull-stream/throughs/map')
const EventEmitter = require('events')

/**
 * Takes a Switch and returns an Observer that can be used in conjunction with
 * observe-connection.js. The returned Observer comes with `incoming` and
 * `outgoing` properties that can be used in pull streams to emit all metadata
 * for messages that pass through a Connection.
 *
 * @param {Switch} swtch
 * @returns {EventEmitter}
 */
module.exports = (swtch) => {
  const observer = Object.assign(new EventEmitter(), {
    incoming: observe('in'),
    outgoing: observe('out')
  })

  swtch.on('peer-mux-established', (peerInfo) => {
    observer.emit('peer:connected', peerInfo.id.toB58String())
  })

  swtch.on('peer-mux-closed', (peerInfo) => {
    observer.emit('peer:closed', peerInfo.id.toB58String())
  })

  return observer

  function observe (direction) {
    return (transport, protocol, peerInfo) => {
      return map((buffer) => {
        willObserve(peerInfo, transport, protocol, direction, buffer.length)
        return buffer
      })
    }
  }

  function willObserve (peerInfo, transport, protocol, direction, bufferLength) {
    peerInfo.then((_peerInfo) => {
      if (_peerInfo) {
        const peerId = _peerInfo.id.toB58String()
        observer.emit('message', peerId, transport, protocol, direction, bufferLength)
      }
    })
  }
}

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/observer.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/stats/index.js", {"./old-peers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/stats/old-peers.js","./stat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/stats/stat.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/stats/index.js
      return function (require, module, exports) {
'use strict'

const EventEmitter = require('events')

const Stat = require('./stat')
const OldPeers = require('./old-peers')

const defaultOptions = {
  computeThrottleMaxQueueSize: 1000,
  computeThrottleTimeout: 2000,
  movingAverageIntervals: [
    60 * 1000, // 1 minute
    5 * 60 * 1000, // 5 minutes
    15 * 60 * 1000 // 15 minutes
  ],
  maxOldPeersRetention: 50
}

const initialCounters = [
  'dataReceived',
  'dataSent'
]

const directionToEvent = {
  in: 'dataReceived',
  out: 'dataSent'
}

/**
 * Binds to message events on the given `observer` to generate stats
 * based on the Peer, Protocol and Transport used for the message. Stat
 * events will be emitted via the `update` event.
 *
 * @param {Observer} observer
 * @param {any} _options
 * @returns {Stats}
 */
module.exports = (observer, _options) => {
  const options = Object.assign({}, defaultOptions, _options)
  const globalStats = new Stat(initialCounters, options)

  const stats = Object.assign(new EventEmitter(), {
    start: start,
    stop: stop,
    global: globalStats,
    peers: () => Array.from(peerStats.keys()),
    forPeer: (peerId) => {
      return peerStats.get(peerId) || oldPeers.get(peerId)
    },
    transports: () => Array.from(transportStats.keys()),
    forTransport: (transport) => transportStats.get(transport),
    protocols: () => Array.from(protocolStats.keys()),
    forProtocol: (protocol) => protocolStats.get(protocol)
  })

  globalStats.on('update', propagateChange)

  const oldPeers = OldPeers(options.maxOldPeersRetention)
  const peerStats = new Map()
  const transportStats = new Map()
  const protocolStats = new Map()

  observer.on('peer:closed', (peerId) => {
    const peer = peerStats.get(peerId)
    if (peer) {
      peer.removeListener('update', propagateChange)
      peer.stop()
      peerStats.delete(peerId)
      oldPeers.set(peerId, peer)
    }
  })

  return stats

  function onMessage (peerId, transportTag, protocolTag, direction, bufferLength) {
    const event = directionToEvent[direction]

    if (transportTag) {
      // because it has a transport tag, this message is at the global level, so we account this
      // traffic as global.
      globalStats.push(event, bufferLength)

      // peer stats
      let peer = peerStats.get(peerId)
      if (!peer) {
        peer = oldPeers.get(peerId)
        if (peer) {
          oldPeers.delete(peerId)
        } else {
          peer = new Stat(initialCounters, options)
        }
        peer.on('update', propagateChange)
        peer.start()
        peerStats.set(peerId, peer)
      }
      peer.push(event, bufferLength)
    }

    // transport stats
    if (transportTag) {
      let transport = transportStats.get(transportTag)
      if (!transport) {
        transport = new Stat(initialCounters, options)
        transport.on('update', propagateChange)
        transportStats.set(transportTag, transport)
      }
      transport.push(event, bufferLength)
    }

    // protocol stats
    if (protocolTag) {
      let protocol = protocolStats.get(protocolTag)
      if (!protocol) {
        protocol = new Stat(initialCounters, options)
        protocol.on('update', propagateChange)
        protocolStats.set(protocolTag, protocol)
      }
      protocol.push(event, bufferLength)
    }
  }

  function start () {
    observer.on('message', onMessage)

    globalStats.start()

    for (let peerStat of peerStats.values()) {
      peerStat.start()
    }
    for (let transportStat of transportStats.values()) {
      transportStat.start()
    }
  }

  function stop () {
    observer.removeListener('message', onMessage)
    globalStats.stop()

    for (let peerStat of peerStats.values()) {
      peerStat.stop()
    }
    for (let transportStat of transportStats.values()) {
      transportStat.stop()
    }
  }

  function propagateChange () {
    stats.emit('update')
  }
}

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/stats/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/handler.js", {"../observe-connection":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/observe-connection.js","./incoming":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/incoming.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/handler.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')
const IncomingConnection = require('./incoming')
const observeConn = require('../observe-connection')

function listener (_switch) {
  const log = debug(`libp2p:switch:listener`)

  /**
   * Takes a transport key and returns a connection handler function
   *
   * @param {string} transportKey The key of the transport to handle connections for
   * @param {function} handler A custom handler to use
   * @returns {function(Connection)} A connection handler function
   */
  return function (transportKey, handler) {
    /**
     * Takes a base connection and manages listening behavior
     *
     * @param {Connection} conn The connection to manage
     * @returns {void}
     */
    return function (conn) {
      log('received incoming connection for transport %s', transportKey)
      conn.getPeerInfo((_, peerInfo) => {
        // Add a transport level observer, if needed
        const connection = transportKey ? observeConn(transportKey, null, conn, _switch.observer) : conn
        const connFSM = new IncomingConnection({ connection, _switch, transportKey, peerInfo })

        connFSM.once('error', (err) => log(err))
        connFSM.once('private', (_conn) => {
          // Use the custom handler, if it was provided
          if (handler) {
            return handler(_conn)
          }
          connFSM.encrypt()
        })
        connFSM.once('encrypted', () => connFSM.upgrade())

        connFSM.protect()
      })
    }
  }
}

module.exports = listener

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/handler.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/dialer/index.js", {"../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/constants.js","../get-peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/get-peer-info.js","./queueManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/dialer/queueManager.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/dialer/index.js
      return function (require, module, exports) {
'use strict'

const DialQueueManager = require('./queueManager')
const getPeerInfo = require('../get-peer-info')
const {
  BLACK_LIST_ATTEMPTS,
  BLACK_LIST_TTL,
  MAX_COLD_CALLS,
  MAX_PARALLEL_DIALS,
  PRIORITY_HIGH,
  PRIORITY_LOW
} = require('../constants')

module.exports = function (_switch) {
  const dialQueueManager = new DialQueueManager(_switch)

  _switch.state.on('STARTED:enter', start)
  _switch.state.on('STOPPING:enter', stop)

  /**
   * @param {DialRequest} dialRequest
   * @returns {void}
   */
  function _dial ({ peerInfo, protocol, options, callback }) {
    if (typeof protocol === 'function') {
      callback = protocol
      protocol = null
    }

    try {
      peerInfo = getPeerInfo(peerInfo, _switch._peerBook)
    } catch (err) {
      return callback(err)
    }

    // Add it to the queue, it will automatically get executed
    dialQueueManager.add({ peerInfo, protocol, options, callback })
  }

  /**
   * Starts the `DialQueueManager`
   *
   * @param {function} callback
   */
  function start (callback) {
    dialQueueManager.start()
    callback()
  }

  /**
   * Aborts all dials that are queued. This should
   * only be used when the Switch is being stopped
   *
   * @param {function} callback
   */
  function stop (callback) {
    dialQueueManager.stop()
    callback()
  }

  /**
   * Clears the blacklist for a given peer
   * @param {PeerInfo} peerInfo
   */
  function clearBlacklist (peerInfo) {
    dialQueueManager.clearBlacklist(peerInfo)
  }

  /**
   * Attempts to establish a connection to the given `peerInfo` at
   * a lower priority than a standard dial.
   * @param {PeerInfo} peerInfo
   * @param {object} options
   * @param {boolean} options.useFSM Whether or not to return a `ConnectionFSM`. Defaults to false.
   * @param {number} options.priority Lowest priority goes first. Defaults to 20.
   * @param {function(Error, Connection)} callback
   */
  function connect (peerInfo, options, callback) {
    if (typeof options === 'function') {
      callback = options
      options = null
    }
    options = { useFSM: false, priority: PRIORITY_LOW, ...options }
    _dial({ peerInfo, protocol: null, options, callback })
  }

  /**
   * Adds the dial request to the queue for the given `peerInfo`
   * The request will be added with a high priority (10).
   * @param {PeerInfo} peerInfo
   * @param {string} protocol
   * @param {function(Error, Connection)} callback
   */
  function dial (peerInfo, protocol, callback) {
    _dial({ peerInfo, protocol, options: { useFSM: false, priority: PRIORITY_HIGH }, callback })
  }

  /**
   * Behaves like dial, except it calls back with a ConnectionFSM
   *
   * @param {PeerInfo} peerInfo
   * @param {string} protocol
   * @param {function(Error, ConnectionFSM)} callback
   */
  function dialFSM (peerInfo, protocol, callback) {
    _dial({ peerInfo, protocol, options: { useFSM: true, priority: PRIORITY_HIGH }, callback })
  }

  return {
    connect,
    dial,
    dialFSM,
    clearBlacklist,
    BLACK_LIST_ATTEMPTS: isNaN(_switch._options.blackListAttempts) ? BLACK_LIST_ATTEMPTS : _switch._options.blackListAttempts,
    BLACK_LIST_TTL: isNaN(_switch._options.blacklistTTL) ? BLACK_LIST_TTL : _switch._options.blacklistTTL,
    MAX_COLD_CALLS: isNaN(_switch._options.maxColdCalls) ? MAX_COLD_CALLS : _switch._options.maxColdCalls,
    MAX_PARALLEL_DIALS: isNaN(_switch._options.maxParallelDials) ? MAX_PARALLEL_DIALS : _switch._options.maxParallelDials
  }
}

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/dialer/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/manager.js", {"../connection":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/index.js","../plaintext":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/plaintext.js","../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/utils.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","libp2p-circuit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-circuit/src/index.js","libp2p-identify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-identify/src/index.js","multistream-select":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multistream-select/src/index.js","once":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/once/once.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/manager.js
      return function (require, module, exports) {
'use strict'

const identify = require('libp2p-identify')
const multistream = require('multistream-select')
const debug = require('debug')
const log = debug('libp2p:switch:conn-manager')
const once = require('once')
const ConnectionFSM = require('../connection')
const { msHandle, msSelect, identifyDialer } = require('../utils')

const Circuit = require('libp2p-circuit')

const plaintext = require('../plaintext')

/**
 * Contains methods for binding handlers to the Switch
 * in order to better manage its connections.
 */
class ConnectionManager {
  constructor (_switch) {
    this.switch = _switch
    this.connections = {}
  }

  /**
   * Adds the connection for tracking if it's not already added
   * @private
   * @param {ConnectionFSM} connection
   * @returns {void}
   */
  add (connection) {
    this.connections[connection.theirB58Id] = this.connections[connection.theirB58Id] || []
    // Only add it if it's not there
    if (!this.get(connection)) {
      this.connections[connection.theirB58Id].push(connection)
      this.switch.emit('connection:start', connection.theirPeerInfo)
      if (connection.getState() === 'MUXED') {
        this.switch.emit('peer-mux-established', connection.theirPeerInfo)
        // Clear the blacklist of the peer
        this.switch.dialer.clearBlacklist(connection.theirPeerInfo)
      } else {
        connection.once('muxed', () => {
          this.switch.emit('peer-mux-established', connection.theirPeerInfo)
          // Clear the blacklist of the peer
          this.switch.dialer.clearBlacklist(connection.theirPeerInfo)
        })
      }
    }
  }

  /**
   * Gets the connection from the list if it exists
   * @private
   * @param {ConnectionFSM} connection
   * @returns {ConnectionFSM|null} The found connection or null
   */
  get (connection) {
    if (!this.connections[connection.theirB58Id]) return null

    for (let i = 0; i < this.connections[connection.theirB58Id].length; i++) {
      if (this.connections[connection.theirB58Id][i] === connection) {
        return this.connections[connection.theirB58Id][i]
      }
    }
    return null
  }

  /**
   * Gets a connection associated with the given peer
   * @private
   * @param {string} peerId The peers id
   * @returns {ConnectionFSM|null} The found connection or null
   */
  getOne (peerId) {
    if (this.connections[peerId]) {
      // Only return muxed connections
      for (var i = 0; i < this.connections[peerId].length; i++) {
        if (this.connections[peerId][i].getState() === 'MUXED') {
          return this.connections[peerId][i]
        }
      }
    }
    return null
  }

  /**
   * Removes the connection from tracking
   * @private
   * @param {ConnectionFSM} connection The connection to remove
   * @returns {void}
   */
  remove (connection) {
    // No record of the peer, disconnect it
    if (!this.connections[connection.theirB58Id]) {
      if (connection.theirPeerInfo) {
        connection.theirPeerInfo.disconnect()
        this.switch.emit('peer-mux-closed', connection.theirPeerInfo)
      }
      return
    }

    for (let i = 0; i < this.connections[connection.theirB58Id].length; i++) {
      if (this.connections[connection.theirB58Id][i] === connection) {
        this.connections[connection.theirB58Id].splice(i, 1)
        break
      }
    }

    // The peer is fully disconnected
    if (this.connections[connection.theirB58Id].length === 0) {
      delete this.connections[connection.theirB58Id]
      connection.theirPeerInfo.disconnect()
      this.switch.emit('peer-mux-closed', connection.theirPeerInfo)
    }

    // A tracked connection was closed, let the world know
    this.switch.emit('connection:end', connection.theirPeerInfo)
  }

  /**
   * Returns all connections being tracked
   * @private
   * @returns {ConnectionFSM[]}
   */
  getAll () {
    let connections = []
    for (const conns of Object.values(this.connections)) {
      connections = [...connections, ...conns]
    }
    return connections
  }

  /**
   * Returns all connections being tracked for a given peer id
   * @private
   * @param {string} peerId Stringified peer id
   * @returns {ConnectionFSM[]}
   */
  getAllById (peerId) {
    return this.connections[peerId] || []
  }

  /**
   * Adds a listener for the given `muxer` and creates a handler for it
   * leveraging the Switch.protocolMuxer handler factory
   *
   * @param {Muxer} muxer
   * @returns {void}
   */
  addStreamMuxer (muxer) {
    // for dialing
    this.switch.muxers[muxer.multicodec] = muxer

    // for listening
    this.switch.handle(muxer.multicodec, (protocol, conn) => {
      const muxedConn = muxer.listener(conn)

      muxedConn.on('stream', this.switch.protocolMuxer(null))

      // If identify is enabled
      //   1. overload getPeerInfo
      //   2. call getPeerInfo
      //   3. add this conn to the pool
      if (this.switch.identify) {
        // Get the peer info from the crypto exchange
        conn.getPeerInfo((err, cryptoPI) => {
          if (err || !cryptoPI) {
            log('crypto peerInfo wasnt found')
          }

          // overload peerInfo to use Identify instead
          conn.getPeerInfo = async (callback) => {
            const conn = muxedConn.newStream()
            const ms = new multistream.Dialer()
            callback = once(callback)

            let results
            try {
              await msHandle(ms, conn)
              const msConn = await msSelect(ms, identify.multicodec)
              results = await identifyDialer(msConn, cryptoPI)
            } catch (err) {
              return muxedConn.end(() => {
                callback(err, null)
              })
            }

            const { peerInfo } = results

            if (peerInfo) {
              conn.setPeerInfo(peerInfo)
            }
            callback(null, peerInfo)
          }

          conn.getPeerInfo((err, peerInfo) => {
            /* eslint no-warning-comments: off */
            if (err) {
              return log('identify not successful')
            }
            const b58Str = peerInfo.id.toB58String()
            peerInfo = this.switch._peerBook.put(peerInfo)

            const connection = new ConnectionFSM({
              _switch: this.switch,
              peerInfo,
              muxer: muxedConn,
              conn: conn,
              type: 'inc'
            })
            this.switch.connection.add(connection)

            // Only update if it's not already connected
            if (!peerInfo.isConnected()) {
              if (peerInfo.multiaddrs.size > 0) {
                // with incomming conn and through identify, going to pick one
                // of the available multiaddrs from the other peer as the one
                // I'm connected to as we really can't be sure at the moment
                // TODO add this consideration to the connection abstraction!
                peerInfo.connect(peerInfo.multiaddrs.toArray()[0])
              } else {
                // for the case of websockets in the browser, where peers have
                // no addr, use just their IPFS id
                peerInfo.connect(`/ipfs/${b58Str}`)
              }
            }

            muxedConn.once('close', () => {
              connection.close()
            })
          })
        })
      }

      return conn
    })
  }

  /**
   * Adds the `encrypt` handler for the given `tag` and also sets the
   * Switch's crypto to passed `encrypt` function
   *
   * @param {String} tag
   * @param {function(PeerID, Connection, PeerId, Callback)} encrypt
   * @returns {void}
   */
  crypto (tag, encrypt) {
    if (!tag && !encrypt) {
      tag = plaintext.tag
      encrypt = plaintext.encrypt
    }

    this.switch.crypto = { tag, encrypt }
  }

  /**
   * If config.enabled is true, a Circuit relay will be added to the
   * available Switch transports.
   *
   * @param {any} config
   * @returns {void}
   */
  enableCircuitRelay (config) {
    config = config || {}

    if (config.enabled) {
      if (!config.hop) {
        Object.assign(config, { hop: { enabled: false, active: false } })
      }

      this.switch.transport.add(Circuit.tag, new Circuit(this.switch, config))
    }
  }

  /**
   * Sets identify to true on the Switch and performs handshakes
   * for libp2p-identify leveraging the Switch's muxer.
   *
   * @returns {void}
   */
  reuse () {
    this.switch.identify = true
    this.switch.handle(identify.multicodec, (protocol, conn) => {
      identify.listener(conn, this.switch._peerInfo)
    })
  }
}

module.exports = ConnectionManager

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/manager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/transport.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/constants.js","./limit-dialer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/limit-dialer/index.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/utils.js","async/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/parallel.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","once":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/once/once.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/transport.js
      return function (require, module, exports) {
'use strict'

/* eslint no-warning-comments: off */

const parallel = require('async/parallel')
const once = require('once')
const debug = require('debug')
const log = debug('libp2p:switch:transport')

const LimitDialer = require('./limit-dialer')
const { DIAL_TIMEOUT } = require('./constants')
const { uniqueBy } = require('./utils')

// number of concurrent outbound dials to make per peer, same as go-libp2p-swtch
const defaultPerPeerRateLimit = 8

/**
 * Manages the transports for the switch. This simplifies dialing and listening across
 * multiple transports.
 */
class TransportManager {
  constructor (_switch) {
    this.switch = _switch
    this.dialer = new LimitDialer(defaultPerPeerRateLimit, this.switch._options.dialTimeout || DIAL_TIMEOUT)
  }

  /**
   * Adds a `Transport` to the list of transports on the switch, and assigns it to the given key
   *
   * @param {String} key
   * @param {Transport} transport
   * @returns {void}
   */
  add (key, transport) {
    log('adding %s', key)
    if (this.switch.transports[key]) {
      throw new Error('There is already a transport with this key')
    }

    this.switch.transports[key] = transport
    if (!this.switch.transports[key].listeners) {
      this.switch.transports[key].listeners = []
    }
  }

  /**
   * Closes connections for the given transport key
   * and removes it from the switch.
   *
   * @param {String} key
   * @param {function(Error)} callback
   * @returns {void}
   */
  remove (key, callback) {
    callback = callback || function () {}

    if (!this.switch.transports[key]) {
      return callback()
    }

    this.close(key, (err) => {
      delete this.switch.transports[key]
      callback(err)
    })
  }

  /**
   * Calls `remove` on each transport the switch has
   *
   * @param {function(Error)} callback
   * @returns {void}
   */
  removeAll (callback) {
    const tasks = Object.keys(this.switch.transports).map((key) => {
      return (cb) => {
        this.remove(key, cb)
      }
    })

    parallel(tasks, callback)
  }

  /**
   * For a given transport `key`, dial to all that transport multiaddrs
   *
   * @param {String} key Key of the `Transport` to dial
   * @param {PeerInfo} peerInfo
   * @param {function(Error, Connection)} callback
   * @returns {void}
   */
  dial (key, peerInfo, callback) {
    const transport = this.switch.transports[key]
    let multiaddrs = peerInfo.multiaddrs.toArray()

    if (!Array.isArray(multiaddrs)) {
      multiaddrs = [multiaddrs]
    }

    // filter the multiaddrs that are actually valid for this transport
    multiaddrs = TransportManager.dialables(transport, multiaddrs, this.switch._peerInfo)
    log('dialing %s', key, multiaddrs.map((m) => m.toString()))

    // dial each of the multiaddrs with the given transport
    this.dialer.dialMany(peerInfo.id, transport, multiaddrs, (errors, success) => {
      if (errors) {
        return callback(errors)
      }

      peerInfo.connect(success.multiaddr)
      callback(null, success.conn)
    })
  }

  /**
   * For a given Transport `key`, listen on all multiaddrs in the switch's `_peerInfo`.
   * If a `handler` is not provided, the Switch's `protocolMuxer` will be used.
   *
   * @param {String} key
   * @param {*} _options Currently ignored
   * @param {function(Connection)} handler
   * @param {function(Error)} callback
   * @returns {void}
   */
  listen (key, _options, handler, callback) {
    handler = this.switch._connectionHandler(key, handler)

    const transport = this.switch.transports[key]
    let originalAddrs = this.switch._peerInfo.multiaddrs.toArray()

    // Until TCP can handle distinct addresses on listen, https://github.com/libp2p/interface-transport/issues/41,
    // make sure we aren't trying to listen on duplicate ports. This also applies to websockets.
    originalAddrs = uniqueBy(originalAddrs, (addr) => {
      // Any non 0 port should register as unique
      const port = Number(addr.toOptions().port)
      return isNaN(port) || port === 0 ? addr.toString() : port
    })

    const multiaddrs = TransportManager.dialables(transport, originalAddrs)

    if (!transport.listeners) {
      transport.listeners = []
    }

    let freshMultiaddrs = []

    const createListeners = multiaddrs.map((ma) => {
      return (cb) => {
        const done = once(cb)
        const listener = transport.createListener(handler)
        listener.once('error', done)

        listener.listen(ma, (err) => {
          if (err) {
            return done(err)
          }
          listener.removeListener('error', done)
          listener.getAddrs((err, addrs) => {
            if (err) {
              return done(err)
            }
            freshMultiaddrs = freshMultiaddrs.concat(addrs)
            transport.listeners.push(listener)
            done()
          })
        })
      }
    })

    parallel(createListeners, (err) => {
      if (err) {
        return callback(err)
      }

      // cause we can listen on port 0 or 0.0.0.0
      this.switch._peerInfo.multiaddrs.replace(multiaddrs, freshMultiaddrs)
      callback()
    })
  }

  /**
   * Closes the transport with the given key, by closing all of its listeners
   *
   * @param {String} key
   * @param {function(Error)} callback
   * @returns {void}
   */
  close (key, callback) {
    const transport = this.switch.transports[key]

    if (!transport) {
      return callback(new Error(`Trying to close non existing transport: ${key}`))
    }

    parallel(transport.listeners.map((listener) => {
      return (cb) => {
        listener.close(cb)
      }
    }), callback)
  }

  /**
   * For a given transport, return its multiaddrs that match the given multiaddrs
   *
   * @param {Transport} transport
   * @param {Array<Multiaddr>} multiaddrs
   * @param {PeerInfo} peerInfo Optional - a peer whose addresses should not be returned
   * @returns {Array<Multiaddr>}
   */
  static dialables (transport, multiaddrs, peerInfo) {
    // If we dont have a proper transport, return no multiaddrs
    if (!transport || !transport.filter) return []

    const transportAddrs = transport.filter(multiaddrs)
    if (!peerInfo || !transportAddrs.length) {
      return transportAddrs
    }

    const ourAddrs = ourAddresses(peerInfo)

    const result = transportAddrs.filter(transportAddr => {
      // If our address is in the destination address, filter it out
      return !ourAddrs.some(a => getDestination(transportAddr).startsWith(a))
    })

    return result
  }
}

/**
 * Expand addresses in peer info into array of addresses with and without peer
 * ID suffix.
 *
 * @param {PeerInfo} peerInfo Our peer info object
 * @returns {String[]}
 */
function ourAddresses (peerInfo) {
  const ourPeerId = peerInfo.id.toB58String()
  return peerInfo.multiaddrs.toArray()
    .reduce((ourAddrs, addr) => {
      const peerId = addr.getPeerId()
      addr = addr.toString()
      const otherAddr = peerId
        ? addr.slice(0, addr.lastIndexOf(`/ipfs/${peerId}`))
        : `${addr}/ipfs/${ourPeerId}`
      return ourAddrs.concat([addr, otherAddr])
    }, [])
    .filter(a => Boolean(a))
    .concat(`/ipfs/${ourPeerId}`)
}

const RelayProtos = [
  'p2p-circuit',
  'p2p-websocket-star',
  'p2p-webrtc-star',
  'p2p-stardust'
]

/**
 * Get the destination address of a (possibly relay) multiaddr as a string
 *
 * @param {Multiaddr} addr
 * @returns {String}
 */
function getDestination (addr) {
  const protos = addr.protoNames().reverse()
  const splitProto = protos.find(p => RelayProtos.includes(p))
  addr = addr.toString()
  if (!splitProto) return addr
  return addr.slice(addr.lastIndexOf(splitProto) + splitProto.length)
}

module.exports = TransportManager

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/transport.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-circuit/src/index.js", {"./circuit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-circuit/src/circuit.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-circuit/src/index.js
      return function (require, module, exports) {
'use strict'

module.exports = require('./circuit')

      };
    };
  }
}, {package:"libp2p-circuit",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-circuit/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/protocol-muxer.js", {"./observe-connection":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/observe-connection.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","multistream-select":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multistream-select/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/protocol-muxer.js
      return function (require, module, exports) {
'use strict'

const multistream = require('multistream-select')
const observeConn = require('./observe-connection')

const debug = require('debug')
const log = debug('libp2p:switch:protocol-muxer')
log.error = debug('libp2p:switch:protocol-muxer:error')

module.exports = function protocolMuxer (protocols, observer) {
  return (transport) => (_parentConn, msListener) => {
    const ms = msListener || new multistream.Listener()
    let parentConn

    // Only observe the transport if we have one, and there is not already a listener
    if (transport && !msListener) {
      parentConn = observeConn(transport, null, _parentConn, observer)
    } else {
      parentConn = _parentConn
    }

    Object.keys(protocols).forEach((protocol) => {
      if (!protocol) {
        return
      }

      const handler = (protocolName, _conn) => {
        log('registering handler with protocol %s', protocolName)
        const protocol = protocols[protocolName]
        if (protocol) {
          const handlerFunc = protocol && protocol.handlerFunc
          if (handlerFunc) {
            const conn = observeConn(null, protocolName, _conn, observer)
            handlerFunc(protocol, conn)
          }
        }
      }

      ms.addHandler(protocol, handler, protocols[protocol].matchFunc)
    })

    ms.handle(parentConn, (err) => {
      if (err) {
        log.error(`multistream handshake failed`, err)
      }
    })
  }
}

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/protocol-muxer.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/dag-cbor.js", {"cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/dag-cbor.js
      return function (require, module, exports) {
'use strict'

const CID = require('cids')
const errCode = require('err-code')

const resolve = async (cid, name, path, toResolve, resolve, depth, ipld) => {
  let node = await ipld.get(cid)
  let subObject = node
  let subPath = path

  while (toResolve.length) {
    const prop = toResolve[0]

    if (prop in subObject) {
      // remove the bit of the path we have resolved
      toResolve.shift()
      subPath = `${subPath}/${prop}`

      if (CID.isCID(subObject[prop])) {
        return {
          entry: {
            name,
            path,
            cid,
            node,
            depth
          },
          next: {
            cid: subObject[prop],
            name: prop,
            path: subPath,
            toResolve
          }
        }
      }

      subObject = subObject[prop]
    } else {
      // cannot resolve further
      throw errCode(new Error(`No property named ${prop} found in cbor node ${cid.toBaseEncodedString()}`), 'ERR_NO_PROP')
    }
  }

  return {
    entry: {
      name,
      path,
      cid,
      node,
      depth
    }
  }
}

module.exports = resolve

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/dag-cbor.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/raw.js", {"../utils/extract-data-from-block":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/utils/extract-data-from-block.js","../utils/validate-offset-and-length":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/utils/validate-offset-and-length.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/raw.js
      return function (require, module, exports) {
'use strict'

const errCode = require('err-code')
const extractDataFromBlock = require('../utils/extract-data-from-block')
const validateOffsetAndLength = require('../utils/validate-offset-and-length')

const rawContent = (node) => {
  return function * (options = {}) {
    const {
      offset,
      length
    } = validateOffsetAndLength(node.length, options.offset, options.length)

    yield extractDataFromBlock(node, 0, offset, offset + length)
  }
}

const resolve = async (cid, name, path, toResolve, resolve, depth, ipld) => {
  if (toResolve.length) {
    throw errCode(new Error(`No link named ${path} found in raw node ${cid.toBaseEncodedString()}`), 'ERR_NOT_FOUND')
  }

  const buf = await ipld.get(cid)

  return {
    entry: {
      name,
      path,
      cid,
      node: buf,
      content: rawContent(buf),
      depth
    }
  }
}

module.exports = resolve

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/raw.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.js", {"../../utils/find-cid-in-shard":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.js","./content/directory":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/directory.js","./content/file":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/file.js","./content/hamt-sharded-directory":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipfs-unixfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.js
      return function (require, module, exports) {
'use strict'

const errCode = require('err-code')
const UnixFS = require('ipfs-unixfs')
const findShardCid = require('../../utils/find-cid-in-shard')

const findLinkCid = (node, name) => {
  const link = node.Links.find(link => link.Name === name)

  return link && link.Hash
}

const contentExporters = {
  raw: require('./content/file'),
  file: require('./content/file'),
  directory: require('./content/directory'),
  'hamt-sharded-directory': require('./content/hamt-sharded-directory'),
  metadata: (cid, node, unixfs, path, resolve, depth, ipld) => {},
  symlink: (cid, node, unixfs, path, resolve, depth, ipld) => {}
}

const unixFsResolver = async (cid, name, path, toResolve, resolve, depth, ipld) => {
  const node = await ipld.get(cid)
  let unixfs
  let next

  if (!name) {
    name = cid.toBaseEncodedString()
  }

  try {
    unixfs = UnixFS.unmarshal(node.Data)
  } catch (err) {
    // non-UnixFS dag-pb node? It could happen.
    throw errCode(err, 'ERR_NOT_UNIXFS')
  }

  if (!path) {
    path = name
  }

  if (toResolve.length) {
    let linkCid

    if (unixfs && unixfs.type === 'hamt-sharded-directory') {
      // special case - unixfs v1 hamt shards
      linkCid = await findShardCid(node, toResolve[0], ipld)
    } else {
      linkCid = findLinkCid(node, toResolve[0])
    }

    if (!linkCid) {
      throw errCode(new Error(`file does not exist`), 'ERR_NOT_FOUND')
    }

    // remove the path component we have resolved
    const nextName = toResolve.shift()
    const nextPath = `${path}/${nextName}`

    next = {
      cid: linkCid,
      toResolve,
      name: nextName,
      path: nextPath
    }
  }

  return {
    entry: {
      name,
      path,
      cid,
      node,
      content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, ipld),
      unixfs,
      depth
    },
    next
  }
}

module.exports = unixFsResolver

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/pipeline.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/errors-browser.js","./end-of-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/pipeline.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/pipeline.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_duplex.js", {"./_stream_readable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_writable.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_duplex.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_duplex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_passthrough.js", {"./_stream_transform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_transform.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_passthrough.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_passthrough.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_transform.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_duplex.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_transform.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_transform.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_writable.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_duplex.js","./internal/streams/destroy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/state.js","./internal/streams/stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/stream-browser.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","util-deprecate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/util-deprecate/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_writable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_writable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_readable.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_duplex.js","./internal/streams/async_iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/async_iterator.js","./internal/streams/buffer_list":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/buffer_list.js","./internal/streams/destroy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/from":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/from-browser.js","./internal/streams/state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/state.js","./internal/streams/stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/stream-browser.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","string_decoder/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/string_decoder/lib/string_decoder.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_readable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_readable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir.js
      return function (require, module, exports) {
'use strict'

module.exports = class Dir {
  constructor (props, options) {
    this.options = options || {}
    Object.assign(this, props)
  }
}

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/utils/to-path-components.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/utils/to-path-components.js
      return function (require, module, exports) {
'use strict'

const toPathComponents = (path = '') => {
  // split on / unless escaped with \
  return (path
    .trim()
    .match(/([^\\^/]|\\\/)+/g) || [])
    .filter(Boolean)
}

module.exports = toPathComponents

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/utils/to-path-components.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-first/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-first/index.js
      return function (require, module, exports) {
'use strict'

const first = async (iterator) => {
  for await (const entry of iterator) {
    return entry
  }
}

module.exports = first

      };
    };
  }
}, {package:"async-iterator-first",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-first/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir-flat.js", {"./dir":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir.js","./utils/persist":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/utils/persist.js","ipfs-unixfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir-flat.js
      return function (require, module, exports) {
'use strict'

const {
  DAGLink,
  DAGNode
} = require('ipld-dag-pb')
const UnixFS = require('ipfs-unixfs')
const Dir = require('./dir')
const persist = require('./utils/persist')

class DirFlat extends Dir {
  constructor (props, options) {
    super(props, options)
    this._children = {}
  }

  put (name, value) {
    this.cid = undefined
    this.size = undefined
    this._children[name] = value
  }

  get (name) {
    return this._children[name]
  }

  childCount () {
    return Object.keys(this._children).length
  }

  directChildrenCount () {
    return this.childCount()
  }

  onlyChild () {
    return this._children[Object.keys(this._children)[0]]
  }

  * eachChildSeries () {
    const keys = Object.keys(this._children)

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i]

      yield {
        key: key,
        child: this._children[key]
      }
    }
  }

  async * flush (path, ipld) {
    const children = Object.keys(this._children)
    const links = []

    for (let i = 0; i < children.length; i++) {
      let child = this._children[children[i]]

      if (typeof child.flush === 'function') {
        for await (const entry of child.flush(child.path, ipld)) {
          child = entry

          yield child
        }
      }

      links.push(new DAGLink(children[i], child.node.length || child.node.size, child.cid))
    }

    const unixfs = new UnixFS('directory')
    let node = DAGNode.create(unixfs.marshal(), links)
    const cid = await persist(node, ipld, this.options)

    this.cid = cid
    this.size = node.size

    yield {
      cid,
      unixfs,
      path,
      node
    }
  }
}

module.exports = DirFlat

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir-flat.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/flat-to-shard.js", {"./dir-sharded":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir-sharded.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/flat-to-shard.js
      return function (require, module, exports) {
'use strict'

const DirSharded = require('./dir-sharded')

module.exports = async function flatToShard (child, dir, threshold, options) {
  let newDir = dir

  if (dir.flat && dir.directChildrenCount() >= threshold) {
    newDir = await convertToShard(dir, options)
  }

  const parent = newDir.parent

  if (parent) {
    if (newDir !== dir) {
      if (child) {
        child.parent = newDir
      }

      await parent.put(newDir.parentKey, newDir)
    }

    if (parent) {
      return flatToShard(newDir, parent, threshold, options)
    }
  }

  return newDir
}

async function convertToShard (oldDir, options) {
  const newDir = new DirSharded({
    root: oldDir.root,
    dir: true,
    parent: oldDir.parent,
    parentKey: oldDir.parentKey,
    path: oldDir.path,
    dirty: oldDir.dirty,
    flat: false
  }, options)

  for await (const { key, child } of oldDir.eachChildSeries()) {
    await newDir.put(key, child)
  }

  return newDir
}

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/flat-to-shard.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/validate-chunks.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/validate-chunks.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const errCode = require('err-code')

// make sure the content only emits buffer-a-likes
async function * validateChunks (source) {
  for await (const content of source) {
    if (content.length === undefined) {
      throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT')
    }

    if (typeof content === 'string' || content instanceof String) {
      yield Buffer.from(content, 'utf8')
    } else if (Array.isArray(content)) {
      yield Buffer.from(content)
    } else {
      yield content
    }
  }
}

module.exports = validateChunks

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/validate-chunks.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/dir.js", {"../utils/persist":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/utils/persist.js","ipfs-unixfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/dir.js
      return function (require, module, exports) {
'use strict'

const UnixFS = require('ipfs-unixfs')
const persist = require('../utils/persist')
const {
  DAGNode
} = require('ipld-dag-pb')

const dirBuilder = async (item, ipld, options) => {
  const unixfs = new UnixFS('directory')
  const node = DAGNode.create(unixfs.marshal(), [])
  const cid = await persist(node, ipld, options)
  let path = item.path

  return {
    cid,
    path,
    unixfs,
    node
  }
}

module.exports = dirBuilder

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/dir.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/index.js", {"../../utils/persist":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/utils/persist.js","./balanced":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/balanced.js","./flat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/flat.js","./trickle":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/trickle.js","async-iterator-all":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-all/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipfs-unixfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/index.js
      return function (require, module, exports) {
'use strict'

const errCode = require('err-code')
const UnixFS = require('ipfs-unixfs')
const persist = require('../../utils/persist')
const {
  DAGNode,
  DAGLink
} = require('ipld-dag-pb')
const all = require('async-iterator-all')

const dagBuilders = {
  flat: require('./flat'),
  balanced: require('./balanced'),
  trickle: require('./trickle')
}

async function * buildFile (source, ipld, options) {
  let count = -1
  let previous

  for await (const buffer of source) {
    count++
    options.progress(buffer.length)
    let node
    let unixfs

    let opts = {
      ...options
    }

    if (options.rawLeaves) {
      node = buffer

      opts.codec = 'raw'
      opts.cidVersion = 1
    } else {
      unixfs = new UnixFS(options.leafType, buffer)
      node = DAGNode.create(unixfs.marshal(), [])
    }

    const cid = await persist(node, ipld, opts)

    const entry = {
      cid: cid,
      unixfs,
      node
    }

    if (count === 0) {
      previous = entry
      continue
    } else if (count === 1) {
      yield previous
      previous = null
    }

    yield entry
  }

  if (previous) {
    previous.single = true
    yield previous
  }
}

const reduce = (file, ipld, options) => {
  return async function (leaves) {
    if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {
      const leaf = leaves[0]

      return {
        cid: leaf.cid,
        path: file.path,
        name: (file.path || '').split('/').pop(),
        unixfs: leaf.unixfs,
        node: leaf.node
      }
    }

    // create a parent node and add all the leaves
    const f = new UnixFS('file')

    const links = leaves
      .filter(leaf => {
        if (leaf.cid.codec === 'raw' && leaf.node.length) {
          return true
        }

        if (!leaf.unixfs.data && leaf.unixfs.fileSize()) {
          return true
        }

        return Boolean(leaf.unixfs.data.length)
      })
      .map((leaf) => {
        if (leaf.cid.codec === 'raw') {
          // node is a leaf buffer
          f.addBlockSize(leaf.node.length)

          return new DAGLink(leaf.name, leaf.node.length, leaf.cid)
        }

        if (!leaf.unixfs.data) {
          // node is an intermediate node
          f.addBlockSize(leaf.unixfs.fileSize())
        } else {
          // node is a unixfs 'file' leaf node
          f.addBlockSize(leaf.unixfs.data.length)
        }

        return new DAGLink(leaf.name, leaf.node.size, leaf.cid)
      })

    const node = DAGNode.create(f.marshal(), links)
    const cid = await persist(node, ipld, options)

    return {
      cid,
      path: file.path,
      unixfs: f,
      node,
      size: node.size
    }
  }
}

const fileBuilder = async (file, source, ipld, options) => {
  const dagBuilder = dagBuilders[options.strategy]

  if (!dagBuilder) {
    throw errCode(new Error(`Unknown importer build strategy name: ${options.strategy}`), 'ERR_BAD_STRATEGY')
  }

  const roots = await all(dagBuilder(buildFile(source, ipld, options), reduce(file, ipld, options), options.builderOptions))

  if (roots.length > 1) {
    throw errCode(new Error('expected a maximum of 1 roots and got ' + roots.length), 'ETOOMANYROOTS')
  }

  return roots[0]
}

module.exports = fileBuilder

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/chunker/index.js", {"../chunker/fixed-size":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/chunker/fixed-size.js","../chunker/rabin":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/chunker/rabin.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/chunker/index.js
      return function (require, module, exports) {
'use strict'

const errCode = require('err-code')

const chunkers = {
  fixed: require('../chunker/fixed-size'),
  rabin: require('../chunker/rabin')
}

module.exports = (type, source, options) => {
  const chunker = chunkers[type]

  if (!chunker) {
    throw errCode(new Error(`Unknkown chunker named ${type}`), 'ERR_UNKNOWN_CHUNKER')
  }

  return chunker(source, options)
}

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/chunker/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/errors-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/errors-browser.js
      return function (require, module, exports) {
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/errors-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/destroy.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/destroy.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/destroy.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js", {"events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js
      return function (require, module, exports) {
module.exports = require('events').EventEmitter;

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/state.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/state.js
      return function (require, module, exports) {
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/state.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/from-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/from-browser.js
      return function (require, module, exports) {
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/from-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js
      return function (require, module, exports) {
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js", {"./end-of-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/apply-default-options.js", {"err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/apply-default-options.js
      return function (require, module, exports) {
'use strict'

const errCode = require('err-code')

module.exports = (options = {}, defaults) => {
  if (Array.isArray(options)) {
    options = options.filter(arg => typeof arg === 'object').pop() || {}
  }

  const output = {}

  for (let key in defaults) {
    if (options[key] !== null && options[key] !== undefined) {
      output[key] = options[key]
    } else {
      output[key] = defaults[key]
    }
  }

  const format = output.format || output.codec

  if (format && isNaN(format)) {
    output.format = format
    delete output.codec
  }

  // support legacy go arguments
  if (options.count !== undefined) {
    output.length = options.count
  }

  if (options.p !== undefined) {
    output.parents = options.p
  }

  if (options.l !== undefined) {
    output.long = options.l
  }

  if (!output.length && output.length !== 0) {
    output.length = Infinity
  }

  if (output.offset < 0) {
    throw errCode(new Error('cannot have negative write offset'), 'ERR_INVALID_PARAMS')
  }

  if (output.length < 0) {
    throw errCode(new Error('cannot have negative byte count'), 'ERR_INVALID_PARAMS')
  }

  return output
}

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/apply-default-options.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-mfs-path.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/constants.js","./to-path-components":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-path-components.js","./with-mfs-root":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/with-mfs-root.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipfs-unixfs-exporter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-mfs-path.js
      return function (require, module, exports) {
'use strict'

const {
  FILE_SEPARATOR
} = require('./constants')
const loadMfsRoot = require('./with-mfs-root')
const toPathComponents = require('./to-path-components')
const exporter = require('ipfs-unixfs-exporter')
const errCode = require('err-code')

const IPFS_PREFIX = 'ipfs'

const toMfsPath = async (context, path) => {
  let outputArray = Array.isArray(path)
  let paths = Array.isArray(path) ? path : [path]
  const root = await loadMfsRoot(context)

  paths = paths.map(path => {
    path = (path || '').trim()
    path = path.replace(/(\/\/+)/g, '/')

    if (path.endsWith('/') && path.length > 1) {
      path = path.substring(0, path.length - 1)
    }

    if (!path) {
      throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH')
    }

    if (path.substring(0, 1) !== FILE_SEPARATOR) {
      throw errCode(new Error(`paths must start with a leading ${FILE_SEPARATOR}`), 'ERR_INVALID_PATH')
    }

    if (path.substring(path.length - FILE_SEPARATOR.length) === FILE_SEPARATOR) {
      path = path.substring(0, path.length - FILE_SEPARATOR.length)
    }

    const pathComponents = toPathComponents(path)

    if (pathComponents[0] === IPFS_PREFIX) {
      // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path
      let mfsDirectory

      if (pathComponents.length === 2) {
        mfsDirectory = `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`
      } else {
        mfsDirectory = `${FILE_SEPARATOR}${pathComponents.slice(0, pathComponents.length - 1).join(FILE_SEPARATOR)}`
      }

      return {
        type: 'ipfs',
        depth: pathComponents.length - 2,

        mfsPath: `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`,
        mfsDirectory,
        parts: pathComponents,
        path: `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`,
        name: pathComponents[pathComponents.length - 1]
      }
    }

    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join(FILE_SEPARATOR) : ''}`
    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join(FILE_SEPARATOR)}`

    return {
      type: 'mfs',
      depth: pathComponents.length,

      mfsDirectory,
      mfsPath,
      parts: pathComponents,
      path: `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`,
      name: pathComponents[pathComponents.length - 1]
    }
  })

  await Promise.all(
    paths.map(async (path) => {
      const cidPath = path.type === 'mfs' ? path.mfsPath : path.path

      try {
        const res = await exporter(cidPath, context.ipld)

        path.cid = res.cid
        path.mfsPath = `/ipfs/${res.path}`
        path.unixfs = res.unixfs
        path.content = res.content
      } catch (err) {
        if (err.code !== 'ERR_NOT_FOUND') {
          throw err
        }
      }

      path.exists = Boolean(path.cid)
    })
  )

  if (outputArray) {
    return paths
  }

  return paths[0]
}

module.exports = toMfsPath

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-mfs-path.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/constants.js", {"interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/constants.js
      return function (require, module, exports) {
'use strict'

const Key = require('interface-datastore').Key

const FILE_TYPES = {
  file: 0,
  directory: 1,
  'hamt-sharded-directory': 1
}

module.exports = {
  FILE_SEPARATOR: '/',
  MFS_ROOT_KEY: new Key('/local/filesroot'),
  MAX_CHUNK_SIZE: 262144,
  MAX_LINKS: 174,
  FILE_TYPES
}

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-sources.js", {"./to-mfs-path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-mfs-path.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-sources.js
      return function (require, module, exports) {
'use strict'

const toMfsPath = require('./to-mfs-path')

async function toSources (context, args) {
  // Support weird mfs.mv([source, dest], options, callback) signature
  if (Array.isArray(args[0])) {
    args = args[0]
  }

  const sources = args
    .filter(arg => typeof arg === 'string')
    .map(source => source.trim())

  return {
    sources: await toMfsPath(context, sources)
  }
}

module.exports = toSources

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-sources.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/update-mfs-root.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/constants.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/update-mfs-root.js
      return function (require, module, exports) {
'use strict'

const log = require('debug')('ipfs:mfs:utils:update-mfs-root')
const {
  MFS_ROOT_KEY
} = require('./constants')

const updateMfsRoot = async (context, cid) => {
  log(`New MFS root will be ${cid}`)

  await context.repo.datastore.put(MFS_ROOT_KEY, cid.buffer)

  return cid
}

module.exports = updateMfsRoot

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/update-mfs-root.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/update-tree.js", {"./add-link":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/add-link.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/update-tree.js
      return function (require, module, exports) {
'use strict'

const log = require('debug')('ipfs:mfs:utils:update-tree')
const addLink = require('./add-link')

const defaultOptions = {
  shardSplitThreshold: 1000
}

// loop backwards through the trail, replacing links of all components to update CIDs
const updateTree = async (context, trail, options) => {
  options = Object.assign({}, defaultOptions, options)

  log('Trail', trail)
  trail = trail.slice().reverse()

  let index = 0
  let child

  for await (const node of context.ipld.getMany(trail.map(node => node.cid))) {
    const cid = trail[index].cid
    const name = trail[index].name
    index++

    if (!child) {
      child = {
        cid,
        name,
        size: node.size
      }

      continue
    }

    const result = await addLink(context, {
      parent: node,
      name: child.name,
      cid: child.cid,
      size: child.size,
      flush: options.flush,
      shardSplitThreshold: options.shardSplitThreshold,
      format: options.format,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion
    })

    // new child for next loop
    child = {
      cid: result.cid,
      name,
      size: result.node.size
    }
  }

  log(`Final CID ${child.cid}`)

  return child.cid
}

module.exports = updateTree

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/update-tree.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/add-link.js", {"./hamt-utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/hamt-utils.js","async-iterator-last":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-last/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipfs-unixfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js","ipfs-unixfs-importer/src/dir-sharded":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir-sharded.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/add-link.js
      return function (require, module, exports) {
'use strict'

const {
  DAGNode,
  DAGLink
} = require('ipld-dag-pb')
const CID = require('cids')
const log = require('debug')('ipfs:mfs:core:utils:add-link')
const UnixFS = require('ipfs-unixfs')
const DirSharded = require('ipfs-unixfs-importer/src/dir-sharded')
const {
  updateHamtDirectory,
  recreateHamtLevel,
  createShard,
  toPrefix,
  addLinksToHamtBucket
} = require('./hamt-utils')
const errCode = require('err-code')
const mc = require('multicodec')
const mh = require('multihashes')
const last = require('async-iterator-last')

const addLink = async (context, options) => {
  if (!options.parentCid && !options.parent) {
    throw errCode(new Error('No parent node or CID passed to addLink'), 'EINVALIDPARENT')
  }

  if (options.parentCid && !CID.isCID(options.parentCid)) {
    throw errCode(new Error('Invalid CID passed to addLink'), 'EINVALIDPARENTCID')
  }

  if (!options.parent) {
    log(`Loading parent node ${options.parentCid}`)

    options.parent = await context.ipld.get(options.parentCid)
  }

  if (!options.cid) {
    throw errCode(new Error('No child cid passed to addLink'), 'EINVALIDCHILDCID')
  }

  if (!options.name) {
    throw errCode(new Error('No child name passed to addLink'), 'EINVALIDCHILDNAME')
  }

  if (!CID.isCID(options.cid)) {
    options.cid = new CID(options.cid)
  }

  if (!options.size && options.size !== 0) {
    throw errCode(new Error('No child size passed to addLink'), 'EINVALIDCHILDSIZE')
  }

  const meta = UnixFS.unmarshal(options.parent.Data)

  if (meta.type === 'hamt-sharded-directory') {
    log('Adding link to sharded directory')

    return addToShardedDirectory(context, options)
  }

  if (options.parent.Links.length >= options.shardSplitThreshold) {
    log('Converting directory to sharded directory')

    return convertToShardedDirectory(context, options)
  }

  log(`Adding ${options.name} (${options.cid}) to regular directory`)

  return addToDirectory(context, options)
}

const convertToShardedDirectory = async (context, options) => {
  const result = await createShard(context, options.parent.Links.map(link => ({
    name: link.Name,
    size: link.Tsize,
    cid: link.Hash
  })).concat({
    name: options.name,
    size: options.size,
    cid: options.cid
  }), options)

  log(`Converted directory to sharded directory ${result.cid}`)

  return result
}

const addToDirectory = async (context, options) => {
  let parent = await DAGNode.rmLink(options.parent, options.name)
  parent = await DAGNode.addLink(parent, new DAGLink(options.name, options.size, options.cid))

  const format = mc[options.format.toUpperCase().replace(/-/g, '_')]
  const hashAlg = mh.names[options.hashAlg]

  // Persist the new parent DAGNode
  const cid = await context.ipld.put(parent, format, {
    cidVersion: options.cidVersion,
    hashAlg,
    hashOnly: !options.flush
  })

  return {
    node: parent,
    cid
  }
}

const addToShardedDirectory = async (context, options) => {
  const {
    shard, path
  } = await addFileToShardedDirectory(context, options)

  const result = await last(shard.flush('', context.ipld))

  // we have written out the shard, but only one sub-shard will have been written so replace it in the original shard
  const oldLink = options.parent.Links
    .find(link => link.Name.substring(0, 2) === path[0].prefix)

  const newLink = result.node.Links
    .find(link => link.Name.substring(0, 2) === path[0].prefix)

  let parent = options.parent

  if (oldLink) {
    parent = await DAGNode.rmLink(options.parent, oldLink.Name)
  }

  parent = await DAGNode.addLink(parent, newLink)

  return updateHamtDirectory(context, parent.Links, path[0].bucket, options)
}

const addFileToShardedDirectory = async (context, options) => {
  const file = {
    name: options.name,
    cid: options.cid,
    size: options.size
  }

  // start at the root bucket and descend, loading nodes as we go
  const rootBucket = await recreateHamtLevel(options.parent.Links)

  const shard = new DirSharded({
    root: true,
    dir: true,
    parent: null,
    parentKey: null,
    path: '',
    dirty: true,
    flat: false
  }, options)
  shard._bucket = rootBucket

  // load subshards until the bucket & position no longer changes
  const position = await rootBucket._findNewBucketAndPos(file.name)
  const path = toBucketPath(position)
  path[0].node = options.parent
  let index = 0

  while (index < path.length) {
    let segment = path[index]
    index++
    let node = segment.node

    let link = node.Links
      .find(link => link.Name.substring(0, 2) === segment.prefix)

    if (!link) {
      // prefix is new, file will be added to the current bucket
      log(`Link ${segment.prefix}${file.name} will be added`)
      index = path.length

      break
    }

    if (link.Name === `${segment.prefix}${file.name}`) {
      // file already existed, file will be added to the current bucket
      log(`Link ${segment.prefix}${file.name} will be replaced`)
      index = path.length

      break
    }

    if (link.Name.length > 2) {
      // another file had the same prefix, will be replaced with a subshard
      log(`Link ${link.Name} will be replaced with a subshard`)
      index = path.length

      break
    }

    // load sub-shard
    log(`Found subshard ${segment.prefix}`)
    const subShard = await context.ipld.get(link.Hash)

    // subshard hasn't been loaded, descend to the next level of the HAMT
    if (!path[index]) {
      log(`Loaded new subshard ${segment.prefix}`)
      await recreateHamtLevel(subShard.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16))

      const position = await rootBucket._findNewBucketAndPos(file.name)

      path.push({
        bucket: position.bucket,
        prefix: toPrefix(position.pos),
        node: subShard
      })

      break
    }

    const nextSegment = path[index]

    // add next level's worth of links to bucket
    await addLinksToHamtBucket(subShard.Links, nextSegment.bucket, rootBucket)

    nextSegment.node = subShard
  }

  // finally add the new file into the shard
  await shard._bucket.put(file.name, {
    size: file.size,
    cid: file.cid
  })

  return {
    shard, path
  }
}

const toBucketPath = (position) => {
  let bucket = position.bucket
  let positionInBucket = position.pos
  let path = [{
    bucket,
    prefix: toPrefix(positionInBucket)
  }]

  bucket = position.bucket._parent
  positionInBucket = position.bucket._posAtParent

  while (bucket) {
    path.push({
      bucket,
      prefix: toPrefix(positionInBucket)
    })

    positionInBucket = bucket._posAtParent
    bucket = bucket._parent
  }

  path.reverse()

  return path
}

module.exports = addLink

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/add-link.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-path-components.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-path-components.js
      return function (require, module, exports) {
'use strict'

const toPathComponents = (path = '') => {
  // split on / unless escaped with \
  return (path
    .trim()
    .match(/([^\\^/]|\\\/)+/g) || [])
    .filter(Boolean)
}

module.exports = toPathComponents

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-path-components.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/create-node.js", {"ipfs-unixfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/create-node.js
      return function (require, module, exports) {
'use strict'

const UnixFS = require('ipfs-unixfs')
const {
  DAGNode
} = require('ipld-dag-pb')
const mc = require('multicodec')
const mh = require('multihashes')

const createNode = async (context, type, options) => {
  const format = mc[options.format.toUpperCase().replace(/-/g, '_')]
  const hashAlg = mh.names[options.hashAlg]

  const node = DAGNode.create(new UnixFS(type).marshal())
  const cid = await context.ipld.put(node, format, {
    cidVersion: options.cidVersion,
    hashAlg
  })

  return {
    cid,
    node
  }
}

module.exports = createNode

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/create-node.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/with-mfs-root.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/constants.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","ipfs-unixfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/with-mfs-root.js
      return function (require, module, exports) {
'use strict'

const CID = require('cids')
const UnixFs = require('ipfs-unixfs')
const {
  DAGNode
} = require('ipld-dag-pb')
const log = require('debug')('ipfs:mfs:utils:with-mfs-root')
const mc = require('multicodec')
const mh = require('multihashes')

const {
  MFS_ROOT_KEY
} = require('./constants')

const loadMfsRoot = async (context) => {
  // Open the repo if it's been closed
  await context.repo.datastore.open()

  // Load the MFS root CID
  let cid

  try {
    const buf = await context.repo.datastore.get(MFS_ROOT_KEY)

    cid = new CID(buf)
  } catch (err) {
    if (err.code !== 'ERR_NOT_FOUND') {
      throw err
    }

    log('Creating new MFS root')
    const node = DAGNode.create(new UnixFs('directory').marshal())
    cid = await context.ipld.put(node, mc.DAG_PB, {
      cidVersion: 0,
      hashAlg: mh.names['sha2-256'] // why can't ipld look this up?
    })

    await context.repo.datastore.put(MFS_ROOT_KEY, cid.buffer)
  }

  log(`Loaded MFS root /ipfs/${cid}`)

  return cid
}

module.exports = loadMfsRoot

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/with-mfs-root.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-trail.js", {"debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","ipfs-unixfs-exporter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-trail.js
      return function (require, module, exports) {
'use strict'

const exporter = require('ipfs-unixfs-exporter')
const log = require('debug')('ipfs:mfs:utils:to-trail')

const toTrail = async (context, path) => {
  log(`Creating trail for path ${path}`)

  const output = []

  for await (const fsEntry of exporter.path(path, context.ipld)) {
    output.push({
      name: fsEntry.name,
      cid: fsEntry.cid,
      size: fsEntry.node.size,
      type: fsEntry.unixfs ? fsEntry.unixfs.type : undefined
    })
  }

  return output
}

module.exports = toTrail

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-trail.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/remove-link.js", {"./hamt-utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/hamt-utils.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipfs-unixfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/remove-link.js
      return function (require, module, exports) {
'use strict'

const {
  DAGNode,
  DAGLink
} = require('ipld-dag-pb')
const CID = require('cids')
const log = require('debug')('ipfs:mfs:core:utils:remove-link')
const UnixFS = require('ipfs-unixfs')
const {
  generatePath,
  updateHamtDirectory
} = require('./hamt-utils')
const errCode = require('err-code')
const mc = require('multicodec')
const mh = require('multihashes')

const removeLink = async (context, options) => {
  if (!options.parentCid && !options.parent) {
    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT')
  }

  if (options.parentCid && !CID.isCID(options.parentCid)) {
    throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID')
  }

  if (!options.parent) {
    log(`Loading parent node ${options.parentCid}`)

    options.parent = await context.ipld.get(options.parentCid)
  }

  if (!options.name) {
    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME')
  }

  const meta = UnixFS.unmarshal(options.parent.Data)

  if (meta.type === 'hamt-sharded-directory') {
    log(`Removing ${options.name} from sharded directory`)

    return removeFromShardedDirectory(context, options)
  }

  log(`Removing link ${options.name} regular directory`)

  return removeFromDirectory(context, options)
}

const removeFromDirectory = async (context, options) => {
  const format = mc[options.format.toUpperCase().replace(/-/g, '_')]
  const hashAlg = mh.names[options.hashAlg]

  const newParentNode = await DAGNode.rmLink(options.parent, options.name)
  const cid = await context.ipld.put(newParentNode, format, {
    cidVersion: options.cidVersion,
    hashAlg
  })

  log(`Updated regular directory ${cid}`)

  return {
    node: newParentNode,
    cid
  }
}

const removeFromShardedDirectory = async (context, options) => {
  const {
    rootBucket, path
  } = await generatePath(context, options.name, options.parent)

  await rootBucket.del(options.name)

  const {
    node
  } = await updateShard(context, path, {
    name: options.name,
    cid: options.cid,
    size: options.size,
    hashAlg: options.hashAlg,
    format: options.format,
    cidVersion: options.cidVersion,
    flush: options.flush
  }, options)

  return updateHamtDirectory(context, node.Links, rootBucket, options)
}

const updateShard = async (context, positions, child, options) => {
  const {
    bucket,
    prefix,
    node
  } = positions.pop()

  const link = node.Links
    .find(link => link.Name.substring(0, 2) === prefix)

  if (!link) {
    throw errCode(new Error(`No link found with prefix ${prefix} for file ${child.name}`), 'ERR_NOT_FOUND')
  }

  if (link.Name === `${prefix}${child.name}`) {
    log(`Removing existing link ${link.Name}`)

    const newNode = await DAGNode.rmLink(node, link.Name)

    await bucket.del(child.name)

    return updateHamtDirectory(context, newNode.Links, bucket, options)
  }

  log(`Descending into sub-shard ${link.Name} for ${prefix}${child.name}`)

  const result = await updateShard(context, positions, child, options)

  let newName = prefix

  if (result.node.Links.length === 1) {
    log(`Removing subshard for ${prefix}`)

    // convert shard back to normal dir
    result.cid = result.node.Links[0].Hash
    result.node = result.node.Links[0]

    newName = `${prefix}${result.node.Name.substring(2)}`
  }

  log(`Updating shard ${prefix} with name ${newName}`)

  const size = DAGNode.isDAGNode(result.node) ? result.node.size : result.node.Tsize

  return updateShardParent(context, bucket, node, prefix, newName, size, result.cid, options)
}

const updateShardParent = async (context, bucket, parent, oldName, newName, size, cid, options) => {
  parent = await DAGNode.rmLink(parent, oldName)
  parent = await DAGNode.addLink(parent, new DAGLink(newName, size, cid))

  return updateHamtDirectory(context, parent.Links, bucket, options)
}

module.exports = removeLink

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/remove-link.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-async-iterator.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/constants.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","fs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-async-iterator.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const errCode = require('err-code')
const fs = require('fs')
const log = require('debug')('ipfs:mfs:utils:to-async-iterator')
const {
  MAX_CHUNK_SIZE
} = require('./constants')

const toAsyncIterator = async (content) => {
  if (!content) {
    throw errCode(new Error('paths must start with a leading /'), 'ERR_INVALID_PATH')
  }

  if (typeof content === 'string' || content instanceof String) {
    // Paths, node only
    log('Content was a path')

    return fs.createReadStream(content)
  }

  if (content.length) {
    log('Content was array-like')

    return {
      [Symbol.asyncIterator]: async function * bufferContent () {
        yield content
      }
    }
  }

  if (content[Symbol.asyncIterator]) {
    log('Content was an async iterator')
    return content
  }

  if (content[Symbol.iterator]) {
    log('Content was an iterator')
    return content
  }

  if (global.Blob && content instanceof global.Blob) {
    // HTML5 Blob objects (including Files)
    log('Content was an HTML5 Blob')

    let index = 0

    const iterator = {
      next: async () => {
        if (index > content.size) {
          return {
            done: true
          }
        }

        return new Promise((resolve, reject) => {
          const chunk = content.slice(index, MAX_CHUNK_SIZE)
          index += MAX_CHUNK_SIZE

          const reader = new global.FileReader()

          const handleLoad = (ev) => {
            reader.removeEventListener('loadend', handleLoad, false)

            if (ev.error) {
              return reject(ev.error)
            }

            resolve({
              done: false,
              value: Buffer.from(reader.result)
            })
          }

          reader.addEventListener('loadend', handleLoad)
          reader.readAsArrayBuffer(chunk)
        })
      }
    }

    return {
      [Symbol.asyncIterator]: () => {
        return iterator
      }
    }
  }

  throw errCode(new Error(`Don't know how to convert ${content} into an async iterator`), 'ERR_INVALID_PARAMS')
}

module.exports = toAsyncIterator

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-async-iterator.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-sources-and-destination.js", {"./to-sources":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-sources.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-sources-and-destination.js
      return function (require, module, exports) {
'use strict'

const toSources = require('./to-sources')

async function toSourcesAndDestination (context, args) {
  const {
    sources,
    options
  } = await toSources(context, args)

  const destination = sources.pop()

  return {
    destination,
    sources,
    options
  }
}

module.exports = toSourcesAndDestination

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-sources-and-destination.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/mortice/lib/index.js", {"./browser":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mortice/lib/browser.js","./node":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mortice/lib/node.js","observable-webworkers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/observable-webworkers/lib/index.js","p-queue":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-queue/index.js","promise-timeout":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promise-timeout/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/mortice/lib/index.js
      return function (require, module, exports) {
const node = require('./node')
const browser = require('./browser')
const Queue = require('p-queue')
const { timeout } = require('promise-timeout')
const observe = require('observable-webworkers')

const mutexes = {}
let implementation

const createMutex = (name, options) => {
  if (implementation.isWorker) {
    return {
      readLock: implementation.readLock(name, options),
      writeLock: implementation.writeLock(name, options)
    }
  }

  const masterQueue = new Queue({ concurrency: 1 })
  let readQueue = null

  return {
    readLock: (fn) => {
      // If there's already a read queue, just add the task to it
      if (readQueue) {
        return readQueue.add(() => timeout(fn(), options.timeout))
      }

      // Create a new read queue
      readQueue = new Queue({
        concurrency: options.concurrency,
        autoStart: false
      })
      const localReadQueue = readQueue

      // Add the task to the read queue
      const readPromise = readQueue.add(() => timeout(fn(), options.timeout))

      masterQueue.add(() => {
        // Start the task only once the master queue has completed processing
        // any previous tasks
        localReadQueue.start()

        // Once all the tasks in the read queue have completed, remove it so
        // that the next read lock will occur after any write locks that were
        // started in the interim
        return localReadQueue.onIdle()
          .then(() => {
            if (readQueue === localReadQueue) {
              readQueue = null
            }
          })
      })

      return readPromise
    },
    writeLock: (fn) => {
      // Remove the read queue reference, so that any later read locks will be
      // added to a new queue that starts after this write lock has been
      // released
      readQueue = null

      return masterQueue.add(() => timeout(fn(), options.timeout))
    }
  }
}

const defaultOptions = {
  concurrency: Infinity,
  timeout: 84600000,
  global: global,
  singleProcess: false
}

module.exports = (name, options) => {
  if (!options) {
    options = {}
  }

  if (typeof name === 'object') {
    options = name
    name = 'lock'
  }

  if (!name) {
    name = 'lock'
  }

  options = Object.assign({}, defaultOptions, options)

  if (!implementation) {
    implementation = node(options) || browser(options)

    if (!implementation.isWorker) {
      // we are master, set up worker requests
      implementation.on('requestReadLock', (name, fn) => {
        mutexes[name] && mutexes[name].readLock(fn)
      })

      implementation.on('requestWriteLock', (name, fn) => {
        mutexes[name] && mutexes[name].writeLock(fn)
      })
    }
  }

  if (!mutexes[name]) {
    mutexes[name] = createMutex(name, options)
  }

  return mutexes[name]
}

module.exports.Worker = function (script, Impl) {
  Impl = Impl || global.Worker
  let worker

  try {
    worker = new Impl(script)
  } catch (error) {
    if (error.message.includes('not a constructor')) {
      worker = Impl(script)
    }
  }

  if (!worker) {
    throw new Error('Could not create Worker from', Impl)
  }

  observe(worker)

  return worker
}

      };
    };
  }
}, {package:"mortice",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mortice/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/utils.js", {"fast-deep-equal":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-deep-equal/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/utils.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidJson = exports.isNonEmptyArray = exports.hasProperty = exports.isPlainObject = exports.timeSince = void 0;
const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
/**
 * @param timestamp - A Unix millisecond timestamp.
 * @returns The number of milliseconds elapsed since the specified timestamp.
 */
function timeSince(timestamp) {
    return Date.now() - timestamp;
}
exports.timeSince = timeSince;
function isPlainObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
exports.isPlainObject = isPlainObject;
const hasProperty = (object, key) => Reflect.hasOwnProperty.call(object, key);
exports.hasProperty = hasProperty;
/**
 * {@link NonEmptyArray} type guard.
 *
 * @template T - The non-empty array member type.
 * @param value - The value to check.
 * @returns Whether the value is a non-empty array.
 */
function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}
exports.isNonEmptyArray = isNonEmptyArray;
/**
 * {@link Json} type guard.
 *
 * @param value - The value to check.
 * @returns Whether the value is valid JSON.
 */
function isValidJson(value) {
    try {
        return fast_deep_equal_1.default(value, JSON.parse(JSON.stringify(value)));
    }
    catch (_) {
        return false;
    }
}
exports.isValidJson = isValidJson;
//# sourceMappingURL=utils.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/snaps/inlineSnaps.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/snaps/inlineSnaps.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.INLINE_SNAPS = void 0;
exports.INLINE_SNAPS = {
    IDLE: `
    console.log('Welcome to Flavortown.');
  `,
    INFINITE_LOOP: `
    console.log('Infinite loop snap start.');
    let num = 0;
    let time;
    while (true) {
      if (num === 0) {
        time = Date.now();
      }
      if (num === (2e8 - 1)) {
        console.log('Ding, gratz.');
        console.log(console.log((Date.now() - time) / 1000))
      }
      num = (num + 1) % 2e8;
  `,
    MEMORY_LEAK: `
    console.log('Memory leak snap start.')
    const getStr = () => Math.random().toString(2)
    const getLongStr = (str) => new Array(1000000).join(str)
    wallet.leakyBoi = {}
    let str
    while (true) {
      str = getStr()
      wallet.leakyBoi[str] = Object.assign({}, wallet.leakyBoi, { [str]: getLongStr(str) })
    }
  `,
};
//# sourceMappingURL=inlineSnaps.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/snaps/inlineSnaps.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/nanoid/index.browser.cjs", {"./url-alphabet/index.cjs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/nanoid/url-alphabet/index.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/nanoid/index.browser.cjs
      return function (require, module, exports) {
let { urlAlphabet } = require('./url-alphabet/index.cjs')
if ("development" !== 'production') {
  if (
    typeof navigator !== 'undefined' &&
    navigator.product === 'ReactNative' &&
    typeof crypto === 'undefined'
  ) {
    throw new Error(
      'React Native does not have a built-in secure random generator. ' +
        'If you dont need unpredictable IDs use `nanoid/non-secure`. ' +
        'For secure IDs, import `react-native-get-random-values` ' +
        'before Nano ID.'
    )
  }
  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {
    throw new Error(
      'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +
        ' before importing Nano ID to fix IE 11 support'
    )
  }
  if (typeof crypto === 'undefined') {
    throw new Error(
      'Your browser does not have secure random generator. ' +
        'If you dont need unpredictable IDs, you can use nanoid/non-secure.'
    )
  }
}
let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
let customRandom = (alphabet, size, getRandom) => {
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  let step = -~((1.6 * mask * size) / alphabet.length)
  return () => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let j = step
      while (j--) {
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)
let nanoid = (size = 21) => {
  let id = ''
  let bytes = crypto.getRandomValues(new Uint8Array(size))
  while (size--) {
    let byte = bytes[size] & 63
    if (byte < 36) {
      id += byte.toString(36)
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte < 63) {
      id += '_'
    } else {
      id += '-'
    }
  }
  return id
}
module.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }

      };
    };
  }
}, {package:"nanoid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/nanoid/index.browser.cjs",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/index.js", {"./BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js","./BaseControllerV2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseControllerV2.js","./ComposableController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/ComposableController.js","./ControllerMessenger":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/ControllerMessenger.js","./approval/ApprovalController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/approval/ApprovalController.js","./assets/AccountTrackerController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/AccountTrackerController.js","./assets/AssetsContractController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/AssetsContractController.js","./assets/AssetsDetectionController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/AssetsDetectionController.js","./assets/CollectiblesController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/CollectiblesController.js","./assets/CurrencyRateController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/CurrencyRateController.js","./assets/TokenBalancesController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokenBalancesController.js","./assets/TokenListController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokenListController.js","./assets/TokenRatesController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokenRatesController.js","./assets/TokensController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokensController.js","./gas/GasFeeController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/gas/GasFeeController.js","./keyring/KeyringController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/keyring/KeyringController.js","./message-manager/MessageManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/MessageManager.js","./message-manager/PersonalMessageManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/PersonalMessageManager.js","./message-manager/TypedMessageManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/TypedMessageManager.js","./network/NetworkController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/network/NetworkController.js","./notification/NotificationController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/notification/NotificationController.js","./third-party/PhishingController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/third-party/PhishingController.js","./transaction/TransactionController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/transaction/TransactionController.js","./user/AddressBookController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/user/AddressBookController.js","./user/PreferencesController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/user/PreferencesController.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js","isomorphic-fetch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/isomorphic-fetch/fetch-npm-browserify.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.util = exports.getAnonymizedState = exports.getPersistentState = exports.BaseControllerV2 = void 0;
require("isomorphic-fetch");
const util = __importStar(require("./util"));
exports.util = util;
__exportStar(require("./assets/AccountTrackerController"), exports);
__exportStar(require("./user/AddressBookController"), exports);
__exportStar(require("./approval/ApprovalController"), exports);
__exportStar(require("./assets/AssetsContractController"), exports);
__exportStar(require("./assets/AssetsDetectionController"), exports);
__exportStar(require("./BaseController"), exports);
var BaseControllerV2_1 = require("./BaseControllerV2");
Object.defineProperty(exports, "BaseControllerV2", { enumerable: true, get: function () { return BaseControllerV2_1.BaseController; } });
Object.defineProperty(exports, "getPersistentState", { enumerable: true, get: function () { return BaseControllerV2_1.getPersistentState; } });
Object.defineProperty(exports, "getAnonymizedState", { enumerable: true, get: function () { return BaseControllerV2_1.getAnonymizedState; } });
__exportStar(require("./ComposableController"), exports);
__exportStar(require("./ControllerMessenger"), exports);
__exportStar(require("./assets/CurrencyRateController"), exports);
__exportStar(require("./keyring/KeyringController"), exports);
__exportStar(require("./message-manager/MessageManager"), exports);
__exportStar(require("./network/NetworkController"), exports);
__exportStar(require("./third-party/PhishingController"), exports);
__exportStar(require("./user/PreferencesController"), exports);
__exportStar(require("./assets/TokenBalancesController"), exports);
__exportStar(require("./assets/TokenRatesController"), exports);
__exportStar(require("./transaction/TransactionController"), exports);
__exportStar(require("./message-manager/PersonalMessageManager"), exports);
__exportStar(require("./message-manager/TypedMessageManager"), exports);
__exportStar(require("./notification/NotificationController"), exports);
__exportStar(require("./assets/TokenListController"), exports);
__exportStar(require("./gas/GasFeeController"), exports);
__exportStar(require("./assets/TokensController"), exports);
__exportStar(require("./assets/CollectiblesController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/index.js", {"./ComposedStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/ComposedStore.js","./MergedStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/MergedStore.js","./ObservableStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/ObservableStore.js","./asStream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/asStream.js","./transform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/transform.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./asStream"), exports);
__exportStar(require("./ComposedStore"), exports);
__exportStar(require("./MergedStore"), exports);
__exportStar(require("./ObservableStore"), exports);
__exportStar(require("./transform"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-workers/dist/index.js", {"./enums":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-workers/dist/enums.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-workers/dist/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SNAP_STREAM_NAMES = void 0;
var enums_1 = require("./enums");
Object.defineProperty(exports, "SNAP_STREAM_NAMES", { enumerable: true, get: function () { return enums_1.STREAM_NAMES; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-workers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-workers/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/json-rpc-middleware-stream/dist/index.js", {"./createEngineStream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/json-rpc-middleware-stream/dist/createEngineStream.js","./createStreamMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/json-rpc-middleware-stream/dist/createStreamMiddleware.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/json-rpc-middleware-stream/dist/index.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStreamMiddleware = exports.createEngineStream = void 0;
const createEngineStream_1 = __importDefault(require("./createEngineStream"));
exports.createEngineStream = createEngineStream_1.default;
const createStreamMiddleware_1 = __importDefault(require("./createStreamMiddleware"));
exports.createStreamMiddleware = createStreamMiddleware_1.default;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"json-rpc-middleware-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/json-rpc-middleware-stream/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/errors.js", {"eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/errors.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionsRequestNotFoundError = exports.DuplicateCaveatError = exports.ForbiddenCaveatError = exports.InvalidCaveatFieldsError = exports.CaveatInvalidJsonError = exports.CaveatMissingValueError = exports.InvalidCaveatTypeError = exports.InvalidCaveatError = exports.CaveatAlreadyExistsError = exports.CaveatDoesNotExistError = exports.InvalidCaveatsPropertyError = exports.UnrecognizedCaveatTypeError = exports.PermissionDoesNotExistError = exports.InvalidApprovedPermissionError = exports.UnrecognizedSubjectError = exports.InvalidSubjectIdentifierError = exports.internalError = exports.userRejectedRequest = exports.invalidParams = exports.methodNotFound = exports.unauthorized = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
function unauthorized(opts) {
    return eth_rpc_errors_1.ethErrors.provider.unauthorized({
        message: 'Unauthorized to perform action. Try requesting the required permission(s) first. For more information, see: https://docs.metamask.io/guide/rpc-api.html#permissions',
        data: opts.data,
    });
}
exports.unauthorized = unauthorized;
function methodNotFound(opts) {
    const message = `The method "${opts.method}" does not exist / is not available.`;
    return eth_rpc_errors_1.ethErrors.rpc.methodNotFound({ data: opts.data, message });
}
exports.methodNotFound = methodNotFound;
function invalidParams(opts) {
    return eth_rpc_errors_1.ethErrors.rpc.invalidParams({
        data: opts.data,
        message: opts.message,
    });
}
exports.invalidParams = invalidParams;
function userRejectedRequest(data) {
    return eth_rpc_errors_1.ethErrors.provider.userRejectedRequest({ data });
}
exports.userRejectedRequest = userRejectedRequest;
function internalError(message, data) {
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message, data });
}
exports.internalError = internalError;
class InvalidSubjectIdentifierError extends Error {
    constructor(origin) {
        super(`Invalid subject identifier: "${typeof origin === 'string' ? origin : typeof origin}"`);
    }
}
exports.InvalidSubjectIdentifierError = InvalidSubjectIdentifierError;
class UnrecognizedSubjectError extends Error {
    constructor(origin) {
        super(`Unrecognized subject: "${origin}" has no permissions.`);
    }
}
exports.UnrecognizedSubjectError = UnrecognizedSubjectError;
class InvalidApprovedPermissionError extends Error {
    constructor(origin, target, approvedPermission) {
        super(`Invalid approved permission for origin "${origin}" and target "${target}".`);
        this.data = { origin, target, approvedPermission };
    }
}
exports.InvalidApprovedPermissionError = InvalidApprovedPermissionError;
class PermissionDoesNotExistError extends Error {
    constructor(origin, target) {
        super(`Subject "${origin}" has no permission for "${target}".`);
    }
}
exports.PermissionDoesNotExistError = PermissionDoesNotExistError;
class UnrecognizedCaveatTypeError extends Error {
    constructor(caveatType, origin, target) {
        super(`Unrecognized caveat type: "${caveatType}"`);
        this.data = { caveatType };
        if (origin !== undefined) {
            this.data.origin = origin;
        }
        if (target !== undefined) {
            this.data.target = target;
        }
    }
}
exports.UnrecognizedCaveatTypeError = UnrecognizedCaveatTypeError;
class InvalidCaveatsPropertyError extends Error {
    constructor(origin, target, caveatsProperty) {
        super(`The "caveats" property of permission for "${target}" of subject "${origin}" is invalid. It must be a non-empty array if specified.`);
        this.data = { origin, target, caveatsProperty };
    }
}
exports.InvalidCaveatsPropertyError = InvalidCaveatsPropertyError;
class CaveatDoesNotExistError extends Error {
    constructor(origin, target, caveatType) {
        super(`Permission for "${target}" of subject "${origin}" has no caveat of type "${caveatType}".`);
    }
}
exports.CaveatDoesNotExistError = CaveatDoesNotExistError;
class CaveatAlreadyExistsError extends Error {
    constructor(origin, target, caveatType) {
        super(`Permission for "${target}" of subject "${origin}" already has a caveat of type "${caveatType}".`);
    }
}
exports.CaveatAlreadyExistsError = CaveatAlreadyExistsError;
class InvalidCaveatError extends eth_rpc_errors_1.EthereumRpcError {
    constructor(receivedCaveat, origin, target) {
        super(eth_rpc_errors_1.errorCodes.rpc.invalidParams, `Invalid caveat. Caveats must be plain objects.`, { receivedCaveat });
        this.data = { origin, target };
    }
}
exports.InvalidCaveatError = InvalidCaveatError;
class InvalidCaveatTypeError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat types must be strings. Received: "${typeof caveat.type}"`);
        this.data = { caveat, origin, target };
    }
}
exports.InvalidCaveatTypeError = InvalidCaveatTypeError;
class CaveatMissingValueError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat is missing "value" field.`);
        this.data = { caveat, origin, target };
    }
}
exports.CaveatMissingValueError = CaveatMissingValueError;
class CaveatInvalidJsonError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat "value" is invalid JSON.`);
        this.data = { caveat, origin, target };
    }
}
exports.CaveatInvalidJsonError = CaveatInvalidJsonError;
class InvalidCaveatFieldsError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat has unexpected number of fields: "${Object.keys(caveat).length}"`);
        this.data = { caveat, origin, target };
    }
}
exports.InvalidCaveatFieldsError = InvalidCaveatFieldsError;
class ForbiddenCaveatError extends Error {
    constructor(caveatType, origin, targetName) {
        super(`Permissions for target "${targetName}" may not have caveats of type "${caveatType}".`);
        this.data = { caveatType, origin, target: targetName };
    }
}
exports.ForbiddenCaveatError = ForbiddenCaveatError;
class DuplicateCaveatError extends Error {
    constructor(caveatType, origin, targetName) {
        super(`Permissions for target "${targetName}" contains multiple caveats of type "${caveatType}".`);
        this.data = { caveatType, origin, target: targetName };
    }
}
exports.DuplicateCaveatError = DuplicateCaveatError;
class PermissionsRequestNotFoundError extends Error {
    constructor(id) {
        super(`Permissions request with id "${id}" not found.`);
    }
}
exports.PermissionsRequestNotFoundError = PermissionsRequestNotFoundError;
//# sourceMappingURL=errors.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/errors.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/getPermissions.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/getPermissions.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPermissionsHandler = void 0;
const utils_1 = require("../utils");
exports.getPermissionsHandler = {
    methodNames: [utils_1.MethodNames.getPermissions],
    implementation: getPermissionsImplementation,
    hookNames: {
        getPermissionsForOrigin: true,
    },
};
async function getPermissionsImplementation(_req, res, _next, end, { getPermissionsForOrigin }) {
    res.result = Object.values(getPermissionsForOrigin() || {});
    return end();
}
//# sourceMappingURL=getPermissions.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/getPermissions.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/requestPermissions.js", {"../../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/utils.js","../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/errors.js","../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/utils.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/requestPermissions.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestPermissionsHandler = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const utils_1 = require("../utils");
const errors_1 = require("../errors");
const utils_2 = require("../../utils");
exports.requestPermissionsHandler = {
    methodNames: [utils_1.MethodNames.requestPermissions],
    implementation: requestPermissionsImplementation,
    hookNames: {
        requestPermissionsForOrigin: true,
    },
};
async function requestPermissionsImplementation(req, res, _next, end, { requestPermissionsForOrigin }) {
    const { id, params } = req;
    if ((typeof id !== 'number' && typeof id !== 'string') ||
        (typeof id === 'string' && !id)) {
        return end(eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: 'Invalid request: Must specify a valid id.',
            data: { request: req },
        }));
    }
    if (!Array.isArray(params) || !utils_2.isPlainObject(params[0])) {
        return end(errors_1.invalidParams({ data: { request: req } }));
    }
    const [requestedPermissions] = params;
    const [grantedPermissions] = await requestPermissionsForOrigin(requestedPermissions, String(id));
    // `wallet_requestPermission` is specified to return an array.
    res.result = Object.values(grantedPermissions);
    return end();
}
//# sourceMappingURL=requestPermissions.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/requestPermissions.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/permission-middleware.js", {"./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/errors.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/permission-middleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPermissionMiddlewareFactory = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const errors_1 = require("./errors");
/**
 * Creates a permission middleware function factory. Intended for internal use
 * in the {@link PermissionController}. Like any {@link JsonRpcEngine}
 * middleware, each middleware will only receive requests from a particular
 * subject / origin. However, each middleware also requires access to some
 * `PermissionController` internals, which is why this "factory factory" exists.
 *
 * The middlewares returned by the factory will pass through requests for
 * unrestricted methods, and attempt to execute restricted methods. If a method
 * is neither restricted nor unrestricted, a "method not found" error will be
 * returned.
 * If a method is restricted, the middleware will first attempt to retrieve the
 * subject's permission for that method. If the permission is found, the method
 * will be executed. Otherwise, an "unauthorized" error will be returned.
 *
 * @param options - Options bag.
 * @param options.executeRestrictedMethod - {@link PermissionController._executeRestrictedMethod}.
 * @param options.getRestrictedMethod - {@link PermissionController.getRestrictedMethod}.
 * @param options.isUnrestrictedMethod - A function that checks whether a
 * particular method is unrestricted.
 * @returns A permission middleware factory function.
 */
function getPermissionMiddlewareFactory({ executeRestrictedMethod, getRestrictedMethod, isUnrestrictedMethod, }) {
    return function createPermissionMiddleware(subject) {
        const { origin } = subject;
        if (typeof origin !== 'string' || !origin) {
            throw new Error('The subject "origin" must be a non-empty string.');
        }
        const permissionsMiddleware = async (req, res, next) => {
            const { method, params } = req;
            // Skip registered unrestricted methods.
            if (isUnrestrictedMethod(method)) {
                return next();
            }
            // This will throw if no restricted method implementation is found.
            const methodImplementation = getRestrictedMethod(method, origin);
            // This will throw if the permission does not exist.
            const result = await executeRestrictedMethod(methodImplementation, subject, method, params);
            if (result === undefined) {
                res.error = errors_1.internalError(`Request for method "${req.method}" returned undefined result.`, { request: req });
                return undefined;
            }
            res.result = result;
            return undefined;
        };
        return json_rpc_engine_1.createAsyncMiddleware(permissionsMiddleware);
    };
}
exports.getPermissionMiddlewareFactory = getPermissionMiddlewareFactory;
//# sourceMappingURL=permission-middleware.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/permission-middleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivers/index.js", {"./bip32":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivers/bip32.js","./bip39":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivers/bip39.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivers/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.derivers = void 0;
const bip32 = __importStar(require("./bip32"));
const bip39 = __importStar(require("./bip39"));
exports.derivers = {
    bip32,
    bip39,
};
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/key-tree",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivers/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/node_modules/ethjs-abi/lib/utils/index.js", {"bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/bn.js/lib/bn.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/js-sha3/src/sha3.js","number-to-bn":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/number-to-bn/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/node_modules/ethjs-abi/lib/utils/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var BN = require('bn.js');
var numberToBN = require('number-to-bn');
var keccak256 = require('js-sha3').keccak_256;

// from ethereumjs-util
function stripZeros(aInput) {
  var a = aInput; // eslint-disable-line
  var first = a[0]; // eslint-disable-line
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
}

function bnToBuffer(bnInput) {
  var bn = bnInput; // eslint-disable-line
  var hex = bn.toString(16); // eslint-disable-line
  if (hex.length % 2) {
    hex = '0' + hex;
  }
  return stripZeros(new Buffer(hex, 'hex'));
}

function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}

function hexOrBuffer(valueInput, name) {
  var value = valueInput; // eslint-disable-line
  if (!Buffer.isBuffer(value)) {
    if (!isHexString(value)) {
      var error = new Error(name ? '[ethjs-abi] invalid ' + name : '[ethjs-abi] invalid hex or buffer, must be a prefixed alphanumeric even length hex string');
      error.reason = '[ethjs-abi] invalid hex string, hex must be prefixed and alphanumeric (e.g. 0x023..)';
      error.value = value;
      throw error;
    }

    value = value.substring(2);
    if (value.length % 2) {
      value = '0' + value;
    }
    value = new Buffer(value, 'hex');
  }

  return value;
}

function hexlify(value) {
  if (typeof value === 'number') {
    return '0x' + bnToBuffer(new BN(value)).toString('hex');
  } else if (value.mod || value.modulo) {
    return '0x' + bnToBuffer(value).toString('hex');
  } else {
    // eslint-disable-line
    return '0x' + hexOrBuffer(value).toString('hex');
  }
}

// getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
function getKeys(params, key, allowEmpty) {
  var result = []; // eslint-disable-line

  if (!Array.isArray(params)) {
    throw new Error('[ethjs-abi] while getting keys, invalid params value ' + JSON.stringify(params));
  }

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('[ethjs-abi] while getKeys found invalid ABI data structure, type value not string');
    }
    result.push(value);
  }

  return result;
}

function coderNumber(size, signed) {
  return {
    encode: function encodeNumber(valueInput) {
      var value = valueInput; // eslint-disable-line

      if (typeof value === 'object' && value.toString && (value.toTwos || value.dividedToIntegerBy)) {
        value = value.toString(10).split('.')[0];
      }

      if (typeof value === 'string' || typeof value === 'number') {
        value = String(value).split('.')[0];
      }

      value = numberToBN(value);
      value = value.toTwos(size * 8).maskn(size * 8);
      if (signed) {
        value = value.fromTwos(size * 8).toTwos(256);
      }
      return value.toArrayLike(Buffer, 'be', 32);
    },
    decode: function decodeNumber(data, offset) {
      var junkLength = 32 - size; // eslint-disable-line
      var value = new BN(data.slice(offset + junkLength, offset + 32)); // eslint-disable-line
      if (signed) {
        value = value.fromTwos(size * 8);
      } else {
        value = value.maskn(size * 8);
      }
      return {
        consumed: 32,
        value: new BN(value.toString(10))
      };
    }
  };
}
var uint256Coder = coderNumber(32, false);

var coderBoolean = {
  encode: function encodeBoolean(value) {
    return uint256Coder.encode(value ? 1 : 0);
  },
  decode: function decodeBoolean(data, offset) {
    var result = uint256Coder.decode(data, offset); // eslint-disable-line
    return {
      consumed: result.consumed,
      value: !result.value.isZero()
    };
  }
};

function coderFixedBytes(length) {
  return {
    encode: function encodeFixedBytes(valueInput) {
      var value = valueInput; // eslint-disable-line
      value = hexOrBuffer(value);

      if (value.length === 32) {
        return value;
      }

      var result = new Buffer(32); // eslint-disable-line
      result.fill(0);
      value.copy(result);
      return result;
    },
    decode: function decodeFixedBytes(data, offset) {
      if (data.length !== 0 && data.length < offset + 32) {
        throw new Error('[ethjs-abi] while decoding fixed bytes, invalid bytes data length: ' + length);
      }

      return {
        consumed: 32,
        value: '0x' + data.slice(offset, offset + length).toString('hex')
      };
    }
  };
}

var coderAddress = {
  encode: function encodeAddress(valueInput) {
    var value = valueInput; // eslint-disable-line
    var result = new Buffer(32); // eslint-disable-line
    if (!isHexString(value, 20)) {
      throw new Error('[ethjs-abi] while encoding address, invalid address value, not alphanumeric 20 byte hex string');
    }
    value = hexOrBuffer(value);
    result.fill(0);
    value.copy(result, 12);
    return result;
  },
  decode: function decodeAddress(data, offset) {
    if (data.length === 0) {
      return {
        consumed: 32,
        value: '0x'
      };
    }
    if (data.length !== 0 && data.length < offset + 32) {
      throw new Error('[ethjs-abi] while decoding address data, invalid address data, invalid byte length ' + data.length);
    }
    return {
      consumed: 32,
      value: '0x' + data.slice(offset + 12, offset + 32).toString('hex')
    };
  }
};

function encodeDynamicBytesHelper(value) {
  var dataLength = parseInt(32 * Math.ceil(value.length / 32)); // eslint-disable-line
  var padding = new Buffer(dataLength - value.length); // eslint-disable-line
  padding.fill(0);

  return Buffer.concat([uint256Coder.encode(value.length), value, padding]);
}

function decodeDynamicBytesHelper(data, offset) {
  if (data.length !== 0 && data.length < offset + 32) {
    throw new Error('[ethjs-abi] while decoding dynamic bytes data, invalid bytes length: ' + data.length + ' should be less than ' + (offset + 32));
  }

  var length = uint256Coder.decode(data, offset).value; // eslint-disable-line
  length = length.toNumber();
  if (data.length !== 0 && data.length < offset + 32 + length) {
    throw new Error('[ethjs-abi] while decoding dynamic bytes data, invalid bytes length: ' + data.length + ' should be less than ' + (offset + 32 + length));
  }

  return {
    consumed: parseInt(32 + 32 * Math.ceil(length / 32), 10),
    value: data.slice(offset + 32, offset + 32 + length)
  };
}

var coderDynamicBytes = {
  encode: function encodeDynamicBytes(value) {
    return encodeDynamicBytesHelper(hexOrBuffer(value));
  },
  decode: function decodeDynamicBytes(data, offset) {
    var result = decodeDynamicBytesHelper(data, offset); // eslint-disable-line
    result.value = '0x' + result.value.toString('hex');
    return result;
  },
  dynamic: true
};

var coderString = {
  encode: function encodeString(value) {
    return encodeDynamicBytesHelper(new Buffer(value, 'utf8'));
  },
  decode: function decodeString(data, offset) {
    var result = decodeDynamicBytesHelper(data, offset); // eslint-disable-line
    result.value = result.value.toString('utf8');
    return result;
  },
  dynamic: true
};

function coderArray(coder, lengthInput) {
  return {
    encode: function encodeArray(value) {
      var result = new Buffer(0); // eslint-disable-line
      var length = lengthInput; // eslint-disable-line

      if (!Array.isArray(value)) {
        throw new Error('[ethjs-abi] while encoding array, invalid array data, not type Object (Array)');
      }

      if (length === -1) {
        length = value.length;
        result = uint256Coder.encode(length);
      }

      if (length !== value.length) {
        throw new Error('[ethjs-abi] while encoding array, size mismatch array length ' + length + ' does not equal ' + value.length);
      }

      value.forEach(function (resultValue) {
        result = Buffer.concat([result, coder.encode(resultValue)]);
      });

      return result;
    },
    decode: function decodeArray(data, offsetInput) {
      var length = lengthInput; // eslint-disable-line
      var offset = offsetInput; // eslint-disable-line
      // @TODO:
      // if (data.length < offset + length * 32) { throw new Error('invalid array'); }

      var consumed = 0; // eslint-disable-line
      var decodeResult; // eslint-disable-line

      if (length === -1) {
        decodeResult = uint256Coder.decode(data, offset);
        length = decodeResult.value.toNumber();
        consumed += decodeResult.consumed;
        offset += decodeResult.consumed;
      }

      var value = []; // eslint-disable-line

      for (var i = 0; i < length; i++) {
        // eslint-disable-line
        var loopResult = coder.decode(data, offset);
        consumed += loopResult.consumed;
        offset += loopResult.consumed;
        value.push(loopResult.value);
      }

      return {
        consumed: consumed,
        value: value
      };
    },
    dynamic: lengthInput === -1
  };
}

// Break the type up into [staticType][staticArray]*[dynamicArray]? | [dynamicType] and
// build the coder up from its parts
var paramTypePart = new RegExp(/^((u?int|bytes)([0-9]*)|(address|bool|string)|(\[([0-9]*)\]))/);

function getParamCoder(typeInput) {
  var type = typeInput; // eslint-disable-line
  var coder = null; // eslint-disable-line
  var invalidTypeErrorMessage = '[ethjs-abi] while getting param coder (getParamCoder) type value ' + JSON.stringify(type) + ' is either invalid or unsupported by ethjs-abi.';

  while (type) {
    var part = type.match(paramTypePart); // eslint-disable-line
    if (!part) {
      throw new Error(invalidTypeErrorMessage);
    }
    type = type.substring(part[0].length);

    var prefix = part[2] || part[4] || part[5]; // eslint-disable-line
    switch (prefix) {
      case 'int':case 'uint':
        if (coder) {
          throw new Error(invalidTypeErrorMessage);
        }
        var intSize = parseInt(part[3] || 256); // eslint-disable-line
        if (intSize === 0 || intSize > 256 || intSize % 8 !== 0) {
          throw new Error('[ethjs-abi] while getting param coder for type ' + type + ', invalid ' + prefix + '<N> width: ' + type);
        }

        coder = coderNumber(intSize / 8, prefix === 'int');
        break;

      case 'bool':
        if (coder) {
          throw new Error(invalidTypeErrorMessage);
        }
        coder = coderBoolean;
        break;

      case 'string':
        if (coder) {
          throw new Error(invalidTypeErrorMessage);
        }
        coder = coderString;
        break;

      case 'bytes':
        if (coder) {
          throw new Error(invalidTypeErrorMessage);
        }
        if (part[3]) {
          var size = parseInt(part[3]); // eslint-disable-line
          if (size === 0 || size > 32) {
            throw new Error('[ethjs-abi] while getting param coder for prefix bytes, invalid type ' + type + ', size ' + size + ' should be 0 or greater than 32');
          }
          coder = coderFixedBytes(size);
        } else {
          coder = coderDynamicBytes;
        }
        break;

      case 'address':
        if (coder) {
          throw new Error(invalidTypeErrorMessage);
        }
        coder = coderAddress;
        break;

      case '[]':
        if (!coder || coder.dynamic) {
          throw new Error(invalidTypeErrorMessage);
        }
        coder = coderArray(coder, -1);
        break;

      // "[0-9+]"
      default:
        if (!coder || coder.dynamic) {
          throw new Error(invalidTypeErrorMessage);
        }
        var defaultSize = parseInt(part[6]); // eslint-disable-line
        coder = coderArray(coder, defaultSize);
    }
  }

  if (!coder) {
    throw new Error(invalidTypeErrorMessage);
  }
  return coder;
}

module.exports = {
  BN: BN,
  bnToBuffer: bnToBuffer,
  isHexString: isHexString,
  hexOrBuffer: hexOrBuffer,
  hexlify: hexlify,
  stripZeros: stripZeros,

  keccak256: keccak256,

  getKeys: getKeys,
  numberToBN: numberToBN,
  coderNumber: coderNumber,
  uint256Coder: uint256Coder,
  coderBoolean: coderBoolean,
  coderFixedBytes: coderFixedBytes,
  coderAddress: coderAddress,
  coderDynamicBytes: coderDynamicBytes,
  coderString: coderString,
  coderArray: coderArray,
  paramTypePart: paramTypePart,
  getParamCoder: getParamCoder
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-abi",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/node_modules/ethjs-abi/lib/utils/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/prr/prr.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/prr/prr.js
      return function (require, module, exports) {
/*!
  * prr
  * (c) 2013 Rod Vagg <rod@vagg.org>
  * https://github.com/rvagg/prr
  * License: MIT
  */

(function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports)
    module.exports = definition()
  else
    context[name] = definition()
})('prr', this, function() {

  var setProperty = typeof Object.defineProperty == 'function'
      ? function (obj, key, options) {
          Object.defineProperty(obj, key, options)
          return obj
        }
      : function (obj, key, options) { // < es5
          obj[key] = options.value
          return obj
        }

    , makeOptions = function (value, options) {
        var oo = typeof options == 'object'
          , os = !oo && typeof options == 'string'
          , op = function (p) {
              return oo
                ? !!options[p]
                : os
                  ? options.indexOf(p[0]) > -1
                  : false
            }

        return {
            enumerable   : op('enumerable')
          , configurable : op('configurable')
          , writable     : op('writable')
          , value        : value
        }
      }

    , prr = function (obj, key, value, options) {
        var k

        options = makeOptions(value, options)

        if (typeof key == 'object') {
          for (k in key) {
            if (Object.hasOwnProperty.call(key, k)) {
              options.value = key[k]
              setProperty(obj, k, options)
            }
          }
          return obj
        }

        return setProperty(obj, key, options)
      }

  return prr
})
      };
    };
  }
}, {package:"prr",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/prr/prr.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/errors-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/errors-browser.js
      return function (require, module, exports) {
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/errors-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/stream-browser.js", {"events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/stream-browser.js
      return function (require, module, exports) {
module.exports = require('events').EventEmitter;

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/stream-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/destroy.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/destroy.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/destroy.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/state.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/state.js
      return function (require, module, exports) {
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/state.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/from-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/from-browser.js
      return function (require, module, exports) {
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/from-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/buffer_list.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/buffer_list.js
      return function (require, module, exports) {
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/buffer_list.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/async_iterator.js", {"./end-of-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/async_iterator.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/async_iterator.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-codec/lib/encodings.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/level-codec/lib/encodings.js
      return function (require, module, exports) {
(function (Buffer){(function (){
exports.utf8 = exports['utf-8'] = {
  encode: function (data) {
    return isBinary(data) ? data : String(data)
  },
  decode: identity,
  buffer: false,
  type: 'utf8'
}

exports.json = {
  encode: JSON.stringify,
  decode: JSON.parse,
  buffer: false,
  type: 'json'
}

exports.binary = {
  encode: function (data) {
    return isBinary(data) ? data : Buffer.from(data)
  },
  decode: identity,
  buffer: true,
  type: 'binary'
}

exports.none = {
  encode: identity,
  decode: identity,
  buffer: false,
  type: 'id'
}

exports.id = exports.none

var bufferEncodings = [
  'hex',
  'ascii',
  'base64',
  'ucs2',
  'ucs-2',
  'utf16le',
  'utf-16le'
]

bufferEncodings.forEach(function (type) {
  exports[type] = {
    encode: function (data) {
      return isBinary(data) ? data : Buffer.from(data, type)
    },
    decode: function (buffer) {
      return buffer.toString(type)
    },
    buffer: true,
    type: type
  }
})

function identity (value) {
  return value
}

function isBinary (data) {
  return data === undefined || data === null || Buffer.isBuffer(data)
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"level-codec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-codec/lib/encodings.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/idb-readable-stream/index.js", {"stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-browserify/index.js","xtend":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xtend/immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/idb-readable-stream/index.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2016 Tim Kuijsten
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

'use strict'

var stream = require('stream')

var xtend = require('xtend')

/**
 * Iterate over an IndexedDB object store with a readable stream.
 *
 * @param {IDBDatabase} db - IndexedDB instance
 * @param {String} storeName - name of the object store to iterate over
 * @param {Object} [opts]
 *
 * Options:
 * @param {IDBKeyRange} opts.range - a valid IndexedDB key range
 * @param {IDBCursorDirection} opts.direction - one of "next", "nextunique",
 *   "prev", "prevunique"
 * @param {Boolean} opts.snapshot=false - Iterate over a snapshot of the database
 *   by opening only one cursor. This disables any form of back pressure to prevent
 *   cursor timeout issues.
 */
function idbReadableStream(db, storeName, opts) {
  if (typeof db !== 'object') throw new TypeError('db must be an object')
  if (typeof storeName !== 'string') throw new TypeError('storeName must be a string')
  if (opts == null) opts = {}
  if (typeof opts !== 'object') throw new TypeError('opts must be an object')

  // use transform stream for buffering and back pressure
  var transformer = new stream.Transform(xtend(opts, {
    objectMode: true,
    transform: function(obj, enc, cb) {
      cb(null, obj)
    }
  }))

  opts = xtend({
    snapshot: false
  }, opts)

  var lastIteratedKey = null
  transformer._cursorsOpened = 0

  function startCursor() {
    var lower, upper, lowerOpen, upperOpen

    var direction = opts.direction || 'next'
    var range = opts.range || {}

    lower = range.lower
    upper = range.upper
    lowerOpen = !!range.lowerOpen
    upperOpen = !!range.upperOpen

    // if this is not the first iteration, use lastIteratedKey
    if (lastIteratedKey) {
      if (direction === 'next') {
        lowerOpen = true // exclude the last iterated key itself
        lower = lastIteratedKey
      } else {
        upperOpen = true // exclude the last iterated key itself
        upper = lastIteratedKey
      }
    }

    var keyRange
    if (lower && upper)
      keyRange = IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen)
    else if (lower)
      keyRange = IDBKeyRange.lowerBound(lower, lowerOpen)
    else if (upper)
      keyRange = IDBKeyRange.upperBound(upper, upperOpen)

    var tx = db.transaction(storeName, 'readonly')
    var store = tx.objectStore(storeName)

    transformer._cursorsOpened++
    var req = store.openCursor(keyRange, opts.direction)

    function proceed(cursor) {
      try {
        cursor.continue() // throws a TransactionInactiveError if the cursor timed out
      } catch(err) {
        // either reopen a cursor or propagate the error
        if (err.name === 'TransactionInactiveError' && !opts.snapshot)
          startCursor() // IndexedDB timed out the cursor
        else
          transformer.emit('error', err)
      }
    }

    req.onsuccess = function() {
      var cursor = req.result
      if (cursor) {
        lastIteratedKey = cursor.key

        var go = transformer.write({ key: cursor.key, value: cursor.value })
        if (opts.snapshot || go)
          proceed(cursor)
        else
          transformer.once('drain', function() {
            proceed(cursor)
          })
      } else
        transformer.end()
    }

    tx.onabort = function() {
      transformer.emit('error', tx.error)
    }
    tx.onerror = function() {
      transformer.emit('error', tx.error)
    }
  }

  startCursor()

  return transformer
}

module.exports = idbReadableStream

      };
    };
  }
}, {package:"idb-readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/idb-readable-stream/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-iterator.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-iterator.js
      return function (require, module, exports) {
(function (process){(function (){
/* Copyright (c) 2013 Rod Vagg, MIT License */

function AbstractIterator (db) {
  this.db = db
  this._ended = false
  this._nexting = false
}

AbstractIterator.prototype.next = function (callback) {
  var self = this

  if (typeof callback != 'function')
    throw new Error('next() requires a callback argument')

  if (self._ended)
    return callback(new Error('cannot call next() after end()'))
  if (self._nexting)
    return callback(new Error('cannot call next() before previous next() has completed'))

  self._nexting = true
  if (typeof self._next == 'function') {
    return self._next(function () {
      self._nexting = false
      callback.apply(null, arguments)
    })
  }

  process.nextTick(function () {
    self._nexting = false
    callback()
  })
}

AbstractIterator.prototype.end = function (callback) {
  if (typeof callback != 'function')
    throw new Error('end() requires a callback argument')

  if (this._ended)
    return callback(new Error('end() already called on iterator'))

  this._ended = true

  if (typeof this._end == 'function')
    return this._end(callback)

  process.nextTick(callback)
}

module.exports = AbstractIterator

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"abstract-leveldown",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-iterator.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-chained-batch.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-chained-batch.js
      return function (require, module, exports) {
(function (process){(function (){
/* Copyright (c) 2013 Rod Vagg, MIT License */

function AbstractChainedBatch (db) {
  this._db         = db
  this._operations = []
  this._written    = false
}

AbstractChainedBatch.prototype._checkWritten = function () {
  if (this._written)
    throw new Error('write() already called on this batch')
}

AbstractChainedBatch.prototype.put = function (key, value) {
  this._checkWritten()

  var err = this._db._checkKey(key, 'key', this._db._isBuffer)
  if (err)
    throw err

  if (!this._db._isBuffer(key)) key = String(key)
  if (!this._db._isBuffer(value)) value = String(value)

  if (typeof this._put == 'function' )
    this._put(key, value)
  else
    this._operations.push({ type: 'put', key: key, value: value })

  return this
}

AbstractChainedBatch.prototype.del = function (key) {
  this._checkWritten()

  var err = this._db._checkKey(key, 'key', this._db._isBuffer)
  if (err) throw err

  if (!this._db._isBuffer(key)) key = String(key)

  if (typeof this._del == 'function' )
    this._del(key)
  else
    this._operations.push({ type: 'del', key: key })

  return this
}

AbstractChainedBatch.prototype.clear = function () {
  this._checkWritten()

  this._operations = []

  if (typeof this._clear == 'function' )
    this._clear()

  return this
}

AbstractChainedBatch.prototype.write = function (options, callback) {
  this._checkWritten()

  if (typeof options == 'function')
    callback = options
  if (typeof callback != 'function')
    throw new Error('write() requires a callback argument')
  if (typeof options != 'object')
    options = {}

  this._written = true

  if (typeof this._write == 'function' )
    return this._write(callback)

  if (typeof this._db._batch == 'function')
    return this._db._batch(this._operations, options, callback)

  process.nextTick(callback)
}

module.exports = AbstractChainedBatch
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"abstract-leveldown",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-chained-batch.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/is-leveldown.js", {"./abstract-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-leveldown.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/is-leveldown.js
      return function (require, module, exports) {
var AbstractLevelDOWN = require('./abstract-leveldown')

function isLevelDOWN (db) {
  if (!db || typeof db !== 'object')
    return false
  return Object.keys(AbstractLevelDOWN.prototype).filter(function (name) {
    // TODO remove approximateSize check when method is gone
    return name[0] != '_' && name != 'approximateSize'
  }).every(function (name) {
    return typeof db[name] == 'function'
  })
}

module.exports = isLevelDOWN

      };
    };
  }
}, {package:"abstract-leveldown",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/is-leveldown.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-leveldown.js", {"../../../../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./abstract-chained-batch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-chained-batch.js","./abstract-iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-iterator.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","xtend":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xtend/immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-leveldown.js
      return function (require, module, exports) {
(function (Buffer,process){(function (){
/* Copyright (c) 2013 Rod Vagg, MIT License */

var xtend                = require('xtend')
  , AbstractIterator     = require('./abstract-iterator')
  , AbstractChainedBatch = require('./abstract-chained-batch')

function AbstractLevelDOWN (location) {
  if (!arguments.length || location === undefined)
    throw new Error('constructor requires at least a location argument')

  if (typeof location != 'string')
    throw new Error('constructor requires a location string argument')

  this.location = location
  this.status = 'new'
}

AbstractLevelDOWN.prototype.open = function (options, callback) {
  var self      = this
    , oldStatus = this.status

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('open() requires a callback argument')

  if (typeof options != 'object')
    options = {}

  options.createIfMissing = options.createIfMissing != false
  options.errorIfExists = !!options.errorIfExists

  if (typeof this._open == 'function') {
    this.status = 'opening'
    this._open(options, function (err) {
      if (err) {
        self.status = oldStatus
        return callback(err)
      }
      self.status = 'open'
      callback()
    })
  } else {
    this.status = 'open'
    process.nextTick(callback)
  }
}

AbstractLevelDOWN.prototype.close = function (callback) {
  var self      = this
    , oldStatus = this.status

  if (typeof callback != 'function')
    throw new Error('close() requires a callback argument')

  if (typeof this._close == 'function') {
    this.status = 'closing'
    this._close(function (err) {
      if (err) {
        self.status = oldStatus
        return callback(err)
      }
      self.status = 'closed'
      callback()
    })
  } else {
    this.status = 'closed'
    process.nextTick(callback)
  }
}

AbstractLevelDOWN.prototype.get = function (key, options, callback) {
  var err

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('get() requires a callback argument')

  if (err = this._checkKey(key, 'key', this._isBuffer))
    return callback(err)

  if (!this._isBuffer(key))
    key = String(key)

  if (typeof options != 'object')
    options = {}

  options.asBuffer = options.asBuffer != false

  if (typeof this._get == 'function')
    return this._get(key, options, callback)

  process.nextTick(function () { callback(new Error('NotFound')) })
}

AbstractLevelDOWN.prototype.put = function (key, value, options, callback) {
  var err

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('put() requires a callback argument')

  if (err = this._checkKey(key, 'key', this._isBuffer))
    return callback(err)

  if (!this._isBuffer(key))
    key = String(key)

  // coerce value to string in node, don't touch it in browser
  // (indexeddb can store any JS type)
  if (value != null && !this._isBuffer(value) && !process.browser)
    value = String(value)

  if (typeof options != 'object')
    options = {}

  if (typeof this._put == 'function')
    return this._put(key, value, options, callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.del = function (key, options, callback) {
  var err

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('del() requires a callback argument')

  if (err = this._checkKey(key, 'key', this._isBuffer))
    return callback(err)

  if (!this._isBuffer(key))
    key = String(key)

  if (typeof options != 'object')
    options = {}

  if (typeof this._del == 'function')
    return this._del(key, options, callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.batch = function (array, options, callback) {
  if (!arguments.length)
    return this._chainedBatch()

  if (typeof options == 'function')
    callback = options

  if (typeof array == 'function')
    callback = array

  if (typeof callback != 'function')
    throw new Error('batch(array) requires a callback argument')

  if (!Array.isArray(array))
    return callback(new Error('batch(array) requires an array argument'))

  if (!options || typeof options != 'object')
    options = {}

  var i = 0
    , l = array.length
    , e
    , err

  for (; i < l; i++) {
    e = array[i]
    if (typeof e != 'object')
      continue

    if (err = this._checkKey(e.type, 'type', this._isBuffer))
      return callback(err)

    if (err = this._checkKey(e.key, 'key', this._isBuffer))
      return callback(err)
  }

  if (typeof this._batch == 'function')
    return this._batch(array, options, callback)

  process.nextTick(callback)
}

//TODO: remove from here, not a necessary primitive
AbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {
  if (   start == null
      || end == null
      || typeof start == 'function'
      || typeof end == 'function') {
    throw new Error('approximateSize() requires valid `start`, `end` and `callback` arguments')
  }

  if (typeof callback != 'function')
    throw new Error('approximateSize() requires a callback argument')

  if (!this._isBuffer(start))
    start = String(start)

  if (!this._isBuffer(end))
    end = String(end)

  if (typeof this._approximateSize == 'function')
    return this._approximateSize(start, end, callback)

  process.nextTick(function () {
    callback(null, 0)
  })
}

AbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {
  var self = this

  options = xtend(options)

  ;[ 'start', 'end', 'gt', 'gte', 'lt', 'lte' ].forEach(function (o) {
    if (options[o] && self._isBuffer(options[o]) && options[o].length === 0)
      delete options[o]
  })

  options.reverse = !!options.reverse
  options.keys = options.keys != false
  options.values = options.values != false
  options.limit = 'limit' in options ? options.limit : -1
  options.keyAsBuffer = options.keyAsBuffer != false
  options.valueAsBuffer = options.valueAsBuffer != false

  return options
}

AbstractLevelDOWN.prototype.iterator = function (options) {
  if (typeof options != 'object')
    options = {}

  options = this._setupIteratorOptions(options)

  if (typeof this._iterator == 'function')
    return this._iterator(options)

  return new AbstractIterator(this)
}

AbstractLevelDOWN.prototype._chainedBatch = function () {
  return new AbstractChainedBatch(this)
}

AbstractLevelDOWN.prototype._isBuffer = function (obj) {
  return Buffer.isBuffer(obj)
}

AbstractLevelDOWN.prototype._checkKey = function (obj, type) {

  if (obj === null || obj === undefined)
    return new Error(type + ' cannot be `null` or `undefined`')

  if (this._isBuffer(obj)) {
    if (obj.length === 0)
      return new Error(type + ' cannot be an empty Buffer')
  } else if (String(obj) === '')
    return new Error(type + ' cannot be an empty String')
}

module.exports = AbstractLevelDOWN

}).call(this)}).call(this,{"isBuffer":require("../../../../../is-buffer/index.js")},require('_process'))

      };
    };
  }
}, {package:"abstract-leveldown",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-leveldown.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/deferred-leveldown/deferred-iterator.js", {"abstract-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/deferred-leveldown/deferred-iterator.js
      return function (require, module, exports) {
var AbstractIterator = require('abstract-leveldown').AbstractIterator
var inherits = require('inherits')

function DeferredIterator (options) {
  AbstractIterator.call(this, options)

  this._options = options
  this._iterator = null
  this._operations = []
}

inherits(DeferredIterator, AbstractIterator)

DeferredIterator.prototype.setDb = function (db) {
  var it = this._iterator = db.iterator(this._options)
  this._operations.forEach(function (op) {
    it[op.method].apply(it, op.args)
  })
}

DeferredIterator.prototype._operation = function (method, args) {
  if (this._iterator) return this._iterator[method].apply(this._iterator, args)
  this._operations.push({ method: method, args: args })
}

'next end'.split(' ').forEach(function (m) {
  DeferredIterator.prototype['_' + m] = function () {
    this._operation(m, arguments)
  }
})

// Must defer seek() rather than _seek() because it requires db._serializeKey to be available
DeferredIterator.prototype.seek = function () {
  this._operation('seek', arguments)
}

module.exports = DeferredIterator

      };
    };
  }
}, {package:"deferred-leveldown",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/deferred-leveldown/deferred-iterator.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/readable-browser.js", {"./lib/_stream_duplex.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_passthrough.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/_stream_readable.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_transform.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_writable.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_writable.js","./lib/internal/streams/end-of-stream.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","./lib/internal/streams/pipeline.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/pipeline.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/readable-browser.js
      return function (require, module, exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/readable-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/constants/der.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/constants/der.js
      return function (require, module, exports) {
'use strict';

// Helper
function reverse(map) {
  const res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    const value = map[key];
    res[value] = key;
  });

  return res;
}

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = reverse(exports.tag);

      };
    };
  }
}, {package:"asn1.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/constants/der.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/reporter.js", {"inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/reporter.js
      return function (require, module, exports) {
'use strict';

const inherits = require('inherits');

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  const state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  const state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  const state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  const state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  const state = this._reporterState;

  const prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  const state = this._reporterState;

  const now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  let err;
  const state = this._reporterState;

  const inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  const state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
}
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};

      };
    };
  }
}, {package:"asn1.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/reporter.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/buffer.js", {"../base/reporter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/reporter.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/buffer.js
      return function (require, module, exports) {
'use strict';

const inherits = require('inherits');
const Reporter = require('../base/reporter').Reporter;
const Buffer = require('buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
  if (data instanceof DecoderBuffer) {
    return true;
  }

  // Or accept compatible API
  const isCompatible = typeof data === 'object' &&
    Buffer.isBuffer(data.base) &&
    data.constructor.name === 'DecoderBuffer' &&
    typeof data.offset === 'number' &&
    typeof data.length === 'number' &&
    typeof data.save === 'function' &&
    typeof data.restore === 'function' &&
    typeof data.isEmpty === 'function' &&
    typeof data.readUInt8 === 'function' &&
    typeof data.skip === 'function' &&
    typeof data.raw === 'function';

  return isCompatible;
};

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  const res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
};

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  const res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
};

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
};

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!EncoderBuffer.isEncoderBuffer(item))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
  if (data instanceof EncoderBuffer) {
    return true;
  }

  // Or accept compatible API
  const isCompatible = typeof data === 'object' &&
    data.constructor.name === 'EncoderBuffer' &&
    typeof data.length === 'number' &&
    typeof data.join === 'function';

  return isCompatible;
};

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

      };
    };
  }
}, {package:"asn1.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/buffer.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/node.js", {"../base/buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/buffer.js","../base/reporter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/reporter.js","minimalistic-assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/minimalistic-assert/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/node.js
      return function (require, module, exports) {
'use strict';

const Reporter = require('../base/reporter').Reporter;
const EncoderBuffer = require('../base/buffer').EncoderBuffer;
const DecoderBuffer = require('../base/buffer').DecoderBuffer;
const assert = require('minimalistic-assert');

// Supported tags
const tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
const methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
const overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent, name) {
  const state = {};
  this._baseState = state;

  state.name = name;
  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

const stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  const state = this._baseState;
  const cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  const res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  const state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      const clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  const state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  const state = this._baseState;

  // Filter children and args
  const children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      const res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        const value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    const state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  const state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  const state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  const state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  const state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  const state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  const state = this._baseState;
  const args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  const state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  const state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  const state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  const state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  const state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  let result = state['default'];
  let present = true;

  let prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    let tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      const save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  let prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      const explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    const start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      let save;
      if (state.any)
        save = input.save();
      const body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any) {
      // no-op
    } else if (state.choice === null) {
      result = this._decodeGeneric(state.tag, input, options);
    } else {
      result = this._decodeChoice(input, options);
    }

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      const data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
        ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  const state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
      ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  const state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  const state = this._baseState;
  let result = null;
  let match = false;

  Object.keys(state.choice).some(function(key) {
    const save = input.save();
    const node = state.choice[key];
    try {
      const value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  const state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  const result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  const state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  let result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default'];
    else
      return;
  }

  // Encode children first
  let content = null;
  let primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      const prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      const res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      const child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        const state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  if (!state.any && state.choice === null) {
    const tag = state.implicit !== null ? state.implicit : state.tag;
    const cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  const state = this._baseState;

  const node = state.choice[data.type];
  if (!node) {
    assert(
      false,
      data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  const state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};

      };
    };
  }
}, {package:"asn1.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/node.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/encoders/der.js", {"../base/node":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/node.js","../constants/der":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/constants/der.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/encoders/der.js
      return function (require, module, exports) {
'use strict';

const inherits = require('inherits');
const Buffer = require('buffer').Buffer;
const Node = require('../base/node');

// Import DER constants
const der = require('../constants/der');

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  Node.call(this, 'der', parent);
}
inherits(DERNode, Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
  primitive,
  cls,
  content) {
  const encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    const header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  let lenOctets = 1;
  for (let i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  const header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    const buf = new Buffer(str.length * 2);
    for (let i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s.]+/g);
    for (let i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (let i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  let size = 0;
  for (let i = 0; i < id.length; i++) {
    let ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  const objid = new Buffer(size);
  let offset = objid.length - 1;
  for (let i = id.length - 1; i >= 0; i--) {
    let ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  let str;
  const date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getUTCFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getUTCFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    const numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    let size = num.length;
    if (num.length === 0)
      size++;

    const out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0;
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  let size = 1;
  for (let i = num; i >= 0x100; i >>= 8)
    size++;

  const out = new Array(size);
  for (let i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  const state = this._baseState;
  let i;
  if (state['default'] === null)
    return false;

  const data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  let res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

      };
    };
  }
}, {package:"asn1.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/encoders/der.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/encoders/pem.js", {"./der":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/encoders/der.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/encoders/pem.js
      return function (require, module, exports) {
'use strict';

const inherits = require('inherits');

const DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
}
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  const buf = DEREncoder.prototype.encode.call(this, data);

  const p = buf.toString('base64');
  const out = [ '-----BEGIN ' + options.label + '-----' ];
  for (let i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

      };
    };
  }
}, {package:"asn1.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/encoders/pem.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/decoders/pem.js", {"./der":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/decoders/der.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/decoders/pem.js
      return function (require, module, exports) {
'use strict';

const inherits = require('inherits');
const Buffer = require('buffer').Buffer;

const DERDecoder = require('./der');

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
}
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  const lines = data.toString().split(/[\r\n]+/g);

  const label = options.label.toUpperCase();

  const re = /^-----(BEGIN|END) ([^-]+)-----$/;
  let start = -1;
  let end = -1;
  for (let i = 0; i < lines.length; i++) {
    const match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  const base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9+/=]+/gi, '');

  const input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

      };
    };
  }
}, {package:"asn1.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/decoders/pem.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/decoders/der.js", {"../base/buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/buffer.js","../base/node":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/node.js","../constants/der":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/constants/der.js","bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/decoders/der.js
      return function (require, module, exports) {
'use strict';

const inherits = require('inherits');

const bignum = require('bn.js');
const DecoderBuffer = require('../base/buffer').DecoderBuffer;
const Node = require('../base/node');

// Import DER constants
const der = require('../constants/der');

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!DecoderBuffer.isDecoderBuffer(data)) {
    data = new DecoderBuffer(data, options);
  }

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  Node.call(this, 'der', parent);
}
inherits(DERNode, Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  const state = buffer.save();
  const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  const decodedTag = derDecodeTag(buffer,
    'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  let len = derDecodeLen(buffer,
    decodedTag.primitive,
    'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  const state = buffer.save();
  const res = this._skipUntilEnd(
    buffer,
    'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  for (;;) {
    const tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    const len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    let res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len);
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
  options) {
  const result = [];
  while (!buffer.isEmpty()) {
    const possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    const res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    const unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    const raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    let str = '';
    for (let i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    const numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    const printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  let result;
  const identifiers = [];
  let ident = 0;
  let subident = 0;
  while (!buffer.isEmpty()) {
    subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  const first = (identifiers[0] / 40) | 0;
  const second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    let tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  const str = buffer.raw().toString();

  let year;
  let mon;
  let day;
  let hour;
  let min;
  let sec;
  if (tag === 'gentime') {
    year = str.slice(0, 4) | 0;
    mon = str.slice(4, 6) | 0;
    day = str.slice(6, 8) | 0;
    hour = str.slice(8, 10) | 0;
    min = str.slice(10, 12) | 0;
    sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    year = str.slice(0, 2) | 0;
    mon = str.slice(2, 4) | 0;
    day = str.slice(4, 6) | 0;
    hour = str.slice(6, 8) | 0;
    min = str.slice(8, 10) | 0;
    sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull() {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  const res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  const raw = buffer.raw();
  let res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  let tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  const cls = der.tagClass[tag >> 6];
  const primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    let oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  const tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  let len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  const num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (let i = 0; i < num; i++) {
    len <<= 8;
    const j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

      };
    };
  }
}, {package:"asn1.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/decoders/der.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/ecpointg.js", {"./bn":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/bn/index.js","./ecjpoint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/ecjpoint.js","./ecpoint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/ecpoint.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/ecpointg.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var BN = require('./bn')
var ECPoint = require('./ecpoint')
var ECJPoint = require('./ecjpoint')

function ECPointG () {
  this.x = BN.fromBuffer(Buffer.from('79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798', 'hex'))
  this.y = BN.fromBuffer(Buffer.from('483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8', 'hex'))
  this.inf = false

  this._precompute()
}

ECPointG.prototype._precompute = function () {
  var ecpoint = new ECPoint(this.x, this.y)

  var dstep = 4
  var points = new Array(1 + Math.ceil(257 / dstep))
  var acc = points[0] = ecpoint
  for (var i = 1; i < points.length; ++i) {
    for (var j = 0; j < dstep; j++) acc = acc.dbl()
    points[i] = acc
  }

  this.precomputed = {
    naf: ecpoint._getNAFPoints(7),
    doubles: {
      step: dstep,
      points: points,
      negpoints: points.map(function (p) { return p.neg() })
    }
  }
}

ECPointG.prototype.mul = function (num) {
  // Algorithm 3.42 Fixed-base NAF windowing method for point multiplication
  var step = this.precomputed.doubles.step
  var points = this.precomputed.doubles.points
  var negpoints = this.precomputed.doubles.negpoints

  var naf = num.getNAF(1)
  var I = ((1 << (step + 1)) - (step % 2 === 0 ? 2 : 1)) / 3

  // Translate into more windowed form
  var repr = []
  for (var j = 0; j < naf.length; j += step) {
    var nafW = 0
    for (var k = j + step - 1; k >= j; k--) nafW = (nafW << 1) + naf[k]
    repr.push(nafW)
  }

  var a = new ECJPoint(null, null, null)
  var b = new ECJPoint(null, null, null)
  for (var i = I; i > 0; i--) {
    for (var jj = 0; jj < repr.length; jj++) {
      if (repr[jj] === i) {
        b = b.mixedAdd(points[jj])
      } else if (repr[jj] === -i) {
        b = b.mixedAdd(negpoints[jj])
      }
    }

    a = a.add(b)
  }

  return ECPoint.fromECJPoint(a)
}

ECPointG.prototype.mulAdd = function (k1, p2, k2) {
  var nafPointsP1 = this.precomputed.naf
  var nafPointsP2 = p2._getNAFPoints1()
  var wnd = [nafPointsP1.points, nafPointsP2.points]
  var naf = [k1.getNAF(nafPointsP1.wnd), k2.getNAF(nafPointsP2.wnd)]

  var acc = new ECJPoint(null, null, null)
  var tmp = [null, null]
  for (var i = Math.max(naf[0].length, naf[1].length); i >= 0; i--) {
    var k = 0

    for (; i >= 0; ++k, --i) {
      tmp[0] = naf[0][i] | 0
      tmp[1] = naf[1][i] | 0

      if (tmp[0] !== 0 || tmp[1] !== 0) break
    }

    if (i >= 0) k += 1
    acc = acc.dblp(k)

    if (i < 0) break

    for (var jj = 0; jj < 2; jj++) {
      var z = tmp[jj]
      var p
      if (z === 0) {
        continue
      } else if (z > 0) {
        p = wnd[jj][z >> 1]
      } else if (z < 0) {
        p = wnd[jj][-z >> 1].neg()
      }

      // hack: ECPoint detection
      if (p.z === undefined) {
        acc = acc.mixedAdd(p)
      } else {
        acc = acc.add(p)
      }
    }
  }

  return acc
}

module.exports = new ECPointG()

      };
    };
  }
}, {package:"secp256k1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/ecpointg.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/ecpoint.js", {"./bn":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/bn/index.js","./ecjpoint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/ecjpoint.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/ecpoint.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var BN = require('./bn')
var ECJPoint = require('./ecjpoint')

function ECPoint (x, y) {
  if (x === null && y === null) {
    this.x = this.y = null
    this.inf = true
  } else {
    this.x = x
    this.y = y
    this.inf = false
  }
}

ECPoint.fromPublicKey = function (publicKey) {
  var first = publicKey[0]
  var x
  var y

  if (publicKey.length === 33 && (first === 0x02 || first === 0x03)) {
    x = BN.fromBuffer(publicKey.slice(1, 33))

    // overflow
    if (x.ucmp(BN.p) >= 0) return null

    // create from X
    y = x.redSqr().redMul(x).redIAdd7().redSqrt()
    if (y === null) return null
    if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

    return new ECPoint(x, y)
  }

  if (publicKey.length === 65 && (first === 0x04 || first === 0x06 || first === 0x07)) {
    x = BN.fromBuffer(publicKey.slice(1, 33))
    y = BN.fromBuffer(publicKey.slice(33, 65))

    // overflow
    if (x.ucmp(BN.p) >= 0 || y.ucmp(BN.p) >= 0) return null

    // is odd flag
    if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

    // x*x*x + 7 = y*y
    if (x.redSqr().redMul(x).redIAdd7().ucmp(y.redSqr()) !== 0) return null

    return new ECPoint(x, y)
  }

  return null
}

ECPoint.prototype.toPublicKey = function (compressed) {
  var x = this.x
  var y = this.y
  var publicKey

  if (compressed) {
    publicKey = Buffer.alloc(33)
    publicKey[0] = y.isOdd() ? 0x03 : 0x02
    x.toBuffer().copy(publicKey, 1)
  } else {
    publicKey = Buffer.alloc(65)
    publicKey[0] = 0x04
    x.toBuffer().copy(publicKey, 1)
    y.toBuffer().copy(publicKey, 33)
  }

  return publicKey
}

ECPoint.fromECJPoint = function (p) {
  if (p.inf) return new ECPoint(null, null)

  var zinv = p.z.redInvm()
  var zinv2 = zinv.redSqr()
  var ax = p.x.redMul(zinv2)
  var ay = p.y.redMul(zinv2).redMul(zinv)

  return new ECPoint(ax, ay)
}

ECPoint.prototype.toECJPoint = function () {
  if (this.inf) return new ECJPoint(null, null, null)

  return new ECJPoint(this.x, this.y, ECJPoint.one)
}

ECPoint.prototype.neg = function () {
  if (this.inf) return this

  return new ECPoint(this.x, this.y.redNeg())
}

ECPoint.prototype.add = function (p) {
  // O + P = P
  if (this.inf) return p

  // P + O = P
  if (p.inf) return this

  if (this.x.ucmp(p.x) === 0) {
    // P + P = 2P
    if (this.y.ucmp(p.y) === 0) return this.dbl()
    // P + (-P) = O
    return new ECPoint(null, null)
  }

  // s = (y - yp) / (x - xp)
  // nx = s^2 - x - xp
  // ny = s * (x - nx) - y
  var s = this.y.redSub(p.y)
  if (!s.isZero()) s = s.redMul(this.x.redSub(p.x).redInvm())

  var nx = s.redSqr().redISub(this.x).redISub(p.x)
  var ny = s.redMul(this.x.redSub(nx)).redISub(this.y)
  return new ECPoint(nx, ny)
}

ECPoint.prototype.dbl = function () {
  if (this.inf) return this

  // 2P = O
  var yy = this.y.redAdd(this.y)
  if (yy.isZero()) return new ECPoint(null, null)

  // s = (3 * x^2) / (2 * y)
  // nx = s^2 - 2*x
  // ny = s * (x - nx) - y
  var x2 = this.x.redSqr()
  var s = x2.redAdd(x2).redIAdd(x2).redMul(yy.redInvm())

  var nx = s.redSqr().redISub(this.x.redAdd(this.x))
  var ny = s.redMul(this.x.redSub(nx)).redISub(this.y)
  return new ECPoint(nx, ny)
}

ECPoint.prototype.mul = function (num) {
  // Algorithm 3.36 Window NAF method for point multiplication
  var nafPoints = this._getNAFPoints(4)
  var points = nafPoints.points

  // Get NAF form
  var naf = num.getNAF(nafPoints.wnd)

  // Add `this`*(N+1) for every w-NAF index
  var acc = new ECJPoint(null, null, null)
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--, ++k);
    if (i >= 0) k += 1
    acc = acc.dblp(k)

    if (i < 0) break

    // J +- P
    var z = naf[i]
    if (z > 0) {
      acc = acc.mixedAdd(points[(z - 1) >> 1])
    } else {
      acc = acc.mixedAdd(points[(-z - 1) >> 1].neg())
    }
  }

  return ECPoint.fromECJPoint(acc)
}

ECPoint.prototype._getNAFPoints1 = function () {
  return { wnd: 1, points: [this] }
}

ECPoint.prototype._getNAFPoints = function (wnd) {
  var points = new Array((1 << wnd) - 1)
  points[0] = this
  var dbl = this.dbl()
  for (var i = 1; i < points.length; ++i) points[i] = points[i - 1].add(dbl)
  return { wnd: wnd, points: points }
}

module.exports = ECPoint

      };
    };
  }
}, {package:"secp256k1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/ecpoint.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/drbg.js/hmac.js", {"./lib/hash-info.json":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/drbg.js/lib/hash-info.json","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","create-hmac":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/create-hmac/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/drbg.js/hmac.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'
var createHmac = require('create-hmac')
var hashInfo = require('./lib/hash-info.json')

var ebuf = new Buffer(0)
var b0x00 = new Buffer([ 0x00 ])
var b0x01 = new Buffer([ 0x01 ])

function HmacDRBG (algo, entropy, nonce, pers) {
  var info = hashInfo[algo]
  if (info === undefined) throw new Error('hash ' + algo + ' is not supported')

  this._algo = algo
  this._securityStrength = info.securityStrength / 8
  this._outlen = info.outlen / 8
  this._reseedInterval = 0x1000000000000 // 2**48

  this._init(entropy, nonce, pers)
}

HmacDRBG.prototype._update = function (seed) {
  var kmac = createHmac(this._algo, this._K).update(this._V).update(b0x00)
  if (seed) kmac.update(seed)

  this._K = kmac.digest()
  this._V = createHmac(this._algo, this._K).update(this._V).digest()
  if (!seed) return

  this._K = createHmac(this._algo, this._K).update(this._V).update(b0x01).update(seed).digest()
  this._V = createHmac(this._algo, this._K).update(this._V).digest()
}

HmacDRBG.prototype._init = function (entropy, nonce, pers) {
  if (entropy.length < this._securityStrength) throw new Error('Not enough entropy')

  this._K = new Buffer(this._outlen)
  this._V = new Buffer(this._outlen)
  for (var i = 0; i < this._K.length; ++i) {
    this._K[i] = 0x00
    this._V[i] = 0x01
  }

  this._update(Buffer.concat([ entropy, nonce, pers || ebuf ]))
  this._reseed = 1
}

HmacDRBG.prototype.reseed = function (entropy, add) {
  if (entropy.length < this._securityStrength) throw new Error('Not enough entropy')

  this._update(Buffer.concat([ entropy, add || ebuf ]))
  this._reseed = 1
}

HmacDRBG.prototype.generate = function (len, add) {
  if (this._reseed > this._reseedInterval) throw new Error('Reseed is required')

  if (add && add.length === 0) add = undefined
  if (add) this._update(add)

  var temp = new Buffer(0)
  while (temp.length < len) {
    this._V = createHmac(this._algo, this._K).update(this._V).digest()
    temp = Buffer.concat([ temp, this._V ])
  }

  this._update(add)
  this._reseed += 1
  return temp.slice(0, len)
}

module.exports = HmacDRBG

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"drbg.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/drbg.js/hmac.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/bn/index.js", {"./optimized":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/bn/optimized.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/bn/index.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var optimized = require('./optimized')

function BN () {
  this.negative = 0
  this.words = null
  this.length = 0
}

BN.fromNumber = function (n) {
  var bn = new BN()
  bn.words = [n & 0x03ffffff]
  bn.length = 1
  return bn
}

BN.fromBuffer = function (b32) {
  var bn = new BN()

  bn.words = new Array(10)
  bn.words[0] = (b32[28] & 0x03) << 24 | b32[29] << 16 | b32[30] << 8 | b32[31]
  bn.words[1] = (b32[25] & 0x0F) << 22 | b32[26] << 14 | b32[27] << 6 | b32[28] >>> 2
  bn.words[2] = (b32[22] & 0x3F) << 20 | b32[23] << 12 | b32[24] << 4 | b32[25] >>> 4
  bn.words[3] = (b32[19] & 0xFF) << 18 | b32[20] << 10 | b32[21] << 2 | b32[22] >>> 6

  bn.words[4] = (b32[15] & 0x03) << 24 | b32[16] << 16 | b32[17] << 8 | b32[18]
  bn.words[5] = (b32[12] & 0x0F) << 22 | b32[13] << 14 | b32[14] << 6 | b32[15] >>> 2
  bn.words[6] = (b32[9] & 0x3F) << 20 | b32[10] << 12 | b32[11] << 4 | b32[12] >>> 4
  bn.words[7] = (b32[6] & 0xFF) << 18 | b32[7] << 10 | b32[8] << 2 | b32[9] >>> 6

  bn.words[8] = (b32[2] & 0x03) << 24 | b32[3] << 16 | b32[4] << 8 | b32[5]
  bn.words[9] = b32[0] << 14 | b32[1] << 6 | b32[2] >>> 2

  bn.length = 10
  return bn.strip()
}

BN.prototype.toBuffer = function () {
  var w = this.words
  for (var i = this.length; i < 10; ++i) w[i] = 0

  return Buffer.from([
    (w[9] >>> 14) & 0xFF, (w[9] >>> 6) & 0xFF, (w[9] & 0x3F) << 2 | ((w[8] >>> 24) & 0x03), // 0, 1, 2
    (w[8] >>> 16) & 0xFF, (w[8] >>> 8) & 0xFF, w[8] & 0xFF, // 3, 4, 5

    (w[7] >>> 18) & 0xFF, (w[7] >>> 10) & 0xFF, (w[7] >>> 2) & 0xFF, // 6, 7, 8
    ((w[7] & 0x03) << 6) | ((w[6] >>> 20) & 0x3F), (w[6] >>> 12) & 0xFF, (w[6] >>> 4) & 0xFF, // 9, 10, 11
    ((w[6] & 0x0F) << 4) | ((w[5] >>> 22) & 0x0F), (w[5] >>> 14) & 0xFF, (w[5] >>> 6) & 0xFF, // 12, 13, 14
    ((w[5] & 0x3F) << 2) | ((w[4] >>> 24) & 0x03), (w[4] >>> 16) & 0xFF, (w[4] >>> 8) & 0xFF, w[4] & 0xFF, // 15, 16, 17, 18

    (w[3] >>> 18) & 0xFF, (w[3] >>> 10) & 0xFF, (w[3] >>> 2) & 0xFF, // 19, 20, 21
    ((w[3] & 0x03) << 6) | ((w[2] >>> 20) & 0x3F), (w[2] >>> 12) & 0xFF, (w[2] >>> 4) & 0xFF, // 22, 23, 24
    ((w[2] & 0x0F) << 4) | ((w[1] >>> 22) & 0x0F), (w[1] >>> 14) & 0xFF, (w[1] >>> 6) & 0xFF, // 25, 26, 27
    ((w[1] & 0x3F) << 2) | ((w[0] >>> 24) & 0x03), (w[0] >>> 16) & 0xFF, (w[0] >>> 8) & 0xFF, w[0] & 0xFF // 28, 29, 30, 31
  ])
}

BN.prototype.clone = function () {
  var r = new BN()
  r.words = new Array(this.length)
  for (var i = 0; i < this.length; i++) r.words[i] = this.words[i]
  r.length = this.length
  r.negative = this.negative
  return r
}

BN.prototype.strip = function () {
  while (this.length > 1 && (this.words[this.length - 1] | 0) === 0) this.length--
  return this
}

BN.prototype.normSign = function () {
  // -0 = 0
  if (this.length === 1 && this.words[0] === 0) this.negative = 0
  return this
}

BN.prototype.isEven = function () {
  return (this.words[0] & 1) === 0
}

BN.prototype.isOdd = function () {
  return (this.words[0] & 1) === 1
}

BN.prototype.isZero = function () {
  return this.length === 1 && this.words[0] === 0
}

BN.prototype.ucmp = function (num) {
  if (this.length !== num.length) return this.length > num.length ? 1 : -1

  for (var i = this.length - 1; i >= 0; --i) {
    if (this.words[i] !== num.words[i]) return this.words[i] > num.words[i] ? 1 : -1
  }

  return 0
}

BN.prototype.gtOne = function () {
  return this.length > 1 || this.words[0] > 1
}

BN.prototype.isOverflow = function () {
  return this.ucmp(BN.n) >= 0
}

BN.prototype.isHigh = function () {
  return this.ucmp(BN.nh) === 1
}

BN.prototype.bitLengthGT256 = function () {
  return this.length > 10 || (this.length === 10 && this.words[9] > 0x003fffff)
}

BN.prototype.iuaddn = function (num) {
  this.words[0] += num

  for (var i = 0; this.words[i] > 0x03ffffff && i < this.length; ++i) {
    this.words[i] -= 0x04000000
    this.words[i + 1] += 1
  }

  if (i === this.length) {
    this.words[i] = 1
    this.length += 1
  }

  return this
}

BN.prototype.iadd = function (num) {
  // (-this) + num -> -(this - num)
  // this + (-num) -> this - num
  if (this.negative !== num.negative) {
    if (this.negative !== 0) {
      this.negative = 0
      this.isub(num)
      this.negative ^= 1
    } else {
      num.negative = 0
      this.isub(num)
      num.negative = 1
    }

    return this.normSign()
  }

  // a.length > b.length
  var a
  var b
  if (this.length > num.length) {
    a = this
    b = num
  } else {
    a = num
    b = this
  }

  for (var i = 0, carry = 0; i < b.length; ++i) {
    var word = a.words[i] + b.words[i] + carry
    this.words[i] = word & 0x03ffffff
    carry = word >>> 26
  }

  for (; carry !== 0 && i < a.length; ++i) {
    word = a.words[i] + carry
    this.words[i] = word & 0x03ffffff
    carry = word >>> 26
  }

  this.length = a.length
  if (carry !== 0) {
    this.words[this.length++] = carry
  } else if (a !== this) {
    for (; i < a.length; ++i) {
      this.words[i] = a.words[i]
    }
  }

  return this
}

BN.prototype.add = function (num) {
  return this.clone().iadd(num)
}

BN.prototype.isub = function (num) {
  // (-this) - num -> -(this + num)
  // this - (-num) -> this + num
  if (this.negative !== num.negative) {
    if (this.negative !== 0) {
      this.negative = 0
      this.iadd(num)
      this.negative = 1
    } else {
      num.negative = 0
      this.iadd(num)
      num.negative = 1
    }

    return this.normSign()
  }

  var cmp = this.ucmp(num)
  if (cmp === 0) {
    this.negative = 0
    this.words[0] = 0
    this.length = 1
    return this
  }

  // a > b
  var a
  var b
  if (cmp > 0) {
    a = this
    b = num
  } else {
    a = num
    b = this
  }

  for (var i = 0, carry = 0; i < b.length; ++i) {
    var word = a.words[i] - b.words[i] + carry
    carry = word >> 26
    this.words[i] = word & 0x03ffffff
  }

  for (; carry !== 0 && i < a.length; ++i) {
    word = a.words[i] + carry
    carry = word >> 26
    this.words[i] = word & 0x03ffffff
  }

  if (carry === 0 && i < a.length && a !== this) {
    for (; i < a.length; ++i) this.words[i] = a.words[i]
  }

  this.length = Math.max(this.length, i)

  if (a !== this) this.negative ^= 1

  return this.strip().normSign()
}

BN.prototype.sub = function (num) {
  return this.clone().isub(num)
}

BN.umulTo = function (num1, num2, out) {
  out.length = num1.length + num2.length - 1

  var a1 = num1.words[0]
  var b1 = num2.words[0]
  var r1 = a1 * b1

  var carry = (r1 / 0x04000000) | 0
  out.words[0] = r1 & 0x03ffffff

  for (var k = 1, maxK = out.length; k < maxK; k++) {
    var ncarry = carry >>> 26
    var rword = carry & 0x03ffffff
    for (var j = Math.max(0, k - num1.length + 1), maxJ = Math.min(k, num2.length - 1); j <= maxJ; j++) {
      var i = k - j
      var a = num1.words[i]
      var b = num2.words[j]
      var r = a * b + rword
      ncarry += (r / 0x04000000) | 0
      rword = r & 0x03ffffff
    }
    out.words[k] = rword
    carry = ncarry
  }

  if (carry !== 0) out.words[out.length++] = carry

  return out.strip()
}

BN.umulTo10x10 = Math.imul ? optimized.umulTo10x10 : BN.umulTo

BN.umulnTo = function (num, k, out) {
  if (k === 0) {
    out.words = [0]
    out.length = 1
    return out
  }

  for (var i = 0, carry = 0; i < num.length; ++i) {
    var r = num.words[i] * k + carry
    out.words[i] = r & 0x03ffffff
    carry = (r / 0x04000000) | 0
  }

  if (carry > 0) {
    out.words[i] = carry
    out.length = num.length + 1
  } else {
    out.length = num.length
  }

  return out
}

BN.prototype.umul = function (num) {
  var out = new BN()
  out.words = new Array(this.length + num.length)

  if (this.length === 10 && num.length === 10) {
    return BN.umulTo10x10(this, num, out)
  } else if (this.length === 1) {
    return BN.umulnTo(num, this.words[0], out)
  } else if (num.length === 1) {
    return BN.umulnTo(this, num.words[0], out)
  } else {
    return BN.umulTo(this, num, out)
  }
}

BN.prototype.isplit = function (output) {
  output.length = Math.min(this.length, 9)
  for (var i = 0; i < output.length; ++i) output.words[i] = this.words[i]

  if (this.length <= 9) {
    this.words[0] = 0
    this.length = 1
    return this
  }

  // Shift by 9 limbs
  var prev = this.words[9]
  output.words[output.length++] = prev & 0x003fffff

  for (i = 10; i < this.length; ++i) {
    var word = this.words[i]
    this.words[i - 10] = ((word & 0x003fffff) << 4) | (prev >>> 22)
    prev = word
  }
  prev >>>= 22
  this.words[i - 10] = prev

  if (prev === 0 && this.length > 10) {
    this.length -= 10
  } else {
    this.length -= 9
  }

  return this
}

BN.prototype.fireduce = function () {
  if (this.isOverflow()) this.isub(BN.n)
  return this
}

BN.prototype.ureduce = function () {
  var num = this.clone().isplit(BN.tmp).umul(BN.nc).iadd(BN.tmp)
  if (num.bitLengthGT256()) {
    num = num.isplit(BN.tmp).umul(BN.nc).iadd(BN.tmp)
    if (num.bitLengthGT256()) num = num.isplit(BN.tmp).umul(BN.nc).iadd(BN.tmp)
  }

  return num.fireduce()
}

BN.prototype.ishrn = function (n) {
  var mask = (1 << n) - 1
  var m = 26 - n

  for (var i = this.length - 1, carry = 0; i >= 0; --i) {
    var word = this.words[i]
    this.words[i] = (carry << m) | (word >>> n)
    carry = word & mask
  }

  if (this.length > 1 && this.words[this.length - 1] === 0) this.length -= 1

  return this
}

BN.prototype.uinvm = function () {
  var x = this.clone()
  var y = BN.n.clone()

  // A * x + B * y = x
  var A = BN.fromNumber(1)
  var B = BN.fromNumber(0)

  // C * x + D * y = y
  var C = BN.fromNumber(0)
  var D = BN.fromNumber(1)

  while (x.isEven() && y.isEven()) {
    for (var k = 1, m = 1; (x.words[0] & m) === 0 && (y.words[0] & m) === 0 && k < 26; ++k, m <<= 1);
    x.ishrn(k)
    y.ishrn(k)
  }

  var yp = y.clone()
  var xp = x.clone()

  while (!x.isZero()) {
    for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
    if (i > 0) {
      x.ishrn(i)
      while (i-- > 0) {
        if (A.isOdd() || B.isOdd()) {
          A.iadd(yp)
          B.isub(xp)
        }

        A.ishrn(1)
        B.ishrn(1)
      }
    }

    for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
    if (j > 0) {
      y.ishrn(j)
      while (j-- > 0) {
        if (C.isOdd() || D.isOdd()) {
          C.iadd(yp)
          D.isub(xp)
        }

        C.ishrn(1)
        D.ishrn(1)
      }
    }

    if (x.ucmp(y) >= 0) {
      x.isub(y)
      A.isub(C)
      B.isub(D)
    } else {
      y.isub(x)
      C.isub(A)
      D.isub(B)
    }
  }

  if (C.negative === 1) {
    C.negative = 0
    var result = C.ureduce()
    result.negative ^= 1
    return result.normSign().iadd(BN.n)
  } else {
    return C.ureduce()
  }
}

BN.prototype.imulK = function () {
  this.words[this.length] = 0
  this.words[this.length + 1] = 0
  this.length += 2

  for (var i = 0, lo = 0; i < this.length; ++i) {
    var w = this.words[i] | 0
    lo += w * 0x3d1
    this.words[i] = lo & 0x03ffffff
    lo = w * 0x40 + ((lo / 0x04000000) | 0)
  }

  if (this.words[this.length - 1] === 0) {
    this.length -= 1
    if (this.words[this.length - 1] === 0) this.length -= 1
  }

  return this
}

BN.prototype.redIReduce = function () {
  this.isplit(BN.tmp).imulK().iadd(BN.tmp)
  if (this.bitLengthGT256()) this.isplit(BN.tmp).imulK().iadd(BN.tmp)

  var cmp = this.ucmp(BN.p)
  if (cmp === 0) {
    this.words[0] = 0
    this.length = 1
  } else if (cmp > 0) {
    this.isub(BN.p)
  } else {
    this.strip()
  }

  return this
}

BN.prototype.redNeg = function () {
  if (this.isZero()) return BN.fromNumber(0)

  return BN.p.sub(this)
}

BN.prototype.redAdd = function (num) {
  return this.clone().redIAdd(num)
}

BN.prototype.redIAdd = function (num) {
  this.iadd(num)
  if (this.ucmp(BN.p) >= 0) this.isub(BN.p)

  return this
}

BN.prototype.redIAdd7 = function () {
  this.iuaddn(7)
  if (this.ucmp(BN.p) >= 0) this.isub(BN.p)

  return this
}

BN.prototype.redSub = function (num) {
  return this.clone().redISub(num)
}

BN.prototype.redISub = function (num) {
  this.isub(num)
  if (this.negative !== 0) this.iadd(BN.p)

  return this
}

BN.prototype.redMul = function (num) {
  return this.umul(num).redIReduce()
}

BN.prototype.redSqr = function () {
  return this.umul(this).redIReduce()
}

BN.prototype.redSqrt = function () {
  if (this.isZero()) return this.clone()

  var wv2 = this.redSqr()
  var wv4 = wv2.redSqr()
  var wv12 = wv4.redSqr().redMul(wv4)
  var wv14 = wv12.redMul(wv2)
  var wv15 = wv14.redMul(this)

  var out = wv15
  for (var i = 0; i < 54; ++i) out = out.redSqr().redSqr().redSqr().redSqr().redMul(wv15)
  out = out.redSqr().redSqr().redSqr().redSqr().redMul(wv14)
  for (i = 0; i < 5; ++i) out = out.redSqr().redSqr().redSqr().redSqr().redMul(wv15)
  out = out.redSqr().redSqr().redSqr().redSqr().redMul(wv12)
  out = out.redSqr().redSqr().redSqr().redSqr().redSqr().redSqr().redMul(wv12)

  if (out.redSqr().ucmp(this) === 0) {
    return out
  } else {
    return null
  }
}

BN.prototype.redInvm = function () {
  var a = this.clone()
  var b = BN.p.clone()

  var x1 = BN.fromNumber(1)
  var x2 = BN.fromNumber(0)

  while (a.gtOne() && b.gtOne()) {
    for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
    if (i > 0) {
      a.ishrn(i)
      while (i-- > 0) {
        if (x1.isOdd()) x1.iadd(BN.p)
        x1.ishrn(1)
      }
    }

    for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
    if (j > 0) {
      b.ishrn(j)
      while (j-- > 0) {
        if (x2.isOdd()) x2.iadd(BN.p)
        x2.ishrn(1)
      }
    }

    if (a.ucmp(b) >= 0) {
      a.isub(b)
      x1.isub(x2)
    } else {
      b.isub(a)
      x2.isub(x1)
    }
  }

  var res
  if (a.length === 1 && a.words[0] === 1) {
    res = x1
  } else {
    res = x2
  }

  if (res.negative !== 0) res.iadd(BN.p)

  if (res.negative !== 0) {
    res.negative = 0
    return res.redIReduce().redNeg()
  } else {
    return res.redIReduce()
  }
}

BN.prototype.getNAF = function (w) {
  var naf = []
  var ws = 1 << (w + 1)
  var wsm1 = ws - 1
  var ws2 = ws >> 1

  var k = this.clone()
  while (!k.isZero()) {
    for (var i = 0, m = 1; (k.words[0] & m) === 0 && i < 26; ++i, m <<= 1) naf.push(0)

    if (i !== 0) {
      k.ishrn(i)
    } else {
      var mod = k.words[0] & wsm1
      if (mod >= ws2) {
        naf.push(ws2 - mod)
        k.iuaddn(mod - ws2).ishrn(1)
      } else {
        naf.push(mod)
        k.words[0] -= mod
        if (!k.isZero()) {
          for (i = w - 1; i > 0; --i) naf.push(0)
          k.ishrn(w)
        }
      }
    }
  }

  return naf
}

BN.prototype.inspect = function () {
  if (this.isZero()) return '0'

  var buffer = this.toBuffer().toString('hex')
  for (var i = 0; buffer[i] === '0'; ++i);
  return buffer.slice(i)
}

BN.n = BN.fromBuffer(Buffer.from('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141', 'hex'))
BN.nh = BN.n.clone().ishrn(1)
BN.nc = BN.fromBuffer(Buffer.from('000000000000000000000000000000014551231950B75FC4402DA1732FC9BEBF', 'hex'))
BN.p = BN.fromBuffer(Buffer.from('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F', 'hex'))
BN.psn = BN.p.sub(BN.n)
BN.tmp = new BN()
BN.tmp.words = new Array(10)

// WTF?! it speed-up benchmark on ~20%
;(function () {
  var x = BN.fromNumber(1)
  x.words[3] = 0
})()

module.exports = BN

      };
    };
  }
}, {package:"secp256k1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/bn/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/truncate-utf8-bytes/lib/truncate.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/truncate-utf8-bytes/lib/truncate.js
      return function (require, module, exports) {
'use strict';

function isHighSurrogate(codePoint) {
  return codePoint >= 0xd800 && codePoint <= 0xdbff;
}

function isLowSurrogate(codePoint) {
  return codePoint >= 0xdc00 && codePoint <= 0xdfff;
}

// Truncate string by size in bytes
module.exports = function truncate(getLength, string, byteLength) {
  if (typeof string !== "string") {
    throw new Error("Input must be string");
  }

  var charLength = string.length;
  var curByteLength = 0;
  var codePoint;
  var segment;

  for (var i = 0; i < charLength; i += 1) {
    codePoint = string.charCodeAt(i);
    segment = string[i];

    if (isHighSurrogate(codePoint) && isLowSurrogate(string.charCodeAt(i + 1))) {
      i += 1;
      segment += string[i];
    }

    curByteLength += getLength(segment);

    if (curByteLength === byteLength) {
      return string.slice(0, i + 1);
    }
    else if (curByteLength > byteLength) {
      return string.slice(0, i - segment.length + 1);
    }
  }

  return string;
};


      };
    };
  }
}, {package:"truncate-utf8-bytes",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/truncate-utf8-bytes/lib/truncate.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/utf8-byte-length/browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/utf8-byte-length/browser.js
      return function (require, module, exports) {
'use strict';

function isHighSurrogate(codePoint) {
  return codePoint >= 0xd800 && codePoint <= 0xdbff;
}

function isLowSurrogate(codePoint) {
  return codePoint >= 0xdc00 && codePoint <= 0xdfff;
}

// Truncate string by size in bytes
module.exports = function getByteLength(string) {
  if (typeof string !== "string") {
    throw new Error("Input must be string");
  }

  var charLength = string.length;
  var byteLength = 0;
  var codePoint = null;
  var prevCodePoint = null;
  for (var i = 0; i < charLength; i++) {
    codePoint = string.charCodeAt(i);
    // handle 4-byte non-BMP chars
    // low surrogate
    if (isLowSurrogate(codePoint)) {
      // when parsing previous hi-surrogate, 3 is added to byteLength
      if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
        byteLength += 1;
      }
      else {
        byteLength += 3;
      }
    }
    else if (codePoint <= 0x7f ) {
      byteLength += 1;
    }
    else if (codePoint >= 0x80 && codePoint <= 0x7ff) {
      byteLength += 2;
    }
    else if (codePoint >= 0x800 && codePoint <= 0xffff) {
      byteLength += 3;
    }
    prevCodePoint = codePoint;
  }

  return byteLength;
};

      };
    };
  }
}, {package:"utf8-byte-length",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/utf8-byte-length/browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/x509.js", {"./aes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/aes.js","./asn1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/asn1.js","./des":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/des.js","./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./md":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/md.js","./mgf":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/mgf.js","./oids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/oids.js","./pem":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pem.js","./pss":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pss.js","./rsa":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/rsa.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/x509.js
      return function (require, module, exports) {
/**
 * Javascript implementation of X.509 and related components (such as
 * Certification Signing Requests) of a Public Key Infrastructure.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The ASN.1 representation of an X.509v3 certificate is as follows
 * (see RFC 2459):
 *
 * Certificate ::= SEQUENCE {
 *   tbsCertificate       TBSCertificate,
 *   signatureAlgorithm   AlgorithmIdentifier,
 *   signatureValue       BIT STRING
 * }
 *
 * TBSCertificate ::= SEQUENCE {
 *   version         [0]  EXPLICIT Version DEFAULT v1,
 *   serialNumber         CertificateSerialNumber,
 *   signature            AlgorithmIdentifier,
 *   issuer               Name,
 *   validity             Validity,
 *   subject              Name,
 *   subjectPublicKeyInfo SubjectPublicKeyInfo,
 *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   extensions      [3]  EXPLICIT Extensions OPTIONAL
 *                        -- If present, version shall be v3
 * }
 *
 * Version ::= INTEGER  { v1(0), v2(1), v3(2) }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * Name ::= CHOICE {
 *   // only one possible choice for now
 *   RDNSequence
 * }
 *
 * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
 *
 * RelativeDistinguishedName ::= SET OF AttributeTypeAndValue
 *
 * AttributeTypeAndValue ::= SEQUENCE {
 *   type     AttributeType,
 *   value    AttributeValue
 * }
 * AttributeType ::= OBJECT IDENTIFIER
 * AttributeValue ::= ANY DEFINED BY AttributeType
 *
 * Validity ::= SEQUENCE {
 *   notBefore      Time,
 *   notAfter       Time
 * }
 *
 * Time ::= CHOICE {
 *   utcTime        UTCTime,
 *   generalTime    GeneralizedTime
 * }
 *
 * UniqueIdentifier ::= BIT STRING
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm            AlgorithmIdentifier,
 *   subjectPublicKey     BIT STRING
 * }
 *
 * Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension
 *
 * Extension ::= SEQUENCE {
 *   extnID      OBJECT IDENTIFIER,
 *   critical    BOOLEAN DEFAULT FALSE,
 *   extnValue   OCTET STRING
 * }
 *
 * The only key algorithm currently supported for PKI is RSA.
 *
 * RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.
 *
 * PKCS#10 v1.7 describes certificate signing requests:
 *
 * CertificationRequestInfo:
 *
 * CertificationRequestInfo ::= SEQUENCE {
 *   version       INTEGER { v1(0) } (v1,...),
 *   subject       Name,
 *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
 *   attributes    [0] Attributes{{ CRIAttributes }}
 * }
 *
 * Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}
 *
 * CRIAttributes  ATTRIBUTE  ::= {
 *   ... -- add any locally defined attributes here -- }
 *
 * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
 *   type   ATTRIBUTE.&id({IOSet}),
 *   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
 * }
 *
 * CertificationRequest ::= SEQUENCE {
 *   certificationRequestInfo CertificationRequestInfo,
 *   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},
 *   signature          BIT STRING
 * }
 */
var forge = require('./forge');
require('./aes');
require('./asn1');
require('./des');
require('./md');
require('./mgf');
require('./oids');
require('./pem');
require('./pss');
require('./rsa');
require('./util');

// shortcut for asn.1 API
var asn1 = forge.asn1;

/* Public Key Infrastructure (PKI) implementation. */
var pki = module.exports = forge.pki = forge.pki || {};
var oids = pki.oids;

// short name OID mappings
var _shortNames = {};
_shortNames['CN'] = oids['commonName'];
_shortNames['commonName'] = 'CN';
_shortNames['C'] = oids['countryName'];
_shortNames['countryName'] = 'C';
_shortNames['L'] = oids['localityName'];
_shortNames['localityName'] = 'L';
_shortNames['ST'] = oids['stateOrProvinceName'];
_shortNames['stateOrProvinceName'] = 'ST';
_shortNames['O'] = oids['organizationName'];
_shortNames['organizationName'] = 'O';
_shortNames['OU'] = oids['organizationalUnitName'];
_shortNames['organizationalUnitName'] = 'OU';
_shortNames['E'] = oids['emailAddress'];
_shortNames['emailAddress'] = 'E';

// validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key
var publicKeyValidator = forge.pki.rsa.publicKeyValidator;

// validator for an X.509v3 certificate
var x509CertificateValidator = {
  name: 'Certificate',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'Certificate.TBSCertificate',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: 'tbsCertificate',
    value: [{
      name: 'Certificate.TBSCertificate.version',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: true,
      optional: true,
      value: [{
        name: 'Certificate.TBSCertificate.version.integer',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'certVersion'
      }]
    }, {
      name: 'Certificate.TBSCertificate.serialNumber',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: 'certSerialNumber'
    }, {
      name: 'Certificate.TBSCertificate.signature',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'Certificate.TBSCertificate.signature.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'certinfoSignatureOid'
      }, {
        name: 'Certificate.TBSCertificate.signature.parameters',
        tagClass: asn1.Class.UNIVERSAL,
        optional: true,
        captureAsn1: 'certinfoSignatureParams'
      }]
    }, {
      name: 'Certificate.TBSCertificate.issuer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'certIssuer'
    }, {
      name: 'Certificate.TBSCertificate.validity',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      // Note: UTC and generalized times may both appear so the capture
      // names are based on their detected order, the names used below
      // are only for the common case, which validity time really means
      // "notBefore" and which means "notAfter" will be determined by order
      value: [{
        // notBefore (Time) (UTC time case)
        name: 'Certificate.TBSCertificate.validity.notBefore (utc)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.UTCTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity1UTCTime'
      }, {
        // notBefore (Time) (generalized time case)
        name: 'Certificate.TBSCertificate.validity.notBefore (generalized)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.GENERALIZEDTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity2GeneralizedTime'
      }, {
        // notAfter (Time) (only UTC time is supported)
        name: 'Certificate.TBSCertificate.validity.notAfter (utc)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.UTCTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity3UTCTime'
      }, {
        // notAfter (Time) (only UTC time is supported)
        name: 'Certificate.TBSCertificate.validity.notAfter (generalized)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.GENERALIZEDTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity4GeneralizedTime'
      }]
    }, {
      // Name (subject) (RDNSequence)
      name: 'Certificate.TBSCertificate.subject',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'certSubject'
    },
    // SubjectPublicKeyInfo
    publicKeyValidator,
    {
      // issuerUniqueID (optional)
      name: 'Certificate.TBSCertificate.issuerUniqueID',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 1,
      constructed: true,
      optional: true,
      value: [{
        name: 'Certificate.TBSCertificate.issuerUniqueID.id',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        // TODO: support arbitrary bit length ids
        captureBitStringValue: 'certIssuerUniqueId'
      }]
    }, {
      // subjectUniqueID (optional)
      name: 'Certificate.TBSCertificate.subjectUniqueID',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 2,
      constructed: true,
      optional: true,
      value: [{
        name: 'Certificate.TBSCertificate.subjectUniqueID.id',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        // TODO: support arbitrary bit length ids
        captureBitStringValue: 'certSubjectUniqueId'
      }]
    }, {
      // Extensions (optional)
      name: 'Certificate.TBSCertificate.extensions',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 3,
      constructed: true,
      captureAsn1: 'certExtensions',
      optional: true
    }]
  }, {
    // AlgorithmIdentifier (signature algorithm)
    name: 'Certificate.signatureAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      // algorithm
      name: 'Certificate.signatureAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'certSignatureOid'
    }, {
      name: 'Certificate.TBSCertificate.signature.parameters',
      tagClass: asn1.Class.UNIVERSAL,
      optional: true,
      captureAsn1: 'certSignatureParams'
    }]
  }, {
    // SignatureValue
    name: 'Certificate.signatureValue',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.BITSTRING,
    constructed: false,
    captureBitStringValue: 'certSignature'
  }]
};

var rsassaPssParameterValidator = {
  name: 'rsapss',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'rsapss.hashAlgorithm',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    value: [{
      name: 'rsapss.hashAlgorithm.AlgorithmIdentifier',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.SEQUENCE,
      constructed: true,
      optional: true,
      value: [{
        name: 'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'hashOid'
        /* parameter block omitted, for SHA1 NULL anyhow. */
      }]
    }]
  }, {
    name: 'rsapss.maskGenAlgorithm',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: true,
    value: [{
      name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.SEQUENCE,
      constructed: true,
      optional: true,
      value: [{
        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'maskGenOid'
      }, {
        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'maskGenHashOid'
          /* parameter block omitted, for SHA1 NULL anyhow. */
        }]
      }]
    }]
  }, {
    name: 'rsapss.saltLength',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 2,
    optional: true,
    value: [{
      name: 'rsapss.saltLength.saltLength',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.INTEGER,
      constructed: false,
      capture: 'saltLength'
    }]
  }, {
    name: 'rsapss.trailerField',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 3,
    optional: true,
    value: [{
      name: 'rsapss.trailer.trailer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.INTEGER,
      constructed: false,
      capture: 'trailer'
    }]
  }]
};

// validator for a CertificationRequestInfo structure
var certificationRequestInfoValidator = {
  name: 'CertificationRequestInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: 'certificationRequestInfo',
  value: [{
    name: 'CertificationRequestInfo.integer',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'certificationRequestInfoVersion'
  }, {
    // Name (subject) (RDNSequence)
    name: 'CertificationRequestInfo.subject',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: 'certificationRequestInfoSubject'
  },
  // SubjectPublicKeyInfo
  publicKeyValidator,
  {
    name: 'CertificationRequestInfo.attributes',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    capture: 'certificationRequestInfoAttributes',
    value: [{
      name: 'CertificationRequestInfo.attributes',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'CertificationRequestInfo.attributes.type',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false
      }, {
        name: 'CertificationRequestInfo.attributes.value',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true
      }]
    }]
  }]
};

// validator for a CertificationRequest structure
var certificationRequestValidator = {
  name: 'CertificationRequest',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: 'csr',
  value: [
    certificationRequestInfoValidator, {
      // AlgorithmIdentifier (signature algorithm)
      name: 'CertificationRequest.signatureAlgorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // algorithm
        name: 'CertificationRequest.signatureAlgorithm.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'csrSignatureOid'
      }, {
        name: 'CertificationRequest.signatureAlgorithm.parameters',
        tagClass: asn1.Class.UNIVERSAL,
        optional: true,
        captureAsn1: 'csrSignatureParams'
      }]
    }, {
      // signature
      name: 'CertificationRequest.signature',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.BITSTRING,
      constructed: false,
      captureBitStringValue: 'csrSignature'
    }
  ]
};

/**
 * Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName
 * sets into an array with objects that have type and value properties.
 *
 * @param rdn the RDNSequence to convert.
 * @param md a message digest to append type and value to if provided.
 */
pki.RDNAttributesAsArray = function(rdn, md) {
  var rval = [];

  // each value in 'rdn' in is a SET of RelativeDistinguishedName
  var set, attr, obj;
  for(var si = 0; si < rdn.value.length; ++si) {
    // get the RelativeDistinguishedName set
    set = rdn.value[si];

    // each value in the SET is an AttributeTypeAndValue sequence
    // containing first a type (an OID) and second a value (defined by
    // the OID)
    for(var i = 0; i < set.value.length; ++i) {
      obj = {};
      attr = set.value[i];
      obj.type = asn1.derToOid(attr.value[0].value);
      obj.value = attr.value[1].value;
      obj.valueTagClass = attr.value[1].type;
      // if the OID is known, get its name and short name
      if(obj.type in oids) {
        obj.name = oids[obj.type];
        if(obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }
      if(md) {
        md.update(obj.type);
        md.update(obj.value);
      }
      rval.push(obj);
    }
  }

  return rval;
};

/**
 * Converts ASN.1 CRIAttributes into an array with objects that have type and
 * value properties.
 *
 * @param attributes the CRIAttributes to convert.
 */
pki.CRIAttributesAsArray = function(attributes) {
  var rval = [];

  // each value in 'attributes' in is a SEQUENCE with an OID and a SET
  for(var si = 0; si < attributes.length; ++si) {
    // get the attribute sequence
    var seq = attributes[si];

    // each value in the SEQUENCE containing first a type (an OID) and
    // second a set of values (defined by the OID)
    var type = asn1.derToOid(seq.value[0].value);
    var values = seq.value[1].value;
    for(var vi = 0; vi < values.length; ++vi) {
      var obj = {};
      obj.type = type;
      obj.value = values[vi].value;
      obj.valueTagClass = values[vi].type;
      // if the OID is known, get its name and short name
      if(obj.type in oids) {
        obj.name = oids[obj.type];
        if(obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }
      // parse extensions
      if(obj.type === oids.extensionRequest) {
        obj.extensions = [];
        for(var ei = 0; ei < obj.value.length; ++ei) {
          obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
        }
      }
      rval.push(obj);
    }
  }

  return rval;
};

/**
 * Gets an issuer or subject attribute from its name, type, or short name.
 *
 * @param obj the issuer or subject object.
 * @param options a short name string or an object with:
 *          shortName the short name for the attribute.
 *          name the name for the attribute.
 *          type the type for the attribute.
 *
 * @return the attribute.
 */
function _getAttribute(obj, options) {
  if(typeof options === 'string') {
    options = {shortName: options};
  }

  var rval = null;
  var attr;
  for(var i = 0; rval === null && i < obj.attributes.length; ++i) {
    attr = obj.attributes[i];
    if(options.type && options.type === attr.type) {
      rval = attr;
    } else if(options.name && options.name === attr.name) {
      rval = attr;
    } else if(options.shortName && options.shortName === attr.shortName) {
      rval = attr;
    }
  }
  return rval;
}

/**
 * Converts signature parameters from ASN.1 structure.
 *
 * Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had
 * no parameters.
 *
 * RSASSA-PSS-params  ::=  SEQUENCE  {
 *   hashAlgorithm      [0] HashAlgorithm DEFAULT
 *                             sha1Identifier,
 *   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT
 *                             mgf1SHA1Identifier,
 *   saltLength         [2] INTEGER DEFAULT 20,
 *   trailerField       [3] INTEGER DEFAULT 1
 * }
 *
 * HashAlgorithm  ::=  AlgorithmIdentifier
 *
 * MaskGenAlgorithm  ::=  AlgorithmIdentifier
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * @param oid The OID specifying the signature algorithm
 * @param obj The ASN.1 structure holding the parameters
 * @param fillDefaults Whether to use return default values where omitted
 * @return signature parameter object
 */
var _readSignatureParameters = function(oid, obj, fillDefaults) {
  var params = {};

  if(oid !== oids['RSASSA-PSS']) {
    return params;
  }

  if(fillDefaults) {
    params = {
      hash: {
        algorithmOid: oids['sha1']
      },
      mgf: {
        algorithmOid: oids['mgf1'],
        hash: {
          algorithmOid: oids['sha1']
        }
      },
      saltLength: 20
    };
  }

  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
    var error = new Error('Cannot read RSASSA-PSS parameter block.');
    error.errors = errors;
    throw error;
  }

  if(capture.hashOid !== undefined) {
    params.hash = params.hash || {};
    params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
  }

  if(capture.maskGenOid !== undefined) {
    params.mgf = params.mgf || {};
    params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
    params.mgf.hash = params.mgf.hash || {};
    params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
  }

  if(capture.saltLength !== undefined) {
    params.saltLength = capture.saltLength.charCodeAt(0);
  }

  return params;
};

/**
 * Converts an X.509 certificate from PEM format.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. This will scan the TBSCertificate part of the ASN.1
 * object while it is converted so it doesn't need to be converted back
 * to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certificate.
 */
pki.certificateFromPem = function(pem, computeHash, strict) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'CERTIFICATE' &&
    msg.type !== 'X509 CERTIFICATE' &&
    msg.type !== 'TRUSTED CERTIFICATE') {
    var error = new Error(
      'Could not convert certificate from PEM; PEM header type ' +
      'is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error(
      'Could not convert certificate from PEM; PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body, strict);

  return pki.certificateFromAsn1(obj, computeHash);
};

/**
 * Converts an X.509 certificate to PEM format.
 *
 * @param cert the certificate.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certificate.
 */
pki.certificateToPem = function(cert, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'CERTIFICATE',
    body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Converts an RSA public key from PEM format.
 *
 * @param pem the PEM-formatted public key.
 *
 * @return the public key.
 */
pki.publicKeyFromPem = function(pem) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'PUBLIC KEY' && msg.type !== 'RSA PUBLIC KEY') {
    var error = new Error('Could not convert public key from PEM; PEM header ' +
      'type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert public key from PEM; PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body);

  return pki.publicKeyFromAsn1(obj);
};

/**
 * Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */
pki.publicKeyToPem = function(key, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'PUBLIC KEY',
    body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Converts an RSA public key to PEM format (using an RSAPublicKey).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */
pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'RSA PUBLIC KEY',
    body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Gets a fingerprint for the given public key.
 *
 * @param options the options to use.
 *          [md] the message digest object to use (defaults to forge.md.sha1).
 *          [type] the type of fingerprint, such as 'RSAPublicKey',
 *            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').
 *          [encoding] an alternative output encoding, such as 'hex'
 *            (defaults to none, outputs a byte buffer).
 *          [delimiter] the delimiter to use between bytes for 'hex' encoded
 *            output, eg: ':' (defaults to none).
 *
 * @return the fingerprint as a byte buffer or other encoding based on options.
 */
pki.getPublicKeyFingerprint = function(key, options) {
  options = options || {};
  var md = options.md || forge.md.sha1.create();
  var type = options.type || 'RSAPublicKey';

  var bytes;
  switch(type) {
    case 'RSAPublicKey':
      bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
      break;
    case 'SubjectPublicKeyInfo':
      bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
      break;
    default:
      throw new Error('Unknown fingerprint type "' + options.type + '".');
  }

  // hash public key bytes
  md.start();
  md.update(bytes);
  var digest = md.digest();
  if(options.encoding === 'hex') {
    var hex = digest.toHex();
    if(options.delimiter) {
      return hex.match(/.{2}/g).join(options.delimiter);
    }
    return hex;
  } else if(options.encoding === 'binary') {
    return digest.getBytes();
  } else if(options.encoding) {
    throw new Error('Unknown encoding "' + options.encoding + '".');
  }
  return digest;
};

/**
 * Converts a PKCS#10 certification request (CSR) from PEM format.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. This will scan the CertificationRequestInfo part of
 * the ASN.1 object while it is converted so it doesn't need to be converted
 * back to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certification request (CSR).
 */
pki.certificationRequestFromPem = function(pem, computeHash, strict) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'CERTIFICATE REQUEST') {
    var error = new Error('Could not convert certification request from PEM; ' +
      'PEM header type is not "CERTIFICATE REQUEST".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert certification request from PEM; ' +
      'PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body, strict);

  return pki.certificationRequestFromAsn1(obj, computeHash);
};

/**
 * Converts a PKCS#10 certification request (CSR) to PEM format.
 *
 * @param csr the certification request.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certification request.
 */
pki.certificationRequestToPem = function(csr, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'CERTIFICATE REQUEST',
    body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Creates an empty X.509v3 RSA certificate.
 *
 * @return the certificate.
 */
pki.createCertificate = function() {
  var cert = {};
  cert.version = 0x02;
  cert.serialNumber = '00';
  cert.signatureOid = null;
  cert.signature = null;
  cert.siginfo = {};
  cert.siginfo.algorithmOid = null;
  cert.validity = {};
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = new Date();

  cert.issuer = {};
  cert.issuer.getField = function(sn) {
    return _getAttribute(cert.issuer, sn);
  };
  cert.issuer.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.issuer.attributes.push(attr);
  };
  cert.issuer.attributes = [];
  cert.issuer.hash = null;

  cert.subject = {};
  cert.subject.getField = function(sn) {
    return _getAttribute(cert.subject, sn);
  };
  cert.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.subject.attributes.push(attr);
  };
  cert.subject.attributes = [];
  cert.subject.hash = null;

  cert.extensions = [];
  cert.publicKey = null;
  cert.md = null;

  /**
   * Sets the subject of this certificate.
   *
   * @param attrs the array of subject attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */
  cert.setSubject = function(attrs, uniqueId) {
    // set new attributes, clear hash
    _fillMissingFields(attrs);
    cert.subject.attributes = attrs;
    delete cert.subject.uniqueId;
    if(uniqueId) {
      // TODO: support arbitrary bit length ids
      cert.subject.uniqueId = uniqueId;
    }
    cert.subject.hash = null;
  };

  /**
   * Sets the issuer of this certificate.
   *
   * @param attrs the array of issuer attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */
  cert.setIssuer = function(attrs, uniqueId) {
    // set new attributes, clear hash
    _fillMissingFields(attrs);
    cert.issuer.attributes = attrs;
    delete cert.issuer.uniqueId;
    if(uniqueId) {
      // TODO: support arbitrary bit length ids
      cert.issuer.uniqueId = uniqueId;
    }
    cert.issuer.hash = null;
  };

  /**
   * Sets the extensions of this certificate.
   *
   * @param exts the array of extensions to use.
   */
  cert.setExtensions = function(exts) {
    for(var i = 0; i < exts.length; ++i) {
      _fillMissingExtensionFields(exts[i], {cert: cert});
    }
    // set new extensions
    cert.extensions = exts;
  };

  /**
   * Gets an extension by its name or id.
   *
   * @param options the name to use or an object with:
   *          name the name to use.
   *          id the id to use.
   *
   * @return the extension or null if not found.
   */
  cert.getExtension = function(options) {
    if(typeof options === 'string') {
      options = {name: options};
    }

    var rval = null;
    var ext;
    for(var i = 0; rval === null && i < cert.extensions.length; ++i) {
      ext = cert.extensions[i];
      if(options.id && ext.id === options.id) {
        rval = ext;
      } else if(options.name && ext.name === options.name) {
        rval = ext;
      }
    }
    return rval;
  };

  /**
   * Signs this certificate using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */
  cert.sign = function(key, md) {
    // TODO: get signature OID from private key
    cert.md = md || forge.md.sha1.create();
    var algorithmOid = oids[cert.md.algorithm + 'WithRSAEncryption'];
    if(!algorithmOid) {
      var error = new Error('Could not compute certificate digest. ' +
        'Unknown message digest algorithm OID.');
      error.algorithm = cert.md.algorithm;
      throw error;
    }
    cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;

    // get TBSCertificate, convert to DER
    cert.tbsCertificate = pki.getTBSCertificate(cert);
    var bytes = asn1.toDer(cert.tbsCertificate);

    // digest and sign
    cert.md.update(bytes.getBytes());
    cert.signature = key.sign(cert.md);
  };

  /**
   * Attempts verify the signature on the passed certificate using this
   * certificate's public key.
   *
   * @param child the certificate to verify.
   *
   * @return true if verified, false if not.
   */
  cert.verify = function(child) {
    var rval = false;

    if(!cert.issued(child)) {
      var issuer = child.issuer;
      var subject = cert.subject;
      var error = new Error(
        'The parent certificate did not issue the given child ' +
        'certificate; the child certificate\'s issuer does not match the ' +
        'parent\'s subject.');
      error.expectedIssuer = issuer.attributes;
      error.actualIssuer = subject.attributes;
      throw error;
    }

    var md = child.md;
    if(md === null) {
      // check signature OID for supported signature types
      if(child.signatureOid in oids) {
        var oid = oids[child.signatureOid];
        switch(oid) {
          case 'sha1WithRSAEncryption':
            md = forge.md.sha1.create();
            break;
          case 'md5WithRSAEncryption':
            md = forge.md.md5.create();
            break;
          case 'sha256WithRSAEncryption':
            md = forge.md.sha256.create();
            break;
          case 'sha384WithRSAEncryption':
            md = forge.md.sha384.create();
            break;
          case 'sha512WithRSAEncryption':
            md = forge.md.sha512.create();
            break;
          case 'RSASSA-PSS':
            md = forge.md.sha256.create();
            break;
        }
      }
      if(md === null) {
        var error = new Error('Could not compute certificate digest. ' +
          'Unknown signature OID.');
        error.signatureOid = child.signatureOid;
        throw error;
      }

      // produce DER formatted TBSCertificate and digest it
      var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
      var bytes = asn1.toDer(tbsCertificate);
      md.update(bytes.getBytes());
    }

    if(md !== null) {
      var scheme;

      switch(child.signatureOid) {
        case oids.sha1WithRSAEncryption:
          scheme = undefined; /* use PKCS#1 v1.5 padding scheme */
          break;
        case oids['RSASSA-PSS']:
          var hash, mgf;

          /* initialize mgf */
          hash = oids[child.signatureParameters.mgf.hash.algorithmOid];
          if(hash === undefined || forge.md[hash] === undefined) {
            var error = new Error('Unsupported MGF hash function.');
            error.oid = child.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash;
            throw error;
          }

          mgf = oids[child.signatureParameters.mgf.algorithmOid];
          if(mgf === undefined || forge.mgf[mgf] === undefined) {
            var error = new Error('Unsupported MGF function.');
            error.oid = child.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }

          mgf = forge.mgf[mgf].create(forge.md[hash].create());

          /* initialize hash function */
          hash = oids[child.signatureParameters.hash.algorithmOid];
          if(hash === undefined || forge.md[hash] === undefined) {
            throw {
              message: 'Unsupported RSASSA-PSS hash function.',
              oid: child.signatureParameters.hash.algorithmOid,
              name: hash
            };
          }

          scheme = forge.pss.create(forge.md[hash].create(), mgf,
            child.signatureParameters.saltLength);
          break;
      }

      // verify signature on cert using public key
      rval = cert.publicKey.verify(
        md.digest().getBytes(), child.signature, scheme);
    }

    return rval;
  };

  /**
   * Returns true if this certificate's issuer matches the passed
   * certificate's subject. Note that no signature check is performed.
   *
   * @param parent the certificate to check.
   *
   * @return true if this certificate's issuer matches the passed certificate's
   *         subject.
   */
  cert.isIssuer = function(parent) {
    var rval = false;

    var i = cert.issuer;
    var s = parent.subject;

    // compare hashes if present
    if(i.hash && s.hash) {
      rval = (i.hash === s.hash);
    } else if(i.attributes.length === s.attributes.length) {
      // all attributes are the same so issuer matches subject
      rval = true;
      var iattr, sattr;
      for(var n = 0; rval && n < i.attributes.length; ++n) {
        iattr = i.attributes[n];
        sattr = s.attributes[n];
        if(iattr.type !== sattr.type || iattr.value !== sattr.value) {
          // attribute mismatch
          rval = false;
        }
      }
    }

    return rval;
  };

  /**
   * Returns true if this certificate's subject matches the issuer of the
   * given certificate). Note that not signature check is performed.
   *
   * @param child the certificate to check.
   *
   * @return true if this certificate's subject matches the passed
   *         certificate's issuer.
   */
  cert.issued = function(child) {
    return child.isIssuer(cert);
  };

  /**
   * Generates the subjectKeyIdentifier for this certificate as byte buffer.
   *
   * @return the subjectKeyIdentifier for this certificate as byte buffer.
   */
  cert.generateSubjectKeyIdentifier = function() {
    /* See: 4.2.1.2 section of the the RFC3280, keyIdentifier is either:

      (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
        value of the BIT STRING subjectPublicKey (excluding the tag,
        length, and number of unused bits).

      (2) The keyIdentifier is composed of a four bit type field with
        the value 0100 followed by the least significant 60 bits of the
        SHA-1 hash of the value of the BIT STRING subjectPublicKey
        (excluding the tag, length, and number of unused bit string bits).
    */

    // skipping the tag, length, and number of unused bits is the same
    // as just using the RSAPublicKey (for RSA keys, which are the
    // only ones supported)
    return pki.getPublicKeyFingerprint(cert.publicKey, {type: 'RSAPublicKey'});
  };

  /**
   * Verifies the subjectKeyIdentifier extension value for this certificate
   * against its public key. If no extension is found, false will be
   * returned.
   *
   * @return true if verified, false if not.
   */
  cert.verifySubjectKeyIdentifier = function() {
    var oid = oids['subjectKeyIdentifier'];
    for(var i = 0; i < cert.extensions.length; ++i) {
      var ext = cert.extensions[i];
      if(ext.id === oid) {
        var ski = cert.generateSubjectKeyIdentifier().getBytes();
        return (forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski);
      }
    }
    return false;
  };

  return cert;
};

/**
 * Converts an X.509v3 RSA certificate from an ASN.1 object.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the TBSCertificate part of the ASN.1
 * object needs to be scanned before the cert object is created.
 *
 * @param obj the asn1 representation of an X.509v3 RSA certificate.
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certificate.
 */
pki.certificateFromAsn1 = function(obj, computeHash) {
  // validate certificate and capture data
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
    var error = new Error('Cannot read X.509 certificate. ' +
      'ASN.1 object is not an X509v3 Certificate.');
    error.errors = errors;
    throw error;
  }

  // get oid
  var oid = asn1.derToOid(capture.publicKeyOid);
  if(oid !== pki.oids.rsaEncryption) {
    throw new Error('Cannot read public key. OID is not RSA.');
  }

  // create certificate
  var cert = pki.createCertificate();
  cert.version = capture.certVersion ?
    capture.certVersion.charCodeAt(0) : 0;
  var serial = forge.util.createBuffer(capture.certSerialNumber);
  cert.serialNumber = serial.toHex();
  cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
  cert.signatureParameters = _readSignatureParameters(
    cert.signatureOid, capture.certSignatureParams, true);
  cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
  cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid,
    capture.certinfoSignatureParams, false);
  cert.signature = capture.certSignature;

  var validity = [];
  if(capture.certValidity1UTCTime !== undefined) {
    validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
  }
  if(capture.certValidity2GeneralizedTime !== undefined) {
    validity.push(asn1.generalizedTimeToDate(
      capture.certValidity2GeneralizedTime));
  }
  if(capture.certValidity3UTCTime !== undefined) {
    validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
  }
  if(capture.certValidity4GeneralizedTime !== undefined) {
    validity.push(asn1.generalizedTimeToDate(
      capture.certValidity4GeneralizedTime));
  }
  if(validity.length > 2) {
    throw new Error('Cannot read notBefore/notAfter validity times; more ' +
      'than two times were provided in the certificate.');
  }
  if(validity.length < 2) {
    throw new Error('Cannot read notBefore/notAfter validity times; they ' +
      'were not provided as either UTCTime or GeneralizedTime.');
  }
  cert.validity.notBefore = validity[0];
  cert.validity.notAfter = validity[1];

  // keep TBSCertificate to preserve signature when exporting
  cert.tbsCertificate = capture.tbsCertificate;

  if(computeHash) {
    // check signature OID for supported signature types
    cert.md = null;
    if(cert.signatureOid in oids) {
      var oid = oids[cert.signatureOid];
      switch(oid) {
        case 'sha1WithRSAEncryption':
          cert.md = forge.md.sha1.create();
          break;
        case 'md5WithRSAEncryption':
          cert.md = forge.md.md5.create();
          break;
        case 'sha256WithRSAEncryption':
          cert.md = forge.md.sha256.create();
          break;
        case 'sha384WithRSAEncryption':
          cert.md = forge.md.sha384.create();
          break;
        case 'sha512WithRSAEncryption':
          cert.md = forge.md.sha512.create();
          break;
        case 'RSASSA-PSS':
          cert.md = forge.md.sha256.create();
          break;
      }
    }
    if(cert.md === null) {
      var error = new Error('Could not compute certificate digest. ' +
        'Unknown signature OID.');
      error.signatureOid = cert.signatureOid;
      throw error;
    }

    // produce DER formatted TBSCertificate and digest it
    var bytes = asn1.toDer(cert.tbsCertificate);
    cert.md.update(bytes.getBytes());
  }

  // handle issuer, build issuer message digest
  var imd = forge.md.sha1.create();
  cert.issuer.getField = function(sn) {
    return _getAttribute(cert.issuer, sn);
  };
  cert.issuer.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.issuer.attributes.push(attr);
  };
  cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);
  if(capture.certIssuerUniqueId) {
    cert.issuer.uniqueId = capture.certIssuerUniqueId;
  }
  cert.issuer.hash = imd.digest().toHex();

  // handle subject, build subject message digest
  var smd = forge.md.sha1.create();
  cert.subject.getField = function(sn) {
    return _getAttribute(cert.subject, sn);
  };
  cert.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.subject.attributes.push(attr);
  };
  cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd);
  if(capture.certSubjectUniqueId) {
    cert.subject.uniqueId = capture.certSubjectUniqueId;
  }
  cert.subject.hash = smd.digest().toHex();

  // handle extensions
  if(capture.certExtensions) {
    cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
  } else {
    cert.extensions = [];
  }

  // convert RSA public key from ASN.1
  cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);

  return cert;
};

/**
 * Converts an ASN.1 extensions object (with extension sequences as its
 * values) into an array of extension objects with types and values.
 *
 * Supported extensions:
 *
 * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
 * KeyUsage ::= BIT STRING {
 *   digitalSignature        (0),
 *   nonRepudiation          (1),
 *   keyEncipherment         (2),
 *   dataEncipherment        (3),
 *   keyAgreement            (4),
 *   keyCertSign             (5),
 *   cRLSign                 (6),
 *   encipherOnly            (7),
 *   decipherOnly            (8)
 * }
 *
 * id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }
 * BasicConstraints ::= SEQUENCE {
 *   cA                      BOOLEAN DEFAULT FALSE,
 *   pathLenConstraint       INTEGER (0..MAX) OPTIONAL
 * }
 *
 * subjectAltName EXTENSION ::= {
 *   SYNTAX GeneralNames
 *   IDENTIFIED BY id-ce-subjectAltName
 * }
 *
 * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
 *
 * GeneralName ::= CHOICE {
 *   otherName      [0] INSTANCE OF OTHER-NAME,
 *   rfc822Name     [1] IA5String,
 *   dNSName        [2] IA5String,
 *   x400Address    [3] ORAddress,
 *   directoryName  [4] Name,
 *   ediPartyName   [5] EDIPartyName,
 *   uniformResourceIdentifier [6] IA5String,
 *   IPAddress      [7] OCTET STRING,
 *   registeredID   [8] OBJECT IDENTIFIER
 * }
 *
 * OTHER-NAME ::= TYPE-IDENTIFIER
 *
 * EDIPartyName ::= SEQUENCE {
 *   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,
 *   partyName    [1] DirectoryString {ub-name}
 * }
 *
 * @param exts the extensions ASN.1 with extension sequences to parse.
 *
 * @return the array.
 */
pki.certificateExtensionsFromAsn1 = function(exts) {
  var rval = [];
  for(var i = 0; i < exts.value.length; ++i) {
    // get extension sequence
    var extseq = exts.value[i];
    for(var ei = 0; ei < extseq.value.length; ++ei) {
      rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
    }
  }

  return rval;
};

/**
 * Parses a single certificate extension from ASN.1.
 *
 * @param ext the extension in ASN.1 format.
 *
 * @return the parsed extension as an object.
 */
pki.certificateExtensionFromAsn1 = function(ext) {
  // an extension has:
  // [0] extnID      OBJECT IDENTIFIER
  // [1] critical    BOOLEAN DEFAULT FALSE
  // [2] extnValue   OCTET STRING
  var e = {};
  e.id = asn1.derToOid(ext.value[0].value);
  e.critical = false;
  if(ext.value[1].type === asn1.Type.BOOLEAN) {
    e.critical = (ext.value[1].value.charCodeAt(0) !== 0x00);
    e.value = ext.value[2].value;
  } else {
    e.value = ext.value[1].value;
  }
  // if the oid is known, get its name
  if(e.id in oids) {
    e.name = oids[e.id];

    // handle key usage
    if(e.name === 'keyUsage') {
      // get value as BIT STRING
      var ev = asn1.fromDer(e.value);
      var b2 = 0x00;
      var b3 = 0x00;
      if(ev.value.length > 1) {
        // skip first byte, just indicates unused bits which
        // will be padded with 0s anyway
        // get bytes with flag bits
        b2 = ev.value.charCodeAt(1);
        b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
      }
      // set flags
      e.digitalSignature = (b2 & 0x80) === 0x80;
      e.nonRepudiation = (b2 & 0x40) === 0x40;
      e.keyEncipherment = (b2 & 0x20) === 0x20;
      e.dataEncipherment = (b2 & 0x10) === 0x10;
      e.keyAgreement = (b2 & 0x08) === 0x08;
      e.keyCertSign = (b2 & 0x04) === 0x04;
      e.cRLSign = (b2 & 0x02) === 0x02;
      e.encipherOnly = (b2 & 0x01) === 0x01;
      e.decipherOnly = (b3 & 0x80) === 0x80;
    } else if(e.name === 'basicConstraints') {
      // handle basic constraints
      // get value as SEQUENCE
      var ev = asn1.fromDer(e.value);
      // get cA BOOLEAN flag (defaults to false)
      if(ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
        e.cA = (ev.value[0].value.charCodeAt(0) !== 0x00);
      } else {
        e.cA = false;
      }
      // get path length constraint
      var value = null;
      if(ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
        value = ev.value[0].value;
      } else if(ev.value.length > 1) {
        value = ev.value[1].value;
      }
      if(value !== null) {
        e.pathLenConstraint = asn1.derToInteger(value);
      }
    } else if(e.name === 'extKeyUsage') {
      // handle extKeyUsage
      // value is a SEQUENCE of OIDs
      var ev = asn1.fromDer(e.value);
      for(var vi = 0; vi < ev.value.length; ++vi) {
        var oid = asn1.derToOid(ev.value[vi].value);
        if(oid in oids) {
          e[oids[oid]] = true;
        } else {
          e[oid] = true;
        }
      }
    } else if(e.name === 'nsCertType') {
      // handle nsCertType
      // get value as BIT STRING
      var ev = asn1.fromDer(e.value);
      var b2 = 0x00;
      if(ev.value.length > 1) {
        // skip first byte, just indicates unused bits which
        // will be padded with 0s anyway
        // get bytes with flag bits
        b2 = ev.value.charCodeAt(1);
      }
      // set flags
      e.client = (b2 & 0x80) === 0x80;
      e.server = (b2 & 0x40) === 0x40;
      e.email = (b2 & 0x20) === 0x20;
      e.objsign = (b2 & 0x10) === 0x10;
      e.reserved = (b2 & 0x08) === 0x08;
      e.sslCA = (b2 & 0x04) === 0x04;
      e.emailCA = (b2 & 0x02) === 0x02;
      e.objCA = (b2 & 0x01) === 0x01;
    } else if(
      e.name === 'subjectAltName' ||
      e.name === 'issuerAltName') {
      // handle subjectAltName/issuerAltName
      e.altNames = [];

      // ev is a SYNTAX SEQUENCE
      var gn;
      var ev = asn1.fromDer(e.value);
      for(var n = 0; n < ev.value.length; ++n) {
        // get GeneralName
        gn = ev.value[n];

        var altName = {
          type: gn.type,
          value: gn.value
        };
        e.altNames.push(altName);

        // Note: Support for types 1,2,6,7,8
        switch(gn.type) {
          // rfc822Name
          case 1:
          // dNSName
          case 2:
          // uniformResourceIdentifier (URI)
          case 6:
            break;
          // IPAddress
          case 7:
            // convert to IPv4/IPv6 string representation
            altName.ip = forge.util.bytesToIP(gn.value);
            break;
          // registeredID
          case 8:
            altName.oid = asn1.derToOid(gn.value);
            break;
          default:
            // unsupported
        }
      }
    } else if(e.name === 'subjectKeyIdentifier') {
      // value is an OCTETSTRING w/the hash of the key-type specific
      // public key structure (eg: RSAPublicKey)
      var ev = asn1.fromDer(e.value);
      e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
    }
  }
  return e;
};

/**
 * Converts a PKCS#10 certification request (CSR) from an ASN.1 object.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the CertificationRequestInfo part of the
 * ASN.1 object needs to be scanned before the csr object is created.
 *
 * @param obj the asn1 representation of a PKCS#10 certification request (CSR).
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certification request (CSR).
 */
pki.certificationRequestFromAsn1 = function(obj, computeHash) {
  // validate certification request and capture data
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
    var error = new Error('Cannot read PKCS#10 certificate request. ' +
      'ASN.1 object is not a PKCS#10 CertificationRequest.');
    error.errors = errors;
    throw error;
  }

  // get oid
  var oid = asn1.derToOid(capture.publicKeyOid);
  if(oid !== pki.oids.rsaEncryption) {
    throw new Error('Cannot read public key. OID is not RSA.');
  }

  // create certification request
  var csr = pki.createCertificationRequest();
  csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
  csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
  csr.signatureParameters = _readSignatureParameters(
    csr.signatureOid, capture.csrSignatureParams, true);
  csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
  csr.siginfo.parameters = _readSignatureParameters(
    csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
  csr.signature = capture.csrSignature;

  // keep CertificationRequestInfo to preserve signature when exporting
  csr.certificationRequestInfo = capture.certificationRequestInfo;

  if(computeHash) {
    // check signature OID for supported signature types
    csr.md = null;
    if(csr.signatureOid in oids) {
      var oid = oids[csr.signatureOid];
      switch(oid) {
        case 'sha1WithRSAEncryption':
          csr.md = forge.md.sha1.create();
          break;
        case 'md5WithRSAEncryption':
          csr.md = forge.md.md5.create();
          break;
        case 'sha256WithRSAEncryption':
          csr.md = forge.md.sha256.create();
          break;
        case 'sha384WithRSAEncryption':
          csr.md = forge.md.sha384.create();
          break;
        case 'sha512WithRSAEncryption':
          csr.md = forge.md.sha512.create();
          break;
        case 'RSASSA-PSS':
          csr.md = forge.md.sha256.create();
          break;
      }
    }
    if(csr.md === null) {
      var error = new Error('Could not compute certification request digest. ' +
        'Unknown signature OID.');
      error.signatureOid = csr.signatureOid;
      throw error;
    }

    // produce DER formatted CertificationRequestInfo and digest it
    var bytes = asn1.toDer(csr.certificationRequestInfo);
    csr.md.update(bytes.getBytes());
  }

  // handle subject, build subject message digest
  var smd = forge.md.sha1.create();
  csr.subject.getField = function(sn) {
    return _getAttribute(csr.subject, sn);
  };
  csr.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    csr.subject.attributes.push(attr);
  };
  csr.subject.attributes = pki.RDNAttributesAsArray(
    capture.certificationRequestInfoSubject, smd);
  csr.subject.hash = smd.digest().toHex();

  // convert RSA public key from ASN.1
  csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);

  // convert attributes from ASN.1
  csr.getAttribute = function(sn) {
    return _getAttribute(csr, sn);
  };
  csr.addAttribute = function(attr) {
    _fillMissingFields([attr]);
    csr.attributes.push(attr);
  };
  csr.attributes = pki.CRIAttributesAsArray(
    capture.certificationRequestInfoAttributes || []);

  return csr;
};

/**
 * Creates an empty certification request (a CSR or certificate signing
 * request). Once created, its public key and attributes can be set and then
 * it can be signed.
 *
 * @return the empty certification request.
 */
pki.createCertificationRequest = function() {
  var csr = {};
  csr.version = 0x00;
  csr.signatureOid = null;
  csr.signature = null;
  csr.siginfo = {};
  csr.siginfo.algorithmOid = null;

  csr.subject = {};
  csr.subject.getField = function(sn) {
    return _getAttribute(csr.subject, sn);
  };
  csr.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    csr.subject.attributes.push(attr);
  };
  csr.subject.attributes = [];
  csr.subject.hash = null;

  csr.publicKey = null;
  csr.attributes = [];
  csr.getAttribute = function(sn) {
    return _getAttribute(csr, sn);
  };
  csr.addAttribute = function(attr) {
    _fillMissingFields([attr]);
    csr.attributes.push(attr);
  };
  csr.md = null;

  /**
   * Sets the subject of this certification request.
   *
   * @param attrs the array of subject attributes to use.
   */
  csr.setSubject = function(attrs) {
    // set new attributes
    _fillMissingFields(attrs);
    csr.subject.attributes = attrs;
    csr.subject.hash = null;
  };

  /**
   * Sets the attributes of this certification request.
   *
   * @param attrs the array of attributes to use.
   */
  csr.setAttributes = function(attrs) {
    // set new attributes
    _fillMissingFields(attrs);
    csr.attributes = attrs;
  };

  /**
   * Signs this certification request using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */
  csr.sign = function(key, md) {
    // TODO: get signature OID from private key
    csr.md = md || forge.md.sha1.create();
    var algorithmOid = oids[csr.md.algorithm + 'WithRSAEncryption'];
    if(!algorithmOid) {
      var error = new Error('Could not compute certification request digest. ' +
        'Unknown message digest algorithm OID.');
      error.algorithm = csr.md.algorithm;
      throw error;
    }
    csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;

    // get CertificationRequestInfo, convert to DER
    csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
    var bytes = asn1.toDer(csr.certificationRequestInfo);

    // digest and sign
    csr.md.update(bytes.getBytes());
    csr.signature = key.sign(csr.md);
  };

  /**
   * Attempts verify the signature on the passed certification request using
   * its public key.
   *
   * A CSR that has been exported to a file in PEM format can be verified using
   * OpenSSL using this command:
   *
   * openssl req -in <the-csr-pem-file> -verify -noout -text
   *
   * @return true if verified, false if not.
   */
  csr.verify = function() {
    var rval = false;

    var md = csr.md;
    if(md === null) {
      // check signature OID for supported signature types
      if(csr.signatureOid in oids) {
        // TODO: create DRY `OID to md` function
        var oid = oids[csr.signatureOid];
        switch(oid) {
          case 'sha1WithRSAEncryption':
            md = forge.md.sha1.create();
            break;
          case 'md5WithRSAEncryption':
            md = forge.md.md5.create();
            break;
          case 'sha256WithRSAEncryption':
            md = forge.md.sha256.create();
            break;
          case 'sha384WithRSAEncryption':
            md = forge.md.sha384.create();
            break;
          case 'sha512WithRSAEncryption':
            md = forge.md.sha512.create();
            break;
          case 'RSASSA-PSS':
            md = forge.md.sha256.create();
            break;
        }
      }
      if(md === null) {
        var error = new Error(
          'Could not compute certification request digest. ' +
          'Unknown signature OID.');
        error.signatureOid = csr.signatureOid;
        throw error;
      }

      // produce DER formatted CertificationRequestInfo and digest it
      var cri = csr.certificationRequestInfo ||
        pki.getCertificationRequestInfo(csr);
      var bytes = asn1.toDer(cri);
      md.update(bytes.getBytes());
    }

    if(md !== null) {
      var scheme;

      switch(csr.signatureOid) {
        case oids.sha1WithRSAEncryption:
          /* use PKCS#1 v1.5 padding scheme */
          break;
        case oids['RSASSA-PSS']:
          var hash, mgf;

          /* initialize mgf */
          hash = oids[csr.signatureParameters.mgf.hash.algorithmOid];
          if(hash === undefined || forge.md[hash] === undefined) {
            var error = new Error('Unsupported MGF hash function.');
            error.oid = csr.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash;
            throw error;
          }

          mgf = oids[csr.signatureParameters.mgf.algorithmOid];
          if(mgf === undefined || forge.mgf[mgf] === undefined) {
            var error = new Error('Unsupported MGF function.');
            error.oid = csr.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }

          mgf = forge.mgf[mgf].create(forge.md[hash].create());

          /* initialize hash function */
          hash = oids[csr.signatureParameters.hash.algorithmOid];
          if(hash === undefined || forge.md[hash] === undefined) {
            var error = new Error('Unsupported RSASSA-PSS hash function.');
            error.oid = csr.signatureParameters.hash.algorithmOid;
            error.name = hash;
            throw error;
          }

          scheme = forge.pss.create(forge.md[hash].create(), mgf,
            csr.signatureParameters.saltLength);
          break;
      }

      // verify signature on csr using its public key
      rval = csr.publicKey.verify(
        md.digest().getBytes(), csr.signature, scheme);
    }

    return rval;
  };

  return csr;
};

/**
 * Converts an X.509 subject or issuer to an ASN.1 RDNSequence.
 *
 * @param obj the subject or issuer (distinguished name).
 *
 * @return the ASN.1 RDNSequence.
 */
function _dnToAsn1(obj) {
  // create an empty RDNSequence
  var rval = asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);

  // iterate over attributes
  var attr, set;
  var attrs = obj.attributes;
  for(var i = 0; i < attrs.length; ++i) {
    attr = attrs[i];
    var value = attr.value;

    // reuse tag class for attribute value if available
    var valueTagClass = asn1.Type.PRINTABLESTRING;
    if('valueTagClass' in attr) {
      valueTagClass = attr.valueTagClass;

      if(valueTagClass === asn1.Type.UTF8) {
        value = forge.util.encodeUtf8(value);
      }
      // FIXME: handle more encodings
    }

    // create a RelativeDistinguishedName set
    // each value in the set is an AttributeTypeAndValue first
    // containing the type (an OID) and second the value
    set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AttributeType
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(attr.type).getBytes()),
        // AttributeValue
        asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
      ])
    ]);
    rval.value.push(set);
  }

  return rval;
}

/**
 * Gets all printable attributes (typically of an issuer or subject) in a
 * simplified JSON format for display.
 *
 * @param attrs the attributes.
 *
 * @return the JSON for display.
 */
function _getAttributesAsJson(attrs) {
  var rval = {};
  for(var i = 0; i < attrs.length; ++i) {
    var attr = attrs[i];
    if(attr.shortName && (
      attr.valueTagClass === asn1.Type.UTF8 ||
      attr.valueTagClass === asn1.Type.PRINTABLESTRING ||
      attr.valueTagClass === asn1.Type.IA5STRING)) {
      var value = attr.value;
      if(attr.valueTagClass === asn1.Type.UTF8) {
        value = forge.util.encodeUtf8(attr.value);
      }
      if(!(attr.shortName in rval)) {
        rval[attr.shortName] = value;
      } else if(forge.util.isArray(rval[attr.shortName])) {
        rval[attr.shortName].push(value);
      } else {
        rval[attr.shortName] = [rval[attr.shortName], value];
      }
    }
  }
  return rval;
}

/**
 * Fills in missing fields in attributes.
 *
 * @param attrs the attributes to fill missing fields in.
 */
function _fillMissingFields(attrs) {
  var attr;
  for(var i = 0; i < attrs.length; ++i) {
    attr = attrs[i];

    // populate missing name
    if(typeof attr.name === 'undefined') {
      if(attr.type && attr.type in pki.oids) {
        attr.name = pki.oids[attr.type];
      } else if(attr.shortName && attr.shortName in _shortNames) {
        attr.name = pki.oids[_shortNames[attr.shortName]];
      }
    }

    // populate missing type (OID)
    if(typeof attr.type === 'undefined') {
      if(attr.name && attr.name in pki.oids) {
        attr.type = pki.oids[attr.name];
      } else {
        var error = new Error('Attribute type not specified.');
        error.attribute = attr;
        throw error;
      }
    }

    // populate missing shortname
    if(typeof attr.shortName === 'undefined') {
      if(attr.name && attr.name in _shortNames) {
        attr.shortName = _shortNames[attr.name];
      }
    }

    // convert extensions to value
    if(attr.type === oids.extensionRequest) {
      attr.valueConstructed = true;
      attr.valueTagClass = asn1.Type.SEQUENCE;
      if(!attr.value && attr.extensions) {
        attr.value = [];
        for(var ei = 0; ei < attr.extensions.length; ++ei) {
          attr.value.push(pki.certificateExtensionToAsn1(
            _fillMissingExtensionFields(attr.extensions[ei])));
        }
      }
    }

    if(typeof attr.value === 'undefined') {
      var error = new Error('Attribute value not specified.');
      error.attribute = attr;
      throw error;
    }
  }
}

/**
 * Fills in missing fields in certificate extensions.
 *
 * @param e the extension.
 * @param [options] the options to use.
 *          [cert] the certificate the extensions are for.
 *
 * @return the extension.
 */
function _fillMissingExtensionFields(e, options) {
  options = options || {};

  // populate missing name
  if(typeof e.name === 'undefined') {
    if(e.id && e.id in pki.oids) {
      e.name = pki.oids[e.id];
    }
  }

  // populate missing id
  if(typeof e.id === 'undefined') {
    if(e.name && e.name in pki.oids) {
      e.id = pki.oids[e.name];
    } else {
      var error = new Error('Extension ID not specified.');
      error.extension = e;
      throw error;
    }
  }

  if(typeof e.value !== 'undefined') {
    return e;
  }

  // handle missing value:

  // value is a BIT STRING
  if(e.name === 'keyUsage') {
    // build flags
    var unused = 0;
    var b2 = 0x00;
    var b3 = 0x00;
    if(e.digitalSignature) {
      b2 |= 0x80;
      unused = 7;
    }
    if(e.nonRepudiation) {
      b2 |= 0x40;
      unused = 6;
    }
    if(e.keyEncipherment) {
      b2 |= 0x20;
      unused = 5;
    }
    if(e.dataEncipherment) {
      b2 |= 0x10;
      unused = 4;
    }
    if(e.keyAgreement) {
      b2 |= 0x08;
      unused = 3;
    }
    if(e.keyCertSign) {
      b2 |= 0x04;
      unused = 2;
    }
    if(e.cRLSign) {
      b2 |= 0x02;
      unused = 1;
    }
    if(e.encipherOnly) {
      b2 |= 0x01;
      unused = 0;
    }
    if(e.decipherOnly) {
      b3 |= 0x80;
      unused = 7;
    }

    // create bit string
    var value = String.fromCharCode(unused);
    if(b3 !== 0) {
      value += String.fromCharCode(b2) + String.fromCharCode(b3);
    } else if(b2 !== 0) {
      value += String.fromCharCode(b2);
    }
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
  } else if(e.name === 'basicConstraints') {
    // basicConstraints is a SEQUENCE
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    // cA BOOLEAN flag defaults to false
    if(e.cA) {
      e.value.value.push(asn1.create(
        asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false,
        String.fromCharCode(0xFF)));
    }
    if('pathLenConstraint' in e) {
      e.value.value.push(asn1.create(
        asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
        asn1.integerToDer(e.pathLenConstraint).getBytes()));
    }
  } else if(e.name === 'extKeyUsage') {
    // extKeyUsage is a SEQUENCE of OIDs
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var seq = e.value.value;
    for(var key in e) {
      if(e[key] !== true) {
        continue;
      }
      // key is name in OID map
      if(key in oids) {
        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID,
          false, asn1.oidToDer(oids[key]).getBytes()));
      } else if(key.indexOf('.') !== -1) {
        // assume key is an OID
        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID,
          false, asn1.oidToDer(key).getBytes()));
      }
    }
  } else if(e.name === 'nsCertType') {
    // nsCertType is a BIT STRING
    // build flags
    var unused = 0;
    var b2 = 0x00;

    if(e.client) {
      b2 |= 0x80;
      unused = 7;
    }
    if(e.server) {
      b2 |= 0x40;
      unused = 6;
    }
    if(e.email) {
      b2 |= 0x20;
      unused = 5;
    }
    if(e.objsign) {
      b2 |= 0x10;
      unused = 4;
    }
    if(e.reserved) {
      b2 |= 0x08;
      unused = 3;
    }
    if(e.sslCA) {
      b2 |= 0x04;
      unused = 2;
    }
    if(e.emailCA) {
      b2 |= 0x02;
      unused = 1;
    }
    if(e.objCA) {
      b2 |= 0x01;
      unused = 0;
    }

    // create bit string
    var value = String.fromCharCode(unused);
    if(b2 !== 0) {
      value += String.fromCharCode(b2);
    }
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
  } else if(e.name === 'subjectAltName' || e.name === 'issuerAltName') {
    // SYNTAX SEQUENCE
    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);

    var altName;
    for(var n = 0; n < e.altNames.length; ++n) {
      altName = e.altNames[n];
      var value = altName.value;
      // handle IP
      if(altName.type === 7 && altName.ip) {
        value = forge.util.bytesFromIP(altName.ip);
        if(value === null) {
          var error = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.');
          error.extension = e;
          throw error;
        }
      } else if(altName.type === 8) {
        // handle OID
        if(altName.oid) {
          value = asn1.oidToDer(asn1.oidToDer(altName.oid));
        } else {
          // deprecated ... convert value to OID
          value = asn1.oidToDer(value);
        }
      }
      e.value.value.push(asn1.create(
        asn1.Class.CONTEXT_SPECIFIC, altName.type, false,
        value));
    }
  } else if(e.name === 'nsComment' && options.cert) {
    // sanity check value is ASCII (req'd) and not too big
    if(!(/^[\x00-\x7F]*$/.test(e.comment)) ||
      (e.comment.length < 1) || (e.comment.length > 128)) {
      throw new Error('Invalid "nsComment" content.');
    }
    // IA5STRING opaque comment
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);
  } else if(e.name === 'subjectKeyIdentifier' && options.cert) {
    var ski = options.cert.generateSubjectKeyIdentifier();
    e.subjectKeyIdentifier = ski.toHex();
    // OCTETSTRING w/digest
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());
  } else if(e.name === 'authorityKeyIdentifier' && options.cert) {
    // SYNTAX SEQUENCE
    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var seq = e.value.value;

    if(e.keyIdentifier) {
      var keyIdentifier = (e.keyIdentifier === true ?
        options.cert.generateSubjectKeyIdentifier().getBytes() :
        e.keyIdentifier);
      seq.push(
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));
    }

    if(e.authorityCertIssuer) {
      var authorityCertIssuer = [
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
          _dnToAsn1(e.authorityCertIssuer === true ?
            options.cert.issuer : e.authorityCertIssuer)
        ])
      ];
      seq.push(
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));
    }

    if(e.serialNumber) {
      var serialNumber = forge.util.hexToBytes(e.serialNumber === true ?
        options.cert.serialNumber : e.serialNumber);
      seq.push(
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));
    }
  } else if(e.name === 'cRLDistributionPoints') {
    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var seq = e.value.value;

    // Create sub SEQUENCE of DistributionPointName
    var subSeq = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);

    // Create fullName CHOICE
    var fullNameGeneralNames = asn1.create(
      asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
    var altName;
    for(var n = 0; n < e.altNames.length; ++n) {
      altName = e.altNames[n];
      var value = altName.value;
      // handle IP
      if(altName.type === 7 && altName.ip) {
        value = forge.util.bytesFromIP(altName.ip);
        if(value === null) {
          var error = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.');
          error.extension = e;
          throw error;
        }
      } else if(altName.type === 8) {
        // handle OID
        if(altName.oid) {
          value = asn1.oidToDer(asn1.oidToDer(altName.oid));
        } else {
          // deprecated ... convert value to OID
          value = asn1.oidToDer(value);
        }
      }
      fullNameGeneralNames.value.push(asn1.create(
        asn1.Class.CONTEXT_SPECIFIC, altName.type, false,
        value));
    }

    // Add to the parent SEQUENCE
    subSeq.value.push(asn1.create(
      asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));
    seq.push(subSeq);
  }

  // ensure value has been defined by now
  if(typeof e.value === 'undefined') {
    var error = new Error('Extension value not specified.');
    error.extension = e;
    throw error;
  }

  return e;
}

/**
 * Convert signature parameters object to ASN.1
 *
 * @param {String} oid Signature algorithm OID
 * @param params The signature parametrs object
 * @return ASN.1 object representing signature parameters
 */
function _signatureParametersToAsn1(oid, params) {
  switch(oid) {
    case oids['RSASSA-PSS']:
      var parts = [];

      if(params.hash.algorithmOid !== undefined) {
        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
              asn1.oidToDer(params.hash.algorithmOid).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
          ])
        ]));
      }

      if(params.mgf.algorithmOid !== undefined) {
        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
              asn1.oidToDer(params.mgf.algorithmOid).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
                asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
            ])
          ])
        ]));
      }

      if(params.saltLength !== undefined) {
        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
            asn1.integerToDer(params.saltLength).getBytes())
        ]));
      }

      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);

    default:
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '');
  }
}

/**
 * Converts a certification request's attributes to an ASN.1 set of
 * CRIAttributes.
 *
 * @param csr certification request.
 *
 * @return the ASN.1 set of CRIAttributes.
 */
function _CRIAttributesToAsn1(csr) {
  // create an empty context-specific container
  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);

  // no attributes, return empty container
  if(csr.attributes.length === 0) {
    return rval;
  }

  // each attribute has a sequence with a type and a set of values
  var attrs = csr.attributes;
  for(var i = 0; i < attrs.length; ++i) {
    var attr = attrs[i];
    var value = attr.value;

    // reuse tag class for attribute value if available
    var valueTagClass = asn1.Type.UTF8;
    if('valueTagClass' in attr) {
      valueTagClass = attr.valueTagClass;
    }
    if(valueTagClass === asn1.Type.UTF8) {
      value = forge.util.encodeUtf8(value);
    }
    var valueConstructed = false;
    if('valueConstructed' in attr) {
      valueConstructed = attr.valueConstructed;
    }
    // FIXME: handle more encodings

    // create a RelativeDistinguishedName set
    // each value in the set is an AttributeTypeAndValue first
    // containing the type (an OID) and second the value
    var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // AttributeType
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(attr.type).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
        // AttributeValue
        asn1.create(
          asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)
      ])
    ]);
    rval.value.push(seq);
  }

  return rval;
}

var jan_1_1950 = new Date('1950-01-01T00:00:00Z');
var jan_1_2050 = new Date('2050-01-01T00:00:00Z');

/**
 * Converts a Date object to ASN.1
 * Handles the different format before and after 1st January 2050
 *
 * @param date date object.
 *
 * @return the ASN.1 object representing the date.
 */
function _dateToAsn1(date) {
  if(date >= jan_1_1950 && date < jan_1_2050) {
    return asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,
      asn1.dateToUtcTime(date));
  } else {
    return asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false,
      asn1.dateToGeneralizedTime(date));
  }
}

/**
 * Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.
 *
 * @param cert the certificate.
 *
 * @return the asn1 TBSCertificate.
 */
pki.getTBSCertificate = function(cert) {
  // TBSCertificate
  var notBefore = _dateToAsn1(cert.validity.notBefore);
  var notAfter = _dateToAsn1(cert.validity.notAfter);
  var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version
    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
      // integer
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
        asn1.integerToDer(cert.version).getBytes())
    ]),
    // serialNumber
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      forge.util.hexToBytes(cert.serialNumber)),
    // signature
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),
      // parameters
      _signatureParametersToAsn1(
        cert.siginfo.algorithmOid, cert.siginfo.parameters)
    ]),
    // issuer
    _dnToAsn1(cert.issuer),
    // validity
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      notBefore,
      notAfter
    ]),
    // subject
    _dnToAsn1(cert.subject),
    // SubjectPublicKeyInfo
    pki.publicKeyToAsn1(cert.publicKey)
  ]);

  if(cert.issuer.uniqueId) {
    // issuerUniqueID (optional)
    tbs.value.push(
      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
          // TODO: support arbitrary bit length ids
          String.fromCharCode(0x00) +
          cert.issuer.uniqueId
        )
      ])
    );
  }
  if(cert.subject.uniqueId) {
    // subjectUniqueID (optional)
    tbs.value.push(
      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
          // TODO: support arbitrary bit length ids
          String.fromCharCode(0x00) +
          cert.subject.uniqueId
        )
      ])
    );
  }

  if(cert.extensions.length > 0) {
    // extensions (optional)
    tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
  }

  return tbs;
};

/**
 * Gets the ASN.1 CertificationRequestInfo part of a
 * PKCS#10 CertificationRequest.
 *
 * @param csr the certification request.
 *
 * @return the asn1 CertificationRequestInfo.
 */
pki.getCertificationRequestInfo = function(csr) {
  // CertificationRequestInfo
  var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      asn1.integerToDer(csr.version).getBytes()),
    // subject
    _dnToAsn1(csr.subject),
    // SubjectPublicKeyInfo
    pki.publicKeyToAsn1(csr.publicKey),
    // attributes
    _CRIAttributesToAsn1(csr)
  ]);

  return cri;
};

/**
 * Converts a DistinguishedName (subject or issuer) to an ASN.1 object.
 *
 * @param dn the DistinguishedName.
 *
 * @return the asn1 representation of a DistinguishedName.
 */
pki.distinguishedNameToAsn1 = function(dn) {
  return _dnToAsn1(dn);
};

/**
 * Converts an X.509v3 RSA certificate to an ASN.1 object.
 *
 * @param cert the certificate.
 *
 * @return the asn1 representation of an X.509v3 RSA certificate.
 */
pki.certificateToAsn1 = function(cert) {
  // prefer cached TBSCertificate over generating one
  var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);

  // Certificate
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // TBSCertificate
    tbsCertificate,
    // AlgorithmIdentifier (signature algorithm)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(cert.signatureOid).getBytes()),
      // parameters
      _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
    ]),
    // SignatureValue
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
      String.fromCharCode(0x00) + cert.signature)
  ]);
};

/**
 * Converts X.509v3 certificate extensions to ASN.1.
 *
 * @param exts the extensions to convert.
 *
 * @return the extensions in ASN.1 format.
 */
pki.certificateExtensionsToAsn1 = function(exts) {
  // create top-level extension container
  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);

  // create extension sequence (stores a sequence for each extension)
  var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
  rval.value.push(seq);

  for(var i = 0; i < exts.length; ++i) {
    seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
  }

  return rval;
};

/**
 * Converts a single certificate extension to ASN.1.
 *
 * @param ext the extension to convert.
 *
 * @return the extension in ASN.1 format.
 */
pki.certificateExtensionToAsn1 = function(ext) {
  // create a sequence for each extension
  var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);

  // extnID (OID)
  extseq.value.push(asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.OID, false,
    asn1.oidToDer(ext.id).getBytes()));

  // critical defaults to false
  if(ext.critical) {
    // critical BOOLEAN DEFAULT FALSE
    extseq.value.push(asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false,
      String.fromCharCode(0xFF)));
  }

  var value = ext.value;
  if(typeof ext.value !== 'string') {
    // value is asn.1
    value = asn1.toDer(value).getBytes();
  }

  // extnValue (OCTET STRING)
  extseq.value.push(asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));

  return extseq;
};

/**
 * Converts a PKCS#10 certification request to an ASN.1 object.
 *
 * @param csr the certification request.
 *
 * @return the asn1 representation of a certification request.
 */
pki.certificationRequestToAsn1 = function(csr) {
  // prefer cached CertificationRequestInfo over generating one
  var cri = csr.certificationRequestInfo ||
    pki.getCertificationRequestInfo(csr);

  // Certificate
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // CertificationRequestInfo
    cri,
    // AlgorithmIdentifier (signature algorithm)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(csr.signatureOid).getBytes()),
      // parameters
      _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
    ]),
    // signature
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
      String.fromCharCode(0x00) + csr.signature)
  ]);
};

/**
 * Creates a CA store.
 *
 * @param certs an optional array of certificate objects or PEM-formatted
 *          certificate strings to add to the CA store.
 *
 * @return the CA store.
 */
pki.createCaStore = function(certs) {
  // create CA store
  var caStore = {
    // stored certificates
    certs: {}
  };

  /**
   * Gets the certificate that issued the passed certificate or its
   * 'parent'.
   *
   * @param cert the certificate to get the parent for.
   *
   * @return the parent certificate or null if none was found.
   */
  caStore.getIssuer = function(cert) {
    var rval = getBySubject(cert.issuer);

    // see if there are multiple matches
    /*if(forge.util.isArray(rval)) {
      // TODO: resolve multiple matches by checking
      // authorityKey/subjectKey/issuerUniqueID/other identifiers, etc.
      // FIXME: or alternatively do authority key mapping
      // if possible (X.509v1 certs can't work?)
      throw new Error('Resolving multiple issuer matches not implemented yet.');
    }*/

    return rval;
  };

  /**
   * Adds a trusted certificate to the store.
   *
   * @param cert the certificate to add as a trusted certificate (either a
   *          pki.certificate object or a PEM-formatted certificate).
   */
  caStore.addCertificate = function(cert) {
    // convert from pem if necessary
    if(typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }

    ensureSubjectHasHash(cert.subject);

    if(!caStore.hasCertificate(cert)) { // avoid duplicate certificates in store
      if(cert.subject.hash in caStore.certs) {
        // subject hash already exists, append to array
        var tmp = caStore.certs[cert.subject.hash];
        if(!forge.util.isArray(tmp)) {
          tmp = [tmp];
        }
        tmp.push(cert);
        caStore.certs[cert.subject.hash] = tmp;
      } else {
        caStore.certs[cert.subject.hash] = cert;
      }
    }
  };

  /**
   * Checks to see if the given certificate is in the store.
   *
   * @param cert the certificate to check (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return true if the certificate is in the store, false if not.
   */
  caStore.hasCertificate = function(cert) {
    // convert from pem if necessary
    if(typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }

    var match = getBySubject(cert.subject);
    if(!match) {
      return false;
    }
    if(!forge.util.isArray(match)) {
      match = [match];
    }
    // compare DER-encoding of certificates
    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();
    for(var i = 0; i < match.length; ++i) {
      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();
      if(der1 === der2) {
        return true;
      }
    }
    return false;
  };

  /**
   * Lists all of the certificates kept in the store.
   *
   * @return an array of all of the pki.certificate objects in the store.
   */
  caStore.listAllCertificates = function() {
    var certList = [];

    for(var hash in caStore.certs) {
      if(caStore.certs.hasOwnProperty(hash)) {
        var value = caStore.certs[hash];
        if(!forge.util.isArray(value)) {
          certList.push(value);
        } else {
          for(var i = 0; i < value.length; ++i) {
            certList.push(value[i]);
          }
        }
      }
    }

    return certList;
  };

  /**
   * Removes a certificate from the store.
   *
   * @param cert the certificate to remove (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return the certificate that was removed or null if the certificate
   *           wasn't in store.
   */
  caStore.removeCertificate = function(cert) {
    var result;

    // convert from pem if necessary
    if(typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }
    ensureSubjectHasHash(cert.subject);
    if(!caStore.hasCertificate(cert)) {
      return null;
    }

    var match = getBySubject(cert.subject);

    if(!forge.util.isArray(match)) {
      result = caStore.certs[cert.subject.hash];
      delete caStore.certs[cert.subject.hash];
      return result;
    }

    // compare DER-encoding of certificates
    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();
    for(var i = 0; i < match.length; ++i) {
      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();
      if(der1 === der2) {
        result = match[i];
        match.splice(i, 1);
      }
    }
    if(match.length === 0) {
      delete caStore.certs[cert.subject.hash];
    }

    return result;
  };

  function getBySubject(subject) {
    ensureSubjectHasHash(subject);
    return caStore.certs[subject.hash] || null;
  }

  function ensureSubjectHasHash(subject) {
    // produce subject hash if it doesn't exist
    if(!subject.hash) {
      var md = forge.md.sha1.create();
      subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
      subject.hash = md.digest().toHex();
    }
  }

  // auto-add passed in certs
  if(certs) {
    // parse PEM-formatted certificates as necessary
    for(var i = 0; i < certs.length; ++i) {
      var cert = certs[i];
      caStore.addCertificate(cert);
    }
  }

  return caStore;
};

/**
 * Certificate verification errors, based on TLS.
 */
pki.certificateError = {
  bad_certificate: 'forge.pki.BadCertificate',
  unsupported_certificate: 'forge.pki.UnsupportedCertificate',
  certificate_revoked: 'forge.pki.CertificateRevoked',
  certificate_expired: 'forge.pki.CertificateExpired',
  certificate_unknown: 'forge.pki.CertificateUnknown',
  unknown_ca: 'forge.pki.UnknownCertificateAuthority'
};

/**
 * Verifies a certificate chain against the given Certificate Authority store
 * with an optional custom verify callback.
 *
 * @param caStore a certificate store to verify against.
 * @param chain the certificate chain to verify, with the root or highest
 *          authority at the end (an array of certificates).
 * @param options a callback to be called for every certificate in the chain or
 *                  an object with:
 *                  verify a callback to be called for every certificate in the
 *                    chain
 *                  validityCheckDate the date against which the certificate
 *                    validity period should be checked. Pass null to not check
 *                    the validity period. By default, the current date is used.
 *
 * The verify callback has the following signature:
 *
 * verified - Set to true if certificate was verified, otherwise the
 *   pki.certificateError for why the certificate failed.
 * depth - The current index in the chain, where 0 is the end point's cert.
 * certs - The certificate chain, *NOTE* an empty chain indicates an anonymous
 *   end point.
 *
 * The function returns true on success and on failure either the appropriate
 * pki.certificateError or an object with 'error' set to the appropriate
 * pki.certificateError and 'message' set to a custom error message.
 *
 * @return true if successful, error thrown if not.
 */
pki.verifyCertificateChain = function(caStore, chain, options) {
  /* From: RFC3280 - Internet X.509 Public Key Infrastructure Certificate
    Section 6: Certification Path Validation
    See inline parentheticals related to this particular implementation.

    The primary goal of path validation is to verify the binding between
    a subject distinguished name or a subject alternative name and subject
    public key, as represented in the end entity certificate, based on the
    public key of the trust anchor. This requires obtaining a sequence of
    certificates that support that binding. That sequence should be provided
    in the passed 'chain'. The trust anchor should be in the given CA
    store. The 'end entity' certificate is the certificate provided by the
    end point (typically a server) and is the first in the chain.

    To meet this goal, the path validation process verifies, among other
    things, that a prospective certification path (a sequence of n
    certificates or a 'chain') satisfies the following conditions:

    (a) for all x in {1, ..., n-1}, the subject of certificate x is
          the issuer of certificate x+1;

    (b) certificate 1 is issued by the trust anchor;

    (c) certificate n is the certificate to be validated; and

    (d) for all x in {1, ..., n}, the certificate was valid at the
          time in question.

    Note that here 'n' is index 0 in the chain and 1 is the last certificate
    in the chain and it must be signed by a certificate in the connection's
    CA store.

    The path validation process also determines the set of certificate
    policies that are valid for this path, based on the certificate policies
    extension, policy mapping extension, policy constraints extension, and
    inhibit any-policy extension.

    Note: Policy mapping extension not supported (Not Required).

    Note: If the certificate has an unsupported critical extension, then it
    must be rejected.

    Note: A certificate is self-issued if the DNs that appear in the subject
    and issuer fields are identical and are not empty.

    The path validation algorithm assumes the following seven inputs are
    provided to the path processing logic. What this specific implementation
    will use is provided parenthetically:

    (a) a prospective certification path of length n (the 'chain')
    (b) the current date/time: ('now').
    (c) user-initial-policy-set: A set of certificate policy identifiers
          naming the policies that are acceptable to the certificate user.
          The user-initial-policy-set contains the special value any-policy
          if the user is not concerned about certificate policy
          (Not implemented. Any policy is accepted).
    (d) trust anchor information, describing a CA that serves as a trust
          anchor for the certification path. The trust anchor information
          includes:

      (1)  the trusted issuer name,
      (2)  the trusted public key algorithm,
      (3)  the trusted public key, and
      (4)  optionally, the trusted public key parameters associated
             with the public key.

      (Trust anchors are provided via certificates in the CA store).

      The trust anchor information may be provided to the path processing
      procedure in the form of a self-signed certificate. The trusted anchor
      information is trusted because it was delivered to the path processing
      procedure by some trustworthy out-of-band procedure. If the trusted
      public key algorithm requires parameters, then the parameters are
      provided along with the trusted public key (No parameters used in this
      implementation).

    (e) initial-policy-mapping-inhibit, which indicates if policy mapping is
          allowed in the certification path.
          (Not implemented, no policy checking)

    (f) initial-explicit-policy, which indicates if the path must be valid
          for at least one of the certificate policies in the user-initial-
          policy-set.
          (Not implemented, no policy checking)

    (g) initial-any-policy-inhibit, which indicates whether the
          anyPolicy OID should be processed if it is included in a
          certificate.
          (Not implemented, so any policy is valid provided that it is
          not marked as critical) */

  /* Basic Path Processing:

    For each certificate in the 'chain', the following is checked:

    1. The certificate validity period includes the current time.
    2. The certificate was signed by its parent (where the parent is either
       the next in the chain or from the CA store). Allow processing to
       continue to the next step if no parent is found but the certificate is
       in the CA store.
    3. TODO: The certificate has not been revoked.
    4. The certificate issuer name matches the parent's subject name.
    5. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is within one of the permitted subtrees of X.500 distinguished names
       and that each of the alternative names in the subjectAltName extension
       (critical or non-critical) is within one of the permitted subtrees for
       that name type.
    6. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is not within one of the excluded subtrees for X.500 distinguished
       names and none of the subjectAltName extension names are excluded for
       that name type.
    7. The other steps in the algorithm for basic path processing involve
       handling the policy extension which is not presently supported in this
       implementation. Instead, if a critical policy extension is found, the
       certificate is rejected as not supported.
    8. If the certificate is not the first or if its the only certificate in
       the chain (having no parent from the CA store or is self-signed) and it
       has a critical key usage extension, verify that the keyCertSign bit is
       set. If the key usage extension exists, verify that the basic
       constraints extension exists. If the basic constraints extension exists,
       verify that the cA flag is set. If pathLenConstraint is set, ensure that
       the number of certificates that precede in the chain (come earlier
       in the chain as implemented below), excluding the very first in the
       chain (typically the end-entity one), isn't greater than the
       pathLenConstraint. This constraint limits the number of intermediate
       CAs that may appear below a CA before only end-entity certificates
       may be issued. */

  // if a verify callback is passed as the third parameter, package it within
  // the options object. This is to support a legacy function signature that
  // expected the verify callback as the third parameter.
  if(typeof options === 'function') {
    options = {verify: options};
  }
  options = options || {};

  // copy cert chain references to another array to protect against changes
  // in verify callback
  chain = chain.slice(0);
  var certs = chain.slice(0);

  var validityCheckDate = options.validityCheckDate;
  // if no validityCheckDate is specified, default to the current date. Make
  // sure to maintain the value null because it indicates that the validity
  // period should not be checked.
  if(typeof validityCheckDate === 'undefined') {
    validityCheckDate = new Date();
  }

  // verify each cert in the chain using its parent, where the parent
  // is either the next in the chain or from the CA store
  var first = true;
  var error = null;
  var depth = 0;
  do {
    var cert = chain.shift();
    var parent = null;
    var selfSigned = false;

    if(validityCheckDate) {
      // 1. check valid time
      if(validityCheckDate < cert.validity.notBefore ||
         validityCheckDate > cert.validity.notAfter) {
        error = {
          message: 'Certificate is not valid yet or has expired.',
          error: pki.certificateError.certificate_expired,
          notBefore: cert.validity.notBefore,
          notAfter: cert.validity.notAfter,
          // TODO: we might want to reconsider renaming 'now' to
          // 'validityCheckDate' should this API be changed in the future.
          now: validityCheckDate
        };
      }
    }

    // 2. verify with parent from chain or CA store
    if(error === null) {
      parent = chain[0] || caStore.getIssuer(cert);
      if(parent === null) {
        // check for self-signed cert
        if(cert.isIssuer(cert)) {
          selfSigned = true;
          parent = cert;
        }
      }

      if(parent) {
        // FIXME: current CA store implementation might have multiple
        // certificates where the issuer can't be determined from the
        // certificate (happens rarely with, eg: old certificates) so normalize
        // by always putting parents into an array
        // TODO: there's may be an extreme degenerate case currently uncovered
        // where an old intermediate certificate seems to have a matching parent
        // but none of the parents actually verify ... but the intermediate
        // is in the CA and it should pass this check; needs investigation
        var parents = parent;
        if(!forge.util.isArray(parents)) {
          parents = [parents];
        }

        // try to verify with each possible parent (typically only one)
        var verified = false;
        while(!verified && parents.length > 0) {
          parent = parents.shift();
          try {
            verified = parent.verify(cert);
          } catch(ex) {
            // failure to verify, don't care why, try next one
          }
        }

        if(!verified) {
          error = {
            message: 'Certificate signature is invalid.',
            error: pki.certificateError.bad_certificate
          };
        }
      }

      if(error === null && (!parent || selfSigned) &&
        !caStore.hasCertificate(cert)) {
        // no parent issuer and certificate itself is not trusted
        error = {
          message: 'Certificate is not trusted.',
          error: pki.certificateError.unknown_ca
        };
      }
    }

    // TODO: 3. check revoked

    // 4. check for matching issuer/subject
    if(error === null && parent && !cert.isIssuer(parent)) {
      // parent is not issuer
      error = {
        message: 'Certificate issuer is invalid.',
        error: pki.certificateError.bad_certificate
      };
    }

    // 5. TODO: check names with permitted names tree

    // 6. TODO: check names against excluded names tree

    // 7. check for unsupported critical extensions
    if(error === null) {
      // supported extensions
      var se = {
        keyUsage: true,
        basicConstraints: true
      };
      for(var i = 0; error === null && i < cert.extensions.length; ++i) {
        var ext = cert.extensions[i];
        if(ext.critical && !(ext.name in se)) {
          error = {
            message:
              'Certificate has an unsupported critical extension.',
            error: pki.certificateError.unsupported_certificate
          };
        }
      }
    }

    // 8. check for CA if cert is not first or is the only certificate
    // remaining in chain with no parent or is self-signed
    if(error === null &&
      (!first || (chain.length === 0 && (!parent || selfSigned)))) {
      // first check keyUsage extension and then basic constraints
      var bcExt = cert.getExtension('basicConstraints');
      var keyUsageExt = cert.getExtension('keyUsage');
      if(keyUsageExt !== null) {
        // keyCertSign must be true and there must be a basic
        // constraints extension
        if(!keyUsageExt.keyCertSign || bcExt === null) {
          // bad certificate
          error = {
            message:
              'Certificate keyUsage or basicConstraints conflict ' +
              'or indicate that the certificate is not a CA. ' +
              'If the certificate is the only one in the chain or ' +
              'isn\'t the first then the certificate must be a ' +
              'valid CA.',
            error: pki.certificateError.bad_certificate
          };
        }
      }
      // basic constraints cA flag must be set
      if(error === null && bcExt !== null && !bcExt.cA) {
        // bad certificate
        error = {
          message:
            'Certificate basicConstraints indicates the certificate ' +
            'is not a CA.',
          error: pki.certificateError.bad_certificate
        };
      }
      // if error is not null and keyUsage is available, then we know it
      // has keyCertSign and there is a basic constraints extension too,
      // which means we can check pathLenConstraint (if it exists)
      if(error === null && keyUsageExt !== null &&
        'pathLenConstraint' in bcExt) {
        // pathLen is the maximum # of intermediate CA certs that can be
        // found between the current certificate and the end-entity (depth 0)
        // certificate; this number does not include the end-entity (depth 0,
        // last in the chain) even if it happens to be a CA certificate itself
        var pathLen = depth - 1;
        if(pathLen > bcExt.pathLenConstraint) {
          // pathLenConstraint violated, bad certificate
          error = {
            message:
              'Certificate basicConstraints pathLenConstraint violated.',
            error: pki.certificateError.bad_certificate
          };
        }
      }
    }

    // call application callback
    var vfd = (error === null) ? true : error.error;
    var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
    if(ret === true) {
      // clear any set error
      error = null;
    } else {
      // if passed basic tests, set default message and alert
      if(vfd === true) {
        error = {
          message: 'The application rejected the certificate.',
          error: pki.certificateError.bad_certificate
        };
      }

      // check for custom error info
      if(ret || ret === 0) {
        // set custom message and error
        if(typeof ret === 'object' && !forge.util.isArray(ret)) {
          if(ret.message) {
            error.message = ret.message;
          }
          if(ret.error) {
            error.error = ret.error;
          }
        } else if(typeof ret === 'string') {
          // set custom error
          error.error = ret;
        }
      }

      // throw error
      throw error;
    }

    // no longer first cert in chain
    first = false;
    ++depth;
  } while(chain.length > 0);

  return true;
};

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/x509.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pkcs7asn1.js", {"./asn1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/asn1.js","./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pkcs7asn1.js
      return function (require, module, exports) {
/**
 * Javascript implementation of ASN.1 validators for PKCS#7 v1.5.
 *
 * @author Dave Longley
 * @author Stefan Siegl
 *
 * Copyright (c) 2012-2015 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * The ASN.1 representation of PKCS#7 is as follows
 * (see RFC #2315 for details, http://www.ietf.org/rfc/rfc2315.txt):
 *
 * A PKCS#7 message consists of a ContentInfo on root level, which may
 * contain any number of further ContentInfo nested into it.
 *
 * ContentInfo ::= SEQUENCE {
 *   contentType                ContentType,
 *   content               [0]  EXPLICIT ANY DEFINED BY contentType OPTIONAL
 * }
 *
 * ContentType ::= OBJECT IDENTIFIER
 *
 * EnvelopedData ::= SEQUENCE {
 *   version                    Version,
 *   recipientInfos             RecipientInfos,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * EncryptedData ::= SEQUENCE {
 *   version                    Version,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)
 *   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }
 *
 * SignedData ::= SEQUENCE {
 *   version           INTEGER,
 *   digestAlgorithms  DigestAlgorithmIdentifiers,
 *   contentInfo       ContentInfo,
 *   certificates      [0] IMPLICIT Certificates OPTIONAL,
 *   crls              [1] IMPLICIT CertificateRevocationLists OPTIONAL,
 *   signerInfos       SignerInfos
 * }
 *
 * SignerInfos ::= SET OF SignerInfo
 *
 * SignerInfo ::= SEQUENCE {
 *   version                    Version,
 *   issuerAndSerialNumber      IssuerAndSerialNumber,
 *   digestAlgorithm            DigestAlgorithmIdentifier,
 *   authenticatedAttributes    [0] IMPLICIT Attributes OPTIONAL,
 *   digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier,
 *   encryptedDigest            EncryptedDigest,
 *   unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL
 * }
 *
 * EncryptedDigest ::= OCTET STRING
 *
 * Attributes ::= SET OF Attribute
 *
 * Attribute ::= SEQUENCE {
 *   attrType    OBJECT IDENTIFIER,
 *   attrValues  SET OF AttributeValue
 * }
 *
 * AttributeValue ::= ANY
 *
 * Version ::= INTEGER
 *
 * RecipientInfos ::= SET OF RecipientInfo
 *
 * EncryptedContentInfo ::= SEQUENCE {
 *   contentType                 ContentType,
 *   contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,
 *   encryptedContent       [0]  IMPLICIT EncryptedContent OPTIONAL
 * }
 *
 * ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of AES and DES3, there is only one,
 * the IV.
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *    algorithm OBJECT IDENTIFIER,
 *    parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * EncryptedContent ::= OCTET STRING
 *
 * RecipientInfo ::= SEQUENCE {
 *   version                     Version,
 *   issuerAndSerialNumber       IssuerAndSerialNumber,
 *   keyEncryptionAlgorithm      KeyEncryptionAlgorithmIdentifier,
 *   encryptedKey                EncryptedKey
 * }
 *
 * IssuerAndSerialNumber ::= SEQUENCE {
 *   issuer                      Name,
 *   serialNumber                CertificateSerialNumber
 * }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedKey ::= OCTET STRING
 */
var forge = require('./forge');
require('./asn1');
require('./util');

// shortcut for ASN.1 API
var asn1 = forge.asn1;

// shortcut for PKCS#7 API
var p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
forge.pkcs7 = forge.pkcs7 || {};
forge.pkcs7.asn1 = p7v;

var contentInfoValidator = {
  name: 'ContentInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'ContentInfo.ContentType',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OID,
    constructed: false,
    capture: 'contentType'
  }, {
    name: 'ContentInfo.content',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    captureAsn1: 'content'
  }]
};
p7v.contentInfoValidator = contentInfoValidator;

var encryptedContentInfoValidator = {
  name: 'EncryptedContentInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EncryptedContentInfo.contentType',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OID,
    constructed: false,
    capture: 'contentType'
  }, {
    name: 'EncryptedContentInfo.contentEncryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'encAlgorithm'
    }, {
      name: 'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',
      tagClass: asn1.Class.UNIVERSAL,
      captureAsn1: 'encParameter'
    }]
  }, {
    name: 'EncryptedContentInfo.encryptedContent',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    /* The PKCS#7 structure output by OpenSSL somewhat differs from what
     * other implementations do generate.
     *
     * OpenSSL generates a structure like this:
     * SEQUENCE {
     *    ...
     *    [0]
     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *       ...
     * }
     *
     * Whereas other implementations (and this PKCS#7 module) generate:
     * SEQUENCE {
     *    ...
     *    [0] {
     *       OCTET STRING
     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *          ...
     *    }
     * }
     *
     * In order to support both, we just capture the context specific
     * field here.  The OCTET STRING bit is removed below.
     */
    capture: 'encryptedContent',
    captureAsn1: 'encryptedContentAsn1'
  }]
};

p7v.envelopedDataValidator = {
  name: 'EnvelopedData',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EnvelopedData.Version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }, {
    name: 'EnvelopedData.RecipientInfos',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SET,
    constructed: true,
    captureAsn1: 'recipientInfos'
  }].concat(encryptedContentInfoValidator)
};

p7v.encryptedDataValidator = {
  name: 'EncryptedData',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EncryptedData.Version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }].concat(encryptedContentInfoValidator)
};

var signerValidator = {
  name: 'SignerInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'SignerInfo.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false
  }, {
    name: 'SignerInfo.issuerAndSerialNumber',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'SignerInfo.issuerAndSerialNumber.issuer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'issuer'
    }, {
      name: 'SignerInfo.issuerAndSerialNumber.serialNumber',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: 'serial'
    }]
  }, {
    name: 'SignerInfo.digestAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'SignerInfo.digestAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'digestAlgorithm'
    }, {
      name: 'SignerInfo.digestAlgorithm.parameter',
      tagClass: asn1.Class.UNIVERSAL,
      constructed: false,
      captureAsn1: 'digestParameter',
      optional: true
    }]
  }, {
    name: 'SignerInfo.authenticatedAttributes',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    capture: 'authenticatedAttributes'
  }, {
    name: 'SignerInfo.digestEncryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    capture: 'signatureAlgorithm'
  }, {
    name: 'SignerInfo.encryptedDigest',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'signature'
  }, {
    name: 'SignerInfo.unauthenticatedAttributes',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: true,
    optional: true,
    capture: 'unauthenticatedAttributes'
  }]
};

p7v.signedDataValidator = {
  name: 'SignedData',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'SignedData.Version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }, {
    name: 'SignedData.DigestAlgorithms',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SET,
    constructed: true,
    captureAsn1: 'digestAlgorithms'
  },
  contentInfoValidator,
  {
    name: 'SignedData.Certificates',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    optional: true,
    captureAsn1: 'certificates'
  }, {
    name: 'SignedData.CertificateRevocationLists',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 1,
    optional: true,
    captureAsn1: 'crls'
  }, {
    name: 'SignedData.SignerInfos',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SET,
    capture: 'signerInfos',
    optional: true,
    value: [signerValidator]
  }]
};

p7v.recipientInfoValidator = {
  name: 'RecipientInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'RecipientInfo.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }, {
    name: 'RecipientInfo.issuerAndSerial',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'RecipientInfo.issuerAndSerial.issuer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'issuer'
    }, {
      name: 'RecipientInfo.issuerAndSerial.serialNumber',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: 'serial'
    }]
  }, {
    name: 'RecipientInfo.keyEncryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'RecipientInfo.keyEncryptionAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'encAlgorithm'
    }, {
      name: 'RecipientInfo.keyEncryptionAlgorithm.parameter',
      tagClass: asn1.Class.UNIVERSAL,
      constructed: false,
      captureAsn1: 'encParameter'
    }]
  }, {
    name: 'RecipientInfo.encryptedKey',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'encKey'
  }]
};

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pkcs7asn1.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/crypto.js", {"./blake":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/blake.js","./crypto-sha1-2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/crypto-sha1-2-browser.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/utils.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha3/src/sha3.js","murmurhash3js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/crypto.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const sha3 = require('js-sha3')
const murmur3 = require('murmurhash3js')

const utils = require('./utils')
const sha = require('./crypto-sha1-2')

const toCallback = utils.toCallback
const toBuf = utils.toBuf
const fromString = utils.fromString
const fromNumberTo32BitBuf = utils.fromNumberTo32BitBuf

const dblSha2256 = (buf, cb) => {
  sha.sha2256(buf, (err, firstHash) => {
    if (err) {
      cb(err)
    }
    sha.sha2256((Buffer.from(firstHash)), cb)
  })
}

module.exports = {
  sha1: sha.sha1,
  sha2256: sha.sha2256,
  sha2512: sha.sha2512,
  sha3512: toCallback(toBuf(sha3.sha3_512)),
  sha3384: toCallback(toBuf(sha3.sha3_384)),
  sha3256: toCallback(toBuf(sha3.sha3_256)),
  sha3224: toCallback(toBuf(sha3.sha3_224)),
  shake128: toCallback(toBuf(sha3.shake_128, 128)),
  shake256: toCallback(toBuf(sha3.shake_256, 256)),
  keccak224: toCallback(toBuf(sha3.keccak_224)),
  keccak256: toCallback(toBuf(sha3.keccak_256)),
  keccak384: toCallback(toBuf(sha3.keccak_384)),
  keccak512: toCallback(toBuf(sha3.keccak_512)),
  murmur3128: toCallback(toBuf(fromString(murmur3.x64.hash128))),
  murmur332: toCallback(fromNumberTo32BitBuf(fromString(murmur3.x86.hash32))),
  addBlake: require('./blake'),
  dblSha2256: dblSha2256
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/crypto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-reader/index.js", {"./state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-reader/state.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-reader/index.js
      return function (require, module, exports) {
'use strict'
var State = require('./state')

function isInteger (i) {
  return Number.isFinite(i)
}

function isFunction (f) {
  return 'function' === typeof f
}

function maxDelay(fn, delay) {
  if(!delay) return fn
  return function (a, cb) {
    var timer = setTimeout(function () {
      fn(new Error('pull-reader: read exceeded timeout'), cb)
    }, delay)
    fn(a, function (err, value) {
      clearTimeout(timer)
      cb(err, value)
    })

  }

}

module.exports = function (timeout) {

  var queue = [], read, readTimed, reading = false
  var state = State(), ended, streaming, abort

  function drain () {
    while (queue.length) {
      if(null == queue[0].length && state.has(1)) {
        queue.shift().cb(null, state.get())
      }
      else if(state.has(queue[0].length)) {
        var next = queue.shift()
        next.cb(null, state.get(next.length))
      }
      else if(ended == true && queue[0].length && state.length < queue[0].length) {
        var msg = 'stream ended with:'+state.length+' but wanted:'+queue[0].length
        queue.shift().cb(new Error(msg))
      }
      else if(ended)
        queue.shift().cb(ended)
      else
        return !!queue.length
    }
    //always read a little data
    return queue.length || !state.has(1) || abort
  }

  function more () {
    var d = drain()
    if(d && !reading)
    if(read && !reading && !streaming) {
      reading = true
      readTimed (null, function (err, data) {
        reading = false
        if(err) {
          ended = err
          return drain()
        }
        state.add(data)
        more()
      })
    }
  }

  function reader (_read) {
    if(abort) {
      while(queue.length) queue.shift().cb(abort)
      return cb && cb(abort)
    }
    readTimed = maxDelay(_read, timeout)
    read = _read
    more()
  }

  reader.abort = function (err, cb) {
    abort = err || true
    if(read) {
      reading = true
      read(abort, function () {
        while(queue.length) queue.shift().cb(abort)
        cb && cb(abort)
      })
    }
    else
      cb()
  }

  reader.read = function (len, _timeout, cb) {
    if(isFunction(_timeout))
      cb = _timeout, _timeout = timeout
    if(isFunction(cb)) {
      queue.push({length: isInteger(len) ? len : null, cb: cb})
      more()
    }
    else {
      //switch into streaming mode for the rest of the stream.
      streaming = true
      //wait for the current read to complete
      return function (abort, cb) {
        //if there is anything still in the queue,
        if(reading || state.has(1)) {
          if(abort) return read(abort, cb)
          queue.push({length: null, cb: cb})
          more()
        }
        else
          maxDelay(read, _timeout)(abort, function (err, data) {
            cb(err, data)
          })
      }
    }
  }

  return reader
}







      };
    };
  }
}, {package:"pull-reader",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-reader/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/selectors/public-key.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/selectors/public-key.js
      return function (require, module, exports) {
'use strict'

/**
 * Best record selector, for public key records.
 * Simply returns the first record, as all valid public key
 * records are equal.
 *
 * @param {Buffer} k
 * @param {Array<Buffer>} records
 * @returns {number}
 */
const publicKeySelector = (k, records) => {
  return 0
}

module.exports = publicKeySelector

      };
    };
  }
}, {package:"libp2p-record",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/selectors/public-key.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer-indexof/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer-indexof/index.js
      return function (require, module, exports) {
module.exports = function bufferIndexOf(buf,search,offset){
  offset = offset||0
  
  var m = 0;
  var s = -1;
  for(var i=offset;i<buf.length;++i){
    if(buf[i] == search[m]) {
      if(s == -1) s = i;
      ++m;
      if(m == search.length) break;
    } else {
      s = -1;
      m = 0;
    }
  }

  if (s > -1 && buf.length - s < search.length) return -1;
  return s;
}

      };
    };
  }
}, {package:"buffer-indexof",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer-indexof/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/validators/public-key.js", {"../../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/node_modules/multihashing-async/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/validators/public-key.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const setImmediate = require('async/setImmediate')
const multihashing = require('multihashing-async')

/**
 * Validator for publick key records.
 * Verifies that the passed in record value is the PublicKey
 * that matches the passed in key.
 *
 * @param {Buffer} key - A valid key is of the form `'/pk/<keymultihash>'`
 * @param {Buffer} publicKey - The public key to validate against (protobuf encoded).
 * @param {function(Error)} callback
 * @returns {undefined}
 */
const validatePublicKeyRecord = (key, publicKey, callback) => {
  const done = (err) => setImmediate(() => callback(err))

  if (!Buffer.isBuffer(key)) {
    return done(new Error('"key" must be a Buffer'))
  }

  if (key.length < 3) {
    return done(new Error('invalid public key record'))
  }

  const prefix = key.slice(0, 4).toString()

  if (prefix !== '/pk/') {
    return done(new Error('key was not prefixed with /pk/'))
  }

  const keyhash = key.slice(4)

  multihashing(publicKey, 'sha2-256', (err, publicKeyHash) => {
    if (err) {
      return done(err)
    }

    if (!keyhash.equals(publicKeyHash)) {
      return done(new Error('public key does not match passed in key'))
    }

    done()
  })
}

module.exports = {
  func: validatePublicKeyRecord,
  sign: false
}

}).call(this)}).call(this,{"isBuffer":require("../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"libp2p-record",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/validators/public-key.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/index.js", {"./client":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/client.js","./duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/duplex.js","./server":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js","./sink":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/sink.js","./source":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/source.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/index.js
      return function (require, module, exports) {
var exports = module.exports = require('./duplex')

exports.source = require('./source');
exports.sink = require('./sink');
exports.createServer = require('./server')
exports.connect = require('./client')

      };
    };
  }
}, {package:"pull-ws",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/relative-url/index.js", {"url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/url/url.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/relative-url/index.js
      return function (require, module, exports) {

//normalize a ws url.
var URL = require('url')
module.exports = function (url, location, protocolMap, defaultProtocol) {
  protocolMap = protocolMap ||{}
  /*

  https://nodejs.org/dist/latest-v6.x/docs/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost

  I didn't know this, but url.parse takes a 3rd
  argument which interprets "//foo.com" as the hostname,
  but without the protocol. by default, // is interpreted
  as the path.

  that lets us do what the wsurl module does.
  https://www.npmjs.com/package/wsurl

  but most of the time, I want to write js
  that will work on localhost, and will work
  on a server...

  so I want to just do createWebSocket('/')
  and get "ws://mydomain.com/"

  */

  var url = URL.parse(url, false, true)

  var proto
  if(url.protocol) proto = url.protocol
  else {
    proto = location.protocol ? location.protocol.replace(/:$/,'') : 'http'
    proto = ((protocolMap)[proto] || defaultProtocol || proto) + ':'
  }

  //handle quirk in url package
  if(url.host && url.host[0] === ':')
    url.host = null

  //useful for websockets
  if(url.hostname) {
    return URL.format({
      protocol: proto,
      slashes: true,
      hostname: url.hostname,
      port: url.port,
      pathname: url.pathname,
      search: url.search
    })
  }
  else url.host = location.host

  //included for completeness. would you want to do this?
  if(url.port) {
    return URL.format({
      protocol: proto,
      slashes: true,
      host: location.hostname + ':' + url.port,
      port: url.port,
      pathname: url.pathname,
      search: url.search
    })
  }

  //definately useful for websockets
  if(url.pathname) {
    return URL.format({
      protocol: proto,
      slashes: true,
      host: url.host,
      pathname: url.pathname,
      search: url.search
    })
  }
  else
    url.pathname = location.pathname

  //included for completeness. would you want to do this?
  if(url.search) {
    return URL.format({
      protocol: proto,
      slashes: true,
      host: url.host,
      pathname: url.pathname,
      search: url.search
    })
  }
  else url.search = location.search

  return url.format(url)
}






      };
    };
  }
}, {package:"relative-url",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/relative-url/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/sink.js", {"./ready":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/ready.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","timers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/timers-browserify/main.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/sink.js
      return function (require, module, exports) {
(function (process,setImmediate){(function (){
var ready = require('./ready');

/**
  ### `sink(socket, opts?)`

  Create a pull-stream `Sink` that will write data to the `socket`.

  <<< examples/write.js

**/

var nextTick = typeof setImmediate !== 'undefined' ? setImmediate : process.nextTick

module.exports = function(socket, opts) {
  return function (read) {
    opts = opts || {}
    var closeOnEnd = opts.closeOnEnd !== false;
    var onClose = 'function' === typeof opts ? opts : opts.onClose;

    function next(end, data) {
      // if the stream has ended, simply return
      if (end) {
        if (closeOnEnd && socket.readyState <= 1) {
          if(onClose)
            socket.addEventListener('close', function (ev) {
              if(ev.wasClean || ev.code === 1006) onClose()
              else {
                var err = new Error('ws error')
                err.event = ev
                onClose(err)
              }
            });

          socket.close()
        }

        return;
      }

      // socket ready?
      ready(socket, function(end) {
        if (end) {
          return read(end, function () {});
        }
        socket.send(data);
        nextTick(function() {
          read(null, next);
        });
      });
    }

    read(null, next);
  }
}

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)

      };
    };
  }
}, {package:"pull-ws",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/sink.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/source.js", {"safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/source.js
      return function (require, module, exports) {
/**
  ### `source(socket)`

  Create a pull-stream `Source` that will read data from the `socket`.

  <<< examples/read.js

**/
var Buffer = require('safe-buffer').Buffer;

// copied from github.com/feross/buffer
// Some ArrayBuffers are not passing the instanceof check, so we need to do a bit more work :(
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

module.exports = function(socket, cb) {
  var buffer = [];
  var receiver;
  var ended;
  var started = false;
  socket.addEventListener('message', function(evt) {
    var data = evt.data;
    if (isArrayBuffer(data)) {
      data = Buffer.from(data);
    }

    if (receiver) {
      return receiver(null, data);
    }

    buffer.push(data);
  });

  socket.addEventListener('close', function(evt) {
    if (ended) return
    if (receiver) {
      receiver(ended = true)
    }
  });

  socket.addEventListener('error', function (evt) {
    if (ended) return;
    ended = evt;
    if(!started) {
      started = true
      cb && cb(evt)
    }
    if (receiver) {
      receiver(ended)
    }
  });

  socket.addEventListener('open', function (evt) {
    if(started || ended) return
    started = true
  })

  function read(abort, cb) {
    receiver = null;

    //if stream has already ended.
    if (ended)
      return cb(ended);

    // if ended, abort
    else if (abort) {
      //this will callback when socket closes
      receiver = cb
      socket.close()
    }

    // return data, if any
    else if(buffer.length > 0)
      cb(null, buffer.shift());

    // wait for more data (or end)
    else
      receiver = cb;

  };

  return read;
};

      };
    };
  }
}, {package:"pull-ws",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/source.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/peer-list.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/peer-list.js
      return function (require, module, exports) {
'use strict'

/**
 * A list of unique peer infos.
 */
class PeerList {
  constructor () {
    this.list = []
  }

  /**
   * Add a new info. Returns `true` if it was a new one
   *
   * @param {PeerInfo} info
   * @returns {bool}
   */
  push (info) {
    if (!this.has(info)) {
      this.list.push(info)
      return true
    }
    return false
  }

  /**
   * Check if this PeerInfo is already in here.
   *
   * @param {PeerInfo} info
   * @returns {bool}
   */
  has (info) {
    const match = this.list.find((i) => i.id.isEqual(info.id))
    return Boolean(match)
  }

  /**
   * Get the list as an array.
   *
   * @returns {Array<PeerInfo>}
   */
  toArray () {
    return this.list.slice()
  }

  /**
   * Remove the last element
   *
   * @returns {PeerInfo}
   */
  pop () {
    return this.list.pop()
  }

  /**
   * The length of the list
   *
   * @type {number}
   */
  get length () {
    return this.list.length
  }
}

module.exports = PeerList

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/peer-list.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-queue/node_modules/eventemitter3/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/p-queue/node_modules/eventemitter3/index.js
      return function (require, module, exports) {
'use strict';

var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if ('undefined' !== typeof module) {
  module.exports = EventEmitter;
}

      };
    };
  }
}, {package:"eventemitter3",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-queue/node_modules/eventemitter3/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/crypto.js", {"./blake":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/blake.js","./crypto-sha1-2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/crypto-sha1-2-browser.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/utils.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha3/src/sha3.js","murmurhash3js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/crypto.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const sha3 = require('js-sha3')
const murmur3 = require('murmurhash3js')

const utils = require('./utils')
const sha = require('./crypto-sha1-2')

const toCallback = utils.toCallback
const toBuf = utils.toBuf
const fromString = utils.fromString
const fromNumberTo32BitBuf = utils.fromNumberTo32BitBuf

const dblSha2256 = (buf, cb) => {
  sha.sha2256(buf, (err, firstHash) => {
    if (err) {
      cb(err)
    }
    sha.sha2256((Buffer.from(firstHash)), cb)
  })
}

module.exports = {
  sha1: sha.sha1,
  sha2256: sha.sha2256,
  sha2512: sha.sha2512,
  sha3512: toCallback(toBuf(sha3.sha3_512)),
  sha3384: toCallback(toBuf(sha3.sha3_384)),
  sha3256: toCallback(toBuf(sha3.sha3_256)),
  sha3224: toCallback(toBuf(sha3.sha3_224)),
  shake128: toCallback(toBuf(sha3.shake_128, 128)),
  shake256: toCallback(toBuf(sha3.shake_256, 256)),
  keccak224: toCallback(toBuf(sha3.keccak_224)),
  keccak256: toCallback(toBuf(sha3.keccak_256)),
  keccak384: toCallback(toBuf(sha3.keccak_384)),
  keccak512: toCallback(toBuf(sha3.keccak_512)),
  murmur3128: toCallback(toBuf(fromString(murmur3.x64.hash128))),
  murmur332: toCallback(fromNumberTo32BitBuf(fromString(murmur3.x86.hash32))),
  addBlake: require('./blake'),
  dblSha2256: dblSha2256
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/crypto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/peer-distance-list.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js","async/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/map.js","xor-distance":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xor-distance/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/peer-distance-list.js
      return function (require, module, exports) {
'use strict'

const distance = require('xor-distance')
const utils = require('./utils')
const map = require('async/map')

/**
 * Maintains a list of peerIds sorted by distance from a DHT key.
 */
class PeerDistanceList {
  /**
   * Creates a new PeerDistanceList.
   *
   * @param {Buffer} originDhtKey - the DHT key from which distance is calculated
   * @param {number} capacity - the maximum size of the list
   */
  constructor (originDhtKey, capacity) {
    this.originDhtKey = originDhtKey
    this.capacity = capacity
    this.peerDistances = []
  }

  /**
   * The length of the list
   */
  get length () {
    return this.peerDistances.length
  }

  /**
   * The peerIds in the list, in order of distance from the origin key
   */
  get peers () {
    return this.peerDistances.map(pd => pd.peerId)
  }

  /**
   * Add a peerId to the list.
   *
   * @param {PeerId} peerId
   * @param {function(Error)} callback
   * @returns {void}
   */
  add (peerId, callback) {
    if (this.peerDistances.find(pd => pd.peerId.id.equals(peerId.id))) {
      return callback()
    }

    utils.convertPeerId(peerId, (err, dhtKey) => {
      if (err) {
        return callback(err)
      }

      const el = {
        peerId,
        distance: distance(this.originDhtKey, dhtKey)
      }

      this.peerDistances.push(el)
      this.peerDistances.sort((a, b) => distance.compare(a.distance, b.distance))
      this.peerDistances = this.peerDistances.slice(0, this.capacity)

      callback()
    })
  }

  /**
   * Indicates whether any of the peerIds passed as a parameter are closer
   * to the origin key than the furthest peerId in the PeerDistanceList.
   *
   * @param {Array<PeerId>} peerIds
   * @param {function(Error, Boolean)} callback
   * @returns {void}
   */
  anyCloser (peerIds, callback) {
    if (!peerIds.length) {
      return callback(null, false)
    }

    if (!this.length) {
      return callback(null, true)
    }

    map(peerIds, (peerId, cb) => utils.convertPeerId(peerId, cb), (err, dhtKeys) => {
      if (err) {
        return callback(err)
      }

      const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance
      for (const dhtKey of dhtKeys) {
        const keyDistance = distance(this.originDhtKey, dhtKey)
        if (distance.compare(keyDistance, furthestDistance) < 0) {
          return callback(null, true)
        }
      }
      return callback(null, false)
    })
  }
}

module.exports = PeerDistanceList

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/peer-distance-list.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/workerQueue.js", {"async/queue":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/queue.js","promise-to-callback":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promise-to-callback/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/workerQueue.js
      return function (require, module, exports) {
'use strict'

const queue = require('async/queue')
const promisify = require('promisify-es6')
const promiseToCallback = require('promise-to-callback')

class WorkerQueue {
  /**
   * Creates a new WorkerQueue.
   *
   * @param {DHT} dht
   * @param {Run} run
   * @param {Object} path
   * @param {function} log
   */
  constructor (dht, run, path, log) {
    this.dht = dht
    this.run = run
    this.path = path
    this.log = log

    this.concurrency = this.dht.concurrency
    this.queue = this.setupQueue()
    // a container for resolve/reject functions that will be populated
    // when execute() is called
    this.execution = null
  }

  /**
   * Create the underlying async queue.
   *
   * @returns {Object}
   */
  setupQueue () {
    const q = queue((peer, cb) => {
      promiseToCallback(this.processNext(peer))(cb)
    }, this.concurrency)

    // If there's an error, stop the worker
    q.error = (err) => {
      this.log.error('queue', err)
      this.stop(err)
    }

    // When all peers in the queue have been processed, stop the worker
    q.drain = () => {
      this.log('queue:drain')
      this.stop()
    }

    // When a space opens up in the queue, add some more peers
    q.unsaturated = () => {
      if (this.running) {
        this.fill()
      }
    }

    q.buffer = 0

    return q
  }

  /**
   * Stop the worker, optionally providing an error to pass to the worker's
   * callback.
   *
   * @param {Error} err
   */
  stop (err) {
    if (!this.running) {
      return
    }

    this.running = false
    this.queue.kill()
    this.log('worker:stop, %d workers still running', this.run.workers.filter(w => w.running).length)
    if (err) {
      this.execution.reject(err)
    } else {
      this.execution.resolve()
    }
  }

  /**
   * Use the queue from async to keep `concurrency` amount items running
   * per path.
   *
   * @return {Promise<void>}
   */
  async execute () {
    this.running = true
    // store the promise resolution functions to be resolved at end of queue
    this.execution = {}
    const execPromise = new Promise((resolve, reject) => Object.assign(this.execution, { resolve, reject }))
    // start queue
    this.fill()
    // await completion
    await execPromise
  }

  /**
   * Add peers to the worker queue until there are enough to satisfy the
   * worker queue concurrency.
   * Note that we don't want to take any more than those required to satisfy
   * concurrency from the peers-to-query queue, because we always want to
   * query the closest peers to the key first, and new peers are continously
   * being added to the peers-to-query queue.
   */
  fill () {
    // Note:
    // - queue.running(): number of items that are currently running
    // - queue.length(): the number of items that are waiting to be run
    while (this.queue.running() + this.queue.length() < this.concurrency &&
           this.path.peersToQuery.length > 0) {
      this.queue.push(this.path.peersToQuery.dequeue())
    }
  }

  /**
   * Process the next peer in the queue
   *
   * @param {PeerId} peer
   * @returns {Promise<void>}
   */
  async processNext (peer) {
    if (!this.running) {
      return
    }

    // The paths must be disjoint, meaning that no two paths in the Query may
    // traverse the same peer
    if (this.run.peersSeen.has(peer)) {
      return
    }

    // Check if we've queried enough peers already
    let continueQuerying, continueQueryingError
    try {
      continueQuerying = await this.run.continueQuerying(this)
    } catch (err) {
      continueQueryingError = err
    }

    // Abort and ignore any error if we're no longer running
    if (!this.running) {
      return
    }

    if (continueQueryingError) {
      throw continueQueryingError
    }

    // No peer we're querying is closer, stop the queue
    // This will cause queries that may potentially result in
    // closer nodes to be ended, but it reduces overall query time
    if (!continueQuerying) {
      this.stop()
      return
    }

    // Check if another path has queried this peer in the mean time
    if (this.run.peersSeen.has(peer)) {
      return
    }
    this.run.peersSeen.add(peer)

    // Execute the query on the next peer
    this.log('queue:work')
    let state, execError
    try {
      state = await this.execQuery(peer)
    } catch (err) {
      execError = err
    }

    // Abort and ignore any error if we're no longer running
    if (!this.running) {
      return
    }

    this.log('queue:work:done', execError, state)

    if (execError) {
      throw execError
    }

    // If query is complete, stop all workers.
    // Note: run.stop() calls stop() on all the workers, which kills the
    // queue and resolves execution
    if (state && state.queryComplete) {
      this.log('query:complete')
      this.run.stop()
      return
    }

    // If path is complete, just stop this worker.
    // Note: this.stop() kills the queue and resolves execution
    if (state && state.pathComplete) {
      this.stop()
    }
  }

  /**
   * Execute a query on the next peer.
   *
   * @param {PeerId} peer
   * @returns {Promise<void>}
   * @private
   */
  async execQuery (peer) {
    let res, queryError
    try {
      res = await this.path.queryFunc(peer)
    } catch (err) {
      queryError = err
    }

    // Abort and ignore any error if we're no longer running
    if (!this.running) {
      return
    }

    if (queryError) {
      this.run.errors.push(queryError)
      return
    }

    // Add the peer to the closest peers we have successfully queried
    await promisify(cb => this.run.peersQueried.add(peer, cb))()

    // If the query indicates that this path or the whole query is complete
    // set the path result and bail out
    if (res.pathComplete || res.queryComplete) {
      this.path.res = res
      return {
        pathComplete: res.pathComplete,
        queryComplete: res.queryComplete
      }
    }

    // If there are closer peers to query, add them to the queue
    if (res.closerPeers && res.closerPeers.length > 0) {
      await Promise.all(res.closerPeers.map(async (closer) => {
        // don't add ourselves
        if (this.dht._isSelf(closer.id)) {
          return
        }
        closer = this.dht.peerBook.put(closer)
        this.dht._peerDiscovered(closer)
        await this.path.addPeerToQuery(closer.id)
      }))
    }
  }
}

module.exports = WorkerQueue

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/workerQueue.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/path.js", {"../peer-queue":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/peer-queue.js","../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/path.js
      return function (require, module, exports) {
'use strict'

const PeerQueue = require('../peer-queue')
const utils = require('../utils')

// TODO: Temporary until parallel dial in Switch have a proper
// timeout. Requires async/await refactor of transports and
// dial abort logic. This gives us 30s to complete the `queryFunc`.
// This should help reduce the high end call times of queries
const QUERY_FUNC_TIMEOUT = 30e3

/**
 * Manages a single Path through the DHT.
 */
class Path {
  /**
   * Creates a Path.
   *
   * @param {Run} run
   * @param {queryFunc} queryFunc
   */
  constructor (run, queryFunc) {
    this.run = run
    this.queryFunc = utils.withTimeout(queryFunc, QUERY_FUNC_TIMEOUT)
    if (!this.queryFunc) throw new Error('Path requires a `queryFn` to be specified')
    if (typeof this.queryFunc !== 'function') throw new Error('Path expected `queryFn` to be a function. Got ' + typeof this.queryFunc)

    /**
     * @type {Array<PeerId>}
     */
    this.initialPeers = []

    /**
     * @type {PeerQueue}
     */
    this.peersToQuery = null
  }

  /**
   * Add a peer to the set of peers that are used to intialize the path.
   *
   * @param {PeerId} peer
   */
  addInitialPeer (peer) {
    this.initialPeers.push(peer)
  }

  /**
   * Execute the path.
   *
   * @returns {Promise}
   *
   */
  async execute () {
    // Create a queue of peers ordered by distance from the key
    const queue = await PeerQueue.fromKey(this.run.query.key)
    // Add initial peers to the queue
    this.peersToQuery = queue
    await Promise.all(this.initialPeers.map(peer => this.addPeerToQuery(peer)))
    await this.run.workerQueue(this)
  }

  /**
   * Add a peer to the peers to be queried.
   *
   * @param {PeerId} peer
   * @returns {Promise<void>}
   */
  async addPeerToQuery (peer) {
    // Don't add self
    if (this.run.query.dht._isSelf(peer)) {
      return
    }

    // The paths must be disjoint, meaning that no two paths in the Query may
    // traverse the same peer
    if (this.run.peersSeen.has(peer)) {
      return
    }

    await this.peersToQuery.enqueue(peer)
  }
}

module.exports = Path

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/path.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/index.js", {"../../message":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/message/index.js","./add-provider":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/add-provider.js","./find-node":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/find-node.js","./get-providers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/get-providers.js","./get-value":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/get-value.js","./ping":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/ping.js","./put-value":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/put-value.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/index.js
      return function (require, module, exports) {
'use strict'

const T = require('../../message').TYPES

module.exports = (dht) => {
  const handlers = {
    [T.GET_VALUE]: require('./get-value')(dht),
    [T.PUT_VALUE]: require('./put-value')(dht),
    [T.FIND_NODE]: require('./find-node')(dht),
    [T.ADD_PROVIDER]: require('./add-provider')(dht),
    [T.GET_PROVIDERS]: require('./get-providers')(dht),
    [T.PING]: require('./ping')(dht)
  }

  /**
   * Get the message handler matching the passed in type.
   *
   * @param {number} type
   *
   * @returns {function(PeerInfo, Message, function(Error, Message))}
   *
   * @private
   */
  return function getMessageHandler (type) {
    return handlers[type]
  }
}

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-pair/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-pair/index.js
      return function (require, module, exports) {
'use strict'

//a pair of pull streams where one drains from the other
module.exports = function () {
  var _read, waiting
  function sink (read) {
    if('function' !== typeof read)
      throw new Error('read must be function')

    if(_read)
      throw new Error('already piped')
    _read = read
    if(waiting) {
      var _waiting = waiting
      waiting = null
      _read.apply(null, _waiting)
    }
  }
  function source (abort, cb) {
    if(_read)
      _read(abort, cb)
    else
      waiting = [abort, cb]
  }

  return {
    source: source, sink: sink
  }
}


      };
    };
  }
}, {package:"pull-pair",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-pair/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/support.js", {"async/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/parallel.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/node_modules/multihashing-async/src/index.js","pull-length-prefixed":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js","pull-stream/sinks/collect":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/collect.js","pull-stream/sources/values":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/values.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/support.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const mh = require('multihashing-async')
const lp = require('pull-length-prefixed')
const pull = require('pull-stream/pull')
const values = require('pull-stream/sources/values')
const collect = require('pull-stream/sinks/collect')
const crypto = require('libp2p-crypto')
const parallel = require('async/parallel')

exports.exchanges = [
  'P-256',
  'P-384',
  'P-521'
]

exports.ciphers = [
  'AES-256',
  'AES-128'
]

exports.hashes = [
  'SHA256',
  'SHA512'
]

// Determines which algorithm to use.  Note:  f(a, b) = f(b, a)
exports.theBest = (order, p1, p2) => {
  let first
  let second

  if (order < 0) {
    first = p2
    second = p1
  } else if (order > 0) {
    first = p1
    second = p2
  } else {
    return p1[0]
  }

  for (let firstCandidate of first) {
    for (let secondCandidate of second) {
      if (firstCandidate === secondCandidate) {
        return firstCandidate
      }
    }
  }

  throw new Error('No algorithms in common!')
}

exports.makeMacAndCipher = (target, callback) => {
  parallel([
    (cb) => makeMac(target.hashT, target.keys.macKey, cb),
    (cb) => makeCipher(target.cipherT, target.keys.iv, target.keys.cipherKey, cb)
  ], (err, macAndCipher) => {
    if (err) {
      return callback(err)
    }

    target.mac = macAndCipher[0]
    target.cipher = macAndCipher[1]
    callback()
  })
}

function makeMac (hash, key, callback) {
  crypto.hmac.create(hash, key, callback)
}

function makeCipher (cipherType, iv, key, callback) {
  if (cipherType === 'AES-128' || cipherType === 'AES-256') {
    return crypto.aes.create(key, iv, callback)
  }

  // TODO: figure out if Blowfish is needed and if so find a library for it.
  callback(new Error(`unrecognized cipher type: ${cipherType}`))
}

exports.selectBest = (local, remote, cb) => {
  exports.digest(Buffer.concat([
    remote.pubKeyBytes,
    local.nonce
  ]), (err, oh1) => {
    if (err) {
      return cb(err)
    }

    exports.digest(Buffer.concat([
      local.pubKeyBytes,
      remote.nonce
    ]), (err, oh2) => {
      if (err) {
        return cb(err)
      }

      const order = Buffer.compare(oh1, oh2)

      if (order === 0) {
        return cb(new Error('you are trying to talk to yourself'))
      }

      cb(null, {
        curveT: exports.theBest(order, local.exchanges, remote.exchanges),
        cipherT: exports.theBest(order, local.ciphers, remote.ciphers),
        hashT: exports.theBest(order, local.hashes, remote.hashes),
        order
      })
    })
  })
}

exports.digest = (buf, cb) => {
  mh.digest(buf, 'sha2-256', buf.length, cb)
}

exports.write = function write (state, msg, cb) {
  cb = cb || (() => {})
  pull(
    values([msg]),
    lp.encode({ fixed: true, bytes: 4 }),
    collect((err, res) => {
      if (err) {
        return cb(err)
      }
      state.shake.write(res[0])
      cb()
    })
  )
}

exports.read = function read (reader, cb) {
  lp.decodeFromReader(reader, { fixed: true, bytes: 4 }, cb)
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-secio",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/support.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/crypto.js", {"../support":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/support.js","./secio.proto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/secio.proto.js","async/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/parallel.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","protons":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/crypto.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const protons = require('protons')
const PeerId = require('peer-id')
const crypto = require('libp2p-crypto')
const parallel = require('async/parallel')
const waterfall = require('async/waterfall')
const debug = require('debug')
const log = debug('libp2p:secio')
log.error = debug('libp2p:secio:error')

const pbm = protons(require('./secio.proto'))

const support = require('../support')

// nonceSize is the size of our nonces (in bytes)
const nonceSize = 16

exports.createProposal = (state) => {
  state.proposal.out = {
    rand: crypto.randomBytes(nonceSize),
    pubkey: state.key.local.public.bytes,
    exchanges: support.exchanges.join(','),
    ciphers: support.ciphers.join(','),
    hashes: support.hashes.join(',')
  }

  state.proposalEncoded.out = pbm.Propose.encode(state.proposal.out)
  return state.proposalEncoded.out
}

exports.createExchange = (state, callback) => {
  crypto.keys.generateEphemeralKeyPair(state.protocols.local.curveT, (err, res) => {
    if (err) {
      return callback(err)
    }

    state.ephemeralKey.local = res.key
    state.shared.generate = res.genSharedKey

    // Gather corpus to sign.
    const selectionOut = Buffer.concat([
      state.proposalEncoded.out,
      state.proposalEncoded.in,
      state.ephemeralKey.local
    ])

    state.key.local.sign(selectionOut, (err, sig) => {
      if (err) {
        return callback(err)
      }

      state.exchange.out = {
        epubkey: state.ephemeralKey.local,
        signature: sig
      }

      callback(null, pbm.Exchange.encode(state.exchange.out))
    })
  })
}

exports.identify = (state, msg, callback) => {
  log('1.1 identify')

  state.proposalEncoded.in = msg
  state.proposal.in = pbm.Propose.decode(msg)
  const pubkey = state.proposal.in.pubkey

  state.key.remote = crypto.keys.unmarshalPublicKey(pubkey)

  PeerId.createFromPubKey(pubkey.toString('base64'), (err, remoteId) => {
    if (err) {
      return callback(err)
    }

    // If we know who we are dialing to, double check
    if (state.id.remote) {
      if (state.id.remote.toB58String() !== remoteId.toB58String()) {
        return callback(new Error('dialed to the wrong peer, Ids do not match'))
      }
    } else {
      state.id.remote = remoteId
    }

    log('1.1 identify - %s - identified remote peer as %s', state.id.local.toB58String(), state.id.remote.toB58String())
    callback()
  })
}

exports.selectProtocols = (state, callback) => {
  log('1.2 selection')

  const local = {
    pubKeyBytes: state.key.local.public.bytes,
    exchanges: support.exchanges,
    hashes: support.hashes,
    ciphers: support.ciphers,
    nonce: state.proposal.out.rand
  }

  const remote = {
    pubKeyBytes: state.proposal.in.pubkey,
    exchanges: state.proposal.in.exchanges.split(','),
    hashes: state.proposal.in.hashes.split(','),
    ciphers: state.proposal.in.ciphers.split(','),
    nonce: state.proposal.in.rand
  }

  support.selectBest(local, remote, (err, selected) => {
    if (err) {
      return callback(err)
    }
    // we use the same params for both directions (must choose same curve)
    // WARNING: if they dont SelectBest the same way, this won't work...
    state.protocols.remote = {
      order: selected.order,
      curveT: selected.curveT,
      cipherT: selected.cipherT,
      hashT: selected.hashT
    }

    state.protocols.local = {
      order: selected.order,
      curveT: selected.curveT,
      cipherT: selected.cipherT,
      hashT: selected.hashT
    }
    callback()
  })
}

exports.verify = (state, msg, callback) => {
  log('2.1. verify')

  state.exchange.in = pbm.Exchange.decode(msg)
  state.ephemeralKey.remote = state.exchange.in.epubkey

  const selectionIn = Buffer.concat([
    state.proposalEncoded.in,
    state.proposalEncoded.out,
    state.ephemeralKey.remote
  ])

  state.key.remote.verify(selectionIn, state.exchange.in.signature, (err, sigOk) => {
    if (err) {
      return callback(err)
    }

    if (!sigOk) {
      return callback(new Error('Bad signature'))
    }

    log('2.1. verify - signature verified')
    callback()
  })
}

exports.generateKeys = (state, callback) => {
  log('2.2. keys')

  waterfall([
    (cb) => state.shared.generate(state.exchange.in.epubkey, cb),
    (secret, cb) => {
      state.shared.secret = secret

      crypto.keys.keyStretcher(
        state.protocols.local.cipherT,
        state.protocols.local.hashT,
        state.shared.secret,
        cb
      )
    },
    (keys, cb) => {
      // use random nonces to decide order.
      if (state.protocols.local.order > 0) {
        state.protocols.local.keys = keys.k1
        state.protocols.remote.keys = keys.k2
      } else if (state.protocols.local.order < 0) {
        // swap
        state.protocols.local.keys = keys.k2
        state.protocols.remote.keys = keys.k1
      } else {
        // we should've bailed before state. but if not, bail here.
        return cb(new Error('you are trying to talk to yourself'))
      }

      log('2.3. mac + cipher')

      parallel([
        (_cb) => support.makeMacAndCipher(state.protocols.local, _cb),
        (_cb) => support.makeMacAndCipher(state.protocols.remote, _cb)
      ], cb)
    }
  ], callback)
}

exports.verifyNonce = (state, n2) => {
  const n1 = state.proposal.out.rand

  if (n1.equals(n2)) return

  throw new Error(
    `Failed to read our encrypted nonce: ${n1.toString('hex')} != ${n2.toString('hex')}`
  )
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-secio",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/crypto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/etm.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","pull-length-prefixed":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js","pull-stream/throughs/async-map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/async-map.js","pull-stream/throughs/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/map.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/etm.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const pull = require('pull-stream/pull')
const map = require('pull-stream/throughs/map')
const asyncMap = require('pull-stream/throughs/async-map')
const lp = require('pull-length-prefixed')

const lpOpts = {
  fixed: true,
  bytes: 4
}

exports.createBoxStream = (cipher, mac) => {
  return pull(
    ensureBuffer(),
    asyncMap((chunk, cb) => {
      cipher.encrypt(chunk, (err, data) => {
        if (err) {
          return cb(err)
        }

        mac.digest(data, (err, digest) => {
          if (err) {
            return cb(err)
          }

          cb(null, Buffer.concat([data, digest]))
        })
      })
    }),
    lp.encode(lpOpts)
  )
}

exports.createUnboxStream = (decipher, mac) => {
  return pull(
    ensureBuffer(),
    lp.decode(lpOpts),
    asyncMap((chunk, cb) => {
      const l = chunk.length
      const macSize = mac.length

      if (l < macSize) {
        return cb(new Error(`buffer (${l}) shorter than MAC size (${macSize})`))
      }

      const mark = l - macSize
      const data = chunk.slice(0, mark)
      const macd = chunk.slice(mark)

      mac.digest(data, (err, expected) => {
        if (err) {
          return cb(err)
        }

        if (!macd.equals(expected)) {
          return cb(new Error(`MAC Invalid: ${macd.toString('hex')} != ${expected.toString('hex')}`))
        }

        // all good, decrypt
        decipher.decrypt(data, (err, decrypted) => {
          if (err) {
            return cb(err)
          }

          cb(null, decrypted)
        })
      })
    })
  )
}

function ensureBuffer () {
  return map((c) => {
    if (typeof c === 'string') {
      return Buffer.from(c, 'utf-8')
    }

    return c
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-secio",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/etm.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/errors/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/errors/index.js
      return function (require, module, exports) {
'use strict'

exports.ERR_WS_STAR_WEBSOCKET_CONNECTION = 'ERR_WS_STAR_WEBSOCKET_CONNECTION'

      };
    };
  }
}, {package:"libp2p-websocket-star",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/errors/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-pull-stream/src/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","data-queue":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/data-queue/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-pull-stream/node_modules/debug/src/browser.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-pull-stream/node_modules/uuid/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-pull-stream/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

// socket.io-pull-stream
const Queue = require('data-queue')
const uuid = require('uuid')
const pull = require('pull-stream')
const sioname = (type, name) => 'socket.io-pull-stream.' + type + (name ? '.' + name : '')
const debug = require('debug')
const _log = debug('socket.io-pull-stream')

function doCodec (codec, data) {
  if (data == null) return data
  try {
    return codec(data)
  } catch (e) {
    console.error('Codec Error')
    console.error(e)
    return false
  }
}

const codecs = {
  hex: {
    encode: v => v.toString('hex'),
    decode: v => Buffer.from(v, 'hex')
  },
  plain: {
    encode: v => v,
    decode: v => v
  },
  buffer: { // always do Buffer.from because browsers
    encode: v => Buffer.from(v),
    decode: v => Buffer.from(v)
  }
}

function getCodec (c) {
  if (!c) c = 'plain'
  if (typeof c === 'object') return c
  const co = codecs[c]
  if (!co) throw new Error('Invalid codec ' + c)
  return co
}

function SIOSource (sio, id, opt) {
  const q = Queue()
  const log = sio.sioplog.bind(sio.sioplog, 'source(' + id + ')')
  const codec = getCodec(opt.codec).decode
  log('create source')
  sio.emit(sioname('accept', id))

  function unlisten () {
    sio.removeAllListeners(sioname('error', id))
    sio.removeAllListeners(sioname('queue', id))
  }

  sio.on(sioname('error', id), err => {
    if (err === true) log('finish')
    else log('error')
    unlisten()
    q.append({end: err})
  })
  sio.on(sioname('queue', id), data => {
    log('queue data')
    q.append({data: doCodec(codec, data)})
  })
  sio.once('disconnect', () => {
    unlisten()
    q.append({end: true})
  })
  return function (end, cb) {
    log('reading')
    if (end) return cb(end)
    q.get((err, data) => {
      if (err) return cb(err)
      if (data.end) {
        q.error(data.end)
        return cb(data.end)
      }
      return cb(null, data.data)
    })
  }
}

function SIOSink (sio, id, opt) {
  const q = Queue()
  const log = sio.sioplog.bind(sio.sioplog, '  sink(' + id + ')')
  const codec = getCodec(opt.codec).encode
  let ended
  log('create sink')
  sio.once(sioname('accept', id), () => {
    log('start transmission')

    function loop () {
      q.get((_, val) => {
        let {data, err} = val || {}
        if (_) err = _
        log('send', err && err === true ? 'finish' : err ? 'error' : data ? 'data' : '<invalid>')
        if (err && !_) q.error(err)
        if (err) return sio.emit(sioname('error', id), err)
        if (data) sio.emit(sioname('queue', id), doCodec(codec, data))
        loop()
      })
    }
    loop()
  })

  function doErr (end) {
    q.append({err: end})
    ended = end
  }

  sio.once('disconnect', () => doErr(true))

  return function (read) {
    read(null, function next (end, data) {
      if (end) return doErr(end)
      if (ended) return read(ended, next)
      q.append({data})
      read(null, next)
    })
  }
}

module.exports = function SIOPullStream (sio, opt) {
  if (sio.createSink) return
  sio.sioplog = sio.id ? _log.bind(_log, '[' + sio.id + ']') : _log
  sio.createSink = (id, _) => {
    if (!id) id = uuid()
    const sink = SIOSink(sio, id, opt || _)
    sink.id = id
    return sink
  }
  sio.createSource = (id, _) => {
    const source = SIOSource(sio, id, opt || _)
    source.id = id
    return source
  }
  sio.createProxy = (id, tsio, _) => {
    pull(
      sio.createSource(id, _),
      tsio.createSink(id, _)
    )
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"socket.io-pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-pull-stream/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/end-of-stream.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/end-of-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/pipeline.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/errors-browser.js","./end-of-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/pipeline.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/pipeline.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_writable.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js","./internal/streams/destroy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/state.js","./internal/streams/stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/stream-browser.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","util-deprecate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/util-deprecate/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_writable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_writable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js", {"./_stream_readable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_writable.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_transform.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_transform.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_transform.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_passthrough.js", {"./_stream_transform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_transform.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_passthrough.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_passthrough.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_readable.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js","./internal/streams/async_iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/async_iterator.js","./internal/streams/buffer_list":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/buffer_list.js","./internal/streams/destroy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/from":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/from-browser.js","./internal/streams/state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/state.js","./internal/streams/stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/stream-browser.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","string_decoder/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/string_decoder/lib/string_decoder.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_readable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/lib/_stream_readable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/parseuri/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/parseuri/index.js
      return function (require, module, exports) {
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);

    return uri;
};

function pathNames(obj, path) {
    var regx = /\/{2,9}/g,
        names = path.replace(regx, "/").split("/");

    if (path.substr(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.substr(path.length - 1, 1) == '/') {
        names.splice(names.length - 1, 1);
    }

    return names;
}

function queryKey(uri, query) {
    var data = {};

    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });

    return data;
}

      };
    };
  }
}, {package:"parseuri",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/parseuri/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/on.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/on.js
      return function (require, module, exports) {

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}

      };
    };
  }
}, {package:"socket.io-client",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/on.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/component-bind/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/component-bind/index.js
      return function (require, module, exports) {
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

      };
    };
  }
}, {package:"component-bind",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/component-bind/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/to-array/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/to-array/index.js
      return function (require, module, exports) {
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

      };
    };
  }
}, {package:"to-array",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/to-array/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/parseqs/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/parseqs/index.js
      return function (require, module, exports) {
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

      };
    };
  }
}, {package:"parseqs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/parseqs/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/has-binary2/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","isarray":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/has-binary2/node_modules/isarray/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/has-binary2/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* global Blob File */

/*
 * Module requirements.
 */

var isArray = require('isarray');

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' ||
                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' ||
                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
    (withNativeBlob && obj instanceof Blob) ||
    (withNativeFile && obj instanceof File)
  ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"has-binary2",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/has-binary2/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/node_modules/debug/src/debug.js", {"ms":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/node_modules/ms/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/node_modules/debug/src/debug.js
      return function (require, module, exports) {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

      };
    };
  }
}, {package:"debug",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/node_modules/debug/src/debug.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/node_modules/isarray/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/node_modules/isarray/index.js
      return function (require, module, exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

      };
    };
  }
}, {package:"isarray",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/node_modules/isarray/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/is-buffer.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/is-buffer.js
      return function (require, module, exports) {
(function (Buffer){(function (){

module.exports = isBuf;

var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
};

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"socket.io-parser",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/is-buffer.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/binary.js", {"./is-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/is-buffer.js","isarray":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/node_modules/isarray/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/binary.js
      return function (require, module, exports) {
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

      };
    };
  }
}, {package:"socket.io-parser",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/binary.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/node_modules/debug/src/browser.js", {"./debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/node_modules/debug/src/debug.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/node_modules/debug/src/browser.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"debug",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/node_modules/debug/src/browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/indexof/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/indexof/index.js
      return function (require, module, exports) {

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
      };
    };
  }
}, {package:"indexof",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/indexof/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/backo2/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/backo2/index.js
      return function (require, module, exports) {

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


      };
    };
  }
}, {package:"backo2",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/backo2/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/engine.io-client/lib/index.js", {"./socket":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/engine.io-client/lib/socket.js","engine.io-parser":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/engine.io-parser/lib/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/engine.io-client/lib/index.js
      return function (require, module, exports) {

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

      };
    };
  }
}, {package:"engine.io-client",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/engine.io-client/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/constants.js
      return function (require, module, exports) {
'use strict'

module.exports = {
  PROTOCOL: '/ipfs/ping/1.0.0',
  PING_LENGTH: 32
}

      };
    };
  }
}, {package:"libp2p-ping",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/util.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/constants.js","libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/util.js
      return function (require, module, exports) {
'use strict'

const crypto = require('libp2p-crypto')
const constants = require('./constants')

exports = module.exports

exports.rnd = (length) => {
  if (!length) {
    length = constants.PING_LENGTH
  }
  return crypto.randomBytes(length)
}

      };
    };
  }
}, {package:"libp2p-ping",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-floodsub/src/config.js", {"debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-floodsub/src/config.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')

const log = debug('libp2p:floodsub')
log.err = debug('libp2p:floodsub:error')

module.exports = {
  log: log,
  multicodec: '/floodsub/1.0.0'
}

      };
    };
  }
}, {package:"libp2p-floodsub",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-floodsub/src/config.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-pubsub/src/index.js", {"./message":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-pubsub/src/message/index.js","./message/sign":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-pubsub/src/message/sign.js","./peer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-pubsub/src/peer.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-pubsub/src/utils.js","async/each":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js","pull-stream/sources/empty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/empty.js","time-cache":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/time-cache/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-pubsub/src/index.js
      return function (require, module, exports) {
'use strict'

const EventEmitter = require('events')
const pull = require('pull-stream/pull')
const empty = require('pull-stream/sources/empty')
const asyncEach = require('async/each')
const TimeCache = require('time-cache')
const debug = require('debug')
const errcode = require('err-code')

const Peer = require('./peer')
const message = require('./message')
const { signMessage } = require('./message/sign')
const utils = require('./utils')

const nextTick = require('async/nextTick')

/**
 * PubsubBaseProtocol handles the peers and connections logic for pubsub routers
 */
class PubsubBaseProtocol extends EventEmitter {
  /**
   * @param {String} debugName
   * @param {String} multicodec
   * @param {Object} libp2p libp2p implementation
   * @param {Object} options
   * @param {boolean} options.signMessages if messages should be signed, defaults to true
   * @constructor
   */
  constructor (debugName, multicodec, libp2p, options) {
    super()

    options = {
      signMessages: true,
      ...options
    }

    this.log = debug(debugName)
    this.log.err = debug(`${debugName}:error`)
    this.multicodec = multicodec
    this.libp2p = libp2p
    this.started = false

    if (options.signMessages) {
      this.peerId = this.libp2p.peerInfo.id
    }

    /**
     * Map of topics to which peers are subscribed to
     *
     * @type {Map<string, Peer>}
     */
    this.topics = new Map()

    /**
     * Cache of seen messages
     *
     * @type {TimeCache}
     */
    this.seenCache = new TimeCache()

    /**
     * Map of peers.
     *
     * @type {Map<string, Peer>}
     */
    this.peers = new Map()

    // Dials that are currently in progress
    this._dials = new Set()

    this._onConnection = this._onConnection.bind(this)
    this._dialPeer = this._dialPeer.bind(this)
  }

  /**
   * Add a new connected peer to the peers map.
   * @private
   * @param {PeerInfo} peer peer info
   * @returns {PeerInfo}
   */
  _addPeer (peer) {
    const id = peer.info.id.toB58String()

    /*
      Always use an existing peer.

      What is happening here is: "If the other peer has already dialed to me, we already have
      an establish link between the two, what might be missing is a
      Connection specifically between me and that Peer"
     */
    let existing = this.peers.get(id)
    if (!existing) {
      this.log('new peer', id)
      this.peers.set(id, peer)
      existing = peer

      peer.once('close', () => this._removePeer(peer))
    }
    ++existing._references

    return existing
  }

  /**
   * Remove a peer from the peers map if it has no references.
   * @private
   * @param {Peer} peer peer state
   * @returns {PeerInfo}
   */
  _removePeer (peer) {
    const id = peer.info.id.toB58String()

    this.log('remove', id, peer._references)
    // Only delete when no one else is referencing this peer.
    if (--peer._references === 0) {
      this.log('delete peer', id)
      this.peers.delete(id)
    }

    return peer
  }

  /**
   * Dial a received peer.
   * @private
   * @param {PeerInfo} peerInfo peer info
   * @param {function} callback
   * @returns {void}
   */
  _dialPeer (peerInfo, callback) {
    callback = callback || function noop () { }
    const idB58Str = peerInfo.id.toB58String()

    // If already have a PubSub conn, ignore
    const peer = this.peers.get(idB58Str)
    if (peer && peer.isConnected) {
      return nextTick(() => callback())
    }

    // If already dialing this peer, ignore
    if (this._dials.has(idB58Str)) {
      this.log('already dialing %s, ignoring dial attempt', idB58Str)
      return nextTick(() => callback())
    }
    this._dials.add(idB58Str)

    this.log('dialing %s', idB58Str)
    this.libp2p.dialProtocol(peerInfo, this.multicodec, (err, conn) => {
      this.log('dial to %s complete', idB58Str)

      // If the dial is not in the set, it means that pubsub has been
      // stopped
      const pubsubStopped = !this._dials.has(idB58Str)
      this._dials.delete(idB58Str)

      if (err) {
        this.log.err(err)
        return callback()
      }

      // pubsub has been stopped, so we should just bail out
      if (pubsubStopped) {
        this.log('pubsub was stopped, not processing dial to %s', idB58Str)
        return callback()
      }

      this._onDial(peerInfo, conn, callback)
    })
  }

  /**
   * Dial a received peer.
   * @private
   * @param {PeerInfo} peerInfo peer info
   * @param {Connection} conn connection to the peer
   * @param {function} callback
   */
  _onDial (peerInfo, conn, callback) {
    const idB58Str = peerInfo.id.toB58String()
    this.log('connected', idB58Str)

    const peer = this._addPeer(new Peer(peerInfo))
    peer.attachConnection(conn)

    nextTick(() => callback())
  }

  /**
   * On successful connection event.
   * @private
   * @param {String} protocol connection protocol
   * @param {Connection} conn connection to the peer
   */
  _onConnection (protocol, conn) {
    conn.getPeerInfo((err, peerInfo) => {
      if (err) {
        this.log.err('Failed to identify incomming conn', err)
        return pull(empty(), conn)
      }

      const idB58Str = peerInfo.id.toB58String()
      const peer = this._addPeer(new Peer(peerInfo))

      this._processConnection(idB58Str, conn, peer)
    })
  }

  /**
   * Overriding the implementation of _processConnection should keep the connection and is
   * responsible for processing each RPC message received by other peers.
   * @abstract
   * @param {string} idB58Str peer id string in base58
   * @param {Connection} conn connection
   * @param {PeerInfo} peer peer info
   * @returns {undefined}
   *
   */
  _processConnection (idB58Str, conn, peer) {
    throw errcode('_processConnection must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')
  }

  /**
   * On connection end event.
   * @private
   * @param {string} idB58Str peer id string in base58
   * @param {PeerInfo} peer peer info
   * @param {Error} err error for connection end
   */
  _onConnectionEnd (idB58Str, peer, err) {
    // socket hang up, means the one side canceled
    if (err && err.message !== 'socket hang up') {
      this.log.err(err)
    }

    this.log('connection ended', idB58Str, err ? err.message : '')
    this._removePeer(peer)
  }

  /**
   * Normalizes the message and signs it, if signing is enabled
   *
   * @param {Message} message
   * @param {function(Error, Message)} callback
   */
  _buildMessage (message, callback) {
    const msg = utils.normalizeOutRpcMessage(message)
    if (this.peerId) {
      signMessage(this.peerId, msg, callback)
    } else {
      nextTick(callback, null, msg)
    }
  }

  /**
   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.
   * For example, a Floodsub implementation might simply publish each message to each topic for every peer
   * @abstract
   * @param {Array<string>|string} topics
   * @param {Array<any>|any} messages
   * @param {function(Error)} callback
   * @returns {undefined}
   *
   */
  publish (topics, messages, callback) {
    throw errcode('publish must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')
  }

  /**
   * Overriding the implementation of subscribe should handle the appropriate algorithms for the publish/subscriber implementation.
   * For example, a Floodsub implementation might simply send a message for every peer showing interest in the topics
   * @abstract
   * @param {Array<string>|string} topics
   * @returns {undefined}
   */
  subscribe (topics) {
    throw errcode('subscribe must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')
  }

  /**
   * Overriding the implementation of unsubscribe should handle the appropriate algorithms for the publish/subscriber implementation.
   * For example, a Floodsub implementation might simply send a message for every peer revoking interest in the topics
   * @abstract
   * @param {Array<string>|string} topics
   * @returns {undefined}
   */
  unsubscribe (topics) {
    throw errcode('unsubscribe must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')
  }

  /**
   * Mounts the pubsub protocol onto the libp2p node and sends our
   * subscriptions to every peer conneceted
   *
   * @param {Function} callback
   * @returns {undefined}
   *
   */
  start (callback) {
    if (this.started) {
      return nextTick(() => callback(new Error('already started')))
    }
    this.log('starting')

    this.libp2p.handle(this.multicodec, this._onConnection)

    // Speed up any new peer that comes in my way
    this.libp2p.on('peer:connect', this._dialPeer)

    // Dial already connected peers
    const peerInfos = Object.values(this.libp2p.peerBook.getAll())

    asyncEach(peerInfos, (peer, cb) => this._dialPeer(peer, cb), (err) => {
      nextTick(() => {
        this.log('started')
        this.started = true
        callback(err)
      })
    })
  }

  /**
   * Unmounts the pubsub protocol and shuts down every connection
   *
   * @param {Function} callback
   * @returns {undefined}
   *
   */
  stop (callback) {
    if (!this.started) {
      return nextTick(() => callback(new Error('not started yet')))
    }

    this.libp2p.unhandle(this.multicodec)
    this.libp2p.removeListener('peer:connect', this._dialPeer)

    // Prevent any dials that are in flight from being processed
    this._dials = new Set()

    this.log('stopping')
    asyncEach(this.peers.values(), (peer, cb) => peer.close(cb), (err) => {
      if (err) {
        return callback(err)
      }

      this.log('stopped')
      this.peers = new Map()
      this.started = false
      callback()
    })
  }
}

module.exports = PubsubBaseProtocol
module.exports.message = message
module.exports.utils = utils

      };
    };
  }
}, {package:"libp2p-pubsub",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-pubsub/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/latency-monitor/dist/LatencyMonitor.js", {"./VisibilityChangeEmitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/latency-monitor/dist/VisibilityChangeEmitter.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/latency-monitor/node_modules/debug/src/browser.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","lodash/get":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/get.js","lodash/isFunction":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/isFunction.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/latency-monitor/dist/LatencyMonitor.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _get = require('lodash/get');

var _get2 = _interopRequireDefault(_get);

var _isFunction = require('lodash/isFunction');

var _isFunction2 = _interopRequireDefault(_isFunction);

var _VisibilityChangeEmitter = require('./VisibilityChangeEmitter');

var _VisibilityChangeEmitter2 = _interopRequireDefault(_VisibilityChangeEmitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global window */


var debug = require('debug')('latency-monitor:LatencyMonitor');

/**
 * @typedef {Object} SummaryObject
 * @property {Number} events How many events were called
 * @property {Number} minMS What was the min time for a cb to be called
 * @property {Number} maxMS What was the max time for a cb to be called
 * @property {Number} avgMs What was the average time for a cb to be called
 * @property {Number} lengthMs How long this interval was in ms
 */

/**
 * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling
 * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.
 * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.
 *
 * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop
 * and timing how long it takes to get back.
 *
 * @example
 * const monitor = new LatencyMonitor();
 * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));
 *
 * @example
 * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});
 * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));
 */

var LatencyMonitor = function (_EventEmitter) {
    _inherits(LatencyMonitor, _EventEmitter);

    /**
     * @param {Number} [latencyCheckIntervalMs=500] How often to add a latency check event (ms)
     * @param {Number} [dataEmitIntervalMs=5000] How often to summarize latency check events. null or 0 disables event firing
     * @param {function} [asyncTestFn] What cb-style async function to use
     * @param {Number} [latencyRandomPercentage=5] What percent (+/-) of latencyCheckIntervalMs should we randomly use? This helps avoid alignment to other events.
     */
    function LatencyMonitor() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            latencyCheckIntervalMs = _ref.latencyCheckIntervalMs,
            dataEmitIntervalMs = _ref.dataEmitIntervalMs,
            asyncTestFn = _ref.asyncTestFn,
            latencyRandomPercentage = _ref.latencyRandomPercentage;

        _classCallCheck(this, LatencyMonitor);

        var _this = _possibleConstructorReturn(this, (LatencyMonitor.__proto__ || Object.getPrototypeOf(LatencyMonitor)).call(this));

        var that = _this;

        // 0 isn't valid here, so its ok to use ||
        that.latencyCheckIntervalMs = latencyCheckIntervalMs || 500; // 0.5s
        that.latencyRandomPercentage = latencyRandomPercentage || 10;
        that._latecyCheckMultiply = 2 * (that.latencyRandomPercentage / 100.0) * that.latencyCheckIntervalMs;
        that._latecyCheckSubtract = that._latecyCheckMultiply / 2;

        that.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? undefined : dataEmitIntervalMs || 5 * 1000; // 5s
        debug('latencyCheckIntervalMs: %s dataEmitIntervalMs: %s', that.latencyCheckIntervalMs, that.dataEmitIntervalMs);
        if (that.dataEmitIntervalMs) {
            debug('Expecting ~%s events per summary', that.latencyCheckIntervalMs / that.dataEmitIntervalMs);
        } else {
            debug('Not emitting summaries');
        }

        that.asyncTestFn = asyncTestFn; // If there is no asyncFn, we measure latency

        // If process: use high resolution timer
        if (process && process.hrtime) {
            debug('Using process.hrtime for timing');
            that.now = process.hrtime;
            that.getDeltaMS = function (startTime) {
                var hrtime = that.now(startTime);
                return hrtime[0] * 1000 + hrtime[1] / 1000000;
            };
            // Let's try for a timer that only monotonically increases
        } else if (typeof window !== 'undefined' && (0, _get2.default)(window, 'performance.now')) {
            debug('Using performance.now for timing');
            that.now = window.performance.now.bind(window.performance);
            that.getDeltaMS = function (startTime) {
                return Math.round(that.now() - startTime);
            };
        } else {
            debug('Using Date.now for timing');
            that.now = Date.now;
            that.getDeltaMS = function (startTime) {
                return that.now() - startTime;
            };
        }

        that._latencyData = that._initLatencyData();

        // We check for isBrowser because of browsers set max rates of timeouts when a page is hidden,
        // so we fall back to another library
        // See: http://stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-background-tabs
        if (isBrowser()) {
            that._visibilityChangeEmitter = new _VisibilityChangeEmitter2.default();
            that._visibilityChangeEmitter.on('visibilityChange', function (pageInFocus) {
                if (pageInFocus) {
                    that._startTimers();
                } else {
                    that._emitSummary();
                    that._stopTimers();
                }
            });
        }

        if (!that._visibilityChangeEmitter || that._visibilityChangeEmitter.isVisible()) {
            that._startTimers();
        }
        return _this;
    }

    /**
     * Start internal timers
     * @private
     */


    _createClass(LatencyMonitor, [{
        key: '_startTimers',
        value: function _startTimers() {
            var _this2 = this;

            // Timer already started, ignore this
            if (this._checkLatencyID) {
                return;
            }
            this._checkLatency();
            if (this.dataEmitIntervalMs) {
                this._emitIntervalID = setInterval(function () {
                    return _this2._emitSummary();
                }, this.dataEmitIntervalMs);
                if ((0, _isFunction2.default)(this._emitIntervalID.unref)) {
                    this._emitIntervalID.unref(); // Doesn't block exit
                }
            }
        }

        /**
         * Stop internal timers
         * @private
         */

    }, {
        key: '_stopTimers',
        value: function _stopTimers() {
            if (this._checkLatencyID) {
                clearTimeout(this._checkLatencyID);
                this._checkLatencyID = undefined;
            }
            if (this._emitIntervalID) {
                clearInterval(this._emitIntervalID);
                this._emitIntervalID = undefined;
            }
        }

        /**
         * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show
         * @private
         */

    }, {
        key: '_emitSummary',
        value: function _emitSummary() {
            var summary = this.getSummary();
            if (summary.events > 0) {
                this.emit('data', summary);
            }
        }

        /**
         * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,
         * it will not count for this time period
         * @returns {SummaryObject}
         */

    }, {
        key: 'getSummary',
        value: function getSummary() {
            // We might want to adjust for the number of expected events
            // Example: first 1 event it comes back, then such a long blocker that the next emit check comes
            // Then this fires - looks like no latency!!
            var latency = {
                events: this._latencyData.events,
                minMs: this._latencyData.minMs,
                maxMs: this._latencyData.maxMs,
                avgMs: this._latencyData.events ? this._latencyData.totalMs / this._latencyData.events : Number.POSITIVE_INFINITY,
                lengthMs: this.getDeltaMS(this._latencyData.startTime)
            };
            this._latencyData = this._initLatencyData(); // Clear

            debug('Summary: %O', latency);
            return latency;
        }

        /**
         * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,
         * it will simply report on event loop latency.
         *
         * @private
         */

    }, {
        key: '_checkLatency',
        value: function _checkLatency() {
            var _this3 = this;

            var that = this;
            // Randomness is needed to avoid alignment by accident to regular things in the event loop
            var randomness = Math.random() * that._latecyCheckMultiply - that._latecyCheckSubtract;

            // We use this to ensure that in case some overlap somehow, we don't take the wrong startTime/offset
            var localData = {
                deltaOffset: Math.ceil(that.latencyCheckIntervalMs + randomness),
                startTime: that.now()
            };

            var cb = function cb() {
                // We are already stopped, ignore this datapoint
                if (!_this3._checkLatencyID) {
                    return;
                }
                var deltaMS = that.getDeltaMS(localData.startTime) - localData.deltaOffset;
                that._checkLatency(); // Start again ASAP

                // Add the data point. If this gets complex, refactor it
                that._latencyData.events++;
                that._latencyData.minMs = Math.min(that._latencyData.minMs, deltaMS);
                that._latencyData.maxMs = Math.max(that._latencyData.maxMs, deltaMS);
                that._latencyData.totalMs += deltaMS;
                debug('MS: %s Data: %O', deltaMS, that._latencyData);
            };
            debug('localData: %O', localData);

            this._checkLatencyID = setTimeout(function () {
                // This gets rid of including event loop
                if (that.asyncTestFn) {
                    // Clear timing related things
                    localData.deltaOffset = 0;
                    localData.startTime = that.now();
                    that.asyncTestFn(cb);
                } else {
                    // setTimeout is not more accurate than 1ms, so this will ensure positive numbers. Add 1 to emitted data to remove.
                    // This is not the best, but for now it'll be just fine. This isn't meant to be sub ms accurate.
                    localData.deltaOffset -= 1;
                    // If there is no function to test, we mean check latency which is a special case that is really cb => cb()
                    // We avoid that for the few extra function all overheads. Also, we want to keep the timers different
                    cb();
                }
            }, localData.deltaOffset);

            if ((0, _isFunction2.default)(this._checkLatencyID.unref)) {
                this._checkLatencyID.unref(); // Doesn't block exit
            }
        }
    }, {
        key: '_initLatencyData',
        value: function _initLatencyData() {
            return {
                startTime: this.now(),
                minMs: Number.POSITIVE_INFINITY,
                maxMs: Number.NEGATIVE_INFINITY,
                events: 0,
                totalMs: 0
            };
        }
    }]);

    return LatencyMonitor;
}(_events2.default);

function isBrowser() {
    return typeof window !== 'undefined';
}

exports.default = LatencyMonitor;


}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"latency-monitor",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/latency-monitor/dist/LatencyMonitor.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/stats/stat.js", {"bignumber.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/node_modules/bignumber.js/bignumber.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","moving-average":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/moving-average/index.js","retimer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/retimer/retimer.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/stats/stat.js
      return function (require, module, exports) {
'use strict'

const EventEmitter = require('events')
const Big = require('bignumber.js')
const MovingAverage = require('moving-average')
const retimer = require('retimer')

/**
 * A queue based manager for stat processing
 *
 * @param {Array<string>} initialCounters
 * @param {any} options
 */
class Stats extends EventEmitter {
  constructor (initialCounters, options) {
    super()

    this._options = options
    this._queue = []
    this._stats = {}

    this._frequencyLastTime = Date.now()
    this._frequencyAccumulators = {}
    this._movingAverages = {}

    this._update = this._update.bind(this)

    const intervals = this._options.movingAverageIntervals

    for (var i = 0; i < initialCounters.length; i++) {
      var key = initialCounters[i]
      this._stats[key] = Big(0)
      this._movingAverages[key] = {}
      for (var k = 0; k < intervals.length; k++) {
        var interval = intervals[k]
        var ma = this._movingAverages[key][interval] = MovingAverage(interval)
        ma.push(this._frequencyLastTime, 0)
      }
    }
  }

  /**
   * Initializes the internal timer if there are items in the queue. This
   * should only need to be called if `Stats.stop` was previously called, as
   * `Stats.push` will also start the processing.
   *
   * @returns {void}
   */
  start () {
    if (this._queue.length) {
      this._resetComputeTimeout()
    }
  }

  /**
   * Stops processing and computing of stats by clearing the internal
   * timer.
   *
   * @returns {void}
   */
  stop () {
    if (this._timeout) {
      this._timeout.clear()
      this._timeout = null
    }
  }

  /**
   * Returns a clone of the current stats.
   *
   * @returns {Map<string, Stat>}
   */
  get snapshot () {
    return Object.assign({}, this._stats)
  }

  /**
   * Returns a clone of the internal movingAverages
   *
   * @returns {Array<MovingAverage>}
   */
  get movingAverages () {
    return Object.assign({}, this._movingAverages)
  }

  /**
   * Pushes the given operation data to the queue, along with the
   * current Timestamp, then resets the update timer.
   *
   * @param {string} counter
   * @param {number} inc
   * @returns {void}
   */
  push (counter, inc) {
    this._queue.push([counter, inc, Date.now()])
    this._resetComputeTimeout()
  }

  /**
   * Resets the timeout for triggering updates.
   *
   * @private
   * @returns {void}
   */
  _resetComputeTimeout () {
    if (this._timeout) {
      this._timeout.reschedule(this._nextTimeout())
    } else {
      this._timeout = retimer(this._update, this._nextTimeout())
    }
  }

  /**
   * Calculates and returns the timeout for the next update based on
   * the urgency of the update.
   *
   * @private
   * @returns {number}
   */
  _nextTimeout () {
    // calculate the need for an update, depending on the queue length
    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize
    const timeout = Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0)
    return timeout
  }

  /**
   * If there are items in the queue, they will will be processed and
   * the frequency for all items will be updated based on the Timestamp
   * of the last item in the queue. The `update` event will also be emitted
   * with the latest stats.
   *
   * If there are no items in the queue, no action is taken.
   *
   * @private
   * @returns {void}
   */
  _update () {
    this._timeout = null
    if (this._queue.length) {
      let last
      while (this._queue.length) {
        const op = last = this._queue.shift()
        this._applyOp(op)
      }

      this._updateFrequency(last[2]) // contains timestamp of last op

      this.emit('update', this._stats)
    }
  }

  /**
   * For each key in the stats, the frequncy and moving averages
   * will be updated via Stats._updateFrequencyFor based on the time
   * difference between calls to this method.
   *
   * @private
   * @param {Timestamp} latestTime
   * @returns {void}
   */
  _updateFrequency (latestTime) {
    const timeDiff = latestTime - this._frequencyLastTime

    Object.keys(this._stats).forEach((key) => {
      this._updateFrequencyFor(key, timeDiff, latestTime)
    })

    this._frequencyLastTime = latestTime
  }

  /**
   * Updates the `movingAverages` for the given `key` and also
   * resets the `frequencyAccumulator` for the `key`.
   *
   * @private
   * @param {string} key
   * @param {number} timeDiffMS Time in milliseconds
   * @param {Timestamp} latestTime Time in ticks
   * @returns {void}
   */
  _updateFrequencyFor (key, timeDiffMS, latestTime) {
    const count = this._frequencyAccumulators[key] || 0
    this._frequencyAccumulators[key] = 0
    // if `timeDiff` is zero, `hz` becomes Infinity, so we fallback to 1ms
    const safeTimeDiff = timeDiffMS || 1
    const hz = (count / safeTimeDiff) * 1000

    let movingAverages = this._movingAverages[key]
    if (!movingAverages) {
      movingAverages = this._movingAverages[key] = {}
    }

    const intervals = this._options.movingAverageIntervals

    for (var i = 0; i < intervals.length; i++) {
      var movingAverageInterval = intervals[i]
      var movingAverage = movingAverages[movingAverageInterval]
      if (!movingAverage) {
        movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval)
      }
      movingAverage.push(latestTime, hz)
    }
  }

  /**
   * For the given operation, `op`, the stats and `frequencyAccumulator`
   * will be updated or initialized if they don't already exist.
   *
   * @private
   * @param {Array<string, number>} op
   * @throws {InvalidNumber}
   * @returns {void}
   */
  _applyOp (op) {
    const key = op[0]
    const inc = op[1]

    if (typeof inc !== 'number') {
      throw new Error('invalid increment number:', inc)
    }

    let n

    if (!this._stats.hasOwnProperty(key)) {
      n = this._stats[key] = Big(0)
    } else {
      n = this._stats[key]
    }
    this._stats[key] = n.plus(inc)

    if (!this._frequencyAccumulators[key]) {
      this._frequencyAccumulators[key] = 0
    }
    this._frequencyAccumulators[key] += inc
  }
}

module.exports = Stats

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/stats/stat.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/stats/old-peers.js", {"hashlru":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/hashlru/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/stats/old-peers.js
      return function (require, module, exports) {
'use strict'

const LRU = require('hashlru')

/**
 * Creates and returns a Least Recently Used Cache
 *
 * @param {Number} maxSize
 * @returns {LRUCache}
 */
module.exports = (maxSize) => {
  const patched = LRU(maxSize)
  patched.delete = patched.remove
  return patched
}

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/stats/old-peers.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/observe-connection.js", {"interface-connection":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/observe-connection.js
      return function (require, module, exports) {
'use strict'

const Connection = require('interface-connection').Connection
const pull = require('pull-stream/pull')

/**
 * Creates a pull stream to run the given Connection stream through
 * the given Observer. This provides a way to more easily monitor connections
 * and their metadata. A new Connection will be returned that contains
 * has the attached Observer.
 *
 * @param {Transport} transport
 * @param {string} protocol
 * @param {Connection} connection
 * @param {Observer} observer
 * @returns {Connection}
 */
module.exports = (transport, protocol, connection, observer) => {
  const peerInfo = new Promise((resolve, reject) => {
    connection.getPeerInfo((err, peerInfo) => {
      if (!err && peerInfo) {
        resolve(peerInfo)
        return
      }

      const setPeerInfo = connection.setPeerInfo
      connection.setPeerInfo = (pi) => {
        setPeerInfo.call(connection, pi)
        resolve(pi)
      }
    })
  })

  const stream = {
    source: pull(
      connection,
      observer.incoming(transport, protocol, peerInfo)),
    sink: pull(
      observer.outgoing(transport, protocol, peerInfo),
      connection)
  }

  return new Connection(stream, connection)
}

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/observe-connection.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/incoming.js", {"./base":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/base.js","class-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js","fsm-event":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fsm-event/index.js","multistream-select":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multistream-select/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/incoming.js
      return function (require, module, exports) {
'use strict'

const FSM = require('fsm-event')
const multistream = require('multistream-select')
const withIs = require('class-is')

const BaseConnection = require('./base')

class IncomingConnectionFSM extends BaseConnection {
  constructor ({ connection, _switch, transportKey, peerInfo }) {
    super({
      _switch,
      name: `inc:${_switch._peerInfo.id.toB58String().slice(0, 8)}`
    })
    this.conn = connection
    this.theirPeerInfo = peerInfo || null
    this.theirB58Id = this.theirPeerInfo ? this.theirPeerInfo.id.toB58String() : null
    this.ourPeerInfo = this.switch._peerInfo
    this.transportKey = transportKey
    this.protocolMuxer = this.switch.protocolMuxer(this.transportKey)
    this.msListener = new multistream.Listener()

    this._state = FSM('DIALED', {
      DISCONNECTED: {
        disconnect: 'DISCONNECTED'
      },
      DIALED: { // Base connection to peer established
        privatize: 'PRIVATIZING',
        encrypt: 'ENCRYPTING'
      },
      PRIVATIZING: { // Protecting the base connection
        done: 'PRIVATIZED',
        disconnect: 'DISCONNECTING'
      },
      PRIVATIZED: { // Base connection is protected
        encrypt: 'ENCRYPTING'
      },
      ENCRYPTING: { // Encrypting the base connection
        done: 'ENCRYPTED',
        disconnect: 'DISCONNECTING'
      },
      ENCRYPTED: { // Upgrading could not happen, the connection is encrypted and waiting
        upgrade: 'UPGRADING',
        disconnect: 'DISCONNECTING'
      },
      UPGRADING: { // Attempting to upgrade the connection with muxers
        done: 'MUXED'
      },
      MUXED: {
        disconnect: 'DISCONNECTING'
      },
      DISCONNECTING: { // Shutting down the connection
        done: 'DISCONNECTED'
      }
    })

    this._state.on('DISCONNECTED', () => this._onDisconnected())
    this._state.on('PRIVATIZING', () => this._onPrivatizing())
    this._state.on('PRIVATIZED', () => this._onPrivatized())
    this._state.on('ENCRYPTING', () => this._onEncrypting())
    this._state.on('ENCRYPTED', () => {
      this.log('successfully encrypted connection to %s', this.theirB58Id || 'unknown peer')
      this.emit('encrypted', this.conn)
    })
    this._state.on('UPGRADING', () => this._onUpgrading())
    this._state.on('MUXED', () => {
      this.log('successfully muxed connection to %s', this.theirB58Id || 'unknown peer')
      this.emit('muxed', this.conn)
    })
    this._state.on('DISCONNECTING', () => {
      this._state('done')
    })
  }

  /**
   * Attempts to encrypt `this.conn` with the Switch's crypto.
   *
   * @private
   * @fires IncomingConnectionFSM#error
   * @returns {void}
   */
  _onEncrypting () {
    this.log('encrypting connection via %s', this.switch.crypto.tag)

    this.msListener.addHandler(this.switch.crypto.tag, (protocol, _conn) => {
      this.conn = this.switch.crypto.encrypt(this.ourPeerInfo.id, _conn, undefined, (err) => {
        if (err) {
          return this.close(err)
        }
        this.conn.getPeerInfo((_, peerInfo) => {
          this.theirPeerInfo = peerInfo
          this._state('done')
        })
      })
    }, null)

    // Start handling the connection
    this.msListener.handle(this.conn, (err) => {
      if (err) {
        this.emit('crypto handshaking failed', err)
      }
    })
  }

  _onUpgrading () {
    this.log('adding the protocol muxer to the connection')
    this.protocolMuxer(this.conn, this.msListener)
    this._state('done')
  }
}

module.exports = withIs(IncomingConnectionFSM, {
  className: 'IncomingConnectionFSM',
  symbolName: 'libp2p-switch/IncomingConnectionFSM'
})

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/incoming.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/constants.js
      return function (require, module, exports) {
'use strict'

module.exports = {
  BLACK_LIST_TTL: 5 * 60 * 1e3, // How long before an errored peer can be dialed again
  BLACK_LIST_ATTEMPTS: 5, // Num of unsuccessful dials before a peer is permanently blacklisted
  DIAL_TIMEOUT: 30e3, // How long in ms a dial attempt is allowed to take
  MAX_COLD_CALLS: 50, // How many dials w/o protocols that can be queued
  MAX_PARALLEL_DIALS: 100, // Maximum allowed concurrent dials
  QUARTER_HOUR: 15 * 60e3,
  PRIORITY_HIGH: 10,
  PRIORITY_LOW: 20
}

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/dialer/queueManager.js", {"../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/constants.js","../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/errors.js","./queue":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/dialer/queue.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","once":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/once/once.js","retimer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/retimer/retimer.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/dialer/queueManager.js
      return function (require, module, exports) {
'use strict'

const once = require('once')
const Queue = require('./queue')
const { DIAL_ABORTED } = require('../errors')
const nextTick = require('async/nextTick')
const retimer = require('retimer')
const { QUARTER_HOUR, PRIORITY_HIGH } = require('../constants')
const debug = require('debug')
const log = debug('libp2p:switch:dial:manager')
const noop = () => {}

class DialQueueManager {
  /**
   * @constructor
   * @param {Switch} _switch
   */
  constructor (_switch) {
    this._queue = new Set()
    this._coldCallQueue = new Set()
    this._dialingQueues = new Set()
    this._queues = {}
    this.switch = _switch
    this._cleanInterval = retimer(this._clean.bind(this), QUARTER_HOUR)
    this.start()
  }

  /**
   * Runs through all queues, aborts and removes them if they
   * are no longer valid. A queue that is blacklisted indefinitely,
   * is considered no longer valid.
   * @private
   */
  _clean () {
    const queues = Object.values(this._queues)
    queues.forEach(dialQueue => {
      // Clear if the queue has reached max blacklist
      if (dialQueue.blackListed === Infinity) {
        dialQueue.abort()
        delete this._queues[dialQueue.id]
        return
      }

      // Keep track of blacklisted queues
      if (dialQueue.blackListed) return

      // Clear if peer is no longer active
      // To avoid reallocating memory, dont delete queues of
      // connected peers, as these are highly likely to leverage the
      // queues in the immediate term
      if (!dialQueue.isRunning && dialQueue.length < 1) {
        let isConnected = false
        try {
          const peerInfo = this.switch._peerBook.get(dialQueue.id)
          isConnected = Boolean(peerInfo.isConnected())
        } catch (_) {
          // If we get an error, that means the peerbook doesnt have the peer
        }

        if (!isConnected) {
          dialQueue.abort()
          delete this._queues[dialQueue.id]
        }
      }
    })

    this._cleanInterval.reschedule(QUARTER_HOUR)
  }

  /**
   * Allows the `DialQueueManager` to execute dials
   */
  start () {
    this.isRunning = true
  }

  /**
   * Iterates over all items in the DialerQueue
   * and executes there callback with an error.
   *
   * This causes the entire DialerQueue to be drained
   */
  stop () {
    this.isRunning = false
    // Clear the general queue
    this._queue.clear()
    // Clear the cold call queue
    this._coldCallQueue.clear()

    this._cleanInterval.clear()

    // Abort the individual peer queues
    const queues = Object.values(this._queues)
    queues.forEach(dialQueue => {
      dialQueue.abort()
      delete this._queues[dialQueue.id]
    })
  }

  /**
   * Adds the `dialRequest` to the queue and ensures queue is running
   *
   * @param {DialRequest} dialRequest
   * @returns {void}
   */
  add ({ peerInfo, protocol, options, callback }) {
    callback = callback ? once(callback) : noop

    // Add the dial to its respective queue
    const targetQueue = this.getQueue(peerInfo)

    // Cold Call
    if (options.priority > PRIORITY_HIGH) {
      // If we have too many cold calls, abort the dial immediately
      if (this._coldCallQueue.size >= this.switch.dialer.MAX_COLD_CALLS) {
        return nextTick(callback, DIAL_ABORTED())
      }

      if (this._queue.has(targetQueue.id)) {
        return nextTick(callback, DIAL_ABORTED())
      }
    }

    targetQueue.add(protocol, options.useFSM, callback)

    // If we're already connected to the peer, start the queue now
    // While it might cause queues to go over the max parallel amount,
    // it avoids blocking peers we're already connected to
    if (peerInfo.isConnected()) {
      targetQueue.start()
      return
    }

    // If dialing is not allowed, abort
    if (!targetQueue.isDialAllowed()) {
      return
    }

    // Add the id to its respective queue set if the queue isn't running
    if (!targetQueue.isRunning) {
      if (options.priority <= PRIORITY_HIGH) {
        this._queue.add(targetQueue.id)
        this._coldCallQueue.delete(targetQueue.id)
      // Only add it to the cold queue if it's not in the normal queue
      } else {
        this._coldCallQueue.add(targetQueue.id)
      }
    }

    this.run()
  }

  /**
   * Will execute up to `MAX_PARALLEL_DIALS` dials
   */
  run () {
    if (!this.isRunning) return

    if (this._dialingQueues.size < this.switch.dialer.MAX_PARALLEL_DIALS) {
      let nextQueue = { done: true }
      // Check the queue first and fall back to the cold call queue
      if (this._queue.size > 0) {
        nextQueue = this._queue.values().next()
        this._queue.delete(nextQueue.value)
      } else if (this._coldCallQueue.size > 0) {
        nextQueue = this._coldCallQueue.values().next()
        this._coldCallQueue.delete(nextQueue.value)
      }

      if (nextQueue.done) {
        return
      }

      let targetQueue = this._queues[nextQueue.value]

      if (!targetQueue) {
        log('missing queue %s, maybe it was aborted?', nextQueue.value)
        return
      }

      this._dialingQueues.add(targetQueue.id)
      targetQueue.start()
    }
  }

  /**
   * Will remove the `peerInfo` from the dial blacklist
   * @param {PeerInfo} peerInfo
   */
  clearBlacklist (peerInfo) {
    const queue = this.getQueue(peerInfo)
    queue.blackListed = null
    queue.blackListCount = 0
  }

  /**
   * A handler for when dialing queues stop. This will trigger
   * `run()` in order to keep the queue processing.
   * @private
   * @param {string} id peer id of the queue that stopped
   */
  _onQueueStopped (id) {
    this._dialingQueues.delete(id)
    this.run()
  }

  /**
   * Returns the `Queue` for the given `peerInfo`
   * @param {PeerInfo} peerInfo
   * @returns {Queue}
   */
  getQueue (peerInfo) {
    const id = peerInfo.id.toB58String()

    this._queues[id] = this._queues[id] || new Queue(id, this.switch, this._onQueueStopped.bind(this))
    return this._queues[id]
  }
}

module.exports = DialQueueManager

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/dialer/queueManager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/utils.js", {"libp2p-identify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-identify/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/utils.js
      return function (require, module, exports) {
'use strict'

const Identify = require('libp2p-identify')

/**
 * For a given multistream, registers to handle the given connection
 * @param {MultistreamDialer} multistream
 * @param {Connection} connection
 * @returns {Promise}
 */
module.exports.msHandle = (multistream, connection) => {
  return new Promise((resolve, reject) => {
    multistream.handle(connection, (err) => {
      if (err) return reject(err)
      resolve()
    })
  })
}

/**
 * For a given multistream, selects the given protocol
 * @param {MultistreamDialer} multistream
 * @param {string} protocol
 * @returns {Promise} Resolves the selected Connection
 */
module.exports.msSelect = (multistream, protocol) => {
  return new Promise((resolve, reject) => {
    multistream.select(protocol, (err, connection) => {
      if (err) return reject(err)
      resolve(connection)
    })
  })
}

/**
 * Runs identify for the given connection and verifies it against the
 * PeerInfo provided
 * @param {Connection} connection
 * @param {PeerInfo} cryptoPeerInfo The PeerInfo determined during crypto exchange
 * @returns {Promise} Resolves {peerInfo, observedAddrs}
 */
module.exports.identifyDialer = (connection, cryptoPeerInfo) => {
  return new Promise((resolve, reject) => {
    Identify.dialer(connection, cryptoPeerInfo, (err, peerInfo, observedAddrs) => {
      if (err) return reject(err)
      resolve({ peerInfo, observedAddrs })
    })
  })
}

/**
 * Get unique values from `arr` using `getValue` to determine
 * what is used for uniqueness
 * @param {Array} arr The array to get unique values for
 * @param {function(value)} getValue The function to determine what is compared
 * @returns {Array}
 */
module.exports.uniqueBy = (arr, getValue) => {
  return [...new Map(arr.map((i) => [getValue(i), i])).values()]
}

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multistream-select/src/index.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multistream-select/src/constants.js","./dialer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multistream-select/src/dialer/index.js","./listener":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multistream-select/src/listener/index.js","./listener/match-exact":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multistream-select/src/listener/match-exact.js","./listener/match-semver":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multistream-select/src/listener/match-semver.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multistream-select/src/index.js
      return function (require, module, exports) {
'use strict'

exports.Listener = exports.listener = require('./listener')
exports.Dialer = exports.dialer = require('./dialer')
exports.matchSemver = require('./listener/match-semver')
exports.matchExact = require('./listener/match-exact')
exports.constants = require('./constants')

      };
    };
  }
}, {package:"multistream-select",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multistream-select/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/index.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/errors.js","../observe-connection":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/observe-connection.js","../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/utils.js","./base":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/base.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","async/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/parallel.js","class-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","fsm-event":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fsm-event/index.js","libp2p-circuit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-circuit/src/index.js","libp2p-identify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-identify/src/index.js","multistream-select":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multistream-select/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/index.js
      return function (require, module, exports) {
'use strict'

const FSM = require('fsm-event')
const Circuit = require('libp2p-circuit')
const multistream = require('multistream-select')
const withIs = require('class-is')
const BaseConnection = require('./base')
const parallel = require('async/parallel')
const nextTick = require('async/nextTick')
const identify = require('libp2p-identify')
const errCode = require('err-code')
const { msHandle, msSelect, identifyDialer } = require('../utils')

const observeConnection = require('../observe-connection')
const {
  CONNECTION_FAILED,
  DIAL_SELF,
  INVALID_STATE_TRANSITION,
  NO_TRANSPORTS_REGISTERED,
  maybeUnexpectedEnd
} = require('../errors')

/**
 * @typedef {Object} ConnectionOptions
 * @property {Switch} _switch Our switch instance
 * @property {PeerInfo} peerInfo The PeerInfo of the peer to dial
 * @property {Muxer} muxer Optional - A muxed connection
 * @property {Connection} conn Optional - The base connection
 * @property {string} type Optional - identify the connection as incoming or outgoing. Defaults to out.
 */

/**
 * ConnectionFSM handles the complex logic of managing a connection
 * between peers. ConnectionFSM is internally composed of a state machine
 * to help improve the usability and debuggability of connections. The
 * state machine also helps to improve the ability to handle dial backoff,
 * coalescing dials and dial locks.
 */
class ConnectionFSM extends BaseConnection {
  /**
   * @param {ConnectionOptions} connectionOptions
   * @constructor
   */
  constructor ({ _switch, peerInfo, muxer, conn, type = 'out' }) {
    super({
      _switch,
      name: `${type}:${_switch._peerInfo.id.toB58String().slice(0, 8)}`
    })

    this.theirPeerInfo = peerInfo
    this.theirB58Id = this.theirPeerInfo.id.toB58String()

    this.conn = conn // The base connection
    this.muxer = muxer // The upgraded/muxed connection

    let startState = 'DISCONNECTED'
    if (this.muxer) {
      startState = 'MUXED'
    }

    this._state = FSM(startState, {
      DISCONNECTED: { // No active connections exist for the peer
        dial: 'DIALING',
        disconnect: 'DISCONNECTED',
        done: 'DISCONNECTED'
      },
      DIALING: { // Creating an initial connection
        abort: 'ABORTED',
        // emit events for different transport dials?
        done: 'DIALED',
        error: 'ERRORED',
        disconnect: 'DISCONNECTING'
      },
      DIALED: { // Base connection to peer established
        encrypt: 'ENCRYPTING',
        privatize: 'PRIVATIZING'
      },
      PRIVATIZING: { // Protecting the base connection
        done: 'PRIVATIZED',
        abort: 'ABORTED',
        disconnect: 'DISCONNECTING'
      },
      PRIVATIZED: { // Base connection is protected
        encrypt: 'ENCRYPTING'
      },
      ENCRYPTING: { // Encrypting the base connection
        done: 'ENCRYPTED',
        error: 'ERRORED',
        disconnect: 'DISCONNECTING'
      },
      ENCRYPTED: { // Upgrading could not happen, the connection is encrypted and waiting
        upgrade: 'UPGRADING',
        disconnect: 'DISCONNECTING'
      },
      UPGRADING: { // Attempting to upgrade the connection with muxers
        stop: 'CONNECTED', // If we cannot mux, stop upgrading
        done: 'MUXED',
        error: 'ERRORED',
        disconnect: 'DISCONNECTING'
      },
      MUXED: {
        disconnect: 'DISCONNECTING'
      },
      CONNECTED: { // A non muxed connection is established
        disconnect: 'DISCONNECTING'
      },
      DISCONNECTING: { // Shutting down the connection
        done: 'DISCONNECTED',
        disconnect: 'DISCONNECTING'
      },
      ABORTED: { }, // A severe event occurred
      ERRORED: { // An error occurred, but future dials may be allowed
        disconnect: 'DISCONNECTING' // There could be multiple options here, but this is a likely action
      }
    })

    this._state.on('DISCONNECTED', () => this._onDisconnected())
    this._state.on('DIALING', () => this._onDialing())
    this._state.on('DIALED', () => this._onDialed())
    this._state.on('PRIVATIZING', () => this._onPrivatizing())
    this._state.on('PRIVATIZED', () => this._onPrivatized())
    this._state.on('ENCRYPTING', () => this._onEncrypting())
    this._state.on('ENCRYPTED', () => {
      this.log('successfully encrypted connection to %s', this.theirB58Id)
      this.emit('encrypted', this.conn)
    })
    this._state.on('UPGRADING', () => this._onUpgrading())
    this._state.on('MUXED', () => {
      this.log('successfully muxed connection to %s', this.theirB58Id)
      delete this.switch.conns[this.theirB58Id]
      this.emit('muxed', this.muxer)
    })
    this._state.on('CONNECTED', () => {
      this.log('unmuxed connection opened to %s', this.theirB58Id)
      this.emit('unmuxed', this.conn)
    })
    this._state.on('DISCONNECTING', () => this._onDisconnecting())
    this._state.on('ABORTED', () => this._onAborted())
    this._state.on('ERRORED', () => this._onErrored())
    this._state.on('error', (err) => this._onStateError(err))
  }

  /**
   * Puts the state into dialing mode
   *
   * @fires ConnectionFSM#Error May emit a DIAL_SELF error
   * @returns {void}
   */
  dial () {
    if (this.theirB58Id === this.ourPeerInfo.id.toB58String()) {
      return this.emit('error', DIAL_SELF())
    } else if (this.getState() === 'DIALING') {
      return this.log('attempted to dial while already dialing, ignoring')
    }

    this._state('dial')
  }

  /**
   * Initiates a handshake for the given protocol
   *
   * @param {string} protocol The protocol to negotiate
   * @param {function(Error, Connection)} callback
   * @returns {void}
   */
  shake (protocol, callback) {
    // If there is no protocol set yet, don't perform the handshake
    if (!protocol) {
      return callback(null, null)
    }

    if (this.muxer && this.muxer.newStream) {
      return this.muxer.newStream((err, stream) => {
        if (err) {
          return callback(err, null)
        }

        this.log('created new stream to %s', this.theirB58Id)
        this._protocolHandshake(protocol, stream, callback)
      })
    }

    this._protocolHandshake(protocol, this.conn, callback)
  }

  /**
   * Puts the state into muxing mode
   *
   * @returns {void}
   */
  upgrade () {
    this._state('upgrade')
  }

  /**
   * Event handler for dialing. Transitions state when successful.
   *
   * @private
   * @fires ConnectionFSM#error
   * @returns {void}
   */
  _onDialing () {
    this.log('dialing %s', this.theirB58Id)

    if (!this.switch.hasTransports()) {
      return this.close(NO_TRANSPORTS_REGISTERED())
    }

    const tKeys = this.switch.availableTransports(this.theirPeerInfo)

    const circuitEnabled = Boolean(this.switch.transports[Circuit.tag])

    if (circuitEnabled && !tKeys.includes(Circuit.tag)) {
      tKeys.push(Circuit.tag)
    }

    const nextTransport = (key) => {
      let transport = key
      if (!transport) {
        if (!circuitEnabled) {
          return this.close(
            CONNECTION_FAILED(`Circuit not enabled and all transports failed to dial peer ${this.theirB58Id}!`)
          )
        }

        return this.close(
          CONNECTION_FAILED(`No available transports to dial peer ${this.theirB58Id}!`)
        )
      }

      if (transport === Circuit.tag) {
        this.theirPeerInfo.multiaddrs.add(`/p2p-circuit/p2p/${this.theirB58Id}`)
      }

      this.log('dialing transport %s', transport)
      this.switch.transport.dial(transport, this.theirPeerInfo, (errors, _conn) => {
        if (errors) {
          this.emit('error:connection_attempt_failed', errors)
          this.log(errors)
          return nextTransport(tKeys.shift())
        }

        this.conn = observeConnection(transport, null, _conn, this.switch.observer)
        this._state('done')
      })
    }

    nextTransport(tKeys.shift())
  }

  /**
   * Once a connection has been successfully dialed, the connection
   * will be privatized or encrypted depending on the presence of the
   * Switch.protector.
   *
   * @returns {void}
   */
  _onDialed () {
    this.log('successfully dialed %s', this.theirB58Id)

    this.emit('connected', this.conn)
  }

  /**
   * Event handler for disconnecting. Handles any needed cleanup
   *
   * @returns {void}
   */
  _onDisconnecting () {
    this.log('disconnecting from %s', this.theirB58Id, Boolean(this.muxer))

    delete this.switch.conns[this.theirB58Id]

    let tasks = []

    // Clean up stored connections
    if (this.muxer) {
      tasks.push((cb) => {
        this.muxer.end(() => {
          delete this.muxer
          cb()
        })
      })
    }

    // If we have the base connection, abort it
    // Ignore abort errors, since we're closing
    if (this.conn) {
      try {
        this.conn.source.abort()
      } catch (_) { }
      delete this.conn
    }

    parallel(tasks, () => {
      this._state('done')
    })
  }

  /**
   * Attempts to encrypt `this.conn` with the Switch's crypto.
   *
   * @private
   * @fires ConnectionFSM#error
   * @returns {void}
   */
  _onEncrypting () {
    const msDialer = new multistream.Dialer()
    msDialer.handle(this.conn, (err) => {
      if (err) {
        return this.close(maybeUnexpectedEnd(err))
      }

      this.log('selecting crypto %s to %s', this.switch.crypto.tag, this.theirB58Id)

      msDialer.select(this.switch.crypto.tag, (err, _conn) => {
        if (err) {
          return this.close(maybeUnexpectedEnd(err))
        }

        const observedConn = observeConnection(null, this.switch.crypto.tag, _conn, this.switch.observer)
        const encryptedConn = this.switch.crypto.encrypt(this.ourPeerInfo.id, observedConn, this.theirPeerInfo.id, (err) => {
          if (err) {
            return this.close(err)
          }

          this.conn = encryptedConn
          this.conn.setPeerInfo(this.theirPeerInfo)
          this._state('done')
        })
      })
    })
  }

  /**
   * Iterates over each Muxer on the Switch and attempts to upgrade
   * the given `connection`. Successful muxed connections will be stored
   * on the Switch.muxedConns with `b58Id` as their key for future reference.
   *
   * @private
   * @returns {void}
   */
  _onUpgrading () {
    const muxers = Object.keys(this.switch.muxers)
    this.log('upgrading connection to %s', this.theirB58Id)

    if (muxers.length === 0) {
      return this._state('stop')
    }

    const msDialer = new multistream.Dialer()
    msDialer.handle(this.conn, (err) => {
      if (err) {
        return this._didUpgrade(err)
      }

      // 1. try to handshake in one of the muxers available
      // 2. if succeeds
      //  - add the muxedConn to the list of muxedConns
      //  - add incomming new streams to connHandler
      const nextMuxer = (key) => {
        this.log('selecting %s', key)
        msDialer.select(key, (err, _conn) => {
          if (err) {
            if (muxers.length === 0) {
              return this._didUpgrade(err)
            }

            return nextMuxer(muxers.shift())
          }

          // observe muxed connections
          const conn = observeConnection(null, key, _conn, this.switch.observer)

          this.muxer = this.switch.muxers[key].dialer(conn)

          this.muxer.once('close', () => {
            this.close()
          })

          // For incoming streams, in case identify is on
          this.muxer.on('stream', (conn) => {
            this.log('new stream created via muxer to %s', this.theirB58Id)
            conn.setPeerInfo(this.theirPeerInfo)
            this.switch.protocolMuxer(null)(conn)
          })

          this._didUpgrade(null)

          // Run identify on the connection
          if (this.switch.identify) {
            this._identify((err, results) => {
              if (err) {
                return this.close(err)
              }
              this.theirPeerInfo = this.switch._peerBook.put(results.peerInfo)
            })
          }
        })
      }

      nextMuxer(muxers.shift())
    })
  }

  /**
   * Runs the identify protocol on the connection
   * @private
   * @param {function(error, { PeerInfo })} callback
   * @returns {void}
   */
  _identify (callback) {
    if (!this.muxer) {
      return nextTick(callback, errCode('The connection was already closed', 'ERR_CONNECTION_CLOSED'))
    }
    this.muxer.newStream(async (err, conn) => {
      if (err) return callback(err)
      const ms = new multistream.Dialer()
      let results
      try {
        await msHandle(ms, conn)
        const msConn = await msSelect(ms, identify.multicodec)
        results = await identifyDialer(msConn, this.theirPeerInfo)
      } catch (err) {
        return callback(err)
      }
      callback(null, results)
    })
  }

  /**
   * Analyses the given error, if it exists, to determine where the state machine
   * needs to go.
   *
   * @param {Error} err
   * @returns {void}
   */
  _didUpgrade (err) {
    if (err) {
      this.log('Error upgrading connection:', err)
      this.switch.conns[this.theirB58Id] = this
      this.emit('error:upgrade_failed', err)
      // Cant upgrade, hold the encrypted connection
      return this._state('stop')
    }

    // move the state machine forward
    this._state('done')
  }

  /**
   * Performs the protocol handshake for the given protocol
   * over the given connection. The resulting error or connection
   * will be returned via the callback.
   *
   * @private
   * @param {string} protocol
   * @param {Connection} connection
   * @param {function(Error, Connection)} callback
   * @returns {void}
   */
  _protocolHandshake (protocol, connection, callback) {
    const msDialer = new multistream.Dialer()
    msDialer.handle(connection, (err) => {
      if (err) {
        return callback(err, null)
      }

      msDialer.select(protocol, (err, _conn) => {
        if (err) {
          this.log('could not perform protocol handshake:', err)
          return callback(err, null)
        }

        const conn = observeConnection(null, protocol, _conn, this.switch.observer)
        this.log('successfully performed handshake of %s to %s', protocol, this.theirB58Id)
        this.emit('connection', conn)
        callback(null, conn)
      })
    })
  }

  /**
   * Event handler for state transition errors
   *
   * @param {Error} err
   * @returns {void}
   */
  _onStateError (err) {
    this.emit('error', INVALID_STATE_TRANSITION(err))
    this.log(err)
  }
}

module.exports = withIs(ConnectionFSM, {
  className: 'ConnectionFSM',
  symbolName: 'libp2p-switch/ConnectionFSM'
})

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-identify/src/index.js", {"./dialer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-identify/src/dialer.js","./listener":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-identify/src/listener.js","./message":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-identify/src/message.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-identify/src/index.js
      return function (require, module, exports) {
'use strict'

exports = module.exports
exports.multicodec = '/ipfs/id/1.0.0'
exports.listener = require('./listener')
exports.dialer = require('./dialer')
exports.message = require('./message')

      };
    };
  }
}, {package:"libp2p-identify",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-identify/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/limit-dialer/index.js", {"./queue":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/limit-dialer/queue.js","async/tryEach":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/tryEach.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/limit-dialer/index.js
      return function (require, module, exports) {
'use strict'

const tryEach = require('async/tryEach')
const debug = require('debug')

const log = debug('libp2p:switch:dialer')

const DialQueue = require('./queue')

/**
 * Track dials per peer and limited them.
 */
class LimitDialer {
  /**
   * Create a new dialer.
   *
   * @param {number} perPeerLimit
   * @param {number} dialTimeout
   */
  constructor (perPeerLimit, dialTimeout) {
    log('create: %s peer limit, %s dial timeout', perPeerLimit, dialTimeout)
    this.perPeerLimit = perPeerLimit
    this.dialTimeout = dialTimeout
    this.queues = new Map()
  }

  /**
   * Dial a list of multiaddrs on the given transport.
   *
   * @param {PeerId} peer
   * @param {SwarmTransport} transport
   * @param {Array<Multiaddr>} addrs
   * @param {function(Error, Connection)} callback
   * @returns {void}
   */
  dialMany (peer, transport, addrs, callback) {
    log('dialMany:start')
    // we use a token to track if we want to cancel following dials
    const token = { cancel: false }

    let errors = []
    const tasks = addrs.map((m) => {
      return (cb) => this.dialSingle(peer, transport, m, token, (err, result) => {
        if (err) {
          errors.push(err)
          return cb(err)
        }
        return cb(null, result)
      })
    })

    tryEach(tasks, (_, result) => {
      if (result && result.conn) {
        log('dialMany:success')
        return callback(null, result)
      }

      log('dialMany:error')
      callback(errors)
    })
  }

  /**
   * Dial a single multiaddr on the given transport.
   *
   * @param {PeerId} peer
   * @param {SwarmTransport} transport
   * @param {Multiaddr} addr
   * @param {CancelToken} token
   * @param {function(Error, Connection)} callback
   * @returns {void}
   */
  dialSingle (peer, transport, addr, token, callback) {
    const ps = peer.toB58String()
    log('dialSingle: %s:%s', ps, addr.toString())
    let q
    if (this.queues.has(ps)) {
      q = this.queues.get(ps)
    } else {
      q = new DialQueue(this.perPeerLimit, this.dialTimeout)
      this.queues.set(ps, q)
    }

    q.push(transport, addr, token, callback)
  }
}

module.exports = LimitDialer

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/limit-dialer/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-circuit/src/circuit.js", {"./circuit/dialer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-circuit/src/circuit/dialer.js","./circuit/utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-circuit/src/circuit/utils.js","./listener":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-circuit/src/listener.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","mafmt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mafmt/src/index.js","multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-circuit/src/circuit.js
      return function (require, module, exports) {
'use strict'

const mafmt = require('mafmt')
const multiaddr = require('multiaddr')

const CircuitDialer = require('./circuit/dialer')
const utilsFactory = require('./circuit/utils')

const debug = require('debug')
const log = debug('libp2p:circuit:transportdialer')
log.err = debug('libp2p:circuit:error:transportdialer')

const createListener = require('./listener')

class Circuit {
  static get tag () {
    return 'Circuit'
  }

  /**
   * Creates an instance of Dialer.
   *
   * @param {Swarm} swarm - the swarm
   * @param {any} options - config options
   *
   * @memberOf Dialer
   */
  constructor (swarm, options) {
    this.options = options || {}

    this.swarm = swarm
    this.dialer = null
    this.utils = utilsFactory(swarm)
    this.peerInfo = this.swarm._peerInfo
    this.relays = this.filter(this.peerInfo.multiaddrs.toArray())

    // if no explicit relays, add a default relay addr
    if (this.relays.length === 0) {
      this.peerInfo
        .multiaddrs
        .add(`/p2p-circuit/ipfs/${this.peerInfo.id.toB58String()}`)
    }

    this.dialer = new CircuitDialer(swarm, options)

    this.swarm.on('peer-mux-established', (peerInfo) => {
      this.dialer.canHop(peerInfo)
    })
    this.swarm.on('peer-mux-closed', (peerInfo) => {
      this.dialer.relayPeers.delete(peerInfo.id.toB58String())
    })
  }

  /**
   * Dial the relays in the Addresses.Swarm config
   *
   * @param {Array} relays
   * @return {void}
   */
  _dialSwarmRelays () {
    // if we have relay addresses in swarm config, then dial those relays
    this.relays.forEach((relay) => {
      let relaySegments = relay
        .toString()
        .split('/p2p-circuit')
        .filter(segment => segment.length)

      relaySegments.forEach((relaySegment) => {
        const ma = this.utils.peerInfoFromMa(multiaddr(relaySegment))
        this.dialer._dialRelay(ma)
      })
    })
  }

  /**
   * Dial a peer over a relay
   *
   * @param {multiaddr} ma - the multiaddr of the peer to dial
   * @param {Object} options - dial options
   * @param {Function} cb - a callback called once dialed
   * @returns {Connection} - the connection
   *
   * @memberOf Dialer
   */
  dial (ma, options, cb) {
    return this.dialer.dial(ma, options, cb)
  }

  /**
   * Create a listener
   *
   * @param {any} options
   * @param {Function} handler
   * @return {listener}
   */
  createListener (options, handler) {
    if (typeof options === 'function') {
      handler = options
      options = this.options || {}
    }

    const listener = createListener(this.swarm, options, handler)
    listener.on('listen', this._dialSwarmRelays.bind(this))
    return listener
  }

  /**
   * Filter check for all multiaddresses
   * that this transport can dial on
   *
   * @param {any} multiaddrs
   * @returns {Array<multiaddr>}
   *
   * @memberOf Dialer
   */
  filter (multiaddrs) {
    if (!Array.isArray(multiaddrs)) {
      multiaddrs = [multiaddrs]
    }
    return multiaddrs.filter((ma) => {
      return mafmt.Circuit.matches(ma)
    })
  }
}

module.exports = Circuit

      };
    };
  }
}, {package:"libp2p-circuit",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-circuit/src/circuit.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/utils/extract-data-from-block.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/utils/extract-data-from-block.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

module.exports = function extractDataFromBlock (block, blockStart, requestedStart, requestedEnd) {
  const blockLength = block.length
  const blockEnd = blockStart + blockLength

  if (requestedStart >= blockEnd || requestedEnd < blockStart) {
    // If we are looking for a byte range that is starts after the start of the block,
    // return an empty block.  This can happen when internal nodes contain data
    return Buffer.alloc(0)
  }

  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
    // If the end byte is in the current block, truncate the block to the end byte
    block = block.slice(0, requestedEnd - blockStart)
  }

  if (requestedStart >= blockStart && requestedStart < blockEnd) {
    // If the start byte is in the current block, skip to the start byte
    block = block.slice(requestedStart - blockStart)
  }

  return block
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/utils/extract-data-from-block.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/utils/validate-offset-and-length.js", {"err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/utils/validate-offset-and-length.js
      return function (require, module, exports) {
'use strict'

const errCode = require('err-code')

const validateOffsetAndLength = (size, offset, length) => {
  if (!offset) {
    offset = 0
  }

  if (offset < 0) {
    throw errCode(new Error('Offset must be greater than or equal to 0'), 'ERR_INVALID_PARAMS')
  }

  if (offset > size) {
    throw errCode(new Error('Offset must be less than the file size'), 'ERR_INVALID_PARAMS')
  }

  if (!length && length !== 0) {
    length = size - offset
  }

  if (length < 0) {
    throw errCode(new Error('Length must be greater than or equal to 0'), 'ERR_INVALID_PARAMS')
  }

  if (offset + length > size) {
    length = size - offset
  }

  return {
    offset,
    length
  }
}

module.exports = validateOffsetAndLength

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/utils/validate-offset-and-length.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/directory.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/directory.js
      return function (require, module, exports) {
'use strict'

const directoryContent = (cid, node, unixfs, path, resolve, depth, ipld) => {
  return async function * (options = {}) {
    const offset = options.offset || 0
    const length = options.length || node.Links.length
    const links = node.Links.slice(offset, length)

    for (const link of links) {
      const result = await resolve(link.Hash, link.Name, `${path}/${link.Name}`, [], depth + 1, ipld)

      yield result.entry
    }
  }
}

module.exports = directoryContent

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/directory.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js
      return function (require, module, exports) {
'use strict'

const hamtShardedDirectoryContent = (cid, node, unixfs, path, resolve, depth, ipld) => {
  return (options = {}) => {
    return listDirectory(node, path, resolve, depth, ipld, options)
  }
}

async function * listDirectory (node, path, resolve, depth, ipld, options) {
  const links = node.Links

  for (const link of links) {
    const name = link.Name.substring(2)

    if (name) {
      const result = await resolve(link.Hash, name, `${path}/${name}`, [], depth + 1, ipld)

      yield result.entry
    } else {
      // descend into subshard
      node = await ipld.get(link.Hash)

      for await (const file of listDirectory(node, path, resolve, depth, ipld, options)) {
        yield file
      }
    }
  }
}

module.exports = hamtShardedDirectoryContent

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/file.js", {"../../../../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","../../../utils/extract-data-from-block":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/utils/extract-data-from-block.js","../../../utils/validate-offset-and-length":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/utils/validate-offset-and-length.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipfs-unixfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/file.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const extractDataFromBlock = require('../../../utils/extract-data-from-block')
const validateOffsetAndLength = require('../../../utils/validate-offset-and-length')
const UnixFS = require('ipfs-unixfs')
const errCode = require('err-code')

async function * emitBytes (ipld, node, start, end, streamPosition = 0) {
  // a `raw` node
  if (Buffer.isBuffer(node)) {
    const buf = extractDataFromBlock(node, streamPosition, start, end)

    if (buf.length) {
      yield buf
    }

    streamPosition += buf.length

    return streamPosition
  }

  let file

  try {
    file = UnixFS.unmarshal(node.Data)
  } catch (err) {
    throw errCode(err, 'ERR_NOT_UNIXFS')
  }

  // might be a unixfs `raw` node or have data on intermediate nodes
  const nodeHasData = Boolean(file.data && file.data.length)

  if (nodeHasData) {
    const buf = extractDataFromBlock(file.data, streamPosition, start, end)

    if (buf.length) {
      yield buf
    }

    streamPosition += file.data.length
  }

  let childStart = streamPosition

  // work out which child nodes contain the requested data
  for (let i = 0; i < node.Links.length; i++) {
    const childLink = node.Links[i]
    const childEnd = streamPosition + file.blockSizes[i]

    if ((start >= childStart && start < childEnd) || // child has offset byte
        (end > childStart && end <= childEnd) || // child has end byte
        (start < childStart && end > childEnd)) { // child is between offset and end bytes
      const child = await ipld.get(childLink.Hash)

      for await (const buf of emitBytes(ipld, child, start, end, streamPosition)) {
        streamPosition += buf.length

        yield buf
      }
    }

    streamPosition = childEnd
    childStart = childEnd + 1
  }
}

const fileContent = (cid, node, unixfs, path, resolve, depth, ipld) => {
  return (options = {}) => {
    const fileSize = unixfs.fileSize()

    const {
      offset,
      length
    } = validateOffsetAndLength(fileSize, options.offset, options.length)

    const start = offset
    const end = offset + length

    return emitBytes(ipld, node, start, end)
  }
}

module.exports = fileContent

}).call(this)}).call(this,{"isBuffer":require("../../../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/file.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.js", {"hamt-sharding/src/bucket":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/hamt-sharding/src/bucket.js","ipfs-unixfs-importer/src/dir-sharded":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir-sharded.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.js
      return function (require, module, exports) {
'use strict'

const Bucket = require('hamt-sharding/src/bucket')
const DirSharded = require('ipfs-unixfs-importer/src/dir-sharded')

const addLinksToHamtBucket = (links, bucket, rootBucket) => {
  return Promise.all(
    links.map(link => {
      if (link.Name.length === 2) {
        const pos = parseInt(link.Name, 16)

        return bucket._putObjectAt(pos, new Bucket({
          hashFn: DirSharded.hashFn
        }, bucket, pos))
      }

      return rootBucket.put(link.Name.substring(2), true)
    })
  )
}

const toPrefix = (position) => {
  return position
    .toString('16')
    .toUpperCase()
    .padStart(2, '0')
    .substring(0, 2)
}

const toBucketPath = (position) => {
  let bucket = position.bucket
  const path = []

  while (bucket._parent) {
    path.push(bucket)

    bucket = bucket._parent
  }

  path.push(bucket)

  return path.reverse()
}

const findShardCid = async (node, name, ipld, context) => {
  if (!context) {
    context = {
      rootBucket: new Bucket({
        hashFn: DirSharded.hashFn
      }),
      hamtDepth: 1
    }

    context.lastBucket = context.rootBucket
  }

  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket)

  const position = await context.rootBucket._findNewBucketAndPos(name)
  let prefix = toPrefix(position.pos)
  const bucketPath = toBucketPath(position)

  if (bucketPath.length > (context.hamtDepth)) {
    context.lastBucket = bucketPath[context.hamtDepth]

    prefix = toPrefix(context.lastBucket._posAtParent)
  }

  const link = node.Links.find(link => {
    const entryPrefix = link.Name.substring(0, 2)
    const entryName = link.Name.substring(2)

    if (entryPrefix !== prefix) {
      // not the entry or subshard we're looking for
      return
    }

    if (entryName && entryName !== name) {
      // not the entry we're looking for
      return
    }

    return true
  })

  if (!link) {
    return null
  }

  if (link.Name.substring(2) === name) {
    return link.Hash
  }

  context.hamtDepth++

  node = await ipld.get(link.Hash)

  return findShardCid(node, name, ipld, context)
}

module.exports = findShardCid

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/errors-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/errors-browser.js
      return function (require, module, exports) {
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/errors-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/destroy.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/destroy.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/destroy.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/stream-browser.js", {"events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/stream-browser.js
      return function (require, module, exports) {
module.exports = require('events').EventEmitter;

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/stream-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/state.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/state.js
      return function (require, module, exports) {
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/state.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/from-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/from-browser.js
      return function (require, module, exports) {
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/from-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/buffer_list.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/buffer_list.js
      return function (require, module, exports) {
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/buffer_list.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/async_iterator.js", {"./end-of-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/async_iterator.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/async_iterator.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/utils/persist.js", {"multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/utils/persist.js
      return function (require, module, exports) {
'use strict'

const mh = require('multihashes')
const mc = require('multicodec')

const persist = (node, ipld, options) => {
  if (!options.codec && node.length) {
    options.cidVersion = 1
    options.codec = 'raw'
  }

  if (isNaN(options.hashAlg)) {
    options.hashAlg = mh.names[options.hashAlg]
  }

  if (options.hashAlg !== mh.names['sha2-256']) {
    options.cidVersion = 1
  }

  if (options.format) {
    options.codec = options.format
  }

  const format = mc[options.codec.toUpperCase().replace(/-/g, '_')]

  return ipld.put(node, format, options)
}

module.exports = persist

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/utils/persist.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir-sharded.js", {"./dir":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir.js","./utils/persist":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/utils/persist.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","deep-extend":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/deep-extend/lib/deep-extend.js","hamt-sharding":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/hamt-sharding/src/index.js","ipfs-unixfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir-sharded.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const {
  DAGLink,
  DAGNode
} = require('ipld-dag-pb')
const UnixFS = require('ipfs-unixfs')
const multihashing = require('multihashing-async')
const Dir = require('./dir')
const persist = require('./utils/persist')
const Bucket = require('hamt-sharding')
const extend = require('deep-extend')

const hashFn = async function (value) {
  const hash = await multihashing(Buffer.from(value, 'utf8'), 'murmur3-128')

  // Multihashing inserts preamble of 2 bytes. Remove it.
  // Also, murmur3 outputs 128 bit but, accidently, IPFS Go's
  // implementation only uses the first 64, so we must do the same
  // for parity..
  const justHash = hash.slice(2, 10)
  const length = justHash.length
  const result = Buffer.alloc(length)
  // TODO: invert buffer because that's how Go impl does it
  for (let i = 0; i < length; i++) {
    result[length - i - 1] = justHash[i]
  }

  return result
}
hashFn.code = 0x22 // TODO: get this from multihashing-async?

const defaultOptions = {
  hashFn: hashFn
}

class DirSharded extends Dir {
  constructor (props, options) {
    options = extend({}, defaultOptions, options)

    super(props, options)

    this._bucket = Bucket(options)
  }

  async put (name, value) {
    await this._bucket.put(name, value)
  }

  get (name) {
    return this._bucket.get(name)
  }

  childCount () {
    return this._bucket.leafCount()
  }

  directChildrenCount () {
    return this._bucket.childrenCount()
  }

  onlyChild () {
    return this._bucket.onlyChild()
  }

  async * eachChildSeries () {
    for await (const { key, value } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value
      }
    }
  }

  async * flush (path, ipld) {
    for await (const entry of flush(path, this._bucket, ipld, this.options)) {
      yield entry
    }
  }
}

module.exports = DirSharded

module.exports.hashFn = hashFn

async function * flush (path, bucket, ipld, options) {
  const children = bucket._children
  const links = []

  for (let i = 0; i < children.length; i++) {
    const child = children.get(i)

    if (!child) {
      continue
    }

    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0')

    if (Bucket.isBucket(child)) {
      let shard

      for await (const subShard of await flush('', child, ipld, options)) {
        shard = subShard
      }

      links.push(await new DAGLink(labelPrefix, shard.node.size, shard.cid))
    } else if (typeof child.value.flush === 'function') {
      const dir = child.value
      let flushedDir

      for await (const entry of dir.flush(dir.path, ipld)) {
        flushedDir = entry

        yield flushedDir
      }

      const label = labelPrefix + child.key
      links.push(new DAGLink(label, flushedDir.node.size, flushedDir.cid))
    } else {
      const value = child.value

      if (!value.node) {
        if (value.cid) {
          value.node = await ipld.get(value.cid)
        } else {
          continue
        }
      }

      const label = labelPrefix + child.key
      const size = value.node.length || value.node.size || value.node.Size

      links.push(await new DAGLink(label, size, value.cid))
    }
  }

  // go-ipfs uses little endian, that's why we have to
  // reverse the bit field before storing it
  const data = Buffer.from(children.bitField().reverse())
  const dir = new UnixFS('hamt-sharded-directory', data)
  dir.fanout = bucket.tableSize()
  dir.hashType = options.hashFn.code

  const node = DAGNode.create(dir.marshal(), links)
  const cid = await persist(node, ipld, options)

  yield {
    cid,
    node,
    unixfs: dir,
    path
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir-sharded.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/trickle.js", {"async-iterator-batch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-batch/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/trickle.js
      return function (require, module, exports) {
'use strict'

const batch = require('async-iterator-batch')

module.exports = function * trickleReduceToRoot (source, reduce, options) {
  yield trickleStream(source, reduce, options)
}

async function trickleStream (source, reduce, options) {
  let root
  let iteration = 0
  let maxDepth = 1
  let subTree = root = new Root(options.layerRepeat)

  for await (const layer of batch(source, options.maxChildrenPerNode)) {
    if (subTree.isFull()) {
      if (subTree !== root) {
        root.addChild(await subTree.reduce(reduce))
      }

      if (iteration && iteration % options.layerRepeat === 0) {
        maxDepth++
      }

      subTree = new SubTree(maxDepth, options.layerRepeat, iteration)

      iteration++
    }

    subTree.append(layer)
  }

  if (subTree && subTree !== root) {
    root.addChild(await subTree.reduce(reduce))
  }

  return root.reduce(reduce)
}

class SubTree {
  constructor (maxDepth, layerRepeat, iteration) {
    this.maxDepth = maxDepth
    this.layerRepeat = layerRepeat
    this.currentDepth = 1
    this.iteration = iteration

    this.root = this.node = this.parent = {
      children: [],
      depth: this.currentDepth,
      maxDepth,
      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
    }
  }

  isFull () {
    if (!this.root.data) {
      return false
    }

    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
      // can descend
      this._addNextNodeToParent(this.node)

      return false
    }

    // try to find new node from node.parent
    const distantRelative = this._findParent(this.node, this.currentDepth)

    if (distantRelative) {
      this._addNextNodeToParent(distantRelative)

      return false
    }

    return true
  }

  _addNextNodeToParent (parent) {
    this.parent = parent

    // find site for new node
    const nextNode = {
      children: [],
      depth: parent.depth + 1,
      parent,
      maxDepth: this.maxDepth,
      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat
    }

    parent.children.push(nextNode)

    this.currentDepth = nextNode.depth
    this.node = nextNode
  }

  append (layer) {
    this.node.data = layer
  }

  reduce (reduce) {
    return this._reduce(this.root, reduce)
  }

  async _reduce (node, reduce) {
    let children = []

    if (node.children.length) {
      children = await Promise.all(
        node.children
          .filter(child => child.data)
          .map(child => this._reduce(child, reduce))
      )
    }

    return reduce(node.data.concat(children))
  }

  _findParent (node, depth) {
    const parent = node.parent

    if (!parent || parent.depth === 0) {
      return
    }

    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {
      // this layer is full, may be able to traverse to a different branch
      return this._findParent(parent, depth)
    }

    return parent
  }
}

class Root extends SubTree {
  constructor (layerRepeat) {
    super(0, layerRepeat)

    this.root.depth = 0
    this.currentDepth = 1
  }

  addChild (child) {
    this.root.children.push(child)
  }

  reduce (reduce) {
    return reduce(this.root.data.concat(this.root.children))
  }
}

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/trickle.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/balanced.js", {"async-iterator-batch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-batch/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/balanced.js
      return function (require, module, exports) {
'use strict'

const batch = require('async-iterator-batch')

async function * balanced (source, reduce, options) {
  yield await reduceToParents(source, reduce, options)
}

async function reduceToParents (source, reduce, options) {
  const roots = []

  for await (const chunked of batch(source, options.maxChildrenPerNode)) {
    roots.push(await reduce(chunked))
  }

  if (roots.length > 1) {
    return reduceToParents(roots, reduce, options)
  }

  return roots[0]
}

module.exports = balanced

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/balanced.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/flat.js", {"async-iterator-batch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-batch/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/flat.js
      return function (require, module, exports) {
'use strict'

const batch = require('async-iterator-batch')

module.exports = async function * (source, reduce) {
  const roots = []

  for await (const chunk of batch(source, Infinity)) {
    roots.push(await reduce(chunk))
  }

  yield roots[0]
}

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/flat.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/chunker/rabin.js", {"bl":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bl/bl.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","rabin-wasm":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/rabin-wasm/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/chunker/rabin.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const BufferList = require('bl')
const { create } = require('rabin-wasm')
const errcode = require('err-code')

module.exports = async function * rabinChunker (source, options) {
  const rabin = jsRabin()

  let min, max, avg

  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
    avg = options.avgChunkSize
    min = options.minChunkSize
    max = options.maxChunkSize
  } else if (!options.avgChunkSize) {
    throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE')
  } else {
    avg = options.avgChunkSize
    min = avg / 3
    max = avg + (avg / 2)
  }

  // validate min/max/avg in the same way as go
  if (min < 16) {
    throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE')
  }

  if (max < min) {
    max = min
  }

  if (avg < min) {
    avg = min
  }

  const sizepow = Math.floor(Math.log2(avg))

  for await (const chunk of rabin(source, {
    min: min,
    max: max,
    bits: sizepow,
    window: options.window,
    polynomial: options.polynomial
  })) {
    yield chunk
  }
}

const jsRabin = () => {
  return async function * (source, options) {
    const r = await create(options.bits, options.min, options.max, options.window)
    const buffers = new BufferList()
    let pending = []

    for await (const chunk of source) {
      buffers.append(chunk)
      pending.push(chunk)

      const sizes = r.fingerprint(Buffer.concat(pending))
      pending = []

      for (let i = 0; i < sizes.length; i++) {
        var size = sizes[i]
        var buf = buffers.slice(0, size)
        buffers.consume(size)

        yield buf
      }
    }

    if (buffers.length) {
      yield buffers.slice(0)
    }
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/chunker/rabin.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/chunker/fixed-size.js", {"bl":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bl/bl.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/chunker/fixed-size.js
      return function (require, module, exports) {
'use strict'

const BufferList = require('bl')

module.exports = async function * fixedSizeChunker (source, options) {
  let bl = new BufferList()
  let currentLength = 0
  let emitted = false
  const maxChunkSize = options.maxChunkSize

  for await (const buffer of source) {
    bl.append(buffer)

    currentLength += buffer.length

    while (currentLength >= maxChunkSize) {
      yield bl.slice(0, maxChunkSize)
      emitted = true

      // throw away consumed bytes
      if (maxChunkSize === bl.length) {
        bl = new BufferList()
        currentLength = 0
      } else {
        const newBl = new BufferList()
        newBl.append(bl.shallowSlice(maxChunkSize))
        bl = newBl

        // update our offset
        currentLength -= maxChunkSize
      }
    }
  }

  if (!emitted || currentLength) {
    // return any remaining bytes or an empty buffer
    yield bl.slice(0, currentLength)
  }
}

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/chunker/fixed-size.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/hamt-utils.js", {"async-iterator-last":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-last/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","hamt-sharding/src/bucket":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/hamt-sharding/src/bucket.js","ipfs-unixfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js","ipfs-unixfs-importer/src/dir-sharded":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir-sharded.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/hamt-utils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const {
  DAGNode
} = require('ipld-dag-pb')
const Bucket = require('hamt-sharding/src/bucket')
const DirSharded = require('ipfs-unixfs-importer/src/dir-sharded')
const log = require('debug')('ipfs:mfs:core:utils:hamt-utils')
const UnixFS = require('ipfs-unixfs')
const mc = require('multicodec')
const mh = require('multihashes')
const last = require('async-iterator-last')

const updateHamtDirectory = async (context, links, bucket, options) => {
  // update parent with new bit field
  const data = Buffer.from(bucket._children.bitField().reverse())
  const dir = new UnixFS('hamt-sharded-directory', data)
  dir.fanout = bucket.tableSize()
  dir.hashType = DirSharded.hashFn.code

  const format = mc[options.format.toUpperCase().replace(/-/g, '_')]
  const hashAlg = mh.names[options.hashAlg]

  const parent = DAGNode.create(dir.marshal(), links)
  const cid = await context.ipld.put(parent, format, {
    cidVersion: options.cidVersion,
    hashAlg,
    hashOnly: !options.flush
  })

  return {
    node: parent,
    cid
  }
}

const recreateHamtLevel = async (links, rootBucket, parentBucket, positionAtParent) => {
  // recreate this level of the HAMT
  const bucket = new Bucket({
    hashFn: DirSharded.hashFn,
    hash: parentBucket ? parentBucket._options.hash : undefined
  }, parentBucket, positionAtParent)

  if (parentBucket) {
    parentBucket._putObjectAt(positionAtParent, bucket)
  }

  await addLinksToHamtBucket(links, bucket, rootBucket)

  return bucket
}

const addLinksToHamtBucket = async (links, bucket, rootBucket) => {
  await Promise.all(
    links.map(link => {
      if (link.Name.length === 2) {
        const pos = parseInt(link.Name, 16)

        bucket._putObjectAt(pos, new Bucket({
          hashFn: DirSharded.hashFn
        }, bucket, pos))

        return Promise.resolve()
      }

      return (rootBucket || bucket).put(link.Name.substring(2), {
        size: link.TSize,
        cid: link.Hash
      })
    })
  )
}

const toPrefix = (position) => {
  return position
    .toString('16')
    .toUpperCase()
    .padStart(2, '0')
    .substring(0, 2)
}

const generatePath = async (context, fileName, rootNode) => {
  // start at the root bucket and descend, loading nodes as we go
  const rootBucket = await recreateHamtLevel(rootNode.Links, null, null, null)
  const position = await rootBucket._findNewBucketAndPos(fileName)

  // the path to the root bucket
  let path = [{
    bucket: position.bucket,
    prefix: toPrefix(position.pos)
  }]
  let currentBucket = position.bucket

  while (currentBucket !== rootBucket) {
    path.push({
      bucket: currentBucket,
      prefix: toPrefix(currentBucket._posAtParent)
    })

    currentBucket = currentBucket._parent
  }

  path.reverse()
  path[0].node = rootNode

  // load DAGNode for each path segment
  for (let i = 0; i < path.length; i++) {
    const segment = path[i]

    // find prefix in links
    const link = segment.node.Links
      .filter(link => link.Name.substring(0, 2) === segment.prefix)
      .pop()

    // entry was not in shard
    if (!link) {
      // reached bottom of tree, file will be added to the current bucket
      log(`Link ${segment.prefix}${fileName} will be added`)
      // return path
      continue
    }

    // found entry
    if (link.Name === `${segment.prefix}${fileName}`) {
      log(`Link ${segment.prefix}${fileName} will be replaced`)
      // file already existed, file will be added to the current bucket
      // return path
      continue
    }

    // found subshard
    log(`Found subshard ${segment.prefix}`)
    const node = await context.ipld.get(link.Hash)

    // subshard hasn't been loaded, descend to the next level of the HAMT
    if (!path[i + 1]) {
      log(`Loaded new subshard ${segment.prefix}`)

      await recreateHamtLevel(node.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16))
      const position = await rootBucket._findNewBucketAndPos(fileName)

      // i--
      path.push({
        bucket: position.bucket,
        prefix: toPrefix(position.pos),
        node: node
      })

      continue
    }

    const nextSegment = path[i + 1]

    // add intermediate links to bucket
    await addLinksToHamtBucket(node.Links, nextSegment.bucket, rootBucket)

    nextSegment.node = node
  }

  await rootBucket.put(fileName, true)

  path.reverse()

  return {
    rootBucket,
    path
  }
}

const createShard = async (context, contents, options) => {
  const shard = new DirSharded({
    root: true,
    dir: true,
    parent: null,
    parentKey: null,
    path: '',
    dirty: true,
    flat: false
  }, options)

  for (let i = 0; i < contents.length; i++) {
    await shard._bucket.put(contents[i].name, {
      size: contents[i].size,
      cid: contents[i].cid
    })
  }

  return last(shard.flush('', context.ipld, null))
}

module.exports = {
  generatePath,
  updateHamtDirectory,
  recreateHamtLevel,
  addLinksToHamtBucket,
  toPrefix,
  createShard
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/hamt-utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/promise-timeout/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/promise-timeout/index.js
      return function (require, module, exports) {
// Copyright (c) 2015-2017 David M. Lee, II
'use strict';

/**
 * Local reference to TimeoutError
 * @private
 */
var TimeoutError;

/**
 * Rejects a promise with a {@link TimeoutError} if it does not settle within
 * the specified timeout.
 *
 * @param {Promise} promise The promise.
 * @param {number} timeoutMillis Number of milliseconds to wait on settling.
 * @returns {Promise} Either resolves/rejects with `promise`, or rejects with
 *                   `TimeoutError`, whichever settles first.
 */
var timeout = module.exports.timeout = function(promise, timeoutMillis) {
  var error = new TimeoutError(),
      timeout;

  return Promise.race([
    promise,
    new Promise(function(resolve, reject) {
      timeout = setTimeout(function() {
        reject(error);
      }, timeoutMillis);
    }),
  ]).then(function(v) {
    clearTimeout(timeout);
    return v;
  }, function(err) {
    clearTimeout(timeout);
    throw err;
  });
};

/**
 * Exception indicating that the timeout expired.
 */
TimeoutError = module.exports.TimeoutError = function() {
  Error.call(this)
  this.stack = Error().stack
  this.message = 'Timeout';
};

TimeoutError.prototype = Object.create(Error.prototype);
TimeoutError.prototype.name = "TimeoutError";

      };
    };
  }
}, {package:"promise-timeout",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promise-timeout/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/observable-webworkers/lib/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/observable-webworkers/lib/index.js
      return function (require, module, exports) {
const events = {}

const observable = (worker) => {
  worker.addEventListener('message', (event) => {
    observable.dispatchEvent('message', worker, event)
  })

  if (worker.port) {
    worker.port.addEventListener('message', (event) => {
      observable.dispatchEvent('message', worker, event)
    })
  }
}

observable.addEventListener = (type, fn) => {
  if (!events[type]) {
    events[type] = []
  }

  events[type].push(fn)
}

observable.removeEventListener = (type, fn) => {
  if (!events[type]) {
    return
  }

  events[type] = events[type]
    .filter(listener => listener === fn)
}

observable.dispatchEvent = function () {
  const args = Array.prototype.slice.call(arguments)
  const type = args.shift()

  if (!events[type]) {
    return
  }

  events[type].forEach(fn => fn.apply(null, args))
}

module.exports = observable

      };
    };
  }
}, {package:"observable-webworkers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/observable-webworkers/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/mortice/lib/node.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mortice/lib/constants.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","cluster":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","shortid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/shortid/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/mortice/lib/node.js
      return function (require, module, exports) {
(function (process){(function (){
const EventEmitter = require('events').EventEmitter
const shortid = require('shortid')
const {
  WORKER_REQUEST_READ_LOCK,
  WORKER_RELEASE_READ_LOCK,
  MASTER_GRANT_READ_LOCK,
  WORKER_REQUEST_WRITE_LOCK,
  WORKER_RELEASE_WRITE_LOCK,
  MASTER_GRANT_WRITE_LOCK
} = require('./constants')
let cluster

const handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, requestEvent) => {
    if (requestEvent && requestEvent.type === requestType) {
      emitter.emit(masterEvent, requestEvent.name, () => {
        // grant lock to worker
        worker.send({
          type: grantType,
          name: requestEvent.name,
          identifier: requestEvent.identifier
        })

        // wait for worker to finish
        return new Promise((resolve) => {
          const releaseEventListener = (releaseEvent) => {
            if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
              worker.removeListener('message', releaseEventListener)
              resolve()
            }
          }

          worker.on('message', releaseEventListener)
        })
      })
    }
  }
}

const makeWorkerLockRequest = (name, requestType, grantType, releaseType) => {
  return (fn) => {
    const id = shortid.generate()

    process.send({
      type: requestType,
      identifier: id,
      name
    })

    return new Promise((resolve, reject) => {
      const listener = (event) => {
        if (event && event.type === grantType && event.identifier === id) {
          process.removeListener('message', listener)

          let error = null

          fn()
            .catch((err) => {
              error = err
            })
            .then((result) => {
              process.send({
                type: releaseType,
                identifier: id,
                name
              })

              if (error) {
                return reject(error)
              }

              resolve(result)
            })
        }
      }

      process.on('message', listener)
    })
  }
}

module.exports = (options) => {
  try {
    cluster = require('cluster')

    if (!Object.keys(cluster).length) {
      return
    }
  } catch (_) {
    return
  }

  if (cluster.isMaster || options.singleProcess) {
    const emitter = new EventEmitter()

    cluster.on('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK))
    cluster.on('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK))

    return emitter
  }

  return {
    isWorker: true,
    readLock: (name, options) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name, options) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  }
}

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"mortice",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mortice/lib/node.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/mortice/lib/browser.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mortice/lib/constants.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","observable-webworkers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/observable-webworkers/lib/index.js","shortid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/shortid/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/mortice/lib/browser.js
      return function (require, module, exports) {
const EventEmitter = require('events').EventEmitter
const shortid = require('shortid')
const {
  WORKER_REQUEST_READ_LOCK,
  WORKER_RELEASE_READ_LOCK,
  MASTER_GRANT_READ_LOCK,
  WORKER_REQUEST_WRITE_LOCK,
  WORKER_RELEASE_WRITE_LOCK,
  MASTER_GRANT_WRITE_LOCK
} = require('./constants')
const observer = require('observable-webworkers')

const handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (!event || !event.data || event.data.type !== requestType) {
      return
    }

    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    }

    emitter.emit(masterEvent, requestEvent.name, () => {
      // grant lock to worker
      worker.postMessage({
        type: grantType,
        name: requestEvent.name,
        identifier: requestEvent.identifier
      })

      // wait for worker to finish
      return new Promise((resolve) => {
        const releaseEventListener = (event) => {
          if (!event || !event.data) {
            return
          }

          const releaseEvent = {
            type: event.data.type,
            name: event.data.name,
            identifier: event.data.identifier
          }

          if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
            worker.removeEventListener('message', releaseEventListener)
            resolve()
          }
        }

        worker.addEventListener('message', releaseEventListener)
      })
    })
  }
}

const makeWorkerLockRequest = (global, name, requestType, grantType, releaseType) => {
  return (fn) => {
    const id = shortid.generate()

    global.postMessage({
      type: requestType,
      identifier: id,
      name
    })

    return new Promise((resolve, reject) => {
      const listener = (event) => {
        if (!event || !event.data) {
          return
        }

        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        }

        if (responseEvent && responseEvent.type === grantType && responseEvent.identifier === id) {
          global.removeEventListener('message', listener)

          let error

          fn()
            .catch((err) => {
              error = err
            })
            .then((result) => {
              global.postMessage({
                type: releaseType,
                identifier: id,
                name
              })

              if (error) {
                return reject(error)
              }

              return resolve(result)
            })
        }
      }

      global.addEventListener('message', listener)
    })
  }
}

const defaultOptions = {
  global: global,
  singleProcess: false
}

module.exports = (options) => {
  options = Object.assign({}, defaultOptions, options)
  const isMaster = !!options.global.document || options.singleProcess

  if (isMaster) {
    const emitter = new EventEmitter()

    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK))
    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK))

    return emitter
  }

  return {
    isWorker: true,
    readLock: (name, options) => makeWorkerLockRequest(options.global, name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name, options) => makeWorkerLockRequest(options.global, name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  }
}

      };
    };
  }
}, {package:"mortice",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mortice/lib/browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/nanoid/url-alphabet/index.cjs", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/nanoid/url-alphabet/index.cjs
      return function (require, module, exports) {
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
module.exports = { urlAlphabet }

      };
    };
  }
}, {package:"nanoid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/nanoid/url-alphabet/index.cjs",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseController = void 0;
/**
 * Controller class that provides configuration, state management, and subscriptions
 */
class BaseController {
    /**
     * Creates a BaseController instance. Both initial state and initial
     * configuration options are merged with defaults upon initialization.
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config = {}, state = {}) {
        /**
         * Default options used to configure this controller
         */
        this.defaultConfig = {};
        /**
         * Default state set on this controller
         */
        this.defaultState = {};
        /**
         * Determines if listeners are notified of state changes
         */
        this.disabled = false;
        /**
         * Name of this controller used during composition
         */
        this.name = 'BaseController';
        this.internalConfig = this.defaultConfig;
        this.internalState = this.defaultState;
        this.internalListeners = [];
        // Use assign since generics can't be spread: https://git.io/vpRhY
        this.initialState = state;
        this.initialConfig = config;
    }
    /**
     * Enables the controller. This sets each config option as a member
     * variable on this instance and triggers any defined setters. This
     * also sets initial state and triggers any listeners.
     *
     * @returns - This controller instance
     */
    initialize() {
        this.internalState = this.defaultState;
        this.internalConfig = this.defaultConfig;
        this.configure(this.initialConfig);
        this.update(this.initialState);
        return this;
    }
    /**
     * Retrieves current controller configuration options
     *
     * @returns - Current configuration
     */
    get config() {
        return this.internalConfig;
    }
    /**
     * Retrieves current controller state
     *
     * @returns - Current state
     */
    get state() {
        return this.internalState;
    }
    /**
     * Updates controller configuration
     *
     * @param config - New configuration options
     * @param overwrite - Overwrite config instead of merging
     * @param fullUpdate - Boolean that defines if the update is partial or not
     */
    configure(config, overwrite = false, fullUpdate = true) {
        if (fullUpdate) {
            this.internalConfig = overwrite
                ? config
                : Object.assign(this.internalConfig, config);
            for (const key in this.internalConfig) {
                if (typeof this.internalConfig[key] !== 'undefined') {
                    this[key] = this.internalConfig[key];
                }
            }
        }
        else {
            for (const key in config) {
                /* istanbul ignore else */
                if (typeof this.internalConfig[key] !== 'undefined') {
                    this.internalConfig[key] = config[key];
                    this[key] = config[key];
                }
            }
        }
    }
    /**
     * Notifies all subscribed listeners of current state
     */
    notify() {
        if (this.disabled) {
            return;
        }
        this.internalListeners.forEach((listener) => {
            listener(this.internalState);
        });
    }
    /**
     * Adds new listener to be notified of state changes
     *
     * @param listener - Callback triggered when state changes
     */
    subscribe(listener) {
        this.internalListeners.push(listener);
    }
    /**
     * Removes existing listener from receiving state changes
     *
     * @param listener - Callback to remove
     * @returns - True if a listener is found and unsubscribed
     */
    unsubscribe(listener) {
        const index = this.internalListeners.findIndex((cb) => listener === cb);
        index > -1 && this.internalListeners.splice(index, 1);
        return index > -1;
    }
    /**
     * Updates controller state
     *
     * @param state - New state
     * @param overwrite - Overwrite state instead of merging
     */
    update(state, overwrite = false) {
        this.internalState = overwrite
            ? Object.assign({}, state)
            : Object.assign({}, this.internalState, state);
        this.notify();
    }
}
exports.BaseController = BaseController;
exports.default = BaseController;
//# sourceMappingURL=BaseController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/ControllerMessenger.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/ControllerMessenger.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ControllerMessenger = exports.RestrictedControllerMessenger = void 0;
/**
 * A restricted controller messenger.
 *
 * This acts as a wrapper around the controller messenger instance that restricts access to actions
 * and events.
 *
 * @template N - The namespace for this messenger. Typically this is the name of the controller or
 *   module that this messenger has been created for. The authority to publish events and register
 *   actions under this namespace is granted to this restricted messenger instance.
 * @template Action - A type union of all Action types.
 * @template Event - A type union of all Event types.
 * @template AllowedAction - A type union of the 'type' string for any allowed actions.
 * @template AllowedEvent - A type union of the 'type' string for any allowed events.
 */
class RestrictedControllerMessenger {
    /**
     * Constructs a restricted controller messenger
     *
     * The provided allowlists grant the ability to call the listed actions and subscribe to the
     * listed events. The "name" provided grants ownership of any actions and events under that
     * namespace. Ownership allows registering actions and publishing events, as well as
     * unregistering actions and clearing event subscriptions.
     *
     * @param options
     * @param options.controllerMessenger - The controller messenger instance that is being wrapped.
     * @param options.name - The name of the thing this messenger will be handed to (e.g. the
     *   controller name). This grants "ownership" of actions and events under this namespace to the
     *   restricted controller messenger returned.
     * @param options.allowedActions - The list of actions that this restricted controller messenger
     *   should be alowed to call.
     * @param options.allowedEvents - The list of events that this restricted controller messenger
     *   should be allowed to subscribe to.
     */
    constructor({ controllerMessenger, name, allowedActions, allowedEvents, }) {
        this.controllerMessenger = controllerMessenger;
        this.controllerName = name;
        this.allowedActions = allowedActions || null;
        this.allowedEvents = allowedEvents || null;
    }
    /**
     * Register an action handler.
     *
     * This will make the registered function available to call via the `call` method.
     *
     * The action type this handler is registered under *must* be in the current namespace.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @param handler- The action handler. This function gets called when the `call` method is
     *   invoked with the given action type.
     * @throws Will throw when a handler has been registered for this action type already.
     * @template T - A type union of Action type strings that are namespaced by N.
     */
    registerActionHandler(action, handler) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!action.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed registering action handlers prefixed by '${this.controllerName}:'`);
        }
        return this.controllerMessenger.registerActionHandler(action, handler);
    }
    /**
     * Unregister an action handler.
     *
     * This will prevent this action from being called.
     *
     * The action type being unregistered *must* be in the current namespace.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @template T - A type union of Action type strings that are namespaced by N.
     */
    unregisterActionHandler(action) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!action.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed unregistering action handlers prefixed by '${this.controllerName}:'`);
        }
        return this.controllerMessenger.unregisterActionHandler(action);
    }
    /**
     * Call an action.
     *
     * This function will call the action handler corresponding to the given action type, passing
     * along any parameters given.
     *
     * The action type being called must be on the action allowlist.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @param params - The action parameters. These must match the type of the parameters of the
     *   registered action handler.
     * @throws Will throw when no handler has been registered for the given type.
     * @template T - A type union of allowed Action type strings.
     */
    call(action, ...params) {
        /* istanbul ignore next */ // Branches unreachable with valid types
        if (this.allowedActions === null) {
            throw new Error('No actions allowed');
        }
        else if (!this.allowedActions.includes(action)) {
            throw new Error(`Action missing from allow list: ${action}`);
        }
        return this.controllerMessenger.call(action, ...params);
    }
    /**
     * Publish an event.
     *
     * Publishes the given payload to all subscribers of the given event type.
     *
     * The event type being published *must* be in the current namespace.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @param payload - The event payload. The type of the parameters for each event handler must
     *   match the type of this payload.
     * @template E - A type union of Event type strings that are namespaced by N.
     */
    publish(event, ...payload) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!event.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed publishing events prefixed by '${this.controllerName}:'`);
        }
        return this.controllerMessenger.publish(event, ...payload);
    }
    subscribe(event, handler, selector) {
        /* istanbul ignore next */ // Branches unreachable with valid types
        if (this.allowedEvents === null) {
            throw new Error('No events allowed');
        }
        else if (!this.allowedEvents.includes(event)) {
            throw new Error(`Event missing from allow list: ${event}`);
        }
        if (selector) {
            return this.controllerMessenger.subscribe(event, handler, selector);
        }
        return this.controllerMessenger.subscribe(event, handler);
    }
    /**
     * Unsubscribe from an event.
     *
     * Unregisters the given function as an event handler for the given event.
     *
     * The event type being unsubscribed to must be on the event allowlist.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @param handler - The event handler to unregister.
     * @throws Will throw when the given event handler is not registered for this event.
     * @template T - A type union of allowed Event type strings.
     */
    unsubscribe(event, handler) {
        /* istanbul ignore next */ // Branches unreachable with valid types
        if (this.allowedEvents === null) {
            throw new Error('No events allowed');
        }
        else if (!this.allowedEvents.includes(event)) {
            throw new Error(`Event missing from allow list: ${event}`);
        }
        return this.controllerMessenger.unsubscribe(event, handler);
    }
    /**
     * Clear subscriptions for a specific event.
     *
     * This will remove all subscribed handlers for this event.
     *
     * The event type being cleared *must* be in the current namespace.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @template E - A type union of Event type strings that are namespaced by N.
     */
    clearEventSubscriptions(event) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!event.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed clearing events prefixed by '${this.controllerName}:'`);
        }
        return this.controllerMessenger.clearEventSubscriptions(event);
    }
}
exports.RestrictedControllerMessenger = RestrictedControllerMessenger;
/**
 * A messaging system for controllers.
 *
 * The controller messenger allows registering functions as 'actions' that can be called elsewhere,
 * and it allows publishing and subscribing to events. Both actions and events are identified by
 * unique strings.
 *
 * @template Action - A type union of all Action types.
 * @template Event - A type union of all Event types.
 */
class ControllerMessenger {
    constructor() {
        this.actions = new Map();
        this.events = new Map();
        /**
         * A cache of selector return values for their respective handlers.
         */
        this.eventPayloadCache = new Map();
    }
    /**
     * Register an action handler.
     *
     * This will make the registered function available to call via the `call` method.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @param handler- The action handler. This function gets called when the `call` method is
     *   invoked with the given action type.
     * @throws Will throw when a handler has been registered for this action type already.
     * @template T - A type union of Action type strings.
     */
    registerActionHandler(actionType, handler) {
        if (this.actions.has(actionType)) {
            throw new Error(`A handler for ${actionType} has already been registered`);
        }
        this.actions.set(actionType, handler);
    }
    /**
     * Unregister an action handler.
     *
     * This will prevent this action from being called.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @template T - A type union of Action type strings.
     */
    unregisterActionHandler(actionType) {
        this.actions.delete(actionType);
    }
    /**
     * Unregister all action handlers.
     *
     * This prevents all actions from being called.
     */
    clearActions() {
        this.actions.clear();
    }
    /**
     * Call an action.
     *
     * This function will call the action handler corresponding to the given action type, passing
     * along any parameters given.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @param params - The action parameters. These must match the type of the parameters of the
     *   registered action handler.
     * @throws Will throw when no handler has been registered for the given type.
     * @template T - A type union of Action type strings.
     */
    call(actionType, ...params) {
        const handler = this.actions.get(actionType);
        if (!handler) {
            throw new Error(`A handler for ${actionType} has not been registered`);
        }
        return handler(...params);
    }
    /**
     * Publish an event.
     *
     * Publishes the given payload to all subscribers of the given event type.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @param payload - The event payload. The type of the parameters for each event handler must
     *   match the type of this payload.
     * @template E - A type union of Event type strings.
     */
    publish(eventType, ...payload) {
        const subscribers = this.events.get(eventType);
        if (subscribers) {
            for (const [handler, selector] of subscribers.entries()) {
                if (selector) {
                    const previousValue = this.eventPayloadCache.get(handler);
                    const newValue = selector(...payload);
                    if (newValue !== previousValue) {
                        this.eventPayloadCache.set(handler, newValue);
                        handler(newValue, previousValue);
                    }
                }
                else {
                    handler(...payload);
                }
            }
        }
    }
    subscribe(eventType, handler, selector) {
        let subscribers = this.events.get(eventType);
        if (!subscribers) {
            subscribers = new Map();
            this.events.set(eventType, subscribers);
        }
        subscribers.set(handler, selector);
    }
    /**
     * Unsubscribe from an event.
     *
     * Unregisters the given function as an event handler for the given event.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @param handler - The event handler to unregister.
     * @throws Will throw when the given event handler is not registered for this event.
     * @template E - A type union of Event type strings.
     */
    unsubscribe(eventType, handler) {
        const subscribers = this.events.get(eventType);
        if (!subscribers || !subscribers.has(handler)) {
            throw new Error(`Subscription not found for event: ${eventType}`);
        }
        const selector = subscribers.get(handler);
        if (selector) {
            this.eventPayloadCache.delete(handler);
        }
        subscribers.delete(handler);
    }
    /**
     * Clear subscriptions for a specific event.
     *
     * This will remove all subscribed handlers for this event.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @template E - A type union of Event type strings.
     */
    clearEventSubscriptions(eventType) {
        this.events.delete(eventType);
    }
    /**
     * Clear all subscriptions.
     *
     * This will remove all subscribed handlers for all events.
     */
    clearSubscriptions() {
        this.events.clear();
    }
    /**
     * Get a restricted controller messenger
     *
     * Returns a wrapper around the controller messenger instance that restricts access to actions
     * and events. The provided allowlists grant the ability to call the listed actions and subscribe
     * to the listed events. The "name" provided grants ownership of any actions and events under
     * that namespace. Ownership allows registering actions and publishing events, as well as
     * unregistering actions and clearing event subscriptions.
     *
     * @param options
     * @param options.name - The name of the thing this messenger will be handed to (e.g. the
     *   controller name). This grants "ownership" of actions and events under this namespace to the
     *   restricted controller messenger returned.
     * @param options.allowedActions - The list of actions that this restricted controller messenger
     *   should be alowed to call.
     * @param options.allowedEvents - The list of events that this restricted controller messenger
     *   should be allowed to subscribe to.
     * @template N - The namespace for this messenger. Typically this is the name of the controller or
     *   module that this messenger has been created for. The authority to publish events and register
     *   actions under this namespace is granted to this restricted messenger instance.
     * @template AllowedAction - A type union of the 'type' string for any allowed actions.
     * @template AllowedEvent - A type union of the 'type' string for any allowed events.
     */
    getRestricted({ name, allowedActions, allowedEvents, }) {
        return new RestrictedControllerMessenger({
            controllerMessenger: this,
            name,
            allowedActions,
            allowedEvents,
        });
    }
}
exports.ControllerMessenger = ControllerMessenger;
//# sourceMappingURL=ControllerMessenger.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/ControllerMessenger.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/ComposableController.js", {"./BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/ComposableController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposableController = void 0;
const BaseController_1 = require("./BaseController");
/**
 * Controller that can be used to compose multiple controllers together
 */
class ComposableController extends BaseController_1.BaseController {
    /**
     * Creates a ComposableController instance
     *
     * @param controllers - Map of names to controller instances
     * @param messenger - The controller messaging system, used for communicating with BaseControllerV2 controllers
     */
    constructor(controllers, messenger) {
        super(undefined, controllers.reduce((state, controller) => {
            state[controller.name] = controller.state;
            return state;
        }, {}));
        this.controllers = [];
        /**
         * Name of this controller used during composition
         */
        this.name = 'ComposableController';
        this.initialize();
        this.controllers = controllers;
        this.messagingSystem = messenger;
        this.controllers.forEach((controller) => {
            const { name } = controller;
            if (controller.subscribe !== undefined) {
                controller.subscribe((state) => {
                    this.update({ [name]: state });
                });
            }
            else if (this.messagingSystem) {
                this.messagingSystem.subscribe(`${name}:stateChange`, (state) => {
                    this.update({ [name]: state });
                });
            }
            else {
                throw new Error(`Messaging system required if any BaseControllerV2 controllers are used`);
            }
        });
    }
    /**
     * Flat state representation, one that isn't keyed
     * of controller name. Instead, all child controller state is merged
     * together into a single, flat object.
     *
     * @returns - Merged state representation of all child controllers
     */
    get flatState() {
        let flatState = {};
        for (const controller of this.controllers) {
            flatState = Object.assign(Object.assign({}, flatState), controller.state);
        }
        return flatState;
    }
}
exports.ComposableController = ComposableController;
exports.default = ComposableController;
//# sourceMappingURL=ComposableController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/ComposableController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/user/AddressBookController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/user/AddressBookController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressBookController = void 0;
const util_1 = require("../util");
const BaseController_1 = require("../BaseController");
/**
 * Controller that manages a list of recipient addresses associated with nicknames
 */
class AddressBookController extends BaseController_1.BaseController {
    /**
     * Creates an AddressBookController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AddressBookController';
        this.defaultState = { addressBook: {} };
        this.initialize();
    }
    /**
     * Remove all contract entries
     */
    clear() {
        this.update({ addressBook: {} });
    }
    /**
     * Remove a contract entry by address
     *
     * @param chainId - Chain id identifies the current chain
     * @param address - Recipient address to delete
     */
    delete(chainId, address) {
        address = util_1.toChecksumHexAddress(address);
        if (!util_1.isValidHexAddress(address) ||
            !this.state.addressBook[chainId] ||
            !this.state.addressBook[chainId][address]) {
            return false;
        }
        const addressBook = Object.assign({}, this.state.addressBook);
        delete addressBook[chainId][address];
        if (Object.keys(addressBook[chainId]).length === 0) {
            delete addressBook[chainId];
        }
        this.update({ addressBook });
        return true;
    }
    /**
     * Add or update a contact entry by address
     *
     * @param address - Recipient address to add or update
     * @param name - Nickname to associate with this address
     * @param chainId - Chain id identifies the current chain
     * @param memo - User's note about address
     * @returns - Boolean indicating if the address was successfully set
     */
    set(address, name, chainId = '1', memo = '') {
        address = util_1.toChecksumHexAddress(address);
        if (!util_1.isValidHexAddress(address)) {
            return false;
        }
        const entry = {
            address,
            chainId,
            isEns: false,
            memo,
            name,
        };
        const ensName = util_1.normalizeEnsName(name);
        if (ensName) {
            entry.name = ensName;
            entry.isEns = true;
        }
        this.update({
            addressBook: Object.assign(Object.assign({}, this.state.addressBook), { [chainId]: Object.assign(Object.assign({}, this.state.addressBook[chainId]), { [address]: entry }) }),
        });
        return true;
    }
}
exports.AddressBookController = AddressBookController;
exports.default = AddressBookController;
//# sourceMappingURL=AddressBookController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/user/AddressBookController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/AssetsDetectionController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js","../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/constants.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/AssetsDetectionController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetsDetectionController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const DEFAULT_INTERVAL = 180000;
/**
 * Controller that passively polls on a set interval for assets auto detection
 */
class AssetsDetectionController extends BaseController_1.BaseController {
    /**
     * Creates a AssetsDetectionController instance
     *
     * @param options
     * @param options.onCollectiblesStateChange - Allows subscribing to assets controller state changes
     * @param options.onTokensStateChange - Allows subscribing to tokens controller state changes
     * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes
     * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set
     * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address
     * @param options.addTokens - Add a list of tokens
     * @param options.addCollectible - Add a collectible
     * @param options.getCollectiblesState - Gets the current state of the Assets controller
     * @param options.getTokenListState - Gets the current state of the TokenList controller
     * @param options.getTokensState - Gets the current state of the Tokens controller
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ onTokensStateChange, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, getBalancesInSingleCall, addTokens, addCollectible, getCollectiblesState, getTokenListState, getTokensState, }, config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AssetsDetectionController';
        this.defaultConfig = {
            interval: DEFAULT_INTERVAL,
            networkType: constants_1.MAINNET,
            selectedAddress: '',
            tokens: [],
        };
        this.initialize();
        this.getCollectiblesState = getCollectiblesState;
        this.getTokensState = getTokensState;
        this.getTokenListState = getTokenListState;
        this.addTokens = addTokens;
        onTokensStateChange(({ tokens }) => {
            this.configure({ tokens });
        });
        onPreferencesStateChange(({ selectedAddress }) => {
            const actualSelectedAddress = this.config.selectedAddress;
            if (selectedAddress !== actualSelectedAddress) {
                this.configure({ selectedAddress });
                this.detectAssets();
            }
        });
        onNetworkStateChange(({ provider }) => {
            this.configure({ networkType: provider.type });
        });
        this.getOpenSeaApiKey = getOpenSeaApiKey;
        this.getBalancesInSingleCall = getBalancesInSingleCall;
        this.addCollectible = addCollectible;
        this.poll();
    }
    getOwnerCollectiblesApi(address, offset) {
        return `https://api.opensea.io/api/v1/assets?owner=${address}&offset=${offset}&limit=50`;
    }
    getOwnerCollectibles() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { selectedAddress } = this.config;
            let response;
            let collectibles = [];
            const openSeaApiKey = this.getOpenSeaApiKey();
            try {
                let offset = 0;
                let pagingFinish = false;
                /* istanbul ignore if */
                do {
                    const api = this.getOwnerCollectiblesApi(selectedAddress, offset);
                    response = yield util_1.timeoutFetch(api, openSeaApiKey ? { headers: { 'X-API-KEY': openSeaApiKey } } : {}, 15000);
                    const collectiblesArray = yield response.json();
                    ((_a = collectiblesArray.assets) === null || _a === void 0 ? void 0 : _a.length) !== 0
                        ? (collectibles = [...collectibles, ...collectiblesArray.assets])
                        : (pagingFinish = true);
                    offset += 50;
                } while (!pagingFinish);
            }
            catch (e) {
                /* istanbul ignore next */
                return [];
            }
            return collectibles;
        });
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval used to auto detect assets
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield this.detectAssets();
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Checks whether network is mainnet or not
     *
     * @returns - Whether current network is mainnet
     */
    isMainnet() {
        if (this.config.networkType !== constants_1.MAINNET || this.disabled) {
            return false;
        }
        return true;
    }
    /**
     * Detect assets owned by current account on mainnet
     */
    detectAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.isMainnet()) {
                return;
            }
            this.detectTokens();
            this.detectCollectibles();
        });
    }
    /**
     * Triggers asset ERC20 token auto detection for each contract address in contract metadata on mainnet
     */
    detectTokens() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.isMainnet()) {
                return;
            }
            const tokensAddresses = this.config.tokens.map(
            /* istanbul ignore next*/ (token) => token.address.toLowerCase());
            const { tokenList } = this.getTokenListState();
            const tokensToDetect = [];
            for (const address in tokenList) {
                if (!tokensAddresses.includes(address)) {
                    tokensToDetect.push(address);
                }
            }
            const sliceOfTokensToDetect = [];
            sliceOfTokensToDetect[0] = tokensToDetect.slice(0, 1000);
            sliceOfTokensToDetect[1] = tokensToDetect.slice(1000, tokensToDetect.length - 1);
            const { selectedAddress } = this.config;
            /* istanbul ignore else */
            if (!selectedAddress) {
                return;
            }
            for (const tokensSlice of sliceOfTokensToDetect) {
                if (tokensSlice.length === 0) {
                    break;
                }
                yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                    const balances = yield this.getBalancesInSingleCall(selectedAddress, tokensSlice);
                    const tokensToAdd = [];
                    for (const tokenAddress in balances) {
                        let ignored;
                        /* istanbul ignore else */
                        const { ignoredTokens } = this.getTokensState();
                        if (ignoredTokens.length) {
                            ignored = ignoredTokens.find((ignoredTokenAddress) => ignoredTokenAddress === util_1.toChecksumHexAddress(tokenAddress));
                        }
                        const caseInsensitiveTokenKey = Object.keys(tokenList).find((i) => i.toLowerCase() === tokenAddress.toLowerCase()) || '';
                        if (ignored === undefined) {
                            tokensToAdd.push({
                                address: tokenAddress,
                                decimals: tokenList[caseInsensitiveTokenKey].decimals,
                                symbol: tokenList[caseInsensitiveTokenKey].symbol,
                            });
                        }
                    }
                    if (tokensToAdd.length) {
                        yield this.addTokens(tokensToAdd);
                    }
                }));
            }
        });
    }
    /**
     * Triggers asset ERC721 token auto detection on mainnet
     * adding new collectibles and removing not owned collectibles
     */
    detectCollectibles() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.isMainnet()) {
                return;
            }
            const requestedSelectedAddress = this.config.selectedAddress;
            /* istanbul ignore else */
            if (!requestedSelectedAddress) {
                return;
            }
            yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                const apiCollectibles = yield this.getOwnerCollectibles();
                const addCollectiblesPromises = apiCollectibles.map((collectible) => __awaiter(this, void 0, void 0, function* () {
                    const { token_id, num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, asset_contract: { address }, last_sale, } = collectible;
                    let ignored;
                    /* istanbul ignore else */
                    const { ignoredCollectibles } = this.getCollectiblesState();
                    if (ignoredCollectibles.length) {
                        ignored = ignoredCollectibles.find((c) => {
                            /* istanbul ignore next */
                            return (c.address === util_1.toChecksumHexAddress(address) &&
                                c.tokenId === Number(token_id));
                        });
                    }
                    /* istanbul ignore else */
                    if (!ignored &&
                        requestedSelectedAddress === this.config.selectedAddress) {
                        /* istanbul ignore next */
                        const collectibleMetadata = Object.assign({}, { name }, creator && { creator }, description && { description }, image_url && { image: image_url }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
                            animationOriginal: animation_original_url,
                        }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale });
                        yield this.addCollectible(address, Number(token_id), collectibleMetadata, true);
                    }
                }));
                yield Promise.all(addCollectiblesPromises);
            }));
        });
    }
}
exports.AssetsDetectionController = AssetsDetectionController;
exports.default = AssetsDetectionController;
//# sourceMappingURL=AssetsDetectionController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/AssetsDetectionController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/user/PreferencesController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/user/PreferencesController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreferencesController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that stores shared settings and exposes convenience methods
 */
class PreferencesController extends BaseController_1.BaseController {
    /**
     * Creates a PreferencesController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'PreferencesController';
        this.defaultState = {
            featureFlags: {},
            frequentRpcList: [],
            identities: {},
            ipfsGateway: 'https://ipfs.io/ipfs/',
            lostIdentities: {},
            selectedAddress: '',
            useStaticTokenList: false,
        };
        this.initialize();
    }
    /**
     * Adds identities to state
     *
     * @param addresses - List of addresses to use to generate new identities
     */
    addIdentities(addresses) {
        const { identities } = this.state;
        addresses.forEach((address) => {
            address = util_1.toChecksumHexAddress(address);
            if (identities[address]) {
                return;
            }
            const identityCount = Object.keys(identities).length;
            identities[address] = {
                name: `Account ${identityCount + 1}`,
                address,
                importTime: Date.now(),
            };
        });
        this.update({ identities: Object.assign({}, identities) });
    }
    /**
     * Removes an identity from state
     *
     * @param address - Address of the identity to remove
     */
    removeIdentity(address) {
        address = util_1.toChecksumHexAddress(address);
        const { identities } = this.state;
        if (!identities[address]) {
            return;
        }
        delete identities[address];
        this.update({ identities: Object.assign({}, identities) });
        if (address === this.state.selectedAddress) {
            this.update({ selectedAddress: Object.keys(identities)[0] });
        }
    }
    /**
     * Associates a new label with an identity
     *
     * @param address - Address of the identity to associate
     * @param label - New label to assign
     */
    setAccountLabel(address, label) {
        address = util_1.toChecksumHexAddress(address);
        const { identities } = this.state;
        identities[address] = identities[address] || {};
        identities[address].name = label;
        this.update({ identities: Object.assign({}, identities) });
    }
    /**
     * Enable or disable a specific feature flag
     *
     * @param feature - Feature to toggle
     * @param activated - Value to assign
     */
    setFeatureFlag(feature, activated) {
        const oldFeatureFlags = this.state.featureFlags;
        const featureFlags = Object.assign(Object.assign({}, oldFeatureFlags), { [feature]: activated });
        this.update({ featureFlags: Object.assign({}, featureFlags) });
    }
    /**
     * Synchronizes the current identity list with new identities
     *
     * @param addresses - List of addresses corresponding to identities to sync
     * @returns - Newly-selected address after syncing
     */
    syncIdentities(addresses) {
        addresses = addresses.map((address) => util_1.toChecksumHexAddress(address));
        const { identities, lostIdentities } = this.state;
        const newlyLost = {};
        for (const identity in identities) {
            if (addresses.indexOf(identity) === -1) {
                newlyLost[identity] = identities[identity];
                delete identities[identity];
            }
        }
        if (Object.keys(newlyLost).length > 0) {
            for (const key in newlyLost) {
                lostIdentities[key] = newlyLost[key];
            }
        }
        this.update({
            identities: Object.assign({}, identities),
            lostIdentities: Object.assign({}, lostIdentities),
        });
        this.addIdentities(addresses);
        if (addresses.indexOf(this.state.selectedAddress) === -1) {
            this.update({ selectedAddress: addresses[0] });
        }
        return this.state.selectedAddress;
    }
    /**
     * Generates and stores a new list of stored identities based on address. If the selected address
     * is unset, or if it refers to an identity that was removed, it will be set to the first
     * identity.
     *
     * @param addresses - List of addresses to use as a basis for each identity
     */
    updateIdentities(addresses) {
        addresses = addresses.map((address) => util_1.toChecksumHexAddress(address));
        const oldIdentities = this.state.identities;
        const identities = addresses.reduce((ids, address, index) => {
            ids[address] = oldIdentities[address] || {
                address,
                name: `Account ${index + 1}`,
                importTime: Date.now(),
            };
            return ids;
        }, {});
        let { selectedAddress } = this.state;
        if (!Object.keys(identities).includes(selectedAddress)) {
            selectedAddress = Object.keys(identities)[0];
        }
        this.update({ identities: Object.assign({}, identities), selectedAddress });
    }
    /**
     * Adds custom RPC URL to state
     *
     * @param url - Custom RPC URL
     * @param chainId? - Network ID as per EIP-155
     * @param ticker? - Currency ticker
     * @param nickname? - Personalized network name
     * @param rpcPrefs? - Personalized preferences
     *
     */
    addToFrequentRpcList(url, chainId, ticker, nickname, rpcPrefs) {
        const { frequentRpcList } = this.state;
        const index = frequentRpcList.findIndex(({ rpcUrl }) => {
            return rpcUrl === url;
        });
        if (index !== -1) {
            frequentRpcList.splice(index, 1);
        }
        const newFrequestRpc = {
            rpcUrl: url,
            chainId,
            ticker,
            nickname,
            rpcPrefs,
        };
        frequentRpcList.push(newFrequestRpc);
        this.update({ frequentRpcList: [...frequentRpcList] });
    }
    /**
     * Removes custom RPC URL from state
     *
     * @param url - Custom RPC URL
     */
    removeFromFrequentRpcList(url) {
        const { frequentRpcList } = this.state;
        const index = frequentRpcList.findIndex(({ rpcUrl }) => {
            return rpcUrl === url;
        });
        if (index !== -1) {
            frequentRpcList.splice(index, 1);
        }
        this.update({ frequentRpcList: [...frequentRpcList] });
    }
    /**
     * Sets selected address
     *
     * @param selectedAddress - Ethereum address
     */
    setSelectedAddress(selectedAddress) {
        this.update({ selectedAddress: util_1.toChecksumHexAddress(selectedAddress) });
    }
    /**
     * Sets new IPFS gateway
     *
     * @param ipfsGateway - IPFS gateway string
     */
    setIpfsGateway(ipfsGateway) {
        this.update({ ipfsGateway });
    }
    /**
     * Toggle the token detection setting to use dynamic token list
     *
     * @param useStaticTokenList - IPFS gateway string
     */
    setUseStaticTokenList(useStaticTokenList) {
        this.update({ useStaticTokenList });
    }
}
exports.PreferencesController = PreferencesController;
exports.default = PreferencesController;
//# sourceMappingURL=PreferencesController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/user/PreferencesController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/notification/NotificationController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/notification/NotificationController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotificationController = void 0;
const BaseController_1 = require("../BaseController");
const defaultState = {
    notifications: {},
};
/**
 * Controller for managing in-app announcement notifications.
 */
class NotificationController extends BaseController_1.BaseController {
    /**
     * Creates a NotificationController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state || defaultState);
        this.initialize();
        this._addNotifications();
    }
    /**
     * Compares the notifications in state with the notifications from file
     * to check if there are any new notifications/announcements
     * if yes, the new notification will be added to the state with a flag indicating
     * that the notification is not seen by the user.
     *
     *  @param allNotifications
     */
    _addNotifications() {
        const newNotifications = {};
        const { allNotifications } = this.config;
        Object.values(allNotifications).forEach((notification) => {
            newNotifications[notification.id] = this.state.notifications[notification.id]
                ? this.state.notifications[notification.id]
                : Object.assign(Object.assign({}, notification), { isShown: false });
        });
        this.update({ notifications: newNotifications });
    }
    /**
     * Updates the status of the status of the specified notifications
     * once it is read by the user.
     *
     * @param viewedIds
     */
    updateViewed(viewedIds) {
        const stateNotifications = this.state.notifications;
        for (const id of Object.keys(viewedIds).map(Number)) {
            stateNotifications[id].isShown = viewedIds[id];
        }
        this.update({ notifications: stateNotifications }, true);
    }
}
exports.NotificationController = NotificationController;
//# sourceMappingURL=NotificationController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/notification/NotificationController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokenRatesController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js","../apis/crypto-compare":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/apis/crypto-compare.js","../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/constants.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokenRatesController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenRatesController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const crypto_compare_1 = require("../apis/crypto-compare");
const CoinGeckoApi = {
    BASE_URL: 'https://api.coingecko.com/api/v3',
    getTokenPriceURL(chainSlug, query) {
        return `${this.BASE_URL}/simple/token_price/${chainSlug}?${query}`;
    },
    getPlatformsURL() {
        return `${this.BASE_URL}/asset_platforms`;
    },
    getSupportedVsCurrencies() {
        return `${this.BASE_URL}/simple/supported_vs_currencies`;
    },
};
/**
 * Finds the chain slug in the data array given a chainId
 *
 * @param chainId current chainId
 * @param data Array of supported platforms from CoinGecko API
 * @returns Slug of chainId
 */
function findChainSlug(chainId, data) {
    var _a;
    if (!data) {
        return null;
    }
    const chain = (_a = data.find(({ chain_identifier }) => chain_identifier !== null && String(chain_identifier) === chainId)) !== null && _a !== void 0 ? _a : null;
    return (chain === null || chain === void 0 ? void 0 : chain.id) || null;
}
/**
 * Controller that passively polls on a set interval for token-to-fiat exchange rates
 * for tokens stored in the TokensController
 */
class TokenRatesController extends BaseController_1.BaseController {
    /**
     * Creates a TokenRatesController instance
     *
     * @param options
     * @param options.onAssetsStateChange - Allows subscribing to assets controller state changes
     * @param options.onCurrencyRateStateChange - Allows subscribing to currency rate controller state changes
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ onTokensStateChange, onCurrencyRateStateChange, onNetworkStateChange, }, config, state) {
        super(config, state);
        this.tokenList = [];
        this.supportedChains = {
            timestamp: 0,
            data: null,
        };
        this.supportedVsCurrencies = {
            timestamp: 0,
            data: [],
        };
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokenRatesController';
        this.defaultConfig = {
            disabled: true,
            interval: 3 * 60 * 1000,
            nativeCurrency: 'eth',
            chainId: '',
            tokens: [],
            threshold: 6 * 60 * 60 * 1000,
        };
        this.defaultState = {
            contractExchangeRates: {},
        };
        this.initialize();
        this.configure({ disabled: false }, false, false);
        onTokensStateChange((tokensState) => {
            this.configure({ tokens: tokensState.tokens });
        });
        onCurrencyRateStateChange((currencyRateState) => {
            this.configure({ nativeCurrency: currencyRateState.nativeCurrency });
        });
        onNetworkStateChange(({ provider }) => {
            const { chainId } = provider;
            this.update({ contractExchangeRates: {} });
            this.configure({ chainId });
        });
        this.poll();
    }
    /**
     * Sets a new polling interval
     *
     * @param interval - Polling interval used to fetch new token rates
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.updateExchangeRates());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Sets a new chainId
     *
     * TODO: Replace this with a method
     *
     * @param chainId current chainId
     */
    set chainId(_chainId) {
        !this.disabled && util_1.safelyExecute(() => this.updateExchangeRates());
    }
    get chainId() {
        throw new Error('Property only used for setting');
    }
    /**
     * Sets a new token list to track prices
     *
     * TODO: Replace this with a method
     *
     * @param tokens - List of tokens to track exchange rates for
     */
    set tokens(tokens) {
        this.tokenList = tokens;
        !this.disabled && util_1.safelyExecute(() => this.updateExchangeRates());
    }
    get tokens() {
        throw new Error('Property only used for setting');
    }
    /**
     * Fetches a pairs of token address and native currency
     *
     * @param chainSlug - Chain string identifier
     * @param vsCurrency - the vsCurrency used to query token exchange rates against.
     * @returns - Promise resolving to exchange rates for given pairs
     */
    fetchExchangeRate(chainSlug, vsCurrency) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenPairs = this.tokenList.map((token) => token.address).join(',');
            const query = `contract_addresses=${tokenPairs}&vs_currencies=${vsCurrency.toLowerCase()}`;
            return util_1.handleFetch(CoinGeckoApi.getTokenPriceURL(chainSlug, query));
        });
    }
    /**
     * Checks if the current native currency is a supported vs currency to use
     * to query for token exchange rates
     *
     * @param nativeCurrency - the native currency of the currently active network
     * @returns - Promise resolving to a boolean indicating whether it's a supported vsCurrency
     */
    checkIsSupportedVsCurrency(nativeCurrency) {
        return __awaiter(this, void 0, void 0, function* () {
            const { threshold } = this.config;
            const { timestamp, data } = this.supportedVsCurrencies;
            const now = Date.now();
            if (now - timestamp > threshold) {
                const currencies = yield util_1.handleFetch(CoinGeckoApi.getSupportedVsCurrencies());
                this.supportedVsCurrencies = {
                    data: currencies,
                    timestamp: Date.now(),
                };
                return currencies.includes(nativeCurrency.toLowerCase());
            }
            return data.includes(nativeCurrency.toLowerCase());
        });
    }
    /**
     * Gets current chainId slug from cached supported platforms CoinGecko API response.
     * If cached supported platforms response is stale, fetches and updates it.
     *
     * @returns current chainId
     */
    getChainSlug() {
        return __awaiter(this, void 0, void 0, function* () {
            const { threshold, chainId } = this.config;
            const { data, timestamp } = this.supportedChains;
            const now = Date.now();
            if (now - timestamp > threshold) {
                const platforms = yield util_1.handleFetch(CoinGeckoApi.getPlatformsURL());
                this.supportedChains = {
                    data: platforms,
                    timestamp: Date.now(),
                };
                return findChainSlug(chainId, platforms);
            }
            return findChainSlug(chainId, data);
        });
    }
    /**
     * Updates exchange rates for all tokens
     *
     * @returns Promise resolving when this operation completes
     */
    updateExchangeRates() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tokenList.length === 0 || this.disabled) {
                return;
            }
            const slug = yield this.getChainSlug();
            let newContractExchangeRates = {};
            if (!slug) {
                this.tokenList.forEach((token) => {
                    const address = util_1.toChecksumHexAddress(token.address);
                    newContractExchangeRates[address] = undefined;
                });
            }
            else {
                const { nativeCurrency } = this.config;
                newContractExchangeRates = yield this.fetchAndMapExchangeRates(nativeCurrency, slug);
            }
            this.update({ contractExchangeRates: newContractExchangeRates });
        });
    }
    /**
     * Checks if the active network's native currency is supported by the coingecko API
     * If supported. fetches and maps contractExchange rates in format to be consumed by UI
     * If not supported fetches contractExchange rates and maps from from token/fallback-currency to token/nativeCurrency
     *
     * @param nativeCurrency - the native currency of the currently active network
     * @param slug - the unique slug used to id the chain by the coingecko api
     * should be used to query token exchange rates
     * @returns An object with conversion rates for each token
     * related to the network's native currency
     */
    fetchAndMapExchangeRates(nativeCurrency, slug) {
        return __awaiter(this, void 0, void 0, function* () {
            const contractExchangeRates = {};
            // check if native currency is supported as a vs_currency by the API
            const nativeCurrencySupported = yield this.checkIsSupportedVsCurrency(nativeCurrency);
            if (nativeCurrencySupported) {
                // If it is we can do a simple fetch against the CoinGecko API
                const prices = yield this.fetchExchangeRate(slug, nativeCurrency);
                this.tokenList.forEach((token) => {
                    const price = prices[token.address.toLowerCase()];
                    contractExchangeRates[util_1.toChecksumHexAddress(token.address)] = price
                        ? price[nativeCurrency.toLowerCase()]
                        : 0;
                });
            }
            else {
                // if native currency is not supported we need to use a fallback vsCurrency, get the exchange rates
                // in token/fallback-currency format and convert them to expected token/nativeCurrency format.
                let tokenExchangeRates;
                let vsCurrencyToNativeCurrencyConversionRate = 0;
                try {
                    [
                        tokenExchangeRates,
                        { conversionRate: vsCurrencyToNativeCurrencyConversionRate },
                    ] = yield Promise.all([
                        this.fetchExchangeRate(slug, constants_1.FALL_BACK_VS_CURRENCY),
                        crypto_compare_1.fetchExchangeRate(nativeCurrency, constants_1.FALL_BACK_VS_CURRENCY, false),
                    ]);
                }
                catch (error) {
                    if (error.message.includes('market does not exist for this coin pair')) {
                        return {};
                    }
                    throw error;
                }
                for (const [tokenAddress, conversion] of Object.entries(tokenExchangeRates)) {
                    const tokenToVsCurrencyConversionRate = conversion[constants_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
                    contractExchangeRates[util_1.toChecksumHexAddress(tokenAddress)] =
                        tokenToVsCurrencyConversionRate *
                            vsCurrencyToNativeCurrencyConversionRate;
                }
            }
            return contractExchangeRates;
        });
    }
}
exports.TokenRatesController = TokenRatesController;
exports.default = TokenRatesController;
//# sourceMappingURL=TokenRatesController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokenRatesController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseControllerV2.js", {"immer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immer/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseControllerV2.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPersistentState = exports.getAnonymizedState = exports.BaseController = void 0;
const immer_1 = require("immer");
immer_1.enablePatches();
/**
 * Controller class that provides state management, subscriptions, and state metadata
 */
class BaseController {
    /**
     * Creates a BaseController instance.
     *
     * @param options
     * @param options.messenger - Controller messaging system
     * @param options.metadata - State metadata, describing how to "anonymize" the state, and which
     *   parts should be persisted.
     * @param options.name - The name of the controller, used as a namespace for events and actions
     * @param options.state - Initial controller state
     */
    constructor({ messenger, metadata, name, state, }) {
        this.messagingSystem = messenger;
        this.name = name;
        this.internalState = state;
        this.metadata = metadata;
        this.messagingSystem.registerActionHandler(`${name}:getState`, () => this.state);
    }
    /**
     * Retrieves current controller state
     *
     * @returns - Current state
     */
    get state() {
        return this.internalState;
    }
    set state(_) {
        throw new Error(`Controller state cannot be directly mutated; use 'update' method instead.`);
    }
    /**
     * Updates controller state. Accepts a callback that is passed a draft copy
     * of the controller state. If a value is returned, it is set as the new
     * state. Otherwise, any changes made within that callback to the draft are
     * applied to the controller state.
     *
     * @param callback - Callback for updating state, passed a draft state
     *   object. Return a new state object or mutate the draft to update state.
     */
    update(callback) {
        // We run into ts2589, "infinite type depth", if we don't cast
        // produceWithPatches here.
        // The final, omitted member of the returned tuple are the inverse patches.
        const [nextState, patches] = immer_1.produceWithPatches(this.internalState, callback);
        this.internalState = nextState;
        this.messagingSystem.publish(`${this.name}:stateChange`, nextState, patches);
    }
    /**
     * Prepares the controller for garbage collection. This should be extended
     * by any subclasses to clean up any additional connections or events.
     *
     * The only cleanup performed here is to remove listeners. While technically
     * this is not required to ensure this instance is garbage collected, it at
     * least ensures this instance won't be responsible for preventing the
     * listeners from being garbage collected.
     */
    destroy() {
        this.messagingSystem.clearEventSubscriptions(`${this.name}:stateChange`);
    }
}
exports.BaseController = BaseController;
/**
 * Returns an anonymized representation of the controller state.
 *
 * By "anonymized" we mean that it should not contain any information that could be personally
 * identifiable.
 *
 * @param state - The controller state
 * @param metadata - The controller state metadata, which describes how to derive the
 *   anonymized state
 * @returns The anonymized controller state
 */
function getAnonymizedState(state, metadata) {
    return deriveStateFromMetadata(state, metadata, 'anonymous');
}
exports.getAnonymizedState = getAnonymizedState;
/**
 * Returns the subset of state that should be persisted
 *
 * @param state - The controller state
 * @param metadata - The controller state metadata, which describes which pieces of state should be persisted
 * @returns The subset of controller state that should be persisted
 */
function getPersistentState(state, metadata) {
    return deriveStateFromMetadata(state, metadata, 'persist');
}
exports.getPersistentState = getPersistentState;
function deriveStateFromMetadata(state, metadata, metadataProperty) {
    return Object.keys(state).reduce((persistedState, key) => {
        const propertyMetadata = metadata[key][metadataProperty];
        const stateProperty = state[key];
        if (typeof propertyMetadata === 'function') {
            persistedState[key] = propertyMetadata(stateProperty);
        }
        else if (propertyMetadata) {
            persistedState[key] = stateProperty;
        }
        return persistedState;
    }, {});
}
//# sourceMappingURL=BaseControllerV2.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseControllerV2.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/AssetsContractController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js","human-standard-collectible-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/human-standard-collectible-abi/index.js","human-standard-token-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/human-standard-token-abi/index.js","single-call-balance-checker-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/single-call-balance-checker-abi/index.js","web3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/web3/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/AssetsContractController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetsContractController = void 0;
const web3_1 = __importDefault(require("web3"));
const human_standard_token_abi_1 = __importDefault(require("human-standard-token-abi"));
const human_standard_collectible_abi_1 = __importDefault(require("human-standard-collectible-abi"));
const single_call_balance_checker_abi_1 = __importDefault(require("single-call-balance-checker-abi"));
const BaseController_1 = require("../BaseController");
const ERC721METADATA_INTERFACE_ID = '0x5b5e139f';
const ERC721ENUMERABLE_INTERFACE_ID = '0x780e9d63';
const SINGLE_CALL_BALANCES_ADDRESS = '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39';
/**
 * Controller that interacts with contracts on mainnet through web3
 */
class AssetsContractController extends BaseController_1.BaseController {
    /**
     * Creates a AssetsContractController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AssetsContractController';
        this.defaultConfig = {
            provider: undefined,
        };
        this.initialize();
    }
    /**
     *
     * Query if a contract implements an interface
     *
     * @param address - Asset contract address
     * @param interfaceId - Interface identifier
     * @returns - Promise resolving to whether the contract implements `interfaceID`
     */
    contractSupportsInterface(address, interfaceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(human_standard_collectible_abi_1.default).at(address);
            return new Promise((resolve, reject) => {
                contract.supportsInterface(interfaceId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Sets a new provider
     *
     * TODO: Replace this wth a method
     *
     * @property provider - Provider used to create a new underlying Web3 instance
     */
    set provider(provider) {
        this.web3 = new web3_1.default(provider);
    }
    get provider() {
        throw new Error('Property only used for setting');
    }
    /**
     * Query if contract implements ERC721Metadata interface
     *
     * @param address - ERC721 asset contract address
     * @returns - Promise resolving to whether the contract implements ERC721Metadata interface
     */
    contractSupportsMetadataInterface(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contractSupportsInterface(address, ERC721METADATA_INTERFACE_ID);
        });
    }
    /**
     * Query if contract implements ERC721Enumerable interface
     *
     * @param address - ERC721 asset contract address
     * @returns - Promise resolving to whether the contract implements ERC721Enumerable interface
     */
    contractSupportsEnumerableInterface(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contractSupportsInterface(address, ERC721ENUMERABLE_INTERFACE_ID);
        });
    }
    /**
     * Get balance or count for current account on specific asset contract
     *
     * @param address - Asset contract address
     * @param selectedAddress - Current account public address
     * @returns - Promise resolving to BN object containing balance for current account on specific asset contract
     */
    getBalanceOf(address, selectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(human_standard_token_abi_1.default).at(address);
            return new Promise((resolve, reject) => {
                contract.balanceOf(selectedAddress, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Enumerate assets assigned to an owner
     *
     * @param address - ERC721 asset contract address
     * @param selectedAddress - Current account public address
     * @param index - A collectible counter less than `balanceOf(selectedAddress)`
     * @returns - Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'
     */
    getCollectibleTokenId(address, selectedAddress, index) {
        const contract = this.web3.eth.contract(human_standard_collectible_abi_1.default).at(address);
        return new Promise((resolve, reject) => {
            contract.tokenOfOwnerByIndex(selectedAddress, index, (error, result) => {
                /* istanbul ignore if */
                if (error) {
                    reject(error);
                    return;
                }
                resolve(result.toNumber());
            });
        });
    }
    /**
     * Query for tokenURI for a given asset
     *
     * @param address - ERC721 asset contract address
     * @param tokenId - ERC721 asset identifier
     * @returns - Promise resolving to the 'tokenURI'
     */
    getCollectibleTokenURI(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const supportsMetadata = yield this.contractSupportsMetadataInterface(address);
            if (!supportsMetadata) {
                return '';
            }
            const contract = this.web3.eth.contract(human_standard_collectible_abi_1.default).at(address);
            return new Promise((resolve, reject) => {
                contract.tokenURI(tokenId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Query for name for a given ERC20 asset
     *
     * @param address - ERC20 asset contract address
     * @returns - Promise resolving to the 'decimals'
     */
    getTokenDecimals(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(human_standard_token_abi_1.default).at(address);
            return new Promise((resolve, reject) => {
                contract.decimals((error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Query for name for a given asset
     *
     * @param address - ERC721 or ERC20 asset contract address
     * @returns - Promise resolving to the 'name'
     */
    getAssetName(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(human_standard_collectible_abi_1.default).at(address);
            return new Promise((resolve, reject) => {
                contract.name((error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Query for symbol for a given asset
     *
     * @param address - ERC721 or ERC20 asset contract address
     * @returns - Promise resolving to the 'symbol'
     */
    getAssetSymbol(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(human_standard_collectible_abi_1.default).at(address);
            return new Promise((resolve, reject) => {
                contract.symbol((error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Query for owner for a given ERC721 asset
     *
     * @param address - ERC721 asset contract address
     * @param tokenId - ERC721 asset identifier
     * @returns - Promise resolving to the owner address
     */
    getOwnerOf(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(human_standard_collectible_abi_1.default).at(address);
            return new Promise((resolve, reject) => {
                contract.ownerOf(tokenId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Returns contract instance of
     *
     * @returns - Promise resolving to the 'tokenURI'
     */
    getBalancesInSingleCall(selectedAddress, tokensToDetect) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth
                .contract(single_call_balance_checker_abi_1.default)
                .at(SINGLE_CALL_BALANCES_ADDRESS);
            return new Promise((resolve, reject) => {
                contract.balances([selectedAddress], tokensToDetect, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    const nonZeroBalances = {};
                    /* istanbul ignore else */
                    if (result.length > 0) {
                        tokensToDetect.forEach((tokenAddress, index) => {
                            const balance = result[index];
                            /* istanbul ignore else */
                            if (!balance.isZero()) {
                                nonZeroBalances[tokenAddress] = balance;
                            }
                        });
                    }
                    resolve(nonZeroBalances);
                });
            });
        });
    }
}
exports.AssetsContractController = AssetsContractController;
exports.default = AssetsContractController;
//# sourceMappingURL=AssetsContractController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/AssetsContractController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/approval/ApprovalController.js", {"../BaseControllerV2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseControllerV2.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","nanoid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/nanoid/index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/approval/ApprovalController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApprovalController = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const BaseControllerV2_1 = require("../BaseControllerV2");
const controllerName = 'ApprovalController';
const stateMetadata = {
    pendingApprovals: { persist: false, anonymous: true },
    pendingApprovalCount: { persist: false, anonymous: false },
};
const getAlreadyPendingMessage = (origin, type) => `Request of type '${type}' already pending for origin ${origin}. Please wait.`;
const getDefaultState = () => {
    return {
        pendingApprovals: {},
        pendingApprovalCount: 0,
    };
};
/**
 * Controller for managing requests that require user approval.
 *
 * Enables limiting the number of pending requests by origin and type, counting
 * pending requests, and more.
 *
 * Adding a request returns a promise that resolves or rejects when the request
 * is approved or denied, respectively.
 */
class ApprovalController extends BaseControllerV2_1.BaseController {
    /**
     * @param opts - Options bag
     * @param opts.showApprovalRequest - Function for opening the UI such that
     * the request can be displayed to the user.
     */
    constructor({ messenger, showApprovalRequest, state = {}, }) {
        super({
            name: controllerName,
            metadata: stateMetadata,
            messenger,
            state: Object.assign(Object.assign({}, getDefaultState()), state),
        });
        this._approvals = new Map();
        this._origins = new Map();
        this._showApprovalRequest = showApprovalRequest;
        this.registerMessageHandlers();
    }
    /**
     * Constructor helper for registering this controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${controllerName}:clearRequests`, this.clear.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:addRequest`, (opts, shouldShowRequest) => {
            if (shouldShowRequest) {
                return this.addAndShowApprovalRequest(opts);
            }
            return this.add(opts);
        });
        this.messagingSystem.registerActionHandler(`${controllerName}:hasRequest`, this.has.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:acceptRequest`, this.accept.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:rejectRequest`, this.reject.bind(this));
    }
    /**
     * Adds an approval request per the given arguments, calls the show approval
     * request function, and returns the associated approval promise.
     *
     * There can only be one approval per origin and type. An error is thrown if
     * attempting to add an invalid or duplicate request.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request. A random id will be
     * generated if none is provided.
     * @param opts.origin - The origin of the approval request.
     * @param opts.type - The type associated with the approval request.
     * @param opts.requestData - Additional data associated with the request,
     * if any.
     * @returns The approval promise.
     */
    addAndShowApprovalRequest(opts) {
        const promise = this._add(opts.origin, opts.type, opts.id, opts.requestData);
        this._showApprovalRequest();
        return promise;
    }
    /**
     * Adds an approval request per the given arguments and returns the approval
     * promise.
     *
     * There can only be one approval per origin and type. An error is thrown if
     * attempting to add an invalid or duplicate request.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request. A random id will be
     * generated if none is provided.
     * @param opts.origin - The origin of the approval request.
     * @param opts.type - The type associated with the approval request.
     * @param opts.requestData - Additional data associated with the request,
     * if any.
     * @returns The approval promise.
     */
    add(opts) {
        return this._add(opts.origin, opts.type, opts.id, opts.requestData);
    }
    /**
     * Gets the info for the approval request with the given id.
     *
     * @param id - The id of the approval request.
     * @returns The approval request data associated with the id.
     */
    get(id) {
        return this.state.pendingApprovals[id];
    }
    /**
     * Gets the number of pending approvals, by origin and/or type.
     *
     * If only `origin` is specified, all approvals for that origin will be
     * counted, regardless of type.
     * If only `type` is specified, all approvals for that type will be counted,
     * regardless of origin.
     * If both `origin` and `type` are specified, 0 or 1 will be returned.
     *
     * @param opts.origin - An approval origin.
     * @param opts.type - The type of the approval request.
     * @returns The current approval request count for the given origin and/or
     * type.
     */
    getApprovalCount(opts = {}) {
        var _a, _b;
        if (!opts.origin && !opts.type) {
            throw new Error('Must specify origin, type, or both.');
        }
        const { origin, type: _type } = opts;
        if (origin && _type) {
            return Number(Boolean((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(_type)));
        }
        if (origin) {
            return ((_b = this._origins.get(origin)) === null || _b === void 0 ? void 0 : _b.size) || 0;
        }
        // Only "type" was specified
        let count = 0;
        for (const approval of Object.values(this.state.pendingApprovals)) {
            if (approval.type === _type) {
                count += 1;
            }
        }
        return count;
    }
    /**
     * @returns The current total approval request count, for all types and
     * origins.
     */
    getTotalApprovalCount() {
        return this.state.pendingApprovalCount;
    }
    /* eslint-enable @typescript-eslint/unified-signatures */
    /**
     * Checks if there's a pending approval request per the given parameters.
     * At least one parameter must be specified. An error will be thrown if the
     * parameters are invalid.
     *
     * If `id` is specified, all other parameters will be ignored.
     * If `id` is not specified, the method will check for requests that match
     * all of the specified parameters.
     *
     * @param opts - Options bag.
     * @param opts.id - The ID to check for.
     * @param opts.origin - The origin to check for.
     * @param opts.type - The type to check for.
     * @returns `true` if a matching approval is found, and `false` otherwise.
     */
    has(opts = {}) {
        var _a;
        const { id, origin, type: _type } = opts;
        if (id) {
            if (typeof id !== 'string') {
                throw new Error('May not specify non-string id.');
            }
            return this._approvals.has(id);
        }
        if (_type && typeof _type !== 'string') {
            throw new Error('May not specify non-string type.');
        }
        if (origin) {
            if (typeof origin !== 'string') {
                throw new Error('May not specify non-string origin.');
            }
            // Check origin and type pair if type also specified
            if (_type) {
                return Boolean((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(_type));
            }
            return this._origins.has(origin);
        }
        if (_type) {
            for (const approval of Object.values(this.state.pendingApprovals)) {
                if (approval.type === _type) {
                    return true;
                }
            }
            return false;
        }
        throw new Error('Must specify a valid combination of id, origin, and type.');
    }
    /**
     * Resolves the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param value - The value to resolve the approval promise with.
     */
    accept(id, value) {
        this._deleteApprovalAndGetCallbacks(id).resolve(value);
    }
    /**
     * Rejects the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param error - The error to reject the approval promise with.
     */
    reject(id, error) {
        this._deleteApprovalAndGetCallbacks(id).reject(error);
    }
    /**
     * Rejects and deletes all approval requests.
     */
    clear() {
        const rejectionError = eth_rpc_errors_1.ethErrors.rpc.resourceUnavailable('The request was rejected; please try again.');
        for (const id of this._approvals.keys()) {
            this.reject(id, rejectionError);
        }
        this._origins.clear();
        this.update(() => getDefaultState());
    }
    /**
     * Implementation of add operation.
     *
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param id - The id of the approval request.
     * @param requestData - The request data associated with the approval request.
     * @returns The approval promise.
     */
    _add(origin, type, id = nanoid_1.nanoid(), requestData) {
        var _a;
        this._validateAddParams(id, origin, type, requestData);
        if ((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(type)) {
            throw eth_rpc_errors_1.ethErrors.rpc.resourceUnavailable(getAlreadyPendingMessage(origin, type));
        }
        // add pending approval
        return new Promise((resolve, reject) => {
            this._approvals.set(id, { resolve, reject });
            this._addPendingApprovalOrigin(origin, type);
            this._addToStore(id, origin, type, requestData);
        });
    }
    /**
     * Validates parameters to the add method.
     *
     * @param id - The id of the approval request.
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param requestData - The request data associated with the approval request.
     */
    _validateAddParams(id, origin, type, requestData) {
        let errorMessage = null;
        if (!id || typeof id !== 'string') {
            errorMessage = 'Must specify non-empty string id.';
        }
        else if (this._approvals.has(id)) {
            errorMessage = `Approval request with id '${id}' already exists.`;
        }
        else if (!origin || typeof origin !== 'string') {
            errorMessage = 'Must specify non-empty string origin.';
        }
        else if (!type || typeof type !== 'string') {
            errorMessage = 'Must specify non-empty string type.';
        }
        else if (requestData &&
            (typeof requestData !== 'object' || Array.isArray(requestData))) {
            errorMessage = 'Request data must be a plain object if specified.';
        }
        if (errorMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.internal(errorMessage);
        }
    }
    /**
     * Adds an entry to _origins.
     * Performs no validation.
     *
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     */
    _addPendingApprovalOrigin(origin, type) {
        const originSet = this._origins.get(origin) || new Set();
        originSet.add(type);
        if (!this._origins.has(origin)) {
            this._origins.set(origin, originSet);
        }
    }
    /**
     * Adds an entry to the store.
     * Performs no validation.
     *
     * @param id - The id of the approval request.
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param requestData - The request data associated with the approval request.
     */
    _addToStore(id, origin, type, requestData) {
        const approval = {
            id,
            origin,
            type,
            time: Date.now(),
            requestData: requestData || null,
        };
        this.update((draftState) => {
            // Typecast: ts(2589)
            draftState.pendingApprovals[id] = approval;
            draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
        });
    }
    /**
     * Deletes the approval with the given id. The approval promise must be
     * resolved or reject before this method is called.
     * Deletion is an internal operation because approval state is solely
     * managed by this controller.
     *
     * @param id - The id of the approval request to be deleted.
     */
    _delete(id) {
        this._approvals.delete(id);
        // This method is only called after verifying that the approval with the
        // specified id exists.
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const { origin, type } = this.state.pendingApprovals[id];
        this._origins.get(origin).delete(type);
        if (this._isEmptyOrigin(origin)) {
            this._origins.delete(origin);
        }
        this.update((draftState) => {
            delete draftState.pendingApprovals[id];
            draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
        });
    }
    /**
     * Gets the approval callbacks for the given id, deletes the entry, and then
     * returns the callbacks for promise resolution.
     * Throws an error if no approval is found for the given id.
     *
     * @param id - The id of the approval request.
     * @returns The promise callbacks associated with the approval request.
     */
    _deleteApprovalAndGetCallbacks(id) {
        const callbacks = this._approvals.get(id);
        if (!callbacks) {
            throw new Error(`Approval request with id '${id}' not found.`);
        }
        this._delete(id);
        return callbacks;
    }
    /**
     * Checks whether there are any approvals associated with the given
     * origin.
     *
     * @param origin - The origin to check.
     * @returns True if the origin has no approvals, false otherwise.
     */
    _isEmptyOrigin(origin) {
        var _a;
        return !((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.size);
    }
}
exports.ApprovalController = ApprovalController;
exports.default = ApprovalController;
//# sourceMappingURL=ApprovalController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/approval/ApprovalController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/AccountTrackerController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js","eth-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-query/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/AccountTrackerController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountTrackerController = void 0;
const eth_query_1 = __importDefault(require("eth-query"));
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that tracks information for all accounts in the current keychain
 */
class AccountTrackerController extends BaseController_1.BaseController {
    /**
     * Creates an AccountTracker instance
     *
     * @param options
     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes
     * @param options.getIdentities - Gets the identities from the Preferences store
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ onPreferencesStateChange, getIdentities, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'AccountTrackerController';
        /**
         * Refreshes all accounts in the current keychain
         */
        this.refresh = () => __awaiter(this, void 0, void 0, function* () {
            this.syncAccounts();
            const { accounts } = this.state;
            for (const address in accounts) {
                yield util_1.safelyExecuteWithTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    const balance = yield util_1.query(this.ethQuery, 'getBalance', [address]);
                    accounts[address] = { balance: util_1.BNToHex(balance) };
                    this.update({ accounts: Object.assign({}, accounts) });
                }));
            }
        });
        this.defaultConfig = {
            interval: 10000,
        };
        this.defaultState = { accounts: {} };
        this.initialize();
        this.getIdentities = getIdentities;
        onPreferencesStateChange(() => {
            this.refresh();
        });
        this.poll();
    }
    syncAccounts() {
        const { accounts } = this.state;
        const addresses = Object.keys(this.getIdentities());
        const existing = Object.keys(accounts);
        const newAddresses = addresses.filter((address) => existing.indexOf(address) === -1);
        const oldAddresses = existing.filter((address) => addresses.indexOf(address) === -1);
        newAddresses.forEach((address) => {
            accounts[address] = { balance: '0x0' };
        });
        oldAddresses.forEach((address) => {
            delete accounts[address];
        });
        this.update({ accounts: Object.assign({}, accounts) });
    }
    /**
     * Sets a new provider
     *
     * TODO: Replace this wth a method
     *
     * @param provider - Provider used to create a new underlying EthQuery instance
     */
    set provider(provider) {
        this.ethQuery = new eth_query_1.default(provider);
    }
    get provider() {
        throw new Error('Property only used for setting');
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval trigger a 'refresh'
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield this.refresh();
            this.handle = setTimeout(() => {
                releaseLock();
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
}
exports.AccountTrackerController = AccountTrackerController;
exports.default = AccountTrackerController;
//# sourceMappingURL=AccountTrackerController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/AccountTrackerController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/CurrencyRateController.js", {"../BaseControllerV2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseControllerV2.js","../apis/crypto-compare":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/apis/crypto-compare.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/CurrencyRateController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CurrencyRateController = void 0;
const async_mutex_1 = require("async-mutex");
const BaseControllerV2_1 = require("../BaseControllerV2");
const util_1 = require("../util");
const crypto_compare_1 = require("../apis/crypto-compare");
const name = 'CurrencyRateController';
const metadata = {
    conversionDate: { persist: true, anonymous: true },
    conversionRate: { persist: true, anonymous: true },
    currentCurrency: { persist: true, anonymous: true },
    nativeCurrency: { persist: true, anonymous: true },
    pendingCurrentCurrency: { persist: false, anonymous: true },
    pendingNativeCurrency: { persist: false, anonymous: true },
    usdConversionRate: { persist: true, anonymous: true },
};
const defaultState = {
    conversionDate: 0,
    conversionRate: 0,
    currentCurrency: 'usd',
    nativeCurrency: 'ETH',
    pendingCurrentCurrency: null,
    pendingNativeCurrency: null,
    usdConversionRate: null,
};
/**
 * Controller that passively polls on a set interval for an exchange rate from the current base
 * asset to the current currency
 */
class CurrencyRateController extends BaseControllerV2_1.BaseController {
    /**
     * Creates a CurrencyRateController instance
     *
     * @param options - Constructor options
     * @param options.includeUsdRate - Keep track of the USD rate in addition to the current currency rate
     * @param options.interval - The polling interval, in milliseconds
     * @param options.messenger - A reference to the messaging system
     * @param options.state - Initial state to set on this controller
     * @param options.fetchExchangeRate - Fetches the exchange rate from an external API. This option is primarily meant for use in unit tests.
     */
    constructor({ includeUsdRate = false, interval = 180000, messenger, state, fetchExchangeRate = crypto_compare_1.fetchExchangeRate, }) {
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this.mutex = new async_mutex_1.Mutex();
        this.includeUsdRate = includeUsdRate;
        this.intervalDelay = interval;
        this.fetchExchangeRate = fetchExchangeRate;
    }
    /**
     * Start polling for the currency rate
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.startPolling();
        });
    }
    /**
     * Stop polling for the currency rate
     */
    stop() {
        this.stopPolling();
    }
    /**
     * Prepare to discard this controller.
     *
     * This stops any active polling.
     */
    destroy() {
        super.destroy();
        this.stopPolling();
    }
    /**
     * Sets a currency to track
     *
     * @param currentCurrency - ISO 4217 currency code
     */
    setCurrentCurrency(currentCurrency) {
        return __awaiter(this, void 0, void 0, function* () {
            this.update((state) => {
                state.pendingCurrentCurrency = currentCurrency;
            });
            yield this.updateExchangeRate();
        });
    }
    /**
     * Sets a new native currency
     *
     * @param symbol - Symbol for the base asset
     */
    setNativeCurrency(symbol) {
        return __awaiter(this, void 0, void 0, function* () {
            this.update((state) => {
                state.pendingNativeCurrency = symbol;
            });
            yield this.updateExchangeRate();
        });
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    /**
     * Starts a new polling interval
     */
    startPolling() {
        return __awaiter(this, void 0, void 0, function* () {
            this.stopPolling();
            // TODO: Expose polling currency rate update errors
            yield util_1.safelyExecute(() => this.updateExchangeRate());
            this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                yield util_1.safelyExecute(() => this.updateExchangeRate());
            }), this.intervalDelay);
        });
    }
    /**
     * Updates exchange rate for the current currency
     */
    updateExchangeRate() {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            const { currentCurrency: stateCurrentCurrency, nativeCurrency: stateNativeCurrency, pendingCurrentCurrency, pendingNativeCurrency, } = this.state;
            const conversionDate = Date.now() / 1000;
            let conversionRate = null;
            let usdConversionRate = null;
            const currentCurrency = pendingCurrentCurrency !== null && pendingCurrentCurrency !== void 0 ? pendingCurrentCurrency : stateCurrentCurrency;
            const nativeCurrency = pendingNativeCurrency !== null && pendingNativeCurrency !== void 0 ? pendingNativeCurrency : stateNativeCurrency;
            try {
                if (currentCurrency &&
                    nativeCurrency &&
                    // if either currency is an empty string we can skip the comparison
                    // because it will result in an error from the api and ultimately
                    // a null conversionRate either way.
                    currentCurrency !== '' &&
                    nativeCurrency !== '') {
                    ({ conversionRate, usdConversionRate } = yield this.fetchExchangeRate(currentCurrency, nativeCurrency, this.includeUsdRate));
                }
            }
            catch (error) {
                if (!error.message.includes('market does not exist for this coin pair')) {
                    throw error;
                }
            }
            finally {
                try {
                    this.update(() => {
                        return {
                            conversionDate,
                            conversionRate,
                            // we currently allow and handle an empty string as a valid nativeCurrency
                            // in cases where a user has not entered a native ticker symbol for a custom network
                            // currentCurrency is not from user input but this protects us from unexpected changes.
                            nativeCurrency,
                            currentCurrency,
                            pendingCurrentCurrency: null,
                            pendingNativeCurrency: null,
                            usdConversionRate,
                        };
                    });
                }
                finally {
                    releaseLock();
                }
            }
            return this.state;
        });
    }
}
exports.CurrencyRateController = CurrencyRateController;
exports.default = CurrencyRateController;
//# sourceMappingURL=CurrencyRateController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/CurrencyRateController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/MessageManager.js", {"../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js","./AbstractMessageManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/AbstractMessageManager.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/MessageManager.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageManager = void 0;
const uuid_1 = require("uuid");
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
/**
 * Controller in charge of managing - storing, adding, removing, updating - Messages.
 */
class MessageManager extends AbstractMessageManager_1.AbstractMessageManager {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'MessageManager';
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
     *
     * @param messageParams - The params for the eth_sign call to be made after the message is approved
     * @param req? - The original request object possibly containing the origin
     * @returns - Promise resolving to the raw data of the signature request
     */
    addUnapprovedMessageAsync(messageParams, req) {
        return new Promise((resolve, reject) => {
            util_1.validateSignMessageData(messageParams);
            const messageId = this.addUnapprovedMessage(messageParams, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Message Signature: User denied message signature.'));
                    default:
                        return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the
     * unapproved Messages.
     *
     * @param messageParams - The params for the eth_sign call to be made after the message
     * is approved
     * @param req? - The original request object possibly containing the origin
     * @returns - The id of the newly created message
     */
    addUnapprovedMessage(messageParams, req) {
        if (req) {
            messageParams.origin = req.origin;
        }
        messageParams.data = util_1.normalizeMessageData(messageParams.data);
        const messageId = uuid_1.v1();
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'eth_sign',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, messageParams), { metamaskId: messageId }));
        return messageId;
    }
    /**
     * Removes the metamaskId property from passed messageParams and returns a promise which
     * resolves the updated messageParams
     *
     * @param messageParams - The messageParams to modify
     * @returns - Promise resolving to the messageParams with the metamaskId property removed
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        return Promise.resolve(messageParams);
    }
}
exports.MessageManager = MessageManager;
exports.default = MessageManager;
//# sourceMappingURL=MessageManager.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/MessageManager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokenBalancesController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokenBalancesController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenBalancesController = exports.BN = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
Object.defineProperty(exports, "BN", { enumerable: true, get: function () { return ethereumjs_util_1.BN; } });
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that passively polls on a set interval token balances
 * for tokens stored in the TokensController
 */
class TokenBalancesController extends BaseController_1.BaseController {
    /**
     * Creates a TokenBalancesController instance
     *
     * @param options
     * @param options.onTokensStateChange - Allows subscribing to assets controller state changes
     * @param options.getSelectedAddress - Gets the current selected address
     * @param options.getBalanceOf - Gets the balance of the given account at the given contract address
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ onTokensStateChange, getSelectedAddress, getBalanceOf, }, config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokenBalancesController';
        this.defaultConfig = {
            interval: 180000,
            tokens: [],
        };
        this.defaultState = { contractBalances: {} };
        this.initialize();
        onTokensStateChange(({ tokens }) => {
            this.configure({ tokens });
            this.updateBalances();
        });
        this.getSelectedAddress = getSelectedAddress;
        this.getBalanceOf = getBalanceOf;
        this.poll();
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval used to fetch new token balances
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.updateBalances());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Updates balances for all tokens
     *
     * @returns Promise resolving when this operation completes
     */
    updateBalances() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.disabled) {
                return;
            }
            const { tokens } = this.config;
            const newContractBalances = {};
            for (const i in tokens) {
                const { address } = tokens[i];
                try {
                    newContractBalances[address] = yield this.getBalanceOf(address, this.getSelectedAddress());
                    tokens[i].balanceError = null;
                }
                catch (error) {
                    newContractBalances[address] = new ethereumjs_util_1.BN(0);
                    tokens[i].balanceError = error;
                }
            }
            this.update({ contractBalances: newContractBalances });
        });
    }
}
exports.TokenBalancesController = TokenBalancesController;
exports.default = TokenBalancesController;
//# sourceMappingURL=TokenBalancesController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokenBalancesController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/TypedMessageManager.js", {"../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js","./AbstractMessageManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/AbstractMessageManager.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/TypedMessageManager.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedMessageManager = void 0;
const uuid_1 = require("uuid");
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
/**
 * Controller in charge of managing - storing, adding, removing, updating - TypedMessages.
 */
class TypedMessageManager extends AbstractMessageManager_1.AbstractMessageManager {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'TypedMessageManager';
    }
    /**
     * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new TypedMessage to this.messages, and to save the unapproved TypedMessages.
     *
     * @param messageParams - The params for the eth_signTypedData call to be made after the message is approved
     * @param version - Compatibility version EIP712
     * @param req? - The original request object possibly containing the origin
     * @returns - Promise resolving to the raw data of the signature request
     */
    addUnapprovedMessageAsync(messageParams, version, req) {
        return new Promise((resolve, reject) => {
            if (version === 'V1') {
                util_1.validateTypedSignMessageDataV1(messageParams);
            }
            if (version === 'V3') {
                util_1.validateTypedSignMessageDataV3(messageParams);
            }
            const messageId = this.addUnapprovedMessage(messageParams, version, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Typed Message Signature: User denied message signature.'));
                    case 'errored':
                        return reject(new Error(`MetaMask Typed Message Signature: ${data.error}`));
                    default:
                        return reject(new Error(`MetaMask Typed Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new TypedMessage to this.messages, and to save the
     * unapproved TypedMessages.
     *
     * @param messageParams - The params for the 'eth_signTypedData' call to be made after the message
     * is approved
     * @param version - Compatibility version EIP712
     * @param req? - The original request object possibly containing the origin
     * @returns - The id of the newly created TypedMessage
     */
    addUnapprovedMessage(messageParams, version, req) {
        const messageId = uuid_1.v1();
        const messageParamsMetamask = Object.assign(Object.assign({}, messageParams), { metamaskId: messageId, version });
        if (req) {
            messageParams.origin = req.origin;
        }
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'eth_signTypedData',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, messageParamsMetamask);
        return messageId;
    }
    /**
     * Sets a TypedMessage status to 'errored' via a call to this.setMessageStatus.
     *
     * @param messageId - The id of the TypedMessage to error
     * @param error - The error to be included in TypedMessage
     */
    setMessageStatusErrored(messageId, error) {
        const message = this.getMessage(messageId);
        /* istanbul ignore if */
        if (!message) {
            return;
        }
        message.error = error;
        this.updateMessage(message);
        this.setMessageStatus(messageId, 'errored');
    }
    /**
     * Removes the metamaskId and version properties from passed messageParams and returns a promise which
     * resolves the updated messageParams
     *
     * @param messageParams - The messageParams to modify
     * @returns - Promise resolving to the messageParams with the metamaskId and version properties removed
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        delete messageParams.version;
        return Promise.resolve(messageParams);
    }
}
exports.TypedMessageManager = TypedMessageManager;
exports.default = TypedMessageManager;
//# sourceMappingURL=TypedMessageManager.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/TypedMessageManager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/PersonalMessageManager.js", {"../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js","./AbstractMessageManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/AbstractMessageManager.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/PersonalMessageManager.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersonalMessageManager = void 0;
const uuid_1 = require("uuid");
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
/**
 * Controller in charge of managing - storing, adding, removing, updating - Messages.
 */
class PersonalMessageManager extends AbstractMessageManager_1.AbstractMessageManager {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'PersonalMessageManager';
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
     *
     * @param messageParams - The params for the personal_sign call to be made after the message is approved
     * @param req? - The original request object possibly containing the origin
     * @returns - Promise resolving to the raw data of the signature request
     */
    addUnapprovedMessageAsync(messageParams, req) {
        return new Promise((resolve, reject) => {
            util_1.validateSignMessageData(messageParams);
            const messageId = this.addUnapprovedMessage(messageParams, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Personal Message Signature: User denied message signature.'));
                    default:
                        return reject(new Error(`MetaMask Personal Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the
     * unapproved Messages.
     *
     * @param messageParams - The params for the personal_sign call to be made after the message
     * is approved
     * @param req? - The original request object possibly containing the origin
     * @returns - The id of the newly created message
     */
    addUnapprovedMessage(messageParams, req) {
        if (req) {
            messageParams.origin = req.origin;
        }
        messageParams.data = util_1.normalizeMessageData(messageParams.data);
        const messageId = uuid_1.v1();
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'personal_sign',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, messageParams), { metamaskId: messageId }));
        return messageId;
    }
    /**
     * Removes the metamaskId property from passed messageParams and returns a promise which
     * resolves the updated messageParams
     *
     * @param messageParams - The messageParams to modify
     * @returns - Promise resolving to the messageParams with the metamaskId property removed
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        return Promise.resolve(messageParams);
    }
}
exports.PersonalMessageManager = PersonalMessageManager;
exports.default = PersonalMessageManager;
//# sourceMappingURL=PersonalMessageManager.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/message-manager/PersonalMessageManager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/CollectiblesController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js","../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/constants.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js","./assetsUtil":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/assetsUtil.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/CollectiblesController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectiblesController = void 0;
const events_1 = require("events");
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const assetsUtil_1 = require("./assetsUtil");
/**
 * Controller that stores assets and exposes convenience methods
 */
class CollectiblesController extends BaseController_1.BaseController {
    /**
     * Creates a CollectiblesController instance
     *
     * @param options
     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes
     * @param options.getAssetName - Gets the name of the asset at the given address
     * @param options.getAssetSymbol - Gets the symbol of the asset at the given address
     * @param options.getCollectibleTokenURI - Gets the URI of the NFT at the given address, with the given ID
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ onPreferencesStateChange, onNetworkStateChange, getAssetName, getAssetSymbol, getCollectibleTokenURI, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * EventEmitter instance used to listen to specific EIP747 events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'CollectiblesController';
        this.defaultConfig = {
            networkType: constants_1.MAINNET,
            selectedAddress: '',
            chainId: '',
        };
        this.defaultState = {
            allCollectibleContracts: {},
            allCollectibles: {},
            collectibleContracts: [],
            collectibles: [],
            ignoredCollectibles: [],
        };
        this.initialize();
        this.getAssetName = getAssetName;
        this.getAssetSymbol = getAssetSymbol;
        this.getCollectibleTokenURI = getCollectibleTokenURI;
        onPreferencesStateChange(({ selectedAddress }) => {
            var _a, _b;
            const { allCollectibleContracts, allCollectibles } = this.state;
            const { chainId } = this.config;
            this.configure({ selectedAddress });
            this.update({
                collectibleContracts: ((_a = allCollectibleContracts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [],
                collectibles: ((_b = allCollectibles[selectedAddress]) === null || _b === void 0 ? void 0 : _b[chainId]) || [],
            });
        });
        onNetworkStateChange(({ provider }) => {
            var _a, _b;
            const { allCollectibleContracts, allCollectibles } = this.state;
            const { selectedAddress } = this.config;
            const { chainId } = provider;
            this.configure({ chainId });
            this.update({
                collectibleContracts: ((_a = allCollectibleContracts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [],
                collectibles: ((_b = allCollectibles[selectedAddress]) === null || _b === void 0 ? void 0 : _b[chainId]) || [],
            });
        });
    }
    getCollectibleApi(contractAddress, tokenId) {
        return `https://api.opensea.io/api/v1/asset/${contractAddress}/${tokenId}`;
    }
    getCollectibleContractInformationApi(contractAddress) {
        return `https://api.opensea.io/api/v1/asset_contract/${contractAddress}`;
    }
    /**
     * Request individual collectible information from OpenSea api
     *
     * @param contractAddress - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleInformationFromApi(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenURI = this.getCollectibleApi(contractAddress, tokenId);
            let collectibleInformation;
            /* istanbul ignore if */
            if (this.openSeaApiKey) {
                collectibleInformation = yield util_1.handleFetch(tokenURI, {
                    headers: { 'X-API-KEY': this.openSeaApiKey },
                });
            }
            else {
                collectibleInformation = yield util_1.handleFetch(tokenURI);
            }
            const { num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, last_sale, } = collectibleInformation;
            /* istanbul ignore next */
            const collectibleMetadata = Object.assign({}, { name }, creator && { creator }, description && { description }, image_url && { image: image_url }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
                animationOriginal: animation_original_url,
            }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale });
            return collectibleMetadata;
        });
    }
    /**
     * Request individual collectible information from contracts that follows Metadata Interface
     *
     * @param contractAddress - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleInformationFromTokenURI(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenURI = yield this.getCollectibleTokenURI(contractAddress, tokenId);
            const object = yield util_1.handleFetch(tokenURI);
            const image = Object.prototype.hasOwnProperty.call(object, 'image')
                ? 'image'
                : /* istanbul ignore next */ 'image_url';
            return { image: object[image], name: object.name };
        });
    }
    /**
     * Request individual collectible information (name, image url and description)
     *
     * @param contractAddress - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleInformation(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            let information;
            // First try with OpenSea
            information = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleInformationFromApi(contractAddress, tokenId);
            }));
            if (information) {
                return information;
            }
            // Then following ERC721 standard
            information = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleInformationFromTokenURI(contractAddress, tokenId);
            }));
            /* istanbul ignore next */
            if (information) {
                return information;
            }
            /* istanbul ignore next */
            return {};
        });
    }
    /**
     * Request collectible contract information from OpenSea api
     *
     * @param contractAddress - Hex address of the collectible contract
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleContractInformationFromApi(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const api = this.getCollectibleContractInformationApi(contractAddress);
            let apiCollectibleContractObject;
            /* istanbul ignore if */
            if (this.openSeaApiKey) {
                apiCollectibleContractObject = yield util_1.handleFetch(api, {
                    headers: { 'X-API-KEY': this.openSeaApiKey },
                });
            }
            else {
                apiCollectibleContractObject = yield util_1.handleFetch(api);
            }
            return apiCollectibleContractObject;
        });
    }
    /**
     * Request collectible contract information from the contract itself
     *
     * @param contractAddress - Hex address of the collectible contract
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleContractInformationFromContract(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const name = yield this.getAssetName(contractAddress);
            const symbol = yield this.getAssetSymbol(contractAddress);
            return {
                name,
                symbol,
                address: contractAddress,
                asset_contract_type: null,
                created_date: null,
                schema_name: null,
                total_supply: null,
                description: null,
                external_link: null,
                image_url: null,
            };
        });
    }
    /**
     * Request collectible contract information from OpenSea api
     *
     * @param contractAddress - Hex address of the collectible contract
     * @returns - Promise resolving to the collectible contract name, image and description
     */
    getCollectibleContractInformation(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            let information;
            // First try with OpenSea
            information = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleContractInformationFromApi(contractAddress);
            }));
            if (information) {
                return information;
            }
            // Then following ERC721 standard
            information = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleContractInformationFromContract(contractAddress);
            }));
            if (information) {
                return information;
            }
            /* istanbul ignore next */
            return {
                address: contractAddress,
                asset_contract_type: null,
                created_date: null,
                name: null,
                schema_name: null,
                symbol: null,
                total_supply: null,
                description: null,
                external_link: null,
                image_url: null,
            };
        });
    }
    /**
     * Adds an individual collectible to the stored collectible list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @param opts - Collectible optional information (name, image and description)
     * @returns - Promise resolving to the current collectible list
     */
    addIndividualCollectible(address, tokenId, collectibleMetadata) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                address = util_1.toChecksumHexAddress(address);
                const { allCollectibles, collectibles } = this.state;
                const { chainId, selectedAddress } = this.config;
                const existingEntry = collectibles.find((collectible) => collectible.address.toLowerCase() === address.toLowerCase() &&
                    collectible.tokenId === tokenId);
                /* istanbul ignore next */
                collectibleMetadata =
                    collectibleMetadata ||
                        (yield this.getCollectibleInformation(address, tokenId));
                if (existingEntry) {
                    const differentMetadata = assetsUtil_1.compareCollectiblesMetadata(collectibleMetadata, existingEntry);
                    if (differentMetadata) {
                        const indexToRemove = collectibles.findIndex((collectible) => collectible.address.toLowerCase() === address.toLowerCase() &&
                            collectible.tokenId === tokenId);
                        /* istanbul ignore next */
                        if (indexToRemove !== -1) {
                            collectibles.splice(indexToRemove, 1);
                        }
                    }
                    else {
                        return collectibles;
                    }
                }
                const newEntry = Object.assign({ address,
                    tokenId }, collectibleMetadata);
                const newCollectibles = [...collectibles, newEntry];
                const addressCollectibles = allCollectibles[selectedAddress];
                const newAddressCollectibles = Object.assign(Object.assign({}, addressCollectibles), { [chainId]: newCollectibles });
                const newAllCollectibles = Object.assign(Object.assign({}, allCollectibles), { [selectedAddress]: newAddressCollectibles });
                this.update({
                    allCollectibles: newAllCollectibles,
                    collectibles: newCollectibles,
                });
                return newCollectibles;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Adds a collectible contract to the stored collectible contracts list
     *
     * @param address - Hex address of the collectible contract
     * @param detection? - Whether the collectible is manually added or auto-detected
     * @returns - Promise resolving to the current collectible contracts list
     */
    addCollectibleContract(address, detection) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                address = util_1.toChecksumHexAddress(address);
                const { allCollectibleContracts, collectibleContracts } = this.state;
                const { chainId, selectedAddress } = this.config;
                const existingEntry = collectibleContracts.find((collectibleContract) => collectibleContract.address.toLowerCase() === address.toLowerCase());
                if (existingEntry) {
                    return collectibleContracts;
                }
                const contractInformation = yield this.getCollectibleContractInformation(address);
                const { asset_contract_type, created_date, name, schema_name, symbol, total_supply, description, external_link, image_url, } = contractInformation;
                // If being auto-detected opensea information is expected
                // Oherwise at least name and symbol from contract is needed
                if ((detection && !image_url) ||
                    Object.keys(contractInformation).length === 0) {
                    return collectibleContracts;
                }
                /* istanbul ignore next */
                const newEntry = Object.assign({}, { address }, description && { description }, name && { name }, image_url && { logo: image_url }, symbol && { symbol }, total_supply !== null && { totalSupply: total_supply }, asset_contract_type && { assetContractType: asset_contract_type }, created_date && { createdDate: created_date }, schema_name && { schemaName: schema_name }, external_link && { externalLink: external_link });
                const newCollectibleContracts = [...collectibleContracts, newEntry];
                const addressCollectibleContracts = allCollectibleContracts[selectedAddress];
                const newAddressCollectibleContracts = Object.assign(Object.assign({}, addressCollectibleContracts), { [chainId]: newCollectibleContracts });
                const newAllCollectibleContracts = Object.assign(Object.assign({}, allCollectibleContracts), { [selectedAddress]: newAddressCollectibleContracts });
                this.update({
                    allCollectibleContracts: newAllCollectibleContracts,
                    collectibleContracts: newCollectibleContracts,
                });
                return newCollectibleContracts;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Removes an individual collectible from the stored token list and saves it in ignored collectibles list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - Token identifier of the collectible
     */
    removeAndIgnoreIndividualCollectible(address, tokenId) {
        address = util_1.toChecksumHexAddress(address);
        const { allCollectibles, collectibles, ignoredCollectibles } = this.state;
        const { chainId, selectedAddress } = this.config;
        const newIgnoredCollectibles = [...ignoredCollectibles];
        const newCollectibles = collectibles.filter((collectible) => {
            if (collectible.address.toLowerCase() === address.toLowerCase() &&
                collectible.tokenId === tokenId) {
                const alreadyIgnored = newIgnoredCollectibles.find((c) => c.address === address && c.tokenId === tokenId);
                !alreadyIgnored && newIgnoredCollectibles.push(collectible);
                return false;
            }
            return true;
        });
        const addressCollectibles = allCollectibles[selectedAddress];
        const newAddressCollectibles = Object.assign(Object.assign({}, addressCollectibles), { [chainId]: newCollectibles });
        const newAllCollectibles = Object.assign(Object.assign({}, allCollectibles), { [selectedAddress]: newAddressCollectibles });
        this.update({
            allCollectibles: newAllCollectibles,
            collectibles: newCollectibles,
            ignoredCollectibles: newIgnoredCollectibles,
        });
    }
    /**
     * Removes an individual collectible from the stored token list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - Token identifier of the collectible
     */
    removeIndividualCollectible(address, tokenId) {
        address = util_1.toChecksumHexAddress(address);
        const { allCollectibles, collectibles } = this.state;
        const { chainId, selectedAddress } = this.config;
        const newCollectibles = collectibles.filter((collectible) => !(collectible.address.toLowerCase() === address.toLowerCase() &&
            collectible.tokenId === tokenId));
        const addressCollectibles = allCollectibles[selectedAddress];
        const newAddressCollectibles = Object.assign(Object.assign({}, addressCollectibles), { [chainId]: newCollectibles });
        const newAllCollectibles = Object.assign(Object.assign({}, allCollectibles), { [selectedAddress]: newAddressCollectibles });
        this.update({
            allCollectibles: newAllCollectibles,
            collectibles: newCollectibles,
        });
    }
    /**
     * Removes a collectible contract to the stored collectible contracts list
     *
     * @param address - Hex address of the collectible contract
     * @returns - Promise resolving to the current collectible contracts list
     */
    removeCollectibleContract(address) {
        address = util_1.toChecksumHexAddress(address);
        const { allCollectibleContracts, collectibleContracts } = this.state;
        const { chainId, selectedAddress } = this.config;
        const newCollectibleContracts = collectibleContracts.filter((collectibleContract) => !(collectibleContract.address.toLowerCase() === address.toLowerCase()));
        const addressCollectibleContracts = allCollectibleContracts[selectedAddress];
        const newAddressCollectibleContracts = Object.assign(Object.assign({}, addressCollectibleContracts), { [chainId]: newCollectibleContracts });
        const newAllCollectibleContracts = Object.assign(Object.assign({}, allCollectibleContracts), { [selectedAddress]: newAddressCollectibleContracts });
        this.update({
            allCollectibleContracts: newAllCollectibleContracts,
            collectibleContracts: newCollectibleContracts,
        });
        return newCollectibleContracts;
    }
    /**
     * Sets an OpenSea API key to retrieve collectible information
     *
     * @param openSeaApiKey - OpenSea API key
     */
    setApiKey(openSeaApiKey) {
        this.openSeaApiKey = openSeaApiKey;
    }
    /**
     * Adds a collectible and respective collectible contract to the stored collectible and collectible contracts lists
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @param collectibleMetadata - Collectible optional metadata
     * @param detection? - Whether the collectible is manually added or autodetected
     * @returns - Promise resolving to the current collectible list
     */
    addCollectible(address, tokenId, collectibleMetadata, detection) {
        return __awaiter(this, void 0, void 0, function* () {
            address = util_1.toChecksumHexAddress(address);
            const newCollectibleContracts = yield this.addCollectibleContract(address, detection);
            collectibleMetadata =
                collectibleMetadata ||
                    (yield this.getCollectibleInformation(address, tokenId));
            // If collectible contract was not added, do not add individual collectible
            const collectibleContract = newCollectibleContracts.find((contract) => contract.address.toLowerCase() === address.toLowerCase());
            // If collectible contract information, add individual collectible
            if (collectibleContract) {
                yield this.addIndividualCollectible(address, tokenId, collectibleMetadata);
            }
        });
    }
    /**
     * Removes a collectible from the stored token list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - Token identifier of the collectible
     */
    removeCollectible(address, tokenId) {
        address = util_1.toChecksumHexAddress(address);
        this.removeIndividualCollectible(address, tokenId);
        const { collectibles } = this.state;
        const remainingCollectible = collectibles.find((collectible) => collectible.address.toLowerCase() === address.toLowerCase());
        if (!remainingCollectible) {
            this.removeCollectibleContract(address);
        }
    }
    /**
     * Removes a collectible from the stored token list and saves it in ignored collectibles list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - Token identifier of the collectible
     */
    removeAndIgnoreCollectible(address, tokenId) {
        address = util_1.toChecksumHexAddress(address);
        this.removeAndIgnoreIndividualCollectible(address, tokenId);
        const { collectibles } = this.state;
        const remainingCollectible = collectibles.find((collectible) => collectible.address.toLowerCase() === address.toLowerCase());
        if (!remainingCollectible) {
            this.removeCollectibleContract(address);
        }
    }
    /**
     * Removes all collectibles from the ignored list
     */
    clearIgnoredCollectibles() {
        this.update({ ignoredCollectibles: [] });
    }
}
exports.CollectiblesController = CollectiblesController;
exports.default = CollectiblesController;
//# sourceMappingURL=CollectiblesController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/CollectiblesController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/gas/GasFeeController.js", {"../BaseControllerV2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseControllerV2.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js","./gas-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/gas/gas-util.js","eth-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-query/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/gas/GasFeeController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GasFeeController = exports.GAS_ESTIMATE_TYPES = exports.LEGACY_GAS_PRICES_API_URL = void 0;
const eth_query_1 = __importDefault(require("eth-query"));
const uuid_1 = require("uuid");
const ethereumjs_util_1 = require("ethereumjs-util");
const BaseControllerV2_1 = require("../BaseControllerV2");
const util_1 = require("../util");
const gas_util_1 = require("./gas-util");
const GAS_FEE_API = 'https://mock-gas-server.herokuapp.com/';
exports.LEGACY_GAS_PRICES_API_URL = `https://api.metaswap.codefi.network/gasPrices`;
/**
 * Indicates which type of gasEstimate the controller is currently returning.
 * This is useful as a way of asserting that the shape of gasEstimates matches
 * expectations. NONE is a special case indicating that no previous gasEstimate
 * has been fetched.
 */
exports.GAS_ESTIMATE_TYPES = {
    FEE_MARKET: 'fee-market',
    LEGACY: 'legacy',
    ETH_GASPRICE: 'eth_gasPrice',
    NONE: 'none',
};
const metadata = {
    gasFeeEstimates: { persist: true, anonymous: false },
    estimatedGasFeeTimeBounds: { persist: true, anonymous: false },
    gasEstimateType: { persist: true, anonymous: false },
};
const name = 'GasFeeController';
const defaultState = {
    gasFeeEstimates: {},
    estimatedGasFeeTimeBounds: {},
    gasEstimateType: exports.GAS_ESTIMATE_TYPES.NONE,
};
/**
 * Controller that retrieves gas fee estimate data and polls for updated data on a set interval
 */
class GasFeeController extends BaseControllerV2_1.BaseController {
    /**
     * Creates a GasFeeController instance
     *
     */
    constructor({ interval = 15000, messenger, state, fetchGasEstimates = gas_util_1.fetchGasEstimates, fetchEthGasPriceEstimate = gas_util_1.fetchEthGasPriceEstimate, fetchLegacyGasPriceEstimates = gas_util_1.fetchLegacyGasPriceEstimates, getCurrentNetworkEIP1559Compatibility, getCurrentAccountEIP1559Compatibility, getChainId, getCurrentNetworkLegacyGasAPICompatibility, getProvider, onNetworkStateChange, legacyAPIEndpoint = exports.LEGACY_GAS_PRICES_API_URL, EIP1559APIEndpoint = GAS_FEE_API, clientId, }) {
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this.intervalDelay = interval;
        this.fetchGasEstimates = fetchGasEstimates;
        this.fetchEthGasPriceEstimate = fetchEthGasPriceEstimate;
        this.fetchLegacyGasPriceEstimates = fetchLegacyGasPriceEstimates;
        this.pollTokens = new Set();
        this.getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;
        this.getCurrentNetworkLegacyGasAPICompatibility = getCurrentNetworkLegacyGasAPICompatibility;
        this.getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility;
        this.EIP1559APIEndpoint = EIP1559APIEndpoint;
        this.legacyAPIEndpoint = legacyAPIEndpoint;
        this.getChainId = getChainId;
        this.currentChainId = this.getChainId();
        const provider = getProvider();
        this.ethQuery = new eth_query_1.default(provider);
        this.clientId = clientId;
        onNetworkStateChange(() => __awaiter(this, void 0, void 0, function* () {
            const newProvider = getProvider();
            const newChainId = this.getChainId();
            this.ethQuery = new eth_query_1.default(newProvider);
            if (this.currentChainId !== newChainId) {
                this.currentChainId = newChainId;
                yield this.resetPolling();
            }
        }));
    }
    resetPolling() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pollTokens.size !== 0) {
                const tokens = Array.from(this.pollTokens);
                this.stopPolling();
                yield this.getGasFeeEstimatesAndStartPolling(tokens[0]);
                tokens.slice(1).forEach((token) => {
                    this.pollTokens.add(token);
                });
            }
        });
    }
    fetchGasFeeEstimates(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._fetchGasFeeEstimateData(options);
        });
    }
    getGasFeeEstimatesAndStartPolling(pollToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const _pollToken = pollToken || uuid_1.v1();
            this.pollTokens.add(_pollToken);
            if (this.pollTokens.size === 1) {
                yield this._fetchGasFeeEstimateData();
                this._poll();
            }
            return _pollToken;
        });
    }
    /**
     * Gets and sets gasFeeEstimates in state
     *
     * @returns GasFeeEstimates
     */
    _fetchGasFeeEstimateData(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { shouldUpdateState = true } = options;
            let isEIP1559Compatible;
            const isLegacyGasAPICompatible = this.getCurrentNetworkLegacyGasAPICompatibility();
            let chainId = this.getChainId();
            if (typeof chainId === 'string' && ethereumjs_util_1.isHexString(chainId)) {
                chainId = parseInt(chainId, 16);
            }
            try {
                isEIP1559Compatible = yield this.getEIP1559Compatibility();
            }
            catch (e) {
                console.error(e);
                isEIP1559Compatible = false;
            }
            let newState = {
                gasFeeEstimates: {},
                estimatedGasFeeTimeBounds: {},
                gasEstimateType: exports.GAS_ESTIMATE_TYPES.NONE,
            };
            try {
                if (isEIP1559Compatible) {
                    const estimates = yield this.fetchGasEstimates(this.EIP1559APIEndpoint.replace('<chain_id>', `${chainId}`), this.clientId);
                    const { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas, } = estimates.medium;
                    const estimatedGasFeeTimeBounds = this.getTimeEstimate(suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas);
                    newState = {
                        gasFeeEstimates: estimates,
                        estimatedGasFeeTimeBounds,
                        gasEstimateType: exports.GAS_ESTIMATE_TYPES.FEE_MARKET,
                    };
                }
                else if (isLegacyGasAPICompatible) {
                    const estimates = yield this.fetchLegacyGasPriceEstimates(this.legacyAPIEndpoint.replace('<chain_id>', `${chainId}`), this.clientId);
                    newState = {
                        gasFeeEstimates: estimates,
                        estimatedGasFeeTimeBounds: {},
                        gasEstimateType: exports.GAS_ESTIMATE_TYPES.LEGACY,
                    };
                }
                else {
                    throw new Error('Main gas fee/price estimation failed. Use fallback');
                }
            }
            catch (_a) {
                try {
                    const estimates = yield this.fetchEthGasPriceEstimate(this.ethQuery);
                    newState = {
                        gasFeeEstimates: estimates,
                        estimatedGasFeeTimeBounds: {},
                        gasEstimateType: exports.GAS_ESTIMATE_TYPES.ETH_GASPRICE,
                    };
                }
                catch (error) {
                    throw new Error(`Gas fee/price estimation failed. Message: ${error.message}`);
                }
            }
            if (shouldUpdateState) {
                this.update(() => {
                    return newState;
                });
            }
            return newState;
        });
    }
    /**
     * Remove the poll token, and stop polling if the set of poll tokens is empty
     */
    disconnectPoller(pollToken) {
        this.pollTokens.delete(pollToken);
        if (this.pollTokens.size === 0) {
            this.stopPolling();
        }
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
        this.pollTokens.clear();
        this.resetState();
    }
    /**
     * Prepare to discard this controller.
     *
     * This stops any active polling.
     */
    destroy() {
        super.destroy();
        this.stopPolling();
    }
    _poll() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
        this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            yield util_1.safelyExecute(() => this._fetchGasFeeEstimateData());
        }), this.intervalDelay);
    }
    resetState() {
        this.update(() => {
            return defaultState;
        });
    }
    getEIP1559Compatibility() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const currentNetworkIsEIP1559Compatible = yield this.getCurrentNetworkEIP1559Compatibility();
            const currentAccountIsEIP1559Compatible = (_b = (_a = this.getCurrentAccountEIP1559Compatibility) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : true;
            return (currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible);
        });
    }
    getTimeEstimate(maxPriorityFeePerGas, maxFeePerGas) {
        if (!this.state.gasFeeEstimates ||
            this.state.gasEstimateType !== exports.GAS_ESTIMATE_TYPES.FEE_MARKET) {
            return {};
        }
        return gas_util_1.calculateTimeEstimate(maxPriorityFeePerGas, maxFeePerGas, this.state.gasFeeEstimates);
    }
}
exports.GasFeeController = GasFeeController;
exports.default = GasFeeController;
//# sourceMappingURL=GasFeeController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/gas/GasFeeController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/constants.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","eth-ens-namehash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-ens-namehash/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","eth-sig-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-sig-util/dist/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","ethjs-unit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-unit/lib/index.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/ethjs-util/lib/index.js","jsonschema":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/jsonschema/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateMinimumIncrease = exports.isGasPriceValue = exports.isFeeMarketEIP1559Values = exports.validateGasValues = exports.getIncreasedPriceFromExisting = exports.getIncreasedPriceHex = exports.convertPriceToDecimal = exports.isEIP1559Transaction = exports.query = exports.normalizeEnsName = exports.timeoutFetch = exports.handleFetch = exports.successfulFetch = exports.isSmartContractCode = exports.validateTokenToWatch = exports.validateTypedSignMessageDataV3 = exports.validateTypedSignMessageDataV1 = exports.validateSignMessageData = exports.normalizeMessageData = exports.validateTransaction = exports.isValidHexAddress = exports.toChecksumHexAddress = exports.safelyExecuteWithTimeout = exports.safelyExecute = exports.normalizeTransaction = exports.hexToText = exports.hexToBN = exports.handleTransactionFetch = exports.getEtherscanApiUrl = exports.getBuyURL = exports.weiHexToGweiDec = exports.gweiDecToWEIBN = exports.fractionBN = exports.BNToHex = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const ethjs_util_1 = require("ethjs-util");
const ethjs_unit_1 = require("ethjs-unit");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const eth_ens_namehash_1 = __importDefault(require("eth-ens-namehash"));
const eth_sig_util_1 = require("eth-sig-util");
const jsonschema_1 = require("jsonschema");
const constants_1 = require("./constants");
const hexRe = /^[0-9A-Fa-f]+$/gu;
const NORMALIZERS = {
    data: (data) => ethereumjs_util_1.addHexPrefix(data),
    from: (from) => ethereumjs_util_1.addHexPrefix(from).toLowerCase(),
    gas: (gas) => ethereumjs_util_1.addHexPrefix(gas),
    gasPrice: (gasPrice) => ethereumjs_util_1.addHexPrefix(gasPrice),
    nonce: (nonce) => ethereumjs_util_1.addHexPrefix(nonce),
    to: (to) => ethereumjs_util_1.addHexPrefix(to).toLowerCase(),
    value: (value) => ethereumjs_util_1.addHexPrefix(value),
    maxFeePerGas: (maxFeePerGas) => ethereumjs_util_1.addHexPrefix(maxFeePerGas),
    maxPriorityFeePerGas: (maxPriorityFeePerGas) => ethereumjs_util_1.addHexPrefix(maxPriorityFeePerGas),
    estimatedBaseFee: (maxPriorityFeePerGas) => ethereumjs_util_1.addHexPrefix(maxPriorityFeePerGas),
};
/**
 * Converts a BN object to a hex string with a '0x' prefix
 *
 * @param inputBn - BN instance to convert to a hex string
 * @returns - '0x'-prefixed hex string
 *
 */
function BNToHex(inputBn) {
    return ethereumjs_util_1.addHexPrefix(inputBn.toString(16));
}
exports.BNToHex = BNToHex;
/**
 * Used to multiply a BN by a fraction
 *
 * @param targetBN - Number to multiply by a fraction
 * @param numerator - Numerator of the fraction multiplier
 * @param denominator - Denominator of the fraction multiplier
 * @returns - Product of the multiplication
 */
function fractionBN(targetBN, numerator, denominator) {
    const numBN = new ethereumjs_util_1.BN(numerator);
    const denomBN = new ethereumjs_util_1.BN(denominator);
    return targetBN.mul(numBN).div(denomBN);
}
exports.fractionBN = fractionBN;
/**
 * Used to convert a base-10 number from GWEI to WEI. Can handle numbers with decimal parts
 *
 * @param n - The base 10 number to convert to WEI
 * @returns - The number in WEI, as a BN
 */
function gweiDecToWEIBN(n) {
    if (Number.isNaN(n)) {
        return new ethereumjs_util_1.BN(0);
    }
    const parts = n.toString().split('.');
    const wholePart = parts[0] || '0';
    let decimalPart = parts[1] || '';
    if (!decimalPart) {
        return ethjs_unit_1.toWei(wholePart, 'gwei');
    }
    if (decimalPart.length <= 9) {
        return ethjs_unit_1.toWei(`${wholePart}.${decimalPart}`, 'gwei');
    }
    const decimalPartToRemove = decimalPart.slice(9);
    const decimalRoundingDigit = decimalPartToRemove[0];
    decimalPart = decimalPart.slice(0, 9);
    let wei = ethjs_unit_1.toWei(`${wholePart}.${decimalPart}`, 'gwei');
    if (Number(decimalRoundingDigit) >= 5) {
        wei = wei.add(new ethereumjs_util_1.BN(1));
    }
    return wei;
}
exports.gweiDecToWEIBN = gweiDecToWEIBN;
/**
 * Used to convert values from wei hex format to dec gwei format
 * @param hex - value in hex wei
 * @returns - value in dec gwei as string
 */
function weiHexToGweiDec(hex) {
    const hexWei = new ethereumjs_util_1.BN(ethjs_util_1.stripHexPrefix(hex), 16);
    return ethjs_unit_1.fromWei(hexWei, 'gwei').toString(10);
}
exports.weiHexToGweiDec = weiHexToGweiDec;
/**
 * Return a URL that can be used to obtain ETH for a given network
 *
 * @param networkCode - Network code of desired network
 * @param address - Address to deposit obtained ETH
 * @param amount - How much ETH is desired
 * @returns - URL to buy ETH based on network
 */
function getBuyURL(networkCode = '1', address, amount = 5) {
    switch (networkCode) {
        case '1':
            return `https://buy.coinbase.com/?code=9ec56d01-7e81-5017-930c-513daa27bb6a&amount=${amount}&address=${address}&crypto_currency=ETH`;
        case '3':
            return 'https://faucet.metamask.io/';
        case '4':
            return 'https://www.rinkeby.io/';
        case '5':
            return 'https://goerli-faucet.slock.it/';
        case '42':
            return 'https://github.com/kovan-testnet/faucet';
        default:
            return undefined;
    }
}
exports.getBuyURL = getBuyURL;
/**
 * Return a URL that can be used to fetch ETH transactions
 *
 * @param networkType - Network type of desired network
 * @param urlParams - Parameters used to construct the URL
 * @returns - URL to fetch the access the endpoint
 */
function getEtherscanApiUrl(networkType, urlParams) {
    let etherscanSubdomain = 'api';
    if (networkType !== constants_1.MAINNET) {
        etherscanSubdomain = `api-${networkType}`;
    }
    const apiUrl = `https://${etherscanSubdomain}.etherscan.io`;
    let url = `${apiUrl}/api?`;
    for (const paramKey in urlParams) {
        if (urlParams[paramKey]) {
            url += `${paramKey}=${urlParams[paramKey]}&`;
        }
    }
    url += 'tag=latest&page=1';
    return url;
}
exports.getEtherscanApiUrl = getEtherscanApiUrl;
/**
 * Handles the fetch of incoming transactions
 *
 * @param networkType - Network type of desired network
 * @param address - Address to get the transactions from
 * @param opt? - Object that can contain fromBlock and Etherscan service API key
 * @returns - Responses for both ETH and ERC20 token transactions
 */
function handleTransactionFetch(networkType, address, txHistoryLimit, opt) {
    return __awaiter(this, void 0, void 0, function* () {
        // transactions
        const urlParams = {
            module: 'account',
            address,
            startBlock: opt === null || opt === void 0 ? void 0 : opt.fromBlock,
            apikey: opt === null || opt === void 0 ? void 0 : opt.etherscanApiKey,
            offset: txHistoryLimit.toString(),
            order: 'desc',
        };
        const etherscanTxUrl = getEtherscanApiUrl(networkType, Object.assign(Object.assign({}, urlParams), { action: 'txlist' }));
        const etherscanTxResponsePromise = handleFetch(etherscanTxUrl);
        // tokens
        const etherscanTokenUrl = getEtherscanApiUrl(networkType, Object.assign(Object.assign({}, urlParams), { action: 'tokentx' }));
        const etherscanTokenResponsePromise = handleFetch(etherscanTokenUrl);
        let [etherscanTxResponse, etherscanTokenResponse] = yield Promise.all([
            etherscanTxResponsePromise,
            etherscanTokenResponsePromise,
        ]);
        if (etherscanTxResponse.status === '0' ||
            etherscanTxResponse.result.length <= 0) {
            etherscanTxResponse = { status: etherscanTxResponse.status, result: [] };
        }
        if (etherscanTokenResponse.status === '0' ||
            etherscanTokenResponse.result.length <= 0) {
            etherscanTokenResponse = {
                status: etherscanTokenResponse.status,
                result: [],
            };
        }
        return [etherscanTxResponse, etherscanTokenResponse];
    });
}
exports.handleTransactionFetch = handleTransactionFetch;
/**
 * Converts a hex string to a BN object
 *
 * @param inputHex - Number represented as a hex string
 * @returns - A BN instance
 *
 */
function hexToBN(inputHex) {
    return new ethereumjs_util_1.BN(ethjs_util_1.stripHexPrefix(inputHex), 16);
}
exports.hexToBN = hexToBN;
/**
 * A helper function that converts hex data to human readable string
 *
 * @param hex - The hex string to convert to string
 * @returns - A human readable string conversion
 *
 */
function hexToText(hex) {
    try {
        const stripped = ethjs_util_1.stripHexPrefix(hex);
        const buff = Buffer.from(stripped, 'hex');
        return buff.toString('utf8');
    }
    catch (e) {
        /* istanbul ignore next */
        return hex;
    }
}
exports.hexToText = hexToText;
/**
 * Normalizes properties on a Transaction object
 *
 * @param transaction - Transaction object to normalize
 * @returns - Normalized Transaction object
 */
function normalizeTransaction(transaction) {
    const normalizedTransaction = { from: '' };
    let key;
    for (key in NORMALIZERS) {
        if (transaction[key]) {
            normalizedTransaction[key] = NORMALIZERS[key](transaction[key]);
        }
    }
    return normalizedTransaction;
}
exports.normalizeTransaction = normalizeTransaction;
/**
 * Execute and return an asynchronous operation without throwing errors
 *
 * @param operation - Function returning a Promise
 * @param logError - Determines if the error should be logged
 * @param retry - Function called if an error is caught
 * @returns - Promise resolving to the result of the async operation
 */
function safelyExecute(operation, logError = false, retry) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield operation();
        }
        catch (error) {
            /* istanbul ignore next */
            if (logError) {
                console.error(error);
            }
            retry === null || retry === void 0 ? void 0 : retry(error);
            return undefined;
        }
    });
}
exports.safelyExecute = safelyExecute;
/**
 * Execute and return an asynchronous operation with a timeout
 *
 * @param operation - Function returning a Promise
 * @param logError - Determines if the error should be logged
 * @param retry - Function called if an error is caught
 * @param timeout - Timeout to fail the operation
 * @returns - Promise resolving to the result of the async operation
 */
function safelyExecuteWithTimeout(operation, logError = false, timeout = 500) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield Promise.race([
                operation(),
                new Promise((_, reject) => setTimeout(() => {
                    reject(new Error('timeout'));
                }, timeout)),
            ]);
        }
        catch (error) {
            /* istanbul ignore next */
            if (logError) {
                console.error(error);
            }
            return undefined;
        }
    });
}
exports.safelyExecuteWithTimeout = safelyExecuteWithTimeout;
function toChecksumHexAddress(address) {
    const hexPrefixed = ethereumjs_util_1.addHexPrefix(address);
    if (!ethereumjs_util_1.isHexString(hexPrefixed)) {
        // Version 5.1 of ethereumjs-utils would have returned '0xY' for input 'y'
        // but we shouldn't waste effort trying to change case on a clearly invalid
        // string. Instead just return the hex prefixed original string which most
        // closely mimics the original behavior.
        return hexPrefixed;
    }
    return ethereumjs_util_1.toChecksumAddress(hexPrefixed);
}
exports.toChecksumHexAddress = toChecksumHexAddress;
/**
 * Validates that the input is a hex address. This utility method is a thin
 * wrapper around ethereumjs-util.isValidAddress, with the exception that it
 * does not throw an error when provided values that are not hex strings. In
 * addition, and by default, this method will return true for hex strings that
 * meet the length requirement of a hex address, but are not prefixed with `0x`
 * Finally, if the mixedCaseUseChecksum flag is true and a mixed case string is
 * provided this method will validate it has the proper checksum formatting.
 * @param {string} possibleAddress - Input parameter to check against
 * @param {Object} [options] - options bag
 * @param {boolean} [options.allowNonPrefixed] - If true will first ensure '0x'
 *  is prepended to the string
 * @returns {boolean} whether or not the input is a valid hex address
 */
function isValidHexAddress(possibleAddress, { allowNonPrefixed = true } = {}) {
    const addressToCheck = allowNonPrefixed
        ? ethereumjs_util_1.addHexPrefix(possibleAddress)
        : possibleAddress;
    if (!ethereumjs_util_1.isHexString(addressToCheck)) {
        return false;
    }
    return ethereumjs_util_1.isValidAddress(addressToCheck);
}
exports.isValidHexAddress = isValidHexAddress;
/**
 * Validates a Transaction object for required properties and throws in
 * the event of any validation error.
 *
 * @param transaction - Transaction object to validate
 */
function validateTransaction(transaction) {
    if (!transaction.from ||
        typeof transaction.from !== 'string' ||
        !isValidHexAddress(transaction.from)) {
        throw new Error(`Invalid "from" address: ${transaction.from} must be a valid string.`);
    }
    if (transaction.to === '0x' || transaction.to === undefined) {
        if (transaction.data) {
            delete transaction.to;
        }
        else {
            throw new Error(`Invalid "to" address: ${transaction.to} must be a valid string.`);
        }
    }
    else if (transaction.to !== undefined &&
        !isValidHexAddress(transaction.to)) {
        throw new Error(`Invalid "to" address: ${transaction.to} must be a valid string.`);
    }
    if (transaction.value !== undefined) {
        const value = transaction.value.toString();
        if (value.includes('-')) {
            throw new Error(`Invalid "value": ${value} is not a positive number.`);
        }
        if (value.includes('.')) {
            throw new Error(`Invalid "value": ${value} number must be denominated in wei.`);
        }
        const intValue = parseInt(transaction.value, 10);
        const isValid = Number.isFinite(intValue) &&
            !Number.isNaN(intValue) &&
            !isNaN(Number(value)) &&
            Number.isSafeInteger(intValue);
        if (!isValid) {
            throw new Error(`Invalid "value": ${value} number must be a valid number.`);
        }
    }
}
exports.validateTransaction = validateTransaction;
/**
 * A helper function that converts rawmessageData buffer data to a hex, or just returns the data if
 * it is already formatted as a hex.
 *
 * @param data - The buffer data to convert to a hex
 * @returns - A hex string conversion of the buffer data
 *
 */
function normalizeMessageData(data) {
    try {
        const stripped = ethjs_util_1.stripHexPrefix(data);
        if (stripped.match(hexRe)) {
            return ethereumjs_util_1.addHexPrefix(stripped);
        }
    }
    catch (e) {
        /* istanbul ignore next */
    }
    return ethereumjs_util_1.bufferToHex(Buffer.from(data, 'utf8'));
}
exports.normalizeMessageData = normalizeMessageData;
/**
 * Validates a PersonalMessageParams and MessageParams objects for required properties and throws in
 * the event of any validation error.
 *
 * @param messageData - PersonalMessageParams object to validate
 */
function validateSignMessageData(messageData) {
    const { from, data } = messageData;
    if (!from || typeof from !== 'string' || !isValidHexAddress(from)) {
        throw new Error(`Invalid "from" address: ${from} must be a valid string.`);
    }
    if (!data || typeof data !== 'string') {
        throw new Error(`Invalid message "data": ${data} must be a valid string.`);
    }
}
exports.validateSignMessageData = validateSignMessageData;
/**
 * Validates a TypedMessageParams object for required properties and throws in
 * the event of any validation error for eth_signTypedMessage_V1.
 *
 * @param messageData - TypedMessageParams object to validate
 * @param activeChainId - Active chain id
 */
function validateTypedSignMessageDataV1(messageData) {
    if (!messageData.from ||
        typeof messageData.from !== 'string' ||
        !isValidHexAddress(messageData.from)) {
        throw new Error(`Invalid "from" address: ${messageData.from} must be a valid string.`);
    }
    if (!messageData.data || !Array.isArray(messageData.data)) {
        throw new Error(`Invalid message "data": ${messageData.data} must be a valid array.`);
    }
    try {
        // typedSignatureHash will throw if the data is invalid.
        eth_sig_util_1.typedSignatureHash(messageData.data);
    }
    catch (e) {
        throw new Error(`Expected EIP712 typed data.`);
    }
}
exports.validateTypedSignMessageDataV1 = validateTypedSignMessageDataV1;
/**
 * Validates a TypedMessageParams object for required properties and throws in
 * the event of any validation error for eth_signTypedMessage_V3.
 *
 * @param messageData - TypedMessageParams object to validate
 */
function validateTypedSignMessageDataV3(messageData) {
    if (!messageData.from ||
        typeof messageData.from !== 'string' ||
        !isValidHexAddress(messageData.from)) {
        throw new Error(`Invalid "from" address: ${messageData.from} must be a valid string.`);
    }
    if (!messageData.data || typeof messageData.data !== 'string') {
        throw new Error(`Invalid message "data": ${messageData.data} must be a valid array.`);
    }
    let data;
    try {
        data = JSON.parse(messageData.data);
    }
    catch (e) {
        throw new Error('Data must be passed as a valid JSON string.');
    }
    const validation = jsonschema_1.validate(data, eth_sig_util_1.TYPED_MESSAGE_SCHEMA);
    if (validation.errors.length > 0) {
        throw new Error('Data must conform to EIP-712 schema. See https://git.io/fNtcx.');
    }
}
exports.validateTypedSignMessageDataV3 = validateTypedSignMessageDataV3;
/**
 * Validates a ERC20 token to be added with EIP747.
 *
 * @param token - Token object to validate
 */
function validateTokenToWatch(token) {
    const { address, symbol, decimals } = token;
    if (!address || !symbol || typeof decimals === 'undefined') {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Must specify address, symbol, and decimals.`);
    }
    if (typeof symbol !== 'string') {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid symbol: not a string.`);
    }
    if (symbol.length > 11) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid symbol "${symbol}": longer than 11 characters.`);
    }
    const numDecimals = parseInt(decimals, 10);
    if (isNaN(numDecimals) || numDecimals > 36 || numDecimals < 0) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid decimals "${decimals}": must be 0 <= 36.`);
    }
    if (!isValidHexAddress(address)) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid address "${address}".`);
    }
}
exports.validateTokenToWatch = validateTokenToWatch;
/**
 * Returns wether the given code corresponds to a smart contract
 *
 * @returns {string} - Corresponding code to review
 */
function isSmartContractCode(code) {
    /* istanbul ignore if */
    if (!code) {
        return false;
    }
    // Geth will return '0x', and ganache-core v2.2.1 will return '0x0'
    const smartContractCode = code !== '0x' && code !== '0x0';
    return smartContractCode;
}
exports.isSmartContractCode = isSmartContractCode;
/**
 * Execute fetch and verify that the response was successful
 *
 * @param request - Request information
 * @param options - Options
 * @returns - Promise resolving to the fetch response
 */
function successfulFetch(request, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield fetch(request, options);
        if (!response.ok) {
            throw new Error(`Fetch failed with status '${response.status}' for request '${request}'`);
        }
        return response;
    });
}
exports.successfulFetch = successfulFetch;
/**
 * Execute fetch and return object response
 *
 * @param request - Request information
 * @param options - Options
 * @returns - Promise resolving to the result object of fetch
 */
function handleFetch(request, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield successfulFetch(request, options);
        const object = yield response.json();
        return object;
    });
}
exports.handleFetch = handleFetch;
/**
 * Fetch that fails after timeout
 *
 * @param url - Url to fetch
 * @param options - Options to send with the request
 * @param timeout - Timeout to fail request
 *
 * @returns - Promise resolving the request
 */
function timeoutFetch(url, options, timeout = 500) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.race([
            successfulFetch(url, options),
            new Promise((_, reject) => setTimeout(() => {
                reject(new Error('timeout'));
            }, timeout)),
        ]);
    });
}
exports.timeoutFetch = timeoutFetch;
/**
 * Normalizes the given ENS name.
 *
 * @param {string} ensName - The ENS name
 *
 * @returns - the normalized ENS name string
 */
function normalizeEnsName(ensName) {
    if (ensName && typeof ensName === 'string') {
        try {
            const normalized = eth_ens_namehash_1.default.normalize(ensName.trim());
            // this regex is only sufficient with the above call to ensNamehash.normalize
            // TODO: change 7 in regex to 3 when shorter ENS domains are live
            if (normalized.match(/^(([\w\d-]+)\.)*[\w\d-]{7,}\.(eth|test)$/u)) {
                return normalized;
            }
        }
        catch (_) {
            // do nothing
        }
    }
    return null;
}
exports.normalizeEnsName = normalizeEnsName;
/**
 * Wrapper method to handle EthQuery requests
 *
 * @param ethQuery - EthQuery object initialized with a provider
 * @param method - Method to request
 * @param args - Arguments to send
 *
 * @returns - Promise resolving the request
 */
function query(ethQuery, method, args = []) {
    return new Promise((resolve, reject) => {
        ethQuery[method](...args, (error, result) => {
            if (error) {
                reject(error);
                return;
            }
            resolve(result);
        });
    });
}
exports.query = query;
/**
 * Checks if a transaction is EIP-1559 by checking for the existence of
 * maxFeePerGas and maxPriorityFeePerGas within its parameters
 *
 * @param transaction - Transaction object to add
 * @returns - Boolean that is true if the transaction is EIP-1559 (has maxFeePerGas and maxPriorityFeePerGas), otherwise returns false
 */
const isEIP1559Transaction = (transaction) => {
    const hasOwnProp = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
    return (hasOwnProp(transaction, 'maxFeePerGas') &&
        hasOwnProp(transaction, 'maxPriorityFeePerGas'));
};
exports.isEIP1559Transaction = isEIP1559Transaction;
const convertPriceToDecimal = (value) => parseInt(value === undefined ? '0x0' : value, 16);
exports.convertPriceToDecimal = convertPriceToDecimal;
const getIncreasedPriceHex = (value, rate) => ethereumjs_util_1.addHexPrefix(`${parseInt(`${value * rate}`, 10).toString(16)}`);
exports.getIncreasedPriceHex = getIncreasedPriceHex;
const getIncreasedPriceFromExisting = (value, rate) => {
    return exports.getIncreasedPriceHex(exports.convertPriceToDecimal(value), rate);
};
exports.getIncreasedPriceFromExisting = getIncreasedPriceFromExisting;
const validateGasValues = (gasValues) => {
    Object.keys(gasValues).forEach((key) => {
        const value = gasValues[key];
        if (typeof value !== 'string' || !ethereumjs_util_1.isHexString(value)) {
            throw new TypeError(`expected hex string for ${key} but received: ${value}`);
        }
    });
};
exports.validateGasValues = validateGasValues;
const isFeeMarketEIP1559Values = (gasValues) => {
    var _a, _b;
    return ((_a = gasValues) === null || _a === void 0 ? void 0 : _a.maxFeePerGas) !== undefined ||
        ((_b = gasValues) === null || _b === void 0 ? void 0 : _b.maxPriorityFeePerGas) !== undefined;
};
exports.isFeeMarketEIP1559Values = isFeeMarketEIP1559Values;
const isGasPriceValue = (gasValues) => { var _a; return ((_a = gasValues) === null || _a === void 0 ? void 0 : _a.gasPrice) !== undefined; };
exports.isGasPriceValue = isGasPriceValue;
function validateMinimumIncrease(proposed, min) {
    const proposedDecimal = exports.convertPriceToDecimal(proposed);
    const minDecimal = exports.convertPriceToDecimal(min);
    if (proposedDecimal >= minDecimal) {
        return proposed;
    }
    const errorMsg = `The proposed value: ${proposedDecimal} should meet or exceed the minimum value: ${minDecimal}`;
    throw new Error(errorMsg);
}
exports.validateMinimumIncrease = validateMinimumIncrease;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokenListController.js", {"../BaseControllerV2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseControllerV2.js","../apis/token-service":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/apis/token-service.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js","@metamask/contract-metadata":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/contract-metadata/index.js","abort-controller":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abort-controller/browser.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokenListController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenListController = void 0;
const contract_metadata_1 = __importDefault(require("@metamask/contract-metadata"));
const async_mutex_1 = require("async-mutex");
// eslint-disable-next-line import/no-named-as-default
const abort_controller_1 = __importDefault(require("abort-controller"));
const BaseControllerV2_1 = require("../BaseControllerV2");
const util_1 = require("../util");
const token_service_1 = require("../apis/token-service");
const DEFAULT_INTERVAL = 60 * 60 * 1000;
const DEFAULT_THRESHOLD = 60 * 30 * 1000;
const name = 'TokenListController';
const metadata = {
    tokenList: { persist: true, anonymous: true },
    tokensChainsCache: { persist: true, anonymous: true },
};
const defaultState = {
    tokenList: {},
    tokensChainsCache: {},
};
/**
 * Controller that passively polls on a set interval for the list of tokens from metaswaps api
 */
class TokenListController extends BaseControllerV2_1.BaseController {
    // private abortSignal: AbortSignal;
    /**
     * Creates a TokenListController instance
     *
     * @param options - Constructor options
     * @param options.interval - The polling interval, in milliseconds
     * @param options.messenger - A reference to the messaging system
     * @param options.state - Initial state to set on this controller
     */
    constructor({ chainId, useStaticTokenList, onNetworkStateChange, onPreferencesStateChange, interval = DEFAULT_INTERVAL, cacheRefreshThreshold = DEFAULT_THRESHOLD, messenger, state, }) {
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this.mutex = new async_mutex_1.Mutex();
        this.intervalDelay = interval;
        this.cacheRefreshThreshold = cacheRefreshThreshold;
        this.chainId = chainId;
        this.useStaticTokenList = useStaticTokenList;
        this.abortController = new abort_controller_1.default();
        onNetworkStateChange((networkState) => __awaiter(this, void 0, void 0, function* () {
            if (this.chainId !== networkState.provider.chainId) {
                this.abortController.abort();
                this.abortController = new abort_controller_1.default();
                this.chainId = networkState.provider.chainId;
                yield this.restart();
            }
        }));
        onPreferencesStateChange((preferencesState) => __awaiter(this, void 0, void 0, function* () {
            if (this.useStaticTokenList !== preferencesState.useStaticTokenList) {
                this.abortController.abort();
                this.abortController = new abort_controller_1.default();
                this.useStaticTokenList = preferencesState.useStaticTokenList;
                yield this.restart();
            }
        }));
    }
    /**
     * Start polling for the token list
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.startPolling();
        });
    }
    /**
     * Restart polling for the token list
     */
    restart() {
        return __awaiter(this, void 0, void 0, function* () {
            this.stopPolling();
            yield this.startPolling();
        });
    }
    /**
     * Stop polling for the token list
     */
    stop() {
        this.stopPolling();
    }
    /**
     * Prepare to discard this controller.
     *
     * This stops any active polling.
     */
    destroy() {
        super.destroy();
        this.stopPolling();
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    /**
     * Starts a new polling interval
     */
    startPolling() {
        return __awaiter(this, void 0, void 0, function* () {
            yield util_1.safelyExecute(() => this.fetchTokenList());
            this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                yield util_1.safelyExecute(() => this.fetchTokenList());
            }), this.intervalDelay);
        });
    }
    /**
     * Fetching token list
     */
    fetchTokenList() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.useStaticTokenList) {
                yield this.fetchFromStaticTokenList();
            }
            else {
                yield this.fetchFromDynamicTokenList();
            }
        });
    }
    /**
     * Fetching token list from the contract-metadata as a fallback
     */
    fetchFromStaticTokenList() {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenList = {};
            for (const tokenAddress in contract_metadata_1.default) {
                const _a = contract_metadata_1.default[tokenAddress], { erc20, logo: filePath } = _a, token = __rest(_a, ["erc20", "logo"]);
                if (erc20) {
                    tokenList[tokenAddress] = Object.assign(Object.assign({}, token), { address: tokenAddress, iconUrl: filePath, occurrences: null });
                }
            }
            this.update(() => {
                return {
                    tokenList,
                    tokensChainsCache: {},
                };
            });
        });
    }
    /**
     * Fetching token list from the Token Service API
     */
    fetchFromDynamicTokenList() {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const cachedTokens = yield util_1.safelyExecute(() => this.fetchFromCache());
                const _a = this.state, { tokensChainsCache } = _a, tokensData = __rest(_a, ["tokensChainsCache"]);
                const tokenList = {};
                if (cachedTokens) {
                    for (const token of cachedTokens) {
                        tokenList[token.address] = token;
                    }
                }
                else {
                    const tokensFromAPI = yield util_1.safelyExecute(() => token_service_1.fetchTokenList(this.chainId, this.abortController.signal));
                    if (!tokensFromAPI) {
                        const backupTokenList = tokensChainsCache[this.chainId]
                            ? tokensChainsCache[this.chainId].data
                            : [];
                        for (const token of backupTokenList) {
                            tokenList[token.address] = token;
                        }
                        this.update(() => {
                            return Object.assign(Object.assign({}, tokensData), { tokenList,
                                tokensChainsCache });
                        });
                        return;
                    }
                    // filtering out tokens with less than 2 occurrences
                    const filteredTokenList = tokensFromAPI.filter((token) => token.occurrences && token.occurrences >= 2);
                    // removing the tokens with symbol conflicts
                    const symbolsList = filteredTokenList.map((token) => token.symbol);
                    const duplicateSymbols = [
                        ...new Set(symbolsList.filter((symbol, index) => symbolsList.indexOf(symbol) !== index)),
                    ];
                    const uniqueTokenList = filteredTokenList.filter((token) => !duplicateSymbols.includes(token.symbol));
                    for (const token of uniqueTokenList) {
                        tokenList[token.address] = token;
                    }
                }
                const updatedTokensChainsCache = Object.assign(Object.assign({}, tokensChainsCache), { [this.chainId]: {
                        timestamp: Date.now(),
                        data: Object.values(tokenList),
                    } });
                this.update(() => {
                    return Object.assign(Object.assign({}, tokensData), { tokenList, tokensChainsCache: updatedTokensChainsCache });
                });
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Checks if the Cache timestamp is valid,
     *  if yes data in cache will be returned
     *  otherwise null will be returned.
     * @returns Promise that resolves into TokenListToken[] or null
     */
    fetchFromCache() {
        return __awaiter(this, void 0, void 0, function* () {
            const { tokensChainsCache } = this.state;
            const dataCache = tokensChainsCache[this.chainId];
            const now = Date.now();
            if ((dataCache === null || dataCache === void 0 ? void 0 : dataCache.data) &&
                now - (dataCache === null || dataCache === void 0 ? void 0 : dataCache.timestamp) < this.cacheRefreshThreshold) {
                return dataCache.data;
            }
            return null;
        });
    }
    /**
     * Fetch metadata for a token whose address is send to the API
     * @param tokenAddress
     * @returns Promise that resolves to Token Metadata
     */
    fetchTokenMetadata(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const token = (yield token_service_1.fetchTokenMetadata(this.chainId, tokenAddress, this.abortController.signal));
                return token;
            }
            finally {
                releaseLock();
            }
        });
    }
}
exports.TokenListController = TokenListController;
exports.default = TokenListController;
//# sourceMappingURL=TokenListController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokenListController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokensController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js","../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/constants.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js","@metamask/contract-metadata":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/contract-metadata/index.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js","ethers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethers/lib/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","human-standard-collectible-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/human-standard-collectible-abi/index.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokensController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensController = void 0;
const events_1 = require("events");
const contract_metadata_1 = __importDefault(require("@metamask/contract-metadata"));
const human_standard_collectible_abi_1 = __importDefault(require("human-standard-collectible-abi"));
const uuid_1 = require("uuid");
const async_mutex_1 = require("async-mutex");
const ethers_1 = require("ethers");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const ERC721_INTERFACE_ID = '0x80ac58cd';
var SuggestedAssetStatus;
(function (SuggestedAssetStatus) {
    SuggestedAssetStatus["accepted"] = "accepted";
    SuggestedAssetStatus["failed"] = "failed";
    SuggestedAssetStatus["pending"] = "pending";
    SuggestedAssetStatus["rejected"] = "rejected";
})(SuggestedAssetStatus || (SuggestedAssetStatus = {}));
/**
 * Controller that stores assets and exposes convenience methods
 */
class TokensController extends BaseController_1.BaseController {
    /**
     * Creates a TokensController instance
     *
     * @param options
     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ onPreferencesStateChange, onNetworkStateChange, config, state, }) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * EventEmitter instance used to listen to specific EIP747 events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokensController';
        this.defaultConfig = Object.assign({ networkType: constants_1.MAINNET, selectedAddress: '', chainId: '', provider: undefined }, config);
        this.defaultState = Object.assign({ allTokens: {}, allIgnoredTokens: {}, ignoredTokens: [], suggestedAssets: [], tokens: [] }, state);
        this.initialize();
        onPreferencesStateChange(({ selectedAddress }) => {
            var _a, _b;
            const { allTokens, allIgnoredTokens } = this.state;
            const { chainId } = this.config;
            this.configure({ selectedAddress });
            this.update({
                tokens: ((_a = allTokens[chainId]) === null || _a === void 0 ? void 0 : _a[selectedAddress]) || [],
                ignoredTokens: ((_b = allIgnoredTokens[chainId]) === null || _b === void 0 ? void 0 : _b[selectedAddress]) || [],
            });
        });
        onNetworkStateChange(({ provider }) => {
            var _a, _b;
            const { allTokens, allIgnoredTokens } = this.state;
            const { selectedAddress } = this.config;
            const { chainId } = provider;
            this.configure({ chainId });
            this.ethersProvider = this._instantiateNewEthersProvider();
            this.update({
                tokens: ((_a = allTokens[chainId]) === null || _a === void 0 ? void 0 : _a[selectedAddress]) || [],
                ignoredTokens: ((_b = allIgnoredTokens[chainId]) === null || _b === void 0 ? void 0 : _b[selectedAddress]) || [],
            });
        });
    }
    failSuggestedAsset(suggestedAssetMeta, error) {
        const failedSuggestedAssetMeta = Object.assign(Object.assign({}, suggestedAssetMeta), { status: SuggestedAssetStatus.failed, error });
        this.hub.emit(`${suggestedAssetMeta.id}:finished`, failedSuggestedAssetMeta);
    }
    _instantiateNewEthersProvider() {
        var _a;
        return new ethers_1.ethers.providers.Web3Provider((_a = this.config) === null || _a === void 0 ? void 0 : _a.provider);
    }
    /**
     * Adds a token to the stored token list
     *
     * @param address - Hex address of the token contract
     * @param symbol - Symbol of the token
     * @param decimals - Number of decimals the token uses
     * @param image - Image of the token
     * @returns - Current token list
     */
    addToken(address, symbol, decimals, image) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                address = util_1.toChecksumHexAddress(address);
                const { tokens, ignoredTokens } = this.state;
                const isERC721 = yield this._detectIsERC721(address);
                const newEntry = { address, symbol, decimals, image, isERC721 };
                const previousEntry = tokens.find((token) => token.address.toLowerCase() === address.toLowerCase());
                if (previousEntry) {
                    const previousIndex = tokens.indexOf(previousEntry);
                    tokens[previousIndex] = newEntry;
                }
                else {
                    tokens.push(newEntry);
                }
                const newIgnoredTokens = ignoredTokens.filter((tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase());
                const { newAllTokens, newAllIgnoredTokens } = this._getNewAllTokensState(tokens, newIgnoredTokens);
                this.update({
                    allTokens: newAllTokens,
                    tokens,
                    allIgnoredTokens: newAllIgnoredTokens,
                    ignoredTokens: newIgnoredTokens,
                });
                return tokens;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Adds a batch of tokens to the stored token list
     *
     * @param tokens - Array of Tokens to be added or updated
     * @returns - Current token list
     */
    addTokens(tokensToAdd) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            const { tokens, ignoredTokens } = this.state;
            try {
                tokensToAdd = yield Promise.all(tokensToAdd.map((token) => __awaiter(this, void 0, void 0, function* () {
                    token.isERC721 = yield this._detectIsERC721(token.address);
                    return token;
                })));
                let newIgnoredTokens = ignoredTokens;
                tokensToAdd.forEach((tokenToAdd) => {
                    const { address, symbol, decimals, image, isERC721 } = tokenToAdd;
                    const checksumAddress = util_1.toChecksumHexAddress(address);
                    const newEntry = {
                        address: checksumAddress,
                        symbol,
                        decimals,
                        image,
                        isERC721,
                    };
                    const previousEntry = tokens.find((token) => token.address.toLowerCase() === checksumAddress.toLowerCase());
                    if (previousEntry) {
                        const previousIndex = tokens.indexOf(previousEntry);
                        tokens[previousIndex] = newEntry;
                    }
                    else {
                        tokens.push(newEntry);
                    }
                    newIgnoredTokens = newIgnoredTokens.filter((tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase());
                });
                const { newAllTokens, newAllIgnoredTokens } = this._getNewAllTokensState(tokens, newIgnoredTokens);
                this.update({
                    tokens,
                    allTokens: newAllTokens,
                    allIgnoredTokens: newAllIgnoredTokens,
                    ignoredTokens: newIgnoredTokens,
                });
                return tokens;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Adds isERC721 field to token object
     * (Called when a user attempts to add tokens that were previously added which do not yet had isERC721 field)
     *
     * @param {string} tokenAddress - The contract address of the token requiring the isERC721 field added.
     * @returns The new token object with the added isERC721 field.
     *
     */
    updateTokenType(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const isERC721 = yield this._detectIsERC721(tokenAddress);
            const { tokens } = this.state;
            const tokenIndex = tokens.findIndex((token) => {
                return token.address.toLowerCase() === tokenAddress.toLowerCase();
            });
            tokens[tokenIndex].isERC721 = isERC721;
            this.update({ tokens });
            return tokens[tokenIndex];
        });
    }
    /**
     * Detects whether or not a token is ERC-721 compatible.
     *
     * @param {string} tokensAddress - the token contract address.
     * @returns boolean indicating whether the token address passed in supports the EIP-721 interface.
     *
     */
    _detectIsERC721(tokenAddress) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const checksumAddress = util_1.toChecksumHexAddress(tokenAddress);
            // if this token is already in our contract metadata map we don't need
            // to check against the contract
            if (((_a = contract_metadata_1.default[checksumAddress]) === null || _a === void 0 ? void 0 : _a.erc721) === true) {
                return Promise.resolve(true);
            }
            else if (((_b = contract_metadata_1.default[checksumAddress]) === null || _b === void 0 ? void 0 : _b.erc20) === true) {
                return Promise.resolve(false);
            }
            const tokenContract = yield this._createEthersContract(tokenAddress, human_standard_collectible_abi_1.default, this.ethersProvider);
            try {
                return yield tokenContract.supportsInterface(ERC721_INTERFACE_ID);
            }
            catch (error) {
                // currently we see a variety of errors across different networks when
                // token contracts are not ERC721 compatible. We need to figure out a better
                // way of differentiating token interface types but for now if we get an error
                // we have to assume the token is not ERC721 compatible.
                return false;
            }
        });
    }
    _createEthersContract(tokenAddress, abi, ethersProvider) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenContract = yield new ethers_1.ethers.Contract(tokenAddress, abi, ethersProvider);
            return tokenContract;
        });
    }
    _generateRandomId() {
        return uuid_1.v1();
    }
    /**
     * Adds a new suggestedAsset to state. Parameters will be validated according to
     * asset type being watched. A `<suggestedAssetMeta.id>:pending` hub event will be emitted once added.
     *
     * @param asset - Asset to be watched. For now only ERC20 tokens are accepted.
     * @param type - Asset type
     * @returns - Object containing a promise resolving to the suggestedAsset address if accepted
     */
    watchAsset(asset, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const suggestedAssetMeta = {
                asset,
                id: this._generateRandomId(),
                status: SuggestedAssetStatus.pending,
                time: Date.now(),
                type,
            };
            try {
                switch (type) {
                    case 'ERC20':
                        util_1.validateTokenToWatch(asset);
                        break;
                    default:
                        throw new Error(`Asset of type ${type} not supported`);
                }
            }
            catch (error) {
                this.failSuggestedAsset(suggestedAssetMeta, error);
                return Promise.reject(error);
            }
            const result = new Promise((resolve, reject) => {
                this.hub.once(`${suggestedAssetMeta.id}:finished`, (meta) => {
                    switch (meta.status) {
                        case SuggestedAssetStatus.accepted:
                            return resolve(meta.asset.address);
                        case SuggestedAssetStatus.rejected:
                            return reject(new Error('User rejected to watch the asset.'));
                        case SuggestedAssetStatus.failed:
                            return reject(new Error(meta.error.message));
                        /* istanbul ignore next */
                        default:
                            return reject(new Error(`Unknown status: ${meta.status}`));
                    }
                });
            });
            const { suggestedAssets } = this.state;
            suggestedAssets.push(suggestedAssetMeta);
            this.update({ suggestedAssets: [...suggestedAssets] });
            this.hub.emit('pendingSuggestedAsset', suggestedAssetMeta);
            return { result, suggestedAssetMeta };
        });
    }
    /**
     * Accepts to watch an asset and updates it's status and deletes the suggestedAsset from state,
     * adding the asset to corresponding asset state. In this case ERC20 tokens.
     * A `<suggestedAssetMeta.id>:finished` hub event is fired after accepted or failure.
     *
     * @param suggestedAssetID - ID of the suggestedAsset to accept
     * @returns - Promise resolving when this operation completes
     */
    acceptWatchAsset(suggestedAssetID) {
        return __awaiter(this, void 0, void 0, function* () {
            const { suggestedAssets } = this.state;
            const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
            const suggestedAssetMeta = suggestedAssets[index];
            try {
                switch (suggestedAssetMeta.type) {
                    case 'ERC20':
                        const { address, symbol, decimals, image } = suggestedAssetMeta.asset;
                        yield this.addToken(address, symbol, decimals, image);
                        suggestedAssetMeta.status = SuggestedAssetStatus.accepted;
                        this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
                        break;
                    default:
                        throw new Error(`Asset of type ${suggestedAssetMeta.type} not supported`);
                }
            }
            catch (error) {
                this.failSuggestedAsset(suggestedAssetMeta, error);
            }
            const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
            this.update({ suggestedAssets: [...newSuggestedAssets] });
        });
    }
    /**
     * Rejects a watchAsset request based on its ID by setting its status to "rejected"
     * and emitting a `<suggestedAssetMeta.id>:finished` hub event.
     *
     * @param suggestedAssetID - ID of the suggestedAsset to accept
     */
    rejectWatchAsset(suggestedAssetID) {
        const { suggestedAssets } = this.state;
        const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
        const suggestedAssetMeta = suggestedAssets[index];
        if (!suggestedAssetMeta) {
            return;
        }
        suggestedAssetMeta.status = SuggestedAssetStatus.rejected;
        this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
        const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
        this.update({ suggestedAssets: [...newSuggestedAssets] });
    }
    /**
     * Removes a token from the stored token list and saves it in ignored tokens list
     *
     * @param address - Hex address of the token contract
     */
    removeAndIgnoreToken(address) {
        address = util_1.toChecksumHexAddress(address);
        const { tokens, ignoredTokens } = this.state;
        const alreadyIgnored = ignoredTokens.find((tokenAddress) => tokenAddress.toLowerCase() === address.toLowerCase());
        const newTokens = tokens.filter((token) => {
            if (token.address.toLowerCase() === address.toLowerCase()) {
                !alreadyIgnored && ignoredTokens.push(address);
                return false;
            }
            return true;
        });
        const { newAllTokens, newAllIgnoredTokens } = this._getNewAllTokensState(newTokens, ignoredTokens);
        this.update({
            allTokens: newAllTokens,
            tokens: newTokens,
            allIgnoredTokens: newAllIgnoredTokens,
            ignoredTokens,
        });
    }
    /**
     * Takes a new tokens and ignoredTokens array for the current network/account combination
     * and returns new allTokens and allIgnoredTokens state to update to.
     *
     * @param newTokens - The new tokens to set for the current network and selected account.
     * @param newIgnoredTokens - The new ignored tokens to set for the current network and selected account.
     * @returns The updated `allTokens` and `allIgnoredTokens` state.
     */
    _getNewAllTokensState(newTokens, newIgnoredTokens) {
        const { allTokens, allIgnoredTokens } = this.state;
        const { chainId, selectedAddress } = this.config;
        const networkTokens = allTokens[chainId];
        const networkIgnoredTokens = allIgnoredTokens[chainId];
        const newNetworkTokens = Object.assign(Object.assign({}, networkTokens), { [selectedAddress]: newTokens });
        const newIgnoredNetworkTokens = Object.assign(Object.assign({}, networkIgnoredTokens), { [selectedAddress]: newIgnoredTokens });
        const newAllTokens = Object.assign(Object.assign({}, allTokens), { [chainId]: newNetworkTokens });
        const newAllIgnoredTokens = Object.assign(Object.assign({}, allIgnoredTokens), { [chainId]: newIgnoredNetworkTokens });
        return { newAllTokens, newAllIgnoredTokens };
    }
    /**
     * Removes all tokens from the ignored list
     */
    clearIgnoredTokens() {
        this.update({ ignoredTokens: [], allIgnoredTokens: {} });
    }
}
exports.TokensController = TokensController;
exports.default = TokensController;
//# sourceMappingURL=TokensController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/assets/TokensController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/network/NetworkController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js","../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/constants.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js","eth-json-rpc-infura/src/createProvider":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-infura/src/createProvider.js","eth-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-query/index.js","web3-provider-engine/subproviders/provider":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/web3-provider-engine/subproviders/provider.js","web3-provider-engine/zero":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/web3-provider-engine/zero.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/network/NetworkController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkController = exports.NetworksChainId = void 0;
const eth_query_1 = __importDefault(require("eth-query"));
const provider_1 = __importDefault(require("web3-provider-engine/subproviders/provider"));
const createProvider_1 = __importDefault(require("eth-json-rpc-infura/src/createProvider"));
const zero_1 = __importDefault(require("web3-provider-engine/zero"));
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const constants_1 = require("../constants");
var NetworksChainId;
(function (NetworksChainId) {
    NetworksChainId["mainnet"] = "1";
    NetworksChainId["kovan"] = "42";
    NetworksChainId["rinkeby"] = "4";
    NetworksChainId["goerli"] = "5";
    NetworksChainId["ropsten"] = "3";
    NetworksChainId["localhost"] = "";
    NetworksChainId["rpc"] = "";
    NetworksChainId["optimism"] = "10";
    NetworksChainId["optimismTest"] = "69";
})(NetworksChainId = exports.NetworksChainId || (exports.NetworksChainId = {}));
const LOCALHOST_RPC_URL = 'http://localhost:8545';
/**
 * Controller that creates and manages an Ethereum network provider
 */
class NetworkController extends BaseController_1.BaseController {
    /**
     * Creates a NetworkController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        this.internalProviderConfig = {};
        this.mutex = new async_mutex_1.Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'NetworkController';
        this.defaultState = {
            network: 'loading',
            isCustomNetwork: false,
            provider: { type: constants_1.MAINNET, chainId: NetworksChainId.mainnet },
            properties: { isEIP1559Compatible: false },
        };
        this.initialize();
        this.getEIP1559Compatibility();
    }
    initializeProvider(type, rpcTarget, chainId, ticker, nickname) {
        this.update({ isCustomNetwork: this.getIsCustomNetwork(chainId) });
        switch (type) {
            case 'kovan':
            case constants_1.MAINNET:
            case 'rinkeby':
            case 'goerli':
            case 'optimism':
            case 'optimismTest':
            case 'ropsten':
                this.setupInfuraProvider(type);
                break;
            case 'localhost':
                this.setupStandardProvider(LOCALHOST_RPC_URL);
                break;
            case constants_1.RPC:
                rpcTarget &&
                    this.setupStandardProvider(rpcTarget, chainId, ticker, nickname);
                break;
            default:
                throw new Error(`Unrecognized network type: '${type}'`);
        }
    }
    refreshNetwork() {
        this.update({ network: 'loading', properties: {} });
        const { rpcTarget, type, chainId, ticker } = this.state.provider;
        this.initializeProvider(type, rpcTarget, chainId, ticker);
        this.lookupNetwork();
    }
    registerProvider() {
        this.provider.on('error', this.verifyNetwork.bind(this));
        this.ethQuery = new eth_query_1.default(this.provider);
    }
    setupInfuraProvider(type) {
        const infuraProvider = createProvider_1.default({
            network: type,
            projectId: this.config.infuraProjectId,
        });
        const infuraSubprovider = new provider_1.default(infuraProvider);
        const config = Object.assign(Object.assign({}, this.internalProviderConfig), {
            dataSubprovider: infuraSubprovider,
            engineParams: {
                blockTrackerProvider: infuraProvider,
                pollingInterval: 12000,
            },
        });
        this.updateProvider(zero_1.default(config));
    }
    getIsCustomNetwork(chainId) {
        return (chainId !== NetworksChainId.mainnet &&
            chainId !== NetworksChainId.kovan &&
            chainId !== NetworksChainId.rinkeby &&
            chainId !== NetworksChainId.goerli &&
            chainId !== NetworksChainId.ropsten &&
            chainId !== NetworksChainId.localhost);
    }
    setupStandardProvider(rpcTarget, chainId, ticker, nickname) {
        const config = Object.assign(Object.assign({}, this.internalProviderConfig), {
            chainId,
            engineParams: { pollingInterval: 12000 },
            nickname,
            rpcUrl: rpcTarget,
            ticker,
        });
        this.updateProvider(zero_1.default(config));
    }
    updateProvider(provider) {
        this.safelyStopProvider(this.provider);
        this.provider = provider;
        this.registerProvider();
    }
    safelyStopProvider(provider) {
        setTimeout(() => {
            provider === null || provider === void 0 ? void 0 : provider.stop();
        }, 500);
    }
    verifyNetwork() {
        this.state.network === 'loading' && this.lookupNetwork();
    }
    /**
     * Sets a new configuration for web3-provider-engine
     *
     * TODO: Replace this wth a method
     *
     * @param providerConfig - web3-provider-engine configuration
     */
    set providerConfig(providerConfig) {
        this.internalProviderConfig = providerConfig;
        const { type, rpcTarget, chainId, ticker, nickname } = this.state.provider;
        this.initializeProvider(type, rpcTarget, chainId, ticker, nickname);
        this.registerProvider();
        this.lookupNetwork();
    }
    get providerConfig() {
        throw new Error('Property only used for setting');
    }
    /**
     * Refreshes the current network code
     */
    lookupNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.ethQuery || !this.ethQuery.sendAsync) {
                return;
            }
            const releaseLock = yield this.mutex.acquire();
            this.ethQuery.sendAsync({ method: 'net_version' }, (error, network) => {
                this.update({
                    network: error ? /* istanbul ignore next*/ 'loading' : network,
                });
                releaseLock();
            });
        });
    }
    /**
     * Convenience method to update provider network type settings
     *
     * @param type - Human readable network name
     */
    setProviderType(type) {
        const _a = this.state.provider, { rpcTarget, chainId, nickname } = _a, providerState = __rest(_a, ["rpcTarget", "chainId", "nickname"]);
        this.update({
            provider: Object.assign(Object.assign({}, providerState), { type, ticker: 'ETH', chainId: NetworksChainId[type] }),
        });
        this.refreshNetwork();
    }
    /**
     * Convenience method to update provider RPC settings
     *
     * @param rpcTarget - RPC endpoint URL
     * @param chainId - Network ID as per EIP-155
     * @param ticker? - Currency ticker
     * @param nickname? - Personalized network name
     */
    setRpcTarget(rpcTarget, chainId, ticker, nickname) {
        this.update({
            provider: Object.assign(Object.assign({}, this.state.provider), { type: constants_1.RPC, ticker, rpcTarget, chainId, nickname }),
        });
        this.refreshNetwork();
    }
    getEIP1559Compatibility() {
        var _a;
        const { properties = {} } = this.state;
        if (!properties.isEIP1559Compatible) {
            if (typeof ((_a = this.ethQuery) === null || _a === void 0 ? void 0 : _a.sendAsync) !== 'function') {
                return Promise.resolve(true);
            }
            return new Promise((resolve, reject) => {
                this.ethQuery.sendAsync({ method: 'eth_getBlockByNumber', params: ['latest', false] }, (error, block) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        const isEIP1559Compatible = typeof block.baseFeePerGas !== 'undefined';
                        if (properties.isEIP1559Compatible !== isEIP1559Compatible) {
                            this.update({
                                properties: {
                                    isEIP1559Compatible,
                                },
                            });
                        }
                        resolve(isEIP1559Compatible);
                    }
                });
            });
        }
        return Promise.resolve(true);
    }
}
exports.NetworkController = NetworkController;
exports.default = NetworkController;
//# sourceMappingURL=NetworkController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/network/NetworkController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/third-party/PhishingController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js","eth-phishing-detect/src/config.json":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-phishing-detect/src/config.json","eth-phishing-detect/src/detector":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-phishing-detect/src/detector.js","punycode/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/punycode/punycode.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/third-party/PhishingController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PhishingController = void 0;
const punycode_1 = require("punycode/");
const config_json_1 = __importDefault(require("eth-phishing-detect/src/config.json"));
const detector_1 = __importDefault(require("eth-phishing-detect/src/detector"));
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that passively polls on a set interval for approved and unapproved website origins
 */
class PhishingController extends BaseController_1.BaseController {
    /**
     * Creates a PhishingController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        this.configUrl = 'https://cdn.jsdelivr.net/gh/MetaMask/eth-phishing-detect@master/src/config.json';
        /**
         * Name of this controller used during composition
         */
        this.name = 'PhishingController';
        this.defaultConfig = { interval: 60 * 60 * 1000 };
        this.defaultState = {
            phishing: config_json_1.default,
            whitelist: [],
        };
        this.detector = new detector_1.default(this.defaultState.phishing);
        this.initialize();
        this.poll();
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval used to fetch new approval lists
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.updatePhishingLists());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Determines if a given origin is unapproved
     *
     * @param origin - Domain origin of a website
     * @returns - True if the origin is an unapproved origin
     */
    test(origin) {
        const punycodeOrigin = punycode_1.toASCII(origin);
        if (this.state.whitelist.indexOf(punycodeOrigin) !== -1) {
            return false;
        }
        return this.detector.check(punycodeOrigin).result;
    }
    /**
     * Temporarily marks a given origin as approved
     */
    bypass(origin) {
        const punycodeOrigin = punycode_1.toASCII(origin);
        const { whitelist } = this.state;
        if (whitelist.indexOf(punycodeOrigin) !== -1) {
            return;
        }
        this.update({ whitelist: [...whitelist, punycodeOrigin] });
    }
    /**
     * Updates lists of approved and unapproved website origins
     *
     * @returns Promise resolving when this operation completes
     */
    updatePhishingLists() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.disabled) {
                return;
            }
            const phishingOpts = yield this.queryConfig(this.configUrl);
            if (phishingOpts) {
                this.detector = new detector_1.default(phishingOpts);
                this.update({
                    phishing: phishingOpts,
                });
            }
        });
    }
    queryConfig(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(input, { cache: 'no-cache' });
            switch (response.status) {
                case 200: {
                    return yield response.json();
                }
                case 304:
                case 403: {
                    return null;
                }
                default: {
                    throw new Error(`Fetch failed with status '${response.status}' for request '${input}'`);
                }
            }
        });
    }
}
exports.PhishingController = PhishingController;
exports.default = PhishingController;
//# sourceMappingURL=PhishingController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/third-party/PhishingController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/keyring/KeyringController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js","eth-keyring-controller":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-keyring-controller/index.js","eth-sig-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-sig-util/dist/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","ethereumjs-wallet":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/ethereumjs-wallet/dist/index.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/ethjs-util/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/keyring/KeyringController.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyringController = exports.SignTypedDataVersion = exports.AccountImportStrategy = exports.KeyringTypes = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const ethjs_util_1 = require("ethjs-util");
const eth_sig_util_1 = require("eth-sig-util");
const ethereumjs_wallet_1 = __importStar(require("ethereumjs-wallet"));
const eth_keyring_controller_1 = __importDefault(require("eth-keyring-controller"));
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const privates = new WeakMap();
/**
 * Available keyring types
 */
var KeyringTypes;
(function (KeyringTypes) {
    KeyringTypes["simple"] = "Simple Key Pair";
    KeyringTypes["hd"] = "HD Key Tree";
})(KeyringTypes = exports.KeyringTypes || (exports.KeyringTypes = {}));
/**
 * A strategy for importing an account
 */
var AccountImportStrategy;
(function (AccountImportStrategy) {
    AccountImportStrategy["privateKey"] = "privateKey";
    AccountImportStrategy["json"] = "json";
})(AccountImportStrategy = exports.AccountImportStrategy || (exports.AccountImportStrategy = {}));
/**
 * The `signTypedMessage` version
 * @see https://docs.metamask.io/guide/signing-data.html
 */
var SignTypedDataVersion;
(function (SignTypedDataVersion) {
    SignTypedDataVersion["V1"] = "V1";
    SignTypedDataVersion["V3"] = "V3";
    SignTypedDataVersion["V4"] = "V4";
})(SignTypedDataVersion = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));
/**
 * Controller responsible for establishing and managing user identity
 */
class KeyringController extends BaseController_1.BaseController {
    /**
     * Creates a KeyringController instance
     *
     * @param options
     * @param options.removeIdentity - Remove the identity with the given address
     * @param options.syncIdentities - Sync identities with the given list of addresses
     * @param options.updateIdentities - Generate an identity for each address given that doesn't already have an identity
     * @param options.setSelectedAddress - Set the selected address
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ removeIdentity, syncIdentities, updateIdentities, setSelectedAddress, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'KeyringController';
        privates.set(this, {
            keyring: new eth_keyring_controller_1.default(Object.assign({ initState: state }, config)),
        });
        this.defaultState = Object.assign(Object.assign({}, privates.get(this).keyring.store.getState()), { keyrings: [] });
        this.removeIdentity = removeIdentity;
        this.syncIdentities = syncIdentities;
        this.updateIdentities = updateIdentities;
        this.setSelectedAddress = setSelectedAddress;
        this.initialize();
        this.fullUpdate();
    }
    /**
     * Adds a new account to the default (first) HD seed phrase keyring
     *
     * @returns - Promise resolving to current state when the account is added
     */
    addNewAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyring = privates
                .get(this)
                .keyring.getKeyringsByType('HD Key Tree')[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found');
            }
            const oldAccounts = yield privates.get(this).keyring.getAccounts();
            yield privates.get(this).keyring.addNewAccount(primaryKeyring);
            const newAccounts = yield privates.get(this).keyring.getAccounts();
            yield this.verifySeedPhrase();
            this.updateIdentities(newAccounts);
            newAccounts.forEach((selectedAddress) => {
                if (!oldAccounts.includes(selectedAddress)) {
                    this.setSelectedAddress(selectedAddress);
                }
            });
            return this.fullUpdate();
        });
    }
    /**
     * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences
     *
     * @returns - Promise resolving to current state when the account is added
     */
    addNewAccountWithoutUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyring = privates
                .get(this)
                .keyring.getKeyringsByType('HD Key Tree')[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found');
            }
            yield privates.get(this).keyring.addNewAccount(primaryKeyring);
            yield this.verifySeedPhrase();
            return this.fullUpdate();
        });
    }
    /**
     * Effectively the same as creating a new keychain then populating it
     * using the given seed phrase
     *
     * @param password - Password to unlock keychain
     * @param seed - Seed phrase to restore keychain
     * @returns - Promise resolving to th restored keychain object
     */
    createNewVaultAndRestore(password, seed) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                this.updateIdentities([]);
                const vault = yield privates
                    .get(this)
                    .keyring.createNewVaultAndRestore(password, seed);
                this.updateIdentities(yield privates.get(this).keyring.getAccounts());
                this.fullUpdate();
                return vault;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Create a new primary keychain and wipe any previous keychains
     *
     * @param password - Password to unlock the new vault
     * @returns - Newly-created keychain object
     */
    createNewVaultAndKeychain(password) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const vault = yield privates
                    .get(this)
                    .keyring.createNewVaultAndKeychain(password);
                this.updateIdentities(yield privates.get(this).keyring.getAccounts());
                this.fullUpdate();
                return vault;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Returns the status of the vault
     *
     * @returns - Boolean returning true if the vault is unlocked
     */
    isUnlocked() {
        return privates.get(this).keyring.memStore.getState().isUnlocked;
    }
    /**
     * Gets the seed phrase of the HD keyring
     *
     * @param password - Password of the keyring
     * @returns - Promise resolving to the seed phrase
     */
    exportSeedPhrase(password) {
        if (privates.get(this).keyring.password === password) {
            return privates.get(this).keyring.keyrings[0].mnemonic;
        }
        throw new Error('Invalid password');
    }
    /**
     * Gets the private key from the keyring controlling an address
     *
     * @param password - Password of the keyring
     * @param address - Address to export
     * @returns - Promise resolving to the private key for an address
     */
    exportAccount(password, address) {
        if (privates.get(this).keyring.password === password) {
            return privates.get(this).keyring.exportAccount(address);
        }
        throw new Error('Invalid password');
    }
    /**
     * Returns the public addresses of all accounts for the current keyring
     *
     * @returns - A promise resolving to an array of addresses
     */
    getAccounts() {
        return privates.get(this).keyring.getAccounts();
    }
    /**
     * Imports an account with the specified import strategy
     *
     * @param strategy - Import strategy name
     * @param args - Array of arguments to pass to the underlying stategy
     * @throws Will throw when passed an unrecognized strategy
     * @returns - Promise resolving to current state when the import is complete
     */
    importAccountWithStrategy(strategy, args) {
        return __awaiter(this, void 0, void 0, function* () {
            let privateKey;
            switch (strategy) {
                case 'privateKey':
                    const [importedKey] = args;
                    if (!importedKey) {
                        throw new Error('Cannot import an empty key.');
                    }
                    const prefixed = ethereumjs_util_1.addHexPrefix(importedKey);
                    /* istanbul ignore if */
                    if (!ethereumjs_util_1.isValidPrivate(ethereumjs_util_1.toBuffer(prefixed))) {
                        throw new Error('Cannot import invalid private key.');
                    }
                    privateKey = ethjs_util_1.stripHexPrefix(prefixed);
                    break;
                case 'json':
                    let wallet;
                    const [input, password] = args;
                    try {
                        wallet = ethereumjs_wallet_1.thirdparty.fromEtherWallet(input, password);
                    }
                    catch (e) {
                        wallet = wallet || (yield ethereumjs_wallet_1.default.fromV3(input, password, true));
                    }
                    privateKey = ethereumjs_util_1.bufferToHex(wallet.getPrivateKey());
                    break;
                default:
                    throw new Error(`Unexpected import strategy: '${strategy}'`);
            }
            const newKeyring = yield privates
                .get(this)
                .keyring.addNewKeyring(KeyringTypes.simple, [privateKey]);
            const accounts = yield newKeyring.getAccounts();
            const allAccounts = yield privates.get(this).keyring.getAccounts();
            this.updateIdentities(allAccounts);
            this.setSelectedAddress(accounts[0]);
            return this.fullUpdate();
        });
    }
    /**
     * Removes an account from keyring state
     *
     * @param address - Address of the account to remove
     * @returns - Promise resolving current state when this account removal completes
     */
    removeAccount(address) {
        return __awaiter(this, void 0, void 0, function* () {
            this.removeIdentity(address);
            yield privates.get(this).keyring.removeAccount(address);
            return this.fullUpdate();
        });
    }
    /**
     * Deallocates all secrets and locks the wallet
     *
     * @returns - Promise resolving to current state
     */
    setLocked() {
        return privates.get(this).keyring.setLocked();
    }
    /**
     * Signs message by calling down into a specific keyring
     *
     * @param messageParams - PersonalMessageParams object to sign
     * @returns - Promise resolving to a signed message string
     */
    signMessage(messageParams) {
        return privates.get(this).keyring.signMessage(messageParams);
    }
    /**
     * Signs personal message by calling down into a specific keyring
     *
     * @param messageParams - PersonalMessageParams object to sign
     * @returns - Promise resolving to a signed message string
     */
    signPersonalMessage(messageParams) {
        return privates.get(this).keyring.signPersonalMessage(messageParams);
    }
    /**
     * Signs typed message by calling down into a specific keyring
     *
     * @param messageParams - TypedMessageParams object to sign
     * @param version - Compatibility version EIP712
     * @throws Will throw when passed an unrecognized version
     * @returns - Promise resolving to a signed message string or an error if any
     */
    signTypedMessage(messageParams, version) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const address = eth_sig_util_1.normalize(messageParams.from);
                const { password } = privates.get(this).keyring;
                const privateKey = yield this.exportAccount(password, address);
                const privateKeyBuffer = ethereumjs_util_1.toBuffer(ethereumjs_util_1.addHexPrefix(privateKey));
                switch (version) {
                    case SignTypedDataVersion.V1:
                        // signTypedDataLegacy will throw if the data is invalid.
                        return eth_sig_util_1.signTypedDataLegacy(privateKeyBuffer, {
                            data: messageParams.data,
                        });
                    case SignTypedDataVersion.V3:
                        return eth_sig_util_1.signTypedData(privateKeyBuffer, {
                            data: JSON.parse(messageParams.data),
                        });
                    case SignTypedDataVersion.V4:
                        return eth_sig_util_1.signTypedData_v4(privateKeyBuffer, {
                            data: JSON.parse(messageParams.data),
                        });
                    default:
                        throw new Error(`Unexpected signTypedMessage version: '${version}'`);
                }
            }
            catch (error) {
                throw new Error(`Keyring Controller signTypedMessage: ${error}`);
            }
        });
    }
    /**
     * Signs a transaction by calling down into a specific keyring
     *
     * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.
     * @param from - Address to sign from, should be in keychain
     * @returns - Promise resolving to a signed transaction string
     */
    signTransaction(transaction, from) {
        return privates.get(this).keyring.signTransaction(transaction, from);
    }
    /**
     * Attempts to decrypt the current vault and load its keyrings
     *
     * @param password - Password to unlock the keychain
     * @returns - Promise resolving to the current state
     */
    submitPassword(password) {
        return __awaiter(this, void 0, void 0, function* () {
            yield privates.get(this).keyring.submitPassword(password);
            const accounts = yield privates.get(this).keyring.getAccounts();
            yield this.syncIdentities(accounts);
            return this.fullUpdate();
        });
    }
    /**
     * Adds new listener to be notified of state changes
     *
     * @param listener - Callback triggered when state changes
     */
    subscribe(listener) {
        privates.get(this).keyring.store.subscribe(listener);
    }
    /**
     * Removes existing listener from receiving state changes
     *
     * @param listener - Callback to remove
     * @returns - True if a listener is found and unsubscribed
     */
    unsubscribe(listener) {
        return privates.get(this).keyring.store.unsubscribe(listener);
    }
    /**
     * Adds new listener to be notified when the wallet is locked
     *
     * @param listener - Callback triggered when wallet is locked
     * @returns - EventEmitter if listener added
     */
    onLock(listener) {
        return privates.get(this).keyring.on('lock', listener);
    }
    /**
     * Adds new listener to be notified when the wallet is unlocked
     *
     * @param listener - Callback triggered when wallet is unlocked
     * @returns - EventEmitter if listener added
     */
    onUnlock(listener) {
        return privates.get(this).keyring.on('unlock', listener);
    }
    /**
     * Verifies the that the seed phrase restores the current keychain's accounts
     *
     * @returns - Promise resolving if the verification succeeds
     */
    verifySeedPhrase() {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyring = privates
                .get(this)
                .keyring.getKeyringsByType(KeyringTypes.hd)[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found.');
            }
            const seedWords = (yield primaryKeyring.serialize()).mnemonic;
            const accounts = yield primaryKeyring.getAccounts();
            /* istanbul ignore if */
            if (accounts.length === 0) {
                throw new Error('Cannot verify an empty keyring.');
            }
            const TestKeyringClass = privates
                .get(this)
                .keyring.getKeyringClassForType(KeyringTypes.hd);
            const testKeyring = new TestKeyringClass({
                mnemonic: seedWords,
                numberOfAccounts: accounts.length,
            });
            const testAccounts = yield testKeyring.getAccounts();
            /* istanbul ignore if */
            if (testAccounts.length !== accounts.length) {
                throw new Error('Seed phrase imported incorrect number of accounts.');
            }
            testAccounts.forEach((account, i) => {
                /* istanbul ignore if */
                if (account.toLowerCase() !== accounts[i].toLowerCase()) {
                    throw new Error('Seed phrase imported different accounts.');
                }
            });
            return seedWords;
        });
    }
    /**
     * Update keyrings in state and calls KeyringController fullUpdate method returning current state
     *
     * @returns - Promise resolving to current state
     */
    fullUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            const keyrings = yield Promise.all(privates.get(this).keyring.keyrings.map((keyring, index) => __awaiter(this, void 0, void 0, function* () {
                const keyringAccounts = yield keyring.getAccounts();
                const accounts = Array.isArray(keyringAccounts)
                    ? keyringAccounts.map((address) => util_1.toChecksumHexAddress(address))
                    : /* istanbul ignore next */ [];
                return {
                    accounts,
                    index,
                    type: keyring.type,
                };
            })));
            this.update({ keyrings: [...keyrings] });
            return privates.get(this).keyring.fullUpdate();
        });
    }
}
exports.KeyringController = KeyringController;
exports.default = KeyringController;
//# sourceMappingURL=KeyringController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/keyring/KeyringController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/transaction/TransactionController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/BaseController.js","../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/constants.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/util.js","@ethereumjs/common":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ethereumjs/common/dist.browser/index.js","@ethereumjs/tx":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ethereumjs/tx/dist.browser/index.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js","eth-method-registry":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/eth-method-registry/index.js","eth-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-query/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/transaction/TransactionController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionController = exports.SPEED_UP_RATE = exports.CANCEL_RATE = exports.WalletDevice = exports.TransactionStatus = void 0;
const events_1 = require("events");
const ethereumjs_util_1 = require("ethereumjs-util");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const eth_method_registry_1 = __importDefault(require("eth-method-registry"));
const eth_query_1 = __importDefault(require("eth-query"));
const common_1 = __importDefault(require("@ethereumjs/common"));
const tx_1 = require("@ethereumjs/tx");
const uuid_1 = require("uuid");
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const HARDFORK = 'london';
/**
 * The status of the transaction. Each status represents the state of the transaction internally
 * in the wallet. Some of these correspond with the state of the transaction on the network, but
 * some are wallet-specific.
 */
var TransactionStatus;
(function (TransactionStatus) {
    TransactionStatus["approved"] = "approved";
    TransactionStatus["cancelled"] = "cancelled";
    TransactionStatus["confirmed"] = "confirmed";
    TransactionStatus["failed"] = "failed";
    TransactionStatus["rejected"] = "rejected";
    TransactionStatus["signed"] = "signed";
    TransactionStatus["submitted"] = "submitted";
    TransactionStatus["unapproved"] = "unapproved";
})(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));
/**
 * Options for wallet device.
 */
var WalletDevice;
(function (WalletDevice) {
    WalletDevice["MM_MOBILE"] = "metamask_mobile";
    WalletDevice["MM_EXTENSION"] = "metamask_extension";
    WalletDevice["OTHER"] = "other_device";
})(WalletDevice = exports.WalletDevice || (exports.WalletDevice = {}));
/**
 * Multiplier used to determine a transaction's increased gas fee during cancellation
 */
exports.CANCEL_RATE = 1.5;
/**
 * Multiplier used to determine a transaction's increased gas fee during speed up
 */
exports.SPEED_UP_RATE = 1.1;
/**
 * Controller responsible for submitting and managing transactions
 */
class TransactionController extends BaseController_1.BaseController {
    /**
     * Creates a TransactionController instance
     *
     * @param options
     * @param options.getNetworkState - Gets the state of the network controller
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes
     * @param options.getProvider - Returns a provider for the current network
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ getNetworkState, onNetworkStateChange, getProvider, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        this.normalizeTokenTx = (txMeta, currentNetworkID, currentChainId) => {
            const time = parseInt(txMeta.timeStamp, 10) * 1000;
            const { to, from, gas, gasPrice, gasUsed, hash, contractAddress, tokenDecimal, tokenSymbol, value, } = txMeta;
            return {
                id: uuid_1.v1({ msecs: time }),
                isTransfer: true,
                networkID: currentNetworkID,
                chainId: currentChainId,
                status: TransactionStatus.confirmed,
                time,
                transaction: {
                    chainId: 1,
                    from,
                    gas,
                    gasPrice,
                    gasUsed,
                    to,
                    value,
                },
                transactionHash: hash,
                transferInformation: {
                    contractAddress,
                    decimals: Number(tokenDecimal),
                    symbol: tokenSymbol,
                },
                verifiedOnBlockchain: false,
            };
        };
        /**
         * EventEmitter instance used to listen to specific transactional events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'TransactionController';
        this.defaultConfig = {
            interval: 15000,
            txHistoryLimit: 40,
        };
        this.defaultState = {
            methodData: {},
            transactions: [],
        };
        this.initialize();
        const provider = getProvider();
        this.getNetworkState = getNetworkState;
        this.ethQuery = new eth_query_1.default(provider);
        this.registry = new eth_method_registry_1.default({ provider });
        onNetworkStateChange(() => {
            const newProvider = getProvider();
            this.ethQuery = new eth_query_1.default(newProvider);
            this.registry = new eth_method_registry_1.default({ provider: newProvider });
        });
        this.poll();
    }
    failTransaction(transactionMeta, error) {
        const newTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { error, status: TransactionStatus.failed });
        this.updateTransaction(newTransactionMeta);
        this.hub.emit(`${transactionMeta.id}:finished`, newTransactionMeta);
    }
    registryLookup(fourBytePrefix) {
        return __awaiter(this, void 0, void 0, function* () {
            const registryMethod = yield this.registry.lookup(fourBytePrefix);
            const parsedRegistryMethod = this.registry.parse(registryMethod);
            return { registryMethod, parsedRegistryMethod };
        });
    }
    /**
     * Normalizes the transaction information from etherscan
     * to be compatible with the TransactionMeta interface
     *
     * @param txMeta - Object containing the transaction information
     * @param currentNetworkID - string representing the current network id
     * @param currentChainId - string representing the current chain id
     * @returns - TransactionMeta
     */
    normalizeTx(txMeta, currentNetworkID, currentChainId) {
        const time = parseInt(txMeta.timeStamp, 10) * 1000;
        const normalizedTransactionBase = {
            blockNumber: txMeta.blockNumber,
            id: uuid_1.v1({ msecs: time }),
            networkID: currentNetworkID,
            chainId: currentChainId,
            time,
            transaction: {
                data: txMeta.input,
                from: txMeta.from,
                gas: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.gas)),
                gasPrice: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.gasPrice)),
                gasUsed: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.gasUsed)),
                nonce: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.nonce)),
                to: txMeta.to,
                value: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.value)),
            },
            transactionHash: txMeta.hash,
            verifiedOnBlockchain: false,
        };
        /* istanbul ignore else */
        if (txMeta.isError === '0') {
            return Object.assign(Object.assign({}, normalizedTransactionBase), { status: TransactionStatus.confirmed });
        }
        /* istanbul ignore next */
        return Object.assign(Object.assign({}, normalizedTransactionBase), { error: new Error('Transaction failed'), status: TransactionStatus.failed });
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval used to fetch new transaction statuses
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.queryTransactionStatuses());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Handle new method data request
     *
     * @param fourBytePrefix - String corresponding to method prefix
     * @returns - Promise resolving to method data object corresponding to signature prefix
     */
    handleMethodData(fourBytePrefix) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const { methodData } = this.state;
                const knownMethod = Object.keys(methodData).find((knownFourBytePrefix) => fourBytePrefix === knownFourBytePrefix);
                if (knownMethod) {
                    return methodData[fourBytePrefix];
                }
                const registry = yield this.registryLookup(fourBytePrefix);
                this.update({
                    methodData: Object.assign(Object.assign({}, methodData), { [fourBytePrefix]: registry }),
                });
                return registry;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Add a new unapproved transaction to state. Parameters will be validated, a
     * unique transaction id will be generated, and gas and gasPrice will be calculated
     * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.
     *
     * @param transaction - Transaction object to add
     * @param origin - Domain origin to append to the generated TransactionMeta
     * @param deviceConfirmedOn - enum to indicate what device the transaction was confirmed to append to the generated TransactionMeta
     * @returns - Object containing a promise resolving to the transaction hash if approved
     */
    addTransaction(transaction, origin, deviceConfirmedOn) {
        return __awaiter(this, void 0, void 0, function* () {
            const { provider, network } = this.getNetworkState();
            const { transactions } = this.state;
            transaction = util_1.normalizeTransaction(transaction);
            util_1.validateTransaction(transaction);
            const transactionMeta = {
                id: uuid_1.v1(),
                networkID: network,
                chainId: provider.chainId,
                origin,
                status: TransactionStatus.unapproved,
                time: Date.now(),
                transaction,
                deviceConfirmedOn,
                verifiedOnBlockchain: false,
            };
            try {
                const { gas } = yield this.estimateGas(transaction);
                transaction.gas = gas;
            }
            catch (error) {
                this.failTransaction(transactionMeta, error);
                return Promise.reject(error);
            }
            const result = new Promise((resolve, reject) => {
                this.hub.once(`${transactionMeta.id}:finished`, (meta) => {
                    switch (meta.status) {
                        case TransactionStatus.submitted:
                            return resolve(meta.transactionHash);
                        case TransactionStatus.rejected:
                            return reject(eth_rpc_errors_1.ethErrors.provider.userRejectedRequest('User rejected the transaction'));
                        case TransactionStatus.cancelled:
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal('User cancelled the transaction'));
                        case TransactionStatus.failed:
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal(meta.error.message));
                        /* istanbul ignore next */
                        default:
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal(`MetaMask Tx Signature: Unknown problem: ${JSON.stringify(meta)}`));
                    }
                });
            });
            transactions.push(transactionMeta);
            this.update({ transactions: this.trimTransactionsForState(transactions) });
            this.hub.emit(`unapprovedTransaction`, transactionMeta);
            return { result, transactionMeta };
        });
    }
    prepareUnsignedEthTx(txParams) {
        return tx_1.TransactionFactory.fromTxData(txParams, {
            common: this.getCommonConfiguration(),
            freeze: false,
        });
    }
    /**
     * @ethereumjs/tx uses @ethereumjs/common as a configuration tool for
     * specifying which chain, network, hardfork and EIPs to support for
     * a transaction. By referencing this configuration, and analyzing the fields
     * specified in txParams, @ethereumjs/tx is able to determine which EIP-2718
     * transaction type to use.
     * @returns {Common} common configuration object
     */
    getCommonConfiguration() {
        const { network: networkId, provider: { type: chain, chainId, nickname: name }, } = this.getNetworkState();
        if (chain !== constants_1.RPC) {
            return new common_1.default({ chain, hardfork: HARDFORK });
        }
        const customChainParams = {
            name,
            chainId: parseInt(chainId, undefined),
            networkId: parseInt(networkId, undefined),
        };
        return common_1.default.forCustomChain(constants_1.MAINNET, customChainParams, HARDFORK);
    }
    /**
     * Approves a transaction and updates it's status in state. If this is not a
     * retry transaction, a nonce will be generated. The transaction is signed
     * using the sign configuration property, then published to the blockchain.
     * A `<tx.id>:finished` hub event is fired after success or failure.
     *
     * @param transactionID - ID of the transaction to approve
     * @returns - Promise resolving when this operation completes
     */
    approveTransaction(transactionID) {
        return __awaiter(this, void 0, void 0, function* () {
            const { transactions } = this.state;
            const releaseLock = yield this.mutex.acquire();
            const { provider } = this.getNetworkState();
            const { chainId: currentChainId } = provider;
            const index = transactions.findIndex(({ id }) => transactionID === id);
            const transactionMeta = transactions[index];
            const { nonce } = transactionMeta.transaction;
            try {
                const { from } = transactionMeta.transaction;
                if (!this.sign) {
                    releaseLock();
                    this.failTransaction(transactionMeta, new Error('No sign method defined.'));
                    return;
                }
                else if (!currentChainId) {
                    releaseLock();
                    this.failTransaction(transactionMeta, new Error('No chainId defined.'));
                    return;
                }
                const chainId = parseInt(currentChainId, undefined);
                const { approved: status } = TransactionStatus;
                const txNonce = nonce ||
                    (yield util_1.query(this.ethQuery, 'getTransactionCount', [from, 'pending']));
                transactionMeta.status = status;
                transactionMeta.transaction.nonce = txNonce;
                transactionMeta.transaction.chainId = chainId;
                const baseTxParams = Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas, chainId, nonce: txNonce, status });
                const isEIP1559 = util_1.isEIP1559Transaction(transactionMeta.transaction);
                const txParams = isEIP1559
                    ? Object.assign(Object.assign({}, baseTxParams), { maxFeePerGas: transactionMeta.transaction.maxFeePerGas, maxPriorityFeePerGas: transactionMeta.transaction.maxPriorityFeePerGas, estimatedBaseFee: transactionMeta.transaction.estimatedBaseFee, 
                        // specify type 2 if maxFeePerGas and maxPriorityFeePerGas are set
                        type: 2 }) : baseTxParams;
                // delete gasPrice if maxFeePerGas and maxPriorityFeePerGas are set
                if (isEIP1559) {
                    delete txParams.gasPrice;
                }
                const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
                const signedTx = yield this.sign(unsignedEthTx, from);
                transactionMeta.status = TransactionStatus.signed;
                this.updateTransaction(transactionMeta);
                const rawTransaction = ethereumjs_util_1.bufferToHex(signedTx.serialize());
                transactionMeta.rawTransaction = rawTransaction;
                this.updateTransaction(transactionMeta);
                const transactionHash = yield util_1.query(this.ethQuery, 'sendRawTransaction', [
                    rawTransaction,
                ]);
                transactionMeta.transactionHash = transactionHash;
                transactionMeta.status = TransactionStatus.submitted;
                this.updateTransaction(transactionMeta);
                this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
            }
            catch (error) {
                this.failTransaction(transactionMeta, error);
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Cancels a transaction based on its ID by setting its status to "rejected"
     * and emitting a `<tx.id>:finished` hub event.
     *
     * @param transactionID - ID of the transaction to cancel
     */
    cancelTransaction(transactionID) {
        const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
        if (!transactionMeta) {
            return;
        }
        transactionMeta.status = TransactionStatus.rejected;
        this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
        const transactions = this.state.transactions.filter(({ id }) => id !== transactionID);
        this.update({ transactions: this.trimTransactionsForState(transactions) });
    }
    /**
     * Attempts to cancel a transaction based on its ID by setting its status to "rejected"
     * and emitting a `<tx.id>:finished` hub event.
     *
     * @param transactionID - ID of the transaction to cancel
     */
    stopTransaction(transactionID, gasValues) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (gasValues) {
                util_1.validateGasValues(gasValues);
            }
            const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
            if (!transactionMeta) {
                return;
            }
            if (!this.sign) {
                throw new Error('No sign method defined.');
            }
            // gasPrice (legacy non EIP1559)
            const minGasPrice = util_1.getIncreasedPriceFromExisting(transactionMeta.transaction.gasPrice, exports.CANCEL_RATE);
            const gasPriceFromValues = util_1.isGasPriceValue(gasValues) && gasValues.gasPrice;
            const newGasPrice = (gasPriceFromValues &&
                util_1.validateMinimumIncrease(gasPriceFromValues, minGasPrice)) ||
                minGasPrice;
            // maxFeePerGas (EIP1559)
            const existingMaxFeePerGas = (_a = transactionMeta.transaction) === null || _a === void 0 ? void 0 : _a.maxFeePerGas;
            const minMaxFeePerGas = util_1.getIncreasedPriceFromExisting(existingMaxFeePerGas, exports.CANCEL_RATE);
            const maxFeePerGasValues = util_1.isFeeMarketEIP1559Values(gasValues) && gasValues.maxFeePerGas;
            const newMaxFeePerGas = (maxFeePerGasValues &&
                util_1.validateMinimumIncrease(maxFeePerGasValues, minMaxFeePerGas)) ||
                (existingMaxFeePerGas && minMaxFeePerGas);
            // maxPriorityFeePerGas (EIP1559)
            const existingMaxPriorityFeePerGas = (_b = transactionMeta.transaction) === null || _b === void 0 ? void 0 : _b.maxPriorityFeePerGas;
            const minMaxPriorityFeePerGas = util_1.getIncreasedPriceFromExisting(existingMaxPriorityFeePerGas, exports.CANCEL_RATE);
            const maxPriorityFeePerGasValues = util_1.isFeeMarketEIP1559Values(gasValues) && gasValues.maxPriorityFeePerGas;
            const newMaxPriorityFeePerGas = (maxPriorityFeePerGasValues &&
                util_1.validateMinimumIncrease(maxPriorityFeePerGasValues, minMaxPriorityFeePerGas)) ||
                (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);
            const txParams = newMaxFeePerGas && newMaxPriorityFeePerGas
                ? {
                    from: transactionMeta.transaction.from,
                    gasLimit: transactionMeta.transaction.gas,
                    maxFeePerGas: newMaxFeePerGas,
                    maxPriorityFeePerGas: newMaxPriorityFeePerGas,
                    type: 2,
                    nonce: transactionMeta.transaction.nonce,
                    to: transactionMeta.transaction.from,
                    value: '0x0',
                }
                : {
                    from: transactionMeta.transaction.from,
                    gasLimit: transactionMeta.transaction.gas,
                    gasPrice: newGasPrice,
                    nonce: transactionMeta.transaction.nonce,
                    to: transactionMeta.transaction.from,
                    value: '0x0',
                };
            const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
            const signedTx = yield this.sign(unsignedEthTx, transactionMeta.transaction.from);
            const rawTransaction = ethereumjs_util_1.bufferToHex(signedTx.serialize());
            yield util_1.query(this.ethQuery, 'sendRawTransaction', [rawTransaction]);
            transactionMeta.status = TransactionStatus.cancelled;
            this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
        });
    }
    /**
     * Attemps to speed up a transaction increasing transaction gasPrice by ten percent
     *
     * @param transactionID - ID of the transaction to speed up
     */
    speedUpTransaction(transactionID, gasValues) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (gasValues) {
                util_1.validateGasValues(gasValues);
            }
            const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
            /* istanbul ignore next */
            if (!transactionMeta) {
                return;
            }
            /* istanbul ignore next */
            if (!this.sign) {
                throw new Error('No sign method defined.');
            }
            const { transactions } = this.state;
            // gasPrice (legacy non EIP1559)
            const minGasPrice = util_1.getIncreasedPriceFromExisting(transactionMeta.transaction.gasPrice, exports.SPEED_UP_RATE);
            const gasPriceFromValues = util_1.isGasPriceValue(gasValues) && gasValues.gasPrice;
            const newGasPrice = (gasPriceFromValues &&
                util_1.validateMinimumIncrease(gasPriceFromValues, minGasPrice)) ||
                minGasPrice;
            // maxFeePerGas (EIP1559)
            const existingMaxFeePerGas = (_a = transactionMeta.transaction) === null || _a === void 0 ? void 0 : _a.maxFeePerGas;
            const minMaxFeePerGas = util_1.getIncreasedPriceFromExisting(existingMaxFeePerGas, exports.SPEED_UP_RATE);
            const maxFeePerGasValues = util_1.isFeeMarketEIP1559Values(gasValues) && gasValues.maxFeePerGas;
            const newMaxFeePerGas = (maxFeePerGasValues &&
                util_1.validateMinimumIncrease(maxFeePerGasValues, minMaxFeePerGas)) ||
                (existingMaxFeePerGas && minMaxFeePerGas);
            // maxPriorityFeePerGas (EIP1559)
            const existingMaxPriorityFeePerGas = (_b = transactionMeta.transaction) === null || _b === void 0 ? void 0 : _b.maxPriorityFeePerGas;
            const minMaxPriorityFeePerGas = util_1.getIncreasedPriceFromExisting(existingMaxPriorityFeePerGas, exports.SPEED_UP_RATE);
            const maxPriorityFeePerGasValues = util_1.isFeeMarketEIP1559Values(gasValues) && gasValues.maxPriorityFeePerGas;
            const newMaxPriorityFeePerGas = (maxPriorityFeePerGasValues &&
                util_1.validateMinimumIncrease(maxPriorityFeePerGasValues, minMaxPriorityFeePerGas)) ||
                (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);
            const txParams = newMaxFeePerGas && newMaxPriorityFeePerGas
                ? Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas, maxFeePerGas: newMaxFeePerGas, maxPriorityFeePerGas: newMaxPriorityFeePerGas, type: 2 }) : Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas, gasPrice: newGasPrice });
            const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
            const signedTx = yield this.sign(unsignedEthTx, transactionMeta.transaction.from);
            const rawTransaction = ethereumjs_util_1.bufferToHex(signedTx.serialize());
            const transactionHash = yield util_1.query(this.ethQuery, 'sendRawTransaction', [
                rawTransaction,
            ]);
            const baseTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { id: uuid_1.v1(), time: Date.now(), transactionHash });
            const newTransactionMeta = newMaxFeePerGas && newMaxPriorityFeePerGas
                ? Object.assign(Object.assign({}, baseTransactionMeta), { transaction: Object.assign(Object.assign({}, transactionMeta.transaction), { maxFeePerGas: newMaxFeePerGas, maxPriorityFeePerGas: newMaxPriorityFeePerGas }) }) : Object.assign(Object.assign({}, baseTransactionMeta), { transaction: Object.assign(Object.assign({}, transactionMeta.transaction), { gasPrice: newGasPrice }) });
            transactions.push(newTransactionMeta);
            this.update({ transactions: this.trimTransactionsForState(transactions) });
            this.hub.emit(`${transactionMeta.id}:speedup`, newTransactionMeta);
        });
    }
    /**
     * Estimates required gas for a given transaction
     *
     * @param transaction - Transaction object to estimate gas for
     * @returns - Promise resolving to an object containing gas and gasPrice
     */
    estimateGas(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const estimatedTransaction = Object.assign({}, transaction);
            const { gas, gasPrice: providedGasPrice, to, value, data, } = estimatedTransaction;
            const gasPrice = typeof providedGasPrice === 'undefined'
                ? yield util_1.query(this.ethQuery, 'gasPrice')
                : providedGasPrice;
            const { isCustomNetwork } = this.getNetworkState();
            // 1. If gas is already defined on the transaction, use it
            if (typeof gas !== 'undefined') {
                return { gas, gasPrice };
            }
            const { gasLimit } = yield util_1.query(this.ethQuery, 'getBlockByNumber', [
                'latest',
                false,
            ]);
            // 2. If to is not defined or this is not a contract address, and there is no data use 0x5208 / 21000.
            // If the newtwork is a custom network then bypass this check and fetch 'estimateGas'.
            /* istanbul ignore next */
            const code = to ? yield util_1.query(this.ethQuery, 'getCode', [to]) : undefined;
            /* istanbul ignore next */
            if (!isCustomNetwork &&
                (!to || (to && !data && (!code || code === '0x')))) {
                return { gas: '0x5208', gasPrice };
            }
            // if data, should be hex string format
            estimatedTransaction.data = !data
                ? data
                : /* istanbul ignore next */ ethereumjs_util_1.addHexPrefix(data);
            // 3. If this is a contract address, safely estimate gas using RPC
            estimatedTransaction.value =
                typeof value === 'undefined' ? '0x0' : /* istanbul ignore next */ value;
            const gasLimitBN = util_1.hexToBN(gasLimit);
            estimatedTransaction.gas = util_1.BNToHex(util_1.fractionBN(gasLimitBN, 19, 20));
            const gasHex = yield util_1.query(this.ethQuery, 'estimateGas', [
                estimatedTransaction,
            ]);
            // 4. Pad estimated gas without exceeding the most recent block gasLimit. If the network is a
            // a custom network then return the eth_estimateGas value.
            const gasBN = util_1.hexToBN(gasHex);
            const maxGasBN = gasLimitBN.muln(0.9);
            const paddedGasBN = gasBN.muln(1.5);
            /* istanbul ignore next */
            if (gasBN.gt(maxGasBN) || isCustomNetwork) {
                return { gas: ethereumjs_util_1.addHexPrefix(gasHex), gasPrice };
            }
            /* istanbul ignore next */
            if (paddedGasBN.lt(maxGasBN)) {
                return { gas: ethereumjs_util_1.addHexPrefix(util_1.BNToHex(paddedGasBN)), gasPrice };
            }
            return { gas: ethereumjs_util_1.addHexPrefix(util_1.BNToHex(maxGasBN)), gasPrice };
        });
    }
    /**
     * Resiliently checks all submitted transactions on the blockchain
     * and verifies that it has been included in a block
     * when that happens, the tx status is updated to confirmed
     *
     * @returns - Promise resolving when this operation completes
     */
    queryTransactionStatuses() {
        return __awaiter(this, void 0, void 0, function* () {
            const { transactions } = this.state;
            const { provider, network: currentNetworkID } = this.getNetworkState();
            const { chainId: currentChainId } = provider;
            let gotUpdates = false;
            yield util_1.safelyExecute(() => Promise.all(transactions.map((meta, index) => __awaiter(this, void 0, void 0, function* () {
                // Using fallback to networkID only when there is no chainId present.
                // Should be removed when networkID is completely removed.
                const txBelongsToCurrentChain = meta.chainId === currentChainId ||
                    (!meta.chainId && meta.networkID === currentNetworkID);
                if (!meta.verifiedOnBlockchain && txBelongsToCurrentChain) {
                    const [reconciledTx, updateRequired,] = yield this.blockchainTransactionStateReconciler(meta);
                    if (updateRequired) {
                        transactions[index] = reconciledTx;
                        gotUpdates = updateRequired;
                    }
                }
            }))));
            /* istanbul ignore else */
            if (gotUpdates) {
                this.update({
                    transactions: this.trimTransactionsForState(transactions),
                });
            }
        });
    }
    /**
     * Updates an existing transaction in state
     *
     * @param transactionMeta - New transaction meta to store in state
     */
    updateTransaction(transactionMeta) {
        const { transactions } = this.state;
        transactionMeta.transaction = util_1.normalizeTransaction(transactionMeta.transaction);
        util_1.validateTransaction(transactionMeta.transaction);
        const index = transactions.findIndex(({ id }) => transactionMeta.id === id);
        transactions[index] = transactionMeta;
        this.update({ transactions: this.trimTransactionsForState(transactions) });
    }
    /**
     * Removes all transactions from state, optionally based on the current network
     *
     * @param ignoreNetwork - Ignores network
     */
    wipeTransactions(ignoreNetwork) {
        /* istanbul ignore next */
        if (ignoreNetwork) {
            this.update({ transactions: [] });
            return;
        }
        const { provider, network: currentNetworkID } = this.getNetworkState();
        const { chainId: currentChainId } = provider;
        const newTransactions = this.state.transactions.filter(({ networkID, chainId }) => {
            // Using fallback to networkID only when there is no chainId present. Should be removed when networkID is completely removed.
            const isCurrentNetwork = chainId === currentChainId ||
                (!chainId && networkID === currentNetworkID);
            return !isCurrentNetwork;
        });
        this.update({
            transactions: this.trimTransactionsForState(newTransactions),
        });
    }
    /**
     * Gets all transactions from etherscan for a specific address
     * optionally starting from a specific block
     *
     * @param address - string representing the address to fetch the transactions from
     * @param opt - Object containing optional data, fromBlock and Alethio API key
     * @returns - Promise resolving to an string containing the block number of the latest incoming transaction.
     */
    fetchAll(address, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const { provider, network: currentNetworkID } = this.getNetworkState();
            const { chainId: currentChainId, type: networkType } = provider;
            const { transactions } = this.state;
            const supportedNetworkIds = ['1', '3', '4', '42'];
            /* istanbul ignore next */
            if (supportedNetworkIds.indexOf(currentNetworkID) === -1) {
                return undefined;
            }
            const [etherscanTxResponse, etherscanTokenResponse,] = yield util_1.handleTransactionFetch(networkType, address, this.config.txHistoryLimit, opt);
            const normalizedTxs = etherscanTxResponse.result.map((tx) => this.normalizeTx(tx, currentNetworkID, currentChainId));
            const normalizedTokenTxs = etherscanTokenResponse.result.map((tx) => this.normalizeTokenTx(tx, currentNetworkID, currentChainId));
            const [updateRequired, allTxs] = this.etherscanTransactionStateReconciler([...normalizedTxs, ...normalizedTokenTxs], transactions);
            allTxs.sort((a, b) => (a.time < b.time ? -1 : 1));
            let latestIncomingTxBlockNumber;
            allTxs.forEach((tx) => __awaiter(this, void 0, void 0, function* () {
                /* istanbul ignore next */
                if (
                // Using fallback to networkID only when there is no chainId present. Should be removed when networkID is completely removed.
                (tx.chainId === currentChainId ||
                    (!tx.chainId && tx.networkID === currentNetworkID)) &&
                    tx.transaction.to &&
                    tx.transaction.to.toLowerCase() === address.toLowerCase()) {
                    if (tx.blockNumber &&
                        (!latestIncomingTxBlockNumber ||
                            parseInt(latestIncomingTxBlockNumber, 10) <
                                parseInt(tx.blockNumber, 10))) {
                        latestIncomingTxBlockNumber = tx.blockNumber;
                    }
                }
                /* istanbul ignore else */
                if (tx.toSmartContract === undefined) {
                    // If not `to` is a contract deploy, if not `data` is send eth
                    if (tx.transaction.to &&
                        (!tx.transaction.data || tx.transaction.data !== '0x')) {
                        const code = yield util_1.query(this.ethQuery, 'getCode', [
                            tx.transaction.to,
                        ]);
                        tx.toSmartContract = util_1.isSmartContractCode(code);
                    }
                    else {
                        tx.toSmartContract = false;
                    }
                }
            }));
            // Update state only if new transactions were fetched or
            // the status or gas data of a transaction has changed
            if (updateRequired) {
                this.update({ transactions: this.trimTransactionsForState(allTxs) });
            }
            return latestIncomingTxBlockNumber;
        });
    }
    /**
     * Trim the amount of transactions that are set on the state. Checks
     * if the length of the tx history is longer then desired persistence
     * limit and then if it is removes the oldest confirmed or rejected tx.
     * Pending or unapproved transactions will not be removed by this
     * operation. For safety of presenting a fully functional transaction UI
     * representation, this function will not break apart transactions with the
     * same nonce, created on the same day, per network. Not accounting for transactions of the same
     * nonce, same day and network combo can result in confusing or broken experiences
     * in the UI. The transactions are then updated using the BaseController update.
     * @param transactions - array of transactions to be applied to the state
     * @returns Array of TransactionMeta with the desired length.
     */
    trimTransactionsForState(transactions) {
        const nonceNetworkSet = new Set();
        const txsToKeep = transactions.reverse().filter((tx) => {
            const { chainId, networkID, status, transaction, time } = tx;
            if (transaction) {
                const key = `${transaction.nonce}-${chainId !== null && chainId !== void 0 ? chainId : networkID}-${new Date(time).toDateString()}`;
                if (nonceNetworkSet.has(key)) {
                    return true;
                }
                else if (nonceNetworkSet.size < this.config.txHistoryLimit ||
                    !this.isFinalState(status)) {
                    nonceNetworkSet.add(key);
                    return true;
                }
            }
            return false;
        });
        txsToKeep.reverse();
        return txsToKeep;
    }
    /**
     * Method to determine if the transaction is in a final state
     * @param status - Transaction status
     * @returns boolean if the transaction is in a final state
     */
    isFinalState(status) {
        return (status === TransactionStatus.rejected ||
            status === TransactionStatus.confirmed ||
            status === TransactionStatus.failed ||
            status === TransactionStatus.cancelled);
    }
    /**
     * Method to verify the state of a transaction using the Blockchain as a source of truth
     * @param meta Local transaction to verify data in blockchain
     * @returns Promise with [TransactionMeta, boolean]
     */
    blockchainTransactionStateReconciler(meta) {
        return __awaiter(this, void 0, void 0, function* () {
            const { status, transactionHash } = meta;
            switch (status) {
                case TransactionStatus.confirmed:
                    const txReceipt = yield util_1.query(this.ethQuery, 'getTransactionReceipt', [
                        transactionHash,
                    ]);
                    if (!txReceipt) {
                        return [meta, false];
                    }
                    meta.verifiedOnBlockchain = true;
                    meta.transaction.gasUsed = txReceipt.gasUsed;
                    // According to the Web3 docs:
                    // TRUE if the transaction was successful, FALSE if the EVM reverted the transaction.
                    if (Number(txReceipt.status) === 0) {
                        const error = new Error('Transaction failed. The transaction was reversed');
                        this.failTransaction(meta, error);
                        return [meta, false];
                    }
                    return [meta, true];
                case TransactionStatus.submitted:
                    const txObj = yield util_1.query(this.ethQuery, 'getTransactionByHash', [
                        transactionHash,
                    ]);
                    if (!txObj) {
                        const receiptShowsFailedStatus = yield this.checkTxReceiptStatusIsFailed(transactionHash);
                        // Case the txObj is evaluated as false, a second check will
                        // determine if the tx failed or it is pending or confirmed
                        if (receiptShowsFailedStatus) {
                            const error = new Error('Transaction failed. The transaction was dropped or replaced by a new one');
                            this.failTransaction(meta, error);
                        }
                    }
                    /* istanbul ignore next */
                    if (txObj === null || txObj === void 0 ? void 0 : txObj.blockNumber) {
                        meta.status = TransactionStatus.confirmed;
                        this.hub.emit(`${meta.id}:confirmed`, meta);
                        return [meta, true];
                    }
                    return [meta, false];
                default:
                    return [meta, false];
            }
        });
    }
    /**
     * Method to check if a tx has failed according to their receipt
     * According to the Web3 docs:
     * TRUE if the transaction was successful, FALSE if the EVM reverted the transaction.
     * The receipt is not available for pending transactions and returns null.
     * @param txHash Transaction hash
     * @returns Promise<boolean> indicating if the transaction have failed
     */
    checkTxReceiptStatusIsFailed(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const txReceipt = yield util_1.query(this.ethQuery, 'getTransactionReceipt', [
                txHash,
            ]);
            if (!txReceipt) {
                // Transaction is pending
                return false;
            }
            return Number(txReceipt.status) === 0;
        });
    }
    /**
     * Method to verify the state of transactions using Etherscan as a source of truth
     * @param remoteTxs Array of transactions from remote source
     * @param localTxs Array of transactions stored locally
     * @returns [boolean, TransactionMeta[]]
     */
    etherscanTransactionStateReconciler(remoteTxs, localTxs) {
        const updatedTxs = this.getUpdatedTransactions(remoteTxs, localTxs);
        const newTxs = this.getNewTransactions(remoteTxs, localTxs);
        const updatedLocalTxs = localTxs.map((tx) => {
            const txIdx = updatedTxs.findIndex(({ transactionHash }) => transactionHash === tx.transactionHash);
            return txIdx === -1 ? tx : updatedTxs[txIdx];
        });
        const updateRequired = newTxs.length > 0 || updatedLocalTxs.length > 0;
        return [updateRequired, [...newTxs, ...updatedLocalTxs]];
    }
    /**
     * Get all transactions that are in the remote transactions array
     * but not in the local transactions array
     * @param remoteTxs - Array of transactions from remote source
     * @param localTxs - Array of transactions stored locally
     * @returns TransactionMeta array
     */
    getNewTransactions(remoteTxs, localTxs) {
        return remoteTxs.filter((tx) => {
            const alreadyInTransactions = localTxs.find(({ transactionHash }) => transactionHash === tx.transactionHash);
            return !alreadyInTransactions;
        });
    }
    /**
     * Get all the transactions that are locally outdated with respect
     * to a remote source (etherscan or blockchain). The returned array
     * contains the transactions with the updated data.
     * @param remoteTxs - Array of transactions from remote source
     * @param localTxs - Array of transactions stored locally
     * @returns TransactionMeta array
     */
    getUpdatedTransactions(remoteTxs, localTxs) {
        return remoteTxs.filter((remoteTx) => {
            const isTxOutdated = localTxs.find((localTx) => {
                return (remoteTx.transactionHash === localTx.transactionHash &&
                    this.isTransactionOutdated(remoteTx, localTx));
            });
            return isTxOutdated;
        });
    }
    /**
     * Verifies if a local transaction is outdated with respect to the remote transaction
     * @param remoteTx - Remote transaction from Etherscan
     * @param localTx - Local transaction
     * @returns boolean
     */
    isTransactionOutdated(remoteTx, localTx) {
        const statusOutdated = this.isStatusOutdated(remoteTx.transactionHash, localTx.transactionHash, remoteTx.status, localTx.status);
        const gasDataOutdated = this.isGasDataOutdated(remoteTx.transaction.gasUsed, localTx.transaction.gasUsed);
        return statusOutdated || gasDataOutdated;
    }
    /**
     * Verifies if the status of a local transaction is outdated with respect to the remote transaction
     * @param remoteTxHash - Remote transaction hash
     * @param localTxHash - Local transaction hash
     * @param remoteTxStatus - Remote transaction status
     * @param localTxStatus - Local transaction status
     * @returns boolean
     */
    isStatusOutdated(remoteTxHash, localTxHash, remoteTxStatus, localTxStatus) {
        return remoteTxHash === localTxHash && remoteTxStatus !== localTxStatus;
    }
    /**
     * Verifies if the gas data of a local transaction is outdated with respect to the remote transaction
     * @param remoteGasUsed - Remote gas used in the transaction
     * @param localGasUsed - Local gas used in the transaction
     * @returns boolean
     */
    isGasDataOutdated(remoteGasUsed, localGasUsed) {
        return remoteGasUsed !== localGasUsed;
    }
}
exports.TransactionController = TransactionController;
exports.default = TransactionController;
//# sourceMappingURL=TransactionController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/transaction/TransactionController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/asStream.js", {"stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/asStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeAsStream = void 0;
const stream_1 = require("stream");
class ObservableStoreStream extends stream_1.Duplex {
    constructor(obsStore) {
        super({
            // pass values, not serializations
            objectMode: true,
        });
        // dont buffer outgoing updates
        this.resume();
        // save handler so we can unsubscribe later
        this.handler = (state) => this.push(state);
        // subscribe to obsStore changes
        this.obsStore = obsStore;
        this.obsStore.subscribe(this.handler);
    }
    // emit current state on new destination
    pipe(dest, options) {
        const result = super.pipe(dest, options);
        dest.write(this.obsStore.getState());
        return result;
    }
    // write from incoming stream to state
    _write(chunk, _encoding, callback) {
        this.obsStore.putState(chunk);
        callback();
    }
    // noop - outgoing stream is asking us if we have data we arent giving it
    _read(_size) {
        return undefined;
    }
    // unsubscribe from event emitter
    _destroy(err, callback) {
        this.obsStore.unsubscribe(this.handler);
        super._destroy(err, callback);
    }
}
function storeAsStream(obsStore) {
    return new ObservableStoreStream(obsStore);
}
exports.storeAsStream = storeAsStream;
//# sourceMappingURL=asStream.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/asStream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/ComposedStore.js", {"./ObservableStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/ComposedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class ComposedStore extends ObservableStore_1.ObservableStore {
    constructor(children) {
        // Typecast: Preserve existing behavior
        super({});
        // subscribe to children
        this._children = children || {};
        Object.keys(this._children).forEach((childKey) => {
            const child = this._children[childKey];
            this._addChild(childKey, child);
        });
    }
    _addChild(childKey, child) {
        const updateFromChild = (childValue) => {
            const state = this.getState();
            state[childKey] = childValue;
            this.putState(state);
        };
        child.subscribe(updateFromChild);
        updateFromChild(child.getState());
    }
}
exports.ComposedStore = ComposedStore;
//# sourceMappingURL=ComposedStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/ComposedStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/MergedStore.js", {"./ObservableStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/MergedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class MergedStore extends ObservableStore_1.ObservableStore {
    constructor(children = []) {
        // Typecast: Preserve existing behavior
        super({});
        this._children = children;
        // subscribe to children
        children.forEach((child) => this._addChild(child));
        this._updateWholeState();
    }
    _addChild(child) {
        child.subscribe(() => this._updateWholeState());
    }
    _updateWholeState() {
        const childStates = this._children.map((child) => child.getState());
        // apply shallow merge over states
        const state = Object.assign({}, ...childStates);
        this.putState(state);
    }
}
exports.MergedStore = MergedStore;
//# sourceMappingURL=MergedStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/MergedStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/ObservableStore.js", {"@metamask/safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/safe-event-emitter/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/ObservableStore.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableStore = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
class ObservableStore extends safe_event_emitter_1.default {
    constructor(initState) {
        super();
        if (initState) {
            this._state = initState;
        }
        else {
            // Typecast/default state: Preserve existing behavior
            this._state = {};
        }
    }
    // wrapper around internal getState
    getState() {
        return this._getState();
    }
    // wrapper around internal putState
    putState(newState) {
        this._putState(newState);
        this.emit('update', newState);
    }
    updateState(partialState) {
        // if non-null object, merge
        if (partialState && typeof partialState === 'object') {
            const state = this.getState();
            this.putState(Object.assign(Object.assign({}, state), partialState));
            // if not object, use new value
        }
        else {
            this.putState(partialState);
        }
    }
    // subscribe to changes
    subscribe(handler) {
        this.on('update', handler);
    }
    // unsubscribe to changes
    unsubscribe(handler) {
        this.removeListener('update', handler);
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        return this._state;
    }
    // write to persistence
    _putState(newState) {
        this._state = newState;
    }
}
exports.ObservableStore = ObservableStore;
//# sourceMappingURL=ObservableStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/ObservableStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/transform.js", {"through2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/through2/through2.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/transform.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeTransformStream = void 0;
const through2_1 = require("through2");
function storeTransformStream(syncTransformFn) {
    return through2_1.obj((state, _encoding, cb) => {
        try {
            const newState = syncTransformFn(state);
            cb(null, newState);
            return undefined;
        }
        catch (err) {
            cb(err);
            return undefined;
        }
    });
}
exports.storeTransformStream = storeTransformStream;
//# sourceMappingURL=transform.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/transform.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-workers/dist/enums.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-workers/dist/enums.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.STREAM_NAMES = void 0;
// I have no idea why this rule fires but you do you eslint
// eslint-disable-next-line no-shadow
var STREAM_NAMES;
(function (STREAM_NAMES) {
    STREAM_NAMES["JSON_RPC"] = "jsonRpc";
    STREAM_NAMES["COMMAND"] = "command";
})(STREAM_NAMES = exports.STREAM_NAMES || (exports.STREAM_NAMES = {}));
//# sourceMappingURL=enums.js.map
      };
    };
  }
}, {package:"@metamask/snap-workers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-workers/dist/enums.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/json-rpc-middleware-stream/dist/createEngineStream.js", {"readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/json-rpc-middleware-stream/dist/createEngineStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const readable_stream_1 = require("readable-stream");
/**
 * Takes a JsonRpcEngine and returns a Duplex stream wrapping it.
 *
 * @param opts - Options bag.
 * @param opts.engine - The JsonRpcEngine to wrap in a stream.
 * @returns The stream wrapping the engine.
 */
function createEngineStream(opts) {
    if (!opts || !opts.engine) {
        throw new Error('Missing engine parameter!');
    }
    const { engine } = opts;
    const stream = new readable_stream_1.Duplex({ objectMode: true, read, write });
    // forward notifications
    if (engine.on) {
        engine.on('notification', (message) => {
            stream.push(message);
        });
    }
    return stream;
    function read() {
        return undefined;
    }
    function write(req, _encoding, cb) {
        engine.handle(req, (_err, res) => {
            stream.push(res);
        });
        cb();
    }
}
exports.default = createEngineStream;
//# sourceMappingURL=createEngineStream.js.map
      };
    };
  }
}, {package:"json-rpc-middleware-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/json-rpc-middleware-stream/dist/createEngineStream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/json-rpc-middleware-stream/dist/createStreamMiddleware.js", {"@metamask/safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/safe-event-emitter/index.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/json-rpc-middleware-stream/dist/createStreamMiddleware.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
const readable_stream_1 = require("readable-stream");
/**
 * Creates a JsonRpcEngine middleware with an associated Duplex stream and
 * EventEmitter. The middleware, and by extension stream, assume that middleware
 * parameters are properly formatted. No runtime type checking or validation is
 * performed.
 *
 * @returns The event emitter, middleware, and stream.
 */
function createStreamMiddleware() {
    const idMap = {};
    const stream = new readable_stream_1.Duplex({
        objectMode: true,
        read: readNoop,
        write: processMessage,
    });
    const events = new safe_event_emitter_1.default();
    const middleware = (req, res, next, end) => {
        // write req to stream
        stream.push(req);
        // register request on id map
        idMap[req.id] = { req, res, next, end };
    };
    return { events, middleware, stream };
    function readNoop() {
        return false;
    }
    function processMessage(res, _encoding, cb) {
        let err;
        try {
            const isNotification = !res.id;
            if (isNotification) {
                processNotification(res);
            }
            else {
                processResponse(res);
            }
        }
        catch (_err) {
            err = _err;
        }
        // continue processing stream
        cb(err);
    }
    function processResponse(res) {
        const context = idMap[res.id];
        if (!context) {
            throw new Error(`StreamMiddleware - Unknown response id "${res.id}"`);
        }
        delete idMap[res.id];
        // copy whole res onto original res
        Object.assign(context.res, res);
        // run callback on empty stack,
        // prevent internal stream-handler from catching errors
        setTimeout(context.end);
    }
    function processNotification(res) {
        events.emit('notification', res);
    }
}
exports.default = createStreamMiddleware;
//# sourceMappingURL=createStreamMiddleware.js.map
      };
    };
  }
}, {package:"json-rpc-middleware-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/json-rpc-middleware-stream/dist/createStreamMiddleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivers/bip39.js", {"bip39":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/node_modules/bip39/src/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crypto-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivers/bip39.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBip39KeyFromSeed = exports.deriveChildKey = exports.bip39MnemonicToMultipath = void 0;
const crypto_1 = __importDefault(require("crypto"));
const bip39_1 = require("bip39");
// This magic constant is analogous to a salt, and is consistent across all
// major BIP-32 implementations.
const ROOT_BASE_SECRET = Buffer.from('Bitcoin seed', 'utf8');
/**
 * @param mnemonic
 */
function bip39MnemonicToMultipath(mnemonic) {
    return `bip39:${mnemonic.toLowerCase().trim()}`;
}
exports.bip39MnemonicToMultipath = bip39MnemonicToMultipath;
// this creates a child key using bip39, ignoring the parent key
/**
 * @param pathPart
 * @param _parentKey
 */
function deriveChildKey(pathPart, _parentKey) {
    return createBip39KeyFromSeed(bip39_1.mnemonicToSeedSync(pathPart));
}
exports.deriveChildKey = deriveChildKey;
/**
 * @param seed - The cryptographic seed bytes.
 * @returns The bytes of the corresponding BIP-39 master key.
 */
function createBip39KeyFromSeed(seed) {
    return crypto_1.default.createHmac('sha512', ROOT_BASE_SECRET).update(seed).digest();
}
exports.createBip39KeyFromSeed = createBip39KeyFromSeed;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/key-tree",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivers/bip39.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivers/bip32.js", {"../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/constants.js","../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/utils.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crypto-browserify/index.js","keccak":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/keccak/js.js","secp256k1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/node_modules/secp256k1/elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivers/bip32.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveChildKey = exports.privateKeyToEthAddress = void 0;
const crypto_1 = __importDefault(require("crypto"));
const secp256k1_1 = __importDefault(require("secp256k1"));
const keccak_1 = __importDefault(require("keccak"));
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const HARDENED_OFFSET = 0x80000000;
/**
 * Converts a BIP-32 private key to an Ethereum address.
 *
 * **WARNING:** Only validates that the key is non-zero and of the correct
 * length. It is the consumer's responsibility to ensure that the specified
 * key is a valid BIP-44 Ethereum `address_index` key.
 *
 * @param key - The `address_index` key buffer to convert to an Ethereum
 * address.
 * @returns The Ethereum address corresponding to the given key.
 */
function privateKeyToEthAddress(key) {
    if (!Buffer.isBuffer(key) || !utils_1.isValidBufferKey(key)) {
        throw new Error('Invalid key: The key must be a 64-byte, non-zero Buffer.');
    }
    const privateKey = key.slice(0, 32);
    const publicKey = secp256k1_1.default
        .publicKeyCreate(new Uint8Array(privateKey), false)
        .slice(1);
    return keccak(Buffer.from(publicKey)).slice(-20);
}
exports.privateKeyToEthAddress = privateKeyToEthAddress;
/**
 * @param data
 * @param keccakBits
 */
function keccak(data, keccakBits = '256') {
    return keccak_1.default(`keccak${keccakBits}`).update(data).digest();
}
/**
 * @param pathPart
 * @param parentKey
 */
function deriveChildKey(pathPart, parentKey) {
    if (!parentKey) {
        throw new Error('Invalid parameters: Must specify a parent key.');
    }
    if (parentKey.length !== constants_1.BUFFER_KEY_LENGTH) {
        throw new Error('Invalid parent key: Must be 64 bytes long.');
    }
    const isHardened = pathPart.includes(`'`);
    const indexPart = pathPart.split(`'`)[0];
    const childIndex = parseInt(indexPart, 10);
    if (!/^\d+$/u.test(indexPart) ||
        !Number.isInteger(childIndex) ||
        childIndex < 0 ||
        childIndex >= HARDENED_OFFSET) {
        throw new Error(`Invalid BIP-32 index: The index must be a non-negative decimal integer less than ${HARDENED_OFFSET}.`);
    }
    const parentPrivateKey = parentKey.slice(0, 32);
    const parentExtraEntropy = parentKey.slice(32);
    const secretExtension = deriveSecretExtension({
        parentPrivateKey,
        childIndex,
        isHardened,
    });
    const { privateKey, extraEntropy } = generateKey({
        parentPrivateKey,
        parentExtraEntropy,
        secretExtension,
    });
    return Buffer.concat([privateKey, extraEntropy]);
}
exports.deriveChildKey = deriveChildKey;
// the bip32 secret extension is created from the parent private or public key and the child index
/**
 * @param options
 * @param options.parentPrivateKey
 * @param options.childIndex
 * @param options.isHardened
 */
function deriveSecretExtension({ parentPrivateKey, childIndex, isHardened, }) {
    if (isHardened) {
        // Hardened child
        const indexBuffer = Buffer.allocUnsafe(4);
        indexBuffer.writeUInt32BE(childIndex + HARDENED_OFFSET, 0);
        const pk = parentPrivateKey;
        const zb = Buffer.alloc(1, 0);
        return Buffer.concat([zb, pk, indexBuffer]);
    }
    // Normal child
    const indexBuffer = Buffer.allocUnsafe(4);
    indexBuffer.writeUInt32BE(childIndex, 0);
    const parentPublicKey = secp256k1_1.default.publicKeyCreate(new Uint8Array(parentPrivateKey), true);
    return Buffer.concat([parentPublicKey, indexBuffer]);
}
/**
 * @param options
 * @param options.parentPrivateKey
 * @param options.parentExtraEntropy
 * @param options.secretExtension
 */
function generateKey({ parentPrivateKey, parentExtraEntropy, secretExtension, }) {
    const entropy = crypto_1.default
        .createHmac('sha512', parentExtraEntropy)
        .update(secretExtension)
        .digest();
    const keyMaterial = entropy.slice(0, 32);
    // extraEntropy is also called "chaincode"
    const extraEntropy = entropy.slice(32);
    const privateKey = secp256k1_1.default.privateKeyTweakAdd(new Uint8Array(parentPrivateKey), new Uint8Array(keyMaterial));
    return { privateKey, extraEntropy };
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/key-tree",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivers/bip32.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/end-of-stream.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/end-of-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/pipeline.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/errors-browser.js","./end-of-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/pipeline.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/pipeline.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_duplex.js", {"./_stream_readable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_writable.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_duplex.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_duplex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_writable.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_duplex.js","./internal/streams/destroy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/state.js","./internal/streams/stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/stream-browser.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","util-deprecate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/util-deprecate/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_writable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_writable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_passthrough.js", {"./_stream_transform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_transform.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_passthrough.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_passthrough.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_transform.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_duplex.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_transform.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_transform.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_readable.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_duplex.js","./internal/streams/async_iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/async_iterator.js","./internal/streams/buffer_list":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/buffer_list.js","./internal/streams/destroy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/from":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/from-browser.js","./internal/streams/state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/state.js","./internal/streams/stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/internal/streams/stream-browser.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","string_decoder/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/string_decoder/lib/string_decoder.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_readable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/lib/_stream_readable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/ecjpoint.js", {"./bn":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/bn/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/ecjpoint.js
      return function (require, module, exports) {
'use strict'
var BN = require('./bn')

function ECJPoint (x, y, z) {
  if (x === null && y === null && z === null) {
    this.x = ECJPoint.one
    this.y = ECJPoint.one
    this.z = ECJPoint.zero
  } else {
    this.x = x
    this.y = y
    this.z = z
  }

  this.zOne = this.z === ECJPoint.one
}

ECJPoint.zero = BN.fromNumber(0)
ECJPoint.one = BN.fromNumber(1)

ECJPoint.prototype.neg = function () {
  if (this.inf) return this

  return new ECJPoint(this.x, this.y.redNeg(), this.z)
}

ECJPoint.prototype.add = function (p) {
  // O + P = P
  if (this.inf) return p

  // P + O = P
  if (p.inf) return this

  // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-1998-cmo-2
  // 12M + 4S + 7A
  var pz2 = p.z.redSqr()
  var z2 = this.z.redSqr()
  var u1 = this.x.redMul(pz2)
  var u2 = p.x.redMul(z2)
  var s1 = this.y.redMul(pz2).redMul(p.z)
  var s2 = p.y.redMul(z2).redMul(this.z)

  var h = u1.redSub(u2)
  var r = s1.redSub(s2)
  if (h.isZero()) {
    if (r.isZero()) return this.dbl()
    return new ECJPoint(null, null, null)
  }

  var h2 = h.redSqr()
  var v = u1.redMul(h2)
  var h3 = h2.redMul(h)

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v)
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3))
  var nz = this.z.redMul(p.z).redMul(h)

  return new ECJPoint(nx, ny, nz)
}

ECJPoint.prototype.mixedAdd = function (p) {
  // O + P = P
  if (this.inf) return p.toECJPoint()

  // P + O = P
  if (p.inf) return this

  // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-1998-cmo-2
  //   with p.z = 1
  // 8M + 3S + 7A
  var z2 = this.z.redSqr()
  var u1 = this.x
  var u2 = p.x.redMul(z2)
  var s1 = this.y
  var s2 = p.y.redMul(z2).redMul(this.z)

  var h = u1.redSub(u2)
  var r = s1.redSub(s2)
  if (h.isZero()) {
    if (r.isZero()) return this.dbl()
    return new ECJPoint(null, null, null)
  }

  var h2 = h.redSqr()
  var v = u1.redMul(h2)
  var h3 = h2.redMul(h)

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v)
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3))
  var nz = this.z.redMul(h)

  return new ECJPoint(nx, ny, nz)
}

ECJPoint.prototype.dbl = function () {
  if (this.inf) return this

  var nx
  var ny
  var nz

  // Z = 1
  if (this.zOne) {
    // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-mdbl-2007-bl
    // 1M + 5S + 6A + 3*2 + 1*3 + 1*8

    // XX = X1^2
    var xx = this.x.redSqr()
    // YY = Y1^2
    var yy = this.y.redSqr()
    // YYYY = YY^2
    var yyyy = yy.redSqr()
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy)
    s = s.redIAdd(s)
    // M = 3 * XX
    var m = xx.redAdd(xx).redIAdd(xx)
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s)

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy).redIAdd(yyyy).redIAdd(yyyy)

    // X3 = T
    nx = t
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8)
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y)
  } else {
    // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l
    // 2M + 5S + 6A + 3*2 + 1*3 + 1*8

    // A = X1^2
    var a = this.x.redSqr()
    // B = Y1^2
    var b = this.y.redSqr()
    // C = B^2
    var c = b.redSqr()
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c)
    d = d.redIAdd(d)
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a)
    // F = E^2
    var f = e.redSqr()

    // 8 * C
    var c8 = c.redIAdd(c).redIAdd(c).redIAdd(c)

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d)
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8)
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z)
    nz = nz.redIAdd(nz)
  }

  return new ECJPoint(nx, ny, nz)
}

ECJPoint.prototype.dblp = function (pow) {
  if (pow === 0 || this.inf) return this

  var point = this
  for (var i = 0; i < pow; i++) point = point.dbl()

  return point
}

Object.defineProperty(ECJPoint.prototype, 'inf', {
  enumerable: true,
  get: function () {
    return this.z.isZero()
  }
})

module.exports = ECJPoint

      };
    };
  }
}, {package:"secp256k1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/ecjpoint.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/drbg.js/lib/hash-info.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/drbg.js/lib/hash-info.json
      return function (require, module, exports) {
module.exports={
  "sha1": {
    "securityStrength": 128,
    "outlen": 160,
    "seedlen": 440
  },
  "sha224": {
    "securityStrength": 192,
    "outlen": 224,
    "seedlen": 440
  },
  "sha256": {
    "securityStrength": 256,
    "outlen": 256,
    "seedlen": 440
  },
  "sha384": {
    "securityStrength": 256,
    "outlen": 384,
    "seedlen": 888
  },
  "sha512": {
    "securityStrength": 256,
    "outlen": 512,
    "seedlen": 888
  }
}

      };
    };
  }
}, {package:"drbg.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/drbg.js/lib/hash-info.json",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/bn/optimized.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/bn/optimized.js
      return function (require, module, exports) {
'use strict'
exports.umulTo10x10 = function (num1, num2, out) {
  var a = num1.words
  var b = num2.words
  var o = out.words
  var c = 0
  var lo
  var mid
  var hi
  var a0 = a[0] | 0
  var al0 = a0 & 0x1fff
  var ah0 = a0 >>> 13
  var a1 = a[1] | 0
  var al1 = a1 & 0x1fff
  var ah1 = a1 >>> 13
  var a2 = a[2] | 0
  var al2 = a2 & 0x1fff
  var ah2 = a2 >>> 13
  var a3 = a[3] | 0
  var al3 = a3 & 0x1fff
  var ah3 = a3 >>> 13
  var a4 = a[4] | 0
  var al4 = a4 & 0x1fff
  var ah4 = a4 >>> 13
  var a5 = a[5] | 0
  var al5 = a5 & 0x1fff
  var ah5 = a5 >>> 13
  var a6 = a[6] | 0
  var al6 = a6 & 0x1fff
  var ah6 = a6 >>> 13
  var a7 = a[7] | 0
  var al7 = a7 & 0x1fff
  var ah7 = a7 >>> 13
  var a8 = a[8] | 0
  var al8 = a8 & 0x1fff
  var ah8 = a8 >>> 13
  var a9 = a[9] | 0
  var al9 = a9 & 0x1fff
  var ah9 = a9 >>> 13
  var b0 = b[0] | 0
  var bl0 = b0 & 0x1fff
  var bh0 = b0 >>> 13
  var b1 = b[1] | 0
  var bl1 = b1 & 0x1fff
  var bh1 = b1 >>> 13
  var b2 = b[2] | 0
  var bl2 = b2 & 0x1fff
  var bh2 = b2 >>> 13
  var b3 = b[3] | 0
  var bl3 = b3 & 0x1fff
  var bh3 = b3 >>> 13
  var b4 = b[4] | 0
  var bl4 = b4 & 0x1fff
  var bh4 = b4 >>> 13
  var b5 = b[5] | 0
  var bl5 = b5 & 0x1fff
  var bh5 = b5 >>> 13
  var b6 = b[6] | 0
  var bl6 = b6 & 0x1fff
  var bh6 = b6 >>> 13
  var b7 = b[7] | 0
  var bl7 = b7 & 0x1fff
  var bh7 = b7 >>> 13
  var b8 = b[8] | 0
  var bl8 = b8 & 0x1fff
  var bh8 = b8 >>> 13
  var b9 = b[9] | 0
  var bl9 = b9 & 0x1fff
  var bh9 = b9 >>> 13

  out.length = 19
  /* k = 0 */
  lo = Math.imul(al0, bl0)
  mid = Math.imul(al0, bh0)
  mid += Math.imul(ah0, bl0)
  hi = Math.imul(ah0, bh0)
  var w0 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w0 >>> 26)
  w0 &= 0x3ffffff
  /* k = 1 */
  lo = Math.imul(al1, bl0)
  mid = Math.imul(al1, bh0)
  mid += Math.imul(ah1, bl0)
  hi = Math.imul(ah1, bh0)
  lo += Math.imul(al0, bl1)
  mid += Math.imul(al0, bh1)
  mid += Math.imul(ah0, bl1)
  hi += Math.imul(ah0, bh1)
  var w1 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w1 >>> 26)
  w1 &= 0x3ffffff
  /* k = 2 */
  lo = Math.imul(al2, bl0)
  mid = Math.imul(al2, bh0)
  mid += Math.imul(ah2, bl0)
  hi = Math.imul(ah2, bh0)
  lo += Math.imul(al1, bl1)
  mid += Math.imul(al1, bh1)
  mid += Math.imul(ah1, bl1)
  hi += Math.imul(ah1, bh1)
  lo += Math.imul(al0, bl2)
  mid += Math.imul(al0, bh2)
  mid += Math.imul(ah0, bl2)
  hi += Math.imul(ah0, bh2)
  var w2 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w2 >>> 26)
  w2 &= 0x3ffffff
  /* k = 3 */
  lo = Math.imul(al3, bl0)
  mid = Math.imul(al3, bh0)
  mid += Math.imul(ah3, bl0)
  hi = Math.imul(ah3, bh0)
  lo += Math.imul(al2, bl1)
  mid += Math.imul(al2, bh1)
  mid += Math.imul(ah2, bl1)
  hi += Math.imul(ah2, bh1)
  lo += Math.imul(al1, bl2)
  mid += Math.imul(al1, bh2)
  mid += Math.imul(ah1, bl2)
  hi += Math.imul(ah1, bh2)
  lo += Math.imul(al0, bl3)
  mid += Math.imul(al0, bh3)
  mid += Math.imul(ah0, bl3)
  hi += Math.imul(ah0, bh3)
  var w3 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w3 >>> 26)
  w3 &= 0x3ffffff
  /* k = 4 */
  lo = Math.imul(al4, bl0)
  mid = Math.imul(al4, bh0)
  mid += Math.imul(ah4, bl0)
  hi = Math.imul(ah4, bh0)
  lo += Math.imul(al3, bl1)
  mid += Math.imul(al3, bh1)
  mid += Math.imul(ah3, bl1)
  hi += Math.imul(ah3, bh1)
  lo += Math.imul(al2, bl2)
  mid += Math.imul(al2, bh2)
  mid += Math.imul(ah2, bl2)
  hi += Math.imul(ah2, bh2)
  lo += Math.imul(al1, bl3)
  mid += Math.imul(al1, bh3)
  mid += Math.imul(ah1, bl3)
  hi += Math.imul(ah1, bh3)
  lo += Math.imul(al0, bl4)
  mid += Math.imul(al0, bh4)
  mid += Math.imul(ah0, bl4)
  hi += Math.imul(ah0, bh4)
  var w4 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w4 >>> 26)
  w4 &= 0x3ffffff
  /* k = 5 */
  lo = Math.imul(al5, bl0)
  mid = Math.imul(al5, bh0)
  mid += Math.imul(ah5, bl0)
  hi = Math.imul(ah5, bh0)
  lo += Math.imul(al4, bl1)
  mid += Math.imul(al4, bh1)
  mid += Math.imul(ah4, bl1)
  hi += Math.imul(ah4, bh1)
  lo += Math.imul(al3, bl2)
  mid += Math.imul(al3, bh2)
  mid += Math.imul(ah3, bl2)
  hi += Math.imul(ah3, bh2)
  lo += Math.imul(al2, bl3)
  mid += Math.imul(al2, bh3)
  mid += Math.imul(ah2, bl3)
  hi += Math.imul(ah2, bh3)
  lo += Math.imul(al1, bl4)
  mid += Math.imul(al1, bh4)
  mid += Math.imul(ah1, bl4)
  hi += Math.imul(ah1, bh4)
  lo += Math.imul(al0, bl5)
  mid += Math.imul(al0, bh5)
  mid += Math.imul(ah0, bl5)
  hi += Math.imul(ah0, bh5)
  var w5 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w5 >>> 26)
  w5 &= 0x3ffffff
  /* k = 6 */
  lo = Math.imul(al6, bl0)
  mid = Math.imul(al6, bh0)
  mid += Math.imul(ah6, bl0)
  hi = Math.imul(ah6, bh0)
  lo += Math.imul(al5, bl1)
  mid += Math.imul(al5, bh1)
  mid += Math.imul(ah5, bl1)
  hi += Math.imul(ah5, bh1)
  lo += Math.imul(al4, bl2)
  mid += Math.imul(al4, bh2)
  mid += Math.imul(ah4, bl2)
  hi += Math.imul(ah4, bh2)
  lo += Math.imul(al3, bl3)
  mid += Math.imul(al3, bh3)
  mid += Math.imul(ah3, bl3)
  hi += Math.imul(ah3, bh3)
  lo += Math.imul(al2, bl4)
  mid += Math.imul(al2, bh4)
  mid += Math.imul(ah2, bl4)
  hi += Math.imul(ah2, bh4)
  lo += Math.imul(al1, bl5)
  mid += Math.imul(al1, bh5)
  mid += Math.imul(ah1, bl5)
  hi += Math.imul(ah1, bh5)
  lo += Math.imul(al0, bl6)
  mid += Math.imul(al0, bh6)
  mid += Math.imul(ah0, bl6)
  hi += Math.imul(ah0, bh6)
  var w6 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w6 >>> 26)
  w6 &= 0x3ffffff
  /* k = 7 */
  lo = Math.imul(al7, bl0)
  mid = Math.imul(al7, bh0)
  mid += Math.imul(ah7, bl0)
  hi = Math.imul(ah7, bh0)
  lo += Math.imul(al6, bl1)
  mid += Math.imul(al6, bh1)
  mid += Math.imul(ah6, bl1)
  hi += Math.imul(ah6, bh1)
  lo += Math.imul(al5, bl2)
  mid += Math.imul(al5, bh2)
  mid += Math.imul(ah5, bl2)
  hi += Math.imul(ah5, bh2)
  lo += Math.imul(al4, bl3)
  mid += Math.imul(al4, bh3)
  mid += Math.imul(ah4, bl3)
  hi += Math.imul(ah4, bh3)
  lo += Math.imul(al3, bl4)
  mid += Math.imul(al3, bh4)
  mid += Math.imul(ah3, bl4)
  hi += Math.imul(ah3, bh4)
  lo += Math.imul(al2, bl5)
  mid += Math.imul(al2, bh5)
  mid += Math.imul(ah2, bl5)
  hi += Math.imul(ah2, bh5)
  lo += Math.imul(al1, bl6)
  mid += Math.imul(al1, bh6)
  mid += Math.imul(ah1, bl6)
  hi += Math.imul(ah1, bh6)
  lo += Math.imul(al0, bl7)
  mid += Math.imul(al0, bh7)
  mid += Math.imul(ah0, bl7)
  hi += Math.imul(ah0, bh7)
  var w7 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w7 >>> 26)
  w7 &= 0x3ffffff
  /* k = 8 */
  lo = Math.imul(al8, bl0)
  mid = Math.imul(al8, bh0)
  mid += Math.imul(ah8, bl0)
  hi = Math.imul(ah8, bh0)
  lo += Math.imul(al7, bl1)
  mid += Math.imul(al7, bh1)
  mid += Math.imul(ah7, bl1)
  hi += Math.imul(ah7, bh1)
  lo += Math.imul(al6, bl2)
  mid += Math.imul(al6, bh2)
  mid += Math.imul(ah6, bl2)
  hi += Math.imul(ah6, bh2)
  lo += Math.imul(al5, bl3)
  mid += Math.imul(al5, bh3)
  mid += Math.imul(ah5, bl3)
  hi += Math.imul(ah5, bh3)
  lo += Math.imul(al4, bl4)
  mid += Math.imul(al4, bh4)
  mid += Math.imul(ah4, bl4)
  hi += Math.imul(ah4, bh4)
  lo += Math.imul(al3, bl5)
  mid += Math.imul(al3, bh5)
  mid += Math.imul(ah3, bl5)
  hi += Math.imul(ah3, bh5)
  lo += Math.imul(al2, bl6)
  mid += Math.imul(al2, bh6)
  mid += Math.imul(ah2, bl6)
  hi += Math.imul(ah2, bh6)
  lo += Math.imul(al1, bl7)
  mid += Math.imul(al1, bh7)
  mid += Math.imul(ah1, bl7)
  hi += Math.imul(ah1, bh7)
  lo += Math.imul(al0, bl8)
  mid += Math.imul(al0, bh8)
  mid += Math.imul(ah0, bl8)
  hi += Math.imul(ah0, bh8)
  var w8 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w8 >>> 26)
  w8 &= 0x3ffffff
  /* k = 9 */
  lo = Math.imul(al9, bl0)
  mid = Math.imul(al9, bh0)
  mid += Math.imul(ah9, bl0)
  hi = Math.imul(ah9, bh0)
  lo += Math.imul(al8, bl1)
  mid += Math.imul(al8, bh1)
  mid += Math.imul(ah8, bl1)
  hi += Math.imul(ah8, bh1)
  lo += Math.imul(al7, bl2)
  mid += Math.imul(al7, bh2)
  mid += Math.imul(ah7, bl2)
  hi += Math.imul(ah7, bh2)
  lo += Math.imul(al6, bl3)
  mid += Math.imul(al6, bh3)
  mid += Math.imul(ah6, bl3)
  hi += Math.imul(ah6, bh3)
  lo += Math.imul(al5, bl4)
  mid += Math.imul(al5, bh4)
  mid += Math.imul(ah5, bl4)
  hi += Math.imul(ah5, bh4)
  lo += Math.imul(al4, bl5)
  mid += Math.imul(al4, bh5)
  mid += Math.imul(ah4, bl5)
  hi += Math.imul(ah4, bh5)
  lo += Math.imul(al3, bl6)
  mid += Math.imul(al3, bh6)
  mid += Math.imul(ah3, bl6)
  hi += Math.imul(ah3, bh6)
  lo += Math.imul(al2, bl7)
  mid += Math.imul(al2, bh7)
  mid += Math.imul(ah2, bl7)
  hi += Math.imul(ah2, bh7)
  lo += Math.imul(al1, bl8)
  mid += Math.imul(al1, bh8)
  mid += Math.imul(ah1, bl8)
  hi += Math.imul(ah1, bh8)
  lo += Math.imul(al0, bl9)
  mid += Math.imul(al0, bh9)
  mid += Math.imul(ah0, bl9)
  hi += Math.imul(ah0, bh9)
  var w9 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w9 >>> 26)
  w9 &= 0x3ffffff
  /* k = 10 */
  lo = Math.imul(al9, bl1)
  mid = Math.imul(al9, bh1)
  mid += Math.imul(ah9, bl1)
  hi = Math.imul(ah9, bh1)
  lo += Math.imul(al8, bl2)
  mid += Math.imul(al8, bh2)
  mid += Math.imul(ah8, bl2)
  hi += Math.imul(ah8, bh2)
  lo += Math.imul(al7, bl3)
  mid += Math.imul(al7, bh3)
  mid += Math.imul(ah7, bl3)
  hi += Math.imul(ah7, bh3)
  lo += Math.imul(al6, bl4)
  mid += Math.imul(al6, bh4)
  mid += Math.imul(ah6, bl4)
  hi += Math.imul(ah6, bh4)
  lo += Math.imul(al5, bl5)
  mid += Math.imul(al5, bh5)
  mid += Math.imul(ah5, bl5)
  hi += Math.imul(ah5, bh5)
  lo += Math.imul(al4, bl6)
  mid += Math.imul(al4, bh6)
  mid += Math.imul(ah4, bl6)
  hi += Math.imul(ah4, bh6)
  lo += Math.imul(al3, bl7)
  mid += Math.imul(al3, bh7)
  mid += Math.imul(ah3, bl7)
  hi += Math.imul(ah3, bh7)
  lo += Math.imul(al2, bl8)
  mid += Math.imul(al2, bh8)
  mid += Math.imul(ah2, bl8)
  hi += Math.imul(ah2, bh8)
  lo += Math.imul(al1, bl9)
  mid += Math.imul(al1, bh9)
  mid += Math.imul(ah1, bl9)
  hi += Math.imul(ah1, bh9)
  var w10 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w10 >>> 26)
  w10 &= 0x3ffffff
  /* k = 11 */
  lo = Math.imul(al9, bl2)
  mid = Math.imul(al9, bh2)
  mid += Math.imul(ah9, bl2)
  hi = Math.imul(ah9, bh2)
  lo += Math.imul(al8, bl3)
  mid += Math.imul(al8, bh3)
  mid += Math.imul(ah8, bl3)
  hi += Math.imul(ah8, bh3)
  lo += Math.imul(al7, bl4)
  mid += Math.imul(al7, bh4)
  mid += Math.imul(ah7, bl4)
  hi += Math.imul(ah7, bh4)
  lo += Math.imul(al6, bl5)
  mid += Math.imul(al6, bh5)
  mid += Math.imul(ah6, bl5)
  hi += Math.imul(ah6, bh5)
  lo += Math.imul(al5, bl6)
  mid += Math.imul(al5, bh6)
  mid += Math.imul(ah5, bl6)
  hi += Math.imul(ah5, bh6)
  lo += Math.imul(al4, bl7)
  mid += Math.imul(al4, bh7)
  mid += Math.imul(ah4, bl7)
  hi += Math.imul(ah4, bh7)
  lo += Math.imul(al3, bl8)
  mid += Math.imul(al3, bh8)
  mid += Math.imul(ah3, bl8)
  hi += Math.imul(ah3, bh8)
  lo += Math.imul(al2, bl9)
  mid += Math.imul(al2, bh9)
  mid += Math.imul(ah2, bl9)
  hi += Math.imul(ah2, bh9)
  var w11 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w11 >>> 26)
  w11 &= 0x3ffffff
  /* k = 12 */
  lo = Math.imul(al9, bl3)
  mid = Math.imul(al9, bh3)
  mid += Math.imul(ah9, bl3)
  hi = Math.imul(ah9, bh3)
  lo += Math.imul(al8, bl4)
  mid += Math.imul(al8, bh4)
  mid += Math.imul(ah8, bl4)
  hi += Math.imul(ah8, bh4)
  lo += Math.imul(al7, bl5)
  mid += Math.imul(al7, bh5)
  mid += Math.imul(ah7, bl5)
  hi += Math.imul(ah7, bh5)
  lo += Math.imul(al6, bl6)
  mid += Math.imul(al6, bh6)
  mid += Math.imul(ah6, bl6)
  hi += Math.imul(ah6, bh6)
  lo += Math.imul(al5, bl7)
  mid += Math.imul(al5, bh7)
  mid += Math.imul(ah5, bl7)
  hi += Math.imul(ah5, bh7)
  lo += Math.imul(al4, bl8)
  mid += Math.imul(al4, bh8)
  mid += Math.imul(ah4, bl8)
  hi += Math.imul(ah4, bh8)
  lo += Math.imul(al3, bl9)
  mid += Math.imul(al3, bh9)
  mid += Math.imul(ah3, bl9)
  hi += Math.imul(ah3, bh9)
  var w12 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w12 >>> 26)
  w12 &= 0x3ffffff
  /* k = 13 */
  lo = Math.imul(al9, bl4)
  mid = Math.imul(al9, bh4)
  mid += Math.imul(ah9, bl4)
  hi = Math.imul(ah9, bh4)
  lo += Math.imul(al8, bl5)
  mid += Math.imul(al8, bh5)
  mid += Math.imul(ah8, bl5)
  hi += Math.imul(ah8, bh5)
  lo += Math.imul(al7, bl6)
  mid += Math.imul(al7, bh6)
  mid += Math.imul(ah7, bl6)
  hi += Math.imul(ah7, bh6)
  lo += Math.imul(al6, bl7)
  mid += Math.imul(al6, bh7)
  mid += Math.imul(ah6, bl7)
  hi += Math.imul(ah6, bh7)
  lo += Math.imul(al5, bl8)
  mid += Math.imul(al5, bh8)
  mid += Math.imul(ah5, bl8)
  hi += Math.imul(ah5, bh8)
  lo += Math.imul(al4, bl9)
  mid += Math.imul(al4, bh9)
  mid += Math.imul(ah4, bl9)
  hi += Math.imul(ah4, bh9)
  var w13 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w13 >>> 26)
  w13 &= 0x3ffffff
  /* k = 14 */
  lo = Math.imul(al9, bl5)
  mid = Math.imul(al9, bh5)
  mid += Math.imul(ah9, bl5)
  hi = Math.imul(ah9, bh5)
  lo += Math.imul(al8, bl6)
  mid += Math.imul(al8, bh6)
  mid += Math.imul(ah8, bl6)
  hi += Math.imul(ah8, bh6)
  lo += Math.imul(al7, bl7)
  mid += Math.imul(al7, bh7)
  mid += Math.imul(ah7, bl7)
  hi += Math.imul(ah7, bh7)
  lo += Math.imul(al6, bl8)
  mid += Math.imul(al6, bh8)
  mid += Math.imul(ah6, bl8)
  hi += Math.imul(ah6, bh8)
  lo += Math.imul(al5, bl9)
  mid += Math.imul(al5, bh9)
  mid += Math.imul(ah5, bl9)
  hi += Math.imul(ah5, bh9)
  var w14 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w14 >>> 26)
  w14 &= 0x3ffffff
  /* k = 15 */
  lo = Math.imul(al9, bl6)
  mid = Math.imul(al9, bh6)
  mid += Math.imul(ah9, bl6)
  hi = Math.imul(ah9, bh6)
  lo += Math.imul(al8, bl7)
  mid += Math.imul(al8, bh7)
  mid += Math.imul(ah8, bl7)
  hi += Math.imul(ah8, bh7)
  lo += Math.imul(al7, bl8)
  mid += Math.imul(al7, bh8)
  mid += Math.imul(ah7, bl8)
  hi += Math.imul(ah7, bh8)
  lo += Math.imul(al6, bl9)
  mid += Math.imul(al6, bh9)
  mid += Math.imul(ah6, bl9)
  hi += Math.imul(ah6, bh9)
  var w15 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w15 >>> 26)
  w15 &= 0x3ffffff
  /* k = 16 */
  lo = Math.imul(al9, bl7)
  mid = Math.imul(al9, bh7)
  mid += Math.imul(ah9, bl7)
  hi = Math.imul(ah9, bh7)
  lo += Math.imul(al8, bl8)
  mid += Math.imul(al8, bh8)
  mid += Math.imul(ah8, bl8)
  hi += Math.imul(ah8, bh8)
  lo += Math.imul(al7, bl9)
  mid += Math.imul(al7, bh9)
  mid += Math.imul(ah7, bl9)
  hi += Math.imul(ah7, bh9)
  var w16 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w16 >>> 26)
  w16 &= 0x3ffffff
  /* k = 17 */
  lo = Math.imul(al9, bl8)
  mid = Math.imul(al9, bh8)
  mid += Math.imul(ah9, bl8)
  hi = Math.imul(ah9, bh8)
  lo += Math.imul(al8, bl9)
  mid += Math.imul(al8, bh9)
  mid += Math.imul(ah8, bl9)
  hi += Math.imul(ah8, bh9)
  var w17 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w17 >>> 26)
  w17 &= 0x3ffffff
  /* k = 18 */
  lo = Math.imul(al9, bl9)
  mid = Math.imul(al9, bh9)
  mid += Math.imul(ah9, bl9)
  hi = Math.imul(ah9, bh9)
  var w18 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w18 >>> 26)
  w18 &= 0x3ffffff
  o[0] = w0
  o[1] = w1
  o[2] = w2
  o[3] = w3
  o[4] = w4
  o[5] = w5
  o[6] = w6
  o[7] = w7
  o[8] = w8
  o[9] = w9
  o[10] = w10
  o[11] = w11
  o[12] = w12
  o[13] = w13
  o[14] = w14
  o[15] = w15
  o[16] = w16
  o[17] = w17
  o[18] = w18
  if (c !== 0) {
    o[19] = c
    out.length++
  }
  return out
}

      };
    };
  }
}, {package:"secp256k1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/bn/optimized.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pss.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./random":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/random.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pss.js
      return function (require, module, exports) {
/**
 * Javascript implementation of PKCS#1 PSS signature padding.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 */
var forge = require('./forge');
require('./random');
require('./util');

// shortcut for PSS API
var pss = module.exports = forge.pss = forge.pss || {};

/**
 * Creates a PSS signature scheme object.
 *
 * There are several ways to provide a salt for encoding:
 *
 * 1. Specify the saltLength only and the built-in PRNG will generate it.
 * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that
 *   will be used.
 * 3. Specify the salt itself as a forge.util.ByteBuffer.
 *
 * @param options the options to use:
 *          md the message digest object to use, a forge md instance.
 *          mgf the mask generation function to use, a forge mgf instance.
 *          [saltLength] the length of the salt in octets.
 *          [prng] the pseudo-random number generator to use to produce a salt.
 *          [salt] the salt to use when encoding.
 *
 * @return a signature scheme object.
 */
pss.create = function(options) {
  // backwards compatibility w/legacy args: hash, mgf, sLen
  if(arguments.length === 3) {
    options = {
      md: arguments[0],
      mgf: arguments[1],
      saltLength: arguments[2]
    };
  }

  var hash = options.md;
  var mgf = options.mgf;
  var hLen = hash.digestLength;

  var salt_ = options.salt || null;
  if(typeof salt_ === 'string') {
    // assume binary-encoded string
    salt_ = forge.util.createBuffer(salt_);
  }

  var sLen;
  if('saltLength' in options) {
    sLen = options.saltLength;
  } else if(salt_ !== null) {
    sLen = salt_.length();
  } else {
    throw new Error('Salt length not specified or specific salt not given.');
  }

  if(salt_ !== null && salt_.length() !== sLen) {
    throw new Error('Given salt length does not match length of given salt.');
  }

  var prng = options.prng || forge.random;

  var pssobj = {};

  /**
   * Encodes a PSS signature.
   *
   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.
   *
   * @param md the message digest object with the hash to sign.
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return the encoded message as a binary-encoded string of length
   *           ceil((modBits - 1) / 8).
   */
  pssobj.encode = function(md, modBits) {
    var i;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);

    /* 2. Let mHash = Hash(M), an octet string of length hLen. */
    var mHash = md.digest().getBytes();

    /* 3. If emLen < hLen + sLen + 2, output "encoding error" and stop. */
    if(emLen < hLen + sLen + 2) {
      throw new Error('Message is too long to encrypt.');
    }

    /* 4. Generate a random octet string salt of length sLen; if sLen = 0,
     *    then salt is the empty string. */
    var salt;
    if(salt_ === null) {
      salt = prng.getBytesSync(sLen);
    } else {
      salt = salt_.bytes();
    }

    /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */
    var m_ = new forge.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);

    /* 6. Let H = Hash(M'), an octet string of length hLen. */
    hash.start();
    hash.update(m_.getBytes());
    var h = hash.digest().getBytes();

    /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2
     *    zero octets.  The length of PS may be 0. */
    var ps = new forge.util.ByteBuffer();
    ps.fillWithByte(0, emLen - sLen - hLen - 2);

    /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length
     *    emLen - hLen - 1. */
    ps.putByte(0x01);
    ps.putBytes(salt);
    var db = ps.getBytes();

    /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */
    var maskLen = emLen - hLen - 1;
    var dbMask = mgf.generate(h, maskLen);

    /* 10. Let maskedDB = DB \xor dbMask. */
    var maskedDB = '';
    for(i = 0; i < maskLen; i++) {
      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
    }

    /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in
     *     maskedDB to zero. */
    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;
    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) +
      maskedDB.substr(1);

    /* 12. Let EM = maskedDB || H || 0xbc.
     * 13. Output EM. */
    return maskedDB + h + String.fromCharCode(0xbc);
  };

  /**
   * Verifies a PSS signature.
   *
   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.
   *
   * @param mHash the message digest hash, as a binary-encoded string, to
   *         compare against the signature.
   * @param em the encoded message, as a binary-encoded string
   *          (RSA decryption result).
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return true if the signature was verified, false if not.
   */
  pssobj.verify = function(mHash, em, modBits) {
    var i;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);

    /* c. Convert the message representative m to an encoded message EM
     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits
     *    is the length in bits of the RSA modulus n */
    em = em.substr(-emLen);

    /* 3. If emLen < hLen + sLen + 2, output "inconsistent" and stop. */
    if(emLen < hLen + sLen + 2) {
      throw new Error('Inconsistent parameters to PSS signature verification.');
    }

    /* 4. If the rightmost octet of EM does not have hexadecimal value
     *    0xbc, output "inconsistent" and stop. */
    if(em.charCodeAt(emLen - 1) !== 0xbc) {
      throw new Error('Encoded message does not end in 0xBC.');
    }

    /* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and
     *    let H be the next hLen octets. */
    var maskLen = emLen - hLen - 1;
    var maskedDB = em.substr(0, maskLen);
    var h = em.substr(maskLen, hLen);

    /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in
     *    maskedDB are not all equal to zero, output "inconsistent" and stop. */
    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;
    if((maskedDB.charCodeAt(0) & mask) !== 0) {
      throw new Error('Bits beyond keysize not zero as expected.');
    }

    /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */
    var dbMask = mgf.generate(h, maskLen);

    /* 8. Let DB = maskedDB \xor dbMask. */
    var db = '';
    for(i = 0; i < maskLen; i++) {
      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
    }

    /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet
     * in DB to zero. */
    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);

    /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero
     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost
     * position is "position 1") does not have hexadecimal value 0x01,
     * output "inconsistent" and stop. */
    var checkLen = emLen - hLen - sLen - 2;
    for(i = 0; i < checkLen; i++) {
      if(db.charCodeAt(i) !== 0x00) {
        throw new Error('Leftmost octets not zero as expected');
      }
    }

    if(db.charCodeAt(checkLen) !== 0x01) {
      throw new Error('Inconsistent PSS signature, 0x01 marker not found');
    }

    /* 11. Let salt be the last sLen octets of DB. */
    var salt = db.substr(-sLen);

    /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */
    var m_ = new forge.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);

    /* 13. Let H' = Hash(M'), an octet string of length hLen. */
    hash.start();
    hash.update(m_.getBytes());
    var h_ = hash.digest().getBytes();

    /* 14. If H = H', output "consistent." Otherwise, output "inconsistent." */
    return h === h_;
  };

  return pssobj;
};

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pss.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/mgf.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./mgf1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/mgf1.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/mgf.js
      return function (require, module, exports) {
/**
 * Node.js module for Forge mask generation functions.
 *
 * @author Stefan Siegl
 *
 * Copyright 2012 Stefan Siegl <stesie@brokenpipe.de>
 */
var forge = require('./forge');
require('./mgf1');

module.exports = forge.mgf = forge.mgf || {};
forge.mgf.mgf1 = forge.mgf1;

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/mgf.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/utils.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/utils.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
'use strict'

exports.toCallback = (doWork) => {
  return function (input, callback) {
    let res
    try {
      res = doWork(input)
    } catch (err) {
      process.nextTick(callback, err)
      return
    }

    process.nextTick(callback, null, res)
  }
}

exports.toBuf = (doWork, other) => (input) => {
  let result = doWork(input, other)
  return Buffer.from(result, 'hex')
}

exports.fromString = (doWork, other) => (_input) => {
  const input = Buffer.isBuffer(_input) ? _input.toString() : _input
  return doWork(input, other)
}

exports.fromNumberTo32BitBuf = (doWork, other) => (input) => {
  let number = doWork(input, other)
  const bytes = new Array(4)

  for (let i = 0; i < 4; i++) {
    bytes[i] = number & 0xff
    number = number >> 8
  }

  return Buffer.from(bytes)
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/crypto-sha1-2-browser.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","nodeify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/nodeify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/crypto-sha1-2-browser.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* global self */

'use strict'

const nodeify = require('nodeify')

const webCrypto = getWebCrypto()

function getWebCrypto () {
  if (self.crypto) {
    return self.crypto.subtle || self.crypto.webkitSubtle
  }

  if (self.msCrypto) {
    return self.msCrypto.subtle
  }
}

function webCryptoHash (type) {
  if (!webCrypto) {
    throw new Error('Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context')
  }

  return (data, callback) => {
    const res = webCrypto.digest({ name: type }, data)

    if (typeof res.then !== 'function') { // IE11
      res.onerror = () => {
        callback(new Error(`hashing data using ${type}`))
      }
      res.oncomplete = (e) => {
        callback(null, e.target.result)
      }
      return
    }

    nodeify(
      res.then((raw) => Buffer.from(new Uint8Array(raw))),
      callback
    )
  }
}

function sha1 (buf, callback) {
  webCryptoHash('SHA-1')(buf, callback)
}

function sha2256 (buf, callback) {
  webCryptoHash('SHA-256')(buf, callback)
}

function sha2512 (buf, callback) {
  webCryptoHash('SHA-512')(buf, callback)
}

module.exports = {
  sha1: sha1,
  sha2256: sha2256,
  sha2512: sha2512
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/crypto-sha1-2-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/blake.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/utils.js","blakejs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/blake.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const blake = require('blakejs')

const toCallback = require('./utils').toCallback

const minB = 0xb201
const minS = 0xb241

const blake2b = {
  init: blake.blake2bInit,
  update: blake.blake2bUpdate,
  digest: blake.blake2bFinal
}

const blake2s = {
  init: blake.blake2sInit,
  update: blake.blake2sUpdate,
  digest: blake.blake2sFinal
}

const makeB2Hash = (size, hf) => toCallback((buf) => {
  const ctx = hf.init(size, null)
  hf.update(ctx, buf)
  return Buffer.from(hf.digest(ctx))
})

module.exports = (table) => {
  for (let i = 0; i < 64; i++) {
    table[minB + i] = makeB2Hash(i + 1, blake2b)
  }
  for (let i = 0; i < 32; i++) {
    table[minS + i] = makeB2Hash(i + 1, blake2s)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/blake.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-reader/state.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-reader/state.js
      return function (require, module, exports) {
(function (Buffer){(function (){

module.exports = function () {

  var buffers = [], length = 0

  //just used for debugging...
  function calcLength () {
    return buffers.reduce(function (a, b) {
      return a + b.length
    }, 0)
  }

  return {
    length: length,
    data: this,
    add: function (data) {
      if(!Buffer.isBuffer(data))
        throw new Error('data must be a buffer, was: ' + JSON.stringify(data))
      this.length = length = length + data.length
      buffers.push(data)
      return this
    },
    has: function (n) {
      if(null == n) return length > 0
      return length >= n
    },
    get: function (n) {
      var _length
      if(n == null || n === length) {
        length = 0
        var _buffers = buffers
        buffers = []
        if(_buffers.length == 1)
          return _buffers[0]
        else
          return Buffer.concat(_buffers)
      } else if (buffers.length > 1 && n <= (_length = buffers[0].length)) {
        var buf = buffers[0].slice(0, n)
        if(n === _length) {
          buffers.shift()
        }
        else {
          buffers[0] = buffers[0].slice(n, _length)
        }
        length -= n
        return buf
      }  else if(n < length) {
        var out = [], len = 0

        while((len + buffers[0].length) < n) {
          var b = buffers.shift()
          len += b.length
          out.push(b)
        }

        if(len < n) {
          out.push(buffers[0].slice(0, n - len))
          buffers[0] = buffers[0].slice(n - len, buffers[0].length)
          this.length = length = length - n
        }
        return Buffer.concat(out)
      }
      else
        throw new Error('could not get ' + n + ' bytes')
    }
  }

}






}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"pull-reader",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-reader/state.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/node_modules/multihashing-async/src/index.js", {"./crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/node_modules/multihashing-async/src/crypto.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/node_modules/multihashing-async/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const multihash = require('multihashes')
const crypto = require('./crypto')

module.exports = Multihashing

/**
 * Hash the given `buf` using the algorithm specified
 * by `func`.
 *
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
function Multihashing (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  Multihashing.digest(buf, func, length, (err, digest) => {
    if (err) {
      return callback(err)
    }

    callback(null, multihash.encode(digest, func, length))
  })
}

/**
 * The `buffer` module for easy use in the browser.
 *
 * @type {Buffer}
 */
Multihashing.Buffer = Buffer // for browser things

/**
 * Expose multihash itself, to avoid silly double requires.
 */
Multihashing.multihash = multihash

/**
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
Multihashing.digest = function (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  let cb = callback
  if (length) {
    cb = (err, digest) => {
      if (err) {
        return callback(err)
      }

      callback(null, digest.slice(0, length))
    }
  }

  let hash
  try {
    hash = Multihashing.createHash(func)
  } catch (err) {
    return cb(err)
  }

  hash(buf, cb)
}

/**
 * @param {string|number} func
 *
 * @returns {function} - The to `func` corresponding hash function.
 */
Multihashing.createHash = function (func) {
  func = multihash.coerceCode(func)
  if (!Multihashing.functions[func]) {
    throw new Error('multihash function ' + func + ' not yet supported')
  }

  return Multihashing.functions[func]
}

/**
 * Mapping of multihash codes to their hashing functions.
 * @type {Object}
 */
Multihashing.functions = {
  // sha1
  0x11: crypto.sha1,
  // sha2-256
  0x12: crypto.sha2256,
  // sha2-512
  0x13: crypto.sha2512,
  // sha3-512
  0x14: crypto.sha3512,
  // sha3-384
  0x15: crypto.sha3384,
  // sha3-256
  0x16: crypto.sha3256,
  // sha3-224
  0x17: crypto.sha3224,
  // shake-128
  0x18: crypto.shake128,
  // shake-256
  0x19: crypto.shake256,
  // keccak-224
  0x1A: crypto.keccak224,
  // keccak-256
  0x1B: crypto.keccak256,
  // keccak-384
  0x1C: crypto.keccak384,
  // keccak-512
  0x1D: crypto.keccak512,
  // murmur3-128
  0x22: crypto.murmur3128,
  // murmur3-32
  0x23: crypto.murmur332,
  // dbl-sha2-256
  0x56: crypto.dblSha2256
}

// add blake functions
crypto.addBlake(Multihashing.functions)

Multihashing.validate = (data, hash, callback) => {
  let algo = multihash.decode(hash).name
  Multihashing(data, algo, (err, newHash) => {
    if (err) return callback(err)
    callback(err, Buffer.compare(hash, newHash) === 0)
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/node_modules/multihashing-async/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/ready.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/ready.js
      return function (require, module, exports) {
module.exports = function(socket, callback) {
  var remove = socket && (socket.removeEventListener || socket.removeListener);

  function cleanup () {
    if (typeof remove == 'function') {
      remove.call(socket, 'open', handleOpen);
      remove.call(socket, 'error', handleErr);
    }
  }

  function handleOpen(evt) {
    cleanup(); callback();
  }

  function handleErr (evt) {
    cleanup(); callback(evt);
  }

  // if the socket is closing or closed, return end
  if (socket.readyState >= 2) {
    return callback(true);
  }

  // if open, trigger the callback
  if (socket.readyState === 1) {
    return callback();
  }

  socket.addEventListener('open', handleOpen);
  socket.addEventListener('error', handleErr);
};

      };
    };
  }
}, {package:"pull-ws",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/ready.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/utils.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/utils.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
'use strict'

exports.toCallback = (doWork) => {
  return function (input, callback) {
    let res
    try {
      res = doWork(input)
    } catch (err) {
      process.nextTick(callback, err)
      return
    }

    process.nextTick(callback, null, res)
  }
}

exports.toBuf = (doWork, other) => (input) => {
  let result = doWork(input, other)
  return Buffer.from(result, 'hex')
}

exports.fromString = (doWork, other) => (_input) => {
  const input = Buffer.isBuffer(_input) ? _input.toString() : _input
  return doWork(input, other)
}

exports.fromNumberTo32BitBuf = (doWork, other) => (input) => {
  let number = doWork(input, other)
  const bytes = new Array(4)

  for (let i = 0; i < 4; i++) {
    bytes[i] = number & 0xff
    number = number >> 8
  }

  return Buffer.from(bytes)
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/crypto-sha1-2-browser.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","nodeify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/nodeify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/crypto-sha1-2-browser.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* global self */

'use strict'

const nodeify = require('nodeify')

const webCrypto = getWebCrypto()

function getWebCrypto () {
  if (self.crypto) {
    return self.crypto.subtle || self.crypto.webkitSubtle
  }

  if (self.msCrypto) {
    return self.msCrypto.subtle
  }
}

function webCryptoHash (type) {
  if (!webCrypto) {
    throw new Error('Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context')
  }

  return (data, callback) => {
    const res = webCrypto.digest({ name: type }, data)

    if (typeof res.then !== 'function') { // IE11
      res.onerror = () => {
        callback(new Error(`hashing data using ${type}`))
      }
      res.oncomplete = (e) => {
        callback(null, e.target.result)
      }
      return
    }

    nodeify(
      res.then((raw) => Buffer.from(new Uint8Array(raw))),
      callback
    )
  }
}

function sha1 (buf, callback) {
  webCryptoHash('SHA-1')(buf, callback)
}

function sha2256 (buf, callback) {
  webCryptoHash('SHA-256')(buf, callback)
}

function sha2512 (buf, callback) {
  webCryptoHash('SHA-512')(buf, callback)
}

module.exports = {
  sha1: sha1,
  sha2256: sha2256,
  sha2512: sha2512
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/crypto-sha1-2-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/blake.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/utils.js","blakejs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/blake.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const blake = require('blakejs')

const toCallback = require('./utils').toCallback

const minB = 0xb201
const minS = 0xb241

const blake2b = {
  init: blake.blake2bInit,
  update: blake.blake2bUpdate,
  digest: blake.blake2bFinal
}

const blake2s = {
  init: blake.blake2sInit,
  update: blake.blake2sUpdate,
  digest: blake.blake2sFinal
}

const makeB2Hash = (size, hf) => toCallback((buf) => {
  const ctx = hf.init(size, null)
  hf.update(ctx, buf)
  return Buffer.from(hf.digest(ctx))
})

module.exports = (table) => {
  for (let i = 0; i < 64; i++) {
    table[minB + i] = makeB2Hash(i + 1, blake2b)
  }
  for (let i = 0; i < 32; i++) {
    table[minS + i] = makeB2Hash(i + 1, blake2s)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/blake.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/peer-queue.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","heap":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/heap/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js","xor-distance":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xor-distance/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/peer-queue.js
      return function (require, module, exports) {
'use strict'

const Heap = require('heap')
const distance = require('xor-distance')
const debug = require('debug')
const promisify = require('promisify-es6')

const utils = require('./utils')

const log = debug('libp2p:dht:peer-queue')

/**
 * PeerQueue is a heap that sorts its entries (PeerIds) by their
 * xor distance to the inital provided key.
 */
class PeerQueue {
  /**
   * Create from a given peer id.
   *
   * @param {PeerId} id
   * @returns {Promise<PeerQueue>}
   */
  static async fromPeerId (id) {
    const key = await promisify(cb => utils.convertPeerId(id, cb))()
    return new PeerQueue(key)
  }

  /**
   * Create from a given buffer.
   *
   * @param {Buffer} keyBuffer
   * @returns {Promise<PeerQueue>}
   */
  static async fromKey (keyBuffer) {
    const key = await promisify(cb => utils.convertBuffer(keyBuffer, cb))()
    return new PeerQueue(key)
  }

  /**
   * Create a new PeerQueue.
   *
   * @param {Buffer} from - The sha2-256 encoded peer id
   */
  constructor (from) {
    log('create: %b', from)
    this.from = from
    this.heap = new Heap(utils.xorCompare)
  }

  /**
   * Add a new PeerId to the queue.
   *
   * @param {PeerId} id
   * @returns {Promise}
   */
  async enqueue (id) {
    log('enqueue %s', id.toB58String())
    const key = await promisify(cb => utils.convertPeerId(id, cb))()

    const el = {
      id: id,
      distance: distance(this.from, key)
    }

    this.heap.push(el)
  }

  /**
   * Returns the closest peer to the `from` peer.
   *
   * @returns {PeerId}
   */
  dequeue () {
    const el = this.heap.pop()
    log('dequeue %s', el.id.toB58String())
    return el.id
  }

  get length () {
    return this.heap.size()
  }
}

module.exports = PeerQueue

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/peer-queue.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/ping.js", {"../../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/ping.js
      return function (require, module, exports) {
'use strict'

const utils = require('../../utils')

module.exports = (dht) => {
  const log = utils.logger(dht.peerInfo.id, 'rpc:ping')

  /**
   * Process `Ping` DHT messages.
   *
   * @param {PeerInfo} peer
   * @param {Message} msg
   * @param {function(Error, Message)} callback
   * @returns {undefined}
   */
  return function ping (peer, msg, callback) {
    log('from %s', peer.id.toB58String())
    callback(null, msg)
  }
}

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/ping.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/put-value.js", {"../../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/put-value.js
      return function (require, module, exports) {
'use strict'

const utils = require('../../utils')
const errcode = require('err-code')

module.exports = (dht) => {
  const log = utils.logger(dht.peerInfo.id, 'rpc:put-value')

  /**
   * Process `PutValue` DHT messages.
   *
   * @param {PeerInfo} peer
   * @param {Message} msg
   * @param {function(Error, Message)} callback
   * @returns {undefined}
   */
  return function putValue (peer, msg, callback) {
    const key = msg.key
    log('key: %b', key)

    const record = msg.record

    if (!record) {
      const errMsg = `Empty record from: ${peer.id.toB58String()}`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_EMPTY_RECORD'))
    }

    dht._verifyRecordLocally(record, (err) => {
      if (err) {
        log.error(err.message)
        return callback(err)
      }

      record.timeReceived = new Date()

      const key = utils.bufferToKey(record.key)

      dht.datastore.put(key, record.serialize(), (err) => {
        if (err) {
          return callback(err)
        }

        callback(null, msg)
      })
    })
  }
}

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/put-value.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/add-provider.js", {"../../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","promise-to-callback":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promise-to-callback/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/add-provider.js
      return function (require, module, exports) {
'use strict'

const CID = require('cids')
const errcode = require('err-code')
const promiseToCallback = require('promise-to-callback')

const utils = require('../../utils')

module.exports = (dht) => {
  const log = utils.logger(dht.peerInfo.id, 'rpc:add-provider')
  /**
   * Process `AddProvider` DHT messages.
   *
   * @param {PeerInfo} peer
   * @param {Message} msg
   * @param {function(Error)} callback
   * @returns {undefined}
   */
  return function addProvider (peer, msg, callback) {
    log('start')

    if (!msg.key || msg.key.length === 0) {
      return callback(errcode(new Error('Missing key'), 'ERR_MISSING_KEY'))
    }

    let cid
    try {
      cid = new CID(msg.key)
    } catch (err) {
      const errMsg = `Invalid CID: ${err.message}`

      return callback(errcode(new Error(errMsg), 'ERR_INVALID_CID'))
    }

    let foundProvider = false
    msg.providerPeers.forEach((pi) => {
      // Ignore providers not from the originator
      if (!pi.id.isEqual(peer.id)) {
        log('invalid provider peer %s from %s', pi.id.toB58String(), peer.id.toB58String())
        return
      }

      if (pi.multiaddrs.size < 1) {
        log('no valid addresses for provider %s. Ignore', peer.id.toB58String())
        return
      }

      log('received provider %s for %s (addrs %s)', peer.id.toB58String(), cid.toBaseEncodedString(), pi.multiaddrs.toArray().map((m) => m.toString()))

      if (!dht._isSelf(pi.id)) {
        foundProvider = true
        dht.peerBook.put(pi)
        promiseToCallback(dht.providers.addProvider(cid, pi.id))(err => callback(err))
      }
    })

    // Previous versions of the JS DHT sent erroneous providers in the
    // `providerPeers` field. In order to accommodate older clients that have
    // this bug, we fall back to assuming the originator is the provider if
    // we can't find any valid providers in the payload.
    // https://github.com/libp2p/js-libp2p-kad-dht/pull/127
    // https://github.com/libp2p/js-libp2p-kad-dht/issues/128
    if (!foundProvider) {
      promiseToCallback(dht.providers.addProvider(cid, peer.id))(err => callback(err))
    }
  }
}

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/handlers/add-provider.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9sb2Rhc2guaXNlcXVhbHdpdGgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy1iaXRzd2FwL3NyYy90eXBlcy9tZXNzYWdlL2VudHJ5LmpzIiwibm9kZV9tb2R1bGVzL3ZhcmludC1kZWNvZGVyL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWJpdHN3YXAvbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy1iaXRzd2FwL3NyYy90eXBlcy93YW50bGlzdC9lbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWJpdHN3YXAvbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanMiLCJub2RlX21vZHVsZXMvbW92aW5nLWF2ZXJhZ2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHVsbC1sZW5ndGgtcHJlZml4ZWQvc3JjL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLWxlbmd0aC1wcmVmaXhlZC9zcmMvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1yZWNvcmQvc3JjL3JlY29yZC5wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtcmVjb3JkL3NyYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtcmVjb3JkL3NyYy9zZWxlY3RvcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyLXNwbGl0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1yZWNvcmQvc3JjL3ZhbGlkYXRvcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHVsbC1tcGxleC9zcmMvY29uc3RzLmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtbXBsZXgvc3JjL3V0aWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHVsbC1tcGxleC9ub2RlX21vZHVsZXMvbG9vcGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtbXBsZXgvc3JjL2NvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtbXBsZXgvc3JjL2NoYW5uZWwuanMiLCJub2RlX21vZHVsZXMvcHVsbC10aHJvdWdoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtd3Mvc2VydmVyLmpzIiwibm9kZV9tb2R1bGVzL2ludGVyZmFjZS1jb25uZWN0aW9uL3NyYy9jb25uZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtd3Mvd2ViLXNvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXdzL3dzLXVybC5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXdzL2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9zcmMvbGltaXRlZC1wZWVyLWxpc3QuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWthZC1kaHQvc3JjL21lc3NhZ2UvZGh0LnByb3RvLmpzIiwibm9kZV9tb2R1bGVzL2hhc2hscnUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcC1xdWV1ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9rLWJ1Y2tldC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9ub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wLXRpbWVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3hvci1kaXN0YW5jZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9zcmMvcXVlcnkvcnVuLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L3NyYy9ycGMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHVsbC1oYW5kc2hha2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXNlY2lvL3NyYy9oYW5kc2hha2UvZXhjaGFuZ2UuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXNlY2lvL3NyYy9oYW5kc2hha2UvZmluaXNoLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zZWNpby9zcmMvaGFuZHNoYWtlL3Byb3Bvc2UuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXdlYnNvY2tldC1zdGFyL3NyYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtd2Vic29ja2V0LXN0YXIvc3JjL2xpc3RlbmVyLmpzIiwibm9kZV9tb2R1bGVzL2dldC1icm93c2VyLXJ0Yy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL21hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvdHJ5RWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtcGluZy9zcmMvaGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtcGluZy9zcmMvcGluZy5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtZmxvb2RzdWIvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xhdGVuY3ktbW9uaXRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc3dpdGNoL3NyYy9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXN3aXRjaC9zcmMvZ2V0LXBlZXItaW5mby5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc3dpdGNoL3NyYy9wbGFpbnRleHQuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXN3aXRjaC9zcmMvb2JzZXJ2ZXIuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXN3aXRjaC9zcmMvc3RhdHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXN3aXRjaC9zcmMvY29ubmVjdGlvbi9oYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zd2l0Y2gvc3JjL2RpYWxlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc3dpdGNoL3NyYy9jb25uZWN0aW9uL21hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXN3aXRjaC9zcmMvdHJhbnNwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jaXJjdWl0L3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc3dpdGNoL3NyYy9wcm90b2NvbC1tdXhlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1leHBvcnRlci9zcmMvcmVzb2x2ZXJzL2RhZy1jYm9yLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWV4cG9ydGVyL3NyYy9yZXNvbHZlcnMvcmF3LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWV4cG9ydGVyL3NyYy9yZXNvbHZlcnMvdW5peGZzLXYxL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvc3JjL2Rpci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9zcmMvdXRpbHMvdG8tcGF0aC1jb21wb25lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jLWl0ZXJhdG9yLWZpcnN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL3NyYy9kaXItZmxhdC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9zcmMvZmxhdC10by1zaGFyZC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9zcmMvZGFnLWJ1aWxkZXIvdmFsaWRhdGUtY2h1bmtzLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL3NyYy9kYWctYnVpbGRlci9kaXIuanMiLCJub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvc3JjL2RhZy1idWlsZGVyL2ZpbGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvc3JjL2NodW5rZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXN5bmMtaXRlcmF0b3ItdG8tc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZXJyb3JzLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYXN5bmMtaXRlcmF0b3ItdG8tc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy1pdGVyYXRvci10by1zdHJlYW0vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy1pdGVyYXRvci10by1zdHJlYW0vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy1pdGVyYXRvci10by1zdHJlYW0vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYXN5bmMtaXRlcmF0b3ItdG8tc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMiLCJub2RlX21vZHVsZXMvYXN5bmMtaXRlcmF0b3ItdG8tc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvaXBmcy1tZnMvc3JjL2NvcmUvdXRpbHMvYXBwbHktZGVmYXVsdC1vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbWZzL3NyYy9jb3JlL3V0aWxzL3RvLW1mcy1wYXRoLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbWZzL3NyYy9jb3JlL3V0aWxzL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLW1mcy9zcmMvY29yZS91dGlscy90by1zb3VyY2VzLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbWZzL3NyYy9jb3JlL3V0aWxzL3VwZGF0ZS1tZnMtcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLW1mcy9zcmMvY29yZS91dGlscy91cGRhdGUtdHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLW1mcy9zcmMvY29yZS91dGlscy9hZGQtbGluay5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLW1mcy9zcmMvY29yZS91dGlscy90by1wYXRoLWNvbXBvbmVudHMuanMiLCJub2RlX21vZHVsZXMvaXBmcy1tZnMvc3JjL2NvcmUvdXRpbHMvY3JlYXRlLW5vZGUuanMiLCJub2RlX21vZHVsZXMvaXBmcy1tZnMvc3JjL2NvcmUvdXRpbHMvd2l0aC1tZnMtcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLW1mcy9zcmMvY29yZS91dGlscy90by10cmFpbC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLW1mcy9zcmMvY29yZS91dGlscy9yZW1vdmUtbGluay5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLW1mcy9zcmMvY29yZS91dGlscy90by1hc3luYy1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLW1mcy9zcmMvY29yZS91dGlscy90by1zb3VyY2VzLWFuZC1kZXN0aW5hdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9tb3J0aWNlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3QvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3NuYXBzL2lubGluZVNuYXBzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvbmFub2lkL2luZGV4LmJyb3dzZXIuY2pzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC13b3JrZXJzL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9qc29uLXJwYy1taWRkbGV3YXJlLXN0cmVhbS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9wZXJtaXNzaW9ucy9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3Blcm1pc3Npb25zL3JwYy1tZXRob2RzL2dldFBlcm1pc3Npb25zLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9wZXJtaXNzaW9ucy9ycGMtbWV0aG9kcy9yZXF1ZXN0UGVybWlzc2lvbnMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3Blcm1pc3Npb25zL3Blcm1pc3Npb24tbWlkZGxld2FyZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvZGlzdC9kZXJpdmVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvZXRoanMtY29udHJhY3Qvbm9kZV9tb2R1bGVzL2V0aGpzLWFiaS9saWIvdXRpbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJyL3Byci5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1rZXlzdG9yZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2Vycm9ycy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWtleXN0b3JlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIta2V5c3RvcmUvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWtleXN0b3JlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIta2V5c3RvcmUvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIta2V5c3RvcmUvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1rZXlzdG9yZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2xldmVsLWNvZGVjL2xpYi9lbmNvZGluZ3MuanMiLCJub2RlX21vZHVsZXMvaWRiLXJlYWRhYmxlLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtbGV2ZWwvbm9kZV9tb2R1bGVzL2xldmVsLWpzL25vZGVfbW9kdWxlcy9hYnN0cmFjdC1sZXZlbGRvd24vYWJzdHJhY3QtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvZGF0YXN0b3JlLWxldmVsL25vZGVfbW9kdWxlcy9sZXZlbC1qcy9ub2RlX21vZHVsZXMvYWJzdHJhY3QtbGV2ZWxkb3duL2Fic3RyYWN0LWNoYWluZWQtYmF0Y2guanMiLCJub2RlX21vZHVsZXMvZGF0YXN0b3JlLWxldmVsL25vZGVfbW9kdWxlcy9sZXZlbC1qcy9ub2RlX21vZHVsZXMvYWJzdHJhY3QtbGV2ZWxkb3duL2lzLWxldmVsZG93bi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtbGV2ZWwvbm9kZV9tb2R1bGVzL2xldmVsLWpzL25vZGVfbW9kdWxlcy9hYnN0cmFjdC1sZXZlbGRvd24vYWJzdHJhY3QtbGV2ZWxkb3duLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFzdG9yZS1sZXZlbC9ub2RlX21vZHVsZXMvZGVmZXJyZWQtbGV2ZWxkb3duL2RlZmVycmVkLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFzdG9yZS1sZXZlbC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9jb25zdGFudHMvZGVyLmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9yZXBvcnRlci5qcyIsIm5vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2UvYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZW5jb2RlcnMvZGVyLmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZW5jb2RlcnMvcGVtLmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvcGVtLmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvanMvZWNwb2ludGcuanMiLCJub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9qcy9lY3BvaW50LmpzIiwibm9kZV9tb2R1bGVzL2RyYmcuanMvaG1hYy5qcyIsIm5vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2pzL2JuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RydW5jYXRlLXV0ZjgtYnl0ZXMvbGliL3RydW5jYXRlLmpzIiwibm9kZV9tb2R1bGVzL3V0ZjgtYnl0ZS1sZW5ndGgvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi94NTA5LmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BrY3M3YXNuMS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWJpdHN3YXAvbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvY3J5cHRvLmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtcmVhZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1yZWNvcmQvc3JjL3NlbGVjdG9ycy9wdWJsaWMta2V5LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci1pbmRleG9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1yZWNvcmQvc3JjL3ZhbGlkYXRvcnMvcHVibGljLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlbGF0aXZlLXVybC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXdzL3NpbmsuanMiLCJub2RlX21vZHVsZXMvcHVsbC13cy9zb3VyY2UuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWthZC1kaHQvc3JjL3BlZXItbGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9wLXF1ZXVlL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL2NyeXB0by5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9zcmMvcGVlci1kaXN0YW5jZS1saXN0LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L3NyYy9xdWVyeS93b3JrZXJRdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9zcmMvcXVlcnkvcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9zcmMvcnBjL2hhbmRsZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtcGFpci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc2VjaW8vc3JjL3N1cHBvcnQuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXNlY2lvL3NyYy9oYW5kc2hha2UvY3J5cHRvLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zZWNpby9zcmMvZXRtLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC13ZWJzb2NrZXQtc3Rhci9zcmMvZXJyb3JzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1wdWxsLXN0cmVhbS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvb24uanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWJpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG8tYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFyc2Vxcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtYmluYXJ5Mi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2lzLWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhY2tvMi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtcGluZy9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1waW5nL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1mbG9vZHN1Yi9zcmMvY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1wdWJzdWIvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xhdGVuY3ktbW9uaXRvci9kaXN0L0xhdGVuY3lNb25pdG9yLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zd2l0Y2gvc3JjL3N0YXRzL3N0YXQuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXN3aXRjaC9zcmMvc3RhdHMvb2xkLXBlZXJzLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zd2l0Y2gvc3JjL29ic2VydmUtY29ubmVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc3dpdGNoL3NyYy9jb25uZWN0aW9uL2luY29taW5nLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zd2l0Y2gvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc3dpdGNoL3NyYy9kaWFsZXIvcXVldWVNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zd2l0Y2gvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL211bHRpc3RyZWFtLXNlbGVjdC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXN3aXRjaC9zcmMvY29ubmVjdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtaWRlbnRpZnkvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zd2l0Y2gvc3JjL2xpbWl0LWRpYWxlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY2lyY3VpdC9zcmMvY2lyY3VpdC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1leHBvcnRlci9zcmMvdXRpbHMvZXh0cmFjdC1kYXRhLWZyb20tYmxvY2suanMiLCJub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtZXhwb3J0ZXIvc3JjL3V0aWxzL3ZhbGlkYXRlLW9mZnNldC1hbmQtbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWV4cG9ydGVyL3NyYy9yZXNvbHZlcnMvdW5peGZzLXYxL2NvbnRlbnQvZGlyZWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWV4cG9ydGVyL3NyYy9yZXNvbHZlcnMvdW5peGZzLXYxL2NvbnRlbnQvaGFtdC1zaGFyZGVkLWRpcmVjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1leHBvcnRlci9zcmMvcmVzb2x2ZXJzL3VuaXhmcy12MS9jb250ZW50L2ZpbGUuanMiLCJub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtZXhwb3J0ZXIvc3JjL3V0aWxzL2ZpbmQtY2lkLWluLXNoYXJkLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9lcnJvcnMtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXBmcy11dGlscy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXBmcy11dGlscy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9zcmMvdXRpbHMvcGVyc2lzdC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9zcmMvZGlyLXNoYXJkZWQuanMiLCJub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvc3JjL2RhZy1idWlsZGVyL2ZpbGUvdHJpY2tsZS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9zcmMvZGFnLWJ1aWxkZXIvZmlsZS9iYWxhbmNlZC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9zcmMvZGFnLWJ1aWxkZXIvZmlsZS9mbGF0LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL3NyYy9jaHVua2VyL3JhYmluLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL3NyYy9jaHVua2VyL2ZpeGVkLXNpemUuanMiLCJub2RlX21vZHVsZXMvaXBmcy1tZnMvc3JjL2NvcmUvdXRpbHMvaGFtdC11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlLXRpbWVvdXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JzZXJ2YWJsZS13ZWJ3b3JrZXJzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3J0aWNlL2xpYi9ub2RlLmpzIiwibm9kZV9tb2R1bGVzL21vcnRpY2UvbGliL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9uYW5vaWQvdXJsLWFscGhhYmV0L2luZGV4LmNqcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L0Jhc2VDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvQ29udHJvbGxlck1lc3Nlbmdlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L0NvbXBvc2FibGVDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvdXNlci9BZGRyZXNzQm9va0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvQXNzZXRzRGV0ZWN0aW9uQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L3VzZXIvUHJlZmVyZW5jZXNDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3Qvbm90aWZpY2F0aW9uL05vdGlmaWNhdGlvbkNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvVG9rZW5SYXRlc0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9CYXNlQ29udHJvbGxlclYyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXNzZXRzL0Fzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2FwcHJvdmFsL0FwcHJvdmFsQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2Fzc2V0cy9BY2NvdW50VHJhY2tlckNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvQ3VycmVuY3lSYXRlQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L21lc3NhZ2UtbWFuYWdlci9NZXNzYWdlTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2Fzc2V0cy9Ub2tlbkJhbGFuY2VzQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L21lc3NhZ2UtbWFuYWdlci9UeXBlZE1lc3NhZ2VNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvbWVzc2FnZS1tYW5hZ2VyL1BlcnNvbmFsTWVzc2FnZU1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvQ29sbGVjdGlibGVzQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2dhcy9HYXNGZWVDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2Fzc2V0cy9Ub2tlbkxpc3RDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXNzZXRzL1Rva2Vuc0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9uZXR3b3JrL05ldHdvcmtDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvdGhpcmQtcGFydHkvUGhpc2hpbmdDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3Qva2V5cmluZy9LZXlyaW5nQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L3RyYW5zYWN0aW9uL1RyYW5zYWN0aW9uQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9hc1N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9Db21wb3NlZFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L01lcmdlZFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L09ic2VydmFibGVTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC13b3JrZXJzL2Rpc3QvZW51bXMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9qc29uLXJwYy1taWRkbGV3YXJlLXN0cmVhbS9kaXN0L2NyZWF0ZUVuZ2luZVN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL2pzb24tcnBjLW1pZGRsZXdhcmUtc3RyZWFtL2Rpc3QvY3JlYXRlU3RyZWFtTWlkZGxld2FyZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvZGlzdC9kZXJpdmVycy9iaXAzOS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvZGlzdC9kZXJpdmVycy9iaXAzMi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtbGV2ZWwvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFzdG9yZS1sZXZlbC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFzdG9yZS1sZXZlbC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtbGV2ZWwvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtbGV2ZWwvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtbGV2ZWwvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvZGF0YXN0b3JlLWxldmVsL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9qcy9lY2pwb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9kcmJnLmpzL2xpYi9oYXNoLWluZm8uanNvbiIsIm5vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2pzL2JuL29wdGltaXplZC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wc3MuanMiLCJub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbWdmLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtYml0c3dhcC9ub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWJpdHN3YXAvbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvY3J5cHRvLXNoYTEtMi1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtYml0c3dhcC9ub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy9ibGFrZS5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXJlYWRlci9zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtcmVjb3JkL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtd3MvcmVhZHkuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWthZC1kaHQvbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWthZC1kaHQvbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvY3J5cHRvLXNoYTEtMi1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL2JsYWtlLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L3NyYy9wZWVyLXF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L3NyYy9ycGMvaGFuZGxlcnMvcGluZy5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9zcmMvcnBjL2hhbmRsZXJzL3B1dC12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9zcmMvcnBjL2hhbmRsZXJzL2FkZC1wcm92aWRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy8xRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdGJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDamtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hSQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25tQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4R0E7QUFDQTs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9IQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOW5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcndHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN6WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbm1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hHQTtBQUNBOzs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDclhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2NEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbm1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiYmFja2dyb3VuZC01LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY29tcGFyaXNvbiBzdHlsZXMuICovXG52YXIgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyA9IDEsXG4gICAgUEFSVElBTF9DT01QQVJFX0ZMQUcgPSAyO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyBkYXRhW2tleV0gIT09IHVuZGVmaW5lZCA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIGdldE1hcERhdGEodGhpcywga2V5KS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPyB2YWx1ZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfX1snZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChjYWNoZSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGNhY2hlLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjYWNoZSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgLy8gU2FmYXJpIDkgbWFrZXMgYGFyZ3VtZW50cy5sZW5ndGhgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHZhciByZXN1bHQgPSAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKVxuICAgID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKVxuICAgIDogW107XG5cbiAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXG4gICAgICBza2lwSW5kZXhlcyA9ICEhbGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAnbGVuZ3RoJyB8fCBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtiaXRtYXNrXSBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLlxuICogIFRoZSBiaXRtYXNrIG1heSBiZSBjb21wb3NlZCBvZiB0aGUgZm9sbG93aW5nIGZsYWdzOlxuICogICAgIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogICAgIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0KHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYmFzZUlzRXF1YWwsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYml0bWFza10gVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBhcnJheVRhZyxcbiAgICAgIG90aFRhZyA9IGFycmF5VGFnO1xuXG4gIGlmICghb2JqSXNBcnIpIHtcbiAgICBvYmpUYWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgfVxuICBpZiAoIW90aElzQXJyKSB7XG4gICAgb3RoVGFnID0gZ2V0VGFnKG90aGVyKTtcbiAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcbiAgfVxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3Qob2JqZWN0KSxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyAmJiAhaXNIb3N0T2JqZWN0KG90aGVyKSxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW29iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBVTk9SREVSRURfQ09NUEFSRV9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIXNlZW4uaGFzKG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5hZGQob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICogIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBVTk9SREVSRURfQ09NUEFSRV9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRyxcbiAgICAgIG9ialByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSxcbi8vIGZvciBkYXRhIHZpZXdzIGluIEVkZ2UgPCAxNCwgYW5kIHByb21pc2VzIGluIE5vZGUuanMuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzRXF1YWxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggdXAgdG9cbiAqIHNpeCBhcmd1bWVudHM6IChvYmpWYWx1ZSwgb3RoVmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIG90aGVyLCBzdGFja10pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlKSB7XG4gKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKG90aFZhbHVlKSkge1xuICogICAgIHJldHVybiB0cnVlO1xuICogICB9XG4gKiB9XG4gKlxuICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAqXG4gKiBfLmlzRXF1YWxXaXRoKGFycmF5LCBvdGhlciwgY3VzdG9taXplcik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWxXaXRoKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikge1xuICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsV2l0aDtcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBXYW50bGlzdEVudHJ5ID0gcmVxdWlyZSgnLi4vd2FudGxpc3QnKS5FbnRyeVxuY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEJpdHN3YXBNZXNzYWdlRW50cnkge1xuICBjb25zdHJ1Y3RvciAoY2lkLCBwcmlvcml0eSwgY2FuY2VsKSB7XG4gICAgYXNzZXJ0KENJRC5pc0NJRChjaWQpLCAnbmVlZHMgdmFsaWQgY2lkJylcbiAgICB0aGlzLmVudHJ5ID0gbmV3IFdhbnRsaXN0RW50cnkoY2lkLCBwcmlvcml0eSlcbiAgICB0aGlzLmNhbmNlbCA9IEJvb2xlYW4oY2FuY2VsKVxuICB9XG5cbiAgZ2V0IGNpZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cnkuY2lkXG4gIH1cblxuICBzZXQgY2lkIChjaWQpIHtcbiAgICB0aGlzLmVudHJ5LmNpZCA9IGNpZFxuICB9XG5cbiAgZ2V0IHByaW9yaXR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyeS5wcmlvcml0eVxuICB9XG5cbiAgc2V0IHByaW9yaXR5ICh2YWwpIHtcbiAgICB0aGlzLmVudHJ5LnByaW9yaXR5ID0gdmFsXG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10gKCkge1xuICAgIGNvbnN0IGNpZFN0ciA9IHRoaXMuY2lkLnRvQmFzZUVuY29kZWRTdHJpbmcoKVxuXG4gICAgcmV0dXJuIGBCaXRzd2FwTWVzc2FnZUVudHJ5ICR7Y2lkU3RyfSA8Y2FuY2VsOiAke3RoaXMuY2FuY2VsfSwgcHJpb3JpdHk6ICR7dGhpcy5wcmlvcml0eX0+YFxuICB9XG5cbiAgZXF1YWxzIChvdGhlcikge1xuICAgIHJldHVybiAodGhpcy5jYW5jZWwgPT09IG90aGVyLmNhbmNlbCkgJiZcbiAgICAgICAgICAgdGhpcy5lbnRyeS5lcXVhbHMob3RoZXIuZW50cnkpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChidWYpID0+IHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYXJnIG5lZWRzIHRvIGJlIGEgYnVmZmVyJylcbiAgfVxuXG4gIGxldCByZXN1bHQgPSBbXVxuXG4gIHdoaWxlIChidWYubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IG51bSA9IHZhcmludC5kZWNvZGUoYnVmKVxuICAgIHJlc3VsdC5wdXNoKG51bSlcbiAgICBidWYgPSBidWYuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtdWx0aWhhc2ggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpXG5cbm1vZHVsZS5leHBvcnRzID0gTXVsdGloYXNoaW5nXG5cbi8qKlxuICogSGFzaCB0aGUgZ2l2ZW4gYGJ1ZmAgdXNpbmcgdGhlIGFsZ29yaXRobSBzcGVjaWZpZWRcbiAqIGJ5IGBmdW5jYC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIC0gVGhlIHZhbHVlIHRvIGhhc2guXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGZ1bmMgLSBUaGUgYWxnb3JpdGhtIHRvIHVzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSAtIE9wdGlvbmFsbHkgdHJpbSB0aGUgcmVzdWx0IHRvIHRoaXMgbGVuZ3RoLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQnVmZmVyKX0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIE11bHRpaGFzaGluZyAoYnVmLCBmdW5jLCBsZW5ndGgsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgbGVuZ3RoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBsZW5ndGhcbiAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY2FsbGJhY2snKVxuICB9XG5cbiAgTXVsdGloYXNoaW5nLmRpZ2VzdChidWYsIGZ1bmMsIGxlbmd0aCwgKGVyciwgZGlnZXN0KSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBtdWx0aWhhc2guZW5jb2RlKGRpZ2VzdCwgZnVuYywgbGVuZ3RoKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBUaGUgYGJ1ZmZlcmAgbW9kdWxlIGZvciBlYXN5IHVzZSBpbiB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAdHlwZSB7QnVmZmVyfVxuICovXG5NdWx0aWhhc2hpbmcuQnVmZmVyID0gQnVmZmVyIC8vIGZvciBicm93c2VyIHRoaW5nc1xuXG4vKipcbiAqIEV4cG9zZSBtdWx0aWhhc2ggaXRzZWxmLCB0byBhdm9pZCBzaWxseSBkb3VibGUgcmVxdWlyZXMuXG4gKi9cbk11bHRpaGFzaGluZy5tdWx0aWhhc2ggPSBtdWx0aWhhc2hcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIC0gVGhlIHZhbHVlIHRvIGhhc2guXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGZ1bmMgLSBUaGUgYWxnb3JpdGhtIHRvIHVzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSAtIE9wdGlvbmFsbHkgdHJpbSB0aGUgcmVzdWx0IHRvIHRoaXMgbGVuZ3RoLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQnVmZmVyKX0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbk11bHRpaGFzaGluZy5kaWdlc3QgPSBmdW5jdGlvbiAoYnVmLCBmdW5jLCBsZW5ndGgsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgbGVuZ3RoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBsZW5ndGhcbiAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY2FsbGJhY2snKVxuICB9XG5cbiAgbGV0IGNiID0gY2FsbGJhY2tcbiAgaWYgKGxlbmd0aCkge1xuICAgIGNiID0gKGVyciwgZGlnZXN0KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRpZ2VzdC5zbGljZSgwLCBsZW5ndGgpKVxuICAgIH1cbiAgfVxuXG4gIGxldCBoYXNoXG4gIHRyeSB7XG4gICAgaGFzaCA9IE11bHRpaGFzaGluZy5jcmVhdGVIYXNoKGZ1bmMpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBjYihlcnIpXG4gIH1cblxuICBoYXNoKGJ1ZiwgY2IpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBmdW5jXG4gKlxuICogQHJldHVybnMge2Z1bmN0aW9ufSAtIFRoZSB0byBgZnVuY2AgY29ycmVzcG9uZGluZyBoYXNoIGZ1bmN0aW9uLlxuICovXG5NdWx0aWhhc2hpbmcuY3JlYXRlSGFzaCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGZ1bmMgPSBtdWx0aWhhc2guY29lcmNlQ29kZShmdW5jKVxuICBpZiAoIU11bHRpaGFzaGluZy5mdW5jdGlvbnNbZnVuY10pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpaGFzaCBmdW5jdGlvbiAnICsgZnVuYyArICcgbm90IHlldCBzdXBwb3J0ZWQnKVxuICB9XG5cbiAgcmV0dXJuIE11bHRpaGFzaGluZy5mdW5jdGlvbnNbZnVuY11cbn1cblxuLyoqXG4gKiBNYXBwaW5nIG9mIG11bHRpaGFzaCBjb2RlcyB0byB0aGVpciBoYXNoaW5nIGZ1bmN0aW9ucy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbk11bHRpaGFzaGluZy5mdW5jdGlvbnMgPSB7XG4gIC8vIHNoYTFcbiAgMHgxMTogY3J5cHRvLnNoYTEsXG4gIC8vIHNoYTItMjU2XG4gIDB4MTI6IGNyeXB0by5zaGEyMjU2LFxuICAvLyBzaGEyLTUxMlxuICAweDEzOiBjcnlwdG8uc2hhMjUxMixcbiAgLy8gc2hhMy01MTJcbiAgMHgxNDogY3J5cHRvLnNoYTM1MTIsXG4gIC8vIHNoYTMtMzg0XG4gIDB4MTU6IGNyeXB0by5zaGEzMzg0LFxuICAvLyBzaGEzLTI1NlxuICAweDE2OiBjcnlwdG8uc2hhMzI1NixcbiAgLy8gc2hhMy0yMjRcbiAgMHgxNzogY3J5cHRvLnNoYTMyMjQsXG4gIC8vIHNoYWtlLTEyOFxuICAweDE4OiBjcnlwdG8uc2hha2UxMjgsXG4gIC8vIHNoYWtlLTI1NlxuICAweDE5OiBjcnlwdG8uc2hha2UyNTYsXG4gIC8vIGtlY2Nhay0yMjRcbiAgMHgxQTogY3J5cHRvLmtlY2NhazIyNCxcbiAgLy8ga2VjY2FrLTI1NlxuICAweDFCOiBjcnlwdG8ua2VjY2FrMjU2LFxuICAvLyBrZWNjYWstMzg0XG4gIDB4MUM6IGNyeXB0by5rZWNjYWszODQsXG4gIC8vIGtlY2Nhay01MTJcbiAgMHgxRDogY3J5cHRvLmtlY2NhazUxMixcbiAgLy8gbXVybXVyMy0xMjhcbiAgMHgyMjogY3J5cHRvLm11cm11cjMxMjgsXG4gIC8vIG11cm11cjMtMzJcbiAgMHgyMzogY3J5cHRvLm11cm11cjMzMixcbiAgLy8gZGJsLXNoYTItMjU2XG4gIDB4NTY6IGNyeXB0by5kYmxTaGEyMjU2XG59XG5cbi8vIGFkZCBibGFrZSBmdW5jdGlvbnNcbmNyeXB0by5hZGRCbGFrZShNdWx0aWhhc2hpbmcuZnVuY3Rpb25zKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcblxuY2xhc3MgV2FudExpc3RFbnRyeSB7XG4gIGNvbnN0cnVjdG9yIChjaWQsIHByaW9yaXR5KSB7XG4gICAgYXNzZXJ0KENJRC5pc0NJRChjaWQpLCAnbXVzdCBiZSB2YWxpZCBDSUQnKVxuXG4gICAgLy8gS2VlcCB0cmFjayBvZiBob3cgbWFueSByZXF1ZXN0cyB3ZSBoYXZlIGZvciB0aGlzIGtleVxuICAgIHRoaXMuX3JlZkNvdW50ZXIgPSAxXG5cbiAgICB0aGlzLmNpZCA9IGNpZFxuICAgIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eSB8fCAxXG4gIH1cblxuICBpbmMgKCkge1xuICAgIHRoaXMuX3JlZkNvdW50ZXIgKz0gMVxuICB9XG5cbiAgZGVjICgpIHtcbiAgICB0aGlzLl9yZWZDb3VudGVyID0gTWF0aC5tYXgoMCwgdGhpcy5fcmVmQ291bnRlciAtIDEpXG4gIH1cblxuICBoYXNSZWZzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmQ291bnRlciA+IDBcbiAgfVxuXG4gIC8vIFNvIHRoYXQgY29uc29sZS5sb2cgcHJpbnRzIGEgbmljZSBkZXNjcmlwdGlvbiBvZiB0aGlzIG9iamVjdFxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10gKCkge1xuICAgIGNvbnN0IGNpZFN0ciA9IHRoaXMuY2lkLnRvQmFzZUVuY29kZWRTdHJpbmcoKVxuICAgIHJldHVybiBgV2FudGxpc3RFbnRyeSA8a2V5OiAke2NpZFN0cn0sIHByaW9yaXR5OiAke3RoaXMucHJpb3JpdHl9LCByZWZzOiAke3RoaXMuX3JlZkNvdW50ZXJ9PmBcbiAgfVxuXG4gIGVxdWFscyAob3RoZXIpIHtcbiAgICByZXR1cm4gKHRoaXMuX3JlZkNvdW50ZXIgPT09IG90aGVyLl9yZWZDb3VudGVyKSAmJlxuICAgICAgdGhpcy5jaWQuZXF1YWxzKG90aGVyLmNpZCkgJiZcbiAgICAgIHRoaXMucHJpb3JpdHkgPT09IG90aGVyLnByaW9yaXR5XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXYW50TGlzdEVudHJ5XG4iLCI7KGZ1bmN0aW9uIChnbG9iYWxPYmplY3QpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4vKlxyXG4gKiAgICAgIGJpZ251bWJlci5qcyB2OC4xLjFcclxuICogICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAxOSBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgICAgIE1JVCBMaWNlbnNlZC5cclxuICpcclxuICogICAgICBCaWdOdW1iZXIucHJvdG90eXBlIG1ldGhvZHMgICAgIHwgIEJpZ051bWJlciBtZXRob2RzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgIGFicyAgICB8ICBjbG9uZVxyXG4gKiAgICAgIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgICAgICAgfCAgY29uZmlnICAgICAgICAgICAgICAgc2V0XHJcbiAqICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgIGRwICAgICB8ICAgICAgREVDSU1BTF9QTEFDRVNcclxuICogICAgICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgZGl2ICAgIHwgICAgICBST1VORElOR19NT0RFXHJcbiAqICAgICAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgIGlkaXYgICB8ICAgICAgRVhQT05FTlRJQUxfQVRcclxuICogICAgICBleHBvbmVudGlhdGVkQnkgICAgICAgICAgcG93ICAgIHwgICAgICBSQU5HRVxyXG4gKiAgICAgIGludGVnZXJWYWx1ZSAgICAgICAgICAgICAgICAgICAgfCAgICAgIENSWVBUT1xyXG4gKiAgICAgIGlzRXF1YWxUbyAgICAgICAgICAgICAgICBlcSAgICAgfCAgICAgIE1PRFVMT19NT0RFXHJcbiAqICAgICAgaXNGaW5pdGUgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgUE9XX1BSRUNJU0lPTlxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW4gICAgICAgICAgICBndCAgICAgfCAgICAgIEZPUk1BVFxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8gICBndGUgICAgfCAgICAgIEFMUEhBQkVUXHJcbiAqICAgICAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgICB8ICBpc0JpZ051bWJlclxyXG4gKiAgICAgIGlzTGVzc1RoYW4gICAgICAgICAgICAgICBsdCAgICAgfCAgbWF4aW11bSAgICAgICAgICAgICAgbWF4XHJcbiAqICAgICAgaXNMZXNzVGhhbk9yRXF1YWxUbyAgICAgIGx0ZSAgICB8ICBtaW5pbXVtICAgICAgICAgICAgICBtaW5cclxuICogICAgICBpc05hTiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJhbmRvbVxyXG4gKiAgICAgIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgICAgICAgfCAgc3VtXHJcbiAqICAgICAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgaXNaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbWludXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbW9kdWxvICAgICAgICAgICAgICAgICAgIG1vZCAgICB8XHJcbiAqICAgICAgbXVsdGlwbGllZEJ5ICAgICAgICAgICAgIHRpbWVzICB8XHJcbiAqICAgICAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcGx1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcHJlY2lzaW9uICAgICAgICAgICAgICAgIHNkICAgICB8XHJcbiAqICAgICAgc2hpZnRlZEJ5ICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgIHNxcnQgICB8XHJcbiAqICAgICAgdG9FeHBvbmVudGlhbCAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GaXhlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9Gb3JtYXQgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GcmFjdGlvbiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9KU09OICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9OdW1iZXIgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9QcmVjaXNpb24gICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbiAgdmFyIEJpZ051bWJlcixcclxuICAgIGlzTnVtZXJpYyA9IC9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcsXHJcblxyXG4gICAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cclxuICAgIGJpZ251bWJlckVycm9yID0gJ1tCaWdOdW1iZXIgRXJyb3JdICcsXHJcbiAgICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgICBCQVNFID0gMWUxNCxcclxuICAgIExPR19CQVNFID0gMTQsXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXHJcbiAgICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gICAgLy8gRURJVEFCTEVcclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxyXG4gICAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gICAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xvbmUoY29uZmlnT2JqZWN0KSB7XHJcbiAgICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IEJpZ051bWJlciwgdG9TdHJpbmc6IG51bGwsIHZhbHVlT2Y6IG51bGwgfSxcclxuICAgICAgT05FID0gbmV3IEJpZ051bWJlcigxKSxcclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cclxuICAgICAgLy8gVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5zZXQuXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAgIC8vIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgLy8gRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgLy8gSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAvLyBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzICd0cnVuY2F0ZWQgZGl2aXNpb24nIGFuZCBpc1xyXG4gICAgICAvLyAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cclxuICAgICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgICAgLy8gRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcclxuICAgICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgICAgLy8gQWx0aG91Z2ggdGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvIGJlIHVzZWQsIHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgUE9XX1BSRUNJU0lPTiA9IDAsICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgICBGT1JNQVQgPSB7XHJcbiAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgICAgc3VmZml4OiAnJ1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gVGhlIGFscGhhYmV0IHVzZWQgZm9yIGJhc2UgY29udmVyc2lvbi4gSXQgbXVzdCBiZSBhdCBsZWFzdCAyIGNoYXJhY3RlcnMgbG9uZywgd2l0aCBubyAnKycsXHJcbiAgICAgIC8vICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgIC8vICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJ1xyXG4gICAgICBBTFBIQUJFVCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xyXG5cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUlxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhlIEJpZ051bWJlciBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJpZ051bWJlciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogdiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAqIFtiXSB7bnVtYmVyfSBUaGUgYmFzZSBvZiB2LiBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJpZ051bWJlcih2LCBiKSB7XHJcbiAgICAgIHZhciBhbHBoYWJldCwgYywgY2FzZUNoYW5nZWQsIGUsIGksIGlzTnVtLCBsZW4sIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgYG5ld2AuXHJcbiAgICAgIGlmICghKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpKSByZXR1cm4gbmV3IEJpZ051bWJlcih2LCBiKTtcclxuXHJcbiAgICAgIGlmIChiID09IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHYgJiYgdi5faXNCaWdOdW1iZXIgPT09IHRydWUpIHtcclxuICAgICAgICAgIHgucyA9IHYucztcclxuXHJcbiAgICAgICAgICBpZiAoIXYuYyB8fCB2LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHYuZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5lID0gdi5lO1xyXG4gICAgICAgICAgICB4LmMgPSB2LmMuc2xpY2UoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpICYmIHYgKiAwID09IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBVc2UgYDEgLyBuYCB0byBoYW5kbGUgbWludXMgemVybyBhbHNvLlxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHYgPSAtdiwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGludGVnZXJzLCB3aGVyZSBuIDwgMjE0NzQ4MzY0OCAoMioqMzEpLlxyXG4gICAgICAgICAgaWYgKHYgPT09IH5+dikge1xyXG4gICAgICAgICAgICBmb3IgKGUgPSAwLCBpID0gdjsgaSA+PSAxMDsgaSAvPSAxMCwgZSsrKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgICB4LmMgPSBbdl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBpZiAoIWlzTnVtZXJpYy50ZXN0KHN0ciA9IFN0cmluZyh2KSkpIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSk7XHJcblxyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgICAgICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgICAgICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgICAgIC8vIEludGVnZXIuXHJcbiAgICAgICAgICBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG5cclxuICAgICAgICAvLyBBbGxvdyBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudCwgd2hpbGVcclxuICAgICAgICAvLyBhbHNvIHJvdW5kaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXHJcbiAgICAgICAgaWYgKGIgPT0gMTApIHtcclxuICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHYpO1xyXG4gICAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcblxyXG4gICAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgaWYgKHYgKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICAgIGUgPSBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBzdHIgaXMgYSB2YWxpZCBiYXNlIGIgbnVtYmVyLlxyXG4gICAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcodiksIGlzTnVtLCBiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICAgIGlzTnVtID0gZmFsc2U7XHJcbiAgICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7KTtcclxuXHJcbiAgICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgICAgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgICAgbGVuID4gMTUgJiYgKHYgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHYgIT09IG1hdGhmbG9vcih2KSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7ICAvLyBpIDwgMVxyXG5cclxuICAgICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpID0gTE9HX0JBU0UgLSAoc3RyID0gc3RyLnNsaWNlKGkpKS5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIHguYy5wdXNoKCtzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICAgIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQWNjZXB0IGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyAoaWYgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaXNcclxuICAgICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgICAqXHJcbiAgICAgKiAgIERFQ0lNQUxfUExBQ0VTICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAgICogICBFWFBPTkVOVElBTF9BVCAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAgb3IgIFstTUFYIHRvIDAsIDAgdG8gTUFYXVxyXG4gICAgICogICBSQU5HRSAgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAobm90IHplcm8pICBvciAgWy1NQVggdG8gLTEsIDEgdG8gTUFYXVxyXG4gICAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICAgKiAgIE1PRFVMT19NT0RFICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOVxyXG4gICAgICogICBQT1dfUFJFQ0lTSU9OICAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb250YWluICcuJy5cclxuICAgICAqICAgRk9STUFUICAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggc29tZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cclxuICAgICAqICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGRlY2ltYWxTZXBhcmF0b3IgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAgICogICAgIHN1ZmZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICpcclxuICAgICAqIEUuZy5cclxuICAgICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAgICpcclxuICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCBleGNlcHQgZm9yIEFMUEhBQkVULlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHZhciBwLCB2O1xyXG5cclxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIERFQ0lNQUxfUExBQ0VTIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUk9VTkRJTkdfTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdFWFBPTkVOVElBTF9BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgMCwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtKFRPX0VYUF9QT1MgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JBTkdFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAtMSwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMSwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgICBNQVhfRVhQID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBNSU5fRVhQID0gLShNQVhfRVhQID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGNhbm5vdCBiZSB6ZXJvOiAnICsgdik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIENSWVBUTyBub3QgdHJ1ZSBvciBmYWxzZToge3Z9J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gISF2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9ICF2O1xyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgdHJ1ZSBvciBmYWxzZTogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnTU9EVUxPX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgICAgTU9EVUxPX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFBPV19QUkVDSVNJT04ge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1BPV19QUkVDSVNJT04nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnb2JqZWN0JykgRk9STUFUID0gdjtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IGFuIG9iamVjdDogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQUxQSEFCRVQgaW52YWxpZDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0FMUEhBQkVUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FsbG93IGlmIG9ubHkgb25lIGNoYXJhY3RlcixcclxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgY29udGFpbnMgJysnLCAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgYSByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uJHxbKy0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICAgIEFMUEhBQkVUID0gdjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBpbnZhbGlkOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gT2JqZWN0IGV4cGVjdGVkOiB7dn0nXHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdPYmplY3QgZXhwZWN0ZWQ6ICcgKyBvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBERUNJTUFMX1BMQUNFUzogREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgUk9VTkRJTkdfTU9ERTogUk9VTkRJTkdfTU9ERSxcclxuICAgICAgICBFWFBPTkVOVElBTF9BVDogW1RPX0VYUF9ORUcsIFRPX0VYUF9QT1NdLFxyXG4gICAgICAgIFJBTkdFOiBbTUlOX0VYUCwgTUFYX0VYUF0sXHJcbiAgICAgICAgQ1JZUFRPOiBDUllQVE8sXHJcbiAgICAgICAgTU9EVUxPX01PREU6IE1PRFVMT19NT0RFLFxyXG4gICAgICAgIFBPV19QUkVDSVNJT046IFBPV19QUkVDSVNJT04sXHJcbiAgICAgICAgRk9STUFUOiBGT1JNQVQsXHJcbiAgICAgICAgQUxQSEFCRVQ6IEFMUEhBQkVUXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdiBpcyBhIEJpZ051bWJlciBpbnN0YW5jZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBJZiBCaWdOdW1iZXIuREVCVUcgaXMgdHJ1ZSwgdGhyb3cgaWYgYSBCaWdOdW1iZXIgaW5zdGFuY2UgaXMgbm90IHdlbGwtZm9ybWVkLlxyXG4gICAgICpcclxuICAgICAqIHYge2FueX1cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gSW52YWxpZCBCaWdOdW1iZXI6IHt2fSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgaWYgKCF2IHx8IHYuX2lzQmlnTnVtYmVyICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICghQmlnTnVtYmVyLkRFQlVHKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciBpLCBuLFxyXG4gICAgICAgIGMgPSB2LmMsXHJcbiAgICAgICAgZSA9IHYuZSxcclxuICAgICAgICBzID0gdi5zO1xyXG5cclxuICAgICAgb3V0OiBpZiAoe30udG9TdHJpbmcuY2FsbChjKSA9PSAnW29iamVjdCBBcnJheV0nKSB7XHJcblxyXG4gICAgICAgIGlmICgocyA9PT0gMSB8fCBzID09PSAtMSkgJiYgZSA+PSAtTUFYICYmIGUgPD0gTUFYICYmIGUgPT09IG1hdGhmbG9vcihlKSkge1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBlbGVtZW50IGlzIHplcm8sIHRoZSBCaWdOdW1iZXIgdmFsdWUgbXVzdCBiZSB6ZXJvLlxyXG4gICAgICAgICAgaWYgKGNbMF0gPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGUgPT09IDAgJiYgYy5sZW5ndGggPT09IDEpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgdGhhdCBjWzBdIHNob3VsZCBoYXZlLCBiYXNlZCBvbiB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGkgPCAxKSBpICs9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgICAgICAvL2lmIChNYXRoLmNlaWwoTWF0aC5sb2coY1swXSArIDEpIC8gTWF0aC5MTjEwKSA9PSBpKSB7XHJcbiAgICAgICAgICBpZiAoU3RyaW5nKGNbMF0pLmxlbmd0aCA9PSBpKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIG4gPSBjW2ldO1xyXG4gICAgICAgICAgICAgIGlmIChuIDwgMCB8fCBuID49IEJBU0UgfHwgbiAhPT0gbWF0aGZsb29yKG4pKSBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExhc3QgZWxlbWVudCBjYW5ub3QgYmUgemVybywgdW5sZXNzIGl0IGlzIHRoZSBvbmx5IGVsZW1lbnQuXHJcbiAgICAgICAgICAgIGlmIChuICE9PSAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAvLyBJbmZpbml0eS9OYU5cclxuICAgICAgfSBlbHNlIGlmIChjID09PSBudWxsICYmIGUgPT09IG51bGwgJiYgKHMgPT09IG51bGwgfHwgcyA9PT0gMSB8fCBzID09PSAtMSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnSW52YWxpZCBCaWdOdW1iZXI6ICcgKyB2KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1heGltdW0gPSBCaWdOdW1iZXIubWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmx0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1pbmltdW0gPSBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmd0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLFxyXG4gICAgICogYW5kIHdpdGggZHAsIG9yIERFQ0lNQUxfUExBQ0VTIGlmIGRwIGlzIG9taXR0ZWQsIGRlY2ltYWwgcGxhY2VzIChvciBsZXNzIGlmIHRyYWlsaW5nXHJcbiAgICAgKiB6ZXJvcyBhcmUgcHJvZHVjZWQpLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5yYW5kb20gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgcG93Ml81MyA9IDB4MjAwMDAwMDAwMDAwMDA7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gYSA1MyBiaXQgaW50ZWdlciBuLCB3aGVyZSAwIDw9IG4gPCA5MDA3MTk5MjU0NzQwOTkyLlxyXG4gICAgICAvLyBDaGVjayBpZiBNYXRoLnJhbmRvbSgpIHByb2R1Y2VzIG1vcmUgdGhhbiAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXHJcbiAgICAgIC8vIElmIGl0IGRvZXMsIGFzc3VtZSBhdCBsZWFzdCA1MyBiaXRzIGFyZSBwcm9kdWNlZCwgb3RoZXJ3aXNlIGFzc3VtZSBhdCBsZWFzdCAzMCBiaXRzLlxyXG4gICAgICAvLyAweDQwMDAwMDAwIGlzIDJeMzAsIDB4ODAwMDAwIGlzIDJeMjMsIDB4MWZmZmZmIGlzIDJeMjEgLSAxLlxyXG4gICAgICB2YXIgcmFuZG9tNTNiaXRJbnQgPSAoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpICYgMHgxZmZmZmZcclxuICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aGZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKTsgfVxyXG4gICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKE1hdGgucmFuZG9tKCkgKiAweDQwMDAwMDAwIHwgMCkgKiAweDgwMDAwMCkgK1xyXG4gICAgICAgICAoTWF0aC5yYW5kb20oKSAqIDB4ODAwMDAwIHwgMCk7IH07XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRwKSB7XHJcbiAgICAgICAgdmFyIGEsIGIsIGUsIGssIHYsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGMgPSBbXSxcclxuICAgICAgICAgIHJhbmQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAgIGlmIChkcCA9PSBudWxsKSBkcCA9IERFQ0lNQUxfUExBQ0VTO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcblxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChkcCAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgaWYgKENSWVBUTykge1xyXG5cclxuICAgICAgICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICAgICAgICAgIGlmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcblxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoayAqPSAyKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDUzIGJpdHM6XHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSAqIE1hdGgucG93KDIsIDIxKSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTEwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMFxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgPj4+IDExKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMHgyMDAwMCBpcyAyXjIxLlxyXG4gICAgICAgICAgICAgIHYgPSBhW2ldICogMHgyMDAwMCArIChhW2kgKyAxXSA+Pj4gMTEpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBSZWplY3Rpb24gc2FtcGxpbmc6XHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIC8vIFByb2JhYmlsaXR5IHRoYXQgdiA+PSA5ZTE1LCBpc1xyXG4gICAgICAgICAgICAgIC8vIDcxOTkyNTQ3NDA5OTIgLyA5MDA3MTk5MjU0NzQwOTkyIH49IDAuMDAwOCwgaS5lLiAxIGluIDEyNTFcclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBiID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpO1xyXG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbMF07XHJcbiAgICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPD0gODk5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBidWZmZXJcclxuICAgICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDcpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMDAwMDAgaXMgMl40OCwgMHgxMDAwMDAwMDAwMCBpcyAyXjQwXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAgaXMgMl4zMiwgMHgxMDAwMDAwIGlzIDJeMjRcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICB2ID0gKChhW2ldICYgMzEpICogMHgxMDAwMDAwMDAwMDAwKSArIChhW2kgKyAxXSAqIDB4MTAwMDAwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgMl0gKiAweDEwMDAwMDAwMCkgKyAoYVtpICsgM10gKiAweDEwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgNF0gPDwgMTYpICsgKGFbaSArIDVdIDw8IDgpICsgYVtpICsgNl07XHJcblxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KGEsIGkpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSA3O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBDUllQVE8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbS5cclxuICAgICAgICBpZiAoIUNSWVBUTykge1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuICAgICAgICAgICAgdiA9IHJhbmRvbTUzYml0SW50KCk7XHJcbiAgICAgICAgICAgIGlmICh2IDwgOWUxNSkgY1tpKytdID0gdiAlIDFlMTQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBrID0gY1stLWldO1xyXG4gICAgICAgIGRwICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gZHAuXHJcbiAgICAgICAgaWYgKGsgJiYgZHApIHtcclxuICAgICAgICAgIHYgPSBQT1dTX1RFTltMT0dfQkFTRSAtIGRwXTtcclxuICAgICAgICAgIGNbaV0gPSBtYXRoZmxvb3IoayAvIHYpICogdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVyby5cclxuICAgICAgICBmb3IgKDsgY1tpXSA9PT0gMDsgYy5wb3AoKSwgaS0tKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIGMgPSBbZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8gYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGZvciAoZSA9IC0xIDsgY1swXSA9PT0gMDsgYy5zcGxpY2UoMCwgMSksIGUgLT0gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYyB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcywgYW5kLi4uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCB2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICAvLyBhZGp1c3QgdGhlIGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgaWYgKGkgPCBMT0dfQkFTRSkgZSAtPSBMT0dfQkFTRSAtIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByYW5kLmUgPSBlO1xyXG4gICAgICAgIHJhbmQuYyA9IGM7XHJcbiAgICAgICAgcmV0dXJuIHJhbmQ7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuc3VtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgICBzdW0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOykgc3VtID0gc3VtLnBsdXMoYXJnc1tpKytdKTtcclxuICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIFBSSVZBVEUgRlVOQ1RJT05TXHJcblxyXG5cclxuICAgIC8vIENhbGxlZCBieSBCaWdOdW1iZXIgYW5kIEJpZ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcuXHJcbiAgICBjb252ZXJ0QmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBkZWNpbWFsID0gJzAxMjM0NTY3ODknO1xyXG5cclxuICAgICAgLypcclxuICAgICAgICogQ29udmVydCBzdHJpbmcgb2YgYmFzZUluIHRvIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYmFzZU91dC5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGFscGhhYmV0KSB7XHJcbiAgICAgICAgdmFyIGosXHJcbiAgICAgICAgICBhcnIgPSBbMF0sXHJcbiAgICAgICAgICBhcnJMLFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGxlbjspIHtcclxuICAgICAgICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgYXJyW2FyckxdICo9IGJhc2VJbik7XHJcblxyXG4gICAgICAgICAgYXJyWzBdICs9IGFscGhhYmV0LmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcclxuXHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcclxuICAgICAgICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PSBudWxsKSBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyLnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VJbiB0byBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgdG9TdHJpbmcsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZSAxMCB0byBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIEJpZ051bWJlciwgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlSW4gdG8gYmFzZSAxMC5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIsIGJhc2VJbiwgYmFzZU91dCwgc2lnbiwgY2FsbGVySXNUb1N0cmluZykge1xyXG4gICAgICAgIHZhciBhbHBoYWJldCwgZCwgZSwgaywgciwgeCwgeGMsIHksXHJcbiAgICAgICAgICBpID0gc3RyLmluZGV4T2YoJy4nKSxcclxuICAgICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgICBybSA9IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICAgIGsgPSBQT1dfUFJFQ0lTSU9OO1xyXG5cclxuICAgICAgICAgIC8vIFVubGltaXRlZCBwcmVjaXNpb24uXHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gMDtcclxuICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYmFzZUluKTtcclxuICAgICAgICAgIHggPSB5LnBvdyhzdHIubGVuZ3RoIC0gaSk7XHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gaztcclxuXHJcbiAgICAgICAgICAvLyBDb252ZXJ0IHN0ciBhcyBpZiBhbiBpbnRlZ2VyLCB0aGVuIHJlc3RvcmUgdGhlIGZyYWN0aW9uIHBhcnQgYnkgZGl2aWRpbmcgdGhlXHJcbiAgICAgICAgICAvLyByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIuXHJcblxyXG4gICAgICAgICAgeS5jID0gdG9CYXNlT3V0KHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKHguYyksIHguZSwgJzAnKSxcclxuICAgICAgICAgICAxMCwgYmFzZU91dCwgZGVjaW1hbCk7XHJcbiAgICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGludGVnZXIuXHJcblxyXG4gICAgICAgIHhjID0gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBjYWxsZXJJc1RvU3RyaW5nXHJcbiAgICAgICAgID8gKGFscGhhYmV0ID0gQUxQSEFCRVQsIGRlY2ltYWwpXHJcbiAgICAgICAgIDogKGFscGhhYmV0ID0gZGVjaW1hbCwgQUxQSEFCRVQpKTtcclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGFzIGFuIGludGVnZXIgYW5kIGNvbnZlcnRlZCB0byBiYXNlT3V0LiBlIGlzIHRoZSBleHBvbmVudC5cclxuICAgICAgICBlID0gayA9IHhjLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyB4Y1stLWtdID09IDA7IHhjLnBvcCgpKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoIXhjWzBdKSByZXR1cm4gYWxwaGFiZXQuY2hhckF0KDApO1xyXG5cclxuICAgICAgICAvLyBEb2VzIHN0ciByZXByZXNlbnQgYW4gaW50ZWdlcj8gSWYgc28sIG5vIG5lZWQgZm9yIHRoZSBkaXZpc2lvbi5cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIC0tZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5jID0geGM7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG5cclxuICAgICAgICAgIC8vIFRoZSBzaWduIGlzIG5lZWRlZCBmb3IgY29ycmVjdCByb3VuZGluZy5cclxuICAgICAgICAgIHgucyA9IHNpZ247XHJcbiAgICAgICAgICB4ID0gZGl2KHgsIHksIGRwLCBybSwgYmFzZU91dCk7XHJcbiAgICAgICAgICB4YyA9IHguYztcclxuICAgICAgICAgIHIgPSB4LnI7XHJcbiAgICAgICAgICBlID0geC5lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGNvbnZlcnRlZCB0byBiYXNlT3V0LlxyXG5cclxuICAgICAgICAvLyBUSGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgIGQgPSBlICsgZHAgKyAxO1xyXG5cclxuICAgICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQ6IHRoZSBkaWdpdCB0byB0aGUgcmlnaHQgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgaSA9IHhjW2RdO1xyXG5cclxuICAgICAgICAvLyBMb29rIGF0IHRoZSByb3VuZGluZyBkaWdpdHMgYW5kIG1vZGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcm91bmQgdXAuXHJcblxyXG4gICAgICAgIGsgPSBiYXNlT3V0IC8gMjtcclxuICAgICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgciA9IHJtIDwgNCA/IChpICE9IG51bGwgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgICAgOiBpID4gayB8fCBpID09IGsgJiYocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiYgeGNbZCAtIDFdICYgMSB8fFxyXG4gICAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgbm90IGdyZWF0ZXIgdGhhbiB6ZXJvLCBvciB4YyByZXByZXNlbnRzXHJcbiAgICAgICAgLy8gemVybywgdGhlbiB0aGUgcmVzdWx0IG9mIHRoZSBiYXNlIGNvbnZlcnNpb24gaXMgemVybyBvciwgaWYgcm91bmRpbmcgdXAsIGEgdmFsdWVcclxuICAgICAgICAvLyBzdWNoIGFzIDAuMDAwMDEuXHJcbiAgICAgICAgaWYgKGQgPCAxIHx8ICF4Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIDFeLWRwIG9yIDBcclxuICAgICAgICAgIHN0ciA9IHIgPyB0b0ZpeGVkUG9pbnQoYWxwaGFiZXQuY2hhckF0KDEpLCAtZHAsIGFscGhhYmV0LmNoYXJBdCgwKSkgOiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBUcnVuY2F0ZSB4YyB0byB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgeGMubGVuZ3RoID0gZDtcclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxyXG4gICAgICAgICAgICBmb3IgKC0tYmFzZU91dDsgKyt4Y1stLWRdID4gYmFzZU91dDspIHtcclxuICAgICAgICAgICAgICB4Y1tkXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgIGlmICghZCkge1xyXG4gICAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgICAgeGMgPSBbMV0uY29uY2F0KHhjKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGsgPSB4Yy5sZW5ndGg7ICF4Y1stLWtdOyk7XHJcblxyXG4gICAgICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cclxuICAgICAgICAgIGZvciAoaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBhbHBoYWJldC5jaGFyQXQoeGNbaSsrXSkpO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm9zLCBkZWNpbWFsIHBvaW50IGFuZCB0cmFpbGluZyB6ZXJvcyBhcyByZXF1aXJlZC5cclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsIGFscGhhYmV0LmNoYXJBdCgwKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgYWRkIHRoZSBzaWduLlxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvLyBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS4gQ2FsbGVkIGJ5IGRpdiBhbmQgY29udmVydEJhc2UuXHJcbiAgICBkaXYgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgLy8gQXNzdW1lIG5vbi16ZXJvIHggYW5kIGsuXHJcbiAgICAgIGZ1bmN0aW9uIG11bHRpcGx5KHgsIGssIGJhc2UpIHtcclxuICAgICAgICB2YXIgbSwgdGVtcCwgeGxvLCB4aGksXHJcbiAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICBpID0geC5sZW5ndGgsXHJcbiAgICAgICAgICBrbG8gPSBrICUgU1FSVF9CQVNFLFxyXG4gICAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoeCA9IHguc2xpY2UoKTsgaS0tOykge1xyXG4gICAgICAgICAgeGxvID0geFtpXSAlIFNRUlRfQkFTRTtcclxuICAgICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xyXG4gICAgICAgICAgbSA9IGtoaSAqIHhsbyArIHhoaSAqIGtsbztcclxuICAgICAgICAgIHRlbXAgPSBrbG8gKiB4bG8gKyAoKG0gJSBTUVJUX0JBU0UpICogU1FSVF9CQVNFKSArIGNhcnJ5O1xyXG4gICAgICAgICAgY2FycnkgPSAodGVtcCAvIGJhc2UgfCAwKSArIChtIC8gU1FSVF9CQVNFIHwgMCkgKyBraGkgKiB4aGk7XHJcbiAgICAgICAgICB4W2ldID0gdGVtcCAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2FycnkpIHggPSBbY2FycnldLmNvbmNhdCh4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XHJcbiAgICAgICAgdmFyIGksIGNtcDtcclxuXHJcbiAgICAgICAgaWYgKGFMICE9IGJMKSB7XHJcbiAgICAgICAgICBjbXAgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgZm9yIChpID0gY21wID0gMDsgaSA8IGFMOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgICAgICBjbXAgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IGIgZnJvbSBhLlxyXG4gICAgICAgIGZvciAoOyBhTC0tOykge1xyXG4gICAgICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XHJcbiAgICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc3BsaWNlKDAsIDEpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geDogZGl2aWRlbmQsIHk6IGRpdmlzb3IuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgZHAsIHJtLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgICAgeUwsIHl6LFxyXG4gICAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICAgIGlmICgheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcclxuXHJcbiAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXHJcbiAgICAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4YyA/IHljICYmIHhjWzBdID09IHljWzBdIDogIXljKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgwrEwIG9yIHkgaXMgwrFJbmZpbml0eSwgb3IgcmV0dXJuIMKxSW5maW5pdHkgYXMgeSBpcyDCsTAuXHJcbiAgICAgICAgICAgIHhjICYmIHhjWzBdID09IDAgfHwgIXljID8gcyAqIDAgOiBzIC8gMFxyXG4gICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcSA9IG5ldyBCaWdOdW1iZXIocyk7XHJcbiAgICAgICAgcWMgPSBxLmMgPSBbXTtcclxuICAgICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgICAgIHMgPSBkcCArIGUgKyAxO1xyXG5cclxuICAgICAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSAtIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgICAgIHMgPSBzIC8gTE9HX0JBU0UgfCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIGUuXHJcbiAgICAgICAgLy8gVGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgQmlnTnVtYmVycyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoaSA9IDA7IHljW2ldID09ICh4Y1tpXSB8fCAwKTsgaSsrKTtcclxuXHJcbiAgICAgICAgaWYgKHljW2ldID4gKHhjW2ldIHx8IDApKSBlLS07XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCkge1xyXG4gICAgICAgICAgcWMucHVzaCgxKTtcclxuICAgICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICBzICs9IDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9ybWFsaXNlIHhjIGFuZCB5YyBzbyBoaWdoZXN0IG9yZGVyIGRpZ2l0IG9mIHljIGlzID49IGJhc2UgLyAyLlxyXG5cclxuICAgICAgICAgIG4gPSBtYXRoZmxvb3IoYmFzZSAvICh5Y1swXSArIDEpKTtcclxuXHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gaGFuZGxlIG9kZCBiYXNlcyB3aGVyZSB5Y1swXSA9PSAoYmFzZSAvIDIpIC0gMS5cclxuICAgICAgICAgIC8vIGlmIChuID4gMSB8fCBuKysgPT0gMSAmJiB5Y1swXSA8IGJhc2UgLyAyKSB7XHJcbiAgICAgICAgICBpZiAobiA+IDEpIHtcclxuICAgICAgICAgICAgeWMgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHhjID0gbXVsdGlwbHkoeGMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICAgIHJlbSA9IHhjLnNsaWNlKDAsIHlMKTtcclxuICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOyByZW1bcmVtTCsrXSA9IDApO1xyXG4gICAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgeXogPSBbMF0uY29uY2F0KHl6KTtcclxuICAgICAgICAgIHljMCA9IHljWzBdO1xyXG4gICAgICAgICAgaWYgKHljWzFdID49IGJhc2UgLyAyKSB5YzArKztcclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAgIC8vIGVsc2UgaWYgKGJhc2UgPT0gMyAmJiB5YzAgPT0gMSkgeWMwID0gMSArIDFlLTE1O1xyXG5cclxuICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbiA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgY21wID0gY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIG4uXHJcblxyXG4gICAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgICAgaWYgKHlMICE9IHJlbUwpIHJlbTAgPSByZW0wICogYmFzZSArIChyZW1bMV0gfHwgMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG4gaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBuID0gbWF0aGZsb29yKHJlbTAgLyB5YzApO1xyXG5cclxuICAgICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAgIC8vICBwcm9kdWN0ID0gZGl2aXNvciBtdWx0aXBsaWVkIGJ5IHRyaWFsIGRpZ2l0IChuKS5cclxuICAgICAgICAgICAgICAvLyAgQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3QgaXMgZ3JlYXRlciB0aGFuIHJlbWFpbmRlcjpcclxuICAgICAgICAgICAgICAvLyAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdCwgZGVjcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIC8vICBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IHdhcyBsZXNzIHRoYW4gcmVtYWluZGVyIGF0IHRoZSBsYXN0IGNvbXBhcmU6XHJcbiAgICAgICAgICAgICAgLy8gICAgQ29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yLlxyXG4gICAgICAgICAgICAgIC8vICAgIElmIHJlbWFpbmRlciBpcyBncmVhdGVyIHRoYW4gZGl2aXNvcjpcclxuICAgICAgICAgICAgICAvLyAgICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIsIGluY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuXHJcbiAgICAgICAgICAgICAgaWYgKG4gPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBtYXkgYmUgPiBiYXNlIG9ubHkgd2hlbiBiYXNlIGlzIDMuXHJcbiAgICAgICAgICAgICAgICBpZiAobiA+PSBiYXNlKSBuID0gYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0ID4gcmVtYWluZGVyIHRoZW4gdHJpYWwgZGlnaXQgbiB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gaGlnaCBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIGlzIG5vdCBrbm93biB0byBoYXZlXHJcbiAgICAgICAgICAgICAgICAvLyBldmVyIGJlZW4gbW9yZSB0aGFuIDEgdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4tLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5YywgcHJvZEwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICBjbXAgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byBjb21wYXJlIHljIGFuZCByZW0gYWdhaW4gYmVsb3csXHJcbiAgICAgICAgICAgICAgICAvLyBzbyBjaGFuZ2UgY21wIHRvIDEgdG8gYXZvaWQgaXQuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICBpZiAobiA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgcmVtYWluZGVyLCBzbyBuIG11c3QgYmUgYXQgbGVhc3QgMS5cclxuICAgICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3JcclxuICAgICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QgPSBbMF0uY29uY2F0KHByb2QpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbisrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCB5TCA8IHJlbUwgPyB5eiA6IHljLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgICByZW0gPSBbMF07XHJcbiAgICAgICAgICAgIH0gLy8gZWxzZSBjbXAgPT09IDEgYW5kIG4gd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgIHFjW2krK10gPSBuO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChyZW1bMF0pIHtcclxuICAgICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhjW3hpXSB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlbSA9IFt4Y1t4aV1dO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsKSAmJiBzLS0pO1xyXG5cclxuICAgICAgICAgIG1vcmUgPSByZW1bMF0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgICAgICBpZiAoIXFjWzBdKSBxYy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYmFzZSA9PSBCQVNFKSB7XHJcblxyXG4gICAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFjWzBdLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgcyA9IHFjWzBdOyBzID49IDEwOyBzIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIHJvdW5kKHEsIGRwICsgKHEuZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSArIDEsIHJtLCBtb3JlKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbGVyIGlzIGNvbnZlcnRCYXNlLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBxLmUgPSBlO1xyXG4gICAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcTtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAgICogbm90YXRpb24gcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIGRlY2ltYWwgcGxhY2VzIG9yIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAqXHJcbiAgICAgKiBuOiBhIEJpZ051bWJlci5cclxuICAgICAqIGk6IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBkaWdpdCByZXF1aXJlZCAoaS5lLiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cCkuXHJcbiAgICAgKiBybTogdGhlIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgKiBpZDogMSAodG9FeHBvbmVudGlhbCkgb3IgMiAodG9QcmVjaXNpb24pLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmb3JtYXQobiwgaSwgcm0sIGlkKSB7XHJcbiAgICAgIHZhciBjMCwgZSwgbmUsIGxlbiwgc3RyO1xyXG5cclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICBpZiAoIW4uYykgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIGMwID0gbi5jWzBdO1xyXG4gICAgICBuZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChpID09IG51bGwpIHtcclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgc3RyID0gaWQgPT0gMSB8fCBpZCA9PSAyICYmIChuZSA8PSBUT19FWFBfTkVHIHx8IG5lID49IFRPX0VYUF9QT1MpXHJcbiAgICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIG5lKVxyXG4gICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIG5lLCAnMCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBpLCBybSk7XHJcblxyXG4gICAgICAgIC8vIG4uZSBtYXkgaGF2ZSBjaGFuZ2VkIGlmIHRoZSB2YWx1ZSB3YXMgcm91bmRlZCB1cC5cclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICAgIC8vIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlclxyXG4gICAgICAgIC8vIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICBpZiAoaWQgPT0gMSB8fCBpZCA9PSAyICYmIChpIDw9IGUgfHwgZSA8PSBUT19FWFBfTkVHKSkge1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGZvciAoOyBsZW4gPCBpOyBzdHIgKz0gJzAnLCBsZW4rKyk7XHJcbiAgICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKHN0ciwgZSk7XHJcblxyXG4gICAgICAgIC8vIEZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpIC09IG5lO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBpZiAoZSArIDEgPiBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKC0taSA+IDApIGZvciAoc3RyICs9ICcuJzsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgKz0gZSAtIGxlbjtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGUgKyAxID09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSBCaWdOdW1iZXIubWF4IGFuZCBCaWdOdW1iZXIubWluLlxyXG4gICAgZnVuY3Rpb24gbWF4T3JNaW4oYXJncywgbWV0aG9kKSB7XHJcbiAgICAgIHZhciBuLFxyXG4gICAgICAgIGkgPSAxLFxyXG4gICAgICAgIG0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIoYXJnc1tpXSk7XHJcblxyXG4gICAgICAgIC8vIElmIGFueSBudW1iZXIgaXMgTmFOLCByZXR1cm4gTmFOLlxyXG4gICAgICAgIGlmICghbi5zKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kLmNhbGwobSwgbikpIHtcclxuICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBTdHJpcCB0cmFpbGluZyB6ZXJvcywgY2FsY3VsYXRlIGJhc2UgMTAgZXhwb25lbnQgYW5kIGNoZWNrIGFnYWluc3QgTUlOX0VYUCBhbmQgTUFYX0VYUC5cclxuICAgICAqIENhbGxlZCBieSBtaW51cywgcGx1cyBhbmQgdGltZXMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGlzZShuLCBjLCBlKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBqID0gYy5sZW5ndGg7XHJcblxyXG4gICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgIWNbLS1qXTsgYy5wb3AoKSk7XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQuIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICBmb3IgKGogPSBjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgIGlmICgoZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgbi5jID0gbi5lID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIG4uYyA9IFtuLmUgPSAwXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuLmUgPSBlO1xyXG4gICAgICAgIG4uYyA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgdmFsdWVzIHRoYXQgZmFpbCB0aGUgdmFsaWRpdHkgdGVzdCBpbiBCaWdOdW1iZXIuXHJcbiAgICBwYXJzZU51bWVyaWMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2ksXHJcbiAgICAgICAgZG90QWZ0ZXIgPSAvXihbXi5dKylcXC4kLyxcclxuICAgICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcclxuICAgICAgICBpc0luZmluaXR5T3JOYU4gPSAvXi0/KEluZmluaXR5fE5hTikkLyxcclxuICAgICAgICB3aGl0ZXNwYWNlT3JQbHVzID0gL15cXHMqXFwrKD89W1xcdy5dKXxeXFxzK3xcXHMrJC9nO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBzdHIsIGlzTnVtLCBiKSB7XHJcbiAgICAgICAgdmFyIGJhc2UsXHJcbiAgICAgICAgICBzID0gaXNOdW0gPyBzdHIgOiBzdHIucmVwbGFjZSh3aGl0ZXNwYWNlT3JQbHVzLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAgICBpZiAoaXNJbmZpbml0eU9yTmFOLnRlc3QocykpIHtcclxuICAgICAgICAgIHgucyA9IGlzTmFOKHMpID8gbnVsbCA6IHMgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoIWlzTnVtKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaVxyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGJhc2VQcmVmaXgsIGZ1bmN0aW9uIChtLCBwMSwgcDIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gKHAyID0gcDIudG9Mb3dlckNhc2UoKSkgPT0gJ3gnID8gMTYgOiBwMiA9PSAnYicgPyAyIDogODtcclxuICAgICAgICAgICAgICByZXR1cm4gIWIgfHwgYiA9PSBiYXNlID8gcDEgOiBtO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IGI7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEUuZy4gJzEuJyB0byAnMScsICcuMScgdG8gJzAuMSdcclxuICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGRvdEFmdGVyLCAnJDEnKS5yZXBsYWNlKGRvdEJlZm9yZSwgJzAuJDEnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHN0ciAhPSBzKSByZXR1cm4gbmV3IEJpZ051bWJlcihzLCBiYXNlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ05vdCBhJyArIChiID8gJyBiYXNlICcgKyBiIDogJycpICsgJyBudW1iZXI6ICcgKyBzdHIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE5hTlxyXG4gICAgICAgICAgeC5zID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSb3VuZCB4IHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gICAgICogSWYgciBpcyB0cnV0aHksIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgYXJlIG1vcmUgZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcm91bmQoeCwgc2QsIHJtLCByKSB7XHJcbiAgICAgIHZhciBkLCBpLCBqLCBrLCBuLCBuaSwgcmQsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgcG93czEwID0gUE9XU19URU47XHJcblxyXG4gICAgICAvLyBpZiB4IGlzIG5vdCBJbmZpbml0eSBvciBOYU4uLi5cclxuICAgICAgaWYgKHhjKSB7XHJcblxyXG4gICAgICAgIC8vIHJkIGlzIHRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgLy8gbiBpcyBhIGJhc2UgMWUxNCBudW1iZXIsIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBvZiBhcnJheSB4LmMgY29udGFpbmluZyByZC5cclxuICAgICAgICAvLyBuaSBpcyB0aGUgaW5kZXggb2YgbiB3aXRoaW4geC5jLlxyXG4gICAgICAgIC8vIGQgaXMgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAvLyBpIGlzIHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiBpbmNsdWRpbmcgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAvLyBqIGlzIHRoZSBhY3R1YWwgaW5kZXggb2YgcmQgd2l0aGluIG4gKGlmIDwgMCwgcmQgaXMgYSBsZWFkaW5nIHplcm8pLlxyXG4gICAgICAgIG91dDoge1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy5cclxuICAgICAgICAgIGZvciAoZCA9IDEsIGsgPSB4Y1swXTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuICAgICAgICAgIGkgPSBzZCAtIGQ7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgICAgaSArPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgaiA9IHNkO1xyXG4gICAgICAgICAgICBuID0geGNbbmkgPSAwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICByZCA9IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5pID0gbWF0aGNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuaSA+PSB4Yy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cclxuICAgICAgICAgICAgICAgIGZvciAoOyB4Yy5sZW5ndGggPD0gbmk7IHhjLnB1c2goMCkpO1xyXG4gICAgICAgICAgICAgICAgbiA9IHJkID0gMDtcclxuICAgICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG4gPSBrID0geGNbbmldO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAgICAgICBmb3IgKGQgPSAxOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLlxyXG4gICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuIGlzIGdpdmVuIGJ5IExPR19CQVNFIC0gZC5cclxuICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcclxuXHJcbiAgICAgICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICAgICAgICAvLyBUaGUgZXhwcmVzc2lvbiAgbiAlIHBvd3MxMFtkIC0gaiAtIDFdICByZXR1cm5zIGFsbCBkaWdpdHMgb2YgbiB0byB0aGUgcmlnaHRcclxuICAgICAgICAgIC8vIG9mIHRoZSBkaWdpdCBhdCBqLCBlLmcuIGlmIG4gaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uIGdpdmVzIDcxNC5cclxuICAgICAgICAgICB4Y1tuaSArIDFdICE9IG51bGwgfHwgKGogPCAwID8gbiA6IG4gJSBwb3dzMTBbZCAtIGogLSAxXSk7XHJcblxyXG4gICAgICAgICAgciA9IHJtIDwgNFxyXG4gICAgICAgICAgID8gKHJkIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxyXG4gICAgICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwW2QgLSBqXSA6IDAgOiB4Y1tuaSAtIDFdKSAlIDEwKSAmIDEgfHxcclxuICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgICBpZiAoc2QgPCAxIHx8ICF4Y1swXSkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29udmVydCBzZCB0byBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0gcG93czEwWyhMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0VdO1xyXG4gICAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0geC5lID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGV4Y2VzcyBkaWdpdHMuXHJcbiAgICAgICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xyXG4gICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgbmktLTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pICsgMTtcclxuICAgICAgICAgICAgayA9IHBvd3MxMFtMT0dfQkFTRSAtIGldO1xyXG5cclxuICAgICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygbi5cclxuICAgICAgICAgICAgeGNbbmldID0gaiA+IDAgPyBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gal0gJSBwb3dzMTBbal0pICogayA6IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgICAgICBpZiAobmkgPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhjWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IHhjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG4gICAgICAgICAgICAgICAgaiA9IHhjWzBdICs9IGs7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKyspO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoeGNbMF0gPT0gQkFTRSkgeGNbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaV0gKz0gaztcclxuICAgICAgICAgICAgICAgIGlmICh4Y1tuaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaS0tXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGkgPSB4Yy5sZW5ndGg7IHhjWy0taV0gPT09IDA7IHhjLnBvcCgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE92ZXJmbG93PyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93PyBaZXJvLlxyXG4gICAgICAgIH0gZWxzZSBpZiAoeC5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHZhbHVlT2Yobikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuXHJcbiAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBlKVxyXG4gICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBQUk9UT1RZUEUvSU5TVEFOQ0UgTUVUSE9EU1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXHJcbiAgICAgKi9cclxuICAgIFAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmICh4LnMgPCAwKSB4LnMgPSAxO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm5cclxuICAgICAqICAgMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIC0xIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAgICAgKiAgIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBpcyBOYU4uXHJcbiAgICAgKi9cclxuICAgIFAuY29tcGFyZWRUbyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIGRwIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9mIHRoZVxyXG4gICAgICogdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgZHAgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXM6IGludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICBuID0gKCh2ID0gYy5sZW5ndGggLSAxKSAtIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSkgKiBMT0dfQkFTRTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgbnVtYmVyLlxyXG4gICAgICBpZiAodiA9IGNbdl0pIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuICAgICAgaWYgKG4gPCAwKSBuID0gMDtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC8gMCA9IElcclxuICAgICAqICBuIC8gTiA9IE5cclxuICAgICAqICBuIC8gSSA9IDBcclxuICAgICAqICAwIC8gbiA9IDBcclxuICAgICAqICAwIC8gMCA9IE5cclxuICAgICAqICAwIC8gTiA9IE5cclxuICAgICAqICAwIC8gSSA9IDBcclxuICAgICAqICBOIC8gbiA9IE5cclxuICAgICAqICBOIC8gMCA9IE5cclxuICAgICAqICBOIC8gTiA9IE5cclxuICAgICAqICBOIC8gSSA9IE5cclxuICAgICAqICBJIC8gbiA9IElcclxuICAgICAqICBJIC8gMCA9IElcclxuICAgICAqICBJIC8gTiA9IE5cclxuICAgICAqICBJIC8gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgREVDSU1BTF9QTEFDRVMsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIGJ5IHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5pZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCAwLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGV4cG9uZW50aWF0ZWQgYnkgbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBtIGlzIHByZXNlbnQsIHJldHVybiB0aGUgcmVzdWx0IG1vZHVsbyBtLlxyXG4gICAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vbi16ZXJvIGFuZCBtIGlzIG5vdCBwcmVzZW50LCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIG1vZHVsYXIgcG93ZXIgb3BlcmF0aW9uIHdvcmtzIGVmZmljaWVudGx5IHdoZW4geCwgbiwgYW5kIG0gYXJlIGludGVnZXJzLCBvdGhlcndpc2UgaXRcclxuICAgICAqIGlzIGVxdWl2YWxlbnQgdG8gY2FsY3VsYXRpbmcgeC5leHBvbmVudGlhdGVkQnkobikubW9kdWxvKG0pIHdpdGggYSBQT1dfUFJFQ0lTSU9OIG9mIDAuXHJcbiAgICAgKlxyXG4gICAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBleHBvbmVudC4gQW4gaW50ZWdlci5cclxuICAgICAqIFttXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBtb2R1bHVzLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBFeHBvbmVudCBub3QgYW4gaW50ZWdlcjoge259J1xyXG4gICAgICovXHJcbiAgICBQLmV4cG9uZW50aWF0ZWRCeSA9IFAucG93ID0gZnVuY3Rpb24gKG4sIG0pIHtcclxuICAgICAgdmFyIGhhbGYsIGlzTW9kRXhwLCBpLCBrLCBtb3JlLCBuSXNCaWcsIG5Jc05lZywgbklzT2RkLCB5LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobik7XHJcblxyXG4gICAgICAvLyBBbGxvdyBOYU4gYW5kIMKxSW5maW5pdHksIGJ1dCBub3Qgb3RoZXIgbm9uLWludGVnZXJzLlxyXG4gICAgICBpZiAobi5jICYmICFuLmlzSW50ZWdlcigpKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogJyArIHZhbHVlT2YobikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobSAhPSBudWxsKSBtID0gbmV3IEJpZ051bWJlcihtKTtcclxuXHJcbiAgICAgIC8vIEV4cG9uZW50IG9mIE1BWF9TQUZFX0lOVEVHRVIgaXMgMTUuXHJcbiAgICAgIG5Jc0JpZyA9IG4uZSA+IDE0O1xyXG5cclxuICAgICAgLy8gSWYgeCBpcyBOYU4sIMKxSW5maW5pdHksIMKxMCBvciDCsTEsIG9yIG4gaXMgwrFJbmZpbml0eSwgTmFOIG9yIMKxMC5cclxuICAgICAgaWYgKCF4LmMgfHwgIXguY1swXSB8fCB4LmNbMF0gPT0gMSAmJiAheC5lICYmIHguYy5sZW5ndGggPT0gMSB8fCAhbi5jIHx8ICFuLmNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gVGhlIHNpZ24gb2YgdGhlIHJlc3VsdCBvZiBwb3cgd2hlbiB4IGlzIG5lZ2F0aXZlIGRlcGVuZHMgb24gdGhlIGV2ZW5uZXNzIG9mIG4uXHJcbiAgICAgICAgLy8gSWYgK24gb3ZlcmZsb3dzIHRvIMKxSW5maW5pdHksIHRoZSBldmVubmVzcyBvZiBuIHdvdWxkIGJlIG5vdCBiZSBrbm93bi5cclxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihNYXRoLnBvdygrdmFsdWVPZih4KSwgbklzQmlnID8gMiAtIGlzT2RkKG4pIDogK3ZhbHVlT2YobikpKTtcclxuICAgICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogeTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbklzTmVnID0gbi5zIDwgMDtcclxuXHJcbiAgICAgIGlmIChtKSB7XHJcblxyXG4gICAgICAgIC8vIHggJSBtIHJldHVybnMgTmFOIGlmIGFicyhtKSBpcyB6ZXJvLCBvciBtIGlzIE5hTi5cclxuICAgICAgICBpZiAobS5jID8gIW0uY1swXSA6ICFtLnMpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAgIGlzTW9kRXhwID0gIW5Jc05lZyAmJiB4LmlzSW50ZWdlcigpICYmIG0uaXNJbnRlZ2VyKCk7XHJcblxyXG4gICAgICAgIGlmIChpc01vZEV4cCkgeCA9IHgubW9kKG0pO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3cgdG8gwrFJbmZpbml0eTogPj0yKioxZTEwIG9yID49MS4wMDAwMDI0KioxZTE1LlxyXG4gICAgICAvLyBVbmRlcmZsb3cgdG8gwrEwOiA8PTAuNzkqKjFlMTAgb3IgPD0wLjk5OTk5NzUqKjFlMTUuXHJcbiAgICAgIH0gZWxzZSBpZiAobi5lID4gOSAmJiAoeC5lID4gMCB8fCB4LmUgPCAtMSB8fCAoeC5lID09IDBcclxuICAgICAgICAvLyBbMSwgMjQwMDAwMDAwXVxyXG4gICAgICAgID8geC5jWzBdID4gMSB8fCBuSXNCaWcgJiYgeC5jWzFdID49IDI0ZTdcclxuICAgICAgICAvLyBbODAwMDAwMDAwMDAwMDBdICBbOTk5OTk3NTAwMDAwMDBdXHJcbiAgICAgICAgOiB4LmNbMF0gPCA4ZTEzIHx8IG5Jc0JpZyAmJiB4LmNbMF0gPD0gOTk5OTk3NWU3KSkpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgeCBpcyBuZWdhdGl2ZSBhbmQgbiBpcyBvZGQsIGsgPSAtMCwgZWxzZSBrID0gMC5cclxuICAgICAgICBrID0geC5zIDwgMCAmJiBpc09kZChuKSA/IC0wIDogMDtcclxuXHJcbiAgICAgICAgLy8gSWYgeCA+PSAxLCBrID0gwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gLTEpIGsgPSAxIC8gaztcclxuXHJcbiAgICAgICAgLy8gSWYgbiBpcyBuZWdhdGl2ZSByZXR1cm4gwrEwLCBlbHNlIHJldHVybiDCsUluZmluaXR5LlxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG5Jc05lZyA/IDEgLyBrIDogayk7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKFBPV19QUkVDSVNJT04pIHtcclxuXHJcbiAgICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgIC8vIGVxdWF0ZXMgdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLFxyXG4gICAgICAgIC8vIGkuZS4gdGhlcmUgd2lsbCBiZSBhIG1pbmltdW0gb2YgMjggZ3VhcmQgZGlnaXRzIHJldGFpbmVkLlxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5Jc0JpZykge1xyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKDAuNSk7XHJcbiAgICAgICAgaWYgKG5Jc05lZykgbi5zID0gMTtcclxuICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpID0gTWF0aC5hYnMoK3ZhbHVlT2YobikpO1xyXG4gICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgLy8gUGVyZm9ybXMgNTQgbG9vcCBpdGVyYXRpb25zIGZvciBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEuXHJcbiAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgIGlmIChuSXNPZGQpIHtcclxuICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgICAgaWYgKCF5LmMpIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICAgIGlmICh5LmMubGVuZ3RoID4gaykgeS5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICAgIHkgPSB5Lm1vZChtKTsgICAgLy95ID0geS5taW51cyhkaXYoeSwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgICBpID0gbWF0aGZsb29yKGkgLyAyKTtcclxuICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gbi50aW1lcyhoYWxmKTtcclxuICAgICAgICAgIHJvdW5kKG4sIG4uZSArIDEsIDEpO1xyXG5cclxuICAgICAgICAgIGlmIChuLmUgPiAxNCkge1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgPSArdmFsdWVPZihuKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggPSB4LnRpbWVzKHgpO1xyXG5cclxuICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgaWYgKHguYyAmJiB4LmMubGVuZ3RoID4gaykgeC5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgeCA9IHgubW9kKG0pOyAgICAvL3ggPSB4Lm1pbnVzKGRpdih4LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzTW9kRXhwKSByZXR1cm4geTtcclxuICAgICAgaWYgKG5Jc05lZykgeSA9IE9ORS5kaXYoeSk7XHJcblxyXG4gICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogayA/IHJvdW5kKHksIFBPV19QUkVDSVNJT04sIFJPVU5ESU5HX01PREUsIG1vcmUpIDogeTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGFuIGludGVnZXJcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtybX0nXHJcbiAgICAgKi9cclxuICAgIFAuaW50ZWdlclZhbHVlID0gZnVuY3Rpb24gKHJtKSB7XHJcbiAgICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcbiAgICAgIHJldHVybiByb3VuZChuLCBuLmUgKyAxLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRXF1YWxUbyA9IFAuZXEgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAxIHx8IGIgPT09IDA7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzSW50ZWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuYy5sZW5ndGggLSAyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gLTEgfHwgYiA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMucztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIHBvc2l0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC0gMCA9IG5cclxuICAgICAqICBuIC0gTiA9IE5cclxuICAgICAqICBuIC0gSSA9IC1JXHJcbiAgICAgKiAgMCAtIG4gPSAtblxyXG4gICAgICogIDAgLSAwID0gMFxyXG4gICAgICogIDAgLSBOID0gTlxyXG4gICAgICogIDAgLSBJID0gLUlcclxuICAgICAqICBOIC0gbiA9IE5cclxuICAgICAqICBOIC0gMCA9IE5cclxuICAgICAqICBOIC0gTiA9IE5cclxuICAgICAqICBOIC0gSSA9IE5cclxuICAgICAqICBJIC0gbiA9IElcclxuICAgICAqICBJIC0gMCA9IElcclxuICAgICAqICBJIC0gTiA9IE5cclxuICAgICAqICBJIC0gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5taW51cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBpLCBqLCB0LCB4TFR5LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiB4YyA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHljID8geCA6IE5hTik7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICByZXR1cm4geWNbMF0gPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOlxyXG5cclxuICAgICAgICAgICAvLyBJRUVFIDc1NCAoMjAwOCkgNi4zOiBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5XHJcbiAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSAzID8gLTAgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICAgICAgaWYgKHhMVHkgPSBhIDwgMCkge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICAgIGZvciAoYiA9IGE7IGItLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgICBqID0gKHhMVHkgPSAoYSA9IHhjLmxlbmd0aCkgPCAoYiA9IHljLmxlbmd0aCkpID8gYSA6IGI7XHJcblxyXG4gICAgICAgIGZvciAoYSA9IGIgPSAwOyBiIDwgajsgYisrKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmICh4TFR5KSB0ID0geGMsIHhjID0geWMsIHljID0gdCwgeS5zID0gLXkucztcclxuXHJcbiAgICAgIGIgPSAoaiA9IHljLmxlbmd0aCkgLSAoaSA9IHhjLmxlbmd0aCk7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgICAgaWYgKGIgPiAwKSBmb3IgKDsgYi0tOyB4Y1tpKytdID0gMCk7XHJcbiAgICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgIGZvciAoOyBqID4gYTspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAgIC0teGNbaV07XHJcbiAgICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGNbal0gLT0geWNbal07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgIGZvciAoOyB4Y1swXSA9PSAwOyB4Yy5zcGxpY2UoMCwgMSksIC0teWUpO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBGb2xsb3dpbmcgSUVFRSA3NTQgKDIwMDgpIDYuMyxcclxuICAgICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgIHkuYyA9IFt5LmUgPSAwXTtcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICAgbiAlIDAgPSAgTlxyXG4gICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgKiAgIG4gJSBJID0gIG5cclxuICAgICAqICAgMCAlIG4gPSAgMFxyXG4gICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgKiAgIDAgJSAwID0gIE5cclxuICAgICAqICAgMCAlIE4gPSAgTlxyXG4gICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgKiAgIE4gJSBuID0gIE5cclxuICAgICAqICAgTiAlIDAgPSAgTlxyXG4gICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgKiAgIE4gJSBJID0gIE5cclxuICAgICAqICAgSSAlIG4gPSAgTlxyXG4gICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgKiAgIEkgJSBOID0gIE5cclxuICAgICAqICAgSSAlIEkgPSAgTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgICBpZiAoIXguYyB8fCAheS5zIHx8IHkuYyAmJiAheS5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKCF5LmMgfHwgeC5jICYmICF4LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKE1PRFVMT19NT0RFID09IDkpIHtcclxuXHJcbiAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgcyA9IHkucztcclxuICAgICAgICB5LnMgPSAxO1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgICAgeS5zID0gcztcclxuICAgICAgICBxLnMgKj0gcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIE1PRFVMT19NT0RFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgICAvLyBUbyBtYXRjaCBKYXZhU2NyaXB0ICUsIGVuc3VyZSBzaWduIG9mIHplcm8gaXMgc2lnbiBvZiBkaXZpZGVuZC5cclxuICAgICAgaWYgKCF5LmNbMF0gJiYgTU9EVUxPX01PREUgPT0gMSkgeS5zID0geC5zO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKiAwID0gMFxyXG4gICAgICogIG4gKiBOID0gTlxyXG4gICAgICogIG4gKiBJID0gSVxyXG4gICAgICogIDAgKiBuID0gMFxyXG4gICAgICogIDAgKiAwID0gMFxyXG4gICAgICogIDAgKiBOID0gTlxyXG4gICAgICogIDAgKiBJID0gTlxyXG4gICAgICogIE4gKiBuID0gTlxyXG4gICAgICogIE4gKiAwID0gTlxyXG4gICAgICogIE4gKiBOID0gTlxyXG4gICAgICogIE4gKiBJID0gTlxyXG4gICAgICogIEkgKiBuID0gSVxyXG4gICAgICogIEkgKiAwID0gTlxyXG4gICAgICogIEkgKiBOID0gTlxyXG4gICAgICogIEkgKiBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlXHJcbiAgICAgKiBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubXVsdGlwbGllZEJ5ID0gUC50aW1lcyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcclxuICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIMKxSW5maW5pdHkgb3IgwrEwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeS5zICo9IHgucztcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICAgIHkuYyA9IHkuZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeS5jID0gWzBdO1xyXG4gICAgICAgICAgICB5LmUgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgIHkucyAqPSB4LnM7XHJcbiAgICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgICAgeWNMID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHhjIHBvaW50cyB0byBsb25nZXIgYXJyYXkgYW5kIHhjTCB0byBpdHMgbGVuZ3RoLlxyXG4gICAgICBpZiAoeGNMIDwgeWNMKSB6YyA9IHhjLCB4YyA9IHljLCB5YyA9IHpjLCBpID0geGNMLCB4Y0wgPSB5Y0wsIHljTCA9IGk7XHJcblxyXG4gICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgICAgZm9yIChpID0geGNMICsgeWNMLCB6YyA9IFtdOyBpLS07IHpjLnB1c2goMCkpO1xyXG5cclxuICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgICAgZm9yIChpID0geWNMOyAtLWkgPj0gMDspIHtcclxuICAgICAgICBjID0gMDtcclxuICAgICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHloaSA9IHljW2ldIC8gc3FydEJhc2UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgICB4aGkgPSB4Y1trXSAvIHNxcnRCYXNlIHwgMDtcclxuICAgICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoKG0gJSBzcXJ0QmFzZSkgKiBzcXJ0QmFzZSkgKyB6Y1tqXSArIGM7XHJcbiAgICAgICAgICBjID0gKHhsbyAvIGJhc2UgfCAwKSArIChtIC8gc3FydEJhc2UgfCAwKSArIHloaSAqIHhoaTtcclxuICAgICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgemNbal0gPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYykge1xyXG4gICAgICAgICsrZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgKi9cclxuICAgIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICB4LnMgPSAteC5zIHx8IG51bGw7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICsgMCA9IG5cclxuICAgICAqICBuICsgTiA9IE5cclxuICAgICAqICBuICsgSSA9IElcclxuICAgICAqICAwICsgbiA9IG5cclxuICAgICAqICAwICsgMCA9IDBcclxuICAgICAqICAwICsgTiA9IE5cclxuICAgICAqICAwICsgSSA9IElcclxuICAgICAqICBOICsgbiA9IE5cclxuICAgICAqICBOICsgMCA9IE5cclxuICAgICAqICBOICsgTiA9IE5cclxuICAgICAqICBOICsgSSA9IE5cclxuICAgICAqICBJICsgbiA9IElcclxuICAgICAqICBJICsgMCA9IElcclxuICAgICAqICBJICsgTiA9IE5cclxuICAgICAqICBJICsgSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLnBsdXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYSAvIDApO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuIHljWzBdID8geSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDogYSAqIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcbiAgICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICBmb3IgKDsgYS0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhID0geGMubGVuZ3RoO1xyXG4gICAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheSwgYW5kIGIgdG8gdGhlIHNob3J0ZXIgbGVuZ3RoLlxyXG4gICAgICBpZiAoYSAtIGIgPCAwKSB0ID0geWMsIHljID0geGMsIHhjID0gdCwgYiA9IGE7XHJcblxyXG4gICAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cclxuICAgICAgZm9yIChhID0gMDsgYjspIHtcclxuICAgICAgICBhID0gKHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSkgLyBCQVNFIHwgMDtcclxuICAgICAgICB4Y1tiXSA9IEJBU0UgPT09IHhjW2JdID8gMCA6IHhjW2JdICUgQkFTRTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGEpIHtcclxuICAgICAgICB4YyA9IFthXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICsreWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgICAgLy8geWUgPSBNQVhfRVhQICsgMSBwb3NzaWJsZVxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgc2QgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mXHJcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICogSWYgc2QgaXMgdHJ1ZSBpbmNsdWRlIGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgY291bnQuXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBzZCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIHNkIHtudW1iZXJ8Ym9vbGVhbn0gbnVtYmVyOiBzaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogd2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoc2QgIT0gbnVsbCAmJiBzZCAhPT0gISFzZCkge1xyXG4gICAgICAgIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBzZCwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIHYgPSBjLmxlbmd0aCAtIDE7XHJcbiAgICAgIG4gPSB2ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSB7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBuKyspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2QgJiYgeC5lICsgMSA+IG4pIG4gPSB4LmUgKyAxO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xyXG4gICAgICogKHBvd2VycyBvZiAxMCkuIFNoaWZ0IHRvIHRoZSByaWdodCBpZiBuID4gMCwgYW5kIHRvIHRoZSBsZWZ0IGlmIG4gPCAwLlxyXG4gICAgICpcclxuICAgICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtrfSdcclxuICAgICAqL1xyXG4gICAgUC5zaGlmdGVkQnkgPSBmdW5jdGlvbiAoaykge1xyXG4gICAgICBpbnRDaGVjayhrLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUik7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWVzKCcxZScgKyBrKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAgICogIHNxcnQoTikgPSAgTlxyXG4gICAgICogIHNxcnQoLUkpID0gIE5cclxuICAgICAqICBzcXJ0KEkpID0gIElcclxuICAgICAqICBzcXJ0KDApID0gIDBcclxuICAgICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxyXG4gICAgICogcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBjID0geC5jLFxyXG4gICAgICAgIHMgPSB4LnMsXHJcbiAgICAgICAgZSA9IHguZSxcclxuICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTICsgNCxcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XHJcblxyXG4gICAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgICAgaWYgKHMgIT09IDEgfHwgIWMgfHwgIWNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcighcyB8fCBzIDwgMCAmJiAoIWMgfHwgY1swXSkgPyBOYU4gOiBjID8geCA6IDEgLyAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgICAgcyA9IE1hdGguc3FydCgrdmFsdWVPZih4KSk7XHJcblxyXG4gICAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcclxuICAgICAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApIG4gKz0gJzAnO1xyXG4gICAgICAgIHMgPSBNYXRoLnNxcnQoK24pO1xyXG4gICAgICAgIGUgPSBiaXRGbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICAgICAgbiA9ICcxZScgKyBlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKHMgKyAnJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciB6ZXJvLlxyXG4gICAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXHJcbiAgICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXHJcbiAgICAgIGlmIChyLmNbMF0pIHtcclxuICAgICAgICBlID0gci5lO1xyXG4gICAgICAgIHMgPSBlICsgZHA7XHJcbiAgICAgICAgaWYgKHMgPCAzKSBzID0gMDtcclxuXHJcbiAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgICB0ID0gcjtcclxuICAgICAgICAgIHIgPSBoYWxmLnRpbWVzKHQucGx1cyhkaXYoeCwgdCwgZHAsIDEpKSk7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZWZmVG9TdHJpbmcodC5jKS5zbGljZSgwLCBzKSA9PT0gKG4gPSBjb2VmZlRvU3RyaW5nKHIuYykpLnNsaWNlKDAsIHMpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXHJcbiAgICAgICAgICAgIC8vIGUuZyAwLjAwMDk5OTkgKGUtNCkgLS0gPiAwLjAwMSAoZS0zKSwgc28gYWRqdXN0IHMgc28gdGhlIHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgaW5kZXhlZCBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgIGlmIChyLmUgPCBlKSAtLXM7XHJcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKHMgLSAzLCBzICsgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIDk5OTkgb3IgNDk5OSAoaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5KSBjb250aW51ZSB0aGVcclxuICAgICAgICAgICAgLy8gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgICAgICAgcm91bmQodCwgdC5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBkcCArPSA0O1xyXG4gICAgICAgICAgICAgIHMgKz0gNDtcclxuICAgICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcclxuICAgICAgICAgICAgICAvLyByZXN1bHQuIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXHJcbiAgICAgICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAxKTtcclxuICAgICAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbiBhbmRcclxuICAgICAqIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCsrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xyXG4gICAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxyXG4gICAgICogYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHAgPSBkcCArIHRoaXMuZSArIDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kZWRcclxuICAgICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBvZiB0aGUgZm9ybWF0IG9yIEZPUk1BVCBvYmplY3QgKHNlZSBCaWdOdW1iZXIuc2V0KS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZm9ybWF0dGluZyBvYmplY3QgbWF5IGNvbnRhaW4gc29tZSBvciBhbGwgb2YgdGhlIHByb3BlcnRpZXMgc2hvd24gYmVsb3cuXHJcbiAgICAgKlxyXG4gICAgICogRk9STUFUID0ge1xyXG4gICAgICogICBwcmVmaXg6ICcnLFxyXG4gICAgICogICBncm91cFNpemU6IDMsXHJcbiAgICAgKiAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAqICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAqICAgc3VmZml4OiAnJ1xyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbZm9ybWF0XSB7b2JqZWN0fSBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZSBGT1JNQVQgcGJqZWN0IGFib3ZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IG5vdCBhbiBvYmplY3Q6IHtmb3JtYXR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRm9ybWF0ID0gZnVuY3Rpb24gKGRwLCBybSwgZm9ybWF0KSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICBpZiAoZHAgIT0gbnVsbCAmJiBybSAmJiB0eXBlb2Ygcm0gPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IHJtO1xyXG4gICAgICAgICAgcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHAgJiYgdHlwZW9mIGRwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBkcDtcclxuICAgICAgICAgIGRwID0gcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBGT1JNQVQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT0gJ29iamVjdCcpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50IG5vdCBhbiBvYmplY3Q6ICcgKyBmb3JtYXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSB4LnRvRml4ZWQoZHAsIHJtKTtcclxuXHJcbiAgICAgIGlmICh4LmMpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLicpLFxyXG4gICAgICAgICAgZzEgPSArZm9ybWF0Lmdyb3VwU2l6ZSxcclxuICAgICAgICAgIGcyID0gK2Zvcm1hdC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgICBncm91cFNlcGFyYXRvciA9IGZvcm1hdC5ncm91cFNlcGFyYXRvciB8fCAnJyxcclxuICAgICAgICAgIGludFBhcnQgPSBhcnJbMF0sXHJcbiAgICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICAgICAgICBpbnREaWdpdHMgPSBpc05lZyA/IGludFBhcnQuc2xpY2UoMSkgOiBpbnRQYXJ0LFxyXG4gICAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKGcyKSBpID0gZzEsIGcxID0gZzIsIGcyID0gaSwgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIGlmIChnMSA+IDAgJiYgbGVuID4gMCkge1xyXG4gICAgICAgICAgaSA9IGxlbiAlIGcxIHx8IGcxO1xyXG4gICAgICAgICAgaW50UGFydCA9IGludERpZ2l0cy5zdWJzdHIoMCwgaSk7XHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSBnMSkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zdWJzdHIoaSwgZzEpO1xyXG4gICAgICAgICAgaWYgKGcyID4gMCkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zbGljZShpKTtcclxuICAgICAgICAgIGlmIChpc05lZykgaW50UGFydCA9ICctJyArIGludFBhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBmcmFjdGlvblBhcnRcclxuICAgICAgICAgPyBpbnRQYXJ0ICsgKGZvcm1hdC5kZWNpbWFsU2VwYXJhdG9yIHx8ICcnKSArICgoZzIgPSArZm9ybWF0LmZyYWN0aW9uR3JvdXBTaXplKVxyXG4gICAgICAgICAgPyBmcmFjdGlvblBhcnQucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcZHsnICsgZzIgKyAnfVxcXFxCJywgJ2cnKSxcclxuICAgICAgICAgICAnJCYnICsgKGZvcm1hdC5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHx8ICcnKSlcclxuICAgICAgICAgIDogZnJhY3Rpb25QYXJ0KVxyXG4gICAgICAgICA6IGludFBhcnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAoZm9ybWF0LnByZWZpeCB8fCAnJykgKyBzdHIgKyAoZm9ybWF0LnN1ZmZpeCB8fCAnJyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHR3byBCaWdOdW1iZXJzIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgYXMgYSBzaW1wbGVcclxuICAgICAqIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlciBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuXHJcbiAgICAgKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKiBtYXhpbXVtIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmVcclxuICAgICAqIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogW21kXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEludGVnZXIgPj0gMSwgb3IgSW5maW5pdHkuIFRoZSBtYXhpbXVtIGRlbm9taW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfSA6IHttZH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtZCkge1xyXG4gICAgICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgZXhwLCBuLCBuMCwgbjEsIHEsIHIsIHMsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmM7XHJcblxyXG4gICAgICBpZiAobWQgIT0gbnVsbCkge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG1kKTtcclxuXHJcbiAgICAgICAgLy8gVGhyb3cgaWYgbWQgaXMgbGVzcyB0aGFuIG9uZSBvciBpcyBub3QgYW4gaW50ZWdlciwgdW5sZXNzIGl0IGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICghbi5pc0ludGVnZXIoKSAmJiAobi5jIHx8IG4ucyAhPT0gMSkgfHwgbi5sdChPTkUpKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgJyArXHJcbiAgICAgICAgICAgICAgKG4uaXNJbnRlZ2VyKCkgPyAnb3V0IG9mIHJhbmdlOiAnIDogJ25vdCBhbiBpbnRlZ2VyOiAnKSArIHZhbHVlT2YobikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF4YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcblxyXG4gICAgICBkID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBuMSA9IGQwID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBzID0gY29lZmZUb1N0cmluZyh4Yyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBkZW5vbWluYXRvci5cclxuICAgICAgLy8gZCBpcyBhIHBvd2VyIG9mIDEwIGFuZCB0aGUgbWluaW11bSBtYXggZGVub21pbmF0b3IgdGhhdCBzcGVjaWZpZXMgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICAgIGUgPSBkLmUgPSBzLmxlbmd0aCAtIHguZSAtIDE7XHJcbiAgICAgIGQuY1swXSA9IFBPV1NfVEVOWyhleHAgPSBlICUgTE9HX0JBU0UpIDwgMCA/IExPR19CQVNFICsgZXhwIDogZXhwXTtcclxuICAgICAgbWQgPSAhbWQgfHwgbi5jb21wYXJlZFRvKGQpID4gMCA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG5cclxuICAgICAgZXhwID0gTUFYX0VYUDtcclxuICAgICAgTUFYX0VYUCA9IDEgLyAwO1xyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihzKTtcclxuXHJcbiAgICAgIC8vIG4wID0gZDEgPSAwXHJcbiAgICAgIG4wLmNbMF0gPSAwO1xyXG5cclxuICAgICAgZm9yICg7IDspICB7XHJcbiAgICAgICAgcSA9IGRpdihuLCBkLCAwLCAxKTtcclxuICAgICAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgICAgIGlmIChkMi5jb21wYXJlZFRvKG1kKSA9PSAxKSBicmVhaztcclxuICAgICAgICBkMCA9IGQxO1xyXG4gICAgICAgIGQxID0gZDI7XHJcbiAgICAgICAgbjEgPSBuMC5wbHVzKHEudGltZXMoZDIgPSBuMSkpO1xyXG4gICAgICAgIG4wID0gZDI7XHJcbiAgICAgICAgZCA9IG4ubWludXMocS50aW1lcyhkMiA9IGQpKTtcclxuICAgICAgICBuID0gZDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGQyID0gZGl2KG1kLm1pbnVzKGQwKSwgZDEsIDAsIDEpO1xyXG4gICAgICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICAgICAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XHJcbiAgICAgIG4wLnMgPSBuMS5zID0geC5zO1xyXG4gICAgICBlID0gZSAqIDI7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZnJhY3Rpb24gaXMgY2xvc2VyIHRvIHgsIG4wL2QwIG9yIG4xL2QxXHJcbiAgICAgIHIgPSBkaXYobjEsIGQxLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKS5jb21wYXJlZFRvKFxyXG4gICAgICAgICAgZGl2KG4wLCBkMCwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkpIDwgMSA/IFtuMSwgZDFdIDogW24wLCBkMF07XHJcblxyXG4gICAgICBNQVhfRVhQID0gZXhwO1xyXG5cclxuICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAgICovXHJcbiAgICBQLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gK3ZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0gb3IgUk9VTkRJTkdfTU9ERS4gSWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzXHJcbiAgICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxyXG4gICAgICogZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgaWYgKHNkICE9IG51bGwpIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIHNkLCBybSwgMik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgICAqIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLCByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kXHJcbiAgICAgKiBST1VORElOR19NT0RFLiBJZiBhIGJhc2UgaXMgbm90IHNwZWNpZmllZCwgYW5kIHRoaXMgQmlnTnVtYmVyIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogVE9fRVhQX05FRywgcmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICovXHJcbiAgICBQLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBuID0gdGhpcyxcclxuICAgICAgICBzID0gbi5zLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eSBvciBOYU4/XHJcbiAgICAgIGlmIChlID09PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgIHN0ciA9ICdJbmZpbml0eSc7XHJcbiAgICAgICAgICBpZiAocyA8IDApIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RyID0gJ05hTic7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChiID09IG51bGwpIHtcclxuICAgICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgICA/IHRvRXhwb25lbnRpYWwoY29lZmZUb1N0cmluZyhuLmMpLCBlKVxyXG4gICAgICAgICAgIDogdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDEwKSB7XHJcbiAgICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgREVDSU1BTF9QTEFDRVMgKyBlICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBuLmUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyksIDEwLCBiLCBzLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCAmJiBuLmNbMF0pIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudCwgYW5kIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24gZm9yXHJcbiAgICAgKiBuZWdhdGl2ZSB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBQLl9pc0JpZ051bWJlciA9IHRydWU7XHJcblxyXG4gICAgaWYgKGhhc1N5bWJvbCkge1xyXG4gICAgICBQW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAnQmlnTnVtYmVyJztcclxuXHJcbiAgICAgIC8vIE5vZGUuanMgdjEwLjEyLjArXHJcbiAgICAgIFBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBQLnZhbHVlT2Y7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbmZpZ09iamVjdCAhPSBudWxsKSBCaWdOdW1iZXIuc2V0KGNvbmZpZ09iamVjdCk7XHJcblxyXG4gICAgcmV0dXJuIEJpZ051bWJlcjtcclxuICB9XHJcblxyXG5cclxuICAvLyBQUklWQVRFIEhFTFBFUiBGVU5DVElPTlNcclxuXHJcbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRvbid0IG5lZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyxcclxuICAvLyBlLmcuIERFQ0lNQUxfUExBQ0VTLCBpbiB0aGUgc2NvcGUgb2YgdGhlIGBjbG9uZWAgZnVuY3Rpb24gYWJvdmUuXHJcblxyXG5cclxuICBmdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgICB2YXIgaSA9IG4gfCAwO1xyXG4gICAgcmV0dXJuIG4gPiAwIHx8IG4gPT09IGkgPyBpIDogaSAtIDE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbiAgZnVuY3Rpb24gY29lZmZUb1N0cmluZyhhKSB7XHJcbiAgICB2YXIgcywgeixcclxuICAgICAgaSA9IDEsXHJcbiAgICAgIGogPSBhLmxlbmd0aCxcclxuICAgICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgICBmb3IgKDsgaSA8IGo7KSB7XHJcbiAgICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoOyB6LS07IHMgPSAnMCcgKyBzKTtcclxuICAgICAgciArPSBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7KTtcclxuXHJcbiAgICByZXR1cm4gci5zbGljZSgwLCBqICsgMSB8fCAxKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbiAgZnVuY3Rpb24gY29tcGFyZSh4LCB5KSB7XHJcbiAgICB2YXIgYSwgYixcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jLFxyXG4gICAgICBpID0geC5zLFxyXG4gICAgICBqID0geS5zLFxyXG4gICAgICBrID0geC5lLFxyXG4gICAgICBsID0geS5lO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICBpZiAoIWkgfHwgIWopIHJldHVybiBudWxsO1xyXG5cclxuICAgIGEgPSB4YyAmJiAheGNbMF07XHJcbiAgICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgaWYgKGEgfHwgYikgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgICBhID0gaSA8IDA7XHJcbiAgICBiID0gayA9PSBsO1xyXG5cclxuICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gICAgaWYgKCFiKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDaGVjayB0aGF0IG4gaXMgYSBwcmltaXRpdmUgbnVtYmVyLCBhbiBpbnRlZ2VyLCBhbmQgaW4gcmFuZ2UsIG90aGVyd2lzZSB0aHJvdy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBpbnRDaGVjayhuLCBtaW4sIG1heCwgbmFtZSkge1xyXG4gICAgaWYgKG4gPCBtaW4gfHwgbiA+IG1heCB8fCBuICE9PSBtYXRoZmxvb3IobikpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgIChiaWdudW1iZXJFcnJvciArIChuYW1lIHx8ICdBcmd1bWVudCcpICsgKHR5cGVvZiBuID09ICdudW1iZXInXHJcbiAgICAgICAgID8gbiA8IG1pbiB8fCBuID4gbWF4ID8gJyBvdXQgb2YgcmFuZ2U6ICcgOiAnIG5vdCBhbiBpbnRlZ2VyOiAnXHJcbiAgICAgICAgIDogJyBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiAnKSArIFN0cmluZyhuKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQXNzdW1lcyBmaW5pdGUgbi5cclxuICBmdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgICB2YXIgayA9IG4uYy5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIGJpdEZsb29yKG4uZSAvIExPR19CQVNFKSA9PSBrICYmIG4uY1trXSAlIDIgIT0gMDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0V4cG9uZW50aWFsKHN0ciwgZSkge1xyXG4gICAgcmV0dXJuIChzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIpICtcclxuICAgICAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9GaXhlZFBvaW50KHN0ciwgZSwgeikge1xyXG4gICAgdmFyIGxlbiwgenM7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgICBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICAgIGZvciAoenMgPSB6ICsgJy4nOyArK2U7IHpzICs9IHopO1xyXG4gICAgICBzdHIgPSB6cyArIHN0cjtcclxuXHJcbiAgICAvLyBQb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgaWYgKCsrZSA+IGxlbikge1xyXG4gICAgICAgIGZvciAoenMgPSB6LCBlIC09IGxlbjsgLS1lOyB6cyArPSB6KTtcclxuICAgICAgICBzdHIgKz0genM7XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IGxlbikge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gRVhQT1JUXHJcblxyXG5cclxuICBCaWdOdW1iZXIgPSBjbG9uZSgpO1xyXG4gIEJpZ051bWJlclsnZGVmYXVsdCddID0gQmlnTnVtYmVyLkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQU1ELlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZ051bWJlcjsgfSk7XHJcblxyXG4gIC8vIE5vZGUuanMgYW5kIG90aGVyIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQnJvd3Nlci5cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFnbG9iYWxPYmplY3QpIHtcclxuICAgICAgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiA/IHNlbGYgOiB3aW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgZ2xvYmFsT2JqZWN0LkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuICB9XHJcbn0pKHRoaXMpO1xyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZXhwID0gTWF0aC5leHBcblxuZXhwb3J0cyA9XG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbiBNb3ZpbmdBdmVyYWdlICh0aW1lc3Bhbikge1xuICBpZiAodHlwZW9mIHRpbWVzcGFuICE9PSAnbnVtYmVyJykgeyB0aHJvdyBuZXcgRXJyb3IoJ211c3QgcHJvdmlkZSBhIHRpbWVzcGFuIHRvIHRoZSBtb3ZpbmcgYXZlcmFnZSBjb25zdHJ1Y3RvcicpIH1cblxuICBpZiAodGltZXNwYW4gPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ211c3QgcHJvdmlkZSBhIHRpbWVzcGFuID4gMCB0byB0aGUgbW92aW5nIGF2ZXJhZ2UgY29uc3RydWN0b3InKSB9XG5cbiAgbGV0IG1hICAgICAvLyBtb3ZpbmcgYXZlcmFnZVxuICBsZXQgdiA9IDAgIC8vIHZhcmlhbmNlXG4gIGxldCBkID0gMCAgLy8gZGV2aWF0aW9uXG4gIGxldCBmID0gMCAgLy8gZm9yZWNhc3RcblxuICBsZXQgcHJldmlvdXNUaW1lXG5cbiAgbGV0IHJldCA9IHt9XG5cbiAgZnVuY3Rpb24gYWxwaGEgKHQsIHB0KSB7XG4gICAgcmV0dXJuIDEgLSAoZXhwKC0odCAtIHB0KSAvIHRpbWVzcGFuKSlcbiAgfVxuXG4gIHJldC5wdXNoID1cbiAgZnVuY3Rpb24gcHVzaCAodGltZSwgdmFsdWUpIHtcbiAgICBpZiAocHJldmlvdXNUaW1lKSB7XG4gICAgICAvLyBjYWxjdWxhdGUgbW92aW5nIGF2ZXJhZ2VcbiAgICAgIGNvbnN0IGEgPSBhbHBoYSh0aW1lLCBwcmV2aW91c1RpbWUpXG4gICAgICBjb25zdCBkaWZmID0gdmFsdWUgLSBtYVxuICAgICAgY29uc3QgaW5jciA9IGEgKiBkaWZmXG4gICAgICBtYSA9IGEgKiB2YWx1ZSArICgxIC0gYSkgKiBtYVxuICAgICAgLy8gY2FsY3VsYXRlIHZhcmlhbmNlICYgZGV2aWF0aW9uXG4gICAgICB2ID0gKDEgLSBhKSAqICh2ICsgZGlmZiAqIGluY3IpXG4gICAgICBkID0gTWF0aC5zcXJ0KHYpXG4gICAgICAvLyBjYWxjdWxhdGUgZm9yZWNhc3RcbiAgICAgIGYgPSBtYSArIGEgKiBkaWZmXG4gICAgfSBlbHNlIHtcbiAgICAgIG1hID0gdmFsdWVcbiAgICB9XG4gICAgcHJldmlvdXNUaW1lID0gdGltZVxuICB9XG5cbiAgLy8gRXhwb25lbnRpYWwgTW92aW5nIEF2ZXJhZ2VcblxuICByZXQubW92aW5nQXZlcmFnZSA9XG4gIGZ1bmN0aW9uIG1vdmluZ0F2ZXJhZ2UgKCkge1xuICAgIHJldHVybiBtYVxuICB9XG5cbiAgLy8gVmFyaWFuY2VcbiAgcmV0LnZhcmlhbmNlID1cbiAgZnVuY3Rpb24gdmFyaWFuY2UgKCkge1xuICAgIHJldHVybiB2XG4gIH1cblxuICByZXQuZGV2aWF0aW9uID1cbiAgZnVuY3Rpb24gZGV2aWF0aW9uICgpIHtcbiAgICByZXR1cm4gZFxuICB9XG5cbiAgcmV0LmZvcmVjYXN0ID1cbiAgZnVuY3Rpb24gZm9yZWNhc3QgKCkge1xuICAgIHJldHVybiBmXG4gIH1cblxuICByZXR1cm4gcmV0XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcblxuY29uc3QgcG9vbFNpemUgPSAxMCAqIDEwMjRcblxuZnVuY3Rpb24gZW5jb2RlIChvcHRzKSB7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBmaXhlZDogZmFsc2VcbiAgfSwgb3B0cyB8fCB7fSlcblxuICAvLyBPbmx5IG5lZWRlZCBmb3IgdmFyaW50XG4gIGNvbnN0IHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG4gIGxldCBwb29sID0gb3B0cy5maXhlZCA/IG51bGwgOiBjcmVhdGVQb29sKClcbiAgbGV0IHVzZWQgPSAwXG5cbiAgbGV0IGVuZGVkID0gZmFsc2VcblxuICByZXR1cm4gKHJlYWQpID0+IChlbmQsIGNiKSA9PiB7XG4gICAgaWYgKGVuZCkgZW5kZWQgPSBlbmRcbiAgICBpZiAoZW5kZWQpIHJldHVybiBjYihlbmRlZClcblxuICAgIHJlYWQobnVsbCwgKGVuZCwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVuZCkgZW5kZWQgPSBlbmRcbiAgICAgIGlmIChlbmRlZCkgcmV0dXJuIGNiKGVuZGVkKVxuXG4gICAgICBpZiAoIWVuZGVkICYmICFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgZW5kZWQgPSBuZXcgRXJyb3IoJ2RhdGEgbXVzdCBiZSBhIGJ1ZmZlcicpXG4gICAgICAgIHJldHVybiBjYihlbmRlZClcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGVuZGVkID8gMCA6IGRhdGEubGVuZ3RoXG5cbiAgICAgIGxldCBlbmNvZGVkTGVuZ3RoXG4gICAgICBpZiAob3B0cy5maXhlZCkge1xuICAgICAgICBlbmNvZGVkTGVuZ3RoID0gQnVmZmVyLmFsbG9jKDQpXG4gICAgICAgIGVuY29kZWRMZW5ndGgud3JpdGVJbnQzMkJFKGRhdGFMZW5ndGgsIDApIC8vIHdyaXRlcyBleGFjdGx5IDQgYnl0ZXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhcmludC5lbmNvZGUoZGF0YUxlbmd0aCwgcG9vbCwgdXNlZClcbiAgICAgICAgdXNlZCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG4gICAgICAgIGVuY29kZWRMZW5ndGggPSBwb29sLnNsaWNlKHVzZWQgLSB2YXJpbnQuZW5jb2RlLmJ5dGVzLCB1c2VkKVxuXG4gICAgICAgIGlmIChwb29sLmxlbmd0aCAtIHVzZWQgPCAxMDApIHtcbiAgICAgICAgICBwb29sID0gY3JlYXRlUG9vbCgpXG4gICAgICAgICAgdXNlZCA9IDBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW5kZWQpIHtcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIGVuY29kZWRMZW5ndGgpXG4gICAgICB9XG5cbiAgICAgIGNiKG51bGwsIEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICBlbmNvZGVkTGVuZ3RoLFxuICAgICAgICBkYXRhXG4gICAgICBdLCAob3B0cy5maXhlZCA/IDQgOiB2YXJpbnQuZW5jb2RlLmJ5dGVzKSArIGRhdGFMZW5ndGgpKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9vbCAoKSB7XG4gIHJldHVybiBCdWZmZXIuYWxsb2MocG9vbFNpemUpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmNvbnN0IFJlYWRlciA9IHJlcXVpcmUoJ3B1bGwtcmVhZGVyJylcbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5jb25zdCBwdXNoYWJsZSA9IHJlcXVpcmUoJ3B1bGwtcHVzaGFibGUnKVxuXG5leHBvcnRzLmRlY29kZSA9IGRlY29kZVxuZXhwb3J0cy5kZWNvZGVGcm9tUmVhZGVyID0gZGVjb2RlRnJvbVJlYWRlclxuXG5jb25zdCBNU0IgPSAweDgwXG5jb25zdCBpc0VuZEJ5dGUgPSAoYnl0ZSkgPT4gIShieXRlICYgTVNCKVxuY29uc3QgTUFYX0xFTkdUSCA9ICgoMTAyNCAqIDEwMjQpICogNClcblxuZnVuY3Rpb24gZGVjb2RlIChvcHRzKSB7XG4gIGxldCByZWFkZXIgPSBuZXcgUmVhZGVyKClcbiAgbGV0IHAgPSBwdXNoYWJsZSgoZXJyKSA9PiB7XG4gICAgcmVhZGVyLmFib3J0KGVycilcbiAgfSlcblxuICByZXR1cm4gKHJlYWQpID0+IHtcbiAgICByZWFkZXIocmVhZClcblxuICAgIC8vIHRoaXMgZnVuY3Rpb24gaGFzIHRvIGJlIHdyaXR0ZW4gd2l0aG91dCByZWN1cnNpb25cbiAgICAvLyBvciBpdCBibG93cyB0aGUgc3RhY2sgaW4gY2FzZSBvZiBzeW5jIHN0cmVhbVxuICAgIGZ1bmN0aW9uIG5leHQgKCkge1xuICAgICAgbGV0IGRvTmV4dCA9IHRydWVcbiAgICAgIGxldCBkZWNvZGVkID0gZmFsc2VcblxuICAgICAgY29uc3QgZGVjb2RlQ2IgPSAoZXJyLCBtc2cpID0+IHtcbiAgICAgICAgZGVjb2RlZCA9IHRydWVcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHAuZW5kKGVycilcbiAgICAgICAgICBkb05leHQgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHAucHVzaChtc2cpXG4gICAgICAgICAgaWYgKCFkb05leHQpIHtcbiAgICAgICAgICAgIG5leHQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoZG9OZXh0KSB7XG4gICAgICAgIGRlY29kZWQgPSBmYWxzZVxuICAgICAgICBfZGVjb2RlRnJvbVJlYWRlcihyZWFkZXIsIG9wdHMsIGRlY29kZUNiKVxuICAgICAgICBpZiAoIWRlY29kZWQpIHtcbiAgICAgICAgICBkb05leHQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV4dCgpXG5cbiAgICByZXR1cm4gcFxuICB9XG59XG5cbi8vIHdyYXBwZXIgdG8gZGV0ZWN0IHN1ZGRlbiBwdWxsLXN0cmVhbSBkaXNjb25uZWN0c1xuZnVuY3Rpb24gZGVjb2RlRnJvbVJlYWRlciAocmVhZGVyLCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfVxuXG4gIF9kZWNvZGVGcm9tUmVhZGVyKHJlYWRlciwgb3B0cywgZnVuY3Rpb24gb25Db21wbGV0ZSAoZXJyLCBtc2cpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoZXJyID09PSB0cnVlKSByZXR1cm4gY2IobmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCBmcm9tIHJlYWRlci4nKSlcbiAgICAgIHJldHVybiBjYihlcnIpXG4gICAgfVxuICAgIGNiKG51bGwsIG1zZylcbiAgfSlcbn1cblxuZnVuY3Rpb24gX2RlY29kZUZyb21SZWFkZXIgKHJlYWRlciwgb3B0cywgY2IpIHtcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGZpeGVkOiBmYWxzZSxcbiAgICBtYXhMZW5ndGg6IE1BWF9MRU5HVEhcbiAgfSwgb3B0cyB8fCB7fSlcblxuICBpZiAob3B0cy5maXhlZCkge1xuICAgIHJlYWRGaXhlZE1lc3NhZ2UocmVhZGVyLCBvcHRzLm1heExlbmd0aCwgY2IpXG4gIH0gZWxzZSB7XG4gICAgcmVhZFZhcmludE1lc3NhZ2UocmVhZGVyLCBvcHRzLm1heExlbmd0aCwgY2IpXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZEZpeGVkTWVzc2FnZSAocmVhZGVyLCBtYXhMZW5ndGgsIGNiKSB7XG4gIHJlYWRlci5yZWFkKDQsIChlcnIsIGJ5dGVzKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycilcbiAgICB9XG5cbiAgICBjb25zdCBtc2dTaXplID0gYnl0ZXMucmVhZEludDMyQkUoMCkgLy8gcmVhZHMgZXhhY3RseSA0IGJ5dGVzXG4gICAgaWYgKG1zZ1NpemUgPiBtYXhMZW5ndGgpIHtcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ3NpemUgbG9uZ2VyIHRoYW4gbWF4IHBlcm1pdHRlZCBsZW5ndGggb2YgJyArIG1heExlbmd0aCArICchJykpXG4gICAgfVxuXG4gICAgcmVhZE1lc3NhZ2UocmVhZGVyLCBtc2dTaXplLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVhZFZhcmludE1lc3NhZ2UgKHJlYWRlciwgbWF4TGVuZ3RoLCBjYikge1xuICBsZXQgcmF3TXNnU2l6ZSA9IFtdXG4gIGlmIChyYXdNc2dTaXplLmxlbmd0aCA9PT0gMCkgcmVhZEJ5dGUoKVxuXG4gIC8vIDEuIFJlYWQgdGhlIHZhcmludFxuICBmdW5jdGlvbiByZWFkQnl0ZSAoKSB7XG4gICAgcmVhZGVyLnJlYWQoMSwgKGVyciwgYnl0ZSkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuXG4gICAgICByYXdNc2dTaXplLnB1c2goYnl0ZSlcblxuICAgICAgaWYgKGJ5dGUgJiYgIWlzRW5kQnl0ZShieXRlWzBdKSkge1xuICAgICAgICByZWFkQnl0ZSgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBtc2dTaXplID0gdmFyaW50LmRlY29kZShCdWZmZXIuY29uY2F0KHJhd01zZ1NpemUpKVxuICAgICAgaWYgKG1zZ1NpemUgPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignc2l6ZSBsb25nZXIgdGhhbiBtYXggcGVybWl0dGVkIGxlbmd0aCBvZiAnICsgbWF4TGVuZ3RoICsgJyEnKSlcbiAgICAgIH1cblxuICAgICAgcmVhZE1lc3NhZ2UocmVhZGVyLCBtc2dTaXplLCAoZXJyLCBtc2cpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cblxuICAgICAgICByYXdNc2dTaXplID0gW11cblxuICAgICAgICBpZiAobXNnLmxlbmd0aCA8IG1zZ1NpemUpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdNZXNzYWdlIGxlbmd0aCBkb2VzIG5vdCBtYXRjaCBwcmVmaXggc3BlY2lmaWVkIGxlbmd0aC4nKSlcbiAgICAgICAgfVxuICAgICAgICBjYihudWxsLCBtc2cpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZE1lc3NhZ2UgKHJlYWRlciwgc2l6ZSwgY2IpIHtcbiAgcmVhZGVyLnJlYWQoc2l6ZSwgKGVyciwgbXNnKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycilcbiAgICB9XG5cbiAgICBjYihudWxsLCBtc2cpXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gYC8vIFJlY29yZCByZXByZXNlbnRzIGEgZGh0IHJlY29yZCB0aGF0IGNvbnRhaW5zIGEgdmFsdWVcbi8vIGZvciBhIGtleSB2YWx1ZSBwYWlyXG5tZXNzYWdlIFJlY29yZCB7XG4gIC8vIFRoZSBrZXkgdGhhdCByZWZlcmVuY2VzIHRoaXMgcmVjb3JkXG4gIGJ5dGVzIGtleSA9IDE7XG5cbiAgLy8gVGhlIGFjdHVhbCB2YWx1ZSB0aGlzIHJlY29yZCBpcyBzdG9yaW5nXG4gIGJ5dGVzIHZhbHVlID0gMjtcblxuICAvLyBOb3RlOiBUaGVzZSBmaWVsZHMgd2VyZSByZW1vdmVkIGZyb20gdGhlIFJlY29yZCBtZXNzYWdlXG4gIC8vIGhhc2ggb2YgdGhlIGF1dGhvcnMgcHVibGljIGtleVxuICAvLyBvcHRpb25hbCBieXRlcyBhdXRob3IgPSAzO1xuICAvLyBBIFBLSSBzaWduYXR1cmUgZm9yIHRoZSBrZXkrdmFsdWUrYXV0aG9yXG4gIC8vIG9wdGlvbmFsIGJ5dGVzIHNpZ25hdHVyZSA9IDQ7XG5cbiAgLy8gVGltZSB0aGUgcmVjb3JkIHdhcyByZWNlaXZlZCwgc2V0IGJ5IHJlY2VpdmVyXG4gIG9wdGlvbmFsIHN0cmluZyB0aW1lUmVjZWl2ZWQgPSA1O1xufWBcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIENvbnZlcnQgYSBKYXZhU2NyaXB0IGRhdGUgaW50byBhbiBgUkZDMzMzOU5hbm9gIGZvcm1hdHRlZFxuICogc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RGF0ZX0gdGltZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMudG9SRkMzMzM5ID0gKHRpbWUpID0+IHtcbiAgY29uc3QgeWVhciA9IHRpbWUuZ2V0VVRDRnVsbFllYXIoKVxuICBjb25zdCBtb250aCA9IFN0cmluZyh0aW1lLmdldFVUQ01vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpXG4gIGNvbnN0IGRheSA9IFN0cmluZyh0aW1lLmdldFVUQ0RhdGUoKSkucGFkU3RhcnQoMiwgJzAnKVxuICBjb25zdCBob3VyID0gU3RyaW5nKHRpbWUuZ2V0VVRDSG91cnMoKSkucGFkU3RhcnQoMiwgJzAnKVxuICBjb25zdCBtaW51dGUgPSBTdHJpbmcodGltZS5nZXRVVENNaW51dGVzKCkpLnBhZFN0YXJ0KDIsICcwJylcbiAgY29uc3Qgc2Vjb25kcyA9IFN0cmluZyh0aW1lLmdldFVUQ1NlY29uZHMoKSkucGFkU3RhcnQoMiwgJzAnKVxuICBjb25zdCBtaWxsaXNlY29uZHMgPSB0aW1lLmdldFVUQ01pbGxpc2Vjb25kcygpXG4gIGNvbnN0IG5hbm9zZWNvbmRzID0gbWlsbGlzZWNvbmRzICogMTAwMCAqIDEwMDBcblxuICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9VCR7aG91cn06JHttaW51dGV9OiR7c2Vjb25kc30uJHtuYW5vc2Vjb25kc31aYFxufVxuXG4vKipcbiAqIFBhcnNlcyBhIGRhdGUgc3RyaW5nIGZvcm1hdHRlZCBhcyBgUkZDMzMzOU5hbm9gIGludG8gYVxuICogSmF2YVNjcmlwdCBEYXRlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGltZVxuICogQHJldHVybnMge0RhdGV9XG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlUkZDMzMzOSA9ICh0aW1lKSA9PiB7XG4gIGNvbnN0IHJmYzMzMzlNYXRjaGVyID0gbmV3IFJlZ0V4cChcbiAgICAvLyAyMDA2LTAxLTAyVFxuICAgICcoXFxcXGR7NH0pLShcXFxcZHsyfSktKFxcXFxkezJ9KVQnICtcbiAgICAvLyAxNTowNDowNVxuICAgICcoXFxcXGR7Mn0pOihcXFxcZHsyfSk6KFxcXFxkezJ9KScgK1xuICAgIC8vIC45OTk5OTk5OTlaXG4gICAgJ1xcXFwuKFxcXFxkKylaJ1xuICApXG4gIGNvbnN0IG0gPSBTdHJpbmcodGltZSkudHJpbSgpLm1hdGNoKHJmYzMzMzlNYXRjaGVyKVxuXG4gIGlmICghbSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmb3JtYXQnKVxuICB9XG5cbiAgY29uc3QgeWVhciA9IHBhcnNlSW50KG1bMV0sIDEwKVxuICBjb25zdCBtb250aCA9IHBhcnNlSW50KG1bMl0sIDEwKSAtIDFcbiAgY29uc3QgZGF0ZSA9IHBhcnNlSW50KG1bM10sIDEwKVxuICBjb25zdCBob3VyID0gcGFyc2VJbnQobVs0XSwgMTApXG4gIGNvbnN0IG1pbnV0ZSA9IHBhcnNlSW50KG1bNV0sIDEwKVxuICBjb25zdCBzZWNvbmQgPSBwYXJzZUludChtWzZdLCAxMClcbiAgY29uc3QgbWlsbGlzZWNvbmQgPSBwYXJzZUludChtWzddLnNsaWNlKDAsIC02KSwgMTApXG5cbiAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXRlLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwazogcmVxdWlyZSgnLi9wdWJsaWMta2V5Jylcbn1cbiIsInZhciBidWZmZXJJbmRleE9mID0gcmVxdWlyZSgnYnVmZmVyLWluZGV4b2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihidWYsc3BsaXRCdWYsaW5jbHVkZURlbGltKXtcbiAgXG4gIHZhciBzZWFyY2ggPSAtMVxuICAsIGxpbmVzID0gW11cbiAgLCBtb3ZlID0gaW5jbHVkZURlbGltP3NwbGl0QnVmLmxlbmd0aDowXG4gIDtcblxuICB3aGlsZSgoc2VhcmNoID0gYnVmZmVySW5kZXhPZihidWYsc3BsaXRCdWYpKSA+IC0xKXtcbiAgICBsaW5lcy5wdXNoKGJ1Zi5zbGljZSgwLHNlYXJjaCttb3ZlKSk7XG4gICAgYnVmID0gYnVmLnNsaWNlKHNlYXJjaCtzcGxpdEJ1Zi5sZW5ndGgsYnVmLmxlbmd0aCk7XG4gIH1cblxuICBsaW5lcy5wdXNoKGJ1Zik7XG4gICAgICAgIFxuICByZXR1cm4gbGluZXM7XG59XG5cblxuXG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGs6IHJlcXVpcmUoJy4vcHVibGljLWtleScpXG59XG4iLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBAdHlwZWRlZiB7bnVtYmVyfSBNZXNzYWdlVHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge01lc3NhZ2VUeXBlfVxuICovXG5leHBvcnRzLlR5cGVzID0ge1xuICBORVc6IDAsXG4gIElOX01FU1NBR0U6IDEsXG4gIE9VVF9NRVNTQUdFOiAyLFxuICBJTl9DTE9TRTogMyxcbiAgT1VUX0NMT1NFOiA0LFxuICBJTl9SRVNFVDogNSxcbiAgT1VUX1JFU0VUOiA2XG59XG5cbmV4cG9ydHMuTUFYX01TR19TSVpFID0gMSA8PCAyMCAvLyAxTUJcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gdGhhdFxuICogQHBhcmFtIHtDaGFubmVsfSBjaGFuXG4gKiBAcGFyYW0ge251bWJlcn0gaWRcbiAqL1xuZnVuY3Rpb24gZW1pdFN0cmVhbSAodGhhdCwgY2hhbiwgaWQpIHtcbiAgdGhhdC5lbWl0KCdzdHJlYW0nLCBjaGFuLCBpZClcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHRoYXRcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKi9cbmZ1bmN0aW9uIGVtaXRFcnJvciAodGhhdCwgZXJyb3IpIHtcbiAgdGhhdC5lbWl0KCdlcnJvcicsIGVycm9yKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5lbWl0RXJyb3IgPSBlbWl0RXJyb3Jcbm1vZHVsZS5leHBvcnRzLmVtaXRTdHJlYW0gPSBlbWl0U3RyZWFtXG4iLCJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGFjdGl2ZSA9IGZhbHNlLCBjYWxsZWQgPSAwXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGVkID0gdHJ1ZVxuICAgIGlmKCFhY3RpdmUpIHtcbiAgICAgIGFjdGl2ZSA9IHRydWVcbiAgICAgIHdoaWxlKGNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSBmYWxzZVxuICAgICAgICBmbigpXG4gICAgICB9XG4gICAgICBhY3RpdmUgPSBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG5cblxuXG5cblxuXG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgdGhyb3VnaCA9IHJlcXVpcmUoJ3B1bGwtdGhyb3VnaCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcblxuY29uc3QgbG9nID0gZGVidWcoJ3B1bGwtcGxleDpjb2RlcicpXG5sb2cuZXJyID0gZGVidWcoJ3B1bGwtcGxleDpjb2RlcjplcnInKVxuXG5jb25zdCBQVUxMX0xFTkdUSCA9IDEwICogMTAyNFxuY29uc3QgZW1wdHkgPSBCdWZmZXIuYWxsb2MoMClcblxuLyoqXG4gKiBDcmVhdGVzIGEgVGhyb3VnaCBQdWxsU3RyZWFtIHRoYXQgd2lsbCB2YXJpbnQgZW5jb2RlIGFsbFxuICogbWVzc2FnZXMgcGFzc2VkIHRocm91Z2ggaXQuXG4gKlxuICogQHJldHVybnMge1B1bGxTdHJlYW19IEEgdGhyb3VnaCBzdHJlYW0gdGhhdCB2YXJpbnQgZW5jb2RlcyBhbGwgbWVzc2FnZXNcbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSAoKSA9PiB7XG4gIGxldCBwb29sID0gQnVmZmVyLmFsbG9jVW5zYWZlKFBVTExfTEVOR1RIKVxuICBsZXQgdXNlZCA9IDBcblxuICByZXR1cm4gdGhyb3VnaChmdW5jdGlvbiAobXNnKSB7XG4gICAgY29uc3Qgb2xkVXNlZCA9IHVzZWRcbiAgICB2YXJpbnQuZW5jb2RlKG1zZ1swXSA8PCAzIHwgbXNnWzFdLCBwb29sLCB1c2VkKVxuICAgIHVzZWQgKz0gdmFyaW50LmVuY29kZS5ieXRlc1xuICAgIHZhcmludC5lbmNvZGUobXNnWzJdID8gbXNnWzJdLmxlbmd0aCA6IDAsIHBvb2wsIHVzZWQpXG4gICAgdXNlZCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG4gICAgdGhpcy5xdWV1ZShwb29sLnNsaWNlKG9sZFVzZWQsIHVzZWQpKSAvLyBzZW5kIGhlYWRlclxuXG4gICAgaWYgKFBVTExfTEVOR1RIIC0gdXNlZCA8IDEwMCkge1xuICAgICAgcG9vbCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShQVUxMX0xFTkdUSClcbiAgICAgIHVzZWQgPSAwXG4gICAgfVxuXG4gICAgdGhpcy5xdWV1ZShtc2dbMl0gPyBtc2dbMl0gOiBlbXB0eSlcbiAgfSlcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7bnVtYmVyfSBTdGF0ZXNcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtTdGF0ZXN9XG4gKi9cbmNvbnN0IFN0YXRlcyA9IHtcbiAgUEFSU0lORzogMCxcbiAgUkVBRElORzogMVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBUaHJvdWdoIFB1bGxTdHJlYW0gdGhhdCB3aWxsIHZhcmludCBkZWNvZGVzIGFsbFxuICogbWVzc2FnZXMgcGFzc2VkIHRocm91Z2ggaXQuXG4gKlxuICogQHJldHVybnMge1B1bGxTdHJlYW19IEEgdGhyb3VnaCBzdHJlYW0gdGhhdCB2YXJpbnQgZGVjb2RlcyBhbGwgbWVzc2FnZXNcbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSAoKSA9PiB7XG4gIGxldCBzdGF0ZSA9IFN0YXRlcy5QQVJTSU5HXG5cbiAgY29uc3QgdHJ5RGVjb2RlID0gKG1zZykgPT4ge1xuICAgIGxldCBvZmZzZXQgPSAwXG4gICAgbGV0IGxlbmd0aCA9IDBcbiAgICB0cnkge1xuICAgICAgbGV0IGggPSB2YXJpbnQuZGVjb2RlKG1zZylcbiAgICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgICBsZW5ndGggPSB2YXJpbnQuZGVjb2RlKG1zZywgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgIHJldHVybiBbaCwgb2Zmc2V0LCBsZW5ndGhdXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZXJyKGVycikgLy8gaWdub3JlIGlmIGRhdGEgaXMgZW1wdHlcbiAgICB9XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBjb25zdCBkZWNvZGUgPSAobXNnKSA9PiB7XG4gICAgY29uc3QgW2gsIG9mZnNldCwgbGVuZ3RoXSA9IHRyeURlY29kZShtc2cpXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBoZWFkZXIsIHByb2Nlc3MgaXRcbiAgICBpZiAoaCAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICBpZDogaCA+PiAzLFxuICAgICAgICB0eXBlOiBoICYgNyxcbiAgICAgICAgZGF0YTogW11cbiAgICAgIH1cblxuICAgICAgc3RhdGUgPSBTdGF0ZXMuUkVBRElOR1xuICAgICAgcmV0dXJuIFttc2cuc2xpY2Uob2Zmc2V0KSwgbWVzc2FnZSwgbGVuZ3RoXVxuICAgIH1cblxuICAgIC8vIFRoZXJlIHdhcyBubyBoZWFkZXIsIHJldHVybiB0aGUgbWVzc2FnZVxuICAgIHJldHVybiBbbXNnXVxuICB9XG5cbiAgY29uc3QgcmVhZCA9IChtc2csIGRhdGEsIGxlbmd0aCkgPT4ge1xuICAgIC8vIElmIHdlJ3JlIGRvbmUgcmVhZGluZywgc3RhcnQgcGFyc2luZyB0aGUgbWVzc2FnZVxuICAgIGlmIChsZW5ndGggPD0gMCkge1xuICAgICAgc3RhdGUgPSBTdGF0ZXMuUEFSU0lOR1xuICAgICAgcmV0dXJuIFswLCBtc2csIGRhdGFdXG4gICAgfVxuXG4gICAgLy8gUmVhZCBtb3JlIGRhdGFcbiAgICBsZXQgbGVmdCA9IGxlbmd0aCAtIG1zZy5sZW5ndGhcbiAgICBpZiAobGVmdCA8IDApIHsgbGVmdCA9IDAgfVxuICAgIGNvbnN0IHNpemUgPSBsZW5ndGggLSBsZWZ0XG4gICAgaWYgKG1zZy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBidWZmID0gQnVmZmVyLmlzQnVmZmVyKG1zZykgPyBtc2cgOiBCdWZmZXIuZnJvbShtc2cpXG4gICAgICBkYXRhLnB1c2goYnVmZi5zbGljZSgwLCBzaXplKSlcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBmaW5pc2hlZCByZWFkaW5nLCBzdGFydCBwYXJzaW5nXG4gICAgaWYgKGxlZnQgPD0gMCkgeyBzdGF0ZSA9IFN0YXRlcy5QQVJTSU5HIH1cbiAgICByZXR1cm4gW2xlZnQsIG1zZy5zbGljZShzaXplKSwgZGF0YV1cbiAgfVxuXG4gIGxldCBsZW5ndGggPSAwXG4gIGxldCBtZXNzYWdlID0gbnVsbFxuICBsZXQgYWNjdW11bGF0aW5nID0gZmFsc2VcbiAgbGV0IGFycmF5ID0gW11cbiAgcmV0dXJuIHRocm91Z2goZnVuY3Rpb24gKG1zZykge1xuICAgIHZhciBwcyA9IHRoaXNcbiAgICBmdW5jdGlvbiBtb3JlICgpIHtcbiAgICAgIGlmIChtc2cgJiYgbXNnLmxlbmd0aCkge1xuICAgICAgICAvLyBSZWFkaW5nIGlzIGRvbmUgZm9yIHRoaXMgbWVzc2FnZSwgc3RhcnQgcHJvY2Vzc2luZyBpdFxuICAgICAgICBpZiAoU3RhdGVzLlBBUlNJTkcgPT09IHN0YXRlKSB7XG4gICAgICAgICAgaWYgKGFjY3VtdWxhdGluZykge1xuICAgICAgICAgICAgYXJyYXkucHVzaChtc2cpXG4gICAgICAgICAgICBtc2cgPSBCdWZmZXIuY29uY2F0KGFycmF5KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIFttc2csIG1lc3NhZ2UsIGxlbmd0aF0gPSBkZWNvZGUobXNnKVxuICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKCFhY2N1bXVsYXRpbmcpIHtcbiAgICAgICAgICAgICAgYXJyYXkucHVzaChtc2cpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2N1bXVsYXRpbmcgPSB0cnVlXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnJheSA9IFtdXG4gICAgICAgICAgYWNjdW11bGF0aW5nID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlJ3JlIG5vdCBkb25lIHJlYWRpbmcgdGhlIG1lc3NhZ2UsIGtlZXAgcmVhZGluZyBpdFxuICAgICAgICBpZiAoU3RhdGVzLlJFQURJTkcgPT09IHN0YXRlKSB7XG4gICAgICAgICAgW2xlbmd0aCwgbXNnLCBtZXNzYWdlLmRhdGFdID0gcmVhZChtc2csIG1lc3NhZ2UuZGF0YSwgbGVuZ3RoKVxuXG4gICAgICAgICAgLy8gSWYgd2UgcmVhZCB0aGUgd2hvbGUgbWVzc2FnZSwgYWRkIGl0IHRvIHRoZSBxdWV1ZVxuICAgICAgICAgIGlmIChsZW5ndGggPD0gMCAmJiBTdGF0ZXMuUEFSU0lORyA9PT0gc3RhdGUpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IEJ1ZmZlci5jb25jYXQobWVzc2FnZS5kYXRhKVxuICAgICAgICAgICAgcHMucXVldWUobWVzc2FnZSlcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBudWxsXG4gICAgICAgICAgICBsZW5ndGggPSAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbW9yZSgpXG4gICAgICB9XG4gICAgfVxuICAgIG1vcmUoKVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHB1c2hhYmxlID0gcmVxdWlyZSgncHVsbC1wdXNoYWJsZScpXG5jb25zdCBsb29wZXIgPSByZXF1aXJlKCdsb29wZXInKVxuY29uc3QgbmV4dFRpY2sgPSByZXF1aXJlKCdhc3luYy9uZXh0VGljaycpXG5jb25zdCBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcblxuY29uc3QgeyBUeXBlcyB9ID0gcmVxdWlyZSgnLi9jb25zdHMnKVxuY29uc3QgeyBlbWl0RXJyb3IgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbmNvbnN0IGxvZyA9IGRlYnVnKCdwdWxsLXBsZXg6Y2hhbicpXG5sb2cuZXJyID0gZGVidWcoJ3B1bGwtcGxleDpjaGFuOmVycicpXG5cbi8qKlxuICogQ3JlYXRlcyBhIHB1bGwtc3RyZWFtIHNpbmsgZm9yIHRoZSBnaXZlbiBDaGFubmVsXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtDaGFubmVsfSBjaGFubmVsXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IFRoZSBzaW5rIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGNoYW5uZWxTaW5rIChjaGFubmVsKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVhZCkge1xuICAgIGNvbnN0IG5leHQgPSBsb29wZXIoZnVuY3Rpb24gKCkge1xuICAgICAgcmVhZChudWxsLCBmdW5jdGlvbiAoZW5kLCBkYXRhKSB7XG4gICAgICAgIC8vIHN0cmVhbSBhbHJlYWR5IGVuZGVkXG4gICAgICAgIGlmIChjaGFubmVsLl9lbmRlZExvY2FsKSB7IHJldHVybiB9XG5cbiAgICAgICAgY2hhbm5lbC5fZW5kZWRMb2NhbCA9IGVuZCB8fCBmYWxzZVxuXG4gICAgICAgIC8vIHNvdXJjZSBlbmRlZCwgY2xvc2UgdGhlIHN0cmVhbVxuICAgICAgICBpZiAoZW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYW5uZWwuZW5kQ2hhbigpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzb3VyY2UgZXJyb3JlZCwgZGVzdHJveSBzdHJlYW1cbiAgICAgICAgaWYgKGVuZCB8fCBjaGFubmVsLl9kZXN0cm95KSB7XG4gICAgICAgICAgY2hhbm5lbC5kZXN0cm95Q2hhbigpXG4gICAgICAgICAgY2hhbm5lbC5lbWl0KCdlcnJvcicsIGVuZCB8fCBjaGFubmVsLl9kZXN0cm95KVxuICAgICAgICAgIGNoYW5uZWwuZGVzdHJveSgpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBqdXN0IHNlbmRcbiAgICAgICAgY2hhbm5lbC5zZW5kTXNnKGRhdGEpXG4gICAgICAgIG5leHQoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgbmV4dCgpXG4gIH1cbn1cblxuLyoqXG4gKiBAZmlyZXMgQ2hhbm5lbCNjbG9zZVxuICogQGZpcmVzIENoYW5uZWwjZXJyb3JcbiAqL1xuY2xhc3MgQ2hhbm5lbCBleHRlbmRzIEVFIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5pZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdHMuaW5pdGlhdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm5hbWVcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRzLm9wZW5cbiAgICogQHBhcmFtIHtNcGxleH0gb3B0cy5wbGV4XG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKClcblxuICAgIG9wdHMgPSB7IGluaXRpYXRvcjogZmFsc2UsIC4uLm9wdHMgfVxuXG4gICAgdGhpcy5faWQgPSBvcHRzLmlkXG4gICAgdGhpcy5fbmFtZSA9IG9wdHMubmFtZVxuICAgIHRoaXMuX3BsZXggPSBvcHRzLnBsZXhcbiAgICB0aGlzLl9vcGVuID0gb3B0cy5vcGVuXG4gICAgdGhpcy5faW5pdGlhdG9yID0gb3B0cy5pbml0aWF0b3JcbiAgICB0aGlzLl9lbmRlZFJlbW90ZSA9IGZhbHNlIC8vIHJlbW90ZSBzdHJlYW0gZW5kZWRcbiAgICB0aGlzLl9lbmRlZExvY2FsID0gZmFsc2UgLy8gbG9jYWwgc3RyZWFtIGVuZGVkXG4gICAgdGhpcy5fZGVzdHJveSA9IGZhbHNlXG5cbiAgICB0aGlzLk1TRyA9IHRoaXMuX2luaXRpYXRvclxuICAgICAgPyBUeXBlcy5PVVRfTUVTU0FHRVxuICAgICAgOiBUeXBlcy5JTl9NRVNTQUdFXG5cbiAgICB0aGlzLkVORCA9IHRoaXMuX2luaXRpYXRvclxuICAgICAgPyBUeXBlcy5PVVRfQ0xPU0VcbiAgICAgIDogVHlwZXMuSU5fQ0xPU0VcblxuICAgIHRoaXMuUkVTRVQgPSB0aGlzLl9pbml0aWF0b3JcbiAgICAgID8gVHlwZXMuT1VUX1JFU0VUXG4gICAgICA6IFR5cGVzLklOX1JFU0VUXG5cbiAgICB0aGlzLl9sb2coJ25ldyBjaGFubmVsJywgdGhpcy5fbmFtZSlcblxuICAgIHRoaXMuX21zZ3MgPSBwdXNoYWJsZSgoZXJyKSA9PiB7XG4gICAgICB0aGlzLl9sb2coJ3NvdXJjZSBjbG9zZWQnLCBlcnIpXG4gICAgICBpZiAoZXJyICYmIHR5cGVvZiBlcnIgIT09ICdib29sZWFuJykge1xuICAgICAgICBuZXh0VGljayhlbWl0RXJyb3IsIHRoaXMsIGVycilcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMuZW5kQ2hhbigpIC8vIERvIG5vdCB1bmNvbW1lbnQgdGhpcywgaXQgd2lsbCBlbmQgdGhlIGNoYW5uZWwgdG9vIGVhcmx5XG4gICAgfSlcblxuICAgIHRoaXMuX3NvdXJjZSA9IHRoaXMuX21zZ3NcbiAgICB0aGlzLnNpbmsgPSBjaGFubmVsU2luayh0aGlzKVxuICB9XG5cbiAgZ2V0IHNvdXJjZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZVxuICB9XG5cbiAgZ2V0IGlkICgpIHtcbiAgICByZXR1cm4gdGhpcy5faWRcbiAgfVxuXG4gIGdldCBvcGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3BlblxuICB9XG5cbiAgc2V0IG9wZW4gKG9wZW4pIHtcbiAgICB0aGlzLl9vcGVuID0gb3BlblxuICB9XG5cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lXG4gIH1cblxuICBnZXQgZGVzdHJveWVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5kZWRSZW1vdGUgJiYgdGhpcy5fZW5kZWRMb2NhbFxuICB9XG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2Ugd3JhcHBlciBmb3IgdGhlIGxvZyB0aGF0IGFkZHMgdXNlZnVsIG1ldGFkYXRhIHRvIGxvZ3NcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIG9wZXJhdGlvbiBiZWluZyBsb2dnZWRcbiAgICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBkYXRhIExvZ2dlZCB3aXRoIHRoZSBtZXRhZGF0YS4gTXVzdCBiZSBgLnRvU3RyaW5nYCBjYXBhYmxlLiBEZWZhdWx0OiBgJydgXG4gICAqL1xuICBfbG9nIChuYW1lLCBkYXRhKSB7XG4gICAgaWYgKCFsb2cuZW5hYmxlZCkgcmV0dXJuXG4gICAgbG9nKHtcbiAgICAgIG9wOiBuYW1lLFxuICAgICAgbmFtZTogdGhpcy5fbmFtZSxcbiAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgIGVuZGVkTG9jYWw6IHRoaXMuX2VuZGVkTG9jYWwsXG4gICAgICBlbmRlZFJlbW90ZTogdGhpcy5fZW5kZWRSZW1vdGUsXG4gICAgICBpbml0aWF0b3I6IHRoaXMuX2luaXRpYXRvcixcbiAgICAgIGRhdGE6IChkYXRhICYmIGRhdGEudG9TdHJpbmcoKSkgfHwgJydcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2hlcyBgZGF0YWAgaW50byB0aGUgY2hhbm5lbFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YVxuICAgKi9cbiAgcHVzaCAoZGF0YSkge1xuICAgIHRoaXMuX2xvZygncHVzaCcpXG4gICAgdGhpcy5fbXNncy5wdXNoKGRhdGEpXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjaGFubmVsIGZvciB3cml0aW5nXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICAgKi9cbiAgY2xvc2UgKGVycikge1xuICAgIHRoaXMuX2xvZygnY2xvc2UnLCBlcnIpXG4gICAgaWYgKCF0aGlzLl9lbmRlZFJlbW90ZSkge1xuICAgICAgdGhpcy5fZW5kZWRSZW1vdGUgPSBlcnIgfHwgdHJ1ZVxuICAgICAgdGhpcy5fbXNncy5lbmQodGhpcy5fZW5kZWRSZW1vdGUpXG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgZXJyKVxuICAgICAgdGhpcy5wbGV4ID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNoYW5uZWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3JcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIERlZmF1bHQ6IGAnY2hhbm5lbCBkZXN0cm95ZWQhJ2BcbiAgICovXG4gIGRlc3Ryb3kgKGVycikge1xuICAgIHRoaXMuX2xvZygnZGVzdHJveScsIGVycilcbiAgICB0aGlzLl9kZXN0cm95ID0gZXJyIHx8ICdjaGFubmVsIGRlc3Ryb3llZCEnXG4gICAgdGhpcy5jbG9zZSh0aGlzLl9kZXN0cm95KVxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBjaGFubmVsIGlmIGl0J3Mgbm90IGFscmVhZHkgb3Blbi4gQXR0ZW1wdGluZ1xuICAgKiB0byBvcGVuIGFuIGFscmVhZHkgb3BlbmVkIGNoYW5uZWwgaXMgaWdub3JlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIG9wZW5DaGFuIChuYW1lKSB7XG4gICAgaWYgKHRoaXMub3BlbikgeyByZXR1cm4gfSAvLyBjaGFuIGFscmVhZHkgb3BlblxuXG4gICAgdGhpcy5vcGVuID0gdHJ1ZVxuICAgIHRoaXMuX3BsZXgucHVzaChbXG4gICAgICB0aGlzLl9pZCxcbiAgICAgIFR5cGVzLk5FVyxcbiAgICAgIG5hbWUgIT09IHRoaXMuX2lkLnRvU3RyaW5nKCkgPyBuYW1lIDogdGhpcy5faWQudG9TdHJpbmcoKVxuICAgIF0pXG4gIH1cblxuICAvKipcbiAgICogUHVzaGVzIGBkYXRhYCB3cmFwcGVkIGluIGEgYE1lc3NhZ2VgIGludG8gdGhlIGNoYW5uZWwuXG4gICAqIElmIHRoZSBjaGFubmVsIGlzIG5vdCBvcGVuLCBpdCB3aWxsIGJlIG9wZW5lZCBhdXRvbWF0aWNhbGx5LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YVxuICAgKi9cbiAgc2VuZE1zZyAoZGF0YSkge1xuICAgIHRoaXMuX2xvZygnc2VuZE1zZycsIGRhdGEpXG5cbiAgICBpZiAoIXRoaXMub3Blbikge1xuICAgICAgdGhpcy5vcGVuQ2hhbih0aGlzLm5hbWUpXG4gICAgfVxuXG4gICAgdGhpcy5fcGxleC5wdXNoKFtcbiAgICAgIHRoaXMuX2lkLFxuICAgICAgdGhpcy5NU0csXG4gICAgICBkYXRhXG4gICAgXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmRzIHRoZSBjaGFubmVsIGJ5IHNlbmRpbmcgYW4gRU5EIGBNZXNzYWdlYC5cbiAgICogSWYgdGhlIGNoYW5uZWwgaXMgbm90IG9wZW4sIG5vIGFjdGlvbiB3aWxsIGJlIHRha2VuLlxuICAgKi9cbiAgZW5kQ2hhbiAoKSB7XG4gICAgdGhpcy5fbG9nKCdlbmRDaGFuJylcblxuICAgIGlmICghdGhpcy5vcGVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9wbGV4LnB1c2goW1xuICAgICAgdGhpcy5faWQsXG4gICAgICB0aGlzLkVORFxuICAgIF0pXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNoYW5uZWwgYnkgc2VuZGluZyBhIFJFU0VUIGBNZXNzYWdlYC5cbiAgICogSWYgdGhlIGNoYW5uZWwgaXMgbm90IG9wZW4sIG5vIGFjdGlvbiB3aWxsIGJlIHRha2VuLlxuICAgKi9cbiAgZGVzdHJveUNoYW4gKCkge1xuICAgIHRoaXMuX2xvZygnZGVzdHJveUNoYW4nKVxuXG4gICAgaWYgKCF0aGlzLm9wZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3BsZXgucHVzaChbXG4gICAgICB0aGlzLl9pZCxcbiAgICAgIHRoaXMuUkVTRVRcbiAgICBdKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhbm5lbFxuIiwidmFyIGxvb3BlciA9IHJlcXVpcmUoJ2xvb3BlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHdyaXRlciwgZW5kZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZWFkKSB7XG4gICAgdmFyIHF1ZXVlID0gW10sIGVuZGVkLCBlcnJvclxuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZSAoZGF0YSkge1xuICAgICAgcXVldWUucHVzaChkYXRhKVxuICAgIH1cblxuICAgIHdyaXRlciA9IHdyaXRlciB8fCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdGhpcy5xdWV1ZShkYXRhKVxuICAgIH1cblxuICAgIGVuZGVyID0gZW5kZXIgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5xdWV1ZShudWxsKVxuICAgIH1cblxuICAgIHZhciBlbWl0dGVyID0ge1xuICAgICAgZW1pdDogZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIGlmKGV2ZW50ID09ICdkYXRhJykgZW5xdWV1ZShkYXRhKVxuICAgICAgICBpZihldmVudCA9PSAnZW5kJykgIGVuZGVkID0gdHJ1ZSwgZW5xdWV1ZShudWxsKVxuICAgICAgICBpZihldmVudCA9PSAnZXJyb3InKSBlcnJvciA9IGRhdGFcbiAgICAgIH0sXG4gICAgICBxdWV1ZTogZW5xdWV1ZVxuICAgIH1cbiAgICB2YXIgX2NiXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbmQsIGNiKSB7XG4gICAgICBlbmRlZCA9IGVuZGVkIHx8IGVuZFxuICAgICAgaWYoZW5kKVxuICAgICAgICByZXR1cm4gcmVhZChlbmQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZihfY2IpIHtcbiAgICAgICAgICAgIHZhciB0ID0gX2NiOyBfY2IgPSBudWxsOyB0KGVuZClcbiAgICAgICAgICB9XG4gICAgICAgICAgY2IoZW5kKVxuICAgICAgICB9KVxuXG4gICAgICBfY2IgPSBjYlxuICAgICAgbG9vcGVyKGZ1bmN0aW9uIHB1bGwgKG5leHQpIHtcbiAgICAgICAgLy9pZiBpdCdzIGFuIGVycm9yXG4gICAgICAgIGlmKCFfY2IpIHJldHVyblxuICAgICAgICBjYiA9IF9jYlxuICAgICAgICBpZihlcnJvcikgX2NiID0gbnVsbCwgY2IoZXJyb3IpXG4gICAgICAgIGVsc2UgaWYocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBxdWV1ZS5zaGlmdCgpXG4gICAgICAgICAgX2NiID0gbnVsbCxjYihkYXRhID09PSBudWxsLCBkYXRhKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlYWQoZW5kZWQsIGZ1bmN0aW9uIChlbmQsIGRhdGEpIHtcbiAgICAgICAgICAgICAvL251bGwgaGFzIG5vIHNwZWNpYWwgbWVhbmluZyBmb3IgcHVsbC1zdHJlYW1cbiAgICAgICAgICAgIGlmKGVuZCAmJiBlbmQgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgZXJyb3IgPSBlbmQ7IHJldHVybiBuZXh0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGVuZGVkID0gZW5kZWQgfHwgZW5kKSAgZW5kZXIuY2FsbChlbWl0dGVyKVxuICAgICAgICAgICAgZWxzZSBpZihkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdyaXRlci5jYWxsKGVtaXR0ZXIsIGRhdGEpXG4gICAgICAgICAgICAgIGlmKGVycm9yIHx8IGVuZGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiByZWFkKGVycm9yIHx8IGVuZGVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBfY2IgPSBudWxsOyBjYihlcnJvciB8fCBlbmRlZClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dChwdWxsKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbiIsInZhciB3cyA9IHJlcXVpcmUoJy4vJylcbnZhciBXZWJTb2NrZXQgPSByZXF1aXJlKCd3cycpXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpXG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpXG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbm1vZHVsZS5leHBvcnRzID0gIVdlYlNvY2tldC5TZXJ2ZXIgPyBudWxsIDogZnVuY3Rpb24gKG9wdHMsIG9uQ29ubmVjdGlvbikge1xuICAgIHZhciBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpXG4gICAgdmFyIHNlcnZlclxuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICBvbkNvbm5lY3Rpb24gPSBvcHRzXG4gICAgICBvcHRzID0gbnVsbFxuICAgIH1cbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgaWYob25Db25uZWN0aW9uKVxuICAgICAgZW1pdHRlci5vbignY29ubmVjdGlvbicsIG9uQ29ubmVjdGlvbilcblxuICAgIGZ1bmN0aW9uIHByb3h5IChzZXJ2ZXIsIGV2ZW50KSB7XG4gICAgICByZXR1cm4gc2VydmVyLm9uKGV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAgIGFyZ3MudW5zaGlmdChldmVudClcbiAgICAgICAgZW1pdHRlci5lbWl0LmFwcGx5KGVtaXR0ZXIsIGFyZ3MpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHZhciBzZXJ2ZXIgPSBvcHRzLnNlcnZlciB8fFxuICAgICAgKG9wdHMua2V5ICYmIG9wdHMuY2VydCA/IGh0dHBzLmNyZWF0ZVNlcnZlcihvcHRzKSA6IGh0dHAuY3JlYXRlU2VydmVyKCkpXG5cbiAgICB2YXIgd3NTZXJ2ZXIgPSBuZXcgV2ViU29ja2V0LlNlcnZlcih7XG4gICAgICBzZXJ2ZXI6IHNlcnZlcixcbiAgICAgIHBlck1lc3NhZ2VEZWZsYXRlOiBmYWxzZSxcbiAgICAgIHZlcmlmeUNsaWVudDogb3B0cy52ZXJpZnlDbGllbnRcbiAgICB9KVxuXG4gICAgcHJveHkoc2VydmVyLCAnbGlzdGVuaW5nJylcbiAgICBwcm94eShzZXJ2ZXIsICdyZXF1ZXN0JylcbiAgICBwcm94eShzZXJ2ZXIsICdjbG9zZScpXG5cbiAgICB3c1NlcnZlci5vbignY29ubmVjdGlvbicsIGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgIHZhciBzdHJlYW0gPSB3cyhzb2NrZXQpXG4gICAgICBzdHJlYW0ucmVtb3RlQWRkcmVzcyA9IHNvY2tldC51cGdyYWRlUmVxLnNvY2tldC5yZW1vdGVBZGRyZXNzXG4gICAgICBlbWl0dGVyLmVtaXQoJ2Nvbm5lY3Rpb24nLCBzdHJlYW0pXG4gICAgfSlcblxuICAgIGVtaXR0ZXIubGlzdGVuID0gZnVuY3Rpb24gKGFkZHIsIG9uTGlzdGVuaW5nKSB7XG4gICAgICBpZihvbkxpc3RlbmluZylcbiAgICAgICAgZW1pdHRlci5vbmNlKCdsaXN0ZW5pbmcnLCBvbkxpc3RlbmluZylcbiAgICAgIHNlcnZlci5saXN0ZW4oYWRkci5wb3J0IHx8IGFkZHIpXG4gICAgICByZXR1cm4gZW1pdHRlclxuICAgIH1cblxuICAgIGVtaXR0ZXIuY2xvc2UgPSBmdW5jdGlvbiAob25DbG9zZSkge1xuICAgICAgc2VydmVyLmNsb3NlKG9uQ2xvc2UpXG4gICAgICB3c1NlcnZlci5jbG9zZSgpXG4gICAgICByZXR1cm4gZW1pdHRlclxuICAgIH1cblxuICAgIGVtaXR0ZXIuYWRkcmVzcyA9IHNlcnZlci5hZGRyZXNzLmJpbmQoc2VydmVyKVxuICAgIHJldHVybiBlbWl0dGVyXG4gIH1cblxuXG5cblxuXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZGVmZXIgPSByZXF1aXJlKCdwdWxsLWRlZmVyL2R1cGxleCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ29ubmVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yIChjb25uLCBpbmZvKSB7XG4gICAgdGhpcy5wZWVySW5mbyA9IG51bGxcbiAgICB0aGlzLmNvbm4gPSBkZWZlcigpXG5cbiAgICBpZiAoY29ubikge1xuICAgICAgdGhpcy5zZXRJbm5lckNvbm4oY29ubiwgaW5mbylcbiAgICB9IGVsc2UgaWYgKGluZm8pIHtcbiAgICAgIHRoaXMuaW5mbyA9IGluZm9cbiAgICB9XG4gIH1cblxuICBnZXQgc291cmNlICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uLnNvdXJjZVxuICB9XG5cbiAgZ2V0IHNpbmsgKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm4uc2lua1xuICB9XG5cbiAgZ2V0UGVlckluZm8gKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuaW5mbyAmJiB0aGlzLmluZm8uZ2V0UGVlckluZm8pIHtcbiAgICAgIHJldHVybiB0aGlzLmluZm8uZ2V0UGVlckluZm8oY2FsbGJhY2spXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnBlZXJJbmZvKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdQZWVyIEluZm8gbm90IHNldCB5ZXQnKSlcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCB0aGlzLnBlZXJJbmZvKVxuICB9XG5cbiAgc2V0UGVlckluZm8gKHBlZXJJbmZvKSB7XG4gICAgaWYgKHRoaXMuaW5mbyAmJiB0aGlzLmluZm8uc2V0UGVlckluZm8pIHtcbiAgICAgIHJldHVybiB0aGlzLmluZm8uc2V0UGVlckluZm8ocGVlckluZm8pXG4gICAgfVxuXG4gICAgdGhpcy5wZWVySW5mbyA9IHBlZXJJbmZvXG4gIH1cblxuICBnZXRPYnNlcnZlZEFkZHJzIChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmluZm8gJiYgdGhpcy5pbmZvLmdldE9ic2VydmVkQWRkcnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZm8uZ2V0T2JzZXJ2ZWRBZGRycyhjYWxsYmFjaylcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgW10pXG4gIH1cblxuICBzZXRJbm5lckNvbm4gKGNvbm4sIGluZm8pIHtcbiAgICB0aGlzLmNvbm4ucmVzb2x2ZShjb25uKVxuICAgIGlmIChpbmZvKSB7XG4gICAgICB0aGlzLmluZm8gPSBpbmZvXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5mbyA9IGNvbm5cbiAgICB9XG4gIH1cbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIFdlYlNvY2tldCA/IHJlcXVpcmUoJ3dzJykgOiBXZWJTb2NrZXRcbiIsInZhciBydXJsID0gcmVxdWlyZSgncmVsYXRpdmUtdXJsJylcbnZhciBtYXAgPSB7aHR0cDond3MnLCBodHRwczond3NzJ31cbnZhciBkZWYgPSAnd3MnXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBydXJsKHVybCwgbG9jYXRpb24sIG1hcCwgZGVmKVxufVxuXG5cbiIsInZhciBzb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZScpXG52YXIgc2luayA9IHJlcXVpcmUoJy4vc2luaycpXG5cbm1vZHVsZS5leHBvcnRzID0gZHVwbGV4XG5cbmZ1bmN0aW9uIGR1cGxleCAod3MsIG9wdHMpIHtcbiAgdmFyIHJlcSA9IHdzLnVwZ3JhZGVSZXEgfHwge31cbiAgaWYob3B0cyAmJiBvcHRzLmJpbmFyeVR5cGUpXG4gICAgd3MuYmluYXJ5VHlwZSA9IG9wdHMuYmluYXJ5VHlwZVxuICBlbHNlIGlmKG9wdHMgJiYgb3B0cy5iaW5hcnkpXG4gICAgd3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgcmV0dXJuIHtcbiAgICBzb3VyY2U6IHNvdXJjZSh3cywgb3B0cyAmJiBvcHRzLm9uQ29ubmVjdCksXG4gICAgc2luazogc2luayh3cywgb3B0cyksXG5cbiAgICAvL2h0dHAgcHJvcGVydGllcyAtIHVzZWZ1bCBmb3Igcm91dGluZyBvciBhdXRoLlxuICAgIGhlYWRlcnM6IHJlcS5oZWFkZXJzLFxuICAgIHVybDogcmVxLnVybCxcbiAgICB1cGdyYWRlOiByZXEudXBncmFkZSxcbiAgICBtZXRob2Q6IHJlcS5tZXRob2RcbiAgfTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBQZWVyTGlzdCA9IHJlcXVpcmUoJy4vcGVlci1saXN0JylcblxuLyoqXG4gKiBMaWtlIFBlZXJMaXN0IGJ1dCB3aXRoIGEgbGVuZ3RoIHJlc3RyaWN0aW9uLlxuICovXG5jbGFzcyBMaW1pdGVkUGVlckxpc3QgZXh0ZW5kcyBQZWVyTGlzdCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbGltaXRlZCBwZWVyIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGxpbWl0KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMubGltaXQgPSBsaW1pdFxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIFBlZXJJbmZvIGlmIGl0IGZpdHMgaW4gdGhlIGxpc3RcbiAgICpcbiAgICogQHBhcmFtIHtQZWVySW5mb30gaW5mb1xuICAgKiBAcmV0dXJucyB7Ym9vbH1cbiAgICovXG4gIHB1c2ggKGluZm8pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPCB0aGlzLmxpbWl0KSB7XG4gICAgICByZXR1cm4gc3VwZXIucHVzaChpbmZvKVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0ZWRQZWVyTGlzdFxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYC8vIGNhbid0IHVzZSwgYmVjYXVzZSBwcm90b2NvbC1idWZmZXJzIGRvZXNuJ3Qgc3VwcG9ydCBpbXBvcnRzXG4vLyBzbyB3ZSBoYXZlIHRvIGR1cGxpY2F0ZSBmb3Igbm93IDooXG4vLyBpbXBvcnQgXCJyZWNvcmQucHJvdG9cIjtcblxubWVzc2FnZSBSZWNvcmQge1xuICAvLyBhZGp1c3RlZCBmb3IgamF2YXNjcmlwdFxuICBvcHRpb25hbCBieXRlcyBrZXkgPSAxO1xuICBvcHRpb25hbCBieXRlcyB2YWx1ZSA9IDI7XG4gIG9wdGlvbmFsIGJ5dGVzIGF1dGhvciA9IDM7XG4gIG9wdGlvbmFsIGJ5dGVzIHNpZ25hdHVyZSA9IDQ7XG4gIG9wdGlvbmFsIHN0cmluZyB0aW1lUmVjZWl2ZWQgPSA1O1xufVxuXG5tZXNzYWdlIE1lc3NhZ2Uge1xuICBlbnVtIE1lc3NhZ2VUeXBlIHtcbiAgICBQVVRfVkFMVUUgPSAwO1xuICAgIEdFVF9WQUxVRSA9IDE7XG4gICAgQUREX1BST1ZJREVSID0gMjtcbiAgICBHRVRfUFJPVklERVJTID0gMztcbiAgICBGSU5EX05PREUgPSA0O1xuICAgIFBJTkcgPSA1O1xuICB9XG5cbiAgZW51bSBDb25uZWN0aW9uVHlwZSB7XG4gICAgLy8gc2VuZGVyIGRvZXMgbm90IGhhdmUgYSBjb25uZWN0aW9uIHRvIHBlZXIsIGFuZCBubyBleHRyYSBpbmZvcm1hdGlvbiAoZGVmYXVsdClcbiAgICBOT1RfQ09OTkVDVEVEID0gMDtcblxuICAgIC8vIHNlbmRlciBoYXMgYSBsaXZlIGNvbm5lY3Rpb24gdG8gcGVlclxuICAgIENPTk5FQ1RFRCA9IDE7XG5cbiAgICAvLyBzZW5kZXIgcmVjZW50bHkgY29ubmVjdGVkIHRvIHBlZXJcbiAgICBDQU5fQ09OTkVDVCA9IDI7XG5cbiAgICAvLyBzZW5kZXIgcmVjZW50bHkgdHJpZWQgdG8gY29ubmVjdCB0byBwZWVyIHJlcGVhdGVkbHkgYnV0IGZhaWxlZCB0byBjb25uZWN0XG4gICAgLy8gKFwidHJ5XCIgaGVyZSBpcyBsb29zZSwgYnV0IHRoaXMgc2hvdWxkIHNpZ25hbCBcIm1hZGUgc3Ryb25nIGVmZm9ydCwgZmFpbGVkXCIpXG4gICAgQ0FOTk9UX0NPTk5FQ1QgPSAzO1xuICB9XG5cbiAgbWVzc2FnZSBQZWVyIHtcbiAgICAvLyBJRCBvZiBhIGdpdmVuIHBlZXIuXG4gICAgb3B0aW9uYWwgYnl0ZXMgaWQgPSAxO1xuXG4gICAgLy8gbXVsdGlhZGRycyBmb3IgYSBnaXZlbiBwZWVyXG4gICAgcmVwZWF0ZWQgYnl0ZXMgYWRkcnMgPSAyO1xuXG4gICAgLy8gdXNlZCB0byBzaWduYWwgdGhlIHNlbmRlcidzIGNvbm5lY3Rpb24gY2FwYWJpbGl0aWVzIHRvIHRoZSBwZWVyXG4gICAgb3B0aW9uYWwgQ29ubmVjdGlvblR5cGUgY29ubmVjdGlvbiA9IDM7XG4gIH1cblxuICAvLyBkZWZpbmVzIHdoYXQgdHlwZSBvZiBtZXNzYWdlIGl0IGlzLlxuICBvcHRpb25hbCBNZXNzYWdlVHlwZSB0eXBlID0gMTtcblxuICAvLyBkZWZpbmVzIHdoYXQgY29yYWwgY2x1c3RlciBsZXZlbCB0aGlzIHF1ZXJ5L3Jlc3BvbnNlIGJlbG9uZ3MgdG8uXG4gIC8vIGluIGNhc2Ugd2Ugd2FudCB0byBpbXBsZW1lbnQgY29yYWwncyBjbHVzdGVyIHJpbmdzIGluIHRoZSBmdXR1cmUuXG4gIG9wdGlvbmFsIGludDMyIGNsdXN0ZXJMZXZlbFJhdyA9IDEwO1xuXG4gIC8vIFVzZWQgdG8gc3BlY2lmeSB0aGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1lc3NhZ2UuXG4gIC8vIFBVVF9WQUxVRSwgR0VUX1ZBTFVFLCBBRERfUFJPVklERVIsIEdFVF9QUk9WSURFUlNcbiAgLy8gYWRqdXN0ZWQgZm9yIGphdmFzY3JpcHRcbiAgb3B0aW9uYWwgYnl0ZXMga2V5ID0gMjtcblxuICAvLyBVc2VkIHRvIHJldHVybiBhIHZhbHVlXG4gIC8vIFBVVF9WQUxVRSwgR0VUX1ZBTFVFXG4gIC8vIGFkanVzdGVkIFJlY29yZCB0byBieXRlcyBmb3IganNcbiAgb3B0aW9uYWwgYnl0ZXMgcmVjb3JkID0gMztcblxuICAvLyBVc2VkIHRvIHJldHVybiBwZWVycyBjbG9zZXIgdG8gYSBrZXkgaW4gYSBxdWVyeVxuICAvLyBHRVRfVkFMVUUsIEdFVF9QUk9WSURFUlMsIEZJTkRfTk9ERVxuICByZXBlYXRlZCBQZWVyIGNsb3NlclBlZXJzID0gODtcblxuICAvLyBVc2VkIHRvIHJldHVybiBQcm92aWRlcnNcbiAgLy8gR0VUX1ZBTFVFLCBBRERfUFJPVklERVIsIEdFVF9QUk9WSURFUlNcbiAgcmVwZWF0ZWQgUGVlciBwcm92aWRlclBlZXJzID0gOTtcbn1gXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXgpIHtcblxuICBpZiAoIW1heCkgdGhyb3cgRXJyb3IoJ2hhc2hscnUgbXVzdCBoYXZlIGEgbWF4IHZhbHVlLCBvZiB0eXBlIG51bWJlciwgZ3JlYXRlciB0aGFuIDAnKVxuXG4gIHZhciBzaXplID0gMCwgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBfY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgZnVuY3Rpb24gdXBkYXRlIChrZXksIHZhbHVlKSB7XG4gICAgY2FjaGVba2V5XSA9IHZhbHVlXG4gICAgc2l6ZSArK1xuICAgIGlmKHNpemUgPj0gbWF4KSB7XG4gICAgICBzaXplID0gMFxuICAgICAgX2NhY2hlID0gY2FjaGVcbiAgICAgIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gY2FjaGVba2V5XSAhPT0gdW5kZWZpbmVkIHx8IF9jYWNoZVtrZXldICE9PSB1bmRlZmluZWRcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYoY2FjaGVba2V5XSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBjYWNoZVtrZXldID0gdW5kZWZpbmVkXG4gICAgICBpZihfY2FjaGVba2V5XSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBfY2FjaGVba2V5XSA9IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgdiA9IGNhY2hlW2tleV1cbiAgICAgIGlmKHYgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHZcbiAgICAgIGlmKCh2ID0gX2NhY2hlW2tleV0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBkYXRlKGtleSwgdilcbiAgICAgICAgcmV0dXJuIHZcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmKGNhY2hlW2tleV0gIT09IHVuZGVmaW5lZCkgY2FjaGVba2V5XSA9IHZhbHVlXG4gICAgICBlbHNlIHVwZGF0ZShrZXksIHZhbHVlKVxuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgX2NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH1cbiAgfVxufVxuXG5cblxuXG5cblxuXG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG5cbi8vIFBvcnQgb2YgbG93ZXJfYm91bmQgZnJvbSBodHRwOi8vZW4uY3BwcmVmZXJlbmNlLmNvbS93L2NwcC9hbGdvcml0aG0vbG93ZXJfYm91bmRcbi8vIFVzZWQgdG8gY29tcHV0ZSBpbnNlcnRpb24gaW5kZXggdG8ga2VlcCBxdWV1ZSBzb3J0ZWQgYWZ0ZXIgaW5zZXJ0aW9uXG5mdW5jdGlvbiBsb3dlckJvdW5kKGFycmF5LCB2YWx1ZSwgY29tcCkge1xuXHRsZXQgZmlyc3QgPSAwO1xuXHRsZXQgY291bnQgPSBhcnJheS5sZW5ndGg7XG5cblx0d2hpbGUgKGNvdW50ID4gMCkge1xuXHRcdGNvbnN0IHN0ZXAgPSAoY291bnQgLyAyKSB8IDA7XG5cdFx0bGV0IGl0ID0gZmlyc3QgKyBzdGVwO1xuXG5cdFx0aWYgKGNvbXAoYXJyYXlbaXRdLCB2YWx1ZSkgPD0gMCkge1xuXHRcdFx0Zmlyc3QgPSArK2l0O1xuXHRcdFx0Y291bnQgLT0gc3RlcCArIDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvdW50ID0gc3RlcDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmlyc3Q7XG59XG5cbmNsYXNzIFByaW9yaXR5UXVldWUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9xdWV1ZSA9IFtdO1xuXHR9XG5cblx0ZW5xdWV1ZShydW4sIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0ge1xuXHRcdFx0cHJpb3JpdHk6IDAsXG5cdFx0XHQuLi5vcHRpb25zXG5cdFx0fTtcblxuXHRcdGNvbnN0IGVsZW1lbnQgPSB7XG5cdFx0XHRwcmlvcml0eTogb3B0aW9ucy5wcmlvcml0eSxcblx0XHRcdHJ1blxuXHRcdH07XG5cblx0XHRpZiAodGhpcy5zaXplICYmIHRoaXMuX3F1ZXVlW3RoaXMuc2l6ZSAtIDFdLnByaW9yaXR5ID49IG9wdGlvbnMucHJpb3JpdHkpIHtcblx0XHRcdHRoaXMuX3F1ZXVlLnB1c2goZWxlbWVudCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5kZXggPSBsb3dlckJvdW5kKHRoaXMuX3F1ZXVlLCBlbGVtZW50LCAoYSwgYikgPT4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHkpO1xuXHRcdHRoaXMuX3F1ZXVlLnNwbGljZShpbmRleCwgMCwgZWxlbWVudCk7XG5cdH1cblxuXHRkZXF1ZXVlKCkge1xuXHRcdHJldHVybiB0aGlzLl9xdWV1ZS5zaGlmdCgpLnJ1bjtcblx0fVxuXG5cdGdldCBzaXplKCkge1xuXHRcdHJldHVybiB0aGlzLl9xdWV1ZS5sZW5ndGg7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQUXVldWUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRjYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50OiBmYWxzZSxcblx0XHRcdGludGVydmFsQ2FwOiBJbmZpbml0eSxcblx0XHRcdGludGVydmFsOiAwLFxuXHRcdFx0Y29uY3VycmVuY3k6IEluZmluaXR5LFxuXHRcdFx0YXV0b1N0YXJ0OiB0cnVlLFxuXHRcdFx0cXVldWVDbGFzczogUHJpb3JpdHlRdWV1ZSxcblx0XHRcdC4uLm9wdGlvbnNcblx0XHR9O1xuXG5cdFx0aWYgKCEodHlwZW9mIG9wdGlvbnMuY29uY3VycmVuY3kgPT09ICdudW1iZXInICYmIG9wdGlvbnMuY29uY3VycmVuY3kgPj0gMSkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGNvbmN1cnJlbmN5XFxgIHRvIGJlIGEgbnVtYmVyIGZyb20gMSBhbmQgdXAsIGdvdCBcXGAke29wdGlvbnMuY29uY3VycmVuY3l9XFxgICgke3R5cGVvZiBvcHRpb25zLmNvbmN1cnJlbmN5fSlgKTtcblx0XHR9XG5cblx0XHRpZiAoISh0eXBlb2Ygb3B0aW9ucy5pbnRlcnZhbENhcCA9PT0gJ251bWJlcicgJiYgb3B0aW9ucy5pbnRlcnZhbENhcCA+PSAxKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgaW50ZXJ2YWxDYXBcXGAgdG8gYmUgYSBudW1iZXIgZnJvbSAxIGFuZCB1cCwgZ290IFxcYCR7b3B0aW9ucy5pbnRlcnZhbENhcH1cXGAgKCR7dHlwZW9mIG9wdGlvbnMuaW50ZXJ2YWxDYXB9KWApO1xuXHRcdH1cblxuXHRcdGlmICghKE51bWJlci5pc0Zpbml0ZShvcHRpb25zLmludGVydmFsKSAmJiBvcHRpb25zLmludGVydmFsID49IDApKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBpbnRlcnZhbFxcYCB0byBiZSBhIGZpbml0ZSBudW1iZXIgPj0gMCwgZ290IFxcYCR7b3B0aW9ucy5pbnRlcnZhbH1cXGAgKCR7dHlwZW9mIG9wdGlvbnMuaW50ZXJ2YWx9KWApO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NhcnJ5b3ZlckNvbmN1cnJlbmN5Q291bnQgPSBvcHRpb25zLmNhcnJ5b3ZlckNvbmN1cnJlbmN5Q291bnQ7XG5cdFx0dGhpcy5faXNJbnRlcnZhbElnbm9yZWQgPSBvcHRpb25zLmludGVydmFsQ2FwID09PSBJbmZpbml0eSB8fCBvcHRpb25zLmludGVydmFsID09PSAwO1xuXHRcdHRoaXMuX2ludGVydmFsQ291bnQgPSAwO1xuXHRcdHRoaXMuX2ludGVydmFsQ2FwID0gb3B0aW9ucy5pbnRlcnZhbENhcDtcblx0XHR0aGlzLl9pbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWw7XG5cdFx0dGhpcy5faW50ZXJ2YWxJZCA9IG51bGw7XG5cdFx0dGhpcy5faW50ZXJ2YWxFbmQgPSAwO1xuXHRcdHRoaXMuX3RpbWVvdXRJZCA9IG51bGw7XG5cblx0XHR0aGlzLnF1ZXVlID0gbmV3IG9wdGlvbnMucXVldWVDbGFzcygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcblx0XHR0aGlzLl9xdWV1ZUNsYXNzID0gb3B0aW9ucy5xdWV1ZUNsYXNzO1xuXHRcdHRoaXMuX3BlbmRpbmdDb3VudCA9IDA7XG5cdFx0dGhpcy5fY29uY3VycmVuY3kgPSBvcHRpb25zLmNvbmN1cnJlbmN5O1xuXHRcdHRoaXMuX2lzUGF1c2VkID0gb3B0aW9ucy5hdXRvU3RhcnQgPT09IGZhbHNlO1xuXHRcdHRoaXMuX3Jlc29sdmVFbXB0eSA9ICgpID0+IHt9O1xuXHRcdHRoaXMuX3Jlc29sdmVJZGxlID0gKCkgPT4ge307XG5cdH1cblxuXHRnZXQgX2RvZXNJbnRlcnZhbEFsbG93QW5vdGhlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5faXNJbnRlcnZhbElnbm9yZWQgfHwgdGhpcy5faW50ZXJ2YWxDb3VudCA8IHRoaXMuX2ludGVydmFsQ2FwO1xuXHR9XG5cblx0Z2V0IF9kb2VzQ29uY3VycmVudEFsbG93QW5vdGhlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50IDwgdGhpcy5fY29uY3VycmVuY3k7XG5cdH1cblxuXHRfbmV4dCgpIHtcblx0XHR0aGlzLl9wZW5kaW5nQ291bnQtLTtcblx0XHR0aGlzLl90cnlUb1N0YXJ0QW5vdGhlcigpO1xuXHR9XG5cblx0X3Jlc29sdmVQcm9taXNlcygpIHtcblx0XHR0aGlzLl9yZXNvbHZlRW1wdHkoKTtcblx0XHR0aGlzLl9yZXNvbHZlRW1wdHkgPSAoKSA9PiB7fTtcblxuXHRcdGlmICh0aGlzLl9wZW5kaW5nQ291bnQgPT09IDApIHtcblx0XHRcdHRoaXMuX3Jlc29sdmVJZGxlKCk7XG5cdFx0XHR0aGlzLl9yZXNvbHZlSWRsZSA9ICgpID0+IHt9O1xuXHRcdH1cblx0fVxuXG5cdF9vblJlc3VtZUludGVydmFsKCkge1xuXHRcdHRoaXMuX29uSW50ZXJ2YWwoKTtcblx0XHR0aGlzLl9pbml0aWFsaXplSW50ZXJ2YWxJZk5lZWRlZCgpO1xuXHRcdHRoaXMuX3RpbWVvdXRJZCA9IG51bGw7XG5cdH1cblxuXHRfaW50ZXJ2YWxQYXVzZWQoKSB7XG5cdFx0Y29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuXHRcdGlmICh0aGlzLl9pbnRlcnZhbElkID09PSBudWxsKSB7XG5cdFx0XHRjb25zdCBkZWxheSA9IHRoaXMuX2ludGVydmFsRW5kIC0gbm93O1xuXHRcdFx0aWYgKGRlbGF5IDwgMCkge1xuXHRcdFx0XHQvLyBBY3QgYXMgdGhlIGludGVydmFsIHdhcyBkb25lXG5cdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgdG8gcmVzdW1lIGl0IGhlcmUsXG5cdFx0XHRcdC8vIGJlY2F1c2UgaXQnbGwgYmUgcmVzdW1lZCBvbiBsaW5lIDE2MFxuXHRcdFx0XHR0aGlzLl9pbnRlcnZhbENvdW50ID0gKHRoaXMuX2NhcnJ5b3ZlckNvbmN1cnJlbmN5Q291bnQpID8gdGhpcy5fcGVuZGluZ0NvdW50IDogMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEFjdCBhcyB0aGUgaW50ZXJ2YWwgaXMgcGVuZGluZ1xuXHRcdFx0XHRpZiAodGhpcy5fdGltZW91dElkID09PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLl9vblJlc3VtZUludGVydmFsKCk7XG5cdFx0XHRcdFx0fSwgZGVsYXkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0X3RyeVRvU3RhcnRBbm90aGVyKCkge1xuXHRcdGlmICh0aGlzLnF1ZXVlLnNpemUgPT09IDApIHtcblx0XHRcdC8vIFdlIGNhbiBjbGVhciB0aGUgaW50ZXJ2YWwgKFwicGF1c2VcIilcblx0XHRcdC8vIGJlY2F1c2Ugd2UgY2FuIHJlZG8gaXQgbGF0ZXIgKFwicmVzdW1lXCIpXG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSWQpO1xuXHRcdFx0dGhpcy5faW50ZXJ2YWxJZCA9IG51bGw7XG5cblx0XHRcdHRoaXMuX3Jlc29sdmVQcm9taXNlcygpO1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9pc1BhdXNlZCkge1xuXHRcdFx0Y29uc3QgY2FuSW5pdGlhbGl6ZUludGVydmFsID0gIXRoaXMuX2ludGVydmFsUGF1c2VkKCk7XG5cdFx0XHRpZiAodGhpcy5fZG9lc0ludGVydmFsQWxsb3dBbm90aGVyICYmIHRoaXMuX2RvZXNDb25jdXJyZW50QWxsb3dBbm90aGVyKSB7XG5cdFx0XHRcdHRoaXMuZW1pdCgnYWN0aXZlJyk7XG5cdFx0XHRcdHRoaXMucXVldWUuZGVxdWV1ZSgpKCk7XG5cdFx0XHRcdGlmIChjYW5Jbml0aWFsaXplSW50ZXJ2YWwpIHtcblx0XHRcdFx0XHR0aGlzLl9pbml0aWFsaXplSW50ZXJ2YWxJZk5lZWRlZCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0X2luaXRpYWxpemVJbnRlcnZhbElmTmVlZGVkKCkge1xuXHRcdGlmICh0aGlzLl9pc0ludGVydmFsSWdub3JlZCB8fCB0aGlzLl9pbnRlcnZhbElkICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5faW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX29uSW50ZXJ2YWwoKSwgdGhpcy5faW50ZXJ2YWwpO1xuXHRcdHRoaXMuX2ludGVydmFsRW5kID0gRGF0ZS5ub3coKSArIHRoaXMuX2ludGVydmFsO1xuXHR9XG5cblx0X29uSW50ZXJ2YWwoKSB7XG5cdFx0aWYgKHRoaXMuX2ludGVydmFsQ291bnQgPT09IDAgJiYgdGhpcy5fcGVuZGluZ0NvdW50ID09PSAwKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSWQpO1xuXHRcdFx0dGhpcy5faW50ZXJ2YWxJZCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dGhpcy5faW50ZXJ2YWxDb3VudCA9ICh0aGlzLl9jYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50KSA/IHRoaXMuX3BlbmRpbmdDb3VudCA6IDA7XG5cdFx0d2hpbGUgKHRoaXMuX3RyeVRvU3RhcnRBbm90aGVyKCkpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblx0fVxuXG5cdGFzeW5jIGFkZChmbiwgb3B0aW9ucykge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRjb25zdCBydW4gPSBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuX3BlbmRpbmdDb3VudCsrO1xuXHRcdFx0XHR0aGlzLl9pbnRlcnZhbENvdW50Kys7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXNvbHZlKGF3YWl0IGZuKCkpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9uZXh0KCk7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLnF1ZXVlLmVucXVldWUocnVuLCBvcHRpb25zKTtcblx0XHRcdHRoaXMuX3RyeVRvU3RhcnRBbm90aGVyKCk7XG5cdFx0fSk7XG5cdH1cblxuXHRhc3luYyBhZGRBbGwoZm5zLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKGZucy5tYXAoZm4gPT4gdGhpcy5hZGQoZm4sIG9wdGlvbnMpKSk7XG5cdH1cblxuXHRzdGFydCgpIHtcblx0XHRpZiAoIXRoaXMuX2lzUGF1c2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcblx0XHR3aGlsZSAodGhpcy5fdHJ5VG9TdGFydEFub3RoZXIoKSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuXHR9XG5cblx0cGF1c2UoKSB7XG5cdFx0dGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuXHR9XG5cblx0Y2xlYXIoKSB7XG5cdFx0dGhpcy5xdWV1ZSA9IG5ldyB0aGlzLl9xdWV1ZUNsYXNzKCk7XG5cdH1cblxuXHRhc3luYyBvbkVtcHR5KCkge1xuXHRcdC8vIEluc3RhbnRseSByZXNvbHZlIGlmIHRoZSBxdWV1ZSBpcyBlbXB0eVxuXHRcdGlmICh0aGlzLnF1ZXVlLnNpemUgPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdFx0XHRjb25zdCBleGlzdGluZ1Jlc29sdmUgPSB0aGlzLl9yZXNvbHZlRW1wdHk7XG5cdFx0XHR0aGlzLl9yZXNvbHZlRW1wdHkgPSAoKSA9PiB7XG5cdFx0XHRcdGV4aXN0aW5nUmVzb2x2ZSgpO1xuXHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHR9XG5cblx0YXN5bmMgb25JZGxlKCkge1xuXHRcdC8vIEluc3RhbnRseSByZXNvbHZlIGlmIG5vbmUgcGVuZGluZyBhbmQgaWYgbm90aGluZyBlbHNlIGlzIHF1ZXVlZFxuXHRcdGlmICh0aGlzLl9wZW5kaW5nQ291bnQgPT09IDAgJiYgdGhpcy5xdWV1ZS5zaXplID09PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRcdFx0Y29uc3QgZXhpc3RpbmdSZXNvbHZlID0gdGhpcy5fcmVzb2x2ZUlkbGU7XG5cdFx0XHR0aGlzLl9yZXNvbHZlSWRsZSA9ICgpID0+IHtcblx0XHRcdFx0ZXhpc3RpbmdSZXNvbHZlKCk7XG5cdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cdH1cblxuXHRnZXQgc2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZS5zaXplO1xuXHR9XG5cblx0Z2V0IHBlbmRpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDtcblx0fVxuXG5cdGdldCBpc1BhdXNlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5faXNQYXVzZWQ7XG5cdH1cbn07XG4iLCIvKlxuaW5kZXguanMgLSBLYWRlbWxpYSBESFQgSy1idWNrZXQgaW1wbGVtZW50YXRpb24gYXMgYSBiaW5hcnkgdHJlZS5cblxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbkNvcHlyaWdodCAoYykgMjAxMy0yMDE4IFRyaXN0YW4gU2xvbWluc2tpXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG5vYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG5yZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbmNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcblNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG5jb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbk9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG5XSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbkZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1Jcbk9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpXG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJylcblxuLyoqXG4gKiBAcGFyYW0gIHtVaW50OEFycmF5fSBhcnJheTFcbiAqIEBwYXJhbSAge1VpbnQ4QXJyYXl9IGFycmF5MlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYXJyYXlFcXVhbHMgKGFycmF5MSwgYXJyYXkyKSB7XG4gIGlmIChhcnJheTEgPT09IGFycmF5Mikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGFycmF5MS5sZW5ndGggIT09IGFycmF5Mi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gYXJyYXkxLmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZSAoKSB7XG4gIHJldHVybiB7IGNvbnRhY3RzOiBbXSwgZG9udFNwbGl0OiBmYWxzZSwgbGVmdDogbnVsbCwgcmlnaHQ6IG51bGwgfVxufVxuXG5mdW5jdGlvbiBlbnN1cmVJbnQ4IChuYW1lLCB2YWwpIHtcbiAgaWYgKCEodmFsIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG5hbWUgKyAnIGlzIG5vdCBhIFVpbnQ4QXJyYXknKVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgYSBLYWRlbWxpYSBESFQgay1idWNrZXQgdXNlZCBmb3Igc3RvcmluZ1xuICogY29udGFjdCAocGVlciBub2RlKSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgS0J1Y2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBgb3B0aW9uc2A6XG4gICAqICAgYGRpc3RhbmNlYDogX0Z1bmN0aW9uX1xuICAgKiAgICAgYGZ1bmN0aW9uIChmaXJzdElkLCBzZWNvbmRJZCkgeyByZXR1cm4gZGlzdGFuY2UgfWAgQW4gb3B0aW9uYWxcbiAgICogICAgIGBkaXN0YW5jZWAgZnVuY3Rpb24gdGhhdCBnZXRzIHR3byBgaWRgIFVpbnQ4QXJyYXlzXG4gICAqICAgICBhbmQgcmV0dXJuIGRpc3RhbmNlIChhcyBudW1iZXIpIGJldHdlZW4gdGhlbS5cbiAgICogICBgYXJiaXRlcmA6IF9GdW5jdGlvbl8gXyhEZWZhdWx0OiB2ZWN0b3JDbG9jayBhcmJpdGVyKV9cbiAgICogICAgIGBmdW5jdGlvbiAoaW5jdW1iZW50LCBjYW5kaWRhdGUpIHsgcmV0dXJuIGNvbnRhY3Q7IH1gIEFuIG9wdGlvbmFsXG4gICAqICAgICBgYXJiaXRlcmAgZnVuY3Rpb24gdGhhdCBnaXZlbnQgdHdvIGBjb250YWN0YCBvYmplY3RzIHdpdGggdGhlIHNhbWUgYGlkYFxuICAgKiAgICAgcmV0dXJucyB0aGUgZGVzaXJlZCBvYmplY3QgdG8gYmUgdXNlZCBmb3IgdXBkYXRpbmcgdGhlIGstYnVja2V0LiBGb3JcbiAgICogICAgIG1vcmUgZGV0YWlscywgc2VlIFthcmJpdGVyIGZ1bmN0aW9uXSgjYXJiaXRlci1mdW5jdGlvbikuXG4gICAqICAgYGxvY2FsTm9kZUlkYDogX1VpbnQ4QXJyYXlfIEFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBub2RlIGlkLlxuICAgKiAgICAgSWYgbm90IHByb3ZpZGVkLCBhIGxvY2FsIG5vZGUgaWQgd2lsbCBiZSBjcmVhdGVkIHZpYSBgcmFuZG9tQnl0ZXMoMjApYC5cbiAgICogICAgIGBtZXRhZGF0YWA6IF9PYmplY3RfIF8oRGVmYXVsdDoge30pXyBPcHRpb25hbCBzYXRlbGxpdGUgZGF0YSB0byBpbmNsdWRlXG4gICAqICAgICB3aXRoIHRoZSBrLWJ1Y2tldC4gYG1ldGFkYXRhYCBwcm9wZXJ0eSBpcyBndWFyYW50ZWVkIG5vdCBiZSBhbHRlcmVkIGJ5LFxuICAgKiAgICAgaXQgaXMgcHJvdmlkZWQgYXMgYW4gZXhwbGljaXQgY29udGFpbmVyIGZvciB1c2VycyBvZiBrLWJ1Y2tldCB0byBzdG9yZVxuICAgKiAgICAgaW1wbGVtZW50YXRpb24tc3BlY2lmaWMgZGF0YS5cbiAgICogICBgbnVtYmVyT2ZOb2Rlc1BlcktCdWNrZXRgOiBfSW50ZWdlcl8gXyhEZWZhdWx0OiAyMClfIFRoZSBudW1iZXIgb2Ygbm9kZXNcbiAgICogICAgIHRoYXQgYSBrLWJ1Y2tldCBjYW4gY29udGFpbiBiZWZvcmUgYmVpbmcgZnVsbCBvciBzcGxpdC5cbiAgICogICAgIGBudW1iZXJPZk5vZGVzVG9QaW5nYDogX0ludGVnZXJfIF8oRGVmYXVsdDogMylfIFRoZSBudW1iZXIgb2Ygbm9kZXMgdG9cbiAgICogICAgIHBpbmcgd2hlbiBhIGJ1Y2tldCB0aGF0IHNob3VsZCBub3QgYmUgc3BsaXQgYmVjb21lcyBmdWxsLiBLQnVja2V0IHdpbGxcbiAgICogICAgIGVtaXQgYSBgcGluZ2AgZXZlbnQgdGhhdCBjb250YWlucyBgbnVtYmVyT2ZOb2Rlc1RvUGluZ2Agbm9kZXMgdGhhdCBoYXZlXG4gICAqICAgICBub3QgYmVlbiBjb250YWN0ZWQgdGhlIGxvbmdlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBvcHRpb25hbFxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMubG9jYWxOb2RlSWQgPSBvcHRpb25zLmxvY2FsTm9kZUlkIHx8IHJhbmRvbUJ5dGVzKDIwKVxuICAgIHRoaXMubnVtYmVyT2ZOb2Rlc1BlcktCdWNrZXQgPSBvcHRpb25zLm51bWJlck9mTm9kZXNQZXJLQnVja2V0IHx8IDIwXG4gICAgdGhpcy5udW1iZXJPZk5vZGVzVG9QaW5nID0gb3B0aW9ucy5udW1iZXJPZk5vZGVzVG9QaW5nIHx8IDNcbiAgICB0aGlzLmRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZSB8fCBLQnVja2V0LmRpc3RhbmNlXG4gICAgLy8gdXNlIGFuIGFyYml0ZXIgZnJvbSBvcHRpb25zIG9yIHZlY3RvckNsb2NrIGFyYml0ZXIgYnkgZGVmYXVsdFxuICAgIHRoaXMuYXJiaXRlciA9IG9wdGlvbnMuYXJiaXRlciB8fCBLQnVja2V0LmFyYml0ZXJcbiAgICB0aGlzLm1ldGFkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5tZXRhZGF0YSlcblxuICAgIGVuc3VyZUludDgoJ29wdGlvbi5sb2NhbE5vZGVJZCBhcyBwYXJhbWV0ZXIgMScsIHRoaXMubG9jYWxOb2RlSWQpXG5cbiAgICB0aGlzLnJvb3QgPSBjcmVhdGVOb2RlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGFyYml0ZXIgZnVuY3Rpb24gZm9yIGNvbnRhY3RzIHdpdGggdGhlIHNhbWUgaWQuIFVzZXNcbiAgICogY29udGFjdC52ZWN0b3JDbG9jayB0byBzZWxlY3Qgd2hpY2ggY29udGFjdCB0byB1cGRhdGUgdGhlIGstYnVja2V0IHdpdGguXG4gICAqIENvbnRhY3Qgd2l0aCBsYXJnZXIgdmVjdG9yQ2xvY2sgZmllbGQgd2lsbCBiZSBzZWxlY3RlZC4gSWYgdmVjdG9yQ2xvY2sgaXNcbiAgICogdGhlIHNhbWUsIGNhbmRpZGF0IHdpbGwgYmUgc2VsZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gaW5jdW1iZW50IENvbnRhY3QgY3VycmVudGx5IHN0b3JlZCBpbiB0aGUgay1idWNrZXQuXG4gICAqIEBwYXJhbSAge09iamVjdH0gY2FuZGlkYXRlIENvbnRhY3QgYmVpbmcgYWRkZWQgdG8gdGhlIGstYnVja2V0LlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICBDb250YWN0IHRvIHVwZGF0ZWQgdGhlIGstYnVja2V0IHdpdGguXG4gICAqL1xuICBzdGF0aWMgYXJiaXRlciAoaW5jdW1iZW50LCBjYW5kaWRhdGUpIHtcbiAgICByZXR1cm4gaW5jdW1iZW50LnZlY3RvckNsb2NrID4gY2FuZGlkYXRlLnZlY3RvckNsb2NrID8gaW5jdW1iZW50IDogY2FuZGlkYXRlXG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBkaXN0YW5jZSBmdW5jdGlvbi4gRmluZHMgdGhlIFhPUlxuICAgKiBkaXN0YW5jZSBiZXR3ZWVuIGZpcnN0SWQgYW5kIHNlY29uZElkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtVaW50OEFycmF5fSBmaXJzdElkICBVaW50OEFycmF5IGNvbnRhaW5pbmcgZmlyc3QgaWQuXG4gICAqIEBwYXJhbSAge1VpbnQ4QXJyYXl9IHNlY29uZElkIFVpbnQ4QXJyYXkgY29udGFpbmluZyBzZWNvbmQgaWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgIEludGVnZXIgVGhlIFhPUiBkaXN0YW5jZSBiZXR3ZWVuIGZpcnN0SWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHNlY29uZElkLlxuICAgKi9cbiAgc3RhdGljIGRpc3RhbmNlIChmaXJzdElkLCBzZWNvbmRJZCkge1xuICAgIGxldCBkaXN0YW5jZSA9IDBcbiAgICBsZXQgaSA9IDBcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihmaXJzdElkLmxlbmd0aCwgc2Vjb25kSWQubGVuZ3RoKVxuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGZpcnN0SWQubGVuZ3RoLCBzZWNvbmRJZC5sZW5ndGgpXG4gICAgZm9yICg7IGkgPCBtaW47ICsraSkge1xuICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZSAqIDI1NiArIChmaXJzdElkW2ldIF4gc2Vjb25kSWRbaV0pXG4gICAgfVxuICAgIGZvciAoOyBpIDwgbWF4OyArK2kpIGRpc3RhbmNlID0gZGlzdGFuY2UgKiAyNTYgKyAyNTVcbiAgICByZXR1cm4gZGlzdGFuY2VcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY29udGFjdCB0byB0aGUgay1idWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWN0IHRoZSBjb250YWN0IG9iamVjdCB0byBhZGRcbiAgICovXG4gIGFkZCAoY29udGFjdCkge1xuICAgIGVuc3VyZUludDgoJ2NvbnRhY3QuaWQnLCAoY29udGFjdCB8fCB7fSkuaWQpXG5cbiAgICBsZXQgYml0SW5kZXggPSAwXG4gICAgbGV0IG5vZGUgPSB0aGlzLnJvb3RcblxuICAgIHdoaWxlIChub2RlLmNvbnRhY3RzID09PSBudWxsKSB7XG4gICAgICAvLyB0aGlzIGlzIG5vdCBhIGxlYWYgbm9kZSBidXQgYW4gaW5uZXIgbm9kZSB3aXRoICdsb3cnIGFuZCAnaGlnaCdcbiAgICAgIC8vIGJyYW5jaGVzOyB3ZSB3aWxsIGNoZWNrIHRoZSBhcHByb3ByaWF0ZSBiaXQgb2YgdGhlIGlkZW50aWZpZXIgYW5kXG4gICAgICAvLyBkZWxlZ2F0ZSB0byB0aGUgYXBwcm9wcmlhdGUgbm9kZSBmb3IgZnVydGhlciBwcm9jZXNzaW5nXG4gICAgICBub2RlID0gdGhpcy5fZGV0ZXJtaW5lTm9kZShub2RlLCBjb250YWN0LmlkLCBiaXRJbmRleCsrKVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHRoZSBjb250YWN0IGFscmVhZHkgZXhpc3RzXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9pbmRleE9mKG5vZGUsIGNvbnRhY3QuaWQpXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShub2RlLCBpbmRleCwgY29udGFjdClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgaWYgKG5vZGUuY29udGFjdHMubGVuZ3RoIDwgdGhpcy5udW1iZXJPZk5vZGVzUGVyS0J1Y2tldCkge1xuICAgICAgbm9kZS5jb250YWN0cy5wdXNoKGNvbnRhY3QpXG4gICAgICB0aGlzLmVtaXQoJ2FkZGVkJywgY29udGFjdClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gdGhlIGJ1Y2tldCBpcyBmdWxsXG4gICAgaWYgKG5vZGUuZG9udFNwbGl0KSB7XG4gICAgICAvLyB3ZSBhcmUgbm90IGFsbG93ZWQgdG8gc3BsaXQgdGhlIGJ1Y2tldFxuICAgICAgLy8gd2UgbmVlZCB0byBwaW5nIHRoZSBmaXJzdCB0aGlzLm51bWJlck9mTm9kZXNUb1BpbmdcbiAgICAgIC8vIGluIG9yZGVyIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBhbGl2ZVxuICAgICAgLy8gb25seSBpZiBvbmUgb2YgdGhlIHBpbmdlZCBub2RlcyBkb2VzIG5vdCByZXNwb25kLCBjYW4gdGhlIG5ldyBjb250YWN0XG4gICAgICAvLyBiZSBhZGRlZCAodGhpcyBwcmV2ZW50cyBEb1MgZmxvZGRpbmcgd2l0aCBuZXcgaW52YWxpZCBjb250YWN0cylcbiAgICAgIHRoaXMuZW1pdCgncGluZycsIG5vZGUuY29udGFjdHMuc2xpY2UoMCwgdGhpcy5udW1iZXJPZk5vZGVzVG9QaW5nKSwgY29udGFjdClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdGhpcy5fc3BsaXQobm9kZSwgYml0SW5kZXgpXG4gICAgcmV0dXJuIHRoaXMuYWRkKGNvbnRhY3QpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuIGNsb3Nlc3QgY29udGFjdHMgdG8gdGhlIHByb3ZpZGVkIG5vZGUgaWQuIFwiQ2xvc2VzdFwiIGhlcmUgbWVhbnM6XG4gICAqIGNsb3Nlc3QgYWNjb3JkaW5nIHRvIHRoZSBYT1IgbWV0cmljIG9mIHRoZSBjb250YWN0IG5vZGUgaWQuXG4gICAqXG4gICAqIEBwYXJhbSAge1VpbnQ4QXJyYXl9IGlkICBDb250YWN0IG5vZGUgaWRcbiAgICogQHBhcmFtICB7TnVtYmVyPX0gbiAgICAgIEludGVnZXIgKERlZmF1bHQ6IEluZmluaXR5KSBUaGUgbWF4aW11bSBudW1iZXIgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3QgY29udGFjdHMgdG8gcmV0dXJuXG4gICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICBBcnJheSBNYXhpbXVtIG9mIG4gY2xvc2VzdCBjb250YWN0cyB0byB0aGUgbm9kZSBpZFxuICAgKi9cbiAgY2xvc2VzdCAoaWQsIG4gPSBJbmZpbml0eSkge1xuICAgIGVuc3VyZUludDgoJ2lkJywgaWQpXG5cbiAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKG4pICYmIG4gIT09IEluZmluaXR5KSB8fCBuIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ24gaXMgbm90IHBvc2l0aXZlIG51bWJlcicpXG4gICAgfVxuXG4gICAgbGV0IGNvbnRhY3RzID0gW11cblxuICAgIGZvciAobGV0IG5vZGVzID0gWyB0aGlzLnJvb3QgXSwgYml0SW5kZXggPSAwOyBub2Rlcy5sZW5ndGggPiAwICYmIGNvbnRhY3RzLmxlbmd0aCA8IG47KSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXMucG9wKClcbiAgICAgIGlmIChub2RlLmNvbnRhY3RzID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRldE5vZGUgPSB0aGlzLl9kZXRlcm1pbmVOb2RlKG5vZGUsIGlkLCBiaXRJbmRleCsrKVxuICAgICAgICBub2Rlcy5wdXNoKG5vZGUubGVmdCA9PT0gZGV0Tm9kZSA/IG5vZGUucmlnaHQgOiBub2RlLmxlZnQpXG4gICAgICAgIG5vZGVzLnB1c2goZGV0Tm9kZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhY3RzID0gY29udGFjdHMuY29uY2F0KG5vZGUuY29udGFjdHMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhY3RzXG4gICAgICAubWFwKGEgPT4gW3RoaXMuZGlzdGFuY2UoYS5pZCwgaWQpLCBhXSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSlcbiAgICAgIC5zbGljZSgwLCBuKVxuICAgICAgLm1hcChhID0+IGFbMV0pXG4gIH1cblxuICAvKipcbiAgICogQ291bnRzIHRoZSB0b3RhbCBudW1iZXIgb2YgY29udGFjdHMgaW4gdGhlIHRyZWUuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG51bWJlciBvZiBjb250YWN0cyBoZWxkIGluIHRoZSB0cmVlXG4gICAqL1xuICBjb3VudCAoKSB7XG4gICAgLy8gcmV0dXJuIHRoaXMudG9BcnJheSgpLmxlbmd0aFxuICAgIGxldCBjb3VudCA9IDBcbiAgICBmb3IgKGNvbnN0IG5vZGVzID0gWyB0aGlzLnJvb3QgXTsgbm9kZXMubGVuZ3RoID4gMDspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlcy5wb3AoKVxuICAgICAgaWYgKG5vZGUuY29udGFjdHMgPT09IG51bGwpIG5vZGVzLnB1c2gobm9kZS5yaWdodCwgbm9kZS5sZWZ0KVxuICAgICAgZWxzZSBjb3VudCArPSBub2RlLmNvbnRhY3RzLmxlbmd0aFxuICAgIH1cbiAgICByZXR1cm4gY291bnRcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGlkIGF0IHRoZSBiaXRJbmRleCBpcyAwIG9yIDEuXG4gICAqIFJldHVybiBsZWZ0IGxlYWYgaWYgYGlkYCBhdCBgYml0SW5kZXhgIGlzIDAsIHJpZ2h0IGxlYWYgb3RoZXJ3aXNlXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSAgICAgaW50ZXJuYWwgb2JqZWN0IHRoYXQgaGFzIDIgbGVhZnM6IGxlZnQgYW5kIHJpZ2h0XG4gICAqIEBwYXJhbSAge1VpbnQ4QXJyYXl9IGlkICAgSWQgdG8gY29tcGFyZSBsb2NhbE5vZGVJZCB3aXRoLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGJpdEluZGV4IEludGVnZXIgKERlZmF1bHQ6IDApIFRoZSBiaXQgaW5kZXggdG8gd2hpY2ggYml0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gY2hlY2sgaW4gdGhlIGlkIFVpbnQ4QXJyYXkuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgbGVmdCBsZWFmIGlmIGlkIGF0IGJpdEluZGV4IGlzIDAsIHJpZ2h0IGxlYWYgb3RoZXJ3aXNlLlxuICAgKi9cbiAgX2RldGVybWluZU5vZGUgKG5vZGUsIGlkLCBiaXRJbmRleCkge1xuICAgIC8vICoqTk9URSoqIHJlbWVtYmVyIHRoYXQgaWQgaXMgYSBVaW50OEFycmF5IGFuZCBoYXMgZ3JhbnVsYXJpdHkgb2ZcbiAgICAvLyBieXRlcyAoOCBiaXRzKSwgd2hlcmVhcyB0aGUgYml0SW5kZXggaXMgdGhlIF9iaXRfIGluZGV4IChub3QgYnl0ZSlcblxuICAgIC8vIGlkJ3MgdGhhdCBhcmUgdG9vIHNob3J0IGFyZSBwdXQgaW4gbG93IGJ1Y2tldCAoMSBieXRlID0gOCBiaXRzKVxuICAgIC8vIChiaXRJbmRleCA+PiAzKSBmaW5kcyBob3cgbWFueSBieXRlcyB0aGUgYml0SW5kZXggZGVzY3JpYmVzXG4gICAgLy8gYml0SW5kZXggJSA4IGNoZWNrcyBpZiB3ZSBoYXZlIGV4dHJhIGJpdHMgYmV5b25kIGJ5dGUgbXVsdGlwbGVzXG4gICAgLy8gaWYgbnVtYmVyIG9mIGJ5dGVzIGlzIDw9IG5vLiBvZiBieXRlcyBkZXNjcmliZWQgYnkgYml0SW5kZXggYW5kIHRoZXJlXG4gICAgLy8gYXJlIGV4dHJhIGJpdHMgdG8gY29uc2lkZXIsIHRoaXMgbWVhbnMgaWQgaGFzIGxlc3MgYml0cyB0aGFuIHdoYXRcbiAgICAvLyBiaXRJbmRleCBkZXNjcmliZXMsIGlkIHRoZXJlZm9yZSBpcyB0b28gc2hvcnQsIGFuZCB3aWxsIGJlIHB1dCBpbiBsb3dcbiAgICAvLyBidWNrZXRcbiAgICBjb25zdCBieXRlc0Rlc2NyaWJlZEJ5Qml0SW5kZXggPSBiaXRJbmRleCA+PiAzXG4gICAgY29uc3QgYml0SW5kZXhXaXRoaW5CeXRlID0gYml0SW5kZXggJSA4XG4gICAgaWYgKChpZC5sZW5ndGggPD0gYnl0ZXNEZXNjcmliZWRCeUJpdEluZGV4KSAmJiAoYml0SW5kZXhXaXRoaW5CeXRlICE9PSAwKSkge1xuICAgICAgcmV0dXJuIG5vZGUubGVmdFxuICAgIH1cblxuICAgIGNvbnN0IGJ5dGVVbmRlckNvbnNpZGVyYXRpb24gPSBpZFtieXRlc0Rlc2NyaWJlZEJ5Qml0SW5kZXhdXG5cbiAgICAvLyBieXRlVW5kZXJDb25zaWRlcmF0aW9uIGlzIGFuIGludGVnZXIgZnJvbSAwIHRvIDI1NSByZXByZXNlbnRlZCBieSA4IGJpdHNcbiAgICAvLyB3aGVyZSAyNTUgaXMgMTExMTExMTEgYW5kIDAgaXMgMDAwMDAwMDBcbiAgICAvLyBpbiBvcmRlciB0byBmaW5kIG91dCB3aGV0aGVyIHRoZSBiaXQgYXQgYml0SW5kZXhXaXRoaW5CeXRlIGlzIHNldFxuICAgIC8vIHdlIGNvbnN0cnVjdCAoMSA8PCAoNyAtIGJpdEluZGV4V2l0aGluQnl0ZSkpIHdoaWNoIHdpbGwgY29uc2lzdFxuICAgIC8vIG9mIGFsbCBiaXRzIGJlaW5nIDAsIHdpdGggb25seSBvbmUgYml0IHNldCB0byAxXG4gICAgLy8gZm9yIGV4YW1wbGUsIGlmIGJpdEluZGV4V2l0aGluQnl0ZSBpcyAzLCB3ZSB3aWxsIGNvbnN0cnVjdCAwMDAxMDAwMCBieVxuICAgIC8vICgxIDw8ICg3IC0gMykpIC0+ICgxIDw8IDQpIC0+IDE2XG4gICAgaWYgKGJ5dGVVbmRlckNvbnNpZGVyYXRpb24gJiAoMSA8PCAoNyAtIGJpdEluZGV4V2l0aGluQnl0ZSkpKSB7XG4gICAgICByZXR1cm4gbm9kZS5yaWdodFxuICAgIH1cblxuICAgIHJldHVybiBub2RlLmxlZnRcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBjb250YWN0IGJ5IGl0cyBleGFjdCBJRC5cbiAgICogSWYgdGhpcyBpcyBhIGxlYWYsIGxvb3AgdGhyb3VnaCB0aGUgYnVja2V0IGNvbnRlbnRzIGFuZCByZXR1cm4gdGhlIGNvcnJlY3RcbiAgICogY29udGFjdCBpZiB3ZSBoYXZlIGl0IG9yIG51bGwgaWYgbm90LiBJZiB0aGlzIGlzIGFuIGlubmVyIG5vZGUsIGRldGVybWluZVxuICAgKiB3aGljaCBicmFuY2ggb2YgdGhlIHRyZWUgdG8gdHJhdmVyc2UgYW5kIHJlcGVhdC5cbiAgICpcbiAgICogQHBhcmFtICB7VWludDhBcnJheX0gaWQgVGhlIElEIG9mIHRoZSBjb250YWN0IHRvIGZldGNoLlxuICAgKiBAcmV0dXJuIHtPYmplY3R8TnVsbH0gICBUaGUgY29udGFjdCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBudWxsXG4gICAqL1xuICBnZXQgKGlkKSB7XG4gICAgZW5zdXJlSW50OCgnaWQnLCBpZClcblxuICAgIGxldCBiaXRJbmRleCA9IDBcblxuICAgIGxldCBub2RlID0gdGhpcy5yb290XG4gICAgd2hpbGUgKG5vZGUuY29udGFjdHMgPT09IG51bGwpIHtcbiAgICAgIG5vZGUgPSB0aGlzLl9kZXRlcm1pbmVOb2RlKG5vZGUsIGlkLCBiaXRJbmRleCsrKVxuICAgIH1cblxuICAgIC8vIGluZGV4IG9mIHVzZXMgY29udGFjdCBpZCBmb3IgbWF0Y2hpbmdcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2luZGV4T2Yobm9kZSwgaWQpXG4gICAgcmV0dXJuIGluZGV4ID49IDAgPyBub2RlLmNvbnRhY3RzW2luZGV4XSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY29udGFjdCB3aXRoIHByb3ZpZGVkXG4gICAqIGlkIGlmIGl0IGV4aXN0cywgcmV0dXJucyAtMSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSAgICBpbnRlcm5hbCBvYmplY3QgdGhhdCBoYXMgMiBsZWFmczogbGVmdCBhbmQgcmlnaHRcbiAgICogQHBhcmFtICB7VWludDhBcnJheX0gaWQgIENvbnRhY3Qgbm9kZSBpZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgIEludGVnZXIgSW5kZXggb2YgY29udGFjdCB3aXRoIHByb3ZpZGVkIGlkIGlmIGl0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdHMsIC0xIG90aGVyd2lzZS5cbiAgICovXG4gIF9pbmRleE9mIChub2RlLCBpZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jb250YWN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGFycmF5RXF1YWxzKG5vZGUuY29udGFjdHNbaV0uaWQsIGlkKSkgcmV0dXJuIGlcbiAgICB9XG5cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGNvbnRhY3Qgd2l0aCB0aGUgcHJvdmlkZWQgaWQuXG4gICAqXG4gICAqIEBwYXJhbSAge1VpbnQ4QXJyYXl9IGlkIFRoZSBJRCBvZiB0aGUgY29udGFjdCB0byByZW1vdmUuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgIFRoZSBrLWJ1Y2tldCBpdHNlbGYuXG4gICAqL1xuICByZW1vdmUgKGlkKSB7XG4gICAgZW5zdXJlSW50OCgndGhlIGlkIGFzIHBhcmFtZXRlciAxJywgaWQpXG5cbiAgICBsZXQgYml0SW5kZXggPSAwXG4gICAgbGV0IG5vZGUgPSB0aGlzLnJvb3RcblxuICAgIHdoaWxlIChub2RlLmNvbnRhY3RzID09PSBudWxsKSB7XG4gICAgICBub2RlID0gdGhpcy5fZGV0ZXJtaW5lTm9kZShub2RlLCBpZCwgYml0SW5kZXgrKylcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2luZGV4T2Yobm9kZSwgaWQpXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IGNvbnRhY3QgPSBub2RlLmNvbnRhY3RzLnNwbGljZShpbmRleCwgMSlbMF1cbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlZCcsIGNvbnRhY3QpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgdGhlIG5vZGUsIHJlZGlzdHJpYnV0ZXMgY29udGFjdHMgdG8gdGhlIG5ldyBub2RlcywgYW5kIG1hcmtzIHRoZVxuICAgKiBub2RlIHRoYXQgd2FzIHNwbGl0IGFzIGFuIGlubmVyIG5vZGUgb2YgdGhlIGJpbmFyeSB0cmVlIG9mIG5vZGVzIGJ5XG4gICAqIHNldHRpbmcgdGhpcy5yb290LmNvbnRhY3RzID0gbnVsbFxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5vZGUgICAgIG5vZGUgZm9yIHNwbGl0dGluZ1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGJpdEluZGV4IHRoZSBiaXRJbmRleCB0byB3aGljaCBieXRlIHRvIGNoZWNrIGluIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFVpbnQ4QXJyYXkgZm9yIG5hdmlnYXRpbmcgdGhlIGJpbmFyeSB0cmVlXG4gICAqL1xuICBfc3BsaXQgKG5vZGUsIGJpdEluZGV4KSB7XG4gICAgbm9kZS5sZWZ0ID0gY3JlYXRlTm9kZSgpXG4gICAgbm9kZS5yaWdodCA9IGNyZWF0ZU5vZGUoKVxuXG4gICAgLy8gcmVkaXN0cmlidXRlIGV4aXN0aW5nIGNvbnRhY3RzIGFtb25nc3QgdGhlIHR3byBuZXdseSBjcmVhdGVkIG5vZGVzXG4gICAgZm9yIChjb25zdCBjb250YWN0IG9mIG5vZGUuY29udGFjdHMpIHtcbiAgICAgIHRoaXMuX2RldGVybWluZU5vZGUobm9kZSwgY29udGFjdC5pZCwgYml0SW5kZXgpLmNvbnRhY3RzLnB1c2goY29udGFjdClcbiAgICB9XG5cbiAgICBub2RlLmNvbnRhY3RzID0gbnVsbCAvLyBtYXJrIGFzIGlubmVyIHRyZWUgbm9kZVxuXG4gICAgLy8gZG9uJ3Qgc3BsaXQgdGhlIFwiZmFyIGF3YXlcIiBub2RlXG4gICAgLy8gd2UgY2hlY2sgd2hlcmUgdGhlIGxvY2FsIG5vZGUgd291bGQgZW5kIHVwIGFuZCBtYXJrIHRoZSBvdGhlciBvbmUgYXNcbiAgICAvLyBcImRvbnRTcGxpdFwiIChpLmUuIFwiZmFyIGF3YXlcIilcbiAgICBjb25zdCBkZXROb2RlID0gdGhpcy5fZGV0ZXJtaW5lTm9kZShub2RlLCB0aGlzLmxvY2FsTm9kZUlkLCBiaXRJbmRleClcbiAgICBjb25zdCBvdGhlck5vZGUgPSBub2RlLmxlZnQgPT09IGRldE5vZGUgPyBub2RlLnJpZ2h0IDogbm9kZS5sZWZ0XG4gICAgb3RoZXJOb2RlLmRvbnRTcGxpdCA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCB0aGUgY29udGFjdHMgY29udGFpbmVkIGluIHRoZSB0cmVlIGFzIGFuIGFycmF5LlxuICAgKiBJZiB0aGlzIGlzIGEgbGVhZiwgcmV0dXJuIGEgY29weSBvZiB0aGUgYnVja2V0LiBgc2xpY2VgIGlzIHVzZWQgc28gdGhhdCB3ZVxuICAgKiBkb24ndCBhY2NpZGVudGFsbHkgbGVhayBhbiBpbnRlcm5hbCByZWZlcmVuY2Ugb3V0IHRoYXQgbWlnaHQgYmVcbiAgICogYWNjaWRlbnRhbGx5IG1pc3VzZWQuIElmIHRoaXMgaXMgbm90IGEgbGVhZiwgcmV0dXJuIHRoZSB1bmlvbiBvZiB0aGUgbG93XG4gICAqIGFuZCBoaWdoIGJyYW5jaGVzICh0aGVtc2VsdmVzIGFsc28gYXMgYXJyYXlzKS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFsbCBvZiB0aGUgY29udGFjdHMgaW4gdGhlIHRyZWUsIGFzIGFuIGFycmF5XG4gICAqL1xuICB0b0FycmF5ICgpIHtcbiAgICBsZXQgcmVzdWx0ID0gW11cbiAgICBmb3IgKGNvbnN0IG5vZGVzID0gWyB0aGlzLnJvb3QgXTsgbm9kZXMubGVuZ3RoID4gMDspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlcy5wb3AoKVxuICAgICAgaWYgKG5vZGUuY29udGFjdHMgPT09IG51bGwpIG5vZGVzLnB1c2gobm9kZS5yaWdodCwgbm9kZS5sZWZ0KVxuICAgICAgZWxzZSByZXN1bHQgPSByZXN1bHQuY29uY2F0KG5vZGUuY29udGFjdHMpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb250YWN0IHNlbGVjdGVkIGJ5IHRoZSBhcmJpdGVyLlxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIG91ciBvbGQgY29udGFjdCBhbmQgdGhlIGNhbmRpZGF0ZSBpcyBzb21lIG5ldyBjb250YWN0XG4gICAqIHRoZW4gdGhlIG5ldyBjb250YWN0IGlzIGFiYW5kb25lZCAobm90IGFkZGVkKS5cbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBvdXIgb2xkIGNvbnRhY3QgYW5kIHRoZSBjYW5kaWRhdGUgaXMgb3VyIG9sZCBjb250YWN0XG4gICAqIHRoZW4gd2UgYXJlIHJlZnJlc2hpbmcgdGhlIGNvbnRhY3QgYW5kIGl0IGlzIG1hcmtlZCBhcyBtb3N0IHJlY2VudGx5XG4gICAqIGNvbnRhY3RlZCAoYnkgYmVpbmcgbW92ZWQgdG8gdGhlIHJpZ2h0L2VuZCBvZiB0aGUgYnVja2V0IGFycmF5KS5cbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBvdXIgbmV3IGNvbnRhY3QsIHRoZSBvbGQgY29udGFjdCBpcyByZW1vdmVkIGFuZCB0aGUgbmV3XG4gICAqIGNvbnRhY3QgaXMgbWFya2VkIGFzIG1vc3QgcmVjZW50bHkgY29udGFjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5vZGUgICAgaW50ZXJuYWwgb2JqZWN0IHRoYXQgaGFzIDIgbGVhZnM6IGxlZnQgYW5kIHJpZ2h0XG4gICAqIEBwYXJhbSAge051bWJlcn0gaW5kZXggICB0aGUgaW5kZXggaW4gdGhlIGJ1Y2tldCB3aGVyZSBjb250YWN0IGV4aXN0c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgKGluZGV4IGhhcyBhbHJlYWR5IGJlZW4gY29tcHV0ZWQgaW4gYSBwcmV2aW91c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRpb24pXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29udGFjdCBUaGUgY29udGFjdCBvYmplY3QgdG8gdXBkYXRlLlxuICAgKi9cbiAgX3VwZGF0ZSAobm9kZSwgaW5kZXgsIGNvbnRhY3QpIHtcbiAgICAvLyBzYW5pdHkgY2hlY2tcbiAgICBpZiAoIWFycmF5RXF1YWxzKG5vZGUuY29udGFjdHNbaW5kZXhdLmlkLCBjb250YWN0LmlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBpbmRleCBmb3IgX3VwZGF0ZScpXG4gICAgfVxuXG4gICAgY29uc3QgaW5jdW1iZW50ID0gbm9kZS5jb250YWN0c1tpbmRleF1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLmFyYml0ZXIoaW5jdW1iZW50LCBjb250YWN0KVxuICAgIC8vIGlmIHRoZSBzZWxlY3Rpb24gaXMgb3VyIG9sZCBjb250YWN0IGFuZCB0aGUgY2FuZGlkYXRlIGlzIHNvbWUgbmV3XG4gICAgLy8gY29udGFjdCwgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvXG4gICAgaWYgKHNlbGVjdGlvbiA9PT0gaW5jdW1iZW50ICYmIGluY3VtYmVudCAhPT0gY29udGFjdCkgcmV0dXJuXG5cbiAgICBub2RlLmNvbnRhY3RzLnNwbGljZShpbmRleCwgMSkgLy8gcmVtb3ZlIG9sZCBjb250YWN0XG4gICAgbm9kZS5jb250YWN0cy5wdXNoKHNlbGVjdGlvbikgLy8gYWRkIG1vcmUgcmVjZW50IGNvbnRhY3QgdmVyc2lvblxuICAgIHRoaXMuZW1pdCgndXBkYXRlZCcsIGluY3VtYmVudCwgc2VsZWN0aW9uKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gS0J1Y2tldFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG11bHRpaGFzaCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJy4vY3J5cHRvJylcblxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aWhhc2hpbmdcblxuLyoqXG4gKiBIYXNoIHRoZSBnaXZlbiBgYnVmYCB1c2luZyB0aGUgYWxnb3JpdGhtIHNwZWNpZmllZFxuICogYnkgYGZ1bmNgLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgLSBUaGUgdmFsdWUgdG8gaGFzaC5cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gZnVuYyAtIFRoZSBhbGdvcml0aG0gdG8gdXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIC0gT3B0aW9uYWxseSB0cmltIHRoZSByZXN1bHQgdG8gdGhpcyBsZW5ndGguXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCdWZmZXIpfSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gTXVsdGloYXNoaW5nIChidWYsIGZ1bmMsIGxlbmd0aCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBjYWxsYmFjaycpXG4gIH1cblxuICBNdWx0aWhhc2hpbmcuZGlnZXN0KGJ1ZiwgZnVuYywgbGVuZ3RoLCAoZXJyLCBkaWdlc3QpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIG11bHRpaGFzaC5lbmNvZGUoZGlnZXN0LCBmdW5jLCBsZW5ndGgpKVxuICB9KVxufVxuXG4vKipcbiAqIFRoZSBgYnVmZmVyYCBtb2R1bGUgZm9yIGVhc3kgdXNlIGluIHRoZSBicm93c2VyLlxuICpcbiAqIEB0eXBlIHtCdWZmZXJ9XG4gKi9cbk11bHRpaGFzaGluZy5CdWZmZXIgPSBCdWZmZXIgLy8gZm9yIGJyb3dzZXIgdGhpbmdzXG5cbi8qKlxuICogRXhwb3NlIG11bHRpaGFzaCBpdHNlbGYsIHRvIGF2b2lkIHNpbGx5IGRvdWJsZSByZXF1aXJlcy5cbiAqL1xuTXVsdGloYXNoaW5nLm11bHRpaGFzaCA9IG11bHRpaGFzaFxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgLSBUaGUgdmFsdWUgdG8gaGFzaC5cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gZnVuYyAtIFRoZSBhbGdvcml0aG0gdG8gdXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIC0gT3B0aW9uYWxseSB0cmltIHRoZSByZXN1bHQgdG8gdGhpcyBsZW5ndGguXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCdWZmZXIpfSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuTXVsdGloYXNoaW5nLmRpZ2VzdCA9IGZ1bmN0aW9uIChidWYsIGZ1bmMsIGxlbmd0aCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBjYWxsYmFjaycpXG4gIH1cblxuICBsZXQgY2IgPSBjYWxsYmFja1xuICBpZiAobGVuZ3RoKSB7XG4gICAgY2IgPSAoZXJyLCBkaWdlc3QpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGlnZXN0LnNsaWNlKDAsIGxlbmd0aCkpXG4gICAgfVxuICB9XG5cbiAgbGV0IGhhc2hcbiAgdHJ5IHtcbiAgICBoYXNoID0gTXVsdGloYXNoaW5nLmNyZWF0ZUhhc2goZnVuYylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGNiKGVycilcbiAgfVxuXG4gIGhhc2goYnVmLCBjYilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGZ1bmNcbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IC0gVGhlIHRvIGBmdW5jYCBjb3JyZXNwb25kaW5nIGhhc2ggZnVuY3Rpb24uXG4gKi9cbk11bHRpaGFzaGluZy5jcmVhdGVIYXNoID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgZnVuYyA9IG11bHRpaGFzaC5jb2VyY2VDb2RlKGZ1bmMpXG4gIGlmICghTXVsdGloYXNoaW5nLmZ1bmN0aW9uc1tmdW5jXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIGZ1bmN0aW9uICcgKyBmdW5jICsgJyBub3QgeWV0IHN1cHBvcnRlZCcpXG4gIH1cblxuICByZXR1cm4gTXVsdGloYXNoaW5nLmZ1bmN0aW9uc1tmdW5jXVxufVxuXG4vKipcbiAqIE1hcHBpbmcgb2YgbXVsdGloYXNoIGNvZGVzIHRvIHRoZWlyIGhhc2hpbmcgZnVuY3Rpb25zLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuTXVsdGloYXNoaW5nLmZ1bmN0aW9ucyA9IHtcbiAgLy8gc2hhMVxuICAweDExOiBjcnlwdG8uc2hhMSxcbiAgLy8gc2hhMi0yNTZcbiAgMHgxMjogY3J5cHRvLnNoYTIyNTYsXG4gIC8vIHNoYTItNTEyXG4gIDB4MTM6IGNyeXB0by5zaGEyNTEyLFxuICAvLyBzaGEzLTUxMlxuICAweDE0OiBjcnlwdG8uc2hhMzUxMixcbiAgLy8gc2hhMy0zODRcbiAgMHgxNTogY3J5cHRvLnNoYTMzODQsXG4gIC8vIHNoYTMtMjU2XG4gIDB4MTY6IGNyeXB0by5zaGEzMjU2LFxuICAvLyBzaGEzLTIyNFxuICAweDE3OiBjcnlwdG8uc2hhMzIyNCxcbiAgLy8gc2hha2UtMTI4XG4gIDB4MTg6IGNyeXB0by5zaGFrZTEyOCxcbiAgLy8gc2hha2UtMjU2XG4gIDB4MTk6IGNyeXB0by5zaGFrZTI1NixcbiAgLy8ga2VjY2FrLTIyNFxuICAweDFBOiBjcnlwdG8ua2VjY2FrMjI0LFxuICAvLyBrZWNjYWstMjU2XG4gIDB4MUI6IGNyeXB0by5rZWNjYWsyNTYsXG4gIC8vIGtlY2Nhay0zODRcbiAgMHgxQzogY3J5cHRvLmtlY2NhazM4NCxcbiAgLy8ga2VjY2FrLTUxMlxuICAweDFEOiBjcnlwdG8ua2VjY2FrNTEyLFxuICAvLyBtdXJtdXIzLTEyOFxuICAweDIyOiBjcnlwdG8ubXVybXVyMzEyOCxcbiAgLy8gbXVybXVyMy0zMlxuICAweDIzOiBjcnlwdG8ubXVybXVyMzMyLFxuICAvLyBkYmwtc2hhMi0yNTZcbiAgMHg1NjogY3J5cHRvLmRibFNoYTIyNTZcbn1cblxuLy8gYWRkIGJsYWtlIGZ1bmN0aW9uc1xuY3J5cHRvLmFkZEJsYWtlKE11bHRpaGFzaGluZy5mdW5jdGlvbnMpXG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwTWFwID0gcmVxdWlyZSgncC1tYXAnKTtcblxuY29uc3QgcFRpbWVzID0gYXN5bmMgKGNvdW50LCBtYXBwZXIsIG9wdGlvbnMpID0+XG5cdHBNYXAobmV3IEFycmF5KGNvdW50KS5maWxsKCksIChlbGVtZW50LCBpbmRleCkgPT4gbWFwcGVyKGluZGV4KSwgb3B0aW9ucyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcFRpbWVzO1xuLy8gVE9ETzogUmVtb3ZlIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIHJlbGVhc2Vcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBwVGltZXM7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGRpc3RcblxuZnVuY3Rpb24gZGlzdCAoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0cyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBsZW5ndGgnKVxuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGEubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHJlc3VsdFtpXSA9IGFbaV0gXiBiW2ldXG4gIHJldHVybiByZXN1bHRcbn1cblxuZGlzdC5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0cyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBsZW5ndGgnKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSA9PT0gYltpXSkgY29udGludWVcbiAgICByZXR1cm4gYVtpXSA8IGJbaV0gPyAtMSA6IDFcbiAgfVxuICByZXR1cm4gMFxufVxuXG5kaXN0Lmd0ID0gZnVuY3Rpb24gZ3QgKGEsIGIpIHtcbiAgcmV0dXJuIGRpc3QuY29tcGFyZShhLCBiKSA9PT0gMVxufVxuXG5kaXN0Lmx0ID0gZnVuY3Rpb24gbHQgKGEsIGIpIHtcbiAgcmV0dXJuIGRpc3QuY29tcGFyZShhLCBiKSA9PT0gLTFcbn1cblxuZGlzdC5lcSA9IGZ1bmN0aW9uIGVxIChhLCBiKSB7XG4gIHJldHVybiBkaXN0LmNvbXBhcmUoYSwgYikgPT09IDBcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBQZWVyRGlzdGFuY2VMaXN0ID0gcmVxdWlyZSgnLi4vcGVlci1kaXN0YW5jZS1saXN0JylcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCBwcm9taXNpZnkgPSByZXF1aXJlKCdwcm9taXNpZnktZXM2JylcblxuY29uc3QgUGF0aCA9IHJlcXVpcmUoJy4vcGF0aCcpXG5jb25zdCBXb3JrZXJRdWV1ZSA9IHJlcXVpcmUoJy4vd29ya2VyUXVldWUnKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpXG5cbi8qKlxuICogTWFuYWdlcyBhIHNpbmdsZSBydW4gb2YgdGhlIHF1ZXJ5LlxuICovXG5jbGFzcyBSdW4gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFJ1bi5cbiAgICpcbiAgICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAgICovXG4gIGNvbnN0cnVjdG9yIChxdWVyeSkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMucXVlcnkgPSBxdWVyeVxuXG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2VcbiAgICB0aGlzLndvcmtlcnMgPSBbXVxuXG4gICAgLy8gVGhlIHBlZXJzIHRoYXQgaGF2ZSBiZWVuIHF1ZXJpZWQgKGluY2x1ZGluZyBlcnJvciByZXNwb25zZXMpXG4gICAgdGhpcy5wZWVyc1NlZW4gPSBuZXcgU2V0KClcbiAgICAvLyBUaGUgZXJyb3JzIHJlY2VpdmVkIHdoZW4gcXVlcnlpbmcgcGVlcnNcbiAgICB0aGlzLmVycm9ycyA9IFtdXG4gICAgLy8gVGhlIGNsb3Nlc3QgSyBwZWVycyB0aGF0IGhhdmUgYmVlbiBxdWVyaWVkIHN1Y2Nlc3NmdWxseVxuICAgIC8vICh0aGlzIG1lbWJlciBpcyBpbml0aWFsaXplZCB3aGVuIHRoZSB3b3JrZXIgcXVldWVzIHN0YXJ0KVxuICAgIHRoaXMucGVlcnNRdWVyaWVkID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgYWxsIHRoZSB3b3JrZXJzXG4gICAqL1xuICBzdG9wICgpIHtcbiAgICBpZiAoIXRoaXMucnVubmluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2VcbiAgICBmb3IgKGNvbnN0IHdvcmtlciBvZiB0aGlzLndvcmtlcnMpIHtcbiAgICAgIHdvcmtlci5zdG9wKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgcnVuIHdpdGggdGhlIGdpdmVuIGluaXRpYWwgc2V0IG9mIHBlZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFBlZXJJZD59IHBlZXJzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuICBhc3luYyBleGVjdXRlIChwZWVycykge1xuICAgIGNvbnN0IHBhdGhzID0gW10gLy8gYXJyYXkgb2Ygc3RhdGVzIHBlciBkaXNqb2ludCBwYXRoXG5cbiAgICAvLyBDcmVhdGUgZGlzam9pbnQgcGF0aHNcbiAgICBjb25zdCBudW1QYXRocyA9IE1hdGgubWluKHRoaXMucXVlcnkuZGh0LmRpc2pvaW50UGF0aHMsIHBlZXJzLmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBhdGhzOyBpKyspIHtcbiAgICAgIHBhdGhzLnB1c2gobmV3IFBhdGgodGhpcywgdGhpcy5xdWVyeS5tYWtlUGF0aChpLCBudW1QYXRocykpKVxuICAgIH1cblxuICAgIC8vIEFzc2lnbiBwZWVycyB0byBwYXRocyByb3VuZC1yb2JpbiBzdHlsZVxuICAgIHBlZXJzLmZvckVhY2goKHBlZXIsIGkpID0+IHtcbiAgICAgIHBhdGhzW2kgJSBudW1QYXRoc10uYWRkSW5pdGlhbFBlZXIocGVlcilcbiAgICB9KVxuXG4gICAgLy8gRXhlY3V0ZSB0aGUgcXVlcnkgYWxvbmcgZWFjaCBkaXNqb2ludCBwYXRoXG4gICAgYXdhaXQgdGhpcy5leGVjdXRlUGF0aHMocGF0aHMpXG5cbiAgICBjb25zdCByZXMgPSB7XG4gICAgICAvLyBUaGUgY2xvc2VzdCBLIHBlZXJzIHdlIHdlcmUgYWJsZSB0byBxdWVyeSBzdWNjZXNzZnVsbHlcbiAgICAgIGZpbmFsU2V0OiBuZXcgU2V0KHRoaXMucGVlcnNRdWVyaWVkLnBlZXJzKSxcbiAgICAgIHBhdGhzOiBbXVxuICAgIH1cblxuICAgIC8vIENvbGxlY3QgdGhlIHJlc3VsdHMgZnJvbSBlYWNoIGNvbXBsZXRlZCBwYXRoXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICBpZiAocGF0aC5yZXMgJiYgKHBhdGgucmVzLnBhdGhDb21wbGV0ZSB8fCBwYXRoLnJlcy5xdWVyeUNvbXBsZXRlKSkge1xuICAgICAgICBwYXRoLnJlcy5zdWNjZXNzID0gdHJ1ZVxuICAgICAgICByZXMucGF0aHMucHVzaChwYXRoLnJlcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhbGwgcGF0aHMgdGhyb3VnaCB0aGUgREhULlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFBhdGg+fSBwYXRoc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIGV4ZWN1dGVQYXRocyAocGF0aHMpIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlXG5cbiAgICB0aGlzLmVtaXQoJ3N0YXJ0JylcbiAgICB0cnkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocGF0aHMubWFwKHBhdGggPT4gcGF0aC5leGVjdXRlKCkpKVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBFbnN1cmUgYWxsIHdvcmtlcnMgYXJlIHN0b3BwZWRcbiAgICAgIHRoaXMuc3RvcCgpXG4gICAgICAvLyBDb21wbGV0ZWQgdGhlIFJ1blxuICAgICAgdGhpcy5lbWl0KCdjb21wbGV0ZScpXG4gICAgfVxuXG4gICAgLy8gSWYgYWxsIHF1ZXJpZXMgZXJyb3JlZCBvdXQsIHNvbWV0aGluZyBpcyBzZXJpb3VzbHkgd3JvbmcsIHNvIGNhbGxiYWNrXG4gICAgLy8gd2l0aCBhbiBlcnJvclxuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPT09IHRoaXMucGVlcnNTZWVuLnNpemUpIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3JzWzBdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGxpc3Qgb2YgcXVlcmllZCBwZWVycywgdGhlbiBzdGFydCBhIHdvcmtlciBxdWV1ZSBmb3IgdGhlXG4gICAqIGdpdmVuIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7UGF0aH0gcGF0aFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIHdvcmtlclF1ZXVlIChwYXRoKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0KClcbiAgICBhd2FpdCB0aGlzLnN0YXJ0V29ya2VyKHBhdGgpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCBzdGFydCBhIHdvcmtlciBxdWV1ZSBmb3IgYSBwYXJ0aWN1bGFyIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7UGF0aH0gcGF0aFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIHN0YXJ0V29ya2VyIChwYXRoKSB7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlclF1ZXVlKHRoaXMucXVlcnkuZGh0LCB0aGlzLCBwYXRoLCB0aGlzLnF1ZXJ5Ll9sb2cpXG4gICAgdGhpcy53b3JrZXJzLnB1c2god29ya2VyKVxuICAgIGF3YWl0IHdvcmtlci5leGVjdXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBsaXN0IG9mIGNsb3Nlc3QgcGVlcnMgd2UndmUgcXVlcmllZCAtIHRoaXMgaXMgc2hhcmVkIGJ5IGFsbFxuICAgKiBwYXRocyBpbiB0aGUgcnVuLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIGluaXQgKCkge1xuICAgIGlmICh0aGlzLnBlZXJzUXVlcmllZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gV2Ugb25seSB3YW50IHRvIGluaXRpYWxpemUgdGhlIFBlZXJEaXN0YW5jZUxpc3Qgb25jZSBmb3IgdGhlIHJ1blxuICAgIGlmICh0aGlzLnBlZXJzUXVlcmllZFByb21pc2UpIHtcbiAgICAgIGF3YWl0IHRoaXMucGVlcnNRdWVyaWVkUHJvbWlzZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gVGhpcyBwcm9taXNlIGlzIHRlbXBvcmFyaWx5IHN0b3JlZCBzbyB0aGF0IG90aGVycyBtYXkgYXdhaXQgaXRzIGNvbXBsZXRpb25cbiAgICB0aGlzLnBlZXJzUXVlcmllZFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGh0S2V5ID0gYXdhaXQgcHJvbWlzaWZ5KGNiID0+IHV0aWxzLmNvbnZlcnRCdWZmZXIodGhpcy5xdWVyeS5rZXksIGNiKSkoKVxuICAgICAgdGhpcy5wZWVyc1F1ZXJpZWQgPSBuZXcgUGVlckRpc3RhbmNlTGlzdChkaHRLZXksIHRoaXMucXVlcnkuZGh0LmtCdWNrZXRTaXplKVxuICAgIH0pKClcblxuICAgIC8vIEFmdGVyIFBlZXJEaXN0YW5jZUxpc3QgaXMgaW5pdGlhbGl6ZWQsIGNsZWFuIHVwXG4gICAgYXdhaXQgdGhpcy5wZWVyc1F1ZXJpZWRQcm9taXNlXG4gICAgZGVsZXRlIHRoaXMucGVlcnNRdWVyaWVkUHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIElmIHdlJ3ZlIHF1ZXJpZWQgSyBwZWVycywgYW5kIHRoZSByZW1haW5pbmcgcGVlcnMgaW4gdGhlIGdpdmVuIGB3b3JrZXJgJ3MgcXVldWVcbiAgICogYXJlIGFsbCBmdXJ0aGVyIGZyb20gdGhlIGtleSB0aGFuIHRoZSBwZWVycyB3ZSd2ZSBhbHJlYWR5IHF1ZXJpZWQsIHRoZW4gd2Ugc2hvdWxkXG4gICAqIHN0b3AgcXVlcnlpbmcgb24gdGhhdCBgd29ya2VyYC5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JrZXJRdWV1ZX0gd29ya2VyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJvb2xlYW4+fVxuICAgKi9cbiAgYXN5bmMgY29udGludWVRdWVyeWluZyAod29ya2VyKSB7XG4gICAgLy8gSWYgd2UgaGF2ZW4ndCBxdWVyaWVkIEsgcGVlcnMgeWV0LCBrZWVwIGdvaW5nXG4gICAgaWYgKHRoaXMucGVlcnNRdWVyaWVkLmxlbmd0aCA8IHRoaXMucGVlcnNRdWVyaWVkLmNhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIEdldCBhbGwgdGhlIHBlZXJzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyBxdWVyaWVkLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIHJpZ2h0IGFmdGVyIGEgcGVlciBoYXMgYmVlbiBwb3BwZWRcbiAgICAvLyBvZmYgdGhlIGhlYWQgb2YgdGhlIGNsb3Nlc3QgcGVlcnMgcXVldWUgc28gaXQgd2lsbCBpbmNsdWRlIHRoYXQgcGVlci5cbiAgICBjb25zdCBydW5uaW5nID0gd29ya2VyLnF1ZXVlLndvcmtlcnNMaXN0KCkubWFwKGkgPT4gaS5kYXRhKVxuXG4gICAgLy8gQ2hlY2sgaWYgYW55IG9mIHRoZSBwZWVycyB0aGF0IGFyZSBjdXJyZW50bHkgYmVpbmcgcXVlcmllZCBhcmUgY2xvc2VyXG4gICAgLy8gdG8gdGhlIGtleSB0aGFuIHRoZSBwZWVycyB3ZSd2ZSBhbHJlYWR5IHF1ZXJpZWRcbiAgICBjb25zdCBzb21lQ2xvc2VyID0gYXdhaXQgcHJvbWlzaWZ5KGNiID0+IHRoaXMucGVlcnNRdWVyaWVkLmFueUNsb3NlcihydW5uaW5nLCBjYikpKClcblxuICAgIC8vIFNvbWUgYXJlIGNsb3NlciwgdGhlIHdvcmtlciBzaG91bGQga2VlcCBnb2luZ1xuICAgIGlmIChzb21lQ2xvc2VyKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIE5vbmUgYXJlIGNsb3NlciwgdGhlIHdvcmtlciBjYW4gc3RvcFxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUnVuXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtJylcbmNvbnN0IGxwID0gcmVxdWlyZSgncHVsbC1sZW5ndGgtcHJlZml4ZWQnKVxuXG5jb25zdCBNZXNzYWdlID0gcmVxdWlyZSgnLi4vbWVzc2FnZScpXG5jb25zdCBoYW5kbGVycyA9IHJlcXVpcmUoJy4vaGFuZGxlcnMnKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpXG5jb25zdCBjID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJylcblxubW9kdWxlLmV4cG9ydHMgPSAoZGh0KSA9PiB7XG4gIGNvbnN0IGxvZyA9IHV0aWxzLmxvZ2dlcihkaHQucGVlckluZm8uaWQsICdycGMnKVxuXG4gIGNvbnN0IGdldE1lc3NhZ2VIYW5kbGVyID0gaGFuZGxlcnMoZGh0KVxuICAvKipcbiAgICogUHJvY2VzcyBpbmNvbWluZyBESFQgbWVzc2FnZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlckluZm99IHBlZXJcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtc2dcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgTWVzc2FnZSl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZSAocGVlciwgbXNnLCBjYWxsYmFjaykge1xuICAgIC8vIHVwZGF0ZSB0aGUgcGVlclxuICAgIGRodC5fYWRkKHBlZXIsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIHRoZSBrYnVja2V0IHN0b3JlJylcbiAgICAgICAgbG9nLmVycm9yKGVycilcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IGhhbmRsZXIgJiBleGVjdHVlIGl0XG4gICAgICBjb25zdCBoYW5kbGVyID0gZ2V0TWVzc2FnZUhhbmRsZXIobXNnLnR5cGUpXG5cbiAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICBsb2cuZXJyb3IoYG5vIGhhbmRsZXIgZm91bmQgZm9yIG1lc3NhZ2UgdHlwZTogJHttc2cudHlwZX1gKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgfVxuXG4gICAgICBoYW5kbGVyKHBlZXIsIG1zZywgY2FsbGJhY2spXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgaW5jb21pbmcgc3RyZWFtcyBmcm9tIHRoZSBTd2l0Y2gsIG9uIHRoZSBkaHQgcHJvdG9jb2wuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiBwcm90b2NvbEhhbmRsZXIgKHByb3RvY29sLCBjb25uKSB7XG4gICAgY29ubi5nZXRQZWVySW5mbygoZXJyLCBwZWVyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZy5lcnJvcignRmFpbGVkIHRvIGdldCBwZWVyIGluZm8nKVxuICAgICAgICBsb2cuZXJyb3IoZXJyKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbG9nKCdmcm9tOiAlcycsIHBlZXIuaWQudG9CNThTdHJpbmcoKSlcblxuICAgICAgcHVsbChcbiAgICAgICAgY29ubixcbiAgICAgICAgbHAuZGVjb2RlKCksXG4gICAgICAgIHB1bGwuZmlsdGVyKChtc2cpID0+IG1zZy5sZW5ndGggPCBjLm1heE1lc3NhZ2VTaXplKSxcbiAgICAgICAgcHVsbC5tYXAoKHJhd01zZykgPT4ge1xuICAgICAgICAgIGxldCBtc2dcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbXNnID0gTWVzc2FnZS5kZXNlcmlhbGl6ZShyYXdNc2cpXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoJ2ZhaWxlZCB0byByZWFkIGluY29taW5nIG1lc3NhZ2UnLCBlcnIpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbXNnXG4gICAgICAgIH0pLFxuICAgICAgICBwdWxsLmZpbHRlcihCb29sZWFuKSxcbiAgICAgICAgcHVsbC5hc3luY01hcCgobXNnLCBjYikgPT4gaGFuZGxlTWVzc2FnZShwZWVyLCBtc2csIGNiKSksXG4gICAgICAgIC8vIE5vdCBhbGwgaGFuZGxlcnMgd2lsbCByZXR1cm4gYSByZXNwb25zZVxuICAgICAgICBwdWxsLmZpbHRlcihCb29sZWFuKSxcbiAgICAgICAgcHVsbC5tYXAoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgbGV0IG1zZ1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtc2cgPSByZXNwb25zZS5zZXJpYWxpemUoKVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nLmVycm9yKCdmYWlsZWQgdG8gc2VuZCBtZXNzYWdlJywgZXJyKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtc2dcbiAgICAgICAgfSksXG4gICAgICAgIHB1bGwuZmlsdGVyKEJvb2xlYW4pLFxuICAgICAgICBscC5lbmNvZGUoKSxcbiAgICAgICAgY29ublxuICAgICAgKVxuICAgIH0pXG4gIH1cbn1cbiIsInZhciBSZWFkZXIgPSByZXF1aXJlKCdwdWxsLXJlYWRlcicpXG52YXIgV3JpdGVyID0gcmVxdWlyZSgncHVsbC1wdXNoYWJsZScpXG52YXIgY2F0ID0gcmVxdWlyZSgncHVsbC1jYXQnKVxudmFyIHBhaXIgPSByZXF1aXJlKCdwdWxsLXBhaXInKVxuXG5mdW5jdGlvbiBvbmNlIChjYikge1xuICB2YXIgY2FsbGVkID0gMFxuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICBpZihjYWxsZWQrKykgcmV0dXJuXG4gICAgY2IoYSwgYiwgYylcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChmKSB7XG4gIHJldHVybiAnZnVuY3Rpb24nID09PSB0eXBlb2YgZlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzLCBfY2IpIHtcbiAgaWYoaXNGdW5jdGlvbihvcHRzKSkgX2NiID0gb3B0cywgb3B0cyA9IHt9XG4gIF9jYiA9IG9uY2UoX2NiIHx8IGZ1bmN0aW9uIG5vb3AgKCkge30pXG4gIHZhciByZWFkZXIgPSBSZWFkZXIob3B0cyAmJiBvcHRzLnRpbWVvdXQgfHwgNWUzKVxuICB2YXIgd3JpdGVyID0gV3JpdGVyKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZihlcnIpIF9jYihlcnIpXG4gIH0pXG5cbiAgdmFyIHAgPSBwYWlyKClcblxuICByZXR1cm4ge1xuICAgIGhhbmRzaGFrZToge1xuICAgICAgcmVhZDogcmVhZGVyLnJlYWQsXG4gICAgICBhYm9ydDogZnVuY3Rpb24gKGVycikge1xuICAgICAgICB3cml0ZXIuZW5kKGVycilcbiAgICAgICAgcmVhZGVyLmFib3J0KGVyciwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICB9KVxuICAgICAgICBfY2IoZXJyKVxuICAgICAgfSxcbiAgICAgIHdyaXRlOiB3cml0ZXIucHVzaCxcbiAgICAgIHJlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd3JpdGVyLmVuZCgpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiByZWFkZXIucmVhZCgpLFxuICAgICAgICAgIHNpbms6IHAuc2lua1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzaW5rOiByZWFkZXIsXG4gICAgc291cmNlOiBjYXQoW3dyaXRlciwgcC5zb3VyY2VdKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCB3YXRlcmZhbGwgPSByZXF1aXJlKCdhc3luYy93YXRlcmZhbGwnKVxuXG5jb25zdCBzdXBwb3J0ID0gcmVxdWlyZSgnLi4vc3VwcG9ydCcpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpXG5cbmNvbnN0IGxvZyA9IGRlYnVnKCdsaWJwMnA6c2VjaW8nKVxubG9nLmVycm9yID0gZGVidWcoJ2xpYnAycDpzZWNpbzplcnJvcicpXG5cbi8vIHN0ZXAgMi4gRXhjaGFuZ2Vcbi8vIC0tIGV4Y2hhbmdlIChzaWduZWQpIGVwaGVtZXJhbCBrZXlzLiB2ZXJpZnkgc2lnbmF0dXJlcy5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhjaGFuZ2UgKHN0YXRlLCBjYWxsYmFjaykge1xuICBsb2coJzIuIGV4Y2hhbmdlIC0gc3RhcnQnKVxuXG4gIGxvZygnMi4gZXhjaGFuZ2UgLSB3cml0aW5nIGV4Y2hhbmdlJylcbiAgd2F0ZXJmYWxsKFtcbiAgICAoY2IpID0+IGNyeXB0by5jcmVhdGVFeGNoYW5nZShzdGF0ZSwgY2IpLFxuICAgIChleCwgY2IpID0+IHtcbiAgICAgIHN1cHBvcnQud3JpdGUoc3RhdGUsIGV4KVxuICAgICAgc3VwcG9ydC5yZWFkKHN0YXRlLnNoYWtlLCBjYilcbiAgICB9LFxuICAgIChtc2csIGNiKSA9PiB7XG4gICAgICBsb2coJzIuIGV4Y2hhbmdlIC0gcmVhZGluZyBleGNoYW5nZScpXG4gICAgICBjcnlwdG8udmVyaWZ5KHN0YXRlLCBtc2csIGNiKVxuICAgIH0sXG4gICAgKGNiKSA9PiBjcnlwdG8uZ2VuZXJhdGVLZXlzKHN0YXRlLCBjYilcbiAgXSwgKGVycikgPT4ge1xuICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycikgfVxuXG4gICAgbG9nKCcyLiBleGNoYW5nZSAtIGZpbmlzaCcpXG4gICAgY2FsbGJhY2soKVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9wdWxsJylcbmNvbnN0IHB1bGxFcnJvciA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3NvdXJjZXMvZXJyb3InKVxuY29uc3QgaGFuZHNoYWtlID0gcmVxdWlyZSgncHVsbC1oYW5kc2hha2UnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5cbmNvbnN0IGxvZyA9IGRlYnVnKCdsaWJwMnA6c2VjaW8nKVxubG9nLmVycm9yID0gZGVidWcoJ2xpYnAycDpzZWNpbzplcnJvcicpXG5cbmNvbnN0IGV0bSA9IHJlcXVpcmUoJy4uL2V0bScpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpXG5cbi8vIHN0ZXAgMy4gRmluaXNoXG4vLyAtLSBzZW5kIGV4cGVjdGVkIG1lc3NhZ2UgdG8gdmVyaWZ5IGVuY3J5cHRpb24gd29ya3MgKHNlbmQgbG9jYWwgbm9uY2UpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbmlzaCAoc3RhdGUsIGNhbGxiYWNrKSB7XG4gIGxvZygnMy4gZmluaXNoIC0gc3RhcnQnKVxuXG4gIGNvbnN0IHByb3RvID0gc3RhdGUucHJvdG9jb2xzXG4gIGNvbnN0IHN0cmVhbSA9IHN0YXRlLnNoYWtlLnJlc3QoKVxuICBjb25zdCBzaGFrZSA9IGhhbmRzaGFrZSh7IHRpbWVvdXQ6IHN0YXRlLnRpbWVvdXQgfSwgKGVycikgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfSlcblxuICBwdWxsKFxuICAgIHN0cmVhbSxcbiAgICBldG0uY3JlYXRlVW5ib3hTdHJlYW0ocHJvdG8ucmVtb3RlLmNpcGhlciwgcHJvdG8ucmVtb3RlLm1hYyksXG4gICAgc2hha2UsXG4gICAgZXRtLmNyZWF0ZUJveFN0cmVhbShwcm90by5sb2NhbC5jaXBoZXIsIHByb3RvLmxvY2FsLm1hYyksXG4gICAgc3RyZWFtXG4gIClcblxuICBzaGFrZS5oYW5kc2hha2Uud3JpdGUoc3RhdGUucHJvcG9zYWwuaW4ucmFuZClcbiAgc2hha2UuaGFuZHNoYWtlLnJlYWQoc3RhdGUucHJvcG9zYWwuaW4ucmFuZC5sZW5ndGgsIChlcnIsIG5vbmNlQmFjaykgPT4ge1xuICAgIGNvbnN0IGZhaWwgPSAoZXJyKSA9PiB7XG4gICAgICBsb2cuZXJyb3IoZXJyKVxuICAgICAgc3RhdGUuc2VjdXJlLnJlc29sdmUoe1xuICAgICAgICBzb3VyY2U6IHB1bGxFcnJvcihlcnIpLFxuICAgICAgICBzaW5rIChyZWFkKSB7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgaWYgKGVycikgcmV0dXJuIGZhaWwoZXJyKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNyeXB0by52ZXJpZnlOb25jZShzdGF0ZSwgbm9uY2VCYWNrKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGZhaWwoZXJyKVxuICAgIH1cblxuICAgIGxvZygnMy4gZmluaXNoIC0gZmluaXNoJylcblxuICAgIC8vIEF3ZXNvbWUgdGhhdCdzIGFsbCBmb2xrcy5cbiAgICBzdGF0ZS5zZWN1cmUucmVzb2x2ZShzaGFrZS5oYW5kc2hha2UucmVzdCgpKVxuICAgIGNhbGxiYWNrKClcbiAgfSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IHdhdGVyZmFsbCA9IHJlcXVpcmUoJ2FzeW5jL3dhdGVyZmFsbCcpXG5cbmNvbnN0IHN1cHBvcnQgPSByZXF1aXJlKCcuLi9zdXBwb3J0JylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJy4vY3J5cHRvJylcblxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycDpzZWNpbycpXG5sb2cuZXJyb3IgPSBkZWJ1ZygnbGlicDJwOnNlY2lvOmVycm9yJylcblxuLy8gc3RlcCAxLiBQcm9wb3NlXG4vLyAtLSBwcm9wb3NlIGNpcGhlciBzdWl0ZSArIHNlbmQgcHVia2V5cyArIG5vbmNlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHByb3Bvc2UgKHN0YXRlLCBjYWxsYmFjaykge1xuICBsb2coJzEuIHByb3Bvc2UgLSBzdGFydCcpXG5cbiAgbG9nKCcxLiBwcm9wb3NlIC0gd3JpdGluZyBwcm9wb3NhbCcpXG4gIHN1cHBvcnQud3JpdGUoc3RhdGUsIGNyeXB0by5jcmVhdGVQcm9wb3NhbChzdGF0ZSkpXG5cbiAgd2F0ZXJmYWxsKFtcbiAgICAoY2IpID0+IHN1cHBvcnQucmVhZChzdGF0ZS5zaGFrZSwgY2IpLFxuICAgIChtc2csIGNiKSA9PiB7XG4gICAgICBsb2coJzEuIHByb3Bvc2UgLSByZWFkaW5nIHByb3Bvc2FsJywgbXNnKVxuICAgICAgY3J5cHRvLmlkZW50aWZ5KHN0YXRlLCBtc2csIGNiKVxuICAgIH0sXG4gICAgKGNiKSA9PiBjcnlwdG8uc2VsZWN0UHJvdG9jb2xzKHN0YXRlLCBjYilcbiAgXSwgKGVycikgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgbG9nKCcxLiBwcm9wb3NlIC0gZmluaXNoJylcbiAgICBjYWxsYmFjaygpXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbXVsdGlhZGRyID0gcmVxdWlyZSgnbXVsdGlhZGRyJylcbmNvbnN0IElkID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdsaWJwMnAtY3J5cHRvJylcbmNvbnN0IG1hZm10ID0gcmVxdWlyZSgnbWFmbXQnKVxuXG5mdW5jdGlvbiBjbGVhblVybFNJTyAobWEpIHtcbiAgY29uc3QgcHJvdG9zID0gbWEucHJvdG9zKClcbiAgY29uc3QgaXBQcm90byA9IHByb3Rvc1swXS5uYW1lXG4gIGNvbnN0IHRjcFByb3RvID0gcHJvdG9zWzFdLm5hbWVcbiAgY29uc3Qgd3NQcm90byA9IHByb3Rvc1syXS5uYW1lXG4gIGNvbnN0IHN0cmluZ1R1cGxlcyA9IG1hLnN0cmluZ1R1cGxlcygpXG4gIGNvbnN0IHRjcFBvcnQgPSBzdHJpbmdUdXBsZXNbMV1bMV1cblxuICBpZiAodGNwUHJvdG8gIT09ICd0Y3AnIHx8ICh3c1Byb3RvICE9PSAnd3MnICYmIHdzUHJvdG8gIT09ICd3c3MnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBtdWx0aWFkZHI6ICcgKyBtYS50b1N0cmluZygpKVxuICB9XG5cbiAgbGV0IGhvc3QgPSBzdHJpbmdUdXBsZXNbMF1bMV1cbiAgaWYgKGlwUHJvdG8gPT09ICdpcDYnKSB7XG4gICAgaG9zdCA9ICdbJyArIGhvc3QgKyAnXSdcbiAgfVxuXG4gIGxldCBwcm90byA9IHdzUHJvdG8gPT09ICd3c3MnID8gJ2h0dHBzJyA6ICdodHRwJ1xuICBsZXQgcG9ydCA9XG4gICAgKHdzUHJvdG8gPT09ICd3cycgJiYgdGNwUG9ydCA9PT0gODApIHx8ICh3c1Byb3RvID09PSAnd3NzJyAmJiB0Y3BQb3J0ID09PSA0NDMpXG4gICAgICA/ICcnIDogdGNwUG9ydFxuXG4gIHJldHVybiBwcm90byArICc6Ly8nICsgaG9zdCArIChwb3J0ID8gJzonICsgcG9ydCA6ICcnKVxufVxuXG5jb25zdCB0eXBlcyA9IHtcbiAgc3RyaW5nOiB2ID0+IHR5cGVvZiB2ID09PSAnc3RyaW5nJyxcbiAgb2JqZWN0OiB2ID0+IHR5cGVvZiB2ID09PSAnb2JqZWN0JyxcbiAgbXVsdGlhZGRyOiB2ID0+IHtcbiAgICBpZiAoIXR5cGVzLnN0cmluZyh2KSkgcmV0dXJuXG4gICAgdHJ5IHtcbiAgICAgIG11bHRpYWRkcih2KVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0sXG4gIGZ1bmN0aW9uOiB2ID0+IHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlIChkZWYsIGRhdGEpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgaXMgbm90IGFuIGFycmF5JylcbiAgZGVmLmZvckVhY2goKHR5cGUsIGluZGV4KSA9PiB7XG4gICAgaWYgKCF0eXBlc1t0eXBlXSkge1xuICAgICAgY29uc29sZS5lcnJvcignVHlwZSAlcyBkb2VzIG5vdCBleGlzdCcsIHR5cGUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlICcgKyB0eXBlICsgJyBkb2VzIG5vdCBleGlzdCcpXG4gICAgfVxuICAgIGlmICghdHlwZXNbdHlwZV0oZGF0YVtpbmRleF0pKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgYXQgaW5kZXggJyArIGluZGV4ICsgJyBpcyBpbnZhbGlkIGZvciB0eXBlICcgKyB0eXBlKVxuICB9KVxufVxuXG5mdW5jdGlvbiBQcm90b2NvbCAobG9nKSB7XG4gIGlmICghbG9nKSBsb2cgPSAoKSA9PiB7fVxuICBjb25zdCBzZWxmID0gdGhpc1xuICBzZWxmLnJlcXVlc3RzID0ge31cbiAgc2VsZi5hZGRSZXF1ZXN0ID0gKG5hbWUsIGRlZiwgaGFuZGxlKSA9PiB7XG4gICAgc2VsZi5yZXF1ZXN0c1tuYW1lXSA9IHtcbiAgICAgIGRlZixcbiAgICAgIGhhbmRsZVxuICAgIH1cbiAgfVxuICBzZWxmLmhhbmRsZVNvY2tldCA9IChzb2NrZXQpID0+IHtcbiAgICBzb2NrZXQuciA9IHt9XG4gICAgT2JqZWN0LmtleXMoc2VsZi5yZXF1ZXN0cykuZm9yRWFjaCgocmVxdWVzdCkgPT4ge1xuICAgICAgY29uc3QgciA9IHNlbGYucmVxdWVzdHNbcmVxdWVzdF1cbiAgICAgIHNvY2tldC5vbihyZXF1ZXN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbLi4uYXJndW1lbnRzXVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbGlkYXRlKHIuZGVmLCBkYXRhKVxuICAgICAgICAgIGRhdGEudW5zaGlmdChzb2NrZXQpXG4gICAgICAgICAgci5oYW5kbGUuYXBwbHkobnVsbCwgZGF0YSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZyhlKVxuICAgICAgICAgIGxvZygncGVlciAlcyBoYXMgc2VudCBpbnZhbGlkIGRhdGEgZm9yIHJlcXVlc3QgJXMnLCBzb2NrZXQuaWQgfHwgJzxzZXJ2ZXI+JywgcmVxdWVzdCwgZGF0YSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldElkQW5kVmFsaWRhdGUgKHB1YiwgaWQsIGNiKSB7XG4gIElkLmNyZWF0ZUZyb21QdWJLZXkoQnVmZmVyLmZyb20ocHViLCAnaGV4JyksIChlcnIsIF9pZCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0NyeXB0byBlcnJvcicpKVxuICAgIH1cbiAgICBpZiAoX2lkLnRvQjU4U3RyaW5nKCkgIT09IGlkKSB7XG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdJZCBpcyBub3QgbWF0Y2hpbmcnKSlcbiAgICB9XG5cbiAgICByZXR1cm4gY2IobnVsbCwgY3J5cHRvLmtleXMudW5tYXJzaGFsUHVibGljS2V5KEJ1ZmZlci5mcm9tKHB1YiwgJ2hleCcpKSlcbiAgfSlcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzXG5leHBvcnRzLmNsZWFuVXJsU0lPID0gY2xlYW5VcmxTSU9cbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZVxuZXhwb3J0cy5Qcm90b2NvbCA9IFByb3RvY29sXG5leHBvcnRzLmdldElkQW5kVmFsaWRhdGUgPSBnZXRJZEFuZFZhbGlkYXRlXG5leHBvcnRzLnZhbGlkYXRlTWEgPSAobWEpID0+IG1hZm10LldlYlNvY2tldFN0YXIubWF0Y2hlcyhtdWx0aWFkZHIobWEpKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycDp3ZWJzb2NrZXQtc3RhcjpsaXN0ZW5lcicpXG5jb25zdCBtdWx0aWFkZHIgPSByZXF1aXJlKCdtdWx0aWFkZHInKVxuY29uc3QgaW8gPSByZXF1aXJlKCdzb2NrZXQuaW8tY2xpZW50JylcbmNvbnN0IHNwID0gcmVxdWlyZSgnc29ja2V0LmlvLXB1bGwtc3RyZWFtJylcbmNvbnN0IHV1aWQgPSByZXF1aXJlKCd1dWlkJylcbmNvbnN0IHNlcmllcyA9IHJlcXVpcmUoJ2FzeW5jL3NlcmllcycpXG5jb25zdCBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuY29uc3QgQ29ubmVjdGlvbiA9IHJlcXVpcmUoJ2ludGVyZmFjZS1jb25uZWN0aW9uJykuQ29ubmVjdGlvblxuY29uc3Qgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxuY29uc3Qgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnYXN5bmMvc2V0SW1tZWRpYXRlJylcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBjbGVhblVybFNJTyA9IHV0aWxzLmNsZWFuVXJsU0lPXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdsaWJwMnAtY3J5cHRvJylcbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9wdWxsJylcbmNvbnN0IHRocm91Z2ggPSByZXF1aXJlKCdwdWxsLXN0cmVhbS90aHJvdWdocy90aHJvdWdoJylcbmNvbnN0IEVSUk9SUyA9IHJlcXVpcmUoJy4vZXJyb3JzJylcblxuY29uc3Qgbm9vcCA9IG9uY2UoKCkgPT4ge30pXG5cbmNvbnN0IHNpb09wdGlvbnMgPSB7XG4gIHRyYW5zcG9ydHM6IFsnd2Vic29ja2V0J10sXG4gICdmb3JjZSBuZXcgY29ubmVjdGlvbic6IHRydWVcbn1cblxuLyoqXG4gICogTGlzdGVuZXIgZm9yIHNpZ25hbGxpbmcgc2VydmVyXG4gICogQGNsYXNzXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbGlzdGVuZXJcbiAgKiBAcGFyYW0ge1BlZXJJZH0gb3B0aW9ucy5pZCAtIElkIGZvciB0aGUgY3J5cHRvIGNoYWxsZW5nZVxuICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuaGFuZGxlciAtIEluY29tbWluZyBjb25uZWN0aW9uIGhhbmRsZXJcbiAgKi9cbmNsYXNzIExpc3RlbmVyIGV4dGVuZHMgRUUge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmlkID0gb3B0aW9ucy5pZFxuICAgIHRoaXMubG9nID0gbG9nLmJpbmQobG9nLCAnbGlzdGVuZXIjb2ZmbGluZScpXG4gICAgdGhpcy5jYW5DcnlwdG8gPSBCb29sZWFuKG9wdGlvbnMuaWQpXG4gICAgdGhpcy5faGFuZGxlciA9IG9wdGlvbnMuaGFuZGxlciB8fCBub29wXG4gICAgdGhpcy5saXN0ZW5lcnNfbGlzdCA9IG9wdGlvbnMubGlzdGVuZXJzIHx8IHt9XG4gICAgdGhpcy5mbGFnID0gb3B0aW9ucy5mbGFnXG4gICAgdGhpcy5jb25ucyA9IFtdXG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZVxuICB9XG5cbiAgLy8gXCJwcml2YXRlXCIgZnVuY3Rpb25zXG4gIC8qKlxuICAgICogQ29ubmVjdHMgdG8gdGhlIHNpZ25hbGxpbmcgc2VydmVyXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrXG4gICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICBfdXAgKGNiKSB7XG4gICAgY2IgPSBjYiA/IG9uY2UoY2IpIDogbm9vcFxuICAgIGlmICh0aGlzLmlvKSB7XG4gICAgICByZXR1cm4gY2IoKVxuICAgIH1cblxuICAgIHRoaXMubG9nID0gbG9nLmJpbmQobG9nLCAnbGlzdGVuZXIjJyArIHRoaXMuc2VydmVyKVxuICAgIHRoaXMubG9nKCdkaWFsaW5nIHRvIHNpZ25hbGxpbmcgc2VydmVyJylcbiAgICBjb25zdCBfaW8gPSB0aGlzLmlvID0gaW8uY29ubmVjdCh0aGlzLnNlcnZlciwgc2lvT3B0aW9ucylcblxuICAgIHNwKF9pbywgeyBjb2RlYzogJ2J1ZmZlcicgfSlcbiAgICBfaW8ub25jZSgnZXJyb3InLCBjYilcbiAgICBfaW8ub25jZSgnY29ubmVjdF9lcnJvcicsIGNiKVxuICAgIF9pby5vbmNlKCdjb25uZWN0JywgY2IpXG5cbiAgICBjb25zdCBwcm90byA9IG5ldyB1dGlscy5Qcm90b2NvbCh0aGlzLmxvZylcblxuICAgIHByb3RvLmFkZFJlcXVlc3QoJ3dzLXBlZXInLCBbJ211bHRpYWRkciddLCAoc29ja2V0LCBwZWVyKSA9PiB0aGlzLmVtaXQoJ3BlZXInLCBwZWVyKSlcbiAgICBwcm90by5hZGRSZXF1ZXN0KCdzcy1pbmNvbW1pbmcnLCBbJ3N0cmluZycsICdtdWx0aWFkZHInLCAnZnVuY3Rpb24nXSwgdGhpcy5faW5jb21taW5nRGlhbC5iaW5kKHRoaXMpKVxuICAgIHByb3RvLmhhbmRsZVNvY2tldChfaW8pXG4gIH1cblxuICAvKipcbiAgICAqIERpc2Nvbm5lY3RzIGZyb20gc2lnbmFsbGluZyBzZXJ2ZXJcbiAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gIF9kb3duICgpIHtcbiAgICBpZiAoIXRoaXMuaW8pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuaW8uZGlzY29ubmVjdCgpXG4gICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgZGVsZXRlIHRoaXMuaW9cbiAgfVxuXG4gIC8qKlxuICAgICogUGVyZm9ybXMgYSBjcnlwdG9DaGFsbGVuZ2VcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gY2FsbGJhY2tcbiAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gIF9jcnlwdG9DaGFsbGVuZ2UgKGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmlvKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdOb3QgY29ubmVjdGVkJykpXG4gICAgfVxuXG4gICAgY29uc3QgcHViS2V5U3RyID0gdGhpcy5jYW5DcnlwdG8gPyBjcnlwdG8ua2V5cy5tYXJzaGFsUHVibGljS2V5KHRoaXMuaWQucHViS2V5KS50b1N0cmluZygnaGV4JykgOiAnJ1xuXG4gICAgY29uc3QgbWFTdHIgPSB0aGlzLm1hLnRvU3RyaW5nKClcblxuICAgIHRoaXMuaW8uZW1pdCgnc3Mtam9pbicsIG1hU3RyLCBwdWJLZXlTdHIsIChlcnIsIHNpZywgcGVlcnMpID0+IHtcbiAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycikgfVxuXG4gICAgICBpZiAoc2lnKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW5DcnlwdG8pIHtcbiAgICAgICAgICB0aGlzLl9kb3duKClcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiQ2FuJ3Qgc2lnbiBjcnlwdG9DaGFsbGVuZ2U6IE5vIGlkIHByb3ZpZGVkXCIpKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2coJ3BlcmZvcm1pbmcgY3J5cHRvQ2hhbGxlbmdlJylcblxuICAgICAgICB0aGlzLmlkLnByaXZLZXkuc2lnbihCdWZmZXIuZnJvbShzaWcpLCAoZXJyLCBzaWduYXR1cmUpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZS50b1N0cmluZygnaGV4JylcbiAgICAgICAgICB0aGlzLl9qb2luKGNhbGxiYWNrKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmZsYWcpIHtcbiAgICAgICAgICB0aGlzLl9kb3duKClcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdUcmllZCB0byBsaXN0ZW4gb24gYSBzZXJ2ZXIgd2l0aCBjcnlwdG8gY2hhbGxlbmdlIGRpc2FibGVkIVxcbiAgICBUaGlzIGlzIHByb2hpYml0ZWQgYnkgZGVmYXVsdCBhbmQgY2FuIGxlYWQgdG8gc2VjdXJpdHkgaXNzdWVzIVxcbiAgICBQbGVhc2Ugc2V0IFwiYWxsb3dKb2luV2l0aERpc2FibGVkQ2hhbGxlbmdlXCIgdG8gdHJ1ZSBpbiB0aGUgY29uc3RydWN0b3Igb3B0aW9ucyAoYnV0IG9ubHkgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nKSEnKSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpZ25hdHVyZSA9ICdfJ1xuICAgICAgICBjYWxsYmFjayhudWxsLCBudWxsLCBwZWVycylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAgKiBQZXJmb3JtcyBhIGNyeXB0b0NoYWxsZW5nZSB3aGVuIG5vIHNpZ25hdHVyZSBpcyBmb3VuZFxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgLSBjYWxsYmFja1xuICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgX2NyeXB0byAoY2IpIHtcbiAgICBjYiA9IGNiID8gb25jZShjYikgOiBub29wXG5cbiAgICB0aGlzLmxvZygnam9pbmluZycpXG5cbiAgICBpZiAoIXRoaXMuaW8pIHtcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zaWduYXR1cmUpIHtcbiAgICAgIHRoaXMuX2pvaW4oY2IpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NyeXB0b0NoYWxsZW5nZShjYilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICAqIEVtaXRzIHNzLWpvaW4gd2l0aCB0aGUgbXVsdGlhZGRyIGFuZCBzaWduYXR1cmVcbiAgICAqXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrXG4gICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICBfam9pbiAoY2IpIHtcbiAgICB0aGlzLmlvLmVtaXQoJ3NzLWpvaW4nLCB0aGlzLm1hLnRvU3RyaW5nKCksIHRoaXMuc2lnbmF0dXJlLCBjYilcbiAgfVxuXG4gIC8qKlxuICAgICogSGFuZGxlcyBpbmNvbW1pbmcgZGlhbHNcbiAgICAqIEBsaXN0ZW5zIHNzLWluY29tbWluZ1xuICAgICogQHBhcmFtIHtzb2NrZXQuaW9fY2xpZW50fSBzb2NrZXRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaWFsSWQgLSBVbmlxdWUgaWQgZm9yIHRoaXMgZGlhbFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGRpYWxGcm9tIC0gTXVsdGlhZGRyIGFzIHN0cmluZ1xuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgLSBjYWxsYmFja1xuICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgX2luY29tbWluZ0RpYWwgKHNvY2tldCwgZGlhbElkLCBkaWFsRnJvbSwgY2IpIHtcbiAgICB0aGlzLmxvZygnZGlhbCMnICsgZGlhbElkICsgJyBpbmNvbW1pbmcgZnJvbScsIGRpYWxGcm9tKVxuICAgIGNvbnN0IG1hID0gbXVsdGlhZGRyKGRpYWxGcm9tKVxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuaW8uY3JlYXRlU291cmNlKGRpYWxJZCArICcuZGlhbGVyJylcbiAgICBjb25zdCBzaW5rID0gdGhpcy5pby5jcmVhdGVTaW5rKGRpYWxJZCArICcubGlzdGVuZXInKVxuXG4gICAgY2IoKVxuXG4gICAgY29uc3QgY29ubiA9IG5ldyBDb25uZWN0aW9uKFxuICAgICAge1xuICAgICAgICBzaW5rOiBzaW5rLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZVxuICAgICAgfSwge1xuICAgICAgICBnZXRPYnNlcnZlZEFkZHJzOiAoY2IpID0+IGNiKG51bGwsIFttYV0pXG4gICAgICB9XG4gICAgKVxuICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbicsIGNvbm4pXG4gICAgdGhpcy5faGFuZGxlcihjb25uKVxuICB9XG5cbiAgLy8gcHVibGljIGZ1bmN0aW9uc1xuICAvKipcbiAgICAqIExpc3RlbnMgb24gYSBtdWx0aWFkZHJcbiAgICAqIEBwYXJhbSB7TXVsdGlhZGRyfSBtYVxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgKi9cbiAgbGlzdGVuIChtYSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLm1hID0gbWFcbiAgICB0aGlzLnNlcnZlciA9IGNsZWFuVXJsU0lPKG1hKVxuICAgIHRoaXMubGlzdGVuZXJzX2xpc3RbdGhpcy5zZXJ2ZXJdID0gdGhpc1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBvbmNlKGNhbGxiYWNrKSA6IG5vb3BcblxuICAgIGlmICh0aGlzLmNvbm5lY3RlZCkgeyAvLyBsaXN0ZW5lciB3YXMgLmNsb3NlKCknZCB5ZXQgbm90IGFsbCBjb25ucyBkaXNjb25uZWN0ZWQuIHdlJ3JlIHN0aWxsIGNvbm5lY3RlZCwgc28gZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgIHRoaXMuY2xvc2luZyA9IGZhbHNlXG4gICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKCkpXG4gICAgfVxuXG4gICAgc2VyaWVzKFtcbiAgICAgIChjYikgPT4gdGhpcy5fdXAoY2IpLFxuICAgICAgKGNiKSA9PiB0aGlzLl9jcnlwdG8oKGVyciwgaWdub3JlLCBwZWVycykgPT4gY2IoZXJyLCBwZWVycykpXG4gICAgXSwgKGVyciwgW2lnbm9yZSwgcGVlcnNdKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIEVycm9yIGNvbm5lY3RpbmcgdG8gV2ViU29ja2V0XG4gICAgICAgIGlmIChlcnIuZGVzY3JpcHRpb24gJiYgZXJyLmRlc2NyaXB0aW9uLmNvZGUgPT09ICdFTk9URk9VTkQnKSB7XG4gICAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBlcnIuZGVzY3JpcHRpb24uaG9zdG5hbWVcblxuICAgICAgICAgIGVyciA9IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGBXZWJTb2NrZXQgY29ubmVjdGlvbiBmYWlsZWQgb24gJHtob3N0bmFtZX1gKSwge1xuICAgICAgICAgICAgY29kZTogRVJST1JTLkVSUl9XU19TVEFSX1dFQlNPQ0tFVF9DT05ORUNUSU9OXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubG9nKCdlcnJvcicsIGVycilcbiAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSBlcnIgPSBuZXcgRXJyb3IoZXJyKVxuICAgICAgICB0aGlzLl9kb3duKClcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKCdzdWNjZXNzJylcbiAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZVxuXG4gICAgICB0aGlzLmlvLm9uKCdyZWNvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIC8vIGZvcmNlIHRvIGdldCBhIG5ldyBzaWduYXR1cmVcbiAgICAgICAgdGhpcy5zaWduYXR1cmUgPSBudWxsXG4gICAgICAgIHRoaXMuX2NyeXB0bygoZXJyLCBpZ25vcmUsIHJlY29ubmVjdFBlZXJzKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3JlY29ubmVjdCBlcnJvcicsIGVycilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdyZWNvbm5lY3RlZCcpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgKHJlY29ubmVjdFBlZXJzIHx8IFtdKSkge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3BlZXInLCBwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuZW1pdCgnbGlzdGVuaW5nJylcbiAgICAgIGZvciAoY29uc3QgcCBvZiAocGVlcnMgfHwgW10pKSB7XG4gICAgICAgIHRoaXMuZW1pdCgncGVlcicsIHApXG4gICAgICB9XG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgICogR2V0cyB0aGUgYWRkcmVzc2VzIHRoZSBsaXN0ZW5lciBsaXN0ZW5zIG9uXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAqL1xuICBnZXRBZGRycyAoY2FsbGJhY2spIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobnVsbCwgdGhpcy5tYSA/IFt0aGlzLm1hXSA6IFtdKSlcbiAgfVxuXG4gIGdldCBhY3RpdmVDb25uZWN0aW9ucyAoKSB7XG4gICAgdGhpcy5jb25ucyA9IHRoaXMuY29ubnMuZmlsdGVyKGMgPT4gYy5zaW5rIHx8IGMuc291cmNlKVxuICAgIHJldHVybiBCb29sZWFuKHRoaXMuY29ubnMubGVuZ3RoKVxuICB9XG5cbiAgbWF5YmVDbG9zZSAoKSB7XG4gICAgaWYgKCF0aGlzLmFjdGl2ZUNvbm5lY3Rpb25zICYmIHRoaXMuY2xvc2luZykge1xuICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgdGhpcy5jbG9zaW5nID0gZmFsc2VcbiAgICAgIHRoaXMubG9nKCdubyBtb3JlIGNvbm5lY3Rpb25zIGFuZCBsaXN0ZW5lciBpcyBvZmZsaW5lIC0gY2xvc2luZycpXG4gICAgICB0aGlzLl9kb3duKClcbiAgICB9XG4gIH1cblxuICBjbG9zZSAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gb25jZShjYWxsYmFjaykgOiBub29wXG5cbiAgICB0aGlzLmNsb3NpbmcgPSB0cnVlIC8vIHdpbGwgY2xvc2Ugb25jZSB0aGUgbGFzdCBjb25uZWN0aW9uIHF1aXRzXG4gICAgdGhpcy5tYXliZUNsb3NlKClcblxuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIHN0YXRlV2F0Y2ggKHNpbmssIHNvdXJjZSkge1xuICAgIGxldCBjc3RhdGUgPSB7IHNpbms6IHRydWUsIHNvdXJjZTogdHJ1ZSB9XG4gICAgY29uc3Qgd2F0Y2ggPSAobmFtZSkgPT4gdGhyb3VnaCh2ID0+IHYsIGUgPT4ge1xuICAgICAgY3N0YXRlW25hbWVdID0gZmFsc2VcbiAgICAgIGlmICghY3N0YXRlLnNpbmsgJiYgIWNzdGF0ZS5zb3VyY2UpIHtcbiAgICAgICAgdGhpcy5tYXliZUNsb3NlKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5jb25ucy5wdXNoKGNzdGF0ZSlcblxuICAgIHJldHVybiB7XG4gICAgICBzaW5rOiBwdWxsKFxuICAgICAgICB3YXRjaCgnc2luaycpLFxuICAgICAgICBzaW5rXG4gICAgICApLFxuICAgICAgc291cmNlOiBwdWxsKFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHdhdGNoKCdzb3VyY2UnKVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGxlZCBmcm9tIHRyYW5zcG9ydFxuICAvKipcbiAgICAqIERpYWxzIGEgcGVlclxuICAgICogQHBhcmFtIHtNdWx0aWFkZHJ9IG1hIC0gTXVsdGlhZGRyIHRvIGRpYWwgdG9cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAqL1xuICBkaWFsIChtYSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgY29uc3QgX21hID0gbXVsdGlhZGRyKG1hKVxuXG4gICAgY29uc3QgY29ubiA9IG5ldyBDb25uZWN0aW9uKG51bGwpXG5cbiAgICBjb25zdCBkaWFsSWQgPSB1dWlkKClcbiAgICBjb25zdCBkbG9nID0gdGhpcy5sb2cuYmluZChsb2csICdkaWFsIycgKyBkaWFsSWQpXG5cbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gb25jZShjYWxsYmFjaykgOiBub29wXG5cbiAgICBsZXQgaW8gPSB0aGlzLmlvXG5cbiAgICBpZiAoIWlvKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdOb3QgbGlzdGVuaW5nJykpXG4gICAgfVxuXG4gICAgY29uc3Qgc2luayA9IGlvLmNyZWF0ZVNpbmsoZGlhbElkICsgJy5kaWFsZXInKVxuXG4gICAgZGxvZygnZGlhbGluZycsIG1hLnRvU3RyaW5nKCkpXG5cbiAgICAvLyBcIm11bHRpYWRkclwiLCBcIm11bHRpYWRkclwiLCBcInN0cmluZ1wiLCBcImZ1bmN0aW9uXCIgLSBkaWFsRnJvbSwgZGlhbFRvLCBkaWFsSWQsIGNiXG4gICAgaW8uZW1pdCgnc3MtZGlhbCcsIHRoaXMubWEudG9TdHJpbmcoKSwgbWEudG9TdHJpbmcoKSwgZGlhbElkLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKGVycikpXG4gICAgICBkbG9nKGVyciA/ICdlcnJvcjogJyArIGVyci50b1N0cmluZygpIDogJ3N1Y2Nlc3MnKVxuICAgICAgY29uc3Qgc291cmNlID0gaW8uY3JlYXRlU291cmNlKGRpYWxJZCArICcubGlzdGVuZXInKVxuXG4gICAgICBjb25uLnNldElubmVyQ29ubih0aGlzLnN0YXRlV2F0Y2goc2luaywgc291cmNlKSwgeyBnZXRPYnNlcnZlZEFkZHJzOiAoY2IpID0+IGNiKG51bGwsIFtfbWFdKSB9KVxuICAgICAgY2FsbGJhY2sobnVsbCwgY29ubilcbiAgICB9KVxuXG4gICAgcmV0dXJuIGNvbm5cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RlbmVyXG4iLCIvLyBvcmlnaW5hbGx5IHB1bGxlZCBvdXQgb2Ygc2ltcGxlLXBlZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRCcm93c2VyUlRDICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbFxuICB2YXIgd3J0YyA9IHtcbiAgICBSVENQZWVyQ29ubmVjdGlvbjogd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbiB8fFxuICAgICAgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLFxuICAgIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbjogd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fFxuICAgICAgd2luZG93Lm1velJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fCB3aW5kb3cud2Via2l0UlRDU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICAgIFJUQ0ljZUNhbmRpZGF0ZTogd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cubW96UlRDSWNlQ2FuZGlkYXRlIHx8XG4gICAgICB3aW5kb3cud2Via2l0UlRDSWNlQ2FuZGlkYXRlXG4gIH1cbiAgaWYgKCF3cnRjLlJUQ1BlZXJDb25uZWN0aW9uKSByZXR1cm4gbnVsbFxuICByZXR1cm4gd3J0Y1xufVxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbmV4cG9ydHMuZmluaXNoZWQgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMnKTtcbmV4cG9ydHMucGlwZWxpbmUgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzJyk7XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdXJsICh1cmksIGxvYykge1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIGxvYyA9IGxvYyB8fCAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBsb2NhdGlvbik7XG4gIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXG4gIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDApKSB7XG4gICAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDEpKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9IGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHZhciBob3N0ID0gaXB2NiA/ICdbJyArIG9iai5ob3N0ICsgJ10nIDogb2JqLmhvc3Q7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJ3RvLWFycmF5Jyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaGFzQmluID0gcmVxdWlyZSgnaGFzLWJpbmFyeTInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZXZlbnRzID0ge1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBjb25uZWN0X3RpbWVvdXQ6IDEsXG4gIGNvbm5lY3Rpbmc6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGVycm9yOiAxLFxuICByZWNvbm5lY3Q6IDEsXG4gIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuICByZWNvbm5lY3RfZXJyb3I6IDEsXG4gIHJlY29ubmVjdGluZzogMSxcbiAgcGluZzogMSxcbiAgcG9uZzogMVxufTtcblxuLyoqXG4gKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQgKGlvLCBuc3AsIG9wdHMpIHtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmZsYWdzID0ge307XG4gIGlmIChvcHRzICYmIG9wdHMucXVlcnkpIHtcbiAgICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgfVxuICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cbiAgdmFyIGlvID0gdGhpcy5pbztcbiAgdGhpcy5zdWJzID0gW1xuICAgIG9uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSxcbiAgICBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLFxuICAgIG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXG4gIF07XG59O1xuXG4vKipcbiAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vcGVuID1cblNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICBpZiAoIXRoaXMuaW8ucmVjb25uZWN0aW5nKSB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldikpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiAodGhpcy5mbGFncy5iaW5hcnkgIT09IHVuZGVmaW5lZCA/IHRoaXMuZmxhZ3MuYmluYXJ5IDogaGFzQmluKGFyZ3MpKSA/IHBhcnNlci5CSU5BUllfRVZFTlQgOiBwYXJzZXIuRVZFTlQsXG4gICAgZGF0YTogYXJnc1xuICB9O1xuXG4gIHBhY2tldC5vcHRpb25zID0ge307XG4gIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgdGhpcy5mbGFncyA9IHt9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cbiAgLy8gd3JpdGUgY29ubmVjdCBwYWNrZXQgaWYgbmVjZXNzYXJ5XG4gIGlmICgnLycgIT09IHRoaXMubnNwKSB7XG4gICAgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgIHZhciBxdWVyeSA9IHR5cGVvZiB0aGlzLnF1ZXJ5ID09PSAnb2JqZWN0JyA/IHBhcnNlcXMuZW5jb2RlKHRoaXMucXVlcnkpIDogdGhpcy5xdWVyeTtcbiAgICAgIGRlYnVnKCdzZW5kaW5nIGNvbm5lY3QgcGFja2V0IHdpdGggcXVlcnkgJXMnLCBxdWVyeSk7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1QsIHF1ZXJ5OiBxdWVyeX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1R9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBwYWNrZXQubnNwID09PSB0aGlzLm5zcDtcbiAgdmFyIHJvb3ROYW1lc3BhY2VFcnJvciA9IHBhY2tldC50eXBlID09PSBwYXJzZXIuRVJST1IgJiYgcGFja2V0Lm5zcCA9PT0gJy8nO1xuXG4gIGlmICghc2FtZU5hbWVzcGFjZSAmJiAhcm9vdE5hbWVzcGFjZUVycm9yKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICBkZWJ1ZygnZW1pdHRpbmcgZXZlbnQgJWonLCBhcmdzKTtcblxuICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICBkZWJ1ZygnYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudCcpO1xuICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzZW50ID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IGhhc0JpbihhcmdzKSA/IHBhcnNlci5CSU5BUllfQUNLIDogcGFyc2VyLkFDSyxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGRhdGE6IGFyZ3NcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFjaykge1xuICAgIGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gICAgYWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICBkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ2JhZCBhY2sgJXMnLCBwYWNrZXQuaWQpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xufTtcblxuLyoqXG4gKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzZXJ2ZXIgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICogdGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgbWFuYWdlciBzdG9wcyB0cmFja2luZyB1cyBhbmRcbiAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZS5cbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1YnMpIHtcbiAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgLy8gZmlyZSBldmVudHNcbiAgICB0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbiAoY29tcHJlc3MpIHtcbiAgdGhpcy5mbGFncy5jb21wcmVzcyA9IGNvbXByZXNzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgYmluYXJ5IGZsYWdcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgdGhlIGVtaXR0ZWQgZGF0YSBjb250YWlucyBiaW5hcnlcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmJpbmFyeSA9IGZ1bmN0aW9uIChiaW5hcnkpIHtcbiAgdGhpcy5mbGFncy5iaW5hcnkgPSBiaW5hcnk7XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLFxuICAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsXG4gICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJyxcbiAgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLFxuICAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsXG4gICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJyxcbiAgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLFxuICAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsXG4gICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJyxcbiAgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLFxuICAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdBQ0snLFxuICAnRVJST1InLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0JJTkFSWV9BQ0snXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG52YXIgRVJST1JfUEFDS0VUID0gZXhwb3J0cy5FUlJPUiArICdcImVuY29kZSBlcnJvclwiJztcblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG5cbiAgLy8gZmlyc3QgaXMgdHlwZVxuICB2YXIgc3RyID0gJycgKyBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cyArICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPT0gb2JqLm5zcCkge1xuICAgIHN0ciArPSBvYmoubnNwICsgJywnO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHRyeVN0cmluZ2lmeShvYmouZGF0YSk7XG4gICAgaWYgKHBheWxvYWQgIT09IGZhbHNlKSB7XG4gICAgICBzdHIgKz0gcGF5bG9hZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVSUk9SX1BBQ0tFVDtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gdHJ5U3RyaW5naWZ5KHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVuY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHBhY2tldCA9IGRlY29kZVN0cmluZyhvYmopO1xuICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIGkgPSAwO1xuICAvLyBsb29rIHVwIHR5cGVcbiAgdmFyIHAgPSB7XG4gICAgdHlwZTogTnVtYmVyKHN0ci5jaGFyQXQoMCkpXG4gIH07XG5cbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSB7XG4gICAgcmV0dXJuIGVycm9yKCd1bmtub3duIHBhY2tldCB0eXBlICcgKyBwLnR5cGUpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHAudHlwZSkge1xuICAgIHZhciBzdGFydCA9IGkgKyAxO1xuICAgIHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT09ICctJyAmJiBpICE9IHN0ci5sZW5ndGgpIHt9XG4gICAgdmFyIGJ1ZiA9IHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkpO1xuICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPT0gJy0nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXR0YWNobWVudHMnKTtcbiAgICB9XG4gICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcbiAgaWYgKCcvJyA9PT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICB2YXIgc3RhcnQgPSBpICsgMTtcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09PSBjKSBicmVhaztcbiAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgcC5uc3AgPSBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcbiAgfSBlbHNlIHtcbiAgICBwLm5zcCA9ICcvJztcbiAgfVxuXG4gIC8vIGxvb2sgdXAgaWRcbiAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgdmFyIHN0YXJ0ID0gaSArIDE7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkgKyAxKSk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgdmFyIHBheWxvYWQgPSB0cnlQYXJzZShzdHIuc3Vic3RyKGkpKTtcbiAgICB2YXIgaXNQYXlsb2FkVmFsaWQgPSBwYXlsb2FkICE9PSBmYWxzZSAmJiAocC50eXBlID09PSBleHBvcnRzLkVSUk9SIHx8IGlzQXJyYXkocGF5bG9hZCkpO1xuICAgIGlmIChpc1BheWxvYWRWYWxpZCkge1xuICAgICAgcC5kYXRhID0gcGF5bG9hZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVycm9yKCdpbnZhbGlkIHBheWxvYWQnKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiB0cnlQYXJzZShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7IC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgIHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGJpbmFyeSBwYWNrZXQgcmVjb25zdHJ1Y3Rpb24gdmFyaWFibGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuRVJST1IsXG4gICAgZGF0YTogJ3BhcnNlciBlcnJvcjogJyArIG1zZ1xuICB9O1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGVpbyA9IHJlcXVpcmUoJ2VuZ2luZS5pby1jbGllbnQnKTtcbnZhciBTb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6bWFuYWdlcicpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgQmFja29mZiA9IHJlcXVpcmUoJ2JhY2tvMicpO1xuXG4vKipcbiAqIElFNisgaGFzT3duUHJvcGVydHlcbiAqL1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlcjtcblxuLyoqXG4gKiBgTWFuYWdlcmAgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVuZ2luZSBpbnN0YW5jZSBvciBlbmdpbmUgdXJpL29wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1hbmFnZXIgKHVyaSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFuYWdlcikpIHJldHVybiBuZXcgTWFuYWdlcih1cmksIG9wdHMpO1xuICBpZiAodXJpICYmICgnb2JqZWN0JyA9PT0gdHlwZW9mIHVyaSkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuICB0aGlzLm5zcHMgPSB7fTtcbiAgdGhpcy5zdWJzID0gW107XG4gIHRoaXMub3B0cyA9IG9wdHM7XG4gIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG4gIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuICB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3Iob3B0cy5yYW5kb21pemF0aW9uRmFjdG9yIHx8IDAuNSk7XG4gIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG4gIH0pO1xuICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLnVyaSA9IHVyaTtcbiAgdGhpcy5jb25uZWN0aW5nID0gW107XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHZhciBfcGFyc2VyID0gb3B0cy5wYXJzZXIgfHwgcGFyc2VyO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgX3BhcnNlci5FbmNvZGVyKCk7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBfcGFyc2VyLkRlY29kZXIoKTtcbiAgdGhpcy5hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuICBpZiAodGhpcy5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogUHJvcGFnYXRlIGdpdmVuIGV2ZW50IHRvIHNvY2tldHMgYW5kIGVtaXQgb24gYHRoaXNgXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZW1pdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5lbWl0LmFwcGx5KHRoaXMubnNwc1tuc3BdLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgYHNvY2tldC5pZGAgb2YgYWxsIHNvY2tldHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTb2NrZXRJZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5pZCA9IHRoaXMuZ2VuZXJhdGVJZChuc3ApO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBnZW5lcmF0ZSBgc29ja2V0LmlkYCBmb3IgdGhlIGdpdmVuIGBuc3BgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5zcFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uIChuc3ApIHtcbiAgcmV0dXJuIChuc3AgPT09ICcvJyA/ICcnIDogKG5zcCArICcjJykpICsgdGhpcy5lbmdpbmUuaWQ7XG59O1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3RcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uO1xuICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIGJlZm9yZSBnaXZpbmcgdXBcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheSA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yO1xuICB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXhpbXVtIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXlNYXggPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heDtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1heCh2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbm5lY3Rpb24gdGltZW91dC4gYGZhbHNlYCB0byBkaXNhYmxlXG4gKlxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgdGhpcy5fdGltZW91dCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24gKCkge1xuICAvLyBPbmx5IHRyeSB0byByZWNvbm5lY3QgaWYgaXQncyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBjb25uZWN0aW5nXG4gIGlmICghdGhpcy5yZWNvbm5lY3RpbmcgJiYgdGhpcy5fcmVjb25uZWN0aW9uICYmIHRoaXMuYmFja29mZi5hdHRlbXB0cyA9PT0gMCkge1xuICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3BcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbmFsLCBjYWxsYmFja1xuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vcGVuID1cbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoZm4sIG9wdHMpIHtcbiAgZGVidWcoJ3JlYWR5U3RhdGUgJXMnLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAofnRoaXMucmVhZHlTdGF0ZS5pbmRleE9mKCdvcGVuJykpIHJldHVybiB0aGlzO1xuXG4gIGRlYnVnKCdvcGVuaW5nICVzJywgdGhpcy51cmkpO1xuICB0aGlzLmVuZ2luZSA9IGVpbyh0aGlzLnVyaSwgdGhpcy5vcHRzKTtcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG5cbiAgLy8gZW1pdCBgb3BlbmBcbiAgdmFyIG9wZW5TdWIgPSBvbihzb2NrZXQsICdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25vcGVuKCk7XG4gICAgZm4gJiYgZm4oKTtcbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF9lcnJvcmBcbiAgdmFyIGVycm9yU3ViID0gb24oc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRlYnVnKCdjb25uZWN0X2Vycm9yJyk7XG4gICAgc2VsZi5jbGVhbnVwKCk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X2Vycm9yJywgZGF0YSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGVycm9yJyk7XG4gICAgICBlcnIuZGF0YSA9IGRhdGE7XG4gICAgICBmbihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgc2VsZi5tYXliZVJlY29ubmVjdE9uT3BlbigpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF90aW1lb3V0YFxuICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblxuICAgIGlmICh0aW1lb3V0ID09PSAwKSB7XG4gICAgICBvcGVuU3ViLmRlc3Ryb3koKTsgLy8gcHJldmVudHMgYSByYWNlIGNvbmRpdGlvbiB3aXRoIHRoZSAnb3BlbicgZXZlbnRcbiAgICB9XG5cbiAgICAvLyBzZXQgdGltZXJcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgdGltZWQgb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG4gICAgICBvcGVuU3ViLmRlc3Ryb3koKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgJ3RpbWVvdXQnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF90aW1lb3V0JywgdGltZW91dCk7XG4gICAgfSwgdGltZW91dCk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLnN1YnMucHVzaChvcGVuU3ViKTtcbiAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdvcGVuJyk7XG5cbiAgLy8gY2xlYXIgb2xkIHN1YnNcbiAgdGhpcy5jbGVhbnVwKCk7XG5cbiAgLy8gbWFyayBhcyBvcGVuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cbiAgLy8gYWRkIG5ldyBzdWJzXG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZGF0YScsIGJpbmQodGhpcywgJ29uZGF0YScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BpbmcnLCBiaW5kKHRoaXMsICdvbnBpbmcnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwb25nJywgYmluZCh0aGlzLCAnb25wb25nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZXJyb3InLCBiaW5kKHRoaXMsICdvbmVycm9yJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24odGhpcy5kZWNvZGVyLCAnZGVjb2RlZCcsIGJpbmQodGhpcywgJ29uZGVjb2RlZCcpKSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGluZy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGFzdFBpbmcgPSBuZXcgRGF0ZSgpO1xuICB0aGlzLmVtaXRBbGwoJ3BpbmcnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25wb25nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXRBbGwoJ3BvbmcnLCBuZXcgRGF0ZSgpIC0gdGhpcy5sYXN0UGluZyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNvY2tldCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICB0aGlzLmVtaXRBbGwoJ2Vycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uIChuc3AsIG9wdHMpIHtcbiAgdmFyIHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICBpZiAoIXNvY2tldCkge1xuICAgIHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwLCBvcHRzKTtcbiAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0aW5nJywgb25Db25uZWN0aW5nKTtcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzb2NrZXQuaWQgPSBzZWxmLmdlbmVyYXRlSWQobnNwKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmF1dG9Db25uZWN0KSB7XG4gICAgICAvLyBtYW51YWxseSBjYWxsIGhlcmUgc2luY2UgY29ubmVjdGluZyBldmVudCBpcyBmaXJlZCBiZWZvcmUgbGlzdGVuaW5nXG4gICAgICBvbkNvbm5lY3RpbmcoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbm5lY3RpbmcgKCkge1xuICAgIGlmICghfmluZGV4T2Yoc2VsZi5jb25uZWN0aW5nLCBzb2NrZXQpKSB7XG4gICAgICBzZWxmLmNvbm5lY3RpbmcucHVzaChzb2NrZXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb2NrZXQ7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc29ja2V0IGNsb3NlLlxuICpcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHNvY2tldCkge1xuICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMuY29ubmVjdGluZywgc29ja2V0KTtcbiAgaWYgKH5pbmRleCkgdGhpcy5jb25uZWN0aW5nLnNwbGljZShpbmRleCwgMSk7XG4gIGlmICh0aGlzLmNvbm5lY3RpbmcubGVuZ3RoKSByZXR1cm47XG5cbiAgdGhpcy5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBkZWJ1Zygnd3JpdGluZyBwYWNrZXQgJWonLCBwYWNrZXQpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChwYWNrZXQucXVlcnkgJiYgcGFja2V0LnR5cGUgPT09IDApIHBhY2tldC5uc3AgKz0gJz8nICsgcGFja2V0LnF1ZXJ5O1xuXG4gIGlmICghc2VsZi5lbmNvZGluZykge1xuICAgIC8vIGVuY29kZSwgdGhlbiB3cml0ZSB0byBlbmdpbmUgd2l0aCByZXN1bHRcbiAgICBzZWxmLmVuY29kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCwgZnVuY3Rpb24gKGVuY29kZWRQYWNrZXRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldLCBwYWNrZXQub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBzZWxmLmVuY29kaW5nID0gZmFsc2U7XG4gICAgICBzZWxmLnByb2Nlc3NQYWNrZXRRdWV1ZSgpO1xuICAgIH0pO1xuICB9IGVsc2UgeyAvLyBhZGQgcGFja2V0IHRvIHRoZSBxdWV1ZVxuICAgIHNlbGYucGFja2V0QnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBJZiBwYWNrZXQgYnVmZmVyIGlzIG5vbi1lbXB0eSwgYmVnaW5zIGVuY29kaW5nIHRoZVxuICogbmV4dCBwYWNrZXQgaW4gbGluZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUGFja2V0UXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBhY2tldEJ1ZmZlci5sZW5ndGggPiAwICYmICF0aGlzLmVuY29kaW5nKSB7XG4gICAgdmFyIHBhY2sgPSB0aGlzLnBhY2tldEJ1ZmZlci5zaGlmdCgpO1xuICAgIHRoaXMucGFja2V0KHBhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIHRyYW5zcG9ydCBzdWJzY3JpcHRpb25zIGFuZCBwYWNrZXQgYnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG5cbiAgdmFyIHN1YnNMZW5ndGggPSB0aGlzLnN1YnMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNMZW5ndGg7IGkrKykge1xuICAgIHZhciBzdWIgPSB0aGlzLnN1YnMuc2hpZnQoKTtcbiAgICBzdWIuZGVzdHJveSgpO1xuICB9XG5cbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcblxuICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xufTtcblxuLyoqXG4gKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPVxuTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2Rpc2Nvbm5lY3QnKTtcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gYG9uY2xvc2VgIHdpbGwgbm90IGZpcmUgYmVjYXVzZVxuICAgIC8vIGFuIG9wZW4gZXZlbnQgbmV2ZXIgaGFwcGVuZWRcbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIGlmICh0aGlzLmVuZ2luZSkgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gIGRlYnVnKCdvbmNsb3NlJyk7XG5cbiAgdGhpcy5jbGVhbnVwKCk7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbik7XG5cbiAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucmVjb25uZWN0aW5nIHx8IHRoaXMuc2tpcFJlY29ubmVjdCkgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPj0gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMpIHtcbiAgICBkZWJ1ZygncmVjb25uZWN0IGZhaWxlZCcpO1xuICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0X2ZhaWxlZCcpO1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlbGF5ID0gdGhpcy5iYWNrb2ZmLmR1cmF0aW9uKCk7XG4gICAgZGVidWcoJ3dpbGwgd2FpdCAlZG1zIGJlZm9yZSByZWNvbm5lY3QgYXR0ZW1wdCcsIGRlbGF5KTtcblxuICAgIHRoaXMucmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgZGVidWcoJ2F0dGVtcHRpbmcgcmVjb25uZWN0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9hdHRlbXB0Jywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0aW5nJywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcblxuICAgICAgLy8gY2hlY2sgYWdhaW4gZm9yIHRoZSBjYXNlIHNvY2tldCBjbG9zZWQgaW4gYWJvdmUgZXZlbnRzXG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIHNlbGYub3BlbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IGF0dGVtcHQgZXJyb3InKTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0KCk7XG4gICAgICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfZXJyb3InLCBlcnIuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBzdWNjZXNzJyk7XG4gICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBkZWxheSk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZWNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcbiAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3QnLCBhdHRlbXB0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRyeUVhY2g7XG5cbnZhciBfbm9vcCA9IHJlcXVpcmUoJ2xvZGFzaC9ub29wJyk7XG5cbnZhciBfbm9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub29wKTtcblxudmFyIF9lYWNoU2VyaWVzID0gcmVxdWlyZSgnLi9lYWNoU2VyaWVzJyk7XG5cbnZhciBfZWFjaFNlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoU2VyaWVzKTtcblxudmFyIF93cmFwQXN5bmMgPSByZXF1aXJlKCcuL2ludGVybmFsL3dyYXBBc3luYycpO1xuXG52YXIgX3dyYXBBc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93cmFwQXN5bmMpO1xuXG52YXIgX3NsaWNlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zbGljZScpO1xuXG52YXIgX3NsaWNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NsaWNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBJdCBydW5zIGVhY2ggdGFzayBpbiBzZXJpZXMgYnV0IHN0b3BzIHdoZW5ldmVyIGFueSBvZiB0aGUgZnVuY3Rpb25zIHdlcmVcbiAqIHN1Y2Nlc3NmdWwuIElmIG9uZSBvZiB0aGUgdGFza3Mgd2VyZSBzdWNjZXNzZnVsLCB0aGUgYGNhbGxiYWNrYCB3aWxsIGJlXG4gKiBwYXNzZWQgdGhlIHJlc3VsdCBvZiB0aGUgc3VjY2Vzc2Z1bCB0YXNrLiBJZiBhbGwgdGFza3MgZmFpbCwgdGhlIGNhbGxiYWNrXG4gKiB3aWxsIGJlIHBhc3NlZCB0aGUgZXJyb3IgYW5kIHJlc3VsdCAoaWYgYW55KSBvZiB0aGUgZmluYWwgYXR0ZW1wdC5cbiAqXG4gKiBAbmFtZSB0cnlFYWNoXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gY29udGFpbmluZyBmdW5jdGlvbnMgdG9cbiAqIHJ1biwgZWFjaCBmdW5jdGlvbiBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCByZXN1bHQpYCBpdCBtdXN0IGNhbGwgb25cbiAqIGNvbXBsZXRpb24gd2l0aCBhbiBlcnJvciBgZXJyYCAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIGFuIG9wdGlvbmFsIGByZXN1bHRgXG4gKiB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBvbmVcbiAqIG9mIHRoZSB0YXNrcyBoYXMgc3VjY2VlZGVkLCBvciBhbGwgaGF2ZSBmYWlsZWQuIEl0IHJlY2VpdmVzIHRoZSBgZXJyYCBhbmRcbiAqIGByZXN1bHRgIGFyZ3VtZW50cyBvZiB0aGUgbGFzdCBhdHRlbXB0IGF0IGNvbXBsZXRpbmcgdGhlIGB0YXNrYC4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHRzKS5cbiAqIEBleGFtcGxlXG4gKiBhc3luYy50cnlFYWNoKFtcbiAqICAgICBmdW5jdGlvbiBnZXREYXRhRnJvbUZpcnN0V2Vic2l0ZShjYWxsYmFjaykge1xuICogICAgICAgICAvLyBUcnkgZ2V0dGluZyB0aGUgZGF0YSBmcm9tIHRoZSBmaXJzdCB3ZWJzaXRlXG4gKiAgICAgICAgIGNhbGxiYWNrKGVyciwgZGF0YSk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbiBnZXREYXRhRnJvbVNlY29uZFdlYnNpdGUoY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gRmlyc3Qgd2Vic2l0ZSBmYWlsZWQsXG4gKiAgICAgICAgIC8vIFRyeSBnZXR0aW5nIHRoZSBkYXRhIGZyb20gdGhlIGJhY2t1cCB3ZWJzaXRlXG4gKiAgICAgICAgIGNhbGxiYWNrKGVyciwgZGF0YSk7XG4gKiAgICAgfVxuICogXSxcbiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBOb3cgZG8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuXG4gKiB9KTtcbiAqXG4gKi9cbmZ1bmN0aW9uIHRyeUVhY2godGFza3MsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgX25vb3AyLmRlZmF1bHQ7XG4gICAgKDAsIF9lYWNoU2VyaWVzMi5kZWZhdWx0KSh0YXNrcywgZnVuY3Rpb24gKHRhc2ssIGNhbGxiYWNrKSB7XG4gICAgICAgICgwLCBfd3JhcEFzeW5jMi5kZWZhdWx0KSh0YXNrKShmdW5jdGlvbiAoZXJyLCByZXMgLyosIC4uLmFyZ3MqLykge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKDAsIF9zbGljZTIuZGVmYXVsdCkoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICBjYWxsYmFjayghZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vcHVsbCcpXG5jb25zdCBoYW5kc2hha2UgPSByZXF1aXJlKCdwdWxsLWhhbmRzaGFrZScpXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBQUk9UT0NPTCA9IGNvbnN0YW50cy5QUk9UT0NPTFxuY29uc3QgUElOR19MRU5HVEggPSBjb25zdGFudHMuUElOR19MRU5HVEhcblxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBsb2cgPSBkZWJ1ZygnbGlicDJwLXBpbmcnKVxubG9nLmVycm9yID0gZGVidWcoJ2xpYnAycC1waW5nOmVycm9yJylcblxuZnVuY3Rpb24gbW91bnQgKHN3YXJtKSB7XG4gIHN3YXJtLmhhbmRsZShQUk9UT0NPTCwgKHByb3RvY29sLCBjb25uKSA9PiB7XG4gICAgY29uc3Qgc3RyZWFtID0gaGFuZHNoYWtlKHsgdGltZW91dDogMCB9KVxuICAgIGNvbnN0IHNoYWtlID0gc3RyZWFtLmhhbmRzaGFrZVxuXG4gICAgLy8gcmVjZWl2ZSBhbmQgZWNobyBiYWNrXG4gICAgZnVuY3Rpb24gbmV4dCAoKSB7XG4gICAgICBzaGFrZS5yZWFkKFBJTkdfTEVOR1RILCAoZXJyLCBidWYpID0+IHtcbiAgICAgICAgaWYgKGVyciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHN0cmVhbSBjbG9zZWRcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGxvZy5lcnJvcihlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBzaGFrZS53cml0ZShidWYpXG4gICAgICAgIHJldHVybiBuZXh0KClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcHVsbChcbiAgICAgIGNvbm4sXG4gICAgICBzdHJlYW0sXG4gICAgICBjb25uXG4gICAgKVxuXG4gICAgbmV4dCgpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHVubW91bnQgKHN3YXJtKSB7XG4gIHN3YXJtLnVuaGFuZGxlKFBST1RPQ09MKVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHNcbmV4cG9ydHMubW91bnQgPSBtb3VudFxuZXhwb3J0cy51bm1vdW50ID0gdW5tb3VudFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3B1bGwnKVxuY29uc3QgZW1wdHkgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9zb3VyY2VzL2VtcHR5JylcbmNvbnN0IGhhbmRzaGFrZSA9IHJlcXVpcmUoJ3B1bGwtaGFuZHNoYWtlJylcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3Qgcm5kID0gdXRpbC5ybmRcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycC1waW5nJylcbmxvZy5lcnJvciA9IGRlYnVnKCdsaWJwMnAtcGluZzplcnJvcicpXG5cbmNvbnN0IFBST1RPQ09MID0gY29uc3RhbnRzLlBST1RPQ09MXG5jb25zdCBQSU5HX0xFTkdUSCA9IGNvbnN0YW50cy5QSU5HX0xFTkdUSFxuXG5jbGFzcyBQaW5nIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKHN3YXJtLCBwZWVyKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlXG4gICAgdGhpcy5wZWVyID0gcGVlclxuICAgIHRoaXMuc3dhcm0gPSBzd2FybVxuICB9XG5cbiAgc3RhcnQgKCkge1xuICAgIGxvZygnZGlhbGluZyAlcyB0byAlcycsIFBST1RPQ09MLCB0aGlzLnBlZXIuaWQudG9CNThTdHJpbmcoKSlcblxuICAgIHRoaXMuc3dhcm0uZGlhbCh0aGlzLnBlZXIsIFBST1RPQ09MLCAoZXJyLCBjb25uKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzdHJlYW0gPSBoYW5kc2hha2UoeyB0aW1lb3V0OiAwIH0pXG4gICAgICB0aGlzLnNoYWtlID0gc3RyZWFtLmhhbmRzaGFrZVxuXG4gICAgICBwdWxsKFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIGNvbm4sXG4gICAgICAgIHN0cmVhbVxuICAgICAgKVxuXG4gICAgICAvLyB3cml0ZSBhbmQgd2FpdCB0byBzZWUgcGluZyBiYWNrXG4gICAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgICAgZnVuY3Rpb24gbmV4dCAoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IG5ldyBEYXRlKClcbiAgICAgICAgbGV0IGJ1ZiA9IHJuZChQSU5HX0xFTkdUSClcbiAgICAgICAgc2VsZi5zaGFrZS53cml0ZShidWYpXG4gICAgICAgIHNlbGYuc2hha2UucmVhZChQSU5HX0xFTkdUSCwgKGVyciwgYnVmQmFjaykgPT4ge1xuICAgICAgICAgIGxldCBlbmQgPSBuZXcgRGF0ZSgpXG4gICAgICAgICAgaWYgKGVyciB8fCAhYnVmLmVxdWFscyhidWZCYWNrKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdSZWNlaXZlZCB3cm9uZyBwaW5nIGFjaycpXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLmVtaXQoJ3BpbmcnLCBlbmQgLSBzdGFydClcblxuICAgICAgICAgIGlmIChzZWxmLl9zdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dCgpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIG5leHQoKVxuICAgIH0pXG4gIH1cblxuICBzdG9wICgpIHtcbiAgICBpZiAodGhpcy5fc3RvcHBlZCB8fCAhdGhpcy5zaGFrZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fc3RvcHBlZCA9IHRydWVcblxuICAgIHB1bGwoXG4gICAgICBlbXB0eSgpLFxuICAgICAgdGhpcy5zaGFrZS5yZXN0KClcbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQaW5nXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtJylcbmNvbnN0IGxwID0gcmVxdWlyZSgncHVsbC1sZW5ndGgtcHJlZml4ZWQnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxuY29uc3QgQmFzZVByb3RvY29sID0gcmVxdWlyZSgnbGlicDJwLXB1YnN1YicpXG5jb25zdCB7IG1lc3NhZ2UsIHV0aWxzIH0gPSByZXF1aXJlKCdsaWJwMnAtcHVic3ViJylcbmNvbnN0IGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJylcblxuY29uc3QgbXVsdGljb2RlYyA9IGNvbmZpZy5tdWx0aWNvZGVjXG5jb25zdCBlbnN1cmVBcnJheSA9IHV0aWxzLmVuc3VyZUFycmF5XG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuY29uc3QgYXN5bmNNYXAgPSByZXF1aXJlKCdhc3luYy9tYXAnKVxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbi8qKlxuICogRmxvb2RTdWIgKGFrYSBkdW1ic3ViIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHB1YnN1YiBmb2N1c2VkIG9uXG4gKiBkZWxpdmVyaW5nIGFuIEFQSSBmb3IgUHVibGlzaC9TdWJzY3JpYmUsIGJ1dCB3aXRoIG5vIENhc3RUcmVlIEZvcm1pbmdcbiAqIChpdCBqdXN0IGZsb29kcyB0aGUgbmV0d29yaykuXG4gKi9cbmNsYXNzIEZsb29kU3ViIGV4dGVuZHMgQmFzZVByb3RvY29sIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsaWJwMnBcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobGlicDJwKSB7XG4gICAgc3VwZXIoJ2xpYnAycDpmbG9vZHN1YicsIG11bHRpY29kZWMsIGxpYnAycClcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2Ygb3VyIHN1YnNjcmlwdGlvbnNcbiAgICAgKiBAdHlwZSB7U2V0PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFNldCgpXG4gIH1cblxuICAvKipcbiAgICogRGlhbCBhIHJlY2VpdmVkIHBlZXIuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge1BlZXJJbmZvfSBwZWVySW5mbyBwZWVyIGluZm9cbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIGNvbm5lY3Rpb24gdG8gdGhlIHBlZXJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIF9vbkRpYWwgKHBlZXJJbmZvLCBjb25uLCBjYWxsYmFjaykge1xuICAgIHN1cGVyLl9vbkRpYWwocGVlckluZm8sIGNvbm4sIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBjb25zdCBpZEI1OFN0ciA9IHBlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKClcbiAgICAgIGNvbnN0IHBlZXIgPSB0aGlzLnBlZXJzLmdldChpZEI1OFN0cilcbiAgICAgIGlmIChwZWVyICYmIHBlZXIuaXNXcml0YWJsZSkge1xuICAgICAgICAvLyBJbW1lZGlhdGVseSBzZW5kIG15IG93biBzdWJzY3JpcHRpb25zIHRvIHRoZSBuZXdseSBlc3RhYmxpc2hlZCBjb25uXG4gICAgICAgIHBlZXIuc2VuZFN1YnNjcmlwdGlvbnModGhpcy5zdWJzY3JpcHRpb25zKVxuICAgICAgfVxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKCkpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkaW5nIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBfcHJvY2Vzc0Nvbm5lY3Rpb24gc2hvdWxkIGtlZXAgdGhlIGNvbm5lY3Rpb24gYW5kIGlzXG4gICAqIHJlc3BvbnNpYmxlIGZvciBwcm9jZXNzaW5nIGVhY2ggUlBDIG1lc3NhZ2UgcmVjZWl2ZWQgYnkgb3RoZXIgcGVlcnMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRCNThTdHIgcGVlciBpZCBzdHJpbmcgaW4gYmFzZTU4XG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7UGVlckluZm99IHBlZXIgcGVlciBpbmZvXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqXG4gICAqL1xuICBfcHJvY2Vzc0Nvbm5lY3Rpb24gKGlkQjU4U3RyLCBjb25uLCBwZWVyKSB7XG4gICAgcHVsbChcbiAgICAgIGNvbm4sXG4gICAgICBscC5kZWNvZGUoKSxcbiAgICAgIHB1bGwubWFwKChkYXRhKSA9PiBtZXNzYWdlLnJwYy5SUEMuZGVjb2RlKGRhdGEpKSxcbiAgICAgIHB1bGwuZHJhaW4oXG4gICAgICAgIChycGMpID0+IHRoaXMuX29uUnBjKGlkQjU4U3RyLCBycGMpLFxuICAgICAgICAoZXJyKSA9PiB0aGlzLl9vbkNvbm5lY3Rpb25FbmQoaWRCNThTdHIsIHBlZXIsIGVycilcbiAgICAgIClcbiAgICApXG4gIH1cblxuICBfb25ScGMgKGlkQjU4U3RyLCBycGMpIHtcbiAgICBpZiAoIXJwYykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5sb2coJ3JwYyBmcm9tJywgaWRCNThTdHIpXG4gICAgY29uc3Qgc3VicyA9IHJwYy5zdWJzY3JpcHRpb25zXG4gICAgY29uc3QgbXNncyA9IHJwYy5tc2dzXG5cbiAgICBpZiAobXNncyAmJiBtc2dzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fcHJvY2Vzc1JwY01lc3NhZ2VzKHV0aWxzLm5vcm1hbGl6ZUluUnBjTWVzc2FnZXMocnBjLm1zZ3MpKVxuICAgIH1cblxuICAgIGlmIChzdWJzICYmIHN1YnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwZWVyID0gdGhpcy5wZWVycy5nZXQoaWRCNThTdHIpXG4gICAgICBpZiAocGVlcikge1xuICAgICAgICBwZWVyLnVwZGF0ZVN1YnNjcmlwdGlvbnMoc3VicylcbiAgICAgICAgdGhpcy5lbWl0KCdmbG9vZHN1YjpzdWJzY3JpcHRpb24tY2hhbmdlJywgcGVlci5pbmZvLCBwZWVyLnRvcGljcywgc3VicylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfcHJvY2Vzc1JwY01lc3NhZ2VzIChtc2dzKSB7XG4gICAgbXNncy5mb3JFYWNoKChtc2cpID0+IHtcbiAgICAgIGNvbnN0IHNlcW5vID0gdXRpbHMubXNnSWQobXNnLmZyb20sIG1zZy5zZXFubylcbiAgICAgIC8vIDEuIGNoZWNrIGlmIEkndmUgc2VlbiB0aGUgbWVzc2FnZSwgaWYgeWVzLCBpZ25vcmVcbiAgICAgIGlmICh0aGlzLnNlZW5DYWNoZS5oYXMoc2Vxbm8pKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLnNlZW5DYWNoZS5wdXQoc2Vxbm8pXG5cbiAgICAgIC8vIDIuIGVtaXQgdG8gc2VsZlxuICAgICAgdGhpcy5fZW1pdE1lc3NhZ2VzKG1zZy50b3BpY0lEcywgW21zZ10pXG5cbiAgICAgIC8vIDMuIHByb3BhZ2F0ZSBtc2cgdG8gb3RoZXJzXG4gICAgICB0aGlzLl9mb3J3YXJkTWVzc2FnZXMobXNnLnRvcGljSURzLCBbbXNnXSlcbiAgICB9KVxuICB9XG5cbiAgX2VtaXRNZXNzYWdlcyAodG9waWNzLCBtZXNzYWdlcykge1xuICAgIHRvcGljcy5mb3JFYWNoKCh0b3BpYykgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN1YnNjcmlwdGlvbnMuaGFzKHRvcGljKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbWVzc2FnZXMuZm9yRWFjaCgobWVzc2FnZSkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQodG9waWMsIG1lc3NhZ2UpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBfZm9yd2FyZE1lc3NhZ2VzICh0b3BpY3MsIG1lc3NhZ2VzKSB7XG4gICAgdGhpcy5wZWVycy5mb3JFYWNoKChwZWVyKSA9PiB7XG4gICAgICBpZiAoIXBlZXIuaXNXcml0YWJsZSB8fCAhdXRpbHMuYW55TWF0Y2gocGVlci50b3BpY3MsIHRvcGljcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHBlZXIuc2VuZE1lc3NhZ2VzKHV0aWxzLm5vcm1hbGl6ZU91dFJwY01lc3NhZ2VzKG1lc3NhZ2VzKSlcblxuICAgICAgdGhpcy5sb2coJ3B1Ymxpc2ggbXNncyBvbiB0b3BpY3MnLCB0b3BpY3MsIHBlZXIuaW5mby5pZC50b0I1OFN0cmluZygpKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVW5tb3VudHMgdGhlIGZsb29kc3ViIHByb3RvY29sIGFuZCBzaHV0cyBkb3duIGV2ZXJ5IGNvbm5lY3Rpb25cbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqXG4gICAqL1xuICBzdG9wIChjYWxsYmFjaykge1xuICAgIHN1cGVyLnN0b3AoKGVycikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTZXQoKVxuICAgICAgY2FsbGJhY2soKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUHVibGlzaCBtZXNzYWdlcyB0byB0aGUgZ2l2ZW4gdG9waWNzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fHN0cmluZ30gdG9waWNzXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pnxhbnl9IG1lc3NhZ2VzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKlxuICAgKi9cbiAgcHVibGlzaCAodG9waWNzLCBtZXNzYWdlcywgY2FsbGJhY2spIHtcbiAgICBhc3NlcnQodGhpcy5zdGFydGVkLCAnRmxvb2RTdWIgaXMgbm90IHN0YXJ0ZWQnKVxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcFxuXG4gICAgdGhpcy5sb2coJ3B1Ymxpc2gnLCB0b3BpY3MsIG1lc3NhZ2VzKVxuXG4gICAgdG9waWNzID0gZW5zdXJlQXJyYXkodG9waWNzKVxuICAgIG1lc3NhZ2VzID0gZW5zdXJlQXJyYXkobWVzc2FnZXMpXG5cbiAgICBjb25zdCBmcm9tID0gdGhpcy5saWJwMnAucGVlckluZm8uaWQudG9CNThTdHJpbmcoKVxuXG4gICAgY29uc3QgYnVpbGRNZXNzYWdlID0gKG1zZywgY2IpID0+IHtcbiAgICAgIGNvbnN0IHNlcW5vID0gdXRpbHMucmFuZG9tU2Vxbm8oKVxuICAgICAgdGhpcy5zZWVuQ2FjaGUucHV0KHV0aWxzLm1zZ0lkKGZyb20sIHNlcW5vKSlcblxuICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgZGF0YTogbXNnLFxuICAgICAgICBzZXFubzogc2Vxbm8sXG4gICAgICAgIHRvcGljSURzOiB0b3BpY3NcbiAgICAgIH1cblxuICAgICAgLy8gRW1pdCB0byBzZWxmIGlmIEknbSBpbnRlcmVzdGVkXG4gICAgICB0aGlzLl9lbWl0TWVzc2FnZXModG9waWNzLCBbbWVzc2FnZV0pXG5cbiAgICAgIHRoaXMuX2J1aWxkTWVzc2FnZShtZXNzYWdlLCBjYilcbiAgICB9XG5cbiAgICBhc3luY01hcChtZXNzYWdlcywgYnVpbGRNZXNzYWdlLCAoZXJyLCBtc2dPYmplY3RzKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuXG4gICAgICAvLyBzZW5kIHRvIGFsbCB0aGUgb3RoZXIgcGVlcnNcbiAgICAgIHRoaXMuX2ZvcndhcmRNZXNzYWdlcyh0b3BpY3MsIG1zZ09iamVjdHMpXG5cbiAgICAgIGNhbGxiYWNrKG51bGwpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIGdpdmVuIHRvcGljKHMpLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fHN0cmluZ30gdG9waWNzXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBzdWJzY3JpYmUgKHRvcGljcykge1xuICAgIGFzc2VydCh0aGlzLnN0YXJ0ZWQsICdGbG9vZFN1YiBpcyBub3Qgc3RhcnRlZCcpXG5cbiAgICB0b3BpY3MgPSBlbnN1cmVBcnJheSh0b3BpY3MpXG5cbiAgICB0b3BpY3MuZm9yRWFjaCgodG9waWMpID0+IHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodG9waWMpKVxuXG4gICAgdGhpcy5wZWVycy5mb3JFYWNoKChwZWVyKSA9PiBzZW5kU3Vic2NyaXB0aW9uc09uY2VSZWFkeShwZWVyKSlcbiAgICAvLyBtYWtlIHN1cmUgdGhhdCBGbG9vZFN1YiBpcyBhbHJlYWR5IG1vdW50ZWRcbiAgICBmdW5jdGlvbiBzZW5kU3Vic2NyaXB0aW9uc09uY2VSZWFkeSAocGVlcikge1xuICAgICAgaWYgKHBlZXIgJiYgcGVlci5pc1dyaXRhYmxlKSB7XG4gICAgICAgIHJldHVybiBwZWVyLnNlbmRTdWJzY3JpcHRpb25zKHRvcGljcylcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uQ29ubmVjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgcGVlci5yZW1vdmVMaXN0ZW5lcignY29ubmVjdGlvbicsIG9uQ29ubmVjdGlvbilcbiAgICAgICAgc2VuZFN1YnNjcmlwdGlvbnNPbmNlUmVhZHkocGVlcilcbiAgICAgIH1cbiAgICAgIHBlZXIub24oJ2Nvbm5lY3Rpb24nLCBvbkNvbm5lY3Rpb24pXG4gICAgICBwZWVyLm9uY2UoJ2Nsb3NlJywgKCkgPT4gcGVlci5yZW1vdmVMaXN0ZW5lcignY29ubmVjdGlvbicsIG9uQ29ubmVjdGlvbikpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGdpdmVuIHRvcGljKHMpLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fHN0cmluZ30gdG9waWNzXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICB1bnN1YnNjcmliZSAodG9waWNzKSB7XG4gICAgLy8gQXZvaWQgcmFjZSBjb25kaXRpb25zLCBieSBxdWlldGx5IGlnbm9yaW5nIHVuc3ViIHdoZW4gc2h1dGRvd24uXG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRvcGljcyA9IGVuc3VyZUFycmF5KHRvcGljcylcblxuICAgIHRvcGljcy5mb3JFYWNoKCh0b3BpYykgPT4gdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZSh0b3BpYykpXG5cbiAgICB0aGlzLnBlZXJzLmZvckVhY2goKHBlZXIpID0+IGNoZWNrSWZSZWFkeShwZWVyKSlcbiAgICAvLyBtYWtlIHN1cmUgdGhhdCBGbG9vZFN1YiBpcyBhbHJlYWR5IG1vdW50ZWRcbiAgICBmdW5jdGlvbiBjaGVja0lmUmVhZHkgKHBlZXIpIHtcbiAgICAgIGlmIChwZWVyICYmIHBlZXIuaXNXcml0YWJsZSkge1xuICAgICAgICBwZWVyLnNlbmRVbnN1YnNjcmlwdGlvbnModG9waWNzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNoZWNrSWZSZWFkeS5iaW5kKHBlZXIpKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZsb29kU3ViXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBzdHJpY3QgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHJlcXVpcmUoJy4vZGlzdC9MYXRlbmN5TW9uaXRvcicpLmRlZmF1bHQ7XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENPTk5FQ1RJT05fRkFJTEVEOiAoZXJyKSA9PiBlcnJDb2RlKGVyciwgJ0NPTk5FQ1RJT05fRkFJTEVEJyksXG4gIERJQUxfQUJPUlRFRDogKCkgPT4gZXJyQ29kZSgnRGlhbCB3YXMgYWJvcnRlZCcsICdESUFMX0FCT1JURUQnKSxcbiAgRVJSX0JMQUNLTElTVEVEOiAoKSA9PiBlcnJDb2RlKCdEaWFsIGlzIGN1cnJlbnRseSBibGFja2xpc3RlZCBmb3IgdGhpcyBwZWVyJywgJ0VSUl9CTEFDS0xJU1RFRCcpLFxuICBESUFMX1NFTEY6ICgpID0+IGVyckNvZGUoJ0Egbm9kZSBjYW5ub3QgZGlhbCBpdHNlbGYnLCAnRElBTF9TRUxGJyksXG4gIElOVkFMSURfU1RBVEVfVFJBTlNJVElPTjogKGVycikgPT4gZXJyQ29kZShlcnIsICdJTlZBTElEX1NUQVRFX1RSQU5TSVRJT04nKSxcbiAgTk9fVFJBTlNQT1JUU19SRUdJU1RFUkVEOiAoKSA9PiBlcnJDb2RlKCdObyB0cmFuc3BvcnRzIHJlZ2lzdGVyZWQsIGRpYWwgbm90IHBvc3NpYmxlJywgJ05PX1RSQU5TUE9SVFNfUkVHSVNURVJFRCcpLFxuICBQUk9URUNUT1JfUkVRVUlSRUQ6ICgpID0+IGVyckNvZGUoJ05vIHByb3RlY3RvciBwcm92aWRlZCB3aXRoIHByaXZhdGUgbmV0d29yayBlbmZvcmNlZCcsICdQUk9URUNUT1JfUkVRVUlSRUQnKSxcbiAgVU5FWFBFQ1RFRF9FTkQ6ICgpID0+IGVyckNvZGUoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0IGZyb20gcmVhZGVyLicsICdVTkVYUEVDVEVEX0VORCcpLFxuICBtYXliZVVuZXhwZWN0ZWRFbmQ6IChlcnIpID0+IHtcbiAgICBpZiAoZXJyID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHMuVU5FWFBFQ1RFRF9FTkQoKVxuICAgIH1cbiAgICByZXR1cm4gZXJyXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBQZWVySWQgPSByZXF1aXJlKCdwZWVyLWlkJylcbmNvbnN0IFBlZXJJbmZvID0gcmVxdWlyZSgncGVlci1pbmZvJylcbmNvbnN0IG11bHRpYWRkciA9IHJlcXVpcmUoJ211bHRpYWRkcicpXG5cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBjaGVjayB0aGUgZGF0YSB0eXBlIG9mIHBlZXIgYW5kIGNvbnZlcnQgaXQgdG8gUGVlckluZm9cbiAqXG4gKiBAcGFyYW0ge1BlZXJJbmZvfE11bHRpYWRkcnxQZWVySWR9IHBlZXJcbiAqIEBwYXJhbSB7UGVlckJvb2t9IHBlZXJCb29rXG4gKiBAdGhyb3dzIHtJbnZhbGlkUGVlclR5cGV9XG4gKiBAcmV0dXJucyB7UGVlckluZm99XG4gKi9cbmZ1bmN0aW9uIGdldFBlZXJJbmZvIChwZWVyLCBwZWVyQm9vaykge1xuICBsZXQgcGVlckluZm9cblxuICAvLyBBbHJlYWR5IGEgUGVlckluZm8gaW5zdGFuY2UsXG4gIC8vIGFkZCB0byB0aGUgcGVlciBib29rIGFuZCByZXR1cm4gdGhlIGxhdGVzdCB2YWx1ZVxuICBpZiAoUGVlckluZm8uaXNQZWVySW5mbyhwZWVyKSkge1xuICAgIHJldHVybiBwZWVyQm9vay5wdXQocGVlcilcbiAgfVxuXG4gIC8vIEF0dGVtcHQgdG8gY29udmVydCBmcm9tIE11bHRpYWRkciBpbnN0YW5jZSAobm90IHN0cmluZylcbiAgaWYgKG11bHRpYWRkci5pc011bHRpYWRkcihwZWVyKSkge1xuICAgIGNvbnN0IHBlZXJJZEI1OFN0ciA9IHBlZXIuZ2V0UGVlcklkKClcbiAgICB0cnkge1xuICAgICAgcGVlckluZm8gPSBwZWVyQm9vay5nZXQocGVlcklkQjU4U3RyKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcGVlckluZm8gPSBuZXcgUGVlckluZm8oUGVlcklkLmNyZWF0ZUZyb21CNThTdHJpbmcocGVlcklkQjU4U3RyKSlcbiAgICB9XG4gICAgcGVlckluZm8ubXVsdGlhZGRycy5hZGQocGVlcilcbiAgICByZXR1cm4gcGVlckluZm9cbiAgfVxuXG4gIC8vIEF0dGVtcHQgdG8gY29udmVydCBmcm9tIFBlZXJJZFxuICBpZiAoUGVlcklkLmlzUGVlcklkKHBlZXIpKSB7XG4gICAgY29uc3QgcGVlcklkQjU4U3RyID0gcGVlci50b0I1OFN0cmluZygpXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBwZWVyQm9vay5nZXQocGVlcklkQjU4U3RyKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG50IGdldCBQZWVySW5mbyBmb3IgJHtwZWVySWRCNThTdHJ9YClcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ3BlZXIgdHlwZSBub3QgcmVjb2duaXplZCcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UGVlckluZm9cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuXG4vKipcbiAqIEFuIGVuY3J5cHRpb24gc3R1YiBpbiB0aGUgaW5zdGFuY2UgdGhhdCB0aGUgZGVmYXVsdCBjcnlwdG9cbiAqIGhhcyBub3QgYmVlbiBvdmVycmlkZW4gZm9yIHRoZSBTd2l0Y2hcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRhZzogJy9wbGFpbnRleHQvMS4wLjAnLFxuICBlbmNyeXB0IChteUlkLCBjb25uLCByZW1vdGVJZCwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHJlbW90ZUlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IHJlbW90ZUlkXG4gICAgICByZW1vdGVJZCA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjaygpKVxuICAgIHJldHVybiBjb25uXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtYXAgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS90aHJvdWdocy9tYXAnKVxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJylcblxuLyoqXG4gKiBUYWtlcyBhIFN3aXRjaCBhbmQgcmV0dXJucyBhbiBPYnNlcnZlciB0aGF0IGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGhcbiAqIG9ic2VydmUtY29ubmVjdGlvbi5qcy4gVGhlIHJldHVybmVkIE9ic2VydmVyIGNvbWVzIHdpdGggYGluY29taW5nYCBhbmRcbiAqIGBvdXRnb2luZ2AgcHJvcGVydGllcyB0aGF0IGNhbiBiZSB1c2VkIGluIHB1bGwgc3RyZWFtcyB0byBlbWl0IGFsbCBtZXRhZGF0YVxuICogZm9yIG1lc3NhZ2VzIHRoYXQgcGFzcyB0aHJvdWdoIGEgQ29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N3aXRjaH0gc3d0Y2hcbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKHN3dGNoKSA9PiB7XG4gIGNvbnN0IG9ic2VydmVyID0gT2JqZWN0LmFzc2lnbihuZXcgRXZlbnRFbWl0dGVyKCksIHtcbiAgICBpbmNvbWluZzogb2JzZXJ2ZSgnaW4nKSxcbiAgICBvdXRnb2luZzogb2JzZXJ2ZSgnb3V0JylcbiAgfSlcblxuICBzd3RjaC5vbigncGVlci1tdXgtZXN0YWJsaXNoZWQnLCAocGVlckluZm8pID0+IHtcbiAgICBvYnNlcnZlci5lbWl0KCdwZWVyOmNvbm5lY3RlZCcsIHBlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKCkpXG4gIH0pXG5cbiAgc3d0Y2gub24oJ3BlZXItbXV4LWNsb3NlZCcsIChwZWVySW5mbykgPT4ge1xuICAgIG9ic2VydmVyLmVtaXQoJ3BlZXI6Y2xvc2VkJywgcGVlckluZm8uaWQudG9CNThTdHJpbmcoKSlcbiAgfSlcblxuICByZXR1cm4gb2JzZXJ2ZXJcblxuICBmdW5jdGlvbiBvYnNlcnZlIChkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gKHRyYW5zcG9ydCwgcHJvdG9jb2wsIHBlZXJJbmZvKSA9PiB7XG4gICAgICByZXR1cm4gbWFwKChidWZmZXIpID0+IHtcbiAgICAgICAgd2lsbE9ic2VydmUocGVlckluZm8sIHRyYW5zcG9ydCwgcHJvdG9jb2wsIGRpcmVjdGlvbiwgYnVmZmVyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGJ1ZmZlclxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3aWxsT2JzZXJ2ZSAocGVlckluZm8sIHRyYW5zcG9ydCwgcHJvdG9jb2wsIGRpcmVjdGlvbiwgYnVmZmVyTGVuZ3RoKSB7XG4gICAgcGVlckluZm8udGhlbigoX3BlZXJJbmZvKSA9PiB7XG4gICAgICBpZiAoX3BlZXJJbmZvKSB7XG4gICAgICAgIGNvbnN0IHBlZXJJZCA9IF9wZWVySW5mby5pZC50b0I1OFN0cmluZygpXG4gICAgICAgIG9ic2VydmVyLmVtaXQoJ21lc3NhZ2UnLCBwZWVySWQsIHRyYW5zcG9ydCwgcHJvdG9jb2wsIGRpcmVjdGlvbiwgYnVmZmVyTGVuZ3RoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKVxuXG5jb25zdCBTdGF0ID0gcmVxdWlyZSgnLi9zdGF0JylcbmNvbnN0IE9sZFBlZXJzID0gcmVxdWlyZSgnLi9vbGQtcGVlcnMnKVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgY29tcHV0ZVRocm90dGxlTWF4UXVldWVTaXplOiAxMDAwLFxuICBjb21wdXRlVGhyb3R0bGVUaW1lb3V0OiAyMDAwLFxuICBtb3ZpbmdBdmVyYWdlSW50ZXJ2YWxzOiBbXG4gICAgNjAgKiAxMDAwLCAvLyAxIG1pbnV0ZVxuICAgIDUgKiA2MCAqIDEwMDAsIC8vIDUgbWludXRlc1xuICAgIDE1ICogNjAgKiAxMDAwIC8vIDE1IG1pbnV0ZXNcbiAgXSxcbiAgbWF4T2xkUGVlcnNSZXRlbnRpb246IDUwXG59XG5cbmNvbnN0IGluaXRpYWxDb3VudGVycyA9IFtcbiAgJ2RhdGFSZWNlaXZlZCcsXG4gICdkYXRhU2VudCdcbl1cblxuY29uc3QgZGlyZWN0aW9uVG9FdmVudCA9IHtcbiAgaW46ICdkYXRhUmVjZWl2ZWQnLFxuICBvdXQ6ICdkYXRhU2VudCdcbn1cblxuLyoqXG4gKiBCaW5kcyB0byBtZXNzYWdlIGV2ZW50cyBvbiB0aGUgZ2l2ZW4gYG9ic2VydmVyYCB0byBnZW5lcmF0ZSBzdGF0c1xuICogYmFzZWQgb24gdGhlIFBlZXIsIFByb3RvY29sIGFuZCBUcmFuc3BvcnQgdXNlZCBmb3IgdGhlIG1lc3NhZ2UuIFN0YXRcbiAqIGV2ZW50cyB3aWxsIGJlIGVtaXR0ZWQgdmlhIHRoZSBgdXBkYXRlYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge09ic2VydmVyfSBvYnNlcnZlclxuICogQHBhcmFtIHthbnl9IF9vcHRpb25zXG4gKiBAcmV0dXJucyB7U3RhdHN9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKG9ic2VydmVyLCBfb3B0aW9ucykgPT4ge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIF9vcHRpb25zKVxuICBjb25zdCBnbG9iYWxTdGF0cyA9IG5ldyBTdGF0KGluaXRpYWxDb3VudGVycywgb3B0aW9ucylcblxuICBjb25zdCBzdGF0cyA9IE9iamVjdC5hc3NpZ24obmV3IEV2ZW50RW1pdHRlcigpLCB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIHN0b3A6IHN0b3AsXG4gICAgZ2xvYmFsOiBnbG9iYWxTdGF0cyxcbiAgICBwZWVyczogKCkgPT4gQXJyYXkuZnJvbShwZWVyU3RhdHMua2V5cygpKSxcbiAgICBmb3JQZWVyOiAocGVlcklkKSA9PiB7XG4gICAgICByZXR1cm4gcGVlclN0YXRzLmdldChwZWVySWQpIHx8IG9sZFBlZXJzLmdldChwZWVySWQpXG4gICAgfSxcbiAgICB0cmFuc3BvcnRzOiAoKSA9PiBBcnJheS5mcm9tKHRyYW5zcG9ydFN0YXRzLmtleXMoKSksXG4gICAgZm9yVHJhbnNwb3J0OiAodHJhbnNwb3J0KSA9PiB0cmFuc3BvcnRTdGF0cy5nZXQodHJhbnNwb3J0KSxcbiAgICBwcm90b2NvbHM6ICgpID0+IEFycmF5LmZyb20ocHJvdG9jb2xTdGF0cy5rZXlzKCkpLFxuICAgIGZvclByb3RvY29sOiAocHJvdG9jb2wpID0+IHByb3RvY29sU3RhdHMuZ2V0KHByb3RvY29sKVxuICB9KVxuXG4gIGdsb2JhbFN0YXRzLm9uKCd1cGRhdGUnLCBwcm9wYWdhdGVDaGFuZ2UpXG5cbiAgY29uc3Qgb2xkUGVlcnMgPSBPbGRQZWVycyhvcHRpb25zLm1heE9sZFBlZXJzUmV0ZW50aW9uKVxuICBjb25zdCBwZWVyU3RhdHMgPSBuZXcgTWFwKClcbiAgY29uc3QgdHJhbnNwb3J0U3RhdHMgPSBuZXcgTWFwKClcbiAgY29uc3QgcHJvdG9jb2xTdGF0cyA9IG5ldyBNYXAoKVxuXG4gIG9ic2VydmVyLm9uKCdwZWVyOmNsb3NlZCcsIChwZWVySWQpID0+IHtcbiAgICBjb25zdCBwZWVyID0gcGVlclN0YXRzLmdldChwZWVySWQpXG4gICAgaWYgKHBlZXIpIHtcbiAgICAgIHBlZXIucmVtb3ZlTGlzdGVuZXIoJ3VwZGF0ZScsIHByb3BhZ2F0ZUNoYW5nZSlcbiAgICAgIHBlZXIuc3RvcCgpXG4gICAgICBwZWVyU3RhdHMuZGVsZXRlKHBlZXJJZClcbiAgICAgIG9sZFBlZXJzLnNldChwZWVySWQsIHBlZXIpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBzdGF0c1xuXG4gIGZ1bmN0aW9uIG9uTWVzc2FnZSAocGVlcklkLCB0cmFuc3BvcnRUYWcsIHByb3RvY29sVGFnLCBkaXJlY3Rpb24sIGJ1ZmZlckxlbmd0aCkge1xuICAgIGNvbnN0IGV2ZW50ID0gZGlyZWN0aW9uVG9FdmVudFtkaXJlY3Rpb25dXG5cbiAgICBpZiAodHJhbnNwb3J0VGFnKSB7XG4gICAgICAvLyBiZWNhdXNlIGl0IGhhcyBhIHRyYW5zcG9ydCB0YWcsIHRoaXMgbWVzc2FnZSBpcyBhdCB0aGUgZ2xvYmFsIGxldmVsLCBzbyB3ZSBhY2NvdW50IHRoaXNcbiAgICAgIC8vIHRyYWZmaWMgYXMgZ2xvYmFsLlxuICAgICAgZ2xvYmFsU3RhdHMucHVzaChldmVudCwgYnVmZmVyTGVuZ3RoKVxuXG4gICAgICAvLyBwZWVyIHN0YXRzXG4gICAgICBsZXQgcGVlciA9IHBlZXJTdGF0cy5nZXQocGVlcklkKVxuICAgICAgaWYgKCFwZWVyKSB7XG4gICAgICAgIHBlZXIgPSBvbGRQZWVycy5nZXQocGVlcklkKVxuICAgICAgICBpZiAocGVlcikge1xuICAgICAgICAgIG9sZFBlZXJzLmRlbGV0ZShwZWVySWQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVlciA9IG5ldyBTdGF0KGluaXRpYWxDb3VudGVycywgb3B0aW9ucylcbiAgICAgICAgfVxuICAgICAgICBwZWVyLm9uKCd1cGRhdGUnLCBwcm9wYWdhdGVDaGFuZ2UpXG4gICAgICAgIHBlZXIuc3RhcnQoKVxuICAgICAgICBwZWVyU3RhdHMuc2V0KHBlZXJJZCwgcGVlcilcbiAgICAgIH1cbiAgICAgIHBlZXIucHVzaChldmVudCwgYnVmZmVyTGVuZ3RoKVxuICAgIH1cblxuICAgIC8vIHRyYW5zcG9ydCBzdGF0c1xuICAgIGlmICh0cmFuc3BvcnRUYWcpIHtcbiAgICAgIGxldCB0cmFuc3BvcnQgPSB0cmFuc3BvcnRTdGF0cy5nZXQodHJhbnNwb3J0VGFnKVxuICAgICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgICAgdHJhbnNwb3J0ID0gbmV3IFN0YXQoaW5pdGlhbENvdW50ZXJzLCBvcHRpb25zKVxuICAgICAgICB0cmFuc3BvcnQub24oJ3VwZGF0ZScsIHByb3BhZ2F0ZUNoYW5nZSlcbiAgICAgICAgdHJhbnNwb3J0U3RhdHMuc2V0KHRyYW5zcG9ydFRhZywgdHJhbnNwb3J0KVxuICAgICAgfVxuICAgICAgdHJhbnNwb3J0LnB1c2goZXZlbnQsIGJ1ZmZlckxlbmd0aClcbiAgICB9XG5cbiAgICAvLyBwcm90b2NvbCBzdGF0c1xuICAgIGlmIChwcm90b2NvbFRhZykge1xuICAgICAgbGV0IHByb3RvY29sID0gcHJvdG9jb2xTdGF0cy5nZXQocHJvdG9jb2xUYWcpXG4gICAgICBpZiAoIXByb3RvY29sKSB7XG4gICAgICAgIHByb3RvY29sID0gbmV3IFN0YXQoaW5pdGlhbENvdW50ZXJzLCBvcHRpb25zKVxuICAgICAgICBwcm90b2NvbC5vbigndXBkYXRlJywgcHJvcGFnYXRlQ2hhbmdlKVxuICAgICAgICBwcm90b2NvbFN0YXRzLnNldChwcm90b2NvbFRhZywgcHJvdG9jb2wpXG4gICAgICB9XG4gICAgICBwcm90b2NvbC5wdXNoKGV2ZW50LCBidWZmZXJMZW5ndGgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnQgKCkge1xuICAgIG9ic2VydmVyLm9uKCdtZXNzYWdlJywgb25NZXNzYWdlKVxuXG4gICAgZ2xvYmFsU3RhdHMuc3RhcnQoKVxuXG4gICAgZm9yIChsZXQgcGVlclN0YXQgb2YgcGVlclN0YXRzLnZhbHVlcygpKSB7XG4gICAgICBwZWVyU3RhdC5zdGFydCgpXG4gICAgfVxuICAgIGZvciAobGV0IHRyYW5zcG9ydFN0YXQgb2YgdHJhbnNwb3J0U3RhdHMudmFsdWVzKCkpIHtcbiAgICAgIHRyYW5zcG9ydFN0YXQuc3RhcnQoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3AgKCkge1xuICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgb25NZXNzYWdlKVxuICAgIGdsb2JhbFN0YXRzLnN0b3AoKVxuXG4gICAgZm9yIChsZXQgcGVlclN0YXQgb2YgcGVlclN0YXRzLnZhbHVlcygpKSB7XG4gICAgICBwZWVyU3RhdC5zdG9wKClcbiAgICB9XG4gICAgZm9yIChsZXQgdHJhbnNwb3J0U3RhdCBvZiB0cmFuc3BvcnRTdGF0cy52YWx1ZXMoKSkge1xuICAgICAgdHJhbnNwb3J0U3RhdC5zdG9wKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wYWdhdGVDaGFuZ2UgKCkge1xuICAgIHN0YXRzLmVtaXQoJ3VwZGF0ZScpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IEluY29taW5nQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vaW5jb21pbmcnKVxuY29uc3Qgb2JzZXJ2ZUNvbm4gPSByZXF1aXJlKCcuLi9vYnNlcnZlLWNvbm5lY3Rpb24nKVxuXG5mdW5jdGlvbiBsaXN0ZW5lciAoX3N3aXRjaCkge1xuICBjb25zdCBsb2cgPSBkZWJ1ZyhgbGlicDJwOnN3aXRjaDpsaXN0ZW5lcmApXG5cbiAgLyoqXG4gICAqIFRha2VzIGEgdHJhbnNwb3J0IGtleSBhbmQgcmV0dXJucyBhIGNvbm5lY3Rpb24gaGFuZGxlciBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNwb3J0S2V5IFRoZSBrZXkgb2YgdGhlIHRyYW5zcG9ydCB0byBoYW5kbGUgY29ubmVjdGlvbnMgZm9yXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgQSBjdXN0b20gaGFuZGxlciB0byB1c2VcbiAgICogQHJldHVybnMge2Z1bmN0aW9uKENvbm5lY3Rpb24pfSBBIGNvbm5lY3Rpb24gaGFuZGxlciBmdW5jdGlvblxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uICh0cmFuc3BvcnRLZXksIGhhbmRsZXIpIHtcbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIGJhc2UgY29ubmVjdGlvbiBhbmQgbWFuYWdlcyBsaXN0ZW5pbmcgYmVoYXZpb3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiBUaGUgY29ubmVjdGlvbiB0byBtYW5hZ2VcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbm4pIHtcbiAgICAgIGxvZygncmVjZWl2ZWQgaW5jb21pbmcgY29ubmVjdGlvbiBmb3IgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0S2V5KVxuICAgICAgY29ubi5nZXRQZWVySW5mbygoXywgcGVlckluZm8pID0+IHtcbiAgICAgICAgLy8gQWRkIGEgdHJhbnNwb3J0IGxldmVsIG9ic2VydmVyLCBpZiBuZWVkZWRcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHRyYW5zcG9ydEtleSA/IG9ic2VydmVDb25uKHRyYW5zcG9ydEtleSwgbnVsbCwgY29ubiwgX3N3aXRjaC5vYnNlcnZlcikgOiBjb25uXG4gICAgICAgIGNvbnN0IGNvbm5GU00gPSBuZXcgSW5jb21pbmdDb25uZWN0aW9uKHsgY29ubmVjdGlvbiwgX3N3aXRjaCwgdHJhbnNwb3J0S2V5LCBwZWVySW5mbyB9KVxuXG4gICAgICAgIGNvbm5GU00ub25jZSgnZXJyb3InLCAoZXJyKSA9PiBsb2coZXJyKSlcbiAgICAgICAgY29ubkZTTS5vbmNlKCdwcml2YXRlJywgKF9jb25uKSA9PiB7XG4gICAgICAgICAgLy8gVXNlIHRoZSBjdXN0b20gaGFuZGxlciwgaWYgaXQgd2FzIHByb3ZpZGVkXG4gICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKF9jb25uKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25uRlNNLmVuY3J5cHQoKVxuICAgICAgICB9KVxuICAgICAgICBjb25uRlNNLm9uY2UoJ2VuY3J5cHRlZCcsICgpID0+IGNvbm5GU00udXBncmFkZSgpKVxuXG4gICAgICAgIGNvbm5GU00ucHJvdGVjdCgpXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RlbmVyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgRGlhbFF1ZXVlTWFuYWdlciA9IHJlcXVpcmUoJy4vcXVldWVNYW5hZ2VyJylcbmNvbnN0IGdldFBlZXJJbmZvID0gcmVxdWlyZSgnLi4vZ2V0LXBlZXItaW5mbycpXG5jb25zdCB7XG4gIEJMQUNLX0xJU1RfQVRURU1QVFMsXG4gIEJMQUNLX0xJU1RfVFRMLFxuICBNQVhfQ09MRF9DQUxMUyxcbiAgTUFYX1BBUkFMTEVMX0RJQUxTLFxuICBQUklPUklUWV9ISUdILFxuICBQUklPUklUWV9MT1dcbn0gPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfc3dpdGNoKSB7XG4gIGNvbnN0IGRpYWxRdWV1ZU1hbmFnZXIgPSBuZXcgRGlhbFF1ZXVlTWFuYWdlcihfc3dpdGNoKVxuXG4gIF9zd2l0Y2guc3RhdGUub24oJ1NUQVJURUQ6ZW50ZXInLCBzdGFydClcbiAgX3N3aXRjaC5zdGF0ZS5vbignU1RPUFBJTkc6ZW50ZXInLCBzdG9wKVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RpYWxSZXF1ZXN0fSBkaWFsUmVxdWVzdFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIF9kaWFsICh7IHBlZXJJbmZvLCBwcm90b2NvbCwgb3B0aW9ucywgY2FsbGJhY2sgfSkge1xuICAgIGlmICh0eXBlb2YgcHJvdG9jb2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gcHJvdG9jb2xcbiAgICAgIHByb3RvY29sID0gbnVsbFxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwZWVySW5mbyA9IGdldFBlZXJJbmZvKHBlZXJJbmZvLCBfc3dpdGNoLl9wZWVyQm9vaylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgLy8gQWRkIGl0IHRvIHRoZSBxdWV1ZSwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGdldCBleGVjdXRlZFxuICAgIGRpYWxRdWV1ZU1hbmFnZXIuYWRkKHsgcGVlckluZm8sIHByb3RvY29sLCBvcHRpb25zLCBjYWxsYmFjayB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgYERpYWxRdWV1ZU1hbmFnZXJgXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBmdW5jdGlvbiBzdGFydCAoY2FsbGJhY2spIHtcbiAgICBkaWFsUXVldWVNYW5hZ2VyLnN0YXJ0KClcbiAgICBjYWxsYmFjaygpXG4gIH1cblxuICAvKipcbiAgICogQWJvcnRzIGFsbCBkaWFscyB0aGF0IGFyZSBxdWV1ZWQuIFRoaXMgc2hvdWxkXG4gICAqIG9ubHkgYmUgdXNlZCB3aGVuIHRoZSBTd2l0Y2ggaXMgYmVpbmcgc3RvcHBlZFxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gc3RvcCAoY2FsbGJhY2spIHtcbiAgICBkaWFsUXVldWVNYW5hZ2VyLnN0b3AoKVxuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGJsYWNrbGlzdCBmb3IgYSBnaXZlbiBwZWVyXG4gICAqIEBwYXJhbSB7UGVlckluZm99IHBlZXJJbmZvXG4gICAqL1xuICBmdW5jdGlvbiBjbGVhckJsYWNrbGlzdCAocGVlckluZm8pIHtcbiAgICBkaWFsUXVldWVNYW5hZ2VyLmNsZWFyQmxhY2tsaXN0KHBlZXJJbmZvKVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gdG8gdGhlIGdpdmVuIGBwZWVySW5mb2AgYXRcbiAgICogYSBsb3dlciBwcmlvcml0eSB0aGFuIGEgc3RhbmRhcmQgZGlhbC5cbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlckluZm9cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnVzZUZTTSBXaGV0aGVyIG9yIG5vdCB0byByZXR1cm4gYSBgQ29ubmVjdGlvbkZTTWAuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5wcmlvcml0eSBMb3dlc3QgcHJpb3JpdHkgZ29lcyBmaXJzdC4gRGVmYXVsdHMgdG8gMjAuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIENvbm5lY3Rpb24pfSBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gY29ubmVjdCAocGVlckluZm8sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSBudWxsXG4gICAgfVxuICAgIG9wdGlvbnMgPSB7IHVzZUZTTTogZmFsc2UsIHByaW9yaXR5OiBQUklPUklUWV9MT1csIC4uLm9wdGlvbnMgfVxuICAgIF9kaWFsKHsgcGVlckluZm8sIHByb3RvY29sOiBudWxsLCBvcHRpb25zLCBjYWxsYmFjayB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGRpYWwgcmVxdWVzdCB0byB0aGUgcXVldWUgZm9yIHRoZSBnaXZlbiBgcGVlckluZm9gXG4gICAqIFRoZSByZXF1ZXN0IHdpbGwgYmUgYWRkZWQgd2l0aCBhIGhpZ2ggcHJpb3JpdHkgKDEwKS5cbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlckluZm9cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIENvbm5lY3Rpb24pfSBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gZGlhbCAocGVlckluZm8sIHByb3RvY29sLCBjYWxsYmFjaykge1xuICAgIF9kaWFsKHsgcGVlckluZm8sIHByb3RvY29sLCBvcHRpb25zOiB7IHVzZUZTTTogZmFsc2UsIHByaW9yaXR5OiBQUklPUklUWV9ISUdIIH0sIGNhbGxiYWNrIH0pXG4gIH1cblxuICAvKipcbiAgICogQmVoYXZlcyBsaWtlIGRpYWwsIGV4Y2VwdCBpdCBjYWxscyBiYWNrIHdpdGggYSBDb25uZWN0aW9uRlNNXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlckluZm99IHBlZXJJbmZvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBDb25uZWN0aW9uRlNNKX0gY2FsbGJhY2tcbiAgICovXG4gIGZ1bmN0aW9uIGRpYWxGU00gKHBlZXJJbmZvLCBwcm90b2NvbCwgY2FsbGJhY2spIHtcbiAgICBfZGlhbCh7IHBlZXJJbmZvLCBwcm90b2NvbCwgb3B0aW9uczogeyB1c2VGU006IHRydWUsIHByaW9yaXR5OiBQUklPUklUWV9ISUdIIH0sIGNhbGxiYWNrIH0pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbm5lY3QsXG4gICAgZGlhbCxcbiAgICBkaWFsRlNNLFxuICAgIGNsZWFyQmxhY2tsaXN0LFxuICAgIEJMQUNLX0xJU1RfQVRURU1QVFM6IGlzTmFOKF9zd2l0Y2guX29wdGlvbnMuYmxhY2tMaXN0QXR0ZW1wdHMpID8gQkxBQ0tfTElTVF9BVFRFTVBUUyA6IF9zd2l0Y2guX29wdGlvbnMuYmxhY2tMaXN0QXR0ZW1wdHMsXG4gICAgQkxBQ0tfTElTVF9UVEw6IGlzTmFOKF9zd2l0Y2guX29wdGlvbnMuYmxhY2tsaXN0VFRMKSA/IEJMQUNLX0xJU1RfVFRMIDogX3N3aXRjaC5fb3B0aW9ucy5ibGFja2xpc3RUVEwsXG4gICAgTUFYX0NPTERfQ0FMTFM6IGlzTmFOKF9zd2l0Y2guX29wdGlvbnMubWF4Q29sZENhbGxzKSA/IE1BWF9DT0xEX0NBTExTIDogX3N3aXRjaC5fb3B0aW9ucy5tYXhDb2xkQ2FsbHMsXG4gICAgTUFYX1BBUkFMTEVMX0RJQUxTOiBpc05hTihfc3dpdGNoLl9vcHRpb25zLm1heFBhcmFsbGVsRGlhbHMpID8gTUFYX1BBUkFMTEVMX0RJQUxTIDogX3N3aXRjaC5fb3B0aW9ucy5tYXhQYXJhbGxlbERpYWxzXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBpZGVudGlmeSA9IHJlcXVpcmUoJ2xpYnAycC1pZGVudGlmeScpXG5jb25zdCBtdWx0aXN0cmVhbSA9IHJlcXVpcmUoJ211bHRpc3RyZWFtLXNlbGVjdCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IGxvZyA9IGRlYnVnKCdsaWJwMnA6c3dpdGNoOmNvbm4tbWFuYWdlcicpXG5jb25zdCBvbmNlID0gcmVxdWlyZSgnb25jZScpXG5jb25zdCBDb25uZWN0aW9uRlNNID0gcmVxdWlyZSgnLi4vY29ubmVjdGlvbicpXG5jb25zdCB7IG1zSGFuZGxlLCBtc1NlbGVjdCwgaWRlbnRpZnlEaWFsZXIgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJylcblxuY29uc3QgQ2lyY3VpdCA9IHJlcXVpcmUoJ2xpYnAycC1jaXJjdWl0JylcblxuY29uc3QgcGxhaW50ZXh0ID0gcmVxdWlyZSgnLi4vcGxhaW50ZXh0JylcblxuLyoqXG4gKiBDb250YWlucyBtZXRob2RzIGZvciBiaW5kaW5nIGhhbmRsZXJzIHRvIHRoZSBTd2l0Y2hcbiAqIGluIG9yZGVyIHRvIGJldHRlciBtYW5hZ2UgaXRzIGNvbm5lY3Rpb25zLlxuICovXG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yIChfc3dpdGNoKSB7XG4gICAgdGhpcy5zd2l0Y2ggPSBfc3dpdGNoXG4gICAgdGhpcy5jb25uZWN0aW9ucyA9IHt9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgY29ubmVjdGlvbiBmb3IgdHJhY2tpbmcgaWYgaXQncyBub3QgYWxyZWFkeSBhZGRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25GU019IGNvbm5lY3Rpb25cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBhZGQgKGNvbm5lY3Rpb24pIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25zW2Nvbm5lY3Rpb24udGhlaXJCNThJZF0gPSB0aGlzLmNvbm5lY3Rpb25zW2Nvbm5lY3Rpb24udGhlaXJCNThJZF0gfHwgW11cbiAgICAvLyBPbmx5IGFkZCBpdCBpZiBpdCdzIG5vdCB0aGVyZVxuICAgIGlmICghdGhpcy5nZXQoY29ubmVjdGlvbikpIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvbnNbY29ubmVjdGlvbi50aGVpckI1OElkXS5wdXNoKGNvbm5lY3Rpb24pXG4gICAgICB0aGlzLnN3aXRjaC5lbWl0KCdjb25uZWN0aW9uOnN0YXJ0JywgY29ubmVjdGlvbi50aGVpclBlZXJJbmZvKVxuICAgICAgaWYgKGNvbm5lY3Rpb24uZ2V0U3RhdGUoKSA9PT0gJ01VWEVEJykge1xuICAgICAgICB0aGlzLnN3aXRjaC5lbWl0KCdwZWVyLW11eC1lc3RhYmxpc2hlZCcsIGNvbm5lY3Rpb24udGhlaXJQZWVySW5mbylcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGJsYWNrbGlzdCBvZiB0aGUgcGVlclxuICAgICAgICB0aGlzLnN3aXRjaC5kaWFsZXIuY2xlYXJCbGFja2xpc3QoY29ubmVjdGlvbi50aGVpclBlZXJJbmZvKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKCdtdXhlZCcsICgpID0+IHtcbiAgICAgICAgICB0aGlzLnN3aXRjaC5lbWl0KCdwZWVyLW11eC1lc3RhYmxpc2hlZCcsIGNvbm5lY3Rpb24udGhlaXJQZWVySW5mbylcbiAgICAgICAgICAvLyBDbGVhciB0aGUgYmxhY2tsaXN0IG9mIHRoZSBwZWVyXG4gICAgICAgICAgdGhpcy5zd2l0Y2guZGlhbGVyLmNsZWFyQmxhY2tsaXN0KGNvbm5lY3Rpb24udGhlaXJQZWVySW5mbylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY29ubmVjdGlvbiBmcm9tIHRoZSBsaXN0IGlmIGl0IGV4aXN0c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25GU019IGNvbm5lY3Rpb25cbiAgICogQHJldHVybnMge0Nvbm5lY3Rpb25GU018bnVsbH0gVGhlIGZvdW5kIGNvbm5lY3Rpb24gb3IgbnVsbFxuICAgKi9cbiAgZ2V0IChjb25uZWN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3Rpb25zW2Nvbm5lY3Rpb24udGhlaXJCNThJZF0pIHJldHVybiBudWxsXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29ubmVjdGlvbnNbY29ubmVjdGlvbi50aGVpckI1OElkXS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbnNbY29ubmVjdGlvbi50aGVpckI1OElkXVtpXSA9PT0gY29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uc1tjb25uZWN0aW9uLnRoZWlyQjU4SWRdW2ldXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIGNvbm5lY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBwZWVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwZWVySWQgVGhlIHBlZXJzIGlkXG4gICAqIEByZXR1cm5zIHtDb25uZWN0aW9uRlNNfG51bGx9IFRoZSBmb3VuZCBjb25uZWN0aW9uIG9yIG51bGxcbiAgICovXG4gIGdldE9uZSAocGVlcklkKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbnNbcGVlcklkXSkge1xuICAgICAgLy8gT25seSByZXR1cm4gbXV4ZWQgY29ubmVjdGlvbnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25uZWN0aW9uc1twZWVySWRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25zW3BlZXJJZF1baV0uZ2V0U3RhdGUoKSA9PT0gJ01VWEVEJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25zW3BlZXJJZF1baV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGNvbm5lY3Rpb24gZnJvbSB0cmFja2luZ1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25GU019IGNvbm5lY3Rpb24gVGhlIGNvbm5lY3Rpb24gdG8gcmVtb3ZlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcmVtb3ZlIChjb25uZWN0aW9uKSB7XG4gICAgLy8gTm8gcmVjb3JkIG9mIHRoZSBwZWVyLCBkaXNjb25uZWN0IGl0XG4gICAgaWYgKCF0aGlzLmNvbm5lY3Rpb25zW2Nvbm5lY3Rpb24udGhlaXJCNThJZF0pIHtcbiAgICAgIGlmIChjb25uZWN0aW9uLnRoZWlyUGVlckluZm8pIHtcbiAgICAgICAgY29ubmVjdGlvbi50aGVpclBlZXJJbmZvLmRpc2Nvbm5lY3QoKVxuICAgICAgICB0aGlzLnN3aXRjaC5lbWl0KCdwZWVyLW11eC1jbG9zZWQnLCBjb25uZWN0aW9uLnRoZWlyUGVlckluZm8pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29ubmVjdGlvbnNbY29ubmVjdGlvbi50aGVpckI1OElkXS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbnNbY29ubmVjdGlvbi50aGVpckI1OElkXVtpXSA9PT0gY29ubmVjdGlvbikge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zW2Nvbm5lY3Rpb24udGhlaXJCNThJZF0uc3BsaWNlKGksIDEpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIHBlZXIgaXMgZnVsbHkgZGlzY29ubmVjdGVkXG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbnNbY29ubmVjdGlvbi50aGVpckI1OElkXS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbm5lY3Rpb25zW2Nvbm5lY3Rpb24udGhlaXJCNThJZF1cbiAgICAgIGNvbm5lY3Rpb24udGhlaXJQZWVySW5mby5kaXNjb25uZWN0KClcbiAgICAgIHRoaXMuc3dpdGNoLmVtaXQoJ3BlZXItbXV4LWNsb3NlZCcsIGNvbm5lY3Rpb24udGhlaXJQZWVySW5mbylcbiAgICB9XG5cbiAgICAvLyBBIHRyYWNrZWQgY29ubmVjdGlvbiB3YXMgY2xvc2VkLCBsZXQgdGhlIHdvcmxkIGtub3dcbiAgICB0aGlzLnN3aXRjaC5lbWl0KCdjb25uZWN0aW9uOmVuZCcsIGNvbm5lY3Rpb24udGhlaXJQZWVySW5mbylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBjb25uZWN0aW9ucyBiZWluZyB0cmFja2VkXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtDb25uZWN0aW9uRlNNW119XG4gICAqL1xuICBnZXRBbGwgKCkge1xuICAgIGxldCBjb25uZWN0aW9ucyA9IFtdXG4gICAgZm9yIChjb25zdCBjb25ucyBvZiBPYmplY3QudmFsdWVzKHRoaXMuY29ubmVjdGlvbnMpKSB7XG4gICAgICBjb25uZWN0aW9ucyA9IFsuLi5jb25uZWN0aW9ucywgLi4uY29ubnNdXG4gICAgfVxuICAgIHJldHVybiBjb25uZWN0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGNvbm5lY3Rpb25zIGJlaW5nIHRyYWNrZWQgZm9yIGEgZ2l2ZW4gcGVlciBpZFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGVlcklkIFN0cmluZ2lmaWVkIHBlZXIgaWRcbiAgICogQHJldHVybnMge0Nvbm5lY3Rpb25GU01bXX1cbiAgICovXG4gIGdldEFsbEJ5SWQgKHBlZXJJZCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25zW3BlZXJJZF0gfHwgW11cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbGlzdGVuZXIgZm9yIHRoZSBnaXZlbiBgbXV4ZXJgIGFuZCBjcmVhdGVzIGEgaGFuZGxlciBmb3IgaXRcbiAgICogbGV2ZXJhZ2luZyB0aGUgU3dpdGNoLnByb3RvY29sTXV4ZXIgaGFuZGxlciBmYWN0b3J5XG4gICAqXG4gICAqIEBwYXJhbSB7TXV4ZXJ9IG11eGVyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgYWRkU3RyZWFtTXV4ZXIgKG11eGVyKSB7XG4gICAgLy8gZm9yIGRpYWxpbmdcbiAgICB0aGlzLnN3aXRjaC5tdXhlcnNbbXV4ZXIubXVsdGljb2RlY10gPSBtdXhlclxuXG4gICAgLy8gZm9yIGxpc3RlbmluZ1xuICAgIHRoaXMuc3dpdGNoLmhhbmRsZShtdXhlci5tdWx0aWNvZGVjLCAocHJvdG9jb2wsIGNvbm4pID0+IHtcbiAgICAgIGNvbnN0IG11eGVkQ29ubiA9IG11eGVyLmxpc3RlbmVyKGNvbm4pXG5cbiAgICAgIG11eGVkQ29ubi5vbignc3RyZWFtJywgdGhpcy5zd2l0Y2gucHJvdG9jb2xNdXhlcihudWxsKSlcblxuICAgICAgLy8gSWYgaWRlbnRpZnkgaXMgZW5hYmxlZFxuICAgICAgLy8gICAxLiBvdmVybG9hZCBnZXRQZWVySW5mb1xuICAgICAgLy8gICAyLiBjYWxsIGdldFBlZXJJbmZvXG4gICAgICAvLyAgIDMuIGFkZCB0aGlzIGNvbm4gdG8gdGhlIHBvb2xcbiAgICAgIGlmICh0aGlzLnN3aXRjaC5pZGVudGlmeSkge1xuICAgICAgICAvLyBHZXQgdGhlIHBlZXIgaW5mbyBmcm9tIHRoZSBjcnlwdG8gZXhjaGFuZ2VcbiAgICAgICAgY29ubi5nZXRQZWVySW5mbygoZXJyLCBjcnlwdG9QSSkgPT4ge1xuICAgICAgICAgIGlmIChlcnIgfHwgIWNyeXB0b1BJKSB7XG4gICAgICAgICAgICBsb2coJ2NyeXB0byBwZWVySW5mbyB3YXNudCBmb3VuZCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gb3ZlcmxvYWQgcGVlckluZm8gdG8gdXNlIElkZW50aWZ5IGluc3RlYWRcbiAgICAgICAgICBjb25uLmdldFBlZXJJbmZvID0gYXN5bmMgKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25uID0gbXV4ZWRDb25uLm5ld1N0cmVhbSgpXG4gICAgICAgICAgICBjb25zdCBtcyA9IG5ldyBtdWx0aXN0cmVhbS5EaWFsZXIoKVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKVxuXG4gICAgICAgICAgICBsZXQgcmVzdWx0c1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgbXNIYW5kbGUobXMsIGNvbm4pXG4gICAgICAgICAgICAgIGNvbnN0IG1zQ29ubiA9IGF3YWl0IG1zU2VsZWN0KG1zLCBpZGVudGlmeS5tdWx0aWNvZGVjKVxuICAgICAgICAgICAgICByZXN1bHRzID0gYXdhaXQgaWRlbnRpZnlEaWFsZXIobXNDb25uLCBjcnlwdG9QSSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gbXV4ZWRDb25uLmVuZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB7IHBlZXJJbmZvIH0gPSByZXN1bHRzXG5cbiAgICAgICAgICAgIGlmIChwZWVySW5mbykge1xuICAgICAgICAgICAgICBjb25uLnNldFBlZXJJbmZvKHBlZXJJbmZvKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcGVlckluZm8pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29ubi5nZXRQZWVySW5mbygoZXJyLCBwZWVySW5mbykgPT4ge1xuICAgICAgICAgICAgLyogZXNsaW50IG5vLXdhcm5pbmctY29tbWVudHM6IG9mZiAqL1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gbG9nKCdpZGVudGlmeSBub3Qgc3VjY2Vzc2Z1bCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiNThTdHIgPSBwZWVySW5mby5pZC50b0I1OFN0cmluZygpXG4gICAgICAgICAgICBwZWVySW5mbyA9IHRoaXMuc3dpdGNoLl9wZWVyQm9vay5wdXQocGVlckluZm8pXG5cbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbkZTTSh7XG4gICAgICAgICAgICAgIF9zd2l0Y2g6IHRoaXMuc3dpdGNoLFxuICAgICAgICAgICAgICBwZWVySW5mbyxcbiAgICAgICAgICAgICAgbXV4ZXI6IG11eGVkQ29ubixcbiAgICAgICAgICAgICAgY29ubjogY29ubixcbiAgICAgICAgICAgICAgdHlwZTogJ2luYydcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB0aGlzLnN3aXRjaC5jb25uZWN0aW9uLmFkZChjb25uZWN0aW9uKVxuXG4gICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBpZiBpdCdzIG5vdCBhbHJlYWR5IGNvbm5lY3RlZFxuICAgICAgICAgICAgaWYgKCFwZWVySW5mby5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICAgIGlmIChwZWVySW5mby5tdWx0aWFkZHJzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gd2l0aCBpbmNvbW1pbmcgY29ubiBhbmQgdGhyb3VnaCBpZGVudGlmeSwgZ29pbmcgdG8gcGljayBvbmVcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgYXZhaWxhYmxlIG11bHRpYWRkcnMgZnJvbSB0aGUgb3RoZXIgcGVlciBhcyB0aGUgb25lXG4gICAgICAgICAgICAgICAgLy8gSSdtIGNvbm5lY3RlZCB0byBhcyB3ZSByZWFsbHkgY2FuJ3QgYmUgc3VyZSBhdCB0aGUgbW9tZW50XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBhZGQgdGhpcyBjb25zaWRlcmF0aW9uIHRvIHRoZSBjb25uZWN0aW9uIGFic3RyYWN0aW9uIVxuICAgICAgICAgICAgICAgIHBlZXJJbmZvLmNvbm5lY3QocGVlckluZm8ubXVsdGlhZGRycy50b0FycmF5KClbMF0pXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBjYXNlIG9mIHdlYnNvY2tldHMgaW4gdGhlIGJyb3dzZXIsIHdoZXJlIHBlZXJzIGhhdmVcbiAgICAgICAgICAgICAgICAvLyBubyBhZGRyLCB1c2UganVzdCB0aGVpciBJUEZTIGlkXG4gICAgICAgICAgICAgICAgcGVlckluZm8uY29ubmVjdChgL2lwZnMvJHtiNThTdHJ9YClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtdXhlZENvbm4ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29ublxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgYGVuY3J5cHRgIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBgdGFnYCBhbmQgYWxzbyBzZXRzIHRoZVxuICAgKiBTd2l0Y2gncyBjcnlwdG8gdG8gcGFzc2VkIGBlbmNyeXB0YCBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGFnXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oUGVlcklELCBDb25uZWN0aW9uLCBQZWVySWQsIENhbGxiYWNrKX0gZW5jcnlwdFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNyeXB0byAodGFnLCBlbmNyeXB0KSB7XG4gICAgaWYgKCF0YWcgJiYgIWVuY3J5cHQpIHtcbiAgICAgIHRhZyA9IHBsYWludGV4dC50YWdcbiAgICAgIGVuY3J5cHQgPSBwbGFpbnRleHQuZW5jcnlwdFxuICAgIH1cblxuICAgIHRoaXMuc3dpdGNoLmNyeXB0byA9IHsgdGFnLCBlbmNyeXB0IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBjb25maWcuZW5hYmxlZCBpcyB0cnVlLCBhIENpcmN1aXQgcmVsYXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgICogYXZhaWxhYmxlIFN3aXRjaCB0cmFuc3BvcnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gY29uZmlnXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZW5hYmxlQ2lyY3VpdFJlbGF5IChjb25maWcpIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge31cblxuICAgIGlmIChjb25maWcuZW5hYmxlZCkge1xuICAgICAgaWYgKCFjb25maWcuaG9wKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCB7IGhvcDogeyBlbmFibGVkOiBmYWxzZSwgYWN0aXZlOiBmYWxzZSB9IH0pXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3dpdGNoLnRyYW5zcG9ydC5hZGQoQ2lyY3VpdC50YWcsIG5ldyBDaXJjdWl0KHRoaXMuc3dpdGNoLCBjb25maWcpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGlkZW50aWZ5IHRvIHRydWUgb24gdGhlIFN3aXRjaCBhbmQgcGVyZm9ybXMgaGFuZHNoYWtlc1xuICAgKiBmb3IgbGlicDJwLWlkZW50aWZ5IGxldmVyYWdpbmcgdGhlIFN3aXRjaCdzIG11eGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHJldXNlICgpIHtcbiAgICB0aGlzLnN3aXRjaC5pZGVudGlmeSA9IHRydWVcbiAgICB0aGlzLnN3aXRjaC5oYW5kbGUoaWRlbnRpZnkubXVsdGljb2RlYywgKHByb3RvY29sLCBjb25uKSA9PiB7XG4gICAgICBpZGVudGlmeS5saXN0ZW5lcihjb25uLCB0aGlzLnN3aXRjaC5fcGVlckluZm8pXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyXG4iLCIndXNlIHN0cmljdCdcblxuLyogZXNsaW50IG5vLXdhcm5pbmctY29tbWVudHM6IG9mZiAqL1xuXG5jb25zdCBwYXJhbGxlbCA9IHJlcXVpcmUoJ2FzeW5jL3BhcmFsbGVsJylcbmNvbnN0IG9uY2UgPSByZXF1aXJlKCdvbmNlJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycDpzd2l0Y2g6dHJhbnNwb3J0JylcblxuY29uc3QgTGltaXREaWFsZXIgPSByZXF1aXJlKCcuL2xpbWl0LWRpYWxlcicpXG5jb25zdCB7IERJQUxfVElNRU9VVCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyB1bmlxdWVCeSB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5cbi8vIG51bWJlciBvZiBjb25jdXJyZW50IG91dGJvdW5kIGRpYWxzIHRvIG1ha2UgcGVyIHBlZXIsIHNhbWUgYXMgZ28tbGlicDJwLXN3dGNoXG5jb25zdCBkZWZhdWx0UGVyUGVlclJhdGVMaW1pdCA9IDhcblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSB0cmFuc3BvcnRzIGZvciB0aGUgc3dpdGNoLiBUaGlzIHNpbXBsaWZpZXMgZGlhbGluZyBhbmQgbGlzdGVuaW5nIGFjcm9zc1xuICogbXVsdGlwbGUgdHJhbnNwb3J0cy5cbiAqL1xuY2xhc3MgVHJhbnNwb3J0TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yIChfc3dpdGNoKSB7XG4gICAgdGhpcy5zd2l0Y2ggPSBfc3dpdGNoXG4gICAgdGhpcy5kaWFsZXIgPSBuZXcgTGltaXREaWFsZXIoZGVmYXVsdFBlclBlZXJSYXRlTGltaXQsIHRoaXMuc3dpdGNoLl9vcHRpb25zLmRpYWxUaW1lb3V0IHx8IERJQUxfVElNRU9VVClcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgYFRyYW5zcG9ydGAgdG8gdGhlIGxpc3Qgb2YgdHJhbnNwb3J0cyBvbiB0aGUgc3dpdGNoLCBhbmQgYXNzaWducyBpdCB0byB0aGUgZ2l2ZW4ga2V5XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtUcmFuc3BvcnR9IHRyYW5zcG9ydFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGFkZCAoa2V5LCB0cmFuc3BvcnQpIHtcbiAgICBsb2coJ2FkZGluZyAlcycsIGtleSlcbiAgICBpZiAodGhpcy5zd2l0Y2gudHJhbnNwb3J0c1trZXldKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIGFscmVhZHkgYSB0cmFuc3BvcnQgd2l0aCB0aGlzIGtleScpXG4gICAgfVxuXG4gICAgdGhpcy5zd2l0Y2gudHJhbnNwb3J0c1trZXldID0gdHJhbnNwb3J0XG4gICAgaWYgKCF0aGlzLnN3aXRjaC50cmFuc3BvcnRzW2tleV0ubGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLnN3aXRjaC50cmFuc3BvcnRzW2tleV0ubGlzdGVuZXJzID0gW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIGNvbm5lY3Rpb25zIGZvciB0aGUgZ2l2ZW4gdHJhbnNwb3J0IGtleVxuICAgKiBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBzd2l0Y2guXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcmVtb3ZlIChrZXksIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fVxuXG4gICAgaWYgKCF0aGlzLnN3aXRjaC50cmFuc3BvcnRzW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZShrZXksIChlcnIpID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLnN3aXRjaC50cmFuc3BvcnRzW2tleV1cbiAgICAgIGNhbGxiYWNrKGVycilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIGByZW1vdmVgIG9uIGVhY2ggdHJhbnNwb3J0IHRoZSBzd2l0Y2ggaGFzXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHJlbW92ZUFsbCAoY2FsbGJhY2spIHtcbiAgICBjb25zdCB0YXNrcyA9IE9iamVjdC5rZXlzKHRoaXMuc3dpdGNoLnRyYW5zcG9ydHMpLm1hcCgoa2V5KSA9PiB7XG4gICAgICByZXR1cm4gKGNiKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGtleSwgY2IpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHBhcmFsbGVsKHRhc2tzLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYSBnaXZlbiB0cmFuc3BvcnQgYGtleWAsIGRpYWwgdG8gYWxsIHRoYXQgdHJhbnNwb3J0IG11bHRpYWRkcnNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgb2YgdGhlIGBUcmFuc3BvcnRgIHRvIGRpYWxcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlckluZm9cbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQ29ubmVjdGlvbil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZGlhbCAoa2V5LCBwZWVySW5mbywgY2FsbGJhY2spIHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLnN3aXRjaC50cmFuc3BvcnRzW2tleV1cbiAgICBsZXQgbXVsdGlhZGRycyA9IHBlZXJJbmZvLm11bHRpYWRkcnMudG9BcnJheSgpXG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobXVsdGlhZGRycykpIHtcbiAgICAgIG11bHRpYWRkcnMgPSBbbXVsdGlhZGRyc11cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgdGhlIG11bHRpYWRkcnMgdGhhdCBhcmUgYWN0dWFsbHkgdmFsaWQgZm9yIHRoaXMgdHJhbnNwb3J0XG4gICAgbXVsdGlhZGRycyA9IFRyYW5zcG9ydE1hbmFnZXIuZGlhbGFibGVzKHRyYW5zcG9ydCwgbXVsdGlhZGRycywgdGhpcy5zd2l0Y2guX3BlZXJJbmZvKVxuICAgIGxvZygnZGlhbGluZyAlcycsIGtleSwgbXVsdGlhZGRycy5tYXAoKG0pID0+IG0udG9TdHJpbmcoKSkpXG5cbiAgICAvLyBkaWFsIGVhY2ggb2YgdGhlIG11bHRpYWRkcnMgd2l0aCB0aGUgZ2l2ZW4gdHJhbnNwb3J0XG4gICAgdGhpcy5kaWFsZXIuZGlhbE1hbnkocGVlckluZm8uaWQsIHRyYW5zcG9ydCwgbXVsdGlhZGRycywgKGVycm9ycywgc3VjY2VzcykgPT4ge1xuICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3JzKVxuICAgICAgfVxuXG4gICAgICBwZWVySW5mby5jb25uZWN0KHN1Y2Nlc3MubXVsdGlhZGRyKVxuICAgICAgY2FsbGJhY2sobnVsbCwgc3VjY2Vzcy5jb25uKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRm9yIGEgZ2l2ZW4gVHJhbnNwb3J0IGBrZXlgLCBsaXN0ZW4gb24gYWxsIG11bHRpYWRkcnMgaW4gdGhlIHN3aXRjaCdzIGBfcGVlckluZm9gLlxuICAgKiBJZiBhIGBoYW5kbGVyYCBpcyBub3QgcHJvdmlkZWQsIHRoZSBTd2l0Y2gncyBgcHJvdG9jb2xNdXhlcmAgd2lsbCBiZSB1c2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Kn0gX29wdGlvbnMgQ3VycmVudGx5IGlnbm9yZWRcbiAgICogQHBhcmFtIHtmdW5jdGlvbihDb25uZWN0aW9uKX0gaGFuZGxlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBsaXN0ZW4gKGtleSwgX29wdGlvbnMsIGhhbmRsZXIsIGNhbGxiYWNrKSB7XG4gICAgaGFuZGxlciA9IHRoaXMuc3dpdGNoLl9jb25uZWN0aW9uSGFuZGxlcihrZXksIGhhbmRsZXIpXG5cbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLnN3aXRjaC50cmFuc3BvcnRzW2tleV1cbiAgICBsZXQgb3JpZ2luYWxBZGRycyA9IHRoaXMuc3dpdGNoLl9wZWVySW5mby5tdWx0aWFkZHJzLnRvQXJyYXkoKVxuXG4gICAgLy8gVW50aWwgVENQIGNhbiBoYW5kbGUgZGlzdGluY3QgYWRkcmVzc2VzIG9uIGxpc3RlbiwgaHR0cHM6Ly9naXRodWIuY29tL2xpYnAycC9pbnRlcmZhY2UtdHJhbnNwb3J0L2lzc3Vlcy80MSxcbiAgICAvLyBtYWtlIHN1cmUgd2UgYXJlbid0IHRyeWluZyB0byBsaXN0ZW4gb24gZHVwbGljYXRlIHBvcnRzLiBUaGlzIGFsc28gYXBwbGllcyB0byB3ZWJzb2NrZXRzLlxuICAgIG9yaWdpbmFsQWRkcnMgPSB1bmlxdWVCeShvcmlnaW5hbEFkZHJzLCAoYWRkcikgPT4ge1xuICAgICAgLy8gQW55IG5vbiAwIHBvcnQgc2hvdWxkIHJlZ2lzdGVyIGFzIHVuaXF1ZVxuICAgICAgY29uc3QgcG9ydCA9IE51bWJlcihhZGRyLnRvT3B0aW9ucygpLnBvcnQpXG4gICAgICByZXR1cm4gaXNOYU4ocG9ydCkgfHwgcG9ydCA9PT0gMCA/IGFkZHIudG9TdHJpbmcoKSA6IHBvcnRcbiAgICB9KVxuXG4gICAgY29uc3QgbXVsdGlhZGRycyA9IFRyYW5zcG9ydE1hbmFnZXIuZGlhbGFibGVzKHRyYW5zcG9ydCwgb3JpZ2luYWxBZGRycylcblxuICAgIGlmICghdHJhbnNwb3J0Lmxpc3RlbmVycykge1xuICAgICAgdHJhbnNwb3J0Lmxpc3RlbmVycyA9IFtdXG4gICAgfVxuXG4gICAgbGV0IGZyZXNoTXVsdGlhZGRycyA9IFtdXG5cbiAgICBjb25zdCBjcmVhdGVMaXN0ZW5lcnMgPSBtdWx0aWFkZHJzLm1hcCgobWEpID0+IHtcbiAgICAgIHJldHVybiAoY2IpID0+IHtcbiAgICAgICAgY29uc3QgZG9uZSA9IG9uY2UoY2IpXG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gdHJhbnNwb3J0LmNyZWF0ZUxpc3RlbmVyKGhhbmRsZXIpXG4gICAgICAgIGxpc3RlbmVyLm9uY2UoJ2Vycm9yJywgZG9uZSlcblxuICAgICAgICBsaXN0ZW5lci5saXN0ZW4obWEsIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIGxpc3RlbmVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGRvbmUpXG4gICAgICAgICAgbGlzdGVuZXIuZ2V0QWRkcnMoKGVyciwgYWRkcnMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJlc2hNdWx0aWFkZHJzID0gZnJlc2hNdWx0aWFkZHJzLmNvbmNhdChhZGRycylcbiAgICAgICAgICAgIHRyYW5zcG9ydC5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcilcbiAgICAgICAgICAgIGRvbmUoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIHBhcmFsbGVsKGNyZWF0ZUxpc3RlbmVycywgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICAvLyBjYXVzZSB3ZSBjYW4gbGlzdGVuIG9uIHBvcnQgMCBvciAwLjAuMC4wXG4gICAgICB0aGlzLnN3aXRjaC5fcGVlckluZm8ubXVsdGlhZGRycy5yZXBsYWNlKG11bHRpYWRkcnMsIGZyZXNoTXVsdGlhZGRycylcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgdHJhbnNwb3J0IHdpdGggdGhlIGdpdmVuIGtleSwgYnkgY2xvc2luZyBhbGwgb2YgaXRzIGxpc3RlbmVyc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNsb3NlIChrZXksIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gdGhpcy5zd2l0Y2gudHJhbnNwb3J0c1trZXldXG5cbiAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihgVHJ5aW5nIHRvIGNsb3NlIG5vbiBleGlzdGluZyB0cmFuc3BvcnQ6ICR7a2V5fWApKVxuICAgIH1cblxuICAgIHBhcmFsbGVsKHRyYW5zcG9ydC5saXN0ZW5lcnMubWFwKChsaXN0ZW5lcikgPT4ge1xuICAgICAgcmV0dXJuIChjYikgPT4ge1xuICAgICAgICBsaXN0ZW5lci5jbG9zZShjYilcbiAgICAgIH1cbiAgICB9KSwgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogRm9yIGEgZ2l2ZW4gdHJhbnNwb3J0LCByZXR1cm4gaXRzIG11bHRpYWRkcnMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gbXVsdGlhZGRyc1xuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zcG9ydH0gdHJhbnNwb3J0XG4gICAqIEBwYXJhbSB7QXJyYXk8TXVsdGlhZGRyPn0gbXVsdGlhZGRyc1xuICAgKiBAcGFyYW0ge1BlZXJJbmZvfSBwZWVySW5mbyBPcHRpb25hbCAtIGEgcGVlciB3aG9zZSBhZGRyZXNzZXMgc2hvdWxkIG5vdCBiZSByZXR1cm5lZFxuICAgKiBAcmV0dXJucyB7QXJyYXk8TXVsdGlhZGRyPn1cbiAgICovXG4gIHN0YXRpYyBkaWFsYWJsZXMgKHRyYW5zcG9ydCwgbXVsdGlhZGRycywgcGVlckluZm8pIHtcbiAgICAvLyBJZiB3ZSBkb250IGhhdmUgYSBwcm9wZXIgdHJhbnNwb3J0LCByZXR1cm4gbm8gbXVsdGlhZGRyc1xuICAgIGlmICghdHJhbnNwb3J0IHx8ICF0cmFuc3BvcnQuZmlsdGVyKSByZXR1cm4gW11cblxuICAgIGNvbnN0IHRyYW5zcG9ydEFkZHJzID0gdHJhbnNwb3J0LmZpbHRlcihtdWx0aWFkZHJzKVxuICAgIGlmICghcGVlckluZm8gfHwgIXRyYW5zcG9ydEFkZHJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRyYW5zcG9ydEFkZHJzXG4gICAgfVxuXG4gICAgY29uc3Qgb3VyQWRkcnMgPSBvdXJBZGRyZXNzZXMocGVlckluZm8pXG5cbiAgICBjb25zdCByZXN1bHQgPSB0cmFuc3BvcnRBZGRycy5maWx0ZXIodHJhbnNwb3J0QWRkciA9PiB7XG4gICAgICAvLyBJZiBvdXIgYWRkcmVzcyBpcyBpbiB0aGUgZGVzdGluYXRpb24gYWRkcmVzcywgZmlsdGVyIGl0IG91dFxuICAgICAgcmV0dXJuICFvdXJBZGRycy5zb21lKGEgPT4gZ2V0RGVzdGluYXRpb24odHJhbnNwb3J0QWRkcikuc3RhcnRzV2l0aChhKSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qKlxuICogRXhwYW5kIGFkZHJlc3NlcyBpbiBwZWVyIGluZm8gaW50byBhcnJheSBvZiBhZGRyZXNzZXMgd2l0aCBhbmQgd2l0aG91dCBwZWVyXG4gKiBJRCBzdWZmaXguXG4gKlxuICogQHBhcmFtIHtQZWVySW5mb30gcGVlckluZm8gT3VyIHBlZXIgaW5mbyBvYmplY3RcbiAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAqL1xuZnVuY3Rpb24gb3VyQWRkcmVzc2VzIChwZWVySW5mbykge1xuICBjb25zdCBvdXJQZWVySWQgPSBwZWVySW5mby5pZC50b0I1OFN0cmluZygpXG4gIHJldHVybiBwZWVySW5mby5tdWx0aWFkZHJzLnRvQXJyYXkoKVxuICAgIC5yZWR1Y2UoKG91ckFkZHJzLCBhZGRyKSA9PiB7XG4gICAgICBjb25zdCBwZWVySWQgPSBhZGRyLmdldFBlZXJJZCgpXG4gICAgICBhZGRyID0gYWRkci50b1N0cmluZygpXG4gICAgICBjb25zdCBvdGhlckFkZHIgPSBwZWVySWRcbiAgICAgICAgPyBhZGRyLnNsaWNlKDAsIGFkZHIubGFzdEluZGV4T2YoYC9pcGZzLyR7cGVlcklkfWApKVxuICAgICAgICA6IGAke2FkZHJ9L2lwZnMvJHtvdXJQZWVySWR9YFxuICAgICAgcmV0dXJuIG91ckFkZHJzLmNvbmNhdChbYWRkciwgb3RoZXJBZGRyXSlcbiAgICB9LCBbXSlcbiAgICAuZmlsdGVyKGEgPT4gQm9vbGVhbihhKSlcbiAgICAuY29uY2F0KGAvaXBmcy8ke291clBlZXJJZH1gKVxufVxuXG5jb25zdCBSZWxheVByb3RvcyA9IFtcbiAgJ3AycC1jaXJjdWl0JyxcbiAgJ3AycC13ZWJzb2NrZXQtc3RhcicsXG4gICdwMnAtd2VicnRjLXN0YXInLFxuICAncDJwLXN0YXJkdXN0J1xuXVxuXG4vKipcbiAqIEdldCB0aGUgZGVzdGluYXRpb24gYWRkcmVzcyBvZiBhIChwb3NzaWJseSByZWxheSkgbXVsdGlhZGRyIGFzIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtNdWx0aWFkZHJ9IGFkZHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERlc3RpbmF0aW9uIChhZGRyKSB7XG4gIGNvbnN0IHByb3RvcyA9IGFkZHIucHJvdG9OYW1lcygpLnJldmVyc2UoKVxuICBjb25zdCBzcGxpdFByb3RvID0gcHJvdG9zLmZpbmQocCA9PiBSZWxheVByb3Rvcy5pbmNsdWRlcyhwKSlcbiAgYWRkciA9IGFkZHIudG9TdHJpbmcoKVxuICBpZiAoIXNwbGl0UHJvdG8pIHJldHVybiBhZGRyXG4gIHJldHVybiBhZGRyLnNsaWNlKGFkZHIubGFzdEluZGV4T2Yoc3BsaXRQcm90bykgKyBzcGxpdFByb3RvLmxlbmd0aClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRNYW5hZ2VyXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NpcmN1aXQnKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG11bHRpc3RyZWFtID0gcmVxdWlyZSgnbXVsdGlzdHJlYW0tc2VsZWN0JylcbmNvbnN0IG9ic2VydmVDb25uID0gcmVxdWlyZSgnLi9vYnNlcnZlLWNvbm5lY3Rpb24nKVxuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IGxvZyA9IGRlYnVnKCdsaWJwMnA6c3dpdGNoOnByb3RvY29sLW11eGVyJylcbmxvZy5lcnJvciA9IGRlYnVnKCdsaWJwMnA6c3dpdGNoOnByb3RvY29sLW11eGVyOmVycm9yJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcm90b2NvbE11eGVyIChwcm90b2NvbHMsIG9ic2VydmVyKSB7XG4gIHJldHVybiAodHJhbnNwb3J0KSA9PiAoX3BhcmVudENvbm4sIG1zTGlzdGVuZXIpID0+IHtcbiAgICBjb25zdCBtcyA9IG1zTGlzdGVuZXIgfHwgbmV3IG11bHRpc3RyZWFtLkxpc3RlbmVyKClcbiAgICBsZXQgcGFyZW50Q29ublxuXG4gICAgLy8gT25seSBvYnNlcnZlIHRoZSB0cmFuc3BvcnQgaWYgd2UgaGF2ZSBvbmUsIGFuZCB0aGVyZSBpcyBub3QgYWxyZWFkeSBhIGxpc3RlbmVyXG4gICAgaWYgKHRyYW5zcG9ydCAmJiAhbXNMaXN0ZW5lcikge1xuICAgICAgcGFyZW50Q29ubiA9IG9ic2VydmVDb25uKHRyYW5zcG9ydCwgbnVsbCwgX3BhcmVudENvbm4sIG9ic2VydmVyKVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRDb25uID0gX3BhcmVudENvbm5cbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhwcm90b2NvbHMpLmZvckVhY2goKHByb3RvY29sKSA9PiB7XG4gICAgICBpZiAoIXByb3RvY29sKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBoYW5kbGVyID0gKHByb3RvY29sTmFtZSwgX2Nvbm4pID0+IHtcbiAgICAgICAgbG9nKCdyZWdpc3RlcmluZyBoYW5kbGVyIHdpdGggcHJvdG9jb2wgJXMnLCBwcm90b2NvbE5hbWUpXG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gcHJvdG9jb2xzW3Byb3RvY29sTmFtZV1cbiAgICAgICAgaWYgKHByb3RvY29sKSB7XG4gICAgICAgICAgY29uc3QgaGFuZGxlckZ1bmMgPSBwcm90b2NvbCAmJiBwcm90b2NvbC5oYW5kbGVyRnVuY1xuICAgICAgICAgIGlmIChoYW5kbGVyRnVuYykge1xuICAgICAgICAgICAgY29uc3QgY29ubiA9IG9ic2VydmVDb25uKG51bGwsIHByb3RvY29sTmFtZSwgX2Nvbm4sIG9ic2VydmVyKVxuICAgICAgICAgICAgaGFuZGxlckZ1bmMocHJvdG9jb2wsIGNvbm4pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1zLmFkZEhhbmRsZXIocHJvdG9jb2wsIGhhbmRsZXIsIHByb3RvY29sc1twcm90b2NvbF0ubWF0Y2hGdW5jKVxuICAgIH0pXG5cbiAgICBtcy5oYW5kbGUocGFyZW50Q29ubiwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2cuZXJyb3IoYG11bHRpc3RyZWFtIGhhbmRzaGFrZSBmYWlsZWRgLCBlcnIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKVxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuY29uc3QgcmVzb2x2ZSA9IGFzeW5jIChjaWQsIG5hbWUsIHBhdGgsIHRvUmVzb2x2ZSwgcmVzb2x2ZSwgZGVwdGgsIGlwbGQpID0+IHtcbiAgbGV0IG5vZGUgPSBhd2FpdCBpcGxkLmdldChjaWQpXG4gIGxldCBzdWJPYmplY3QgPSBub2RlXG4gIGxldCBzdWJQYXRoID0gcGF0aFxuXG4gIHdoaWxlICh0b1Jlc29sdmUubGVuZ3RoKSB7XG4gICAgY29uc3QgcHJvcCA9IHRvUmVzb2x2ZVswXVxuXG4gICAgaWYgKHByb3AgaW4gc3ViT2JqZWN0KSB7XG4gICAgICAvLyByZW1vdmUgdGhlIGJpdCBvZiB0aGUgcGF0aCB3ZSBoYXZlIHJlc29sdmVkXG4gICAgICB0b1Jlc29sdmUuc2hpZnQoKVxuICAgICAgc3ViUGF0aCA9IGAke3N1YlBhdGh9LyR7cHJvcH1gXG5cbiAgICAgIGlmIChDSUQuaXNDSUQoc3ViT2JqZWN0W3Byb3BdKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVudHJ5OiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGNpZCxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBkZXB0aFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmV4dDoge1xuICAgICAgICAgICAgY2lkOiBzdWJPYmplY3RbcHJvcF0sXG4gICAgICAgICAgICBuYW1lOiBwcm9wLFxuICAgICAgICAgICAgcGF0aDogc3ViUGF0aCxcbiAgICAgICAgICAgIHRvUmVzb2x2ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdWJPYmplY3QgPSBzdWJPYmplY3RbcHJvcF1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2Fubm90IHJlc29sdmUgZnVydGhlclxuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYE5vIHByb3BlcnR5IG5hbWVkICR7cHJvcH0gZm91bmQgaW4gY2JvciBub2RlICR7Y2lkLnRvQmFzZUVuY29kZWRTdHJpbmcoKX1gKSwgJ0VSUl9OT19QUk9QJylcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudHJ5OiB7XG4gICAgICBuYW1lLFxuICAgICAgcGF0aCxcbiAgICAgIGNpZCxcbiAgICAgIG5vZGUsXG4gICAgICBkZXB0aFxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuY29uc3QgZXh0cmFjdERhdGFGcm9tQmxvY2sgPSByZXF1aXJlKCcuLi91dGlscy9leHRyYWN0LWRhdGEtZnJvbS1ibG9jaycpXG5jb25zdCB2YWxpZGF0ZU9mZnNldEFuZExlbmd0aCA9IHJlcXVpcmUoJy4uL3V0aWxzL3ZhbGlkYXRlLW9mZnNldC1hbmQtbGVuZ3RoJylcblxuY29uc3QgcmF3Q29udGVudCA9IChub2RlKSA9PiB7XG4gIHJldHVybiBmdW5jdGlvbiAqIChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXQsXG4gICAgICBsZW5ndGhcbiAgICB9ID0gdmFsaWRhdGVPZmZzZXRBbmRMZW5ndGgobm9kZS5sZW5ndGgsIG9wdGlvbnMub2Zmc2V0LCBvcHRpb25zLmxlbmd0aClcblxuICAgIHlpZWxkIGV4dHJhY3REYXRhRnJvbUJsb2NrKG5vZGUsIDAsIG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKVxuICB9XG59XG5cbmNvbnN0IHJlc29sdmUgPSBhc3luYyAoY2lkLCBuYW1lLCBwYXRoLCB0b1Jlc29sdmUsIHJlc29sdmUsIGRlcHRoLCBpcGxkKSA9PiB7XG4gIGlmICh0b1Jlc29sdmUubGVuZ3RoKSB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYE5vIGxpbmsgbmFtZWQgJHtwYXRofSBmb3VuZCBpbiByYXcgbm9kZSAke2NpZC50b0Jhc2VFbmNvZGVkU3RyaW5nKCl9YCksICdFUlJfTk9UX0ZPVU5EJylcbiAgfVxuXG4gIGNvbnN0IGJ1ZiA9IGF3YWl0IGlwbGQuZ2V0KGNpZClcblxuICByZXR1cm4ge1xuICAgIGVudHJ5OiB7XG4gICAgICBuYW1lLFxuICAgICAgcGF0aCxcbiAgICAgIGNpZCxcbiAgICAgIG5vZGU6IGJ1ZixcbiAgICAgIGNvbnRlbnQ6IHJhd0NvbnRlbnQoYnVmKSxcbiAgICAgIGRlcHRoXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCBVbml4RlMgPSByZXF1aXJlKCdpcGZzLXVuaXhmcycpXG5jb25zdCBmaW5kU2hhcmRDaWQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9maW5kLWNpZC1pbi1zaGFyZCcpXG5cbmNvbnN0IGZpbmRMaW5rQ2lkID0gKG5vZGUsIG5hbWUpID0+IHtcbiAgY29uc3QgbGluayA9IG5vZGUuTGlua3MuZmluZChsaW5rID0+IGxpbmsuTmFtZSA9PT0gbmFtZSlcblxuICByZXR1cm4gbGluayAmJiBsaW5rLkhhc2hcbn1cblxuY29uc3QgY29udGVudEV4cG9ydGVycyA9IHtcbiAgcmF3OiByZXF1aXJlKCcuL2NvbnRlbnQvZmlsZScpLFxuICBmaWxlOiByZXF1aXJlKCcuL2NvbnRlbnQvZmlsZScpLFxuICBkaXJlY3Rvcnk6IHJlcXVpcmUoJy4vY29udGVudC9kaXJlY3RvcnknKSxcbiAgJ2hhbXQtc2hhcmRlZC1kaXJlY3RvcnknOiByZXF1aXJlKCcuL2NvbnRlbnQvaGFtdC1zaGFyZGVkLWRpcmVjdG9yeScpLFxuICBtZXRhZGF0YTogKGNpZCwgbm9kZSwgdW5peGZzLCBwYXRoLCByZXNvbHZlLCBkZXB0aCwgaXBsZCkgPT4ge30sXG4gIHN5bWxpbms6IChjaWQsIG5vZGUsIHVuaXhmcywgcGF0aCwgcmVzb2x2ZSwgZGVwdGgsIGlwbGQpID0+IHt9XG59XG5cbmNvbnN0IHVuaXhGc1Jlc29sdmVyID0gYXN5bmMgKGNpZCwgbmFtZSwgcGF0aCwgdG9SZXNvbHZlLCByZXNvbHZlLCBkZXB0aCwgaXBsZCkgPT4ge1xuICBjb25zdCBub2RlID0gYXdhaXQgaXBsZC5nZXQoY2lkKVxuICBsZXQgdW5peGZzXG4gIGxldCBuZXh0XG5cbiAgaWYgKCFuYW1lKSB7XG4gICAgbmFtZSA9IGNpZC50b0Jhc2VFbmNvZGVkU3RyaW5nKClcbiAgfVxuXG4gIHRyeSB7XG4gICAgdW5peGZzID0gVW5peEZTLnVubWFyc2hhbChub2RlLkRhdGEpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIG5vbi1Vbml4RlMgZGFnLXBiIG5vZGU/IEl0IGNvdWxkIGhhcHBlbi5cbiAgICB0aHJvdyBlcnJDb2RlKGVyciwgJ0VSUl9OT1RfVU5JWEZTJylcbiAgfVxuXG4gIGlmICghcGF0aCkge1xuICAgIHBhdGggPSBuYW1lXG4gIH1cblxuICBpZiAodG9SZXNvbHZlLmxlbmd0aCkge1xuICAgIGxldCBsaW5rQ2lkXG5cbiAgICBpZiAodW5peGZzICYmIHVuaXhmcy50eXBlID09PSAnaGFtdC1zaGFyZGVkLWRpcmVjdG9yeScpIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSAtIHVuaXhmcyB2MSBoYW10IHNoYXJkc1xuICAgICAgbGlua0NpZCA9IGF3YWl0IGZpbmRTaGFyZENpZChub2RlLCB0b1Jlc29sdmVbMF0sIGlwbGQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmtDaWQgPSBmaW5kTGlua0NpZChub2RlLCB0b1Jlc29sdmVbMF0pXG4gICAgfVxuXG4gICAgaWYgKCFsaW5rQ2lkKSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcihgZmlsZSBkb2VzIG5vdCBleGlzdGApLCAnRVJSX05PVF9GT1VORCcpXG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHRoZSBwYXRoIGNvbXBvbmVudCB3ZSBoYXZlIHJlc29sdmVkXG4gICAgY29uc3QgbmV4dE5hbWUgPSB0b1Jlc29sdmUuc2hpZnQoKVxuICAgIGNvbnN0IG5leHRQYXRoID0gYCR7cGF0aH0vJHtuZXh0TmFtZX1gXG5cbiAgICBuZXh0ID0ge1xuICAgICAgY2lkOiBsaW5rQ2lkLFxuICAgICAgdG9SZXNvbHZlLFxuICAgICAgbmFtZTogbmV4dE5hbWUsXG4gICAgICBwYXRoOiBuZXh0UGF0aFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZW50cnk6IHtcbiAgICAgIG5hbWUsXG4gICAgICBwYXRoLFxuICAgICAgY2lkLFxuICAgICAgbm9kZSxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRFeHBvcnRlcnNbdW5peGZzLnR5cGVdKGNpZCwgbm9kZSwgdW5peGZzLCBwYXRoLCByZXNvbHZlLCBkZXB0aCwgaXBsZCksXG4gICAgICB1bml4ZnMsXG4gICAgICBkZXB0aFxuICAgIH0sXG4gICAgbmV4dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5peEZzUmVzb2x2ZXJcbiIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvZW5kLW9mLXN0cmVhbSB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0U7XG5cbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBlb3Moc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgdmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCBvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGU7XG4gIHZhciB3cml0YWJsZSA9IG9wdHMud3JpdGFibGUgfHwgb3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlO1xuXG4gIHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uIG9ubGVnYWN5ZmluaXNoKCkge1xuICAgIGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xuICB9O1xuXG4gIHZhciB3cml0YWJsZUVuZGVkID0gc3RyZWFtLl93cml0YWJsZVN0YXRlICYmIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZDtcblxuICB2YXIgb25maW5pc2ggPSBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICB3cml0YWJsZSA9IGZhbHNlO1xuICAgIHdyaXRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcblxuICB2YXIgcmVhZGFibGVFbmRlZCA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZDtcblxuICB2YXIgb25lbmQgPSBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgIHJlYWRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghd3JpdGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcblxuICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gIH07XG5cbiAgdmFyIG9uY2xvc2UgPSBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIHZhciBlcnI7XG5cbiAgICBpZiAocmVhZGFibGUgJiYgIXJlYWRhYmxlRW5kZWQpIHtcbiAgICAgIGlmICghc3RyZWFtLl9yZWFkYWJsZVN0YXRlIHx8ICFzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIGlmICh3cml0YWJsZSAmJiAhd3JpdGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3dyaXRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbiBvbnJlcXVlc3QoKSB7XG4gICAgc3RyZWFtLnJlcS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICB9O1xuXG4gIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkge1xuICAgIHN0cmVhbS5vbignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTtlbHNlIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gIH0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSkge1xuICAgIC8vIGxlZ2FjeSBzdHJlYW1zXG4gICAgc3RyZWFtLm9uKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgfVxuXG4gIHN0cmVhbS5vbignZW5kJywgb25lbmQpO1xuICBzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgaWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVvczsiLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL3B1bXAgd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlb3M7XG5cbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1MsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRDtcblxuZnVuY3Rpb24gbm9vcChlcnIpIHtcbiAgLy8gUmV0aHJvdyB0aGUgZXJyb3IgaWYgaXQgZXhpc3RzIHRvIGF2b2lkIHN3YWxsb3dpbmcgaXRcbiAgaWYgKGVycikgdGhyb3cgZXJyO1xufVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gIHZhciBjbG9zZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICB9KTtcbiAgaWYgKGVvcyA9PT0gdW5kZWZpbmVkKSBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcbiAgZW9zKHN0cmVhbSwge1xuICAgIHJlYWRhYmxlOiByZWFkaW5nLFxuICAgIHdyaXRhYmxlOiB3cml0aW5nXG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xuICB2YXIgZGVzdHJveWVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBkZXN0cm95ZWQgPSB0cnVlOyAvLyByZXF1ZXN0LmRlc3Ryb3kganVzdCBkbyAuZW5kIC0gLmFib3J0IGlzIHdoYXQgd2Ugd2FudFxuXG4gICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmFib3J0KCk7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgncGlwZScpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FsbChmbikge1xuICBmbigpO1xufVxuXG5mdW5jdGlvbiBwaXBlKGZyb20sIHRvKSB7XG4gIHJldHVybiBmcm9tLnBpcGUodG8pO1xufVxuXG5mdW5jdGlvbiBwb3BDYWxsYmFjayhzdHJlYW1zKSB7XG4gIGlmICghc3RyZWFtcy5sZW5ndGgpIHJldHVybiBub29wO1xuICBpZiAodHlwZW9mIHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5vb3A7XG4gIHJldHVybiBzdHJlYW1zLnBvcCgpO1xufVxuXG5mdW5jdGlvbiBwaXBlbGluZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0cmVhbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3RyZWFtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBjYWxsYmFjayA9IHBvcENhbGxiYWNrKHN0cmVhbXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF07XG5cbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdzdHJlYW1zJyk7XG4gIH1cblxuICB2YXIgZXJyb3I7XG4gIHZhciBkZXN0cm95cyA9IHN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW0sIGkpIHtcbiAgICB2YXIgcmVhZGluZyA9IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDE7XG4gICAgdmFyIHdyaXRpbmcgPSBpID4gMDtcbiAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gICAgICBpZiAoZXJyKSBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgaWYgKHJlYWRpbmcpIHJldHVybjtcbiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlwZWxpbmU7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuJ3VzZSBzdHJpY3QnO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xuXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBBbGxvdyB0aGUga2V5cyBhcnJheSB0byBiZSBHQydlZC5cbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5cbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgfVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gSWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47IC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyxcbiAgICBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzA7XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCkpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG4gIGNiKGVyKTtcbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuXG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9OyAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9IC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cblxuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCkge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTsgLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ190cmFuc2Zvcm0oKScpKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG5cbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59OyAvLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpOyAvLyBUT0RPKEJyaWRnZUFSKTogV3JpdGUgYSB0ZXN0IGZvciB0aGVzZSB0d28gZXJyb3IgY2FzZXNcbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcblxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCgpO1xuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HKCk7XG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcbi8qIDxyZXBsYWNlbWVudD4gKi9cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufSAvLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuXG5cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcblxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVELFxuICAgIEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX05VTExfVkFMVUVTLFxuICAgIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsXG4gICAgRVJSX1VOS05PV05fRU5DT0RJTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVU5LTk9XTl9FTkNPRElORztcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0sXG4gIC8vIGUuZy4gb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUgdnMuIG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlLCBldGMuXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG5cbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlOyAvLyBkcmFpbiBldmVudCBmbGFnLlxuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7IC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG5cbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTsgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTsgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG5cbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlOyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuXG4gIHRoaXMubGVuZ3RoID0gMDsgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cblxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTsgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuXG4gIHRoaXMuY29ya2VkID0gMDsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cblxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07IC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuXG5cbiAgdGhpcy53cml0ZWNiID0gbnVsbDsgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7IC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuXG4gIHRoaXMucGVuZGluZ2NiID0gMDsgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTsgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2ZpbmlzaCcgKGFuZCBwb3RlbnRpYWxseSAnZW5kJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwOyAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cblxuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUJ1ZmZlckdldHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7IC8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxuXG5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIHJlYWxIYXNJbnN0YW5jZShvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpOyAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFdyaXRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgaWYgKCFpc0R1cGxleCAmJiAhcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3kuXG5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufSAvLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5cblxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFKCkpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCgpOyAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuXG4gIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG59IC8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cblxuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgZXI7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInXSwgY2h1bmspO1xuICB9XG5cbiAgaWYgKGVyKSB7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcbiAgaWYgKHN0YXRlLmVuZGluZykgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTsgLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cblxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG5cbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cblxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrOyAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cblxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpKTtlbHNlIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcblxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCk7XG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKSB8fCBzdHJlYW0uZGVzdHJveWVkO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn0gLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5cblxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufSAvLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuXG5cbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcblxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpOyAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tOyAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3dyaXRlKCknKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpOyAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH0gLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuXG5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG5cbiAgICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAgIC8vIGlmIHRoZSByZWFkYWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgICAgICAgaWYgKCFyU3RhdGUgfHwgclN0YXRlLmF1dG9EZXN0cm95ICYmIHJTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcblxuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3MubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG5cbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH0gLy8gcmV1c2UgdGhlIGZyZWUgY29ya1JlcS5cblxuXG4gIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIEVFbGlzdGVuZXJDb3VudChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBkZWJ1ZztcblxuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QnKTtcblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVDsgLy8gTGF6eSBsb2FkZWQgdG8gaW1wcm92ZSB0aGUgc3RhcnR1cCBwZXJmb3JtYW5jZS5cblxuXG52YXIgU3RyaW5nRGVjb2RlcjtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG52YXIgZnJvbTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTsgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcblxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB0aGlzLnBhdXNlZCA9IHRydWU7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG5cbiAgdGhpcy5hd2FpdERyYWluID0gMDsgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG5cbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTsgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgUmVhZGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3lcblxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsgLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cblxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59OyAvLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICBkZWJ1ZygncmVhZGFibGVBZGRDaHVuaycsIGNodW5rKTtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuXG4gICAgaWYgKGVyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCgpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRigpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IC8vIFdlIGNhbiBwdXNoIG1vcmUgZGF0YSBpZiB3ZSBhcmUgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmsuXG4gIC8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lIG1vcmUgYnl0ZXMuXG4gIC8vIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsIHN1Y2ggYXMgdGhlIHJlcGwuXG5cblxuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cblxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcblxuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKTtcbiAgfVxuXG4gIHJldHVybiBlcjtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyOyAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7IC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG5cbiAgdmFyIHAgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5oZWFkO1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIHdoaWxlIChwICE9PSBudWxsKSB7XG4gICAgY29udGVudCArPSBkZWNvZGVyLndyaXRlKHAuZGF0YSk7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XG5cbiAgaWYgKGNvbnRlbnQgIT09ICcnKSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5wdXNoKGNvbnRlbnQpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoO1xuICByZXR1cm4gdGhpcztcbn07IC8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxR0JcblxuXG52YXIgTUFYX0hXTSA9IDB4NDAwMDAwMDA7XG5cbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIC8vIFRPRE8ocm9uYWcpOiBUaHJvdyBFUlJfVkFMVUVfT1VUX09GX1JBTkdFLlxuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cblxuICByZXR1cm4gbjtcbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcblxuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfSAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cblxuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuOyAvLyBEb24ndCBoYXZlIGVub3VnaFxuXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn0gLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoKHN0YXRlLmhpZ2hXYXRlck1hcmsgIT09IDAgPyBzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayA6IHN0YXRlLmxlbmd0aCA+IDApIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTsgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuXG5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpOyAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9IC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cblxuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7IC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG5cbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuXG4gICAgc3RhdGUuc3luYyA9IGZhbHNlOyAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cblxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cblxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJyk7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcblxuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnN5bmMpIHtcbiAgICAvLyBpZiB3ZSBhcmUgc3luYywgd2FpdCB1bnRpbCBuZXh0IHRpY2sgdG8gZW1pdCB0aGUgZGF0YS5cbiAgICAvLyBPdGhlcndpc2Ugd2UgcmlzayBlbWl0dGluZyBkYXRhIGluIHRoZSBmbG93KClcbiAgICAvLyB0aGUgcmVhZGFibGUgY29kZSB0cmlnZ2VycyBkdXJpbmcgYSByZWFkKCkgY2FsbFxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfVxuICB9XG59IC8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5uZWVkUmVhZGFibGUsIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSk7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuXG4gIGlmICghc3RhdGUuZGVzdHJveWVkICYmIChzdGF0ZS5sZW5ndGggfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIH0gLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXG4gIC8vIDEuIEl0IGlzIG5vdCBmbG93aW5nLCBhcyB0aGUgZmxvdyBtZWNoYW5pc20gd2lsbCB0YWtlXG4gIC8vICAgIGNhcmUgb2YgaXQuXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cbiAgLy8gMy4gSXQgaXMgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmssIHNvIHdlIGNhbiBzY2hlZHVsZVxuICAvLyAgICBhbm90aGVyIHJlYWRhYmxlIGxhdGVyLlxuXG5cbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICBmbG93KHN0cmVhbSk7XG59IC8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuXG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWFkIG1vcmUgZGF0YSBpZiB3ZSBzaG91bGQuXG4gIC8vXG4gIC8vIFRoZSBjb25kaXRpb25zIGZvciByZWFkaW5nIG1vcmUgZGF0YSBhcmUgKG9uZSBvZik6XG4gIC8vIC0gTm90IGVub3VnaCBkYXRhIGJ1ZmZlcmVkIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKS4gVGhlIGxvb3BcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXG4gIC8vICAgaXMgYXZhaWxhYmxlLiBJZiBoaWdoV2F0ZXJNYXJrIGlzIDAgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZsb3dpbmcgbW9kZVxuICAvLyAgIHdlIHNob3VsZCBfbm90XyBhdHRlbXB0IHRvIGJ1ZmZlciBhbnkgZXh0cmEgZGF0YS4gV2UnbGwgZ2V0IG1vcmUgZGF0YVxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cbiAgLy8gLSBObyBkYXRhIGluIHRoZSBidWZmZXIsIGFuZCB0aGUgc3RyZWFtIGlzIGluIGZsb3dpbmcgbW9kZS4gSW4gdGhpcyBtb2RlXG4gIC8vICAgdGhlIGxvb3AgYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHJlYWQoKSBpcyBjYWxsZWQuIEZhaWxpbmcgdG9cbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXG4gIC8vICAgY29udGludWluZyB0aGUgZmxvdyBpZiB0aGUgc3RyZWFtIGNvbnN1bWVyIGhhcyBqdXN0IHN1YnNjcmliZWQgdG8gdGhlXG4gIC8vICAgJ2RhdGEnIGV2ZW50LlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgYWJvdmUgY29uZGl0aW9ucyB0byBrZWVwIHJlYWRpbmcgZGF0YSwgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIHByZXZlbnQgdGhlIGRhdGEgZnJvbSBiZWluZyByZWFkOlxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXG4gIC8vIC0gVGhlcmUgaXMgYWxyZWFkeSBhIHBlbmRpbmcgJ3JlYWQnIG9wZXJhdGlvbiAoc3RhdGUucmVhZGluZykuIFRoaXMgaXMgYVxuICAvLyAgIGNhc2Ugd2hlcmUgdGhlIHRoZSBzdHJlYW0gaGFzIGNhbGxlZCB0aGUgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBfcmVhZCgpXG4gIC8vICAgbWV0aG9kLCBidXQgdGhleSBhcmUgcHJvY2Vzc2luZyB0aGUgY2FsbCBhc3luY2hyb25vdXNseSBhbmQgaGF2ZSBfbm90X1xuICAvLyAgIGNhbGxlZCBwdXNoKCkgd2l0aCBuZXcgZGF0YS4gSW4gdGhpcyBjYXNlIHdlIHNraXAgcGVyZm9ybWluZyBtb3JlXG4gIC8vICAgcmVhZCgpcy4gVGhlIGV4ZWN1dGlvbiBlbmRzIGluIHRoaXMgbWV0aG9kIGFnYWluIGFmdGVyIHRoZSBfcmVhZCgpIGVuZHNcbiAgLy8gICB1cCBjYWxsaW5nIHB1c2goKSB3aXRoIG1vcmUgZGF0YS5cbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aCkgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn0gLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcblxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH0gLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG5cblxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7IC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgY2xlYW5lZFVwID0gdHJ1ZTsgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBkZWJ1ZygnZGVzdC53cml0ZScsIHJldCk7XG5cbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cblxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9IC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG5cblxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBlcnJvck9yRGVzdHJveShkZXN0LCBlcik7XG4gIH0gLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuXG5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpOyAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH0gLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cblxuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7IC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gcGlwZU9uRHJhaW5GdW5jdGlvblJlc3VsdCgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH07IC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7IC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlczsgLy8gZ290IGEgbWF0Y2guXG5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuXG5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICByZXR1cm4gdGhpcztcbn07IC8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5cblxuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyB1cGRhdGUgcmVhZGFibGVMaXN0ZW5pbmcgc28gdGhhdCByZXN1bWUoKSBtYXkgYmUgYSBuby1vcFxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cbiAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7IC8vIFRyeSBzdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcblxuICAgIGlmIChzdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKTtcblxuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnIHx8IGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG5cbiAgaWYgKHN0YXRlLnJlc3VtZVNjaGVkdWxlZCAmJiAhc3RhdGUucGF1c2VkKSB7XG4gICAgLy8gZmxvd2luZyBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZSBub3csIG90aGVyd2lzZVxuICAgIC8vIHRoZSB1cGNvbWluZyByZXN1bWUgd2lsbCBub3QgZmxvdy5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsgLy8gY3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWVcbiAgfSBlbHNlIGlmIChzZWxmLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICBzZWxmLnJlc3VtZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn0gLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpOyAvLyB3ZSBmbG93IG9ubHkgaWYgdGhlcmUgaXMgbm8gb25lIGxpc3RlbmluZ1xuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxuICAgIC8vIHJlc3VtZSgpXG5cbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpO1xuXG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnBhdXNlZCA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuXG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHtcbiAgICA7XG4gIH1cbn0gLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOyAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcblxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcblxuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTsgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cblxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9IC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cblxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH0gLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cblxuXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG5cbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKTtcbiAgfTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUZsb3dpbmcnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IHN0YXRlO1xuICAgIH1cbiAgfVxufSk7IC8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZScsIHN0YXRlLmVuZEVtaXR0ZWQpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7IC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgIC8vIGlmIHRoZSB3cml0YWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuXG4gICAgICBpZiAoIXdTdGF0ZSB8fCB3U3RhdGUuYXV0b0Rlc3Ryb3kgJiYgd1N0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbShSZWFkYWJsZSwgaXRlcmFibGUsIG9wdHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn0iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEaXIge1xuICBjb25zdHJ1Y3RvciAocHJvcHMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wcylcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHRvUGF0aENvbXBvbmVudHMgPSAocGF0aCA9ICcnKSA9PiB7XG4gIC8vIHNwbGl0IG9uIC8gdW5sZXNzIGVzY2FwZWQgd2l0aCBcXFxuICByZXR1cm4gKHBhdGhcbiAgICAudHJpbSgpXG4gICAgLm1hdGNoKC8oW15cXFxcXi9dfFxcXFxcXC8pKy9nKSB8fCBbXSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QYXRoQ29tcG9uZW50c1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZpcnN0ID0gYXN5bmMgKGl0ZXJhdG9yKSA9PiB7XG4gIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgaXRlcmF0b3IpIHtcbiAgICByZXR1cm4gZW50cnlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpcnN0XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBEQUdMaW5rLFxuICBEQUdOb2RlXG59ID0gcmVxdWlyZSgnaXBsZC1kYWctcGInKVxuY29uc3QgVW5peEZTID0gcmVxdWlyZSgnaXBmcy11bml4ZnMnKVxuY29uc3QgRGlyID0gcmVxdWlyZSgnLi9kaXInKVxuY29uc3QgcGVyc2lzdCA9IHJlcXVpcmUoJy4vdXRpbHMvcGVyc2lzdCcpXG5cbmNsYXNzIERpckZsYXQgZXh0ZW5kcyBEaXIge1xuICBjb25zdHJ1Y3RvciAocHJvcHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihwcm9wcywgb3B0aW9ucylcbiAgICB0aGlzLl9jaGlsZHJlbiA9IHt9XG4gIH1cblxuICBwdXQgKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5jaWQgPSB1bmRlZmluZWRcbiAgICB0aGlzLnNpemUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9jaGlsZHJlbltuYW1lXSA9IHZhbHVlXG4gIH1cblxuICBnZXQgKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW5bbmFtZV1cbiAgfVxuXG4gIGNoaWxkQ291bnQgKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jaGlsZHJlbikubGVuZ3RoXG4gIH1cblxuICBkaXJlY3RDaGlsZHJlbkNvdW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZENvdW50KClcbiAgfVxuXG4gIG9ubHlDaGlsZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW09iamVjdC5rZXlzKHRoaXMuX2NoaWxkcmVuKVswXV1cbiAgfVxuXG4gICogZWFjaENoaWxkU2VyaWVzICgpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5fY2hpbGRyZW4pXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV1cblxuICAgICAgeWllbGQge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgY2hpbGQ6IHRoaXMuX2NoaWxkcmVuW2tleV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyAqIGZsdXNoIChwYXRoLCBpcGxkKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBPYmplY3Qua2V5cyh0aGlzLl9jaGlsZHJlbilcbiAgICBjb25zdCBsaW5rcyA9IFtdXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltjaGlsZHJlbltpXV1cblxuICAgICAgaWYgKHR5cGVvZiBjaGlsZC5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIGNoaWxkLmZsdXNoKGNoaWxkLnBhdGgsIGlwbGQpKSB7XG4gICAgICAgICAgY2hpbGQgPSBlbnRyeVxuXG4gICAgICAgICAgeWllbGQgY2hpbGRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaW5rcy5wdXNoKG5ldyBEQUdMaW5rKGNoaWxkcmVuW2ldLCBjaGlsZC5ub2RlLmxlbmd0aCB8fCBjaGlsZC5ub2RlLnNpemUsIGNoaWxkLmNpZCkpXG4gICAgfVxuXG4gICAgY29uc3QgdW5peGZzID0gbmV3IFVuaXhGUygnZGlyZWN0b3J5JylcbiAgICBsZXQgbm9kZSA9IERBR05vZGUuY3JlYXRlKHVuaXhmcy5tYXJzaGFsKCksIGxpbmtzKVxuICAgIGNvbnN0IGNpZCA9IGF3YWl0IHBlcnNpc3Qobm9kZSwgaXBsZCwgdGhpcy5vcHRpb25zKVxuXG4gICAgdGhpcy5jaWQgPSBjaWRcbiAgICB0aGlzLnNpemUgPSBub2RlLnNpemVcblxuICAgIHlpZWxkIHtcbiAgICAgIGNpZCxcbiAgICAgIHVuaXhmcyxcbiAgICAgIHBhdGgsXG4gICAgICBub2RlXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlyRmxhdFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERpclNoYXJkZWQgPSByZXF1aXJlKCcuL2Rpci1zaGFyZGVkJylcblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYyBmdW5jdGlvbiBmbGF0VG9TaGFyZCAoY2hpbGQsIGRpciwgdGhyZXNob2xkLCBvcHRpb25zKSB7XG4gIGxldCBuZXdEaXIgPSBkaXJcblxuICBpZiAoZGlyLmZsYXQgJiYgZGlyLmRpcmVjdENoaWxkcmVuQ291bnQoKSA+PSB0aHJlc2hvbGQpIHtcbiAgICBuZXdEaXIgPSBhd2FpdCBjb252ZXJ0VG9TaGFyZChkaXIsIG9wdGlvbnMpXG4gIH1cblxuICBjb25zdCBwYXJlbnQgPSBuZXdEaXIucGFyZW50XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIGlmIChuZXdEaXIgIT09IGRpcikge1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG5ld0RpclxuICAgICAgfVxuXG4gICAgICBhd2FpdCBwYXJlbnQucHV0KG5ld0Rpci5wYXJlbnRLZXksIG5ld0RpcilcbiAgICB9XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICByZXR1cm4gZmxhdFRvU2hhcmQobmV3RGlyLCBwYXJlbnQsIHRocmVzaG9sZCwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3RGlyXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRUb1NoYXJkIChvbGREaXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgbmV3RGlyID0gbmV3IERpclNoYXJkZWQoe1xuICAgIHJvb3Q6IG9sZERpci5yb290LFxuICAgIGRpcjogdHJ1ZSxcbiAgICBwYXJlbnQ6IG9sZERpci5wYXJlbnQsXG4gICAgcGFyZW50S2V5OiBvbGREaXIucGFyZW50S2V5LFxuICAgIHBhdGg6IG9sZERpci5wYXRoLFxuICAgIGRpcnR5OiBvbGREaXIuZGlydHksXG4gICAgZmxhdDogZmFsc2VcbiAgfSwgb3B0aW9ucylcblxuICBmb3IgYXdhaXQgKGNvbnN0IHsga2V5LCBjaGlsZCB9IG9mIG9sZERpci5lYWNoQ2hpbGRTZXJpZXMoKSkge1xuICAgIGF3YWl0IG5ld0Rpci5wdXQoa2V5LCBjaGlsZClcbiAgfVxuXG4gIHJldHVybiBuZXdEaXJcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG4vLyBtYWtlIHN1cmUgdGhlIGNvbnRlbnQgb25seSBlbWl0cyBidWZmZXItYS1saWtlc1xuYXN5bmMgZnVuY3Rpb24gKiB2YWxpZGF0ZUNodW5rcyAoc291cmNlKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY29udGVudCBvZiBzb3VyY2UpIHtcbiAgICBpZiAoY29udGVudC5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ0NvbnRlbnQgd2FzIGludmFsaWQnKSwgJ0VSUl9JTlZBTElEX0NPTlRFTlQnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycgfHwgY29udGVudCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgeWllbGQgQnVmZmVyLmZyb20oY29udGVudCwgJ3V0ZjgnKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50KSkge1xuICAgICAgeWllbGQgQnVmZmVyLmZyb20oY29udGVudClcbiAgICB9IGVsc2Uge1xuICAgICAgeWllbGQgY29udGVudFxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRlQ2h1bmtzXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgVW5peEZTID0gcmVxdWlyZSgnaXBmcy11bml4ZnMnKVxuY29uc3QgcGVyc2lzdCA9IHJlcXVpcmUoJy4uL3V0aWxzL3BlcnNpc3QnKVxuY29uc3Qge1xuICBEQUdOb2RlXG59ID0gcmVxdWlyZSgnaXBsZC1kYWctcGInKVxuXG5jb25zdCBkaXJCdWlsZGVyID0gYXN5bmMgKGl0ZW0sIGlwbGQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgdW5peGZzID0gbmV3IFVuaXhGUygnZGlyZWN0b3J5JylcbiAgY29uc3Qgbm9kZSA9IERBR05vZGUuY3JlYXRlKHVuaXhmcy5tYXJzaGFsKCksIFtdKVxuICBjb25zdCBjaWQgPSBhd2FpdCBwZXJzaXN0KG5vZGUsIGlwbGQsIG9wdGlvbnMpXG4gIGxldCBwYXRoID0gaXRlbS5wYXRoXG5cbiAgcmV0dXJuIHtcbiAgICBjaWQsXG4gICAgcGF0aCxcbiAgICB1bml4ZnMsXG4gICAgbm9kZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGlyQnVpbGRlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCBVbml4RlMgPSByZXF1aXJlKCdpcGZzLXVuaXhmcycpXG5jb25zdCBwZXJzaXN0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcGVyc2lzdCcpXG5jb25zdCB7XG4gIERBR05vZGUsXG4gIERBR0xpbmtcbn0gPSByZXF1aXJlKCdpcGxkLWRhZy1wYicpXG5jb25zdCBhbGwgPSByZXF1aXJlKCdhc3luYy1pdGVyYXRvci1hbGwnKVxuXG5jb25zdCBkYWdCdWlsZGVycyA9IHtcbiAgZmxhdDogcmVxdWlyZSgnLi9mbGF0JyksXG4gIGJhbGFuY2VkOiByZXF1aXJlKCcuL2JhbGFuY2VkJyksXG4gIHRyaWNrbGU6IHJlcXVpcmUoJy4vdHJpY2tsZScpXG59XG5cbmFzeW5jIGZ1bmN0aW9uICogYnVpbGRGaWxlIChzb3VyY2UsIGlwbGQsIG9wdGlvbnMpIHtcbiAgbGV0IGNvdW50ID0gLTFcbiAgbGV0IHByZXZpb3VzXG5cbiAgZm9yIGF3YWl0IChjb25zdCBidWZmZXIgb2Ygc291cmNlKSB7XG4gICAgY291bnQrK1xuICAgIG9wdGlvbnMucHJvZ3Jlc3MoYnVmZmVyLmxlbmd0aClcbiAgICBsZXQgbm9kZVxuICAgIGxldCB1bml4ZnNcblxuICAgIGxldCBvcHRzID0ge1xuICAgICAgLi4ub3B0aW9uc1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnJhd0xlYXZlcykge1xuICAgICAgbm9kZSA9IGJ1ZmZlclxuXG4gICAgICBvcHRzLmNvZGVjID0gJ3JhdydcbiAgICAgIG9wdHMuY2lkVmVyc2lvbiA9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgdW5peGZzID0gbmV3IFVuaXhGUyhvcHRpb25zLmxlYWZUeXBlLCBidWZmZXIpXG4gICAgICBub2RlID0gREFHTm9kZS5jcmVhdGUodW5peGZzLm1hcnNoYWwoKSwgW10pXG4gICAgfVxuXG4gICAgY29uc3QgY2lkID0gYXdhaXQgcGVyc2lzdChub2RlLCBpcGxkLCBvcHRzKVxuXG4gICAgY29uc3QgZW50cnkgPSB7XG4gICAgICBjaWQ6IGNpZCxcbiAgICAgIHVuaXhmcyxcbiAgICAgIG5vZGVcbiAgICB9XG5cbiAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgIHByZXZpb3VzID0gZW50cnlcbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgeWllbGQgcHJldmlvdXNcbiAgICAgIHByZXZpb3VzID0gbnVsbFxuICAgIH1cblxuICAgIHlpZWxkIGVudHJ5XG4gIH1cblxuICBpZiAocHJldmlvdXMpIHtcbiAgICBwcmV2aW91cy5zaW5nbGUgPSB0cnVlXG4gICAgeWllbGQgcHJldmlvdXNcbiAgfVxufVxuXG5jb25zdCByZWR1Y2UgPSAoZmlsZSwgaXBsZCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKGxlYXZlcykge1xuICAgIGlmIChsZWF2ZXMubGVuZ3RoID09PSAxICYmIGxlYXZlc1swXS5zaW5nbGUgJiYgb3B0aW9ucy5yZWR1Y2VTaW5nbGVMZWFmVG9TZWxmKSB7XG4gICAgICBjb25zdCBsZWFmID0gbGVhdmVzWzBdXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNpZDogbGVhZi5jaWQsXG4gICAgICAgIHBhdGg6IGZpbGUucGF0aCxcbiAgICAgICAgbmFtZTogKGZpbGUucGF0aCB8fCAnJykuc3BsaXQoJy8nKS5wb3AoKSxcbiAgICAgICAgdW5peGZzOiBsZWFmLnVuaXhmcyxcbiAgICAgICAgbm9kZTogbGVhZi5ub2RlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGEgcGFyZW50IG5vZGUgYW5kIGFkZCBhbGwgdGhlIGxlYXZlc1xuICAgIGNvbnN0IGYgPSBuZXcgVW5peEZTKCdmaWxlJylcblxuICAgIGNvbnN0IGxpbmtzID0gbGVhdmVzXG4gICAgICAuZmlsdGVyKGxlYWYgPT4ge1xuICAgICAgICBpZiAobGVhZi5jaWQuY29kZWMgPT09ICdyYXcnICYmIGxlYWYubm9kZS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsZWFmLnVuaXhmcy5kYXRhICYmIGxlYWYudW5peGZzLmZpbGVTaXplKCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEJvb2xlYW4obGVhZi51bml4ZnMuZGF0YS5sZW5ndGgpXG4gICAgICB9KVxuICAgICAgLm1hcCgobGVhZikgPT4ge1xuICAgICAgICBpZiAobGVhZi5jaWQuY29kZWMgPT09ICdyYXcnKSB7XG4gICAgICAgICAgLy8gbm9kZSBpcyBhIGxlYWYgYnVmZmVyXG4gICAgICAgICAgZi5hZGRCbG9ja1NpemUobGVhZi5ub2RlLmxlbmd0aClcblxuICAgICAgICAgIHJldHVybiBuZXcgREFHTGluayhsZWFmLm5hbWUsIGxlYWYubm9kZS5sZW5ndGgsIGxlYWYuY2lkKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsZWFmLnVuaXhmcy5kYXRhKSB7XG4gICAgICAgICAgLy8gbm9kZSBpcyBhbiBpbnRlcm1lZGlhdGUgbm9kZVxuICAgICAgICAgIGYuYWRkQmxvY2tTaXplKGxlYWYudW5peGZzLmZpbGVTaXplKCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm9kZSBpcyBhIHVuaXhmcyAnZmlsZScgbGVhZiBub2RlXG4gICAgICAgICAgZi5hZGRCbG9ja1NpemUobGVhZi51bml4ZnMuZGF0YS5sZW5ndGgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERBR0xpbmsobGVhZi5uYW1lLCBsZWFmLm5vZGUuc2l6ZSwgbGVhZi5jaWQpXG4gICAgICB9KVxuXG4gICAgY29uc3Qgbm9kZSA9IERBR05vZGUuY3JlYXRlKGYubWFyc2hhbCgpLCBsaW5rcylcbiAgICBjb25zdCBjaWQgPSBhd2FpdCBwZXJzaXN0KG5vZGUsIGlwbGQsIG9wdGlvbnMpXG5cbiAgICByZXR1cm4ge1xuICAgICAgY2lkLFxuICAgICAgcGF0aDogZmlsZS5wYXRoLFxuICAgICAgdW5peGZzOiBmLFxuICAgICAgbm9kZSxcbiAgICAgIHNpemU6IG5vZGUuc2l6ZVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBmaWxlQnVpbGRlciA9IGFzeW5jIChmaWxlLCBzb3VyY2UsIGlwbGQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZGFnQnVpbGRlciA9IGRhZ0J1aWxkZXJzW29wdGlvbnMuc3RyYXRlZ3ldXG5cbiAgaWYgKCFkYWdCdWlsZGVyKSB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYFVua25vd24gaW1wb3J0ZXIgYnVpbGQgc3RyYXRlZ3kgbmFtZTogJHtvcHRpb25zLnN0cmF0ZWd5fWApLCAnRVJSX0JBRF9TVFJBVEVHWScpXG4gIH1cblxuICBjb25zdCByb290cyA9IGF3YWl0IGFsbChkYWdCdWlsZGVyKGJ1aWxkRmlsZShzb3VyY2UsIGlwbGQsIG9wdGlvbnMpLCByZWR1Y2UoZmlsZSwgaXBsZCwgb3B0aW9ucyksIG9wdGlvbnMuYnVpbGRlck9wdGlvbnMpKVxuXG4gIGlmIChyb290cy5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2V4cGVjdGVkIGEgbWF4aW11bSBvZiAxIHJvb3RzIGFuZCBnb3QgJyArIHJvb3RzLmxlbmd0aCksICdFVE9PTUFOWVJPT1RTJylcbiAgfVxuXG4gIHJldHVybiByb290c1swXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbGVCdWlsZGVyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuY29uc3QgY2h1bmtlcnMgPSB7XG4gIGZpeGVkOiByZXF1aXJlKCcuLi9jaHVua2VyL2ZpeGVkLXNpemUnKSxcbiAgcmFiaW46IHJlcXVpcmUoJy4uL2NodW5rZXIvcmFiaW4nKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICh0eXBlLCBzb3VyY2UsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgY2h1bmtlciA9IGNodW5rZXJzW3R5cGVdXG5cbiAgaWYgKCFjaHVua2VyKSB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYFVua25rb3duIGNodW5rZXIgbmFtZWQgJHt0eXBlfWApLCAnRVJSX1VOS05PV05fQ0hVTktFUicpXG4gIH1cblxuICByZXR1cm4gY2h1bmtlcihzb3VyY2UsIG9wdGlvbnMpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgY29kZXMgPSB7fTtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0c0xvb3NlKE5vZGVFcnJvciwgX0Jhc2UpO1xuXG4gICAgZnVuY3Rpb24gTm9kZUVycm9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHJldHVybiBfQmFzZS5jYWxsKHRoaXMsIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBOb2RlRXJyb3IucHJvdG90eXBlLm5hbWUgPSBCYXNlLm5hbWU7XG4gIE5vZGVFcnJvci5wcm90b3R5cGUuY29kZSA9IGNvZGU7XG4gIGNvZGVzW2NvZGVdID0gTm9kZUVycm9yO1xufSAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTAuOC4wL2xpYi9pbnRlcm5hbC9lcnJvcnMuanNcblxuXG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgdmFyIGxlbiA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpKTtcbiAgICB9KTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyksIFwiLCBvciBcIikgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChTdHJpbmcoZXhwZWN0ZWQpKTtcbiAgfVxufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxuXG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gsIHBvcykge1xuICByZXR1cm4gc3RyLnN1YnN0cighcG9zIHx8IHBvcyA8IDAgPyAwIDogK3Bvcywgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cblxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xuXG5cbmZ1bmN0aW9uIGluY2x1ZGVzKHN0ciwgc2VhcmNoLCBzdGFydCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChzdGFydCArIHNlYXJjaC5sZW5ndGggPiBzdHIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihzZWFyY2gsIHN0YXJ0KSAhPT0gLTE7XG4gIH1cbn1cblxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9PUFRfVkFMVUUnLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuICdUaGUgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwiJyArIG5hbWUgKyAnXCInO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuICB2YXIgZGV0ZXJtaW5lcjtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBzdGFydHNXaXRoKGV4cGVjdGVkLCAnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgdmFyIG1zZztcblxuICBpZiAoZW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfVxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQodHlwZW9mIGFjdHVhbCk7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GJywgJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdUaGUgJyArIG5hbWUgKyAnIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQnO1xufSk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJywgJ1ByZW1hdHVyZSBjbG9zZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0RFU1RST1lFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnQ2Fubm90IGNhbGwgJyArIG5hbWUgKyAnIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQnO1xufSk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NVUxUSVBMRV9DQUxMQkFDSycsICdDYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9DQU5OT1RfUElQRScsICdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EJywgJ3dyaXRlIGFmdGVyIGVuZCcpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX05VTExfVkFMVUVTJywgJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJywgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1VOS05PV05fRU5DT0RJTkcnLCBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiAnVW5rbm93biBlbmNvZGluZzogJyArIGFyZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQnLCAnc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7XG4iLCIndXNlIHN0cmljdCc7IC8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcblxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9IC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcblxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcbiAgZW1pdENsb3NlTlQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGVtaXRDbG9zZU5UKHNlbGYpIHtcbiAgaWYgKHNlbGYuX3dyaXRhYmxlU3RhdGUgJiYgIXNlbGYuX3dyaXRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIGlmIChzZWxmLl9yZWFkYWJsZVN0YXRlICYmICFzZWxmLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHtcbiAgLy8gV2UgaGF2ZSB0ZXN0cyB0aGF0IHJlbHkgb24gZXJyb3JzIGJlaW5nIGVtaXR0ZWRcbiAgLy8gaW4gdGhlIHNhbWUgdGljaywgc28gY2hhbmdpbmcgdGhpcyBpcyBzZW12ZXIgbWFqb3IuXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XG4gIC8vIHRoZSBlcnJvciB0byBiZSBlbWl0dGVkIG5leHRUaWNrLiBJbiBhIGZ1dHVyZVxuICAvLyBzZW12ZXIgbWFqb3IgdXBkYXRlIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGRlZmF1bHQgdG8gdGhpcy5cbiAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHJTdGF0ZSAmJiByU3RhdGUuYXV0b0Rlc3Ryb3kgfHwgd1N0YXRlICYmIHdTdGF0ZS5hdXRvRGVzdHJveSkgc3RyZWFtLmRlc3Ryb3koZXJyKTtlbHNlIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveSxcbiAgZXJyb3JPckRlc3Ryb3k6IGVycm9yT3JEZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX0lOVkFMSURfT1BUX1ZBTFVFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX0lOVkFMSURfT1BUX1ZBTFVFO1xuXG5mdW5jdGlvbiBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KSB7XG4gIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0SGlnaFdhdGVyTWFyayhzdGF0ZSwgb3B0aW9ucywgZHVwbGV4S2V5LCBpc0R1cGxleCkge1xuICB2YXIgaHdtID0gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSk7XG5cbiAgaWYgKGh3bSAhPSBudWxsKSB7XG4gICAgaWYgKCEoaXNGaW5pdGUoaHdtKSAmJiBNYXRoLmZsb29yKGh3bSkgPT09IGh3bSkgfHwgaHdtIDwgMCkge1xuICAgICAgdmFyIG5hbWUgPSBpc0R1cGxleCA/IGR1cGxleEtleSA6ICdoaWdoV2F0ZXJNYXJrJztcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9PUFRfVkFMVUUobmFtZSwgaHdtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcihod20pO1xuICB9IC8vIERlZmF1bHQgdmFsdWVcblxuXG4gIHJldHVybiBzdGF0ZS5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRIaWdoV2F0ZXJNYXJrOiBnZXRIaWdoV2F0ZXJNYXJrXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWRhYmxlLmZyb20gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3NlcicpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdidWZmZXInKSxcbiAgICBCdWZmZXIgPSBfcmVxdWlyZS5CdWZmZXI7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsJyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xuXG52YXIgY3VzdG9tID0gaW5zcGVjdCAmJiBpbnNwZWN0LmN1c3RvbSB8fCAnaW5zcGVjdCc7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbChzcmMsIHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQnVmZmVyTGlzdCwgW3tcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogdGhpcy5oZWFkXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgLS10aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiam9pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25jYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBvciBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25zdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnN1bWUobiwgaGFzU3RyaW5ncykge1xuICAgICAgdmFyIHJldDtcblxuICAgICAgaWYgKG4gPCB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gYHNsaWNlYCBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgICAgcmV0ID0gdGhpcy5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgICAgIHRoaXMuaGVhZC5kYXRhID0gdGhpcy5oZWFkLmRhdGEuc2xpY2Uobik7XG4gICAgICB9IGVsc2UgaWYgKG4gPT09IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBGaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2guXG4gICAgICAgIHJldCA9IHRoaXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlci5cbiAgICAgICAgcmV0ID0gaGFzU3RyaW5ncyA/IHRoaXMuX2dldFN0cmluZyhuKSA6IHRoaXMuX2dldEJ1ZmZlcihuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RyaW5nKG4pIHtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgdmFyIHJldCA9IHAuZGF0YTtcbiAgICAgIG4gLT0gcmV0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCdWZmZXIobikge1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgcC5kYXRhLmNvcHkocmV0KTtcbiAgICAgIG4gLT0gcC5kYXRhLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICAgICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgICAgICBuIC09IG5iO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrYztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBNYWtlIHN1cmUgdGhlIGxpbmtlZCBsaXN0IG9ubHkgc2hvd3MgdGhlIG1pbmltYWwgbmVjZXNzYXJ5IGluZm9ybWF0aW9uLlxuXG4gIH0sIHtcbiAgICBrZXk6IGN1c3RvbSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoXywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGluc3BlY3QodGhpcywgX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAvLyBPbmx5IGluc3BlY3Qgb25lIGxldmVsLlxuICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgLy8gSXQgc2hvdWxkIG5vdCByZWN1cnNlLlxuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGZpbmlzaGVkID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG5cbnZhciBrTGFzdFJlc29sdmUgPSBTeW1ib2woJ2xhc3RSZXNvbHZlJyk7XG52YXIga0xhc3RSZWplY3QgPSBTeW1ib2woJ2xhc3RSZWplY3QnKTtcbnZhciBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG52YXIga0VuZGVkID0gU3ltYm9sKCdlbmRlZCcpO1xudmFyIGtMYXN0UHJvbWlzZSA9IFN5bWJvbCgnbGFzdFByb21pc2UnKTtcbnZhciBrSGFuZGxlUHJvbWlzZSA9IFN5bWJvbCgnaGFuZGxlUHJvbWlzZScpO1xudmFyIGtTdHJlYW0gPSBTeW1ib2woJ3N0cmVhbScpO1xuXG5mdW5jdGlvbiBjcmVhdGVJdGVyUmVzdWx0KHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6IGRvbmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuZFJlc29sdmUoaXRlcikge1xuICB2YXIgcmVzb2x2ZSA9IGl0ZXJba0xhc3RSZXNvbHZlXTtcblxuICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgIHZhciBkYXRhID0gaXRlcltrU3RyZWFtXS5yZWFkKCk7IC8vIHdlIGRlZmVyIGlmIGRhdGEgaXMgbnVsbFxuICAgIC8vIHdlIGNhbiBiZSBleHBlY3RpbmcgZWl0aGVyICdlbmQnIG9yXG4gICAgLy8gJ2Vycm9yJ1xuXG4gICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVhZGFibGUoaXRlcikge1xuICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCB0aWNrLCBiZWNhdXNlIGl0IG1pZ2h0XG4gIC8vIGVtaXQgYW4gZXJyb3Igd2l0aCBwcm9jZXNzLm5leHRUaWNrXG4gIHByb2Nlc3MubmV4dFRpY2socmVhZEFuZFJlc29sdmUsIGl0ZXIpO1xufVxuXG5mdW5jdGlvbiB3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgaXRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxhc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGl0ZXJba0VuZGVkXSkge1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlcltrSGFuZGxlUHJvbWlzZV0ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9LCByZWplY3QpO1xuICB9O1xufVxuXG52YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiAoKSB7fSk7XG52YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKChfT2JqZWN0JHNldFByb3RvdHlwZU8gPSB7XG4gIGdldCBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXNba1N0cmVhbV07XG4gIH0sXG5cbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBkZXRlY3RlZCBhbiBlcnJvciBpbiB0aGUgbWVhbndoaWxlXG4gICAgLy8gcmVqZWN0IHN0cmFpZ2h0IGF3YXlcbiAgICB2YXIgZXJyb3IgPSB0aGlzW2tFcnJvcl07XG5cbiAgICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0VuZGVkXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tTdHJlYW1dLmRlc3Ryb3llZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBkZWZlciB2aWEgbmV4dFRpY2sgYmVjYXVzZSBpZiAuZGVzdHJveShlcnIpIGlzXG4gICAgICAvLyBjYWxsZWQsIHRoZSBlcnJvciB3aWxsIGJlIGVtaXR0ZWQgdmlhIG5leHRUaWNrLCBhbmRcbiAgICAgIC8vIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCB0aGVyZSBpcyBubyBlcnJvciBsaW5nZXJpbmcgYXJvdW5kXG4gICAgICAvLyB3YWl0aW5nIHRvIGJlIGVtaXR0ZWQuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXNba0Vycm9yXSkge1xuICAgICAgICAgICAgcmVqZWN0KF90aGlzW2tFcnJvcl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBuZXh0KCkgY2FsbHNcbiAgICAvLyB3ZSB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBQcm9taXNlIHRvIGZpbmlzaFxuICAgIC8vIHRoaXMgbG9naWMgaXMgb3B0aW1pemVkIHRvIHN1cHBvcnQgZm9yIGF3YWl0IGxvb3BzLFxuICAgIC8vIHdoZXJlIG5leHQoKSBpcyBvbmx5IGNhbGxlZCBvbmNlIGF0IGEgdGltZVxuXG5cbiAgICB2YXIgbGFzdFByb21pc2UgPSB0aGlzW2tMYXN0UHJvbWlzZV07XG4gICAgdmFyIHByb21pc2U7XG5cbiAgICBpZiAobGFzdFByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYXN0IHBhdGggbmVlZGVkIHRvIHN1cHBvcnQgbXVsdGlwbGUgdGhpcy5wdXNoKClcbiAgICAgIC8vIHdpdGhvdXQgdHJpZ2dlcmluZyB0aGUgbmV4dCgpIHF1ZXVlXG4gICAgICB2YXIgZGF0YSA9IHRoaXNba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHRoaXNba0hhbmRsZVByb21pc2VdKTtcbiAgICB9XG5cbiAgICB0aGlzW2tMYXN0UHJvbWlzZV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBcInJldHVyblwiLCBmdW5jdGlvbiBfcmV0dXJuKCkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAvLyBkZXN0cm95KGVyciwgY2IpIGlzIGEgcHJpdmF0ZSBBUElcbiAgLy8gd2UgY2FuIGd1YXJhbnRlZSB3ZSBoYXZlIHRoYXQgaGVyZSwgYmVjYXVzZSB3ZSBjb250cm9sIHRoZVxuICAvLyBSZWFkYWJsZSBjbGFzcyB0aGlzIGlzIGF0dGFjaGVkIHRvXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgX3RoaXMyW2tTdHJlYW1dLmRlc3Ryb3kobnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfSk7XG4gIH0pO1xufSksIF9PYmplY3Qkc2V0UHJvdG90eXBlTyksIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuXG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHN0cmVhbSkge1xuICB2YXIgX09iamVjdCRjcmVhdGU7XG5cbiAgdmFyIGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIChfT2JqZWN0JGNyZWF0ZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtTdHJlYW0sIHtcbiAgICB2YWx1ZTogc3RyZWFtLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVzb2x2ZSwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVqZWN0LCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0Vycm9yLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0VuZGVkLCB7XG4gICAgdmFsdWU6IHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtIYW5kbGVQcm9taXNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGRhdGEgPSBpdGVyYXRvcltrU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gcmVzb2x2ZTtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gcmVqZWN0O1xuICAgICAgfVxuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9PYmplY3QkY3JlYXRlKSk7XG4gIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICBmaW5pc2hlZChzdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSB7XG4gICAgICB2YXIgcmVqZWN0ID0gaXRlcmF0b3Jba0xhc3RSZWplY3RdOyAvLyByZWplY3QgaWYgd2UgYXJlIHdhaXRpbmcgZm9yIGRhdGEgaW4gdGhlIFByb21pc2VcbiAgICAgIC8vIHJldHVybmVkIGJ5IG5leHQoKSBhbmQgc3RvcmUgdGhlIGVycm9yXG5cbiAgICAgIGlmIChyZWplY3QgIT09IG51bGwpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0b3Jba0Vycm9yXSA9IGVycjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZSA9IGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV07XG5cbiAgICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaXRlcmF0b3Jba0VuZGVkXSA9IHRydWU7XG4gIH0pO1xuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgb25SZWFkYWJsZS5iaW5kKG51bGwsIGl0ZXJhdG9yKSk7XG4gIHJldHVybiBpdGVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChvcHRpb25zID0ge30sIGRlZmF1bHRzKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMuZmlsdGVyKGFyZyA9PiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JykucG9wKCkgfHwge31cbiAgfVxuXG4gIGNvbnN0IG91dHB1dCA9IHt9XG5cbiAgZm9yIChsZXQga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKG9wdGlvbnNba2V5XSAhPT0gbnVsbCAmJiBvcHRpb25zW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3V0cHV0W2tleV0gPSBvcHRpb25zW2tleV1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0W2tleV0gPSBkZWZhdWx0c1trZXldXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZm9ybWF0ID0gb3V0cHV0LmZvcm1hdCB8fCBvdXRwdXQuY29kZWNcblxuICBpZiAoZm9ybWF0ICYmIGlzTmFOKGZvcm1hdCkpIHtcbiAgICBvdXRwdXQuZm9ybWF0ID0gZm9ybWF0XG4gICAgZGVsZXRlIG91dHB1dC5jb2RlY1xuICB9XG5cbiAgLy8gc3VwcG9ydCBsZWdhY3kgZ28gYXJndW1lbnRzXG4gIGlmIChvcHRpb25zLmNvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQubGVuZ3RoID0gb3B0aW9ucy5jb3VudFxuICB9XG5cbiAgaWYgKG9wdGlvbnMucCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LnBhcmVudHMgPSBvcHRpb25zLnBcbiAgfVxuXG4gIGlmIChvcHRpb25zLmwgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC5sb25nID0gb3B0aW9ucy5sXG4gIH1cblxuICBpZiAoIW91dHB1dC5sZW5ndGggJiYgb3V0cHV0Lmxlbmd0aCAhPT0gMCkge1xuICAgIG91dHB1dC5sZW5ndGggPSBJbmZpbml0eVxuICB9XG5cbiAgaWYgKG91dHB1dC5vZmZzZXQgPCAwKSB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCBoYXZlIG5lZ2F0aXZlIHdyaXRlIG9mZnNldCcpLCAnRVJSX0lOVkFMSURfUEFSQU1TJylcbiAgfVxuXG4gIGlmIChvdXRwdXQubGVuZ3RoIDwgMCkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgaGF2ZSBuZWdhdGl2ZSBieXRlIGNvdW50JyksICdFUlJfSU5WQUxJRF9QQVJBTVMnKVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgRklMRV9TRVBBUkFUT1Jcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBsb2FkTWZzUm9vdCA9IHJlcXVpcmUoJy4vd2l0aC1tZnMtcm9vdCcpXG5jb25zdCB0b1BhdGhDb21wb25lbnRzID0gcmVxdWlyZSgnLi90by1wYXRoLWNvbXBvbmVudHMnKVxuY29uc3QgZXhwb3J0ZXIgPSByZXF1aXJlKCdpcGZzLXVuaXhmcy1leHBvcnRlcicpXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG5jb25zdCBJUEZTX1BSRUZJWCA9ICdpcGZzJ1xuXG5jb25zdCB0b01mc1BhdGggPSBhc3luYyAoY29udGV4dCwgcGF0aCkgPT4ge1xuICBsZXQgb3V0cHV0QXJyYXkgPSBBcnJheS5pc0FycmF5KHBhdGgpXG4gIGxldCBwYXRocyA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogW3BhdGhdXG4gIGNvbnN0IHJvb3QgPSBhd2FpdCBsb2FkTWZzUm9vdChjb250ZXh0KVxuXG4gIHBhdGhzID0gcGF0aHMubWFwKHBhdGggPT4ge1xuICAgIHBhdGggPSAocGF0aCB8fCAnJykudHJpbSgpXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvKFxcL1xcLyspL2csICcvJylcblxuICAgIGlmIChwYXRoLmVuZHNXaXRoKCcvJykgJiYgcGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sZW5ndGggLSAxKVxuICAgIH1cblxuICAgIGlmICghcGF0aCkge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ3BhdGhzIG11c3Qgbm90IGJlIGVtcHR5JyksICdFUlJfTk9fUEFUSCcpXG4gICAgfVxuXG4gICAgaWYgKHBhdGguc3Vic3RyaW5nKDAsIDEpICE9PSBGSUxFX1NFUEFSQVRPUikge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYHBhdGhzIG11c3Qgc3RhcnQgd2l0aCBhIGxlYWRpbmcgJHtGSUxFX1NFUEFSQVRPUn1gKSwgJ0VSUl9JTlZBTElEX1BBVEgnKVxuICAgIH1cblxuICAgIGlmIChwYXRoLnN1YnN0cmluZyhwYXRoLmxlbmd0aCAtIEZJTEVfU0VQQVJBVE9SLmxlbmd0aCkgPT09IEZJTEVfU0VQQVJBVE9SKSB7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sZW5ndGggLSBGSUxFX1NFUEFSQVRPUi5sZW5ndGgpXG4gICAgfVxuXG4gICAgY29uc3QgcGF0aENvbXBvbmVudHMgPSB0b1BhdGhDb21wb25lbnRzKHBhdGgpXG5cbiAgICBpZiAocGF0aENvbXBvbmVudHNbMF0gPT09IElQRlNfUFJFRklYKSB7XG4gICAgICAvLyBlLmcuIC9pcGZzL1FNZm9vIG9yIC9pcGZzL1FtZm9vL3N1Yi9wYXRoXG4gICAgICBsZXQgbWZzRGlyZWN0b3J5XG5cbiAgICAgIGlmIChwYXRoQ29tcG9uZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgbWZzRGlyZWN0b3J5ID0gYCR7RklMRV9TRVBBUkFUT1J9JHtwYXRoQ29tcG9uZW50cy5qb2luKEZJTEVfU0VQQVJBVE9SKX1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZnNEaXJlY3RvcnkgPSBgJHtGSUxFX1NFUEFSQVRPUn0ke3BhdGhDb21wb25lbnRzLnNsaWNlKDAsIHBhdGhDb21wb25lbnRzLmxlbmd0aCAtIDEpLmpvaW4oRklMRV9TRVBBUkFUT1IpfWBcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2lwZnMnLFxuICAgICAgICBkZXB0aDogcGF0aENvbXBvbmVudHMubGVuZ3RoIC0gMixcblxuICAgICAgICBtZnNQYXRoOiBgJHtGSUxFX1NFUEFSQVRPUn0ke3BhdGhDb21wb25lbnRzLmpvaW4oRklMRV9TRVBBUkFUT1IpfWAsXG4gICAgICAgIG1mc0RpcmVjdG9yeSxcbiAgICAgICAgcGFydHM6IHBhdGhDb21wb25lbnRzLFxuICAgICAgICBwYXRoOiBgJHtGSUxFX1NFUEFSQVRPUn0ke3BhdGhDb21wb25lbnRzLmpvaW4oRklMRV9TRVBBUkFUT1IpfWAsXG4gICAgICAgIG5hbWU6IHBhdGhDb21wb25lbnRzW3BhdGhDb21wb25lbnRzLmxlbmd0aCAtIDFdXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWZzUGF0aCA9IGAvJHtJUEZTX1BSRUZJWH0vJHtyb290fSR7cGF0aENvbXBvbmVudHMubGVuZ3RoID8gJy8nICsgcGF0aENvbXBvbmVudHMuam9pbihGSUxFX1NFUEFSQVRPUikgOiAnJ31gXG4gICAgY29uc3QgbWZzRGlyZWN0b3J5ID0gYC8ke0lQRlNfUFJFRklYfS8ke3Jvb3R9LyR7cGF0aENvbXBvbmVudHMuc2xpY2UoMCwgcGF0aENvbXBvbmVudHMubGVuZ3RoIC0gMSkuam9pbihGSUxFX1NFUEFSQVRPUil9YFxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdtZnMnLFxuICAgICAgZGVwdGg6IHBhdGhDb21wb25lbnRzLmxlbmd0aCxcblxuICAgICAgbWZzRGlyZWN0b3J5LFxuICAgICAgbWZzUGF0aCxcbiAgICAgIHBhcnRzOiBwYXRoQ29tcG9uZW50cyxcbiAgICAgIHBhdGg6IGAke0ZJTEVfU0VQQVJBVE9SfSR7cGF0aENvbXBvbmVudHMuam9pbihGSUxFX1NFUEFSQVRPUil9YCxcbiAgICAgIG5hbWU6IHBhdGhDb21wb25lbnRzW3BhdGhDb21wb25lbnRzLmxlbmd0aCAtIDFdXG4gICAgfVxuICB9KVxuXG4gIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHBhdGhzLm1hcChhc3luYyAocGF0aCkgPT4ge1xuICAgICAgY29uc3QgY2lkUGF0aCA9IHBhdGgudHlwZSA9PT0gJ21mcycgPyBwYXRoLm1mc1BhdGggOiBwYXRoLnBhdGhcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZXhwb3J0ZXIoY2lkUGF0aCwgY29udGV4dC5pcGxkKVxuXG4gICAgICAgIHBhdGguY2lkID0gcmVzLmNpZFxuICAgICAgICBwYXRoLm1mc1BhdGggPSBgL2lwZnMvJHtyZXMucGF0aH1gXG4gICAgICAgIHBhdGgudW5peGZzID0gcmVzLnVuaXhmc1xuICAgICAgICBwYXRoLmNvbnRlbnQgPSByZXMuY29udGVudFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VSUl9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGF0aC5leGlzdHMgPSBCb29sZWFuKHBhdGguY2lkKVxuICAgIH0pXG4gIClcblxuICBpZiAob3V0cHV0QXJyYXkpIHtcbiAgICByZXR1cm4gcGF0aHNcbiAgfVxuXG4gIHJldHVybiBwYXRoc1swXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTWZzUGF0aFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEtleSA9IHJlcXVpcmUoJ2ludGVyZmFjZS1kYXRhc3RvcmUnKS5LZXlcblxuY29uc3QgRklMRV9UWVBFUyA9IHtcbiAgZmlsZTogMCxcbiAgZGlyZWN0b3J5OiAxLFxuICAnaGFtdC1zaGFyZGVkLWRpcmVjdG9yeSc6IDFcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEZJTEVfU0VQQVJBVE9SOiAnLycsXG4gIE1GU19ST09UX0tFWTogbmV3IEtleSgnL2xvY2FsL2ZpbGVzcm9vdCcpLFxuICBNQVhfQ0hVTktfU0laRTogMjYyMTQ0LFxuICBNQVhfTElOS1M6IDE3NCxcbiAgRklMRV9UWVBFU1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHRvTWZzUGF0aCA9IHJlcXVpcmUoJy4vdG8tbWZzLXBhdGgnKVxuXG5hc3luYyBmdW5jdGlvbiB0b1NvdXJjZXMgKGNvbnRleHQsIGFyZ3MpIHtcbiAgLy8gU3VwcG9ydCB3ZWlyZCBtZnMubXYoW3NvdXJjZSwgZGVzdF0sIG9wdGlvbnMsIGNhbGxiYWNrKSBzaWduYXR1cmVcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICBhcmdzID0gYXJnc1swXVxuICB9XG5cbiAgY29uc3Qgc291cmNlcyA9IGFyZ3NcbiAgICAuZmlsdGVyKGFyZyA9PiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJylcbiAgICAubWFwKHNvdXJjZSA9PiBzb3VyY2UudHJpbSgpKVxuXG4gIHJldHVybiB7XG4gICAgc291cmNlczogYXdhaXQgdG9NZnNQYXRoKGNvbnRleHQsIHNvdXJjZXMpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZXNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBsb2cgPSByZXF1aXJlKCdkZWJ1ZycpKCdpcGZzOm1mczp1dGlsczp1cGRhdGUtbWZzLXJvb3QnKVxuY29uc3Qge1xuICBNRlNfUk9PVF9LRVlcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmNvbnN0IHVwZGF0ZU1mc1Jvb3QgPSBhc3luYyAoY29udGV4dCwgY2lkKSA9PiB7XG4gIGxvZyhgTmV3IE1GUyByb290IHdpbGwgYmUgJHtjaWR9YClcblxuICBhd2FpdCBjb250ZXh0LnJlcG8uZGF0YXN0b3JlLnB1dChNRlNfUk9PVF9LRVksIGNpZC5idWZmZXIpXG5cbiAgcmV0dXJuIGNpZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVwZGF0ZU1mc1Jvb3RcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBsb2cgPSByZXF1aXJlKCdkZWJ1ZycpKCdpcGZzOm1mczp1dGlsczp1cGRhdGUtdHJlZScpXG5jb25zdCBhZGRMaW5rID0gcmVxdWlyZSgnLi9hZGQtbGluaycpXG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBzaGFyZFNwbGl0VGhyZXNob2xkOiAxMDAwXG59XG5cbi8vIGxvb3AgYmFja3dhcmRzIHRocm91Z2ggdGhlIHRyYWlsLCByZXBsYWNpbmcgbGlua3Mgb2YgYWxsIGNvbXBvbmVudHMgdG8gdXBkYXRlIENJRHNcbmNvbnN0IHVwZGF0ZVRyZWUgPSBhc3luYyAoY29udGV4dCwgdHJhaWwsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuXG4gIGxvZygnVHJhaWwnLCB0cmFpbClcbiAgdHJhaWwgPSB0cmFpbC5zbGljZSgpLnJldmVyc2UoKVxuXG4gIGxldCBpbmRleCA9IDBcbiAgbGV0IGNoaWxkXG5cbiAgZm9yIGF3YWl0IChjb25zdCBub2RlIG9mIGNvbnRleHQuaXBsZC5nZXRNYW55KHRyYWlsLm1hcChub2RlID0+IG5vZGUuY2lkKSkpIHtcbiAgICBjb25zdCBjaWQgPSB0cmFpbFtpbmRleF0uY2lkXG4gICAgY29uc3QgbmFtZSA9IHRyYWlsW2luZGV4XS5uYW1lXG4gICAgaW5kZXgrK1xuXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgY2hpbGQgPSB7XG4gICAgICAgIGNpZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc2l6ZTogbm9kZS5zaXplXG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWRkTGluayhjb250ZXh0LCB7XG4gICAgICBwYXJlbnQ6IG5vZGUsXG4gICAgICBuYW1lOiBjaGlsZC5uYW1lLFxuICAgICAgY2lkOiBjaGlsZC5jaWQsXG4gICAgICBzaXplOiBjaGlsZC5zaXplLFxuICAgICAgZmx1c2g6IG9wdGlvbnMuZmx1c2gsXG4gICAgICBzaGFyZFNwbGl0VGhyZXNob2xkOiBvcHRpb25zLnNoYXJkU3BsaXRUaHJlc2hvbGQsXG4gICAgICBmb3JtYXQ6IG9wdGlvbnMuZm9ybWF0LFxuICAgICAgaGFzaEFsZzogb3B0aW9ucy5oYXNoQWxnLFxuICAgICAgY2lkVmVyc2lvbjogb3B0aW9ucy5jaWRWZXJzaW9uXG4gICAgfSlcblxuICAgIC8vIG5ldyBjaGlsZCBmb3IgbmV4dCBsb29wXG4gICAgY2hpbGQgPSB7XG4gICAgICBjaWQ6IHJlc3VsdC5jaWQsXG4gICAgICBuYW1lLFxuICAgICAgc2l6ZTogcmVzdWx0Lm5vZGUuc2l6ZVxuICAgIH1cbiAgfVxuXG4gIGxvZyhgRmluYWwgQ0lEICR7Y2hpbGQuY2lkfWApXG5cbiAgcmV0dXJuIGNoaWxkLmNpZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVwZGF0ZVRyZWVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIERBR05vZGUsXG4gIERBR0xpbmtcbn0gPSByZXF1aXJlKCdpcGxkLWRhZy1wYicpXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IGxvZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2lwZnM6bWZzOmNvcmU6dXRpbHM6YWRkLWxpbmsnKVxuY29uc3QgVW5peEZTID0gcmVxdWlyZSgnaXBmcy11bml4ZnMnKVxuY29uc3QgRGlyU2hhcmRlZCA9IHJlcXVpcmUoJ2lwZnMtdW5peGZzLWltcG9ydGVyL3NyYy9kaXItc2hhcmRlZCcpXG5jb25zdCB7XG4gIHVwZGF0ZUhhbXREaXJlY3RvcnksXG4gIHJlY3JlYXRlSGFtdExldmVsLFxuICBjcmVhdGVTaGFyZCxcbiAgdG9QcmVmaXgsXG4gIGFkZExpbmtzVG9IYW10QnVja2V0XG59ID0gcmVxdWlyZSgnLi9oYW10LXV0aWxzJylcbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCBtYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuY29uc3QgbWggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpXG5jb25zdCBsYXN0ID0gcmVxdWlyZSgnYXN5bmMtaXRlcmF0b3ItbGFzdCcpXG5cbmNvbnN0IGFkZExpbmsgPSBhc3luYyAoY29udGV4dCwgb3B0aW9ucykgPT4ge1xuICBpZiAoIW9wdGlvbnMucGFyZW50Q2lkICYmICFvcHRpb25zLnBhcmVudCkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdObyBwYXJlbnQgbm9kZSBvciBDSUQgcGFzc2VkIHRvIGFkZExpbmsnKSwgJ0VJTlZBTElEUEFSRU5UJylcbiAgfVxuXG4gIGlmIChvcHRpb25zLnBhcmVudENpZCAmJiAhQ0lELmlzQ0lEKG9wdGlvbnMucGFyZW50Q2lkKSkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdJbnZhbGlkIENJRCBwYXNzZWQgdG8gYWRkTGluaycpLCAnRUlOVkFMSURQQVJFTlRDSUQnKVxuICB9XG5cbiAgaWYgKCFvcHRpb25zLnBhcmVudCkge1xuICAgIGxvZyhgTG9hZGluZyBwYXJlbnQgbm9kZSAke29wdGlvbnMucGFyZW50Q2lkfWApXG5cbiAgICBvcHRpb25zLnBhcmVudCA9IGF3YWl0IGNvbnRleHQuaXBsZC5nZXQob3B0aW9ucy5wYXJlbnRDaWQpXG4gIH1cblxuICBpZiAoIW9wdGlvbnMuY2lkKSB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ05vIGNoaWxkIGNpZCBwYXNzZWQgdG8gYWRkTGluaycpLCAnRUlOVkFMSURDSElMRENJRCcpXG4gIH1cblxuICBpZiAoIW9wdGlvbnMubmFtZSkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdObyBjaGlsZCBuYW1lIHBhc3NlZCB0byBhZGRMaW5rJyksICdFSU5WQUxJRENISUxETkFNRScpXG4gIH1cblxuICBpZiAoIUNJRC5pc0NJRChvcHRpb25zLmNpZCkpIHtcbiAgICBvcHRpb25zLmNpZCA9IG5ldyBDSUQob3B0aW9ucy5jaWQpXG4gIH1cblxuICBpZiAoIW9wdGlvbnMuc2l6ZSAmJiBvcHRpb25zLnNpemUgIT09IDApIHtcbiAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignTm8gY2hpbGQgc2l6ZSBwYXNzZWQgdG8gYWRkTGluaycpLCAnRUlOVkFMSURDSElMRFNJWkUnKVxuICB9XG5cbiAgY29uc3QgbWV0YSA9IFVuaXhGUy51bm1hcnNoYWwob3B0aW9ucy5wYXJlbnQuRGF0YSlcblxuICBpZiAobWV0YS50eXBlID09PSAnaGFtdC1zaGFyZGVkLWRpcmVjdG9yeScpIHtcbiAgICBsb2coJ0FkZGluZyBsaW5rIHRvIHNoYXJkZWQgZGlyZWN0b3J5JylcblxuICAgIHJldHVybiBhZGRUb1NoYXJkZWREaXJlY3RvcnkoY29udGV4dCwgb3B0aW9ucylcbiAgfVxuXG4gIGlmIChvcHRpb25zLnBhcmVudC5MaW5rcy5sZW5ndGggPj0gb3B0aW9ucy5zaGFyZFNwbGl0VGhyZXNob2xkKSB7XG4gICAgbG9nKCdDb252ZXJ0aW5nIGRpcmVjdG9yeSB0byBzaGFyZGVkIGRpcmVjdG9yeScpXG5cbiAgICByZXR1cm4gY29udmVydFRvU2hhcmRlZERpcmVjdG9yeShjb250ZXh0LCBvcHRpb25zKVxuICB9XG5cbiAgbG9nKGBBZGRpbmcgJHtvcHRpb25zLm5hbWV9ICgke29wdGlvbnMuY2lkfSkgdG8gcmVndWxhciBkaXJlY3RvcnlgKVxuXG4gIHJldHVybiBhZGRUb0RpcmVjdG9yeShjb250ZXh0LCBvcHRpb25zKVxufVxuXG5jb25zdCBjb252ZXJ0VG9TaGFyZGVkRGlyZWN0b3J5ID0gYXN5bmMgKGNvbnRleHQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlU2hhcmQoY29udGV4dCwgb3B0aW9ucy5wYXJlbnQuTGlua3MubWFwKGxpbmsgPT4gKHtcbiAgICBuYW1lOiBsaW5rLk5hbWUsXG4gICAgc2l6ZTogbGluay5Uc2l6ZSxcbiAgICBjaWQ6IGxpbmsuSGFzaFxuICB9KSkuY29uY2F0KHtcbiAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgc2l6ZTogb3B0aW9ucy5zaXplLFxuICAgIGNpZDogb3B0aW9ucy5jaWRcbiAgfSksIG9wdGlvbnMpXG5cbiAgbG9nKGBDb252ZXJ0ZWQgZGlyZWN0b3J5IHRvIHNoYXJkZWQgZGlyZWN0b3J5ICR7cmVzdWx0LmNpZH1gKVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuY29uc3QgYWRkVG9EaXJlY3RvcnkgPSBhc3luYyAoY29udGV4dCwgb3B0aW9ucykgPT4ge1xuICBsZXQgcGFyZW50ID0gYXdhaXQgREFHTm9kZS5ybUxpbmsob3B0aW9ucy5wYXJlbnQsIG9wdGlvbnMubmFtZSlcbiAgcGFyZW50ID0gYXdhaXQgREFHTm9kZS5hZGRMaW5rKHBhcmVudCwgbmV3IERBR0xpbmsob3B0aW9ucy5uYW1lLCBvcHRpb25zLnNpemUsIG9wdGlvbnMuY2lkKSlcblxuICBjb25zdCBmb3JtYXQgPSBtY1tvcHRpb25zLmZvcm1hdC50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJ18nKV1cbiAgY29uc3QgaGFzaEFsZyA9IG1oLm5hbWVzW29wdGlvbnMuaGFzaEFsZ11cblxuICAvLyBQZXJzaXN0IHRoZSBuZXcgcGFyZW50IERBR05vZGVcbiAgY29uc3QgY2lkID0gYXdhaXQgY29udGV4dC5pcGxkLnB1dChwYXJlbnQsIGZvcm1hdCwge1xuICAgIGNpZFZlcnNpb246IG9wdGlvbnMuY2lkVmVyc2lvbixcbiAgICBoYXNoQWxnLFxuICAgIGhhc2hPbmx5OiAhb3B0aW9ucy5mbHVzaFxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgbm9kZTogcGFyZW50LFxuICAgIGNpZFxuICB9XG59XG5cbmNvbnN0IGFkZFRvU2hhcmRlZERpcmVjdG9yeSA9IGFzeW5jIChjb250ZXh0LCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzaGFyZCwgcGF0aFxuICB9ID0gYXdhaXQgYWRkRmlsZVRvU2hhcmRlZERpcmVjdG9yeShjb250ZXh0LCBvcHRpb25zKVxuXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxhc3Qoc2hhcmQuZmx1c2goJycsIGNvbnRleHQuaXBsZCkpXG5cbiAgLy8gd2UgaGF2ZSB3cml0dGVuIG91dCB0aGUgc2hhcmQsIGJ1dCBvbmx5IG9uZSBzdWItc2hhcmQgd2lsbCBoYXZlIGJlZW4gd3JpdHRlbiBzbyByZXBsYWNlIGl0IGluIHRoZSBvcmlnaW5hbCBzaGFyZFxuICBjb25zdCBvbGRMaW5rID0gb3B0aW9ucy5wYXJlbnQuTGlua3NcbiAgICAuZmluZChsaW5rID0+IGxpbmsuTmFtZS5zdWJzdHJpbmcoMCwgMikgPT09IHBhdGhbMF0ucHJlZml4KVxuXG4gIGNvbnN0IG5ld0xpbmsgPSByZXN1bHQubm9kZS5MaW5rc1xuICAgIC5maW5kKGxpbmsgPT4gbGluay5OYW1lLnN1YnN0cmluZygwLCAyKSA9PT0gcGF0aFswXS5wcmVmaXgpXG5cbiAgbGV0IHBhcmVudCA9IG9wdGlvbnMucGFyZW50XG5cbiAgaWYgKG9sZExpbmspIHtcbiAgICBwYXJlbnQgPSBhd2FpdCBEQUdOb2RlLnJtTGluayhvcHRpb25zLnBhcmVudCwgb2xkTGluay5OYW1lKVxuICB9XG5cbiAgcGFyZW50ID0gYXdhaXQgREFHTm9kZS5hZGRMaW5rKHBhcmVudCwgbmV3TGluaylcblxuICByZXR1cm4gdXBkYXRlSGFtdERpcmVjdG9yeShjb250ZXh0LCBwYXJlbnQuTGlua3MsIHBhdGhbMF0uYnVja2V0LCBvcHRpb25zKVxufVxuXG5jb25zdCBhZGRGaWxlVG9TaGFyZGVkRGlyZWN0b3J5ID0gYXN5bmMgKGNvbnRleHQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZmlsZSA9IHtcbiAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgY2lkOiBvcHRpb25zLmNpZCxcbiAgICBzaXplOiBvcHRpb25zLnNpemVcbiAgfVxuXG4gIC8vIHN0YXJ0IGF0IHRoZSByb290IGJ1Y2tldCBhbmQgZGVzY2VuZCwgbG9hZGluZyBub2RlcyBhcyB3ZSBnb1xuICBjb25zdCByb290QnVja2V0ID0gYXdhaXQgcmVjcmVhdGVIYW10TGV2ZWwob3B0aW9ucy5wYXJlbnQuTGlua3MpXG5cbiAgY29uc3Qgc2hhcmQgPSBuZXcgRGlyU2hhcmRlZCh7XG4gICAgcm9vdDogdHJ1ZSxcbiAgICBkaXI6IHRydWUsXG4gICAgcGFyZW50OiBudWxsLFxuICAgIHBhcmVudEtleTogbnVsbCxcbiAgICBwYXRoOiAnJyxcbiAgICBkaXJ0eTogdHJ1ZSxcbiAgICBmbGF0OiBmYWxzZVxuICB9LCBvcHRpb25zKVxuICBzaGFyZC5fYnVja2V0ID0gcm9vdEJ1Y2tldFxuXG4gIC8vIGxvYWQgc3Vic2hhcmRzIHVudGlsIHRoZSBidWNrZXQgJiBwb3NpdGlvbiBubyBsb25nZXIgY2hhbmdlc1xuICBjb25zdCBwb3NpdGlvbiA9IGF3YWl0IHJvb3RCdWNrZXQuX2ZpbmROZXdCdWNrZXRBbmRQb3MoZmlsZS5uYW1lKVxuICBjb25zdCBwYXRoID0gdG9CdWNrZXRQYXRoKHBvc2l0aW9uKVxuICBwYXRoWzBdLm5vZGUgPSBvcHRpb25zLnBhcmVudFxuICBsZXQgaW5kZXggPSAwXG5cbiAgd2hpbGUgKGluZGV4IDwgcGF0aC5sZW5ndGgpIHtcbiAgICBsZXQgc2VnbWVudCA9IHBhdGhbaW5kZXhdXG4gICAgaW5kZXgrK1xuICAgIGxldCBub2RlID0gc2VnbWVudC5ub2RlXG5cbiAgICBsZXQgbGluayA9IG5vZGUuTGlua3NcbiAgICAgIC5maW5kKGxpbmsgPT4gbGluay5OYW1lLnN1YnN0cmluZygwLCAyKSA9PT0gc2VnbWVudC5wcmVmaXgpXG5cbiAgICBpZiAoIWxpbmspIHtcbiAgICAgIC8vIHByZWZpeCBpcyBuZXcsIGZpbGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgY3VycmVudCBidWNrZXRcbiAgICAgIGxvZyhgTGluayAke3NlZ21lbnQucHJlZml4fSR7ZmlsZS5uYW1lfSB3aWxsIGJlIGFkZGVkYClcbiAgICAgIGluZGV4ID0gcGF0aC5sZW5ndGhcblxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBpZiAobGluay5OYW1lID09PSBgJHtzZWdtZW50LnByZWZpeH0ke2ZpbGUubmFtZX1gKSB7XG4gICAgICAvLyBmaWxlIGFscmVhZHkgZXhpc3RlZCwgZmlsZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjdXJyZW50IGJ1Y2tldFxuICAgICAgbG9nKGBMaW5rICR7c2VnbWVudC5wcmVmaXh9JHtmaWxlLm5hbWV9IHdpbGwgYmUgcmVwbGFjZWRgKVxuICAgICAgaW5kZXggPSBwYXRoLmxlbmd0aFxuXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGlmIChsaW5rLk5hbWUubGVuZ3RoID4gMikge1xuICAgICAgLy8gYW5vdGhlciBmaWxlIGhhZCB0aGUgc2FtZSBwcmVmaXgsIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIHN1YnNoYXJkXG4gICAgICBsb2coYExpbmsgJHtsaW5rLk5hbWV9IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIHN1YnNoYXJkYClcbiAgICAgIGluZGV4ID0gcGF0aC5sZW5ndGhcblxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICAvLyBsb2FkIHN1Yi1zaGFyZFxuICAgIGxvZyhgRm91bmQgc3Vic2hhcmQgJHtzZWdtZW50LnByZWZpeH1gKVxuICAgIGNvbnN0IHN1YlNoYXJkID0gYXdhaXQgY29udGV4dC5pcGxkLmdldChsaW5rLkhhc2gpXG5cbiAgICAvLyBzdWJzaGFyZCBoYXNuJ3QgYmVlbiBsb2FkZWQsIGRlc2NlbmQgdG8gdGhlIG5leHQgbGV2ZWwgb2YgdGhlIEhBTVRcbiAgICBpZiAoIXBhdGhbaW5kZXhdKSB7XG4gICAgICBsb2coYExvYWRlZCBuZXcgc3Vic2hhcmQgJHtzZWdtZW50LnByZWZpeH1gKVxuICAgICAgYXdhaXQgcmVjcmVhdGVIYW10TGV2ZWwoc3ViU2hhcmQuTGlua3MsIHJvb3RCdWNrZXQsIHNlZ21lbnQuYnVja2V0LCBwYXJzZUludChzZWdtZW50LnByZWZpeCwgMTYpKVxuXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGF3YWl0IHJvb3RCdWNrZXQuX2ZpbmROZXdCdWNrZXRBbmRQb3MoZmlsZS5uYW1lKVxuXG4gICAgICBwYXRoLnB1c2goe1xuICAgICAgICBidWNrZXQ6IHBvc2l0aW9uLmJ1Y2tldCxcbiAgICAgICAgcHJlZml4OiB0b1ByZWZpeChwb3NpdGlvbi5wb3MpLFxuICAgICAgICBub2RlOiBzdWJTaGFyZFxuICAgICAgfSlcblxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBjb25zdCBuZXh0U2VnbWVudCA9IHBhdGhbaW5kZXhdXG5cbiAgICAvLyBhZGQgbmV4dCBsZXZlbCdzIHdvcnRoIG9mIGxpbmtzIHRvIGJ1Y2tldFxuICAgIGF3YWl0IGFkZExpbmtzVG9IYW10QnVja2V0KHN1YlNoYXJkLkxpbmtzLCBuZXh0U2VnbWVudC5idWNrZXQsIHJvb3RCdWNrZXQpXG5cbiAgICBuZXh0U2VnbWVudC5ub2RlID0gc3ViU2hhcmRcbiAgfVxuXG4gIC8vIGZpbmFsbHkgYWRkIHRoZSBuZXcgZmlsZSBpbnRvIHRoZSBzaGFyZFxuICBhd2FpdCBzaGFyZC5fYnVja2V0LnB1dChmaWxlLm5hbWUsIHtcbiAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgY2lkOiBmaWxlLmNpZFxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgc2hhcmQsIHBhdGhcbiAgfVxufVxuXG5jb25zdCB0b0J1Y2tldFBhdGggPSAocG9zaXRpb24pID0+IHtcbiAgbGV0IGJ1Y2tldCA9IHBvc2l0aW9uLmJ1Y2tldFxuICBsZXQgcG9zaXRpb25JbkJ1Y2tldCA9IHBvc2l0aW9uLnBvc1xuICBsZXQgcGF0aCA9IFt7XG4gICAgYnVja2V0LFxuICAgIHByZWZpeDogdG9QcmVmaXgocG9zaXRpb25JbkJ1Y2tldClcbiAgfV1cblxuICBidWNrZXQgPSBwb3NpdGlvbi5idWNrZXQuX3BhcmVudFxuICBwb3NpdGlvbkluQnVja2V0ID0gcG9zaXRpb24uYnVja2V0Ll9wb3NBdFBhcmVudFxuXG4gIHdoaWxlIChidWNrZXQpIHtcbiAgICBwYXRoLnB1c2goe1xuICAgICAgYnVja2V0LFxuICAgICAgcHJlZml4OiB0b1ByZWZpeChwb3NpdGlvbkluQnVja2V0KVxuICAgIH0pXG5cbiAgICBwb3NpdGlvbkluQnVja2V0ID0gYnVja2V0Ll9wb3NBdFBhcmVudFxuICAgIGJ1Y2tldCA9IGJ1Y2tldC5fcGFyZW50XG4gIH1cblxuICBwYXRoLnJldmVyc2UoKVxuXG4gIHJldHVybiBwYXRoXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkTGlua1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHRvUGF0aENvbXBvbmVudHMgPSAocGF0aCA9ICcnKSA9PiB7XG4gIC8vIHNwbGl0IG9uIC8gdW5sZXNzIGVzY2FwZWQgd2l0aCBcXFxuICByZXR1cm4gKHBhdGhcbiAgICAudHJpbSgpXG4gICAgLm1hdGNoKC8oW15cXFxcXi9dfFxcXFxcXC8pKy9nKSB8fCBbXSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QYXRoQ29tcG9uZW50c1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFVuaXhGUyA9IHJlcXVpcmUoJ2lwZnMtdW5peGZzJylcbmNvbnN0IHtcbiAgREFHTm9kZVxufSA9IHJlcXVpcmUoJ2lwbGQtZGFnLXBiJylcbmNvbnN0IG1jID0gcmVxdWlyZSgnbXVsdGljb2RlYycpXG5jb25zdCBtaCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJylcblxuY29uc3QgY3JlYXRlTm9kZSA9IGFzeW5jIChjb250ZXh0LCB0eXBlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGZvcm1hdCA9IG1jW29wdGlvbnMuZm9ybWF0LnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvLS9nLCAnXycpXVxuICBjb25zdCBoYXNoQWxnID0gbWgubmFtZXNbb3B0aW9ucy5oYXNoQWxnXVxuXG4gIGNvbnN0IG5vZGUgPSBEQUdOb2RlLmNyZWF0ZShuZXcgVW5peEZTKHR5cGUpLm1hcnNoYWwoKSlcbiAgY29uc3QgY2lkID0gYXdhaXQgY29udGV4dC5pcGxkLnB1dChub2RlLCBmb3JtYXQsIHtcbiAgICBjaWRWZXJzaW9uOiBvcHRpb25zLmNpZFZlcnNpb24sXG4gICAgaGFzaEFsZ1xuICB9KVxuXG4gIHJldHVybiB7XG4gICAgY2lkLFxuICAgIG5vZGVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU5vZGVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IFVuaXhGcyA9IHJlcXVpcmUoJ2lwZnMtdW5peGZzJylcbmNvbnN0IHtcbiAgREFHTm9kZVxufSA9IHJlcXVpcmUoJ2lwbGQtZGFnLXBiJylcbmNvbnN0IGxvZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2lwZnM6bWZzOnV0aWxzOndpdGgtbWZzLXJvb3QnKVxuY29uc3QgbWMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJylcbmNvbnN0IG1oID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuXG5jb25zdCB7XG4gIE1GU19ST09UX0tFWVxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuY29uc3QgbG9hZE1mc1Jvb3QgPSBhc3luYyAoY29udGV4dCkgPT4ge1xuICAvLyBPcGVuIHRoZSByZXBvIGlmIGl0J3MgYmVlbiBjbG9zZWRcbiAgYXdhaXQgY29udGV4dC5yZXBvLmRhdGFzdG9yZS5vcGVuKClcblxuICAvLyBMb2FkIHRoZSBNRlMgcm9vdCBDSURcbiAgbGV0IGNpZFxuXG4gIHRyeSB7XG4gICAgY29uc3QgYnVmID0gYXdhaXQgY29udGV4dC5yZXBvLmRhdGFzdG9yZS5nZXQoTUZTX1JPT1RfS0VZKVxuXG4gICAgY2lkID0gbmV3IENJRChidWYpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIuY29kZSAhPT0gJ0VSUl9OT1RfRk9VTkQnKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICBsb2coJ0NyZWF0aW5nIG5ldyBNRlMgcm9vdCcpXG4gICAgY29uc3Qgbm9kZSA9IERBR05vZGUuY3JlYXRlKG5ldyBVbml4RnMoJ2RpcmVjdG9yeScpLm1hcnNoYWwoKSlcbiAgICBjaWQgPSBhd2FpdCBjb250ZXh0LmlwbGQucHV0KG5vZGUsIG1jLkRBR19QQiwge1xuICAgICAgY2lkVmVyc2lvbjogMCxcbiAgICAgIGhhc2hBbGc6IG1oLm5hbWVzWydzaGEyLTI1NiddIC8vIHdoeSBjYW4ndCBpcGxkIGxvb2sgdGhpcyB1cD9cbiAgICB9KVxuXG4gICAgYXdhaXQgY29udGV4dC5yZXBvLmRhdGFzdG9yZS5wdXQoTUZTX1JPT1RfS0VZLCBjaWQuYnVmZmVyKVxuICB9XG5cbiAgbG9nKGBMb2FkZWQgTUZTIHJvb3QgL2lwZnMvJHtjaWR9YClcblxuICByZXR1cm4gY2lkXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbG9hZE1mc1Jvb3RcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBleHBvcnRlciA9IHJlcXVpcmUoJ2lwZnMtdW5peGZzLWV4cG9ydGVyJylcbmNvbnN0IGxvZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2lwZnM6bWZzOnV0aWxzOnRvLXRyYWlsJylcblxuY29uc3QgdG9UcmFpbCA9IGFzeW5jIChjb250ZXh0LCBwYXRoKSA9PiB7XG4gIGxvZyhgQ3JlYXRpbmcgdHJhaWwgZm9yIHBhdGggJHtwYXRofWApXG5cbiAgY29uc3Qgb3V0cHV0ID0gW11cblxuICBmb3IgYXdhaXQgKGNvbnN0IGZzRW50cnkgb2YgZXhwb3J0ZXIucGF0aChwYXRoLCBjb250ZXh0LmlwbGQpKSB7XG4gICAgb3V0cHV0LnB1c2goe1xuICAgICAgbmFtZTogZnNFbnRyeS5uYW1lLFxuICAgICAgY2lkOiBmc0VudHJ5LmNpZCxcbiAgICAgIHNpemU6IGZzRW50cnkubm9kZS5zaXplLFxuICAgICAgdHlwZTogZnNFbnRyeS51bml4ZnMgPyBmc0VudHJ5LnVuaXhmcy50eXBlIDogdW5kZWZpbmVkXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1RyYWlsXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBEQUdOb2RlLFxuICBEQUdMaW5rXG59ID0gcmVxdWlyZSgnaXBsZC1kYWctcGInKVxuY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpXG5jb25zdCBsb2cgPSByZXF1aXJlKCdkZWJ1ZycpKCdpcGZzOm1mczpjb3JlOnV0aWxzOnJlbW92ZS1saW5rJylcbmNvbnN0IFVuaXhGUyA9IHJlcXVpcmUoJ2lwZnMtdW5peGZzJylcbmNvbnN0IHtcbiAgZ2VuZXJhdGVQYXRoLFxuICB1cGRhdGVIYW10RGlyZWN0b3J5XG59ID0gcmVxdWlyZSgnLi9oYW10LXV0aWxzJylcbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCBtYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuY29uc3QgbWggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpXG5cbmNvbnN0IHJlbW92ZUxpbmsgPSBhc3luYyAoY29udGV4dCwgb3B0aW9ucykgPT4ge1xuICBpZiAoIW9wdGlvbnMucGFyZW50Q2lkICYmICFvcHRpb25zLnBhcmVudCkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdObyBwYXJlbnQgbm9kZSBvciBDSUQgcGFzc2VkIHRvIHJlbW92ZUxpbmsnKSwgJ0VJTlZBTElEUEFSRU5UJylcbiAgfVxuXG4gIGlmIChvcHRpb25zLnBhcmVudENpZCAmJiAhQ0lELmlzQ0lEKG9wdGlvbnMucGFyZW50Q2lkKSkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdJbnZhbGlkIENJRCBwYXNzZWQgdG8gcmVtb3ZlTGluaycpLCAnRUlOVkFMSURQQVJFTlRDSUQnKVxuICB9XG5cbiAgaWYgKCFvcHRpb25zLnBhcmVudCkge1xuICAgIGxvZyhgTG9hZGluZyBwYXJlbnQgbm9kZSAke29wdGlvbnMucGFyZW50Q2lkfWApXG5cbiAgICBvcHRpb25zLnBhcmVudCA9IGF3YWl0IGNvbnRleHQuaXBsZC5nZXQob3B0aW9ucy5wYXJlbnRDaWQpXG4gIH1cblxuICBpZiAoIW9wdGlvbnMubmFtZSkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdObyBjaGlsZCBuYW1lIHBhc3NlZCB0byByZW1vdmVMaW5rJyksICdFSU5WQUxJRENISUxETkFNRScpXG4gIH1cblxuICBjb25zdCBtZXRhID0gVW5peEZTLnVubWFyc2hhbChvcHRpb25zLnBhcmVudC5EYXRhKVxuXG4gIGlmIChtZXRhLnR5cGUgPT09ICdoYW10LXNoYXJkZWQtZGlyZWN0b3J5Jykge1xuICAgIGxvZyhgUmVtb3ZpbmcgJHtvcHRpb25zLm5hbWV9IGZyb20gc2hhcmRlZCBkaXJlY3RvcnlgKVxuXG4gICAgcmV0dXJuIHJlbW92ZUZyb21TaGFyZGVkRGlyZWN0b3J5KGNvbnRleHQsIG9wdGlvbnMpXG4gIH1cblxuICBsb2coYFJlbW92aW5nIGxpbmsgJHtvcHRpb25zLm5hbWV9IHJlZ3VsYXIgZGlyZWN0b3J5YClcblxuICByZXR1cm4gcmVtb3ZlRnJvbURpcmVjdG9yeShjb250ZXh0LCBvcHRpb25zKVxufVxuXG5jb25zdCByZW1vdmVGcm9tRGlyZWN0b3J5ID0gYXN5bmMgKGNvbnRleHQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZm9ybWF0ID0gbWNbb3B0aW9ucy5mb3JtYXQudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tL2csICdfJyldXG4gIGNvbnN0IGhhc2hBbGcgPSBtaC5uYW1lc1tvcHRpb25zLmhhc2hBbGddXG5cbiAgY29uc3QgbmV3UGFyZW50Tm9kZSA9IGF3YWl0IERBR05vZGUucm1MaW5rKG9wdGlvbnMucGFyZW50LCBvcHRpb25zLm5hbWUpXG4gIGNvbnN0IGNpZCA9IGF3YWl0IGNvbnRleHQuaXBsZC5wdXQobmV3UGFyZW50Tm9kZSwgZm9ybWF0LCB7XG4gICAgY2lkVmVyc2lvbjogb3B0aW9ucy5jaWRWZXJzaW9uLFxuICAgIGhhc2hBbGdcbiAgfSlcblxuICBsb2coYFVwZGF0ZWQgcmVndWxhciBkaXJlY3RvcnkgJHtjaWR9YClcblxuICByZXR1cm4ge1xuICAgIG5vZGU6IG5ld1BhcmVudE5vZGUsXG4gICAgY2lkXG4gIH1cbn1cblxuY29uc3QgcmVtb3ZlRnJvbVNoYXJkZWREaXJlY3RvcnkgPSBhc3luYyAoY29udGV4dCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB7XG4gICAgcm9vdEJ1Y2tldCwgcGF0aFxuICB9ID0gYXdhaXQgZ2VuZXJhdGVQYXRoKGNvbnRleHQsIG9wdGlvbnMubmFtZSwgb3B0aW9ucy5wYXJlbnQpXG5cbiAgYXdhaXQgcm9vdEJ1Y2tldC5kZWwob3B0aW9ucy5uYW1lKVxuXG4gIGNvbnN0IHtcbiAgICBub2RlXG4gIH0gPSBhd2FpdCB1cGRhdGVTaGFyZChjb250ZXh0LCBwYXRoLCB7XG4gICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgIGNpZDogb3B0aW9ucy5jaWQsXG4gICAgc2l6ZTogb3B0aW9ucy5zaXplLFxuICAgIGhhc2hBbGc6IG9wdGlvbnMuaGFzaEFsZyxcbiAgICBmb3JtYXQ6IG9wdGlvbnMuZm9ybWF0LFxuICAgIGNpZFZlcnNpb246IG9wdGlvbnMuY2lkVmVyc2lvbixcbiAgICBmbHVzaDogb3B0aW9ucy5mbHVzaFxuICB9LCBvcHRpb25zKVxuXG4gIHJldHVybiB1cGRhdGVIYW10RGlyZWN0b3J5KGNvbnRleHQsIG5vZGUuTGlua3MsIHJvb3RCdWNrZXQsIG9wdGlvbnMpXG59XG5cbmNvbnN0IHVwZGF0ZVNoYXJkID0gYXN5bmMgKGNvbnRleHQsIHBvc2l0aW9ucywgY2hpbGQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qge1xuICAgIGJ1Y2tldCxcbiAgICBwcmVmaXgsXG4gICAgbm9kZVxuICB9ID0gcG9zaXRpb25zLnBvcCgpXG5cbiAgY29uc3QgbGluayA9IG5vZGUuTGlua3NcbiAgICAuZmluZChsaW5rID0+IGxpbmsuTmFtZS5zdWJzdHJpbmcoMCwgMikgPT09IHByZWZpeClcblxuICBpZiAoIWxpbmspIHtcbiAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcihgTm8gbGluayBmb3VuZCB3aXRoIHByZWZpeCAke3ByZWZpeH0gZm9yIGZpbGUgJHtjaGlsZC5uYW1lfWApLCAnRVJSX05PVF9GT1VORCcpXG4gIH1cblxuICBpZiAobGluay5OYW1lID09PSBgJHtwcmVmaXh9JHtjaGlsZC5uYW1lfWApIHtcbiAgICBsb2coYFJlbW92aW5nIGV4aXN0aW5nIGxpbmsgJHtsaW5rLk5hbWV9YClcblxuICAgIGNvbnN0IG5ld05vZGUgPSBhd2FpdCBEQUdOb2RlLnJtTGluayhub2RlLCBsaW5rLk5hbWUpXG5cbiAgICBhd2FpdCBidWNrZXQuZGVsKGNoaWxkLm5hbWUpXG5cbiAgICByZXR1cm4gdXBkYXRlSGFtdERpcmVjdG9yeShjb250ZXh0LCBuZXdOb2RlLkxpbmtzLCBidWNrZXQsIG9wdGlvbnMpXG4gIH1cblxuICBsb2coYERlc2NlbmRpbmcgaW50byBzdWItc2hhcmQgJHtsaW5rLk5hbWV9IGZvciAke3ByZWZpeH0ke2NoaWxkLm5hbWV9YClcblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cGRhdGVTaGFyZChjb250ZXh0LCBwb3NpdGlvbnMsIGNoaWxkLCBvcHRpb25zKVxuXG4gIGxldCBuZXdOYW1lID0gcHJlZml4XG5cbiAgaWYgKHJlc3VsdC5ub2RlLkxpbmtzLmxlbmd0aCA9PT0gMSkge1xuICAgIGxvZyhgUmVtb3Zpbmcgc3Vic2hhcmQgZm9yICR7cHJlZml4fWApXG5cbiAgICAvLyBjb252ZXJ0IHNoYXJkIGJhY2sgdG8gbm9ybWFsIGRpclxuICAgIHJlc3VsdC5jaWQgPSByZXN1bHQubm9kZS5MaW5rc1swXS5IYXNoXG4gICAgcmVzdWx0Lm5vZGUgPSByZXN1bHQubm9kZS5MaW5rc1swXVxuXG4gICAgbmV3TmFtZSA9IGAke3ByZWZpeH0ke3Jlc3VsdC5ub2RlLk5hbWUuc3Vic3RyaW5nKDIpfWBcbiAgfVxuXG4gIGxvZyhgVXBkYXRpbmcgc2hhcmQgJHtwcmVmaXh9IHdpdGggbmFtZSAke25ld05hbWV9YClcblxuICBjb25zdCBzaXplID0gREFHTm9kZS5pc0RBR05vZGUocmVzdWx0Lm5vZGUpID8gcmVzdWx0Lm5vZGUuc2l6ZSA6IHJlc3VsdC5ub2RlLlRzaXplXG5cbiAgcmV0dXJuIHVwZGF0ZVNoYXJkUGFyZW50KGNvbnRleHQsIGJ1Y2tldCwgbm9kZSwgcHJlZml4LCBuZXdOYW1lLCBzaXplLCByZXN1bHQuY2lkLCBvcHRpb25zKVxufVxuXG5jb25zdCB1cGRhdGVTaGFyZFBhcmVudCA9IGFzeW5jIChjb250ZXh0LCBidWNrZXQsIHBhcmVudCwgb2xkTmFtZSwgbmV3TmFtZSwgc2l6ZSwgY2lkLCBvcHRpb25zKSA9PiB7XG4gIHBhcmVudCA9IGF3YWl0IERBR05vZGUucm1MaW5rKHBhcmVudCwgb2xkTmFtZSlcbiAgcGFyZW50ID0gYXdhaXQgREFHTm9kZS5hZGRMaW5rKHBhcmVudCwgbmV3IERBR0xpbmsobmV3TmFtZSwgc2l6ZSwgY2lkKSlcblxuICByZXR1cm4gdXBkYXRlSGFtdERpcmVjdG9yeShjb250ZXh0LCBwYXJlbnQuTGlua3MsIGJ1Y2tldCwgb3B0aW9ucylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZW1vdmVMaW5rXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgbG9nID0gcmVxdWlyZSgnZGVidWcnKSgnaXBmczptZnM6dXRpbHM6dG8tYXN5bmMtaXRlcmF0b3InKVxuY29uc3Qge1xuICBNQVhfQ0hVTktfU0laRVxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuY29uc3QgdG9Bc3luY0l0ZXJhdG9yID0gYXN5bmMgKGNvbnRlbnQpID0+IHtcbiAgaWYgKCFjb250ZW50KSB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ3BhdGhzIG11c3Qgc3RhcnQgd2l0aCBhIGxlYWRpbmcgLycpLCAnRVJSX0lOVkFMSURfUEFUSCcpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnIHx8IGNvbnRlbnQgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAvLyBQYXRocywgbm9kZSBvbmx5XG4gICAgbG9nKCdDb250ZW50IHdhcyBhIHBhdGgnKVxuXG4gICAgcmV0dXJuIGZzLmNyZWF0ZVJlYWRTdHJlYW0oY29udGVudClcbiAgfVxuXG4gIGlmIChjb250ZW50Lmxlbmd0aCkge1xuICAgIGxvZygnQ29udGVudCB3YXMgYXJyYXktbGlrZScpXG5cbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTogYXN5bmMgZnVuY3Rpb24gKiBidWZmZXJDb250ZW50ICgpIHtcbiAgICAgICAgeWllbGQgY29udGVudFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjb250ZW50W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkge1xuICAgIGxvZygnQ29udGVudCB3YXMgYW4gYXN5bmMgaXRlcmF0b3InKVxuICAgIHJldHVybiBjb250ZW50XG4gIH1cblxuICBpZiAoY29udGVudFtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgbG9nKCdDb250ZW50IHdhcyBhbiBpdGVyYXRvcicpXG4gICAgcmV0dXJuIGNvbnRlbnRcbiAgfVxuXG4gIGlmIChnbG9iYWwuQmxvYiAmJiBjb250ZW50IGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICAvLyBIVE1MNSBCbG9iIG9iamVjdHMgKGluY2x1ZGluZyBGaWxlcylcbiAgICBsb2coJ0NvbnRlbnQgd2FzIGFuIEhUTUw1IEJsb2InKVxuXG4gICAgbGV0IGluZGV4ID0gMFxuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChpbmRleCA+IGNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCBjaHVuayA9IGNvbnRlbnQuc2xpY2UoaW5kZXgsIE1BWF9DSFVOS19TSVpFKVxuICAgICAgICAgIGluZGV4ICs9IE1BWF9DSFVOS19TSVpFXG5cbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgZ2xvYmFsLkZpbGVSZWFkZXIoKVxuXG4gICAgICAgICAgY29uc3QgaGFuZGxlTG9hZCA9IChldikgPT4ge1xuICAgICAgICAgICAgcmVhZGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBoYW5kbGVMb2FkLCBmYWxzZSlcblxuICAgICAgICAgICAgaWYgKGV2LmVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXYuZXJyb3IpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgdmFsdWU6IEJ1ZmZlci5mcm9tKHJlYWRlci5yZXN1bHQpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgaGFuZGxlTG9hZClcbiAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoY2h1bmspXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl06ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYERvbid0IGtub3cgaG93IHRvIGNvbnZlcnQgJHtjb250ZW50fSBpbnRvIGFuIGFzeW5jIGl0ZXJhdG9yYCksICdFUlJfSU5WQUxJRF9QQVJBTVMnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvQXN5bmNJdGVyYXRvclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHRvU291cmNlcyA9IHJlcXVpcmUoJy4vdG8tc291cmNlcycpXG5cbmFzeW5jIGZ1bmN0aW9uIHRvU291cmNlc0FuZERlc3RpbmF0aW9uIChjb250ZXh0LCBhcmdzKSB7XG4gIGNvbnN0IHtcbiAgICBzb3VyY2VzLFxuICAgIG9wdGlvbnNcbiAgfSA9IGF3YWl0IHRvU291cmNlcyhjb250ZXh0LCBhcmdzKVxuXG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gc291cmNlcy5wb3AoKVxuXG4gIHJldHVybiB7XG4gICAgZGVzdGluYXRpb24sXG4gICAgc291cmNlcyxcbiAgICBvcHRpb25zXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZXNBbmREZXN0aW5hdGlvblxuIiwiY29uc3Qgbm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpXG5jb25zdCBicm93c2VyID0gcmVxdWlyZSgnLi9icm93c2VyJylcbmNvbnN0IFF1ZXVlID0gcmVxdWlyZSgncC1xdWV1ZScpXG5jb25zdCB7IHRpbWVvdXQgfSA9IHJlcXVpcmUoJ3Byb21pc2UtdGltZW91dCcpXG5jb25zdCBvYnNlcnZlID0gcmVxdWlyZSgnb2JzZXJ2YWJsZS13ZWJ3b3JrZXJzJylcblxuY29uc3QgbXV0ZXhlcyA9IHt9XG5sZXQgaW1wbGVtZW50YXRpb25cblxuY29uc3QgY3JlYXRlTXV0ZXggPSAobmFtZSwgb3B0aW9ucykgPT4ge1xuICBpZiAoaW1wbGVtZW50YXRpb24uaXNXb3JrZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVhZExvY2s6IGltcGxlbWVudGF0aW9uLnJlYWRMb2NrKG5hbWUsIG9wdGlvbnMpLFxuICAgICAgd3JpdGVMb2NrOiBpbXBsZW1lbnRhdGlvbi53cml0ZUxvY2sobmFtZSwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICBjb25zdCBtYXN0ZXJRdWV1ZSA9IG5ldyBRdWV1ZSh7IGNvbmN1cnJlbmN5OiAxIH0pXG4gIGxldCByZWFkUXVldWUgPSBudWxsXG5cbiAgcmV0dXJuIHtcbiAgICByZWFkTG9jazogKGZuKSA9PiB7XG4gICAgICAvLyBJZiB0aGVyZSdzIGFscmVhZHkgYSByZWFkIHF1ZXVlLCBqdXN0IGFkZCB0aGUgdGFzayB0byBpdFxuICAgICAgaWYgKHJlYWRRdWV1ZSkge1xuICAgICAgICByZXR1cm4gcmVhZFF1ZXVlLmFkZCgoKSA9PiB0aW1lb3V0KGZuKCksIG9wdGlvbnMudGltZW91dCkpXG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyByZWFkIHF1ZXVlXG4gICAgICByZWFkUXVldWUgPSBuZXcgUXVldWUoe1xuICAgICAgICBjb25jdXJyZW5jeTogb3B0aW9ucy5jb25jdXJyZW5jeSxcbiAgICAgICAgYXV0b1N0YXJ0OiBmYWxzZVxuICAgICAgfSlcbiAgICAgIGNvbnN0IGxvY2FsUmVhZFF1ZXVlID0gcmVhZFF1ZXVlXG5cbiAgICAgIC8vIEFkZCB0aGUgdGFzayB0byB0aGUgcmVhZCBxdWV1ZVxuICAgICAgY29uc3QgcmVhZFByb21pc2UgPSByZWFkUXVldWUuYWRkKCgpID0+IHRpbWVvdXQoZm4oKSwgb3B0aW9ucy50aW1lb3V0KSlcblxuICAgICAgbWFzdGVyUXVldWUuYWRkKCgpID0+IHtcbiAgICAgICAgLy8gU3RhcnQgdGhlIHRhc2sgb25seSBvbmNlIHRoZSBtYXN0ZXIgcXVldWUgaGFzIGNvbXBsZXRlZCBwcm9jZXNzaW5nXG4gICAgICAgIC8vIGFueSBwcmV2aW91cyB0YXNrc1xuICAgICAgICBsb2NhbFJlYWRRdWV1ZS5zdGFydCgpXG5cbiAgICAgICAgLy8gT25jZSBhbGwgdGhlIHRhc2tzIGluIHRoZSByZWFkIHF1ZXVlIGhhdmUgY29tcGxldGVkLCByZW1vdmUgaXQgc29cbiAgICAgICAgLy8gdGhhdCB0aGUgbmV4dCByZWFkIGxvY2sgd2lsbCBvY2N1ciBhZnRlciBhbnkgd3JpdGUgbG9ja3MgdGhhdCB3ZXJlXG4gICAgICAgIC8vIHN0YXJ0ZWQgaW4gdGhlIGludGVyaW1cbiAgICAgICAgcmV0dXJuIGxvY2FsUmVhZFF1ZXVlLm9uSWRsZSgpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlYWRRdWV1ZSA9PT0gbG9jYWxSZWFkUXVldWUpIHtcbiAgICAgICAgICAgICAgcmVhZFF1ZXVlID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gcmVhZFByb21pc2VcbiAgICB9LFxuICAgIHdyaXRlTG9jazogKGZuKSA9PiB7XG4gICAgICAvLyBSZW1vdmUgdGhlIHJlYWQgcXVldWUgcmVmZXJlbmNlLCBzbyB0aGF0IGFueSBsYXRlciByZWFkIGxvY2tzIHdpbGwgYmVcbiAgICAgIC8vIGFkZGVkIHRvIGEgbmV3IHF1ZXVlIHRoYXQgc3RhcnRzIGFmdGVyIHRoaXMgd3JpdGUgbG9jayBoYXMgYmVlblxuICAgICAgLy8gcmVsZWFzZWRcbiAgICAgIHJlYWRRdWV1ZSA9IG51bGxcblxuICAgICAgcmV0dXJuIG1hc3RlclF1ZXVlLmFkZCgoKSA9PiB0aW1lb3V0KGZuKCksIG9wdGlvbnMudGltZW91dCkpXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBjb25jdXJyZW5jeTogSW5maW5pdHksXG4gIHRpbWVvdXQ6IDg0NjAwMDAwLFxuICBnbG9iYWw6IGdsb2JhbCxcbiAgc2luZ2xlUHJvY2VzczogZmFsc2Vcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAobmFtZSwgb3B0aW9ucykgPT4ge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gbmFtZVxuICAgIG5hbWUgPSAnbG9jaydcbiAgfVxuXG4gIGlmICghbmFtZSkge1xuICAgIG5hbWUgPSAnbG9jaydcbiAgfVxuXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcblxuICBpZiAoIWltcGxlbWVudGF0aW9uKSB7XG4gICAgaW1wbGVtZW50YXRpb24gPSBub2RlKG9wdGlvbnMpIHx8IGJyb3dzZXIob3B0aW9ucylcblxuICAgIGlmICghaW1wbGVtZW50YXRpb24uaXNXb3JrZXIpIHtcbiAgICAgIC8vIHdlIGFyZSBtYXN0ZXIsIHNldCB1cCB3b3JrZXIgcmVxdWVzdHNcbiAgICAgIGltcGxlbWVudGF0aW9uLm9uKCdyZXF1ZXN0UmVhZExvY2snLCAobmFtZSwgZm4pID0+IHtcbiAgICAgICAgbXV0ZXhlc1tuYW1lXSAmJiBtdXRleGVzW25hbWVdLnJlYWRMb2NrKGZuKVxuICAgICAgfSlcblxuICAgICAgaW1wbGVtZW50YXRpb24ub24oJ3JlcXVlc3RXcml0ZUxvY2snLCAobmFtZSwgZm4pID0+IHtcbiAgICAgICAgbXV0ZXhlc1tuYW1lXSAmJiBtdXRleGVzW25hbWVdLndyaXRlTG9jayhmbilcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKCFtdXRleGVzW25hbWVdKSB7XG4gICAgbXV0ZXhlc1tuYW1lXSA9IGNyZWF0ZU11dGV4KG5hbWUsIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gbXV0ZXhlc1tuYW1lXVxufVxuXG5tb2R1bGUuZXhwb3J0cy5Xb3JrZXIgPSBmdW5jdGlvbiAoc2NyaXB0LCBJbXBsKSB7XG4gIEltcGwgPSBJbXBsIHx8IGdsb2JhbC5Xb3JrZXJcbiAgbGV0IHdvcmtlclxuXG4gIHRyeSB7XG4gICAgd29ya2VyID0gbmV3IEltcGwoc2NyaXB0KVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdub3QgYSBjb25zdHJ1Y3RvcicpKSB7XG4gICAgICB3b3JrZXIgPSBJbXBsKHNjcmlwdClcbiAgICB9XG4gIH1cblxuICBpZiAoIXdvcmtlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNyZWF0ZSBXb3JrZXIgZnJvbScsIEltcGwpXG4gIH1cblxuICBvYnNlcnZlKHdvcmtlcilcblxuICByZXR1cm4gd29ya2VyXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNWYWxpZEpzb24gPSBleHBvcnRzLmlzTm9uRW1wdHlBcnJheSA9IGV4cG9ydHMuaGFzUHJvcGVydHkgPSBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSBleHBvcnRzLnRpbWVTaW5jZSA9IHZvaWQgMDtcbmNvbnN0IGZhc3RfZGVlcF9lcXVhbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmYXN0LWRlZXAtZXF1YWxcIikpO1xuLyoqXG4gKiBAcGFyYW0gdGltZXN0YW1wIC0gQSBVbml4IG1pbGxpc2Vjb25kIHRpbWVzdGFtcC5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgc2luY2UgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gKi9cbmZ1bmN0aW9uIHRpbWVTaW5jZSh0aW1lc3RhbXApIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcbn1cbmV4cG9ydHMudGltZVNpbmNlID0gdGltZVNpbmNlO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG5jb25zdCBoYXNQcm9wZXJ0eSA9IChvYmplY3QsIGtleSkgPT4gUmVmbGVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbmV4cG9ydHMuaGFzUHJvcGVydHkgPSBoYXNQcm9wZXJ0eTtcbi8qKlxuICoge0BsaW5rIE5vbkVtcHR5QXJyYXl9IHR5cGUgZ3VhcmQuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgbm9uLWVtcHR5IGFycmF5IG1lbWJlciB0eXBlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSBub24tZW1wdHkgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGlzTm9uRW1wdHlBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufVxuZXhwb3J0cy5pc05vbkVtcHR5QXJyYXkgPSBpc05vbkVtcHR5QXJyYXk7XG4vKipcbiAqIHtAbGluayBKc29ufSB0eXBlIGd1YXJkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIHZhbGlkIEpTT04uXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRKc29uKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZhc3RfZGVlcF9lcXVhbF8xLmRlZmF1bHQodmFsdWUsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKSk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzVmFsaWRKc29uID0gaXNWYWxpZEpzb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSU5MSU5FX1NOQVBTID0gdm9pZCAwO1xuZXhwb3J0cy5JTkxJTkVfU05BUFMgPSB7XG4gICAgSURMRTogYFxuICAgIGNvbnNvbGUubG9nKCdXZWxjb21lIHRvIEZsYXZvcnRvd24uJyk7XG4gIGAsXG4gICAgSU5GSU5JVEVfTE9PUDogYFxuICAgIGNvbnNvbGUubG9nKCdJbmZpbml0ZSBsb29wIHNuYXAgc3RhcnQuJyk7XG4gICAgbGV0IG51bSA9IDA7XG4gICAgbGV0IHRpbWU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChudW0gPT09IDApIHtcbiAgICAgICAgdGltZSA9IERhdGUubm93KCk7XG4gICAgICB9XG4gICAgICBpZiAobnVtID09PSAoMmU4IC0gMSkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0RpbmcsIGdyYXR6LicpO1xuICAgICAgICBjb25zb2xlLmxvZyhjb25zb2xlLmxvZygoRGF0ZS5ub3coKSAtIHRpbWUpIC8gMTAwMCkpXG4gICAgICB9XG4gICAgICBudW0gPSAobnVtICsgMSkgJSAyZTg7XG4gIGAsXG4gICAgTUVNT1JZX0xFQUs6IGBcbiAgICBjb25zb2xlLmxvZygnTWVtb3J5IGxlYWsgc25hcCBzdGFydC4nKVxuICAgIGNvbnN0IGdldFN0ciA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMilcbiAgICBjb25zdCBnZXRMb25nU3RyID0gKHN0cikgPT4gbmV3IEFycmF5KDEwMDAwMDApLmpvaW4oc3RyKVxuICAgIHdhbGxldC5sZWFreUJvaSA9IHt9XG4gICAgbGV0IHN0clxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBzdHIgPSBnZXRTdHIoKVxuICAgICAgd2FsbGV0LmxlYWt5Qm9pW3N0cl0gPSBPYmplY3QuYXNzaWduKHt9LCB3YWxsZXQubGVha3lCb2ksIHsgW3N0cl06IGdldExvbmdTdHIoc3RyKSB9KVxuICAgIH1cbiAgYCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmxpbmVTbmFwcy5qcy5tYXAiLCJsZXQgeyB1cmxBbHBoYWJldCB9ID0gcmVxdWlyZSgnLi91cmwtYWxwaGFiZXQvaW5kZXguY2pzJylcbmlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICBpZiAoXG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyAmJlxuICAgIHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdSZWFjdCBOYXRpdmUgZG9lcyBub3QgaGF2ZSBhIGJ1aWx0LWluIHNlY3VyZSByYW5kb20gZ2VuZXJhdG9yLiAnICtcbiAgICAgICAgJ0lmIHlvdSBkb27igJl0IG5lZWQgdW5wcmVkaWN0YWJsZSBJRHMgdXNlIGBuYW5vaWQvbm9uLXNlY3VyZWAuICcgK1xuICAgICAgICAnRm9yIHNlY3VyZSBJRHMsIGltcG9ydCBgcmVhY3QtbmF0aXZlLWdldC1yYW5kb20tdmFsdWVzYCAnICtcbiAgICAgICAgJ2JlZm9yZSBOYW5vIElELidcbiAgICApXG4gIH1cbiAgaWYgKHR5cGVvZiBtc0NyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW1wb3J0IGZpbGUgd2l0aCBgaWYgKCF3aW5kb3cuY3J5cHRvKSB3aW5kb3cuY3J5cHRvID0gd2luZG93Lm1zQ3J5cHRvYCcgK1xuICAgICAgICAnIGJlZm9yZSBpbXBvcnRpbmcgTmFubyBJRCB0byBmaXggSUUgMTEgc3VwcG9ydCdcbiAgICApXG4gIH1cbiAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1lvdXIgYnJvd3NlciBkb2VzIG5vdCBoYXZlIHNlY3VyZSByYW5kb20gZ2VuZXJhdG9yLiAnICtcbiAgICAgICAgJ0lmIHlvdSBkb27igJl0IG5lZWQgdW5wcmVkaWN0YWJsZSBJRHMsIHlvdSBjYW4gdXNlIG5hbm9pZC9ub24tc2VjdXJlLidcbiAgICApXG4gIH1cbn1cbmxldCByYW5kb20gPSBieXRlcyA9PiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzKSlcbmxldCBjdXN0b21SYW5kb20gPSAoYWxwaGFiZXQsIHNpemUsIGdldFJhbmRvbSkgPT4ge1xuICBsZXQgbWFzayA9ICgyIDw8IChNYXRoLmxvZyhhbHBoYWJldC5sZW5ndGggLSAxKSAvIE1hdGguTE4yKSkgLSAxXG4gIGxldCBzdGVwID0gLX4oKDEuNiAqIG1hc2sgKiBzaXplKSAvIGFscGhhYmV0Lmxlbmd0aClcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgaWQgPSAnJ1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgYnl0ZXMgPSBnZXRSYW5kb20oc3RlcClcbiAgICAgIGxldCBqID0gc3RlcFxuICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICBpZCArPSBhbHBoYWJldFtieXRlc1tqXSAmIG1hc2tdIHx8ICcnXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IHNpemUpIHJldHVybiBpZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxubGV0IGN1c3RvbUFscGhhYmV0ID0gKGFscGhhYmV0LCBzaXplKSA9PiBjdXN0b21SYW5kb20oYWxwaGFiZXQsIHNpemUsIHJhbmRvbSlcbmxldCBuYW5vaWQgPSAoc2l6ZSA9IDIxKSA9PiB7XG4gIGxldCBpZCA9ICcnXG4gIGxldCBieXRlcyA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpXG4gIHdoaWxlIChzaXplLS0pIHtcbiAgICBsZXQgYnl0ZSA9IGJ5dGVzW3NpemVdICYgNjNcbiAgICBpZiAoYnl0ZSA8IDM2KSB7XG4gICAgICBpZCArPSBieXRlLnRvU3RyaW5nKDM2KVxuICAgIH0gZWxzZSBpZiAoYnl0ZSA8IDYyKSB7XG4gICAgICBpZCArPSAoYnl0ZSAtIDI2KS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKVxuICAgIH0gZWxzZSBpZiAoYnl0ZSA8IDYzKSB7XG4gICAgICBpZCArPSAnXydcbiAgICB9IGVsc2Uge1xuICAgICAgaWQgKz0gJy0nXG4gICAgfVxuICB9XG4gIHJldHVybiBpZFxufVxubW9kdWxlLmV4cG9ydHMgPSB7IG5hbm9pZCwgY3VzdG9tQWxwaGFiZXQsIGN1c3RvbVJhbmRvbSwgdXJsQWxwaGFiZXQsIHJhbmRvbSB9XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXRpbCA9IGV4cG9ydHMuZ2V0QW5vbnltaXplZFN0YXRlID0gZXhwb3J0cy5nZXRQZXJzaXN0ZW50U3RhdGUgPSBleHBvcnRzLkJhc2VDb250cm9sbGVyVjIgPSB2b2lkIDA7XG5yZXF1aXJlKFwiaXNvbW9ycGhpYy1mZXRjaFwiKTtcbmNvbnN0IHV0aWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbFwiKSk7XG5leHBvcnRzLnV0aWwgPSB1dGlsO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2V0cy9BY2NvdW50VHJhY2tlckNvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3VzZXIvQWRkcmVzc0Jvb2tDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hcHByb3ZhbC9BcHByb3ZhbENvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2V0cy9Bc3NldHNDb250cmFjdENvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2V0cy9Bc3NldHNEZXRlY3Rpb25Db250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9CYXNlQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG52YXIgQmFzZUNvbnRyb2xsZXJWMl8xID0gcmVxdWlyZShcIi4vQmFzZUNvbnRyb2xsZXJWMlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VDb250cm9sbGVyVjJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2VDb250cm9sbGVyVjJfMS5CYXNlQ29udHJvbGxlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFBlcnNpc3RlbnRTdGF0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmFzZUNvbnRyb2xsZXJWMl8xLmdldFBlcnNpc3RlbnRTdGF0ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEFub255bWl6ZWRTdGF0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmFzZUNvbnRyb2xsZXJWMl8xLmdldEFub255bWl6ZWRTdGF0ZTsgfSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Db21wb3NhYmxlQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29udHJvbGxlck1lc3NlbmdlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXRzL0N1cnJlbmN5UmF0ZUNvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2tleXJpbmcvS2V5cmluZ0NvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21lc3NhZ2UtbWFuYWdlci9NZXNzYWdlTWFuYWdlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbmV0d29yay9OZXR3b3JrQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdGhpcmQtcGFydHkvUGhpc2hpbmdDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91c2VyL1ByZWZlcmVuY2VzQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXRzL1Rva2VuQmFsYW5jZXNDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NldHMvVG9rZW5SYXRlc0NvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uL1RyYW5zYWN0aW9uQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWVzc2FnZS1tYW5hZ2VyL1BlcnNvbmFsTWVzc2FnZU1hbmFnZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21lc3NhZ2UtbWFuYWdlci9UeXBlZE1lc3NhZ2VNYW5hZ2VyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ub3RpZmljYXRpb24vTm90aWZpY2F0aW9uQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXRzL1Rva2VuTGlzdENvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2dhcy9HYXNGZWVDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NldHMvVG9rZW5zQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXRzL0NvbGxlY3RpYmxlc0NvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc1N0cmVhbVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29tcG9zZWRTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTWVyZ2VkU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHJhbnNmb3JtXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TTkFQX1NUUkVBTV9OQU1FUyA9IHZvaWQgMDtcbnZhciBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTTkFQX1NUUkVBTV9OQU1FU1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW51bXNfMS5TVFJFQU1fTkFNRVM7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlU3RyZWFtTWlkZGxld2FyZSA9IGV4cG9ydHMuY3JlYXRlRW5naW5lU3RyZWFtID0gdm9pZCAwO1xuY29uc3QgY3JlYXRlRW5naW5lU3RyZWFtXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY3JlYXRlRW5naW5lU3RyZWFtXCIpKTtcbmV4cG9ydHMuY3JlYXRlRW5naW5lU3RyZWFtID0gY3JlYXRlRW5naW5lU3RyZWFtXzEuZGVmYXVsdDtcbmNvbnN0IGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jcmVhdGVTdHJlYW1NaWRkbGV3YXJlXCIpKTtcbmV4cG9ydHMuY3JlYXRlU3RyZWFtTWlkZGxld2FyZSA9IGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmVfMS5kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IgPSBleHBvcnRzLkR1cGxpY2F0ZUNhdmVhdEVycm9yID0gZXhwb3J0cy5Gb3JiaWRkZW5DYXZlYXRFcnJvciA9IGV4cG9ydHMuSW52YWxpZENhdmVhdEZpZWxkc0Vycm9yID0gZXhwb3J0cy5DYXZlYXRJbnZhbGlkSnNvbkVycm9yID0gZXhwb3J0cy5DYXZlYXRNaXNzaW5nVmFsdWVFcnJvciA9IGV4cG9ydHMuSW52YWxpZENhdmVhdFR5cGVFcnJvciA9IGV4cG9ydHMuSW52YWxpZENhdmVhdEVycm9yID0gZXhwb3J0cy5DYXZlYXRBbHJlYWR5RXhpc3RzRXJyb3IgPSBleHBvcnRzLkNhdmVhdERvZXNOb3RFeGlzdEVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0c1Byb3BlcnR5RXJyb3IgPSBleHBvcnRzLlVucmVjb2duaXplZENhdmVhdFR5cGVFcnJvciA9IGV4cG9ydHMuUGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yID0gZXhwb3J0cy5JbnZhbGlkQXBwcm92ZWRQZXJtaXNzaW9uRXJyb3IgPSBleHBvcnRzLlVucmVjb2duaXplZFN1YmplY3RFcnJvciA9IGV4cG9ydHMuSW52YWxpZFN1YmplY3RJZGVudGlmaWVyRXJyb3IgPSBleHBvcnRzLmludGVybmFsRXJyb3IgPSBleHBvcnRzLnVzZXJSZWplY3RlZFJlcXVlc3QgPSBleHBvcnRzLmludmFsaWRQYXJhbXMgPSBleHBvcnRzLm1ldGhvZE5vdEZvdW5kID0gZXhwb3J0cy51bmF1dGhvcml6ZWQgPSB2b2lkIDA7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuZnVuY3Rpb24gdW5hdXRob3JpemVkKG9wdHMpIHtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudW5hdXRob3JpemVkKHtcbiAgICAgICAgbWVzc2FnZTogJ1VuYXV0aG9yaXplZCB0byBwZXJmb3JtIGFjdGlvbi4gVHJ5IHJlcXVlc3RpbmcgdGhlIHJlcXVpcmVkIHBlcm1pc3Npb24ocykgZmlyc3QuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWU6IGh0dHBzOi8vZG9jcy5tZXRhbWFzay5pby9ndWlkZS9ycGMtYXBpLmh0bWwjcGVybWlzc2lvbnMnLFxuICAgICAgICBkYXRhOiBvcHRzLmRhdGEsXG4gICAgfSk7XG59XG5leHBvcnRzLnVuYXV0aG9yaXplZCA9IHVuYXV0aG9yaXplZDtcbmZ1bmN0aW9uIG1ldGhvZE5vdEZvdW5kKG9wdHMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFRoZSBtZXRob2QgXCIke29wdHMubWV0aG9kfVwiIGRvZXMgbm90IGV4aXN0IC8gaXMgbm90IGF2YWlsYWJsZS5gO1xuICAgIHJldHVybiBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90Rm91bmQoeyBkYXRhOiBvcHRzLmRhdGEsIG1lc3NhZ2UgfSk7XG59XG5leHBvcnRzLm1ldGhvZE5vdEZvdW5kID0gbWV0aG9kTm90Rm91bmQ7XG5mdW5jdGlvbiBpbnZhbGlkUGFyYW1zKG9wdHMpIHtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICBkYXRhOiBvcHRzLmRhdGEsXG4gICAgICAgIG1lc3NhZ2U6IG9wdHMubWVzc2FnZSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuaW52YWxpZFBhcmFtcyA9IGludmFsaWRQYXJhbXM7XG5mdW5jdGlvbiB1c2VyUmVqZWN0ZWRSZXF1ZXN0KGRhdGEpIHtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCh7IGRhdGEgfSk7XG59XG5leHBvcnRzLnVzZXJSZWplY3RlZFJlcXVlc3QgPSB1c2VyUmVqZWN0ZWRSZXF1ZXN0O1xuZnVuY3Rpb24gaW50ZXJuYWxFcnJvcihtZXNzYWdlLCBkYXRhKSB7XG4gICAgcmV0dXJuIGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7IG1lc3NhZ2UsIGRhdGEgfSk7XG59XG5leHBvcnRzLmludGVybmFsRXJyb3IgPSBpbnRlcm5hbEVycm9yO1xuY2xhc3MgSW52YWxpZFN1YmplY3RJZGVudGlmaWVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luKSB7XG4gICAgICAgIHN1cGVyKGBJbnZhbGlkIHN1YmplY3QgaWRlbnRpZmllcjogXCIke3R5cGVvZiBvcmlnaW4gPT09ICdzdHJpbmcnID8gb3JpZ2luIDogdHlwZW9mIG9yaWdpbn1cImApO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFN1YmplY3RJZGVudGlmaWVyRXJyb3IgPSBJbnZhbGlkU3ViamVjdElkZW50aWZpZXJFcnJvcjtcbmNsYXNzIFVucmVjb2duaXplZFN1YmplY3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW4pIHtcbiAgICAgICAgc3VwZXIoYFVucmVjb2duaXplZCBzdWJqZWN0OiBcIiR7b3JpZ2lufVwiIGhhcyBubyBwZXJtaXNzaW9ucy5gKTtcbiAgICB9XG59XG5leHBvcnRzLlVucmVjb2duaXplZFN1YmplY3RFcnJvciA9IFVucmVjb2duaXplZFN1YmplY3RFcnJvcjtcbmNsYXNzIEludmFsaWRBcHByb3ZlZFBlcm1pc3Npb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW4sIHRhcmdldCwgYXBwcm92ZWRQZXJtaXNzaW9uKSB7XG4gICAgICAgIHN1cGVyKGBJbnZhbGlkIGFwcHJvdmVkIHBlcm1pc3Npb24gZm9yIG9yaWdpbiBcIiR7b3JpZ2lufVwiIGFuZCB0YXJnZXQgXCIke3RhcmdldH1cIi5gKTtcbiAgICAgICAgdGhpcy5kYXRhID0geyBvcmlnaW4sIHRhcmdldCwgYXBwcm92ZWRQZXJtaXNzaW9uIH07XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQXBwcm92ZWRQZXJtaXNzaW9uRXJyb3IgPSBJbnZhbGlkQXBwcm92ZWRQZXJtaXNzaW9uRXJyb3I7XG5jbGFzcyBQZXJtaXNzaW9uRG9lc05vdEV4aXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luLCB0YXJnZXQpIHtcbiAgICAgICAgc3VwZXIoYFN1YmplY3QgXCIke29yaWdpbn1cIiBoYXMgbm8gcGVybWlzc2lvbiBmb3IgXCIke3RhcmdldH1cIi5gKTtcbiAgICB9XG59XG5leHBvcnRzLlBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvciA9IFBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvcjtcbmNsYXNzIFVucmVjb2duaXplZENhdmVhdFR5cGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYXZlYXRUeXBlLCBvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICBzdXBlcihgVW5yZWNvZ25pemVkIGNhdmVhdCB0eXBlOiBcIiR7Y2F2ZWF0VHlwZX1cImApO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IGNhdmVhdFR5cGUgfTtcbiAgICAgICAgaWYgKG9yaWdpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEub3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVW5yZWNvZ25pemVkQ2F2ZWF0VHlwZUVycm9yID0gVW5yZWNvZ25pemVkQ2F2ZWF0VHlwZUVycm9yO1xuY2xhc3MgSW52YWxpZENhdmVhdHNQcm9wZXJ0eUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRzUHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoYFRoZSBcImNhdmVhdHNcIiBwcm9wZXJ0eSBvZiBwZXJtaXNzaW9uIGZvciBcIiR7dGFyZ2V0fVwiIG9mIHN1YmplY3QgXCIke29yaWdpbn1cIiBpcyBpbnZhbGlkLiBJdCBtdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5IGlmIHNwZWNpZmllZC5gKTtcbiAgICAgICAgdGhpcy5kYXRhID0geyBvcmlnaW4sIHRhcmdldCwgY2F2ZWF0c1Byb3BlcnR5IH07XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0c1Byb3BlcnR5RXJyb3IgPSBJbnZhbGlkQ2F2ZWF0c1Byb3BlcnR5RXJyb3I7XG5jbGFzcyBDYXZlYXREb2VzTm90RXhpc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSkge1xuICAgICAgICBzdXBlcihgUGVybWlzc2lvbiBmb3IgXCIke3RhcmdldH1cIiBvZiBzdWJqZWN0IFwiJHtvcmlnaW59XCIgaGFzIG5vIGNhdmVhdCBvZiB0eXBlIFwiJHtjYXZlYXRUeXBlfVwiLmApO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2F2ZWF0RG9lc05vdEV4aXN0RXJyb3IgPSBDYXZlYXREb2VzTm90RXhpc3RFcnJvcjtcbmNsYXNzIENhdmVhdEFscmVhZHlFeGlzdHNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSkge1xuICAgICAgICBzdXBlcihgUGVybWlzc2lvbiBmb3IgXCIke3RhcmdldH1cIiBvZiBzdWJqZWN0IFwiJHtvcmlnaW59XCIgYWxyZWFkeSBoYXMgYSBjYXZlYXQgb2YgdHlwZSBcIiR7Y2F2ZWF0VHlwZX1cIi5gKTtcbiAgICB9XG59XG5leHBvcnRzLkNhdmVhdEFscmVhZHlFeGlzdHNFcnJvciA9IENhdmVhdEFscmVhZHlFeGlzdHNFcnJvcjtcbmNsYXNzIEludmFsaWRDYXZlYXRFcnJvciBleHRlbmRzIGV0aF9ycGNfZXJyb3JzXzEuRXRoZXJldW1ScGNFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVjZWl2ZWRDYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIHN1cGVyKGV0aF9ycGNfZXJyb3JzXzEuZXJyb3JDb2Rlcy5ycGMuaW52YWxpZFBhcmFtcywgYEludmFsaWQgY2F2ZWF0LiBDYXZlYXRzIG11c3QgYmUgcGxhaW4gb2JqZWN0cy5gLCB7IHJlY2VpdmVkQ2F2ZWF0IH0pO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IG9yaWdpbiwgdGFyZ2V0IH07XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0RXJyb3IgPSBJbnZhbGlkQ2F2ZWF0RXJyb3I7XG5jbGFzcyBJbnZhbGlkQ2F2ZWF0VHlwZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpIHtcbiAgICAgICAgc3VwZXIoYENhdmVhdCB0eXBlcyBtdXN0IGJlIHN0cmluZ3MuIFJlY2VpdmVkOiBcIiR7dHlwZW9mIGNhdmVhdC50eXBlfVwiYCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZENhdmVhdFR5cGVFcnJvciA9IEludmFsaWRDYXZlYXRUeXBlRXJyb3I7XG5jbGFzcyBDYXZlYXRNaXNzaW5nVmFsdWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIHN1cGVyKGBDYXZlYXQgaXMgbWlzc2luZyBcInZhbHVlXCIgZmllbGQuYCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2F2ZWF0TWlzc2luZ1ZhbHVlRXJyb3IgPSBDYXZlYXRNaXNzaW5nVmFsdWVFcnJvcjtcbmNsYXNzIENhdmVhdEludmFsaWRKc29uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICBzdXBlcihgQ2F2ZWF0IFwidmFsdWVcIiBpcyBpbnZhbGlkIEpTT04uYCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2F2ZWF0SW52YWxpZEpzb25FcnJvciA9IENhdmVhdEludmFsaWRKc29uRXJyb3I7XG5jbGFzcyBJbnZhbGlkQ2F2ZWF0RmllbGRzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICBzdXBlcihgQ2F2ZWF0IGhhcyB1bmV4cGVjdGVkIG51bWJlciBvZiBmaWVsZHM6IFwiJHtPYmplY3Qua2V5cyhjYXZlYXQpLmxlbmd0aH1cImApO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQgfTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRDYXZlYXRGaWVsZHNFcnJvciA9IEludmFsaWRDYXZlYXRGaWVsZHNFcnJvcjtcbmNsYXNzIEZvcmJpZGRlbkNhdmVhdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdmVhdFR5cGUsIG9yaWdpbiwgdGFyZ2V0TmFtZSkge1xuICAgICAgICBzdXBlcihgUGVybWlzc2lvbnMgZm9yIHRhcmdldCBcIiR7dGFyZ2V0TmFtZX1cIiBtYXkgbm90IGhhdmUgY2F2ZWF0cyBvZiB0eXBlIFwiJHtjYXZlYXRUeXBlfVwiLmApO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IGNhdmVhdFR5cGUsIG9yaWdpbiwgdGFyZ2V0OiB0YXJnZXROYW1lIH07XG4gICAgfVxufVxuZXhwb3J0cy5Gb3JiaWRkZW5DYXZlYXRFcnJvciA9IEZvcmJpZGRlbkNhdmVhdEVycm9yO1xuY2xhc3MgRHVwbGljYXRlQ2F2ZWF0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2F2ZWF0VHlwZSwgb3JpZ2luLCB0YXJnZXROYW1lKSB7XG4gICAgICAgIHN1cGVyKGBQZXJtaXNzaW9ucyBmb3IgdGFyZ2V0IFwiJHt0YXJnZXROYW1lfVwiIGNvbnRhaW5zIG11bHRpcGxlIGNhdmVhdHMgb2YgdHlwZSBcIiR7Y2F2ZWF0VHlwZX1cIi5gKTtcbiAgICAgICAgdGhpcy5kYXRhID0geyBjYXZlYXRUeXBlLCBvcmlnaW4sIHRhcmdldDogdGFyZ2V0TmFtZSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRHVwbGljYXRlQ2F2ZWF0RXJyb3IgPSBEdXBsaWNhdGVDYXZlYXRFcnJvcjtcbmNsYXNzIFBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaWQpIHtcbiAgICAgICAgc3VwZXIoYFBlcm1pc3Npb25zIHJlcXVlc3Qgd2l0aCBpZCBcIiR7aWR9XCIgbm90IGZvdW5kLmApO1xuICAgIH1cbn1cbmV4cG9ydHMuUGVybWlzc2lvbnNSZXF1ZXN0Tm90Rm91bmRFcnJvciA9IFBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFBlcm1pc3Npb25zSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5leHBvcnRzLmdldFBlcm1pc3Npb25zSGFuZGxlciA9IHtcbiAgICBtZXRob2ROYW1lczogW3V0aWxzXzEuTWV0aG9kTmFtZXMuZ2V0UGVybWlzc2lvbnNdLFxuICAgIGltcGxlbWVudGF0aW9uOiBnZXRQZXJtaXNzaW9uc0ltcGxlbWVudGF0aW9uLFxuICAgIGhvb2tOYW1lczoge1xuICAgICAgICBnZXRQZXJtaXNzaW9uc0Zvck9yaWdpbjogdHJ1ZSxcbiAgICB9LFxufTtcbmFzeW5jIGZ1bmN0aW9uIGdldFBlcm1pc3Npb25zSW1wbGVtZW50YXRpb24oX3JlcSwgcmVzLCBfbmV4dCwgZW5kLCB7IGdldFBlcm1pc3Npb25zRm9yT3JpZ2luIH0pIHtcbiAgICByZXMucmVzdWx0ID0gT2JqZWN0LnZhbHVlcyhnZXRQZXJtaXNzaW9uc0Zvck9yaWdpbigpIHx8IHt9KTtcbiAgICByZXR1cm4gZW5kKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRQZXJtaXNzaW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVxdWVzdFBlcm1pc3Npb25zSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmV4cG9ydHMucmVxdWVzdFBlcm1pc3Npb25zSGFuZGxlciA9IHtcbiAgICBtZXRob2ROYW1lczogW3V0aWxzXzEuTWV0aG9kTmFtZXMucmVxdWVzdFBlcm1pc3Npb25zXSxcbiAgICBpbXBsZW1lbnRhdGlvbjogcmVxdWVzdFBlcm1pc3Npb25zSW1wbGVtZW50YXRpb24sXG4gICAgaG9va05hbWVzOiB7XG4gICAgICAgIHJlcXVlc3RQZXJtaXNzaW9uc0Zvck9yaWdpbjogdHJ1ZSxcbiAgICB9LFxufTtcbmFzeW5jIGZ1bmN0aW9uIHJlcXVlc3RQZXJtaXNzaW9uc0ltcGxlbWVudGF0aW9uKHJlcSwgcmVzLCBfbmV4dCwgZW5kLCB7IHJlcXVlc3RQZXJtaXNzaW9uc0Zvck9yaWdpbiB9KSB7XG4gICAgY29uc3QgeyBpZCwgcGFyYW1zIH0gPSByZXE7XG4gICAgaWYgKCh0eXBlb2YgaWQgIT09ICdudW1iZXInICYmIHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHx8XG4gICAgICAgICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnICYmICFpZCkpIHtcbiAgICAgICAgcmV0dXJuIGVuZChldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFJlcXVlc3Qoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgcmVxdWVzdDogTXVzdCBzcGVjaWZ5IGEgdmFsaWQgaWQuJyxcbiAgICAgICAgICAgIGRhdGE6IHsgcmVxdWVzdDogcmVxIH0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcykgfHwgIXV0aWxzXzIuaXNQbGFpbk9iamVjdChwYXJhbXNbMF0pKSB7XG4gICAgICAgIHJldHVybiBlbmQoZXJyb3JzXzEuaW52YWxpZFBhcmFtcyh7IGRhdGE6IHsgcmVxdWVzdDogcmVxIH0gfSkpO1xuICAgIH1cbiAgICBjb25zdCBbcmVxdWVzdGVkUGVybWlzc2lvbnNdID0gcGFyYW1zO1xuICAgIGNvbnN0IFtncmFudGVkUGVybWlzc2lvbnNdID0gYXdhaXQgcmVxdWVzdFBlcm1pc3Npb25zRm9yT3JpZ2luKHJlcXVlc3RlZFBlcm1pc3Npb25zLCBTdHJpbmcoaWQpKTtcbiAgICAvLyBgd2FsbGV0X3JlcXVlc3RQZXJtaXNzaW9uYCBpcyBzcGVjaWZpZWQgdG8gcmV0dXJuIGFuIGFycmF5LlxuICAgIHJlcy5yZXN1bHQgPSBPYmplY3QudmFsdWVzKGdyYW50ZWRQZXJtaXNzaW9ucyk7XG4gICAgcmV0dXJuIGVuZCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdFBlcm1pc3Npb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRQZXJtaXNzaW9uTWlkZGxld2FyZUZhY3RvcnkgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbi8qKlxuICogQ3JlYXRlcyBhIHBlcm1pc3Npb24gbWlkZGxld2FyZSBmdW5jdGlvbiBmYWN0b3J5LiBJbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlXG4gKiBpbiB0aGUge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyfS4gTGlrZSBhbnkge0BsaW5rIEpzb25ScGNFbmdpbmV9XG4gKiBtaWRkbGV3YXJlLCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBvbmx5IHJlY2VpdmUgcmVxdWVzdHMgZnJvbSBhIHBhcnRpY3VsYXJcbiAqIHN1YmplY3QgLyBvcmlnaW4uIEhvd2V2ZXIsIGVhY2ggbWlkZGxld2FyZSBhbHNvIHJlcXVpcmVzIGFjY2VzcyB0byBzb21lXG4gKiBgUGVybWlzc2lvbkNvbnRyb2xsZXJgIGludGVybmFscywgd2hpY2ggaXMgd2h5IHRoaXMgXCJmYWN0b3J5IGZhY3RvcnlcIiBleGlzdHMuXG4gKlxuICogVGhlIG1pZGRsZXdhcmVzIHJldHVybmVkIGJ5IHRoZSBmYWN0b3J5IHdpbGwgcGFzcyB0aHJvdWdoIHJlcXVlc3RzIGZvclxuICogdW5yZXN0cmljdGVkIG1ldGhvZHMsIGFuZCBhdHRlbXB0IHRvIGV4ZWN1dGUgcmVzdHJpY3RlZCBtZXRob2RzLiBJZiBhIG1ldGhvZFxuICogaXMgbmVpdGhlciByZXN0cmljdGVkIG5vciB1bnJlc3RyaWN0ZWQsIGEgXCJtZXRob2Qgbm90IGZvdW5kXCIgZXJyb3Igd2lsbCBiZVxuICogcmV0dXJuZWQuXG4gKiBJZiBhIG1ldGhvZCBpcyByZXN0cmljdGVkLCB0aGUgbWlkZGxld2FyZSB3aWxsIGZpcnN0IGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlXG4gKiBzdWJqZWN0J3MgcGVybWlzc2lvbiBmb3IgdGhhdCBtZXRob2QuIElmIHRoZSBwZXJtaXNzaW9uIGlzIGZvdW5kLCB0aGUgbWV0aG9kXG4gKiB3aWxsIGJlIGV4ZWN1dGVkLiBPdGhlcndpc2UsIGFuIFwidW5hdXRob3JpemVkXCIgZXJyb3Igd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICogQHBhcmFtIG9wdGlvbnMuZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2QgLSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuX2V4ZWN1dGVSZXN0cmljdGVkTWV0aG9kfS5cbiAqIEBwYXJhbSBvcHRpb25zLmdldFJlc3RyaWN0ZWRNZXRob2QgLSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuZ2V0UmVzdHJpY3RlZE1ldGhvZH0uXG4gKiBAcGFyYW0gb3B0aW9ucy5pc1VucmVzdHJpY3RlZE1ldGhvZCAtIEEgZnVuY3Rpb24gdGhhdCBjaGVja3Mgd2hldGhlciBhXG4gKiBwYXJ0aWN1bGFyIG1ldGhvZCBpcyB1bnJlc3RyaWN0ZWQuXG4gKiBAcmV0dXJucyBBIHBlcm1pc3Npb24gbWlkZGxld2FyZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRQZXJtaXNzaW9uTWlkZGxld2FyZUZhY3RvcnkoeyBleGVjdXRlUmVzdHJpY3RlZE1ldGhvZCwgZ2V0UmVzdHJpY3RlZE1ldGhvZCwgaXNVbnJlc3RyaWN0ZWRNZXRob2QsIH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUGVybWlzc2lvbk1pZGRsZXdhcmUoc3ViamVjdCkge1xuICAgICAgICBjb25zdCB7IG9yaWdpbiB9ID0gc3ViamVjdDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnIHx8ICFvcmlnaW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1YmplY3QgXCJvcmlnaW5cIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwZXJtaXNzaW9uc01pZGRsZXdhcmUgPSBhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbWV0aG9kLCBwYXJhbXMgfSA9IHJlcTtcbiAgICAgICAgICAgIC8vIFNraXAgcmVnaXN0ZXJlZCB1bnJlc3RyaWN0ZWQgbWV0aG9kcy5cbiAgICAgICAgICAgIGlmIChpc1VucmVzdHJpY3RlZE1ldGhvZChtZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBubyByZXN0cmljdGVkIG1ldGhvZCBpbXBsZW1lbnRhdGlvbiBpcyBmb3VuZC5cbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZEltcGxlbWVudGF0aW9uID0gZ2V0UmVzdHJpY3RlZE1ldGhvZChtZXRob2QsIG9yaWdpbik7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgdGhlIHBlcm1pc3Npb24gZG9lcyBub3QgZXhpc3QuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlUmVzdHJpY3RlZE1ldGhvZChtZXRob2RJbXBsZW1lbnRhdGlvbiwgc3ViamVjdCwgbWV0aG9kLCBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzLmVycm9yID0gZXJyb3JzXzEuaW50ZXJuYWxFcnJvcihgUmVxdWVzdCBmb3IgbWV0aG9kIFwiJHtyZXEubWV0aG9kfVwiIHJldHVybmVkIHVuZGVmaW5lZCByZXN1bHQuYCwgeyByZXF1ZXN0OiByZXEgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHBlcm1pc3Npb25zTWlkZGxld2FyZSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0UGVybWlzc2lvbk1pZGRsZXdhcmVGYWN0b3J5ID0gZ2V0UGVybWlzc2lvbk1pZGRsZXdhcmVGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVybWlzc2lvbi1taWRkbGV3YXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlcml2ZXJzID0gdm9pZCAwO1xuY29uc3QgYmlwMzIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmlwMzJcIikpO1xuY29uc3QgYmlwMzkgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmlwMzlcIikpO1xuZXhwb3J0cy5kZXJpdmVycyA9IHtcbiAgICBiaXAzMixcbiAgICBiaXAzOSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgbnVtYmVyVG9CTiA9IHJlcXVpcmUoJ251bWJlci10by1ibicpO1xudmFyIGtlY2NhazI1NiA9IHJlcXVpcmUoJ2pzLXNoYTMnKS5rZWNjYWtfMjU2O1xuXG4vLyBmcm9tIGV0aGVyZXVtanMtdXRpbFxuZnVuY3Rpb24gc3RyaXBaZXJvcyhhSW5wdXQpIHtcbiAgdmFyIGEgPSBhSW5wdXQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGZpcnN0ID0gYVswXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgIGEgPSBhLnNsaWNlKDEpO1xuICAgIGZpcnN0ID0gYVswXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gYm5Ub0J1ZmZlcihibklucHV0KSB7XG4gIHZhciBibiA9IGJuSW5wdXQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGhleCA9IGJuLnRvU3RyaW5nKDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICBoZXggPSAnMCcgKyBoZXg7XG4gIH1cbiAgcmV0dXJuIHN0cmlwWmVyb3MobmV3IEJ1ZmZlcihoZXgsICdoZXgnKSk7XG59XG5cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBoZXhPckJ1ZmZlcih2YWx1ZUlucHV0LCBuYW1lKSB7XG4gIHZhciB2YWx1ZSA9IHZhbHVlSW5wdXQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihuYW1lID8gJ1tldGhqcy1hYmldIGludmFsaWQgJyArIG5hbWUgOiAnW2V0aGpzLWFiaV0gaW52YWxpZCBoZXggb3IgYnVmZmVyLCBtdXN0IGJlIGEgcHJlZml4ZWQgYWxwaGFudW1lcmljIGV2ZW4gbGVuZ3RoIGhleCBzdHJpbmcnKTtcbiAgICAgIGVycm9yLnJlYXNvbiA9ICdbZXRoanMtYWJpXSBpbnZhbGlkIGhleCBzdHJpbmcsIGhleCBtdXN0IGJlIHByZWZpeGVkIGFuZCBhbHBoYW51bWVyaWMgKGUuZy4gMHgwMjMuLiknO1xuICAgICAgZXJyb3IudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG4gICAgICB2YWx1ZSA9ICcwJyArIHZhbHVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IG5ldyBCdWZmZXIodmFsdWUsICdoZXgnKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gaGV4bGlmeSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiAnMHgnICsgYm5Ub0J1ZmZlcihuZXcgQk4odmFsdWUpKS50b1N0cmluZygnaGV4Jyk7XG4gIH0gZWxzZSBpZiAodmFsdWUubW9kIHx8IHZhbHVlLm1vZHVsbykge1xuICAgIHJldHVybiAnMHgnICsgYm5Ub0J1ZmZlcih2YWx1ZSkudG9TdHJpbmcoJ2hleCcpO1xuICB9IGVsc2Uge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gJzB4JyArIGhleE9yQnVmZmVyKHZhbHVlKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cbn1cblxuLy8gZ2V0S2V5cyhbe2E6IDEsIGI6IDJ9LCB7YTogMywgYjogNH1dLCAnYScpID0+IFsxLCAzXVxuZnVuY3Rpb24gZ2V0S2V5cyhwYXJhbXMsIGtleSwgYWxsb3dFbXB0eSkge1xuICB2YXIgcmVzdWx0ID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLWFiaV0gd2hpbGUgZ2V0dGluZyBrZXlzLCBpbnZhbGlkIHBhcmFtcyB2YWx1ZSAnICsgSlNPTi5zdHJpbmdpZnkocGFyYW1zKSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgdmFsdWUgPSBwYXJhbXNbaV1ba2V5XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChhbGxvd0VtcHR5ICYmICF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLWFiaV0gd2hpbGUgZ2V0S2V5cyBmb3VuZCBpbnZhbGlkIEFCSSBkYXRhIHN0cnVjdHVyZSwgdHlwZSB2YWx1ZSBub3Qgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNvZGVyTnVtYmVyKHNpemUsIHNpZ25lZCkge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlTnVtYmVyKHZhbHVlSW5wdXQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW5wdXQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUudG9TdHJpbmcgJiYgKHZhbHVlLnRvVHdvcyB8fCB2YWx1ZS5kaXZpZGVkVG9JbnRlZ2VyQnkpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoMTApLnNwbGl0KCcuJylbMF07XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpLnNwbGl0KCcuJylbMF07XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gbnVtYmVyVG9CTih2YWx1ZSk7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvVHdvcyhzaXplICogOCkubWFza24oc2l6ZSAqIDgpO1xuICAgICAgaWYgKHNpZ25lZCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLmZyb21Ud29zKHNpemUgKiA4KS50b1R3b3MoMjU2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKTtcbiAgICB9LFxuICAgIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlTnVtYmVyKGRhdGEsIG9mZnNldCkge1xuICAgICAgdmFyIGp1bmtMZW5ndGggPSAzMiAtIHNpemU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHZhciB2YWx1ZSA9IG5ldyBCTihkYXRhLnNsaWNlKG9mZnNldCArIGp1bmtMZW5ndGgsIG9mZnNldCArIDMyKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5mcm9tVHdvcyhzaXplICogOCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hc2tuKHNpemUgKiA4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN1bWVkOiAzMixcbiAgICAgICAgdmFsdWU6IG5ldyBCTih2YWx1ZS50b1N0cmluZygxMCkpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbnZhciB1aW50MjU2Q29kZXIgPSBjb2Rlck51bWJlcigzMiwgZmFsc2UpO1xuXG52YXIgY29kZXJCb29sZWFuID0ge1xuICBlbmNvZGU6IGZ1bmN0aW9uIGVuY29kZUJvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdWludDI1NkNvZGVyLmVuY29kZSh2YWx1ZSA/IDEgOiAwKTtcbiAgfSxcbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGVCb29sZWFuKGRhdGEsIG9mZnNldCkge1xuICAgIHZhciByZXN1bHQgPSB1aW50MjU2Q29kZXIuZGVjb2RlKGRhdGEsIG9mZnNldCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4ge1xuICAgICAgY29uc3VtZWQ6IHJlc3VsdC5jb25zdW1lZCxcbiAgICAgIHZhbHVlOiAhcmVzdWx0LnZhbHVlLmlzWmVybygpXG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY29kZXJGaXhlZEJ5dGVzKGxlbmd0aCkge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlRml4ZWRCeXRlcyh2YWx1ZUlucHV0KSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUlucHV0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB2YWx1ZSA9IGhleE9yQnVmZmVyKHZhbHVlKTtcblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEJ1ZmZlcigzMik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHJlc3VsdC5maWxsKDApO1xuICAgICAgdmFsdWUuY29weShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlRml4ZWRCeXRlcyhkYXRhLCBvZmZzZXQpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMCAmJiBkYXRhLmxlbmd0aCA8IG9mZnNldCArIDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLWFiaV0gd2hpbGUgZGVjb2RpbmcgZml4ZWQgYnl0ZXMsIGludmFsaWQgYnl0ZXMgZGF0YSBsZW5ndGg6ICcgKyBsZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb25zdW1lZDogMzIsXG4gICAgICAgIHZhbHVlOiAnMHgnICsgZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCkudG9TdHJpbmcoJ2hleCcpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGNvZGVyQWRkcmVzcyA9IHtcbiAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGVBZGRyZXNzKHZhbHVlSW5wdXQpIHtcbiAgICB2YXIgdmFsdWUgPSB2YWx1ZUlucHV0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBCdWZmZXIoMzIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSwgMjApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy1hYmldIHdoaWxlIGVuY29kaW5nIGFkZHJlc3MsIGludmFsaWQgYWRkcmVzcyB2YWx1ZSwgbm90IGFscGhhbnVtZXJpYyAyMCBieXRlIGhleCBzdHJpbmcnKTtcbiAgICB9XG4gICAgdmFsdWUgPSBoZXhPckJ1ZmZlcih2YWx1ZSk7XG4gICAgcmVzdWx0LmZpbGwoMCk7XG4gICAgdmFsdWUuY29weShyZXN1bHQsIDEyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZUFkZHJlc3MoZGF0YSwgb2Zmc2V0KSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb25zdW1lZDogMzIsXG4gICAgICAgIHZhbHVlOiAnMHgnXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZGF0YS5sZW5ndGggIT09IDAgJiYgZGF0YS5sZW5ndGggPCBvZmZzZXQgKyAzMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtYWJpXSB3aGlsZSBkZWNvZGluZyBhZGRyZXNzIGRhdGEsIGludmFsaWQgYWRkcmVzcyBkYXRhLCBpbnZhbGlkIGJ5dGUgbGVuZ3RoICcgKyBkYXRhLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb25zdW1lZDogMzIsXG4gICAgICB2YWx1ZTogJzB4JyArIGRhdGEuc2xpY2Uob2Zmc2V0ICsgMTIsIG9mZnNldCArIDMyKS50b1N0cmluZygnaGV4JylcbiAgICB9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBlbmNvZGVEeW5hbWljQnl0ZXNIZWxwZXIodmFsdWUpIHtcbiAgdmFyIGRhdGFMZW5ndGggPSBwYXJzZUludCgzMiAqIE1hdGguY2VpbCh2YWx1ZS5sZW5ndGggLyAzMikpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHZhciBwYWRkaW5nID0gbmV3IEJ1ZmZlcihkYXRhTGVuZ3RoIC0gdmFsdWUubGVuZ3RoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBwYWRkaW5nLmZpbGwoMCk7XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3VpbnQyNTZDb2Rlci5lbmNvZGUodmFsdWUubGVuZ3RoKSwgdmFsdWUsIHBhZGRpbmddKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRHluYW1pY0J5dGVzSGVscGVyKGRhdGEsIG9mZnNldCkge1xuICBpZiAoZGF0YS5sZW5ndGggIT09IDAgJiYgZGF0YS5sZW5ndGggPCBvZmZzZXQgKyAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLWFiaV0gd2hpbGUgZGVjb2RpbmcgZHluYW1pYyBieXRlcyBkYXRhLCBpbnZhbGlkIGJ5dGVzIGxlbmd0aDogJyArIGRhdGEubGVuZ3RoICsgJyBzaG91bGQgYmUgbGVzcyB0aGFuICcgKyAob2Zmc2V0ICsgMzIpKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSB1aW50MjU2Q29kZXIuZGVjb2RlKGRhdGEsIG9mZnNldCkudmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgbGVuZ3RoID0gbGVuZ3RoLnRvTnVtYmVyKCk7XG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gMCAmJiBkYXRhLmxlbmd0aCA8IG9mZnNldCArIDMyICsgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtYWJpXSB3aGlsZSBkZWNvZGluZyBkeW5hbWljIGJ5dGVzIGRhdGEsIGludmFsaWQgYnl0ZXMgbGVuZ3RoOiAnICsgZGF0YS5sZW5ndGggKyAnIHNob3VsZCBiZSBsZXNzIHRoYW4gJyArIChvZmZzZXQgKyAzMiArIGxlbmd0aCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb25zdW1lZDogcGFyc2VJbnQoMzIgKyAzMiAqIE1hdGguY2VpbChsZW5ndGggLyAzMiksIDEwKSxcbiAgICB2YWx1ZTogZGF0YS5zbGljZShvZmZzZXQgKyAzMiwgb2Zmc2V0ICsgMzIgKyBsZW5ndGgpXG4gIH07XG59XG5cbnZhciBjb2RlckR5bmFtaWNCeXRlcyA9IHtcbiAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGVEeW5hbWljQnl0ZXModmFsdWUpIHtcbiAgICByZXR1cm4gZW5jb2RlRHluYW1pY0J5dGVzSGVscGVyKGhleE9yQnVmZmVyKHZhbHVlKSk7XG4gIH0sXG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlRHluYW1pY0J5dGVzKGRhdGEsIG9mZnNldCkge1xuICAgIHZhciByZXN1bHQgPSBkZWNvZGVEeW5hbWljQnl0ZXNIZWxwZXIoZGF0YSwgb2Zmc2V0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHJlc3VsdC52YWx1ZSA9ICcweCcgKyByZXN1bHQudmFsdWUudG9TdHJpbmcoJ2hleCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIGR5bmFtaWM6IHRydWVcbn07XG5cbnZhciBjb2RlclN0cmluZyA9IHtcbiAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGVTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gZW5jb2RlRHluYW1pY0J5dGVzSGVscGVyKG5ldyBCdWZmZXIodmFsdWUsICd1dGY4JykpO1xuICB9LFxuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZVN0cmluZyhkYXRhLCBvZmZzZXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGVjb2RlRHluYW1pY0J5dGVzSGVscGVyKGRhdGEsIG9mZnNldCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICByZXN1bHQudmFsdWUgPSByZXN1bHQudmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBkeW5hbWljOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBjb2RlckFycmF5KGNvZGVyLCBsZW5ndGhJbnB1dCkge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlQXJyYXkodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQnVmZmVyKDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoSW5wdXQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy1hYmldIHdoaWxlIGVuY29kaW5nIGFycmF5LCBpbnZhbGlkIGFycmF5IGRhdGEsIG5vdCB0eXBlIE9iamVjdCAoQXJyYXkpJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW5ndGggPT09IC0xKSB7XG4gICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgcmVzdWx0ID0gdWludDI1NkNvZGVyLmVuY29kZShsZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoICE9PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtYWJpXSB3aGlsZSBlbmNvZGluZyBhcnJheSwgc2l6ZSBtaXNtYXRjaCBhcnJheSBsZW5ndGggJyArIGxlbmd0aCArICcgZG9lcyBub3QgZXF1YWwgJyArIHZhbHVlLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdFZhbHVlKSB7XG4gICAgICAgIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoW3Jlc3VsdCwgY29kZXIuZW5jb2RlKHJlc3VsdFZhbHVlKV0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZUFycmF5KGRhdGEsIG9mZnNldElucHV0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoSW5wdXQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXRJbnB1dDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgLy8gQFRPRE86XG4gICAgICAvLyBpZiAoZGF0YS5sZW5ndGggPCBvZmZzZXQgKyBsZW5ndGggKiAzMikgeyB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJyYXknKTsgfVxuXG4gICAgICB2YXIgY29uc3VtZWQgPSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB2YXIgZGVjb2RlUmVzdWx0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgIGlmIChsZW5ndGggPT09IC0xKSB7XG4gICAgICAgIGRlY29kZVJlc3VsdCA9IHVpbnQyNTZDb2Rlci5kZWNvZGUoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgbGVuZ3RoID0gZGVjb2RlUmVzdWx0LnZhbHVlLnRvTnVtYmVyKCk7XG4gICAgICAgIGNvbnN1bWVkICs9IGRlY29kZVJlc3VsdC5jb25zdW1lZDtcbiAgICAgICAgb2Zmc2V0ICs9IGRlY29kZVJlc3VsdC5jb25zdW1lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHZhciBsb29wUmVzdWx0ID0gY29kZXIuZGVjb2RlKGRhdGEsIG9mZnNldCk7XG4gICAgICAgIGNvbnN1bWVkICs9IGxvb3BSZXN1bHQuY29uc3VtZWQ7XG4gICAgICAgIG9mZnNldCArPSBsb29wUmVzdWx0LmNvbnN1bWVkO1xuICAgICAgICB2YWx1ZS5wdXNoKGxvb3BSZXN1bHQudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb25zdW1lZDogY29uc3VtZWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGR5bmFtaWM6IGxlbmd0aElucHV0ID09PSAtMVxuICB9O1xufVxuXG4vLyBCcmVhayB0aGUgdHlwZSB1cCBpbnRvIFtzdGF0aWNUeXBlXVtzdGF0aWNBcnJheV0qW2R5bmFtaWNBcnJheV0/IHwgW2R5bmFtaWNUeXBlXSBhbmRcbi8vIGJ1aWxkIHRoZSBjb2RlciB1cCBmcm9tIGl0cyBwYXJ0c1xudmFyIHBhcmFtVHlwZVBhcnQgPSBuZXcgUmVnRXhwKC9eKCh1P2ludHxieXRlcykoWzAtOV0qKXwoYWRkcmVzc3xib29sfHN0cmluZyl8KFxcWyhbMC05XSopXFxdKSkvKTtcblxuZnVuY3Rpb24gZ2V0UGFyYW1Db2Rlcih0eXBlSW5wdXQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlSW5wdXQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGNvZGVyID0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgaW52YWxpZFR5cGVFcnJvck1lc3NhZ2UgPSAnW2V0aGpzLWFiaV0gd2hpbGUgZ2V0dGluZyBwYXJhbSBjb2RlciAoZ2V0UGFyYW1Db2RlcikgdHlwZSB2YWx1ZSAnICsgSlNPTi5zdHJpbmdpZnkodHlwZSkgKyAnIGlzIGVpdGhlciBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGJ5IGV0aGpzLWFiaS4nO1xuXG4gIHdoaWxlICh0eXBlKSB7XG4gICAgdmFyIHBhcnQgPSB0eXBlLm1hdGNoKHBhcmFtVHlwZVBhcnQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKCFwYXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoaW52YWxpZFR5cGVFcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICB0eXBlID0gdHlwZS5zdWJzdHJpbmcocGFydFswXS5sZW5ndGgpO1xuXG4gICAgdmFyIHByZWZpeCA9IHBhcnRbMl0gfHwgcGFydFs0XSB8fCBwYXJ0WzVdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgc3dpdGNoIChwcmVmaXgpIHtcbiAgICAgIGNhc2UgJ2ludCc6Y2FzZSAndWludCc6XG4gICAgICAgIGlmIChjb2Rlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbnZhbGlkVHlwZUVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludFNpemUgPSBwYXJzZUludChwYXJ0WzNdIHx8IDI1Nik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgaWYgKGludFNpemUgPT09IDAgfHwgaW50U2l6ZSA+IDI1NiB8fCBpbnRTaXplICUgOCAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLWFiaV0gd2hpbGUgZ2V0dGluZyBwYXJhbSBjb2RlciBmb3IgdHlwZSAnICsgdHlwZSArICcsIGludmFsaWQgJyArIHByZWZpeCArICc8Tj4gd2lkdGg6ICcgKyB0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGVyID0gY29kZXJOdW1iZXIoaW50U2l6ZSAvIDgsIHByZWZpeCA9PT0gJ2ludCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgIGlmIChjb2Rlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbnZhbGlkVHlwZUVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZXIgPSBjb2RlckJvb2xlYW47XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBpZiAoY29kZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW52YWxpZFR5cGVFcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVyID0gY29kZXJTdHJpbmc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdieXRlcyc6XG4gICAgICAgIGlmIChjb2Rlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbnZhbGlkVHlwZUVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRbM10pIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KHBhcnRbM10pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgaWYgKHNpemUgPT09IDAgfHwgc2l6ZSA+IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy1hYmldIHdoaWxlIGdldHRpbmcgcGFyYW0gY29kZXIgZm9yIHByZWZpeCBieXRlcywgaW52YWxpZCB0eXBlICcgKyB0eXBlICsgJywgc2l6ZSAnICsgc2l6ZSArICcgc2hvdWxkIGJlIDAgb3IgZ3JlYXRlciB0aGFuIDMyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvZGVyID0gY29kZXJGaXhlZEJ5dGVzKHNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvZGVyID0gY29kZXJEeW5hbWljQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgICBpZiAoY29kZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW52YWxpZFR5cGVFcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVyID0gY29kZXJBZGRyZXNzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnW10nOlxuICAgICAgICBpZiAoIWNvZGVyIHx8IGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW52YWxpZFR5cGVFcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVyID0gY29kZXJBcnJheShjb2RlciwgLTEpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gXCJbMC05K11cIlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKCFjb2RlciB8fCBjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGludmFsaWRUeXBlRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmYXVsdFNpemUgPSBwYXJzZUludChwYXJ0WzZdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBjb2RlciA9IGNvZGVyQXJyYXkoY29kZXIsIGRlZmF1bHRTaXplKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGludmFsaWRUeXBlRXJyb3JNZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gY29kZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCTjogQk4sXG4gIGJuVG9CdWZmZXI6IGJuVG9CdWZmZXIsXG4gIGlzSGV4U3RyaW5nOiBpc0hleFN0cmluZyxcbiAgaGV4T3JCdWZmZXI6IGhleE9yQnVmZmVyLFxuICBoZXhsaWZ5OiBoZXhsaWZ5LFxuICBzdHJpcFplcm9zOiBzdHJpcFplcm9zLFxuXG4gIGtlY2NhazI1Njoga2VjY2FrMjU2LFxuXG4gIGdldEtleXM6IGdldEtleXMsXG4gIG51bWJlclRvQk46IG51bWJlclRvQk4sXG4gIGNvZGVyTnVtYmVyOiBjb2Rlck51bWJlcixcbiAgdWludDI1NkNvZGVyOiB1aW50MjU2Q29kZXIsXG4gIGNvZGVyQm9vbGVhbjogY29kZXJCb29sZWFuLFxuICBjb2RlckZpeGVkQnl0ZXM6IGNvZGVyRml4ZWRCeXRlcyxcbiAgY29kZXJBZGRyZXNzOiBjb2RlckFkZHJlc3MsXG4gIGNvZGVyRHluYW1pY0J5dGVzOiBjb2RlckR5bmFtaWNCeXRlcyxcbiAgY29kZXJTdHJpbmc6IGNvZGVyU3RyaW5nLFxuICBjb2RlckFycmF5OiBjb2RlckFycmF5LFxuICBwYXJhbVR5cGVQYXJ0OiBwYXJhbVR5cGVQYXJ0LFxuICBnZXRQYXJhbUNvZGVyOiBnZXRQYXJhbUNvZGVyXG59OyIsIi8qIVxuICAqIHByclxuICAqIChjKSAyMDEzIFJvZCBWYWdnIDxyb2RAdmFnZy5vcmc+XG4gICogaHR0cHM6Ly9naXRodWIuY29tL3J2YWdnL3ByclxuICAqIExpY2Vuc2U6IE1JVFxuICAqL1xuXG4oZnVuY3Rpb24gKG5hbWUsIGNvbnRleHQsIGRlZmluaXRpb24pIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZVxuICAgIGNvbnRleHRbbmFtZV0gPSBkZWZpbml0aW9uKClcbn0pKCdwcnInLCB0aGlzLCBmdW5jdGlvbigpIHtcblxuICB2YXIgc2V0UHJvcGVydHkgPSB0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09ICdmdW5jdGlvbidcbiAgICAgID8gZnVuY3Rpb24gKG9iaiwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCBvcHRpb25zKVxuICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgfVxuICAgICAgOiBmdW5jdGlvbiAob2JqLCBrZXksIG9wdGlvbnMpIHsgLy8gPCBlczVcbiAgICAgICAgICBvYmpba2V5XSA9IG9wdGlvbnMudmFsdWVcbiAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIH1cblxuICAgICwgbWFrZU9wdGlvbnMgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9vID0gdHlwZW9mIG9wdGlvbnMgPT0gJ29iamVjdCdcbiAgICAgICAgICAsIG9zID0gIW9vICYmIHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnXG4gICAgICAgICAgLCBvcCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvb1xuICAgICAgICAgICAgICAgID8gISFvcHRpb25zW3BdXG4gICAgICAgICAgICAgICAgOiBvc1xuICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmluZGV4T2YocFswXSkgPiAtMVxuICAgICAgICAgICAgICAgICAgOiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlICAgOiBvcCgnZW51bWVyYWJsZScpXG4gICAgICAgICAgLCBjb25maWd1cmFibGUgOiBvcCgnY29uZmlndXJhYmxlJylcbiAgICAgICAgICAsIHdyaXRhYmxlICAgICA6IG9wKCd3cml0YWJsZScpXG4gICAgICAgICAgLCB2YWx1ZSAgICAgICAgOiB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAsIHByciA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGtcblxuICAgICAgICBvcHRpb25zID0gbWFrZU9wdGlvbnModmFsdWUsIG9wdGlvbnMpXG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKGsgaW4ga2V5KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoa2V5LCBrKSkge1xuICAgICAgICAgICAgICBvcHRpb25zLnZhbHVlID0ga2V5W2tdXG4gICAgICAgICAgICAgIHNldFByb3BlcnR5KG9iaiwgaywgb3B0aW9ucylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNldFByb3BlcnR5KG9iaiwga2V5LCBvcHRpb25zKVxuICAgICAgfVxuXG4gIHJldHVybiBwcnJcbn0pIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGNvZGVzID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTm9kZUVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHNMb29zZShOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICByZXR1cm4gX0Jhc2UuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXJyb3I7XG4gIH0oQmFzZSk7XG5cbiAgTm9kZUVycm9yLnByb3RvdHlwZS5uYW1lID0gQmFzZS5uYW1lO1xuICBOb2RlRXJyb3IucHJvdG90eXBlLmNvZGUgPSBjb2RlO1xuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiAnVGhlIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiJztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgZnVuY3Rpb24gKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH1cblxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KHR5cGVvZiBhY3R1YWwpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRicsICdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnVGhlICcgKyBuYW1lICsgJyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScsICdQcmVtYXR1cmUgY2xvc2UnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ0Nhbm5vdCBjYWxsICcgKyBuYW1lICsgJyBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTVVMVElQTEVfQ0FMTEJBQ0snLCAnQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fQ0FOTk9UX1BJUEUnLCAnQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCcsICd3cml0ZSBhZnRlciBlbmQnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUycsICdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScsIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9VTktOT1dOX0VOQ09ESU5HJywgZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBhcmc7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UJywgJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCIndXNlIHN0cmljdCc7IC8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcblxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9IC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcblxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcbiAgZW1pdENsb3NlTlQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGVtaXRDbG9zZU5UKHNlbGYpIHtcbiAgaWYgKHNlbGYuX3dyaXRhYmxlU3RhdGUgJiYgIXNlbGYuX3dyaXRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIGlmIChzZWxmLl9yZWFkYWJsZVN0YXRlICYmICFzZWxmLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHtcbiAgLy8gV2UgaGF2ZSB0ZXN0cyB0aGF0IHJlbHkgb24gZXJyb3JzIGJlaW5nIGVtaXR0ZWRcbiAgLy8gaW4gdGhlIHNhbWUgdGljaywgc28gY2hhbmdpbmcgdGhpcyBpcyBzZW12ZXIgbWFqb3IuXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XG4gIC8vIHRoZSBlcnJvciB0byBiZSBlbWl0dGVkIG5leHRUaWNrLiBJbiBhIGZ1dHVyZVxuICAvLyBzZW12ZXIgbWFqb3IgdXBkYXRlIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGRlZmF1bHQgdG8gdGhpcy5cbiAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHJTdGF0ZSAmJiByU3RhdGUuYXV0b0Rlc3Ryb3kgfHwgd1N0YXRlICYmIHdTdGF0ZS5hdXRvRGVzdHJveSkgc3RyZWFtLmRlc3Ryb3koZXJyKTtlbHNlIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveSxcbiAgZXJyb3JPckRlc3Ryb3k6IGVycm9yT3JEZXN0cm95XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9JTlZBTElEX09QVF9WQUxVRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9JTlZBTElEX09QVF9WQUxVRTtcblxuZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkge1xuICByZXR1cm4gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrICE9IG51bGwgPyBvcHRpb25zLmhpZ2hXYXRlck1hcmsgOiBpc0R1cGxleCA/IG9wdGlvbnNbZHVwbGV4S2V5XSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEhpZ2hXYXRlck1hcmsoc3RhdGUsIG9wdGlvbnMsIGR1cGxleEtleSwgaXNEdXBsZXgpIHtcbiAgdmFyIGh3bSA9IGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpO1xuXG4gIGlmIChod20gIT0gbnVsbCkge1xuICAgIGlmICghKGlzRmluaXRlKGh3bSkgJiYgTWF0aC5mbG9vcihod20pID09PSBod20pIHx8IGh3bSA8IDApIHtcbiAgICAgIHZhciBuYW1lID0gaXNEdXBsZXggPyBkdXBsZXhLZXkgOiAnaGlnaFdhdGVyTWFyayc7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfT1BUX1ZBTFVFKG5hbWUsIGh3bSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoaHdtKTtcbiAgfSAvLyBEZWZhdWx0IHZhbHVlXG5cblxuICByZXR1cm4gc3RhdGUub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0SGlnaFdhdGVyTWFyazogZ2V0SGlnaFdhdGVyTWFya1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdSZWFkYWJsZS5mcm9tIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJyb3dzZXInKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnYnVmZmVyJyksXG4gICAgQnVmZmVyID0gX3JlcXVpcmUuQnVmZmVyO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgndXRpbCcpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcblxudmFyIGN1c3RvbSA9IGluc3BlY3QgJiYgaW5zcGVjdC5jdXN0b20gfHwgJ2luc3BlY3QnO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoc3JjLCB0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJ1ZmZlckxpc3QsIFt7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuc2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IHRoaXMuaGVhZFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpvaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gam9pbihzKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29uY2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgb3IgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uc3VtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdW1lKG4sIGhhc1N0cmluZ3MpIHtcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIGlmIChuIDwgdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIGBzbGljZWAgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICAgIHJldCA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgICAgICB0aGlzLmhlYWQuZGF0YSA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICAgICAgfSBlbHNlIGlmIChuID09PSB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gRmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoLlxuICAgICAgICByZXQgPSB0aGlzLnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXIuXG4gICAgICAgIHJldCA9IGhhc1N0cmluZ3MgPyB0aGlzLl9nZXRTdHJpbmcobikgOiB0aGlzLl9nZXRCdWZmZXIobik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0cmluZyhuKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHZhciByZXQgPSBwLmRhdGE7XG4gICAgICBuIC09IHJldC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgICAgIG4gLT0gbmI7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytjO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QnVmZmVyKG4pIHtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHAuZGF0YS5jb3B5KHJldCk7XG4gICAgICBuIC09IHAuZGF0YS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gTWFrZSBzdXJlIHRoZSBsaW5rZWQgbGlzdCBvbmx5IHNob3dzIHRoZSBtaW5pbWFsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbi5cblxuICB9LCB7XG4gICAga2V5OiBjdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKF8sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgLy8gT25seSBpbnNwZWN0IG9uZSBsZXZlbC5cbiAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgIC8vIEl0IHNob3VsZCBub3QgcmVjdXJzZS5cbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU87XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBmaW5pc2hlZCA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuXG52YXIga0xhc3RSZXNvbHZlID0gU3ltYm9sKCdsYXN0UmVzb2x2ZScpO1xudmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKCdsYXN0UmVqZWN0Jyk7XG52YXIga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xudmFyIGtFbmRlZCA9IFN5bWJvbCgnZW5kZWQnKTtcbnZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woJ2xhc3RQcm9taXNlJyk7XG52YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woJ2hhbmRsZVByb21pc2UnKTtcbnZhciBrU3RyZWFtID0gU3ltYm9sKCdzdHJlYW0nKTtcblxuZnVuY3Rpb24gY3JlYXRlSXRlclJlc3VsdCh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkb25lOiBkb25lXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGl0ZXIpIHtcbiAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07XG5cbiAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICB2YXIgZGF0YSA9IGl0ZXJba1N0cmVhbV0ucmVhZCgpOyAvLyB3ZSBkZWZlciBpZiBkYXRhIGlzIG51bGxcbiAgICAvLyB3ZSBjYW4gYmUgZXhwZWN0aW5nIGVpdGhlciAnZW5kJyBvclxuICAgIC8vICdlcnJvcidcblxuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHtcbiAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgdGljaywgYmVjYXVzZSBpdCBtaWdodFxuICAvLyBlbWl0IGFuIGVycm9yIHdpdGggcHJvY2Vzcy5uZXh0VGlja1xuICBwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLCBpdGVyKTtcbn1cblxuZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsYXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGl0ZXJba0hhbmRsZVByb21pc2VdKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfTtcbn1cblxudmFyIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24gKCkge30pO1xudmFyIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZigoX09iamVjdCRzZXRQcm90b3R5cGVPID0ge1xuICBnZXQgc3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzW2tTdHJlYW1dO1xuICB9LFxuXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIGlmIHdlIGhhdmUgZGV0ZWN0ZWQgYW4gZXJyb3IgaW4gdGhlIG1lYW53aGlsZVxuICAgIC8vIHJlamVjdCBzdHJhaWdodCBhd2F5XG4gICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tFbmRlZF0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trU3RyZWFtXS5kZXN0cm95ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdmlhIG5leHRUaWNrIGJlY2F1c2UgaWYgLmRlc3Ryb3koZXJyKSBpc1xuICAgICAgLy8gY2FsbGVkLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIHZpYSBuZXh0VGljaywgYW5kXG4gICAgICAvLyB3ZSBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhlcmUgaXMgbm8gZXJyb3IgbGluZ2VyaW5nIGFyb3VuZFxuICAgICAgLy8gd2FpdGluZyB0byBiZSBlbWl0dGVkLlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzW2tFcnJvcl0pIHtcbiAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIGlmIHdlIGhhdmUgbXVsdGlwbGUgbmV4dCgpIGNhbGxzXG4gICAgLy8gd2Ugd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgUHJvbWlzZSB0byBmaW5pc2hcbiAgICAvLyB0aGlzIGxvZ2ljIGlzIG9wdGltaXplZCB0byBzdXBwb3J0IGZvciBhd2FpdCBsb29wcyxcbiAgICAvLyB3aGVyZSBuZXh0KCkgaXMgb25seSBjYWxsZWQgb25jZSBhdCBhIHRpbWVcblxuXG4gICAgdmFyIGxhc3RQcm9taXNlID0gdGhpc1trTGFzdFByb21pc2VdO1xuICAgIHZhciBwcm9taXNlO1xuXG4gICAgaWYgKGxhc3RQcm9taXNlKSB7XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2Uod3JhcEZvck5leHQobGFzdFByb21pc2UsIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmFzdCBwYXRoIG5lZWRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHRoaXMucHVzaCgpXG4gICAgICAvLyB3aXRob3V0IHRyaWdnZXJpbmcgdGhlIG5leHQoKSBxdWV1ZVxuICAgICAgdmFyIGRhdGEgPSB0aGlzW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh0aGlzW2tIYW5kbGVQcm9taXNlXSk7XG4gICAgfVxuXG4gICAgdGhpc1trTGFzdFByb21pc2VdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgXCJyZXR1cm5cIiwgZnVuY3Rpb24gX3JldHVybigpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgLy8gZGVzdHJveShlcnIsIGNiKSBpcyBhIHByaXZhdGUgQVBJXG4gIC8vIHdlIGNhbiBndWFyYW50ZWUgd2UgaGF2ZSB0aGF0IGhlcmUsIGJlY2F1c2Ugd2UgY29udHJvbCB0aGVcbiAgLy8gUmVhZGFibGUgY2xhc3MgdGhpcyBpcyBhdHRhY2hlZCB0b1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIF90aGlzMltrU3RyZWFtXS5kZXN0cm95KG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcbn0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcblxudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0pIHtcbiAgdmFyIF9PYmplY3QkY3JlYXRlO1xuXG4gIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7XG4gICAgdmFsdWU6IHN0cmVhbSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwge1xuICAgIHZhbHVlOiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBkYXRhID0gaXRlcmF0b3Jba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IHJlc29sdmU7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfT2JqZWN0JGNyZWF0ZSkpO1xuICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykge1xuICAgICAgdmFyIHJlamVjdCA9IGl0ZXJhdG9yW2tMYXN0UmVqZWN0XTsgLy8gcmVqZWN0IGlmIHdlIGFyZSB3YWl0aW5nIGZvciBkYXRhIGluIHRoZSBQcm9taXNlXG4gICAgICAvLyByZXR1cm5lZCBieSBuZXh0KCkgYW5kIHN0b3JlIHRoZSBlcnJvclxuXG4gICAgICBpZiAocmVqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmUgPSBpdGVyYXRvcltrTGFzdFJlc29sdmVdO1xuXG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGl0ZXJhdG9yW2tFbmRlZF0gPSB0cnVlO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xuICByZXR1cm4gaXRlcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjsiLCJleHBvcnRzLnV0ZjggPSBleHBvcnRzWyd1dGYtOCddID0ge1xuICBlbmNvZGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIGlzQmluYXJ5KGRhdGEpID8gZGF0YSA6IFN0cmluZyhkYXRhKVxuICB9LFxuICBkZWNvZGU6IGlkZW50aXR5LFxuICBidWZmZXI6IGZhbHNlLFxuICB0eXBlOiAndXRmOCdcbn1cblxuZXhwb3J0cy5qc29uID0ge1xuICBlbmNvZGU6IEpTT04uc3RyaW5naWZ5LFxuICBkZWNvZGU6IEpTT04ucGFyc2UsXG4gIGJ1ZmZlcjogZmFsc2UsXG4gIHR5cGU6ICdqc29uJ1xufVxuXG5leHBvcnRzLmJpbmFyeSA9IHtcbiAgZW5jb2RlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBpc0JpbmFyeShkYXRhKSA/IGRhdGEgOiBCdWZmZXIuZnJvbShkYXRhKVxuICB9LFxuICBkZWNvZGU6IGlkZW50aXR5LFxuICBidWZmZXI6IHRydWUsXG4gIHR5cGU6ICdiaW5hcnknXG59XG5cbmV4cG9ydHMubm9uZSA9IHtcbiAgZW5jb2RlOiBpZGVudGl0eSxcbiAgZGVjb2RlOiBpZGVudGl0eSxcbiAgYnVmZmVyOiBmYWxzZSxcbiAgdHlwZTogJ2lkJ1xufVxuXG5leHBvcnRzLmlkID0gZXhwb3J0cy5ub25lXG5cbnZhciBidWZmZXJFbmNvZGluZ3MgPSBbXG4gICdoZXgnLFxuICAnYXNjaWknLFxuICAnYmFzZTY0JyxcbiAgJ3VjczInLFxuICAndWNzLTInLFxuICAndXRmMTZsZScsXG4gICd1dGYtMTZsZSdcbl1cblxuYnVmZmVyRW5jb2RpbmdzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgZXhwb3J0c1t0eXBlXSA9IHtcbiAgICBlbmNvZGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gaXNCaW5hcnkoZGF0YSkgPyBkYXRhIDogQnVmZmVyLmZyb20oZGF0YSwgdHlwZSlcbiAgICB9LFxuICAgIGRlY29kZTogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0eXBlKVxuICAgIH0sXG4gICAgYnVmZmVyOiB0cnVlLFxuICAgIHR5cGU6IHR5cGVcbiAgfVxufSlcblxuZnVuY3Rpb24gaWRlbnRpdHkgKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBpc0JpbmFyeSAoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkIHx8IGRhdGEgPT09IG51bGwgfHwgQnVmZmVyLmlzQnVmZmVyKGRhdGEpXG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNiBUaW0gS3VpanN0ZW5cbiAqXG4gKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAqIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcblxudmFyIHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBJbmRleGVkREIgb2JqZWN0IHN0b3JlIHdpdGggYSByZWFkYWJsZSBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtJREJEYXRhYmFzZX0gZGIgLSBJbmRleGVkREIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdG9yZU5hbWUgLSBuYW1lIG9mIHRoZSBvYmplY3Qgc3RvcmUgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gKlxuICogT3B0aW9uczpcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2V9IG9wdHMucmFuZ2UgLSBhIHZhbGlkIEluZGV4ZWREQiBrZXkgcmFuZ2VcbiAqIEBwYXJhbSB7SURCQ3Vyc29yRGlyZWN0aW9ufSBvcHRzLmRpcmVjdGlvbiAtIG9uZSBvZiBcIm5leHRcIiwgXCJuZXh0dW5pcXVlXCIsXG4gKiAgIFwicHJldlwiLCBcInByZXZ1bmlxdWVcIlxuICogQHBhcmFtIHtCb29sZWFufSBvcHRzLnNuYXBzaG90PWZhbHNlIC0gSXRlcmF0ZSBvdmVyIGEgc25hcHNob3Qgb2YgdGhlIGRhdGFiYXNlXG4gKiAgIGJ5IG9wZW5pbmcgb25seSBvbmUgY3Vyc29yLiBUaGlzIGRpc2FibGVzIGFueSBmb3JtIG9mIGJhY2sgcHJlc3N1cmUgdG8gcHJldmVudFxuICogICBjdXJzb3IgdGltZW91dCBpc3N1ZXMuXG4gKi9cbmZ1bmN0aW9uIGlkYlJlYWRhYmxlU3RyZWFtKGRiLCBzdG9yZU5hbWUsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBkYiAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RiIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgaWYgKHR5cGVvZiBzdG9yZU5hbWUgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdG9yZU5hbWUgbXVzdCBiZSBhIHN0cmluZycpXG4gIGlmIChvcHRzID09IG51bGwpIG9wdHMgPSB7fVxuICBpZiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRzIG11c3QgYmUgYW4gb2JqZWN0JylcblxuICAvLyB1c2UgdHJhbnNmb3JtIHN0cmVhbSBmb3IgYnVmZmVyaW5nIGFuZCBiYWNrIHByZXNzdXJlXG4gIHZhciB0cmFuc2Zvcm1lciA9IG5ldyBzdHJlYW0uVHJhbnNmb3JtKHh0ZW5kKG9wdHMsIHtcbiAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24ob2JqLCBlbmMsIGNiKSB7XG4gICAgICBjYihudWxsLCBvYmopXG4gICAgfVxuICB9KSlcblxuICBvcHRzID0geHRlbmQoe1xuICAgIHNuYXBzaG90OiBmYWxzZVxuICB9LCBvcHRzKVxuXG4gIHZhciBsYXN0SXRlcmF0ZWRLZXkgPSBudWxsXG4gIHRyYW5zZm9ybWVyLl9jdXJzb3JzT3BlbmVkID0gMFxuXG4gIGZ1bmN0aW9uIHN0YXJ0Q3Vyc29yKCkge1xuICAgIHZhciBsb3dlciwgdXBwZXIsIGxvd2VyT3BlbiwgdXBwZXJPcGVuXG5cbiAgICB2YXIgZGlyZWN0aW9uID0gb3B0cy5kaXJlY3Rpb24gfHwgJ25leHQnXG4gICAgdmFyIHJhbmdlID0gb3B0cy5yYW5nZSB8fCB7fVxuXG4gICAgbG93ZXIgPSByYW5nZS5sb3dlclxuICAgIHVwcGVyID0gcmFuZ2UudXBwZXJcbiAgICBsb3dlck9wZW4gPSAhIXJhbmdlLmxvd2VyT3BlblxuICAgIHVwcGVyT3BlbiA9ICEhcmFuZ2UudXBwZXJPcGVuXG5cbiAgICAvLyBpZiB0aGlzIGlzIG5vdCB0aGUgZmlyc3QgaXRlcmF0aW9uLCB1c2UgbGFzdEl0ZXJhdGVkS2V5XG4gICAgaWYgKGxhc3RJdGVyYXRlZEtleSkge1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ25leHQnKSB7XG4gICAgICAgIGxvd2VyT3BlbiA9IHRydWUgLy8gZXhjbHVkZSB0aGUgbGFzdCBpdGVyYXRlZCBrZXkgaXRzZWxmXG4gICAgICAgIGxvd2VyID0gbGFzdEl0ZXJhdGVkS2V5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cHBlck9wZW4gPSB0cnVlIC8vIGV4Y2x1ZGUgdGhlIGxhc3QgaXRlcmF0ZWQga2V5IGl0c2VsZlxuICAgICAgICB1cHBlciA9IGxhc3RJdGVyYXRlZEtleVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlSYW5nZVxuICAgIGlmIChsb3dlciAmJiB1cHBlcilcbiAgICAgIGtleVJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQobG93ZXIsIHVwcGVyLCBsb3dlck9wZW4sIHVwcGVyT3BlbilcbiAgICBlbHNlIGlmIChsb3dlcilcbiAgICAgIGtleVJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChsb3dlciwgbG93ZXJPcGVuKVxuICAgIGVsc2UgaWYgKHVwcGVyKVxuICAgICAga2V5UmFuZ2UgPSBJREJLZXlSYW5nZS51cHBlckJvdW5kKHVwcGVyLCB1cHBlck9wZW4pXG5cbiAgICB2YXIgdHggPSBkYi50cmFuc2FjdGlvbihzdG9yZU5hbWUsICdyZWFkb25seScpXG4gICAgdmFyIHN0b3JlID0gdHgub2JqZWN0U3RvcmUoc3RvcmVOYW1lKVxuXG4gICAgdHJhbnNmb3JtZXIuX2N1cnNvcnNPcGVuZWQrK1xuICAgIHZhciByZXEgPSBzdG9yZS5vcGVuQ3Vyc29yKGtleVJhbmdlLCBvcHRzLmRpcmVjdGlvbilcblxuICAgIGZ1bmN0aW9uIHByb2NlZWQoY3Vyc29yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjdXJzb3IuY29udGludWUoKSAvLyB0aHJvd3MgYSBUcmFuc2FjdGlvbkluYWN0aXZlRXJyb3IgaWYgdGhlIGN1cnNvciB0aW1lZCBvdXRcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIC8vIGVpdGhlciByZW9wZW4gYSBjdXJzb3Igb3IgcHJvcGFnYXRlIHRoZSBlcnJvclxuICAgICAgICBpZiAoZXJyLm5hbWUgPT09ICdUcmFuc2FjdGlvbkluYWN0aXZlRXJyb3InICYmICFvcHRzLnNuYXBzaG90KVxuICAgICAgICAgIHN0YXJ0Q3Vyc29yKCkgLy8gSW5kZXhlZERCIHRpbWVkIG91dCB0aGUgY3Vyc29yXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0cmFuc2Zvcm1lci5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3Vyc29yID0gcmVxLnJlc3VsdFxuICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICBsYXN0SXRlcmF0ZWRLZXkgPSBjdXJzb3Iua2V5XG5cbiAgICAgICAgdmFyIGdvID0gdHJhbnNmb3JtZXIud3JpdGUoeyBrZXk6IGN1cnNvci5rZXksIHZhbHVlOiBjdXJzb3IudmFsdWUgfSlcbiAgICAgICAgaWYgKG9wdHMuc25hcHNob3QgfHwgZ28pXG4gICAgICAgICAgcHJvY2VlZChjdXJzb3IpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0cmFuc2Zvcm1lci5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcHJvY2VlZChjdXJzb3IpXG4gICAgICAgICAgfSlcbiAgICAgIH0gZWxzZVxuICAgICAgICB0cmFuc2Zvcm1lci5lbmQoKVxuICAgIH1cblxuICAgIHR4Lm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRyYW5zZm9ybWVyLmVtaXQoJ2Vycm9yJywgdHguZXJyb3IpXG4gICAgfVxuICAgIHR4Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRyYW5zZm9ybWVyLmVtaXQoJ2Vycm9yJywgdHguZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgc3RhcnRDdXJzb3IoKVxuXG4gIHJldHVybiB0cmFuc2Zvcm1lclxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkYlJlYWRhYmxlU3RyZWFtXG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTMgUm9kIFZhZ2csIE1JVCBMaWNlbnNlICovXG5cbmZ1bmN0aW9uIEFic3RyYWN0SXRlcmF0b3IgKGRiKSB7XG4gIHRoaXMuZGIgPSBkYlxuICB0aGlzLl9lbmRlZCA9IGZhbHNlXG4gIHRoaXMuX25leHRpbmcgPSBmYWxzZVxufVxuXG5BYnN0cmFjdEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25leHQoKSByZXF1aXJlcyBhIGNhbGxiYWNrIGFyZ3VtZW50JylcblxuICBpZiAoc2VsZi5fZW5kZWQpXG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignY2Fubm90IGNhbGwgbmV4dCgpIGFmdGVyIGVuZCgpJykpXG4gIGlmIChzZWxmLl9uZXh0aW5nKVxuICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ2Nhbm5vdCBjYWxsIG5leHQoKSBiZWZvcmUgcHJldmlvdXMgbmV4dCgpIGhhcyBjb21wbGV0ZWQnKSlcblxuICBzZWxmLl9uZXh0aW5nID0gdHJ1ZVxuICBpZiAodHlwZW9mIHNlbGYuX25leHQgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzZWxmLl9uZXh0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX25leHRpbmcgPSBmYWxzZVxuICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH0pXG4gIH1cblxuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9uZXh0aW5nID0gZmFsc2VcbiAgICBjYWxsYmFjaygpXG4gIH0pXG59XG5cbkFic3RyYWN0SXRlcmF0b3IucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmQoKSByZXF1aXJlcyBhIGNhbGxiYWNrIGFyZ3VtZW50JylcblxuICBpZiAodGhpcy5fZW5kZWQpXG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignZW5kKCkgYWxyZWFkeSBjYWxsZWQgb24gaXRlcmF0b3InKSlcblxuICB0aGlzLl9lbmRlZCA9IHRydWVcblxuICBpZiAodHlwZW9mIHRoaXMuX2VuZCA9PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB0aGlzLl9lbmQoY2FsbGJhY2spXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdEl0ZXJhdG9yXG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTMgUm9kIFZhZ2csIE1JVCBMaWNlbnNlICovXG5cbmZ1bmN0aW9uIEFic3RyYWN0Q2hhaW5lZEJhdGNoIChkYikge1xuICB0aGlzLl9kYiAgICAgICAgID0gZGJcbiAgdGhpcy5fb3BlcmF0aW9ucyA9IFtdXG4gIHRoaXMuX3dyaXR0ZW4gICAgPSBmYWxzZVxufVxuXG5BYnN0cmFjdENoYWluZWRCYXRjaC5wcm90b3R5cGUuX2NoZWNrV3JpdHRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX3dyaXR0ZW4pXG4gICAgdGhyb3cgbmV3IEVycm9yKCd3cml0ZSgpIGFscmVhZHkgY2FsbGVkIG9uIHRoaXMgYmF0Y2gnKVxufVxuXG5BYnN0cmFjdENoYWluZWRCYXRjaC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdGhpcy5fY2hlY2tXcml0dGVuKClcblxuICB2YXIgZXJyID0gdGhpcy5fZGIuX2NoZWNrS2V5KGtleSwgJ2tleScsIHRoaXMuX2RiLl9pc0J1ZmZlcilcbiAgaWYgKGVycilcbiAgICB0aHJvdyBlcnJcblxuICBpZiAoIXRoaXMuX2RiLl9pc0J1ZmZlcihrZXkpKSBrZXkgPSBTdHJpbmcoa2V5KVxuICBpZiAoIXRoaXMuX2RiLl9pc0J1ZmZlcih2YWx1ZSkpIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuXG4gIGlmICh0eXBlb2YgdGhpcy5fcHV0ID09ICdmdW5jdGlvbicgKVxuICAgIHRoaXMuX3B1dChrZXksIHZhbHVlKVxuICBlbHNlXG4gICAgdGhpcy5fb3BlcmF0aW9ucy5wdXNoKHsgdHlwZTogJ3B1dCcsIGtleToga2V5LCB2YWx1ZTogdmFsdWUgfSlcblxuICByZXR1cm4gdGhpc1xufVxuXG5BYnN0cmFjdENoYWluZWRCYXRjaC5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKGtleSkge1xuICB0aGlzLl9jaGVja1dyaXR0ZW4oKVxuXG4gIHZhciBlcnIgPSB0aGlzLl9kYi5fY2hlY2tLZXkoa2V5LCAna2V5JywgdGhpcy5fZGIuX2lzQnVmZmVyKVxuICBpZiAoZXJyKSB0aHJvdyBlcnJcblxuICBpZiAoIXRoaXMuX2RiLl9pc0J1ZmZlcihrZXkpKSBrZXkgPSBTdHJpbmcoa2V5KVxuXG4gIGlmICh0eXBlb2YgdGhpcy5fZGVsID09ICdmdW5jdGlvbicgKVxuICAgIHRoaXMuX2RlbChrZXkpXG4gIGVsc2VcbiAgICB0aGlzLl9vcGVyYXRpb25zLnB1c2goeyB0eXBlOiAnZGVsJywga2V5OiBrZXkgfSlcblxuICByZXR1cm4gdGhpc1xufVxuXG5BYnN0cmFjdENoYWluZWRCYXRjaC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2NoZWNrV3JpdHRlbigpXG5cbiAgdGhpcy5fb3BlcmF0aW9ucyA9IFtdXG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9jbGVhciA9PSAnZnVuY3Rpb24nIClcbiAgICB0aGlzLl9jbGVhcigpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQWJzdHJhY3RDaGFpbmVkQmF0Y2gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHRoaXMuX2NoZWNrV3JpdHRlbigpXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdmdW5jdGlvbicpXG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRlKCkgcmVxdWlyZXMgYSBjYWxsYmFjayBhcmd1bWVudCcpXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPSAnb2JqZWN0JylcbiAgICBvcHRpb25zID0ge31cblxuICB0aGlzLl93cml0dGVuID0gdHJ1ZVxuXG4gIGlmICh0eXBlb2YgdGhpcy5fd3JpdGUgPT0gJ2Z1bmN0aW9uJyApXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRlKGNhbGxiYWNrKVxuXG4gIGlmICh0eXBlb2YgdGhpcy5fZGIuX2JhdGNoID09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHRoaXMuX2RiLl9iYXRjaCh0aGlzLl9vcGVyYXRpb25zLCBvcHRpb25zLCBjYWxsYmFjaylcblxuICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0Q2hhaW5lZEJhdGNoIiwidmFyIEFic3RyYWN0TGV2ZWxET1dOID0gcmVxdWlyZSgnLi9hYnN0cmFjdC1sZXZlbGRvd24nKVxuXG5mdW5jdGlvbiBpc0xldmVsRE9XTiAoZGIpIHtcbiAgaWYgKCFkYiB8fCB0eXBlb2YgZGIgIT09ICdvYmplY3QnKVxuICAgIHJldHVybiBmYWxzZVxuICByZXR1cm4gT2JqZWN0LmtleXMoQWJzdHJhY3RMZXZlbERPV04ucHJvdG90eXBlKS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyBUT0RPIHJlbW92ZSBhcHByb3hpbWF0ZVNpemUgY2hlY2sgd2hlbiBtZXRob2QgaXMgZ29uZVxuICAgIHJldHVybiBuYW1lWzBdICE9ICdfJyAmJiBuYW1lICE9ICdhcHByb3hpbWF0ZVNpemUnXG4gIH0pLmV2ZXJ5KGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkYltuYW1lXSA9PSAnZnVuY3Rpb24nXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZXZlbERPV05cbiIsIi8qIENvcHlyaWdodCAoYykgMjAxMyBSb2QgVmFnZywgTUlUIExpY2Vuc2UgKi9cblxudmFyIHh0ZW5kICAgICAgICAgICAgICAgID0gcmVxdWlyZSgneHRlbmQnKVxuICAsIEFic3RyYWN0SXRlcmF0b3IgICAgID0gcmVxdWlyZSgnLi9hYnN0cmFjdC1pdGVyYXRvcicpXG4gICwgQWJzdHJhY3RDaGFpbmVkQmF0Y2ggPSByZXF1aXJlKCcuL2Fic3RyYWN0LWNoYWluZWQtYmF0Y2gnKVxuXG5mdW5jdGlvbiBBYnN0cmFjdExldmVsRE9XTiAobG9jYXRpb24pIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoIHx8IGxvY2F0aW9uID09PSB1bmRlZmluZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb25zdHJ1Y3RvciByZXF1aXJlcyBhdCBsZWFzdCBhIGxvY2F0aW9uIGFyZ3VtZW50JylcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uICE9ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBFcnJvcignY29uc3RydWN0b3IgcmVxdWlyZXMgYSBsb2NhdGlvbiBzdHJpbmcgYXJndW1lbnQnKVxuXG4gIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvblxuICB0aGlzLnN0YXR1cyA9ICduZXcnXG59XG5cbkFic3RyYWN0TGV2ZWxET1dOLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmICAgICAgPSB0aGlzXG4gICAgLCBvbGRTdGF0dXMgPSB0aGlzLnN0YXR1c1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnZnVuY3Rpb24nKVxuICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29wZW4oKSByZXF1aXJlcyBhIGNhbGxiYWNrIGFyZ3VtZW50JylcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHt9XG5cbiAgb3B0aW9ucy5jcmVhdGVJZk1pc3NpbmcgPSBvcHRpb25zLmNyZWF0ZUlmTWlzc2luZyAhPSBmYWxzZVxuICBvcHRpb25zLmVycm9ySWZFeGlzdHMgPSAhIW9wdGlvbnMuZXJyb3JJZkV4aXN0c1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fb3BlbiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5zdGF0dXMgPSAnb3BlbmluZydcbiAgICB0aGlzLl9vcGVuKG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgc2VsZi5zdGF0dXMgPSBvbGRTdGF0dXNcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICAgIHNlbGYuc3RhdHVzID0gJ29wZW4nXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YXR1cyA9ICdvcGVuJ1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spXG4gIH1cbn1cblxuQWJzdHJhY3RMZXZlbERPV04ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmICAgICAgPSB0aGlzXG4gICAgLCBvbGRTdGF0dXMgPSB0aGlzLnN0YXR1c1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsb3NlKCkgcmVxdWlyZXMgYSBjYWxsYmFjayBhcmd1bWVudCcpXG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9jbG9zZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5zdGF0dXMgPSAnY2xvc2luZydcbiAgICB0aGlzLl9jbG9zZShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHNlbGYuc3RhdHVzID0gb2xkU3RhdHVzXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICBzZWxmLnN0YXR1cyA9ICdjbG9zZWQnXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YXR1cyA9ICdjbG9zZWQnXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaylcbiAgfVxufVxuXG5BYnN0cmFjdExldmVsRE9XTi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGVyclxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnZnVuY3Rpb24nKVxuICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldCgpIHJlcXVpcmVzIGEgY2FsbGJhY2sgYXJndW1lbnQnKVxuXG4gIGlmIChlcnIgPSB0aGlzLl9jaGVja0tleShrZXksICdrZXknLCB0aGlzLl9pc0J1ZmZlcikpXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVycilcblxuICBpZiAoIXRoaXMuX2lzQnVmZmVyKGtleSkpXG4gICAga2V5ID0gU3RyaW5nKGtleSlcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHt9XG5cbiAgb3B0aW9ucy5hc0J1ZmZlciA9IG9wdGlvbnMuYXNCdWZmZXIgIT0gZmFsc2VcblxuICBpZiAodHlwZW9mIHRoaXMuX2dldCA9PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB0aGlzLl9nZXQoa2V5LCBvcHRpb25zLCBjYWxsYmFjaylcblxuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgY2FsbGJhY2sobmV3IEVycm9yKCdOb3RGb3VuZCcpKSB9KVxufVxuXG5BYnN0cmFjdExldmVsRE9XTi5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBlcnJcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJylcbiAgICBjYWxsYmFjayA9IG9wdGlvbnNcblxuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwdXQoKSByZXF1aXJlcyBhIGNhbGxiYWNrIGFyZ3VtZW50JylcblxuICBpZiAoZXJyID0gdGhpcy5fY2hlY2tLZXkoa2V5LCAna2V5JywgdGhpcy5faXNCdWZmZXIpKVxuICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG5cbiAgaWYgKCF0aGlzLl9pc0J1ZmZlcihrZXkpKVxuICAgIGtleSA9IFN0cmluZyhrZXkpXG5cbiAgLy8gY29lcmNlIHZhbHVlIHRvIHN0cmluZyBpbiBub2RlLCBkb24ndCB0b3VjaCBpdCBpbiBicm93c2VyXG4gIC8vIChpbmRleGVkZGIgY2FuIHN0b3JlIGFueSBKUyB0eXBlKVxuICBpZiAodmFsdWUgIT0gbnVsbCAmJiAhdGhpcy5faXNCdWZmZXIodmFsdWUpICYmICFwcm9jZXNzLmJyb3dzZXIpXG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9ICdvYmplY3QnKVxuICAgIG9wdGlvbnMgPSB7fVxuXG4gIGlmICh0eXBlb2YgdGhpcy5fcHV0ID09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHRoaXMuX3B1dChrZXksIHZhbHVlLCBvcHRpb25zLCBjYWxsYmFjaylcblxuICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKVxufVxuXG5BYnN0cmFjdExldmVsRE9XTi5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKGtleSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGVyclxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnZnVuY3Rpb24nKVxuICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlbCgpIHJlcXVpcmVzIGEgY2FsbGJhY2sgYXJndW1lbnQnKVxuXG4gIGlmIChlcnIgPSB0aGlzLl9jaGVja0tleShrZXksICdrZXknLCB0aGlzLl9pc0J1ZmZlcikpXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVycilcblxuICBpZiAoIXRoaXMuX2lzQnVmZmVyKGtleSkpXG4gICAga2V5ID0gU3RyaW5nKGtleSlcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHt9XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9kZWwgPT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdGhpcy5fZGVsKGtleSwgb3B0aW9ucywgY2FsbGJhY2spXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaylcbn1cblxuQWJzdHJhY3RMZXZlbERPV04ucHJvdG90eXBlLmJhdGNoID0gZnVuY3Rpb24gKGFycmF5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXMuX2NoYWluZWRCYXRjaCgpXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdmdW5jdGlvbicpXG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG5cbiAgaWYgKHR5cGVvZiBhcnJheSA9PSAnZnVuY3Rpb24nKVxuICAgIGNhbGxiYWNrID0gYXJyYXlcblxuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYXRjaChhcnJheSkgcmVxdWlyZXMgYSBjYWxsYmFjayBhcmd1bWVudCcpXG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSlcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdiYXRjaChhcnJheSkgcmVxdWlyZXMgYW4gYXJyYXkgYXJndW1lbnQnKSlcblxuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHt9XG5cbiAgdmFyIGkgPSAwXG4gICAgLCBsID0gYXJyYXkubGVuZ3RoXG4gICAgLCBlXG4gICAgLCBlcnJcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSBhcnJheVtpXVxuICAgIGlmICh0eXBlb2YgZSAhPSAnb2JqZWN0JylcbiAgICAgIGNvbnRpbnVlXG5cbiAgICBpZiAoZXJyID0gdGhpcy5fY2hlY2tLZXkoZS50eXBlLCAndHlwZScsIHRoaXMuX2lzQnVmZmVyKSlcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG5cbiAgICBpZiAoZXJyID0gdGhpcy5fY2hlY2tLZXkoZS5rZXksICdrZXknLCB0aGlzLl9pc0J1ZmZlcikpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9iYXRjaCA9PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB0aGlzLl9iYXRjaChhcnJheSwgb3B0aW9ucywgY2FsbGJhY2spXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaylcbn1cblxuLy9UT0RPOiByZW1vdmUgZnJvbSBoZXJlLCBub3QgYSBuZWNlc3NhcnkgcHJpbWl0aXZlXG5BYnN0cmFjdExldmVsRE9XTi5wcm90b3R5cGUuYXBwcm94aW1hdGVTaXplID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNhbGxiYWNrKSB7XG4gIGlmICggICBzdGFydCA9PSBudWxsXG4gICAgICB8fCBlbmQgPT0gbnVsbFxuICAgICAgfHwgdHlwZW9mIHN0YXJ0ID09ICdmdW5jdGlvbidcbiAgICAgIHx8IHR5cGVvZiBlbmQgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignYXBwcm94aW1hdGVTaXplKCkgcmVxdWlyZXMgdmFsaWQgYHN0YXJ0YCwgYGVuZGAgYW5kIGBjYWxsYmFja2AgYXJndW1lbnRzJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FwcHJveGltYXRlU2l6ZSgpIHJlcXVpcmVzIGEgY2FsbGJhY2sgYXJndW1lbnQnKVxuXG4gIGlmICghdGhpcy5faXNCdWZmZXIoc3RhcnQpKVxuICAgIHN0YXJ0ID0gU3RyaW5nKHN0YXJ0KVxuXG4gIGlmICghdGhpcy5faXNCdWZmZXIoZW5kKSlcbiAgICBlbmQgPSBTdHJpbmcoZW5kKVxuXG4gIGlmICh0eXBlb2YgdGhpcy5fYXBwcm94aW1hdGVTaXplID09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHRoaXMuX2FwcHJveGltYXRlU2l6ZShzdGFydCwgZW5kLCBjYWxsYmFjaylcblxuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhudWxsLCAwKVxuICB9KVxufVxuXG5BYnN0cmFjdExldmVsRE9XTi5wcm90b3R5cGUuX3NldHVwSXRlcmF0b3JPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgb3B0aW9ucyA9IHh0ZW5kKG9wdGlvbnMpXG5cbiAgO1sgJ3N0YXJ0JywgJ2VuZCcsICdndCcsICdndGUnLCAnbHQnLCAnbHRlJyBdLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAob3B0aW9uc1tvXSAmJiBzZWxmLl9pc0J1ZmZlcihvcHRpb25zW29dKSAmJiBvcHRpb25zW29dLmxlbmd0aCA9PT0gMClcbiAgICAgIGRlbGV0ZSBvcHRpb25zW29dXG4gIH0pXG5cbiAgb3B0aW9ucy5yZXZlcnNlID0gISFvcHRpb25zLnJldmVyc2VcbiAgb3B0aW9ucy5rZXlzID0gb3B0aW9ucy5rZXlzICE9IGZhbHNlXG4gIG9wdGlvbnMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXMgIT0gZmFsc2VcbiAgb3B0aW9ucy5saW1pdCA9ICdsaW1pdCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMubGltaXQgOiAtMVxuICBvcHRpb25zLmtleUFzQnVmZmVyID0gb3B0aW9ucy5rZXlBc0J1ZmZlciAhPSBmYWxzZVxuICBvcHRpb25zLnZhbHVlQXNCdWZmZXIgPSBvcHRpb25zLnZhbHVlQXNCdWZmZXIgIT0gZmFsc2VcblxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5BYnN0cmFjdExldmVsRE9XTi5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHt9XG5cbiAgb3B0aW9ucyA9IHRoaXMuX3NldHVwSXRlcmF0b3JPcHRpb25zKG9wdGlvbnMpXG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9pdGVyYXRvciA9PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB0aGlzLl9pdGVyYXRvcihvcHRpb25zKVxuXG4gIHJldHVybiBuZXcgQWJzdHJhY3RJdGVyYXRvcih0aGlzKVxufVxuXG5BYnN0cmFjdExldmVsRE9XTi5wcm90b3R5cGUuX2NoYWluZWRCYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBBYnN0cmFjdENoYWluZWRCYXRjaCh0aGlzKVxufVxuXG5BYnN0cmFjdExldmVsRE9XTi5wcm90b3R5cGUuX2lzQnVmZmVyID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iailcbn1cblxuQWJzdHJhY3RMZXZlbERPV04ucHJvdG90eXBlLl9jaGVja0tleSA9IGZ1bmN0aW9uIChvYmosIHR5cGUpIHtcblxuICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBuZXcgRXJyb3IodHlwZSArICcgY2Fubm90IGJlIGBudWxsYCBvciBgdW5kZWZpbmVkYCcpXG5cbiAgaWYgKHRoaXMuX2lzQnVmZmVyKG9iaikpIHtcbiAgICBpZiAob2JqLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBuZXcgRXJyb3IodHlwZSArICcgY2Fubm90IGJlIGFuIGVtcHR5IEJ1ZmZlcicpXG4gIH0gZWxzZSBpZiAoU3RyaW5nKG9iaikgPT09ICcnKVxuICAgIHJldHVybiBuZXcgRXJyb3IodHlwZSArICcgY2Fubm90IGJlIGFuIGVtcHR5IFN0cmluZycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RMZXZlbERPV05cbiIsInZhciBBYnN0cmFjdEl0ZXJhdG9yID0gcmVxdWlyZSgnYWJzdHJhY3QtbGV2ZWxkb3duJykuQWJzdHJhY3RJdGVyYXRvclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5mdW5jdGlvbiBEZWZlcnJlZEl0ZXJhdG9yIChvcHRpb25zKSB7XG4gIEFic3RyYWN0SXRlcmF0b3IuY2FsbCh0aGlzLCBvcHRpb25zKVxuXG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gIHRoaXMuX2l0ZXJhdG9yID0gbnVsbFxuICB0aGlzLl9vcGVyYXRpb25zID0gW11cbn1cblxuaW5oZXJpdHMoRGVmZXJyZWRJdGVyYXRvciwgQWJzdHJhY3RJdGVyYXRvcilcblxuRGVmZXJyZWRJdGVyYXRvci5wcm90b3R5cGUuc2V0RGIgPSBmdW5jdGlvbiAoZGIpIHtcbiAgdmFyIGl0ID0gdGhpcy5faXRlcmF0b3IgPSBkYi5pdGVyYXRvcih0aGlzLl9vcHRpb25zKVxuICB0aGlzLl9vcGVyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7XG4gICAgaXRbb3AubWV0aG9kXS5hcHBseShpdCwgb3AuYXJncylcbiAgfSlcbn1cblxuRGVmZXJyZWRJdGVyYXRvci5wcm90b3R5cGUuX29wZXJhdGlvbiA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZ3MpIHtcbiAgaWYgKHRoaXMuX2l0ZXJhdG9yKSByZXR1cm4gdGhpcy5faXRlcmF0b3JbbWV0aG9kXS5hcHBseSh0aGlzLl9pdGVyYXRvciwgYXJncylcbiAgdGhpcy5fb3BlcmF0aW9ucy5wdXNoKHsgbWV0aG9kOiBtZXRob2QsIGFyZ3M6IGFyZ3MgfSlcbn1cblxuJ25leHQgZW5kJy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgRGVmZXJyZWRJdGVyYXRvci5wcm90b3R5cGVbJ18nICsgbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fb3BlcmF0aW9uKG0sIGFyZ3VtZW50cylcbiAgfVxufSlcblxuLy8gTXVzdCBkZWZlciBzZWVrKCkgcmF0aGVyIHRoYW4gX3NlZWsoKSBiZWNhdXNlIGl0IHJlcXVpcmVzIGRiLl9zZXJpYWxpemVLZXkgdG8gYmUgYXZhaWxhYmxlXG5EZWZlcnJlZEl0ZXJhdG9yLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9vcGVyYXRpb24oJ3NlZWsnLCBhcmd1bWVudHMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGVmZXJyZWRJdGVyYXRvclxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbmV4cG9ydHMuZmluaXNoZWQgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMnKTtcbmV4cG9ydHMucGlwZWxpbmUgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEhlbHBlclxuZnVuY3Rpb24gcmV2ZXJzZShtYXApIHtcbiAgY29uc3QgcmVzID0ge307XG5cbiAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIC8vIENvbnZlcnQga2V5IHRvIGludGVnZXIgaWYgaXQgaXMgc3RyaW5naWZpZWRcbiAgICBpZiAoKGtleSB8IDApID09IGtleSlcbiAgICAgIGtleSA9IGtleSB8IDA7XG5cbiAgICBjb25zdCB2YWx1ZSA9IG1hcFtrZXldO1xuICAgIHJlc1t2YWx1ZV0gPSBrZXk7XG4gIH0pO1xuXG4gIHJldHVybiByZXM7XG59XG5cbmV4cG9ydHMudGFnQ2xhc3MgPSB7XG4gIDA6ICd1bml2ZXJzYWwnLFxuICAxOiAnYXBwbGljYXRpb24nLFxuICAyOiAnY29udGV4dCcsXG4gIDM6ICdwcml2YXRlJ1xufTtcbmV4cG9ydHMudGFnQ2xhc3NCeU5hbWUgPSByZXZlcnNlKGV4cG9ydHMudGFnQ2xhc3MpO1xuXG5leHBvcnRzLnRhZyA9IHtcbiAgMHgwMDogJ2VuZCcsXG4gIDB4MDE6ICdib29sJyxcbiAgMHgwMjogJ2ludCcsXG4gIDB4MDM6ICdiaXRzdHInLFxuICAweDA0OiAnb2N0c3RyJyxcbiAgMHgwNTogJ251bGxfJyxcbiAgMHgwNjogJ29iamlkJyxcbiAgMHgwNzogJ29iakRlc2MnLFxuICAweDA4OiAnZXh0ZXJuYWwnLFxuICAweDA5OiAncmVhbCcsXG4gIDB4MGE6ICdlbnVtJyxcbiAgMHgwYjogJ2VtYmVkJyxcbiAgMHgwYzogJ3V0ZjhzdHInLFxuICAweDBkOiAncmVsYXRpdmVPaWQnLFxuICAweDEwOiAnc2VxJyxcbiAgMHgxMTogJ3NldCcsXG4gIDB4MTI6ICdudW1zdHInLFxuICAweDEzOiAncHJpbnRzdHInLFxuICAweDE0OiAndDYxc3RyJyxcbiAgMHgxNTogJ3ZpZGVvc3RyJyxcbiAgMHgxNjogJ2lhNXN0cicsXG4gIDB4MTc6ICd1dGN0aW1lJyxcbiAgMHgxODogJ2dlbnRpbWUnLFxuICAweDE5OiAnZ3JhcGhzdHInLFxuICAweDFhOiAnaXNvNjQ2c3RyJyxcbiAgMHgxYjogJ2dlbnN0cicsXG4gIDB4MWM6ICd1bmlzdHInLFxuICAweDFkOiAnY2hhcnN0cicsXG4gIDB4MWU6ICdibXBzdHInXG59O1xuZXhwb3J0cy50YWdCeU5hbWUgPSByZXZlcnNlKGV4cG9ydHMudGFnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5mdW5jdGlvbiBSZXBvcnRlcihvcHRpb25zKSB7XG4gIHRoaXMuX3JlcG9ydGVyU3RhdGUgPSB7XG4gICAgb2JqOiBudWxsLFxuICAgIHBhdGg6IFtdLFxuICAgIG9wdGlvbnM6IG9wdGlvbnMgfHwge30sXG4gICAgZXJyb3JzOiBbXVxuICB9O1xufVxuZXhwb3J0cy5SZXBvcnRlciA9IFJlcG9ydGVyO1xuXG5SZXBvcnRlci5wcm90b3R5cGUuaXNFcnJvciA9IGZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBSZXBvcnRlckVycm9yO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgcmV0dXJuIHsgb2JqOiBzdGF0ZS5vYmosIHBhdGhMZW46IHN0YXRlLnBhdGgubGVuZ3RoIH07XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoZGF0YSkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgc3RhdGUub2JqID0gZGF0YS5vYmo7XG4gIHN0YXRlLnBhdGggPSBzdGF0ZS5wYXRoLnNsaWNlKDAsIGRhdGEucGF0aExlbik7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZW50ZXJLZXkgPSBmdW5jdGlvbiBlbnRlcktleShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX3JlcG9ydGVyU3RhdGUucGF0aC5wdXNoKGtleSk7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZXhpdEtleSA9IGZ1bmN0aW9uIGV4aXRLZXkoaW5kZXgpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHN0YXRlLnBhdGggPSBzdGF0ZS5wYXRoLnNsaWNlKDAsIGluZGV4IC0gMSk7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUubGVhdmVLZXkgPSBmdW5jdGlvbiBsZWF2ZUtleShpbmRleCwga2V5LCB2YWx1ZSkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdGhpcy5leGl0S2V5KGluZGV4KTtcbiAgaWYgKHN0YXRlLm9iaiAhPT0gbnVsbClcbiAgICBzdGF0ZS5vYmpba2V5XSA9IHZhbHVlO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiBwYXRoKCkge1xuICByZXR1cm4gdGhpcy5fcmVwb3J0ZXJTdGF0ZS5wYXRoLmpvaW4oJy8nKTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5lbnRlck9iamVjdCA9IGZ1bmN0aW9uIGVudGVyT2JqZWN0KCkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgY29uc3QgcHJldiA9IHN0YXRlLm9iajtcbiAgc3RhdGUub2JqID0ge307XG4gIHJldHVybiBwcmV2O1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmxlYXZlT2JqZWN0ID0gZnVuY3Rpb24gbGVhdmVPYmplY3QocHJldikge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgY29uc3Qgbm93ID0gc3RhdGUub2JqO1xuICBzdGF0ZS5vYmogPSBwcmV2O1xuICByZXR1cm4gbm93O1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIGxldCBlcnI7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICBjb25zdCBpbmhlcml0ZWQgPSBtc2cgaW5zdGFuY2VvZiBSZXBvcnRlckVycm9yO1xuICBpZiAoaW5oZXJpdGVkKSB7XG4gICAgZXJyID0gbXNnO1xuICB9IGVsc2Uge1xuICAgIGVyciA9IG5ldyBSZXBvcnRlckVycm9yKHN0YXRlLnBhdGgubWFwKGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHJldHVybiAnWycgKyBKU09OLnN0cmluZ2lmeShlbGVtKSArICddJztcbiAgICB9KS5qb2luKCcnKSwgbXNnLm1lc3NhZ2UgfHwgbXNnLCBtc2cuc3RhY2spO1xuICB9XG5cbiAgaWYgKCFzdGF0ZS5vcHRpb25zLnBhcnRpYWwpXG4gICAgdGhyb3cgZXJyO1xuXG4gIGlmICghaW5oZXJpdGVkKVxuICAgIHN0YXRlLmVycm9ycy5wdXNoKGVycik7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS53cmFwUmVzdWx0ID0gZnVuY3Rpb24gd3JhcFJlc3VsdChyZXN1bHQpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuICBpZiAoIXN0YXRlLm9wdGlvbnMucGFydGlhbClcbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gIHJldHVybiB7XG4gICAgcmVzdWx0OiB0aGlzLmlzRXJyb3IocmVzdWx0KSA/IG51bGwgOiByZXN1bHQsXG4gICAgZXJyb3JzOiBzdGF0ZS5lcnJvcnNcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFJlcG9ydGVyRXJyb3IocGF0aCwgbXNnKSB7XG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIHRoaXMucmV0aHJvdyhtc2cpO1xufVxuaW5oZXJpdHMoUmVwb3J0ZXJFcnJvciwgRXJyb3IpO1xuXG5SZXBvcnRlckVycm9yLnByb3RvdHlwZS5yZXRocm93ID0gZnVuY3Rpb24gcmV0aHJvdyhtc2cpIHtcbiAgdGhpcy5tZXNzYWdlID0gbXNnICsgJyBhdDogJyArICh0aGlzLnBhdGggfHwgJyhzaGFsbG93KScpO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVwb3J0ZXJFcnJvcik7XG5cbiAgaWYgKCF0aGlzLnN0YWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIElFIG9ubHkgYWRkcyBzdGFjayB3aGVuIHRocm93blxuICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMubWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5zdGFjayA9IGUuc3RhY2s7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuY29uc3QgUmVwb3J0ZXIgPSByZXF1aXJlKCcuLi9iYXNlL3JlcG9ydGVyJykuUmVwb3J0ZXI7XG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbmZ1bmN0aW9uIERlY29kZXJCdWZmZXIoYmFzZSwgb3B0aW9ucykge1xuICBSZXBvcnRlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiYXNlKSkge1xuICAgIHRoaXMuZXJyb3IoJ0lucHV0IG5vdCBCdWZmZXInKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmJhc2UgPSBiYXNlO1xuICB0aGlzLm9mZnNldCA9IDA7XG4gIHRoaXMubGVuZ3RoID0gYmFzZS5sZW5ndGg7XG59XG5pbmhlcml0cyhEZWNvZGVyQnVmZmVyLCBSZXBvcnRlcik7XG5leHBvcnRzLkRlY29kZXJCdWZmZXIgPSBEZWNvZGVyQnVmZmVyO1xuXG5EZWNvZGVyQnVmZmVyLmlzRGVjb2RlckJ1ZmZlciA9IGZ1bmN0aW9uIGlzRGVjb2RlckJ1ZmZlcihkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgRGVjb2RlckJ1ZmZlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gT3IgYWNjZXB0IGNvbXBhdGlibGUgQVBJXG4gIGNvbnN0IGlzQ29tcGF0aWJsZSA9IHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLmJhc2UpICYmXG4gICAgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnRGVjb2RlckJ1ZmZlcicgJiZcbiAgICB0eXBlb2YgZGF0YS5vZmZzZXQgPT09ICdudW1iZXInICYmXG4gICAgdHlwZW9mIGRhdGEubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiBkYXRhLnNhdmUgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgZGF0YS5yZXN0b3JlID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIGRhdGEuaXNFbXB0eSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBkYXRhLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBkYXRhLnNraXAgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgZGF0YS5yYXcgPT09ICdmdW5jdGlvbic7XG5cbiAgcmV0dXJuIGlzQ29tcGF0aWJsZTtcbn07XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xuICByZXR1cm4geyBvZmZzZXQ6IHRoaXMub2Zmc2V0LCByZXBvcnRlcjogUmVwb3J0ZXIucHJvdG90eXBlLnNhdmUuY2FsbCh0aGlzKSB9O1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoc2F2ZSkge1xuICAvLyBSZXR1cm4gc2tpcHBlZCBkYXRhXG4gIGNvbnN0IHJlcyA9IG5ldyBEZWNvZGVyQnVmZmVyKHRoaXMuYmFzZSk7XG4gIHJlcy5vZmZzZXQgPSBzYXZlLm9mZnNldDtcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0O1xuXG4gIHRoaXMub2Zmc2V0ID0gc2F2ZS5vZmZzZXQ7XG4gIFJlcG9ydGVyLnByb3RvdHlwZS5yZXN0b3JlLmNhbGwodGhpcywgc2F2ZS5yZXBvcnRlcik7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICByZXR1cm4gdGhpcy5vZmZzZXQgPT09IHRoaXMubGVuZ3RoO1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4KGZhaWwpIHtcbiAgaWYgKHRoaXMub2Zmc2V0ICsgMSA8PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5iYXNlLnJlYWRVSW50OCh0aGlzLm9mZnNldCsrLCB0cnVlKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmVycm9yKGZhaWwgfHwgJ0RlY29kZXJCdWZmZXIgb3ZlcnJ1bicpO1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAoYnl0ZXMsIGZhaWwpIHtcbiAgaWYgKCEodGhpcy5vZmZzZXQgKyBieXRlcyA8PSB0aGlzLmxlbmd0aCkpXG4gICAgcmV0dXJuIHRoaXMuZXJyb3IoZmFpbCB8fCAnRGVjb2RlckJ1ZmZlciBvdmVycnVuJyk7XG5cbiAgY29uc3QgcmVzID0gbmV3IERlY29kZXJCdWZmZXIodGhpcy5iYXNlKTtcblxuICAvLyBTaGFyZSByZXBvcnRlciBzdGF0ZVxuICByZXMuX3JlcG9ydGVyU3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHJlcy5vZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0ICsgYnl0ZXM7XG4gIHRoaXMub2Zmc2V0ICs9IGJ5dGVzO1xuICByZXR1cm4gcmVzO1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24gcmF3KHNhdmUpIHtcbiAgcmV0dXJuIHRoaXMuYmFzZS5zbGljZShzYXZlID8gc2F2ZS5vZmZzZXQgOiB0aGlzLm9mZnNldCwgdGhpcy5sZW5ndGgpO1xufTtcblxuZnVuY3Rpb24gRW5jb2RlckJ1ZmZlcih2YWx1ZSwgcmVwb3J0ZXIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgaWYgKCFFbmNvZGVyQnVmZmVyLmlzRW5jb2RlckJ1ZmZlcihpdGVtKSlcbiAgICAgICAgaXRlbSA9IG5ldyBFbmNvZGVyQnVmZmVyKGl0ZW0sIHJlcG9ydGVyKTtcbiAgICAgIHRoaXMubGVuZ3RoICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSwgdGhpcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGlmICghKDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMHhmZikpXG4gICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ25vbi1ieXRlIEVuY29kZXJCdWZmZXIgdmFsdWUnKTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGU6ICcgKyB0eXBlb2YgdmFsdWUpO1xuICB9XG59XG5leHBvcnRzLkVuY29kZXJCdWZmZXIgPSBFbmNvZGVyQnVmZmVyO1xuXG5FbmNvZGVyQnVmZmVyLmlzRW5jb2RlckJ1ZmZlciA9IGZ1bmN0aW9uIGlzRW5jb2RlckJ1ZmZlcihkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgRW5jb2RlckJ1ZmZlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gT3IgYWNjZXB0IGNvbXBhdGlibGUgQVBJXG4gIGNvbnN0IGlzQ29tcGF0aWJsZSA9IHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgIGRhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ0VuY29kZXJCdWZmZXInICYmXG4gICAgdHlwZW9mIGRhdGEubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiBkYXRhLmpvaW4gPT09ICdmdW5jdGlvbic7XG5cbiAgcmV0dXJuIGlzQ29tcGF0aWJsZTtcbn07XG5cbkVuY29kZXJCdWZmZXIucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKG91dCwgb2Zmc2V0KSB7XG4gIGlmICghb3V0KVxuICAgIG91dCA9IG5ldyBCdWZmZXIodGhpcy5sZW5ndGgpO1xuICBpZiAoIW9mZnNldClcbiAgICBvZmZzZXQgPSAwO1xuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gb3V0O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgdGhpcy52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGl0ZW0uam9pbihvdXQsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gaXRlbS5sZW5ndGg7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgIG91dFtvZmZzZXRdID0gdGhpcy52YWx1ZTtcbiAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICBvdXQud3JpdGUodGhpcy52YWx1ZSwgb2Zmc2V0KTtcbiAgICBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodGhpcy52YWx1ZSkpXG4gICAgICB0aGlzLnZhbHVlLmNvcHkob3V0LCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSZXBvcnRlciA9IHJlcXVpcmUoJy4uL2Jhc2UvcmVwb3J0ZXInKS5SZXBvcnRlcjtcbmNvbnN0IEVuY29kZXJCdWZmZXIgPSByZXF1aXJlKCcuLi9iYXNlL2J1ZmZlcicpLkVuY29kZXJCdWZmZXI7XG5jb25zdCBEZWNvZGVyQnVmZmVyID0gcmVxdWlyZSgnLi4vYmFzZS9idWZmZXInKS5EZWNvZGVyQnVmZmVyO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG4vLyBTdXBwb3J0ZWQgdGFnc1xuY29uc3QgdGFncyA9IFtcbiAgJ3NlcScsICdzZXFvZicsICdzZXQnLCAnc2V0b2YnLCAnb2JqaWQnLCAnYm9vbCcsXG4gICdnZW50aW1lJywgJ3V0Y3RpbWUnLCAnbnVsbF8nLCAnZW51bScsICdpbnQnLCAnb2JqRGVzYycsXG4gICdiaXRzdHInLCAnYm1wc3RyJywgJ2NoYXJzdHInLCAnZ2Vuc3RyJywgJ2dyYXBoc3RyJywgJ2lhNXN0cicsICdpc282NDZzdHInLFxuICAnbnVtc3RyJywgJ29jdHN0cicsICdwcmludHN0cicsICd0NjFzdHInLCAndW5pc3RyJywgJ3V0ZjhzdHInLCAndmlkZW9zdHInXG5dO1xuXG4vLyBQdWJsaWMgbWV0aG9kcyBsaXN0XG5jb25zdCBtZXRob2RzID0gW1xuICAna2V5JywgJ29iaicsICd1c2UnLCAnb3B0aW9uYWwnLCAnZXhwbGljaXQnLCAnaW1wbGljaXQnLCAnZGVmJywgJ2Nob2ljZScsXG4gICdhbnknLCAnY29udGFpbnMnXG5dLmNvbmNhdCh0YWdzKTtcblxuLy8gT3ZlcnJpZGVkIG1ldGhvZHMgbGlzdFxuY29uc3Qgb3ZlcnJpZGVkID0gW1xuICAnX3BlZWtUYWcnLCAnX2RlY29kZVRhZycsICdfdXNlJyxcbiAgJ19kZWNvZGVTdHInLCAnX2RlY29kZU9iamlkJywgJ19kZWNvZGVUaW1lJyxcbiAgJ19kZWNvZGVOdWxsJywgJ19kZWNvZGVJbnQnLCAnX2RlY29kZUJvb2wnLCAnX2RlY29kZUxpc3QnLFxuXG4gICdfZW5jb2RlQ29tcG9zaXRlJywgJ19lbmNvZGVTdHInLCAnX2VuY29kZU9iamlkJywgJ19lbmNvZGVUaW1lJyxcbiAgJ19lbmNvZGVOdWxsJywgJ19lbmNvZGVJbnQnLCAnX2VuY29kZUJvb2wnXG5dO1xuXG5mdW5jdGlvbiBOb2RlKGVuYywgcGFyZW50LCBuYW1lKSB7XG4gIGNvbnN0IHN0YXRlID0ge307XG4gIHRoaXMuX2Jhc2VTdGF0ZSA9IHN0YXRlO1xuXG4gIHN0YXRlLm5hbWUgPSBuYW1lO1xuICBzdGF0ZS5lbmMgPSBlbmM7XG5cbiAgc3RhdGUucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gIHN0YXRlLmNoaWxkcmVuID0gbnVsbDtcblxuICAvLyBTdGF0ZVxuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5hcmdzID0gbnVsbDtcbiAgc3RhdGUucmV2ZXJzZUFyZ3MgPSBudWxsO1xuICBzdGF0ZS5jaG9pY2UgPSBudWxsO1xuICBzdGF0ZS5vcHRpb25hbCA9IGZhbHNlO1xuICBzdGF0ZS5hbnkgPSBmYWxzZTtcbiAgc3RhdGUub2JqID0gZmFsc2U7XG4gIHN0YXRlLnVzZSA9IG51bGw7XG4gIHN0YXRlLnVzZURlY29kZXIgPSBudWxsO1xuICBzdGF0ZS5rZXkgPSBudWxsO1xuICBzdGF0ZVsnZGVmYXVsdCddID0gbnVsbDtcbiAgc3RhdGUuZXhwbGljaXQgPSBudWxsO1xuICBzdGF0ZS5pbXBsaWNpdCA9IG51bGw7XG4gIHN0YXRlLmNvbnRhaW5zID0gbnVsbDtcblxuICAvLyBTaG91bGQgY3JlYXRlIG5ldyBpbnN0YW5jZSBvbiBlYWNoIG1ldGhvZFxuICBpZiAoIXN0YXRlLnBhcmVudCkge1xuICAgIHN0YXRlLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5fd3JhcCgpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IE5vZGU7XG5cbmNvbnN0IHN0YXRlUHJvcHMgPSBbXG4gICdlbmMnLCAncGFyZW50JywgJ2NoaWxkcmVuJywgJ3RhZycsICdhcmdzJywgJ3JldmVyc2VBcmdzJywgJ2Nob2ljZScsXG4gICdvcHRpb25hbCcsICdhbnknLCAnb2JqJywgJ3VzZScsICdhbHRlcmVkVXNlJywgJ2tleScsICdkZWZhdWx0JywgJ2V4cGxpY2l0JyxcbiAgJ2ltcGxpY2l0JywgJ2NvbnRhaW5zJ1xuXTtcblxuTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIGNvbnN0IGNzdGF0ZSA9IHt9O1xuICBzdGF0ZVByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgIGNzdGF0ZVtwcm9wXSA9IHN0YXRlW3Byb3BdO1xuICB9KTtcbiAgY29uc3QgcmVzID0gbmV3IHRoaXMuY29uc3RydWN0b3IoY3N0YXRlLnBhcmVudCk7XG4gIHJlcy5fYmFzZVN0YXRlID0gY3N0YXRlO1xuICByZXR1cm4gcmVzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX3dyYXAgPSBmdW5jdGlvbiB3cmFwKCkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIHRoaXNbbWV0aG9kXSA9IGZ1bmN0aW9uIF93cmFwcGVkTWV0aG9kKCkge1xuICAgICAgY29uc3QgY2xvbmUgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgIHN0YXRlLmNoaWxkcmVuLnB1c2goY2xvbmUpO1xuICAgICAgcmV0dXJuIGNsb25lW21ldGhvZF0uYXBwbHkoY2xvbmUsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSwgdGhpcyk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoYm9keSkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUucGFyZW50ID09PSBudWxsKTtcbiAgYm9keS5jYWxsKHRoaXMpO1xuXG4gIC8vIEZpbHRlciBjaGlsZHJlblxuICBzdGF0ZS5jaGlsZHJlbiA9IHN0YXRlLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZC5fYmFzZVN0YXRlLnBhcmVudCA9PT0gdGhpcztcbiAgfSwgdGhpcyk7XG4gIGFzc2VydC5lcXVhbChzdGF0ZS5jaGlsZHJlbi5sZW5ndGgsIDEsICdSb290IG5vZGUgY2FuIGhhdmUgb25seSBvbmUgY2hpbGQnKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl91c2VBcmdzID0gZnVuY3Rpb24gdXNlQXJncyhhcmdzKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIEZpbHRlciBjaGlsZHJlbiBhbmQgYXJnc1xuICBjb25zdCBjaGlsZHJlbiA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yO1xuICB9LCB0aGlzKTtcbiAgYXJncyA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiAhKGFyZyBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpO1xuICB9LCB0aGlzKTtcblxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNzZXJ0KHN0YXRlLmNoaWxkcmVuID09PSBudWxsKTtcbiAgICBzdGF0ZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgLy8gUmVwbGFjZSBwYXJlbnQgdG8gbWFpbnRhaW4gYmFja3dhcmQgbGlua1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGNoaWxkLl9iYXNlU3RhdGUucGFyZW50ID0gdGhpcztcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBpZiAoYXJncy5sZW5ndGggIT09IDApIHtcbiAgICBhc3NlcnQoc3RhdGUuYXJncyA9PT0gbnVsbCk7XG4gICAgc3RhdGUuYXJncyA9IGFyZ3M7XG4gICAgc3RhdGUucmV2ZXJzZUFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnb2JqZWN0JyB8fCBhcmcuY29uc3RydWN0b3IgIT09IE9iamVjdClcbiAgICAgICAgcmV0dXJuIGFyZztcblxuICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICBPYmplY3Qua2V5cyhhcmcpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT0gKGtleSB8IDApKVxuICAgICAgICAgIGtleSB8PSAwO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZ1trZXldO1xuICAgICAgICByZXNbdmFsdWVdID0ga2V5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICB9XG59O1xuXG4vL1xuLy8gT3ZlcnJpZGVkIG1ldGhvZHNcbi8vXG5cbm92ZXJyaWRlZC5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBOb2RlLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gX292ZXJyaWRlZCgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJyBub3QgaW1wbGVtZW50ZWQgZm9yIGVuY29kaW5nOiAnICsgc3RhdGUuZW5jKTtcbiAgfTtcbn0pO1xuXG4vL1xuLy8gUHVibGljIG1ldGhvZHNcbi8vXG5cbnRhZ3MuZm9yRWFjaChmdW5jdGlvbih0YWcpIHtcbiAgTm9kZS5wcm90b3R5cGVbdGFnXSA9IGZ1bmN0aW9uIF90YWdNZXRob2QoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhc3NlcnQoc3RhdGUudGFnID09PSBudWxsKTtcbiAgICBzdGF0ZS50YWcgPSB0YWc7XG5cbiAgICB0aGlzLl91c2VBcmdzKGFyZ3MpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcblxuTm9kZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGl0ZW0pIHtcbiAgYXNzZXJ0KGl0ZW0pO1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUudXNlID09PSBudWxsKTtcbiAgc3RhdGUudXNlID0gaXRlbTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLm9wdGlvbmFsID0gZnVuY3Rpb24gb3B0aW9uYWwoKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIHN0YXRlLm9wdGlvbmFsID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmRlZiA9IGZ1bmN0aW9uIGRlZih2YWwpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlWydkZWZhdWx0J10gPT09IG51bGwpO1xuICBzdGF0ZVsnZGVmYXVsdCddID0gdmFsO1xuICBzdGF0ZS5vcHRpb25hbCA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5leHBsaWNpdCA9IGZ1bmN0aW9uIGV4cGxpY2l0KG51bSkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUuZXhwbGljaXQgPT09IG51bGwgJiYgc3RhdGUuaW1wbGljaXQgPT09IG51bGwpO1xuICBzdGF0ZS5leHBsaWNpdCA9IG51bTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmltcGxpY2l0ID0gZnVuY3Rpb24gaW1wbGljaXQobnVtKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5leHBsaWNpdCA9PT0gbnVsbCAmJiBzdGF0ZS5pbXBsaWNpdCA9PT0gbnVsbCk7XG4gIHN0YXRlLmltcGxpY2l0ID0gbnVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUub2JqID0gZnVuY3Rpb24gb2JqKCkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgc3RhdGUub2JqID0gdHJ1ZTtcblxuICBpZiAoYXJncy5sZW5ndGggIT09IDApXG4gICAgdGhpcy5fdXNlQXJncyhhcmdzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uIGtleShuZXdLZXkpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmtleSA9PT0gbnVsbCk7XG4gIHN0YXRlLmtleSA9IG5ld0tleTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uIGFueSgpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgc3RhdGUuYW55ID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmNob2ljZSA9IGZ1bmN0aW9uIGNob2ljZShvYmopIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmNob2ljZSA9PT0gbnVsbCk7XG4gIHN0YXRlLmNob2ljZSA9IG9iajtcbiAgdGhpcy5fdXNlQXJncyhPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH0pKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMoaXRlbSkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUudXNlID09PSBudWxsKTtcbiAgc3RhdGUuY29udGFpbnMgPSBpdGVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIERlY29kaW5nXG4vL1xuXG5Ob2RlLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIERlY29kZSByb290IG5vZGVcbiAgaWYgKHN0YXRlLnBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gaW5wdXQud3JhcFJlc3VsdChzdGF0ZS5jaGlsZHJlblswXS5fZGVjb2RlKGlucHV0LCBvcHRpb25zKSk7XG5cbiAgbGV0IHJlc3VsdCA9IHN0YXRlWydkZWZhdWx0J107XG4gIGxldCBwcmVzZW50ID0gdHJ1ZTtcblxuICBsZXQgcHJldktleSA9IG51bGw7XG4gIGlmIChzdGF0ZS5rZXkgIT09IG51bGwpXG4gICAgcHJldktleSA9IGlucHV0LmVudGVyS2V5KHN0YXRlLmtleSk7XG5cbiAgLy8gQ2hlY2sgaWYgdGFnIGlzIHRoZXJlXG4gIGlmIChzdGF0ZS5vcHRpb25hbCkge1xuICAgIGxldCB0YWcgPSBudWxsO1xuICAgIGlmIChzdGF0ZS5leHBsaWNpdCAhPT0gbnVsbClcbiAgICAgIHRhZyA9IHN0YXRlLmV4cGxpY2l0O1xuICAgIGVsc2UgaWYgKHN0YXRlLmltcGxpY2l0ICE9PSBudWxsKVxuICAgICAgdGFnID0gc3RhdGUuaW1wbGljaXQ7XG4gICAgZWxzZSBpZiAoc3RhdGUudGFnICE9PSBudWxsKVxuICAgICAgdGFnID0gc3RhdGUudGFnO1xuXG4gICAgaWYgKHRhZyA9PT0gbnVsbCAmJiAhc3RhdGUuYW55KSB7XG4gICAgICAvLyBUcmlhbCBhbmQgRXJyb3JcbiAgICAgIGNvbnN0IHNhdmUgPSBpbnB1dC5zYXZlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc3RhdGUuY2hvaWNlID09PSBudWxsKVxuICAgICAgICAgIHRoaXMuX2RlY29kZUdlbmVyaWMoc3RhdGUudGFnLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLl9kZWNvZGVDaG9pY2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICBwcmVzZW50ID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJlc2VudCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaW5wdXQucmVzdG9yZShzYXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlc2VudCA9IHRoaXMuX3BlZWtUYWcoaW5wdXQsIHRhZywgc3RhdGUuYW55KTtcblxuICAgICAgaWYgKGlucHV0LmlzRXJyb3IocHJlc2VudCkpXG4gICAgICAgIHJldHVybiBwcmVzZW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1c2ggb2JqZWN0IG9uIHN0YWNrXG4gIGxldCBwcmV2T2JqO1xuICBpZiAoc3RhdGUub2JqICYmIHByZXNlbnQpXG4gICAgcHJldk9iaiA9IGlucHV0LmVudGVyT2JqZWN0KCk7XG5cbiAgaWYgKHByZXNlbnQpIHtcbiAgICAvLyBVbndyYXAgZXhwbGljaXQgdmFsdWVzXG4gICAgaWYgKHN0YXRlLmV4cGxpY2l0ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBleHBsaWNpdCA9IHRoaXMuX2RlY29kZVRhZyhpbnB1dCwgc3RhdGUuZXhwbGljaXQpO1xuICAgICAgaWYgKGlucHV0LmlzRXJyb3IoZXhwbGljaXQpKVxuICAgICAgICByZXR1cm4gZXhwbGljaXQ7XG4gICAgICBpbnB1dCA9IGV4cGxpY2l0O1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ID0gaW5wdXQub2Zmc2V0O1xuXG4gICAgLy8gVW53cmFwIGltcGxpY2l0IGFuZCBub3JtYWwgdmFsdWVzXG4gICAgaWYgKHN0YXRlLnVzZSA9PT0gbnVsbCAmJiBzdGF0ZS5jaG9pY2UgPT09IG51bGwpIHtcbiAgICAgIGxldCBzYXZlO1xuICAgICAgaWYgKHN0YXRlLmFueSlcbiAgICAgICAgc2F2ZSA9IGlucHV0LnNhdmUoKTtcbiAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLl9kZWNvZGVUYWcoXG4gICAgICAgIGlucHV0LFxuICAgICAgICBzdGF0ZS5pbXBsaWNpdCAhPT0gbnVsbCA/IHN0YXRlLmltcGxpY2l0IDogc3RhdGUudGFnLFxuICAgICAgICBzdGF0ZS5hbnlcbiAgICAgICk7XG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcihib2R5KSlcbiAgICAgICAgcmV0dXJuIGJvZHk7XG5cbiAgICAgIGlmIChzdGF0ZS5hbnkpXG4gICAgICAgIHJlc3VsdCA9IGlucHV0LnJhdyhzYXZlKTtcbiAgICAgIGVsc2VcbiAgICAgICAgaW5wdXQgPSBib2R5O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHJhY2sgJiYgc3RhdGUudGFnICE9PSBudWxsKVxuICAgICAgb3B0aW9ucy50cmFjayhpbnB1dC5wYXRoKCksIHN0YXJ0LCBpbnB1dC5sZW5ndGgsICd0YWdnZWQnKTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHJhY2sgJiYgc3RhdGUudGFnICE9PSBudWxsKVxuICAgICAgb3B0aW9ucy50cmFjayhpbnB1dC5wYXRoKCksIGlucHV0Lm9mZnNldCwgaW5wdXQubGVuZ3RoLCAnY29udGVudCcpO1xuXG4gICAgLy8gU2VsZWN0IHByb3BlciBtZXRob2QgZm9yIHRhZ1xuICAgIGlmIChzdGF0ZS5hbnkpIHtcbiAgICAgIC8vIG5vLW9wXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5jaG9pY2UgPT09IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZUdlbmVyaWMoc3RhdGUudGFnLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZUNob2ljZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0LmlzRXJyb3IocmVzdWx0KSlcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAvLyBEZWNvZGUgY2hpbGRyZW5cbiAgICBpZiAoIXN0YXRlLmFueSAmJiBzdGF0ZS5jaG9pY2UgPT09IG51bGwgJiYgc3RhdGUuY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIHN0YXRlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gZGVjb2RlQ2hpbGRyZW4oY2hpbGQpIHtcbiAgICAgICAgLy8gTk9URTogV2UgYXJlIGlnbm9yaW5nIGVycm9ycyBoZXJlLCB0byBsZXQgcGFyc2VyIGNvbnRpbnVlIHdpdGggb3RoZXJcbiAgICAgICAgLy8gcGFydHMgb2YgZW5jb2RlZCBkYXRhXG4gICAgICAgIGNoaWxkLl9kZWNvZGUoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGVjb2RlIGNvbnRhaW5lZC9lbmNvZGVkIGJ5IHNjaGVtYSwgb25seSBpbiBiaXQgb3Igb2N0ZXQgc3RyaW5nc1xuICAgIGlmIChzdGF0ZS5jb250YWlucyAmJiAoc3RhdGUudGFnID09PSAnb2N0c3RyJyB8fCBzdGF0ZS50YWcgPT09ICdiaXRzdHInKSkge1xuICAgICAgY29uc3QgZGF0YSA9IG5ldyBEZWNvZGVyQnVmZmVyKHJlc3VsdCk7XG4gICAgICByZXN1bHQgPSB0aGlzLl9nZXRVc2Uoc3RhdGUuY29udGFpbnMsIGlucHV0Ll9yZXBvcnRlclN0YXRlLm9iailcbiAgICAgICAgLl9kZWNvZGUoZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLy8gUG9wIG9iamVjdFxuICBpZiAoc3RhdGUub2JqICYmIHByZXNlbnQpXG4gICAgcmVzdWx0ID0gaW5wdXQubGVhdmVPYmplY3QocHJldk9iaik7XG5cbiAgLy8gU2V0IGtleVxuICBpZiAoc3RhdGUua2V5ICE9PSBudWxsICYmIChyZXN1bHQgIT09IG51bGwgfHwgcHJlc2VudCA9PT0gdHJ1ZSkpXG4gICAgaW5wdXQubGVhdmVLZXkocHJldktleSwgc3RhdGUua2V5LCByZXN1bHQpO1xuICBlbHNlIGlmIChwcmV2S2V5ICE9PSBudWxsKVxuICAgIGlucHV0LmV4aXRLZXkocHJldktleSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9kZWNvZGVHZW5lcmljID0gZnVuY3Rpb24gZGVjb2RlR2VuZXJpYyh0YWcsIGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGlmICh0YWcgPT09ICdzZXEnIHx8IHRhZyA9PT0gJ3NldCcpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICh0YWcgPT09ICdzZXFvZicgfHwgdGFnID09PSAnc2V0b2YnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVMaXN0KGlucHV0LCB0YWcsIHN0YXRlLmFyZ3NbMF0sIG9wdGlvbnMpO1xuICBlbHNlIGlmICgvc3RyJC8udGVzdCh0YWcpKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVTdHIoaW5wdXQsIHRhZywgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJyAmJiBzdGF0ZS5hcmdzKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVPYmppZChpbnB1dCwgc3RhdGUuYXJnc1swXSwgc3RhdGUuYXJnc1sxXSwgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlT2JqaWQoaW5wdXQsIG51bGwsIG51bGwsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdnZW50aW1lJyB8fCB0YWcgPT09ICd1dGN0aW1lJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlVGltZShpbnB1dCwgdGFnLCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnbnVsbF8nKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVOdWxsKGlucHV0LCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnYm9vbCcpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUJvb2woaW5wdXQsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlU3RyKGlucHV0LCB0YWcsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdpbnQnIHx8IHRhZyA9PT0gJ2VudW0nKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVJbnQoaW5wdXQsIHN0YXRlLmFyZ3MgJiYgc3RhdGUuYXJnc1swXSwgb3B0aW9ucyk7XG5cbiAgaWYgKHN0YXRlLnVzZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVc2Uoc3RhdGUudXNlLCBpbnB1dC5fcmVwb3J0ZXJTdGF0ZS5vYmopXG4gICAgICAuX2RlY29kZShpbnB1dCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlucHV0LmVycm9yKCd1bmtub3duIHRhZzogJyArIHRhZyk7XG4gIH1cbn07XG5cbk5vZGUucHJvdG90eXBlLl9nZXRVc2UgPSBmdW5jdGlvbiBfZ2V0VXNlKGVudGl0eSwgb2JqKSB7XG5cbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIC8vIENyZWF0ZSBhbHRlcmVkIHVzZSBkZWNvZGVyIGlmIGltcGxpY2l0IGlzIHNldFxuICBzdGF0ZS51c2VEZWNvZGVyID0gdGhpcy5fdXNlKGVudGl0eSwgb2JqKTtcbiAgYXNzZXJ0KHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5wYXJlbnQgPT09IG51bGwpO1xuICBzdGF0ZS51c2VEZWNvZGVyID0gc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmNoaWxkcmVuWzBdO1xuICBpZiAoc3RhdGUuaW1wbGljaXQgIT09IHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5pbXBsaWNpdCkge1xuICAgIHN0YXRlLnVzZURlY29kZXIgPSBzdGF0ZS51c2VEZWNvZGVyLmNsb25lKCk7XG4gICAgc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmltcGxpY2l0ID0gc3RhdGUuaW1wbGljaXQ7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnVzZURlY29kZXI7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZGVjb2RlQ2hvaWNlID0gZnVuY3Rpb24gZGVjb2RlQ2hvaWNlKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgbGV0IG1hdGNoID0gZmFsc2U7XG5cbiAgT2JqZWN0LmtleXMoc3RhdGUuY2hvaWNlKS5zb21lKGZ1bmN0aW9uKGtleSkge1xuICAgIGNvbnN0IHNhdmUgPSBpbnB1dC5zYXZlKCk7XG4gICAgY29uc3Qgbm9kZSA9IHN0YXRlLmNob2ljZVtrZXldO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG5vZGUuX2RlY29kZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcih2YWx1ZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgcmVzdWx0ID0geyB0eXBlOiBrZXksIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgbWF0Y2ggPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlucHV0LnJlc3RvcmUoc2F2ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCB0aGlzKTtcblxuICBpZiAoIW1hdGNoKVxuICAgIHJldHVybiBpbnB1dC5lcnJvcignQ2hvaWNlIG5vdCBtYXRjaGVkJyk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vXG4vLyBFbmNvZGluZ1xuLy9cblxuTm9kZS5wcm90b3R5cGUuX2NyZWF0ZUVuY29kZXJCdWZmZXIgPSBmdW5jdGlvbiBjcmVhdGVFbmNvZGVyQnVmZmVyKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBFbmNvZGVyQnVmZmVyKGRhdGEsIHRoaXMucmVwb3J0ZXIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlciwgcGFyZW50KSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSAhPT0gbnVsbCAmJiBzdGF0ZVsnZGVmYXVsdCddID09PSBkYXRhKVxuICAgIHJldHVybjtcblxuICBjb25zdCByZXN1bHQgPSB0aGlzLl9lbmNvZGVWYWx1ZShkYXRhLCByZXBvcnRlciwgcGFyZW50KTtcbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybjtcblxuICBpZiAodGhpcy5fc2tpcERlZmF1bHQocmVzdWx0LCByZXBvcnRlciwgcGFyZW50KSlcbiAgICByZXR1cm47XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVWYWx1ZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlciwgcGFyZW50KSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIERlY29kZSByb290IG5vZGVcbiAgaWYgKHN0YXRlLnBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gc3RhdGUuY2hpbGRyZW5bMF0uX2VuY29kZShkYXRhLCByZXBvcnRlciB8fCBuZXcgUmVwb3J0ZXIoKSk7XG5cbiAgbGV0IHJlc3VsdCA9IG51bGw7XG5cbiAgLy8gU2V0IHJlcG9ydGVyIHRvIHNoYXJlIGl0IHdpdGggYSBjaGlsZCBjbGFzc1xuICB0aGlzLnJlcG9ydGVyID0gcmVwb3J0ZXI7XG5cbiAgLy8gQ2hlY2sgaWYgZGF0YSBpcyB0aGVyZVxuICBpZiAoc3RhdGUub3B0aW9uYWwgJiYgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHN0YXRlWydkZWZhdWx0J10gIT09IG51bGwpXG4gICAgICBkYXRhID0gc3RhdGVbJ2RlZmF1bHQnXTtcbiAgICBlbHNlXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbmNvZGUgY2hpbGRyZW4gZmlyc3RcbiAgbGV0IGNvbnRlbnQgPSBudWxsO1xuICBsZXQgcHJpbWl0aXZlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5hbnkpIHtcbiAgICAvLyBBbnl0aGluZyB0aGF0IHdhcyBnaXZlbiBpcyB0cmFuc2xhdGVkIHRvIGJ1ZmZlclxuICAgIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuY2hvaWNlKSB7XG4gICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ2hvaWNlKGRhdGEsIHJlcG9ydGVyKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5jb250YWlucykge1xuICAgIGNvbnRlbnQgPSB0aGlzLl9nZXRVc2Uoc3RhdGUuY29udGFpbnMsIHBhcmVudCkuX2VuY29kZShkYXRhLCByZXBvcnRlcik7XG4gICAgcHJpbWl0aXZlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5jaGlsZHJlbikge1xuICAgIGNvbnRlbnQgPSBzdGF0ZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fYmFzZVN0YXRlLnRhZyA9PT0gJ251bGxfJylcbiAgICAgICAgcmV0dXJuIGNoaWxkLl9lbmNvZGUobnVsbCwgcmVwb3J0ZXIsIGRhdGEpO1xuXG4gICAgICBpZiAoY2hpbGQuX2Jhc2VTdGF0ZS5rZXkgPT09IG51bGwpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignQ2hpbGQgc2hvdWxkIGhhdmUgYSBrZXknKTtcbiAgICAgIGNvbnN0IHByZXZLZXkgPSByZXBvcnRlci5lbnRlcktleShjaGlsZC5fYmFzZVN0YXRlLmtleSk7XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignQ2hpbGQgZXhwZWN0ZWQsIGJ1dCBpbnB1dCBpcyBub3Qgb2JqZWN0Jyk7XG5cbiAgICAgIGNvbnN0IHJlcyA9IGNoaWxkLl9lbmNvZGUoZGF0YVtjaGlsZC5fYmFzZVN0YXRlLmtleV0sIHJlcG9ydGVyLCBkYXRhKTtcbiAgICAgIHJlcG9ydGVyLmxlYXZlS2V5KHByZXZLZXkpO1xuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sIHRoaXMpLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0pO1xuICAgIGNvbnRlbnQgPSB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKGNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGlmIChzdGF0ZS50YWcgPT09ICdzZXFvZicgfHwgc3RhdGUudGFnID09PSAnc2V0b2YnKSB7XG4gICAgICAvLyBUT0RPKGluZHV0bnkpOiB0aGlzIHNob3VsZCBiZSB0aHJvd24gb24gRFNMIGxldmVsXG4gICAgICBpZiAoIShzdGF0ZS5hcmdzICYmIHN0YXRlLmFyZ3MubGVuZ3RoID09PSAxKSlcbiAgICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdUb28gbWFueSBhcmdzIGZvciA6ICcgKyBzdGF0ZS50YWcpO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignc2Vxb2Yvc2V0b2YsIGJ1dCBkYXRhIGlzIG5vdCBBcnJheScpO1xuXG4gICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGNoaWxkLl9iYXNlU3RhdGUuaW1wbGljaXQgPSBudWxsO1xuICAgICAgY29udGVudCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VXNlKHN0YXRlLmFyZ3NbMF0sIGRhdGEpLl9lbmNvZGUoaXRlbSwgcmVwb3J0ZXIpO1xuICAgICAgfSwgY2hpbGQpKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLnVzZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0VXNlKHN0YXRlLnVzZSwgcGFyZW50KS5fZW5jb2RlKGRhdGEsIHJlcG9ydGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IHRoaXMuX2VuY29kZVByaW1pdGl2ZShzdGF0ZS50YWcsIGRhdGEpO1xuICAgICAgcHJpbWl0aXZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBFbmNvZGUgZGF0YSBpdHNlbGZcbiAgaWYgKCFzdGF0ZS5hbnkgJiYgc3RhdGUuY2hvaWNlID09PSBudWxsKSB7XG4gICAgY29uc3QgdGFnID0gc3RhdGUuaW1wbGljaXQgIT09IG51bGwgPyBzdGF0ZS5pbXBsaWNpdCA6IHN0YXRlLnRhZztcbiAgICBjb25zdCBjbHMgPSBzdGF0ZS5pbXBsaWNpdCA9PT0gbnVsbCA/ICd1bml2ZXJzYWwnIDogJ2NvbnRleHQnO1xuXG4gICAgaWYgKHRhZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlLnVzZSA9PT0gbnVsbClcbiAgICAgICAgcmVwb3J0ZXIuZXJyb3IoJ1RhZyBjb3VsZCBiZSBvbWl0dGVkIG9ubHkgZm9yIC51c2UoKScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUudXNlID09PSBudWxsKVxuICAgICAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVDb21wb3NpdGUodGFnLCBwcmltaXRpdmUsIGNscywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gV3JhcCBpbiBleHBsaWNpdFxuICBpZiAoc3RhdGUuZXhwbGljaXQgIT09IG51bGwpXG4gICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ29tcG9zaXRlKHN0YXRlLmV4cGxpY2l0LCBmYWxzZSwgJ2NvbnRleHQnLCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZW5jb2RlQ2hvaWNlID0gZnVuY3Rpb24gZW5jb2RlQ2hvaWNlKGRhdGEsIHJlcG9ydGVyKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGNvbnN0IG5vZGUgPSBzdGF0ZS5jaG9pY2VbZGF0YS50eXBlXTtcbiAgaWYgKCFub2RlKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgZmFsc2UsXG4gICAgICBkYXRhLnR5cGUgKyAnIG5vdCBmb3VuZCBpbiAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHN0YXRlLmNob2ljZSkpKTtcbiAgfVxuICByZXR1cm4gbm9kZS5fZW5jb2RlKGRhdGEudmFsdWUsIHJlcG9ydGVyKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVQcmltaXRpdmUgPSBmdW5jdGlvbiBlbmNvZGVQcmltaXRpdmUodGFnLCBkYXRhKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGlmICgvc3RyJC8udGVzdCh0YWcpKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoZGF0YSwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnICYmIHN0YXRlLmFyZ3MpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZU9iamlkKGRhdGEsIHN0YXRlLnJldmVyc2VBcmdzWzBdLCBzdGF0ZS5hcmdzWzFdKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVPYmppZChkYXRhLCBudWxsLCBudWxsKTtcbiAgZWxzZSBpZiAodGFnID09PSAnZ2VudGltZScgfHwgdGFnID09PSAndXRjdGltZScpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZVRpbWUoZGF0YSwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnbnVsbF8nKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVOdWxsKCk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2ludCcgfHwgdGFnID09PSAnZW51bScpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZUludChkYXRhLCBzdGF0ZS5hcmdzICYmIHN0YXRlLnJldmVyc2VBcmdzWzBdKTtcbiAgZWxzZSBpZiAodGFnID09PSAnYm9vbCcpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZUJvb2woZGF0YSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iakRlc2MnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoZGF0YSwgdGFnKTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdGFnOiAnICsgdGFnKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9pc051bXN0ciA9IGZ1bmN0aW9uIGlzTnVtc3RyKHN0cikge1xuICByZXR1cm4gL15bMC05IF0qJC8udGVzdChzdHIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2lzUHJpbnRzdHIgPSBmdW5jdGlvbiBpc1ByaW50c3RyKHN0cikge1xuICByZXR1cm4gL15bQS1aYS16MC05ICcoKSssLS4vOj0/XSokLy50ZXN0KHN0cik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5jb25zdCBOb2RlID0gcmVxdWlyZSgnLi4vYmFzZS9ub2RlJyk7XG5cbi8vIEltcG9ydCBERVIgY29uc3RhbnRzXG5jb25zdCBkZXIgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvZGVyJyk7XG5cbmZ1bmN0aW9uIERFUkVuY29kZXIoZW50aXR5KSB7XG4gIHRoaXMuZW5jID0gJ2Rlcic7XG4gIHRoaXMubmFtZSA9IGVudGl0eS5uYW1lO1xuICB0aGlzLmVudGl0eSA9IGVudGl0eTtcblxuICAvLyBDb25zdHJ1Y3QgYmFzZSB0cmVlXG4gIHRoaXMudHJlZSA9IG5ldyBERVJOb2RlKCk7XG4gIHRoaXMudHJlZS5faW5pdChlbnRpdHkuYm9keSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IERFUkVuY29kZXI7XG5cbkRFUkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlcikge1xuICByZXR1cm4gdGhpcy50cmVlLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpLmpvaW4oKTtcbn07XG5cbi8vIFRyZWUgbWV0aG9kc1xuXG5mdW5jdGlvbiBERVJOb2RlKHBhcmVudCkge1xuICBOb2RlLmNhbGwodGhpcywgJ2RlcicsIHBhcmVudCk7XG59XG5pbmhlcml0cyhERVJOb2RlLCBOb2RlKTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZUNvbXBvc2l0ZSA9IGZ1bmN0aW9uIGVuY29kZUNvbXBvc2l0ZSh0YWcsXG4gIHByaW1pdGl2ZSxcbiAgY2xzLFxuICBjb250ZW50KSB7XG4gIGNvbnN0IGVuY29kZWRUYWcgPSBlbmNvZGVUYWcodGFnLCBwcmltaXRpdmUsIGNscywgdGhpcy5yZXBvcnRlcik7XG5cbiAgLy8gU2hvcnQgZm9ybVxuICBpZiAoY29udGVudC5sZW5ndGggPCAweDgwKSB7XG4gICAgY29uc3QgaGVhZGVyID0gbmV3IEJ1ZmZlcigyKTtcbiAgICBoZWFkZXJbMF0gPSBlbmNvZGVkVGFnO1xuICAgIGhlYWRlclsxXSA9IGNvbnRlbnQubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgaGVhZGVyLCBjb250ZW50IF0pO1xuICB9XG5cbiAgLy8gTG9uZyBmb3JtXG4gIC8vIENvdW50IG9jdGV0cyByZXF1aXJlZCB0byBzdG9yZSBsZW5ndGhcbiAgbGV0IGxlbk9jdGV0cyA9IDE7XG4gIGZvciAobGV0IGkgPSBjb250ZW50Lmxlbmd0aDsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBsZW5PY3RldHMrKztcblxuICBjb25zdCBoZWFkZXIgPSBuZXcgQnVmZmVyKDEgKyAxICsgbGVuT2N0ZXRzKTtcbiAgaGVhZGVyWzBdID0gZW5jb2RlZFRhZztcbiAgaGVhZGVyWzFdID0gMHg4MCB8IGxlbk9jdGV0cztcblxuICBmb3IgKGxldCBpID0gMSArIGxlbk9jdGV0cywgaiA9IGNvbnRlbnQubGVuZ3RoOyBqID4gMDsgaS0tLCBqID4+PSA4KVxuICAgIGhlYWRlcltpXSA9IGogJiAweGZmO1xuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgaGVhZGVyLCBjb250ZW50IF0pO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZVN0ciA9IGZ1bmN0aW9uIGVuY29kZVN0cihzdHIsIHRhZykge1xuICBpZiAodGFnID09PSAnYml0c3RyJykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgc3RyLnVudXNlZCB8IDAsIHN0ci5kYXRhIF0pO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2JtcHN0cicpIHtcbiAgICBjb25zdCBidWYgPSBuZXcgQnVmZmVyKHN0ci5sZW5ndGggKiAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoc3RyLmNoYXJDb2RlQXQoaSksIGkgKiAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoYnVmKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdudW1zdHInKSB7XG4gICAgaWYgKCF0aGlzLl9pc051bXN0cihzdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignRW5jb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6IG51bXN0ciBzdXBwb3J0cyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbmx5IGRpZ2l0cyBhbmQgc3BhY2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdwcmludHN0cicpIHtcbiAgICBpZiAoIXRoaXMuX2lzUHJpbnRzdHIoc3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nIG9mIHN0cmluZyB0eXBlOiBwcmludHN0ciBzdXBwb3J0cyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbmx5IGxhdGluIHVwcGVyIGFuZCBsb3dlciBjYXNlIGxldHRlcnMsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RpZ2l0cywgc3BhY2UsIGFwb3N0cm9waGUsIGxlZnQgYW5kIHJpZ3RoICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BhcmVudGhlc2lzLCBwbHVzIHNpZ24sIGNvbW1hLCBoeXBoZW4sICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RvdCwgc2xhc2gsIGNvbG9uLCBlcXVhbCBzaWduLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdxdWVzdGlvbiBtYXJrJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIH0gZWxzZSBpZiAoL3N0ciQvLnRlc3QodGFnKSkge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnb2JqRGVzYycpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArIHRhZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB1bnN1cHBvcnRlZCcpO1xuICB9XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlT2JqaWQgPSBmdW5jdGlvbiBlbmNvZGVPYmppZChpZCwgdmFsdWVzLCByZWxhdGl2ZSkge1xuICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgIGlmICghdmFsdWVzKVxuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ3N0cmluZyBvYmppZCBnaXZlbiwgYnV0IG5vIHZhbHVlcyBtYXAgZm91bmQnKTtcbiAgICBpZiAoIXZhbHVlcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignb2JqaWQgbm90IGZvdW5kIGluIHZhbHVlcyBtYXAnKTtcbiAgICBpZCA9IHZhbHVlc1tpZF0uc3BsaXQoL1tcXHMuXSsvZyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKylcbiAgICAgIGlkW2ldIHw9IDA7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICBpZCA9IGlkLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKylcbiAgICAgIGlkW2ldIHw9IDA7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ29iamlkKCkgc2hvdWxkIGJlIGVpdGhlciBhcnJheSBvciBzdHJpbmcsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdnb3Q6ICcgKyBKU09OLnN0cmluZ2lmeShpZCkpO1xuICB9XG5cbiAgaWYgKCFyZWxhdGl2ZSkge1xuICAgIGlmIChpZFsxXSA+PSA0MClcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdTZWNvbmQgb2JqaWQgaWRlbnRpZmllciBPT0InKTtcbiAgICBpZC5zcGxpY2UoMCwgMiwgaWRbMF0gKiA0MCArIGlkWzFdKTtcbiAgfVxuXG4gIC8vIENvdW50IG51bWJlciBvZiBvY3RldHNcbiAgbGV0IHNpemUgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlkLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGlkZW50ID0gaWRbaV07XG4gICAgZm9yIChzaXplKys7IGlkZW50ID49IDB4ODA7IGlkZW50ID4+PSA3KVxuICAgICAgc2l6ZSsrO1xuICB9XG5cbiAgY29uc3Qgb2JqaWQgPSBuZXcgQnVmZmVyKHNpemUpO1xuICBsZXQgb2Zmc2V0ID0gb2JqaWQubGVuZ3RoIC0gMTtcbiAgZm9yIChsZXQgaSA9IGlkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IGlkZW50ID0gaWRbaV07XG4gICAgb2JqaWRbb2Zmc2V0LS1dID0gaWRlbnQgJiAweDdmO1xuICAgIHdoaWxlICgoaWRlbnQgPj49IDcpID4gMClcbiAgICAgIG9iamlkW29mZnNldC0tXSA9IDB4ODAgfCAoaWRlbnQgJiAweDdmKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG9iamlkKTtcbn07XG5cbmZ1bmN0aW9uIHR3byhudW0pIHtcbiAgaWYgKG51bSA8IDEwKVxuICAgIHJldHVybiAnMCcgKyBudW07XG4gIGVsc2VcbiAgICByZXR1cm4gbnVtO1xufVxuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlVGltZSA9IGZ1bmN0aW9uIGVuY29kZVRpbWUodGltZSwgdGFnKSB7XG4gIGxldCBzdHI7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcblxuICBpZiAodGFnID09PSAnZ2VudGltZScpIHtcbiAgICBzdHIgPSBbXG4gICAgICB0d28oZGF0ZS5nZXRVVENGdWxsWWVhcigpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0RhdGUoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENIb3VycygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01pbnV0ZXMoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENTZWNvbmRzKCkpLFxuICAgICAgJ1onXG4gICAgXS5qb2luKCcnKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHN0ciA9IFtcbiAgICAgIHR3byhkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDApLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDRGF0ZSgpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0hvdXJzKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTWludXRlcygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ1NlY29uZHMoKSksXG4gICAgICAnWidcbiAgICBdLmpvaW4oJycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nICcgKyB0YWcgKyAnIHRpbWUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoc3RyLCAnb2N0c3RyJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlTnVsbCA9IGZ1bmN0aW9uIGVuY29kZU51bGwoKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKCcnKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU3RyaW5nIGludCBvciBlbnVtIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KG51bSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdWYWx1ZXMgbWFwIGRvZXNuXFwndCBjb250YWluOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG51bSkpO1xuICAgIH1cbiAgICBudW0gPSB2YWx1ZXNbbnVtXTtcbiAgfVxuXG4gIC8vIEJpZ251bSwgYXNzdW1lIGJpZyBlbmRpYW5cbiAgaWYgKHR5cGVvZiBudW0gIT09ICdudW1iZXInICYmICFCdWZmZXIuaXNCdWZmZXIobnVtKSkge1xuICAgIGNvbnN0IG51bUFycmF5ID0gbnVtLnRvQXJyYXkoKTtcbiAgICBpZiAoIW51bS5zaWduICYmIG51bUFycmF5WzBdICYgMHg4MCkge1xuICAgICAgbnVtQXJyYXkudW5zaGlmdCgwKTtcbiAgICB9XG4gICAgbnVtID0gbmV3IEJ1ZmZlcihudW1BcnJheSk7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG51bSkpIHtcbiAgICBsZXQgc2l6ZSA9IG51bS5sZW5ndGg7XG4gICAgaWYgKG51bS5sZW5ndGggPT09IDApXG4gICAgICBzaXplKys7XG5cbiAgICBjb25zdCBvdXQgPSBuZXcgQnVmZmVyKHNpemUpO1xuICAgIG51bS5jb3B5KG91dCk7XG4gICAgaWYgKG51bS5sZW5ndGggPT09IDApXG4gICAgICBvdXRbMF0gPSAwO1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG91dCk7XG4gIH1cblxuICBpZiAobnVtIDwgMHg4MClcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihudW0pO1xuXG4gIGlmIChudW0gPCAweDEwMClcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbMCwgbnVtXSk7XG5cbiAgbGV0IHNpemUgPSAxO1xuICBmb3IgKGxldCBpID0gbnVtOyBpID49IDB4MTAwOyBpID4+PSA4KVxuICAgIHNpemUrKztcblxuICBjb25zdCBvdXQgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIGZvciAobGV0IGkgPSBvdXQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBvdXRbaV0gPSBudW0gJiAweGZmO1xuICAgIG51bSA+Pj0gODtcbiAgfVxuICBpZihvdXRbMF0gJiAweDgwKSB7XG4gICAgb3V0LnVuc2hpZnQoMCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihuZXcgQnVmZmVyKG91dCkpO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZUJvb2wgPSBmdW5jdGlvbiBlbmNvZGVCb29sKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHZhbHVlID8gMHhmZiA6IDApO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3VzZSA9IGZ1bmN0aW9uIHVzZShlbnRpdHksIG9iaikge1xuICBpZiAodHlwZW9mIGVudGl0eSA9PT0gJ2Z1bmN0aW9uJylcbiAgICBlbnRpdHkgPSBlbnRpdHkob2JqKTtcbiAgcmV0dXJuIGVudGl0eS5fZ2V0RW5jb2RlcignZGVyJykudHJlZTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9za2lwRGVmYXVsdCA9IGZ1bmN0aW9uIHNraXBEZWZhdWx0KGRhdGFCdWZmZXIsIHJlcG9ydGVyLCBwYXJlbnQpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIGxldCBpO1xuICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgY29uc3QgZGF0YSA9IGRhdGFCdWZmZXIuam9pbigpO1xuICBpZiAoc3RhdGUuZGVmYXVsdEJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuICAgIHN0YXRlLmRlZmF1bHRCdWZmZXIgPSB0aGlzLl9lbmNvZGVWYWx1ZShzdGF0ZVsnZGVmYXVsdCddLCByZXBvcnRlciwgcGFyZW50KS5qb2luKCk7XG5cbiAgaWYgKGRhdGEubGVuZ3RoICE9PSBzdGF0ZS5kZWZhdWx0QnVmZmVyLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChpPTA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxuICAgIGlmIChkYXRhW2ldICE9PSBzdGF0ZS5kZWZhdWx0QnVmZmVyW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gVXRpbGl0eSBtZXRob2RzXG5cbmZ1bmN0aW9uIGVuY29kZVRhZyh0YWcsIHByaW1pdGl2ZSwgY2xzLCByZXBvcnRlcikge1xuICBsZXQgcmVzO1xuXG4gIGlmICh0YWcgPT09ICdzZXFvZicpXG4gICAgdGFnID0gJ3NlcSc7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ3NldG9mJylcbiAgICB0YWcgPSAnc2V0JztcblxuICBpZiAoZGVyLnRhZ0J5TmFtZS5oYXNPd25Qcm9wZXJ0eSh0YWcpKVxuICAgIHJlcyA9IGRlci50YWdCeU5hbWVbdGFnXTtcbiAgZWxzZSBpZiAodHlwZW9mIHRhZyA9PT0gJ251bWJlcicgJiYgKHRhZyB8IDApID09PSB0YWcpXG4gICAgcmVzID0gdGFnO1xuICBlbHNlXG4gICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdVbmtub3duIHRhZzogJyArIHRhZyk7XG5cbiAgaWYgKHJlcyA+PSAweDFmKVxuICAgIHJldHVybiByZXBvcnRlci5lcnJvcignTXVsdGktb2N0ZXQgdGFnIGVuY29kaW5nIHVuc3VwcG9ydGVkJyk7XG5cbiAgaWYgKCFwcmltaXRpdmUpXG4gICAgcmVzIHw9IDB4MjA7XG5cbiAgcmVzIHw9IChkZXIudGFnQ2xhc3NCeU5hbWVbY2xzIHx8ICd1bml2ZXJzYWwnXSA8PCA2KTtcblxuICByZXR1cm4gcmVzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmNvbnN0IERFUkVuY29kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuXG5mdW5jdGlvbiBQRU1FbmNvZGVyKGVudGl0eSkge1xuICBERVJFbmNvZGVyLmNhbGwodGhpcywgZW50aXR5KTtcbiAgdGhpcy5lbmMgPSAncGVtJztcbn1cbmluaGVyaXRzKFBFTUVuY29kZXIsIERFUkVuY29kZXIpO1xubW9kdWxlLmV4cG9ydHMgPSBQRU1FbmNvZGVyO1xuXG5QRU1FbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgb3B0aW9ucykge1xuICBjb25zdCBidWYgPSBERVJFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUuY2FsbCh0aGlzLCBkYXRhKTtcblxuICBjb25zdCBwID0gYnVmLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgY29uc3Qgb3V0ID0gWyAnLS0tLS1CRUdJTiAnICsgb3B0aW9ucy5sYWJlbCArICctLS0tLScgXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSArPSA2NClcbiAgICBvdXQucHVzaChwLnNsaWNlKGksIGkgKyA2NCkpO1xuICBvdXQucHVzaCgnLS0tLS1FTkQgJyArIG9wdGlvbnMubGFiZWwgKyAnLS0tLS0nKTtcbiAgcmV0dXJuIG91dC5qb2luKCdcXG4nKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxuY29uc3QgREVSRGVjb2RlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5cbmZ1bmN0aW9uIFBFTURlY29kZXIoZW50aXR5KSB7XG4gIERFUkRlY29kZXIuY2FsbCh0aGlzLCBlbnRpdHkpO1xuICB0aGlzLmVuYyA9ICdwZW0nO1xufVxuaW5oZXJpdHMoUEVNRGVjb2RlciwgREVSRGVjb2Rlcik7XG5tb2R1bGUuZXhwb3J0cyA9IFBFTURlY29kZXI7XG5cblBFTURlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBvcHRpb25zKSB7XG4gIGNvbnN0IGxpbmVzID0gZGF0YS50b1N0cmluZygpLnNwbGl0KC9bXFxyXFxuXSsvZyk7XG5cbiAgY29uc3QgbGFiZWwgPSBvcHRpb25zLmxhYmVsLnRvVXBwZXJDYXNlKCk7XG5cbiAgY29uc3QgcmUgPSAvXi0tLS0tKEJFR0lOfEVORCkgKFteLV0rKS0tLS0tJC87XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtYXRjaCA9IGxpbmVzW2ldLm1hdGNoKHJlKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpXG4gICAgICBjb250aW51ZTtcblxuICAgIGlmIChtYXRjaFsyXSAhPT0gbGFiZWwpXG4gICAgICBjb250aW51ZTtcblxuICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgIGlmIChtYXRjaFsxXSAhPT0gJ0JFR0lOJylcbiAgICAgICAgYnJlYWs7XG4gICAgICBzdGFydCA9IGk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXRjaFsxXSAhPT0gJ0VORCcpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZW5kID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQRU0gc2VjdGlvbiBub3QgZm91bmQgZm9yOiAnICsgbGFiZWwpO1xuXG4gIGNvbnN0IGJhc2U2NCA9IGxpbmVzLnNsaWNlKHN0YXJ0ICsgMSwgZW5kKS5qb2luKCcnKTtcbiAgLy8gUmVtb3ZlIGV4Y2Vzc2l2ZSBzeW1ib2xzXG4gIGJhc2U2NC5yZXBsYWNlKC9bXmEtejAtOSsvPV0rL2dpLCAnJyk7XG5cbiAgY29uc3QgaW5wdXQgPSBuZXcgQnVmZmVyKGJhc2U2NCwgJ2Jhc2U2NCcpO1xuICByZXR1cm4gREVSRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlLmNhbGwodGhpcywgaW5wdXQsIG9wdGlvbnMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5jb25zdCBiaWdudW0gPSByZXF1aXJlKCdibi5qcycpO1xuY29uc3QgRGVjb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4uL2Jhc2UvYnVmZmVyJykuRGVjb2RlckJ1ZmZlcjtcbmNvbnN0IE5vZGUgPSByZXF1aXJlKCcuLi9iYXNlL25vZGUnKTtcblxuLy8gSW1wb3J0IERFUiBjb25zdGFudHNcbmNvbnN0IGRlciA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9kZXInKTtcblxuZnVuY3Rpb24gREVSRGVjb2RlcihlbnRpdHkpIHtcbiAgdGhpcy5lbmMgPSAnZGVyJztcbiAgdGhpcy5uYW1lID0gZW50aXR5Lm5hbWU7XG4gIHRoaXMuZW50aXR5ID0gZW50aXR5O1xuXG4gIC8vIENvbnN0cnVjdCBiYXNlIHRyZWVcbiAgdGhpcy50cmVlID0gbmV3IERFUk5vZGUoKTtcbiAgdGhpcy50cmVlLl9pbml0KGVudGl0eS5ib2R5KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gREVSRGVjb2RlcjtcblxuREVSRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCFEZWNvZGVyQnVmZmVyLmlzRGVjb2RlckJ1ZmZlcihkYXRhKSkge1xuICAgIGRhdGEgPSBuZXcgRGVjb2RlckJ1ZmZlcihkYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnRyZWUuX2RlY29kZShkYXRhLCBvcHRpb25zKTtcbn07XG5cbi8vIFRyZWUgbWV0aG9kc1xuXG5mdW5jdGlvbiBERVJOb2RlKHBhcmVudCkge1xuICBOb2RlLmNhbGwodGhpcywgJ2RlcicsIHBhcmVudCk7XG59XG5pbmhlcml0cyhERVJOb2RlLCBOb2RlKTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3BlZWtUYWcgPSBmdW5jdGlvbiBwZWVrVGFnKGJ1ZmZlciwgdGFnLCBhbnkpIHtcbiAgaWYgKGJ1ZmZlci5pc0VtcHR5KCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGNvbnN0IHN0YXRlID0gYnVmZmVyLnNhdmUoKTtcbiAgY29uc3QgZGVjb2RlZFRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsICdGYWlsZWQgdG8gcGVlayB0YWc6IFwiJyArIHRhZyArICdcIicpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IoZGVjb2RlZFRhZykpXG4gICAgcmV0dXJuIGRlY29kZWRUYWc7XG5cbiAgYnVmZmVyLnJlc3RvcmUoc3RhdGUpO1xuXG4gIHJldHVybiBkZWNvZGVkVGFnLnRhZyA9PT0gdGFnIHx8IGRlY29kZWRUYWcudGFnU3RyID09PSB0YWcgfHxcbiAgICAoZGVjb2RlZFRhZy50YWdTdHIgKyAnb2YnKSA9PT0gdGFnIHx8IGFueTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVUYWcgPSBmdW5jdGlvbiBkZWNvZGVUYWcoYnVmZmVyLCB0YWcsIGFueSkge1xuICBjb25zdCBkZWNvZGVkVGFnID0gZGVyRGVjb2RlVGFnKGJ1ZmZlcixcbiAgICAnRmFpbGVkIHRvIGRlY29kZSB0YWcgb2YgXCInICsgdGFnICsgJ1wiJyk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihkZWNvZGVkVGFnKSlcbiAgICByZXR1cm4gZGVjb2RlZFRhZztcblxuICBsZXQgbGVuID0gZGVyRGVjb2RlTGVuKGJ1ZmZlcixcbiAgICBkZWNvZGVkVGFnLnByaW1pdGl2ZSxcbiAgICAnRmFpbGVkIHRvIGdldCBsZW5ndGggb2YgXCInICsgdGFnICsgJ1wiJyk7XG5cbiAgLy8gRmFpbHVyZVxuICBpZiAoYnVmZmVyLmlzRXJyb3IobGVuKSlcbiAgICByZXR1cm4gbGVuO1xuXG4gIGlmICghYW55ICYmXG4gICAgICBkZWNvZGVkVGFnLnRhZyAhPT0gdGFnICYmXG4gICAgICBkZWNvZGVkVGFnLnRhZ1N0ciAhPT0gdGFnICYmXG4gICAgICBkZWNvZGVkVGFnLnRhZ1N0ciArICdvZicgIT09IHRhZykge1xuICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0ZhaWxlZCB0byBtYXRjaCB0YWc6IFwiJyArIHRhZyArICdcIicpO1xuICB9XG5cbiAgaWYgKGRlY29kZWRUYWcucHJpbWl0aXZlIHx8IGxlbiAhPT0gbnVsbClcbiAgICByZXR1cm4gYnVmZmVyLnNraXAobGVuLCAnRmFpbGVkIHRvIG1hdGNoIGJvZHkgb2Y6IFwiJyArIHRhZyArICdcIicpO1xuXG4gIC8vIEluZGVmaW5pdGUgbGVuZ3RoLi4uIGZpbmQgRU5EIHRhZ1xuICBjb25zdCBzdGF0ZSA9IGJ1ZmZlci5zYXZlKCk7XG4gIGNvbnN0IHJlcyA9IHRoaXMuX3NraXBVbnRpbEVuZChcbiAgICBidWZmZXIsXG4gICAgJ0ZhaWxlZCB0byBza2lwIGluZGVmaW5pdGUgbGVuZ3RoIGJvZHk6IFwiJyArIHRoaXMudGFnICsgJ1wiJyk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihyZXMpKVxuICAgIHJldHVybiByZXM7XG5cbiAgbGVuID0gYnVmZmVyLm9mZnNldCAtIHN0YXRlLm9mZnNldDtcbiAgYnVmZmVyLnJlc3RvcmUoc3RhdGUpO1xuICByZXR1cm4gYnVmZmVyLnNraXAobGVuLCAnRmFpbGVkIHRvIG1hdGNoIGJvZHkgb2Y6IFwiJyArIHRhZyArICdcIicpO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3NraXBVbnRpbEVuZCA9IGZ1bmN0aW9uIHNraXBVbnRpbEVuZChidWZmZXIsIGZhaWwpIHtcbiAgZm9yICg7Oykge1xuICAgIGNvbnN0IHRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsIGZhaWwpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcih0YWcpKVxuICAgICAgcmV0dXJuIHRhZztcbiAgICBjb25zdCBsZW4gPSBkZXJEZWNvZGVMZW4oYnVmZmVyLCB0YWcucHJpbWl0aXZlLCBmYWlsKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IobGVuKSlcbiAgICAgIHJldHVybiBsZW47XG5cbiAgICBsZXQgcmVzO1xuICAgIGlmICh0YWcucHJpbWl0aXZlIHx8IGxlbiAhPT0gbnVsbClcbiAgICAgIHJlcyA9IGJ1ZmZlci5za2lwKGxlbik7XG4gICAgZWxzZVxuICAgICAgcmVzID0gdGhpcy5fc2tpcFVudGlsRW5kKGJ1ZmZlciwgZmFpbCk7XG5cbiAgICAvLyBGYWlsdXJlXG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgICByZXR1cm4gcmVzO1xuXG4gICAgaWYgKHRhZy50YWdTdHIgPT09ICdlbmQnKVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVMaXN0ID0gZnVuY3Rpb24gZGVjb2RlTGlzdChidWZmZXIsIHRhZywgZGVjb2RlcixcbiAgb3B0aW9ucykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKCFidWZmZXIuaXNFbXB0eSgpKSB7XG4gICAgY29uc3QgcG9zc2libGVFbmQgPSB0aGlzLl9wZWVrVGFnKGJ1ZmZlciwgJ2VuZCcpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcihwb3NzaWJsZUVuZCkpXG4gICAgICByZXR1cm4gcG9zc2libGVFbmQ7XG5cbiAgICBjb25zdCByZXMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIsICdkZXInLCBvcHRpb25zKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSAmJiBwb3NzaWJsZUVuZClcbiAgICAgIGJyZWFrO1xuICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVTdHIgPSBmdW5jdGlvbiBkZWNvZGVTdHIoYnVmZmVyLCB0YWcpIHtcbiAgaWYgKHRhZyA9PT0gJ2JpdHN0cicpIHtcbiAgICBjb25zdCB1bnVzZWQgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHVudXNlZCkpXG4gICAgICByZXR1cm4gdW51c2VkO1xuICAgIHJldHVybiB7IHVudXNlZDogdW51c2VkLCBkYXRhOiBidWZmZXIucmF3KCkgfTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdibXBzdHInKSB7XG4gICAgY29uc3QgcmF3ID0gYnVmZmVyLnJhdygpO1xuICAgIGlmIChyYXcubGVuZ3RoICUgMiA9PT0gMSlcbiAgICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiBibXBzdHIgbGVuZ3RoIG1pc21hdGNoJyk7XG5cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyYXcucmVhZFVJbnQxNkJFKGkgKiAyKSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnbnVtc3RyJykge1xuICAgIGNvbnN0IG51bXN0ciA9IGJ1ZmZlci5yYXcoKS50b1N0cmluZygnYXNjaWknKTtcbiAgICBpZiAoIXRoaXMuX2lzTnVtc3RyKG51bXN0cikpIHtcbiAgICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ251bXN0ciB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICAgIHJldHVybiBudW1zdHI7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnb2N0c3RyJykge1xuICAgIHJldHVybiBidWZmZXIucmF3KCk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnb2JqRGVzYycpIHtcbiAgICByZXR1cm4gYnVmZmVyLnJhdygpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3ByaW50c3RyJykge1xuICAgIGNvbnN0IHByaW50c3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCdhc2NpaScpO1xuICAgIGlmICghdGhpcy5faXNQcmludHN0cihwcmludHN0cikpIHtcbiAgICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByaW50c3RyIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHByaW50c3RyO1xuICB9IGVsc2UgaWYgKC9zdHIkLy50ZXN0KHRhZykpIHtcbiAgICByZXR1cm4gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6ICcgKyB0YWcgKyAnIHVuc3VwcG9ydGVkJyk7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVPYmppZCA9IGZ1bmN0aW9uIGRlY29kZU9iamlkKGJ1ZmZlciwgdmFsdWVzLCByZWxhdGl2ZSkge1xuICBsZXQgcmVzdWx0O1xuICBjb25zdCBpZGVudGlmaWVycyA9IFtdO1xuICBsZXQgaWRlbnQgPSAwO1xuICBsZXQgc3ViaWRlbnQgPSAwO1xuICB3aGlsZSAoIWJ1ZmZlci5pc0VtcHR5KCkpIHtcbiAgICBzdWJpZGVudCA9IGJ1ZmZlci5yZWFkVUludDgoKTtcbiAgICBpZGVudCA8PD0gNztcbiAgICBpZGVudCB8PSBzdWJpZGVudCAmIDB4N2Y7XG4gICAgaWYgKChzdWJpZGVudCAmIDB4ODApID09PSAwKSB7XG4gICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50KTtcbiAgICAgIGlkZW50ID0gMDtcbiAgICB9XG4gIH1cbiAgaWYgKHN1YmlkZW50ICYgMHg4MClcbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50KTtcblxuICBjb25zdCBmaXJzdCA9IChpZGVudGlmaWVyc1swXSAvIDQwKSB8IDA7XG4gIGNvbnN0IHNlY29uZCA9IGlkZW50aWZpZXJzWzBdICUgNDA7XG5cbiAgaWYgKHJlbGF0aXZlKVxuICAgIHJlc3VsdCA9IGlkZW50aWZpZXJzO1xuICBlbHNlXG4gICAgcmVzdWx0ID0gW2ZpcnN0LCBzZWNvbmRdLmNvbmNhdChpZGVudGlmaWVycy5zbGljZSgxKSk7XG5cbiAgaWYgKHZhbHVlcykge1xuICAgIGxldCB0bXAgPSB2YWx1ZXNbcmVzdWx0LmpvaW4oJyAnKV07XG4gICAgaWYgKHRtcCA9PT0gdW5kZWZpbmVkKVxuICAgICAgdG1wID0gdmFsdWVzW3Jlc3VsdC5qb2luKCcuJyldO1xuICAgIGlmICh0bXAgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlc3VsdCA9IHRtcDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlVGltZSA9IGZ1bmN0aW9uIGRlY29kZVRpbWUoYnVmZmVyLCB0YWcpIHtcbiAgY29uc3Qgc3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCk7XG5cbiAgbGV0IHllYXI7XG4gIGxldCBtb247XG4gIGxldCBkYXk7XG4gIGxldCBob3VyO1xuICBsZXQgbWluO1xuICBsZXQgc2VjO1xuICBpZiAodGFnID09PSAnZ2VudGltZScpIHtcbiAgICB5ZWFyID0gc3RyLnNsaWNlKDAsIDQpIHwgMDtcbiAgICBtb24gPSBzdHIuc2xpY2UoNCwgNikgfCAwO1xuICAgIGRheSA9IHN0ci5zbGljZSg2LCA4KSB8IDA7XG4gICAgaG91ciA9IHN0ci5zbGljZSg4LCAxMCkgfCAwO1xuICAgIG1pbiA9IHN0ci5zbGljZSgxMCwgMTIpIHwgMDtcbiAgICBzZWMgPSBzdHIuc2xpY2UoMTIsIDE0KSB8IDA7XG4gIH0gZWxzZSBpZiAodGFnID09PSAndXRjdGltZScpIHtcbiAgICB5ZWFyID0gc3RyLnNsaWNlKDAsIDIpIHwgMDtcbiAgICBtb24gPSBzdHIuc2xpY2UoMiwgNCkgfCAwO1xuICAgIGRheSA9IHN0ci5zbGljZSg0LCA2KSB8IDA7XG4gICAgaG91ciA9IHN0ci5zbGljZSg2LCA4KSB8IDA7XG4gICAgbWluID0gc3RyLnNsaWNlKDgsIDEwKSB8IDA7XG4gICAgc2VjID0gc3RyLnNsaWNlKDEwLCAxMikgfCAwO1xuICAgIGlmICh5ZWFyIDwgNzApXG4gICAgICB5ZWFyID0gMjAwMCArIHllYXI7XG4gICAgZWxzZVxuICAgICAgeWVhciA9IDE5MDAgKyB5ZWFyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nICcgKyB0YWcgKyAnIHRpbWUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIHJldHVybiBEYXRlLlVUQyh5ZWFyLCBtb24gLSAxLCBkYXksIGhvdXIsIG1pbiwgc2VjLCAwKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVOdWxsID0gZnVuY3Rpb24gZGVjb2RlTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlQm9vbCA9IGZ1bmN0aW9uIGRlY29kZUJvb2woYnVmZmVyKSB7XG4gIGNvbnN0IHJlcyA9IGJ1ZmZlci5yZWFkVUludDgoKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgcmV0dXJuIHJlcztcbiAgZWxzZVxuICAgIHJldHVybiByZXMgIT09IDA7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlSW50ID0gZnVuY3Rpb24gZGVjb2RlSW50KGJ1ZmZlciwgdmFsdWVzKSB7XG4gIC8vIEJpZ2ludCwgcmV0dXJuIGFzIGl0IGlzIChhc3N1bWUgYmlnIGVuZGlhbilcbiAgY29uc3QgcmF3ID0gYnVmZmVyLnJhdygpO1xuICBsZXQgcmVzID0gbmV3IGJpZ251bShyYXcpO1xuXG4gIGlmICh2YWx1ZXMpXG4gICAgcmVzID0gdmFsdWVzW3Jlcy50b1N0cmluZygxMCldIHx8IHJlcztcblxuICByZXR1cm4gcmVzO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3VzZSA9IGZ1bmN0aW9uIHVzZShlbnRpdHksIG9iaikge1xuICBpZiAodHlwZW9mIGVudGl0eSA9PT0gJ2Z1bmN0aW9uJylcbiAgICBlbnRpdHkgPSBlbnRpdHkob2JqKTtcbiAgcmV0dXJuIGVudGl0eS5fZ2V0RGVjb2RlcignZGVyJykudHJlZTtcbn07XG5cbi8vIFV0aWxpdHkgbWV0aG9kc1xuXG5mdW5jdGlvbiBkZXJEZWNvZGVUYWcoYnVmLCBmYWlsKSB7XG4gIGxldCB0YWcgPSBidWYucmVhZFVJbnQ4KGZhaWwpO1xuICBpZiAoYnVmLmlzRXJyb3IodGFnKSlcbiAgICByZXR1cm4gdGFnO1xuXG4gIGNvbnN0IGNscyA9IGRlci50YWdDbGFzc1t0YWcgPj4gNl07XG4gIGNvbnN0IHByaW1pdGl2ZSA9ICh0YWcgJiAweDIwKSA9PT0gMDtcblxuICAvLyBNdWx0aS1vY3RldCB0YWcgLSBsb2FkXG4gIGlmICgodGFnICYgMHgxZikgPT09IDB4MWYpIHtcbiAgICBsZXQgb2N0ID0gdGFnO1xuICAgIHRhZyA9IDA7XG4gICAgd2hpbGUgKChvY3QgJiAweDgwKSA9PT0gMHg4MCkge1xuICAgICAgb2N0ID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgICAgIGlmIChidWYuaXNFcnJvcihvY3QpKVxuICAgICAgICByZXR1cm4gb2N0O1xuXG4gICAgICB0YWcgPDw9IDc7XG4gICAgICB0YWcgfD0gb2N0ICYgMHg3ZjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFnICY9IDB4MWY7XG4gIH1cbiAgY29uc3QgdGFnU3RyID0gZGVyLnRhZ1t0YWddO1xuXG4gIHJldHVybiB7XG4gICAgY2xzOiBjbHMsXG4gICAgcHJpbWl0aXZlOiBwcmltaXRpdmUsXG4gICAgdGFnOiB0YWcsXG4gICAgdGFnU3RyOiB0YWdTdHJcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVyRGVjb2RlTGVuKGJ1ZiwgcHJpbWl0aXZlLCBmYWlsKSB7XG4gIGxldCBsZW4gPSBidWYucmVhZFVJbnQ4KGZhaWwpO1xuICBpZiAoYnVmLmlzRXJyb3IobGVuKSlcbiAgICByZXR1cm4gbGVuO1xuXG4gIC8vIEluZGVmaW5pdGUgZm9ybVxuICBpZiAoIXByaW1pdGl2ZSAmJiBsZW4gPT09IDB4ODApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgLy8gRGVmaW5pdGUgZm9ybVxuICBpZiAoKGxlbiAmIDB4ODApID09PSAwKSB7XG4gICAgLy8gU2hvcnQgZm9ybVxuICAgIHJldHVybiBsZW47XG4gIH1cblxuICAvLyBMb25nIGZvcm1cbiAgY29uc3QgbnVtID0gbGVuICYgMHg3ZjtcbiAgaWYgKG51bSA+IDQpXG4gICAgcmV0dXJuIGJ1Zi5lcnJvcignbGVuZ3RoIG9jdGVjdCBpcyB0b28gbG9uZycpO1xuXG4gIGxlbiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICBsZW4gPDw9IDg7XG4gICAgY29uc3QgaiA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gICAgaWYgKGJ1Zi5pc0Vycm9yKGopKVxuICAgICAgcmV0dXJuIGo7XG4gICAgbGVuIHw9IGo7XG4gIH1cblxuICByZXR1cm4gbGVuO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBCTiA9IHJlcXVpcmUoJy4vYm4nKVxudmFyIEVDUG9pbnQgPSByZXF1aXJlKCcuL2VjcG9pbnQnKVxudmFyIEVDSlBvaW50ID0gcmVxdWlyZSgnLi9lY2pwb2ludCcpXG5cbmZ1bmN0aW9uIEVDUG9pbnRHICgpIHtcbiAgdGhpcy54ID0gQk4uZnJvbUJ1ZmZlcihCdWZmZXIuZnJvbSgnNzlCRTY2N0VGOURDQkJBQzU1QTA2Mjk1Q0U4NzBCMDcwMjlCRkNEQjJEQ0UyOEQ5NTlGMjgxNUIxNkY4MTc5OCcsICdoZXgnKSlcbiAgdGhpcy55ID0gQk4uZnJvbUJ1ZmZlcihCdWZmZXIuZnJvbSgnNDgzQURBNzcyNkEzQzQ2NTVEQTRGQkZDMEUxMTA4QThGRDE3QjQ0OEE2ODU1NDE5OUM0N0QwOEZGQjEwRDRCOCcsICdoZXgnKSlcbiAgdGhpcy5pbmYgPSBmYWxzZVxuXG4gIHRoaXMuX3ByZWNvbXB1dGUoKVxufVxuXG5FQ1BvaW50Ry5wcm90b3R5cGUuX3ByZWNvbXB1dGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlY3BvaW50ID0gbmV3IEVDUG9pbnQodGhpcy54LCB0aGlzLnkpXG5cbiAgdmFyIGRzdGVwID0gNFxuICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KDEgKyBNYXRoLmNlaWwoMjU3IC8gZHN0ZXApKVxuICB2YXIgYWNjID0gcG9pbnRzWzBdID0gZWNwb2ludFxuICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZHN0ZXA7IGorKykgYWNjID0gYWNjLmRibCgpXG4gICAgcG9pbnRzW2ldID0gYWNjXG4gIH1cblxuICB0aGlzLnByZWNvbXB1dGVkID0ge1xuICAgIG5hZjogZWNwb2ludC5fZ2V0TkFGUG9pbnRzKDcpLFxuICAgIGRvdWJsZXM6IHtcbiAgICAgIHN0ZXA6IGRzdGVwLFxuICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICBuZWdwb2ludHM6IHBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAubmVnKCkgfSlcbiAgICB9XG4gIH1cbn1cblxuRUNQb2ludEcucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgLy8gQWxnb3JpdGhtIDMuNDIgRml4ZWQtYmFzZSBOQUYgd2luZG93aW5nIG1ldGhvZCBmb3IgcG9pbnQgbXVsdGlwbGljYXRpb25cbiAgdmFyIHN0ZXAgPSB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMuc3RlcFxuICB2YXIgcG9pbnRzID0gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnBvaW50c1xuICB2YXIgbmVncG9pbnRzID0gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLm5lZ3BvaW50c1xuXG4gIHZhciBuYWYgPSBudW0uZ2V0TkFGKDEpXG4gIHZhciBJID0gKCgxIDw8IChzdGVwICsgMSkpIC0gKHN0ZXAgJSAyID09PSAwID8gMiA6IDEpKSAvIDNcblxuICAvLyBUcmFuc2xhdGUgaW50byBtb3JlIHdpbmRvd2VkIGZvcm1cbiAgdmFyIHJlcHIgPSBbXVxuICBmb3IgKHZhciBqID0gMDsgaiA8IG5hZi5sZW5ndGg7IGogKz0gc3RlcCkge1xuICAgIHZhciBuYWZXID0gMFxuICAgIGZvciAodmFyIGsgPSBqICsgc3RlcCAtIDE7IGsgPj0gajsgay0tKSBuYWZXID0gKG5hZlcgPDwgMSkgKyBuYWZba11cbiAgICByZXByLnB1c2gobmFmVylcbiAgfVxuXG4gIHZhciBhID0gbmV3IEVDSlBvaW50KG51bGwsIG51bGwsIG51bGwpXG4gIHZhciBiID0gbmV3IEVDSlBvaW50KG51bGwsIG51bGwsIG51bGwpXG4gIGZvciAodmFyIGkgPSBJOyBpID4gMDsgaS0tKSB7XG4gICAgZm9yICh2YXIgamogPSAwOyBqaiA8IHJlcHIubGVuZ3RoOyBqaisrKSB7XG4gICAgICBpZiAocmVwcltqal0gPT09IGkpIHtcbiAgICAgICAgYiA9IGIubWl4ZWRBZGQocG9pbnRzW2pqXSlcbiAgICAgIH0gZWxzZSBpZiAocmVwcltqal0gPT09IC1pKSB7XG4gICAgICAgIGIgPSBiLm1peGVkQWRkKG5lZ3BvaW50c1tqal0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgYSA9IGEuYWRkKGIpXG4gIH1cblxuICByZXR1cm4gRUNQb2ludC5mcm9tRUNKUG9pbnQoYSlcbn1cblxuRUNQb2ludEcucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIChrMSwgcDIsIGsyKSB7XG4gIHZhciBuYWZQb2ludHNQMSA9IHRoaXMucHJlY29tcHV0ZWQubmFmXG4gIHZhciBuYWZQb2ludHNQMiA9IHAyLl9nZXROQUZQb2ludHMxKClcbiAgdmFyIHduZCA9IFtuYWZQb2ludHNQMS5wb2ludHMsIG5hZlBvaW50c1AyLnBvaW50c11cbiAgdmFyIG5hZiA9IFtrMS5nZXROQUYobmFmUG9pbnRzUDEud25kKSwgazIuZ2V0TkFGKG5hZlBvaW50c1AyLnduZCldXG5cbiAgdmFyIGFjYyA9IG5ldyBFQ0pQb2ludChudWxsLCBudWxsLCBudWxsKVxuICB2YXIgdG1wID0gW251bGwsIG51bGxdXG4gIGZvciAodmFyIGkgPSBNYXRoLm1heChuYWZbMF0ubGVuZ3RoLCBuYWZbMV0ubGVuZ3RoKTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgayA9IDBcblxuICAgIGZvciAoOyBpID49IDA7ICsraywgLS1pKSB7XG4gICAgICB0bXBbMF0gPSBuYWZbMF1baV0gfCAwXG4gICAgICB0bXBbMV0gPSBuYWZbMV1baV0gfCAwXG5cbiAgICAgIGlmICh0bXBbMF0gIT09IDAgfHwgdG1wWzFdICE9PSAwKSBicmVha1xuICAgIH1cblxuICAgIGlmIChpID49IDApIGsgKz0gMVxuICAgIGFjYyA9IGFjYy5kYmxwKGspXG5cbiAgICBpZiAoaSA8IDApIGJyZWFrXG5cbiAgICBmb3IgKHZhciBqaiA9IDA7IGpqIDwgMjsgamorKykge1xuICAgICAgdmFyIHogPSB0bXBbampdXG4gICAgICB2YXIgcFxuICAgICAgaWYgKHogPT09IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZiAoeiA+IDApIHtcbiAgICAgICAgcCA9IHduZFtqal1beiA+PiAxXVxuICAgICAgfSBlbHNlIGlmICh6IDwgMCkge1xuICAgICAgICBwID0gd25kW2pqXVsteiA+PiAxXS5uZWcoKVxuICAgICAgfVxuXG4gICAgICAvLyBoYWNrOiBFQ1BvaW50IGRldGVjdGlvblxuICAgICAgaWYgKHAueiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZChwKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWNjID0gYWNjLmFkZChwKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRUNQb2ludEcoKVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBCTiA9IHJlcXVpcmUoJy4vYm4nKVxudmFyIEVDSlBvaW50ID0gcmVxdWlyZSgnLi9lY2pwb2ludCcpXG5cbmZ1bmN0aW9uIEVDUG9pbnQgKHgsIHkpIHtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMueSA9IG51bGxcbiAgICB0aGlzLmluZiA9IHRydWVcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSB4XG4gICAgdGhpcy55ID0geVxuICAgIHRoaXMuaW5mID0gZmFsc2VcbiAgfVxufVxuXG5FQ1BvaW50LmZyb21QdWJsaWNLZXkgPSBmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gIHZhciBmaXJzdCA9IHB1YmxpY0tleVswXVxuICB2YXIgeFxuICB2YXIgeVxuXG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAzMyAmJiAoZmlyc3QgPT09IDB4MDIgfHwgZmlyc3QgPT09IDB4MDMpKSB7XG4gICAgeCA9IEJOLmZyb21CdWZmZXIocHVibGljS2V5LnNsaWNlKDEsIDMzKSlcblxuICAgIC8vIG92ZXJmbG93XG4gICAgaWYgKHgudWNtcChCTi5wKSA+PSAwKSByZXR1cm4gbnVsbFxuXG4gICAgLy8gY3JlYXRlIGZyb20gWFxuICAgIHkgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkNygpLnJlZFNxcnQoKVxuICAgIGlmICh5ID09PSBudWxsKSByZXR1cm4gbnVsbFxuICAgIGlmICgoZmlyc3QgPT09IDB4MDMpICE9PSB5LmlzT2RkKCkpIHkgPSB5LnJlZE5lZygpXG5cbiAgICByZXR1cm4gbmV3IEVDUG9pbnQoeCwgeSlcbiAgfVxuXG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NSAmJiAoZmlyc3QgPT09IDB4MDQgfHwgZmlyc3QgPT09IDB4MDYgfHwgZmlyc3QgPT09IDB4MDcpKSB7XG4gICAgeCA9IEJOLmZyb21CdWZmZXIocHVibGljS2V5LnNsaWNlKDEsIDMzKSlcbiAgICB5ID0gQk4uZnJvbUJ1ZmZlcihwdWJsaWNLZXkuc2xpY2UoMzMsIDY1KSlcblxuICAgIC8vIG92ZXJmbG93XG4gICAgaWYgKHgudWNtcChCTi5wKSA+PSAwIHx8IHkudWNtcChCTi5wKSA+PSAwKSByZXR1cm4gbnVsbFxuXG4gICAgLy8gaXMgb2RkIGZsYWdcbiAgICBpZiAoKGZpcnN0ID09PSAweDA2IHx8IGZpcnN0ID09PSAweDA3KSAmJiB5LmlzT2RkKCkgIT09IChmaXJzdCA9PT0gMHgwNykpIHJldHVybiBudWxsXG5cbiAgICAvLyB4KngqeCArIDcgPSB5KnlcbiAgICBpZiAoeC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZDcoKS51Y21wKHkucmVkU3FyKCkpICE9PSAwKSByZXR1cm4gbnVsbFxuXG4gICAgcmV0dXJuIG5ldyBFQ1BvaW50KHgsIHkpXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5FQ1BvaW50LnByb3RvdHlwZS50b1B1YmxpY0tleSA9IGZ1bmN0aW9uIChjb21wcmVzc2VkKSB7XG4gIHZhciB4ID0gdGhpcy54XG4gIHZhciB5ID0gdGhpcy55XG4gIHZhciBwdWJsaWNLZXlcblxuICBpZiAoY29tcHJlc3NlZCkge1xuICAgIHB1YmxpY0tleSA9IEJ1ZmZlci5hbGxvYygzMylcbiAgICBwdWJsaWNLZXlbMF0gPSB5LmlzT2RkKCkgPyAweDAzIDogMHgwMlxuICAgIHgudG9CdWZmZXIoKS5jb3B5KHB1YmxpY0tleSwgMSlcbiAgfSBlbHNlIHtcbiAgICBwdWJsaWNLZXkgPSBCdWZmZXIuYWxsb2MoNjUpXG4gICAgcHVibGljS2V5WzBdID0gMHgwNFxuICAgIHgudG9CdWZmZXIoKS5jb3B5KHB1YmxpY0tleSwgMSlcbiAgICB5LnRvQnVmZmVyKCkuY29weShwdWJsaWNLZXksIDMzKVxuICB9XG5cbiAgcmV0dXJuIHB1YmxpY0tleVxufVxuXG5FQ1BvaW50LmZyb21FQ0pQb2ludCA9IGZ1bmN0aW9uIChwKSB7XG4gIGlmIChwLmluZikgcmV0dXJuIG5ldyBFQ1BvaW50KG51bGwsIG51bGwpXG5cbiAgdmFyIHppbnYgPSBwLnoucmVkSW52bSgpXG4gIHZhciB6aW52MiA9IHppbnYucmVkU3FyKClcbiAgdmFyIGF4ID0gcC54LnJlZE11bCh6aW52MilcbiAgdmFyIGF5ID0gcC55LnJlZE11bCh6aW52MikucmVkTXVsKHppbnYpXG5cbiAgcmV0dXJuIG5ldyBFQ1BvaW50KGF4LCBheSlcbn1cblxuRUNQb2ludC5wcm90b3R5cGUudG9FQ0pQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaW5mKSByZXR1cm4gbmV3IEVDSlBvaW50KG51bGwsIG51bGwsIG51bGwpXG5cbiAgcmV0dXJuIG5ldyBFQ0pQb2ludCh0aGlzLngsIHRoaXMueSwgRUNKUG9pbnQub25lKVxufVxuXG5FQ1BvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmluZikgcmV0dXJuIHRoaXNcblxuICByZXR1cm4gbmV3IEVDUG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCkpXG59XG5cbkVDUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pbmYpIHJldHVybiBwXG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmluZikgcmV0dXJuIHRoaXNcblxuICBpZiAodGhpcy54LnVjbXAocC54KSA9PT0gMCkge1xuICAgIC8vIFAgKyBQID0gMlBcbiAgICBpZiAodGhpcy55LnVjbXAocC55KSA9PT0gMCkgcmV0dXJuIHRoaXMuZGJsKClcbiAgICAvLyBQICsgKC1QKSA9IE9cbiAgICByZXR1cm4gbmV3IEVDUG9pbnQobnVsbCwgbnVsbClcbiAgfVxuXG4gIC8vIHMgPSAoeSAtIHlwKSAvICh4IC0geHApXG4gIC8vIG54ID0gc14yIC0geCAtIHhwXG4gIC8vIG55ID0gcyAqICh4IC0gbngpIC0geVxuICB2YXIgcyA9IHRoaXMueS5yZWRTdWIocC55KVxuICBpZiAoIXMuaXNaZXJvKCkpIHMgPSBzLnJlZE11bCh0aGlzLngucmVkU3ViKHAueCkucmVkSW52bSgpKVxuXG4gIHZhciBueCA9IHMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIocC54KVxuICB2YXIgbnkgPSBzLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpXG4gIHJldHVybiBuZXcgRUNQb2ludChueCwgbnkpXG59XG5cbkVDUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaW5mKSByZXR1cm4gdGhpc1xuXG4gIC8vIDJQID0gT1xuICB2YXIgeXkgPSB0aGlzLnkucmVkQWRkKHRoaXMueSlcbiAgaWYgKHl5LmlzWmVybygpKSByZXR1cm4gbmV3IEVDUG9pbnQobnVsbCwgbnVsbClcblxuICAvLyBzID0gKDMgKiB4XjIpIC8gKDIgKiB5KVxuICAvLyBueCA9IHNeMiAtIDIqeFxuICAvLyBueSA9IHMgKiAoeCAtIG54KSAtIHlcbiAgdmFyIHgyID0gdGhpcy54LnJlZFNxcigpXG4gIHZhciBzID0geDIucmVkQWRkKHgyKS5yZWRJQWRkKHgyKS5yZWRNdWwoeXkucmVkSW52bSgpKVxuXG4gIHZhciBueCA9IHMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngucmVkQWRkKHRoaXMueCkpXG4gIHZhciBueSA9IHMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSlcbiAgcmV0dXJuIG5ldyBFQ1BvaW50KG54LCBueSlcbn1cblxuRUNQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gKG51bSkge1xuICAvLyBBbGdvcml0aG0gMy4zNiBXaW5kb3cgTkFGIG1ldGhvZCBmb3IgcG9pbnQgbXVsdGlwbGljYXRpb25cbiAgdmFyIG5hZlBvaW50cyA9IHRoaXMuX2dldE5BRlBvaW50cyg0KVxuICB2YXIgcG9pbnRzID0gbmFmUG9pbnRzLnBvaW50c1xuXG4gIC8vIEdldCBOQUYgZm9ybVxuICB2YXIgbmFmID0gbnVtLmdldE5BRihuYWZQb2ludHMud25kKVxuXG4gIC8vIEFkZCBgdGhpc2AqKE4rMSkgZm9yIGV2ZXJ5IHctTkFGIGluZGV4XG4gIHZhciBhY2MgPSBuZXcgRUNKUG9pbnQobnVsbCwgbnVsbCwgbnVsbClcbiAgZm9yICh2YXIgaSA9IG5hZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIC8vIENvdW50IHplcm9lc1xuICAgIGZvciAodmFyIGsgPSAwOyBpID49IDAgJiYgbmFmW2ldID09PSAwOyBpLS0sICsrayk7XG4gICAgaWYgKGkgPj0gMCkgayArPSAxXG4gICAgYWNjID0gYWNjLmRibHAoaylcblxuICAgIGlmIChpIDwgMCkgYnJlYWtcblxuICAgIC8vIEogKy0gUFxuICAgIHZhciB6ID0gbmFmW2ldXG4gICAgaWYgKHogPiAwKSB7XG4gICAgICBhY2MgPSBhY2MubWl4ZWRBZGQocG9pbnRzWyh6IC0gMSkgPj4gMV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGFjYyA9IGFjYy5taXhlZEFkZChwb2ludHNbKC16IC0gMSkgPj4gMV0ubmVnKCkpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEVDUG9pbnQuZnJvbUVDSlBvaW50KGFjYylcbn1cblxuRUNQb2ludC5wcm90b3R5cGUuX2dldE5BRlBvaW50czEgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7IHduZDogMSwgcG9pbnRzOiBbdGhpc10gfVxufVxuXG5FQ1BvaW50LnByb3RvdHlwZS5fZ2V0TkFGUG9pbnRzID0gZnVuY3Rpb24gKHduZCkge1xuICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KCgxIDw8IHduZCkgLSAxKVxuICBwb2ludHNbMF0gPSB0aGlzXG4gIHZhciBkYmwgPSB0aGlzLmRibCgpXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSBwb2ludHNbaV0gPSBwb2ludHNbaSAtIDFdLmFkZChkYmwpXG4gIHJldHVybiB7IHduZDogd25kLCBwb2ludHM6IHBvaW50cyB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRUNQb2ludFxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgY3JlYXRlSG1hYyA9IHJlcXVpcmUoJ2NyZWF0ZS1obWFjJylcbnZhciBoYXNoSW5mbyA9IHJlcXVpcmUoJy4vbGliL2hhc2gtaW5mby5qc29uJylcblxudmFyIGVidWYgPSBuZXcgQnVmZmVyKDApXG52YXIgYjB4MDAgPSBuZXcgQnVmZmVyKFsgMHgwMCBdKVxudmFyIGIweDAxID0gbmV3IEJ1ZmZlcihbIDB4MDEgXSlcblxuZnVuY3Rpb24gSG1hY0RSQkcgKGFsZ28sIGVudHJvcHksIG5vbmNlLCBwZXJzKSB7XG4gIHZhciBpbmZvID0gaGFzaEluZm9bYWxnb11cbiAgaWYgKGluZm8gPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdoYXNoICcgKyBhbGdvICsgJyBpcyBub3Qgc3VwcG9ydGVkJylcblxuICB0aGlzLl9hbGdvID0gYWxnb1xuICB0aGlzLl9zZWN1cml0eVN0cmVuZ3RoID0gaW5mby5zZWN1cml0eVN0cmVuZ3RoIC8gOFxuICB0aGlzLl9vdXRsZW4gPSBpbmZvLm91dGxlbiAvIDhcbiAgdGhpcy5fcmVzZWVkSW50ZXJ2YWwgPSAweDEwMDAwMDAwMDAwMDAgLy8gMioqNDhcblxuICB0aGlzLl9pbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKVxufVxuXG5IbWFjRFJCRy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gIHZhciBrbWFjID0gY3JlYXRlSG1hYyh0aGlzLl9hbGdvLCB0aGlzLl9LKS51cGRhdGUodGhpcy5fVikudXBkYXRlKGIweDAwKVxuICBpZiAoc2VlZCkga21hYy51cGRhdGUoc2VlZClcblxuICB0aGlzLl9LID0ga21hYy5kaWdlc3QoKVxuICB0aGlzLl9WID0gY3JlYXRlSG1hYyh0aGlzLl9hbGdvLCB0aGlzLl9LKS51cGRhdGUodGhpcy5fVikuZGlnZXN0KClcbiAgaWYgKCFzZWVkKSByZXR1cm5cblxuICB0aGlzLl9LID0gY3JlYXRlSG1hYyh0aGlzLl9hbGdvLCB0aGlzLl9LKS51cGRhdGUodGhpcy5fVikudXBkYXRlKGIweDAxKS51cGRhdGUoc2VlZCkuZGlnZXN0KClcbiAgdGhpcy5fViA9IGNyZWF0ZUhtYWModGhpcy5fYWxnbywgdGhpcy5fSykudXBkYXRlKHRoaXMuX1YpLmRpZ2VzdCgpXG59XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChlbnRyb3B5LCBub25jZSwgcGVycykge1xuICBpZiAoZW50cm9weS5sZW5ndGggPCB0aGlzLl9zZWN1cml0eVN0cmVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBlbm91Z2ggZW50cm9weScpXG5cbiAgdGhpcy5fSyA9IG5ldyBCdWZmZXIodGhpcy5fb3V0bGVuKVxuICB0aGlzLl9WID0gbmV3IEJ1ZmZlcih0aGlzLl9vdXRsZW4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fSy5sZW5ndGg7ICsraSkge1xuICAgIHRoaXMuX0tbaV0gPSAweDAwXG4gICAgdGhpcy5fVltpXSA9IDB4MDFcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZShCdWZmZXIuY29uY2F0KFsgZW50cm9weSwgbm9uY2UsIHBlcnMgfHwgZWJ1ZiBdKSlcbiAgdGhpcy5fcmVzZWVkID0gMVxufVxuXG5IbWFjRFJCRy5wcm90b3R5cGUucmVzZWVkID0gZnVuY3Rpb24gKGVudHJvcHksIGFkZCkge1xuICBpZiAoZW50cm9weS5sZW5ndGggPCB0aGlzLl9zZWN1cml0eVN0cmVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBlbm91Z2ggZW50cm9weScpXG5cbiAgdGhpcy5fdXBkYXRlKEJ1ZmZlci5jb25jYXQoWyBlbnRyb3B5LCBhZGQgfHwgZWJ1ZiBdKSlcbiAgdGhpcy5fcmVzZWVkID0gMVxufVxuXG5IbWFjRFJCRy5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAobGVuLCBhZGQpIHtcbiAgaWYgKHRoaXMuX3Jlc2VlZCA+IHRoaXMuX3Jlc2VlZEludGVydmFsKSB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2VlZCBpcyByZXF1aXJlZCcpXG5cbiAgaWYgKGFkZCAmJiBhZGQubGVuZ3RoID09PSAwKSBhZGQgPSB1bmRlZmluZWRcbiAgaWYgKGFkZCkgdGhpcy5fdXBkYXRlKGFkZClcblxuICB2YXIgdGVtcCA9IG5ldyBCdWZmZXIoMClcbiAgd2hpbGUgKHRlbXAubGVuZ3RoIDwgbGVuKSB7XG4gICAgdGhpcy5fViA9IGNyZWF0ZUhtYWModGhpcy5fYWxnbywgdGhpcy5fSykudXBkYXRlKHRoaXMuX1YpLmRpZ2VzdCgpXG4gICAgdGVtcCA9IEJ1ZmZlci5jb25jYXQoWyB0ZW1wLCB0aGlzLl9WIF0pXG4gIH1cblxuICB0aGlzLl91cGRhdGUoYWRkKVxuICB0aGlzLl9yZXNlZWQgKz0gMVxuICByZXR1cm4gdGVtcC5zbGljZSgwLCBsZW4pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSG1hY0RSQkdcbiIsIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgb3B0aW1pemVkID0gcmVxdWlyZSgnLi9vcHRpbWl6ZWQnKVxuXG5mdW5jdGlvbiBCTiAoKSB7XG4gIHRoaXMubmVnYXRpdmUgPSAwXG4gIHRoaXMud29yZHMgPSBudWxsXG4gIHRoaXMubGVuZ3RoID0gMFxufVxuXG5CTi5mcm9tTnVtYmVyID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIGJuID0gbmV3IEJOKClcbiAgYm4ud29yZHMgPSBbbiAmIDB4MDNmZmZmZmZdXG4gIGJuLmxlbmd0aCA9IDFcbiAgcmV0dXJuIGJuXG59XG5cbkJOLmZyb21CdWZmZXIgPSBmdW5jdGlvbiAoYjMyKSB7XG4gIHZhciBibiA9IG5ldyBCTigpXG5cbiAgYm4ud29yZHMgPSBuZXcgQXJyYXkoMTApXG4gIGJuLndvcmRzWzBdID0gKGIzMlsyOF0gJiAweDAzKSA8PCAyNCB8IGIzMlsyOV0gPDwgMTYgfCBiMzJbMzBdIDw8IDggfCBiMzJbMzFdXG4gIGJuLndvcmRzWzFdID0gKGIzMlsyNV0gJiAweDBGKSA8PCAyMiB8IGIzMlsyNl0gPDwgMTQgfCBiMzJbMjddIDw8IDYgfCBiMzJbMjhdID4+PiAyXG4gIGJuLndvcmRzWzJdID0gKGIzMlsyMl0gJiAweDNGKSA8PCAyMCB8IGIzMlsyM10gPDwgMTIgfCBiMzJbMjRdIDw8IDQgfCBiMzJbMjVdID4+PiA0XG4gIGJuLndvcmRzWzNdID0gKGIzMlsxOV0gJiAweEZGKSA8PCAxOCB8IGIzMlsyMF0gPDwgMTAgfCBiMzJbMjFdIDw8IDIgfCBiMzJbMjJdID4+PiA2XG5cbiAgYm4ud29yZHNbNF0gPSAoYjMyWzE1XSAmIDB4MDMpIDw8IDI0IHwgYjMyWzE2XSA8PCAxNiB8IGIzMlsxN10gPDwgOCB8IGIzMlsxOF1cbiAgYm4ud29yZHNbNV0gPSAoYjMyWzEyXSAmIDB4MEYpIDw8IDIyIHwgYjMyWzEzXSA8PCAxNCB8IGIzMlsxNF0gPDwgNiB8IGIzMlsxNV0gPj4+IDJcbiAgYm4ud29yZHNbNl0gPSAoYjMyWzldICYgMHgzRikgPDwgMjAgfCBiMzJbMTBdIDw8IDEyIHwgYjMyWzExXSA8PCA0IHwgYjMyWzEyXSA+Pj4gNFxuICBibi53b3Jkc1s3XSA9IChiMzJbNl0gJiAweEZGKSA8PCAxOCB8IGIzMls3XSA8PCAxMCB8IGIzMls4XSA8PCAyIHwgYjMyWzldID4+PiA2XG5cbiAgYm4ud29yZHNbOF0gPSAoYjMyWzJdICYgMHgwMykgPDwgMjQgfCBiMzJbM10gPDwgMTYgfCBiMzJbNF0gPDwgOCB8IGIzMls1XVxuICBibi53b3Jkc1s5XSA9IGIzMlswXSA8PCAxNCB8IGIzMlsxXSA8PCA2IHwgYjMyWzJdID4+PiAyXG5cbiAgYm4ubGVuZ3RoID0gMTBcbiAgcmV0dXJuIGJuLnN0cmlwKClcbn1cblxuQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdyA9IHRoaXMud29yZHNcbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoOyBpIDwgMTA7ICsraSkgd1tpXSA9IDBcblxuICByZXR1cm4gQnVmZmVyLmZyb20oW1xuICAgICh3WzldID4+PiAxNCkgJiAweEZGLCAod1s5XSA+Pj4gNikgJiAweEZGLCAod1s5XSAmIDB4M0YpIDw8IDIgfCAoKHdbOF0gPj4+IDI0KSAmIDB4MDMpLCAvLyAwLCAxLCAyXG4gICAgKHdbOF0gPj4+IDE2KSAmIDB4RkYsICh3WzhdID4+PiA4KSAmIDB4RkYsIHdbOF0gJiAweEZGLCAvLyAzLCA0LCA1XG5cbiAgICAod1s3XSA+Pj4gMTgpICYgMHhGRiwgKHdbN10gPj4+IDEwKSAmIDB4RkYsICh3WzddID4+PiAyKSAmIDB4RkYsIC8vIDYsIDcsIDhcbiAgICAoKHdbN10gJiAweDAzKSA8PCA2KSB8ICgod1s2XSA+Pj4gMjApICYgMHgzRiksICh3WzZdID4+PiAxMikgJiAweEZGLCAod1s2XSA+Pj4gNCkgJiAweEZGLCAvLyA5LCAxMCwgMTFcbiAgICAoKHdbNl0gJiAweDBGKSA8PCA0KSB8ICgod1s1XSA+Pj4gMjIpICYgMHgwRiksICh3WzVdID4+PiAxNCkgJiAweEZGLCAod1s1XSA+Pj4gNikgJiAweEZGLCAvLyAxMiwgMTMsIDE0XG4gICAgKCh3WzVdICYgMHgzRikgPDwgMikgfCAoKHdbNF0gPj4+IDI0KSAmIDB4MDMpLCAod1s0XSA+Pj4gMTYpICYgMHhGRiwgKHdbNF0gPj4+IDgpICYgMHhGRiwgd1s0XSAmIDB4RkYsIC8vIDE1LCAxNiwgMTcsIDE4XG5cbiAgICAod1szXSA+Pj4gMTgpICYgMHhGRiwgKHdbM10gPj4+IDEwKSAmIDB4RkYsICh3WzNdID4+PiAyKSAmIDB4RkYsIC8vIDE5LCAyMCwgMjFcbiAgICAoKHdbM10gJiAweDAzKSA8PCA2KSB8ICgod1syXSA+Pj4gMjApICYgMHgzRiksICh3WzJdID4+PiAxMikgJiAweEZGLCAod1syXSA+Pj4gNCkgJiAweEZGLCAvLyAyMiwgMjMsIDI0XG4gICAgKCh3WzJdICYgMHgwRikgPDwgNCkgfCAoKHdbMV0gPj4+IDIyKSAmIDB4MEYpLCAod1sxXSA+Pj4gMTQpICYgMHhGRiwgKHdbMV0gPj4+IDYpICYgMHhGRiwgLy8gMjUsIDI2LCAyN1xuICAgICgod1sxXSAmIDB4M0YpIDw8IDIpIHwgKCh3WzBdID4+PiAyNCkgJiAweDAzKSwgKHdbMF0gPj4+IDE2KSAmIDB4RkYsICh3WzBdID4+PiA4KSAmIDB4RkYsIHdbMF0gJiAweEZGIC8vIDI4LCAyOSwgMzAsIDMxXG4gIF0pXG59XG5cbkJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSBuZXcgQk4oKVxuICByLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHIud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldXG4gIHIubGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgci5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmVcbiAgcmV0dXJuIHJcbn1cblxuQk4ucHJvdG90eXBlLnN0cmlwID0gZnVuY3Rpb24gKCkge1xuICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmICh0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gfCAwKSA9PT0gMCkgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gdGhpc1xufVxuXG5CTi5wcm90b3R5cGUubm9ybVNpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIC0wID0gMFxuICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkgdGhpcy5uZWdhdGl2ZSA9IDBcbiAgcmV0dXJuIHRoaXNcbn1cblxuQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDBcbn1cblxuQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMVxufVxuXG5CTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMFxufVxuXG5CTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgaWYgKHRoaXMubGVuZ3RoICE9PSBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoID8gMSA6IC0xXG5cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAodGhpcy53b3Jkc1tpXSAhPT0gbnVtLndvcmRzW2ldKSByZXR1cm4gdGhpcy53b3Jkc1tpXSA+IG51bS53b3Jkc1tpXSA/IDEgOiAtMVxuICB9XG5cbiAgcmV0dXJuIDBcbn1cblxuQk4ucHJvdG90eXBlLmd0T25lID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGggPiAxIHx8IHRoaXMud29yZHNbMF0gPiAxXG59XG5cbkJOLnByb3RvdHlwZS5pc092ZXJmbG93ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy51Y21wKEJOLm4pID49IDBcbn1cblxuQk4ucHJvdG90eXBlLmlzSGlnaCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudWNtcChCTi5uaCkgPT09IDFcbn1cblxuQk4ucHJvdG90eXBlLmJpdExlbmd0aEdUMjU2ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGggPiAxMCB8fCAodGhpcy5sZW5ndGggPT09IDEwICYmIHRoaXMud29yZHNbOV0gPiAweDAwM2ZmZmZmKVxufVxuXG5CTi5wcm90b3R5cGUuaXVhZGRuID0gZnVuY3Rpb24gKG51bSkge1xuICB0aGlzLndvcmRzWzBdICs9IG51bVxuXG4gIGZvciAodmFyIGkgPSAwOyB0aGlzLndvcmRzW2ldID4gMHgwM2ZmZmZmZiAmJiBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgIHRoaXMud29yZHNbaV0gLT0gMHgwNDAwMDAwMFxuICAgIHRoaXMud29yZHNbaSArIDFdICs9IDFcbiAgfVxuXG4gIGlmIChpID09PSB0aGlzLmxlbmd0aCkge1xuICAgIHRoaXMud29yZHNbaV0gPSAxXG4gICAgdGhpcy5sZW5ndGggKz0gMVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIC8vICgtdGhpcykgKyBudW0gLT4gLSh0aGlzIC0gbnVtKVxuICAvLyB0aGlzICsgKC1udW0pIC0+IHRoaXMgLSBudW1cbiAgaWYgKHRoaXMubmVnYXRpdmUgIT09IG51bS5uZWdhdGl2ZSkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMFxuICAgICAgdGhpcy5pc3ViKG51bSlcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMVxuICAgIH0gZWxzZSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwXG4gICAgICB0aGlzLmlzdWIobnVtKVxuICAgICAgbnVtLm5lZ2F0aXZlID0gMVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm5vcm1TaWduKClcbiAgfVxuXG4gIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgdmFyIGFcbiAgdmFyIGJcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgIGEgPSB0aGlzXG4gICAgYiA9IG51bVxuICB9IGVsc2Uge1xuICAgIGEgPSBudW1cbiAgICBiID0gdGhpc1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGNhcnJ5ID0gMDsgaSA8IGIubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgd29yZCA9IGEud29yZHNbaV0gKyBiLndvcmRzW2ldICsgY2FycnlcbiAgICB0aGlzLndvcmRzW2ldID0gd29yZCAmIDB4MDNmZmZmZmZcbiAgICBjYXJyeSA9IHdvcmQgPj4+IDI2XG4gIH1cblxuICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICB3b3JkID0gYS53b3Jkc1tpXSArIGNhcnJ5XG4gICAgdGhpcy53b3Jkc1tpXSA9IHdvcmQgJiAweDAzZmZmZmZmXG4gICAgY2FycnkgPSB3b3JkID4+PiAyNlxuICB9XG5cbiAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aFxuICBpZiAoY2FycnkgIT09IDApIHtcbiAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gY2FycnlcbiAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pXG59XG5cbkJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gKG51bSkge1xuICAvLyAoLXRoaXMpIC0gbnVtIC0+IC0odGhpcyArIG51bSlcbiAgLy8gdGhpcyAtICgtbnVtKSAtPiB0aGlzICsgbnVtXG4gIGlmICh0aGlzLm5lZ2F0aXZlICE9PSBudW0ubmVnYXRpdmUpIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDBcbiAgICAgIHRoaXMuaWFkZChudW0pXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMVxuICAgIH0gZWxzZSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwXG4gICAgICB0aGlzLmlhZGQobnVtKVxuICAgICAgbnVtLm5lZ2F0aXZlID0gMVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm5vcm1TaWduKClcbiAgfVxuXG4gIHZhciBjbXAgPSB0aGlzLnVjbXAobnVtKVxuICBpZiAoY21wID09PSAwKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDBcbiAgICB0aGlzLndvcmRzWzBdID0gMFxuICAgIHRoaXMubGVuZ3RoID0gMVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBhID4gYlxuICB2YXIgYVxuICB2YXIgYlxuICBpZiAoY21wID4gMCkge1xuICAgIGEgPSB0aGlzXG4gICAgYiA9IG51bVxuICB9IGVsc2Uge1xuICAgIGEgPSBudW1cbiAgICBiID0gdGhpc1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGNhcnJ5ID0gMDsgaSA8IGIubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgd29yZCA9IGEud29yZHNbaV0gLSBiLndvcmRzW2ldICsgY2FycnlcbiAgICBjYXJyeSA9IHdvcmQgPj4gMjZcbiAgICB0aGlzLndvcmRzW2ldID0gd29yZCAmIDB4MDNmZmZmZmZcbiAgfVxuXG4gIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgIHdvcmQgPSBhLndvcmRzW2ldICsgY2FycnlcbiAgICBjYXJyeSA9IHdvcmQgPj4gMjZcbiAgICB0aGlzLndvcmRzW2ldID0gd29yZCAmIDB4MDNmZmZmZmZcbiAgfVxuXG4gIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7ICsraSkgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV1cbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpXG5cbiAgaWYgKGEgIT09IHRoaXMpIHRoaXMubmVnYXRpdmUgXj0gMVxuXG4gIHJldHVybiB0aGlzLnN0cmlwKCkubm9ybVNpZ24oKVxufVxuXG5CTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKVxufVxuXG5CTi51bXVsVG8gPSBmdW5jdGlvbiAobnVtMSwgbnVtMiwgb3V0KSB7XG4gIG91dC5sZW5ndGggPSBudW0xLmxlbmd0aCArIG51bTIubGVuZ3RoIC0gMVxuXG4gIHZhciBhMSA9IG51bTEud29yZHNbMF1cbiAgdmFyIGIxID0gbnVtMi53b3Jkc1swXVxuICB2YXIgcjEgPSBhMSAqIGIxXG5cbiAgdmFyIGNhcnJ5ID0gKHIxIC8gMHgwNDAwMDAwMCkgfCAwXG4gIG91dC53b3Jkc1swXSA9IHIxICYgMHgwM2ZmZmZmZlxuXG4gIGZvciAodmFyIGsgPSAxLCBtYXhLID0gb3V0Lmxlbmd0aDsgayA8IG1heEs7IGsrKykge1xuICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjZcbiAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4MDNmZmZmZmZcbiAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIG51bTEubGVuZ3RoICsgMSksIG1heEogPSBNYXRoLm1pbihrLCBudW0yLmxlbmd0aCAtIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgdmFyIGkgPSBrIC0galxuICAgICAgdmFyIGEgPSBudW0xLndvcmRzW2ldXG4gICAgICB2YXIgYiA9IG51bTIud29yZHNbal1cbiAgICAgIHZhciByID0gYSAqIGIgKyByd29yZFxuICAgICAgbmNhcnJ5ICs9IChyIC8gMHgwNDAwMDAwMCkgfCAwXG4gICAgICByd29yZCA9IHIgJiAweDAzZmZmZmZmXG4gICAgfVxuICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkXG4gICAgY2FycnkgPSBuY2FycnlcbiAgfVxuXG4gIGlmIChjYXJyeSAhPT0gMCkgb3V0LndvcmRzW291dC5sZW5ndGgrK10gPSBjYXJyeVxuXG4gIHJldHVybiBvdXQuc3RyaXAoKVxufVxuXG5CTi51bXVsVG8xMHgxMCA9IE1hdGguaW11bCA/IG9wdGltaXplZC51bXVsVG8xMHgxMCA6IEJOLnVtdWxUb1xuXG5CTi51bXVsblRvID0gZnVuY3Rpb24gKG51bSwgaywgb3V0KSB7XG4gIGlmIChrID09PSAwKSB7XG4gICAgb3V0LndvcmRzID0gWzBdXG4gICAgb3V0Lmxlbmd0aCA9IDFcbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgY2FycnkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHIgPSBudW0ud29yZHNbaV0gKiBrICsgY2FycnlcbiAgICBvdXQud29yZHNbaV0gPSByICYgMHgwM2ZmZmZmZlxuICAgIGNhcnJ5ID0gKHIgLyAweDA0MDAwMDAwKSB8IDBcbiAgfVxuXG4gIGlmIChjYXJyeSA+IDApIHtcbiAgICBvdXQud29yZHNbaV0gPSBjYXJyeVxuICAgIG91dC5sZW5ndGggPSBudW0ubGVuZ3RoICsgMVxuICB9IGVsc2Uge1xuICAgIG91dC5sZW5ndGggPSBudW0ubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbkJOLnByb3RvdHlwZS51bXVsID0gZnVuY3Rpb24gKG51bSkge1xuICB2YXIgb3V0ID0gbmV3IEJOKClcbiAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aClcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKSB7XG4gICAgcmV0dXJuIEJOLnVtdWxUbzEweDEwKHRoaXMsIG51bSwgb3V0KVxuICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIEJOLnVtdWxuVG8obnVtLCB0aGlzLndvcmRzWzBdLCBvdXQpXG4gIH0gZWxzZSBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBCTi51bXVsblRvKHRoaXMsIG51bS53b3Jkc1swXSwgb3V0KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBCTi51bXVsVG8odGhpcywgbnVtLCBvdXQpXG4gIH1cbn1cblxuQk4ucHJvdG90eXBlLmlzcGxpdCA9IGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgb3V0cHV0Lmxlbmd0aCA9IE1hdGgubWluKHRoaXMubGVuZ3RoLCA5KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7ICsraSkgb3V0cHV0LndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXVxuXG4gIGlmICh0aGlzLmxlbmd0aCA8PSA5KSB7XG4gICAgdGhpcy53b3Jkc1swXSA9IDBcbiAgICB0aGlzLmxlbmd0aCA9IDFcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gU2hpZnQgYnkgOSBsaW1ic1xuICB2YXIgcHJldiA9IHRoaXMud29yZHNbOV1cbiAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgMHgwMDNmZmZmZlxuXG4gIGZvciAoaSA9IDEwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciB3b3JkID0gdGhpcy53b3Jkc1tpXVxuICAgIHRoaXMud29yZHNbaSAtIDEwXSA9ICgod29yZCAmIDB4MDAzZmZmZmYpIDw8IDQpIHwgKHByZXYgPj4+IDIyKVxuICAgIHByZXYgPSB3b3JkXG4gIH1cbiAgcHJldiA+Pj49IDIyXG4gIHRoaXMud29yZHNbaSAtIDEwXSA9IHByZXZcblxuICBpZiAocHJldiA9PT0gMCAmJiB0aGlzLmxlbmd0aCA+IDEwKSB7XG4gICAgdGhpcy5sZW5ndGggLT0gMTBcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxlbmd0aCAtPSA5XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5CTi5wcm90b3R5cGUuZmlyZWR1Y2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmlzT3ZlcmZsb3coKSkgdGhpcy5pc3ViKEJOLm4pXG4gIHJldHVybiB0aGlzXG59XG5cbkJOLnByb3RvdHlwZS51cmVkdWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbnVtID0gdGhpcy5jbG9uZSgpLmlzcGxpdChCTi50bXApLnVtdWwoQk4ubmMpLmlhZGQoQk4udG1wKVxuICBpZiAobnVtLmJpdExlbmd0aEdUMjU2KCkpIHtcbiAgICBudW0gPSBudW0uaXNwbGl0KEJOLnRtcCkudW11bChCTi5uYykuaWFkZChCTi50bXApXG4gICAgaWYgKG51bS5iaXRMZW5ndGhHVDI1NigpKSBudW0gPSBudW0uaXNwbGl0KEJOLnRtcCkudW11bChCTi5uYykuaWFkZChCTi50bXApXG4gIH1cblxuICByZXR1cm4gbnVtLmZpcmVkdWNlKClcbn1cblxuQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIG1hc2sgPSAoMSA8PCBuKSAtIDFcbiAgdmFyIG0gPSAyNiAtIG5cblxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxLCBjYXJyeSA9IDA7IGkgPj0gMDsgLS1pKSB7XG4gICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldXG4gICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCBtKSB8ICh3b3JkID4+PiBuKVxuICAgIGNhcnJ5ID0gd29yZCAmIG1hc2tcbiAgfVxuXG4gIGlmICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB0aGlzLmxlbmd0aCAtPSAxXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQk4ucHJvdG90eXBlLnVpbnZtID0gZnVuY3Rpb24gKCkge1xuICB2YXIgeCA9IHRoaXMuY2xvbmUoKVxuICB2YXIgeSA9IEJOLm4uY2xvbmUoKVxuXG4gIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gIHZhciBBID0gQk4uZnJvbU51bWJlcigxKVxuICB2YXIgQiA9IEJOLmZyb21OdW1iZXIoMClcblxuICAvLyBDICogeCArIEQgKiB5ID0geVxuICB2YXIgQyA9IEJOLmZyb21OdW1iZXIoMClcbiAgdmFyIEQgPSBCTi5mcm9tTnVtYmVyKDEpXG5cbiAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgIGZvciAodmFyIGsgPSAxLCBtID0gMTsgKHgud29yZHNbMF0gJiBtKSA9PT0gMCAmJiAoeS53b3Jkc1swXSAmIG0pID09PSAwICYmIGsgPCAyNjsgKytrLCBtIDw8PSAxKTtcbiAgICB4LmlzaHJuKGspXG4gICAgeS5pc2hybihrKVxuICB9XG5cbiAgdmFyIHlwID0geS5jbG9uZSgpXG4gIHZhciB4cCA9IHguY2xvbmUoKVxuXG4gIHdoaWxlICgheC5pc1plcm8oKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7ICh4LndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICB4LmlzaHJuKGkpXG4gICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuICAgICAgICAgIEEuaWFkZCh5cClcbiAgICAgICAgICBCLmlzdWIoeHApXG4gICAgICAgIH1cblxuICAgICAgICBBLmlzaHJuKDEpXG4gICAgICAgIEIuaXNocm4oMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgIGlmIChqID4gMCkge1xuICAgICAgeS5pc2hybihqKVxuICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgaWYgKEMuaXNPZGQoKSB8fCBELmlzT2RkKCkpIHtcbiAgICAgICAgICBDLmlhZGQoeXApXG4gICAgICAgICAgRC5pc3ViKHhwKVxuICAgICAgICB9XG5cbiAgICAgICAgQy5pc2hybigxKVxuICAgICAgICBELmlzaHJuKDEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHgudWNtcCh5KSA+PSAwKSB7XG4gICAgICB4LmlzdWIoeSlcbiAgICAgIEEuaXN1YihDKVxuICAgICAgQi5pc3ViKEQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHkuaXN1Yih4KVxuICAgICAgQy5pc3ViKEEpXG4gICAgICBELmlzdWIoQilcbiAgICB9XG4gIH1cblxuICBpZiAoQy5uZWdhdGl2ZSA9PT0gMSkge1xuICAgIEMubmVnYXRpdmUgPSAwXG4gICAgdmFyIHJlc3VsdCA9IEMudXJlZHVjZSgpXG4gICAgcmVzdWx0Lm5lZ2F0aXZlIF49IDFcbiAgICByZXR1cm4gcmVzdWx0Lm5vcm1TaWduKCkuaWFkZChCTi5uKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBDLnVyZWR1Y2UoKVxuICB9XG59XG5cbkJOLnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSAwXG4gIHRoaXMud29yZHNbdGhpcy5sZW5ndGggKyAxXSA9IDBcbiAgdGhpcy5sZW5ndGggKz0gMlxuXG4gIGZvciAodmFyIGkgPSAwLCBsbyA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMFxuICAgIGxvICs9IHcgKiAweDNkMVxuICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4MDNmZmZmZmZcbiAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4MDQwMDAwMDApIHwgMClcbiAgfVxuXG4gIGlmICh0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICB0aGlzLmxlbmd0aCAtPSAxXG4gICAgaWYgKHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMCkgdGhpcy5sZW5ndGggLT0gMVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQk4ucHJvdG90eXBlLnJlZElSZWR1Y2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaXNwbGl0KEJOLnRtcCkuaW11bEsoKS5pYWRkKEJOLnRtcClcbiAgaWYgKHRoaXMuYml0TGVuZ3RoR1QyNTYoKSkgdGhpcy5pc3BsaXQoQk4udG1wKS5pbXVsSygpLmlhZGQoQk4udG1wKVxuXG4gIHZhciBjbXAgPSB0aGlzLnVjbXAoQk4ucClcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIHRoaXMud29yZHNbMF0gPSAwXG4gICAgdGhpcy5sZW5ndGggPSAxXG4gIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgIHRoaXMuaXN1YihCTi5wKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RyaXAoKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBCTi5mcm9tTnVtYmVyKDApXG5cbiAgcmV0dXJuIEJOLnAuc3ViKHRoaXMpXG59XG5cbkJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkucmVkSUFkZChudW0pXG59XG5cbkJOLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gKG51bSkge1xuICB0aGlzLmlhZGQobnVtKVxuICBpZiAodGhpcy51Y21wKEJOLnApID49IDApIHRoaXMuaXN1YihCTi5wKVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkJOLnByb3RvdHlwZS5yZWRJQWRkNyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pdWFkZG4oNylcbiAgaWYgKHRoaXMudWNtcChCTi5wKSA+PSAwKSB0aGlzLmlzdWIoQk4ucClcblxuICByZXR1cm4gdGhpc1xufVxuXG5CTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLnJlZElTdWIobnVtKVxufVxuXG5CTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIChudW0pIHtcbiAgdGhpcy5pc3ViKG51bSlcbiAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHRoaXMuaWFkZChCTi5wKVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiB0aGlzLnVtdWwobnVtKS5yZWRJUmVkdWNlKClcbn1cblxuQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudW11bCh0aGlzKS5yZWRJUmVkdWNlKClcbn1cblxuQk4ucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gdGhpcy5jbG9uZSgpXG5cbiAgdmFyIHd2MiA9IHRoaXMucmVkU3FyKClcbiAgdmFyIHd2NCA9IHd2Mi5yZWRTcXIoKVxuICB2YXIgd3YxMiA9IHd2NC5yZWRTcXIoKS5yZWRNdWwod3Y0KVxuICB2YXIgd3YxNCA9IHd2MTIucmVkTXVsKHd2MilcbiAgdmFyIHd2MTUgPSB3djE0LnJlZE11bCh0aGlzKVxuXG4gIHZhciBvdXQgPSB3djE1XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNTQ7ICsraSkgb3V0ID0gb3V0LnJlZFNxcigpLnJlZFNxcigpLnJlZFNxcigpLnJlZFNxcigpLnJlZE11bCh3djE1KVxuICBvdXQgPSBvdXQucmVkU3FyKCkucmVkU3FyKCkucmVkU3FyKCkucmVkU3FyKCkucmVkTXVsKHd2MTQpXG4gIGZvciAoaSA9IDA7IGkgPCA1OyArK2kpIG91dCA9IG91dC5yZWRTcXIoKS5yZWRTcXIoKS5yZWRTcXIoKS5yZWRTcXIoKS5yZWRNdWwod3YxNSlcbiAgb3V0ID0gb3V0LnJlZFNxcigpLnJlZFNxcigpLnJlZFNxcigpLnJlZFNxcigpLnJlZE11bCh3djEyKVxuICBvdXQgPSBvdXQucmVkU3FyKCkucmVkU3FyKCkucmVkU3FyKCkucmVkU3FyKCkucmVkU3FyKCkucmVkU3FyKCkucmVkTXVsKHd2MTIpXG5cbiAgaWYgKG91dC5yZWRTcXIoKS51Y21wKHRoaXMpID09PSAwKSB7XG4gICAgcmV0dXJuIG91dFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhID0gdGhpcy5jbG9uZSgpXG4gIHZhciBiID0gQk4ucC5jbG9uZSgpXG5cbiAgdmFyIHgxID0gQk4uZnJvbU51bWJlcigxKVxuICB2YXIgeDIgPSBCTi5mcm9tTnVtYmVyKDApXG5cbiAgd2hpbGUgKGEuZ3RPbmUoKSAmJiBiLmd0T25lKCkpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgIGlmIChpID4gMCkge1xuICAgICAgYS5pc2hybihpKVxuICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgaWYgKHgxLmlzT2RkKCkpIHgxLmlhZGQoQk4ucClcbiAgICAgICAgeDEuaXNocm4oMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoYi53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgIGlmIChqID4gMCkge1xuICAgICAgYi5pc2hybihqKVxuICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgaWYgKHgyLmlzT2RkKCkpIHgyLmlhZGQoQk4ucClcbiAgICAgICAgeDIuaXNocm4oMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYS51Y21wKGIpID49IDApIHtcbiAgICAgIGEuaXN1YihiKVxuICAgICAgeDEuaXN1Yih4MilcbiAgICB9IGVsc2Uge1xuICAgICAgYi5pc3ViKGEpXG4gICAgICB4Mi5pc3ViKHgxKVxuICAgIH1cbiAgfVxuXG4gIHZhciByZXNcbiAgaWYgKGEubGVuZ3RoID09PSAxICYmIGEud29yZHNbMF0gPT09IDEpIHtcbiAgICByZXMgPSB4MVxuICB9IGVsc2Uge1xuICAgIHJlcyA9IHgyXG4gIH1cblxuICBpZiAocmVzLm5lZ2F0aXZlICE9PSAwKSByZXMuaWFkZChCTi5wKVxuXG4gIGlmIChyZXMubmVnYXRpdmUgIT09IDApIHtcbiAgICByZXMubmVnYXRpdmUgPSAwXG4gICAgcmV0dXJuIHJlcy5yZWRJUmVkdWNlKCkucmVkTmVnKClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzLnJlZElSZWR1Y2UoKVxuICB9XG59XG5cbkJOLnByb3RvdHlwZS5nZXROQUYgPSBmdW5jdGlvbiAodykge1xuICB2YXIgbmFmID0gW11cbiAgdmFyIHdzID0gMSA8PCAodyArIDEpXG4gIHZhciB3c20xID0gd3MgLSAxXG4gIHZhciB3czIgPSB3cyA+PiAxXG5cbiAgdmFyIGsgPSB0aGlzLmNsb25lKClcbiAgd2hpbGUgKCFrLmlzWmVybygpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG0gPSAxOyAoay53b3Jkc1swXSAmIG0pID09PSAwICYmIGkgPCAyNjsgKytpLCBtIDw8PSAxKSBuYWYucHVzaCgwKVxuXG4gICAgaWYgKGkgIT09IDApIHtcbiAgICAgIGsuaXNocm4oaSlcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1vZCA9IGsud29yZHNbMF0gJiB3c20xXG4gICAgICBpZiAobW9kID49IHdzMikge1xuICAgICAgICBuYWYucHVzaCh3czIgLSBtb2QpXG4gICAgICAgIGsuaXVhZGRuKG1vZCAtIHdzMikuaXNocm4oMSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hZi5wdXNoKG1vZClcbiAgICAgICAgay53b3Jkc1swXSAtPSBtb2RcbiAgICAgICAgaWYgKCFrLmlzWmVybygpKSB7XG4gICAgICAgICAgZm9yIChpID0gdyAtIDE7IGkgPiAwOyAtLWkpIG5hZi5wdXNoKDApXG4gICAgICAgICAgay5pc2hybih3KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hZlxufVxuXG5CTi5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAnMCdcblxuICB2YXIgYnVmZmVyID0gdGhpcy50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKVxuICBmb3IgKHZhciBpID0gMDsgYnVmZmVyW2ldID09PSAnMCc7ICsraSk7XG4gIHJldHVybiBidWZmZXIuc2xpY2UoaSlcbn1cblxuQk4ubiA9IEJOLmZyb21CdWZmZXIoQnVmZmVyLmZyb20oJ0ZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFQkFBRURDRTZBRjQ4QTAzQkJGRDI1RThDRDAzNjQxNDEnLCAnaGV4JykpXG5CTi5uaCA9IEJOLm4uY2xvbmUoKS5pc2hybigxKVxuQk4ubmMgPSBCTi5mcm9tQnVmZmVyKEJ1ZmZlci5mcm9tKCcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTQ1NTEyMzE5NTBCNzVGQzQ0MDJEQTE3MzJGQzlCRUJGJywgJ2hleCcpKVxuQk4ucCA9IEJOLmZyb21CdWZmZXIoQnVmZmVyLmZyb20oJ0ZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFRkZGRkZDMkYnLCAnaGV4JykpXG5CTi5wc24gPSBCTi5wLnN1YihCTi5uKVxuQk4udG1wID0gbmV3IEJOKClcbkJOLnRtcC53b3JkcyA9IG5ldyBBcnJheSgxMClcblxuLy8gV1RGPyEgaXQgc3BlZWQtdXAgYmVuY2htYXJrIG9uIH4yMCVcbjsoZnVuY3Rpb24gKCkge1xuICB2YXIgeCA9IEJOLmZyb21OdW1iZXIoMSlcbiAgeC53b3Jkc1szXSA9IDBcbn0pKClcblxubW9kdWxlLmV4cG9ydHMgPSBCTlxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBpc0hpZ2hTdXJyb2dhdGUoY29kZVBvaW50KSB7XG4gIHJldHVybiBjb2RlUG9pbnQgPj0gMHhkODAwICYmIGNvZGVQb2ludCA8PSAweGRiZmY7XG59XG5cbmZ1bmN0aW9uIGlzTG93U3Vycm9nYXRlKGNvZGVQb2ludCkge1xuICByZXR1cm4gY29kZVBvaW50ID49IDB4ZGMwMCAmJiBjb2RlUG9pbnQgPD0gMHhkZmZmO1xufVxuXG4vLyBUcnVuY2F0ZSBzdHJpbmcgYnkgc2l6ZSBpbiBieXRlc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cnVuY2F0ZShnZXRMZW5ndGgsIHN0cmluZywgYnl0ZUxlbmd0aCkge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IG11c3QgYmUgc3RyaW5nXCIpO1xuICB9XG5cbiAgdmFyIGNoYXJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB2YXIgY3VyQnl0ZUxlbmd0aCA9IDA7XG4gIHZhciBjb2RlUG9pbnQ7XG4gIHZhciBzZWdtZW50O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhckxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgc2VnbWVudCA9IHN0cmluZ1tpXTtcblxuICAgIGlmIChpc0hpZ2hTdXJyb2dhdGUoY29kZVBvaW50KSAmJiBpc0xvd1N1cnJvZ2F0ZShzdHJpbmcuY2hhckNvZGVBdChpICsgMSkpKSB7XG4gICAgICBpICs9IDE7XG4gICAgICBzZWdtZW50ICs9IHN0cmluZ1tpXTtcbiAgICB9XG5cbiAgICBjdXJCeXRlTGVuZ3RoICs9IGdldExlbmd0aChzZWdtZW50KTtcblxuICAgIGlmIChjdXJCeXRlTGVuZ3RoID09PSBieXRlTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGkgKyAxKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3VyQnl0ZUxlbmd0aCA+IGJ5dGVMZW5ndGgpIHtcbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgaSAtIHNlZ21lbnQubGVuZ3RoICsgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gaXNIaWdoU3Vycm9nYXRlKGNvZGVQb2ludCkge1xuICByZXR1cm4gY29kZVBvaW50ID49IDB4ZDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhkYmZmO1xufVxuXG5mdW5jdGlvbiBpc0xvd1N1cnJvZ2F0ZShjb2RlUG9pbnQpIHtcbiAgcmV0dXJuIGNvZGVQb2ludCA+PSAweGRjMDAgJiYgY29kZVBvaW50IDw9IDB4ZGZmZjtcbn1cblxuLy8gVHJ1bmNhdGUgc3RyaW5nIGJ5IHNpemUgaW4gYnl0ZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0Qnl0ZUxlbmd0aChzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgfVxuXG4gIHZhciBjaGFyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgdmFyIGJ5dGVMZW5ndGggPSAwO1xuICB2YXIgY29kZVBvaW50ID0gbnVsbDtcbiAgdmFyIHByZXZDb2RlUG9pbnQgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJMZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIC8vIGhhbmRsZSA0LWJ5dGUgbm9uLUJNUCBjaGFyc1xuICAgIC8vIGxvdyBzdXJyb2dhdGVcbiAgICBpZiAoaXNMb3dTdXJyb2dhdGUoY29kZVBvaW50KSkge1xuICAgICAgLy8gd2hlbiBwYXJzaW5nIHByZXZpb3VzIGhpLXN1cnJvZ2F0ZSwgMyBpcyBhZGRlZCB0byBieXRlTGVuZ3RoXG4gICAgICBpZiAocHJldkNvZGVQb2ludCAhPSBudWxsICYmIGlzSGlnaFN1cnJvZ2F0ZShwcmV2Q29kZVBvaW50KSkge1xuICAgICAgICBieXRlTGVuZ3RoICs9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYnl0ZUxlbmd0aCArPSAzO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHg3ZiApIHtcbiAgICAgIGJ5dGVMZW5ndGggKz0gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZVBvaW50ID49IDB4ODAgJiYgY29kZVBvaW50IDw9IDB4N2ZmKSB7XG4gICAgICBieXRlTGVuZ3RoICs9IDI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVQb2ludCA+PSAweDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICBieXRlTGVuZ3RoICs9IDM7XG4gICAgfVxuICAgIHByZXZDb2RlUG9pbnQgPSBjb2RlUG9pbnQ7XG4gIH1cblxuICByZXR1cm4gYnl0ZUxlbmd0aDtcbn07XG4iLCIvKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgWC41MDkgYW5kIHJlbGF0ZWQgY29tcG9uZW50cyAoc3VjaCBhc1xuICogQ2VydGlmaWNhdGlvbiBTaWduaW5nIFJlcXVlc3RzKSBvZiBhIFB1YmxpYyBLZXkgSW5mcmFzdHJ1Y3R1cmUuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIFRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIGNlcnRpZmljYXRlIGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgUkZDIDI0NTkpOlxuICpcbiAqIENlcnRpZmljYXRlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHRic0NlcnRpZmljYXRlICAgICAgIFRCU0NlcnRpZmljYXRlLFxuICogICBzaWduYXR1cmVBbGdvcml0aG0gICBBbGdvcml0aG1JZGVudGlmaWVyLFxuICogICBzaWduYXR1cmVWYWx1ZSAgICAgICBCSVQgU1RSSU5HXG4gKiB9XG4gKlxuICogVEJTQ2VydGlmaWNhdGUgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgIFswXSAgRVhQTElDSVQgVmVyc2lvbiBERUZBVUxUIHYxLFxuICogICBzZXJpYWxOdW1iZXIgICAgICAgICBDZXJ0aWZpY2F0ZVNlcmlhbE51bWJlcixcbiAqICAgc2lnbmF0dXJlICAgICAgICAgICAgQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgaXNzdWVyICAgICAgICAgICAgICAgTmFtZSxcbiAqICAgdmFsaWRpdHkgICAgICAgICAgICAgVmFsaWRpdHksXG4gKiAgIHN1YmplY3QgICAgICAgICAgICAgIE5hbWUsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXlJbmZvIFN1YmplY3RQdWJsaWNLZXlJbmZvLFxuICogICBpc3N1ZXJVbmlxdWVJRCAgWzFdICBJTVBMSUNJVCBVbmlxdWVJZGVudGlmaWVyIE9QVElPTkFMLFxuICogICAgICAgICAgICAgICAgICAgICAgICAtLSBJZiBwcmVzZW50LCB2ZXJzaW9uIHNoYWxsIGJlIHYyIG9yIHYzXG4gKiAgIHN1YmplY3RVbmlxdWVJRCBbMl0gIElNUExJQ0lUIFVuaXF1ZUlkZW50aWZpZXIgT1BUSU9OQUwsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIC0tIElmIHByZXNlbnQsIHZlcnNpb24gc2hhbGwgYmUgdjIgb3IgdjNcbiAqICAgZXh0ZW5zaW9ucyAgICAgIFszXSAgRVhQTElDSVQgRXh0ZW5zaW9ucyBPUFRJT05BTFxuICogICAgICAgICAgICAgICAgICAgICAgICAtLSBJZiBwcmVzZW50LCB2ZXJzaW9uIHNoYWxsIGJlIHYzXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUiAgeyB2MSgwKSwgdjIoMSksIHYzKDIpIH1cbiAqXG4gKiBDZXJ0aWZpY2F0ZVNlcmlhbE51bWJlciA6Oj0gSU5URUdFUlxuICpcbiAqIE5hbWUgOjo9IENIT0lDRSB7XG4gKiAgIC8vIG9ubHkgb25lIHBvc3NpYmxlIGNob2ljZSBmb3Igbm93XG4gKiAgIFJETlNlcXVlbmNlXG4gKiB9XG4gKlxuICogUkROU2VxdWVuY2UgOjo9IFNFUVVFTkNFIE9GIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWVcbiAqXG4gKiBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lIDo6PSBTRVQgT0YgQXR0cmlidXRlVHlwZUFuZFZhbHVlXG4gKlxuICogQXR0cmlidXRlVHlwZUFuZFZhbHVlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHR5cGUgICAgIEF0dHJpYnV0ZVR5cGUsXG4gKiAgIHZhbHVlICAgIEF0dHJpYnV0ZVZhbHVlXG4gKiB9XG4gKiBBdHRyaWJ1dGVUeXBlIDo6PSBPQkpFQ1QgSURFTlRJRklFUlxuICogQXR0cmlidXRlVmFsdWUgOjo9IEFOWSBERUZJTkVEIEJZIEF0dHJpYnV0ZVR5cGVcbiAqXG4gKiBWYWxpZGl0eSA6Oj0gU0VRVUVOQ0Uge1xuICogICBub3RCZWZvcmUgICAgICBUaW1lLFxuICogICBub3RBZnRlciAgICAgICBUaW1lXG4gKiB9XG4gKlxuICogVGltZSA6Oj0gQ0hPSUNFIHtcbiAqICAgdXRjVGltZSAgICAgICAgVVRDVGltZSxcbiAqICAgZ2VuZXJhbFRpbWUgICAgR2VuZXJhbGl6ZWRUaW1lXG4gKiB9XG4gKlxuICogVW5pcXVlSWRlbnRpZmllciA6Oj0gQklUIFNUUklOR1xuICpcbiAqIFN1YmplY3RQdWJsaWNLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGFsZ29yaXRobSAgICAgICAgICAgIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXkgICAgIEJJVCBTVFJJTkdcbiAqIH1cbiAqXG4gKiBFeHRlbnNpb25zIDo6PSBTRVFVRU5DRSBTSVpFICgxLi5NQVgpIE9GIEV4dGVuc2lvblxuICpcbiAqIEV4dGVuc2lvbiA6Oj0gU0VRVUVOQ0Uge1xuICogICBleHRuSUQgICAgICBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgY3JpdGljYWwgICAgQk9PTEVBTiBERUZBVUxUIEZBTFNFLFxuICogICBleHRuVmFsdWUgICBPQ1RFVCBTVFJJTkdcbiAqIH1cbiAqXG4gKiBUaGUgb25seSBrZXkgYWxnb3JpdGhtIGN1cnJlbnRseSBzdXBwb3J0ZWQgZm9yIFBLSSBpcyBSU0EuXG4gKlxuICogUlNBU1NBLVBTUyBzaWduYXR1cmVzIGFyZSBkZXNjcmliZWQgaW4gUkZDIDM0NDcgYW5kIFJGQyA0MDU1LlxuICpcbiAqIFBLQ1MjMTAgdjEuNyBkZXNjcmliZXMgY2VydGlmaWNhdGUgc2lnbmluZyByZXF1ZXN0czpcbiAqXG4gKiBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm86XG4gKlxuICogQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgSU5URUdFUiB7IHYxKDApIH0gKHYxLC4uLiksXG4gKiAgIHN1YmplY3QgICAgICAgTmFtZSxcbiAqICAgc3ViamVjdFBLSW5mbyBTdWJqZWN0UHVibGljS2V5SW5mb3t7IFBLSW5mb0FsZ29yaXRobXMgfX0sXG4gKiAgIGF0dHJpYnV0ZXMgICAgWzBdIEF0dHJpYnV0ZXN7eyBDUklBdHRyaWJ1dGVzIH19XG4gKiB9XG4gKlxuICogQXR0cmlidXRlcyB7IEFUVFJJQlVURTpJT1NldCB9IDo6PSBTRVQgT0YgQXR0cmlidXRle3sgSU9TZXQgfX1cbiAqXG4gKiBDUklBdHRyaWJ1dGVzICBBVFRSSUJVVEUgIDo6PSB7XG4gKiAgIC4uLiAtLSBhZGQgYW55IGxvY2FsbHkgZGVmaW5lZCBhdHRyaWJ1dGVzIGhlcmUgLS0gfVxuICpcbiAqIEF0dHJpYnV0ZSB7IEFUVFJJQlVURTpJT1NldCB9IDo6PSBTRVFVRU5DRSB7XG4gKiAgIHR5cGUgICBBVFRSSUJVVEUuJmlkKHtJT1NldH0pLFxuICogICB2YWx1ZXMgU0VUIFNJWkUoMS4uTUFYKSBPRiBBVFRSSUJVVEUuJlR5cGUoe0lPU2V0fXtAdHlwZX0pXG4gKiB9XG4gKlxuICogQ2VydGlmaWNhdGlvblJlcXVlc3QgOjo9IFNFUVVFTkNFIHtcbiAqICAgY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyxcbiAqICAgc2lnbmF0dXJlQWxnb3JpdGhtIEFsZ29yaXRobUlkZW50aWZpZXJ7eyBTaWduYXR1cmVBbGdvcml0aG1zIH19LFxuICogICBzaWduYXR1cmUgICAgICAgICAgQklUIFNUUklOR1xuICogfVxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL2FlcycpO1xucmVxdWlyZSgnLi9hc24xJyk7XG5yZXF1aXJlKCcuL2RlcycpO1xucmVxdWlyZSgnLi9tZCcpO1xucmVxdWlyZSgnLi9tZ2YnKTtcbnJlcXVpcmUoJy4vb2lkcycpO1xucmVxdWlyZSgnLi9wZW0nKTtcbnJlcXVpcmUoJy4vcHNzJyk7XG5yZXF1aXJlKCcuL3JzYScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIHNob3J0Y3V0IGZvciBhc24uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLyogUHVibGljIEtleSBJbmZyYXN0cnVjdHVyZSAoUEtJKSBpbXBsZW1lbnRhdGlvbi4gKi9cbnZhciBwa2kgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBraSA9IGZvcmdlLnBraSB8fCB7fTtcbnZhciBvaWRzID0gcGtpLm9pZHM7XG5cbi8vIHNob3J0IG5hbWUgT0lEIG1hcHBpbmdzXG52YXIgX3Nob3J0TmFtZXMgPSB7fTtcbl9zaG9ydE5hbWVzWydDTiddID0gb2lkc1snY29tbW9uTmFtZSddO1xuX3Nob3J0TmFtZXNbJ2NvbW1vbk5hbWUnXSA9ICdDTic7XG5fc2hvcnROYW1lc1snQyddID0gb2lkc1snY291bnRyeU5hbWUnXTtcbl9zaG9ydE5hbWVzWydjb3VudHJ5TmFtZSddID0gJ0MnO1xuX3Nob3J0TmFtZXNbJ0wnXSA9IG9pZHNbJ2xvY2FsaXR5TmFtZSddO1xuX3Nob3J0TmFtZXNbJ2xvY2FsaXR5TmFtZSddID0gJ0wnO1xuX3Nob3J0TmFtZXNbJ1NUJ10gPSBvaWRzWydzdGF0ZU9yUHJvdmluY2VOYW1lJ107XG5fc2hvcnROYW1lc1snc3RhdGVPclByb3ZpbmNlTmFtZSddID0gJ1NUJztcbl9zaG9ydE5hbWVzWydPJ10gPSBvaWRzWydvcmdhbml6YXRpb25OYW1lJ107XG5fc2hvcnROYW1lc1snb3JnYW5pemF0aW9uTmFtZSddID0gJ08nO1xuX3Nob3J0TmFtZXNbJ09VJ10gPSBvaWRzWydvcmdhbml6YXRpb25hbFVuaXROYW1lJ107XG5fc2hvcnROYW1lc1snb3JnYW5pemF0aW9uYWxVbml0TmFtZSddID0gJ09VJztcbl9zaG9ydE5hbWVzWydFJ10gPSBvaWRzWydlbWFpbEFkZHJlc3MnXTtcbl9zaG9ydE5hbWVzWydlbWFpbEFkZHJlc3MnXSA9ICdFJztcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBTdWJqZWN0UHVibGljS2V5SW5mbyBzdHJ1Y3R1cmVcbi8vIE5vdGU6IEN1cnJlbnRseSBvbmx5IHdvcmtzIHdpdGggYW4gUlNBIHB1YmxpYyBrZXlcbnZhciBwdWJsaWNLZXlWYWxpZGF0b3IgPSBmb3JnZS5wa2kucnNhLnB1YmxpY0tleVZhbGlkYXRvcjtcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBYLjUwOXYzIGNlcnRpZmljYXRlXG52YXIgeDUwOUNlcnRpZmljYXRlVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydGlmaWNhdGUnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ3Ric0NlcnRpZmljYXRlJyxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52ZXJzaW9uJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICB0eXBlOiAwLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmVyc2lvbi5pbnRlZ2VyJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydFZlcnNpb24nXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zZXJpYWxOdW1iZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnY2VydFNlcmlhbE51bWJlcidcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2lnbmF0dXJlJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmUuYWxnb3JpdGhtJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdjZXJ0aW5mb1NpZ25hdHVyZU9pZCdcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0aW5mb1NpZ25hdHVyZVBhcmFtcydcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmlzc3VlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnY2VydElzc3VlcidcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHknLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAvLyBOb3RlOiBVVEMgYW5kIGdlbmVyYWxpemVkIHRpbWVzIG1heSBib3RoIGFwcGVhciBzbyB0aGUgY2FwdHVyZVxuICAgICAgLy8gbmFtZXMgYXJlIGJhc2VkIG9uIHRoZWlyIGRldGVjdGVkIG9yZGVyLCB0aGUgbmFtZXMgdXNlZCBiZWxvd1xuICAgICAgLy8gYXJlIG9ubHkgZm9yIHRoZSBjb21tb24gY2FzZSwgd2hpY2ggdmFsaWRpdHkgdGltZSByZWFsbHkgbWVhbnNcbiAgICAgIC8vIFwibm90QmVmb3JlXCIgYW5kIHdoaWNoIG1lYW5zIFwibm90QWZ0ZXJcIiB3aWxsIGJlIGRldGVybWluZWQgYnkgb3JkZXJcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICAvLyBub3RCZWZvcmUgKFRpbWUpIChVVEMgdGltZSBjYXNlKVxuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QmVmb3JlICh1dGMpJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuVVRDVElNRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRWYWxpZGl0eTFVVENUaW1lJ1xuICAgICAgfSwge1xuICAgICAgICAvLyBub3RCZWZvcmUgKFRpbWUpIChnZW5lcmFsaXplZCB0aW1lIGNhc2UpXG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RCZWZvcmUgKGdlbmVyYWxpemVkKScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkdFTkVSQUxJWkVEVElNRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRWYWxpZGl0eTJHZW5lcmFsaXplZFRpbWUnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIG5vdEFmdGVyIChUaW1lKSAob25seSBVVEMgdGltZSBpcyBzdXBwb3J0ZWQpXG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RBZnRlciAodXRjKScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlVUQ1RJTUUsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6ICdjZXJ0VmFsaWRpdHkzVVRDVGltZSdcbiAgICAgIH0sIHtcbiAgICAgICAgLy8gbm90QWZ0ZXIgKFRpbWUpIChvbmx5IFVUQyB0aW1lIGlzIHN1cHBvcnRlZClcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEFmdGVyIChnZW5lcmFsaXplZCknLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5HRU5FUkFMSVpFRFRJTUUsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6ICdjZXJ0VmFsaWRpdHk0R2VuZXJhbGl6ZWRUaW1lJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAvLyBOYW1lIChzdWJqZWN0KSAoUkROU2VxdWVuY2UpXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdCcsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnY2VydFN1YmplY3QnXG4gICAgfSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHB1YmxpY0tleVZhbGlkYXRvcixcbiAgICB7XG4gICAgICAvLyBpc3N1ZXJVbmlxdWVJRCAob3B0aW9uYWwpXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyVW5pcXVlSUQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDEsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5pc3N1ZXJVbmlxdWVJRC5pZCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjZXJ0SXNzdWVyVW5pcXVlSWQnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIHN1YmplY3RVbmlxdWVJRCAob3B0aW9uYWwpXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlEJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICB0eXBlOiAyLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlELmlkJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXJiaXRyYXJ5IGJpdCBsZW5ndGggaWRzXG4gICAgICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogJ2NlcnRTdWJqZWN0VW5pcXVlSWQnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIEV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmV4dGVuc2lvbnMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDMsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnY2VydEV4dGVuc2lvbnMnLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllciAoc2lnbmF0dXJlIGFsZ29yaXRobSlcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2NlcnRTaWduYXR1cmVPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0U2lnbmF0dXJlUGFyYW1zJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5zaWduYXR1cmVWYWx1ZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogJ2NlcnRTaWduYXR1cmUnXG4gIH1dXG59O1xuXG52YXIgcnNhc3NhUHNzUGFyYW1ldGVyVmFsaWRhdG9yID0ge1xuICBuYW1lOiAncnNhcHNzJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAncnNhcHNzLmhhc2hBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdyc2Fwc3MuaGFzaEFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdyc2Fwc3MuaGFzaEFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAnaGFzaE9pZCdcbiAgICAgICAgLyogcGFyYW1ldGVyIGJsb2NrIG9taXR0ZWQsIGZvciBTSEExIE5VTEwgYW55aG93LiAqL1xuICAgICAgfV1cbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDEsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAncnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLkNsYXNzLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAncnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ21hc2tHZW5PaWQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdyc2Fwc3MubWFza0dlbkFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtcycsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtLkFsZ29yaXRobUlkZW50aWZpZXIucGFyYW1zLmFsZ29yaXRobScsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6ICdtYXNrR2VuSGFzaE9pZCdcbiAgICAgICAgICAvKiBwYXJhbWV0ZXIgYmxvY2sgb21pdHRlZCwgZm9yIFNIQTEgTlVMTCBhbnlob3cuICovXG4gICAgICAgIH1dXG4gICAgICB9XVxuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAncnNhcHNzLnNhbHRMZW5ndGgnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMixcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdyc2Fwc3Muc2FsdExlbmd0aC5zYWx0TGVuZ3RoJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuSU5URUdFUixcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdzYWx0TGVuZ3RoJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAncnNhcHNzLnRyYWlsZXJGaWVsZCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAzLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ3JzYXBzcy50cmFpbGVyLnRyYWlsZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5DbGFzcy5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3RyYWlsZXInXG4gICAgfV1cbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gc3RydWN0dXJlXG52YXIgY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICBjYXB0dXJlQXNuMTogJ2NlcnRpZmljYXRpb25SZXF1ZXN0SW5mbycsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8uaW50ZWdlcicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmVyc2lvbidcbiAgfSwge1xuICAgIC8vIE5hbWUgKHN1YmplY3QpIChSRE5TZXF1ZW5jZSlcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLnN1YmplY3QnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9TdWJqZWN0J1xuICB9LFxuICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICBwdWJsaWNLZXlWYWxpZGF0b3IsXG4gIHtcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvQXR0cmlidXRlcycsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzLnR5cGUnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMudmFsdWUnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlXG4gICAgICB9XVxuICAgIH1dXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgQ2VydGlmaWNhdGlvblJlcXVlc3Qgc3RydWN0dXJlXG52YXIgY2VydGlmaWNhdGlvblJlcXVlc3RWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdCcsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgY2FwdHVyZUFzbjE6ICdjc3InLFxuICB2YWx1ZTogW1xuICAgIGNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1ZhbGlkYXRvciwge1xuICAgICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllciAoc2lnbmF0dXJlIGFsZ29yaXRobSlcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdC5zaWduYXR1cmVBbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdC5zaWduYXR1cmVBbGdvcml0aG0uYWxnb3JpdGhtJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdjc3JTaWduYXR1cmVPaWQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdC5zaWduYXR1cmVBbGdvcml0aG0ucGFyYW1ldGVycycsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmVBc24xOiAnY3NyU2lnbmF0dXJlUGFyYW1zJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAvLyBzaWduYXR1cmVcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdC5zaWduYXR1cmUnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogJ2NzclNpZ25hdHVyZSdcbiAgICB9XG4gIF1cbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUkROU2VxdWVuY2Ugb2YgQVNOLjEgREVSLWVuY29kZWQgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZVxuICogc2V0cyBpbnRvIGFuIGFycmF5IHdpdGggb2JqZWN0cyB0aGF0IGhhdmUgdHlwZSBhbmQgdmFsdWUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0gcmRuIHRoZSBSRE5TZXF1ZW5jZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIG1kIGEgbWVzc2FnZSBkaWdlc3QgdG8gYXBwZW5kIHR5cGUgYW5kIHZhbHVlIHRvIGlmIHByb3ZpZGVkLlxuICovXG5wa2kuUkROQXR0cmlidXRlc0FzQXJyYXkgPSBmdW5jdGlvbihyZG4sIG1kKSB7XG4gIHZhciBydmFsID0gW107XG5cbiAgLy8gZWFjaCB2YWx1ZSBpbiAncmRuJyBpbiBpcyBhIFNFVCBvZiBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lXG4gIHZhciBzZXQsIGF0dHIsIG9iajtcbiAgZm9yKHZhciBzaSA9IDA7IHNpIDwgcmRuLnZhbHVlLmxlbmd0aDsgKytzaSkge1xuICAgIC8vIGdldCB0aGUgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSBzZXRcbiAgICBzZXQgPSByZG4udmFsdWVbc2ldO1xuXG4gICAgLy8gZWFjaCB2YWx1ZSBpbiB0aGUgU0VUIGlzIGFuIEF0dHJpYnV0ZVR5cGVBbmRWYWx1ZSBzZXF1ZW5jZVxuICAgIC8vIGNvbnRhaW5pbmcgZmlyc3QgYSB0eXBlIChhbiBPSUQpIGFuZCBzZWNvbmQgYSB2YWx1ZSAoZGVmaW5lZCBieVxuICAgIC8vIHRoZSBPSUQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNldC52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgb2JqID0ge307XG4gICAgICBhdHRyID0gc2V0LnZhbHVlW2ldO1xuICAgICAgb2JqLnR5cGUgPSBhc24xLmRlclRvT2lkKGF0dHIudmFsdWVbMF0udmFsdWUpO1xuICAgICAgb2JqLnZhbHVlID0gYXR0ci52YWx1ZVsxXS52YWx1ZTtcbiAgICAgIG9iai52YWx1ZVRhZ0NsYXNzID0gYXR0ci52YWx1ZVsxXS50eXBlO1xuICAgICAgLy8gaWYgdGhlIE9JRCBpcyBrbm93biwgZ2V0IGl0cyBuYW1lIGFuZCBzaG9ydCBuYW1lXG4gICAgICBpZihvYmoudHlwZSBpbiBvaWRzKSB7XG4gICAgICAgIG9iai5uYW1lID0gb2lkc1tvYmoudHlwZV07XG4gICAgICAgIGlmKG9iai5uYW1lIGluIF9zaG9ydE5hbWVzKSB7XG4gICAgICAgICAgb2JqLnNob3J0TmFtZSA9IF9zaG9ydE5hbWVzW29iai5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYobWQpIHtcbiAgICAgICAgbWQudXBkYXRlKG9iai50eXBlKTtcbiAgICAgICAgbWQudXBkYXRlKG9iai52YWx1ZSk7XG4gICAgICB9XG4gICAgICBydmFsLnB1c2gob2JqKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgQVNOLjEgQ1JJQXR0cmlidXRlcyBpbnRvIGFuIGFycmF5IHdpdGggb2JqZWN0cyB0aGF0IGhhdmUgdHlwZSBhbmRcbiAqIHZhbHVlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIGF0dHJpYnV0ZXMgdGhlIENSSUF0dHJpYnV0ZXMgdG8gY29udmVydC5cbiAqL1xucGtpLkNSSUF0dHJpYnV0ZXNBc0FycmF5ID0gZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICB2YXIgcnZhbCA9IFtdO1xuXG4gIC8vIGVhY2ggdmFsdWUgaW4gJ2F0dHJpYnV0ZXMnIGluIGlzIGEgU0VRVUVOQ0Ugd2l0aCBhbiBPSUQgYW5kIGEgU0VUXG4gIGZvcih2YXIgc2kgPSAwOyBzaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArK3NpKSB7XG4gICAgLy8gZ2V0IHRoZSBhdHRyaWJ1dGUgc2VxdWVuY2VcbiAgICB2YXIgc2VxID0gYXR0cmlidXRlc1tzaV07XG5cbiAgICAvLyBlYWNoIHZhbHVlIGluIHRoZSBTRVFVRU5DRSBjb250YWluaW5nIGZpcnN0IGEgdHlwZSAoYW4gT0lEKSBhbmRcbiAgICAvLyBzZWNvbmQgYSBzZXQgb2YgdmFsdWVzIChkZWZpbmVkIGJ5IHRoZSBPSUQpXG4gICAgdmFyIHR5cGUgPSBhc24xLmRlclRvT2lkKHNlcS52YWx1ZVswXS52YWx1ZSk7XG4gICAgdmFyIHZhbHVlcyA9IHNlcS52YWx1ZVsxXS52YWx1ZTtcbiAgICBmb3IodmFyIHZpID0gMDsgdmkgPCB2YWx1ZXMubGVuZ3RoOyArK3ZpKSB7XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICBvYmoudHlwZSA9IHR5cGU7XG4gICAgICBvYmoudmFsdWUgPSB2YWx1ZXNbdmldLnZhbHVlO1xuICAgICAgb2JqLnZhbHVlVGFnQ2xhc3MgPSB2YWx1ZXNbdmldLnR5cGU7XG4gICAgICAvLyBpZiB0aGUgT0lEIGlzIGtub3duLCBnZXQgaXRzIG5hbWUgYW5kIHNob3J0IG5hbWVcbiAgICAgIGlmKG9iai50eXBlIGluIG9pZHMpIHtcbiAgICAgICAgb2JqLm5hbWUgPSBvaWRzW29iai50eXBlXTtcbiAgICAgICAgaWYob2JqLm5hbWUgaW4gX3Nob3J0TmFtZXMpIHtcbiAgICAgICAgICBvYmouc2hvcnROYW1lID0gX3Nob3J0TmFtZXNbb2JqLm5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBwYXJzZSBleHRlbnNpb25zXG4gICAgICBpZihvYmoudHlwZSA9PT0gb2lkcy5leHRlbnNpb25SZXF1ZXN0KSB7XG4gICAgICAgIG9iai5leHRlbnNpb25zID0gW107XG4gICAgICAgIGZvcih2YXIgZWkgPSAwOyBlaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsrZWkpIHtcbiAgICAgICAgICBvYmouZXh0ZW5zaW9ucy5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xKG9iai52YWx1ZVtlaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcnZhbC5wdXNoKG9iaik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gaXNzdWVyIG9yIHN1YmplY3QgYXR0cmlidXRlIGZyb20gaXRzIG5hbWUsIHR5cGUsIG9yIHNob3J0IG5hbWUuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgaXNzdWVyIG9yIHN1YmplY3Qgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMgYSBzaG9ydCBuYW1lIHN0cmluZyBvciBhbiBvYmplY3Qgd2l0aDpcbiAqICAgICAgICAgIHNob3J0TmFtZSB0aGUgc2hvcnQgbmFtZSBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAqICAgICAgICAgIG5hbWUgdGhlIG5hbWUgZm9yIHRoZSBhdHRyaWJ1dGUuXG4gKiAgICAgICAgICB0eXBlIHRoZSB0eXBlIGZvciB0aGUgYXR0cmlidXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIGF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gX2dldEF0dHJpYnV0ZShvYmosIG9wdGlvbnMpIHtcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHtzaG9ydE5hbWU6IG9wdGlvbnN9O1xuICB9XG5cbiAgdmFyIHJ2YWwgPSBudWxsO1xuICB2YXIgYXR0cjtcbiAgZm9yKHZhciBpID0gMDsgcnZhbCA9PT0gbnVsbCAmJiBpIDwgb2JqLmF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBhdHRyID0gb2JqLmF0dHJpYnV0ZXNbaV07XG4gICAgaWYob3B0aW9ucy50eXBlICYmIG9wdGlvbnMudHlwZSA9PT0gYXR0ci50eXBlKSB7XG4gICAgICBydmFsID0gYXR0cjtcbiAgICB9IGVsc2UgaWYob3B0aW9ucy5uYW1lICYmIG9wdGlvbnMubmFtZSA9PT0gYXR0ci5uYW1lKSB7XG4gICAgICBydmFsID0gYXR0cjtcbiAgICB9IGVsc2UgaWYob3B0aW9ucy5zaG9ydE5hbWUgJiYgb3B0aW9ucy5zaG9ydE5hbWUgPT09IGF0dHIuc2hvcnROYW1lKSB7XG4gICAgICBydmFsID0gYXR0cjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtZXRlcnMgZnJvbSBBU04uMSBzdHJ1Y3R1cmUuXG4gKlxuICogQ3VycmVudGx5IG9ubHkgUlNBU1NBLVBTUyBzdXBwb3J0ZWQuICBUaGUgUEtDUyMxIHYxLjUgc2lnbmF0dXJlIHNjaGVtZSBoYWRcbiAqIG5vIHBhcmFtZXRlcnMuXG4gKlxuICogUlNBU1NBLVBTUy1wYXJhbXMgIDo6PSAgU0VRVUVOQ0UgIHtcbiAqICAgaGFzaEFsZ29yaXRobSAgICAgIFswXSBIYXNoQWxnb3JpdGhtIERFRkFVTFRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGExSWRlbnRpZmllcixcbiAqICAgbWFza0dlbkFsZ29yaXRobSAgIFsxXSBNYXNrR2VuQWxnb3JpdGhtIERFRkFVTFRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZ2YxU0hBMUlkZW50aWZpZXIsXG4gKiAgIHNhbHRMZW5ndGggICAgICAgICBbMl0gSU5URUdFUiBERUZBVUxUIDIwLFxuICogICB0cmFpbGVyRmllbGQgICAgICAgWzNdIElOVEVHRVIgREVGQVVMVCAxXG4gKiB9XG4gKlxuICogSGFzaEFsZ29yaXRobSAgOjo9ICBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogTWFza0dlbkFsZ29yaXRobSAgOjo9ICBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogQWxnb3JpdGhtSWRlbnRpZmVyIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGFsZ29yaXRobSBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgcGFyYW1ldGVycyBBTlkgREVGSU5FRCBCWSBhbGdvcml0aG0gT1BUSU9OQUxcbiAqIH1cbiAqXG4gKiBAcGFyYW0gb2lkIFRoZSBPSUQgc3BlY2lmeWluZyB0aGUgc2lnbmF0dXJlIGFsZ29yaXRobVxuICogQHBhcmFtIG9iaiBUaGUgQVNOLjEgc3RydWN0dXJlIGhvbGRpbmcgdGhlIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBmaWxsRGVmYXVsdHMgV2hldGhlciB0byB1c2UgcmV0dXJuIGRlZmF1bHQgdmFsdWVzIHdoZXJlIG9taXR0ZWRcbiAqIEByZXR1cm4gc2lnbmF0dXJlIHBhcmFtZXRlciBvYmplY3RcbiAqL1xudmFyIF9yZWFkU2lnbmF0dXJlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG9pZCwgb2JqLCBmaWxsRGVmYXVsdHMpIHtcbiAgdmFyIHBhcmFtcyA9IHt9O1xuXG4gIGlmKG9pZCAhPT0gb2lkc1snUlNBU1NBLVBTUyddKSB7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIGlmKGZpbGxEZWZhdWx0cykge1xuICAgIHBhcmFtcyA9IHtcbiAgICAgIGhhc2g6IHtcbiAgICAgICAgYWxnb3JpdGhtT2lkOiBvaWRzWydzaGExJ11cbiAgICAgIH0sXG4gICAgICBtZ2Y6IHtcbiAgICAgICAgYWxnb3JpdGhtT2lkOiBvaWRzWydtZ2YxJ10sXG4gICAgICAgIGhhc2g6IHtcbiAgICAgICAgICBhbGdvcml0aG1PaWQ6IG9pZHNbJ3NoYTEnXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2FsdExlbmd0aDogMjBcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIHJzYXNzYVBzc1BhcmFtZXRlclZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUlNBU1NBLVBTUyBwYXJhbWV0ZXIgYmxvY2suJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgaWYoY2FwdHVyZS5oYXNoT2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICBwYXJhbXMuaGFzaCA9IHBhcmFtcy5oYXNoIHx8IHt9O1xuICAgIHBhcmFtcy5oYXNoLmFsZ29yaXRobU9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5oYXNoT2lkKTtcbiAgfVxuXG4gIGlmKGNhcHR1cmUubWFza0dlbk9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLm1nZiA9IHBhcmFtcy5tZ2YgfHwge307XG4gICAgcGFyYW1zLm1nZi5hbGdvcml0aG1PaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUubWFza0dlbk9pZCk7XG4gICAgcGFyYW1zLm1nZi5oYXNoID0gcGFyYW1zLm1nZi5oYXNoIHx8IHt9O1xuICAgIHBhcmFtcy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUubWFza0dlbkhhc2hPaWQpO1xuICB9XG5cbiAgaWYoY2FwdHVyZS5zYWx0TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBwYXJhbXMuc2FsdExlbmd0aCA9IGNhcHR1cmUuc2FsdExlbmd0aC5jaGFyQ29kZUF0KDApO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gWC41MDkgY2VydGlmaWNhdGUgZnJvbSBQRU0gZm9ybWF0LlxuICpcbiAqIE5vdGU6IElmIHRoZSBjZXJ0aWZpY2F0ZSBpcyB0byBiZSB2ZXJpZmllZCB0aGVuIGNvbXB1dGUgaGFzaCBzaG91bGRcbiAqIGJlIHNldCB0byB0cnVlLiBUaGlzIHdpbGwgc2NhbiB0aGUgVEJTQ2VydGlmaWNhdGUgcGFydCBvZiB0aGUgQVNOLjFcbiAqIG9iamVjdCB3aGlsZSBpdCBpcyBjb252ZXJ0ZWQgc28gaXQgZG9lc24ndCBuZWVkIHRvIGJlIGNvbnZlcnRlZCBiYWNrXG4gKiB0byBBU04uMS1ERVItZW5jb2RpbmcgbGF0ZXIuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBjb21wdXRlSGFzaCB0cnVlIHRvIGNvbXB1dGUgdGhlIGhhc2ggZm9yIHZlcmlmaWNhdGlvbi5cbiAqIEBwYXJhbSBzdHJpY3QgdHJ1ZSB0byBiZSBzdHJpY3Qgd2hlbiBjaGVja2luZyBBU04uMSB2YWx1ZSBsZW5ndGhzLCBmYWxzZSB0b1xuICogICAgICAgICAgYWxsb3cgdHJ1bmNhdGVkIHZhbHVlcyAoZGVmYXVsdDogdHJ1ZSkuXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGUuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUZyb21QZW0gPSBmdW5jdGlvbihwZW0sIGNvbXB1dGVIYXNoLCBzdHJpY3QpIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ0NFUlRJRklDQVRFJyAmJlxuICAgIG1zZy50eXBlICE9PSAnWDUwOSBDRVJUSUZJQ0FURScgJiZcbiAgICBtc2cudHlwZSAhPT0gJ1RSVVNURUQgQ0VSVElGSUNBVEUnKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRlIGZyb20gUEVNOyBQRU0gaGVhZGVyIHR5cGUgJyArXG4gICAgICAnaXMgbm90IFwiQ0VSVElGSUNBVEVcIiwgXCJYNTA5IENFUlRJRklDQVRFXCIsIG9yIFwiVFJVU1RFRCBDRVJUSUZJQ0FURVwiLicpO1xuICAgIGVycm9yLmhlYWRlclR5cGUgPSBtc2cudHlwZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRlIGZyb20gUEVNOyBQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG5cbiAgLy8gY29udmVydCBERVIgdG8gQVNOLjEgb2JqZWN0XG4gIHZhciBvYmogPSBhc24xLmZyb21EZXIobXNnLmJvZHksIHN0cmljdCk7XG5cbiAgcmV0dXJuIHBraS5jZXJ0aWZpY2F0ZUZyb21Bc24xKG9iaiwgY29tcHV0ZUhhc2gpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOSBjZXJ0aWZpY2F0ZSB0byBQRU0gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZVRvUGVtID0gZnVuY3Rpb24oY2VydCwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ0NFUlRJRklDQVRFJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShjZXJ0KSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwdWJsaWMga2V5IGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBQRU0tZm9ybWF0dGVkIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgcHVibGljIGtleS5cbiAqL1xucGtpLnB1YmxpY0tleUZyb21QZW0gPSBmdW5jdGlvbihwZW0pIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ1BVQkxJQyBLRVknICYmIG1zZy50eXBlICE9PSAnUlNBIFBVQkxJQyBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwdWJsaWMga2V5IGZyb20gUEVNOyBQRU0gaGVhZGVyICcgK1xuICAgICAgJ3R5cGUgaXMgbm90IFwiUFVCTElDIEtFWVwiIG9yIFwiUlNBIFBVQkxJQyBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHVibGljIGtleSBmcm9tIFBFTTsgUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcblxuICByZXR1cm4gcGtpLnB1YmxpY0tleUZyb21Bc24xKG9iaik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwdWJsaWMga2V5IHRvIFBFTSBmb3JtYXQgKHVzaW5nIGEgU3ViamVjdFB1YmxpY0tleUluZm8pLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHB1YmxpYyBrZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlUb1BlbSA9IGZ1bmN0aW9uKGtleSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ1BVQkxJQyBLRVknLFxuICAgIGJvZHk6IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvQXNuMShrZXkpKS5nZXRCeXRlcygpXG4gIH07XG4gIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKG1zZywge21heGxpbmU6IG1heGxpbmV9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUlNBIHB1YmxpYyBrZXkgdG8gUEVNIGZvcm1hdCAodXNpbmcgYW4gUlNBUHVibGljS2V5KS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwdWJsaWMga2V5LlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBwdWJsaWMga2V5LlxuICovXG5wa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXlQZW0gPSBmdW5jdGlvbihrZXksIG1heGxpbmUpIHtcbiAgLy8gY29udmVydCB0byBBU04uMSwgdGhlbiBERVIsIHRoZW4gUEVNLWVuY29kZVxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdSU0EgUFVCTElDIEtFWScsXG4gICAgYm9keTogYXNuMS50b0Rlcihwa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXkoa2V5KSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBmaW5nZXJwcmludCBmb3IgdGhlIGdpdmVuIHB1YmxpYyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAgW21kXSB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSAoZGVmYXVsdHMgdG8gZm9yZ2UubWQuc2hhMSkuXG4gKiAgICAgICAgICBbdHlwZV0gdGhlIHR5cGUgb2YgZmluZ2VycHJpbnQsIHN1Y2ggYXMgJ1JTQVB1YmxpY0tleScsXG4gKiAgICAgICAgICAgICdTdWJqZWN0UHVibGljS2V5SW5mbycgKGRlZmF1bHRzIHRvICdSU0FQdWJsaWNLZXknKS5cbiAqICAgICAgICAgIFtlbmNvZGluZ10gYW4gYWx0ZXJuYXRpdmUgb3V0cHV0IGVuY29kaW5nLCBzdWNoIGFzICdoZXgnXG4gKiAgICAgICAgICAgIChkZWZhdWx0cyB0byBub25lLCBvdXRwdXRzIGEgYnl0ZSBidWZmZXIpLlxuICogICAgICAgICAgW2RlbGltaXRlcl0gdGhlIGRlbGltaXRlciB0byB1c2UgYmV0d2VlbiBieXRlcyBmb3IgJ2hleCcgZW5jb2RlZFxuICogICAgICAgICAgICBvdXRwdXQsIGVnOiAnOicgKGRlZmF1bHRzIHRvIG5vbmUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGZpbmdlcnByaW50IGFzIGEgYnl0ZSBidWZmZXIgb3Igb3RoZXIgZW5jb2RpbmcgYmFzZWQgb24gb3B0aW9ucy5cbiAqL1xucGtpLmdldFB1YmxpY0tleUZpbmdlcnByaW50ID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbWQgPSBvcHRpb25zLm1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIHZhciB0eXBlID0gb3B0aW9ucy50eXBlIHx8ICdSU0FQdWJsaWNLZXknO1xuXG4gIHZhciBieXRlcztcbiAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlICdSU0FQdWJsaWNLZXknOlxuICAgICAgYnl0ZXMgPSBhc24xLnRvRGVyKHBraS5wdWJsaWNLZXlUb1JTQVB1YmxpY0tleShrZXkpKS5nZXRCeXRlcygpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnU3ViamVjdFB1YmxpY0tleUluZm8nOlxuICAgICAgYnl0ZXMgPSBhc24xLnRvRGVyKHBraS5wdWJsaWNLZXlUb0FzbjEoa2V5KSkuZ2V0Qnl0ZXMoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZmluZ2VycHJpbnQgdHlwZSBcIicgKyBvcHRpb25zLnR5cGUgKyAnXCIuJyk7XG4gIH1cblxuICAvLyBoYXNoIHB1YmxpYyBrZXkgYnl0ZXNcbiAgbWQuc3RhcnQoKTtcbiAgbWQudXBkYXRlKGJ5dGVzKTtcbiAgdmFyIGRpZ2VzdCA9IG1kLmRpZ2VzdCgpO1xuICBpZihvcHRpb25zLmVuY29kaW5nID09PSAnaGV4Jykge1xuICAgIHZhciBoZXggPSBkaWdlc3QudG9IZXgoKTtcbiAgICBpZihvcHRpb25zLmRlbGltaXRlcikge1xuICAgICAgcmV0dXJuIGhleC5tYXRjaCgvLnsyfS9nKS5qb2luKG9wdGlvbnMuZGVsaW1pdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbiAgfSBlbHNlIGlmKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdiaW5hcnknKSB7XG4gICAgcmV0dXJuIGRpZ2VzdC5nZXRCeXRlcygpO1xuICB9IGVsc2UgaWYob3B0aW9ucy5lbmNvZGluZykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBcIicgKyBvcHRpb25zLmVuY29kaW5nICsgJ1wiLicpO1xuICB9XG4gIHJldHVybiBkaWdlc3Q7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikgZnJvbSBQRU0gZm9ybWF0LlxuICpcbiAqIE5vdGU6IElmIHRoZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2hcbiAqIHNob3VsZCBiZSBzZXQgdG8gdHJ1ZS4gVGhpcyB3aWxsIHNjYW4gdGhlIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBwYXJ0IG9mXG4gKiB0aGUgQVNOLjEgb2JqZWN0IHdoaWxlIGl0IGlzIGNvbnZlcnRlZCBzbyBpdCBkb2Vzbid0IG5lZWQgdG8gYmUgY29udmVydGVkXG4gKiBiYWNrIHRvIEFTTi4xLURFUi1lbmNvZGluZyBsYXRlci5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlLlxuICogQHBhcmFtIGNvbXB1dGVIYXNoIHRydWUgdG8gY29tcHV0ZSB0aGUgaGFzaCBmb3IgdmVyaWZpY2F0aW9uLlxuICogQHBhcmFtIHN0cmljdCB0cnVlIHRvIGJlIHN0cmljdCB3aGVuIGNoZWNraW5nIEFTTi4xIHZhbHVlIGxlbmd0aHMsIGZhbHNlIHRvXG4gKiAgICAgICAgICBhbGxvdyB0cnVuY2F0ZWQgdmFsdWVzIChkZWZhdWx0OiB0cnVlKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikuXG4gKi9cbnBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEZyb21QZW0gPSBmdW5jdGlvbihwZW0sIGNvbXB1dGVIYXNoLCBzdHJpY3QpIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ0NFUlRJRklDQVRFIFJFUVVFU1QnKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgZnJvbSBQRU07ICcgK1xuICAgICAgJ1BFTSBoZWFkZXIgdHlwZSBpcyBub3QgXCJDRVJUSUZJQ0FURSBSRVFVRVNUXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRpb24gcmVxdWVzdCBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKG1zZy5ib2R5LCBzdHJpY3QpO1xuXG4gIHJldHVybiBwa2kuY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tQXNuMShvYmosIGNvbXB1dGVIYXNoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEwIGNlcnRpZmljYXRpb24gcmVxdWVzdCAoQ1NSKSB0byBQRU0gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBjc3IgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICovXG5wa2kuY2VydGlmaWNhdGlvblJlcXVlc3RUb1BlbSA9IGZ1bmN0aW9uKGNzciwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ0NFUlRJRklDQVRFIFJFUVVFU1QnLFxuICAgIGJvZHk6IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRpb25SZXF1ZXN0VG9Bc24xKGNzcikpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtcHR5IFguNTA5djMgUlNBIGNlcnRpZmljYXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRlLlxuICovXG5wa2kuY3JlYXRlQ2VydGlmaWNhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNlcnQgPSB7fTtcbiAgY2VydC52ZXJzaW9uID0gMHgwMjtcbiAgY2VydC5zZXJpYWxOdW1iZXIgPSAnMDAnO1xuICBjZXJ0LnNpZ25hdHVyZU9pZCA9IG51bGw7XG4gIGNlcnQuc2lnbmF0dXJlID0gbnVsbDtcbiAgY2VydC5zaWdpbmZvID0ge307XG4gIGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBudWxsO1xuICBjZXJ0LnZhbGlkaXR5ID0ge307XG4gIGNlcnQudmFsaWRpdHkubm90QmVmb3JlID0gbmV3IERhdGUoKTtcbiAgY2VydC52YWxpZGl0eS5ub3RBZnRlciA9IG5ldyBEYXRlKCk7XG5cbiAgY2VydC5pc3N1ZXIgPSB7fTtcbiAgY2VydC5pc3N1ZXIuZ2V0RmllbGQgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNlcnQuaXNzdWVyLCBzbik7XG4gIH07XG4gIGNlcnQuaXNzdWVyLmFkZEZpZWxkID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcyA9IFtdO1xuICBjZXJ0Lmlzc3Vlci5oYXNoID0gbnVsbDtcblxuICBjZXJ0LnN1YmplY3QgPSB7fTtcbiAgY2VydC5zdWJqZWN0LmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjZXJ0LnN1YmplY3QsIHNuKTtcbiAgfTtcbiAgY2VydC5zdWJqZWN0LmFkZEZpZWxkID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNlcnQuc3ViamVjdC5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNlcnQuc3ViamVjdC5hdHRyaWJ1dGVzID0gW107XG4gIGNlcnQuc3ViamVjdC5oYXNoID0gbnVsbDtcblxuICBjZXJ0LmV4dGVuc2lvbnMgPSBbXTtcbiAgY2VydC5wdWJsaWNLZXkgPSBudWxsO1xuICBjZXJ0Lm1kID0gbnVsbDtcblxuICAvKipcbiAgICogU2V0cyB0aGUgc3ViamVjdCBvZiB0aGlzIGNlcnRpZmljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgdGhlIGFycmF5IG9mIHN1YmplY3QgYXR0cmlidXRlcyB0byB1c2UuXG4gICAqIEBwYXJhbSB1bmlxdWVJZCBhbiBvcHRpb25hbCBhIHVuaXF1ZSBJRCB0byB1c2UuXG4gICAqL1xuICBjZXJ0LnNldFN1YmplY3QgPSBmdW5jdGlvbihhdHRycywgdW5pcXVlSWQpIHtcbiAgICAvLyBzZXQgbmV3IGF0dHJpYnV0ZXMsIGNsZWFyIGhhc2hcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgIGNlcnQuc3ViamVjdC5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gICAgZGVsZXRlIGNlcnQuc3ViamVjdC51bmlxdWVJZDtcbiAgICBpZih1bmlxdWVJZCkge1xuICAgICAgLy8gVE9ETzogc3VwcG9ydCBhcmJpdHJhcnkgYml0IGxlbmd0aCBpZHNcbiAgICAgIGNlcnQuc3ViamVjdC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIH1cbiAgICBjZXJ0LnN1YmplY3QuaGFzaCA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlzc3VlciBvZiB0aGlzIGNlcnRpZmljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgdGhlIGFycmF5IG9mIGlzc3VlciBhdHRyaWJ1dGVzIHRvIHVzZS5cbiAgICogQHBhcmFtIHVuaXF1ZUlkIGFuIG9wdGlvbmFsIGEgdW5pcXVlIElEIHRvIHVzZS5cbiAgICovXG4gIGNlcnQuc2V0SXNzdWVyID0gZnVuY3Rpb24oYXR0cnMsIHVuaXF1ZUlkKSB7XG4gICAgLy8gc2V0IG5ldyBhdHRyaWJ1dGVzLCBjbGVhciBoYXNoXG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKGF0dHJzKTtcbiAgICBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gICAgZGVsZXRlIGNlcnQuaXNzdWVyLnVuaXF1ZUlkO1xuICAgIGlmKHVuaXF1ZUlkKSB7XG4gICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgY2VydC5pc3N1ZXIudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICB9XG4gICAgY2VydC5pc3N1ZXIuaGFzaCA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGV4dGVuc2lvbnMgb2YgdGhpcyBjZXJ0aWZpY2F0ZS5cbiAgICpcbiAgICogQHBhcmFtIGV4dHMgdGhlIGFycmF5IG9mIGV4dGVuc2lvbnMgdG8gdXNlLlxuICAgKi9cbiAgY2VydC5zZXRFeHRlbnNpb25zID0gZnVuY3Rpb24oZXh0cykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBfZmlsbE1pc3NpbmdFeHRlbnNpb25GaWVsZHMoZXh0c1tpXSwge2NlcnQ6IGNlcnR9KTtcbiAgICB9XG4gICAgLy8gc2V0IG5ldyBleHRlbnNpb25zXG4gICAgY2VydC5leHRlbnNpb25zID0gZXh0cztcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhbiBleHRlbnNpb24gYnkgaXRzIG5hbWUgb3IgaWQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSBuYW1lIHRvIHVzZSBvciBhbiBvYmplY3Qgd2l0aDpcbiAgICogICAgICAgICAgbmFtZSB0aGUgbmFtZSB0byB1c2UuXG4gICAqICAgICAgICAgIGlkIHRoZSBpZCB0byB1c2UuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGV4dGVuc2lvbiBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIGNlcnQuZ2V0RXh0ZW5zaW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucyA9IHtuYW1lOiBvcHRpb25zfTtcbiAgICB9XG5cbiAgICB2YXIgcnZhbCA9IG51bGw7XG4gICAgdmFyIGV4dDtcbiAgICBmb3IodmFyIGkgPSAwOyBydmFsID09PSBudWxsICYmIGkgPCBjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGV4dCA9IGNlcnQuZXh0ZW5zaW9uc1tpXTtcbiAgICAgIGlmKG9wdGlvbnMuaWQgJiYgZXh0LmlkID09PSBvcHRpb25zLmlkKSB7XG4gICAgICAgIHJ2YWwgPSBleHQ7XG4gICAgICB9IGVsc2UgaWYob3B0aW9ucy5uYW1lICYmIGV4dC5uYW1lID09PSBvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgcnZhbCA9IGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpZ25zIHRoaXMgY2VydGlmaWNhdGUgdXNpbmcgdGhlIGdpdmVuIHByaXZhdGUga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IHRoZSBwcml2YXRlIGtleSB0byBzaWduIHdpdGguXG4gICAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSAoZGVmYXVsdHMgdG8gZm9yZ2UubWQuc2hhMSkuXG4gICAqL1xuICBjZXJ0LnNpZ24gPSBmdW5jdGlvbihrZXksIG1kKSB7XG4gICAgLy8gVE9ETzogZ2V0IHNpZ25hdHVyZSBPSUQgZnJvbSBwcml2YXRlIGtleVxuICAgIGNlcnQubWQgPSBtZCB8fCBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgIHZhciBhbGdvcml0aG1PaWQgPSBvaWRzW2NlcnQubWQuYWxnb3JpdGhtICsgJ1dpdGhSU0FFbmNyeXB0aW9uJ107XG4gICAgaWYoIWFsZ29yaXRobU9pZCkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29tcHV0ZSBjZXJ0aWZpY2F0ZSBkaWdlc3QuICcgK1xuICAgICAgICAnVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0gT0lELicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gY2VydC5tZC5hbGdvcml0aG07XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY2VydC5zaWduYXR1cmVPaWQgPSBjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gYWxnb3JpdGhtT2lkO1xuXG4gICAgLy8gZ2V0IFRCU0NlcnRpZmljYXRlLCBjb252ZXJ0IHRvIERFUlxuICAgIGNlcnQudGJzQ2VydGlmaWNhdGUgPSBwa2kuZ2V0VEJTQ2VydGlmaWNhdGUoY2VydCk7XG4gICAgdmFyIGJ5dGVzID0gYXNuMS50b0RlcihjZXJ0LnRic0NlcnRpZmljYXRlKTtcblxuICAgIC8vIGRpZ2VzdCBhbmQgc2lnblxuICAgIGNlcnQubWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICAgIGNlcnQuc2lnbmF0dXJlID0ga2V5LnNpZ24oY2VydC5tZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHZlcmlmeSB0aGUgc2lnbmF0dXJlIG9uIHRoZSBwYXNzZWQgY2VydGlmaWNhdGUgdXNpbmcgdGhpc1xuICAgKiBjZXJ0aWZpY2F0ZSdzIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBjaGlsZCB0aGUgY2VydGlmaWNhdGUgdG8gdmVyaWZ5LlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdmVyaWZpZWQsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGNlcnQudmVyaWZ5ID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gICAgaWYoIWNlcnQuaXNzdWVkKGNoaWxkKSkge1xuICAgICAgdmFyIGlzc3VlciA9IGNoaWxkLmlzc3VlcjtcbiAgICAgIHZhciBzdWJqZWN0ID0gY2VydC5zdWJqZWN0O1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHBhcmVudCBjZXJ0aWZpY2F0ZSBkaWQgbm90IGlzc3VlIHRoZSBnaXZlbiBjaGlsZCAnICtcbiAgICAgICAgJ2NlcnRpZmljYXRlOyB0aGUgY2hpbGQgY2VydGlmaWNhdGVcXCdzIGlzc3VlciBkb2VzIG5vdCBtYXRjaCB0aGUgJyArXG4gICAgICAgICdwYXJlbnRcXCdzIHN1YmplY3QuJyk7XG4gICAgICBlcnJvci5leHBlY3RlZElzc3VlciA9IGlzc3Vlci5hdHRyaWJ1dGVzO1xuICAgICAgZXJyb3IuYWN0dWFsSXNzdWVyID0gc3ViamVjdC5hdHRyaWJ1dGVzO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgdmFyIG1kID0gY2hpbGQubWQ7XG4gICAgaWYobWQgPT09IG51bGwpIHtcbiAgICAgIC8vIGNoZWNrIHNpZ25hdHVyZSBPSUQgZm9yIHN1cHBvcnRlZCBzaWduYXR1cmUgdHlwZXNcbiAgICAgIGlmKGNoaWxkLnNpZ25hdHVyZU9pZCBpbiBvaWRzKSB7XG4gICAgICAgIHZhciBvaWQgPSBvaWRzW2NoaWxkLnNpZ25hdHVyZU9pZF07XG4gICAgICAgIHN3aXRjaChvaWQpIHtcbiAgICAgICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWQ1V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzaGEyNTZXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2hhNTEyV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdSU0FTU0EtUFNTJzpcbiAgICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGUgZGlnZXN0LiAnICtcbiAgICAgICAgICAnVW5rbm93biBzaWduYXR1cmUgT0lELicpO1xuICAgICAgICBlcnJvci5zaWduYXR1cmVPaWQgPSBjaGlsZC5zaWduYXR1cmVPaWQ7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICAvLyBwcm9kdWNlIERFUiBmb3JtYXR0ZWQgVEJTQ2VydGlmaWNhdGUgYW5kIGRpZ2VzdCBpdFxuICAgICAgdmFyIHRic0NlcnRpZmljYXRlID0gY2hpbGQudGJzQ2VydGlmaWNhdGUgfHwgcGtpLmdldFRCU0NlcnRpZmljYXRlKGNoaWxkKTtcbiAgICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIodGJzQ2VydGlmaWNhdGUpO1xuICAgICAgbWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICAgIH1cblxuICAgIGlmKG1kICE9PSBudWxsKSB7XG4gICAgICB2YXIgc2NoZW1lO1xuXG4gICAgICBzd2l0Y2goY2hpbGQuc2lnbmF0dXJlT2lkKSB7XG4gICAgICAgIGNhc2Ugb2lkcy5zaGExV2l0aFJTQUVuY3J5cHRpb246XG4gICAgICAgICAgc2NoZW1lID0gdW5kZWZpbmVkOyAvKiB1c2UgUEtDUyMxIHYxLjUgcGFkZGluZyBzY2hlbWUgKi9cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvaWRzWydSU0FTU0EtUFNTJ106XG4gICAgICAgICAgdmFyIGhhc2gsIG1nZjtcblxuICAgICAgICAgIC8qIGluaXRpYWxpemUgbWdmICovXG4gICAgICAgICAgaGFzaCA9IG9pZHNbY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICAgIGlmKGhhc2ggPT09IHVuZGVmaW5lZCB8fCBmb3JnZS5tZFtoYXNoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE1HRiBoYXNoIGZ1bmN0aW9uLicpO1xuICAgICAgICAgICAgZXJyb3Iub2lkID0gY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgICBlcnJvci5uYW1lID0gaGFzaDtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1nZiA9IG9pZHNbY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuYWxnb3JpdGhtT2lkXTtcbiAgICAgICAgICBpZihtZ2YgPT09IHVuZGVmaW5lZCB8fCBmb3JnZS5tZ2ZbbWdmXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE1HRiBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgIGVycm9yLm9pZCA9IGNoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZDtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSBtZ2Y7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtZ2YgPSBmb3JnZS5tZ2ZbbWdmXS5jcmVhdGUoZm9yZ2UubWRbaGFzaF0uY3JlYXRlKCkpO1xuXG4gICAgICAgICAgLyogaW5pdGlhbGl6ZSBoYXNoIGZ1bmN0aW9uICovXG4gICAgICAgICAgaGFzaCA9IG9pZHNbY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5oYXNoLmFsZ29yaXRobU9pZF07XG4gICAgICAgICAgaWYoaGFzaCA9PT0gdW5kZWZpbmVkIHx8IGZvcmdlLm1kW2hhc2hdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1Vuc3VwcG9ydGVkIFJTQVNTQS1QU1MgaGFzaCBmdW5jdGlvbi4nLFxuICAgICAgICAgICAgICBvaWQ6IGNoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMuaGFzaC5hbGdvcml0aG1PaWQsXG4gICAgICAgICAgICAgIG5hbWU6IGhhc2hcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2NoZW1lID0gZm9yZ2UucHNzLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSwgbWdmLFxuICAgICAgICAgICAgY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5zYWx0TGVuZ3RoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gdmVyaWZ5IHNpZ25hdHVyZSBvbiBjZXJ0IHVzaW5nIHB1YmxpYyBrZXlcbiAgICAgIHJ2YWwgPSBjZXJ0LnB1YmxpY0tleS52ZXJpZnkoXG4gICAgICAgIG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCksIGNoaWxkLnNpZ25hdHVyZSwgc2NoZW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY2VydGlmaWNhdGUncyBpc3N1ZXIgbWF0Y2hlcyB0aGUgcGFzc2VkXG4gICAqIGNlcnRpZmljYXRlJ3Mgc3ViamVjdC4gTm90ZSB0aGF0IG5vIHNpZ25hdHVyZSBjaGVjayBpcyBwZXJmb3JtZWQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJlbnQgdGhlIGNlcnRpZmljYXRlIHRvIGNoZWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBjZXJ0aWZpY2F0ZSdzIGlzc3VlciBtYXRjaGVzIHRoZSBwYXNzZWQgY2VydGlmaWNhdGUnc1xuICAgKiAgICAgICAgIHN1YmplY3QuXG4gICAqL1xuICBjZXJ0LmlzSXNzdWVyID0gZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgdmFyIHJ2YWwgPSBmYWxzZTtcblxuICAgIHZhciBpID0gY2VydC5pc3N1ZXI7XG4gICAgdmFyIHMgPSBwYXJlbnQuc3ViamVjdDtcblxuICAgIC8vIGNvbXBhcmUgaGFzaGVzIGlmIHByZXNlbnRcbiAgICBpZihpLmhhc2ggJiYgcy5oYXNoKSB7XG4gICAgICBydmFsID0gKGkuaGFzaCA9PT0gcy5oYXNoKTtcbiAgICB9IGVsc2UgaWYoaS5hdHRyaWJ1dGVzLmxlbmd0aCA9PT0gcy5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgLy8gYWxsIGF0dHJpYnV0ZXMgYXJlIHRoZSBzYW1lIHNvIGlzc3VlciBtYXRjaGVzIHN1YmplY3RcbiAgICAgIHJ2YWwgPSB0cnVlO1xuICAgICAgdmFyIGlhdHRyLCBzYXR0cjtcbiAgICAgIGZvcih2YXIgbiA9IDA7IHJ2YWwgJiYgbiA8IGkuYXR0cmlidXRlcy5sZW5ndGg7ICsrbikge1xuICAgICAgICBpYXR0ciA9IGkuYXR0cmlidXRlc1tuXTtcbiAgICAgICAgc2F0dHIgPSBzLmF0dHJpYnV0ZXNbbl07XG4gICAgICAgIGlmKGlhdHRyLnR5cGUgIT09IHNhdHRyLnR5cGUgfHwgaWF0dHIudmFsdWUgIT09IHNhdHRyLnZhbHVlKSB7XG4gICAgICAgICAgLy8gYXR0cmlidXRlIG1pc21hdGNoXG4gICAgICAgICAgcnZhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNlcnRpZmljYXRlJ3Mgc3ViamVjdCBtYXRjaGVzIHRoZSBpc3N1ZXIgb2YgdGhlXG4gICAqIGdpdmVuIGNlcnRpZmljYXRlKS4gTm90ZSB0aGF0IG5vdCBzaWduYXR1cmUgY2hlY2sgaXMgcGVyZm9ybWVkLlxuICAgKlxuICAgKiBAcGFyYW0gY2hpbGQgdGhlIGNlcnRpZmljYXRlIHRvIGNoZWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBjZXJ0aWZpY2F0ZSdzIHN1YmplY3QgbWF0Y2hlcyB0aGUgcGFzc2VkXG4gICAqICAgICAgICAgY2VydGlmaWNhdGUncyBpc3N1ZXIuXG4gICAqL1xuICBjZXJ0Lmlzc3VlZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkLmlzSXNzdWVyKGNlcnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIHN1YmplY3RLZXlJZGVudGlmaWVyIGZvciB0aGlzIGNlcnRpZmljYXRlIGFzIGJ5dGUgYnVmZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBzdWJqZWN0S2V5SWRlbnRpZmllciBmb3IgdGhpcyBjZXJ0aWZpY2F0ZSBhcyBieXRlIGJ1ZmZlci5cbiAgICovXG4gIGNlcnQuZ2VuZXJhdGVTdWJqZWN0S2V5SWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIFNlZTogNC4yLjEuMiBzZWN0aW9uIG9mIHRoZSB0aGUgUkZDMzI4MCwga2V5SWRlbnRpZmllciBpcyBlaXRoZXI6XG5cbiAgICAgICgxKSBUaGUga2V5SWRlbnRpZmllciBpcyBjb21wb3NlZCBvZiB0aGUgMTYwLWJpdCBTSEEtMSBoYXNoIG9mIHRoZVxuICAgICAgICB2YWx1ZSBvZiB0aGUgQklUIFNUUklORyBzdWJqZWN0UHVibGljS2V5IChleGNsdWRpbmcgdGhlIHRhZyxcbiAgICAgICAgbGVuZ3RoLCBhbmQgbnVtYmVyIG9mIHVudXNlZCBiaXRzKS5cblxuICAgICAgKDIpIFRoZSBrZXlJZGVudGlmaWVyIGlzIGNvbXBvc2VkIG9mIGEgZm91ciBiaXQgdHlwZSBmaWVsZCB3aXRoXG4gICAgICAgIHRoZSB2YWx1ZSAwMTAwIGZvbGxvd2VkIGJ5IHRoZSBsZWFzdCBzaWduaWZpY2FudCA2MCBiaXRzIG9mIHRoZVxuICAgICAgICBTSEEtMSBoYXNoIG9mIHRoZSB2YWx1ZSBvZiB0aGUgQklUIFNUUklORyBzdWJqZWN0UHVibGljS2V5XG4gICAgICAgIChleGNsdWRpbmcgdGhlIHRhZywgbGVuZ3RoLCBhbmQgbnVtYmVyIG9mIHVudXNlZCBiaXQgc3RyaW5nIGJpdHMpLlxuICAgICovXG5cbiAgICAvLyBza2lwcGluZyB0aGUgdGFnLCBsZW5ndGgsIGFuZCBudW1iZXIgb2YgdW51c2VkIGJpdHMgaXMgdGhlIHNhbWVcbiAgICAvLyBhcyBqdXN0IHVzaW5nIHRoZSBSU0FQdWJsaWNLZXkgKGZvciBSU0Ega2V5cywgd2hpY2ggYXJlIHRoZVxuICAgIC8vIG9ubHkgb25lcyBzdXBwb3J0ZWQpXG4gICAgcmV0dXJuIHBraS5nZXRQdWJsaWNLZXlGaW5nZXJwcmludChjZXJ0LnB1YmxpY0tleSwge3R5cGU6ICdSU0FQdWJsaWNLZXknfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoZSBzdWJqZWN0S2V5SWRlbnRpZmllciBleHRlbnNpb24gdmFsdWUgZm9yIHRoaXMgY2VydGlmaWNhdGVcbiAgICogYWdhaW5zdCBpdHMgcHVibGljIGtleS4gSWYgbm8gZXh0ZW5zaW9uIGlzIGZvdW5kLCBmYWxzZSB3aWxsIGJlXG4gICAqIHJldHVybmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdmVyaWZpZWQsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGNlcnQudmVyaWZ5U3ViamVjdEtleUlkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2lkID0gb2lkc1snc3ViamVjdEtleUlkZW50aWZpZXInXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2VydC5leHRlbnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZXh0ID0gY2VydC5leHRlbnNpb25zW2ldO1xuICAgICAgaWYoZXh0LmlkID09PSBvaWQpIHtcbiAgICAgICAgdmFyIHNraSA9IGNlcnQuZ2VuZXJhdGVTdWJqZWN0S2V5SWRlbnRpZmllcigpLmdldEJ5dGVzKCk7XG4gICAgICAgIHJldHVybiAoZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGV4dC5zdWJqZWN0S2V5SWRlbnRpZmllcikgPT09IHNraSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICByZXR1cm4gY2VydDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gWC41MDl2MyBSU0EgY2VydGlmaWNhdGUgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogTm90ZTogSWYgdGhlIGNlcnRpZmljYXRlIGlzIHRvIGJlIHZlcmlmaWVkIHRoZW4gY29tcHV0ZSBoYXNoIHNob3VsZFxuICogYmUgc2V0IHRvIHRydWUuIFRoZXJlIGlzIGN1cnJlbnRseSBubyBpbXBsZW1lbnRhdGlvbiBmb3IgY29udmVydGluZ1xuICogYSBjZXJ0aWZpY2F0ZSBiYWNrIHRvIEFTTi4xIHNvIHRoZSBUQlNDZXJ0aWZpY2F0ZSBwYXJ0IG9mIHRoZSBBU04uMVxuICogb2JqZWN0IG5lZWRzIHRvIGJlIHNjYW5uZWQgYmVmb3JlIHRoZSBjZXJ0IG9iamVjdCBpcyBjcmVhdGVkLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYW4gWC41MDl2MyBSU0EgY2VydGlmaWNhdGUuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGUuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUZyb21Bc24xID0gZnVuY3Rpb24ob2JqLCBjb21wdXRlSGFzaCkge1xuICAvLyB2YWxpZGF0ZSBjZXJ0aWZpY2F0ZSBhbmQgY2FwdHVyZSBkYXRhXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCB4NTA5Q2VydGlmaWNhdGVWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFguNTA5IGNlcnRpZmljYXRlLiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGFuIFg1MDl2MyBDZXJ0aWZpY2F0ZS4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgb2lkXG4gIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUucHVibGljS2V5T2lkKTtcbiAgaWYob2lkICE9PSBwa2kub2lkcy5yc2FFbmNyeXB0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwdWJsaWMga2V5LiBPSUQgaXMgbm90IFJTQS4nKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBjZXJ0aWZpY2F0ZVxuICB2YXIgY2VydCA9IHBraS5jcmVhdGVDZXJ0aWZpY2F0ZSgpO1xuICBjZXJ0LnZlcnNpb24gPSBjYXB0dXJlLmNlcnRWZXJzaW9uID9cbiAgICBjYXB0dXJlLmNlcnRWZXJzaW9uLmNoYXJDb2RlQXQoMCkgOiAwO1xuICB2YXIgc2VyaWFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5jZXJ0U2VyaWFsTnVtYmVyKTtcbiAgY2VydC5zZXJpYWxOdW1iZXIgPSBzZXJpYWwudG9IZXgoKTtcbiAgY2VydC5zaWduYXR1cmVPaWQgPSBmb3JnZS5hc24xLmRlclRvT2lkKGNhcHR1cmUuY2VydFNpZ25hdHVyZU9pZCk7XG4gIGNlcnQuc2lnbmF0dXJlUGFyYW1ldGVycyA9IF9yZWFkU2lnbmF0dXJlUGFyYW1ldGVycyhcbiAgICBjZXJ0LnNpZ25hdHVyZU9pZCwgY2FwdHVyZS5jZXJ0U2lnbmF0dXJlUGFyYW1zLCB0cnVlKTtcbiAgY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0aW5mb1NpZ25hdHVyZU9pZCk7XG4gIGNlcnQuc2lnaW5mby5wYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQsXG4gICAgY2FwdHVyZS5jZXJ0aW5mb1NpZ25hdHVyZVBhcmFtcywgZmFsc2UpO1xuICBjZXJ0LnNpZ25hdHVyZSA9IGNhcHR1cmUuY2VydFNpZ25hdHVyZTtcblxuICB2YXIgdmFsaWRpdHkgPSBbXTtcbiAgaWYoY2FwdHVyZS5jZXJ0VmFsaWRpdHkxVVRDVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLnV0Y1RpbWVUb0RhdGUoY2FwdHVyZS5jZXJ0VmFsaWRpdHkxVVRDVGltZSkpO1xuICB9XG4gIGlmKGNhcHR1cmUuY2VydFZhbGlkaXR5MkdlbmVyYWxpemVkVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLmdlbmVyYWxpemVkVGltZVRvRGF0ZShcbiAgICAgIGNhcHR1cmUuY2VydFZhbGlkaXR5MkdlbmVyYWxpemVkVGltZSkpO1xuICB9XG4gIGlmKGNhcHR1cmUuY2VydFZhbGlkaXR5M1VUQ1RpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkaXR5LnB1c2goYXNuMS51dGNUaW1lVG9EYXRlKGNhcHR1cmUuY2VydFZhbGlkaXR5M1VUQ1RpbWUpKTtcbiAgfVxuICBpZihjYXB0dXJlLmNlcnRWYWxpZGl0eTRHZW5lcmFsaXplZFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkaXR5LnB1c2goYXNuMS5nZW5lcmFsaXplZFRpbWVUb0RhdGUoXG4gICAgICBjYXB0dXJlLmNlcnRWYWxpZGl0eTRHZW5lcmFsaXplZFRpbWUpKTtcbiAgfVxuICBpZih2YWxpZGl0eS5sZW5ndGggPiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBub3RCZWZvcmUvbm90QWZ0ZXIgdmFsaWRpdHkgdGltZXM7IG1vcmUgJyArXG4gICAgICAndGhhbiB0d28gdGltZXMgd2VyZSBwcm92aWRlZCBpbiB0aGUgY2VydGlmaWNhdGUuJyk7XG4gIH1cbiAgaWYodmFsaWRpdHkubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgbm90QmVmb3JlL25vdEFmdGVyIHZhbGlkaXR5IHRpbWVzOyB0aGV5ICcgK1xuICAgICAgJ3dlcmUgbm90IHByb3ZpZGVkIGFzIGVpdGhlciBVVENUaW1lIG9yIEdlbmVyYWxpemVkVGltZS4nKTtcbiAgfVxuICBjZXJ0LnZhbGlkaXR5Lm5vdEJlZm9yZSA9IHZhbGlkaXR5WzBdO1xuICBjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyID0gdmFsaWRpdHlbMV07XG5cbiAgLy8ga2VlcCBUQlNDZXJ0aWZpY2F0ZSB0byBwcmVzZXJ2ZSBzaWduYXR1cmUgd2hlbiBleHBvcnRpbmdcbiAgY2VydC50YnNDZXJ0aWZpY2F0ZSA9IGNhcHR1cmUudGJzQ2VydGlmaWNhdGU7XG5cbiAgaWYoY29tcHV0ZUhhc2gpIHtcbiAgICAvLyBjaGVjayBzaWduYXR1cmUgT0lEIGZvciBzdXBwb3J0ZWQgc2lnbmF0dXJlIHR5cGVzXG4gICAgY2VydC5tZCA9IG51bGw7XG4gICAgaWYoY2VydC5zaWduYXR1cmVPaWQgaW4gb2lkcykge1xuICAgICAgdmFyIG9pZCA9IG9pZHNbY2VydC5zaWduYXR1cmVPaWRdO1xuICAgICAgc3dpdGNoKG9pZCkge1xuICAgICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtZDVXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgY2VydC5tZCA9IGZvcmdlLm1kLm1kNS5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBjZXJ0Lm1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgY2VydC5tZCA9IGZvcmdlLm1kLnNoYTUxMi5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUlNBU1NBLVBTUyc6XG4gICAgICAgICAgY2VydC5tZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoY2VydC5tZCA9PT0gbnVsbCkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29tcHV0ZSBjZXJ0aWZpY2F0ZSBkaWdlc3QuICcgK1xuICAgICAgICAnVW5rbm93biBzaWduYXR1cmUgT0lELicpO1xuICAgICAgZXJyb3Iuc2lnbmF0dXJlT2lkID0gY2VydC5zaWduYXR1cmVPaWQ7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBwcm9kdWNlIERFUiBmb3JtYXR0ZWQgVEJTQ2VydGlmaWNhdGUgYW5kIGRpZ2VzdCBpdFxuICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY2VydC50YnNDZXJ0aWZpY2F0ZSk7XG4gICAgY2VydC5tZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gIH1cblxuICAvLyBoYW5kbGUgaXNzdWVyLCBidWlsZCBpc3N1ZXIgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIGltZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIGNlcnQuaXNzdWVyLmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjZXJ0Lmlzc3Vlciwgc24pO1xuICB9O1xuICBjZXJ0Lmlzc3Vlci5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMgPSBwa2kuUkROQXR0cmlidXRlc0FzQXJyYXkoY2FwdHVyZS5jZXJ0SXNzdWVyLCBpbWQpO1xuICBpZihjYXB0dXJlLmNlcnRJc3N1ZXJVbmlxdWVJZCkge1xuICAgIGNlcnQuaXNzdWVyLnVuaXF1ZUlkID0gY2FwdHVyZS5jZXJ0SXNzdWVyVW5pcXVlSWQ7XG4gIH1cbiAgY2VydC5pc3N1ZXIuaGFzaCA9IGltZC5kaWdlc3QoKS50b0hleCgpO1xuXG4gIC8vIGhhbmRsZSBzdWJqZWN0LCBidWlsZCBzdWJqZWN0IG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBzbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICBjZXJ0LnN1YmplY3QuZ2V0RmllbGQgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNlcnQuc3ViamVjdCwgc24pO1xuICB9O1xuICBjZXJ0LnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBwa2kuUkROQXR0cmlidXRlc0FzQXJyYXkoY2FwdHVyZS5jZXJ0U3ViamVjdCwgc21kKTtcbiAgaWYoY2FwdHVyZS5jZXJ0U3ViamVjdFVuaXF1ZUlkKSB7XG4gICAgY2VydC5zdWJqZWN0LnVuaXF1ZUlkID0gY2FwdHVyZS5jZXJ0U3ViamVjdFVuaXF1ZUlkO1xuICB9XG4gIGNlcnQuc3ViamVjdC5oYXNoID0gc21kLmRpZ2VzdCgpLnRvSGV4KCk7XG5cbiAgLy8gaGFuZGxlIGV4dGVuc2lvbnNcbiAgaWYoY2FwdHVyZS5jZXJ0RXh0ZW5zaW9ucykge1xuICAgIGNlcnQuZXh0ZW5zaW9ucyA9IHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNGcm9tQXNuMShjYXB0dXJlLmNlcnRFeHRlbnNpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBjZXJ0LmV4dGVuc2lvbnMgPSBbXTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgUlNBIHB1YmxpYyBrZXkgZnJvbSBBU04uMVxuICBjZXJ0LnB1YmxpY0tleSA9IHBraS5wdWJsaWNLZXlGcm9tQXNuMShjYXB0dXJlLnN1YmplY3RQdWJsaWNLZXlJbmZvKTtcblxuICByZXR1cm4gY2VydDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gQVNOLjEgZXh0ZW5zaW9ucyBvYmplY3QgKHdpdGggZXh0ZW5zaW9uIHNlcXVlbmNlcyBhcyBpdHNcbiAqIHZhbHVlcykgaW50byBhbiBhcnJheSBvZiBleHRlbnNpb24gb2JqZWN0cyB3aXRoIHR5cGVzIGFuZCB2YWx1ZXMuXG4gKlxuICogU3VwcG9ydGVkIGV4dGVuc2lvbnM6XG4gKlxuICogaWQtY2Uta2V5VXNhZ2UgT0JKRUNUIElERU5USUZJRVIgOjo9ICB7IGlkLWNlIDE1IH1cbiAqIEtleVVzYWdlIDo6PSBCSVQgU1RSSU5HIHtcbiAqICAgZGlnaXRhbFNpZ25hdHVyZSAgICAgICAgKDApLFxuICogICBub25SZXB1ZGlhdGlvbiAgICAgICAgICAoMSksXG4gKiAgIGtleUVuY2lwaGVybWVudCAgICAgICAgICgyKSxcbiAqICAgZGF0YUVuY2lwaGVybWVudCAgICAgICAgKDMpLFxuICogICBrZXlBZ3JlZW1lbnQgICAgICAgICAgICAoNCksXG4gKiAgIGtleUNlcnRTaWduICAgICAgICAgICAgICg1KSxcbiAqICAgY1JMU2lnbiAgICAgICAgICAgICAgICAgKDYpLFxuICogICBlbmNpcGhlck9ubHkgICAgICAgICAgICAoNyksXG4gKiAgIGRlY2lwaGVyT25seSAgICAgICAgICAgICg4KVxuICogfVxuICpcbiAqIGlkLWNlLWJhc2ljQ29uc3RyYWludHMgT0JKRUNUIElERU5USUZJRVIgOjo9ICB7IGlkLWNlIDE5IH1cbiAqIEJhc2ljQ29uc3RyYWludHMgOjo9IFNFUVVFTkNFIHtcbiAqICAgY0EgICAgICAgICAgICAgICAgICAgICAgQk9PTEVBTiBERUZBVUxUIEZBTFNFLFxuICogICBwYXRoTGVuQ29uc3RyYWludCAgICAgICBJTlRFR0VSICgwLi5NQVgpIE9QVElPTkFMXG4gKiB9XG4gKlxuICogc3ViamVjdEFsdE5hbWUgRVhURU5TSU9OIDo6PSB7XG4gKiAgIFNZTlRBWCBHZW5lcmFsTmFtZXNcbiAqICAgSURFTlRJRklFRCBCWSBpZC1jZS1zdWJqZWN0QWx0TmFtZVxuICogfVxuICpcbiAqIEdlbmVyYWxOYW1lcyA6Oj0gU0VRVUVOQ0UgU0laRSAoMS4uTUFYKSBPRiBHZW5lcmFsTmFtZVxuICpcbiAqIEdlbmVyYWxOYW1lIDo6PSBDSE9JQ0Uge1xuICogICBvdGhlck5hbWUgICAgICBbMF0gSU5TVEFOQ0UgT0YgT1RIRVItTkFNRSxcbiAqICAgcmZjODIyTmFtZSAgICAgWzFdIElBNVN0cmluZyxcbiAqICAgZE5TTmFtZSAgICAgICAgWzJdIElBNVN0cmluZyxcbiAqICAgeDQwMEFkZHJlc3MgICAgWzNdIE9SQWRkcmVzcyxcbiAqICAgZGlyZWN0b3J5TmFtZSAgWzRdIE5hbWUsXG4gKiAgIGVkaVBhcnR5TmFtZSAgIFs1XSBFRElQYXJ0eU5hbWUsXG4gKiAgIHVuaWZvcm1SZXNvdXJjZUlkZW50aWZpZXIgWzZdIElBNVN0cmluZyxcbiAqICAgSVBBZGRyZXNzICAgICAgWzddIE9DVEVUIFNUUklORyxcbiAqICAgcmVnaXN0ZXJlZElEICAgWzhdIE9CSkVDVCBJREVOVElGSUVSXG4gKiB9XG4gKlxuICogT1RIRVItTkFNRSA6Oj0gVFlQRS1JREVOVElGSUVSXG4gKlxuICogRURJUGFydHlOYW1lIDo6PSBTRVFVRU5DRSB7XG4gKiAgIG5hbWVBc3NpZ25lciBbMF0gRGlyZWN0b3J5U3RyaW5nIHt1Yi1uYW1lfSBPUFRJT05BTCxcbiAqICAgcGFydHlOYW1lICAgIFsxXSBEaXJlY3RvcnlTdHJpbmcge3ViLW5hbWV9XG4gKiB9XG4gKlxuICogQHBhcmFtIGV4dHMgdGhlIGV4dGVuc2lvbnMgQVNOLjEgd2l0aCBleHRlbnNpb24gc2VxdWVuY2VzIHRvIHBhcnNlLlxuICpcbiAqIEByZXR1cm4gdGhlIGFycmF5LlxuICovXG5wa2kuY2VydGlmaWNhdGVFeHRlbnNpb25zRnJvbUFzbjEgPSBmdW5jdGlvbihleHRzKSB7XG4gIHZhciBydmFsID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBleHRzLnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gZ2V0IGV4dGVuc2lvbiBzZXF1ZW5jZVxuICAgIHZhciBleHRzZXEgPSBleHRzLnZhbHVlW2ldO1xuICAgIGZvcih2YXIgZWkgPSAwOyBlaSA8IGV4dHNlcS52YWx1ZS5sZW5ndGg7ICsrZWkpIHtcbiAgICAgIHJ2YWwucHVzaChwa2kuY2VydGlmaWNhdGVFeHRlbnNpb25Gcm9tQXNuMShleHRzZXEudmFsdWVbZWldKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHNpbmdsZSBjZXJ0aWZpY2F0ZSBleHRlbnNpb24gZnJvbSBBU04uMS5cbiAqXG4gKiBAcGFyYW0gZXh0IHRoZSBleHRlbnNpb24gaW4gQVNOLjEgZm9ybWF0LlxuICpcbiAqIEByZXR1cm4gdGhlIHBhcnNlZCBleHRlbnNpb24gYXMgYW4gb2JqZWN0LlxuICovXG5wa2kuY2VydGlmaWNhdGVFeHRlbnNpb25Gcm9tQXNuMSA9IGZ1bmN0aW9uKGV4dCkge1xuICAvLyBhbiBleHRlbnNpb24gaGFzOlxuICAvLyBbMF0gZXh0bklEICAgICAgT0JKRUNUIElERU5USUZJRVJcbiAgLy8gWzFdIGNyaXRpY2FsICAgIEJPT0xFQU4gREVGQVVMVCBGQUxTRVxuICAvLyBbMl0gZXh0blZhbHVlICAgT0NURVQgU1RSSU5HXG4gIHZhciBlID0ge307XG4gIGUuaWQgPSBhc24xLmRlclRvT2lkKGV4dC52YWx1ZVswXS52YWx1ZSk7XG4gIGUuY3JpdGljYWwgPSBmYWxzZTtcbiAgaWYoZXh0LnZhbHVlWzFdLnR5cGUgPT09IGFzbjEuVHlwZS5CT09MRUFOKSB7XG4gICAgZS5jcml0aWNhbCA9IChleHQudmFsdWVbMV0udmFsdWUuY2hhckNvZGVBdCgwKSAhPT0gMHgwMCk7XG4gICAgZS52YWx1ZSA9IGV4dC52YWx1ZVsyXS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBlLnZhbHVlID0gZXh0LnZhbHVlWzFdLnZhbHVlO1xuICB9XG4gIC8vIGlmIHRoZSBvaWQgaXMga25vd24sIGdldCBpdHMgbmFtZVxuICBpZihlLmlkIGluIG9pZHMpIHtcbiAgICBlLm5hbWUgPSBvaWRzW2UuaWRdO1xuXG4gICAgLy8gaGFuZGxlIGtleSB1c2FnZVxuICAgIGlmKGUubmFtZSA9PT0gJ2tleVVzYWdlJykge1xuICAgICAgLy8gZ2V0IHZhbHVlIGFzIEJJVCBTVFJJTkdcbiAgICAgIHZhciBldiA9IGFzbjEuZnJvbURlcihlLnZhbHVlKTtcbiAgICAgIHZhciBiMiA9IDB4MDA7XG4gICAgICB2YXIgYjMgPSAweDAwO1xuICAgICAgaWYoZXYudmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBza2lwIGZpcnN0IGJ5dGUsIGp1c3QgaW5kaWNhdGVzIHVudXNlZCBiaXRzIHdoaWNoXG4gICAgICAgIC8vIHdpbGwgYmUgcGFkZGVkIHdpdGggMHMgYW55d2F5XG4gICAgICAgIC8vIGdldCBieXRlcyB3aXRoIGZsYWcgYml0c1xuICAgICAgICBiMiA9IGV2LnZhbHVlLmNoYXJDb2RlQXQoMSk7XG4gICAgICAgIGIzID0gZXYudmFsdWUubGVuZ3RoID4gMiA/IGV2LnZhbHVlLmNoYXJDb2RlQXQoMikgOiAwO1xuICAgICAgfVxuICAgICAgLy8gc2V0IGZsYWdzXG4gICAgICBlLmRpZ2l0YWxTaWduYXR1cmUgPSAoYjIgJiAweDgwKSA9PT0gMHg4MDtcbiAgICAgIGUubm9uUmVwdWRpYXRpb24gPSAoYjIgJiAweDQwKSA9PT0gMHg0MDtcbiAgICAgIGUua2V5RW5jaXBoZXJtZW50ID0gKGIyICYgMHgyMCkgPT09IDB4MjA7XG4gICAgICBlLmRhdGFFbmNpcGhlcm1lbnQgPSAoYjIgJiAweDEwKSA9PT0gMHgxMDtcbiAgICAgIGUua2V5QWdyZWVtZW50ID0gKGIyICYgMHgwOCkgPT09IDB4MDg7XG4gICAgICBlLmtleUNlcnRTaWduID0gKGIyICYgMHgwNCkgPT09IDB4MDQ7XG4gICAgICBlLmNSTFNpZ24gPSAoYjIgJiAweDAyKSA9PT0gMHgwMjtcbiAgICAgIGUuZW5jaXBoZXJPbmx5ID0gKGIyICYgMHgwMSkgPT09IDB4MDE7XG4gICAgICBlLmRlY2lwaGVyT25seSA9IChiMyAmIDB4ODApID09PSAweDgwO1xuICAgIH0gZWxzZSBpZihlLm5hbWUgPT09ICdiYXNpY0NvbnN0cmFpbnRzJykge1xuICAgICAgLy8gaGFuZGxlIGJhc2ljIGNvbnN0cmFpbnRzXG4gICAgICAvLyBnZXQgdmFsdWUgYXMgU0VRVUVOQ0VcbiAgICAgIHZhciBldiA9IGFzbjEuZnJvbURlcihlLnZhbHVlKTtcbiAgICAgIC8vIGdldCBjQSBCT09MRUFOIGZsYWcgKGRlZmF1bHRzIHRvIGZhbHNlKVxuICAgICAgaWYoZXYudmFsdWUubGVuZ3RoID4gMCAmJiBldi52YWx1ZVswXS50eXBlID09PSBhc24xLlR5cGUuQk9PTEVBTikge1xuICAgICAgICBlLmNBID0gKGV2LnZhbHVlWzBdLnZhbHVlLmNoYXJDb2RlQXQoMCkgIT09IDB4MDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS5jQSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gZ2V0IHBhdGggbGVuZ3RoIGNvbnN0cmFpbnRcbiAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAwICYmIGV2LnZhbHVlWzBdLnR5cGUgPT09IGFzbjEuVHlwZS5JTlRFR0VSKSB7XG4gICAgICAgIHZhbHVlID0gZXYudmFsdWVbMF0udmFsdWU7XG4gICAgICB9IGVsc2UgaWYoZXYudmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWx1ZSA9IGV2LnZhbHVlWzFdLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgZS5wYXRoTGVuQ29uc3RyYWludCA9IGFzbjEuZGVyVG9JbnRlZ2VyKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZS5uYW1lID09PSAnZXh0S2V5VXNhZ2UnKSB7XG4gICAgICAvLyBoYW5kbGUgZXh0S2V5VXNhZ2VcbiAgICAgIC8vIHZhbHVlIGlzIGEgU0VRVUVOQ0Ugb2YgT0lEc1xuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgZm9yKHZhciB2aSA9IDA7IHZpIDwgZXYudmFsdWUubGVuZ3RoOyArK3ZpKSB7XG4gICAgICAgIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGV2LnZhbHVlW3ZpXS52YWx1ZSk7XG4gICAgICAgIGlmKG9pZCBpbiBvaWRzKSB7XG4gICAgICAgICAgZVtvaWRzW29pZF1dID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlW29pZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ25zQ2VydFR5cGUnKSB7XG4gICAgICAvLyBoYW5kbGUgbnNDZXJ0VHlwZVxuICAgICAgLy8gZ2V0IHZhbHVlIGFzIEJJVCBTVFJJTkdcbiAgICAgIHZhciBldiA9IGFzbjEuZnJvbURlcihlLnZhbHVlKTtcbiAgICAgIHZhciBiMiA9IDB4MDA7XG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHNraXAgZmlyc3QgYnl0ZSwganVzdCBpbmRpY2F0ZXMgdW51c2VkIGJpdHMgd2hpY2hcbiAgICAgICAgLy8gd2lsbCBiZSBwYWRkZWQgd2l0aCAwcyBhbnl3YXlcbiAgICAgICAgLy8gZ2V0IGJ5dGVzIHdpdGggZmxhZyBiaXRzXG4gICAgICAgIGIyID0gZXYudmFsdWUuY2hhckNvZGVBdCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHNldCBmbGFnc1xuICAgICAgZS5jbGllbnQgPSAoYjIgJiAweDgwKSA9PT0gMHg4MDtcbiAgICAgIGUuc2VydmVyID0gKGIyICYgMHg0MCkgPT09IDB4NDA7XG4gICAgICBlLmVtYWlsID0gKGIyICYgMHgyMCkgPT09IDB4MjA7XG4gICAgICBlLm9ianNpZ24gPSAoYjIgJiAweDEwKSA9PT0gMHgxMDtcbiAgICAgIGUucmVzZXJ2ZWQgPSAoYjIgJiAweDA4KSA9PT0gMHgwODtcbiAgICAgIGUuc3NsQ0EgPSAoYjIgJiAweDA0KSA9PT0gMHgwNDtcbiAgICAgIGUuZW1haWxDQSA9IChiMiAmIDB4MDIpID09PSAweDAyO1xuICAgICAgZS5vYmpDQSA9IChiMiAmIDB4MDEpID09PSAweDAxO1xuICAgIH0gZWxzZSBpZihcbiAgICAgIGUubmFtZSA9PT0gJ3N1YmplY3RBbHROYW1lJyB8fFxuICAgICAgZS5uYW1lID09PSAnaXNzdWVyQWx0TmFtZScpIHtcbiAgICAgIC8vIGhhbmRsZSBzdWJqZWN0QWx0TmFtZS9pc3N1ZXJBbHROYW1lXG4gICAgICBlLmFsdE5hbWVzID0gW107XG5cbiAgICAgIC8vIGV2IGlzIGEgU1lOVEFYIFNFUVVFTkNFXG4gICAgICB2YXIgZ247XG4gICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICBmb3IodmFyIG4gPSAwOyBuIDwgZXYudmFsdWUubGVuZ3RoOyArK24pIHtcbiAgICAgICAgLy8gZ2V0IEdlbmVyYWxOYW1lXG4gICAgICAgIGduID0gZXYudmFsdWVbbl07XG5cbiAgICAgICAgdmFyIGFsdE5hbWUgPSB7XG4gICAgICAgICAgdHlwZTogZ24udHlwZSxcbiAgICAgICAgICB2YWx1ZTogZ24udmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgZS5hbHROYW1lcy5wdXNoKGFsdE5hbWUpO1xuXG4gICAgICAgIC8vIE5vdGU6IFN1cHBvcnQgZm9yIHR5cGVzIDEsMiw2LDcsOFxuICAgICAgICBzd2l0Y2goZ24udHlwZSkge1xuICAgICAgICAgIC8vIHJmYzgyMk5hbWVcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgLy8gZE5TTmFtZVxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAvLyB1bmlmb3JtUmVzb3VyY2VJZGVudGlmaWVyIChVUkkpXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gSVBBZGRyZXNzXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgLy8gY29udmVydCB0byBJUHY0L0lQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICBhbHROYW1lLmlwID0gZm9yZ2UudXRpbC5ieXRlc1RvSVAoZ24udmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gcmVnaXN0ZXJlZElEXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgYWx0TmFtZS5vaWQgPSBhc24xLmRlclRvT2lkKGduLnZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyB1bnN1cHBvcnRlZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ3N1YmplY3RLZXlJZGVudGlmaWVyJykge1xuICAgICAgLy8gdmFsdWUgaXMgYW4gT0NURVRTVFJJTkcgdy90aGUgaGFzaCBvZiB0aGUga2V5LXR5cGUgc3BlY2lmaWNcbiAgICAgIC8vIHB1YmxpYyBrZXkgc3RydWN0dXJlIChlZzogUlNBUHVibGljS2V5KVxuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgZS5zdWJqZWN0S2V5SWRlbnRpZmllciA9IGZvcmdlLnV0aWwuYnl0ZXNUb0hleChldi52YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBLQ1MjMTAgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpIGZyb20gYW4gQVNOLjEgb2JqZWN0LlxuICpcbiAqIE5vdGU6IElmIHRoZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2hcbiAqIHNob3VsZCBiZSBzZXQgdG8gdHJ1ZS4gVGhlcmUgaXMgY3VycmVudGx5IG5vIGltcGxlbWVudGF0aW9uIGZvciBjb252ZXJ0aW5nXG4gKiBhIGNlcnRpZmljYXRlIGJhY2sgdG8gQVNOLjEgc28gdGhlIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBwYXJ0IG9mIHRoZVxuICogQVNOLjEgb2JqZWN0IG5lZWRzIHRvIGJlIHNjYW5uZWQgYmVmb3JlIHRoZSBjc3Igb2JqZWN0IGlzIGNyZWF0ZWQuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFBLQ1MjMTAgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpLlxuICogQHBhcmFtIGNvbXB1dGVIYXNoIHRydWUgdG8gY29tcHV0ZSB0aGUgaGFzaCBmb3IgdmVyaWZpY2F0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCAoQ1NSKS5cbiAqL1xucGtpLmNlcnRpZmljYXRpb25SZXF1ZXN0RnJvbUFzbjEgPSBmdW5jdGlvbihvYmosIGNvbXB1dGVIYXNoKSB7XG4gIC8vIHZhbGlkYXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBhbmQgY2FwdHVyZSBkYXRhXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCBjZXJ0aWZpY2F0aW9uUmVxdWVzdFZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUEtDUyMxMCBjZXJ0aWZpY2F0ZSByZXF1ZXN0LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGEgUEtDUyMxMCBDZXJ0aWZpY2F0aW9uUmVxdWVzdC4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgb2lkXG4gIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUucHVibGljS2V5T2lkKTtcbiAgaWYob2lkICE9PSBwa2kub2lkcy5yc2FFbmNyeXB0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwdWJsaWMga2V5LiBPSUQgaXMgbm90IFJTQS4nKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3RcbiAgdmFyIGNzciA9IHBraS5jcmVhdGVDZXJ0aWZpY2F0aW9uUmVxdWVzdCgpO1xuICBjc3IudmVyc2lvbiA9IGNhcHR1cmUuY3NyVmVyc2lvbiA/IGNhcHR1cmUuY3NyVmVyc2lvbi5jaGFyQ29kZUF0KDApIDogMDtcbiAgY3NyLnNpZ25hdHVyZU9pZCA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jc3JTaWduYXR1cmVPaWQpO1xuICBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycyA9IF9yZWFkU2lnbmF0dXJlUGFyYW1ldGVycyhcbiAgICBjc3Iuc2lnbmF0dXJlT2lkLCBjYXB0dXJlLmNzclNpZ25hdHVyZVBhcmFtcywgdHJ1ZSk7XG4gIGNzci5zaWdpbmZvLmFsZ29yaXRobU9pZCA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jc3JTaWduYXR1cmVPaWQpO1xuICBjc3Iuc2lnaW5mby5wYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgIGNzci5zaWdpbmZvLmFsZ29yaXRobU9pZCwgY2FwdHVyZS5jc3JTaWduYXR1cmVQYXJhbXMsIGZhbHNlKTtcbiAgY3NyLnNpZ25hdHVyZSA9IGNhcHR1cmUuY3NyU2lnbmF0dXJlO1xuXG4gIC8vIGtlZXAgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHRvIHByZXNlcnZlIHNpZ25hdHVyZSB3aGVuIGV4cG9ydGluZ1xuICBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvID0gY2FwdHVyZS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm87XG5cbiAgaWYoY29tcHV0ZUhhc2gpIHtcbiAgICAvLyBjaGVjayBzaWduYXR1cmUgT0lEIGZvciBzdXBwb3J0ZWQgc2lnbmF0dXJlIHR5cGVzXG4gICAgY3NyLm1kID0gbnVsbDtcbiAgICBpZihjc3Iuc2lnbmF0dXJlT2lkIGluIG9pZHMpIHtcbiAgICAgIHZhciBvaWQgPSBvaWRzW2Nzci5zaWduYXR1cmVPaWRdO1xuICAgICAgc3dpdGNoKG9pZCkge1xuICAgICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIGNzci5tZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21kNVdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTI1NldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5zaGEzODQuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTUxMldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1JTQVNTQS1QU1MnOlxuICAgICAgICAgIGNzci5tZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoY3NyLm1kID09PSBudWxsKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBkaWdlc3QuICcgK1xuICAgICAgICAnVW5rbm93biBzaWduYXR1cmUgT0lELicpO1xuICAgICAgZXJyb3Iuc2lnbmF0dXJlT2lkID0gY3NyLnNpZ25hdHVyZU9pZDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIHByb2R1Y2UgREVSIGZvcm1hdHRlZCBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gYW5kIGRpZ2VzdCBpdFxuICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY3NyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyk7XG4gICAgY3NyLm1kLnVwZGF0ZShieXRlcy5nZXRCeXRlcygpKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBzdWJqZWN0LCBidWlsZCBzdWJqZWN0IG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBzbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICBjc3Iuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY3NyLnN1YmplY3QsIHNuKTtcbiAgfTtcbiAgY3NyLnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY3NyLnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzID0gcGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KFxuICAgIGNhcHR1cmUuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvU3ViamVjdCwgc21kKTtcbiAgY3NyLnN1YmplY3QuaGFzaCA9IHNtZC5kaWdlc3QoKS50b0hleCgpO1xuXG4gIC8vIGNvbnZlcnQgUlNBIHB1YmxpYyBrZXkgZnJvbSBBU04uMVxuICBjc3IucHVibGljS2V5ID0gcGtpLnB1YmxpY0tleUZyb21Bc24xKGNhcHR1cmUuc3ViamVjdFB1YmxpY0tleUluZm8pO1xuXG4gIC8vIGNvbnZlcnQgYXR0cmlidXRlcyBmcm9tIEFTTi4xXG4gIGNzci5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNzciwgc24pO1xuICB9O1xuICBjc3IuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNzci5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5hdHRyaWJ1dGVzID0gcGtpLkNSSUF0dHJpYnV0ZXNBc0FycmF5KFxuICAgIGNhcHR1cmUuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvQXR0cmlidXRlcyB8fCBbXSk7XG5cbiAgcmV0dXJuIGNzcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXB0eSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKGEgQ1NSIG9yIGNlcnRpZmljYXRlIHNpZ25pbmdcbiAqIHJlcXVlc3QpLiBPbmNlIGNyZWF0ZWQsIGl0cyBwdWJsaWMga2V5IGFuZCBhdHRyaWJ1dGVzIGNhbiBiZSBzZXQgYW5kIHRoZW5cbiAqIGl0IGNhbiBiZSBzaWduZWQuXG4gKlxuICogQHJldHVybiB0aGUgZW1wdHkgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICovXG5wa2kuY3JlYXRlQ2VydGlmaWNhdGlvblJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNzciA9IHt9O1xuICBjc3IudmVyc2lvbiA9IDB4MDA7XG4gIGNzci5zaWduYXR1cmVPaWQgPSBudWxsO1xuICBjc3Iuc2lnbmF0dXJlID0gbnVsbDtcbiAgY3NyLnNpZ2luZm8gPSB7fTtcbiAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gbnVsbDtcblxuICBjc3Iuc3ViamVjdCA9IHt9O1xuICBjc3Iuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY3NyLnN1YmplY3QsIHNuKTtcbiAgfTtcbiAgY3NyLnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY3NyLnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzID0gW107XG4gIGNzci5zdWJqZWN0Lmhhc2ggPSBudWxsO1xuXG4gIGNzci5wdWJsaWNLZXkgPSBudWxsO1xuICBjc3IuYXR0cmlidXRlcyA9IFtdO1xuICBjc3IuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjc3IsIHNuKTtcbiAgfTtcbiAgY3NyLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjc3IuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjc3IubWQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdWJqZWN0IG9mIHRoaXMgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgdGhlIGFycmF5IG9mIHN1YmplY3QgYXR0cmlidXRlcyB0byB1c2UuXG4gICAqL1xuICBjc3Iuc2V0U3ViamVjdCA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgLy8gc2V0IG5ldyBhdHRyaWJ1dGVzXG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKGF0dHJzKTtcbiAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gICAgY3NyLnN1YmplY3QuaGFzaCA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2YgYXR0cmlidXRlcyB0byB1c2UuXG4gICAqL1xuICBjc3Iuc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgLy8gc2V0IG5ldyBhdHRyaWJ1dGVzXG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKGF0dHJzKTtcbiAgICBjc3IuYXR0cmlidXRlcyA9IGF0dHJzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaWducyB0aGlzIGNlcnRpZmljYXRpb24gcmVxdWVzdCB1c2luZyB0aGUgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5IHRvIHNpZ24gd2l0aC5cbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIChkZWZhdWx0cyB0byBmb3JnZS5tZC5zaGExKS5cbiAgICovXG4gIGNzci5zaWduID0gZnVuY3Rpb24oa2V5LCBtZCkge1xuICAgIC8vIFRPRE86IGdldCBzaWduYXR1cmUgT0lEIGZyb20gcHJpdmF0ZSBrZXlcbiAgICBjc3IubWQgPSBtZCB8fCBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgIHZhciBhbGdvcml0aG1PaWQgPSBvaWRzW2Nzci5tZC5hbGdvcml0aG0gKyAnV2l0aFJTQUVuY3J5cHRpb24nXTtcbiAgICBpZighYWxnb3JpdGhtT2lkKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBkaWdlc3QuICcgK1xuICAgICAgICAnVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0gT0lELicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gY3NyLm1kLmFsZ29yaXRobTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjc3Iuc2lnbmF0dXJlT2lkID0gY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gYWxnb3JpdGhtT2lkO1xuXG4gICAgLy8gZ2V0IENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbywgY29udmVydCB0byBERVJcbiAgICBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvID0gcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY3NyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyk7XG5cbiAgICAvLyBkaWdlc3QgYW5kIHNpZ25cbiAgICBjc3IubWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICAgIGNzci5zaWduYXR1cmUgPSBrZXkuc2lnbihjc3IubWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB2ZXJpZnkgdGhlIHNpZ25hdHVyZSBvbiB0aGUgcGFzc2VkIGNlcnRpZmljYXRpb24gcmVxdWVzdCB1c2luZ1xuICAgKiBpdHMgcHVibGljIGtleS5cbiAgICpcbiAgICogQSBDU1IgdGhhdCBoYXMgYmVlbiBleHBvcnRlZCB0byBhIGZpbGUgaW4gUEVNIGZvcm1hdCBjYW4gYmUgdmVyaWZpZWQgdXNpbmdcbiAgICogT3BlblNTTCB1c2luZyB0aGlzIGNvbW1hbmQ6XG4gICAqXG4gICAqIG9wZW5zc2wgcmVxIC1pbiA8dGhlLWNzci1wZW0tZmlsZT4gLXZlcmlmeSAtbm9vdXQgLXRleHRcbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBjc3IudmVyaWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJ2YWwgPSBmYWxzZTtcblxuICAgIHZhciBtZCA9IGNzci5tZDtcbiAgICBpZihtZCA9PT0gbnVsbCkge1xuICAgICAgLy8gY2hlY2sgc2lnbmF0dXJlIE9JRCBmb3Igc3VwcG9ydGVkIHNpZ25hdHVyZSB0eXBlc1xuICAgICAgaWYoY3NyLnNpZ25hdHVyZU9pZCBpbiBvaWRzKSB7XG4gICAgICAgIC8vIFRPRE86IGNyZWF0ZSBEUlkgYE9JRCB0byBtZGAgZnVuY3Rpb25cbiAgICAgICAgdmFyIG9pZCA9IG9pZHNbY3NyLnNpZ25hdHVyZU9pZF07XG4gICAgICAgIHN3aXRjaChvaWQpIHtcbiAgICAgICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWQ1V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzaGEyNTZXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2hhNTEyV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdSU0FTU0EtUFNTJzpcbiAgICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGRpZ2VzdC4gJyArXG4gICAgICAgICAgJ1Vua25vd24gc2lnbmF0dXJlIE9JRC4nKTtcbiAgICAgICAgZXJyb3Iuc2lnbmF0dXJlT2lkID0gY3NyLnNpZ25hdHVyZU9pZDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIHByb2R1Y2UgREVSIGZvcm1hdHRlZCBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gYW5kIGRpZ2VzdCBpdFxuICAgICAgdmFyIGNyaSA9IGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gfHxcbiAgICAgICAgcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuICAgICAgdmFyIGJ5dGVzID0gYXNuMS50b0RlcihjcmkpO1xuICAgICAgbWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICAgIH1cblxuICAgIGlmKG1kICE9PSBudWxsKSB7XG4gICAgICB2YXIgc2NoZW1lO1xuXG4gICAgICBzd2l0Y2goY3NyLnNpZ25hdHVyZU9pZCkge1xuICAgICAgICBjYXNlIG9pZHMuc2hhMVdpdGhSU0FFbmNyeXB0aW9uOlxuICAgICAgICAgIC8qIHVzZSBQS0NTIzEgdjEuNSBwYWRkaW5nIHNjaGVtZSAqL1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9pZHNbJ1JTQVNTQS1QU1MnXTpcbiAgICAgICAgICB2YXIgaGFzaCwgbWdmO1xuXG4gICAgICAgICAgLyogaW5pdGlhbGl6ZSBtZ2YgKi9cbiAgICAgICAgICBoYXNoID0gb2lkc1tjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICAgIGlmKGhhc2ggPT09IHVuZGVmaW5lZCB8fCBmb3JnZS5tZFtoYXNoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE1HRiBoYXNoIGZ1bmN0aW9uLicpO1xuICAgICAgICAgICAgZXJyb3Iub2lkID0gY3NyLnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmhhc2guYWxnb3JpdGhtT2lkO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IGhhc2g7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtZ2YgPSBvaWRzW2Nzci5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5hbGdvcml0aG1PaWRdO1xuICAgICAgICAgIGlmKG1nZiA9PT0gdW5kZWZpbmVkIHx8IGZvcmdlLm1nZlttZ2ZdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGZ1bmN0aW9uLicpO1xuICAgICAgICAgICAgZXJyb3Iub2lkID0gY3NyLnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZDtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSBtZ2Y7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtZ2YgPSBmb3JnZS5tZ2ZbbWdmXS5jcmVhdGUoZm9yZ2UubWRbaGFzaF0uY3JlYXRlKCkpO1xuXG4gICAgICAgICAgLyogaW5pdGlhbGl6ZSBoYXNoIGZ1bmN0aW9uICovXG4gICAgICAgICAgaGFzaCA9IG9pZHNbY3NyLnNpZ25hdHVyZVBhcmFtZXRlcnMuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICAgIGlmKGhhc2ggPT09IHVuZGVmaW5lZCB8fCBmb3JnZS5tZFtoYXNoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFJTQVNTQS1QU1MgaGFzaCBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgIGVycm9yLm9pZCA9IGNzci5zaWduYXR1cmVQYXJhbWV0ZXJzLmhhc2guYWxnb3JpdGhtT2lkO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IGhhc2g7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY2hlbWUgPSBmb3JnZS5wc3MuY3JlYXRlKGZvcmdlLm1kW2hhc2hdLmNyZWF0ZSgpLCBtZ2YsXG4gICAgICAgICAgICBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5zYWx0TGVuZ3RoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gdmVyaWZ5IHNpZ25hdHVyZSBvbiBjc3IgdXNpbmcgaXRzIHB1YmxpYyBrZXlcbiAgICAgIHJ2YWwgPSBjc3IucHVibGljS2V5LnZlcmlmeShcbiAgICAgICAgbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKSwgY3NyLnNpZ25hdHVyZSwgc2NoZW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gY3NyO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOSBzdWJqZWN0IG9yIGlzc3VlciB0byBhbiBBU04uMSBSRE5TZXF1ZW5jZS5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBzdWJqZWN0IG9yIGlzc3VlciAoZGlzdGluZ3Vpc2hlZCBuYW1lKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBSRE5TZXF1ZW5jZS5cbiAqL1xuZnVuY3Rpb24gX2RuVG9Bc24xKG9iaikge1xuICAvLyBjcmVhdGUgYW4gZW1wdHkgUkROU2VxdWVuY2VcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG5cbiAgLy8gaXRlcmF0ZSBvdmVyIGF0dHJpYnV0ZXNcbiAgdmFyIGF0dHIsIHNldDtcbiAgdmFyIGF0dHJzID0gb2JqLmF0dHJpYnV0ZXM7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7ICsraSkge1xuICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICB2YXIgdmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgLy8gcmV1c2UgdGFnIGNsYXNzIGZvciBhdHRyaWJ1dGUgdmFsdWUgaWYgYXZhaWxhYmxlXG4gICAgdmFyIHZhbHVlVGFnQ2xhc3MgPSBhc24xLlR5cGUuUFJJTlRBQkxFU1RSSU5HO1xuICAgIGlmKCd2YWx1ZVRhZ0NsYXNzJyBpbiBhdHRyKSB7XG4gICAgICB2YWx1ZVRhZ0NsYXNzID0gYXR0ci52YWx1ZVRhZ0NsYXNzO1xuXG4gICAgICBpZih2YWx1ZVRhZ0NsYXNzID09PSBhc24xLlR5cGUuVVRGOCkge1xuICAgICAgICB2YWx1ZSA9IGZvcmdlLnV0aWwuZW5jb2RlVXRmOCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBGSVhNRTogaGFuZGxlIG1vcmUgZW5jb2RpbmdzXG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGEgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSBzZXRcbiAgICAvLyBlYWNoIHZhbHVlIGluIHRoZSBzZXQgaXMgYW4gQXR0cmlidXRlVHlwZUFuZFZhbHVlIGZpcnN0XG4gICAgLy8gY29udGFpbmluZyB0aGUgdHlwZSAoYW4gT0lEKSBhbmQgc2Vjb25kIHRoZSB2YWx1ZVxuICAgIHNldCA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIEF0dHJpYnV0ZVR5cGVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIoYXR0ci50eXBlKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gQXR0cmlidXRlVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIHZhbHVlVGFnQ2xhc3MsIGZhbHNlLCB2YWx1ZSlcbiAgICAgIF0pXG4gICAgXSk7XG4gICAgcnZhbC52YWx1ZS5wdXNoKHNldCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBHZXRzIGFsbCBwcmludGFibGUgYXR0cmlidXRlcyAodHlwaWNhbGx5IG9mIGFuIGlzc3VlciBvciBzdWJqZWN0KSBpbiBhXG4gKiBzaW1wbGlmaWVkIEpTT04gZm9ybWF0IGZvciBkaXNwbGF5LlxuICpcbiAqIEBwYXJhbSBhdHRycyB0aGUgYXR0cmlidXRlcy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBKU09OIGZvciBkaXNwbGF5LlxuICovXG5mdW5jdGlvbiBfZ2V0QXR0cmlidXRlc0FzSnNvbihhdHRycykge1xuICB2YXIgcnZhbCA9IHt9O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmKGF0dHIuc2hvcnROYW1lICYmIChcbiAgICAgIGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjggfHxcbiAgICAgIGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORyB8fFxuICAgICAgYXR0ci52YWx1ZVRhZ0NsYXNzID09PSBhc24xLlR5cGUuSUE1U1RSSU5HKSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgIGlmKGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgoYXR0ci52YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZighKGF0dHIuc2hvcnROYW1lIGluIHJ2YWwpKSB7XG4gICAgICAgIHJ2YWxbYXR0ci5zaG9ydE5hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYoZm9yZ2UudXRpbC5pc0FycmF5KHJ2YWxbYXR0ci5zaG9ydE5hbWVdKSkge1xuICAgICAgICBydmFsW2F0dHIuc2hvcnROYW1lXS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWxbYXR0ci5zaG9ydE5hbWVdID0gW3J2YWxbYXR0ci5zaG9ydE5hbWVdLCB2YWx1ZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIEZpbGxzIGluIG1pc3NpbmcgZmllbGRzIGluIGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIGF0dHJzIHRoZSBhdHRyaWJ1dGVzIHRvIGZpbGwgbWlzc2luZyBmaWVsZHMgaW4uXG4gKi9cbmZ1bmN0aW9uIF9maWxsTWlzc2luZ0ZpZWxkcyhhdHRycykge1xuICB2YXIgYXR0cjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgYXR0ciA9IGF0dHJzW2ldO1xuXG4gICAgLy8gcG9wdWxhdGUgbWlzc2luZyBuYW1lXG4gICAgaWYodHlwZW9mIGF0dHIubmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmKGF0dHIudHlwZSAmJiBhdHRyLnR5cGUgaW4gcGtpLm9pZHMpIHtcbiAgICAgICAgYXR0ci5uYW1lID0gcGtpLm9pZHNbYXR0ci50eXBlXTtcbiAgICAgIH0gZWxzZSBpZihhdHRyLnNob3J0TmFtZSAmJiBhdHRyLnNob3J0TmFtZSBpbiBfc2hvcnROYW1lcykge1xuICAgICAgICBhdHRyLm5hbWUgPSBwa2kub2lkc1tfc2hvcnROYW1lc1thdHRyLnNob3J0TmFtZV1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBvcHVsYXRlIG1pc3NpbmcgdHlwZSAoT0lEKVxuICAgIGlmKHR5cGVvZiBhdHRyLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZihhdHRyLm5hbWUgJiYgYXR0ci5uYW1lIGluIHBraS5vaWRzKSB7XG4gICAgICAgIGF0dHIudHlwZSA9IHBraS5vaWRzW2F0dHIubmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB0eXBlIG5vdCBzcGVjaWZpZWQuJyk7XG4gICAgICAgIGVycm9yLmF0dHJpYnV0ZSA9IGF0dHI7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBvcHVsYXRlIG1pc3Npbmcgc2hvcnRuYW1lXG4gICAgaWYodHlwZW9mIGF0dHIuc2hvcnROYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYoYXR0ci5uYW1lICYmIGF0dHIubmFtZSBpbiBfc2hvcnROYW1lcykge1xuICAgICAgICBhdHRyLnNob3J0TmFtZSA9IF9zaG9ydE5hbWVzW2F0dHIubmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBleHRlbnNpb25zIHRvIHZhbHVlXG4gICAgaWYoYXR0ci50eXBlID09PSBvaWRzLmV4dGVuc2lvblJlcXVlc3QpIHtcbiAgICAgIGF0dHIudmFsdWVDb25zdHJ1Y3RlZCA9IHRydWU7XG4gICAgICBhdHRyLnZhbHVlVGFnQ2xhc3MgPSBhc24xLlR5cGUuU0VRVUVOQ0U7XG4gICAgICBpZighYXR0ci52YWx1ZSAmJiBhdHRyLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgYXR0ci52YWx1ZSA9IFtdO1xuICAgICAgICBmb3IodmFyIGVpID0gMDsgZWkgPCBhdHRyLmV4dGVuc2lvbnMubGVuZ3RoOyArK2VpKSB7XG4gICAgICAgICAgYXR0ci52YWx1ZS5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvblRvQXNuMShcbiAgICAgICAgICAgIF9maWxsTWlzc2luZ0V4dGVuc2lvbkZpZWxkcyhhdHRyLmV4dGVuc2lvbnNbZWldKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYodHlwZW9mIGF0dHIudmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB2YWx1ZSBub3Qgc3BlY2lmaWVkLicpO1xuICAgICAgZXJyb3IuYXR0cmlidXRlID0gYXR0cjtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEZpbGxzIGluIG1pc3NpbmcgZmllbGRzIGluIGNlcnRpZmljYXRlIGV4dGVuc2lvbnMuXG4gKlxuICogQHBhcmFtIGUgdGhlIGV4dGVuc2lvbi5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAgW2NlcnRdIHRoZSBjZXJ0aWZpY2F0ZSB0aGUgZXh0ZW5zaW9ucyBhcmUgZm9yLlxuICpcbiAqIEByZXR1cm4gdGhlIGV4dGVuc2lvbi5cbiAqL1xuZnVuY3Rpb24gX2ZpbGxNaXNzaW5nRXh0ZW5zaW9uRmllbGRzKGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gcG9wdWxhdGUgbWlzc2luZyBuYW1lXG4gIGlmKHR5cGVvZiBlLm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYoZS5pZCAmJiBlLmlkIGluIHBraS5vaWRzKSB7XG4gICAgICBlLm5hbWUgPSBwa2kub2lkc1tlLmlkXTtcbiAgICB9XG4gIH1cblxuICAvLyBwb3B1bGF0ZSBtaXNzaW5nIGlkXG4gIGlmKHR5cGVvZiBlLmlkID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmKGUubmFtZSAmJiBlLm5hbWUgaW4gcGtpLm9pZHMpIHtcbiAgICAgIGUuaWQgPSBwa2kub2lkc1tlLm5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBJRCBub3Qgc3BlY2lmaWVkLicpO1xuICAgICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGlmKHR5cGVvZiBlLnZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBlO1xuICB9XG5cbiAgLy8gaGFuZGxlIG1pc3NpbmcgdmFsdWU6XG5cbiAgLy8gdmFsdWUgaXMgYSBCSVQgU1RSSU5HXG4gIGlmKGUubmFtZSA9PT0gJ2tleVVzYWdlJykge1xuICAgIC8vIGJ1aWxkIGZsYWdzXG4gICAgdmFyIHVudXNlZCA9IDA7XG4gICAgdmFyIGIyID0gMHgwMDtcbiAgICB2YXIgYjMgPSAweDAwO1xuICAgIGlmKGUuZGlnaXRhbFNpZ25hdHVyZSkge1xuICAgICAgYjIgfD0gMHg4MDtcbiAgICAgIHVudXNlZCA9IDc7XG4gICAgfVxuICAgIGlmKGUubm9uUmVwdWRpYXRpb24pIHtcbiAgICAgIGIyIHw9IDB4NDA7XG4gICAgICB1bnVzZWQgPSA2O1xuICAgIH1cbiAgICBpZihlLmtleUVuY2lwaGVybWVudCkge1xuICAgICAgYjIgfD0gMHgyMDtcbiAgICAgIHVudXNlZCA9IDU7XG4gICAgfVxuICAgIGlmKGUuZGF0YUVuY2lwaGVybWVudCkge1xuICAgICAgYjIgfD0gMHgxMDtcbiAgICAgIHVudXNlZCA9IDQ7XG4gICAgfVxuICAgIGlmKGUua2V5QWdyZWVtZW50KSB7XG4gICAgICBiMiB8PSAweDA4O1xuICAgICAgdW51c2VkID0gMztcbiAgICB9XG4gICAgaWYoZS5rZXlDZXJ0U2lnbikge1xuICAgICAgYjIgfD0gMHgwNDtcbiAgICAgIHVudXNlZCA9IDI7XG4gICAgfVxuICAgIGlmKGUuY1JMU2lnbikge1xuICAgICAgYjIgfD0gMHgwMjtcbiAgICAgIHVudXNlZCA9IDE7XG4gICAgfVxuICAgIGlmKGUuZW5jaXBoZXJPbmx5KSB7XG4gICAgICBiMiB8PSAweDAxO1xuICAgICAgdW51c2VkID0gMDtcbiAgICB9XG4gICAgaWYoZS5kZWNpcGhlck9ubHkpIHtcbiAgICAgIGIzIHw9IDB4ODA7XG4gICAgICB1bnVzZWQgPSA3O1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBiaXQgc3RyaW5nXG4gICAgdmFyIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bnVzZWQpO1xuICAgIGlmKGIzICE9PSAwKSB7XG4gICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIyKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYjMpO1xuICAgIH0gZWxzZSBpZihiMiAhPT0gMCkge1xuICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiMik7XG4gICAgfVxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnYmFzaWNDb25zdHJhaW50cycpIHtcbiAgICAvLyBiYXNpY0NvbnN0cmFpbnRzIGlzIGEgU0VRVUVOQ0VcbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gICAgLy8gY0EgQk9PTEVBTiBmbGFnIGRlZmF1bHRzIHRvIGZhbHNlXG4gICAgaWYoZS5jQSkge1xuICAgICAgZS52YWx1ZS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJPT0xFQU4sIGZhbHNlLFxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkYpKSk7XG4gICAgfVxuICAgIGlmKCdwYXRoTGVuQ29uc3RyYWludCcgaW4gZSkge1xuICAgICAgZS52YWx1ZS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0RlcihlLnBhdGhMZW5Db25zdHJhaW50KS5nZXRCeXRlcygpKSk7XG4gICAgfVxuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnZXh0S2V5VXNhZ2UnKSB7XG4gICAgLy8gZXh0S2V5VXNhZ2UgaXMgYSBTRVFVRU5DRSBvZiBPSURzXG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICAgIHZhciBzZXEgPSBlLnZhbHVlLnZhbHVlO1xuICAgIGZvcih2YXIga2V5IGluIGUpIHtcbiAgICAgIGlmKGVba2V5XSAhPT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIGtleSBpcyBuYW1lIGluIE9JRCBtYXBcbiAgICAgIGlmKGtleSBpbiBvaWRzKSB7XG4gICAgICAgIHNlcS5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGZhbHNlLCBhc24xLm9pZFRvRGVyKG9pZHNba2V5XSkuZ2V0Qnl0ZXMoKSkpO1xuICAgICAgfSBlbHNlIGlmKGtleS5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgICAgIC8vIGFzc3VtZSBrZXkgaXMgYW4gT0lEXG4gICAgICAgIHNlcS5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGZhbHNlLCBhc24xLm9pZFRvRGVyKGtleSkuZ2V0Qnl0ZXMoKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ25zQ2VydFR5cGUnKSB7XG4gICAgLy8gbnNDZXJ0VHlwZSBpcyBhIEJJVCBTVFJJTkdcbiAgICAvLyBidWlsZCBmbGFnc1xuICAgIHZhciB1bnVzZWQgPSAwO1xuICAgIHZhciBiMiA9IDB4MDA7XG5cbiAgICBpZihlLmNsaWVudCkge1xuICAgICAgYjIgfD0gMHg4MDtcbiAgICAgIHVudXNlZCA9IDc7XG4gICAgfVxuICAgIGlmKGUuc2VydmVyKSB7XG4gICAgICBiMiB8PSAweDQwO1xuICAgICAgdW51c2VkID0gNjtcbiAgICB9XG4gICAgaWYoZS5lbWFpbCkge1xuICAgICAgYjIgfD0gMHgyMDtcbiAgICAgIHVudXNlZCA9IDU7XG4gICAgfVxuICAgIGlmKGUub2Jqc2lnbikge1xuICAgICAgYjIgfD0gMHgxMDtcbiAgICAgIHVudXNlZCA9IDQ7XG4gICAgfVxuICAgIGlmKGUucmVzZXJ2ZWQpIHtcbiAgICAgIGIyIHw9IDB4MDg7XG4gICAgICB1bnVzZWQgPSAzO1xuICAgIH1cbiAgICBpZihlLnNzbENBKSB7XG4gICAgICBiMiB8PSAweDA0O1xuICAgICAgdW51c2VkID0gMjtcbiAgICB9XG4gICAgaWYoZS5lbWFpbENBKSB7XG4gICAgICBiMiB8PSAweDAyO1xuICAgICAgdW51c2VkID0gMTtcbiAgICB9XG4gICAgaWYoZS5vYmpDQSkge1xuICAgICAgYjIgfD0gMHgwMTtcbiAgICAgIHVudXNlZCA9IDA7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGJpdCBzdHJpbmdcbiAgICB2YXIgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVudXNlZCk7XG4gICAgaWYoYjIgIT09IDApIHtcbiAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYjIpO1xuICAgIH1cbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ3N1YmplY3RBbHROYW1lJyB8fCBlLm5hbWUgPT09ICdpc3N1ZXJBbHROYW1lJykge1xuICAgIC8vIFNZTlRBWCBTRVFVRU5DRVxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG5cbiAgICB2YXIgYWx0TmFtZTtcbiAgICBmb3IodmFyIG4gPSAwOyBuIDwgZS5hbHROYW1lcy5sZW5ndGg7ICsrbikge1xuICAgICAgYWx0TmFtZSA9IGUuYWx0TmFtZXNbbl07XG4gICAgICB2YXIgdmFsdWUgPSBhbHROYW1lLnZhbHVlO1xuICAgICAgLy8gaGFuZGxlIElQXG4gICAgICBpZihhbHROYW1lLnR5cGUgPT09IDcgJiYgYWx0TmFtZS5pcCkge1xuICAgICAgICB2YWx1ZSA9IGZvcmdlLnV0aWwuYnl0ZXNGcm9tSVAoYWx0TmFtZS5pcCk7XG4gICAgICAgIGlmKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0V4dGVuc2lvbiBcImlwXCIgdmFsdWUgaXMgbm90IGEgdmFsaWQgSVB2NCBvciBJUHY2IGFkZHJlc3MuJyk7XG4gICAgICAgICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGFsdE5hbWUudHlwZSA9PT0gOCkge1xuICAgICAgICAvLyBoYW5kbGUgT0lEXG4gICAgICAgIGlmKGFsdE5hbWUub2lkKSB7XG4gICAgICAgICAgdmFsdWUgPSBhc24xLm9pZFRvRGVyKGFzbjEub2lkVG9EZXIoYWx0TmFtZS5vaWQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZXByZWNhdGVkIC4uLiBjb252ZXJ0IHZhbHVlIHRvIE9JRFxuICAgICAgICAgIHZhbHVlID0gYXNuMS5vaWRUb0Rlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGUudmFsdWUudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCBhbHROYW1lLnR5cGUsIGZhbHNlLFxuICAgICAgICB2YWx1ZSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ25zQ29tbWVudCcgJiYgb3B0aW9ucy5jZXJ0KSB7XG4gICAgLy8gc2FuaXR5IGNoZWNrIHZhbHVlIGlzIEFTQ0lJIChyZXEnZCkgYW5kIG5vdCB0b28gYmlnXG4gICAgaWYoISgvXltcXHgwMC1cXHg3Rl0qJC8udGVzdChlLmNvbW1lbnQpKSB8fFxuICAgICAgKGUuY29tbWVudC5sZW5ndGggPCAxKSB8fCAoZS5jb21tZW50Lmxlbmd0aCA+IDEyOCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBcIm5zQ29tbWVudFwiIGNvbnRlbnQuJyk7XG4gICAgfVxuICAgIC8vIElBNVNUUklORyBvcGFxdWUgY29tbWVudFxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSUE1U1RSSU5HLCBmYWxzZSwgZS5jb21tZW50KTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ3N1YmplY3RLZXlJZGVudGlmaWVyJyAmJiBvcHRpb25zLmNlcnQpIHtcbiAgICB2YXIgc2tpID0gb3B0aW9ucy5jZXJ0LmdlbmVyYXRlU3ViamVjdEtleUlkZW50aWZpZXIoKTtcbiAgICBlLnN1YmplY3RLZXlJZGVudGlmaWVyID0gc2tpLnRvSGV4KCk7XG4gICAgLy8gT0NURVRTVFJJTkcgdy9kaWdlc3RcbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgc2tpLmdldEJ5dGVzKCkpO1xuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnYXV0aG9yaXR5S2V5SWRlbnRpZmllcicgJiYgb3B0aW9ucy5jZXJ0KSB7XG4gICAgLy8gU1lOVEFYIFNFUVVFTkNFXG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgICB2YXIgc2VxID0gZS52YWx1ZS52YWx1ZTtcblxuICAgIGlmKGUua2V5SWRlbnRpZmllcikge1xuICAgICAgdmFyIGtleUlkZW50aWZpZXIgPSAoZS5rZXlJZGVudGlmaWVyID09PSB0cnVlID9cbiAgICAgICAgb3B0aW9ucy5jZXJ0LmdlbmVyYXRlU3ViamVjdEtleUlkZW50aWZpZXIoKS5nZXRCeXRlcygpIDpcbiAgICAgICAgZS5rZXlJZGVudGlmaWVyKTtcbiAgICAgIHNlcS5wdXNoKFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIGZhbHNlLCBrZXlJZGVudGlmaWVyKSk7XG4gICAgfVxuXG4gICAgaWYoZS5hdXRob3JpdHlDZXJ0SXNzdWVyKSB7XG4gICAgICB2YXIgYXV0aG9yaXR5Q2VydElzc3VlciA9IFtcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCA0LCB0cnVlLCBbXG4gICAgICAgICAgX2RuVG9Bc24xKGUuYXV0aG9yaXR5Q2VydElzc3VlciA9PT0gdHJ1ZSA/XG4gICAgICAgICAgICBvcHRpb25zLmNlcnQuaXNzdWVyIDogZS5hdXRob3JpdHlDZXJ0SXNzdWVyKVxuICAgICAgICBdKVxuICAgICAgXTtcbiAgICAgIHNlcS5wdXNoKFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDEsIHRydWUsIGF1dGhvcml0eUNlcnRJc3N1ZXIpKTtcbiAgICB9XG5cbiAgICBpZihlLnNlcmlhbE51bWJlcikge1xuICAgICAgdmFyIHNlcmlhbE51bWJlciA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhlLnNlcmlhbE51bWJlciA9PT0gdHJ1ZSA/XG4gICAgICAgIG9wdGlvbnMuY2VydC5zZXJpYWxOdW1iZXIgOiBlLnNlcmlhbE51bWJlcik7XG4gICAgICBzZXEucHVzaChcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCBmYWxzZSwgc2VyaWFsTnVtYmVyKSk7XG4gICAgfVxuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnY1JMRGlzdHJpYnV0aW9uUG9pbnRzJykge1xuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gICAgdmFyIHNlcSA9IGUudmFsdWUudmFsdWU7XG5cbiAgICAvLyBDcmVhdGUgc3ViIFNFUVVFTkNFIG9mIERpc3RyaWJ1dGlvblBvaW50TmFtZVxuICAgIHZhciBzdWJTZXEgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcblxuICAgIC8vIENyZWF0ZSBmdWxsTmFtZSBDSE9JQ0VcbiAgICB2YXIgZnVsbE5hbWVHZW5lcmFsTmFtZXMgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW10pO1xuICAgIHZhciBhbHROYW1lO1xuICAgIGZvcih2YXIgbiA9IDA7IG4gPCBlLmFsdE5hbWVzLmxlbmd0aDsgKytuKSB7XG4gICAgICBhbHROYW1lID0gZS5hbHROYW1lc1tuXTtcbiAgICAgIHZhciB2YWx1ZSA9IGFsdE5hbWUudmFsdWU7XG4gICAgICAvLyBoYW5kbGUgSVBcbiAgICAgIGlmKGFsdE5hbWUudHlwZSA9PT0gNyAmJiBhbHROYW1lLmlwKSB7XG4gICAgICAgIHZhbHVlID0gZm9yZ2UudXRpbC5ieXRlc0Zyb21JUChhbHROYW1lLmlwKTtcbiAgICAgICAgaWYodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnRXh0ZW5zaW9uIFwiaXBcIiB2YWx1ZSBpcyBub3QgYSB2YWxpZCBJUHY0IG9yIElQdjYgYWRkcmVzcy4nKTtcbiAgICAgICAgICBlcnJvci5leHRlbnNpb24gPSBlO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoYWx0TmFtZS50eXBlID09PSA4KSB7XG4gICAgICAgIC8vIGhhbmRsZSBPSURcbiAgICAgICAgaWYoYWx0TmFtZS5vaWQpIHtcbiAgICAgICAgICB2YWx1ZSA9IGFzbjEub2lkVG9EZXIoYXNuMS5vaWRUb0RlcihhbHROYW1lLm9pZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRlcHJlY2F0ZWQgLi4uIGNvbnZlcnQgdmFsdWUgdG8gT0lEXG4gICAgICAgICAgdmFsdWUgPSBhc24xLm9pZFRvRGVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVsbE5hbWVHZW5lcmFsTmFtZXMudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCBhbHROYW1lLnR5cGUsIGZhbHNlLFxuICAgICAgICB2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8vIEFkZCB0byB0aGUgcGFyZW50IFNFUVVFTkNFXG4gICAgc3ViU2VxLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtmdWxsTmFtZUdlbmVyYWxOYW1lc10pKTtcbiAgICBzZXEucHVzaChzdWJTZXEpO1xuICB9XG5cbiAgLy8gZW5zdXJlIHZhbHVlIGhhcyBiZWVuIGRlZmluZWQgYnkgbm93XG4gIGlmKHR5cGVvZiBlLnZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignRXh0ZW5zaW9uIHZhbHVlIG5vdCBzcGVjaWZpZWQuJyk7XG4gICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHJldHVybiBlO1xufVxuXG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgb2JqZWN0IHRvIEFTTi4xXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9pZCBTaWduYXR1cmUgYWxnb3JpdGhtIE9JRFxuICogQHBhcmFtIHBhcmFtcyBUaGUgc2lnbmF0dXJlIHBhcmFtZXRycyBvYmplY3RcbiAqIEByZXR1cm4gQVNOLjEgb2JqZWN0IHJlcHJlc2VudGluZyBzaWduYXR1cmUgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMShvaWQsIHBhcmFtcykge1xuICBzd2l0Y2gob2lkKSB7XG4gICAgY2FzZSBvaWRzWydSU0FTU0EtUFNTJ106XG4gICAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgICAgaWYocGFyYW1zLmhhc2guYWxnb3JpdGhtT2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFydHMucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGFyYW1zLmhhc2guYWxnb3JpdGhtT2lkKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pKTtcbiAgICAgIH1cblxuICAgICAgaWYocGFyYW1zLm1nZi5hbGdvcml0aG1PaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJ0cy5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihwYXJhbXMubWdmLmFsZ29yaXRobU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBhcmFtcy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSlcbiAgICAgICAgXSkpO1xuICAgICAgfVxuXG4gICAgICBpZihwYXJhbXMuc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEuaW50ZWdlclRvRGVyKHBhcmFtcy5zYWx0TGVuZ3RoKS5nZXRCeXRlcygpKVxuICAgICAgICBdKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBwYXJ0cyk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgY2VydGlmaWNhdGlvbiByZXF1ZXN0J3MgYXR0cmlidXRlcyB0byBhbiBBU04uMSBzZXQgb2ZcbiAqIENSSUF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIGNzciBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgc2V0IG9mIENSSUF0dHJpYnV0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9DUklBdHRyaWJ1dGVzVG9Bc24xKGNzcikge1xuICAvLyBjcmVhdGUgYW4gZW1wdHkgY29udGV4dC1zcGVjaWZpYyBjb250YWluZXJcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtdKTtcblxuICAvLyBubyBhdHRyaWJ1dGVzLCByZXR1cm4gZW1wdHkgY29udGFpbmVyXG4gIGlmKGNzci5hdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBydmFsO1xuICB9XG5cbiAgLy8gZWFjaCBhdHRyaWJ1dGUgaGFzIGEgc2VxdWVuY2Ugd2l0aCBhIHR5cGUgYW5kIGEgc2V0IG9mIHZhbHVlc1xuICB2YXIgYXR0cnMgPSBjc3IuYXR0cmlidXRlcztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICB2YXIgdmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgLy8gcmV1c2UgdGFnIGNsYXNzIGZvciBhdHRyaWJ1dGUgdmFsdWUgaWYgYXZhaWxhYmxlXG4gICAgdmFyIHZhbHVlVGFnQ2xhc3MgPSBhc24xLlR5cGUuVVRGODtcbiAgICBpZigndmFsdWVUYWdDbGFzcycgaW4gYXR0cikge1xuICAgICAgdmFsdWVUYWdDbGFzcyA9IGF0dHIudmFsdWVUYWdDbGFzcztcbiAgICB9XG4gICAgaWYodmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgIHZhbHVlID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KHZhbHVlKTtcbiAgICB9XG4gICAgdmFyIHZhbHVlQ29uc3RydWN0ZWQgPSBmYWxzZTtcbiAgICBpZigndmFsdWVDb25zdHJ1Y3RlZCcgaW4gYXR0cikge1xuICAgICAgdmFsdWVDb25zdHJ1Y3RlZCA9IGF0dHIudmFsdWVDb25zdHJ1Y3RlZDtcbiAgICB9XG4gICAgLy8gRklYTUU6IGhhbmRsZSBtb3JlIGVuY29kaW5nc1xuXG4gICAgLy8gY3JlYXRlIGEgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSBzZXRcbiAgICAvLyBlYWNoIHZhbHVlIGluIHRoZSBzZXQgaXMgYW4gQXR0cmlidXRlVHlwZUFuZFZhbHVlIGZpcnN0XG4gICAgLy8gY29udGFpbmluZyB0aGUgdHlwZSAoYW4gT0lEKSBhbmQgc2Vjb25kIHRoZSB2YWx1ZVxuICAgIHZhciBzZXEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBBdHRyaWJ1dGVUeXBlXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoYXR0ci50eXBlKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgIC8vIEF0dHJpYnV0ZVZhbHVlXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCB2YWx1ZVRhZ0NsYXNzLCB2YWx1ZUNvbnN0cnVjdGVkLCB2YWx1ZSlcbiAgICAgIF0pXG4gICAgXSk7XG4gICAgcnZhbC52YWx1ZS5wdXNoKHNlcSk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn1cblxudmFyIGphbl8xXzE5NTAgPSBuZXcgRGF0ZSgnMTk1MC0wMS0wMVQwMDowMDowMFonKTtcbnZhciBqYW5fMV8yMDUwID0gbmV3IERhdGUoJzIwNTAtMDEtMDFUMDA6MDA6MDBaJyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBEYXRlIG9iamVjdCB0byBBU04uMVxuICogSGFuZGxlcyB0aGUgZGlmZmVyZW50IGZvcm1hdCBiZWZvcmUgYW5kIGFmdGVyIDFzdCBKYW51YXJ5IDIwNTBcbiAqXG4gKiBAcGFyYW0gZGF0ZSBkYXRlIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRlLlxuICovXG5mdW5jdGlvbiBfZGF0ZVRvQXNuMShkYXRlKSB7XG4gIGlmKGRhdGUgPj0gamFuXzFfMTk1MCAmJiBkYXRlIDwgamFuXzFfMjA1MCkge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuVVRDVElNRSwgZmFsc2UsXG4gICAgICBhc24xLmRhdGVUb1V0Y1RpbWUoZGF0ZSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLCBmYWxzZSxcbiAgICAgIGFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lKGRhdGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIEFTTi4xIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgYW4gWC41MDl2MyBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSBUQlNDZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmdldFRCU0NlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICB2YXIgbm90QmVmb3JlID0gX2RhdGVUb0FzbjEoY2VydC52YWxpZGl0eS5ub3RCZWZvcmUpO1xuICB2YXIgbm90QWZ0ZXIgPSBfZGF0ZVRvQXNuMShjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyKTtcbiAgdmFyIHRicyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAvLyBpbnRlZ2VyXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0RlcihjZXJ0LnZlcnNpb24pLmdldEJ5dGVzKCkpXG4gICAgXSksXG4gICAgLy8gc2VyaWFsTnVtYmVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhjZXJ0LnNlcmlhbE51bWJlcikpLFxuICAgIC8vIHNpZ25hdHVyZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoXG4gICAgICAgIGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQsIGNlcnQuc2lnaW5mby5wYXJhbWV0ZXJzKVxuICAgIF0pLFxuICAgIC8vIGlzc3VlclxuICAgIF9kblRvQXNuMShjZXJ0Lmlzc3VlciksXG4gICAgLy8gdmFsaWRpdHlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBub3RCZWZvcmUsXG4gICAgICBub3RBZnRlclxuICAgIF0pLFxuICAgIC8vIHN1YmplY3RcbiAgICBfZG5Ub0FzbjEoY2VydC5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY2VydC5wdWJsaWNLZXkpXG4gIF0pO1xuXG4gIGlmKGNlcnQuaXNzdWVyLnVuaXF1ZUlkKSB7XG4gICAgLy8gaXNzdWVyVW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuaXNzdWVyLnVuaXF1ZUlkXG4gICAgICAgIClcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuICBpZihjZXJ0LnN1YmplY3QudW5pcXVlSWQpIHtcbiAgICAvLyBzdWJqZWN0VW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuc3ViamVjdC51bmlxdWVJZFxuICAgICAgICApXG4gICAgICBdKVxuICAgICk7XG4gIH1cblxuICBpZihjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoID4gMCkge1xuICAgIC8vIGV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNUb0FzbjEoY2VydC5leHRlbnNpb25zKSk7XG4gIH1cblxuICByZXR1cm4gdGJzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBBU04uMSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gcGFydCBvZiBhXG4gKiBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBjc3IgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5cbiAqL1xucGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9cbiAgdmFyIGNyaSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGFzbjEuaW50ZWdlclRvRGVyKGNzci52ZXJzaW9uKS5nZXRCeXRlcygpKSxcbiAgICAvLyBzdWJqZWN0XG4gICAgX2RuVG9Bc24xKGNzci5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY3NyLnB1YmxpY0tleSksXG4gICAgLy8gYXR0cmlidXRlc1xuICAgIF9DUklBdHRyaWJ1dGVzVG9Bc24xKGNzcilcbiAgXSk7XG5cbiAgcmV0dXJuIGNyaTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBEaXN0aW5ndWlzaGVkTmFtZSAoc3ViamVjdCBvciBpc3N1ZXIpIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gZG4gdGhlIERpc3Rpbmd1aXNoZWROYW1lLlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBEaXN0aW5ndWlzaGVkTmFtZS5cbiAqL1xucGtpLmRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xID0gZnVuY3Rpb24oZG4pIHtcbiAgcmV0dXJuIF9kblRvQXNuMShkbik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFguNTA5djMgUlNBIGNlcnRpZmljYXRlIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNlcnRpZmljYXRlVG9Bc24xID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBwcmVmZXIgY2FjaGVkIFRCU0NlcnRpZmljYXRlIG92ZXIgZ2VuZXJhdGluZyBvbmVcbiAgdmFyIHRic0NlcnRpZmljYXRlID0gY2VydC50YnNDZXJ0aWZpY2F0ZSB8fCBwa2kuZ2V0VEJTQ2VydGlmaWNhdGUoY2VydCk7XG5cbiAgLy8gQ2VydGlmaWNhdGVcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICAgIHRic0NlcnRpZmljYXRlLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY2VydC5zaWduYXR1cmVPaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoY2VydC5zaWduYXR1cmVPaWQsIGNlcnQuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgKyBjZXJ0LnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIFguNTA5djMgY2VydGlmaWNhdGUgZXh0ZW5zaW9ucyB0byBBU04uMS5cbiAqXG4gKiBAcGFyYW0gZXh0cyB0aGUgZXh0ZW5zaW9ucyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGV4dGVuc2lvbnMgaW4gQVNOLjEgZm9ybWF0LlxuICovXG5wa2kuY2VydGlmaWNhdGVFeHRlbnNpb25zVG9Bc24xID0gZnVuY3Rpb24oZXh0cykge1xuICAvLyBjcmVhdGUgdG9wLWxldmVsIGV4dGVuc2lvbiBjb250YWluZXJcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDMsIHRydWUsIFtdKTtcblxuICAvLyBjcmVhdGUgZXh0ZW5zaW9uIHNlcXVlbmNlIChzdG9yZXMgYSBzZXF1ZW5jZSBmb3IgZWFjaCBleHRlbnNpb24pXG4gIHZhciBzZXEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIHJ2YWwudmFsdWUucHVzaChzZXEpO1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgKytpKSB7XG4gICAgc2VxLnZhbHVlLnB1c2gocGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xKGV4dHNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpbmdsZSBjZXJ0aWZpY2F0ZSBleHRlbnNpb24gdG8gQVNOLjEuXG4gKlxuICogQHBhcmFtIGV4dCB0aGUgZXh0ZW5zaW9uIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgZXh0ZW5zaW9uIGluIEFTTi4xIGZvcm1hdC5cbiAqL1xucGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gIC8vIGNyZWF0ZSBhIHNlcXVlbmNlIGZvciBlYWNoIGV4dGVuc2lvblxuICB2YXIgZXh0c2VxID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gIC8vIGV4dG5JRCAoT0lEKVxuICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgYXNuMS5vaWRUb0RlcihleHQuaWQpLmdldEJ5dGVzKCkpKTtcblxuICAvLyBjcml0aWNhbCBkZWZhdWx0cyB0byBmYWxzZVxuICBpZihleHQuY3JpdGljYWwpIHtcbiAgICAvLyBjcml0aWNhbCBCT09MRUFOIERFRkFVTFQgRkFMU0VcbiAgICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQk9PTEVBTiwgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkYpKSk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBleHQudmFsdWU7XG4gIGlmKHR5cGVvZiBleHQudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gdmFsdWUgaXMgYXNuLjFcbiAgICB2YWx1ZSA9IGFzbjEudG9EZXIodmFsdWUpLmdldEJ5dGVzKCk7XG4gIH1cblxuICAvLyBleHRuVmFsdWUgKE9DVEVUIFNUUklORylcbiAgZXh0c2VxLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHZhbHVlKSk7XG5cbiAgcmV0dXJuIGV4dHNlcTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEwIGNlcnRpZmljYXRpb24gcmVxdWVzdCB0byBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGNzciB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvQXNuMSA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBwcmVmZXIgY2FjaGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBvdmVyIGdlbmVyYXRpbmcgb25lXG4gIHZhciBjcmkgPSBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHx8XG4gICAgcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuXG4gIC8vIENlcnRpZmljYXRlXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvXG4gICAgY3JpLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY3NyLnNpZ25hdHVyZU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwYXJhbWV0ZXJzXG4gICAgICBfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMShjc3Iuc2lnbmF0dXJlT2lkLCBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBzaWduYXR1cmVcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApICsgY3NyLnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDQSBzdG9yZS5cbiAqXG4gKiBAcGFyYW0gY2VydHMgYW4gb3B0aW9uYWwgYXJyYXkgb2YgY2VydGlmaWNhdGUgb2JqZWN0cyBvciBQRU0tZm9ybWF0dGVkXG4gKiAgICAgICAgICBjZXJ0aWZpY2F0ZSBzdHJpbmdzIHRvIGFkZCB0byB0aGUgQ0Egc3RvcmUuXG4gKlxuICogQHJldHVybiB0aGUgQ0Egc3RvcmUuXG4gKi9cbnBraS5jcmVhdGVDYVN0b3JlID0gZnVuY3Rpb24oY2VydHMpIHtcbiAgLy8gY3JlYXRlIENBIHN0b3JlXG4gIHZhciBjYVN0b3JlID0ge1xuICAgIC8vIHN0b3JlZCBjZXJ0aWZpY2F0ZXNcbiAgICBjZXJ0czoge31cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgY2VydGlmaWNhdGUgdGhhdCBpc3N1ZWQgdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSBvciBpdHNcbiAgICogJ3BhcmVudCcuXG4gICAqXG4gICAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byBnZXQgdGhlIHBhcmVudCBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHBhcmVudCBjZXJ0aWZpY2F0ZSBvciBudWxsIGlmIG5vbmUgd2FzIGZvdW5kLlxuICAgKi9cbiAgY2FTdG9yZS5nZXRJc3N1ZXIgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgdmFyIHJ2YWwgPSBnZXRCeVN1YmplY3QoY2VydC5pc3N1ZXIpO1xuXG4gICAgLy8gc2VlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzXG4gICAgLyppZihmb3JnZS51dGlsLmlzQXJyYXkocnZhbCkpIHtcbiAgICAgIC8vIFRPRE86IHJlc29sdmUgbXVsdGlwbGUgbWF0Y2hlcyBieSBjaGVja2luZ1xuICAgICAgLy8gYXV0aG9yaXR5S2V5L3N1YmplY3RLZXkvaXNzdWVyVW5pcXVlSUQvb3RoZXIgaWRlbnRpZmllcnMsIGV0Yy5cbiAgICAgIC8vIEZJWE1FOiBvciBhbHRlcm5hdGl2ZWx5IGRvIGF1dGhvcml0eSBrZXkgbWFwcGluZ1xuICAgICAgLy8gaWYgcG9zc2libGUgKFguNTA5djEgY2VydHMgY2FuJ3Qgd29yaz8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBtdWx0aXBsZSBpc3N1ZXIgbWF0Y2hlcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgIH0qL1xuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB0cnVzdGVkIGNlcnRpZmljYXRlIHRvIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIGFkZCBhcyBhIHRydXN0ZWQgY2VydGlmaWNhdGUgKGVpdGhlciBhXG4gICAqICAgICAgICAgIHBraS5jZXJ0aWZpY2F0ZSBvYmplY3Qgb3IgYSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlKS5cbiAgICovXG4gIGNhU3RvcmUuYWRkQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgLy8gY29udmVydCBmcm9tIHBlbSBpZiBuZWNlc3NhcnlcbiAgICBpZih0eXBlb2YgY2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgIH1cblxuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKGNlcnQuc3ViamVjdCk7XG5cbiAgICBpZighY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZShjZXJ0KSkgeyAvLyBhdm9pZCBkdXBsaWNhdGUgY2VydGlmaWNhdGVzIGluIHN0b3JlXG4gICAgICBpZihjZXJ0LnN1YmplY3QuaGFzaCBpbiBjYVN0b3JlLmNlcnRzKSB7XG4gICAgICAgIC8vIHN1YmplY3QgaGFzaCBhbHJlYWR5IGV4aXN0cywgYXBwZW5kIHRvIGFycmF5XG4gICAgICAgIHZhciB0bXAgPSBjYVN0b3JlLmNlcnRzW2NlcnQuc3ViamVjdC5oYXNoXTtcbiAgICAgICAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheSh0bXApKSB7XG4gICAgICAgICAgdG1wID0gW3RtcF07XG4gICAgICAgIH1cbiAgICAgICAgdG1wLnB1c2goY2VydCk7XG4gICAgICAgIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdID0gdG1wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF0gPSBjZXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgZ2l2ZW4gY2VydGlmaWNhdGUgaXMgaW4gdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2sgKGVpdGhlciBhIHBraS5jZXJ0aWZpY2F0ZSBvciBhXG4gICAqICAgICAgICAgIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIGNlcnRpZmljYXRlIGlzIGluIHRoZSBzdG9yZSwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uKGNlcnQpIHtcbiAgICAvLyBjb252ZXJ0IGZyb20gcGVtIGlmIG5lY2Vzc2FyeVxuICAgIGlmKHR5cGVvZiBjZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2VydCA9IGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUZyb21QZW0oY2VydCk7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gZ2V0QnlTdWJqZWN0KGNlcnQuc3ViamVjdCk7XG4gICAgaWYoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkobWF0Y2gpKSB7XG4gICAgICBtYXRjaCA9IFttYXRjaF07XG4gICAgfVxuICAgIC8vIGNvbXBhcmUgREVSLWVuY29kaW5nIG9mIGNlcnRpZmljYXRlc1xuICAgIHZhciBkZXIxID0gYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEoY2VydCkpLmdldEJ5dGVzKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1hdGNoLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZGVyMiA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKG1hdGNoW2ldKSkuZ2V0Qnl0ZXMoKTtcbiAgICAgIGlmKGRlcjEgPT09IGRlcjIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogTGlzdHMgYWxsIG9mIHRoZSBjZXJ0aWZpY2F0ZXMga2VwdCBpbiB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBwa2kuY2VydGlmaWNhdGUgb2JqZWN0cyBpbiB0aGUgc3RvcmUuXG4gICAqL1xuICBjYVN0b3JlLmxpc3RBbGxDZXJ0aWZpY2F0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2VydExpc3QgPSBbXTtcblxuICAgIGZvcih2YXIgaGFzaCBpbiBjYVN0b3JlLmNlcnRzKSB7XG4gICAgICBpZihjYVN0b3JlLmNlcnRzLmhhc093blByb3BlcnR5KGhhc2gpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNhU3RvcmUuY2VydHNbaGFzaF07XG4gICAgICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgY2VydExpc3QucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjZXJ0TGlzdC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2VydExpc3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjZXJ0aWZpY2F0ZSBmcm9tIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIHJlbW92ZSAoZWl0aGVyIGEgcGtpLmNlcnRpZmljYXRlIG9yIGFcbiAgICogICAgICAgICAgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0ZSkuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRlIHRoYXQgd2FzIHJlbW92ZWQgb3IgbnVsbCBpZiB0aGUgY2VydGlmaWNhdGVcbiAgICogICAgICAgICAgIHdhc24ndCBpbiBzdG9yZS5cbiAgICovXG4gIGNhU3RvcmUucmVtb3ZlQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIC8vIGNvbnZlcnQgZnJvbSBwZW0gaWYgbmVjZXNzYXJ5XG4gICAgaWYodHlwZW9mIGNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjZXJ0ID0gZm9yZ2UucGtpLmNlcnRpZmljYXRlRnJvbVBlbShjZXJ0KTtcbiAgICB9XG4gICAgZW5zdXJlU3ViamVjdEhhc0hhc2goY2VydC5zdWJqZWN0KTtcbiAgICBpZighY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZShjZXJ0KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gZ2V0QnlTdWJqZWN0KGNlcnQuc3ViamVjdCk7XG5cbiAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KG1hdGNoKSkge1xuICAgICAgcmVzdWx0ID0gY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgICBkZWxldGUgY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgREVSLWVuY29kaW5nIG9mIGNlcnRpZmljYXRlc1xuICAgIHZhciBkZXIxID0gYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEoY2VydCkpLmdldEJ5dGVzKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1hdGNoLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZGVyMiA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKG1hdGNoW2ldKSkuZ2V0Qnl0ZXMoKTtcbiAgICAgIGlmKGRlcjEgPT09IGRlcjIpIHtcbiAgICAgICAgcmVzdWx0ID0gbWF0Y2hbaV07XG4gICAgICAgIG1hdGNoLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYobWF0Y2gubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRCeVN1YmplY3Qoc3ViamVjdCkge1xuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKHN1YmplY3QpO1xuICAgIHJldHVybiBjYVN0b3JlLmNlcnRzW3N1YmplY3QuaGFzaF0gfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZVN1YmplY3RIYXNIYXNoKHN1YmplY3QpIHtcbiAgICAvLyBwcm9kdWNlIHN1YmplY3QgaGFzaCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYoIXN1YmplY3QuaGFzaCkge1xuICAgICAgdmFyIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgIHN1YmplY3QuYXR0cmlidXRlcyA9IHBraS5SRE5BdHRyaWJ1dGVzQXNBcnJheShfZG5Ub0FzbjEoc3ViamVjdCksIG1kKTtcbiAgICAgIHN1YmplY3QuaGFzaCA9IG1kLmRpZ2VzdCgpLnRvSGV4KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXV0by1hZGQgcGFzc2VkIGluIGNlcnRzXG4gIGlmKGNlcnRzKSB7XG4gICAgLy8gcGFyc2UgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0ZXMgYXMgbmVjZXNzYXJ5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNlcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY2VydCA9IGNlcnRzW2ldO1xuICAgICAgY2FTdG9yZS5hZGRDZXJ0aWZpY2F0ZShjZXJ0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FTdG9yZTtcbn07XG5cbi8qKlxuICogQ2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uIGVycm9ycywgYmFzZWQgb24gVExTLlxuICovXG5wa2kuY2VydGlmaWNhdGVFcnJvciA9IHtcbiAgYmFkX2NlcnRpZmljYXRlOiAnZm9yZ2UucGtpLkJhZENlcnRpZmljYXRlJyxcbiAgdW5zdXBwb3J0ZWRfY2VydGlmaWNhdGU6ICdmb3JnZS5wa2kuVW5zdXBwb3J0ZWRDZXJ0aWZpY2F0ZScsXG4gIGNlcnRpZmljYXRlX3Jldm9rZWQ6ICdmb3JnZS5wa2kuQ2VydGlmaWNhdGVSZXZva2VkJyxcbiAgY2VydGlmaWNhdGVfZXhwaXJlZDogJ2ZvcmdlLnBraS5DZXJ0aWZpY2F0ZUV4cGlyZWQnLFxuICBjZXJ0aWZpY2F0ZV91bmtub3duOiAnZm9yZ2UucGtpLkNlcnRpZmljYXRlVW5rbm93bicsXG4gIHVua25vd25fY2E6ICdmb3JnZS5wa2kuVW5rbm93bkNlcnRpZmljYXRlQXV0aG9yaXR5J1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyBhIGNlcnRpZmljYXRlIGNoYWluIGFnYWluc3QgdGhlIGdpdmVuIENlcnRpZmljYXRlIEF1dGhvcml0eSBzdG9yZVxuICogd2l0aCBhbiBvcHRpb25hbCBjdXN0b20gdmVyaWZ5IGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSBjYVN0b3JlIGEgY2VydGlmaWNhdGUgc3RvcmUgdG8gdmVyaWZ5IGFnYWluc3QuXG4gKiBAcGFyYW0gY2hhaW4gdGhlIGNlcnRpZmljYXRlIGNoYWluIHRvIHZlcmlmeSwgd2l0aCB0aGUgcm9vdCBvciBoaWdoZXN0XG4gKiAgICAgICAgICBhdXRob3JpdHkgYXQgdGhlIGVuZCAoYW4gYXJyYXkgb2YgY2VydGlmaWNhdGVzKS5cbiAqIEBwYXJhbSBvcHRpb25zIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBldmVyeSBjZXJ0aWZpY2F0ZSBpbiB0aGUgY2hhaW4gb3JcbiAqICAgICAgICAgICAgICAgICAgYW4gb2JqZWN0IHdpdGg6XG4gKiAgICAgICAgICAgICAgICAgIHZlcmlmeSBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZXZlcnkgY2VydGlmaWNhdGUgaW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgY2hhaW5cbiAqICAgICAgICAgICAgICAgICAgdmFsaWRpdHlDaGVja0RhdGUgdGhlIGRhdGUgYWdhaW5zdCB3aGljaCB0aGUgY2VydGlmaWNhdGVcbiAqICAgICAgICAgICAgICAgICAgICB2YWxpZGl0eSBwZXJpb2Qgc2hvdWxkIGJlIGNoZWNrZWQuIFBhc3MgbnVsbCB0byBub3QgY2hlY2tcbiAqICAgICAgICAgICAgICAgICAgICB0aGUgdmFsaWRpdHkgcGVyaW9kLiBCeSBkZWZhdWx0LCB0aGUgY3VycmVudCBkYXRlIGlzIHVzZWQuXG4gKlxuICogVGhlIHZlcmlmeSBjYWxsYmFjayBoYXMgdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gKlxuICogdmVyaWZpZWQgLSBTZXQgdG8gdHJ1ZSBpZiBjZXJ0aWZpY2F0ZSB3YXMgdmVyaWZpZWQsIG90aGVyd2lzZSB0aGVcbiAqICAgcGtpLmNlcnRpZmljYXRlRXJyb3IgZm9yIHdoeSB0aGUgY2VydGlmaWNhdGUgZmFpbGVkLlxuICogZGVwdGggLSBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgY2hhaW4sIHdoZXJlIDAgaXMgdGhlIGVuZCBwb2ludCdzIGNlcnQuXG4gKiBjZXJ0cyAtIFRoZSBjZXJ0aWZpY2F0ZSBjaGFpbiwgKk5PVEUqIGFuIGVtcHR5IGNoYWluIGluZGljYXRlcyBhbiBhbm9ueW1vdXNcbiAqICAgZW5kIHBvaW50LlxuICpcbiAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgb24gc3VjY2VzcyBhbmQgb24gZmFpbHVyZSBlaXRoZXIgdGhlIGFwcHJvcHJpYXRlXG4gKiBwa2kuY2VydGlmaWNhdGVFcnJvciBvciBhbiBvYmplY3Qgd2l0aCAnZXJyb3InIHNldCB0byB0aGUgYXBwcm9wcmlhdGVcbiAqIHBraS5jZXJ0aWZpY2F0ZUVycm9yIGFuZCAnbWVzc2FnZScgc2V0IHRvIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2UuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIHRocm93biBpZiBub3QuXG4gKi9cbnBraS52ZXJpZnlDZXJ0aWZpY2F0ZUNoYWluID0gZnVuY3Rpb24oY2FTdG9yZSwgY2hhaW4sIG9wdGlvbnMpIHtcbiAgLyogRnJvbTogUkZDMzI4MCAtIEludGVybmV0IFguNTA5IFB1YmxpYyBLZXkgSW5mcmFzdHJ1Y3R1cmUgQ2VydGlmaWNhdGVcbiAgICBTZWN0aW9uIDY6IENlcnRpZmljYXRpb24gUGF0aCBWYWxpZGF0aW9uXG4gICAgU2VlIGlubGluZSBwYXJlbnRoZXRpY2FscyByZWxhdGVkIHRvIHRoaXMgcGFydGljdWxhciBpbXBsZW1lbnRhdGlvbi5cblxuICAgIFRoZSBwcmltYXJ5IGdvYWwgb2YgcGF0aCB2YWxpZGF0aW9uIGlzIHRvIHZlcmlmeSB0aGUgYmluZGluZyBiZXR3ZWVuXG4gICAgYSBzdWJqZWN0IGRpc3Rpbmd1aXNoZWQgbmFtZSBvciBhIHN1YmplY3QgYWx0ZXJuYXRpdmUgbmFtZSBhbmQgc3ViamVjdFxuICAgIHB1YmxpYyBrZXksIGFzIHJlcHJlc2VudGVkIGluIHRoZSBlbmQgZW50aXR5IGNlcnRpZmljYXRlLCBiYXNlZCBvbiB0aGVcbiAgICBwdWJsaWMga2V5IG9mIHRoZSB0cnVzdCBhbmNob3IuIFRoaXMgcmVxdWlyZXMgb2J0YWluaW5nIGEgc2VxdWVuY2Ugb2ZcbiAgICBjZXJ0aWZpY2F0ZXMgdGhhdCBzdXBwb3J0IHRoYXQgYmluZGluZy4gVGhhdCBzZXF1ZW5jZSBzaG91bGQgYmUgcHJvdmlkZWRcbiAgICBpbiB0aGUgcGFzc2VkICdjaGFpbicuIFRoZSB0cnVzdCBhbmNob3Igc2hvdWxkIGJlIGluIHRoZSBnaXZlbiBDQVxuICAgIHN0b3JlLiBUaGUgJ2VuZCBlbnRpdHknIGNlcnRpZmljYXRlIGlzIHRoZSBjZXJ0aWZpY2F0ZSBwcm92aWRlZCBieSB0aGVcbiAgICBlbmQgcG9pbnQgKHR5cGljYWxseSBhIHNlcnZlcikgYW5kIGlzIHRoZSBmaXJzdCBpbiB0aGUgY2hhaW4uXG5cbiAgICBUbyBtZWV0IHRoaXMgZ29hbCwgdGhlIHBhdGggdmFsaWRhdGlvbiBwcm9jZXNzIHZlcmlmaWVzLCBhbW9uZyBvdGhlclxuICAgIHRoaW5ncywgdGhhdCBhIHByb3NwZWN0aXZlIGNlcnRpZmljYXRpb24gcGF0aCAoYSBzZXF1ZW5jZSBvZiBuXG4gICAgY2VydGlmaWNhdGVzIG9yIGEgJ2NoYWluJykgc2F0aXNmaWVzIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIChhKSBmb3IgYWxsIHggaW4gezEsIC4uLiwgbi0xfSwgdGhlIHN1YmplY3Qgb2YgY2VydGlmaWNhdGUgeCBpc1xuICAgICAgICAgIHRoZSBpc3N1ZXIgb2YgY2VydGlmaWNhdGUgeCsxO1xuXG4gICAgKGIpIGNlcnRpZmljYXRlIDEgaXMgaXNzdWVkIGJ5IHRoZSB0cnVzdCBhbmNob3I7XG5cbiAgICAoYykgY2VydGlmaWNhdGUgbiBpcyB0aGUgY2VydGlmaWNhdGUgdG8gYmUgdmFsaWRhdGVkOyBhbmRcblxuICAgIChkKSBmb3IgYWxsIHggaW4gezEsIC4uLiwgbn0sIHRoZSBjZXJ0aWZpY2F0ZSB3YXMgdmFsaWQgYXQgdGhlXG4gICAgICAgICAgdGltZSBpbiBxdWVzdGlvbi5cblxuICAgIE5vdGUgdGhhdCBoZXJlICduJyBpcyBpbmRleCAwIGluIHRoZSBjaGFpbiBhbmQgMSBpcyB0aGUgbGFzdCBjZXJ0aWZpY2F0ZVxuICAgIGluIHRoZSBjaGFpbiBhbmQgaXQgbXVzdCBiZSBzaWduZWQgYnkgYSBjZXJ0aWZpY2F0ZSBpbiB0aGUgY29ubmVjdGlvbidzXG4gICAgQ0Egc3RvcmUuXG5cbiAgICBUaGUgcGF0aCB2YWxpZGF0aW9uIHByb2Nlc3MgYWxzbyBkZXRlcm1pbmVzIHRoZSBzZXQgb2YgY2VydGlmaWNhdGVcbiAgICBwb2xpY2llcyB0aGF0IGFyZSB2YWxpZCBmb3IgdGhpcyBwYXRoLCBiYXNlZCBvbiB0aGUgY2VydGlmaWNhdGUgcG9saWNpZXNcbiAgICBleHRlbnNpb24sIHBvbGljeSBtYXBwaW5nIGV4dGVuc2lvbiwgcG9saWN5IGNvbnN0cmFpbnRzIGV4dGVuc2lvbiwgYW5kXG4gICAgaW5oaWJpdCBhbnktcG9saWN5IGV4dGVuc2lvbi5cblxuICAgIE5vdGU6IFBvbGljeSBtYXBwaW5nIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkIChOb3QgUmVxdWlyZWQpLlxuXG4gICAgTm90ZTogSWYgdGhlIGNlcnRpZmljYXRlIGhhcyBhbiB1bnN1cHBvcnRlZCBjcml0aWNhbCBleHRlbnNpb24sIHRoZW4gaXRcbiAgICBtdXN0IGJlIHJlamVjdGVkLlxuXG4gICAgTm90ZTogQSBjZXJ0aWZpY2F0ZSBpcyBzZWxmLWlzc3VlZCBpZiB0aGUgRE5zIHRoYXQgYXBwZWFyIGluIHRoZSBzdWJqZWN0XG4gICAgYW5kIGlzc3VlciBmaWVsZHMgYXJlIGlkZW50aWNhbCBhbmQgYXJlIG5vdCBlbXB0eS5cblxuICAgIFRoZSBwYXRoIHZhbGlkYXRpb24gYWxnb3JpdGhtIGFzc3VtZXMgdGhlIGZvbGxvd2luZyBzZXZlbiBpbnB1dHMgYXJlXG4gICAgcHJvdmlkZWQgdG8gdGhlIHBhdGggcHJvY2Vzc2luZyBsb2dpYy4gV2hhdCB0aGlzIHNwZWNpZmljIGltcGxlbWVudGF0aW9uXG4gICAgd2lsbCB1c2UgaXMgcHJvdmlkZWQgcGFyZW50aGV0aWNhbGx5OlxuXG4gICAgKGEpIGEgcHJvc3BlY3RpdmUgY2VydGlmaWNhdGlvbiBwYXRoIG9mIGxlbmd0aCBuICh0aGUgJ2NoYWluJylcbiAgICAoYikgdGhlIGN1cnJlbnQgZGF0ZS90aW1lOiAoJ25vdycpLlxuICAgIChjKSB1c2VyLWluaXRpYWwtcG9saWN5LXNldDogQSBzZXQgb2YgY2VydGlmaWNhdGUgcG9saWN5IGlkZW50aWZpZXJzXG4gICAgICAgICAgbmFtaW5nIHRoZSBwb2xpY2llcyB0aGF0IGFyZSBhY2NlcHRhYmxlIHRvIHRoZSBjZXJ0aWZpY2F0ZSB1c2VyLlxuICAgICAgICAgIFRoZSB1c2VyLWluaXRpYWwtcG9saWN5LXNldCBjb250YWlucyB0aGUgc3BlY2lhbCB2YWx1ZSBhbnktcG9saWN5XG4gICAgICAgICAgaWYgdGhlIHVzZXIgaXMgbm90IGNvbmNlcm5lZCBhYm91dCBjZXJ0aWZpY2F0ZSBwb2xpY3lcbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLiBBbnkgcG9saWN5IGlzIGFjY2VwdGVkKS5cbiAgICAoZCkgdHJ1c3QgYW5jaG9yIGluZm9ybWF0aW9uLCBkZXNjcmliaW5nIGEgQ0EgdGhhdCBzZXJ2ZXMgYXMgYSB0cnVzdFxuICAgICAgICAgIGFuY2hvciBmb3IgdGhlIGNlcnRpZmljYXRpb24gcGF0aC4gVGhlIHRydXN0IGFuY2hvciBpbmZvcm1hdGlvblxuICAgICAgICAgIGluY2x1ZGVzOlxuXG4gICAgICAoMSkgIHRoZSB0cnVzdGVkIGlzc3VlciBuYW1lLFxuICAgICAgKDIpICB0aGUgdHJ1c3RlZCBwdWJsaWMga2V5IGFsZ29yaXRobSxcbiAgICAgICgzKSAgdGhlIHRydXN0ZWQgcHVibGljIGtleSwgYW5kXG4gICAgICAoNCkgIG9wdGlvbmFsbHksIHRoZSB0cnVzdGVkIHB1YmxpYyBrZXkgcGFyYW1ldGVycyBhc3NvY2lhdGVkXG4gICAgICAgICAgICAgd2l0aCB0aGUgcHVibGljIGtleS5cblxuICAgICAgKFRydXN0IGFuY2hvcnMgYXJlIHByb3ZpZGVkIHZpYSBjZXJ0aWZpY2F0ZXMgaW4gdGhlIENBIHN0b3JlKS5cblxuICAgICAgVGhlIHRydXN0IGFuY2hvciBpbmZvcm1hdGlvbiBtYXkgYmUgcHJvdmlkZWQgdG8gdGhlIHBhdGggcHJvY2Vzc2luZ1xuICAgICAgcHJvY2VkdXJlIGluIHRoZSBmb3JtIG9mIGEgc2VsZi1zaWduZWQgY2VydGlmaWNhdGUuIFRoZSB0cnVzdGVkIGFuY2hvclxuICAgICAgaW5mb3JtYXRpb24gaXMgdHJ1c3RlZCBiZWNhdXNlIGl0IHdhcyBkZWxpdmVyZWQgdG8gdGhlIHBhdGggcHJvY2Vzc2luZ1xuICAgICAgcHJvY2VkdXJlIGJ5IHNvbWUgdHJ1c3R3b3J0aHkgb3V0LW9mLWJhbmQgcHJvY2VkdXJlLiBJZiB0aGUgdHJ1c3RlZFxuICAgICAgcHVibGljIGtleSBhbGdvcml0aG0gcmVxdWlyZXMgcGFyYW1ldGVycywgdGhlbiB0aGUgcGFyYW1ldGVycyBhcmVcbiAgICAgIHByb3ZpZGVkIGFsb25nIHdpdGggdGhlIHRydXN0ZWQgcHVibGljIGtleSAoTm8gcGFyYW1ldGVycyB1c2VkIGluIHRoaXNcbiAgICAgIGltcGxlbWVudGF0aW9uKS5cblxuICAgIChlKSBpbml0aWFsLXBvbGljeS1tYXBwaW5nLWluaGliaXQsIHdoaWNoIGluZGljYXRlcyBpZiBwb2xpY3kgbWFwcGluZyBpc1xuICAgICAgICAgIGFsbG93ZWQgaW4gdGhlIGNlcnRpZmljYXRpb24gcGF0aC5cbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLCBubyBwb2xpY3kgY2hlY2tpbmcpXG5cbiAgICAoZikgaW5pdGlhbC1leHBsaWNpdC1wb2xpY3ksIHdoaWNoIGluZGljYXRlcyBpZiB0aGUgcGF0aCBtdXN0IGJlIHZhbGlkXG4gICAgICAgICAgZm9yIGF0IGxlYXN0IG9uZSBvZiB0aGUgY2VydGlmaWNhdGUgcG9saWNpZXMgaW4gdGhlIHVzZXItaW5pdGlhbC1cbiAgICAgICAgICBwb2xpY3ktc2V0LlxuICAgICAgICAgIChOb3QgaW1wbGVtZW50ZWQsIG5vIHBvbGljeSBjaGVja2luZylcblxuICAgIChnKSBpbml0aWFsLWFueS1wb2xpY3ktaW5oaWJpdCwgd2hpY2ggaW5kaWNhdGVzIHdoZXRoZXIgdGhlXG4gICAgICAgICAgYW55UG9saWN5IE9JRCBzaG91bGQgYmUgcHJvY2Vzc2VkIGlmIGl0IGlzIGluY2x1ZGVkIGluIGFcbiAgICAgICAgICBjZXJ0aWZpY2F0ZS5cbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLCBzbyBhbnkgcG9saWN5IGlzIHZhbGlkIHByb3ZpZGVkIHRoYXQgaXQgaXNcbiAgICAgICAgICBub3QgbWFya2VkIGFzIGNyaXRpY2FsKSAqL1xuXG4gIC8qIEJhc2ljIFBhdGggUHJvY2Vzc2luZzpcblxuICAgIEZvciBlYWNoIGNlcnRpZmljYXRlIGluIHRoZSAnY2hhaW4nLCB0aGUgZm9sbG93aW5nIGlzIGNoZWNrZWQ6XG5cbiAgICAxLiBUaGUgY2VydGlmaWNhdGUgdmFsaWRpdHkgcGVyaW9kIGluY2x1ZGVzIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgMi4gVGhlIGNlcnRpZmljYXRlIHdhcyBzaWduZWQgYnkgaXRzIHBhcmVudCAod2hlcmUgdGhlIHBhcmVudCBpcyBlaXRoZXJcbiAgICAgICB0aGUgbmV4dCBpbiB0aGUgY2hhaW4gb3IgZnJvbSB0aGUgQ0Egc3RvcmUpLiBBbGxvdyBwcm9jZXNzaW5nIHRvXG4gICAgICAgY29udGludWUgdG8gdGhlIG5leHQgc3RlcCBpZiBubyBwYXJlbnQgaXMgZm91bmQgYnV0IHRoZSBjZXJ0aWZpY2F0ZSBpc1xuICAgICAgIGluIHRoZSBDQSBzdG9yZS5cbiAgICAzLiBUT0RPOiBUaGUgY2VydGlmaWNhdGUgaGFzIG5vdCBiZWVuIHJldm9rZWQuXG4gICAgNC4gVGhlIGNlcnRpZmljYXRlIGlzc3VlciBuYW1lIG1hdGNoZXMgdGhlIHBhcmVudCdzIHN1YmplY3QgbmFtZS5cbiAgICA1LiBUT0RPOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgc2VsZi1pc3N1ZWQgYW5kIG5vdCB0aGUgZmluYWwgY2VydGlmaWNhdGVcbiAgICAgICBpbiB0aGUgY2hhaW4sIHNraXAgdGhpcyBzdGVwLCBvdGhlcndpc2UgdmVyaWZ5IHRoYXQgdGhlIHN1YmplY3QgbmFtZVxuICAgICAgIGlzIHdpdGhpbiBvbmUgb2YgdGhlIHBlcm1pdHRlZCBzdWJ0cmVlcyBvZiBYLjUwMCBkaXN0aW5ndWlzaGVkIG5hbWVzXG4gICAgICAgYW5kIHRoYXQgZWFjaCBvZiB0aGUgYWx0ZXJuYXRpdmUgbmFtZXMgaW4gdGhlIHN1YmplY3RBbHROYW1lIGV4dGVuc2lvblxuICAgICAgIChjcml0aWNhbCBvciBub24tY3JpdGljYWwpIGlzIHdpdGhpbiBvbmUgb2YgdGhlIHBlcm1pdHRlZCBzdWJ0cmVlcyBmb3JcbiAgICAgICB0aGF0IG5hbWUgdHlwZS5cbiAgICA2LiBUT0RPOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgc2VsZi1pc3N1ZWQgYW5kIG5vdCB0aGUgZmluYWwgY2VydGlmaWNhdGVcbiAgICAgICBpbiB0aGUgY2hhaW4sIHNraXAgdGhpcyBzdGVwLCBvdGhlcndpc2UgdmVyaWZ5IHRoYXQgdGhlIHN1YmplY3QgbmFtZVxuICAgICAgIGlzIG5vdCB3aXRoaW4gb25lIG9mIHRoZSBleGNsdWRlZCBzdWJ0cmVlcyBmb3IgWC41MDAgZGlzdGluZ3Vpc2hlZFxuICAgICAgIG5hbWVzIGFuZCBub25lIG9mIHRoZSBzdWJqZWN0QWx0TmFtZSBleHRlbnNpb24gbmFtZXMgYXJlIGV4Y2x1ZGVkIGZvclxuICAgICAgIHRoYXQgbmFtZSB0eXBlLlxuICAgIDcuIFRoZSBvdGhlciBzdGVwcyBpbiB0aGUgYWxnb3JpdGhtIGZvciBiYXNpYyBwYXRoIHByb2Nlc3NpbmcgaW52b2x2ZVxuICAgICAgIGhhbmRsaW5nIHRoZSBwb2xpY3kgZXh0ZW5zaW9uIHdoaWNoIGlzIG5vdCBwcmVzZW50bHkgc3VwcG9ydGVkIGluIHRoaXNcbiAgICAgICBpbXBsZW1lbnRhdGlvbi4gSW5zdGVhZCwgaWYgYSBjcml0aWNhbCBwb2xpY3kgZXh0ZW5zaW9uIGlzIGZvdW5kLCB0aGVcbiAgICAgICBjZXJ0aWZpY2F0ZSBpcyByZWplY3RlZCBhcyBub3Qgc3VwcG9ydGVkLlxuICAgIDguIElmIHRoZSBjZXJ0aWZpY2F0ZSBpcyBub3QgdGhlIGZpcnN0IG9yIGlmIGl0cyB0aGUgb25seSBjZXJ0aWZpY2F0ZSBpblxuICAgICAgIHRoZSBjaGFpbiAoaGF2aW5nIG5vIHBhcmVudCBmcm9tIHRoZSBDQSBzdG9yZSBvciBpcyBzZWxmLXNpZ25lZCkgYW5kIGl0XG4gICAgICAgaGFzIGEgY3JpdGljYWwga2V5IHVzYWdlIGV4dGVuc2lvbiwgdmVyaWZ5IHRoYXQgdGhlIGtleUNlcnRTaWduIGJpdCBpc1xuICAgICAgIHNldC4gSWYgdGhlIGtleSB1c2FnZSBleHRlbnNpb24gZXhpc3RzLCB2ZXJpZnkgdGhhdCB0aGUgYmFzaWNcbiAgICAgICBjb25zdHJhaW50cyBleHRlbnNpb24gZXhpc3RzLiBJZiB0aGUgYmFzaWMgY29uc3RyYWludHMgZXh0ZW5zaW9uIGV4aXN0cyxcbiAgICAgICB2ZXJpZnkgdGhhdCB0aGUgY0EgZmxhZyBpcyBzZXQuIElmIHBhdGhMZW5Db25zdHJhaW50IGlzIHNldCwgZW5zdXJlIHRoYXRcbiAgICAgICB0aGUgbnVtYmVyIG9mIGNlcnRpZmljYXRlcyB0aGF0IHByZWNlZGUgaW4gdGhlIGNoYWluIChjb21lIGVhcmxpZXJcbiAgICAgICBpbiB0aGUgY2hhaW4gYXMgaW1wbGVtZW50ZWQgYmVsb3cpLCBleGNsdWRpbmcgdGhlIHZlcnkgZmlyc3QgaW4gdGhlXG4gICAgICAgY2hhaW4gKHR5cGljYWxseSB0aGUgZW5kLWVudGl0eSBvbmUpLCBpc24ndCBncmVhdGVyIHRoYW4gdGhlXG4gICAgICAgcGF0aExlbkNvbnN0cmFpbnQuIFRoaXMgY29uc3RyYWludCBsaW1pdHMgdGhlIG51bWJlciBvZiBpbnRlcm1lZGlhdGVcbiAgICAgICBDQXMgdGhhdCBtYXkgYXBwZWFyIGJlbG93IGEgQ0EgYmVmb3JlIG9ubHkgZW5kLWVudGl0eSBjZXJ0aWZpY2F0ZXNcbiAgICAgICBtYXkgYmUgaXNzdWVkLiAqL1xuXG4gIC8vIGlmIGEgdmVyaWZ5IGNhbGxiYWNrIGlzIHBhc3NlZCBhcyB0aGUgdGhpcmQgcGFyYW1ldGVyLCBwYWNrYWdlIGl0IHdpdGhpblxuICAvLyB0aGUgb3B0aW9ucyBvYmplY3QuIFRoaXMgaXMgdG8gc3VwcG9ydCBhIGxlZ2FjeSBmdW5jdGlvbiBzaWduYXR1cmUgdGhhdFxuICAvLyBleHBlY3RlZCB0aGUgdmVyaWZ5IGNhbGxiYWNrIGFzIHRoZSB0aGlyZCBwYXJhbWV0ZXIuXG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucyA9IHt2ZXJpZnk6IG9wdGlvbnN9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIGNvcHkgY2VydCBjaGFpbiByZWZlcmVuY2VzIHRvIGFub3RoZXIgYXJyYXkgdG8gcHJvdGVjdCBhZ2FpbnN0IGNoYW5nZXNcbiAgLy8gaW4gdmVyaWZ5IGNhbGxiYWNrXG4gIGNoYWluID0gY2hhaW4uc2xpY2UoMCk7XG4gIHZhciBjZXJ0cyA9IGNoYWluLnNsaWNlKDApO1xuXG4gIHZhciB2YWxpZGl0eUNoZWNrRGF0ZSA9IG9wdGlvbnMudmFsaWRpdHlDaGVja0RhdGU7XG4gIC8vIGlmIG5vIHZhbGlkaXR5Q2hlY2tEYXRlIGlzIHNwZWNpZmllZCwgZGVmYXVsdCB0byB0aGUgY3VycmVudCBkYXRlLiBNYWtlXG4gIC8vIHN1cmUgdG8gbWFpbnRhaW4gdGhlIHZhbHVlIG51bGwgYmVjYXVzZSBpdCBpbmRpY2F0ZXMgdGhhdCB0aGUgdmFsaWRpdHlcbiAgLy8gcGVyaW9kIHNob3VsZCBub3QgYmUgY2hlY2tlZC5cbiAgaWYodHlwZW9mIHZhbGlkaXR5Q2hlY2tEYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhbGlkaXR5Q2hlY2tEYXRlID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIC8vIHZlcmlmeSBlYWNoIGNlcnQgaW4gdGhlIGNoYWluIHVzaW5nIGl0cyBwYXJlbnQsIHdoZXJlIHRoZSBwYXJlbnRcbiAgLy8gaXMgZWl0aGVyIHRoZSBuZXh0IGluIHRoZSBjaGFpbiBvciBmcm9tIHRoZSBDQSBzdG9yZVxuICB2YXIgZmlyc3QgPSB0cnVlO1xuICB2YXIgZXJyb3IgPSBudWxsO1xuICB2YXIgZGVwdGggPSAwO1xuICBkbyB7XG4gICAgdmFyIGNlcnQgPSBjaGFpbi5zaGlmdCgpO1xuICAgIHZhciBwYXJlbnQgPSBudWxsO1xuICAgIHZhciBzZWxmU2lnbmVkID0gZmFsc2U7XG5cbiAgICBpZih2YWxpZGl0eUNoZWNrRGF0ZSkge1xuICAgICAgLy8gMS4gY2hlY2sgdmFsaWQgdGltZVxuICAgICAgaWYodmFsaWRpdHlDaGVja0RhdGUgPCBjZXJ0LnZhbGlkaXR5Lm5vdEJlZm9yZSB8fFxuICAgICAgICAgdmFsaWRpdHlDaGVja0RhdGUgPiBjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyKSB7XG4gICAgICAgIGVycm9yID0ge1xuICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpcyBub3QgdmFsaWQgeWV0IG9yIGhhcyBleHBpcmVkLicsXG4gICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLmNlcnRpZmljYXRlX2V4cGlyZWQsXG4gICAgICAgICAgbm90QmVmb3JlOiBjZXJ0LnZhbGlkaXR5Lm5vdEJlZm9yZSxcbiAgICAgICAgICBub3RBZnRlcjogY2VydC52YWxpZGl0eS5ub3RBZnRlcixcbiAgICAgICAgICAvLyBUT0RPOiB3ZSBtaWdodCB3YW50IHRvIHJlY29uc2lkZXIgcmVuYW1pbmcgJ25vdycgdG9cbiAgICAgICAgICAvLyAndmFsaWRpdHlDaGVja0RhdGUnIHNob3VsZCB0aGlzIEFQSSBiZSBjaGFuZ2VkIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgbm93OiB2YWxpZGl0eUNoZWNrRGF0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDIuIHZlcmlmeSB3aXRoIHBhcmVudCBmcm9tIGNoYWluIG9yIENBIHN0b3JlXG4gICAgaWYoZXJyb3IgPT09IG51bGwpIHtcbiAgICAgIHBhcmVudCA9IGNoYWluWzBdIHx8IGNhU3RvcmUuZ2V0SXNzdWVyKGNlcnQpO1xuICAgICAgaWYocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBzZWxmLXNpZ25lZCBjZXJ0XG4gICAgICAgIGlmKGNlcnQuaXNJc3N1ZXIoY2VydCkpIHtcbiAgICAgICAgICBzZWxmU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICBwYXJlbnQgPSBjZXJ0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHBhcmVudCkge1xuICAgICAgICAvLyBGSVhNRTogY3VycmVudCBDQSBzdG9yZSBpbXBsZW1lbnRhdGlvbiBtaWdodCBoYXZlIG11bHRpcGxlXG4gICAgICAgIC8vIGNlcnRpZmljYXRlcyB3aGVyZSB0aGUgaXNzdWVyIGNhbid0IGJlIGRldGVybWluZWQgZnJvbSB0aGVcbiAgICAgICAgLy8gY2VydGlmaWNhdGUgKGhhcHBlbnMgcmFyZWx5IHdpdGgsIGVnOiBvbGQgY2VydGlmaWNhdGVzKSBzbyBub3JtYWxpemVcbiAgICAgICAgLy8gYnkgYWx3YXlzIHB1dHRpbmcgcGFyZW50cyBpbnRvIGFuIGFycmF5XG4gICAgICAgIC8vIFRPRE86IHRoZXJlJ3MgbWF5IGJlIGFuIGV4dHJlbWUgZGVnZW5lcmF0ZSBjYXNlIGN1cnJlbnRseSB1bmNvdmVyZWRcbiAgICAgICAgLy8gd2hlcmUgYW4gb2xkIGludGVybWVkaWF0ZSBjZXJ0aWZpY2F0ZSBzZWVtcyB0byBoYXZlIGEgbWF0Y2hpbmcgcGFyZW50XG4gICAgICAgIC8vIGJ1dCBub25lIG9mIHRoZSBwYXJlbnRzIGFjdHVhbGx5IHZlcmlmeSAuLi4gYnV0IHRoZSBpbnRlcm1lZGlhdGVcbiAgICAgICAgLy8gaXMgaW4gdGhlIENBIGFuZCBpdCBzaG91bGQgcGFzcyB0aGlzIGNoZWNrOyBuZWVkcyBpbnZlc3RpZ2F0aW9uXG4gICAgICAgIHZhciBwYXJlbnRzID0gcGFyZW50O1xuICAgICAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KHBhcmVudHMpKSB7XG4gICAgICAgICAgcGFyZW50cyA9IFtwYXJlbnRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byB2ZXJpZnkgd2l0aCBlYWNoIHBvc3NpYmxlIHBhcmVudCAodHlwaWNhbGx5IG9ubHkgb25lKVxuICAgICAgICB2YXIgdmVyaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUoIXZlcmlmaWVkICYmIHBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcmVudCA9IHBhcmVudHMuc2hpZnQoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmVyaWZpZWQgPSBwYXJlbnQudmVyaWZ5KGNlcnQpO1xuICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgIC8vIGZhaWx1cmUgdG8gdmVyaWZ5LCBkb24ndCBjYXJlIHdoeSwgdHJ5IG5leHQgb25lXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgc2lnbmF0dXJlIGlzIGludmFsaWQuJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGVycm9yID09PSBudWxsICYmICghcGFyZW50IHx8IHNlbGZTaWduZWQpICYmXG4gICAgICAgICFjYVN0b3JlLmhhc0NlcnRpZmljYXRlKGNlcnQpKSB7XG4gICAgICAgIC8vIG5vIHBhcmVudCBpc3N1ZXIgYW5kIGNlcnRpZmljYXRlIGl0c2VsZiBpcyBub3QgdHJ1c3RlZFxuICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgaXMgbm90IHRydXN0ZWQuJyxcbiAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IudW5rbm93bl9jYVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IDMuIGNoZWNrIHJldm9rZWRcblxuICAgIC8vIDQuIGNoZWNrIGZvciBtYXRjaGluZyBpc3N1ZXIvc3ViamVjdFxuICAgIGlmKGVycm9yID09PSBudWxsICYmIHBhcmVudCAmJiAhY2VydC5pc0lzc3VlcihwYXJlbnQpKSB7XG4gICAgICAvLyBwYXJlbnQgaXMgbm90IGlzc3VlclxuICAgICAgZXJyb3IgPSB7XG4gICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpc3N1ZXIgaXMgaW52YWxpZC4nLFxuICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIDUuIFRPRE86IGNoZWNrIG5hbWVzIHdpdGggcGVybWl0dGVkIG5hbWVzIHRyZWVcblxuICAgIC8vIDYuIFRPRE86IGNoZWNrIG5hbWVzIGFnYWluc3QgZXhjbHVkZWQgbmFtZXMgdHJlZVxuXG4gICAgLy8gNy4gY2hlY2sgZm9yIHVuc3VwcG9ydGVkIGNyaXRpY2FsIGV4dGVuc2lvbnNcbiAgICBpZihlcnJvciA9PT0gbnVsbCkge1xuICAgICAgLy8gc3VwcG9ydGVkIGV4dGVuc2lvbnNcbiAgICAgIHZhciBzZSA9IHtcbiAgICAgICAga2V5VXNhZ2U6IHRydWUsXG4gICAgICAgIGJhc2ljQ29uc3RyYWludHM6IHRydWVcbiAgICAgIH07XG4gICAgICBmb3IodmFyIGkgPSAwOyBlcnJvciA9PT0gbnVsbCAmJiBpIDwgY2VydC5leHRlbnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBleHQgPSBjZXJ0LmV4dGVuc2lvbnNbaV07XG4gICAgICAgIGlmKGV4dC5jcml0aWNhbCAmJiAhKGV4dC5uYW1lIGluIHNlKSkge1xuICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGhhcyBhbiB1bnN1cHBvcnRlZCBjcml0aWNhbCBleHRlbnNpb24uJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci51bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA4LiBjaGVjayBmb3IgQ0EgaWYgY2VydCBpcyBub3QgZmlyc3Qgb3IgaXMgdGhlIG9ubHkgY2VydGlmaWNhdGVcbiAgICAvLyByZW1haW5pbmcgaW4gY2hhaW4gd2l0aCBubyBwYXJlbnQgb3IgaXMgc2VsZi1zaWduZWRcbiAgICBpZihlcnJvciA9PT0gbnVsbCAmJlxuICAgICAgKCFmaXJzdCB8fCAoY2hhaW4ubGVuZ3RoID09PSAwICYmICghcGFyZW50IHx8IHNlbGZTaWduZWQpKSkpIHtcbiAgICAgIC8vIGZpcnN0IGNoZWNrIGtleVVzYWdlIGV4dGVuc2lvbiBhbmQgdGhlbiBiYXNpYyBjb25zdHJhaW50c1xuICAgICAgdmFyIGJjRXh0ID0gY2VydC5nZXRFeHRlbnNpb24oJ2Jhc2ljQ29uc3RyYWludHMnKTtcbiAgICAgIHZhciBrZXlVc2FnZUV4dCA9IGNlcnQuZ2V0RXh0ZW5zaW9uKCdrZXlVc2FnZScpO1xuICAgICAgaWYoa2V5VXNhZ2VFeHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8ga2V5Q2VydFNpZ24gbXVzdCBiZSB0cnVlIGFuZCB0aGVyZSBtdXN0IGJlIGEgYmFzaWNcbiAgICAgICAgLy8gY29uc3RyYWludHMgZXh0ZW5zaW9uXG4gICAgICAgIGlmKCFrZXlVc2FnZUV4dC5rZXlDZXJ0U2lnbiB8fCBiY0V4dCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIGJhZCBjZXJ0aWZpY2F0ZVxuICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGtleVVzYWdlIG9yIGJhc2ljQ29uc3RyYWludHMgY29uZmxpY3QgJyArXG4gICAgICAgICAgICAgICdvciBpbmRpY2F0ZSB0aGF0IHRoZSBjZXJ0aWZpY2F0ZSBpcyBub3QgYSBDQS4gJyArXG4gICAgICAgICAgICAgICdJZiB0aGUgY2VydGlmaWNhdGUgaXMgdGhlIG9ubHkgb25lIGluIHRoZSBjaGFpbiBvciAnICtcbiAgICAgICAgICAgICAgJ2lzblxcJ3QgdGhlIGZpcnN0IHRoZW4gdGhlIGNlcnRpZmljYXRlIG11c3QgYmUgYSAnICtcbiAgICAgICAgICAgICAgJ3ZhbGlkIENBLicsXG4gICAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYmFzaWMgY29uc3RyYWludHMgY0EgZmxhZyBtdXN0IGJlIHNldFxuICAgICAgaWYoZXJyb3IgPT09IG51bGwgJiYgYmNFeHQgIT09IG51bGwgJiYgIWJjRXh0LmNBKSB7XG4gICAgICAgIC8vIGJhZCBjZXJ0aWZpY2F0ZVxuICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGJhc2ljQ29uc3RyYWludHMgaW5kaWNhdGVzIHRoZSBjZXJ0aWZpY2F0ZSAnICtcbiAgICAgICAgICAgICdpcyBub3QgYSBDQS4nLFxuICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGVycm9yIGlzIG5vdCBudWxsIGFuZCBrZXlVc2FnZSBpcyBhdmFpbGFibGUsIHRoZW4gd2Uga25vdyBpdFxuICAgICAgLy8gaGFzIGtleUNlcnRTaWduIGFuZCB0aGVyZSBpcyBhIGJhc2ljIGNvbnN0cmFpbnRzIGV4dGVuc2lvbiB0b28sXG4gICAgICAvLyB3aGljaCBtZWFucyB3ZSBjYW4gY2hlY2sgcGF0aExlbkNvbnN0cmFpbnQgKGlmIGl0IGV4aXN0cylcbiAgICAgIGlmKGVycm9yID09PSBudWxsICYmIGtleVVzYWdlRXh0ICE9PSBudWxsICYmXG4gICAgICAgICdwYXRoTGVuQ29uc3RyYWludCcgaW4gYmNFeHQpIHtcbiAgICAgICAgLy8gcGF0aExlbiBpcyB0aGUgbWF4aW11bSAjIG9mIGludGVybWVkaWF0ZSBDQSBjZXJ0cyB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBmb3VuZCBiZXR3ZWVuIHRoZSBjdXJyZW50IGNlcnRpZmljYXRlIGFuZCB0aGUgZW5kLWVudGl0eSAoZGVwdGggMClcbiAgICAgICAgLy8gY2VydGlmaWNhdGU7IHRoaXMgbnVtYmVyIGRvZXMgbm90IGluY2x1ZGUgdGhlIGVuZC1lbnRpdHkgKGRlcHRoIDAsXG4gICAgICAgIC8vIGxhc3QgaW4gdGhlIGNoYWluKSBldmVuIGlmIGl0IGhhcHBlbnMgdG8gYmUgYSBDQSBjZXJ0aWZpY2F0ZSBpdHNlbGZcbiAgICAgICAgdmFyIHBhdGhMZW4gPSBkZXB0aCAtIDE7XG4gICAgICAgIGlmKHBhdGhMZW4gPiBiY0V4dC5wYXRoTGVuQ29uc3RyYWludCkge1xuICAgICAgICAgIC8vIHBhdGhMZW5Db25zdHJhaW50IHZpb2xhdGVkLCBiYWQgY2VydGlmaWNhdGVcbiAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICdDZXJ0aWZpY2F0ZSBiYXNpY0NvbnN0cmFpbnRzIHBhdGhMZW5Db25zdHJhaW50IHZpb2xhdGVkLicsXG4gICAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGwgYXBwbGljYXRpb24gY2FsbGJhY2tcbiAgICB2YXIgdmZkID0gKGVycm9yID09PSBudWxsKSA/IHRydWUgOiBlcnJvci5lcnJvcjtcbiAgICB2YXIgcmV0ID0gb3B0aW9ucy52ZXJpZnkgPyBvcHRpb25zLnZlcmlmeSh2ZmQsIGRlcHRoLCBjZXJ0cykgOiB2ZmQ7XG4gICAgaWYocmV0ID09PSB0cnVlKSB7XG4gICAgICAvLyBjbGVhciBhbnkgc2V0IGVycm9yXG4gICAgICBlcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHBhc3NlZCBiYXNpYyB0ZXN0cywgc2V0IGRlZmF1bHQgbWVzc2FnZSBhbmQgYWxlcnRcbiAgICAgIGlmKHZmZCA9PT0gdHJ1ZSkge1xuICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICBtZXNzYWdlOiAnVGhlIGFwcGxpY2F0aW9uIHJlamVjdGVkIHRoZSBjZXJ0aWZpY2F0ZS4nLFxuICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgZm9yIGN1c3RvbSBlcnJvciBpbmZvXG4gICAgICBpZihyZXQgfHwgcmV0ID09PSAwKSB7XG4gICAgICAgIC8vIHNldCBjdXN0b20gbWVzc2FnZSBhbmQgZXJyb3JcbiAgICAgICAgaWYodHlwZW9mIHJldCA9PT0gJ29iamVjdCcgJiYgIWZvcmdlLnV0aWwuaXNBcnJheShyZXQpKSB7XG4gICAgICAgICAgaWYocmV0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSByZXQubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmV0LmVycm9yKSB7XG4gICAgICAgICAgICBlcnJvci5lcnJvciA9IHJldC5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YgcmV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHNldCBjdXN0b20gZXJyb3JcbiAgICAgICAgICBlcnJvci5lcnJvciA9IHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0aHJvdyBlcnJvclxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gbm8gbG9uZ2VyIGZpcnN0IGNlcnQgaW4gY2hhaW5cbiAgICBmaXJzdCA9IGZhbHNlO1xuICAgICsrZGVwdGg7XG4gIH0gd2hpbGUoY2hhaW4ubGVuZ3RoID4gMCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFTTi4xIHZhbGlkYXRvcnMgZm9yIFBLQ1MjNyB2MS41LlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBUaGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgUEtDUyM3IGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgUkZDICMyMzE1IGZvciBkZXRhaWxzLCBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMzE1LnR4dCk6XG4gKlxuICogQSBQS0NTIzcgbWVzc2FnZSBjb25zaXN0cyBvZiBhIENvbnRlbnRJbmZvIG9uIHJvb3QgbGV2ZWwsIHdoaWNoIG1heVxuICogY29udGFpbiBhbnkgbnVtYmVyIG9mIGZ1cnRoZXIgQ29udGVudEluZm8gbmVzdGVkIGludG8gaXQuXG4gKlxuICogQ29udGVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgY29udGVudFR5cGUgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnQgICAgICAgICAgICAgICBbMF0gIEVYUExJQ0lUIEFOWSBERUZJTkVEIEJZIGNvbnRlbnRUeXBlIE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudFR5cGUgOjo9IE9CSkVDVCBJREVOVElGSUVSXG4gKlxuICogRW52ZWxvcGVkRGF0YSA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICByZWNpcGllbnRJbmZvcyAgICAgICAgICAgICBSZWNpcGllbnRJbmZvcyxcbiAqICAgZW5jcnlwdGVkQ29udGVudEluZm8gICAgICAgRW5jcnlwdGVkQ29udGVudEluZm9cbiAqIH1cbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGVuY3J5cHRlZENvbnRlbnRJbmZvICAgICAgIEVuY3J5cHRlZENvbnRlbnRJbmZvXG4gKiB9XG4gKlxuICogaWQtc2lnbmVkRGF0YSBPQkpFQ1QgSURFTlRJRklFUiA6Oj0geyBpc28oMSkgbWVtYmVyLWJvZHkoMilcbiAqICAgdXMoODQwKSByc2Fkc2koMTEzNTQ5KSBwa2NzKDEpIHBrY3M3KDcpIDIgfVxuICpcbiAqIFNpZ25lZERhdGEgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgSU5URUdFUixcbiAqICAgZGlnZXN0QWxnb3JpdGhtcyAgRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnMsXG4gKiAgIGNvbnRlbnRJbmZvICAgICAgIENvbnRlbnRJbmZvLFxuICogICBjZXJ0aWZpY2F0ZXMgICAgICBbMF0gSU1QTElDSVQgQ2VydGlmaWNhdGVzIE9QVElPTkFMLFxuICogICBjcmxzICAgICAgICAgICAgICBbMV0gSU1QTElDSVQgQ2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdHMgT1BUSU9OQUwsXG4gKiAgIHNpZ25lckluZm9zICAgICAgIFNpZ25lckluZm9zXG4gKiB9XG4gKlxuICogU2lnbmVySW5mb3MgOjo9IFNFVCBPRiBTaWduZXJJbmZvXG4gKlxuICogU2lnbmVySW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICBpc3N1ZXJBbmRTZXJpYWxOdW1iZXIgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGRpZ2VzdEFsZ29yaXRobSAgICAgICAgICAgIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICAgIFswXSBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMLFxuICogICBkaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtICBEaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGlnZXN0ICAgICAgICAgICAgRW5jcnlwdGVkRGlnZXN0LFxuICogICB1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICBbMV0gSU1QTElDSVQgQXR0cmlidXRlcyBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gKlxuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEF0dHJpYnV0ZSA6Oj0gU0VRVUVOQ0Uge1xuICogICBhdHRyVHlwZSAgICBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgYXR0clZhbHVlcyAgU0VUIE9GIEF0dHJpYnV0ZVZhbHVlXG4gKiB9XG4gKlxuICogQXR0cmlidXRlVmFsdWUgOjo9IEFOWVxuICpcbiAqIFZlcnNpb24gOjo9IElOVEVHRVJcbiAqXG4gKiBSZWNpcGllbnRJbmZvcyA6Oj0gU0VUIE9GIFJlY2lwaWVudEluZm9cbiAqXG4gKiBFbmNyeXB0ZWRDb250ZW50SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjb250ZW50VHlwZSAgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtICBDb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGVuY3J5cHRlZENvbnRlbnQgICAgICAgWzBdICBJTVBMSUNJVCBFbmNyeXB0ZWRDb250ZW50IE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudEVuY3J5cHRpb25BbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogVGhlIEFsZ29yaXRobUlkZW50aWZpZXIgY29udGFpbnMgYW4gT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgYW5kIHBhcmFtZXRlcnNcbiAqIGZvciB0aGUgYWxnb3JpdGhtLCBpZiBhbnkuIEluIHRoZSBjYXNlIG9mIEFFUyBhbmQgREVTMywgdGhlcmUgaXMgb25seSBvbmUsXG4gKiB0aGUgSVYuXG4gKlxuICogQWxnb3JpdGhtSWRlbnRpZmVyIDo6PSBTRVFVRU5DRSB7XG4gKiAgICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgICBwYXJhbWV0ZXJzIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZENvbnRlbnQgOjo9IE9DVEVUIFNUUklOR1xuICpcbiAqIFJlY2lwaWVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGlzc3VlckFuZFNlcmlhbE51bWJlciAgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGtleUVuY3J5cHRpb25BbGdvcml0aG0gICAgICBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkS2V5ICAgICAgICAgICAgICAgIEVuY3J5cHRlZEtleVxuICogfVxuICpcbiAqIElzc3VlckFuZFNlcmlhbE51bWJlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBpc3N1ZXIgICAgICAgICAgICAgICAgICAgICAgTmFtZSxcbiAqICAgc2VyaWFsTnVtYmVyICAgICAgICAgICAgICAgIENlcnRpZmljYXRlU2VyaWFsTnVtYmVyXG4gKiB9XG4gKlxuICogQ2VydGlmaWNhdGVTZXJpYWxOdW1iZXIgOjo9IElOVEVHRVJcbiAqXG4gKiBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEVuY3J5cHRlZEtleSA6Oj0gT0NURVQgU1RSSU5HXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vYXNuMScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIHNob3J0Y3V0IGZvciBBU04uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLy8gc2hvcnRjdXQgZm9yIFBLQ1MjNyBBUElcbnZhciBwN3YgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBrY3M3YXNuMSA9IGZvcmdlLnBrY3M3YXNuMSB8fCB7fTtcbmZvcmdlLnBrY3M3ID0gZm9yZ2UucGtjczcgfHwge307XG5mb3JnZS5wa2NzNy5hc24xID0gcDd2O1xuXG52YXIgY29udGVudEluZm9WYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDb250ZW50SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0NvbnRlbnRJbmZvLkNvbnRlbnRUeXBlJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2NvbnRlbnRUeXBlJ1xuICB9LCB7XG4gICAgbmFtZTogJ0NvbnRlbnRJbmZvLmNvbnRlbnQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2NvbnRlbnQnXG4gIH1dXG59O1xucDd2LmNvbnRlbnRJbmZvVmFsaWRhdG9yID0gY29udGVudEluZm9WYWxpZGF0b3I7XG5cbnZhciBlbmNyeXB0ZWRDb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0VuY3J5cHRlZENvbnRlbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudFR5cGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY29udGVudFR5cGUnXG4gIH0sIHtcbiAgICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudEVuY3J5cHRpb25BbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudEVuY3J5cHRpb25BbGdvcml0aG0uYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZW5jQWxnb3JpdGhtJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobS5wYXJhbWV0ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgY2FwdHVyZUFzbjE6ICdlbmNQYXJhbWV0ZXInXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5lbmNyeXB0ZWRDb250ZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgLyogVGhlIFBLQ1MjNyBzdHJ1Y3R1cmUgb3V0cHV0IGJ5IE9wZW5TU0wgc29tZXdoYXQgZGlmZmVycyBmcm9tIHdoYXRcbiAgICAgKiBvdGhlciBpbXBsZW1lbnRhdGlvbnMgZG8gZ2VuZXJhdGUuXG4gICAgICpcbiAgICAgKiBPcGVuU1NMIGdlbmVyYXRlcyBhIHN0cnVjdHVyZSBsaWtlIHRoaXM6XG4gICAgICogU0VRVUVOQ0Uge1xuICAgICAqICAgIC4uLlxuICAgICAqICAgIFswXVxuICAgICAqICAgICAgIDI2IERBIDY3IEQyIDE3IDlDIDQ1IDNDIEIxIDJBIEE4IDU5IDJGIDI5IDMzIDM4XG4gICAgICogICAgICAgQzMgQzMgREYgODYgNzEgNzQgN0EgMTkgOUYgNDAgRDAgMjkgQkUgODUgOTAgNDVcbiAgICAgKiAgICAgICAuLi5cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBXaGVyZWFzIG90aGVyIGltcGxlbWVudGF0aW9ucyAoYW5kIHRoaXMgUEtDUyM3IG1vZHVsZSkgZ2VuZXJhdGU6XG4gICAgICogU0VRVUVOQ0Uge1xuICAgICAqICAgIC4uLlxuICAgICAqICAgIFswXSB7XG4gICAgICogICAgICAgT0NURVQgU1RSSU5HXG4gICAgICogICAgICAgICAgMjYgREEgNjcgRDIgMTcgOUMgNDUgM0MgQjEgMkEgQTggNTkgMkYgMjkgMzMgMzhcbiAgICAgKiAgICAgICAgICBDMyBDMyBERiA4NiA3MSA3NCA3QSAxOSA5RiA0MCBEMCAyOSBCRSA4NSA5MCA0NVxuICAgICAqICAgICAgICAgIC4uLlxuICAgICAqICAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byBzdXBwb3J0IGJvdGgsIHdlIGp1c3QgY2FwdHVyZSB0aGUgY29udGV4dCBzcGVjaWZpY1xuICAgICAqIGZpZWxkIGhlcmUuICBUaGUgT0NURVQgU1RSSU5HIGJpdCBpcyByZW1vdmVkIGJlbG93LlxuICAgICAqL1xuICAgIGNhcHR1cmU6ICdlbmNyeXB0ZWRDb250ZW50JyxcbiAgICBjYXB0dXJlQXNuMTogJ2VuY3J5cHRlZENvbnRlbnRBc24xJ1xuICB9XVxufTtcblxucDd2LmVudmVsb3BlZERhdGFWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdFbnZlbG9wZWREYXRhJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW52ZWxvcGVkRGF0YS5WZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9LCB7XG4gICAgbmFtZTogJ0VudmVsb3BlZERhdGEuUmVjaXBpZW50SW5mb3MnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VULFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAncmVjaXBpZW50SW5mb3MnXG4gIH1dLmNvbmNhdChlbmNyeXB0ZWRDb250ZW50SW5mb1ZhbGlkYXRvcilcbn07XG5cbnA3di5lbmNyeXB0ZWREYXRhVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnRW5jcnlwdGVkRGF0YScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0VuY3J5cHRlZERhdGEuVmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAndmVyc2lvbidcbiAgfV0uY29uY2F0KGVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yKVxufTtcblxudmFyIHNpZ25lclZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ1NpZ25lckluZm8nLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdTaWduZXJJbmZvLnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2VcbiAgfSwge1xuICAgIG5hbWU6ICdTaWduZXJJbmZvLmlzc3VlckFuZFNlcmlhbE51bWJlcicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdTaWduZXJJbmZvLmlzc3VlckFuZFNlcmlhbE51bWJlci5pc3N1ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2lzc3VlcidcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnU2lnbmVySW5mby5pc3N1ZXJBbmRTZXJpYWxOdW1iZXIuc2VyaWFsTnVtYmVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3NlcmlhbCdcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uZGlnZXN0QWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1NpZ25lckluZm8uZGlnZXN0QWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2RpZ2VzdEFsZ29yaXRobSdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RBbGdvcml0aG0ucGFyYW1ldGVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnZGlnZXN0UGFyYW1ldGVyJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdTaWduZXJJbmZvLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZTogJ2F1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uZGlnZXN0RW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnc2lnbmF0dXJlQWxnb3JpdGhtJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uZW5jcnlwdGVkRGlnZXN0JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnc2lnbmF0dXJlJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8udW5hdXRoZW50aWNhdGVkQXR0cmlidXRlcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAxLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmU6ICd1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJ1xuICB9XVxufTtcblxucDd2LnNpZ25lZERhdGFWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdTaWduZWREYXRhJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5WZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lZERhdGEuRGlnZXN0QWxnb3JpdGhtcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdkaWdlc3RBbGdvcml0aG1zJ1xuICB9LFxuICBjb250ZW50SW5mb1ZhbGlkYXRvcixcbiAge1xuICAgIG5hbWU6ICdTaWduZWREYXRhLkNlcnRpZmljYXRlcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAwLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnY2VydGlmaWNhdGVzJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lZERhdGEuQ2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdHMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2NybHMnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5TaWduZXJJbmZvcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY2FwdHVyZTogJ3NpZ25lckluZm9zJyxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWx1ZTogW3NpZ25lclZhbGlkYXRvcl1cbiAgfV1cbn07XG5cbnA3di5yZWNpcGllbnRJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnUmVjaXBpZW50SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ1JlY2lwaWVudEluZm8udmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAndmVyc2lvbidcbiAgfSwge1xuICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmlzc3VlckFuZFNlcmlhbCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmlzc3VlckFuZFNlcmlhbC5pc3N1ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2lzc3VlcidcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnUmVjaXBpZW50SW5mby5pc3N1ZXJBbmRTZXJpYWwuc2VyaWFsTnVtYmVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3NlcmlhbCdcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ1JlY2lwaWVudEluZm8ua2V5RW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmtleUVuY3J5cHRpb25BbGdvcml0aG0uYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZW5jQWxnb3JpdGhtJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmtleUVuY3J5cHRpb25BbGdvcml0aG0ucGFyYW1ldGVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnZW5jUGFyYW1ldGVyJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAnUmVjaXBpZW50SW5mby5lbmNyeXB0ZWRLZXknLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdlbmNLZXknXG4gIH1dXG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHNoYTMgPSByZXF1aXJlKCdqcy1zaGEzJylcbmNvbnN0IG11cm11cjMgPSByZXF1aXJlKCdtdXJtdXJoYXNoM2pzJylcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IHNoYSA9IHJlcXVpcmUoJy4vY3J5cHRvLXNoYTEtMicpXG5cbmNvbnN0IHRvQ2FsbGJhY2sgPSB1dGlscy50b0NhbGxiYWNrXG5jb25zdCB0b0J1ZiA9IHV0aWxzLnRvQnVmXG5jb25zdCBmcm9tU3RyaW5nID0gdXRpbHMuZnJvbVN0cmluZ1xuY29uc3QgZnJvbU51bWJlclRvMzJCaXRCdWYgPSB1dGlscy5mcm9tTnVtYmVyVG8zMkJpdEJ1ZlxuXG5jb25zdCBkYmxTaGEyMjU2ID0gKGJ1ZiwgY2IpID0+IHtcbiAgc2hhLnNoYTIyNTYoYnVmLCAoZXJyLCBmaXJzdEhhc2gpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYihlcnIpXG4gICAgfVxuICAgIHNoYS5zaGEyMjU2KChCdWZmZXIuZnJvbShmaXJzdEhhc2gpKSwgY2IpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaGExOiBzaGEuc2hhMSxcbiAgc2hhMjI1Njogc2hhLnNoYTIyNTYsXG4gIHNoYTI1MTI6IHNoYS5zaGEyNTEyLFxuICBzaGEzNTEyOiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hhM181MTIpKSxcbiAgc2hhMzM4NDogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYTNfMzg0KSksXG4gIHNoYTMyNTY6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGEzXzI1NikpLFxuICBzaGEzMjI0OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hhM18yMjQpKSxcbiAgc2hha2UxMjg6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGFrZV8xMjgsIDEyOCkpLFxuICBzaGFrZTI1NjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYWtlXzI1NiwgMjU2KSksXG4gIGtlY2NhazIyNDogdG9DYWxsYmFjayh0b0J1ZihzaGEzLmtlY2Nha18yMjQpKSxcbiAga2VjY2FrMjU2OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMua2VjY2FrXzI1NikpLFxuICBrZWNjYWszODQ6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5rZWNjYWtfMzg0KSksXG4gIGtlY2NhazUxMjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLmtlY2Nha181MTIpKSxcbiAgbXVybXVyMzEyODogdG9DYWxsYmFjayh0b0J1Zihmcm9tU3RyaW5nKG11cm11cjMueDY0Lmhhc2gxMjgpKSksXG4gIG11cm11cjMzMjogdG9DYWxsYmFjayhmcm9tTnVtYmVyVG8zMkJpdEJ1Zihmcm9tU3RyaW5nKG11cm11cjMueDg2Lmhhc2gzMikpKSxcbiAgYWRkQmxha2U6IHJlcXVpcmUoJy4vYmxha2UnKSxcbiAgZGJsU2hhMjI1NjogZGJsU2hhMjI1NlxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgU3RhdGUgPSByZXF1aXJlKCcuL3N0YXRlJylcblxuZnVuY3Rpb24gaXNJbnRlZ2VyIChpKSB7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUoaSlcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAoZikge1xuICByZXR1cm4gJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZcbn1cblxuZnVuY3Rpb24gbWF4RGVsYXkoZm4sIGRlbGF5KSB7XG4gIGlmKCFkZWxheSkgcmV0dXJuIGZuXG4gIHJldHVybiBmdW5jdGlvbiAoYSwgY2IpIHtcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuKG5ldyBFcnJvcigncHVsbC1yZWFkZXI6IHJlYWQgZXhjZWVkZWQgdGltZW91dCcpLCBjYilcbiAgICB9LCBkZWxheSlcbiAgICBmbihhLCBmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKVxuICAgICAgY2IoZXJyLCB2YWx1ZSlcbiAgICB9KVxuXG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG5cbiAgdmFyIHF1ZXVlID0gW10sIHJlYWQsIHJlYWRUaW1lZCwgcmVhZGluZyA9IGZhbHNlXG4gIHZhciBzdGF0ZSA9IFN0YXRlKCksIGVuZGVkLCBzdHJlYW1pbmcsIGFib3J0XG5cbiAgZnVuY3Rpb24gZHJhaW4gKCkge1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGlmKG51bGwgPT0gcXVldWVbMF0ubGVuZ3RoICYmIHN0YXRlLmhhcygxKSkge1xuICAgICAgICBxdWV1ZS5zaGlmdCgpLmNiKG51bGwsIHN0YXRlLmdldCgpKVxuICAgICAgfVxuICAgICAgZWxzZSBpZihzdGF0ZS5oYXMocXVldWVbMF0ubGVuZ3RoKSkge1xuICAgICAgICB2YXIgbmV4dCA9IHF1ZXVlLnNoaWZ0KClcbiAgICAgICAgbmV4dC5jYihudWxsLCBzdGF0ZS5nZXQobmV4dC5sZW5ndGgpKVxuICAgICAgfVxuICAgICAgZWxzZSBpZihlbmRlZCA9PSB0cnVlICYmIHF1ZXVlWzBdLmxlbmd0aCAmJiBzdGF0ZS5sZW5ndGggPCBxdWV1ZVswXS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG1zZyA9ICdzdHJlYW0gZW5kZWQgd2l0aDonK3N0YXRlLmxlbmd0aCsnIGJ1dCB3YW50ZWQ6JytxdWV1ZVswXS5sZW5ndGhcbiAgICAgICAgcXVldWUuc2hpZnQoKS5jYihuZXcgRXJyb3IobXNnKSlcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoZW5kZWQpXG4gICAgICAgIHF1ZXVlLnNoaWZ0KCkuY2IoZW5kZWQpXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAhIXF1ZXVlLmxlbmd0aFxuICAgIH1cbiAgICAvL2Fsd2F5cyByZWFkIGEgbGl0dGxlIGRhdGFcbiAgICByZXR1cm4gcXVldWUubGVuZ3RoIHx8ICFzdGF0ZS5oYXMoMSkgfHwgYWJvcnRcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vcmUgKCkge1xuICAgIHZhciBkID0gZHJhaW4oKVxuICAgIGlmKGQgJiYgIXJlYWRpbmcpXG4gICAgaWYocmVhZCAmJiAhcmVhZGluZyAmJiAhc3RyZWFtaW5nKSB7XG4gICAgICByZWFkaW5nID0gdHJ1ZVxuICAgICAgcmVhZFRpbWVkIChudWxsLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgIHJlYWRpbmcgPSBmYWxzZVxuICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICBlbmRlZCA9IGVyclxuICAgICAgICAgIHJldHVybiBkcmFpbigpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYWRkKGRhdGEpXG4gICAgICAgIG1vcmUoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkZXIgKF9yZWFkKSB7XG4gICAgaWYoYWJvcnQpIHtcbiAgICAgIHdoaWxlKHF1ZXVlLmxlbmd0aCkgcXVldWUuc2hpZnQoKS5jYihhYm9ydClcbiAgICAgIHJldHVybiBjYiAmJiBjYihhYm9ydClcbiAgICB9XG4gICAgcmVhZFRpbWVkID0gbWF4RGVsYXkoX3JlYWQsIHRpbWVvdXQpXG4gICAgcmVhZCA9IF9yZWFkXG4gICAgbW9yZSgpXG4gIH1cblxuICByZWFkZXIuYWJvcnQgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICAgIGFib3J0ID0gZXJyIHx8IHRydWVcbiAgICBpZihyZWFkKSB7XG4gICAgICByZWFkaW5nID0gdHJ1ZVxuICAgICAgcmVhZChhYm9ydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZShxdWV1ZS5sZW5ndGgpIHF1ZXVlLnNoaWZ0KCkuY2IoYWJvcnQpXG4gICAgICAgIGNiICYmIGNiKGFib3J0KVxuICAgICAgfSlcbiAgICB9XG4gICAgZWxzZVxuICAgICAgY2IoKVxuICB9XG5cbiAgcmVhZGVyLnJlYWQgPSBmdW5jdGlvbiAobGVuLCBfdGltZW91dCwgY2IpIHtcbiAgICBpZihpc0Z1bmN0aW9uKF90aW1lb3V0KSlcbiAgICAgIGNiID0gX3RpbWVvdXQsIF90aW1lb3V0ID0gdGltZW91dFxuICAgIGlmKGlzRnVuY3Rpb24oY2IpKSB7XG4gICAgICBxdWV1ZS5wdXNoKHtsZW5ndGg6IGlzSW50ZWdlcihsZW4pID8gbGVuIDogbnVsbCwgY2I6IGNifSlcbiAgICAgIG1vcmUoKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vc3dpdGNoIGludG8gc3RyZWFtaW5nIG1vZGUgZm9yIHRoZSByZXN0IG9mIHRoZSBzdHJlYW0uXG4gICAgICBzdHJlYW1pbmcgPSB0cnVlXG4gICAgICAvL3dhaXQgZm9yIHRoZSBjdXJyZW50IHJlYWQgdG8gY29tcGxldGVcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWJvcnQsIGNiKSB7XG4gICAgICAgIC8vaWYgdGhlcmUgaXMgYW55dGhpbmcgc3RpbGwgaW4gdGhlIHF1ZXVlLFxuICAgICAgICBpZihyZWFkaW5nIHx8IHN0YXRlLmhhcygxKSkge1xuICAgICAgICAgIGlmKGFib3J0KSByZXR1cm4gcmVhZChhYm9ydCwgY2IpXG4gICAgICAgICAgcXVldWUucHVzaCh7bGVuZ3RoOiBudWxsLCBjYjogY2J9KVxuICAgICAgICAgIG1vcmUoKVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtYXhEZWxheShyZWFkLCBfdGltZW91dCkoYWJvcnQsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIGNiKGVyciwgZGF0YSlcbiAgICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkZXJcbn1cblxuXG5cblxuXG5cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEJlc3QgcmVjb3JkIHNlbGVjdG9yLCBmb3IgcHVibGljIGtleSByZWNvcmRzLlxuICogU2ltcGx5IHJldHVybnMgdGhlIGZpcnN0IHJlY29yZCwgYXMgYWxsIHZhbGlkIHB1YmxpYyBrZXlcbiAqIHJlY29yZHMgYXJlIGVxdWFsLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBrXG4gKiBAcGFyYW0ge0FycmF5PEJ1ZmZlcj59IHJlY29yZHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmNvbnN0IHB1YmxpY0tleVNlbGVjdG9yID0gKGssIHJlY29yZHMpID0+IHtcbiAgcmV0dXJuIDBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwdWJsaWNLZXlTZWxlY3RvclxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWZmZXJJbmRleE9mKGJ1ZixzZWFyY2gsb2Zmc2V0KXtcbiAgb2Zmc2V0ID0gb2Zmc2V0fHwwXG4gIFxuICB2YXIgbSA9IDA7XG4gIHZhciBzID0gLTE7XG4gIGZvcih2YXIgaT1vZmZzZXQ7aTxidWYubGVuZ3RoOysraSl7XG4gICAgaWYoYnVmW2ldID09IHNlYXJjaFttXSkge1xuICAgICAgaWYocyA9PSAtMSkgcyA9IGk7XG4gICAgICArK207XG4gICAgICBpZihtID09IHNlYXJjaC5sZW5ndGgpIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gLTE7XG4gICAgICBtID0gMDtcbiAgICB9XG4gIH1cblxuICBpZiAocyA+IC0xICYmIGJ1Zi5sZW5ndGggLSBzIDwgc2VhcmNoLmxlbmd0aCkgcmV0dXJuIC0xO1xuICByZXR1cm4gcztcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuY29uc3QgbXVsdGloYXNoaW5nID0gcmVxdWlyZSgnbXVsdGloYXNoaW5nLWFzeW5jJylcblxuLyoqXG4gKiBWYWxpZGF0b3IgZm9yIHB1YmxpY2sga2V5IHJlY29yZHMuXG4gKiBWZXJpZmllcyB0aGF0IHRoZSBwYXNzZWQgaW4gcmVjb3JkIHZhbHVlIGlzIHRoZSBQdWJsaWNLZXlcbiAqIHRoYXQgbWF0Y2hlcyB0aGUgcGFzc2VkIGluIGtleS5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0ga2V5IC0gQSB2YWxpZCBrZXkgaXMgb2YgdGhlIGZvcm0gYCcvcGsvPGtleW11bHRpaGFzaD4nYFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHRvIHZhbGlkYXRlIGFnYWluc3QgKHByb3RvYnVmIGVuY29kZWQpLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5jb25zdCB2YWxpZGF0ZVB1YmxpY0tleVJlY29yZCA9IChrZXksIHB1YmxpY0tleSwgY2FsbGJhY2spID0+IHtcbiAgY29uc3QgZG9uZSA9IChlcnIpID0+IHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhlcnIpKVxuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGtleSkpIHtcbiAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ1wia2V5XCIgbXVzdCBiZSBhIEJ1ZmZlcicpKVxuICB9XG5cbiAgaWYgKGtleS5sZW5ndGggPCAzKSB7XG4gICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdpbnZhbGlkIHB1YmxpYyBrZXkgcmVjb3JkJykpXG4gIH1cblxuICBjb25zdCBwcmVmaXggPSBrZXkuc2xpY2UoMCwgNCkudG9TdHJpbmcoKVxuXG4gIGlmIChwcmVmaXggIT09ICcvcGsvJykge1xuICAgIHJldHVybiBkb25lKG5ldyBFcnJvcigna2V5IHdhcyBub3QgcHJlZml4ZWQgd2l0aCAvcGsvJykpXG4gIH1cblxuICBjb25zdCBrZXloYXNoID0ga2V5LnNsaWNlKDQpXG5cbiAgbXVsdGloYXNoaW5nKHB1YmxpY0tleSwgJ3NoYTItMjU2JywgKGVyciwgcHVibGljS2V5SGFzaCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBkb25lKGVycilcbiAgICB9XG5cbiAgICBpZiAoIWtleWhhc2guZXF1YWxzKHB1YmxpY0tleUhhc2gpKSB7XG4gICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ3B1YmxpYyBrZXkgZG9lcyBub3QgbWF0Y2ggcGFzc2VkIGluIGtleScpKVxuICAgIH1cblxuICAgIGRvbmUoKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZnVuYzogdmFsaWRhdGVQdWJsaWNLZXlSZWNvcmQsXG4gIHNpZ246IGZhbHNlXG59XG4iLCJ2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kdXBsZXgnKVxuXG5leHBvcnRzLnNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlJyk7XG5leHBvcnRzLnNpbmsgPSByZXF1aXJlKCcuL3NpbmsnKTtcbmV4cG9ydHMuY3JlYXRlU2VydmVyID0gcmVxdWlyZSgnLi9zZXJ2ZXInKVxuZXhwb3J0cy5jb25uZWN0ID0gcmVxdWlyZSgnLi9jbGllbnQnKVxuIiwiXG4vL25vcm1hbGl6ZSBhIHdzIHVybC5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwnKVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXJsLCBsb2NhdGlvbiwgcHJvdG9jb2xNYXAsIGRlZmF1bHRQcm90b2NvbCkge1xuICBwcm90b2NvbE1hcCA9IHByb3RvY29sTWFwIHx8e31cbiAgLypcblxuICBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjYueC9kb2NzL2FwaS91cmwuaHRtbCN1cmxfdXJsX3BhcnNlX3VybHN0cl9wYXJzZXF1ZXJ5c3RyaW5nX3NsYXNoZXNkZW5vdGVob3N0XG5cbiAgSSBkaWRuJ3Qga25vdyB0aGlzLCBidXQgdXJsLnBhcnNlIHRha2VzIGEgM3JkXG4gIGFyZ3VtZW50IHdoaWNoIGludGVycHJldHMgXCIvL2Zvby5jb21cIiBhcyB0aGUgaG9zdG5hbWUsXG4gIGJ1dCB3aXRob3V0IHRoZSBwcm90b2NvbC4gYnkgZGVmYXVsdCwgLy8gaXMgaW50ZXJwcmV0ZWRcbiAgYXMgdGhlIHBhdGguXG5cbiAgdGhhdCBsZXRzIHVzIGRvIHdoYXQgdGhlIHdzdXJsIG1vZHVsZSBkb2VzLlxuICBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS93c3VybFxuXG4gIGJ1dCBtb3N0IG9mIHRoZSB0aW1lLCBJIHdhbnQgdG8gd3JpdGUganNcbiAgdGhhdCB3aWxsIHdvcmsgb24gbG9jYWxob3N0LCBhbmQgd2lsbCB3b3JrXG4gIG9uIGEgc2VydmVyLi4uXG5cbiAgc28gSSB3YW50IHRvIGp1c3QgZG8gY3JlYXRlV2ViU29ja2V0KCcvJylcbiAgYW5kIGdldCBcIndzOi8vbXlkb21haW4uY29tL1wiXG5cbiAgKi9cblxuICB2YXIgdXJsID0gVVJMLnBhcnNlKHVybCwgZmFsc2UsIHRydWUpXG5cbiAgdmFyIHByb3RvXG4gIGlmKHVybC5wcm90b2NvbCkgcHJvdG8gPSB1cmwucHJvdG9jb2xcbiAgZWxzZSB7XG4gICAgcHJvdG8gPSBsb2NhdGlvbi5wcm90b2NvbCA/IGxvY2F0aW9uLnByb3RvY29sLnJlcGxhY2UoLzokLywnJykgOiAnaHR0cCdcbiAgICBwcm90byA9ICgocHJvdG9jb2xNYXApW3Byb3RvXSB8fCBkZWZhdWx0UHJvdG9jb2wgfHwgcHJvdG8pICsgJzonXG4gIH1cblxuICAvL2hhbmRsZSBxdWlyayBpbiB1cmwgcGFja2FnZVxuICBpZih1cmwuaG9zdCAmJiB1cmwuaG9zdFswXSA9PT0gJzonKVxuICAgIHVybC5ob3N0ID0gbnVsbFxuXG4gIC8vdXNlZnVsIGZvciB3ZWJzb2NrZXRzXG4gIGlmKHVybC5ob3N0bmFtZSkge1xuICAgIHJldHVybiBVUkwuZm9ybWF0KHtcbiAgICAgIHByb3RvY29sOiBwcm90byxcbiAgICAgIHNsYXNoZXM6IHRydWUsXG4gICAgICBob3N0bmFtZTogdXJsLmhvc3RuYW1lLFxuICAgICAgcG9ydDogdXJsLnBvcnQsXG4gICAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoOiB1cmwuc2VhcmNoXG4gICAgfSlcbiAgfVxuICBlbHNlIHVybC5ob3N0ID0gbG9jYXRpb24uaG9zdFxuXG4gIC8vaW5jbHVkZWQgZm9yIGNvbXBsZXRlbmVzcy4gd291bGQgeW91IHdhbnQgdG8gZG8gdGhpcz9cbiAgaWYodXJsLnBvcnQpIHtcbiAgICByZXR1cm4gVVJMLmZvcm1hdCh7XG4gICAgICBwcm90b2NvbDogcHJvdG8sXG4gICAgICBzbGFzaGVzOiB0cnVlLFxuICAgICAgaG9zdDogbG9jYXRpb24uaG9zdG5hbWUgKyAnOicgKyB1cmwucG9ydCxcbiAgICAgIHBvcnQ6IHVybC5wb3J0LFxuICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgIHNlYXJjaDogdXJsLnNlYXJjaFxuICAgIH0pXG4gIH1cblxuICAvL2RlZmluYXRlbHkgdXNlZnVsIGZvciB3ZWJzb2NrZXRzXG4gIGlmKHVybC5wYXRobmFtZSkge1xuICAgIHJldHVybiBVUkwuZm9ybWF0KHtcbiAgICAgIHByb3RvY29sOiBwcm90byxcbiAgICAgIHNsYXNoZXM6IHRydWUsXG4gICAgICBob3N0OiB1cmwuaG9zdCxcbiAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG4gICAgICBzZWFyY2g6IHVybC5zZWFyY2hcbiAgICB9KVxuICB9XG4gIGVsc2VcbiAgICB1cmwucGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZVxuXG4gIC8vaW5jbHVkZWQgZm9yIGNvbXBsZXRlbmVzcy4gd291bGQgeW91IHdhbnQgdG8gZG8gdGhpcz9cbiAgaWYodXJsLnNlYXJjaCkge1xuICAgIHJldHVybiBVUkwuZm9ybWF0KHtcbiAgICAgIHByb3RvY29sOiBwcm90byxcbiAgICAgIHNsYXNoZXM6IHRydWUsXG4gICAgICBob3N0OiB1cmwuaG9zdCxcbiAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG4gICAgICBzZWFyY2g6IHVybC5zZWFyY2hcbiAgICB9KVxuICB9XG4gIGVsc2UgdXJsLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaFxuXG4gIHJldHVybiB1cmwuZm9ybWF0KHVybClcbn1cblxuXG5cblxuXG4iLCJ2YXIgcmVhZHkgPSByZXF1aXJlKCcuL3JlYWR5Jyk7XG5cbi8qKlxuICAjIyMgYHNpbmsoc29ja2V0LCBvcHRzPylgXG5cbiAgQ3JlYXRlIGEgcHVsbC1zdHJlYW0gYFNpbmtgIHRoYXQgd2lsbCB3cml0ZSBkYXRhIHRvIHRoZSBgc29ja2V0YC5cblxuICA8PDwgZXhhbXBsZXMvd3JpdGUuanNcblxuKiovXG5cbnZhciBuZXh0VGljayA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnID8gc2V0SW1tZWRpYXRlIDogcHJvY2Vzcy5uZXh0VGlja1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNvY2tldCwgb3B0cykge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlYWQpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuICAgIHZhciBjbG9zZU9uRW5kID0gb3B0cy5jbG9zZU9uRW5kICE9PSBmYWxzZTtcbiAgICB2YXIgb25DbG9zZSA9ICdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRzID8gb3B0cyA6IG9wdHMub25DbG9zZTtcblxuICAgIGZ1bmN0aW9uIG5leHQoZW5kLCBkYXRhKSB7XG4gICAgICAvLyBpZiB0aGUgc3RyZWFtIGhhcyBlbmRlZCwgc2ltcGx5IHJldHVyblxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBpZiAoY2xvc2VPbkVuZCAmJiBzb2NrZXQucmVhZHlTdGF0ZSA8PSAxKSB7XG4gICAgICAgICAgaWYob25DbG9zZSlcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBpZihldi53YXNDbGVhbiB8fCBldi5jb2RlID09PSAxMDA2KSBvbkNsb3NlKClcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignd3MgZXJyb3InKVxuICAgICAgICAgICAgICAgIGVyci5ldmVudCA9IGV2XG4gICAgICAgICAgICAgICAgb25DbG9zZShlcnIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgc29ja2V0LmNsb3NlKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gc29ja2V0IHJlYWR5P1xuICAgICAgcmVhZHkoc29ja2V0LCBmdW5jdGlvbihlbmQpIHtcbiAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgIHJldHVybiByZWFkKGVuZCwgZnVuY3Rpb24gKCkge30pO1xuICAgICAgICB9XG4gICAgICAgIHNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICBuZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICByZWFkKG51bGwsIG5leHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlYWQobnVsbCwgbmV4dCk7XG4gIH1cbn1cbiIsIi8qKlxuICAjIyMgYHNvdXJjZShzb2NrZXQpYFxuXG4gIENyZWF0ZSBhIHB1bGwtc3RyZWFtIGBTb3VyY2VgIHRoYXQgd2lsbCByZWFkIGRhdGEgZnJvbSB0aGUgYHNvY2tldGAuXG5cbiAgPDw8IGV4YW1wbGVzL3JlYWQuanNcblxuKiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5cbi8vIGNvcGllZCBmcm9tIGdpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlclxuLy8gU29tZSBBcnJheUJ1ZmZlcnMgYXJlIG5vdCBwYXNzaW5nIHRoZSBpbnN0YW5jZW9mIGNoZWNrLCBzbyB3ZSBuZWVkIHRvIGRvIGEgYml0IG1vcmUgd29yayA6KFxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxuICAgICAgdHlwZW9mIG9iai5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzb2NrZXQsIGNiKSB7XG4gIHZhciBidWZmZXIgPSBbXTtcbiAgdmFyIHJlY2VpdmVyO1xuICB2YXIgZW5kZWQ7XG4gIHZhciBzdGFydGVkID0gZmFsc2U7XG4gIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIGRhdGEgPSBldnQuZGF0YTtcbiAgICBpZiAoaXNBcnJheUJ1ZmZlcihkYXRhKSkge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgIH1cblxuICAgIGlmIChyZWNlaXZlcikge1xuICAgICAgcmV0dXJuIHJlY2VpdmVyKG51bGwsIGRhdGEpO1xuICAgIH1cblxuICAgIGJ1ZmZlci5wdXNoKGRhdGEpO1xuICB9KTtcblxuICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBmdW5jdGlvbihldnQpIHtcbiAgICBpZiAoZW5kZWQpIHJldHVyblxuICAgIGlmIChyZWNlaXZlcikge1xuICAgICAgcmVjZWl2ZXIoZW5kZWQgPSB0cnVlKVxuICAgIH1cbiAgfSk7XG5cbiAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKGV2dCkge1xuICAgIGlmIChlbmRlZCkgcmV0dXJuO1xuICAgIGVuZGVkID0gZXZ0O1xuICAgIGlmKCFzdGFydGVkKSB7XG4gICAgICBzdGFydGVkID0gdHJ1ZVxuICAgICAgY2IgJiYgY2IoZXZ0KVxuICAgIH1cbiAgICBpZiAocmVjZWl2ZXIpIHtcbiAgICAgIHJlY2VpdmVyKGVuZGVkKVxuICAgIH1cbiAgfSk7XG5cbiAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYoc3RhcnRlZCB8fCBlbmRlZCkgcmV0dXJuXG4gICAgc3RhcnRlZCA9IHRydWVcbiAgfSlcblxuICBmdW5jdGlvbiByZWFkKGFib3J0LCBjYikge1xuICAgIHJlY2VpdmVyID0gbnVsbDtcblxuICAgIC8vaWYgc3RyZWFtIGhhcyBhbHJlYWR5IGVuZGVkLlxuICAgIGlmIChlbmRlZClcbiAgICAgIHJldHVybiBjYihlbmRlZCk7XG5cbiAgICAvLyBpZiBlbmRlZCwgYWJvcnRcbiAgICBlbHNlIGlmIChhYm9ydCkge1xuICAgICAgLy90aGlzIHdpbGwgY2FsbGJhY2sgd2hlbiBzb2NrZXQgY2xvc2VzXG4gICAgICByZWNlaXZlciA9IGNiXG4gICAgICBzb2NrZXQuY2xvc2UoKVxuICAgIH1cblxuICAgIC8vIHJldHVybiBkYXRhLCBpZiBhbnlcbiAgICBlbHNlIGlmKGJ1ZmZlci5sZW5ndGggPiAwKVxuICAgICAgY2IobnVsbCwgYnVmZmVyLnNoaWZ0KCkpO1xuXG4gICAgLy8gd2FpdCBmb3IgbW9yZSBkYXRhIChvciBlbmQpXG4gICAgZWxzZVxuICAgICAgcmVjZWl2ZXIgPSBjYjtcblxuICB9O1xuXG4gIHJldHVybiByZWFkO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEEgbGlzdCBvZiB1bmlxdWUgcGVlciBpbmZvcy5cbiAqL1xuY2xhc3MgUGVlckxpc3Qge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5saXN0ID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgaW5mby4gUmV0dXJucyBgdHJ1ZWAgaWYgaXQgd2FzIGEgbmV3IG9uZVxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJbmZvfSBpbmZvXG4gICAqIEByZXR1cm5zIHtib29sfVxuICAgKi9cbiAgcHVzaCAoaW5mbykge1xuICAgIGlmICghdGhpcy5oYXMoaW5mbykpIHtcbiAgICAgIHRoaXMubGlzdC5wdXNoKGluZm8pXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGlzIFBlZXJJbmZvIGlzIGFscmVhZHkgaW4gaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySW5mb30gaW5mb1xuICAgKiBAcmV0dXJucyB7Ym9vbH1cbiAgICovXG4gIGhhcyAoaW5mbykge1xuICAgIGNvbnN0IG1hdGNoID0gdGhpcy5saXN0LmZpbmQoKGkpID0+IGkuaWQuaXNFcXVhbChpbmZvLmlkKSlcbiAgICByZXR1cm4gQm9vbGVhbihtYXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3QgYXMgYW4gYXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheTxQZWVySW5mbz59XG4gICAqL1xuICB0b0FycmF5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0LnNsaWNlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGxhc3QgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJucyB7UGVlckluZm99XG4gICAqL1xuICBwb3AgKCkge1xuICAgIHJldHVybiB0aGlzLmxpc3QucG9wKClcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBsaXN0XG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0Lmxlbmd0aFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVlckxpc3RcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzaGEzID0gcmVxdWlyZSgnanMtc2hhMycpXG5jb25zdCBtdXJtdXIzID0gcmVxdWlyZSgnbXVybXVyaGFzaDNqcycpXG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBzaGEgPSByZXF1aXJlKCcuL2NyeXB0by1zaGExLTInKVxuXG5jb25zdCB0b0NhbGxiYWNrID0gdXRpbHMudG9DYWxsYmFja1xuY29uc3QgdG9CdWYgPSB1dGlscy50b0J1ZlxuY29uc3QgZnJvbVN0cmluZyA9IHV0aWxzLmZyb21TdHJpbmdcbmNvbnN0IGZyb21OdW1iZXJUbzMyQml0QnVmID0gdXRpbHMuZnJvbU51bWJlclRvMzJCaXRCdWZcblxuY29uc3QgZGJsU2hhMjI1NiA9IChidWYsIGNiKSA9PiB7XG4gIHNoYS5zaGEyMjU2KGJ1ZiwgKGVyciwgZmlyc3RIYXNoKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2IoZXJyKVxuICAgIH1cbiAgICBzaGEuc2hhMjI1NigoQnVmZmVyLmZyb20oZmlyc3RIYXNoKSksIGNiKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2hhMTogc2hhLnNoYTEsXG4gIHNoYTIyNTY6IHNoYS5zaGEyMjU2LFxuICBzaGEyNTEyOiBzaGEuc2hhMjUxMixcbiAgc2hhMzUxMjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYTNfNTEyKSksXG4gIHNoYTMzODQ6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGEzXzM4NCkpLFxuICBzaGEzMjU2OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hhM18yNTYpKSxcbiAgc2hhMzIyNDogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYTNfMjI0KSksXG4gIHNoYWtlMTI4OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hha2VfMTI4LCAxMjgpKSxcbiAgc2hha2UyNTY6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGFrZV8yNTYsIDI1NikpLFxuICBrZWNjYWsyMjQ6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5rZWNjYWtfMjI0KSksXG4gIGtlY2NhazI1NjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLmtlY2Nha18yNTYpKSxcbiAga2VjY2FrMzg0OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMua2VjY2FrXzM4NCkpLFxuICBrZWNjYWs1MTI6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5rZWNjYWtfNTEyKSksXG4gIG11cm11cjMxMjg6IHRvQ2FsbGJhY2sodG9CdWYoZnJvbVN0cmluZyhtdXJtdXIzLng2NC5oYXNoMTI4KSkpLFxuICBtdXJtdXIzMzI6IHRvQ2FsbGJhY2soZnJvbU51bWJlclRvMzJCaXRCdWYoZnJvbVN0cmluZyhtdXJtdXIzLng4Ni5oYXNoMzIpKSksXG4gIGFkZEJsYWtlOiByZXF1aXJlKCcuL2JsYWtlJyksXG4gIGRibFNoYTIyNTY6IGRibFNoYTIyNTZcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkaXN0YW5jZSA9IHJlcXVpcmUoJ3hvci1kaXN0YW5jZScpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgbWFwID0gcmVxdWlyZSgnYXN5bmMvbWFwJylcblxuLyoqXG4gKiBNYWludGFpbnMgYSBsaXN0IG9mIHBlZXJJZHMgc29ydGVkIGJ5IGRpc3RhbmNlIGZyb20gYSBESFQga2V5LlxuICovXG5jbGFzcyBQZWVyRGlzdGFuY2VMaXN0IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUGVlckRpc3RhbmNlTGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IG9yaWdpbkRodEtleSAtIHRoZSBESFQga2V5IGZyb20gd2hpY2ggZGlzdGFuY2UgaXMgY2FsY3VsYXRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gY2FwYWNpdHkgLSB0aGUgbWF4aW11bSBzaXplIG9mIHRoZSBsaXN0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3JpZ2luRGh0S2V5LCBjYXBhY2l0eSkge1xuICAgIHRoaXMub3JpZ2luRGh0S2V5ID0gb3JpZ2luRGh0S2V5XG4gICAgdGhpcy5jYXBhY2l0eSA9IGNhcGFjaXR5XG4gICAgdGhpcy5wZWVyRGlzdGFuY2VzID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBsaXN0XG4gICAqL1xuICBnZXQgbGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5wZWVyRGlzdGFuY2VzLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwZWVySWRzIGluIHRoZSBsaXN0LCBpbiBvcmRlciBvZiBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4ga2V5XG4gICAqL1xuICBnZXQgcGVlcnMgKCkge1xuICAgIHJldHVybiB0aGlzLnBlZXJEaXN0YW5jZXMubWFwKHBkID0+IHBkLnBlZXJJZClcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwZWVySWQgdG8gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlcklkfSBwZWVySWRcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgYWRkIChwZWVySWQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGVlckRpc3RhbmNlcy5maW5kKHBkID0+IHBkLnBlZXJJZC5pZC5lcXVhbHMocGVlcklkLmlkKSkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgfVxuXG4gICAgdXRpbHMuY29udmVydFBlZXJJZChwZWVySWQsIChlcnIsIGRodEtleSkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlbCA9IHtcbiAgICAgICAgcGVlcklkLFxuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UodGhpcy5vcmlnaW5EaHRLZXksIGRodEtleSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5wZWVyRGlzdGFuY2VzLnB1c2goZWwpXG4gICAgICB0aGlzLnBlZXJEaXN0YW5jZXMuc29ydCgoYSwgYikgPT4gZGlzdGFuY2UuY29tcGFyZShhLmRpc3RhbmNlLCBiLmRpc3RhbmNlKSlcbiAgICAgIHRoaXMucGVlckRpc3RhbmNlcyA9IHRoaXMucGVlckRpc3RhbmNlcy5zbGljZSgwLCB0aGlzLmNhcGFjaXR5KVxuXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhbnkgb2YgdGhlIHBlZXJJZHMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGFyZSBjbG9zZXJcbiAgICogdG8gdGhlIG9yaWdpbiBrZXkgdGhhbiB0aGUgZnVydGhlc3QgcGVlcklkIGluIHRoZSBQZWVyRGlzdGFuY2VMaXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFBlZXJJZD59IHBlZXJJZHNcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQm9vbGVhbil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgYW55Q2xvc2VyIChwZWVySWRzLCBjYWxsYmFjaykge1xuICAgIGlmICghcGVlcklkcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBmYWxzZSlcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdHJ1ZSlcbiAgICB9XG5cbiAgICBtYXAocGVlcklkcywgKHBlZXJJZCwgY2IpID0+IHV0aWxzLmNvbnZlcnRQZWVySWQocGVlcklkLCBjYiksIChlcnIsIGRodEtleXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgY29uc3QgZnVydGhlc3REaXN0YW5jZSA9IHRoaXMucGVlckRpc3RhbmNlc1t0aGlzLnBlZXJEaXN0YW5jZXMubGVuZ3RoIC0gMV0uZGlzdGFuY2VcbiAgICAgIGZvciAoY29uc3QgZGh0S2V5IG9mIGRodEtleXMpIHtcbiAgICAgICAgY29uc3Qga2V5RGlzdGFuY2UgPSBkaXN0YW5jZSh0aGlzLm9yaWdpbkRodEtleSwgZGh0S2V5KVxuICAgICAgICBpZiAoZGlzdGFuY2UuY29tcGFyZShrZXlEaXN0YW5jZSwgZnVydGhlc3REaXN0YW5jZSkgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHRydWUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBmYWxzZSlcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVlckRpc3RhbmNlTGlzdFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHF1ZXVlID0gcmVxdWlyZSgnYXN5bmMvcXVldWUnKVxuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgncHJvbWlzaWZ5LWVzNicpXG5jb25zdCBwcm9taXNlVG9DYWxsYmFjayA9IHJlcXVpcmUoJ3Byb21pc2UtdG8tY2FsbGJhY2snKVxuXG5jbGFzcyBXb3JrZXJRdWV1ZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFdvcmtlclF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RIVH0gZGh0XG4gICAqIEBwYXJhbSB7UnVufSBydW5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhdGhcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbG9nXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGh0LCBydW4sIHBhdGgsIGxvZykge1xuICAgIHRoaXMuZGh0ID0gZGh0XG4gICAgdGhpcy5ydW4gPSBydW5cbiAgICB0aGlzLnBhdGggPSBwYXRoXG4gICAgdGhpcy5sb2cgPSBsb2dcblxuICAgIHRoaXMuY29uY3VycmVuY3kgPSB0aGlzLmRodC5jb25jdXJyZW5jeVxuICAgIHRoaXMucXVldWUgPSB0aGlzLnNldHVwUXVldWUoKVxuICAgIC8vIGEgY29udGFpbmVyIGZvciByZXNvbHZlL3JlamVjdCBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIHBvcHVsYXRlZFxuICAgIC8vIHdoZW4gZXhlY3V0ZSgpIGlzIGNhbGxlZFxuICAgIHRoaXMuZXhlY3V0aW9uID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgdW5kZXJseWluZyBhc3luYyBxdWV1ZS5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHNldHVwUXVldWUgKCkge1xuICAgIGNvbnN0IHEgPSBxdWV1ZSgocGVlciwgY2IpID0+IHtcbiAgICAgIHByb21pc2VUb0NhbGxiYWNrKHRoaXMucHJvY2Vzc05leHQocGVlcikpKGNiKVxuICAgIH0sIHRoaXMuY29uY3VycmVuY3kpXG5cbiAgICAvLyBJZiB0aGVyZSdzIGFuIGVycm9yLCBzdG9wIHRoZSB3b3JrZXJcbiAgICBxLmVycm9yID0gKGVycikgPT4ge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoJ3F1ZXVlJywgZXJyKVxuICAgICAgdGhpcy5zdG9wKGVycilcbiAgICB9XG5cbiAgICAvLyBXaGVuIGFsbCBwZWVycyBpbiB0aGUgcXVldWUgaGF2ZSBiZWVuIHByb2Nlc3NlZCwgc3RvcCB0aGUgd29ya2VyXG4gICAgcS5kcmFpbiA9ICgpID0+IHtcbiAgICAgIHRoaXMubG9nKCdxdWV1ZTpkcmFpbicpXG4gICAgICB0aGlzLnN0b3AoKVxuICAgIH1cblxuICAgIC8vIFdoZW4gYSBzcGFjZSBvcGVucyB1cCBpbiB0aGUgcXVldWUsIGFkZCBzb21lIG1vcmUgcGVlcnNcbiAgICBxLnVuc2F0dXJhdGVkID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICB0aGlzLmZpbGwoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHEuYnVmZmVyID0gMFxuXG4gICAgcmV0dXJuIHFcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSB3b3JrZXIsIG9wdGlvbmFsbHkgcHJvdmlkaW5nIGFuIGVycm9yIHRvIHBhc3MgdG8gdGhlIHdvcmtlcidzXG4gICAqIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAgICovXG4gIHN0b3AgKGVycikge1xuICAgIGlmICghdGhpcy5ydW5uaW5nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZVxuICAgIHRoaXMucXVldWUua2lsbCgpXG4gICAgdGhpcy5sb2coJ3dvcmtlcjpzdG9wLCAlZCB3b3JrZXJzIHN0aWxsIHJ1bm5pbmcnLCB0aGlzLnJ1bi53b3JrZXJzLmZpbHRlcih3ID0+IHcucnVubmluZykubGVuZ3RoKVxuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXMuZXhlY3V0aW9uLnJlamVjdChlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhlY3V0aW9uLnJlc29sdmUoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhlIHF1ZXVlIGZyb20gYXN5bmMgdG8ga2VlcCBgY29uY3VycmVuY3lgIGFtb3VudCBpdGVtcyBydW5uaW5nXG4gICAqIHBlciBwYXRoLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgZXhlY3V0ZSAoKSB7XG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZVxuICAgIC8vIHN0b3JlIHRoZSBwcm9taXNlIHJlc29sdXRpb24gZnVuY3Rpb25zIHRvIGJlIHJlc29sdmVkIGF0IGVuZCBvZiBxdWV1ZVxuICAgIHRoaXMuZXhlY3V0aW9uID0ge31cbiAgICBjb25zdCBleGVjUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IE9iamVjdC5hc3NpZ24odGhpcy5leGVjdXRpb24sIHsgcmVzb2x2ZSwgcmVqZWN0IH0pKVxuICAgIC8vIHN0YXJ0IHF1ZXVlXG4gICAgdGhpcy5maWxsKClcbiAgICAvLyBhd2FpdCBjb21wbGV0aW9uXG4gICAgYXdhaXQgZXhlY1Byb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgcGVlcnMgdG8gdGhlIHdvcmtlciBxdWV1ZSB1bnRpbCB0aGVyZSBhcmUgZW5vdWdoIHRvIHNhdGlzZnkgdGhlXG4gICAqIHdvcmtlciBxdWV1ZSBjb25jdXJyZW5jeS5cbiAgICogTm90ZSB0aGF0IHdlIGRvbid0IHdhbnQgdG8gdGFrZSBhbnkgbW9yZSB0aGFuIHRob3NlIHJlcXVpcmVkIHRvIHNhdGlzZnlcbiAgICogY29uY3VycmVuY3kgZnJvbSB0aGUgcGVlcnMtdG8tcXVlcnkgcXVldWUsIGJlY2F1c2Ugd2UgYWx3YXlzIHdhbnQgdG9cbiAgICogcXVlcnkgdGhlIGNsb3Nlc3QgcGVlcnMgdG8gdGhlIGtleSBmaXJzdCwgYW5kIG5ldyBwZWVycyBhcmUgY29udGlub3VzbHlcbiAgICogYmVpbmcgYWRkZWQgdG8gdGhlIHBlZXJzLXRvLXF1ZXJ5IHF1ZXVlLlxuICAgKi9cbiAgZmlsbCAoKSB7XG4gICAgLy8gTm90ZTpcbiAgICAvLyAtIHF1ZXVlLnJ1bm5pbmcoKTogbnVtYmVyIG9mIGl0ZW1zIHRoYXQgYXJlIGN1cnJlbnRseSBydW5uaW5nXG4gICAgLy8gLSBxdWV1ZS5sZW5ndGgoKTogdGhlIG51bWJlciBvZiBpdGVtcyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlIHJ1blxuICAgIHdoaWxlICh0aGlzLnF1ZXVlLnJ1bm5pbmcoKSArIHRoaXMucXVldWUubGVuZ3RoKCkgPCB0aGlzLmNvbmN1cnJlbmN5ICYmXG4gICAgICAgICAgIHRoaXMucGF0aC5wZWVyc1RvUXVlcnkubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRoaXMucGF0aC5wZWVyc1RvUXVlcnkuZGVxdWV1ZSgpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBuZXh0IHBlZXIgaW4gdGhlIHF1ZXVlXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlcklkfSBwZWVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgcHJvY2Vzc05leHQgKHBlZXIpIHtcbiAgICBpZiAoIXRoaXMucnVubmluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gVGhlIHBhdGhzIG11c3QgYmUgZGlzam9pbnQsIG1lYW5pbmcgdGhhdCBubyB0d28gcGF0aHMgaW4gdGhlIFF1ZXJ5IG1heVxuICAgIC8vIHRyYXZlcnNlIHRoZSBzYW1lIHBlZXJcbiAgICBpZiAodGhpcy5ydW4ucGVlcnNTZWVuLmhhcyhwZWVyKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgd2UndmUgcXVlcmllZCBlbm91Z2ggcGVlcnMgYWxyZWFkeVxuICAgIGxldCBjb250aW51ZVF1ZXJ5aW5nLCBjb250aW51ZVF1ZXJ5aW5nRXJyb3JcbiAgICB0cnkge1xuICAgICAgY29udGludWVRdWVyeWluZyA9IGF3YWl0IHRoaXMucnVuLmNvbnRpbnVlUXVlcnlpbmcodGhpcylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnRpbnVlUXVlcnlpbmdFcnJvciA9IGVyclxuICAgIH1cblxuICAgIC8vIEFib3J0IGFuZCBpZ25vcmUgYW55IGVycm9yIGlmIHdlJ3JlIG5vIGxvbmdlciBydW5uaW5nXG4gICAgaWYgKCF0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjb250aW51ZVF1ZXJ5aW5nRXJyb3IpIHtcbiAgICAgIHRocm93IGNvbnRpbnVlUXVlcnlpbmdFcnJvclxuICAgIH1cblxuICAgIC8vIE5vIHBlZXIgd2UncmUgcXVlcnlpbmcgaXMgY2xvc2VyLCBzdG9wIHRoZSBxdWV1ZVxuICAgIC8vIFRoaXMgd2lsbCBjYXVzZSBxdWVyaWVzIHRoYXQgbWF5IHBvdGVudGlhbGx5IHJlc3VsdCBpblxuICAgIC8vIGNsb3NlciBub2RlcyB0byBiZSBlbmRlZCwgYnV0IGl0IHJlZHVjZXMgb3ZlcmFsbCBxdWVyeSB0aW1lXG4gICAgaWYgKCFjb250aW51ZVF1ZXJ5aW5nKSB7XG4gICAgICB0aGlzLnN0b3AoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYW5vdGhlciBwYXRoIGhhcyBxdWVyaWVkIHRoaXMgcGVlciBpbiB0aGUgbWVhbiB0aW1lXG4gICAgaWYgKHRoaXMucnVuLnBlZXJzU2Vlbi5oYXMocGVlcikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnJ1bi5wZWVyc1NlZW4uYWRkKHBlZXIpXG5cbiAgICAvLyBFeGVjdXRlIHRoZSBxdWVyeSBvbiB0aGUgbmV4dCBwZWVyXG4gICAgdGhpcy5sb2coJ3F1ZXVlOndvcmsnKVxuICAgIGxldCBzdGF0ZSwgZXhlY0Vycm9yXG4gICAgdHJ5IHtcbiAgICAgIHN0YXRlID0gYXdhaXQgdGhpcy5leGVjUXVlcnkocGVlcilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGV4ZWNFcnJvciA9IGVyclxuICAgIH1cblxuICAgIC8vIEFib3J0IGFuZCBpZ25vcmUgYW55IGVycm9yIGlmIHdlJ3JlIG5vIGxvbmdlciBydW5uaW5nXG4gICAgaWYgKCF0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMubG9nKCdxdWV1ZTp3b3JrOmRvbmUnLCBleGVjRXJyb3IsIHN0YXRlKVxuXG4gICAgaWYgKGV4ZWNFcnJvcikge1xuICAgICAgdGhyb3cgZXhlY0Vycm9yXG4gICAgfVxuXG4gICAgLy8gSWYgcXVlcnkgaXMgY29tcGxldGUsIHN0b3AgYWxsIHdvcmtlcnMuXG4gICAgLy8gTm90ZTogcnVuLnN0b3AoKSBjYWxscyBzdG9wKCkgb24gYWxsIHRoZSB3b3JrZXJzLCB3aGljaCBraWxscyB0aGVcbiAgICAvLyBxdWV1ZSBhbmQgcmVzb2x2ZXMgZXhlY3V0aW9uXG4gICAgaWYgKHN0YXRlICYmIHN0YXRlLnF1ZXJ5Q29tcGxldGUpIHtcbiAgICAgIHRoaXMubG9nKCdxdWVyeTpjb21wbGV0ZScpXG4gICAgICB0aGlzLnJ1bi5zdG9wKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHBhdGggaXMgY29tcGxldGUsIGp1c3Qgc3RvcCB0aGlzIHdvcmtlci5cbiAgICAvLyBOb3RlOiB0aGlzLnN0b3AoKSBraWxscyB0aGUgcXVldWUgYW5kIHJlc29sdmVzIGV4ZWN1dGlvblxuICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5wYXRoQ29tcGxldGUpIHtcbiAgICAgIHRoaXMuc3RvcCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBxdWVyeSBvbiB0aGUgbmV4dCBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJZH0gcGVlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIGV4ZWNRdWVyeSAocGVlcikge1xuICAgIGxldCByZXMsIHF1ZXJ5RXJyb3JcbiAgICB0cnkge1xuICAgICAgcmVzID0gYXdhaXQgdGhpcy5wYXRoLnF1ZXJ5RnVuYyhwZWVyKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcXVlcnlFcnJvciA9IGVyclxuICAgIH1cblxuICAgIC8vIEFib3J0IGFuZCBpZ25vcmUgYW55IGVycm9yIGlmIHdlJ3JlIG5vIGxvbmdlciBydW5uaW5nXG4gICAgaWYgKCF0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChxdWVyeUVycm9yKSB7XG4gICAgICB0aGlzLnJ1bi5lcnJvcnMucHVzaChxdWVyeUVycm9yKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBwZWVyIHRvIHRoZSBjbG9zZXN0IHBlZXJzIHdlIGhhdmUgc3VjY2Vzc2Z1bGx5IHF1ZXJpZWRcbiAgICBhd2FpdCBwcm9taXNpZnkoY2IgPT4gdGhpcy5ydW4ucGVlcnNRdWVyaWVkLmFkZChwZWVyLCBjYikpKClcblxuICAgIC8vIElmIHRoZSBxdWVyeSBpbmRpY2F0ZXMgdGhhdCB0aGlzIHBhdGggb3IgdGhlIHdob2xlIHF1ZXJ5IGlzIGNvbXBsZXRlXG4gICAgLy8gc2V0IHRoZSBwYXRoIHJlc3VsdCBhbmQgYmFpbCBvdXRcbiAgICBpZiAocmVzLnBhdGhDb21wbGV0ZSB8fCByZXMucXVlcnlDb21wbGV0ZSkge1xuICAgICAgdGhpcy5wYXRoLnJlcyA9IHJlc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aENvbXBsZXRlOiByZXMucGF0aENvbXBsZXRlLFxuICAgICAgICBxdWVyeUNvbXBsZXRlOiByZXMucXVlcnlDb21wbGV0ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBjbG9zZXIgcGVlcnMgdG8gcXVlcnksIGFkZCB0aGVtIHRvIHRoZSBxdWV1ZVxuICAgIGlmIChyZXMuY2xvc2VyUGVlcnMgJiYgcmVzLmNsb3NlclBlZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlcy5jbG9zZXJQZWVycy5tYXAoYXN5bmMgKGNsb3NlcikgPT4ge1xuICAgICAgICAvLyBkb24ndCBhZGQgb3Vyc2VsdmVzXG4gICAgICAgIGlmICh0aGlzLmRodC5faXNTZWxmKGNsb3Nlci5pZCkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjbG9zZXIgPSB0aGlzLmRodC5wZWVyQm9vay5wdXQoY2xvc2VyKVxuICAgICAgICB0aGlzLmRodC5fcGVlckRpc2NvdmVyZWQoY2xvc2VyKVxuICAgICAgICBhd2FpdCB0aGlzLnBhdGguYWRkUGVlclRvUXVlcnkoY2xvc2VyLmlkKVxuICAgICAgfSkpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV29ya2VyUXVldWVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBQZWVyUXVldWUgPSByZXF1aXJlKCcuLi9wZWVyLXF1ZXVlJylcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKVxuXG4vLyBUT0RPOiBUZW1wb3JhcnkgdW50aWwgcGFyYWxsZWwgZGlhbCBpbiBTd2l0Y2ggaGF2ZSBhIHByb3BlclxuLy8gdGltZW91dC4gUmVxdWlyZXMgYXN5bmMvYXdhaXQgcmVmYWN0b3Igb2YgdHJhbnNwb3J0cyBhbmRcbi8vIGRpYWwgYWJvcnQgbG9naWMuIFRoaXMgZ2l2ZXMgdXMgMzBzIHRvIGNvbXBsZXRlIHRoZSBgcXVlcnlGdW5jYC5cbi8vIFRoaXMgc2hvdWxkIGhlbHAgcmVkdWNlIHRoZSBoaWdoIGVuZCBjYWxsIHRpbWVzIG9mIHF1ZXJpZXNcbmNvbnN0IFFVRVJZX0ZVTkNfVElNRU9VVCA9IDMwZTNcblxuLyoqXG4gKiBNYW5hZ2VzIGEgc2luZ2xlIFBhdGggdGhyb3VnaCB0aGUgREhULlxuICovXG5jbGFzcyBQYXRoIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQYXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge1J1bn0gcnVuXG4gICAqIEBwYXJhbSB7cXVlcnlGdW5jfSBxdWVyeUZ1bmNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChydW4sIHF1ZXJ5RnVuYykge1xuICAgIHRoaXMucnVuID0gcnVuXG4gICAgdGhpcy5xdWVyeUZ1bmMgPSB1dGlscy53aXRoVGltZW91dChxdWVyeUZ1bmMsIFFVRVJZX0ZVTkNfVElNRU9VVClcbiAgICBpZiAoIXRoaXMucXVlcnlGdW5jKSB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggcmVxdWlyZXMgYSBgcXVlcnlGbmAgdG8gYmUgc3BlY2lmaWVkJylcbiAgICBpZiAodHlwZW9mIHRoaXMucXVlcnlGdW5jICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggZXhwZWN0ZWQgYHF1ZXJ5Rm5gIHRvIGJlIGEgZnVuY3Rpb24uIEdvdCAnICsgdHlwZW9mIHRoaXMucXVlcnlGdW5jKVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFBlZXJJZD59XG4gICAgICovXG4gICAgdGhpcy5pbml0aWFsUGVlcnMgPSBbXVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1BlZXJRdWV1ZX1cbiAgICAgKi9cbiAgICB0aGlzLnBlZXJzVG9RdWVyeSA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwZWVyIHRvIHRoZSBzZXQgb2YgcGVlcnMgdGhhdCBhcmUgdXNlZCB0byBpbnRpYWxpemUgdGhlIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlcklkfSBwZWVyXG4gICAqL1xuICBhZGRJbml0aWFsUGVlciAocGVlcikge1xuICAgIHRoaXMuaW5pdGlhbFBlZXJzLnB1c2gocGVlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBwYXRoLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICpcbiAgICovXG4gIGFzeW5jIGV4ZWN1dGUgKCkge1xuICAgIC8vIENyZWF0ZSBhIHF1ZXVlIG9mIHBlZXJzIG9yZGVyZWQgYnkgZGlzdGFuY2UgZnJvbSB0aGUga2V5XG4gICAgY29uc3QgcXVldWUgPSBhd2FpdCBQZWVyUXVldWUuZnJvbUtleSh0aGlzLnJ1bi5xdWVyeS5rZXkpXG4gICAgLy8gQWRkIGluaXRpYWwgcGVlcnMgdG8gdGhlIHF1ZXVlXG4gICAgdGhpcy5wZWVyc1RvUXVlcnkgPSBxdWV1ZVxuICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaW5pdGlhbFBlZXJzLm1hcChwZWVyID0+IHRoaXMuYWRkUGVlclRvUXVlcnkocGVlcikpKVxuICAgIGF3YWl0IHRoaXMucnVuLndvcmtlclF1ZXVlKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcGVlciB0byB0aGUgcGVlcnMgdG8gYmUgcXVlcmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySWR9IHBlZXJcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBhZGRQZWVyVG9RdWVyeSAocGVlcikge1xuICAgIC8vIERvbid0IGFkZCBzZWxmXG4gICAgaWYgKHRoaXMucnVuLnF1ZXJ5LmRodC5faXNTZWxmKHBlZXIpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUaGUgcGF0aHMgbXVzdCBiZSBkaXNqb2ludCwgbWVhbmluZyB0aGF0IG5vIHR3byBwYXRocyBpbiB0aGUgUXVlcnkgbWF5XG4gICAgLy8gdHJhdmVyc2UgdGhlIHNhbWUgcGVlclxuICAgIGlmICh0aGlzLnJ1bi5wZWVyc1NlZW4uaGFzKHBlZXIpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLnBlZXJzVG9RdWVyeS5lbnF1ZXVlKHBlZXIpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXRoXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgVCA9IHJlcXVpcmUoJy4uLy4uL21lc3NhZ2UnKS5UWVBFU1xuXG5tb2R1bGUuZXhwb3J0cyA9IChkaHQpID0+IHtcbiAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgW1QuR0VUX1ZBTFVFXTogcmVxdWlyZSgnLi9nZXQtdmFsdWUnKShkaHQpLFxuICAgIFtULlBVVF9WQUxVRV06IHJlcXVpcmUoJy4vcHV0LXZhbHVlJykoZGh0KSxcbiAgICBbVC5GSU5EX05PREVdOiByZXF1aXJlKCcuL2ZpbmQtbm9kZScpKGRodCksXG4gICAgW1QuQUREX1BST1ZJREVSXTogcmVxdWlyZSgnLi9hZGQtcHJvdmlkZXInKShkaHQpLFxuICAgIFtULkdFVF9QUk9WSURFUlNdOiByZXF1aXJlKCcuL2dldC1wcm92aWRlcnMnKShkaHQpLFxuICAgIFtULlBJTkddOiByZXF1aXJlKCcuL3BpbmcnKShkaHQpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtZXNzYWdlIGhhbmRsZXIgbWF0Y2hpbmcgdGhlIHBhc3NlZCBpbiB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICAgKlxuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oUGVlckluZm8sIE1lc3NhZ2UsIGZ1bmN0aW9uKEVycm9yLCBNZXNzYWdlKSl9XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0TWVzc2FnZUhhbmRsZXIgKHR5cGUpIHtcbiAgICByZXR1cm4gaGFuZGxlcnNbdHlwZV1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vYSBwYWlyIG9mIHB1bGwgc3RyZWFtcyB3aGVyZSBvbmUgZHJhaW5zIGZyb20gdGhlIG90aGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWFkLCB3YWl0aW5nXG4gIGZ1bmN0aW9uIHNpbmsgKHJlYWQpIHtcbiAgICBpZignZnVuY3Rpb24nICE9PSB0eXBlb2YgcmVhZClcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVhZCBtdXN0IGJlIGZ1bmN0aW9uJylcblxuICAgIGlmKF9yZWFkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHJlYWR5IHBpcGVkJylcbiAgICBfcmVhZCA9IHJlYWRcbiAgICBpZih3YWl0aW5nKSB7XG4gICAgICB2YXIgX3dhaXRpbmcgPSB3YWl0aW5nXG4gICAgICB3YWl0aW5nID0gbnVsbFxuICAgICAgX3JlYWQuYXBwbHkobnVsbCwgX3dhaXRpbmcpXG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNvdXJjZSAoYWJvcnQsIGNiKSB7XG4gICAgaWYoX3JlYWQpXG4gICAgICBfcmVhZChhYm9ydCwgY2IpXG4gICAgZWxzZVxuICAgICAgd2FpdGluZyA9IFthYm9ydCwgY2JdXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNvdXJjZTogc291cmNlLCBzaW5rOiBzaW5rXG4gIH1cbn1cblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG1oID0gcmVxdWlyZSgnbXVsdGloYXNoaW5nLWFzeW5jJylcbmNvbnN0IGxwID0gcmVxdWlyZSgncHVsbC1sZW5ndGgtcHJlZml4ZWQnKVxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3B1bGwnKVxuY29uc3QgdmFsdWVzID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vc291cmNlcy92YWx1ZXMnKVxuY29uc3QgY29sbGVjdCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3NpbmtzL2NvbGxlY3QnKVxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnbGlicDJwLWNyeXB0bycpXG5jb25zdCBwYXJhbGxlbCA9IHJlcXVpcmUoJ2FzeW5jL3BhcmFsbGVsJylcblxuZXhwb3J0cy5leGNoYW5nZXMgPSBbXG4gICdQLTI1NicsXG4gICdQLTM4NCcsXG4gICdQLTUyMSdcbl1cblxuZXhwb3J0cy5jaXBoZXJzID0gW1xuICAnQUVTLTI1NicsXG4gICdBRVMtMTI4J1xuXVxuXG5leHBvcnRzLmhhc2hlcyA9IFtcbiAgJ1NIQTI1NicsXG4gICdTSEE1MTInXG5dXG5cbi8vIERldGVybWluZXMgd2hpY2ggYWxnb3JpdGhtIHRvIHVzZS4gIE5vdGU6ICBmKGEsIGIpID0gZihiLCBhKVxuZXhwb3J0cy50aGVCZXN0ID0gKG9yZGVyLCBwMSwgcDIpID0+IHtcbiAgbGV0IGZpcnN0XG4gIGxldCBzZWNvbmRcblxuICBpZiAob3JkZXIgPCAwKSB7XG4gICAgZmlyc3QgPSBwMlxuICAgIHNlY29uZCA9IHAxXG4gIH0gZWxzZSBpZiAob3JkZXIgPiAwKSB7XG4gICAgZmlyc3QgPSBwMVxuICAgIHNlY29uZCA9IHAyXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHAxWzBdXG4gIH1cblxuICBmb3IgKGxldCBmaXJzdENhbmRpZGF0ZSBvZiBmaXJzdCkge1xuICAgIGZvciAobGV0IHNlY29uZENhbmRpZGF0ZSBvZiBzZWNvbmQpIHtcbiAgICAgIGlmIChmaXJzdENhbmRpZGF0ZSA9PT0gc2Vjb25kQ2FuZGlkYXRlKSB7XG4gICAgICAgIHJldHVybiBmaXJzdENhbmRpZGF0ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignTm8gYWxnb3JpdGhtcyBpbiBjb21tb24hJylcbn1cblxuZXhwb3J0cy5tYWtlTWFjQW5kQ2lwaGVyID0gKHRhcmdldCwgY2FsbGJhY2spID0+IHtcbiAgcGFyYWxsZWwoW1xuICAgIChjYikgPT4gbWFrZU1hYyh0YXJnZXQuaGFzaFQsIHRhcmdldC5rZXlzLm1hY0tleSwgY2IpLFxuICAgIChjYikgPT4gbWFrZUNpcGhlcih0YXJnZXQuY2lwaGVyVCwgdGFyZ2V0LmtleXMuaXYsIHRhcmdldC5rZXlzLmNpcGhlcktleSwgY2IpXG4gIF0sIChlcnIsIG1hY0FuZENpcGhlcikgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgdGFyZ2V0Lm1hYyA9IG1hY0FuZENpcGhlclswXVxuICAgIHRhcmdldC5jaXBoZXIgPSBtYWNBbmRDaXBoZXJbMV1cbiAgICBjYWxsYmFjaygpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1ha2VNYWMgKGhhc2gsIGtleSwgY2FsbGJhY2spIHtcbiAgY3J5cHRvLmhtYWMuY3JlYXRlKGhhc2gsIGtleSwgY2FsbGJhY2spXG59XG5cbmZ1bmN0aW9uIG1ha2VDaXBoZXIgKGNpcGhlclR5cGUsIGl2LCBrZXksIGNhbGxiYWNrKSB7XG4gIGlmIChjaXBoZXJUeXBlID09PSAnQUVTLTEyOCcgfHwgY2lwaGVyVHlwZSA9PT0gJ0FFUy0yNTYnKSB7XG4gICAgcmV0dXJuIGNyeXB0by5hZXMuY3JlYXRlKGtleSwgaXYsIGNhbGxiYWNrKVxuICB9XG5cbiAgLy8gVE9ETzogZmlndXJlIG91dCBpZiBCbG93ZmlzaCBpcyBuZWVkZWQgYW5kIGlmIHNvIGZpbmQgYSBsaWJyYXJ5IGZvciBpdC5cbiAgY2FsbGJhY2sobmV3IEVycm9yKGB1bnJlY29nbml6ZWQgY2lwaGVyIHR5cGU6ICR7Y2lwaGVyVHlwZX1gKSlcbn1cblxuZXhwb3J0cy5zZWxlY3RCZXN0ID0gKGxvY2FsLCByZW1vdGUsIGNiKSA9PiB7XG4gIGV4cG9ydHMuZGlnZXN0KEJ1ZmZlci5jb25jYXQoW1xuICAgIHJlbW90ZS5wdWJLZXlCeXRlcyxcbiAgICBsb2NhbC5ub25jZVxuICBdKSwgKGVyciwgb2gxKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycilcbiAgICB9XG5cbiAgICBleHBvcnRzLmRpZ2VzdChCdWZmZXIuY29uY2F0KFtcbiAgICAgIGxvY2FsLnB1YktleUJ5dGVzLFxuICAgICAgcmVtb3RlLm5vbmNlXG4gICAgXSksIChlcnIsIG9oMikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvcmRlciA9IEJ1ZmZlci5jb21wYXJlKG9oMSwgb2gyKVxuXG4gICAgICBpZiAob3JkZXIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcigneW91IGFyZSB0cnlpbmcgdG8gdGFsayB0byB5b3Vyc2VsZicpKVxuICAgICAgfVxuXG4gICAgICBjYihudWxsLCB7XG4gICAgICAgIGN1cnZlVDogZXhwb3J0cy50aGVCZXN0KG9yZGVyLCBsb2NhbC5leGNoYW5nZXMsIHJlbW90ZS5leGNoYW5nZXMpLFxuICAgICAgICBjaXBoZXJUOiBleHBvcnRzLnRoZUJlc3Qob3JkZXIsIGxvY2FsLmNpcGhlcnMsIHJlbW90ZS5jaXBoZXJzKSxcbiAgICAgICAgaGFzaFQ6IGV4cG9ydHMudGhlQmVzdChvcmRlciwgbG9jYWwuaGFzaGVzLCByZW1vdGUuaGFzaGVzKSxcbiAgICAgICAgb3JkZXJcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZXhwb3J0cy5kaWdlc3QgPSAoYnVmLCBjYikgPT4ge1xuICBtaC5kaWdlc3QoYnVmLCAnc2hhMi0yNTYnLCBidWYubGVuZ3RoLCBjYilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdGF0ZSwgbXNnLCBjYikge1xuICBjYiA9IGNiIHx8ICgoKSA9PiB7fSlcbiAgcHVsbChcbiAgICB2YWx1ZXMoW21zZ10pLFxuICAgIGxwLmVuY29kZSh7IGZpeGVkOiB0cnVlLCBieXRlczogNCB9KSxcbiAgICBjb2xsZWN0KChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuICAgICAgc3RhdGUuc2hha2Uud3JpdGUocmVzWzBdKVxuICAgICAgY2IoKVxuICAgIH0pXG4gIClcbn1cblxuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gcmVhZCAocmVhZGVyLCBjYikge1xuICBscC5kZWNvZGVGcm9tUmVhZGVyKHJlYWRlciwgeyBmaXhlZDogdHJ1ZSwgYnl0ZXM6IDQgfSwgY2IpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHJvdG9ucyA9IHJlcXVpcmUoJ3Byb3RvbnMnKVxuY29uc3QgUGVlcklkID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdsaWJwMnAtY3J5cHRvJylcbmNvbnN0IHBhcmFsbGVsID0gcmVxdWlyZSgnYXN5bmMvcGFyYWxsZWwnKVxuY29uc3Qgd2F0ZXJmYWxsID0gcmVxdWlyZSgnYXN5bmMvd2F0ZXJmYWxsJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycDpzZWNpbycpXG5sb2cuZXJyb3IgPSBkZWJ1ZygnbGlicDJwOnNlY2lvOmVycm9yJylcblxuY29uc3QgcGJtID0gcHJvdG9ucyhyZXF1aXJlKCcuL3NlY2lvLnByb3RvJykpXG5cbmNvbnN0IHN1cHBvcnQgPSByZXF1aXJlKCcuLi9zdXBwb3J0JylcblxuLy8gbm9uY2VTaXplIGlzIHRoZSBzaXplIG9mIG91ciBub25jZXMgKGluIGJ5dGVzKVxuY29uc3Qgbm9uY2VTaXplID0gMTZcblxuZXhwb3J0cy5jcmVhdGVQcm9wb3NhbCA9IChzdGF0ZSkgPT4ge1xuICBzdGF0ZS5wcm9wb3NhbC5vdXQgPSB7XG4gICAgcmFuZDogY3J5cHRvLnJhbmRvbUJ5dGVzKG5vbmNlU2l6ZSksXG4gICAgcHVia2V5OiBzdGF0ZS5rZXkubG9jYWwucHVibGljLmJ5dGVzLFxuICAgIGV4Y2hhbmdlczogc3VwcG9ydC5leGNoYW5nZXMuam9pbignLCcpLFxuICAgIGNpcGhlcnM6IHN1cHBvcnQuY2lwaGVycy5qb2luKCcsJyksXG4gICAgaGFzaGVzOiBzdXBwb3J0Lmhhc2hlcy5qb2luKCcsJylcbiAgfVxuXG4gIHN0YXRlLnByb3Bvc2FsRW5jb2RlZC5vdXQgPSBwYm0uUHJvcG9zZS5lbmNvZGUoc3RhdGUucHJvcG9zYWwub3V0KVxuICByZXR1cm4gc3RhdGUucHJvcG9zYWxFbmNvZGVkLm91dFxufVxuXG5leHBvcnRzLmNyZWF0ZUV4Y2hhbmdlID0gKHN0YXRlLCBjYWxsYmFjaykgPT4ge1xuICBjcnlwdG8ua2V5cy5nZW5lcmF0ZUVwaGVtZXJhbEtleVBhaXIoc3RhdGUucHJvdG9jb2xzLmxvY2FsLmN1cnZlVCwgKGVyciwgcmVzKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG5cbiAgICBzdGF0ZS5lcGhlbWVyYWxLZXkubG9jYWwgPSByZXMua2V5XG4gICAgc3RhdGUuc2hhcmVkLmdlbmVyYXRlID0gcmVzLmdlblNoYXJlZEtleVxuXG4gICAgLy8gR2F0aGVyIGNvcnB1cyB0byBzaWduLlxuICAgIGNvbnN0IHNlbGVjdGlvbk91dCA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgc3RhdGUucHJvcG9zYWxFbmNvZGVkLm91dCxcbiAgICAgIHN0YXRlLnByb3Bvc2FsRW5jb2RlZC5pbixcbiAgICAgIHN0YXRlLmVwaGVtZXJhbEtleS5sb2NhbFxuICAgIF0pXG5cbiAgICBzdGF0ZS5rZXkubG9jYWwuc2lnbihzZWxlY3Rpb25PdXQsIChlcnIsIHNpZykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS5leGNoYW5nZS5vdXQgPSB7XG4gICAgICAgIGVwdWJrZXk6IHN0YXRlLmVwaGVtZXJhbEtleS5sb2NhbCxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWdcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgcGJtLkV4Y2hhbmdlLmVuY29kZShzdGF0ZS5leGNoYW5nZS5vdXQpKVxuICAgIH0pXG4gIH0pXG59XG5cbmV4cG9ydHMuaWRlbnRpZnkgPSAoc3RhdGUsIG1zZywgY2FsbGJhY2spID0+IHtcbiAgbG9nKCcxLjEgaWRlbnRpZnknKVxuXG4gIHN0YXRlLnByb3Bvc2FsRW5jb2RlZC5pbiA9IG1zZ1xuICBzdGF0ZS5wcm9wb3NhbC5pbiA9IHBibS5Qcm9wb3NlLmRlY29kZShtc2cpXG4gIGNvbnN0IHB1YmtleSA9IHN0YXRlLnByb3Bvc2FsLmluLnB1YmtleVxuXG4gIHN0YXRlLmtleS5yZW1vdGUgPSBjcnlwdG8ua2V5cy51bm1hcnNoYWxQdWJsaWNLZXkocHVia2V5KVxuXG4gIFBlZXJJZC5jcmVhdGVGcm9tUHViS2V5KHB1YmtleS50b1N0cmluZygnYmFzZTY0JyksIChlcnIsIHJlbW90ZUlkKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBrbm93IHdobyB3ZSBhcmUgZGlhbGluZyB0bywgZG91YmxlIGNoZWNrXG4gICAgaWYgKHN0YXRlLmlkLnJlbW90ZSkge1xuICAgICAgaWYgKHN0YXRlLmlkLnJlbW90ZS50b0I1OFN0cmluZygpICE9PSByZW1vdGVJZC50b0I1OFN0cmluZygpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ2RpYWxlZCB0byB0aGUgd3JvbmcgcGVlciwgSWRzIGRvIG5vdCBtYXRjaCcpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5pZC5yZW1vdGUgPSByZW1vdGVJZFxuICAgIH1cblxuICAgIGxvZygnMS4xIGlkZW50aWZ5IC0gJXMgLSBpZGVudGlmaWVkIHJlbW90ZSBwZWVyIGFzICVzJywgc3RhdGUuaWQubG9jYWwudG9CNThTdHJpbmcoKSwgc3RhdGUuaWQucmVtb3RlLnRvQjU4U3RyaW5nKCkpXG4gICAgY2FsbGJhY2soKVxuICB9KVxufVxuXG5leHBvcnRzLnNlbGVjdFByb3RvY29scyA9IChzdGF0ZSwgY2FsbGJhY2spID0+IHtcbiAgbG9nKCcxLjIgc2VsZWN0aW9uJylcblxuICBjb25zdCBsb2NhbCA9IHtcbiAgICBwdWJLZXlCeXRlczogc3RhdGUua2V5LmxvY2FsLnB1YmxpYy5ieXRlcyxcbiAgICBleGNoYW5nZXM6IHN1cHBvcnQuZXhjaGFuZ2VzLFxuICAgIGhhc2hlczogc3VwcG9ydC5oYXNoZXMsXG4gICAgY2lwaGVyczogc3VwcG9ydC5jaXBoZXJzLFxuICAgIG5vbmNlOiBzdGF0ZS5wcm9wb3NhbC5vdXQucmFuZFxuICB9XG5cbiAgY29uc3QgcmVtb3RlID0ge1xuICAgIHB1YktleUJ5dGVzOiBzdGF0ZS5wcm9wb3NhbC5pbi5wdWJrZXksXG4gICAgZXhjaGFuZ2VzOiBzdGF0ZS5wcm9wb3NhbC5pbi5leGNoYW5nZXMuc3BsaXQoJywnKSxcbiAgICBoYXNoZXM6IHN0YXRlLnByb3Bvc2FsLmluLmhhc2hlcy5zcGxpdCgnLCcpLFxuICAgIGNpcGhlcnM6IHN0YXRlLnByb3Bvc2FsLmluLmNpcGhlcnMuc3BsaXQoJywnKSxcbiAgICBub25jZTogc3RhdGUucHJvcG9zYWwuaW4ucmFuZFxuICB9XG5cbiAgc3VwcG9ydC5zZWxlY3RCZXN0KGxvY2FsLCByZW1vdGUsIChlcnIsIHNlbGVjdGVkKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG4gICAgLy8gd2UgdXNlIHRoZSBzYW1lIHBhcmFtcyBmb3IgYm90aCBkaXJlY3Rpb25zIChtdXN0IGNob29zZSBzYW1lIGN1cnZlKVxuICAgIC8vIFdBUk5JTkc6IGlmIHRoZXkgZG9udCBTZWxlY3RCZXN0IHRoZSBzYW1lIHdheSwgdGhpcyB3b24ndCB3b3JrLi4uXG4gICAgc3RhdGUucHJvdG9jb2xzLnJlbW90ZSA9IHtcbiAgICAgIG9yZGVyOiBzZWxlY3RlZC5vcmRlcixcbiAgICAgIGN1cnZlVDogc2VsZWN0ZWQuY3VydmVULFxuICAgICAgY2lwaGVyVDogc2VsZWN0ZWQuY2lwaGVyVCxcbiAgICAgIGhhc2hUOiBzZWxlY3RlZC5oYXNoVFxuICAgIH1cblxuICAgIHN0YXRlLnByb3RvY29scy5sb2NhbCA9IHtcbiAgICAgIG9yZGVyOiBzZWxlY3RlZC5vcmRlcixcbiAgICAgIGN1cnZlVDogc2VsZWN0ZWQuY3VydmVULFxuICAgICAgY2lwaGVyVDogc2VsZWN0ZWQuY2lwaGVyVCxcbiAgICAgIGhhc2hUOiBzZWxlY3RlZC5oYXNoVFxuICAgIH1cbiAgICBjYWxsYmFjaygpXG4gIH0pXG59XG5cbmV4cG9ydHMudmVyaWZ5ID0gKHN0YXRlLCBtc2csIGNhbGxiYWNrKSA9PiB7XG4gIGxvZygnMi4xLiB2ZXJpZnknKVxuXG4gIHN0YXRlLmV4Y2hhbmdlLmluID0gcGJtLkV4Y2hhbmdlLmRlY29kZShtc2cpXG4gIHN0YXRlLmVwaGVtZXJhbEtleS5yZW1vdGUgPSBzdGF0ZS5leGNoYW5nZS5pbi5lcHVia2V5XG5cbiAgY29uc3Qgc2VsZWN0aW9uSW4gPSBCdWZmZXIuY29uY2F0KFtcbiAgICBzdGF0ZS5wcm9wb3NhbEVuY29kZWQuaW4sXG4gICAgc3RhdGUucHJvcG9zYWxFbmNvZGVkLm91dCxcbiAgICBzdGF0ZS5lcGhlbWVyYWxLZXkucmVtb3RlXG4gIF0pXG5cbiAgc3RhdGUua2V5LnJlbW90ZS52ZXJpZnkoc2VsZWN0aW9uSW4sIHN0YXRlLmV4Y2hhbmdlLmluLnNpZ25hdHVyZSwgKGVyciwgc2lnT2spID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cblxuICAgIGlmICghc2lnT2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0JhZCBzaWduYXR1cmUnKSlcbiAgICB9XG5cbiAgICBsb2coJzIuMS4gdmVyaWZ5IC0gc2lnbmF0dXJlIHZlcmlmaWVkJylcbiAgICBjYWxsYmFjaygpXG4gIH0pXG59XG5cbmV4cG9ydHMuZ2VuZXJhdGVLZXlzID0gKHN0YXRlLCBjYWxsYmFjaykgPT4ge1xuICBsb2coJzIuMi4ga2V5cycpXG5cbiAgd2F0ZXJmYWxsKFtcbiAgICAoY2IpID0+IHN0YXRlLnNoYXJlZC5nZW5lcmF0ZShzdGF0ZS5leGNoYW5nZS5pbi5lcHVia2V5LCBjYiksXG4gICAgKHNlY3JldCwgY2IpID0+IHtcbiAgICAgIHN0YXRlLnNoYXJlZC5zZWNyZXQgPSBzZWNyZXRcblxuICAgICAgY3J5cHRvLmtleXMua2V5U3RyZXRjaGVyKFxuICAgICAgICBzdGF0ZS5wcm90b2NvbHMubG9jYWwuY2lwaGVyVCxcbiAgICAgICAgc3RhdGUucHJvdG9jb2xzLmxvY2FsLmhhc2hULFxuICAgICAgICBzdGF0ZS5zaGFyZWQuc2VjcmV0LFxuICAgICAgICBjYlxuICAgICAgKVxuICAgIH0sXG4gICAgKGtleXMsIGNiKSA9PiB7XG4gICAgICAvLyB1c2UgcmFuZG9tIG5vbmNlcyB0byBkZWNpZGUgb3JkZXIuXG4gICAgICBpZiAoc3RhdGUucHJvdG9jb2xzLmxvY2FsLm9yZGVyID4gMCkge1xuICAgICAgICBzdGF0ZS5wcm90b2NvbHMubG9jYWwua2V5cyA9IGtleXMuazFcbiAgICAgICAgc3RhdGUucHJvdG9jb2xzLnJlbW90ZS5rZXlzID0ga2V5cy5rMlxuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5wcm90b2NvbHMubG9jYWwub3JkZXIgPCAwKSB7XG4gICAgICAgIC8vIHN3YXBcbiAgICAgICAgc3RhdGUucHJvdG9jb2xzLmxvY2FsLmtleXMgPSBrZXlzLmsyXG4gICAgICAgIHN0YXRlLnByb3RvY29scy5yZW1vdGUua2V5cyA9IGtleXMuazFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIHNob3VsZCd2ZSBiYWlsZWQgYmVmb3JlIHN0YXRlLiBidXQgaWYgbm90LCBiYWlsIGhlcmUuXG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ3lvdSBhcmUgdHJ5aW5nIHRvIHRhbGsgdG8geW91cnNlbGYnKSlcbiAgICAgIH1cblxuICAgICAgbG9nKCcyLjMuIG1hYyArIGNpcGhlcicpXG5cbiAgICAgIHBhcmFsbGVsKFtcbiAgICAgICAgKF9jYikgPT4gc3VwcG9ydC5tYWtlTWFjQW5kQ2lwaGVyKHN0YXRlLnByb3RvY29scy5sb2NhbCwgX2NiKSxcbiAgICAgICAgKF9jYikgPT4gc3VwcG9ydC5tYWtlTWFjQW5kQ2lwaGVyKHN0YXRlLnByb3RvY29scy5yZW1vdGUsIF9jYilcbiAgICAgIF0sIGNiKVxuICAgIH1cbiAgXSwgY2FsbGJhY2spXG59XG5cbmV4cG9ydHMudmVyaWZ5Tm9uY2UgPSAoc3RhdGUsIG4yKSA9PiB7XG4gIGNvbnN0IG4xID0gc3RhdGUucHJvcG9zYWwub3V0LnJhbmRcblxuICBpZiAobjEuZXF1YWxzKG4yKSkgcmV0dXJuXG5cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBGYWlsZWQgdG8gcmVhZCBvdXIgZW5jcnlwdGVkIG5vbmNlOiAke24xLnRvU3RyaW5nKCdoZXgnKX0gIT0gJHtuMi50b1N0cmluZygnaGV4Jyl9YFxuICApXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3B1bGwnKVxuY29uc3QgbWFwID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vdGhyb3VnaHMvbWFwJylcbmNvbnN0IGFzeW5jTWFwID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vdGhyb3VnaHMvYXN5bmMtbWFwJylcbmNvbnN0IGxwID0gcmVxdWlyZSgncHVsbC1sZW5ndGgtcHJlZml4ZWQnKVxuXG5jb25zdCBscE9wdHMgPSB7XG4gIGZpeGVkOiB0cnVlLFxuICBieXRlczogNFxufVxuXG5leHBvcnRzLmNyZWF0ZUJveFN0cmVhbSA9IChjaXBoZXIsIG1hYykgPT4ge1xuICByZXR1cm4gcHVsbChcbiAgICBlbnN1cmVCdWZmZXIoKSxcbiAgICBhc3luY01hcCgoY2h1bmssIGNiKSA9PiB7XG4gICAgICBjaXBoZXIuZW5jcnlwdChjaHVuaywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgfVxuXG4gICAgICAgIG1hYy5kaWdlc3QoZGF0YSwgKGVyciwgZGlnZXN0KSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYihudWxsLCBCdWZmZXIuY29uY2F0KFtkYXRhLCBkaWdlc3RdKSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSksXG4gICAgbHAuZW5jb2RlKGxwT3B0cylcbiAgKVxufVxuXG5leHBvcnRzLmNyZWF0ZVVuYm94U3RyZWFtID0gKGRlY2lwaGVyLCBtYWMpID0+IHtcbiAgcmV0dXJuIHB1bGwoXG4gICAgZW5zdXJlQnVmZmVyKCksXG4gICAgbHAuZGVjb2RlKGxwT3B0cyksXG4gICAgYXN5bmNNYXAoKGNodW5rLCBjYikgPT4ge1xuICAgICAgY29uc3QgbCA9IGNodW5rLmxlbmd0aFxuICAgICAgY29uc3QgbWFjU2l6ZSA9IG1hYy5sZW5ndGhcblxuICAgICAgaWYgKGwgPCBtYWNTaXplKSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoYGJ1ZmZlciAoJHtsfSkgc2hvcnRlciB0aGFuIE1BQyBzaXplICgke21hY1NpemV9KWApKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXJrID0gbCAtIG1hY1NpemVcbiAgICAgIGNvbnN0IGRhdGEgPSBjaHVuay5zbGljZSgwLCBtYXJrKVxuICAgICAgY29uc3QgbWFjZCA9IGNodW5rLnNsaWNlKG1hcmspXG5cbiAgICAgIG1hYy5kaWdlc3QoZGF0YSwgKGVyciwgZXhwZWN0ZWQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1hY2QuZXF1YWxzKGV4cGVjdGVkKSkge1xuICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoYE1BQyBJbnZhbGlkOiAke21hY2QudG9TdHJpbmcoJ2hleCcpfSAhPSAke2V4cGVjdGVkLnRvU3RyaW5nKCdoZXgnKX1gKSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFsbCBnb29kLCBkZWNyeXB0XG4gICAgICAgIGRlY2lwaGVyLmRlY3J5cHQoZGF0YSwgKGVyciwgZGVjcnlwdGVkKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYihudWxsLCBkZWNyeXB0ZWQpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIClcbn1cblxuZnVuY3Rpb24gZW5zdXJlQnVmZmVyICgpIHtcbiAgcmV0dXJuIG1hcCgoYykgPT4ge1xuICAgIGlmICh0eXBlb2YgYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShjLCAndXRmLTgnKVxuICAgIH1cblxuICAgIHJldHVybiBjXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5FUlJfV1NfU1RBUl9XRUJTT0NLRVRfQ09OTkVDVElPTiA9ICdFUlJfV1NfU1RBUl9XRUJTT0NLRVRfQ09OTkVDVElPTidcbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBzb2NrZXQuaW8tcHVsbC1zdHJlYW1cbmNvbnN0IFF1ZXVlID0gcmVxdWlyZSgnZGF0YS1xdWV1ZScpXG5jb25zdCB1dWlkID0gcmVxdWlyZSgndXVpZCcpXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0nKVxuY29uc3Qgc2lvbmFtZSA9ICh0eXBlLCBuYW1lKSA9PiAnc29ja2V0LmlvLXB1bGwtc3RyZWFtLicgKyB0eXBlICsgKG5hbWUgPyAnLicgKyBuYW1lIDogJycpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IF9sb2cgPSBkZWJ1Zygnc29ja2V0LmlvLXB1bGwtc3RyZWFtJylcblxuZnVuY3Rpb24gZG9Db2RlYyAoY29kZWMsIGRhdGEpIHtcbiAgaWYgKGRhdGEgPT0gbnVsbCkgcmV0dXJuIGRhdGFcbiAgdHJ5IHtcbiAgICByZXR1cm4gY29kZWMoZGF0YSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0NvZGVjIEVycm9yJylcbiAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuY29uc3QgY29kZWNzID0ge1xuICBoZXg6IHtcbiAgICBlbmNvZGU6IHYgPT4gdi50b1N0cmluZygnaGV4JyksXG4gICAgZGVjb2RlOiB2ID0+IEJ1ZmZlci5mcm9tKHYsICdoZXgnKVxuICB9LFxuICBwbGFpbjoge1xuICAgIGVuY29kZTogdiA9PiB2LFxuICAgIGRlY29kZTogdiA9PiB2XG4gIH0sXG4gIGJ1ZmZlcjogeyAvLyBhbHdheXMgZG8gQnVmZmVyLmZyb20gYmVjYXVzZSBicm93c2Vyc1xuICAgIGVuY29kZTogdiA9PiBCdWZmZXIuZnJvbSh2KSxcbiAgICBkZWNvZGU6IHYgPT4gQnVmZmVyLmZyb20odilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb2RlYyAoYykge1xuICBpZiAoIWMpIGMgPSAncGxhaW4nXG4gIGlmICh0eXBlb2YgYyA9PT0gJ29iamVjdCcpIHJldHVybiBjXG4gIGNvbnN0IGNvID0gY29kZWNzW2NdXG4gIGlmICghY28pIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlYyAnICsgYylcbiAgcmV0dXJuIGNvXG59XG5cbmZ1bmN0aW9uIFNJT1NvdXJjZSAoc2lvLCBpZCwgb3B0KSB7XG4gIGNvbnN0IHEgPSBRdWV1ZSgpXG4gIGNvbnN0IGxvZyA9IHNpby5zaW9wbG9nLmJpbmQoc2lvLnNpb3Bsb2csICdzb3VyY2UoJyArIGlkICsgJyknKVxuICBjb25zdCBjb2RlYyA9IGdldENvZGVjKG9wdC5jb2RlYykuZGVjb2RlXG4gIGxvZygnY3JlYXRlIHNvdXJjZScpXG4gIHNpby5lbWl0KHNpb25hbWUoJ2FjY2VwdCcsIGlkKSlcblxuICBmdW5jdGlvbiB1bmxpc3RlbiAoKSB7XG4gICAgc2lvLnJlbW92ZUFsbExpc3RlbmVycyhzaW9uYW1lKCdlcnJvcicsIGlkKSlcbiAgICBzaW8ucmVtb3ZlQWxsTGlzdGVuZXJzKHNpb25hbWUoJ3F1ZXVlJywgaWQpKVxuICB9XG5cbiAgc2lvLm9uKHNpb25hbWUoJ2Vycm9yJywgaWQpLCBlcnIgPT4ge1xuICAgIGlmIChlcnIgPT09IHRydWUpIGxvZygnZmluaXNoJylcbiAgICBlbHNlIGxvZygnZXJyb3InKVxuICAgIHVubGlzdGVuKClcbiAgICBxLmFwcGVuZCh7ZW5kOiBlcnJ9KVxuICB9KVxuICBzaW8ub24oc2lvbmFtZSgncXVldWUnLCBpZCksIGRhdGEgPT4ge1xuICAgIGxvZygncXVldWUgZGF0YScpXG4gICAgcS5hcHBlbmQoe2RhdGE6IGRvQ29kZWMoY29kZWMsIGRhdGEpfSlcbiAgfSlcbiAgc2lvLm9uY2UoJ2Rpc2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgdW5saXN0ZW4oKVxuICAgIHEuYXBwZW5kKHtlbmQ6IHRydWV9KVxuICB9KVxuICByZXR1cm4gZnVuY3Rpb24gKGVuZCwgY2IpIHtcbiAgICBsb2coJ3JlYWRpbmcnKVxuICAgIGlmIChlbmQpIHJldHVybiBjYihlbmQpXG4gICAgcS5nZXQoKGVyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGlmIChkYXRhLmVuZCkge1xuICAgICAgICBxLmVycm9yKGRhdGEuZW5kKVxuICAgICAgICByZXR1cm4gY2IoZGF0YS5lbmQpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2IobnVsbCwgZGF0YS5kYXRhKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gU0lPU2luayAoc2lvLCBpZCwgb3B0KSB7XG4gIGNvbnN0IHEgPSBRdWV1ZSgpXG4gIGNvbnN0IGxvZyA9IHNpby5zaW9wbG9nLmJpbmQoc2lvLnNpb3Bsb2csICcgIHNpbmsoJyArIGlkICsgJyknKVxuICBjb25zdCBjb2RlYyA9IGdldENvZGVjKG9wdC5jb2RlYykuZW5jb2RlXG4gIGxldCBlbmRlZFxuICBsb2coJ2NyZWF0ZSBzaW5rJylcbiAgc2lvLm9uY2Uoc2lvbmFtZSgnYWNjZXB0JywgaWQpLCAoKSA9PiB7XG4gICAgbG9nKCdzdGFydCB0cmFuc21pc3Npb24nKVxuXG4gICAgZnVuY3Rpb24gbG9vcCAoKSB7XG4gICAgICBxLmdldCgoXywgdmFsKSA9PiB7XG4gICAgICAgIGxldCB7ZGF0YSwgZXJyfSA9IHZhbCB8fCB7fVxuICAgICAgICBpZiAoXykgZXJyID0gX1xuICAgICAgICBsb2coJ3NlbmQnLCBlcnIgJiYgZXJyID09PSB0cnVlID8gJ2ZpbmlzaCcgOiBlcnIgPyAnZXJyb3InIDogZGF0YSA/ICdkYXRhJyA6ICc8aW52YWxpZD4nKVxuICAgICAgICBpZiAoZXJyICYmICFfKSBxLmVycm9yKGVycilcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHNpby5lbWl0KHNpb25hbWUoJ2Vycm9yJywgaWQpLCBlcnIpXG4gICAgICAgIGlmIChkYXRhKSBzaW8uZW1pdChzaW9uYW1lKCdxdWV1ZScsIGlkKSwgZG9Db2RlYyhjb2RlYywgZGF0YSkpXG4gICAgICAgIGxvb3AoKVxuICAgICAgfSlcbiAgICB9XG4gICAgbG9vcCgpXG4gIH0pXG5cbiAgZnVuY3Rpb24gZG9FcnIgKGVuZCkge1xuICAgIHEuYXBwZW5kKHtlcnI6IGVuZH0pXG4gICAgZW5kZWQgPSBlbmRcbiAgfVxuXG4gIHNpby5vbmNlKCdkaXNjb25uZWN0JywgKCkgPT4gZG9FcnIodHJ1ZSkpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZWFkKSB7XG4gICAgcmVhZChudWxsLCBmdW5jdGlvbiBuZXh0IChlbmQsIGRhdGEpIHtcbiAgICAgIGlmIChlbmQpIHJldHVybiBkb0VycihlbmQpXG4gICAgICBpZiAoZW5kZWQpIHJldHVybiByZWFkKGVuZGVkLCBuZXh0KVxuICAgICAgcS5hcHBlbmQoe2RhdGF9KVxuICAgICAgcmVhZChudWxsLCBuZXh0KVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTSU9QdWxsU3RyZWFtIChzaW8sIG9wdCkge1xuICBpZiAoc2lvLmNyZWF0ZVNpbmspIHJldHVyblxuICBzaW8uc2lvcGxvZyA9IHNpby5pZCA/IF9sb2cuYmluZChfbG9nLCAnWycgKyBzaW8uaWQgKyAnXScpIDogX2xvZ1xuICBzaW8uY3JlYXRlU2luayA9IChpZCwgXykgPT4ge1xuICAgIGlmICghaWQpIGlkID0gdXVpZCgpXG4gICAgY29uc3Qgc2luayA9IFNJT1Npbmsoc2lvLCBpZCwgb3B0IHx8IF8pXG4gICAgc2luay5pZCA9IGlkXG4gICAgcmV0dXJuIHNpbmtcbiAgfVxuICBzaW8uY3JlYXRlU291cmNlID0gKGlkLCBfKSA9PiB7XG4gICAgY29uc3Qgc291cmNlID0gU0lPU291cmNlKHNpbywgaWQsIG9wdCB8fCBfKVxuICAgIHNvdXJjZS5pZCA9IGlkXG4gICAgcmV0dXJuIHNvdXJjZVxuICB9XG4gIHNpby5jcmVhdGVQcm94eSA9IChpZCwgdHNpbywgXykgPT4ge1xuICAgIHB1bGwoXG4gICAgICBzaW8uY3JlYXRlU291cmNlKGlkLCBfKSxcbiAgICAgIHRzaW8uY3JlYXRlU2luayhpZCwgXylcbiAgICApXG4gIH1cbn1cbiIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvZW5kLW9mLXN0cmVhbSB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0U7XG5cbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBlb3Moc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgdmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCBvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGU7XG4gIHZhciB3cml0YWJsZSA9IG9wdHMud3JpdGFibGUgfHwgb3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlO1xuXG4gIHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uIG9ubGVnYWN5ZmluaXNoKCkge1xuICAgIGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xuICB9O1xuXG4gIHZhciB3cml0YWJsZUVuZGVkID0gc3RyZWFtLl93cml0YWJsZVN0YXRlICYmIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZDtcblxuICB2YXIgb25maW5pc2ggPSBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICB3cml0YWJsZSA9IGZhbHNlO1xuICAgIHdyaXRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcblxuICB2YXIgcmVhZGFibGVFbmRlZCA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZDtcblxuICB2YXIgb25lbmQgPSBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgIHJlYWRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghd3JpdGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcblxuICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gIH07XG5cbiAgdmFyIG9uY2xvc2UgPSBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIHZhciBlcnI7XG5cbiAgICBpZiAocmVhZGFibGUgJiYgIXJlYWRhYmxlRW5kZWQpIHtcbiAgICAgIGlmICghc3RyZWFtLl9yZWFkYWJsZVN0YXRlIHx8ICFzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIGlmICh3cml0YWJsZSAmJiAhd3JpdGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3dyaXRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbiBvbnJlcXVlc3QoKSB7XG4gICAgc3RyZWFtLnJlcS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICB9O1xuXG4gIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkge1xuICAgIHN0cmVhbS5vbignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTtlbHNlIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gIH0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSkge1xuICAgIC8vIGxlZ2FjeSBzdHJlYW1zXG4gICAgc3RyZWFtLm9uKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgfVxuXG4gIHN0cmVhbS5vbignZW5kJywgb25lbmQpO1xuICBzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgaWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVvczsiLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL3B1bXAgd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlb3M7XG5cbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1MsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRDtcblxuZnVuY3Rpb24gbm9vcChlcnIpIHtcbiAgLy8gUmV0aHJvdyB0aGUgZXJyb3IgaWYgaXQgZXhpc3RzIHRvIGF2b2lkIHN3YWxsb3dpbmcgaXRcbiAgaWYgKGVycikgdGhyb3cgZXJyO1xufVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gIHZhciBjbG9zZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICB9KTtcbiAgaWYgKGVvcyA9PT0gdW5kZWZpbmVkKSBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcbiAgZW9zKHN0cmVhbSwge1xuICAgIHJlYWRhYmxlOiByZWFkaW5nLFxuICAgIHdyaXRhYmxlOiB3cml0aW5nXG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xuICB2YXIgZGVzdHJveWVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBkZXN0cm95ZWQgPSB0cnVlOyAvLyByZXF1ZXN0LmRlc3Ryb3kganVzdCBkbyAuZW5kIC0gLmFib3J0IGlzIHdoYXQgd2Ugd2FudFxuXG4gICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmFib3J0KCk7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgncGlwZScpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FsbChmbikge1xuICBmbigpO1xufVxuXG5mdW5jdGlvbiBwaXBlKGZyb20sIHRvKSB7XG4gIHJldHVybiBmcm9tLnBpcGUodG8pO1xufVxuXG5mdW5jdGlvbiBwb3BDYWxsYmFjayhzdHJlYW1zKSB7XG4gIGlmICghc3RyZWFtcy5sZW5ndGgpIHJldHVybiBub29wO1xuICBpZiAodHlwZW9mIHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5vb3A7XG4gIHJldHVybiBzdHJlYW1zLnBvcCgpO1xufVxuXG5mdW5jdGlvbiBwaXBlbGluZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0cmVhbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3RyZWFtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBjYWxsYmFjayA9IHBvcENhbGxiYWNrKHN0cmVhbXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF07XG5cbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdzdHJlYW1zJyk7XG4gIH1cblxuICB2YXIgZXJyb3I7XG4gIHZhciBkZXN0cm95cyA9IHN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW0sIGkpIHtcbiAgICB2YXIgcmVhZGluZyA9IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDE7XG4gICAgdmFyIHdyaXRpbmcgPSBpID4gMDtcbiAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gICAgICBpZiAoZXJyKSBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgaWYgKHJlYWRpbmcpIHJldHVybjtcbiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlwZWxpbmU7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn0gLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cblxuXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgICBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxcbiAgICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICAgIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsgLy8gZHJhaW4gZXZlbnQgZmxhZy5cblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOyAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7IC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcblxuICB0aGlzLmVuZGVkID0gZmFsc2U7IC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cblxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7IC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcblxuICB0aGlzLmNvcmtlZCA9IDA7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7IC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcblxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9OyAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcblxuXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7IC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cblxuICB0aGlzLndyaXRlbGVuID0gMDtcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOyAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcblxuICB0aGlzLnBlbmRpbmdjYiA9IDA7IC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcblxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdmaW5pc2gnIChhbmQgcG90ZW50aWFsbHkgJ2VuZCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG5cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpOyAvLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cblxuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTsgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBXcml0YWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5LlxuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn0gLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuXG5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQoKTsgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcblxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xufSAvLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5cblxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIGVyO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJ10sIGNodW5rKTtcbiAgfVxuXG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuXG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7IC8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyazsgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG5cbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59IC8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuXG5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn0gLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcblxuXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG5cbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTsgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcblxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cblxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ193cml0ZSgpJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTsgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9IC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cblxuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuXG4gICAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgICAvLyBpZiB0aGUgcmVhZGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuXG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9IC8vIHJldXNlIHRoZSBmcmVlIGNvcmtSZXEuXG5cblxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG4ndXNlIHN0cmljdCc7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG5cbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIEFsbG93IHRoZSBrZXlzIGFycmF5IHRvIGJlIEdDJ2VkLlxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcblxuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICB9XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5cbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBJZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwgdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjsgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cblxuICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcsXG4gICAgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmIChjYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuICBjYihlcik7XG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcblxuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTsgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfSAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG5cblxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07IC8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfdHJhbnNmb3JtKCknKSk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuXG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTsgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTsgLy8gVE9ETyhCcmlkZ2VBUik6IFdyaXRlIGEgdGVzdCBmb3IgdGhlc2UgdHdvIGVycm9yIGNhc2VzXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG5cbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAoKTtcbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORygpO1xuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIEVFbGlzdGVuZXJDb3VudChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBkZWJ1ZztcblxuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QnKTtcblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVDsgLy8gTGF6eSBsb2FkZWQgdG8gaW1wcm92ZSB0aGUgc3RhcnR1cCBwZXJmb3JtYW5jZS5cblxuXG52YXIgU3RyaW5nRGVjb2RlcjtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG52YXIgZnJvbTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTsgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcblxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB0aGlzLnBhdXNlZCA9IHRydWU7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG5cbiAgdGhpcy5hd2FpdERyYWluID0gMDsgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG5cbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTsgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgUmVhZGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3lcblxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsgLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cblxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59OyAvLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICBkZWJ1ZygncmVhZGFibGVBZGRDaHVuaycsIGNodW5rKTtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuXG4gICAgaWYgKGVyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCgpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRigpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IC8vIFdlIGNhbiBwdXNoIG1vcmUgZGF0YSBpZiB3ZSBhcmUgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmsuXG4gIC8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lIG1vcmUgYnl0ZXMuXG4gIC8vIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsIHN1Y2ggYXMgdGhlIHJlcGwuXG5cblxuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cblxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcblxuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKTtcbiAgfVxuXG4gIHJldHVybiBlcjtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyOyAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7IC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG5cbiAgdmFyIHAgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5oZWFkO1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIHdoaWxlIChwICE9PSBudWxsKSB7XG4gICAgY29udGVudCArPSBkZWNvZGVyLndyaXRlKHAuZGF0YSk7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XG5cbiAgaWYgKGNvbnRlbnQgIT09ICcnKSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5wdXNoKGNvbnRlbnQpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoO1xuICByZXR1cm4gdGhpcztcbn07IC8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxR0JcblxuXG52YXIgTUFYX0hXTSA9IDB4NDAwMDAwMDA7XG5cbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIC8vIFRPRE8ocm9uYWcpOiBUaHJvdyBFUlJfVkFMVUVfT1VUX09GX1JBTkdFLlxuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cblxuICByZXR1cm4gbjtcbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcblxuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfSAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cblxuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuOyAvLyBEb24ndCBoYXZlIGVub3VnaFxuXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn0gLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoKHN0YXRlLmhpZ2hXYXRlck1hcmsgIT09IDAgPyBzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayA6IHN0YXRlLmxlbmd0aCA+IDApIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTsgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuXG5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpOyAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9IC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cblxuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7IC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG5cbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuXG4gICAgc3RhdGUuc3luYyA9IGZhbHNlOyAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cblxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cblxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJyk7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcblxuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnN5bmMpIHtcbiAgICAvLyBpZiB3ZSBhcmUgc3luYywgd2FpdCB1bnRpbCBuZXh0IHRpY2sgdG8gZW1pdCB0aGUgZGF0YS5cbiAgICAvLyBPdGhlcndpc2Ugd2UgcmlzayBlbWl0dGluZyBkYXRhIGluIHRoZSBmbG93KClcbiAgICAvLyB0aGUgcmVhZGFibGUgY29kZSB0cmlnZ2VycyBkdXJpbmcgYSByZWFkKCkgY2FsbFxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfVxuICB9XG59IC8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5uZWVkUmVhZGFibGUsIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSk7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuXG4gIGlmICghc3RhdGUuZGVzdHJveWVkICYmIChzdGF0ZS5sZW5ndGggfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIH0gLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXG4gIC8vIDEuIEl0IGlzIG5vdCBmbG93aW5nLCBhcyB0aGUgZmxvdyBtZWNoYW5pc20gd2lsbCB0YWtlXG4gIC8vICAgIGNhcmUgb2YgaXQuXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cbiAgLy8gMy4gSXQgaXMgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmssIHNvIHdlIGNhbiBzY2hlZHVsZVxuICAvLyAgICBhbm90aGVyIHJlYWRhYmxlIGxhdGVyLlxuXG5cbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICBmbG93KHN0cmVhbSk7XG59IC8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuXG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWFkIG1vcmUgZGF0YSBpZiB3ZSBzaG91bGQuXG4gIC8vXG4gIC8vIFRoZSBjb25kaXRpb25zIGZvciByZWFkaW5nIG1vcmUgZGF0YSBhcmUgKG9uZSBvZik6XG4gIC8vIC0gTm90IGVub3VnaCBkYXRhIGJ1ZmZlcmVkIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKS4gVGhlIGxvb3BcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXG4gIC8vICAgaXMgYXZhaWxhYmxlLiBJZiBoaWdoV2F0ZXJNYXJrIGlzIDAgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZsb3dpbmcgbW9kZVxuICAvLyAgIHdlIHNob3VsZCBfbm90XyBhdHRlbXB0IHRvIGJ1ZmZlciBhbnkgZXh0cmEgZGF0YS4gV2UnbGwgZ2V0IG1vcmUgZGF0YVxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cbiAgLy8gLSBObyBkYXRhIGluIHRoZSBidWZmZXIsIGFuZCB0aGUgc3RyZWFtIGlzIGluIGZsb3dpbmcgbW9kZS4gSW4gdGhpcyBtb2RlXG4gIC8vICAgdGhlIGxvb3AgYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHJlYWQoKSBpcyBjYWxsZWQuIEZhaWxpbmcgdG9cbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXG4gIC8vICAgY29udGludWluZyB0aGUgZmxvdyBpZiB0aGUgc3RyZWFtIGNvbnN1bWVyIGhhcyBqdXN0IHN1YnNjcmliZWQgdG8gdGhlXG4gIC8vICAgJ2RhdGEnIGV2ZW50LlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgYWJvdmUgY29uZGl0aW9ucyB0byBrZWVwIHJlYWRpbmcgZGF0YSwgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIHByZXZlbnQgdGhlIGRhdGEgZnJvbSBiZWluZyByZWFkOlxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXG4gIC8vIC0gVGhlcmUgaXMgYWxyZWFkeSBhIHBlbmRpbmcgJ3JlYWQnIG9wZXJhdGlvbiAoc3RhdGUucmVhZGluZykuIFRoaXMgaXMgYVxuICAvLyAgIGNhc2Ugd2hlcmUgdGhlIHRoZSBzdHJlYW0gaGFzIGNhbGxlZCB0aGUgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBfcmVhZCgpXG4gIC8vICAgbWV0aG9kLCBidXQgdGhleSBhcmUgcHJvY2Vzc2luZyB0aGUgY2FsbCBhc3luY2hyb25vdXNseSBhbmQgaGF2ZSBfbm90X1xuICAvLyAgIGNhbGxlZCBwdXNoKCkgd2l0aCBuZXcgZGF0YS4gSW4gdGhpcyBjYXNlIHdlIHNraXAgcGVyZm9ybWluZyBtb3JlXG4gIC8vICAgcmVhZCgpcy4gVGhlIGV4ZWN1dGlvbiBlbmRzIGluIHRoaXMgbWV0aG9kIGFnYWluIGFmdGVyIHRoZSBfcmVhZCgpIGVuZHNcbiAgLy8gICB1cCBjYWxsaW5nIHB1c2goKSB3aXRoIG1vcmUgZGF0YS5cbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aCkgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn0gLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcblxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH0gLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG5cblxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7IC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgY2xlYW5lZFVwID0gdHJ1ZTsgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBkZWJ1ZygnZGVzdC53cml0ZScsIHJldCk7XG5cbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cblxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9IC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG5cblxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBlcnJvck9yRGVzdHJveShkZXN0LCBlcik7XG4gIH0gLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuXG5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpOyAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH0gLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cblxuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7IC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gcGlwZU9uRHJhaW5GdW5jdGlvblJlc3VsdCgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH07IC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7IC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlczsgLy8gZ290IGEgbWF0Y2guXG5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuXG5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICByZXR1cm4gdGhpcztcbn07IC8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5cblxuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyB1cGRhdGUgcmVhZGFibGVMaXN0ZW5pbmcgc28gdGhhdCByZXN1bWUoKSBtYXkgYmUgYSBuby1vcFxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cbiAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7IC8vIFRyeSBzdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcblxuICAgIGlmIChzdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKTtcblxuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnIHx8IGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG5cbiAgaWYgKHN0YXRlLnJlc3VtZVNjaGVkdWxlZCAmJiAhc3RhdGUucGF1c2VkKSB7XG4gICAgLy8gZmxvd2luZyBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZSBub3csIG90aGVyd2lzZVxuICAgIC8vIHRoZSB1cGNvbWluZyByZXN1bWUgd2lsbCBub3QgZmxvdy5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsgLy8gY3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWVcbiAgfSBlbHNlIGlmIChzZWxmLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICBzZWxmLnJlc3VtZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn0gLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpOyAvLyB3ZSBmbG93IG9ubHkgaWYgdGhlcmUgaXMgbm8gb25lIGxpc3RlbmluZ1xuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxuICAgIC8vIHJlc3VtZSgpXG5cbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpO1xuXG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnBhdXNlZCA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuXG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHtcbiAgICA7XG4gIH1cbn0gLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOyAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcblxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcblxuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTsgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cblxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9IC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cblxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH0gLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cblxuXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG5cbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKTtcbiAgfTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUZsb3dpbmcnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IHN0YXRlO1xuICAgIH1cbiAgfVxufSk7IC8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZScsIHN0YXRlLmVuZEVtaXR0ZWQpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7IC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgIC8vIGlmIHRoZSB3cml0YWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuXG4gICAgICBpZiAoIXdTdGF0ZSB8fCB3U3RhdGUuYXV0b0Rlc3Ryb3kgJiYgd1N0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbShSZWFkYWJsZSwgaXRlcmFibGUsIG9wdHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn0iLCIvKipcbiAqIFBhcnNlcyBhbiBVUklcbiAqXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcblxudmFyIHBhcnRzID0gW1xuICAgICdzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ1xuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcbiAgICB2YXIgc3JjID0gc3RyLFxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcbiAgICAgICAgZSA9IHN0ci5pbmRleE9mKCddJyk7XG5cbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXG4gICAgICAgIHVyaSA9IHt9LFxuICAgICAgICBpID0gMTQ7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xuICAgIH1cblxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG4gICAgfVxuXG4gICAgdXJpLnBhdGhOYW1lcyA9IHBhdGhOYW1lcyh1cmksIHVyaVsncGF0aCddKTtcbiAgICB1cmkucXVlcnlLZXkgPSBxdWVyeUtleSh1cmksIHVyaVsncXVlcnknXSk7XG5cbiAgICByZXR1cm4gdXJpO1xufTtcblxuZnVuY3Rpb24gcGF0aE5hbWVzKG9iaiwgcGF0aCkge1xuICAgIHZhciByZWd4ID0gL1xcL3syLDl9L2csXG4gICAgICAgIG5hbWVzID0gcGF0aC5yZXBsYWNlKHJlZ3gsIFwiL1wiKS5zcGxpdChcIi9cIik7XG5cbiAgICBpZiAocGF0aC5zdWJzdHIoMCwgMSkgPT0gJy8nIHx8IHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5hbWVzLnNwbGljZSgwLCAxKTtcbiAgICB9XG4gICAgaWYgKHBhdGguc3Vic3RyKHBhdGgubGVuZ3RoIC0gMSwgMSkgPT0gJy8nKSB7XG4gICAgICAgIG5hbWVzLnNwbGljZShuYW1lcy5sZW5ndGggLSAxLCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZXM7XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5S2V5KHVyaSwgcXVlcnkpIHtcbiAgICB2YXIgZGF0YSA9IHt9O1xuXG4gICAgcXVlcnkucmVwbGFjZSgvKD86XnwmKShbXiY9XSopPT8oW14mXSopL2csIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XG4gICAgICAgIGlmICgkMSkge1xuICAgICAgICAgICAgZGF0YVskMV0gPSAkMjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRhdGE7XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBvbiAob2JqLCBldiwgZm4pIHtcbiAgb2JqLm9uKGV2LCBmbik7XG4gIHJldHVybiB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKGV2LCBmbik7XG4gICAgfVxuICB9O1xufVxuIiwiLyoqXG4gKiBTbGljZSByZWZlcmVuY2UuXG4gKi9cblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbi8qKlxuICogQmluZCBgb2JqYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBvciBzdHJpbmdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgZm4pe1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IG9ialtmbl07XG4gIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuIiwiLyoqXG4gKiBDb21waWxlcyBhIHF1ZXJ5c3RyaW5nXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgaWYgKHN0ci5sZW5ndGgpIHN0ciArPSAnJic7XG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2ltcGxlIHF1ZXJ5c3RyaW5nIGludG8gYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHFzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKHFzKXtcbiAgdmFyIHFyeSA9IHt9O1xuICB2YXIgcGFpcnMgPSBxcy5zcGxpdCgnJicpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcbiAgICBxcnlbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgfVxuICByZXR1cm4gcXJ5O1xufTtcbiIsIi8qIGdsb2JhbCBCbG9iIEZpbGUgKi9cblxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHRvU3RyaW5nLmNhbGwoQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nO1xudmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIEZpbGUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJztcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFN1cHBvcnRzIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEJsb2IgYW5kIEZpbGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeSAob2JqKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGhhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLmlzQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgKHdpdGhOYXRpdmVCbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgKHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9oYXMtYmluYXJ5L3B1bGwvNFxuICBpZiAob2JqLnRvSlNPTiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGhhc0JpbmFyeShvYmoudG9KU09OKCksIHRydWUpO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIGhhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0cy5pbnN0YW5jZXMgPSBbXTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgdmFyIHByZXZUaW1lO1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICBleHBvcnRzLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuICByZXR1cm4gZGVidWc7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICB2YXIgaW5kZXggPSBleHBvcnRzLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgZXhwb3J0cy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgaTtcbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cG9ydHMuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZXhwb3J0cy5pbnN0YW5jZXNbaV07XG4gICAgaW5zdGFuY2UuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG52YXIgd2l0aE5hdGl2ZUJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIEJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcbnZhciB3aXRoTmF0aXZlQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbic7XG5cbnZhciBpc1ZpZXcgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nID8gQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikgOiAob2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuICh3aXRoTmF0aXZlQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgICh3aXRoTmF0aXZlQXJyYXlCdWZmZXIgJiYgKG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IGlzVmlldyhvYmopKSk7XG59XG4iLCIvKmdsb2JhbCBCbG9iLEZpbGUqL1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJyk7XG52YXIgd2l0aE5hdGl2ZUZpbGUgPSB0eXBlb2YgRmlsZSA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIHRvU3RyaW5nLmNhbGwoRmlsZSkgPT09ICdbb2JqZWN0IEZpbGVDb25zdHJ1Y3Rvcl0nKTtcblxuLyoqXG4gKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuICogQW55dGhpbmcgd2l0aCBibG9icyBvciBmaWxlcyBzaG91bGQgYmUgZmVkIHRocm91Z2ggcmVtb3ZlQmxvYnMgYmVmb3JlIGNvbWluZ1xuICogaGVyZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgcGFjayA9IHBhY2tldDtcbiAgcGFjay5kYXRhID0gX2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEsIGJ1ZmZlcnMpO1xuICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG59O1xuXG5mdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gIGlmIChpc0J1ZihkYXRhKSkge1xuICAgIHZhciBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgdmFyIG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIGV2ZW50IHBhY2tldCB3aXRoIHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjb25zdHJ1Y3RlZCBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgYnVmZmVycykge1xuICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSwgYnVmZmVycyk7XG4gIHBhY2tldC5hdHRhY2htZW50cyA9IHVuZGVmaW5lZDsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuICByZXR1cm4gcGFja2V0O1xufTtcblxuZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG4gIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuICogRmlsZVJlYWRlcidzIHJlYWRBc0FycmF5QnVmZmVyIG1ldGhvZC4gVXNlZCBiZWZvcmUgZW5jb2RpbmdcbiAqIGRhdGEgYXMgbXNncGFjay4gQ2FsbHMgY2FsbGJhY2sgd2l0aCB0aGUgYmxvYmxlc3MgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucmVtb3ZlQmxvYnMgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBfcmVtb3ZlQmxvYnMob2JqLCBjdXJLZXksIGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuICAgIC8vIGNvbnZlcnQgYW55IGJsb2JcbiAgICBpZiAoKHdpdGhOYXRpdmVCbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgcGVuZGluZ0Jsb2JzKys7XG5cbiAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcbiAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7IC8vIHRoaXMucmVzdWx0ID09IGFycmF5YnVmZmVyXG4gICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG4gICAgICAgICAgY29udGFpbmluZ09iamVjdFtjdXJLZXldID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYmxvYmxlc3NEYXRhID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcbiAgICAgICAgaWYoISAtLXBlbmRpbmdCbG9icykge1xuICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIob2JqKTsgLy8gYmxvYiAtPiBhcnJheWJ1ZmZlclxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7IC8vIGhhbmRsZSBhcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3RcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG4gIHZhciBibG9ibGVzc0RhdGEgPSBkYXRhO1xuICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcbiAgaWYgKCFwZW5kaW5nQmxvYnMpIHtcbiAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICB9XG59O1xuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTsiLCJcbi8qKlxuICogRXhwb3NlIGBCYWNrb2ZmYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBCYWNrb2ZmKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMDA7XG4gIHRoaXMuZmFjdG9yID0gb3B0cy5mYWN0b3IgfHwgMjtcbiAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpe1xuICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG4gIGlmICh0aGlzLmppdHRlcikge1xuICAgIHZhciByYW5kID0gIE1hdGgucmFuZG9tKCk7XG4gICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1pbmltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uKG1pbil7XG4gIHRoaXMubXMgPSBtaW47XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24obWF4KXtcbiAgdGhpcy5tYXggPSBtYXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaml0dGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG5cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydHMgcGFyc2VyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUFJPVE9DT0w6ICcvaXBmcy9waW5nLzEuMC4wJyxcbiAgUElOR19MRU5HVEg6IDMyXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnbGlicDJwLWNyeXB0bycpXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0c1xuXG5leHBvcnRzLnJuZCA9IChsZW5ndGgpID0+IHtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSBjb25zdGFudHMuUElOR19MRU5HVEhcbiAgfVxuICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aClcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcblxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycDpmbG9vZHN1YicpXG5sb2cuZXJyID0gZGVidWcoJ2xpYnAycDpmbG9vZHN1YjplcnJvcicpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb2c6IGxvZyxcbiAgbXVsdGljb2RlYzogJy9mbG9vZHN1Yi8xLjAuMCdcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3B1bGwnKVxuY29uc3QgZW1wdHkgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9zb3VyY2VzL2VtcHR5JylcbmNvbnN0IGFzeW5jRWFjaCA9IHJlcXVpcmUoJ2FzeW5jL2VhY2gnKVxuY29uc3QgVGltZUNhY2hlID0gcmVxdWlyZSgndGltZS1jYWNoZScpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IGVycmNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5cbmNvbnN0IFBlZXIgPSByZXF1aXJlKCcuL3BlZXInKVxuY29uc3QgbWVzc2FnZSA9IHJlcXVpcmUoJy4vbWVzc2FnZScpXG5jb25zdCB7IHNpZ25NZXNzYWdlIH0gPSByZXF1aXJlKCcuL21lc3NhZ2Uvc2lnbicpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5jb25zdCBuZXh0VGljayA9IHJlcXVpcmUoJ2FzeW5jL25leHRUaWNrJylcblxuLyoqXG4gKiBQdWJzdWJCYXNlUHJvdG9jb2wgaGFuZGxlcyB0aGUgcGVlcnMgYW5kIGNvbm5lY3Rpb25zIGxvZ2ljIGZvciBwdWJzdWIgcm91dGVyc1xuICovXG5jbGFzcyBQdWJzdWJCYXNlUHJvdG9jb2wgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRlYnVnTmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXVsdGljb2RlY1xuICAgKiBAcGFyYW0ge09iamVjdH0gbGlicDJwIGxpYnAycCBpbXBsZW1lbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2lnbk1lc3NhZ2VzIGlmIG1lc3NhZ2VzIHNob3VsZCBiZSBzaWduZWQsIGRlZmF1bHRzIHRvIHRydWVcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVidWdOYW1lLCBtdWx0aWNvZGVjLCBsaWJwMnAsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgc2lnbk1lc3NhZ2VzOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH1cblxuICAgIHRoaXMubG9nID0gZGVidWcoZGVidWdOYW1lKVxuICAgIHRoaXMubG9nLmVyciA9IGRlYnVnKGAke2RlYnVnTmFtZX06ZXJyb3JgKVxuICAgIHRoaXMubXVsdGljb2RlYyA9IG11bHRpY29kZWNcbiAgICB0aGlzLmxpYnAycCA9IGxpYnAycFxuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlXG5cbiAgICBpZiAob3B0aW9ucy5zaWduTWVzc2FnZXMpIHtcbiAgICAgIHRoaXMucGVlcklkID0gdGhpcy5saWJwMnAucGVlckluZm8uaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXAgb2YgdG9waWNzIHRvIHdoaWNoIHBlZXJzIGFyZSBzdWJzY3JpYmVkIHRvXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgUGVlcj59XG4gICAgICovXG4gICAgdGhpcy50b3BpY3MgPSBuZXcgTWFwKClcblxuICAgIC8qKlxuICAgICAqIENhY2hlIG9mIHNlZW4gbWVzc2FnZXNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtUaW1lQ2FjaGV9XG4gICAgICovXG4gICAgdGhpcy5zZWVuQ2FjaGUgPSBuZXcgVGltZUNhY2hlKClcblxuICAgIC8qKlxuICAgICAqIE1hcCBvZiBwZWVycy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBQZWVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnBlZXJzID0gbmV3IE1hcCgpXG5cbiAgICAvLyBEaWFscyB0aGF0IGFyZSBjdXJyZW50bHkgaW4gcHJvZ3Jlc3NcbiAgICB0aGlzLl9kaWFscyA9IG5ldyBTZXQoKVxuXG4gICAgdGhpcy5fb25Db25uZWN0aW9uID0gdGhpcy5fb25Db25uZWN0aW9uLmJpbmQodGhpcylcbiAgICB0aGlzLl9kaWFsUGVlciA9IHRoaXMuX2RpYWxQZWVyLmJpbmQodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgY29ubmVjdGVkIHBlZXIgdG8gdGhlIHBlZXJzIG1hcC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlciBwZWVyIGluZm9cbiAgICogQHJldHVybnMge1BlZXJJbmZvfVxuICAgKi9cbiAgX2FkZFBlZXIgKHBlZXIpIHtcbiAgICBjb25zdCBpZCA9IHBlZXIuaW5mby5pZC50b0I1OFN0cmluZygpXG5cbiAgICAvKlxuICAgICAgQWx3YXlzIHVzZSBhbiBleGlzdGluZyBwZWVyLlxuXG4gICAgICBXaGF0IGlzIGhhcHBlbmluZyBoZXJlIGlzOiBcIklmIHRoZSBvdGhlciBwZWVyIGhhcyBhbHJlYWR5IGRpYWxlZCB0byBtZSwgd2UgYWxyZWFkeSBoYXZlXG4gICAgICBhbiBlc3RhYmxpc2ggbGluayBiZXR3ZWVuIHRoZSB0d28sIHdoYXQgbWlnaHQgYmUgbWlzc2luZyBpcyBhXG4gICAgICBDb25uZWN0aW9uIHNwZWNpZmljYWxseSBiZXR3ZWVuIG1lIGFuZCB0aGF0IFBlZXJcIlxuICAgICAqL1xuICAgIGxldCBleGlzdGluZyA9IHRoaXMucGVlcnMuZ2V0KGlkKVxuICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgIHRoaXMubG9nKCduZXcgcGVlcicsIGlkKVxuICAgICAgdGhpcy5wZWVycy5zZXQoaWQsIHBlZXIpXG4gICAgICBleGlzdGluZyA9IHBlZXJcblxuICAgICAgcGVlci5vbmNlKCdjbG9zZScsICgpID0+IHRoaXMuX3JlbW92ZVBlZXIocGVlcikpXG4gICAgfVxuICAgICsrZXhpc3RpbmcuX3JlZmVyZW5jZXNcblxuICAgIHJldHVybiBleGlzdGluZ1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHBlZXIgZnJvbSB0aGUgcGVlcnMgbWFwIGlmIGl0IGhhcyBubyByZWZlcmVuY2VzLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1BlZXJ9IHBlZXIgcGVlciBzdGF0ZVxuICAgKiBAcmV0dXJucyB7UGVlckluZm99XG4gICAqL1xuICBfcmVtb3ZlUGVlciAocGVlcikge1xuICAgIGNvbnN0IGlkID0gcGVlci5pbmZvLmlkLnRvQjU4U3RyaW5nKClcblxuICAgIHRoaXMubG9nKCdyZW1vdmUnLCBpZCwgcGVlci5fcmVmZXJlbmNlcylcbiAgICAvLyBPbmx5IGRlbGV0ZSB3aGVuIG5vIG9uZSBlbHNlIGlzIHJlZmVyZW5jaW5nIHRoaXMgcGVlci5cbiAgICBpZiAoLS1wZWVyLl9yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICB0aGlzLmxvZygnZGVsZXRlIHBlZXInLCBpZClcbiAgICAgIHRoaXMucGVlcnMuZGVsZXRlKGlkKVxuICAgIH1cblxuICAgIHJldHVybiBwZWVyXG4gIH1cblxuICAvKipcbiAgICogRGlhbCBhIHJlY2VpdmVkIHBlZXIuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UGVlckluZm99IHBlZXJJbmZvIHBlZXIgaW5mb1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9kaWFsUGVlciAocGVlckluZm8sIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiBub29wICgpIHsgfVxuICAgIGNvbnN0IGlkQjU4U3RyID0gcGVlckluZm8uaWQudG9CNThTdHJpbmcoKVxuXG4gICAgLy8gSWYgYWxyZWFkeSBoYXZlIGEgUHViU3ViIGNvbm4sIGlnbm9yZVxuICAgIGNvbnN0IHBlZXIgPSB0aGlzLnBlZXJzLmdldChpZEI1OFN0cilcbiAgICBpZiAocGVlciAmJiBwZWVyLmlzQ29ubmVjdGVkKSB7XG4gICAgICByZXR1cm4gbmV4dFRpY2soKCkgPT4gY2FsbGJhY2soKSlcbiAgICB9XG5cbiAgICAvLyBJZiBhbHJlYWR5IGRpYWxpbmcgdGhpcyBwZWVyLCBpZ25vcmVcbiAgICBpZiAodGhpcy5fZGlhbHMuaGFzKGlkQjU4U3RyKSkge1xuICAgICAgdGhpcy5sb2coJ2FscmVhZHkgZGlhbGluZyAlcywgaWdub3JpbmcgZGlhbCBhdHRlbXB0JywgaWRCNThTdHIpXG4gICAgICByZXR1cm4gbmV4dFRpY2soKCkgPT4gY2FsbGJhY2soKSlcbiAgICB9XG4gICAgdGhpcy5fZGlhbHMuYWRkKGlkQjU4U3RyKVxuXG4gICAgdGhpcy5sb2coJ2RpYWxpbmcgJXMnLCBpZEI1OFN0cilcbiAgICB0aGlzLmxpYnAycC5kaWFsUHJvdG9jb2wocGVlckluZm8sIHRoaXMubXVsdGljb2RlYywgKGVyciwgY29ubikgPT4ge1xuICAgICAgdGhpcy5sb2coJ2RpYWwgdG8gJXMgY29tcGxldGUnLCBpZEI1OFN0cilcblxuICAgICAgLy8gSWYgdGhlIGRpYWwgaXMgbm90IGluIHRoZSBzZXQsIGl0IG1lYW5zIHRoYXQgcHVic3ViIGhhcyBiZWVuXG4gICAgICAvLyBzdG9wcGVkXG4gICAgICBjb25zdCBwdWJzdWJTdG9wcGVkID0gIXRoaXMuX2RpYWxzLmhhcyhpZEI1OFN0cilcbiAgICAgIHRoaXMuX2RpYWxzLmRlbGV0ZShpZEI1OFN0cilcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLmxvZy5lcnIoZXJyKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgfVxuXG4gICAgICAvLyBwdWJzdWIgaGFzIGJlZW4gc3RvcHBlZCwgc28gd2Ugc2hvdWxkIGp1c3QgYmFpbCBvdXRcbiAgICAgIGlmIChwdWJzdWJTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMubG9nKCdwdWJzdWIgd2FzIHN0b3BwZWQsIG5vdCBwcm9jZXNzaW5nIGRpYWwgdG8gJXMnLCBpZEI1OFN0cilcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb25EaWFsKHBlZXJJbmZvLCBjb25uLCBjYWxsYmFjaylcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERpYWwgYSByZWNlaXZlZCBwZWVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1BlZXJJbmZvfSBwZWVySW5mbyBwZWVyIGluZm9cbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIGNvbm5lY3Rpb24gdG8gdGhlIHBlZXJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIF9vbkRpYWwgKHBlZXJJbmZvLCBjb25uLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGlkQjU4U3RyID0gcGVlckluZm8uaWQudG9CNThTdHJpbmcoKVxuICAgIHRoaXMubG9nKCdjb25uZWN0ZWQnLCBpZEI1OFN0cilcblxuICAgIGNvbnN0IHBlZXIgPSB0aGlzLl9hZGRQZWVyKG5ldyBQZWVyKHBlZXJJbmZvKSlcbiAgICBwZWVyLmF0dGFjaENvbm5lY3Rpb24oY29ubilcblxuICAgIG5leHRUaWNrKCgpID0+IGNhbGxiYWNrKCkpXG4gIH1cblxuICAvKipcbiAgICogT24gc3VjY2Vzc2Z1bCBjb25uZWN0aW9uIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgY29ubmVjdGlvbiBwcm90b2NvbFxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gY29ubmVjdGlvbiB0byB0aGUgcGVlclxuICAgKi9cbiAgX29uQ29ubmVjdGlvbiAocHJvdG9jb2wsIGNvbm4pIHtcbiAgICBjb25uLmdldFBlZXJJbmZvKChlcnIsIHBlZXJJbmZvKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMubG9nLmVycignRmFpbGVkIHRvIGlkZW50aWZ5IGluY29tbWluZyBjb25uJywgZXJyKVxuICAgICAgICByZXR1cm4gcHVsbChlbXB0eSgpLCBjb25uKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpZEI1OFN0ciA9IHBlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKClcbiAgICAgIGNvbnN0IHBlZXIgPSB0aGlzLl9hZGRQZWVyKG5ldyBQZWVyKHBlZXJJbmZvKSlcblxuICAgICAgdGhpcy5fcHJvY2Vzc0Nvbm5lY3Rpb24oaWRCNThTdHIsIGNvbm4sIHBlZXIpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkaW5nIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBfcHJvY2Vzc0Nvbm5lY3Rpb24gc2hvdWxkIGtlZXAgdGhlIGNvbm5lY3Rpb24gYW5kIGlzXG4gICAqIHJlc3BvbnNpYmxlIGZvciBwcm9jZXNzaW5nIGVhY2ggUlBDIG1lc3NhZ2UgcmVjZWl2ZWQgYnkgb3RoZXIgcGVlcnMuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRCNThTdHIgcGVlciBpZCBzdHJpbmcgaW4gYmFzZTU4XG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7UGVlckluZm99IHBlZXIgcGVlciBpbmZvXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqXG4gICAqL1xuICBfcHJvY2Vzc0Nvbm5lY3Rpb24gKGlkQjU4U3RyLCBjb25uLCBwZWVyKSB7XG4gICAgdGhyb3cgZXJyY29kZSgnX3Byb2Nlc3NDb25uZWN0aW9uIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIHN1YmNsYXNzJywgJ0VSUl9OT1RfSU1QTEVNRU5URUQnKVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGNvbm5lY3Rpb24gZW5kIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRCNThTdHIgcGVlciBpZCBzdHJpbmcgaW4gYmFzZTU4XG4gICAqIEBwYXJhbSB7UGVlckluZm99IHBlZXIgcGVlciBpbmZvXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyciBlcnJvciBmb3IgY29ubmVjdGlvbiBlbmRcbiAgICovXG4gIF9vbkNvbm5lY3Rpb25FbmQgKGlkQjU4U3RyLCBwZWVyLCBlcnIpIHtcbiAgICAvLyBzb2NrZXQgaGFuZyB1cCwgbWVhbnMgdGhlIG9uZSBzaWRlIGNhbmNlbGVkXG4gICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSAhPT0gJ3NvY2tldCBoYW5nIHVwJykge1xuICAgICAgdGhpcy5sb2cuZXJyKGVycilcbiAgICB9XG5cbiAgICB0aGlzLmxvZygnY29ubmVjdGlvbiBlbmRlZCcsIGlkQjU4U3RyLCBlcnIgPyBlcnIubWVzc2FnZSA6ICcnKVxuICAgIHRoaXMuX3JlbW92ZVBlZXIocGVlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIHRoZSBtZXNzYWdlIGFuZCBzaWducyBpdCwgaWYgc2lnbmluZyBpcyBlbmFibGVkXG4gICAqXG4gICAqIEBwYXJhbSB7TWVzc2FnZX0gbWVzc2FnZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBNZXNzYWdlKX0gY2FsbGJhY2tcbiAgICovXG4gIF9idWlsZE1lc3NhZ2UgKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbXNnID0gdXRpbHMubm9ybWFsaXplT3V0UnBjTWVzc2FnZShtZXNzYWdlKVxuICAgIGlmICh0aGlzLnBlZXJJZCkge1xuICAgICAgc2lnbk1lc3NhZ2UodGhpcy5wZWVySWQsIG1zZywgY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRUaWNrKGNhbGxiYWNrLCBudWxsLCBtc2cpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRpbmcgdGhlIGltcGxlbWVudGF0aW9uIG9mIHB1Ymxpc2ggc2hvdWxkIGhhbmRsZSB0aGUgYXBwcm9wcmlhdGUgYWxnb3JpdGhtcyBmb3IgdGhlIHB1Ymxpc2gvc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbi5cbiAgICogRm9yIGV4YW1wbGUsIGEgRmxvb2RzdWIgaW1wbGVtZW50YXRpb24gbWlnaHQgc2ltcGx5IHB1Ymxpc2ggZWFjaCBtZXNzYWdlIHRvIGVhY2ggdG9waWMgZm9yIGV2ZXJ5IHBlZXJcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPnxzdHJpbmd9IHRvcGljc1xuICAgKiBAcGFyYW0ge0FycmF5PGFueT58YW55fSBtZXNzYWdlc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICpcbiAgICovXG4gIHB1Ymxpc2ggKHRvcGljcywgbWVzc2FnZXMsIGNhbGxiYWNrKSB7XG4gICAgdGhyb3cgZXJyY29kZSgncHVibGlzaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHRoZSBzdWJjbGFzcycsICdFUlJfTk9UX0lNUExFTUVOVEVEJylcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkaW5nIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBzdWJzY3JpYmUgc2hvdWxkIGhhbmRsZSB0aGUgYXBwcm9wcmlhdGUgYWxnb3JpdGhtcyBmb3IgdGhlIHB1Ymxpc2gvc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbi5cbiAgICogRm9yIGV4YW1wbGUsIGEgRmxvb2RzdWIgaW1wbGVtZW50YXRpb24gbWlnaHQgc2ltcGx5IHNlbmQgYSBtZXNzYWdlIGZvciBldmVyeSBwZWVyIHNob3dpbmcgaW50ZXJlc3QgaW4gdGhlIHRvcGljc1xuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fHN0cmluZ30gdG9waWNzXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBzdWJzY3JpYmUgKHRvcGljcykge1xuICAgIHRocm93IGVycmNvZGUoJ3N1YnNjcmliZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHRoZSBzdWJjbGFzcycsICdFUlJfTk9UX0lNUExFTUVOVEVEJylcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkaW5nIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB1bnN1YnNjcmliZSBzaG91bGQgaGFuZGxlIHRoZSBhcHByb3ByaWF0ZSBhbGdvcml0aG1zIGZvciB0aGUgcHVibGlzaC9zdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uLlxuICAgKiBGb3IgZXhhbXBsZSwgYSBGbG9vZHN1YiBpbXBsZW1lbnRhdGlvbiBtaWdodCBzaW1wbHkgc2VuZCBhIG1lc3NhZ2UgZm9yIGV2ZXJ5IHBlZXIgcmV2b2tpbmcgaW50ZXJlc3QgaW4gdGhlIHRvcGljc1xuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fHN0cmluZ30gdG9waWNzXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICB1bnN1YnNjcmliZSAodG9waWNzKSB7XG4gICAgdGhyb3cgZXJyY29kZSgndW5zdWJzY3JpYmUgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgc3ViY2xhc3MnLCAnRVJSX05PVF9JTVBMRU1FTlRFRCcpXG4gIH1cblxuICAvKipcbiAgICogTW91bnRzIHRoZSBwdWJzdWIgcHJvdG9jb2wgb250byB0aGUgbGlicDJwIG5vZGUgYW5kIHNlbmRzIG91clxuICAgKiBzdWJzY3JpcHRpb25zIHRvIGV2ZXJ5IHBlZXIgY29ubmVjZXRlZFxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKlxuICAgKi9cbiAgc3RhcnQgKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgcmV0dXJuIG5leHRUaWNrKCgpID0+IGNhbGxiYWNrKG5ldyBFcnJvcignYWxyZWFkeSBzdGFydGVkJykpKVxuICAgIH1cbiAgICB0aGlzLmxvZygnc3RhcnRpbmcnKVxuXG4gICAgdGhpcy5saWJwMnAuaGFuZGxlKHRoaXMubXVsdGljb2RlYywgdGhpcy5fb25Db25uZWN0aW9uKVxuXG4gICAgLy8gU3BlZWQgdXAgYW55IG5ldyBwZWVyIHRoYXQgY29tZXMgaW4gbXkgd2F5XG4gICAgdGhpcy5saWJwMnAub24oJ3BlZXI6Y29ubmVjdCcsIHRoaXMuX2RpYWxQZWVyKVxuXG4gICAgLy8gRGlhbCBhbHJlYWR5IGNvbm5lY3RlZCBwZWVyc1xuICAgIGNvbnN0IHBlZXJJbmZvcyA9IE9iamVjdC52YWx1ZXModGhpcy5saWJwMnAucGVlckJvb2suZ2V0QWxsKCkpXG5cbiAgICBhc3luY0VhY2gocGVlckluZm9zLCAocGVlciwgY2IpID0+IHRoaXMuX2RpYWxQZWVyKHBlZXIsIGNiKSwgKGVycikgPT4ge1xuICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZygnc3RhcnRlZCcpXG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWVcbiAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFVubW91bnRzIHRoZSBwdWJzdWIgcHJvdG9jb2wgYW5kIHNodXRzIGRvd24gZXZlcnkgY29ubmVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKlxuICAgKi9cbiAgc3RvcCAoY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgcmV0dXJuIG5leHRUaWNrKCgpID0+IGNhbGxiYWNrKG5ldyBFcnJvcignbm90IHN0YXJ0ZWQgeWV0JykpKVxuICAgIH1cblxuICAgIHRoaXMubGlicDJwLnVuaGFuZGxlKHRoaXMubXVsdGljb2RlYylcbiAgICB0aGlzLmxpYnAycC5yZW1vdmVMaXN0ZW5lcigncGVlcjpjb25uZWN0JywgdGhpcy5fZGlhbFBlZXIpXG5cbiAgICAvLyBQcmV2ZW50IGFueSBkaWFscyB0aGF0IGFyZSBpbiBmbGlnaHQgZnJvbSBiZWluZyBwcm9jZXNzZWRcbiAgICB0aGlzLl9kaWFscyA9IG5ldyBTZXQoKVxuXG4gICAgdGhpcy5sb2coJ3N0b3BwaW5nJylcbiAgICBhc3luY0VhY2godGhpcy5wZWVycy52YWx1ZXMoKSwgKHBlZXIsIGNiKSA9PiBwZWVyLmNsb3NlKGNiKSwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZygnc3RvcHBlZCcpXG4gICAgICB0aGlzLnBlZXJzID0gbmV3IE1hcCgpXG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZVxuICAgICAgY2FsbGJhY2soKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQdWJzdWJCYXNlUHJvdG9jb2xcbm1vZHVsZS5leHBvcnRzLm1lc3NhZ2UgPSBtZXNzYWdlXG5tb2R1bGUuZXhwb3J0cy51dGlscyA9IHV0aWxzXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9nZXQgPSByZXF1aXJlKCdsb2Rhc2gvZ2V0Jyk7XG5cbnZhciBfZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldCk7XG5cbnZhciBfaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2xvZGFzaC9pc0Z1bmN0aW9uJyk7XG5cbnZhciBfaXNGdW5jdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0Z1bmN0aW9uKTtcblxudmFyIF9WaXNpYmlsaXR5Q2hhbmdlRW1pdHRlciA9IHJlcXVpcmUoJy4vVmlzaWJpbGl0eUNoYW5nZUVtaXR0ZXInKTtcblxudmFyIF9WaXNpYmlsaXR5Q2hhbmdlRW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9WaXNpYmlsaXR5Q2hhbmdlRW1pdHRlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2xhdGVuY3ktbW9uaXRvcjpMYXRlbmN5TW9uaXRvcicpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN1bW1hcnlPYmplY3RcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBldmVudHMgSG93IG1hbnkgZXZlbnRzIHdlcmUgY2FsbGVkXG4gKiBAcHJvcGVydHkge051bWJlcn0gbWluTVMgV2hhdCB3YXMgdGhlIG1pbiB0aW1lIGZvciBhIGNiIHRvIGJlIGNhbGxlZFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IG1heE1TIFdoYXQgd2FzIHRoZSBtYXggdGltZSBmb3IgYSBjYiB0byBiZSBjYWxsZWRcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBhdmdNcyBXaGF0IHdhcyB0aGUgYXZlcmFnZSB0aW1lIGZvciBhIGNiIHRvIGJlIGNhbGxlZFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGxlbmd0aE1zIEhvdyBsb25nIHRoaXMgaW50ZXJ2YWwgd2FzIGluIG1zXG4gKi9cblxuLyoqXG4gKiBBIGNsYXNzIHRvIG1vbml0b3IgbGF0ZW5jeSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24gd2hpY2ggd29ya3MgaW4gYSBicm93c2VyIG9yIG5vZGUuIFRoaXMgd29ya3MgYnkgcGVyaW9kaWNhbGx5IGNhbGxpbmdcbiAqIHRoZSBhc3luY1Rlc3RGbiBhbmQgdGltaW5nIGhvdyBsb25nIGl0IHRha2VzIHRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQuIEl0IGNhbiBhbHNvIHBlcmlvZGljYWxseSBlbWl0IHN0YXRzIGFib3V0IHRoaXMuXG4gKiBUaGlzIGNhbiBiZSBkaXNhYmxlZCBhbmQgc3RhdHMgY2FuIGJlIHB1bGxlZCB2aWEgc2V0dGluZyBkYXRhRW1pdEludGVydmFsTXMgPSAwLlxuICpcbiAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIGFuIGV2ZW50IGxvb3AgbGF0ZW5jeSBtb25pdG9yLiBUaGlzIHdvcmtzIGJ5IGZpcmluZyBwZXJpb2RpYyBldmVudHMgaW50byB0aGUgZXZlbnQgbG9vcFxuICogYW5kIHRpbWluZyBob3cgbG9uZyBpdCB0YWtlcyB0byBnZXQgYmFjay5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbW9uaXRvciA9IG5ldyBMYXRlbmN5TW9uaXRvcigpO1xuICogbW9uaXRvci5vbignZGF0YScsIChzdW1tYXJ5KSA9PiBjb25zb2xlLmxvZygnRXZlbnQgTG9vcCBMYXRlbmN5OiAlTycsIHN1bW1hcnkpKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbW9uaXRvciA9IG5ldyBMYXRlbmN5TW9uaXRvcih7bGF0ZW5jeUNoZWNrSW50ZXJ2YWxNczogMTAwMCwgZGF0YUVtaXRJbnRlcnZhbE1zOiA2MDAwMCwgYXN5bmNUZXN0Rm46cGluZ30pO1xuICogbW9uaXRvci5vbignZGF0YScsIChzdW1tYXJ5KSA9PiBjb25zb2xlLmxvZygnUGluZyBQb25nIExhdGVuY3k6ICVPJywgc3VtbWFyeSkpO1xuICovXG5cbnZhciBMYXRlbmN5TW9uaXRvciA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKExhdGVuY3lNb25pdG9yLCBfRXZlbnRFbWl0dGVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGF0ZW5jeUNoZWNrSW50ZXJ2YWxNcz01MDBdIEhvdyBvZnRlbiB0byBhZGQgYSBsYXRlbmN5IGNoZWNrIGV2ZW50IChtcylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGFFbWl0SW50ZXJ2YWxNcz01MDAwXSBIb3cgb2Z0ZW4gdG8gc3VtbWFyaXplIGxhdGVuY3kgY2hlY2sgZXZlbnRzLiBudWxsIG9yIDAgZGlzYWJsZXMgZXZlbnQgZmlyaW5nXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2FzeW5jVGVzdEZuXSBXaGF0IGNiLXN0eWxlIGFzeW5jIGZ1bmN0aW9uIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGF0ZW5jeVJhbmRvbVBlcmNlbnRhZ2U9NV0gV2hhdCBwZXJjZW50ICgrLy0pIG9mIGxhdGVuY3lDaGVja0ludGVydmFsTXMgc2hvdWxkIHdlIHJhbmRvbWx5IHVzZT8gVGhpcyBoZWxwcyBhdm9pZCBhbGlnbm1lbnQgdG8gb3RoZXIgZXZlbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhdGVuY3lNb25pdG9yKCkge1xuICAgICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgICBsYXRlbmN5Q2hlY2tJbnRlcnZhbE1zID0gX3JlZi5sYXRlbmN5Q2hlY2tJbnRlcnZhbE1zLFxuICAgICAgICAgICAgZGF0YUVtaXRJbnRlcnZhbE1zID0gX3JlZi5kYXRhRW1pdEludGVydmFsTXMsXG4gICAgICAgICAgICBhc3luY1Rlc3RGbiA9IF9yZWYuYXN5bmNUZXN0Rm4sXG4gICAgICAgICAgICBsYXRlbmN5UmFuZG9tUGVyY2VudGFnZSA9IF9yZWYubGF0ZW5jeVJhbmRvbVBlcmNlbnRhZ2U7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhdGVuY3lNb25pdG9yKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTGF0ZW5jeU1vbml0b3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMYXRlbmN5TW9uaXRvcikpLmNhbGwodGhpcykpO1xuXG4gICAgICAgIHZhciB0aGF0ID0gX3RoaXM7XG5cbiAgICAgICAgLy8gMCBpc24ndCB2YWxpZCBoZXJlLCBzbyBpdHMgb2sgdG8gdXNlIHx8XG4gICAgICAgIHRoYXQubGF0ZW5jeUNoZWNrSW50ZXJ2YWxNcyA9IGxhdGVuY3lDaGVja0ludGVydmFsTXMgfHwgNTAwOyAvLyAwLjVzXG4gICAgICAgIHRoYXQubGF0ZW5jeVJhbmRvbVBlcmNlbnRhZ2UgPSBsYXRlbmN5UmFuZG9tUGVyY2VudGFnZSB8fCAxMDtcbiAgICAgICAgdGhhdC5fbGF0ZWN5Q2hlY2tNdWx0aXBseSA9IDIgKiAodGhhdC5sYXRlbmN5UmFuZG9tUGVyY2VudGFnZSAvIDEwMC4wKSAqIHRoYXQubGF0ZW5jeUNoZWNrSW50ZXJ2YWxNcztcbiAgICAgICAgdGhhdC5fbGF0ZWN5Q2hlY2tTdWJ0cmFjdCA9IHRoYXQuX2xhdGVjeUNoZWNrTXVsdGlwbHkgLyAyO1xuXG4gICAgICAgIHRoYXQuZGF0YUVtaXRJbnRlcnZhbE1zID0gZGF0YUVtaXRJbnRlcnZhbE1zID09PSBudWxsIHx8IGRhdGFFbWl0SW50ZXJ2YWxNcyA9PT0gMCA/IHVuZGVmaW5lZCA6IGRhdGFFbWl0SW50ZXJ2YWxNcyB8fCA1ICogMTAwMDsgLy8gNXNcbiAgICAgICAgZGVidWcoJ2xhdGVuY3lDaGVja0ludGVydmFsTXM6ICVzIGRhdGFFbWl0SW50ZXJ2YWxNczogJXMnLCB0aGF0LmxhdGVuY3lDaGVja0ludGVydmFsTXMsIHRoYXQuZGF0YUVtaXRJbnRlcnZhbE1zKTtcbiAgICAgICAgaWYgKHRoYXQuZGF0YUVtaXRJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICBkZWJ1ZygnRXhwZWN0aW5nIH4lcyBldmVudHMgcGVyIHN1bW1hcnknLCB0aGF0LmxhdGVuY3lDaGVja0ludGVydmFsTXMgLyB0aGF0LmRhdGFFbWl0SW50ZXJ2YWxNcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZygnTm90IGVtaXR0aW5nIHN1bW1hcmllcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5hc3luY1Rlc3RGbiA9IGFzeW5jVGVzdEZuOyAvLyBJZiB0aGVyZSBpcyBubyBhc3luY0ZuLCB3ZSBtZWFzdXJlIGxhdGVuY3lcblxuICAgICAgICAvLyBJZiBwcm9jZXNzOiB1c2UgaGlnaCByZXNvbHV0aW9uIHRpbWVyXG4gICAgICAgIGlmIChwcm9jZXNzICYmIHByb2Nlc3MuaHJ0aW1lKSB7XG4gICAgICAgICAgICBkZWJ1ZygnVXNpbmcgcHJvY2Vzcy5ocnRpbWUgZm9yIHRpbWluZycpO1xuICAgICAgICAgICAgdGhhdC5ub3cgPSBwcm9jZXNzLmhydGltZTtcbiAgICAgICAgICAgIHRoYXQuZ2V0RGVsdGFNUyA9IGZ1bmN0aW9uIChzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHJ0aW1lID0gdGhhdC5ub3coc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHJ0aW1lWzBdICogMTAwMCArIGhydGltZVsxXSAvIDEwMDAwMDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gTGV0J3MgdHJ5IGZvciBhIHRpbWVyIHRoYXQgb25seSBtb25vdG9uaWNhbGx5IGluY3JlYXNlc1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgwLCBfZ2V0Mi5kZWZhdWx0KSh3aW5kb3csICdwZXJmb3JtYW5jZS5ub3cnKSkge1xuICAgICAgICAgICAgZGVidWcoJ1VzaW5nIHBlcmZvcm1hbmNlLm5vdyBmb3IgdGltaW5nJyk7XG4gICAgICAgICAgICB0aGF0Lm5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh3aW5kb3cucGVyZm9ybWFuY2UpO1xuICAgICAgICAgICAgdGhhdC5nZXREZWx0YU1TID0gZnVuY3Rpb24gKHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRoYXQubm93KCkgLSBzdGFydFRpbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKCdVc2luZyBEYXRlLm5vdyBmb3IgdGltaW5nJyk7XG4gICAgICAgICAgICB0aGF0Lm5vdyA9IERhdGUubm93O1xuICAgICAgICAgICAgdGhhdC5nZXREZWx0YU1TID0gZnVuY3Rpb24gKHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGF0Lm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQuX2xhdGVuY3lEYXRhID0gdGhhdC5faW5pdExhdGVuY3lEYXRhKCk7XG5cbiAgICAgICAgLy8gV2UgY2hlY2sgZm9yIGlzQnJvd3NlciBiZWNhdXNlIG9mIGJyb3dzZXJzIHNldCBtYXggcmF0ZXMgb2YgdGltZW91dHMgd2hlbiBhIHBhZ2UgaXMgaGlkZGVuLFxuICAgICAgICAvLyBzbyB3ZSBmYWxsIGJhY2sgdG8gYW5vdGhlciBsaWJyYXJ5XG4gICAgICAgIC8vIFNlZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MDMyNDI5L2Nocm9tZS10aW1lb3V0cy1pbnRlcnZhbC1zdXNwZW5kZWQtaW4tYmFja2dyb3VuZC10YWJzXG4gICAgICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICAgICAgdGhhdC5fdmlzaWJpbGl0eUNoYW5nZUVtaXR0ZXIgPSBuZXcgX1Zpc2liaWxpdHlDaGFuZ2VFbWl0dGVyMi5kZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGF0Ll92aXNpYmlsaXR5Q2hhbmdlRW1pdHRlci5vbigndmlzaWJpbGl0eUNoYW5nZScsIGZ1bmN0aW9uIChwYWdlSW5Gb2N1cykge1xuICAgICAgICAgICAgICAgIGlmIChwYWdlSW5Gb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9zdGFydFRpbWVycygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX2VtaXRTdW1tYXJ5KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX3N0b3BUaW1lcnMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhhdC5fdmlzaWJpbGl0eUNoYW5nZUVtaXR0ZXIgfHwgdGhhdC5fdmlzaWJpbGl0eUNoYW5nZUVtaXR0ZXIuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHRoYXQuX3N0YXJ0VGltZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGludGVybmFsIHRpbWVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhMYXRlbmN5TW9uaXRvciwgW3tcbiAgICAgICAga2V5OiAnX3N0YXJ0VGltZXJzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFRpbWVycygpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBUaW1lciBhbHJlYWR5IHN0YXJ0ZWQsIGlnbm9yZSB0aGlzXG4gICAgICAgICAgICBpZiAodGhpcy5fY2hlY2tMYXRlbmN5SUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGVja0xhdGVuY3koKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFFbWl0SW50ZXJ2YWxNcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRJbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9lbWl0U3VtbWFyeSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMuZGF0YUVtaXRJbnRlcnZhbE1zKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uMi5kZWZhdWx0KSh0aGlzLl9lbWl0SW50ZXJ2YWxJRC51bnJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdEludGVydmFsSUQudW5yZWYoKTsgLy8gRG9lc24ndCBibG9jayBleGl0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3AgaW50ZXJuYWwgdGltZXJzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfc3RvcFRpbWVycycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RvcFRpbWVycygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGVja0xhdGVuY3lJRCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jaGVja0xhdGVuY3lJRCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tMYXRlbmN5SUQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdEludGVydmFsSUQpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2VtaXRJbnRlcnZhbElEKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0SW50ZXJ2YWxJRCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0IHN1bW1hcnkgb25seSBpZiB0aGVyZSB3ZXJlIGV2ZW50cy4gSXQgbWlnaHQgbm90IGhhdmUgYW55IGV2ZW50cyBpZiBpdCB3YXMgZm9yY2VkIHZpYSBhIHBhZ2UgaGlkZGVuL3Nob3dcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19lbWl0U3VtbWFyeScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFN1bW1hcnkoKSB7XG4gICAgICAgICAgICB2YXIgc3VtbWFyeSA9IHRoaXMuZ2V0U3VtbWFyeSgpO1xuICAgICAgICAgICAgaWYgKHN1bW1hcnkuZXZlbnRzID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHN1bW1hcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxpbmcgdGhpcyBmdW5jdGlvbiB3aWxsIGVuZCB0aGUgY29sbGVjdGlvbiBwZXJpb2QuIElmIGEgdGltaW5nIGV2ZW50IHdhcyBhbHJlYWR5IGZpcmVkIGFuZCBzb21ld2hlcmUgaW4gdGhlIHF1ZXVlLFxuICAgICAgICAgKiBpdCB3aWxsIG5vdCBjb3VudCBmb3IgdGhpcyB0aW1lIHBlcmlvZFxuICAgICAgICAgKiBAcmV0dXJucyB7U3VtbWFyeU9iamVjdH1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFN1bW1hcnknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3VtbWFyeSgpIHtcbiAgICAgICAgICAgIC8vIFdlIG1pZ2h0IHdhbnQgdG8gYWRqdXN0IGZvciB0aGUgbnVtYmVyIG9mIGV4cGVjdGVkIGV2ZW50c1xuICAgICAgICAgICAgLy8gRXhhbXBsZTogZmlyc3QgMSBldmVudCBpdCBjb21lcyBiYWNrLCB0aGVuIHN1Y2ggYSBsb25nIGJsb2NrZXIgdGhhdCB0aGUgbmV4dCBlbWl0IGNoZWNrIGNvbWVzXG4gICAgICAgICAgICAvLyBUaGVuIHRoaXMgZmlyZXMgLSBsb29rcyBsaWtlIG5vIGxhdGVuY3khIVxuICAgICAgICAgICAgdmFyIGxhdGVuY3kgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzOiB0aGlzLl9sYXRlbmN5RGF0YS5ldmVudHMsXG4gICAgICAgICAgICAgICAgbWluTXM6IHRoaXMuX2xhdGVuY3lEYXRhLm1pbk1zLFxuICAgICAgICAgICAgICAgIG1heE1zOiB0aGlzLl9sYXRlbmN5RGF0YS5tYXhNcyxcbiAgICAgICAgICAgICAgICBhdmdNczogdGhpcy5fbGF0ZW5jeURhdGEuZXZlbnRzID8gdGhpcy5fbGF0ZW5jeURhdGEudG90YWxNcyAvIHRoaXMuX2xhdGVuY3lEYXRhLmV2ZW50cyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICAgICAgICBsZW5ndGhNczogdGhpcy5nZXREZWx0YU1TKHRoaXMuX2xhdGVuY3lEYXRhLnN0YXJ0VGltZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9sYXRlbmN5RGF0YSA9IHRoaXMuX2luaXRMYXRlbmN5RGF0YSgpOyAvLyBDbGVhclxuXG4gICAgICAgICAgICBkZWJ1ZygnU3VtbWFyeTogJU8nLCBsYXRlbmN5KTtcbiAgICAgICAgICAgIHJldHVybiBsYXRlbmN5O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJhbmRvbWx5IGNhbGxzIGFuIGFzeW5jIGZuIGV2ZXJ5IHJvdWdobHkgbGF0ZW5jeUNoZWNrSW50ZXJ2YWxNcyAocGx1cyBzb21lIHJhbmRvbW5lc3MpLiBJZiBubyBhc3luYyBmbiBpcyBmb3VuZCxcbiAgICAgICAgICogaXQgd2lsbCBzaW1wbHkgcmVwb3J0IG9uIGV2ZW50IGxvb3AgbGF0ZW5jeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19jaGVja0xhdGVuY3knLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrTGF0ZW5jeSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICAvLyBSYW5kb21uZXNzIGlzIG5lZWRlZCB0byBhdm9pZCBhbGlnbm1lbnQgYnkgYWNjaWRlbnQgdG8gcmVndWxhciB0aGluZ3MgaW4gdGhlIGV2ZW50IGxvb3BcbiAgICAgICAgICAgIHZhciByYW5kb21uZXNzID0gTWF0aC5yYW5kb20oKSAqIHRoYXQuX2xhdGVjeUNoZWNrTXVsdGlwbHkgLSB0aGF0Ll9sYXRlY3lDaGVja1N1YnRyYWN0O1xuXG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhpcyB0byBlbnN1cmUgdGhhdCBpbiBjYXNlIHNvbWUgb3ZlcmxhcCBzb21laG93LCB3ZSBkb24ndCB0YWtlIHRoZSB3cm9uZyBzdGFydFRpbWUvb2Zmc2V0XG4gICAgICAgICAgICB2YXIgbG9jYWxEYXRhID0ge1xuICAgICAgICAgICAgICAgIGRlbHRhT2Zmc2V0OiBNYXRoLmNlaWwodGhhdC5sYXRlbmN5Q2hlY2tJbnRlcnZhbE1zICsgcmFuZG9tbmVzcyksXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiB0aGF0Lm5vdygpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiBjYigpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgYWxyZWFkeSBzdG9wcGVkLCBpZ25vcmUgdGhpcyBkYXRhcG9pbnRcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzMy5fY2hlY2tMYXRlbmN5SUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFNUyA9IHRoYXQuZ2V0RGVsdGFNUyhsb2NhbERhdGEuc3RhcnRUaW1lKSAtIGxvY2FsRGF0YS5kZWx0YU9mZnNldDtcbiAgICAgICAgICAgICAgICB0aGF0Ll9jaGVja0xhdGVuY3koKTsgLy8gU3RhcnQgYWdhaW4gQVNBUFxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBkYXRhIHBvaW50LiBJZiB0aGlzIGdldHMgY29tcGxleCwgcmVmYWN0b3IgaXRcbiAgICAgICAgICAgICAgICB0aGF0Ll9sYXRlbmN5RGF0YS5ldmVudHMrKztcbiAgICAgICAgICAgICAgICB0aGF0Ll9sYXRlbmN5RGF0YS5taW5NcyA9IE1hdGgubWluKHRoYXQuX2xhdGVuY3lEYXRhLm1pbk1zLCBkZWx0YU1TKTtcbiAgICAgICAgICAgICAgICB0aGF0Ll9sYXRlbmN5RGF0YS5tYXhNcyA9IE1hdGgubWF4KHRoYXQuX2xhdGVuY3lEYXRhLm1heE1zLCBkZWx0YU1TKTtcbiAgICAgICAgICAgICAgICB0aGF0Ll9sYXRlbmN5RGF0YS50b3RhbE1zICs9IGRlbHRhTVM7XG4gICAgICAgICAgICAgICAgZGVidWcoJ01TOiAlcyBEYXRhOiAlTycsIGRlbHRhTVMsIHRoYXQuX2xhdGVuY3lEYXRhKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWJ1ZygnbG9jYWxEYXRhOiAlTycsIGxvY2FsRGF0YSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2NoZWNrTGF0ZW5jeUlEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBnZXRzIHJpZCBvZiBpbmNsdWRpbmcgZXZlbnQgbG9vcFxuICAgICAgICAgICAgICAgIGlmICh0aGF0LmFzeW5jVGVzdEZuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIHRpbWluZyByZWxhdGVkIHRoaW5nc1xuICAgICAgICAgICAgICAgICAgICBsb2NhbERhdGEuZGVsdGFPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbERhdGEuc3RhcnRUaW1lID0gdGhhdC5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hc3luY1Rlc3RGbihjYik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0VGltZW91dCBpcyBub3QgbW9yZSBhY2N1cmF0ZSB0aGFuIDFtcywgc28gdGhpcyB3aWxsIGVuc3VyZSBwb3NpdGl2ZSBudW1iZXJzLiBBZGQgMSB0byBlbWl0dGVkIGRhdGEgdG8gcmVtb3ZlLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG5vdCB0aGUgYmVzdCwgYnV0IGZvciBub3cgaXQnbGwgYmUganVzdCBmaW5lLiBUaGlzIGlzbid0IG1lYW50IHRvIGJlIHN1YiBtcyBhY2N1cmF0ZS5cbiAgICAgICAgICAgICAgICAgICAgbG9jYWxEYXRhLmRlbHRhT2Zmc2V0IC09IDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGZ1bmN0aW9uIHRvIHRlc3QsIHdlIG1lYW4gY2hlY2sgbGF0ZW5jeSB3aGljaCBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IGlzIHJlYWxseSBjYiA9PiBjYigpXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGF2b2lkIHRoYXQgZm9yIHRoZSBmZXcgZXh0cmEgZnVuY3Rpb24gYWxsIG92ZXJoZWFkcy4gQWxzbywgd2Ugd2FudCB0byBrZWVwIHRoZSB0aW1lcnMgZGlmZmVyZW50XG4gICAgICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbG9jYWxEYXRhLmRlbHRhT2Zmc2V0KTtcblxuICAgICAgICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbjIuZGVmYXVsdCkodGhpcy5fY2hlY2tMYXRlbmN5SUQudW5yZWYpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tMYXRlbmN5SUQudW5yZWYoKTsgLy8gRG9lc24ndCBibG9jayBleGl0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19pbml0TGF0ZW5jeURhdGEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRMYXRlbmN5RGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiB0aGlzLm5vdygpLFxuICAgICAgICAgICAgICAgIG1pbk1zOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgICAgICAgbWF4TXM6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICAgICAgICAgICAgICBldmVudHM6IDAsXG4gICAgICAgICAgICAgICAgdG90YWxNczogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBMYXRlbmN5TW9uaXRvcjtcbn0oX2V2ZW50czIuZGVmYXVsdCk7XG5cbmZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExhdGVuY3lNb25pdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGF0ZW5jeU1vbml0b3IuanMubWFwXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IEJpZyA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpXG5jb25zdCBNb3ZpbmdBdmVyYWdlID0gcmVxdWlyZSgnbW92aW5nLWF2ZXJhZ2UnKVxuY29uc3QgcmV0aW1lciA9IHJlcXVpcmUoJ3JldGltZXInKVxuXG4vKipcbiAqIEEgcXVldWUgYmFzZWQgbWFuYWdlciBmb3Igc3RhdCBwcm9jZXNzaW5nXG4gKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBpbml0aWFsQ291bnRlcnNcbiAqIEBwYXJhbSB7YW55fSBvcHRpb25zXG4gKi9cbmNsYXNzIFN0YXRzIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKGluaXRpYWxDb3VudGVycywgb3B0aW9ucykge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5fcXVldWUgPSBbXVxuICAgIHRoaXMuX3N0YXRzID0ge31cblxuICAgIHRoaXMuX2ZyZXF1ZW5jeUxhc3RUaW1lID0gRGF0ZS5ub3coKVxuICAgIHRoaXMuX2ZyZXF1ZW5jeUFjY3VtdWxhdG9ycyA9IHt9XG4gICAgdGhpcy5fbW92aW5nQXZlcmFnZXMgPSB7fVxuXG4gICAgdGhpcy5fdXBkYXRlID0gdGhpcy5fdXBkYXRlLmJpbmQodGhpcylcblxuICAgIGNvbnN0IGludGVydmFscyA9IHRoaXMuX29wdGlvbnMubW92aW5nQXZlcmFnZUludGVydmFsc1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsQ291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBpbml0aWFsQ291bnRlcnNbaV1cbiAgICAgIHRoaXMuX3N0YXRzW2tleV0gPSBCaWcoMClcbiAgICAgIHRoaXMuX21vdmluZ0F2ZXJhZ2VzW2tleV0gPSB7fVxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBpbnRlcnZhbHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGludGVydmFsID0gaW50ZXJ2YWxzW2tdXG4gICAgICAgIHZhciBtYSA9IHRoaXMuX21vdmluZ0F2ZXJhZ2VzW2tleV1baW50ZXJ2YWxdID0gTW92aW5nQXZlcmFnZShpbnRlcnZhbClcbiAgICAgICAgbWEucHVzaCh0aGlzLl9mcmVxdWVuY3lMYXN0VGltZSwgMClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIHRpbWVyIGlmIHRoZXJlIGFyZSBpdGVtcyBpbiB0aGUgcXVldWUuIFRoaXNcbiAgICogc2hvdWxkIG9ubHkgbmVlZCB0byBiZSBjYWxsZWQgaWYgYFN0YXRzLnN0b3BgIHdhcyBwcmV2aW91c2x5IGNhbGxlZCwgYXNcbiAgICogYFN0YXRzLnB1c2hgIHdpbGwgYWxzbyBzdGFydCB0aGUgcHJvY2Vzc2luZy5cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzdGFydCAoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgdGhpcy5fcmVzZXRDb21wdXRlVGltZW91dCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHByb2Nlc3NpbmcgYW5kIGNvbXB1dGluZyBvZiBzdGF0cyBieSBjbGVhcmluZyB0aGUgaW50ZXJuYWxcbiAgICogdGltZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc3RvcCAoKSB7XG4gICAgaWYgKHRoaXMuX3RpbWVvdXQpIHtcbiAgICAgIHRoaXMuX3RpbWVvdXQuY2xlYXIoKVxuICAgICAgdGhpcy5fdGltZW91dCA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBjdXJyZW50IHN0YXRzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TWFwPHN0cmluZywgU3RhdD59XG4gICAqL1xuICBnZXQgc25hcHNob3QgKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9zdGF0cylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGludGVybmFsIG1vdmluZ0F2ZXJhZ2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheTxNb3ZpbmdBdmVyYWdlPn1cbiAgICovXG4gIGdldCBtb3ZpbmdBdmVyYWdlcyAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX21vdmluZ0F2ZXJhZ2VzKVxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2hlcyB0aGUgZ2l2ZW4gb3BlcmF0aW9uIGRhdGEgdG8gdGhlIHF1ZXVlLCBhbG9uZyB3aXRoIHRoZVxuICAgKiBjdXJyZW50IFRpbWVzdGFtcCwgdGhlbiByZXNldHMgdGhlIHVwZGF0ZSB0aW1lci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvdW50ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluY1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHB1c2ggKGNvdW50ZXIsIGluYykge1xuICAgIHRoaXMuX3F1ZXVlLnB1c2goW2NvdW50ZXIsIGluYywgRGF0ZS5ub3coKV0pXG4gICAgdGhpcy5fcmVzZXRDb21wdXRlVGltZW91dCgpXG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSB0aW1lb3V0IGZvciB0cmlnZ2VyaW5nIHVwZGF0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX3Jlc2V0Q29tcHV0ZVRpbWVvdXQgKCkge1xuICAgIGlmICh0aGlzLl90aW1lb3V0KSB7XG4gICAgICB0aGlzLl90aW1lb3V0LnJlc2NoZWR1bGUodGhpcy5fbmV4dFRpbWVvdXQoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGltZW91dCA9IHJldGltZXIodGhpcy5fdXBkYXRlLCB0aGlzLl9uZXh0VGltZW91dCgpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSB0aW1lb3V0IGZvciB0aGUgbmV4dCB1cGRhdGUgYmFzZWQgb25cbiAgICogdGhlIHVyZ2VuY3kgb2YgdGhlIHVwZGF0ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIF9uZXh0VGltZW91dCAoKSB7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBuZWVkIGZvciBhbiB1cGRhdGUsIGRlcGVuZGluZyBvbiB0aGUgcXVldWUgbGVuZ3RoXG4gICAgY29uc3QgdXJnZW5jeSA9IHRoaXMuX3F1ZXVlLmxlbmd0aCAvIHRoaXMuX29wdGlvbnMuY29tcHV0ZVRocm90dGxlTWF4UXVldWVTaXplXG4gICAgY29uc3QgdGltZW91dCA9IE1hdGgubWF4KHRoaXMuX29wdGlvbnMuY29tcHV0ZVRocm90dGxlVGltZW91dCAqICgxIC0gdXJnZW5jeSksIDApXG4gICAgcmV0dXJuIHRpbWVvdXRcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGVyZSBhcmUgaXRlbXMgaW4gdGhlIHF1ZXVlLCB0aGV5IHdpbGwgd2lsbCBiZSBwcm9jZXNzZWQgYW5kXG4gICAqIHRoZSBmcmVxdWVuY3kgZm9yIGFsbCBpdGVtcyB3aWxsIGJlIHVwZGF0ZWQgYmFzZWQgb24gdGhlIFRpbWVzdGFtcFxuICAgKiBvZiB0aGUgbGFzdCBpdGVtIGluIHRoZSBxdWV1ZS4gVGhlIGB1cGRhdGVgIGV2ZW50IHdpbGwgYWxzbyBiZSBlbWl0dGVkXG4gICAqIHdpdGggdGhlIGxhdGVzdCBzdGF0cy5cbiAgICpcbiAgICogSWYgdGhlcmUgYXJlIG5vIGl0ZW1zIGluIHRoZSBxdWV1ZSwgbm8gYWN0aW9uIGlzIHRha2VuLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF91cGRhdGUgKCkge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsXG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgbGV0IGxhc3RcbiAgICAgIHdoaWxlICh0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgb3AgPSBsYXN0ID0gdGhpcy5fcXVldWUuc2hpZnQoKVxuICAgICAgICB0aGlzLl9hcHBseU9wKG9wKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVGcmVxdWVuY3kobGFzdFsyXSkgLy8gY29udGFpbnMgdGltZXN0YW1wIG9mIGxhc3Qgb3BcblxuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLl9zdGF0cylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yIGVhY2gga2V5IGluIHRoZSBzdGF0cywgdGhlIGZyZXF1bmN5IGFuZCBtb3ZpbmcgYXZlcmFnZXNcbiAgICogd2lsbCBiZSB1cGRhdGVkIHZpYSBTdGF0cy5fdXBkYXRlRnJlcXVlbmN5Rm9yIGJhc2VkIG9uIHRoZSB0aW1lXG4gICAqIGRpZmZlcmVuY2UgYmV0d2VlbiBjYWxscyB0byB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUaW1lc3RhbXB9IGxhdGVzdFRpbWVcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfdXBkYXRlRnJlcXVlbmN5IChsYXRlc3RUaW1lKSB7XG4gICAgY29uc3QgdGltZURpZmYgPSBsYXRlc3RUaW1lIC0gdGhpcy5fZnJlcXVlbmN5TGFzdFRpbWVcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuX3N0YXRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZUZyZXF1ZW5jeUZvcihrZXksIHRpbWVEaWZmLCBsYXRlc3RUaW1lKVxuICAgIH0pXG5cbiAgICB0aGlzLl9mcmVxdWVuY3lMYXN0VGltZSA9IGxhdGVzdFRpbWVcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBgbW92aW5nQXZlcmFnZXNgIGZvciB0aGUgZ2l2ZW4gYGtleWAgYW5kIGFsc29cbiAgICogcmVzZXRzIHRoZSBgZnJlcXVlbmN5QWNjdW11bGF0b3JgIGZvciB0aGUgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVEaWZmTVMgVGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtUaW1lc3RhbXB9IGxhdGVzdFRpbWUgVGltZSBpbiB0aWNrc1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF91cGRhdGVGcmVxdWVuY3lGb3IgKGtleSwgdGltZURpZmZNUywgbGF0ZXN0VGltZSkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fZnJlcXVlbmN5QWNjdW11bGF0b3JzW2tleV0gfHwgMFxuICAgIHRoaXMuX2ZyZXF1ZW5jeUFjY3VtdWxhdG9yc1trZXldID0gMFxuICAgIC8vIGlmIGB0aW1lRGlmZmAgaXMgemVybywgYGh6YCBiZWNvbWVzIEluZmluaXR5LCBzbyB3ZSBmYWxsYmFjayB0byAxbXNcbiAgICBjb25zdCBzYWZlVGltZURpZmYgPSB0aW1lRGlmZk1TIHx8IDFcbiAgICBjb25zdCBoeiA9IChjb3VudCAvIHNhZmVUaW1lRGlmZikgKiAxMDAwXG5cbiAgICBsZXQgbW92aW5nQXZlcmFnZXMgPSB0aGlzLl9tb3ZpbmdBdmVyYWdlc1trZXldXG4gICAgaWYgKCFtb3ZpbmdBdmVyYWdlcykge1xuICAgICAgbW92aW5nQXZlcmFnZXMgPSB0aGlzLl9tb3ZpbmdBdmVyYWdlc1trZXldID0ge31cbiAgICB9XG5cbiAgICBjb25zdCBpbnRlcnZhbHMgPSB0aGlzLl9vcHRpb25zLm1vdmluZ0F2ZXJhZ2VJbnRlcnZhbHNcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJ2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbW92aW5nQXZlcmFnZUludGVydmFsID0gaW50ZXJ2YWxzW2ldXG4gICAgICB2YXIgbW92aW5nQXZlcmFnZSA9IG1vdmluZ0F2ZXJhZ2VzW21vdmluZ0F2ZXJhZ2VJbnRlcnZhbF1cbiAgICAgIGlmICghbW92aW5nQXZlcmFnZSkge1xuICAgICAgICBtb3ZpbmdBdmVyYWdlID0gbW92aW5nQXZlcmFnZXNbbW92aW5nQXZlcmFnZUludGVydmFsXSA9IE1vdmluZ0F2ZXJhZ2UobW92aW5nQXZlcmFnZUludGVydmFsKVxuICAgICAgfVxuICAgICAgbW92aW5nQXZlcmFnZS5wdXNoKGxhdGVzdFRpbWUsIGh6KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgdGhlIGdpdmVuIG9wZXJhdGlvbiwgYG9wYCwgdGhlIHN0YXRzIGFuZCBgZnJlcXVlbmN5QWNjdW11bGF0b3JgXG4gICAqIHdpbGwgYmUgdXBkYXRlZCBvciBpbml0aWFsaXplZCBpZiB0aGV5IGRvbid0IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nLCBudW1iZXI+fSBvcFxuICAgKiBAdGhyb3dzIHtJbnZhbGlkTnVtYmVyfVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9hcHBseU9wIChvcCkge1xuICAgIGNvbnN0IGtleSA9IG9wWzBdXG4gICAgY29uc3QgaW5jID0gb3BbMV1cblxuICAgIGlmICh0eXBlb2YgaW5jICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBudW1iZXI6JywgaW5jKVxuICAgIH1cblxuICAgIGxldCBuXG5cbiAgICBpZiAoIXRoaXMuX3N0YXRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIG4gPSB0aGlzLl9zdGF0c1trZXldID0gQmlnKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSB0aGlzLl9zdGF0c1trZXldXG4gICAgfVxuICAgIHRoaXMuX3N0YXRzW2tleV0gPSBuLnBsdXMoaW5jKVxuXG4gICAgaWYgKCF0aGlzLl9mcmVxdWVuY3lBY2N1bXVsYXRvcnNba2V5XSkge1xuICAgICAgdGhpcy5fZnJlcXVlbmN5QWNjdW11bGF0b3JzW2tleV0gPSAwXG4gICAgfVxuICAgIHRoaXMuX2ZyZXF1ZW5jeUFjY3VtdWxhdG9yc1trZXldICs9IGluY1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdHNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBMUlUgPSByZXF1aXJlKCdoYXNobHJ1JylcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgTGVhc3QgUmVjZW50bHkgVXNlZCBDYWNoZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhTaXplXG4gKiBAcmV0dXJucyB7TFJVQ2FjaGV9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKG1heFNpemUpID0+IHtcbiAgY29uc3QgcGF0Y2hlZCA9IExSVShtYXhTaXplKVxuICBwYXRjaGVkLmRlbGV0ZSA9IHBhdGNoZWQucmVtb3ZlXG4gIHJldHVybiBwYXRjaGVkXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQ29ubmVjdGlvbiA9IHJlcXVpcmUoJ2ludGVyZmFjZS1jb25uZWN0aW9uJykuQ29ubmVjdGlvblxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3B1bGwnKVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwdWxsIHN0cmVhbSB0byBydW4gdGhlIGdpdmVuIENvbm5lY3Rpb24gc3RyZWFtIHRocm91Z2hcbiAqIHRoZSBnaXZlbiBPYnNlcnZlci4gVGhpcyBwcm92aWRlcyBhIHdheSB0byBtb3JlIGVhc2lseSBtb25pdG9yIGNvbm5lY3Rpb25zXG4gKiBhbmQgdGhlaXIgbWV0YWRhdGEuIEEgbmV3IENvbm5lY3Rpb24gd2lsbCBiZSByZXR1cm5lZCB0aGF0IGNvbnRhaW5zXG4gKiBoYXMgdGhlIGF0dGFjaGVkIE9ic2VydmVyLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNwb3J0fSB0cmFuc3BvcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge09ic2VydmVyfSBvYnNlcnZlclxuICogQHJldHVybnMge0Nvbm5lY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKHRyYW5zcG9ydCwgcHJvdG9jb2wsIGNvbm5lY3Rpb24sIG9ic2VydmVyKSA9PiB7XG4gIGNvbnN0IHBlZXJJbmZvID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbm5lY3Rpb24uZ2V0UGVlckluZm8oKGVyciwgcGVlckluZm8pID0+IHtcbiAgICAgIGlmICghZXJyICYmIHBlZXJJbmZvKSB7XG4gICAgICAgIHJlc29sdmUocGVlckluZm8pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXRQZWVySW5mbyA9IGNvbm5lY3Rpb24uc2V0UGVlckluZm9cbiAgICAgIGNvbm5lY3Rpb24uc2V0UGVlckluZm8gPSAocGkpID0+IHtcbiAgICAgICAgc2V0UGVlckluZm8uY2FsbChjb25uZWN0aW9uLCBwaSlcbiAgICAgICAgcmVzb2x2ZShwaSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxuXG4gIGNvbnN0IHN0cmVhbSA9IHtcbiAgICBzb3VyY2U6IHB1bGwoXG4gICAgICBjb25uZWN0aW9uLFxuICAgICAgb2JzZXJ2ZXIuaW5jb21pbmcodHJhbnNwb3J0LCBwcm90b2NvbCwgcGVlckluZm8pKSxcbiAgICBzaW5rOiBwdWxsKFxuICAgICAgb2JzZXJ2ZXIub3V0Z29pbmcodHJhbnNwb3J0LCBwcm90b2NvbCwgcGVlckluZm8pLFxuICAgICAgY29ubmVjdGlvbilcbiAgfVxuXG4gIHJldHVybiBuZXcgQ29ubmVjdGlvbihzdHJlYW0sIGNvbm5lY3Rpb24pXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgRlNNID0gcmVxdWlyZSgnZnNtLWV2ZW50JylcbmNvbnN0IG11bHRpc3RyZWFtID0gcmVxdWlyZSgnbXVsdGlzdHJlYW0tc2VsZWN0JylcbmNvbnN0IHdpdGhJcyA9IHJlcXVpcmUoJ2NsYXNzLWlzJylcblxuY29uc3QgQmFzZUNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL2Jhc2UnKVxuXG5jbGFzcyBJbmNvbWluZ0Nvbm5lY3Rpb25GU00gZXh0ZW5kcyBCYXNlQ29ubmVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yICh7IGNvbm5lY3Rpb24sIF9zd2l0Y2gsIHRyYW5zcG9ydEtleSwgcGVlckluZm8gfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIF9zd2l0Y2gsXG4gICAgICBuYW1lOiBgaW5jOiR7X3N3aXRjaC5fcGVlckluZm8uaWQudG9CNThTdHJpbmcoKS5zbGljZSgwLCA4KX1gXG4gICAgfSlcbiAgICB0aGlzLmNvbm4gPSBjb25uZWN0aW9uXG4gICAgdGhpcy50aGVpclBlZXJJbmZvID0gcGVlckluZm8gfHwgbnVsbFxuICAgIHRoaXMudGhlaXJCNThJZCA9IHRoaXMudGhlaXJQZWVySW5mbyA/IHRoaXMudGhlaXJQZWVySW5mby5pZC50b0I1OFN0cmluZygpIDogbnVsbFxuICAgIHRoaXMub3VyUGVlckluZm8gPSB0aGlzLnN3aXRjaC5fcGVlckluZm9cbiAgICB0aGlzLnRyYW5zcG9ydEtleSA9IHRyYW5zcG9ydEtleVxuICAgIHRoaXMucHJvdG9jb2xNdXhlciA9IHRoaXMuc3dpdGNoLnByb3RvY29sTXV4ZXIodGhpcy50cmFuc3BvcnRLZXkpXG4gICAgdGhpcy5tc0xpc3RlbmVyID0gbmV3IG11bHRpc3RyZWFtLkxpc3RlbmVyKClcblxuICAgIHRoaXMuX3N0YXRlID0gRlNNKCdESUFMRUQnLCB7XG4gICAgICBESVNDT05ORUNURUQ6IHtcbiAgICAgICAgZGlzY29ubmVjdDogJ0RJU0NPTk5FQ1RFRCdcbiAgICAgIH0sXG4gICAgICBESUFMRUQ6IHsgLy8gQmFzZSBjb25uZWN0aW9uIHRvIHBlZXIgZXN0YWJsaXNoZWRcbiAgICAgICAgcHJpdmF0aXplOiAnUFJJVkFUSVpJTkcnLFxuICAgICAgICBlbmNyeXB0OiAnRU5DUllQVElORydcbiAgICAgIH0sXG4gICAgICBQUklWQVRJWklORzogeyAvLyBQcm90ZWN0aW5nIHRoZSBiYXNlIGNvbm5lY3Rpb25cbiAgICAgICAgZG9uZTogJ1BSSVZBVElaRUQnLFxuICAgICAgICBkaXNjb25uZWN0OiAnRElTQ09OTkVDVElORydcbiAgICAgIH0sXG4gICAgICBQUklWQVRJWkVEOiB7IC8vIEJhc2UgY29ubmVjdGlvbiBpcyBwcm90ZWN0ZWRcbiAgICAgICAgZW5jcnlwdDogJ0VOQ1JZUFRJTkcnXG4gICAgICB9LFxuICAgICAgRU5DUllQVElORzogeyAvLyBFbmNyeXB0aW5nIHRoZSBiYXNlIGNvbm5lY3Rpb25cbiAgICAgICAgZG9uZTogJ0VOQ1JZUFRFRCcsXG4gICAgICAgIGRpc2Nvbm5lY3Q6ICdESVNDT05ORUNUSU5HJ1xuICAgICAgfSxcbiAgICAgIEVOQ1JZUFRFRDogeyAvLyBVcGdyYWRpbmcgY291bGQgbm90IGhhcHBlbiwgdGhlIGNvbm5lY3Rpb24gaXMgZW5jcnlwdGVkIGFuZCB3YWl0aW5nXG4gICAgICAgIHVwZ3JhZGU6ICdVUEdSQURJTkcnLFxuICAgICAgICBkaXNjb25uZWN0OiAnRElTQ09OTkVDVElORydcbiAgICAgIH0sXG4gICAgICBVUEdSQURJTkc6IHsgLy8gQXR0ZW1wdGluZyB0byB1cGdyYWRlIHRoZSBjb25uZWN0aW9uIHdpdGggbXV4ZXJzXG4gICAgICAgIGRvbmU6ICdNVVhFRCdcbiAgICAgIH0sXG4gICAgICBNVVhFRDoge1xuICAgICAgICBkaXNjb25uZWN0OiAnRElTQ09OTkVDVElORydcbiAgICAgIH0sXG4gICAgICBESVNDT05ORUNUSU5HOiB7IC8vIFNodXR0aW5nIGRvd24gdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgZG9uZTogJ0RJU0NPTk5FQ1RFRCdcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5fc3RhdGUub24oJ0RJU0NPTk5FQ1RFRCcsICgpID0+IHRoaXMuX29uRGlzY29ubmVjdGVkKCkpXG4gICAgdGhpcy5fc3RhdGUub24oJ1BSSVZBVElaSU5HJywgKCkgPT4gdGhpcy5fb25Qcml2YXRpemluZygpKVxuICAgIHRoaXMuX3N0YXRlLm9uKCdQUklWQVRJWkVEJywgKCkgPT4gdGhpcy5fb25Qcml2YXRpemVkKCkpXG4gICAgdGhpcy5fc3RhdGUub24oJ0VOQ1JZUFRJTkcnLCAoKSA9PiB0aGlzLl9vbkVuY3J5cHRpbmcoKSlcbiAgICB0aGlzLl9zdGF0ZS5vbignRU5DUllQVEVEJywgKCkgPT4ge1xuICAgICAgdGhpcy5sb2coJ3N1Y2Nlc3NmdWxseSBlbmNyeXB0ZWQgY29ubmVjdGlvbiB0byAlcycsIHRoaXMudGhlaXJCNThJZCB8fCAndW5rbm93biBwZWVyJylcbiAgICAgIHRoaXMuZW1pdCgnZW5jcnlwdGVkJywgdGhpcy5jb25uKVxuICAgIH0pXG4gICAgdGhpcy5fc3RhdGUub24oJ1VQR1JBRElORycsICgpID0+IHRoaXMuX29uVXBncmFkaW5nKCkpXG4gICAgdGhpcy5fc3RhdGUub24oJ01VWEVEJywgKCkgPT4ge1xuICAgICAgdGhpcy5sb2coJ3N1Y2Nlc3NmdWxseSBtdXhlZCBjb25uZWN0aW9uIHRvICVzJywgdGhpcy50aGVpckI1OElkIHx8ICd1bmtub3duIHBlZXInKVxuICAgICAgdGhpcy5lbWl0KCdtdXhlZCcsIHRoaXMuY29ubilcbiAgICB9KVxuICAgIHRoaXMuX3N0YXRlLm9uKCdESVNDT05ORUNUSU5HJywgKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhdGUoJ2RvbmUnKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZW5jcnlwdCBgdGhpcy5jb25uYCB3aXRoIHRoZSBTd2l0Y2gncyBjcnlwdG8uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmaXJlcyBJbmNvbWluZ0Nvbm5lY3Rpb25GU00jZXJyb3JcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfb25FbmNyeXB0aW5nICgpIHtcbiAgICB0aGlzLmxvZygnZW5jcnlwdGluZyBjb25uZWN0aW9uIHZpYSAlcycsIHRoaXMuc3dpdGNoLmNyeXB0by50YWcpXG5cbiAgICB0aGlzLm1zTGlzdGVuZXIuYWRkSGFuZGxlcih0aGlzLnN3aXRjaC5jcnlwdG8udGFnLCAocHJvdG9jb2wsIF9jb25uKSA9PiB7XG4gICAgICB0aGlzLmNvbm4gPSB0aGlzLnN3aXRjaC5jcnlwdG8uZW5jcnlwdCh0aGlzLm91clBlZXJJbmZvLmlkLCBfY29ubiwgdW5kZWZpbmVkLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZShlcnIpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uLmdldFBlZXJJbmZvKChfLCBwZWVySW5mbykgPT4ge1xuICAgICAgICAgIHRoaXMudGhlaXJQZWVySW5mbyA9IHBlZXJJbmZvXG4gICAgICAgICAgdGhpcy5fc3RhdGUoJ2RvbmUnKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9LCBudWxsKVxuXG4gICAgLy8gU3RhcnQgaGFuZGxpbmcgdGhlIGNvbm5lY3Rpb25cbiAgICB0aGlzLm1zTGlzdGVuZXIuaGFuZGxlKHRoaXMuY29ubiwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLmVtaXQoJ2NyeXB0byBoYW5kc2hha2luZyBmYWlsZWQnLCBlcnIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIF9vblVwZ3JhZGluZyAoKSB7XG4gICAgdGhpcy5sb2coJ2FkZGluZyB0aGUgcHJvdG9jb2wgbXV4ZXIgdG8gdGhlIGNvbm5lY3Rpb24nKVxuICAgIHRoaXMucHJvdG9jb2xNdXhlcih0aGlzLmNvbm4sIHRoaXMubXNMaXN0ZW5lcilcbiAgICB0aGlzLl9zdGF0ZSgnZG9uZScpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aXRoSXMoSW5jb21pbmdDb25uZWN0aW9uRlNNLCB7XG4gIGNsYXNzTmFtZTogJ0luY29taW5nQ29ubmVjdGlvbkZTTScsXG4gIHN5bWJvbE5hbWU6ICdsaWJwMnAtc3dpdGNoL0luY29taW5nQ29ubmVjdGlvbkZTTSdcbn0pXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJMQUNLX0xJU1RfVFRMOiA1ICogNjAgKiAxZTMsIC8vIEhvdyBsb25nIGJlZm9yZSBhbiBlcnJvcmVkIHBlZXIgY2FuIGJlIGRpYWxlZCBhZ2FpblxuICBCTEFDS19MSVNUX0FUVEVNUFRTOiA1LCAvLyBOdW0gb2YgdW5zdWNjZXNzZnVsIGRpYWxzIGJlZm9yZSBhIHBlZXIgaXMgcGVybWFuZW50bHkgYmxhY2tsaXN0ZWRcbiAgRElBTF9USU1FT1VUOiAzMGUzLCAvLyBIb3cgbG9uZyBpbiBtcyBhIGRpYWwgYXR0ZW1wdCBpcyBhbGxvd2VkIHRvIHRha2VcbiAgTUFYX0NPTERfQ0FMTFM6IDUwLCAvLyBIb3cgbWFueSBkaWFscyB3L28gcHJvdG9jb2xzIHRoYXQgY2FuIGJlIHF1ZXVlZFxuICBNQVhfUEFSQUxMRUxfRElBTFM6IDEwMCwgLy8gTWF4aW11bSBhbGxvd2VkIGNvbmN1cnJlbnQgZGlhbHNcbiAgUVVBUlRFUl9IT1VSOiAxNSAqIDYwZTMsXG4gIFBSSU9SSVRZX0hJR0g6IDEwLFxuICBQUklPUklUWV9MT1c6IDIwXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxuY29uc3QgUXVldWUgPSByZXF1aXJlKCcuL3F1ZXVlJylcbmNvbnN0IHsgRElBTF9BQk9SVEVEIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKVxuY29uc3QgbmV4dFRpY2sgPSByZXF1aXJlKCdhc3luYy9uZXh0VGljaycpXG5jb25zdCByZXRpbWVyID0gcmVxdWlyZSgncmV0aW1lcicpXG5jb25zdCB7IFFVQVJURVJfSE9VUiwgUFJJT1JJVFlfSElHSCB9ID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycDpzd2l0Y2g6ZGlhbDptYW5hZ2VyJylcbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5jbGFzcyBEaWFsUXVldWVNYW5hZ2VyIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N3aXRjaH0gX3N3aXRjaFxuICAgKi9cbiAgY29uc3RydWN0b3IgKF9zd2l0Y2gpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IG5ldyBTZXQoKVxuICAgIHRoaXMuX2NvbGRDYWxsUXVldWUgPSBuZXcgU2V0KClcbiAgICB0aGlzLl9kaWFsaW5nUXVldWVzID0gbmV3IFNldCgpXG4gICAgdGhpcy5fcXVldWVzID0ge31cbiAgICB0aGlzLnN3aXRjaCA9IF9zd2l0Y2hcbiAgICB0aGlzLl9jbGVhbkludGVydmFsID0gcmV0aW1lcih0aGlzLl9jbGVhbi5iaW5kKHRoaXMpLCBRVUFSVEVSX0hPVVIpXG4gICAgdGhpcy5zdGFydCgpXG4gIH1cblxuICAvKipcbiAgICogUnVucyB0aHJvdWdoIGFsbCBxdWV1ZXMsIGFib3J0cyBhbmQgcmVtb3ZlcyB0aGVtIGlmIHRoZXlcbiAgICogYXJlIG5vIGxvbmdlciB2YWxpZC4gQSBxdWV1ZSB0aGF0IGlzIGJsYWNrbGlzdGVkIGluZGVmaW5pdGVseSxcbiAgICogaXMgY29uc2lkZXJlZCBubyBsb25nZXIgdmFsaWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2xlYW4gKCkge1xuICAgIGNvbnN0IHF1ZXVlcyA9IE9iamVjdC52YWx1ZXModGhpcy5fcXVldWVzKVxuICAgIHF1ZXVlcy5mb3JFYWNoKGRpYWxRdWV1ZSA9PiB7XG4gICAgICAvLyBDbGVhciBpZiB0aGUgcXVldWUgaGFzIHJlYWNoZWQgbWF4IGJsYWNrbGlzdFxuICAgICAgaWYgKGRpYWxRdWV1ZS5ibGFja0xpc3RlZCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgZGlhbFF1ZXVlLmFib3J0KClcbiAgICAgICAgZGVsZXRlIHRoaXMuX3F1ZXVlc1tkaWFsUXVldWUuaWRdXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIGJsYWNrbGlzdGVkIHF1ZXVlc1xuICAgICAgaWYgKGRpYWxRdWV1ZS5ibGFja0xpc3RlZCkgcmV0dXJuXG5cbiAgICAgIC8vIENsZWFyIGlmIHBlZXIgaXMgbm8gbG9uZ2VyIGFjdGl2ZVxuICAgICAgLy8gVG8gYXZvaWQgcmVhbGxvY2F0aW5nIG1lbW9yeSwgZG9udCBkZWxldGUgcXVldWVzIG9mXG4gICAgICAvLyBjb25uZWN0ZWQgcGVlcnMsIGFzIHRoZXNlIGFyZSBoaWdobHkgbGlrZWx5IHRvIGxldmVyYWdlIHRoZVxuICAgICAgLy8gcXVldWVzIGluIHRoZSBpbW1lZGlhdGUgdGVybVxuICAgICAgaWYgKCFkaWFsUXVldWUuaXNSdW5uaW5nICYmIGRpYWxRdWV1ZS5sZW5ndGggPCAxKSB7XG4gICAgICAgIGxldCBpc0Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGVlckluZm8gPSB0aGlzLnN3aXRjaC5fcGVlckJvb2suZ2V0KGRpYWxRdWV1ZS5pZClcbiAgICAgICAgICBpc0Nvbm5lY3RlZCA9IEJvb2xlYW4ocGVlckluZm8uaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIC8vIElmIHdlIGdldCBhbiBlcnJvciwgdGhhdCBtZWFucyB0aGUgcGVlcmJvb2sgZG9lc250IGhhdmUgdGhlIHBlZXJcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICBkaWFsUXVldWUuYWJvcnQoKVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9xdWV1ZXNbZGlhbFF1ZXVlLmlkXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuX2NsZWFuSW50ZXJ2YWwucmVzY2hlZHVsZShRVUFSVEVSX0hPVVIpXG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHRoZSBgRGlhbFF1ZXVlTWFuYWdlcmAgdG8gZXhlY3V0ZSBkaWFsc1xuICAgKi9cbiAgc3RhcnQgKCkge1xuICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgYWxsIGl0ZW1zIGluIHRoZSBEaWFsZXJRdWV1ZVxuICAgKiBhbmQgZXhlY3V0ZXMgdGhlcmUgY2FsbGJhY2sgd2l0aCBhbiBlcnJvci5cbiAgICpcbiAgICogVGhpcyBjYXVzZXMgdGhlIGVudGlyZSBEaWFsZXJRdWV1ZSB0byBiZSBkcmFpbmVkXG4gICAqL1xuICBzdG9wICgpIHtcbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlXG4gICAgLy8gQ2xlYXIgdGhlIGdlbmVyYWwgcXVldWVcbiAgICB0aGlzLl9xdWV1ZS5jbGVhcigpXG4gICAgLy8gQ2xlYXIgdGhlIGNvbGQgY2FsbCBxdWV1ZVxuICAgIHRoaXMuX2NvbGRDYWxsUXVldWUuY2xlYXIoKVxuXG4gICAgdGhpcy5fY2xlYW5JbnRlcnZhbC5jbGVhcigpXG5cbiAgICAvLyBBYm9ydCB0aGUgaW5kaXZpZHVhbCBwZWVyIHF1ZXVlc1xuICAgIGNvbnN0IHF1ZXVlcyA9IE9iamVjdC52YWx1ZXModGhpcy5fcXVldWVzKVxuICAgIHF1ZXVlcy5mb3JFYWNoKGRpYWxRdWV1ZSA9PiB7XG4gICAgICBkaWFsUXVldWUuYWJvcnQoKVxuICAgICAgZGVsZXRlIHRoaXMuX3F1ZXVlc1tkaWFsUXVldWUuaWRdXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBgZGlhbFJlcXVlc3RgIHRvIHRoZSBxdWV1ZSBhbmQgZW5zdXJlcyBxdWV1ZSBpcyBydW5uaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7RGlhbFJlcXVlc3R9IGRpYWxSZXF1ZXN0XG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgYWRkICh7IHBlZXJJbmZvLCBwcm90b2NvbCwgb3B0aW9ucywgY2FsbGJhY2sgfSkge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBvbmNlKGNhbGxiYWNrKSA6IG5vb3BcblxuICAgIC8vIEFkZCB0aGUgZGlhbCB0byBpdHMgcmVzcGVjdGl2ZSBxdWV1ZVxuICAgIGNvbnN0IHRhcmdldFF1ZXVlID0gdGhpcy5nZXRRdWV1ZShwZWVySW5mbylcblxuICAgIC8vIENvbGQgQ2FsbFxuICAgIGlmIChvcHRpb25zLnByaW9yaXR5ID4gUFJJT1JJVFlfSElHSCkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSB0b28gbWFueSBjb2xkIGNhbGxzLCBhYm9ydCB0aGUgZGlhbCBpbW1lZGlhdGVseVxuICAgICAgaWYgKHRoaXMuX2NvbGRDYWxsUXVldWUuc2l6ZSA+PSB0aGlzLnN3aXRjaC5kaWFsZXIuTUFYX0NPTERfQ0FMTFMpIHtcbiAgICAgICAgcmV0dXJuIG5leHRUaWNrKGNhbGxiYWNrLCBESUFMX0FCT1JURUQoKSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3F1ZXVlLmhhcyh0YXJnZXRRdWV1ZS5pZCkpIHtcbiAgICAgICAgcmV0dXJuIG5leHRUaWNrKGNhbGxiYWNrLCBESUFMX0FCT1JURUQoKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0YXJnZXRRdWV1ZS5hZGQocHJvdG9jb2wsIG9wdGlvbnMudXNlRlNNLCBjYWxsYmFjaylcblxuICAgIC8vIElmIHdlJ3JlIGFscmVhZHkgY29ubmVjdGVkIHRvIHRoZSBwZWVyLCBzdGFydCB0aGUgcXVldWUgbm93XG4gICAgLy8gV2hpbGUgaXQgbWlnaHQgY2F1c2UgcXVldWVzIHRvIGdvIG92ZXIgdGhlIG1heCBwYXJhbGxlbCBhbW91bnQsXG4gICAgLy8gaXQgYXZvaWRzIGJsb2NraW5nIHBlZXJzIHdlJ3JlIGFscmVhZHkgY29ubmVjdGVkIHRvXG4gICAgaWYgKHBlZXJJbmZvLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRhcmdldFF1ZXVlLnN0YXJ0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIGRpYWxpbmcgaXMgbm90IGFsbG93ZWQsIGFib3J0XG4gICAgaWYgKCF0YXJnZXRRdWV1ZS5pc0RpYWxBbGxvd2VkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgaWQgdG8gaXRzIHJlc3BlY3RpdmUgcXVldWUgc2V0IGlmIHRoZSBxdWV1ZSBpc24ndCBydW5uaW5nXG4gICAgaWYgKCF0YXJnZXRRdWV1ZS5pc1J1bm5pbmcpIHtcbiAgICAgIGlmIChvcHRpb25zLnByaW9yaXR5IDw9IFBSSU9SSVRZX0hJR0gpIHtcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKHRhcmdldFF1ZXVlLmlkKVxuICAgICAgICB0aGlzLl9jb2xkQ2FsbFF1ZXVlLmRlbGV0ZSh0YXJnZXRRdWV1ZS5pZClcbiAgICAgIC8vIE9ubHkgYWRkIGl0IHRvIHRoZSBjb2xkIHF1ZXVlIGlmIGl0J3Mgbm90IGluIHRoZSBub3JtYWwgcXVldWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbGRDYWxsUXVldWUuYWRkKHRhcmdldFF1ZXVlLmlkKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucnVuKClcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIGV4ZWN1dGUgdXAgdG8gYE1BWF9QQVJBTExFTF9ESUFMU2AgZGlhbHNcbiAgICovXG4gIHJ1biAoKSB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5fZGlhbGluZ1F1ZXVlcy5zaXplIDwgdGhpcy5zd2l0Y2guZGlhbGVyLk1BWF9QQVJBTExFTF9ESUFMUykge1xuICAgICAgbGV0IG5leHRRdWV1ZSA9IHsgZG9uZTogdHJ1ZSB9XG4gICAgICAvLyBDaGVjayB0aGUgcXVldWUgZmlyc3QgYW5kIGZhbGwgYmFjayB0byB0aGUgY29sZCBjYWxsIHF1ZXVlXG4gICAgICBpZiAodGhpcy5fcXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgbmV4dFF1ZXVlID0gdGhpcy5fcXVldWUudmFsdWVzKCkubmV4dCgpXG4gICAgICAgIHRoaXMuX3F1ZXVlLmRlbGV0ZShuZXh0UXVldWUudmFsdWUpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2NvbGRDYWxsUXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgbmV4dFF1ZXVlID0gdGhpcy5fY29sZENhbGxRdWV1ZS52YWx1ZXMoKS5uZXh0KClcbiAgICAgICAgdGhpcy5fY29sZENhbGxRdWV1ZS5kZWxldGUobmV4dFF1ZXVlLnZhbHVlKVxuICAgICAgfVxuXG4gICAgICBpZiAobmV4dFF1ZXVlLmRvbmUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxldCB0YXJnZXRRdWV1ZSA9IHRoaXMuX3F1ZXVlc1tuZXh0UXVldWUudmFsdWVdXG5cbiAgICAgIGlmICghdGFyZ2V0UXVldWUpIHtcbiAgICAgICAgbG9nKCdtaXNzaW5nIHF1ZXVlICVzLCBtYXliZSBpdCB3YXMgYWJvcnRlZD8nLCBuZXh0UXVldWUudmFsdWUpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLl9kaWFsaW5nUXVldWVzLmFkZCh0YXJnZXRRdWV1ZS5pZClcbiAgICAgIHRhcmdldFF1ZXVlLnN0YXJ0KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2lsbCByZW1vdmUgdGhlIGBwZWVySW5mb2AgZnJvbSB0aGUgZGlhbCBibGFja2xpc3RcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlckluZm9cbiAgICovXG4gIGNsZWFyQmxhY2tsaXN0IChwZWVySW5mbykge1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5nZXRRdWV1ZShwZWVySW5mbylcbiAgICBxdWV1ZS5ibGFja0xpc3RlZCA9IG51bGxcbiAgICBxdWV1ZS5ibGFja0xpc3RDb3VudCA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhhbmRsZXIgZm9yIHdoZW4gZGlhbGluZyBxdWV1ZXMgc3RvcC4gVGhpcyB3aWxsIHRyaWdnZXJcbiAgICogYHJ1bigpYCBpbiBvcmRlciB0byBrZWVwIHRoZSBxdWV1ZSBwcm9jZXNzaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgcGVlciBpZCBvZiB0aGUgcXVldWUgdGhhdCBzdG9wcGVkXG4gICAqL1xuICBfb25RdWV1ZVN0b3BwZWQgKGlkKSB7XG4gICAgdGhpcy5fZGlhbGluZ1F1ZXVlcy5kZWxldGUoaWQpXG4gICAgdGhpcy5ydW4oKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBRdWV1ZWAgZm9yIHRoZSBnaXZlbiBgcGVlckluZm9gXG4gICAqIEBwYXJhbSB7UGVlckluZm99IHBlZXJJbmZvXG4gICAqIEByZXR1cm5zIHtRdWV1ZX1cbiAgICovXG4gIGdldFF1ZXVlIChwZWVySW5mbykge1xuICAgIGNvbnN0IGlkID0gcGVlckluZm8uaWQudG9CNThTdHJpbmcoKVxuXG4gICAgdGhpcy5fcXVldWVzW2lkXSA9IHRoaXMuX3F1ZXVlc1tpZF0gfHwgbmV3IFF1ZXVlKGlkLCB0aGlzLnN3aXRjaCwgdGhpcy5fb25RdWV1ZVN0b3BwZWQuYmluZCh0aGlzKSlcbiAgICByZXR1cm4gdGhpcy5fcXVldWVzW2lkXVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlhbFF1ZXVlTWFuYWdlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IElkZW50aWZ5ID0gcmVxdWlyZSgnbGlicDJwLWlkZW50aWZ5JylcblxuLyoqXG4gKiBGb3IgYSBnaXZlbiBtdWx0aXN0cmVhbSwgcmVnaXN0ZXJzIHRvIGhhbmRsZSB0aGUgZ2l2ZW4gY29ubmVjdGlvblxuICogQHBhcmFtIHtNdWx0aXN0cmVhbURpYWxlcn0gbXVsdGlzdHJlYW1cbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbm1vZHVsZS5leHBvcnRzLm1zSGFuZGxlID0gKG11bHRpc3RyZWFtLCBjb25uZWN0aW9uKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbXVsdGlzdHJlYW0uaGFuZGxlKGNvbm5lY3Rpb24sIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSlcbiAgfSlcbn1cblxuLyoqXG4gKiBGb3IgYSBnaXZlbiBtdWx0aXN0cmVhbSwgc2VsZWN0cyB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBwYXJhbSB7TXVsdGlzdHJlYW1EaWFsZXJ9IG11bHRpc3RyZWFtXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXNvbHZlcyB0aGUgc2VsZWN0ZWQgQ29ubmVjdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cy5tc1NlbGVjdCA9IChtdWx0aXN0cmVhbSwgcHJvdG9jb2wpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBtdWx0aXN0cmVhbS5zZWxlY3QocHJvdG9jb2wsIChlcnIsIGNvbm5lY3Rpb24pID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZShjb25uZWN0aW9uKVxuICAgIH0pXG4gIH0pXG59XG5cbi8qKlxuICogUnVucyBpZGVudGlmeSBmb3IgdGhlIGdpdmVuIGNvbm5lY3Rpb24gYW5kIHZlcmlmaWVzIGl0IGFnYWluc3QgdGhlXG4gKiBQZWVySW5mbyBwcm92aWRlZFxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge1BlZXJJbmZvfSBjcnlwdG9QZWVySW5mbyBUaGUgUGVlckluZm8gZGV0ZXJtaW5lZCBkdXJpbmcgY3J5cHRvIGV4Y2hhbmdlXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUmVzb2x2ZXMge3BlZXJJbmZvLCBvYnNlcnZlZEFkZHJzfVxuICovXG5tb2R1bGUuZXhwb3J0cy5pZGVudGlmeURpYWxlciA9IChjb25uZWN0aW9uLCBjcnlwdG9QZWVySW5mbykgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIElkZW50aWZ5LmRpYWxlcihjb25uZWN0aW9uLCBjcnlwdG9QZWVySW5mbywgKGVyciwgcGVlckluZm8sIG9ic2VydmVkQWRkcnMpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IHBlZXJJbmZvLCBvYnNlcnZlZEFkZHJzIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLyoqXG4gKiBHZXQgdW5pcXVlIHZhbHVlcyBmcm9tIGBhcnJgIHVzaW5nIGBnZXRWYWx1ZWAgdG8gZGV0ZXJtaW5lXG4gKiB3aGF0IGlzIHVzZWQgZm9yIHVuaXF1ZW5lc3NcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBUaGUgYXJyYXkgdG8gZ2V0IHVuaXF1ZSB2YWx1ZXMgZm9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlKX0gZ2V0VmFsdWUgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGF0IGlzIGNvbXBhcmVkXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbm1vZHVsZS5leHBvcnRzLnVuaXF1ZUJ5ID0gKGFyciwgZ2V0VmFsdWUpID0+IHtcbiAgcmV0dXJuIFsuLi5uZXcgTWFwKGFyci5tYXAoKGkpID0+IFtnZXRWYWx1ZShpKSwgaV0pKS52YWx1ZXMoKV1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLkxpc3RlbmVyID0gZXhwb3J0cy5saXN0ZW5lciA9IHJlcXVpcmUoJy4vbGlzdGVuZXInKVxuZXhwb3J0cy5EaWFsZXIgPSBleHBvcnRzLmRpYWxlciA9IHJlcXVpcmUoJy4vZGlhbGVyJylcbmV4cG9ydHMubWF0Y2hTZW12ZXIgPSByZXF1aXJlKCcuL2xpc3RlbmVyL21hdGNoLXNlbXZlcicpXG5leHBvcnRzLm1hdGNoRXhhY3QgPSByZXF1aXJlKCcuL2xpc3RlbmVyL21hdGNoLWV4YWN0JylcbmV4cG9ydHMuY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEZTTSA9IHJlcXVpcmUoJ2ZzbS1ldmVudCcpXG5jb25zdCBDaXJjdWl0ID0gcmVxdWlyZSgnbGlicDJwLWNpcmN1aXQnKVxuY29uc3QgbXVsdGlzdHJlYW0gPSByZXF1aXJlKCdtdWx0aXN0cmVhbS1zZWxlY3QnKVxuY29uc3Qgd2l0aElzID0gcmVxdWlyZSgnY2xhc3MtaXMnKVxuY29uc3QgQmFzZUNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL2Jhc2UnKVxuY29uc3QgcGFyYWxsZWwgPSByZXF1aXJlKCdhc3luYy9wYXJhbGxlbCcpXG5jb25zdCBuZXh0VGljayA9IHJlcXVpcmUoJ2FzeW5jL25leHRUaWNrJylcbmNvbnN0IGlkZW50aWZ5ID0gcmVxdWlyZSgnbGlicDJwLWlkZW50aWZ5JylcbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCB7IG1zSGFuZGxlLCBtc1NlbGVjdCwgaWRlbnRpZnlEaWFsZXIgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJylcblxuY29uc3Qgb2JzZXJ2ZUNvbm5lY3Rpb24gPSByZXF1aXJlKCcuLi9vYnNlcnZlLWNvbm5lY3Rpb24nKVxuY29uc3Qge1xuICBDT05ORUNUSU9OX0ZBSUxFRCxcbiAgRElBTF9TRUxGLFxuICBJTlZBTElEX1NUQVRFX1RSQU5TSVRJT04sXG4gIE5PX1RSQU5TUE9SVFNfUkVHSVNURVJFRCxcbiAgbWF5YmVVbmV4cGVjdGVkRW5kXG59ID0gcmVxdWlyZSgnLi4vZXJyb3JzJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb25uZWN0aW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtTd2l0Y2h9IF9zd2l0Y2ggT3VyIHN3aXRjaCBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtQZWVySW5mb30gcGVlckluZm8gVGhlIFBlZXJJbmZvIG9mIHRoZSBwZWVyIHRvIGRpYWxcbiAqIEBwcm9wZXJ0eSB7TXV4ZXJ9IG11eGVyIE9wdGlvbmFsIC0gQSBtdXhlZCBjb25uZWN0aW9uXG4gKiBAcHJvcGVydHkge0Nvbm5lY3Rpb259IGNvbm4gT3B0aW9uYWwgLSBUaGUgYmFzZSBjb25uZWN0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBPcHRpb25hbCAtIGlkZW50aWZ5IHRoZSBjb25uZWN0aW9uIGFzIGluY29taW5nIG9yIG91dGdvaW5nLiBEZWZhdWx0cyB0byBvdXQuXG4gKi9cblxuLyoqXG4gKiBDb25uZWN0aW9uRlNNIGhhbmRsZXMgdGhlIGNvbXBsZXggbG9naWMgb2YgbWFuYWdpbmcgYSBjb25uZWN0aW9uXG4gKiBiZXR3ZWVuIHBlZXJzLiBDb25uZWN0aW9uRlNNIGlzIGludGVybmFsbHkgY29tcG9zZWQgb2YgYSBzdGF0ZSBtYWNoaW5lXG4gKiB0byBoZWxwIGltcHJvdmUgdGhlIHVzYWJpbGl0eSBhbmQgZGVidWdnYWJpbGl0eSBvZiBjb25uZWN0aW9ucy4gVGhlXG4gKiBzdGF0ZSBtYWNoaW5lIGFsc28gaGVscHMgdG8gaW1wcm92ZSB0aGUgYWJpbGl0eSB0byBoYW5kbGUgZGlhbCBiYWNrb2ZmLFxuICogY29hbGVzY2luZyBkaWFscyBhbmQgZGlhbCBsb2Nrcy5cbiAqL1xuY2xhc3MgQ29ubmVjdGlvbkZTTSBleHRlbmRzIEJhc2VDb25uZWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbk9wdGlvbnN9IGNvbm5lY3Rpb25PcHRpb25zXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHsgX3N3aXRjaCwgcGVlckluZm8sIG11eGVyLCBjb25uLCB0eXBlID0gJ291dCcgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIF9zd2l0Y2gsXG4gICAgICBuYW1lOiBgJHt0eXBlfToke19zd2l0Y2guX3BlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKCkuc2xpY2UoMCwgOCl9YFxuICAgIH0pXG5cbiAgICB0aGlzLnRoZWlyUGVlckluZm8gPSBwZWVySW5mb1xuICAgIHRoaXMudGhlaXJCNThJZCA9IHRoaXMudGhlaXJQZWVySW5mby5pZC50b0I1OFN0cmluZygpXG5cbiAgICB0aGlzLmNvbm4gPSBjb25uIC8vIFRoZSBiYXNlIGNvbm5lY3Rpb25cbiAgICB0aGlzLm11eGVyID0gbXV4ZXIgLy8gVGhlIHVwZ3JhZGVkL211eGVkIGNvbm5lY3Rpb25cblxuICAgIGxldCBzdGFydFN0YXRlID0gJ0RJU0NPTk5FQ1RFRCdcbiAgICBpZiAodGhpcy5tdXhlcikge1xuICAgICAgc3RhcnRTdGF0ZSA9ICdNVVhFRCdcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0ZSA9IEZTTShzdGFydFN0YXRlLCB7XG4gICAgICBESVNDT05ORUNURUQ6IHsgLy8gTm8gYWN0aXZlIGNvbm5lY3Rpb25zIGV4aXN0IGZvciB0aGUgcGVlclxuICAgICAgICBkaWFsOiAnRElBTElORycsXG4gICAgICAgIGRpc2Nvbm5lY3Q6ICdESVNDT05ORUNURUQnLFxuICAgICAgICBkb25lOiAnRElTQ09OTkVDVEVEJ1xuICAgICAgfSxcbiAgICAgIERJQUxJTkc6IHsgLy8gQ3JlYXRpbmcgYW4gaW5pdGlhbCBjb25uZWN0aW9uXG4gICAgICAgIGFib3J0OiAnQUJPUlRFRCcsXG4gICAgICAgIC8vIGVtaXQgZXZlbnRzIGZvciBkaWZmZXJlbnQgdHJhbnNwb3J0IGRpYWxzP1xuICAgICAgICBkb25lOiAnRElBTEVEJyxcbiAgICAgICAgZXJyb3I6ICdFUlJPUkVEJyxcbiAgICAgICAgZGlzY29ubmVjdDogJ0RJU0NPTk5FQ1RJTkcnXG4gICAgICB9LFxuICAgICAgRElBTEVEOiB7IC8vIEJhc2UgY29ubmVjdGlvbiB0byBwZWVyIGVzdGFibGlzaGVkXG4gICAgICAgIGVuY3J5cHQ6ICdFTkNSWVBUSU5HJyxcbiAgICAgICAgcHJpdmF0aXplOiAnUFJJVkFUSVpJTkcnXG4gICAgICB9LFxuICAgICAgUFJJVkFUSVpJTkc6IHsgLy8gUHJvdGVjdGluZyB0aGUgYmFzZSBjb25uZWN0aW9uXG4gICAgICAgIGRvbmU6ICdQUklWQVRJWkVEJyxcbiAgICAgICAgYWJvcnQ6ICdBQk9SVEVEJyxcbiAgICAgICAgZGlzY29ubmVjdDogJ0RJU0NPTk5FQ1RJTkcnXG4gICAgICB9LFxuICAgICAgUFJJVkFUSVpFRDogeyAvLyBCYXNlIGNvbm5lY3Rpb24gaXMgcHJvdGVjdGVkXG4gICAgICAgIGVuY3J5cHQ6ICdFTkNSWVBUSU5HJ1xuICAgICAgfSxcbiAgICAgIEVOQ1JZUFRJTkc6IHsgLy8gRW5jcnlwdGluZyB0aGUgYmFzZSBjb25uZWN0aW9uXG4gICAgICAgIGRvbmU6ICdFTkNSWVBURUQnLFxuICAgICAgICBlcnJvcjogJ0VSUk9SRUQnLFxuICAgICAgICBkaXNjb25uZWN0OiAnRElTQ09OTkVDVElORydcbiAgICAgIH0sXG4gICAgICBFTkNSWVBURUQ6IHsgLy8gVXBncmFkaW5nIGNvdWxkIG5vdCBoYXBwZW4sIHRoZSBjb25uZWN0aW9uIGlzIGVuY3J5cHRlZCBhbmQgd2FpdGluZ1xuICAgICAgICB1cGdyYWRlOiAnVVBHUkFESU5HJyxcbiAgICAgICAgZGlzY29ubmVjdDogJ0RJU0NPTk5FQ1RJTkcnXG4gICAgICB9LFxuICAgICAgVVBHUkFESU5HOiB7IC8vIEF0dGVtcHRpbmcgdG8gdXBncmFkZSB0aGUgY29ubmVjdGlvbiB3aXRoIG11eGVyc1xuICAgICAgICBzdG9wOiAnQ09OTkVDVEVEJywgLy8gSWYgd2UgY2Fubm90IG11eCwgc3RvcCB1cGdyYWRpbmdcbiAgICAgICAgZG9uZTogJ01VWEVEJyxcbiAgICAgICAgZXJyb3I6ICdFUlJPUkVEJyxcbiAgICAgICAgZGlzY29ubmVjdDogJ0RJU0NPTk5FQ1RJTkcnXG4gICAgICB9LFxuICAgICAgTVVYRUQ6IHtcbiAgICAgICAgZGlzY29ubmVjdDogJ0RJU0NPTk5FQ1RJTkcnXG4gICAgICB9LFxuICAgICAgQ09OTkVDVEVEOiB7IC8vIEEgbm9uIG11eGVkIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWRcbiAgICAgICAgZGlzY29ubmVjdDogJ0RJU0NPTk5FQ1RJTkcnXG4gICAgICB9LFxuICAgICAgRElTQ09OTkVDVElORzogeyAvLyBTaHV0dGluZyBkb3duIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIGRvbmU6ICdESVNDT05ORUNURUQnLFxuICAgICAgICBkaXNjb25uZWN0OiAnRElTQ09OTkVDVElORydcbiAgICAgIH0sXG4gICAgICBBQk9SVEVEOiB7IH0sIC8vIEEgc2V2ZXJlIGV2ZW50IG9jY3VycmVkXG4gICAgICBFUlJPUkVEOiB7IC8vIEFuIGVycm9yIG9jY3VycmVkLCBidXQgZnV0dXJlIGRpYWxzIG1heSBiZSBhbGxvd2VkXG4gICAgICAgIGRpc2Nvbm5lY3Q6ICdESVNDT05ORUNUSU5HJyAvLyBUaGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBvcHRpb25zIGhlcmUsIGJ1dCB0aGlzIGlzIGEgbGlrZWx5IGFjdGlvblxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLl9zdGF0ZS5vbignRElTQ09OTkVDVEVEJywgKCkgPT4gdGhpcy5fb25EaXNjb25uZWN0ZWQoKSlcbiAgICB0aGlzLl9zdGF0ZS5vbignRElBTElORycsICgpID0+IHRoaXMuX29uRGlhbGluZygpKVxuICAgIHRoaXMuX3N0YXRlLm9uKCdESUFMRUQnLCAoKSA9PiB0aGlzLl9vbkRpYWxlZCgpKVxuICAgIHRoaXMuX3N0YXRlLm9uKCdQUklWQVRJWklORycsICgpID0+IHRoaXMuX29uUHJpdmF0aXppbmcoKSlcbiAgICB0aGlzLl9zdGF0ZS5vbignUFJJVkFUSVpFRCcsICgpID0+IHRoaXMuX29uUHJpdmF0aXplZCgpKVxuICAgIHRoaXMuX3N0YXRlLm9uKCdFTkNSWVBUSU5HJywgKCkgPT4gdGhpcy5fb25FbmNyeXB0aW5nKCkpXG4gICAgdGhpcy5fc3RhdGUub24oJ0VOQ1JZUFRFRCcsICgpID0+IHtcbiAgICAgIHRoaXMubG9nKCdzdWNjZXNzZnVsbHkgZW5jcnlwdGVkIGNvbm5lY3Rpb24gdG8gJXMnLCB0aGlzLnRoZWlyQjU4SWQpXG4gICAgICB0aGlzLmVtaXQoJ2VuY3J5cHRlZCcsIHRoaXMuY29ubilcbiAgICB9KVxuICAgIHRoaXMuX3N0YXRlLm9uKCdVUEdSQURJTkcnLCAoKSA9PiB0aGlzLl9vblVwZ3JhZGluZygpKVxuICAgIHRoaXMuX3N0YXRlLm9uKCdNVVhFRCcsICgpID0+IHtcbiAgICAgIHRoaXMubG9nKCdzdWNjZXNzZnVsbHkgbXV4ZWQgY29ubmVjdGlvbiB0byAlcycsIHRoaXMudGhlaXJCNThJZClcbiAgICAgIGRlbGV0ZSB0aGlzLnN3aXRjaC5jb25uc1t0aGlzLnRoZWlyQjU4SWRdXG4gICAgICB0aGlzLmVtaXQoJ211eGVkJywgdGhpcy5tdXhlcilcbiAgICB9KVxuICAgIHRoaXMuX3N0YXRlLm9uKCdDT05ORUNURUQnLCAoKSA9PiB7XG4gICAgICB0aGlzLmxvZygndW5tdXhlZCBjb25uZWN0aW9uIG9wZW5lZCB0byAlcycsIHRoaXMudGhlaXJCNThJZClcbiAgICAgIHRoaXMuZW1pdCgndW5tdXhlZCcsIHRoaXMuY29ubilcbiAgICB9KVxuICAgIHRoaXMuX3N0YXRlLm9uKCdESVNDT05ORUNUSU5HJywgKCkgPT4gdGhpcy5fb25EaXNjb25uZWN0aW5nKCkpXG4gICAgdGhpcy5fc3RhdGUub24oJ0FCT1JURUQnLCAoKSA9PiB0aGlzLl9vbkFib3J0ZWQoKSlcbiAgICB0aGlzLl9zdGF0ZS5vbignRVJST1JFRCcsICgpID0+IHRoaXMuX29uRXJyb3JlZCgpKVxuICAgIHRoaXMuX3N0YXRlLm9uKCdlcnJvcicsIChlcnIpID0+IHRoaXMuX29uU3RhdGVFcnJvcihlcnIpKVxuICB9XG5cbiAgLyoqXG4gICAqIFB1dHMgdGhlIHN0YXRlIGludG8gZGlhbGluZyBtb2RlXG4gICAqXG4gICAqIEBmaXJlcyBDb25uZWN0aW9uRlNNI0Vycm9yIE1heSBlbWl0IGEgRElBTF9TRUxGIGVycm9yXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZGlhbCAoKSB7XG4gICAgaWYgKHRoaXMudGhlaXJCNThJZCA9PT0gdGhpcy5vdXJQZWVySW5mby5pZC50b0I1OFN0cmluZygpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIERJQUxfU0VMRigpKVxuICAgIH0gZWxzZSBpZiAodGhpcy5nZXRTdGF0ZSgpID09PSAnRElBTElORycpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvZygnYXR0ZW1wdGVkIHRvIGRpYWwgd2hpbGUgYWxyZWFkeSBkaWFsaW5nLCBpZ25vcmluZycpXG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUoJ2RpYWwnKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIGhhbmRzaGFrZSBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbCBUaGUgcHJvdG9jb2wgdG8gbmVnb3RpYXRlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIENvbm5lY3Rpb24pfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHNoYWtlIChwcm90b2NvbCwgY2FsbGJhY2spIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBwcm90b2NvbCBzZXQgeWV0LCBkb24ndCBwZXJmb3JtIHRoZSBoYW5kc2hha2VcbiAgICBpZiAoIXByb3RvY29sKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tdXhlciAmJiB0aGlzLm11eGVyLm5ld1N0cmVhbSkge1xuICAgICAgcmV0dXJuIHRoaXMubXV4ZXIubmV3U3RyZWFtKChlcnIsIHN0cmVhbSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVsbClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubG9nKCdjcmVhdGVkIG5ldyBzdHJlYW0gdG8gJXMnLCB0aGlzLnRoZWlyQjU4SWQpXG4gICAgICAgIHRoaXMuX3Byb3RvY29sSGFuZHNoYWtlKHByb3RvY29sLCBzdHJlYW0sIGNhbGxiYWNrKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLl9wcm90b2NvbEhhbmRzaGFrZShwcm90b2NvbCwgdGhpcy5jb25uLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXRzIHRoZSBzdGF0ZSBpbnRvIG11eGluZyBtb2RlXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgdXBncmFkZSAoKSB7XG4gICAgdGhpcy5fc3RhdGUoJ3VwZ3JhZGUnKVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGRpYWxpbmcuIFRyYW5zaXRpb25zIHN0YXRlIHdoZW4gc3VjY2Vzc2Z1bC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzIENvbm5lY3Rpb25GU00jZXJyb3JcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfb25EaWFsaW5nICgpIHtcbiAgICB0aGlzLmxvZygnZGlhbGluZyAlcycsIHRoaXMudGhlaXJCNThJZClcblxuICAgIGlmICghdGhpcy5zd2l0Y2guaGFzVHJhbnNwb3J0cygpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9zZShOT19UUkFOU1BPUlRTX1JFR0lTVEVSRUQoKSlcbiAgICB9XG5cbiAgICBjb25zdCB0S2V5cyA9IHRoaXMuc3dpdGNoLmF2YWlsYWJsZVRyYW5zcG9ydHModGhpcy50aGVpclBlZXJJbmZvKVxuXG4gICAgY29uc3QgY2lyY3VpdEVuYWJsZWQgPSBCb29sZWFuKHRoaXMuc3dpdGNoLnRyYW5zcG9ydHNbQ2lyY3VpdC50YWddKVxuXG4gICAgaWYgKGNpcmN1aXRFbmFibGVkICYmICF0S2V5cy5pbmNsdWRlcyhDaXJjdWl0LnRhZykpIHtcbiAgICAgIHRLZXlzLnB1c2goQ2lyY3VpdC50YWcpXG4gICAgfVxuXG4gICAgY29uc3QgbmV4dFRyYW5zcG9ydCA9IChrZXkpID0+IHtcbiAgICAgIGxldCB0cmFuc3BvcnQgPSBrZXlcbiAgICAgIGlmICghdHJhbnNwb3J0KSB7XG4gICAgICAgIGlmICghY2lyY3VpdEVuYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZShcbiAgICAgICAgICAgIENPTk5FQ1RJT05fRkFJTEVEKGBDaXJjdWl0IG5vdCBlbmFibGVkIGFuZCBhbGwgdHJhbnNwb3J0cyBmYWlsZWQgdG8gZGlhbCBwZWVyICR7dGhpcy50aGVpckI1OElkfSFgKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlKFxuICAgICAgICAgIENPTk5FQ1RJT05fRkFJTEVEKGBObyBhdmFpbGFibGUgdHJhbnNwb3J0cyB0byBkaWFsIHBlZXIgJHt0aGlzLnRoZWlyQjU4SWR9IWApXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zcG9ydCA9PT0gQ2lyY3VpdC50YWcpIHtcbiAgICAgICAgdGhpcy50aGVpclBlZXJJbmZvLm11bHRpYWRkcnMuYWRkKGAvcDJwLWNpcmN1aXQvcDJwLyR7dGhpcy50aGVpckI1OElkfWApXG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKCdkaWFsaW5nIHRyYW5zcG9ydCAlcycsIHRyYW5zcG9ydClcbiAgICAgIHRoaXMuc3dpdGNoLnRyYW5zcG9ydC5kaWFsKHRyYW5zcG9ydCwgdGhpcy50aGVpclBlZXJJbmZvLCAoZXJyb3JzLCBfY29ubikgPT4ge1xuICAgICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcjpjb25uZWN0aW9uX2F0dGVtcHRfZmFpbGVkJywgZXJyb3JzKVxuICAgICAgICAgIHRoaXMubG9nKGVycm9ycylcbiAgICAgICAgICByZXR1cm4gbmV4dFRyYW5zcG9ydCh0S2V5cy5zaGlmdCgpKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25uID0gb2JzZXJ2ZUNvbm5lY3Rpb24odHJhbnNwb3J0LCBudWxsLCBfY29ubiwgdGhpcy5zd2l0Y2gub2JzZXJ2ZXIpXG4gICAgICAgIHRoaXMuX3N0YXRlKCdkb25lJylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgbmV4dFRyYW5zcG9ydCh0S2V5cy5zaGlmdCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIE9uY2UgYSBjb25uZWN0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBkaWFsZWQsIHRoZSBjb25uZWN0aW9uXG4gICAqIHdpbGwgYmUgcHJpdmF0aXplZCBvciBlbmNyeXB0ZWQgZGVwZW5kaW5nIG9uIHRoZSBwcmVzZW5jZSBvZiB0aGVcbiAgICogU3dpdGNoLnByb3RlY3Rvci5cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfb25EaWFsZWQgKCkge1xuICAgIHRoaXMubG9nKCdzdWNjZXNzZnVsbHkgZGlhbGVkICVzJywgdGhpcy50aGVpckI1OElkKVxuXG4gICAgdGhpcy5lbWl0KCdjb25uZWN0ZWQnLCB0aGlzLmNvbm4pXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgZGlzY29ubmVjdGluZy4gSGFuZGxlcyBhbnkgbmVlZGVkIGNsZWFudXBcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfb25EaXNjb25uZWN0aW5nICgpIHtcbiAgICB0aGlzLmxvZygnZGlzY29ubmVjdGluZyBmcm9tICVzJywgdGhpcy50aGVpckI1OElkLCBCb29sZWFuKHRoaXMubXV4ZXIpKVxuXG4gICAgZGVsZXRlIHRoaXMuc3dpdGNoLmNvbm5zW3RoaXMudGhlaXJCNThJZF1cblxuICAgIGxldCB0YXNrcyA9IFtdXG5cbiAgICAvLyBDbGVhbiB1cCBzdG9yZWQgY29ubmVjdGlvbnNcbiAgICBpZiAodGhpcy5tdXhlcikge1xuICAgICAgdGFza3MucHVzaCgoY2IpID0+IHtcbiAgICAgICAgdGhpcy5tdXhlci5lbmQoKCkgPT4ge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLm11eGVyXG4gICAgICAgICAgY2IoKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIHRoZSBiYXNlIGNvbm5lY3Rpb24sIGFib3J0IGl0XG4gICAgLy8gSWdub3JlIGFib3J0IGVycm9ycywgc2luY2Ugd2UncmUgY2xvc2luZ1xuICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY29ubi5zb3VyY2UuYWJvcnQoKVxuICAgICAgfSBjYXRjaCAoXykgeyB9XG4gICAgICBkZWxldGUgdGhpcy5jb25uXG4gICAgfVxuXG4gICAgcGFyYWxsZWwodGFza3MsICgpID0+IHtcbiAgICAgIHRoaXMuX3N0YXRlKCdkb25lJylcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGVuY3J5cHQgYHRoaXMuY29ubmAgd2l0aCB0aGUgU3dpdGNoJ3MgY3J5cHRvLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZmlyZXMgQ29ubmVjdGlvbkZTTSNlcnJvclxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9vbkVuY3J5cHRpbmcgKCkge1xuICAgIGNvbnN0IG1zRGlhbGVyID0gbmV3IG11bHRpc3RyZWFtLkRpYWxlcigpXG4gICAgbXNEaWFsZXIuaGFuZGxlKHRoaXMuY29ubiwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZShtYXliZVVuZXhwZWN0ZWRFbmQoZXJyKSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2coJ3NlbGVjdGluZyBjcnlwdG8gJXMgdG8gJXMnLCB0aGlzLnN3aXRjaC5jcnlwdG8udGFnLCB0aGlzLnRoZWlyQjU4SWQpXG5cbiAgICAgIG1zRGlhbGVyLnNlbGVjdCh0aGlzLnN3aXRjaC5jcnlwdG8udGFnLCAoZXJyLCBfY29ubikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UobWF5YmVVbmV4cGVjdGVkRW5kKGVycikpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYnNlcnZlZENvbm4gPSBvYnNlcnZlQ29ubmVjdGlvbihudWxsLCB0aGlzLnN3aXRjaC5jcnlwdG8udGFnLCBfY29ubiwgdGhpcy5zd2l0Y2gub2JzZXJ2ZXIpXG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZENvbm4gPSB0aGlzLnN3aXRjaC5jcnlwdG8uZW5jcnlwdCh0aGlzLm91clBlZXJJbmZvLmlkLCBvYnNlcnZlZENvbm4sIHRoaXMudGhlaXJQZWVySW5mby5pZCwgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKGVycilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNvbm4gPSBlbmNyeXB0ZWRDb25uXG4gICAgICAgICAgdGhpcy5jb25uLnNldFBlZXJJbmZvKHRoaXMudGhlaXJQZWVySW5mbylcbiAgICAgICAgICB0aGlzLl9zdGF0ZSgnZG9uZScpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBlYWNoIE11eGVyIG9uIHRoZSBTd2l0Y2ggYW5kIGF0dGVtcHRzIHRvIHVwZ3JhZGVcbiAgICogdGhlIGdpdmVuIGBjb25uZWN0aW9uYC4gU3VjY2Vzc2Z1bCBtdXhlZCBjb25uZWN0aW9ucyB3aWxsIGJlIHN0b3JlZFxuICAgKiBvbiB0aGUgU3dpdGNoLm11eGVkQ29ubnMgd2l0aCBgYjU4SWRgIGFzIHRoZWlyIGtleSBmb3IgZnV0dXJlIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfb25VcGdyYWRpbmcgKCkge1xuICAgIGNvbnN0IG11eGVycyA9IE9iamVjdC5rZXlzKHRoaXMuc3dpdGNoLm11eGVycylcbiAgICB0aGlzLmxvZygndXBncmFkaW5nIGNvbm5lY3Rpb24gdG8gJXMnLCB0aGlzLnRoZWlyQjU4SWQpXG5cbiAgICBpZiAobXV4ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlKCdzdG9wJylcbiAgICB9XG5cbiAgICBjb25zdCBtc0RpYWxlciA9IG5ldyBtdWx0aXN0cmVhbS5EaWFsZXIoKVxuICAgIG1zRGlhbGVyLmhhbmRsZSh0aGlzLmNvbm4sIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpZFVwZ3JhZGUoZXJyKVxuICAgICAgfVxuXG4gICAgICAvLyAxLiB0cnkgdG8gaGFuZHNoYWtlIGluIG9uZSBvZiB0aGUgbXV4ZXJzIGF2YWlsYWJsZVxuICAgICAgLy8gMi4gaWYgc3VjY2VlZHNcbiAgICAgIC8vICAtIGFkZCB0aGUgbXV4ZWRDb25uIHRvIHRoZSBsaXN0IG9mIG11eGVkQ29ubnNcbiAgICAgIC8vICAtIGFkZCBpbmNvbW1pbmcgbmV3IHN0cmVhbXMgdG8gY29ubkhhbmRsZXJcbiAgICAgIGNvbnN0IG5leHRNdXhlciA9IChrZXkpID0+IHtcbiAgICAgICAgdGhpcy5sb2coJ3NlbGVjdGluZyAlcycsIGtleSlcbiAgICAgICAgbXNEaWFsZXIuc2VsZWN0KGtleSwgKGVyciwgX2Nvbm4pID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAobXV4ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlkVXBncmFkZShlcnIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXh0TXV4ZXIobXV4ZXJzLnNoaWZ0KCkpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gb2JzZXJ2ZSBtdXhlZCBjb25uZWN0aW9uc1xuICAgICAgICAgIGNvbnN0IGNvbm4gPSBvYnNlcnZlQ29ubmVjdGlvbihudWxsLCBrZXksIF9jb25uLCB0aGlzLnN3aXRjaC5vYnNlcnZlcilcblxuICAgICAgICAgIHRoaXMubXV4ZXIgPSB0aGlzLnN3aXRjaC5tdXhlcnNba2V5XS5kaWFsZXIoY29ubilcblxuICAgICAgICAgIHRoaXMubXV4ZXIub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgLy8gRm9yIGluY29taW5nIHN0cmVhbXMsIGluIGNhc2UgaWRlbnRpZnkgaXMgb25cbiAgICAgICAgICB0aGlzLm11eGVyLm9uKCdzdHJlYW0nLCAoY29ubikgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coJ25ldyBzdHJlYW0gY3JlYXRlZCB2aWEgbXV4ZXIgdG8gJXMnLCB0aGlzLnRoZWlyQjU4SWQpXG4gICAgICAgICAgICBjb25uLnNldFBlZXJJbmZvKHRoaXMudGhlaXJQZWVySW5mbylcbiAgICAgICAgICAgIHRoaXMuc3dpdGNoLnByb3RvY29sTXV4ZXIobnVsbCkoY29ubilcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgdGhpcy5fZGlkVXBncmFkZShudWxsKVxuXG4gICAgICAgICAgLy8gUnVuIGlkZW50aWZ5IG9uIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgaWYgKHRoaXMuc3dpdGNoLmlkZW50aWZ5KSB7XG4gICAgICAgICAgICB0aGlzLl9pZGVudGlmeSgoZXJyLCByZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZShlcnIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy50aGVpclBlZXJJbmZvID0gdGhpcy5zd2l0Y2guX3BlZXJCb29rLnB1dChyZXN1bHRzLnBlZXJJbmZvKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIG5leHRNdXhlcihtdXhlcnMuc2hpZnQoKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgdGhlIGlkZW50aWZ5IHByb3RvY29sIG9uIHRoZSBjb25uZWN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyb3IsIHsgUGVlckluZm8gfSl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX2lkZW50aWZ5IChjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5tdXhlcikge1xuICAgICAgcmV0dXJuIG5leHRUaWNrKGNhbGxiYWNrLCBlcnJDb2RlKCdUaGUgY29ubmVjdGlvbiB3YXMgYWxyZWFkeSBjbG9zZWQnLCAnRVJSX0NPTk5FQ1RJT05fQ0xPU0VEJykpXG4gICAgfVxuICAgIHRoaXMubXV4ZXIubmV3U3RyZWFtKGFzeW5jIChlcnIsIGNvbm4pID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBjb25zdCBtcyA9IG5ldyBtdWx0aXN0cmVhbS5EaWFsZXIoKVxuICAgICAgbGV0IHJlc3VsdHNcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG1zSGFuZGxlKG1zLCBjb25uKVxuICAgICAgICBjb25zdCBtc0Nvbm4gPSBhd2FpdCBtc1NlbGVjdChtcywgaWRlbnRpZnkubXVsdGljb2RlYylcbiAgICAgICAgcmVzdWx0cyA9IGF3YWl0IGlkZW50aWZ5RGlhbGVyKG1zQ29ubiwgdGhpcy50aGVpclBlZXJJbmZvKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQW5hbHlzZXMgdGhlIGdpdmVuIGVycm9yLCBpZiBpdCBleGlzdHMsIHRvIGRldGVybWluZSB3aGVyZSB0aGUgc3RhdGUgbWFjaGluZVxuICAgKiBuZWVkcyB0byBnby5cbiAgICpcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX2RpZFVwZ3JhZGUgKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXMubG9nKCdFcnJvciB1cGdyYWRpbmcgY29ubmVjdGlvbjonLCBlcnIpXG4gICAgICB0aGlzLnN3aXRjaC5jb25uc1t0aGlzLnRoZWlyQjU4SWRdID0gdGhpc1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcjp1cGdyYWRlX2ZhaWxlZCcsIGVycilcbiAgICAgIC8vIENhbnQgdXBncmFkZSwgaG9sZCB0aGUgZW5jcnlwdGVkIGNvbm5lY3Rpb25cbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSgnc3RvcCcpXG4gICAgfVxuXG4gICAgLy8gbW92ZSB0aGUgc3RhdGUgbWFjaGluZSBmb3J3YXJkXG4gICAgdGhpcy5fc3RhdGUoJ2RvbmUnKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIHRoZSBwcm90b2NvbCBoYW5kc2hha2UgZm9yIHRoZSBnaXZlbiBwcm90b2NvbFxuICAgKiBvdmVyIHRoZSBnaXZlbiBjb25uZWN0aW9uLiBUaGUgcmVzdWx0aW5nIGVycm9yIG9yIGNvbm5lY3Rpb25cbiAgICogd2lsbCBiZSByZXR1cm5lZCB2aWEgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xcbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIENvbm5lY3Rpb24pfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9wcm90b2NvbEhhbmRzaGFrZSAocHJvdG9jb2wsIGNvbm5lY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbXNEaWFsZXIgPSBuZXcgbXVsdGlzdHJlYW0uRGlhbGVyKClcbiAgICBtc0RpYWxlci5oYW5kbGUoY29ubmVjdGlvbiwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKVxuICAgICAgfVxuXG4gICAgICBtc0RpYWxlci5zZWxlY3QocHJvdG9jb2wsIChlcnIsIF9jb25uKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB0aGlzLmxvZygnY291bGQgbm90IHBlcmZvcm0gcHJvdG9jb2wgaGFuZHNoYWtlOicsIGVycilcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29ubiA9IG9ic2VydmVDb25uZWN0aW9uKG51bGwsIHByb3RvY29sLCBfY29ubiwgdGhpcy5zd2l0Y2gub2JzZXJ2ZXIpXG4gICAgICAgIHRoaXMubG9nKCdzdWNjZXNzZnVsbHkgcGVyZm9ybWVkIGhhbmRzaGFrZSBvZiAlcyB0byAlcycsIHByb3RvY29sLCB0aGlzLnRoZWlyQjU4SWQpXG4gICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbicsIGNvbm4pXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNvbm4pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3Igc3RhdGUgdHJhbnNpdGlvbiBlcnJvcnNcbiAgICpcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX29uU3RhdGVFcnJvciAoZXJyKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIElOVkFMSURfU1RBVEVfVFJBTlNJVElPTihlcnIpKVxuICAgIHRoaXMubG9nKGVycilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpdGhJcyhDb25uZWN0aW9uRlNNLCB7XG4gIGNsYXNzTmFtZTogJ0Nvbm5lY3Rpb25GU00nLFxuICBzeW1ib2xOYW1lOiAnbGlicDJwLXN3aXRjaC9Db25uZWN0aW9uRlNNJ1xufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHNcbmV4cG9ydHMubXVsdGljb2RlYyA9ICcvaXBmcy9pZC8xLjAuMCdcbmV4cG9ydHMubGlzdGVuZXIgPSByZXF1aXJlKCcuL2xpc3RlbmVyJylcbmV4cG9ydHMuZGlhbGVyID0gcmVxdWlyZSgnLi9kaWFsZXInKVxuZXhwb3J0cy5tZXNzYWdlID0gcmVxdWlyZSgnLi9tZXNzYWdlJylcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB0cnlFYWNoID0gcmVxdWlyZSgnYXN5bmMvdHJ5RWFjaCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcblxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycDpzd2l0Y2g6ZGlhbGVyJylcblxuY29uc3QgRGlhbFF1ZXVlID0gcmVxdWlyZSgnLi9xdWV1ZScpXG5cbi8qKlxuICogVHJhY2sgZGlhbHMgcGVyIHBlZXIgYW5kIGxpbWl0ZWQgdGhlbS5cbiAqL1xuY2xhc3MgTGltaXREaWFsZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGRpYWxlci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBlclBlZXJMaW1pdFxuICAgKiBAcGFyYW0ge251bWJlcn0gZGlhbFRpbWVvdXRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChwZXJQZWVyTGltaXQsIGRpYWxUaW1lb3V0KSB7XG4gICAgbG9nKCdjcmVhdGU6ICVzIHBlZXIgbGltaXQsICVzIGRpYWwgdGltZW91dCcsIHBlclBlZXJMaW1pdCwgZGlhbFRpbWVvdXQpXG4gICAgdGhpcy5wZXJQZWVyTGltaXQgPSBwZXJQZWVyTGltaXRcbiAgICB0aGlzLmRpYWxUaW1lb3V0ID0gZGlhbFRpbWVvdXRcbiAgICB0aGlzLnF1ZXVlcyA9IG5ldyBNYXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIERpYWwgYSBsaXN0IG9mIG11bHRpYWRkcnMgb24gdGhlIGdpdmVuIHRyYW5zcG9ydC5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySWR9IHBlZXJcbiAgICogQHBhcmFtIHtTd2FybVRyYW5zcG9ydH0gdHJhbnNwb3J0XG4gICAqIEBwYXJhbSB7QXJyYXk8TXVsdGlhZGRyPn0gYWRkcnNcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQ29ubmVjdGlvbil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZGlhbE1hbnkgKHBlZXIsIHRyYW5zcG9ydCwgYWRkcnMsIGNhbGxiYWNrKSB7XG4gICAgbG9nKCdkaWFsTWFueTpzdGFydCcpXG4gICAgLy8gd2UgdXNlIGEgdG9rZW4gdG8gdHJhY2sgaWYgd2Ugd2FudCB0byBjYW5jZWwgZm9sbG93aW5nIGRpYWxzXG4gICAgY29uc3QgdG9rZW4gPSB7IGNhbmNlbDogZmFsc2UgfVxuXG4gICAgbGV0IGVycm9ycyA9IFtdXG4gICAgY29uc3QgdGFza3MgPSBhZGRycy5tYXAoKG0pID0+IHtcbiAgICAgIHJldHVybiAoY2IpID0+IHRoaXMuZGlhbFNpbmdsZShwZWVyLCB0cmFuc3BvcnQsIG0sIHRva2VuLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGVycilcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYihudWxsLCByZXN1bHQpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0cnlFYWNoKHRhc2tzLCAoXywgcmVzdWx0KSA9PiB7XG4gICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5jb25uKSB7XG4gICAgICAgIGxvZygnZGlhbE1hbnk6c3VjY2VzcycpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXN1bHQpXG4gICAgICB9XG5cbiAgICAgIGxvZygnZGlhbE1hbnk6ZXJyb3InKVxuICAgICAgY2FsbGJhY2soZXJyb3JzKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGlhbCBhIHNpbmdsZSBtdWx0aWFkZHIgb24gdGhlIGdpdmVuIHRyYW5zcG9ydC5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySWR9IHBlZXJcbiAgICogQHBhcmFtIHtTd2FybVRyYW5zcG9ydH0gdHJhbnNwb3J0XG4gICAqIEBwYXJhbSB7TXVsdGlhZGRyfSBhZGRyXG4gICAqIEBwYXJhbSB7Q2FuY2VsVG9rZW59IHRva2VuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIENvbm5lY3Rpb24pfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGRpYWxTaW5nbGUgKHBlZXIsIHRyYW5zcG9ydCwgYWRkciwgdG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHMgPSBwZWVyLnRvQjU4U3RyaW5nKClcbiAgICBsb2coJ2RpYWxTaW5nbGU6ICVzOiVzJywgcHMsIGFkZHIudG9TdHJpbmcoKSlcbiAgICBsZXQgcVxuICAgIGlmICh0aGlzLnF1ZXVlcy5oYXMocHMpKSB7XG4gICAgICBxID0gdGhpcy5xdWV1ZXMuZ2V0KHBzKVxuICAgIH0gZWxzZSB7XG4gICAgICBxID0gbmV3IERpYWxRdWV1ZSh0aGlzLnBlclBlZXJMaW1pdCwgdGhpcy5kaWFsVGltZW91dClcbiAgICAgIHRoaXMucXVldWVzLnNldChwcywgcSlcbiAgICB9XG5cbiAgICBxLnB1c2godHJhbnNwb3J0LCBhZGRyLCB0b2tlbiwgY2FsbGJhY2spXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMaW1pdERpYWxlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG1hZm10ID0gcmVxdWlyZSgnbWFmbXQnKVxuY29uc3QgbXVsdGlhZGRyID0gcmVxdWlyZSgnbXVsdGlhZGRyJylcblxuY29uc3QgQ2lyY3VpdERpYWxlciA9IHJlcXVpcmUoJy4vY2lyY3VpdC9kaWFsZXInKVxuY29uc3QgdXRpbHNGYWN0b3J5ID0gcmVxdWlyZSgnLi9jaXJjdWl0L3V0aWxzJylcblxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBsb2cgPSBkZWJ1ZygnbGlicDJwOmNpcmN1aXQ6dHJhbnNwb3J0ZGlhbGVyJylcbmxvZy5lcnIgPSBkZWJ1ZygnbGlicDJwOmNpcmN1aXQ6ZXJyb3I6dHJhbnNwb3J0ZGlhbGVyJylcblxuY29uc3QgY3JlYXRlTGlzdGVuZXIgPSByZXF1aXJlKCcuL2xpc3RlbmVyJylcblxuY2xhc3MgQ2lyY3VpdCB7XG4gIHN0YXRpYyBnZXQgdGFnICgpIHtcbiAgICByZXR1cm4gJ0NpcmN1aXQnXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBEaWFsZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3dhcm19IHN3YXJtIC0gdGhlIHN3YXJtXG4gICAqIEBwYXJhbSB7YW55fSBvcHRpb25zIC0gY29uZmlnIG9wdGlvbnNcbiAgICpcbiAgICogQG1lbWJlck9mIERpYWxlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHN3YXJtLCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgdGhpcy5zd2FybSA9IHN3YXJtXG4gICAgdGhpcy5kaWFsZXIgPSBudWxsXG4gICAgdGhpcy51dGlscyA9IHV0aWxzRmFjdG9yeShzd2FybSlcbiAgICB0aGlzLnBlZXJJbmZvID0gdGhpcy5zd2FybS5fcGVlckluZm9cbiAgICB0aGlzLnJlbGF5cyA9IHRoaXMuZmlsdGVyKHRoaXMucGVlckluZm8ubXVsdGlhZGRycy50b0FycmF5KCkpXG5cbiAgICAvLyBpZiBubyBleHBsaWNpdCByZWxheXMsIGFkZCBhIGRlZmF1bHQgcmVsYXkgYWRkclxuICAgIGlmICh0aGlzLnJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucGVlckluZm9cbiAgICAgICAgLm11bHRpYWRkcnNcbiAgICAgICAgLmFkZChgL3AycC1jaXJjdWl0L2lwZnMvJHt0aGlzLnBlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKCl9YClcbiAgICB9XG5cbiAgICB0aGlzLmRpYWxlciA9IG5ldyBDaXJjdWl0RGlhbGVyKHN3YXJtLCBvcHRpb25zKVxuXG4gICAgdGhpcy5zd2FybS5vbigncGVlci1tdXgtZXN0YWJsaXNoZWQnLCAocGVlckluZm8pID0+IHtcbiAgICAgIHRoaXMuZGlhbGVyLmNhbkhvcChwZWVySW5mbylcbiAgICB9KVxuICAgIHRoaXMuc3dhcm0ub24oJ3BlZXItbXV4LWNsb3NlZCcsIChwZWVySW5mbykgPT4ge1xuICAgICAgdGhpcy5kaWFsZXIucmVsYXlQZWVycy5kZWxldGUocGVlckluZm8uaWQudG9CNThTdHJpbmcoKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERpYWwgdGhlIHJlbGF5cyBpbiB0aGUgQWRkcmVzc2VzLlN3YXJtIGNvbmZpZ1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSByZWxheXNcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIF9kaWFsU3dhcm1SZWxheXMgKCkge1xuICAgIC8vIGlmIHdlIGhhdmUgcmVsYXkgYWRkcmVzc2VzIGluIHN3YXJtIGNvbmZpZywgdGhlbiBkaWFsIHRob3NlIHJlbGF5c1xuICAgIHRoaXMucmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB7XG4gICAgICBsZXQgcmVsYXlTZWdtZW50cyA9IHJlbGF5XG4gICAgICAgIC50b1N0cmluZygpXG4gICAgICAgIC5zcGxpdCgnL3AycC1jaXJjdWl0JylcbiAgICAgICAgLmZpbHRlcihzZWdtZW50ID0+IHNlZ21lbnQubGVuZ3RoKVxuXG4gICAgICByZWxheVNlZ21lbnRzLmZvckVhY2goKHJlbGF5U2VnbWVudCkgPT4ge1xuICAgICAgICBjb25zdCBtYSA9IHRoaXMudXRpbHMucGVlckluZm9Gcm9tTWEobXVsdGlhZGRyKHJlbGF5U2VnbWVudCkpXG4gICAgICAgIHRoaXMuZGlhbGVyLl9kaWFsUmVsYXkobWEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGlhbCBhIHBlZXIgb3ZlciBhIHJlbGF5XG4gICAqXG4gICAqIEBwYXJhbSB7bXVsdGlhZGRyfSBtYSAtIHRoZSBtdWx0aWFkZHIgb2YgdGhlIHBlZXIgdG8gZGlhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGRpYWwgb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGEgY2FsbGJhY2sgY2FsbGVkIG9uY2UgZGlhbGVkXG4gICAqIEByZXR1cm5zIHtDb25uZWN0aW9ufSAtIHRoZSBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBtZW1iZXJPZiBEaWFsZXJcbiAgICovXG4gIGRpYWwgKG1hLCBvcHRpb25zLCBjYikge1xuICAgIHJldHVybiB0aGlzLmRpYWxlci5kaWFsKG1hLCBvcHRpb25zLCBjYilcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsaXN0ZW5lclxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEByZXR1cm4ge2xpc3RlbmVyfVxuICAgKi9cbiAgY3JlYXRlTGlzdGVuZXIgKG9wdGlvbnMsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGhhbmRsZXIgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdGVuZXIgPSBjcmVhdGVMaXN0ZW5lcih0aGlzLnN3YXJtLCBvcHRpb25zLCBoYW5kbGVyKVxuICAgIGxpc3RlbmVyLm9uKCdsaXN0ZW4nLCB0aGlzLl9kaWFsU3dhcm1SZWxheXMuYmluZCh0aGlzKSlcbiAgICByZXR1cm4gbGlzdGVuZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBGaWx0ZXIgY2hlY2sgZm9yIGFsbCBtdWx0aWFkZHJlc3Nlc1xuICAgKiB0aGF0IHRoaXMgdHJhbnNwb3J0IGNhbiBkaWFsIG9uXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBtdWx0aWFkZHJzXG4gICAqIEByZXR1cm5zIHtBcnJheTxtdWx0aWFkZHI+fVxuICAgKlxuICAgKiBAbWVtYmVyT2YgRGlhbGVyXG4gICAqL1xuICBmaWx0ZXIgKG11bHRpYWRkcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobXVsdGlhZGRycykpIHtcbiAgICAgIG11bHRpYWRkcnMgPSBbbXVsdGlhZGRyc11cbiAgICB9XG4gICAgcmV0dXJuIG11bHRpYWRkcnMuZmlsdGVyKChtYSkgPT4ge1xuICAgICAgcmV0dXJuIG1hZm10LkNpcmN1aXQubWF0Y2hlcyhtYSlcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY3VpdFxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXh0cmFjdERhdGFGcm9tQmxvY2sgKGJsb2NrLCBibG9ja1N0YXJ0LCByZXF1ZXN0ZWRTdGFydCwgcmVxdWVzdGVkRW5kKSB7XG4gIGNvbnN0IGJsb2NrTGVuZ3RoID0gYmxvY2subGVuZ3RoXG4gIGNvbnN0IGJsb2NrRW5kID0gYmxvY2tTdGFydCArIGJsb2NrTGVuZ3RoXG5cbiAgaWYgKHJlcXVlc3RlZFN0YXJ0ID49IGJsb2NrRW5kIHx8IHJlcXVlc3RlZEVuZCA8IGJsb2NrU3RhcnQpIHtcbiAgICAvLyBJZiB3ZSBhcmUgbG9va2luZyBmb3IgYSBieXRlIHJhbmdlIHRoYXQgaXMgc3RhcnRzIGFmdGVyIHRoZSBzdGFydCBvZiB0aGUgYmxvY2ssXG4gICAgLy8gcmV0dXJuIGFuIGVtcHR5IGJsb2NrLiAgVGhpcyBjYW4gaGFwcGVuIHdoZW4gaW50ZXJuYWwgbm9kZXMgY29udGFpbiBkYXRhXG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgaWYgKHJlcXVlc3RlZEVuZCA+PSBibG9ja1N0YXJ0ICYmIHJlcXVlc3RlZEVuZCA8IGJsb2NrRW5kKSB7XG4gICAgLy8gSWYgdGhlIGVuZCBieXRlIGlzIGluIHRoZSBjdXJyZW50IGJsb2NrLCB0cnVuY2F0ZSB0aGUgYmxvY2sgdG8gdGhlIGVuZCBieXRlXG4gICAgYmxvY2sgPSBibG9jay5zbGljZSgwLCByZXF1ZXN0ZWRFbmQgLSBibG9ja1N0YXJ0KVxuICB9XG5cbiAgaWYgKHJlcXVlc3RlZFN0YXJ0ID49IGJsb2NrU3RhcnQgJiYgcmVxdWVzdGVkU3RhcnQgPCBibG9ja0VuZCkge1xuICAgIC8vIElmIHRoZSBzdGFydCBieXRlIGlzIGluIHRoZSBjdXJyZW50IGJsb2NrLCBza2lwIHRvIHRoZSBzdGFydCBieXRlXG4gICAgYmxvY2sgPSBibG9jay5zbGljZShyZXF1ZXN0ZWRTdGFydCAtIGJsb2NrU3RhcnQpXG4gIH1cblxuICByZXR1cm4gYmxvY2tcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG5jb25zdCB2YWxpZGF0ZU9mZnNldEFuZExlbmd0aCA9IChzaXplLCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICBpZiAoIW9mZnNldCkge1xuICAgIG9mZnNldCA9IDBcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ09mZnNldCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwJyksICdFUlJfSU5WQUxJRF9QQVJBTVMnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+IHNpemUpIHtcbiAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignT2Zmc2V0IG11c3QgYmUgbGVzcyB0aGFuIHRoZSBmaWxlIHNpemUnKSwgJ0VSUl9JTlZBTElEX1BBUkFNUycpXG4gIH1cblxuICBpZiAoIWxlbmd0aCAmJiBsZW5ndGggIT09IDApIHtcbiAgICBsZW5ndGggPSBzaXplIC0gb2Zmc2V0XG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdMZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCcpLCAnRVJSX0lOVkFMSURfUEFSQU1TJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgKyBsZW5ndGggPiBzaXplKSB7XG4gICAgbGVuZ3RoID0gc2l6ZSAtIG9mZnNldFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvZmZzZXQsXG4gICAgbGVuZ3RoXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZU9mZnNldEFuZExlbmd0aFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRpcmVjdG9yeUNvbnRlbnQgPSAoY2lkLCBub2RlLCB1bml4ZnMsIHBhdGgsIHJlc29sdmUsIGRlcHRoLCBpcGxkKSA9PiB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiAqIChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBvZmZzZXQgPSBvcHRpb25zLm9mZnNldCB8fCAwXG4gICAgY29uc3QgbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfHwgbm9kZS5MaW5rcy5sZW5ndGhcbiAgICBjb25zdCBsaW5rcyA9IG5vZGUuTGlua3Muc2xpY2Uob2Zmc2V0LCBsZW5ndGgpXG5cbiAgICBmb3IgKGNvbnN0IGxpbmsgb2YgbGlua3MpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc29sdmUobGluay5IYXNoLCBsaW5rLk5hbWUsIGAke3BhdGh9LyR7bGluay5OYW1lfWAsIFtdLCBkZXB0aCArIDEsIGlwbGQpXG5cbiAgICAgIHlpZWxkIHJlc3VsdC5lbnRyeVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRpcmVjdG9yeUNvbnRlbnRcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBoYW10U2hhcmRlZERpcmVjdG9yeUNvbnRlbnQgPSAoY2lkLCBub2RlLCB1bml4ZnMsIHBhdGgsIHJlc29sdmUsIGRlcHRoLCBpcGxkKSA9PiB7XG4gIHJldHVybiAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgcmV0dXJuIGxpc3REaXJlY3Rvcnkobm9kZSwgcGF0aCwgcmVzb2x2ZSwgZGVwdGgsIGlwbGQsIG9wdGlvbnMpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gKiBsaXN0RGlyZWN0b3J5IChub2RlLCBwYXRoLCByZXNvbHZlLCBkZXB0aCwgaXBsZCwgb3B0aW9ucykge1xuICBjb25zdCBsaW5rcyA9IG5vZGUuTGlua3NcblxuICBmb3IgKGNvbnN0IGxpbmsgb2YgbGlua3MpIHtcbiAgICBjb25zdCBuYW1lID0gbGluay5OYW1lLnN1YnN0cmluZygyKVxuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc29sdmUobGluay5IYXNoLCBuYW1lLCBgJHtwYXRofS8ke25hbWV9YCwgW10sIGRlcHRoICsgMSwgaXBsZClcblxuICAgICAgeWllbGQgcmVzdWx0LmVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRlc2NlbmQgaW50byBzdWJzaGFyZFxuICAgICAgbm9kZSA9IGF3YWl0IGlwbGQuZ2V0KGxpbmsuSGFzaClcblxuICAgICAgZm9yIGF3YWl0IChjb25zdCBmaWxlIG9mIGxpc3REaXJlY3Rvcnkobm9kZSwgcGF0aCwgcmVzb2x2ZSwgZGVwdGgsIGlwbGQsIG9wdGlvbnMpKSB7XG4gICAgICAgIHlpZWxkIGZpbGVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYW10U2hhcmRlZERpcmVjdG9yeUNvbnRlbnRcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBleHRyYWN0RGF0YUZyb21CbG9jayA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL2V4dHJhY3QtZGF0YS1mcm9tLWJsb2NrJylcbmNvbnN0IHZhbGlkYXRlT2Zmc2V0QW5kTGVuZ3RoID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvdmFsaWRhdGUtb2Zmc2V0LWFuZC1sZW5ndGgnKVxuY29uc3QgVW5peEZTID0gcmVxdWlyZSgnaXBmcy11bml4ZnMnKVxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuYXN5bmMgZnVuY3Rpb24gKiBlbWl0Qnl0ZXMgKGlwbGQsIG5vZGUsIHN0YXJ0LCBlbmQsIHN0cmVhbVBvc2l0aW9uID0gMCkge1xuICAvLyBhIGByYXdgIG5vZGVcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihub2RlKSkge1xuICAgIGNvbnN0IGJ1ZiA9IGV4dHJhY3REYXRhRnJvbUJsb2NrKG5vZGUsIHN0cmVhbVBvc2l0aW9uLCBzdGFydCwgZW5kKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGgpIHtcbiAgICAgIHlpZWxkIGJ1ZlxuICAgIH1cblxuICAgIHN0cmVhbVBvc2l0aW9uICs9IGJ1Zi5sZW5ndGhcblxuICAgIHJldHVybiBzdHJlYW1Qb3NpdGlvblxuICB9XG5cbiAgbGV0IGZpbGVcblxuICB0cnkge1xuICAgIGZpbGUgPSBVbml4RlMudW5tYXJzaGFsKG5vZGUuRGF0YSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgZXJyQ29kZShlcnIsICdFUlJfTk9UX1VOSVhGUycpXG4gIH1cblxuICAvLyBtaWdodCBiZSBhIHVuaXhmcyBgcmF3YCBub2RlIG9yIGhhdmUgZGF0YSBvbiBpbnRlcm1lZGlhdGUgbm9kZXNcbiAgY29uc3Qgbm9kZUhhc0RhdGEgPSBCb29sZWFuKGZpbGUuZGF0YSAmJiBmaWxlLmRhdGEubGVuZ3RoKVxuXG4gIGlmIChub2RlSGFzRGF0YSkge1xuICAgIGNvbnN0IGJ1ZiA9IGV4dHJhY3REYXRhRnJvbUJsb2NrKGZpbGUuZGF0YSwgc3RyZWFtUG9zaXRpb24sIHN0YXJ0LCBlbmQpXG5cbiAgICBpZiAoYnVmLmxlbmd0aCkge1xuICAgICAgeWllbGQgYnVmXG4gICAgfVxuXG4gICAgc3RyZWFtUG9zaXRpb24gKz0gZmlsZS5kYXRhLmxlbmd0aFxuICB9XG5cbiAgbGV0IGNoaWxkU3RhcnQgPSBzdHJlYW1Qb3NpdGlvblxuXG4gIC8vIHdvcmsgb3V0IHdoaWNoIGNoaWxkIG5vZGVzIGNvbnRhaW4gdGhlIHJlcXVlc3RlZCBkYXRhXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5MaW5rcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkTGluayA9IG5vZGUuTGlua3NbaV1cbiAgICBjb25zdCBjaGlsZEVuZCA9IHN0cmVhbVBvc2l0aW9uICsgZmlsZS5ibG9ja1NpemVzW2ldXG5cbiAgICBpZiAoKHN0YXJ0ID49IGNoaWxkU3RhcnQgJiYgc3RhcnQgPCBjaGlsZEVuZCkgfHwgLy8gY2hpbGQgaGFzIG9mZnNldCBieXRlXG4gICAgICAgIChlbmQgPiBjaGlsZFN0YXJ0ICYmIGVuZCA8PSBjaGlsZEVuZCkgfHwgLy8gY2hpbGQgaGFzIGVuZCBieXRlXG4gICAgICAgIChzdGFydCA8IGNoaWxkU3RhcnQgJiYgZW5kID4gY2hpbGRFbmQpKSB7IC8vIGNoaWxkIGlzIGJldHdlZW4gb2Zmc2V0IGFuZCBlbmQgYnl0ZXNcbiAgICAgIGNvbnN0IGNoaWxkID0gYXdhaXQgaXBsZC5nZXQoY2hpbGRMaW5rLkhhc2gpXG5cbiAgICAgIGZvciBhd2FpdCAoY29uc3QgYnVmIG9mIGVtaXRCeXRlcyhpcGxkLCBjaGlsZCwgc3RhcnQsIGVuZCwgc3RyZWFtUG9zaXRpb24pKSB7XG4gICAgICAgIHN0cmVhbVBvc2l0aW9uICs9IGJ1Zi5sZW5ndGhcblxuICAgICAgICB5aWVsZCBidWZcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdHJlYW1Qb3NpdGlvbiA9IGNoaWxkRW5kXG4gICAgY2hpbGRTdGFydCA9IGNoaWxkRW5kICsgMVxuICB9XG59XG5cbmNvbnN0IGZpbGVDb250ZW50ID0gKGNpZCwgbm9kZSwgdW5peGZzLCBwYXRoLCByZXNvbHZlLCBkZXB0aCwgaXBsZCkgPT4ge1xuICByZXR1cm4gKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IGZpbGVTaXplID0gdW5peGZzLmZpbGVTaXplKClcblxuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldCxcbiAgICAgIGxlbmd0aFxuICAgIH0gPSB2YWxpZGF0ZU9mZnNldEFuZExlbmd0aChmaWxlU2l6ZSwgb3B0aW9ucy5vZmZzZXQsIG9wdGlvbnMubGVuZ3RoKVxuXG4gICAgY29uc3Qgc3RhcnQgPSBvZmZzZXRcbiAgICBjb25zdCBlbmQgPSBvZmZzZXQgKyBsZW5ndGhcblxuICAgIHJldHVybiBlbWl0Qnl0ZXMoaXBsZCwgbm9kZSwgc3RhcnQsIGVuZClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbGVDb250ZW50XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQnVja2V0ID0gcmVxdWlyZSgnaGFtdC1zaGFyZGluZy9zcmMvYnVja2V0JylcbmNvbnN0IERpclNoYXJkZWQgPSByZXF1aXJlKCdpcGZzLXVuaXhmcy1pbXBvcnRlci9zcmMvZGlyLXNoYXJkZWQnKVxuXG5jb25zdCBhZGRMaW5rc1RvSGFtdEJ1Y2tldCA9IChsaW5rcywgYnVja2V0LCByb290QnVja2V0KSA9PiB7XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICBsaW5rcy5tYXAobGluayA9PiB7XG4gICAgICBpZiAobGluay5OYW1lLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBjb25zdCBwb3MgPSBwYXJzZUludChsaW5rLk5hbWUsIDE2KVxuXG4gICAgICAgIHJldHVybiBidWNrZXQuX3B1dE9iamVjdEF0KHBvcywgbmV3IEJ1Y2tldCh7XG4gICAgICAgICAgaGFzaEZuOiBEaXJTaGFyZGVkLmhhc2hGblxuICAgICAgICB9LCBidWNrZXQsIHBvcykpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb290QnVja2V0LnB1dChsaW5rLk5hbWUuc3Vic3RyaW5nKDIpLCB0cnVlKVxuICAgIH0pXG4gIClcbn1cblxuY29uc3QgdG9QcmVmaXggPSAocG9zaXRpb24pID0+IHtcbiAgcmV0dXJuIHBvc2l0aW9uXG4gICAgLnRvU3RyaW5nKCcxNicpXG4gICAgLnRvVXBwZXJDYXNlKClcbiAgICAucGFkU3RhcnQoMiwgJzAnKVxuICAgIC5zdWJzdHJpbmcoMCwgMilcbn1cblxuY29uc3QgdG9CdWNrZXRQYXRoID0gKHBvc2l0aW9uKSA9PiB7XG4gIGxldCBidWNrZXQgPSBwb3NpdGlvbi5idWNrZXRcbiAgY29uc3QgcGF0aCA9IFtdXG5cbiAgd2hpbGUgKGJ1Y2tldC5fcGFyZW50KSB7XG4gICAgcGF0aC5wdXNoKGJ1Y2tldClcblxuICAgIGJ1Y2tldCA9IGJ1Y2tldC5fcGFyZW50XG4gIH1cblxuICBwYXRoLnB1c2goYnVja2V0KVxuXG4gIHJldHVybiBwYXRoLnJldmVyc2UoKVxufVxuXG5jb25zdCBmaW5kU2hhcmRDaWQgPSBhc3luYyAobm9kZSwgbmFtZSwgaXBsZCwgY29udGV4dCkgPT4ge1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0ge1xuICAgICAgcm9vdEJ1Y2tldDogbmV3IEJ1Y2tldCh7XG4gICAgICAgIGhhc2hGbjogRGlyU2hhcmRlZC5oYXNoRm5cbiAgICAgIH0pLFxuICAgICAgaGFtdERlcHRoOiAxXG4gICAgfVxuXG4gICAgY29udGV4dC5sYXN0QnVja2V0ID0gY29udGV4dC5yb290QnVja2V0XG4gIH1cblxuICBhd2FpdCBhZGRMaW5rc1RvSGFtdEJ1Y2tldChub2RlLkxpbmtzLCBjb250ZXh0Lmxhc3RCdWNrZXQsIGNvbnRleHQucm9vdEJ1Y2tldClcblxuICBjb25zdCBwb3NpdGlvbiA9IGF3YWl0IGNvbnRleHQucm9vdEJ1Y2tldC5fZmluZE5ld0J1Y2tldEFuZFBvcyhuYW1lKVxuICBsZXQgcHJlZml4ID0gdG9QcmVmaXgocG9zaXRpb24ucG9zKVxuICBjb25zdCBidWNrZXRQYXRoID0gdG9CdWNrZXRQYXRoKHBvc2l0aW9uKVxuXG4gIGlmIChidWNrZXRQYXRoLmxlbmd0aCA+IChjb250ZXh0LmhhbXREZXB0aCkpIHtcbiAgICBjb250ZXh0Lmxhc3RCdWNrZXQgPSBidWNrZXRQYXRoW2NvbnRleHQuaGFtdERlcHRoXVxuXG4gICAgcHJlZml4ID0gdG9QcmVmaXgoY29udGV4dC5sYXN0QnVja2V0Ll9wb3NBdFBhcmVudClcbiAgfVxuXG4gIGNvbnN0IGxpbmsgPSBub2RlLkxpbmtzLmZpbmQobGluayA9PiB7XG4gICAgY29uc3QgZW50cnlQcmVmaXggPSBsaW5rLk5hbWUuc3Vic3RyaW5nKDAsIDIpXG4gICAgY29uc3QgZW50cnlOYW1lID0gbGluay5OYW1lLnN1YnN0cmluZygyKVxuXG4gICAgaWYgKGVudHJ5UHJlZml4ICE9PSBwcmVmaXgpIHtcbiAgICAgIC8vIG5vdCB0aGUgZW50cnkgb3Igc3Vic2hhcmQgd2UncmUgbG9va2luZyBmb3JcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChlbnRyeU5hbWUgJiYgZW50cnlOYW1lICE9PSBuYW1lKSB7XG4gICAgICAvLyBub3QgdGhlIGVudHJ5IHdlJ3JlIGxvb2tpbmcgZm9yXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9KVxuXG4gIGlmICghbGluaykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAobGluay5OYW1lLnN1YnN0cmluZygyKSA9PT0gbmFtZSkge1xuICAgIHJldHVybiBsaW5rLkhhc2hcbiAgfVxuXG4gIGNvbnRleHQuaGFtdERlcHRoKytcblxuICBub2RlID0gYXdhaXQgaXBsZC5nZXQobGluay5IYXNoKVxuXG4gIHJldHVybiBmaW5kU2hhcmRDaWQobm9kZSwgbmFtZSwgaXBsZCwgY29udGV4dClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kU2hhcmRDaWRcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBjb2RlcyA9IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xuICBpZiAoIUJhc2UpIHtcbiAgICBCYXNlID0gRXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIE5vZGVFcnJvciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9CYXNlKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoTm9kZUVycm9yLCBfQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBOb2RlRXJyb3IoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgcmV0dXJuIF9CYXNlLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkgfHwgdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTm9kZUVycm9yO1xuICB9KEJhc2UpO1xuXG4gIE5vZGVFcnJvci5wcm90b3R5cGUubmFtZSA9IEJhc2UubmFtZTtcbiAgTm9kZUVycm9yLnByb3RvdHlwZS5jb2RlID0gY29kZTtcbiAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC44LjAvbGliL2ludGVybmFsL2Vycm9ycy5qc1xuXG5cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGkpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKSwgXCIsIG9yIFwiKSArIGV4cGVjdGVkW2xlbiAtIDFdO1xuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdLCBcIiBvciBcIikuY29uY2F0KGV4cGVjdGVkWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KFN0cmluZyhleHBlY3RlZCkpO1xuICB9XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoXG5cblxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG5cblxuZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTtcbiAgfVxufVxuXG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX09QVF9WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gJ1RoZSB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCInICsgbmFtZSArICdcIic7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG4gIHZhciBkZXRlcm1pbmVyO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJykpIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICB9IGVsc2Uge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gIH1cblxuICB2YXIgbXNnO1xuXG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gXCJUaGUgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR5cGUgPSBpbmNsdWRlcyhuYW1lLCAnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgbXNnID0gXCJUaGUgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgXCIpLmNvbmNhdCh0eXBlLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9XG5cbiAgbXNnICs9IFwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdCh0eXBlb2YgYWN0dWFsKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YnLCAnc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ1RoZSAnICsgbmFtZSArICcgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnLCAnUHJlbWF0dXJlIGNsb3NlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fREVTVFJPWUVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdDYW5ub3QgY2FsbCAnICsgbmFtZSArICcgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01VTFRJUExFX0NBTExCQUNLJywgJ0NhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0NBTk5PVF9QSVBFJywgJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnLCAnd3JpdGUgYWZ0ZXIgZW5kJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fTlVMTF9WQUxVRVMnLCAnTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfVU5LTk9XTl9FTkNPRElORycsIGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuICdVbmtub3duIGVuY29kaW5nOiAnICsgYXJnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCcsICdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xubW9kdWxlLmV4cG9ydHMuY29kZXMgPSBjb2RlcztcbiIsIid1c2Ugc3RyaWN0JzsgLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH0gLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuXG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZU5UKHNlbGYsIGVycikge1xuICBlbWl0RXJyb3JOVChzZWxmLCBlcnIpO1xuICBlbWl0Q2xvc2VOVChzZWxmKTtcbn1cblxuZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZikge1xuICBpZiAoc2VsZi5fd3JpdGFibGVTdGF0ZSAmJiAhc2VsZi5fd3JpdGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgaWYgKHNlbGYuX3JlYWRhYmxlU3RhdGUgJiYgIXNlbGYuX3JlYWRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5mdW5jdGlvbiBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycikge1xuICAvLyBXZSBoYXZlIHRlc3RzIHRoYXQgcmVseSBvbiBlcnJvcnMgYmVpbmcgZW1pdHRlZFxuICAvLyBpbiB0aGUgc2FtZSB0aWNrLCBzbyBjaGFuZ2luZyB0aGlzIGlzIHNlbXZlciBtYWpvci5cbiAgLy8gRm9yIG5vdyB3aGVuIHlvdSBvcHQtaW4gdG8gYXV0b0Rlc3Ryb3kgd2UgYWxsb3dcbiAgLy8gdGhlIGVycm9yIHRvIGJlIGVtaXR0ZWQgbmV4dFRpY2suIEluIGEgZnV0dXJlXG4gIC8vIHNlbXZlciBtYWpvciB1cGRhdGUgd2Ugc2hvdWxkIGNoYW5nZSB0aGUgZGVmYXVsdCB0byB0aGlzLlxuICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICBpZiAoclN0YXRlICYmIHJTdGF0ZS5hdXRvRGVzdHJveSB8fCB3U3RhdGUgJiYgd1N0YXRlLmF1dG9EZXN0cm95KSBzdHJlYW0uZGVzdHJveShlcnIpO2Vsc2Ugc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95LFxuICBlcnJvck9yRGVzdHJveTogZXJyb3JPckRlc3Ryb3lcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfSU5WQUxJRF9PUFRfVkFMVUUgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfSU5WQUxJRF9PUFRfVkFMVUU7XG5cbmZ1bmN0aW9uIGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpIHtcbiAgcmV0dXJuIG9wdGlvbnMuaGlnaFdhdGVyTWFyayAhPSBudWxsID8gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrIDogaXNEdXBsZXggPyBvcHRpb25zW2R1cGxleEtleV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRIaWdoV2F0ZXJNYXJrKHN0YXRlLCBvcHRpb25zLCBkdXBsZXhLZXksIGlzRHVwbGV4KSB7XG4gIHZhciBod20gPSBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KTtcblxuICBpZiAoaHdtICE9IG51bGwpIHtcbiAgICBpZiAoIShpc0Zpbml0ZShod20pICYmIE1hdGguZmxvb3IoaHdtKSA9PT0gaHdtKSB8fCBod20gPCAwKSB7XG4gICAgICB2YXIgbmFtZSA9IGlzRHVwbGV4ID8gZHVwbGV4S2V5IDogJ2hpZ2hXYXRlck1hcmsnO1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX09QVF9WQUxVRShuYW1lLCBod20pO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLmZsb29yKGh3bSk7XG4gIH0gLy8gRGVmYXVsdCB2YWx1ZVxuXG5cbiAgcmV0dXJuIHN0YXRlLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEhpZ2hXYXRlck1hcms6IGdldEhpZ2hXYXRlck1hcmtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignUmVhZGFibGUuZnJvbSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyJylcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2J1ZmZlcicpLFxuICAgIEJ1ZmZlciA9IF9yZXF1aXJlLkJ1ZmZlcjtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ3V0aWwnKSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG5cbnZhciBjdXN0b20gPSBpbnNwZWN0ICYmIGluc3BlY3QuY3VzdG9tIHx8ICdpbnNwZWN0JztcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuY29weS5jYWxsKHNyYywgdGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdWZmZXJMaXN0LCBbe1xuICAgIGtleTogXCJwdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2godikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiB0aGlzLmhlYWRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgICAtLXRoaXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJqb2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmNhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQobikge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAocCkge1xuICAgICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIG9yIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcImNvbnN1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3VtZShuLCBoYXNTdHJpbmdzKSB7XG4gICAgICB2YXIgcmV0O1xuXG4gICAgICBpZiAobiA8IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBgc2xpY2VgIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgICByZXQgPSB0aGlzLmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICAgICAgdGhpcy5oZWFkLmRhdGEgPSB0aGlzLmhlYWQuZGF0YS5zbGljZShuKTtcbiAgICAgIH0gZWxzZSBpZiAobiA9PT0gdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIEZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaC5cbiAgICAgICAgcmV0ID0gdGhpcy5zaGlmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyLlxuICAgICAgICByZXQgPSBoYXNTdHJpbmdzID8gdGhpcy5fZ2V0U3RyaW5nKG4pIDogdGhpcy5fZ2V0QnVmZmVyKG4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXJzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTdHJpbmcobikge1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICB2YXIgcmV0ID0gcC5kYXRhO1xuICAgICAgbiAtPSByZXQubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgICAgICBuIC09IG5iO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrYztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEJ1ZmZlcihuKSB7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICBwLmRhdGEuY29weShyZXQpO1xuICAgICAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgICAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgICAgIG4gLT0gbmI7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytjO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIE1ha2Ugc3VyZSB0aGUgbGlua2VkIGxpc3Qgb25seSBzaG93cyB0aGUgbWluaW1hbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24uXG5cbiAgfSwge1xuICAgIGtleTogY3VzdG9tLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gaW5zcGVjdCh0aGlzLCBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIC8vIE9ubHkgaW5zcGVjdCBvbmUgbGV2ZWwuXG4gICAgICAgIGRlcHRoOiAwLFxuICAgICAgICAvLyBJdCBzaG91bGQgbm90IHJlY3Vyc2UuXG4gICAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgZmluaXNoZWQgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcblxudmFyIGtMYXN0UmVzb2x2ZSA9IFN5bWJvbCgnbGFzdFJlc29sdmUnKTtcbnZhciBrTGFzdFJlamVjdCA9IFN5bWJvbCgnbGFzdFJlamVjdCcpO1xudmFyIGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcbnZhciBrRW5kZWQgPSBTeW1ib2woJ2VuZGVkJyk7XG52YXIga0xhc3RQcm9taXNlID0gU3ltYm9sKCdsYXN0UHJvbWlzZScpO1xudmFyIGtIYW5kbGVQcm9taXNlID0gU3ltYm9sKCdoYW5kbGVQcm9taXNlJyk7XG52YXIga1N0cmVhbSA9IFN5bWJvbCgnc3RyZWFtJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHQodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZG9uZTogZG9uZVxuICB9O1xufVxuXG5mdW5jdGlvbiByZWFkQW5kUmVzb2x2ZShpdGVyKSB7XG4gIHZhciByZXNvbHZlID0gaXRlcltrTGFzdFJlc29sdmVdO1xuXG4gIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgdmFyIGRhdGEgPSBpdGVyW2tTdHJlYW1dLnJlYWQoKTsgLy8gd2UgZGVmZXIgaWYgZGF0YSBpcyBudWxsXG4gICAgLy8gd2UgY2FuIGJlIGV4cGVjdGluZyBlaXRoZXIgJ2VuZCcgb3JcbiAgICAvLyAnZXJyb3InXG5cbiAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgaXRlcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25SZWFkYWJsZShpdGVyKSB7XG4gIC8vIHdlIHdhaXQgZm9yIHRoZSBuZXh0IHRpY2ssIGJlY2F1c2UgaXQgbWlnaHRcbiAgLy8gZW1pdCBhbiBlcnJvciB3aXRoIHByb2Nlc3MubmV4dFRpY2tcbiAgcHJvY2Vzcy5uZXh0VGljayhyZWFkQW5kUmVzb2x2ZSwgaXRlcik7XG59XG5cbmZ1bmN0aW9uIHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCBpdGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGFzdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXRlcltrRW5kZWRdKSB7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpdGVyW2tIYW5kbGVQcm9taXNlXShyZXNvbHZlLCByZWplY3QpO1xuICAgIH0sIHJlamVjdCk7XG4gIH07XG59XG5cbnZhciBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uICgpIHt9KTtcbnZhciBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YoKF9PYmplY3Qkc2V0UHJvdG90eXBlTyA9IHtcbiAgZ2V0IHN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpc1trU3RyZWFtXTtcbiAgfSxcblxuICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGRldGVjdGVkIGFuIGVycm9yIGluIHRoZSBtZWFud2hpbGVcbiAgICAvLyByZWplY3Qgc3RyYWlnaHQgYXdheVxuICAgIHZhciBlcnJvciA9IHRoaXNba0Vycm9yXTtcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRW5kZWRdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba1N0cmVhbV0uZGVzdHJveWVkKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGRlZmVyIHZpYSBuZXh0VGljayBiZWNhdXNlIGlmIC5kZXN0cm95KGVycikgaXNcbiAgICAgIC8vIGNhbGxlZCwgdGhlIGVycm9yIHdpbGwgYmUgZW1pdHRlZCB2aWEgbmV4dFRpY2ssIGFuZFxuICAgICAgLy8gd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IHRoZXJlIGlzIG5vIGVycm9yIGxpbmdlcmluZyBhcm91bmRcbiAgICAgIC8vIHdhaXRpbmcgdG8gYmUgZW1pdHRlZC5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpc1trRXJyb3JdKSB7XG4gICAgICAgICAgICByZWplY3QoX3RoaXNba0Vycm9yXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSAvLyBpZiB3ZSBoYXZlIG11bHRpcGxlIG5leHQoKSBjYWxsc1xuICAgIC8vIHdlIHdpbGwgd2FpdCBmb3IgdGhlIHByZXZpb3VzIFByb21pc2UgdG8gZmluaXNoXG4gICAgLy8gdGhpcyBsb2dpYyBpcyBvcHRpbWl6ZWQgdG8gc3VwcG9ydCBmb3IgYXdhaXQgbG9vcHMsXG4gICAgLy8gd2hlcmUgbmV4dCgpIGlzIG9ubHkgY2FsbGVkIG9uY2UgYXQgYSB0aW1lXG5cblxuICAgIHZhciBsYXN0UHJvbWlzZSA9IHRoaXNba0xhc3RQcm9taXNlXTtcbiAgICB2YXIgcHJvbWlzZTtcblxuICAgIGlmIChsYXN0UHJvbWlzZSkge1xuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhc3QgcGF0aCBuZWVkZWQgdG8gc3VwcG9ydCBtdWx0aXBsZSB0aGlzLnB1c2goKVxuICAgICAgLy8gd2l0aG91dCB0cmlnZ2VyaW5nIHRoZSBuZXh0KCkgcXVldWVcbiAgICAgIHZhciBkYXRhID0gdGhpc1trU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2UodGhpc1trSGFuZGxlUHJvbWlzZV0pO1xuICAgIH1cblxuICAgIHRoaXNba0xhc3RQcm9taXNlXSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn0sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFwicmV0dXJuXCIsIGZ1bmN0aW9uIF9yZXR1cm4oKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIC8vIGRlc3Ryb3koZXJyLCBjYikgaXMgYSBwcml2YXRlIEFQSVxuICAvLyB3ZSBjYW4gZ3VhcmFudGVlIHdlIGhhdmUgdGhhdCBoZXJlLCBiZWNhdXNlIHdlIGNvbnRyb2wgdGhlXG4gIC8vIFJlYWRhYmxlIGNsYXNzIHRoaXMgaXMgYXR0YWNoZWQgdG9cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBfdGhpczJba1N0cmVhbV0uZGVzdHJveShudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9KTtcbiAgfSk7XG59KSwgX09iamVjdCRzZXRQcm90b3R5cGVPKSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG5cbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSBmdW5jdGlvbiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtKSB7XG4gIHZhciBfT2JqZWN0JGNyZWF0ZTtcblxuICB2YXIgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSwgKF9PYmplY3QkY3JlYXRlID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga1N0cmVhbSwge1xuICAgIHZhbHVlOiBzdHJlYW0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZXNvbHZlLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZWplY3QsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRXJyb3IsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRW5kZWQsIHtcbiAgICB2YWx1ZTogc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0hhbmRsZVByb21pc2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZGF0YSA9IGl0ZXJhdG9yW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSByZXNvbHZlO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSByZWplY3Q7XG4gICAgICB9XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX09iamVjdCRjcmVhdGUpKTtcbiAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gIGZpbmlzaGVkKHN0cmVhbSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScpIHtcbiAgICAgIHZhciByZWplY3QgPSBpdGVyYXRvcltrTGFzdFJlamVjdF07IC8vIHJlamVjdCBpZiB3ZSBhcmUgd2FpdGluZyBmb3IgZGF0YSBpbiB0aGUgUHJvbWlzZVxuICAgICAgLy8gcmV0dXJuZWQgYnkgbmV4dCgpIGFuZCBzdG9yZSB0aGUgZXJyb3JcblxuICAgICAgaWYgKHJlamVjdCAhPT0gbnVsbCkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRvcltrRXJyb3JdID0gZXJyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlID0gaXRlcmF0b3Jba0xhc3RSZXNvbHZlXTtcblxuICAgIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpdGVyYXRvcltrRW5kZWRdID0gdHJ1ZTtcbiAgfSk7XG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBvblJlYWRhYmxlLmJpbmQobnVsbCwgaXRlcmF0b3IpKTtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7IiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG1oID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuY29uc3QgbWMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJylcblxuY29uc3QgcGVyc2lzdCA9IChub2RlLCBpcGxkLCBvcHRpb25zKSA9PiB7XG4gIGlmICghb3B0aW9ucy5jb2RlYyAmJiBub2RlLmxlbmd0aCkge1xuICAgIG9wdGlvbnMuY2lkVmVyc2lvbiA9IDFcbiAgICBvcHRpb25zLmNvZGVjID0gJ3JhdydcbiAgfVxuXG4gIGlmIChpc05hTihvcHRpb25zLmhhc2hBbGcpKSB7XG4gICAgb3B0aW9ucy5oYXNoQWxnID0gbWgubmFtZXNbb3B0aW9ucy5oYXNoQWxnXVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzaEFsZyAhPT0gbWgubmFtZXNbJ3NoYTItMjU2J10pIHtcbiAgICBvcHRpb25zLmNpZFZlcnNpb24gPSAxXG4gIH1cblxuICBpZiAob3B0aW9ucy5mb3JtYXQpIHtcbiAgICBvcHRpb25zLmNvZGVjID0gb3B0aW9ucy5mb3JtYXRcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdCA9IG1jW29wdGlvbnMuY29kZWMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tL2csICdfJyldXG5cbiAgcmV0dXJuIGlwbGQucHV0KG5vZGUsIGZvcm1hdCwgb3B0aW9ucylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJzaXN0XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBEQUdMaW5rLFxuICBEQUdOb2RlXG59ID0gcmVxdWlyZSgnaXBsZC1kYWctcGInKVxuY29uc3QgVW5peEZTID0gcmVxdWlyZSgnaXBmcy11bml4ZnMnKVxuY29uc3QgbXVsdGloYXNoaW5nID0gcmVxdWlyZSgnbXVsdGloYXNoaW5nLWFzeW5jJylcbmNvbnN0IERpciA9IHJlcXVpcmUoJy4vZGlyJylcbmNvbnN0IHBlcnNpc3QgPSByZXF1aXJlKCcuL3V0aWxzL3BlcnNpc3QnKVxuY29uc3QgQnVja2V0ID0gcmVxdWlyZSgnaGFtdC1zaGFyZGluZycpXG5jb25zdCBleHRlbmQgPSByZXF1aXJlKCdkZWVwLWV4dGVuZCcpXG5cbmNvbnN0IGhhc2hGbiA9IGFzeW5jIGZ1bmN0aW9uICh2YWx1ZSkge1xuICBjb25zdCBoYXNoID0gYXdhaXQgbXVsdGloYXNoaW5nKEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpLCAnbXVybXVyMy0xMjgnKVxuXG4gIC8vIE11bHRpaGFzaGluZyBpbnNlcnRzIHByZWFtYmxlIG9mIDIgYnl0ZXMuIFJlbW92ZSBpdC5cbiAgLy8gQWxzbywgbXVybXVyMyBvdXRwdXRzIDEyOCBiaXQgYnV0LCBhY2NpZGVudGx5LCBJUEZTIEdvJ3NcbiAgLy8gaW1wbGVtZW50YXRpb24gb25seSB1c2VzIHRoZSBmaXJzdCA2NCwgc28gd2UgbXVzdCBkbyB0aGUgc2FtZVxuICAvLyBmb3IgcGFyaXR5Li5cbiAgY29uc3QganVzdEhhc2ggPSBoYXNoLnNsaWNlKDIsIDEwKVxuICBjb25zdCBsZW5ndGggPSBqdXN0SGFzaC5sZW5ndGhcbiAgY29uc3QgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKGxlbmd0aClcbiAgLy8gVE9ETzogaW52ZXJ0IGJ1ZmZlciBiZWNhdXNlIHRoYXQncyBob3cgR28gaW1wbCBkb2VzIGl0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbbGVuZ3RoIC0gaSAtIDFdID0ganVzdEhhc2hbaV1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cbmhhc2hGbi5jb2RlID0gMHgyMiAvLyBUT0RPOiBnZXQgdGhpcyBmcm9tIG11bHRpaGFzaGluZy1hc3luYz9cblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGhhc2hGbjogaGFzaEZuXG59XG5cbmNsYXNzIERpclNoYXJkZWQgZXh0ZW5kcyBEaXIge1xuICBjb25zdHJ1Y3RvciAocHJvcHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcblxuICAgIHN1cGVyKHByb3BzLCBvcHRpb25zKVxuXG4gICAgdGhpcy5fYnVja2V0ID0gQnVja2V0KG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBwdXQgKG5hbWUsIHZhbHVlKSB7XG4gICAgYXdhaXQgdGhpcy5fYnVja2V0LnB1dChuYW1lLCB2YWx1ZSlcbiAgfVxuXG4gIGdldCAobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9idWNrZXQuZ2V0KG5hbWUpXG4gIH1cblxuICBjaGlsZENvdW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVja2V0LmxlYWZDb3VudCgpXG4gIH1cblxuICBkaXJlY3RDaGlsZHJlbkNvdW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVja2V0LmNoaWxkcmVuQ291bnQoKVxuICB9XG5cbiAgb25seUNoaWxkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVja2V0Lm9ubHlDaGlsZCgpXG4gIH1cblxuICBhc3luYyAqIGVhY2hDaGlsZFNlcmllcyAoKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCB7IGtleSwgdmFsdWUgfSBvZiB0aGlzLl9idWNrZXQuZWFjaExlYWZTZXJpZXMoKSkge1xuICAgICAgeWllbGQge1xuICAgICAgICBrZXksXG4gICAgICAgIGNoaWxkOiB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jICogZmx1c2ggKHBhdGgsIGlwbGQpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIGZsdXNoKHBhdGgsIHRoaXMuX2J1Y2tldCwgaXBsZCwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgeWllbGQgZW50cnlcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaXJTaGFyZGVkXG5cbm1vZHVsZS5leHBvcnRzLmhhc2hGbiA9IGhhc2hGblxuXG5hc3luYyBmdW5jdGlvbiAqIGZsdXNoIChwYXRoLCBidWNrZXQsIGlwbGQsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBidWNrZXQuX2NoaWxkcmVuXG4gIGNvbnN0IGxpbmtzID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbi5nZXQoaSlcblxuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxQcmVmaXggPSBpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDIsICcwJylcblxuICAgIGlmIChCdWNrZXQuaXNCdWNrZXQoY2hpbGQpKSB7XG4gICAgICBsZXQgc2hhcmRcblxuICAgICAgZm9yIGF3YWl0IChjb25zdCBzdWJTaGFyZCBvZiBhd2FpdCBmbHVzaCgnJywgY2hpbGQsIGlwbGQsIG9wdGlvbnMpKSB7XG4gICAgICAgIHNoYXJkID0gc3ViU2hhcmRcbiAgICAgIH1cblxuICAgICAgbGlua3MucHVzaChhd2FpdCBuZXcgREFHTGluayhsYWJlbFByZWZpeCwgc2hhcmQubm9kZS5zaXplLCBzaGFyZC5jaWQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkLnZhbHVlLmZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBkaXIgPSBjaGlsZC52YWx1ZVxuICAgICAgbGV0IGZsdXNoZWREaXJcblxuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbnRyeSBvZiBkaXIuZmx1c2goZGlyLnBhdGgsIGlwbGQpKSB7XG4gICAgICAgIGZsdXNoZWREaXIgPSBlbnRyeVxuXG4gICAgICAgIHlpZWxkIGZsdXNoZWREaXJcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGFiZWwgPSBsYWJlbFByZWZpeCArIGNoaWxkLmtleVxuICAgICAgbGlua3MucHVzaChuZXcgREFHTGluayhsYWJlbCwgZmx1c2hlZERpci5ub2RlLnNpemUsIGZsdXNoZWREaXIuY2lkKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsdWUgPSBjaGlsZC52YWx1ZVxuXG4gICAgICBpZiAoIXZhbHVlLm5vZGUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmNpZCkge1xuICAgICAgICAgIHZhbHVlLm5vZGUgPSBhd2FpdCBpcGxkLmdldCh2YWx1ZS5jaWQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBsYWJlbCA9IGxhYmVsUHJlZml4ICsgY2hpbGQua2V5XG4gICAgICBjb25zdCBzaXplID0gdmFsdWUubm9kZS5sZW5ndGggfHwgdmFsdWUubm9kZS5zaXplIHx8IHZhbHVlLm5vZGUuU2l6ZVxuXG4gICAgICBsaW5rcy5wdXNoKGF3YWl0IG5ldyBEQUdMaW5rKGxhYmVsLCBzaXplLCB2YWx1ZS5jaWQpKVxuICAgIH1cbiAgfVxuXG4gIC8vIGdvLWlwZnMgdXNlcyBsaXR0bGUgZW5kaWFuLCB0aGF0J3Mgd2h5IHdlIGhhdmUgdG9cbiAgLy8gcmV2ZXJzZSB0aGUgYml0IGZpZWxkIGJlZm9yZSBzdG9yaW5nIGl0XG4gIGNvbnN0IGRhdGEgPSBCdWZmZXIuZnJvbShjaGlsZHJlbi5iaXRGaWVsZCgpLnJldmVyc2UoKSlcbiAgY29uc3QgZGlyID0gbmV3IFVuaXhGUygnaGFtdC1zaGFyZGVkLWRpcmVjdG9yeScsIGRhdGEpXG4gIGRpci5mYW5vdXQgPSBidWNrZXQudGFibGVTaXplKClcbiAgZGlyLmhhc2hUeXBlID0gb3B0aW9ucy5oYXNoRm4uY29kZVxuXG4gIGNvbnN0IG5vZGUgPSBEQUdOb2RlLmNyZWF0ZShkaXIubWFyc2hhbCgpLCBsaW5rcylcbiAgY29uc3QgY2lkID0gYXdhaXQgcGVyc2lzdChub2RlLCBpcGxkLCBvcHRpb25zKVxuXG4gIHlpZWxkIHtcbiAgICBjaWQsXG4gICAgbm9kZSxcbiAgICB1bml4ZnM6IGRpcixcbiAgICBwYXRoXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXRjaCA9IHJlcXVpcmUoJ2FzeW5jLWl0ZXJhdG9yLWJhdGNoJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAqIHRyaWNrbGVSZWR1Y2VUb1Jvb3QgKHNvdXJjZSwgcmVkdWNlLCBvcHRpb25zKSB7XG4gIHlpZWxkIHRyaWNrbGVTdHJlYW0oc291cmNlLCByZWR1Y2UsIG9wdGlvbnMpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRyaWNrbGVTdHJlYW0gKHNvdXJjZSwgcmVkdWNlLCBvcHRpb25zKSB7XG4gIGxldCByb290XG4gIGxldCBpdGVyYXRpb24gPSAwXG4gIGxldCBtYXhEZXB0aCA9IDFcbiAgbGV0IHN1YlRyZWUgPSByb290ID0gbmV3IFJvb3Qob3B0aW9ucy5sYXllclJlcGVhdClcblxuICBmb3IgYXdhaXQgKGNvbnN0IGxheWVyIG9mIGJhdGNoKHNvdXJjZSwgb3B0aW9ucy5tYXhDaGlsZHJlblBlck5vZGUpKSB7XG4gICAgaWYgKHN1YlRyZWUuaXNGdWxsKCkpIHtcbiAgICAgIGlmIChzdWJUcmVlICE9PSByb290KSB7XG4gICAgICAgIHJvb3QuYWRkQ2hpbGQoYXdhaXQgc3ViVHJlZS5yZWR1Y2UocmVkdWNlKSlcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZXJhdGlvbiAmJiBpdGVyYXRpb24gJSBvcHRpb25zLmxheWVyUmVwZWF0ID09PSAwKSB7XG4gICAgICAgIG1heERlcHRoKytcbiAgICAgIH1cblxuICAgICAgc3ViVHJlZSA9IG5ldyBTdWJUcmVlKG1heERlcHRoLCBvcHRpb25zLmxheWVyUmVwZWF0LCBpdGVyYXRpb24pXG5cbiAgICAgIGl0ZXJhdGlvbisrXG4gICAgfVxuXG4gICAgc3ViVHJlZS5hcHBlbmQobGF5ZXIpXG4gIH1cblxuICBpZiAoc3ViVHJlZSAmJiBzdWJUcmVlICE9PSByb290KSB7XG4gICAgcm9vdC5hZGRDaGlsZChhd2FpdCBzdWJUcmVlLnJlZHVjZShyZWR1Y2UpKVxuICB9XG5cbiAgcmV0dXJuIHJvb3QucmVkdWNlKHJlZHVjZSlcbn1cblxuY2xhc3MgU3ViVHJlZSB7XG4gIGNvbnN0cnVjdG9yIChtYXhEZXB0aCwgbGF5ZXJSZXBlYXQsIGl0ZXJhdGlvbikge1xuICAgIHRoaXMubWF4RGVwdGggPSBtYXhEZXB0aFxuICAgIHRoaXMubGF5ZXJSZXBlYXQgPSBsYXllclJlcGVhdFxuICAgIHRoaXMuY3VycmVudERlcHRoID0gMVxuICAgIHRoaXMuaXRlcmF0aW9uID0gaXRlcmF0aW9uXG5cbiAgICB0aGlzLnJvb3QgPSB0aGlzLm5vZGUgPSB0aGlzLnBhcmVudCA9IHtcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIGRlcHRoOiB0aGlzLmN1cnJlbnREZXB0aCxcbiAgICAgIG1heERlcHRoLFxuICAgICAgbWF4Q2hpbGRyZW46ICh0aGlzLm1heERlcHRoIC0gdGhpcy5jdXJyZW50RGVwdGgpICogdGhpcy5sYXllclJlcGVhdFxuICAgIH1cbiAgfVxuXG4gIGlzRnVsbCAoKSB7XG4gICAgaWYgKCF0aGlzLnJvb3QuZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY3VycmVudERlcHRoIDwgdGhpcy5tYXhEZXB0aCAmJiB0aGlzLm5vZGUubWF4Q2hpbGRyZW4pIHtcbiAgICAgIC8vIGNhbiBkZXNjZW5kXG4gICAgICB0aGlzLl9hZGROZXh0Tm9kZVRvUGFyZW50KHRoaXMubm9kZSlcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gdHJ5IHRvIGZpbmQgbmV3IG5vZGUgZnJvbSBub2RlLnBhcmVudFxuICAgIGNvbnN0IGRpc3RhbnRSZWxhdGl2ZSA9IHRoaXMuX2ZpbmRQYXJlbnQodGhpcy5ub2RlLCB0aGlzLmN1cnJlbnREZXB0aClcblxuICAgIGlmIChkaXN0YW50UmVsYXRpdmUpIHtcbiAgICAgIHRoaXMuX2FkZE5leHROb2RlVG9QYXJlbnQoZGlzdGFudFJlbGF0aXZlKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgX2FkZE5leHROb2RlVG9QYXJlbnQgKHBhcmVudCkge1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50XG5cbiAgICAvLyBmaW5kIHNpdGUgZm9yIG5ldyBub2RlXG4gICAgY29uc3QgbmV4dE5vZGUgPSB7XG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBkZXB0aDogcGFyZW50LmRlcHRoICsgMSxcbiAgICAgIHBhcmVudCxcbiAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoLFxuICAgICAgbWF4Q2hpbGRyZW46IE1hdGguZmxvb3IocGFyZW50LmNoaWxkcmVuLmxlbmd0aCAvIHRoaXMubGF5ZXJSZXBlYXQpICogdGhpcy5sYXllclJlcGVhdFxuICAgIH1cblxuICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5leHROb2RlKVxuXG4gICAgdGhpcy5jdXJyZW50RGVwdGggPSBuZXh0Tm9kZS5kZXB0aFxuICAgIHRoaXMubm9kZSA9IG5leHROb2RlXG4gIH1cblxuICBhcHBlbmQgKGxheWVyKSB7XG4gICAgdGhpcy5ub2RlLmRhdGEgPSBsYXllclxuICB9XG5cbiAgcmVkdWNlIChyZWR1Y2UpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVkdWNlKHRoaXMucm9vdCwgcmVkdWNlKVxuICB9XG5cbiAgYXN5bmMgX3JlZHVjZSAobm9kZSwgcmVkdWNlKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gW11cblxuICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgY2hpbGRyZW4gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgbm9kZS5jaGlsZHJlblxuICAgICAgICAgIC5maWx0ZXIoY2hpbGQgPT4gY2hpbGQuZGF0YSlcbiAgICAgICAgICAubWFwKGNoaWxkID0+IHRoaXMuX3JlZHVjZShjaGlsZCwgcmVkdWNlKSlcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVkdWNlKG5vZGUuZGF0YS5jb25jYXQoY2hpbGRyZW4pKVxuICB9XG5cbiAgX2ZpbmRQYXJlbnQgKG5vZGUsIGRlcHRoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnRcblxuICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5kZXB0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IHBhcmVudC5tYXhDaGlsZHJlbiB8fCAhcGFyZW50Lm1heENoaWxkcmVuKSB7XG4gICAgICAvLyB0aGlzIGxheWVyIGlzIGZ1bGwsIG1heSBiZSBhYmxlIHRvIHRyYXZlcnNlIHRvIGEgZGlmZmVyZW50IGJyYW5jaFxuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRQYXJlbnQocGFyZW50LCBkZXB0aClcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50XG4gIH1cbn1cblxuY2xhc3MgUm9vdCBleHRlbmRzIFN1YlRyZWUge1xuICBjb25zdHJ1Y3RvciAobGF5ZXJSZXBlYXQpIHtcbiAgICBzdXBlcigwLCBsYXllclJlcGVhdClcblxuICAgIHRoaXMucm9vdC5kZXB0aCA9IDBcbiAgICB0aGlzLmN1cnJlbnREZXB0aCA9IDFcbiAgfVxuXG4gIGFkZENoaWxkIChjaGlsZCkge1xuICAgIHRoaXMucm9vdC5jaGlsZHJlbi5wdXNoKGNoaWxkKVxuICB9XG5cbiAgcmVkdWNlIChyZWR1Y2UpIHtcbiAgICByZXR1cm4gcmVkdWNlKHRoaXMucm9vdC5kYXRhLmNvbmNhdCh0aGlzLnJvb3QuY2hpbGRyZW4pKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYmF0Y2ggPSByZXF1aXJlKCdhc3luYy1pdGVyYXRvci1iYXRjaCcpXG5cbmFzeW5jIGZ1bmN0aW9uICogYmFsYW5jZWQgKHNvdXJjZSwgcmVkdWNlLCBvcHRpb25zKSB7XG4gIHlpZWxkIGF3YWl0IHJlZHVjZVRvUGFyZW50cyhzb3VyY2UsIHJlZHVjZSwgb3B0aW9ucylcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVkdWNlVG9QYXJlbnRzIChzb3VyY2UsIHJlZHVjZSwgb3B0aW9ucykge1xuICBjb25zdCByb290cyA9IFtdXG5cbiAgZm9yIGF3YWl0IChjb25zdCBjaHVua2VkIG9mIGJhdGNoKHNvdXJjZSwgb3B0aW9ucy5tYXhDaGlsZHJlblBlck5vZGUpKSB7XG4gICAgcm9vdHMucHVzaChhd2FpdCByZWR1Y2UoY2h1bmtlZCkpXG4gIH1cblxuICBpZiAocm9vdHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiByZWR1Y2VUb1BhcmVudHMocm9vdHMsIHJlZHVjZSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiByb290c1swXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhbGFuY2VkXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYmF0Y2ggPSByZXF1aXJlKCdhc3luYy1pdGVyYXRvci1iYXRjaCcpXG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgZnVuY3Rpb24gKiAoc291cmNlLCByZWR1Y2UpIHtcbiAgY29uc3Qgcm9vdHMgPSBbXVxuXG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYmF0Y2goc291cmNlLCBJbmZpbml0eSkpIHtcbiAgICByb290cy5wdXNoKGF3YWl0IHJlZHVjZShjaHVuaykpXG4gIH1cblxuICB5aWVsZCByb290c1swXVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJ1ZmZlckxpc3QgPSByZXF1aXJlKCdibCcpXG5jb25zdCB7IGNyZWF0ZSB9ID0gcmVxdWlyZSgncmFiaW4td2FzbScpXG5jb25zdCBlcnJjb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jIGZ1bmN0aW9uICogcmFiaW5DaHVua2VyIChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmFiaW4gPSBqc1JhYmluKClcblxuICBsZXQgbWluLCBtYXgsIGF2Z1xuXG4gIGlmIChvcHRpb25zLm1pbkNodW5rU2l6ZSAmJiBvcHRpb25zLm1heENodW5rU2l6ZSAmJiBvcHRpb25zLmF2Z0NodW5rU2l6ZSkge1xuICAgIGF2ZyA9IG9wdGlvbnMuYXZnQ2h1bmtTaXplXG4gICAgbWluID0gb3B0aW9ucy5taW5DaHVua1NpemVcbiAgICBtYXggPSBvcHRpb25zLm1heENodW5rU2l6ZVxuICB9IGVsc2UgaWYgKCFvcHRpb25zLmF2Z0NodW5rU2l6ZSkge1xuICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKCdwbGVhc2Ugc3BlY2lmeSBhbiBhdmVyYWdlIGNodW5rIHNpemUnKSwgJ0VSUl9JTlZBTElEX0FWR19DSFVOS19TSVpFJylcbiAgfSBlbHNlIHtcbiAgICBhdmcgPSBvcHRpb25zLmF2Z0NodW5rU2l6ZVxuICAgIG1pbiA9IGF2ZyAvIDNcbiAgICBtYXggPSBhdmcgKyAoYXZnIC8gMilcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIG1pbi9tYXgvYXZnIGluIHRoZSBzYW1lIHdheSBhcyBnb1xuICBpZiAobWluIDwgMTYpIHtcbiAgICB0aHJvdyBlcnJjb2RlKG5ldyBFcnJvcigncmFiaW4gbWluIG11c3QgYmUgZ3JlYXRlciB0aGFuIDE2JyksICdFUlJfSU5WQUxJRF9NSU5fQ0hVTktfU0laRScpXG4gIH1cblxuICBpZiAobWF4IDwgbWluKSB7XG4gICAgbWF4ID0gbWluXG4gIH1cblxuICBpZiAoYXZnIDwgbWluKSB7XG4gICAgYXZnID0gbWluXG4gIH1cblxuICBjb25zdCBzaXplcG93ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIoYXZnKSlcblxuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJhYmluKHNvdXJjZSwge1xuICAgIG1pbjogbWluLFxuICAgIG1heDogbWF4LFxuICAgIGJpdHM6IHNpemVwb3csXG4gICAgd2luZG93OiBvcHRpb25zLndpbmRvdyxcbiAgICBwb2x5bm9taWFsOiBvcHRpb25zLnBvbHlub21pYWxcbiAgfSkpIHtcbiAgICB5aWVsZCBjaHVua1xuICB9XG59XG5cbmNvbnN0IGpzUmFiaW4gPSAoKSA9PiB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiAqIChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByID0gYXdhaXQgY3JlYXRlKG9wdGlvbnMuYml0cywgb3B0aW9ucy5taW4sIG9wdGlvbnMubWF4LCBvcHRpb25zLndpbmRvdylcbiAgICBjb25zdCBidWZmZXJzID0gbmV3IEJ1ZmZlckxpc3QoKVxuICAgIGxldCBwZW5kaW5nID0gW11cblxuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc291cmNlKSB7XG4gICAgICBidWZmZXJzLmFwcGVuZChjaHVuaylcbiAgICAgIHBlbmRpbmcucHVzaChjaHVuaylcblxuICAgICAgY29uc3Qgc2l6ZXMgPSByLmZpbmdlcnByaW50KEJ1ZmZlci5jb25jYXQocGVuZGluZykpXG4gICAgICBwZW5kaW5nID0gW11cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2l6ZSA9IHNpemVzW2ldXG4gICAgICAgIHZhciBidWYgPSBidWZmZXJzLnNsaWNlKDAsIHNpemUpXG4gICAgICAgIGJ1ZmZlcnMuY29uc3VtZShzaXplKVxuXG4gICAgICAgIHlpZWxkIGJ1ZlxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChidWZmZXJzLmxlbmd0aCkge1xuICAgICAgeWllbGQgYnVmZmVycy5zbGljZSgwKVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJ1ZmZlckxpc3QgPSByZXF1aXJlKCdibCcpXG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgZnVuY3Rpb24gKiBmaXhlZFNpemVDaHVua2VyIChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgbGV0IGJsID0gbmV3IEJ1ZmZlckxpc3QoKVxuICBsZXQgY3VycmVudExlbmd0aCA9IDBcbiAgbGV0IGVtaXR0ZWQgPSBmYWxzZVxuICBjb25zdCBtYXhDaHVua1NpemUgPSBvcHRpb25zLm1heENodW5rU2l6ZVxuXG4gIGZvciBhd2FpdCAoY29uc3QgYnVmZmVyIG9mIHNvdXJjZSkge1xuICAgIGJsLmFwcGVuZChidWZmZXIpXG5cbiAgICBjdXJyZW50TGVuZ3RoICs9IGJ1ZmZlci5sZW5ndGhcblxuICAgIHdoaWxlIChjdXJyZW50TGVuZ3RoID49IG1heENodW5rU2l6ZSkge1xuICAgICAgeWllbGQgYmwuc2xpY2UoMCwgbWF4Q2h1bmtTaXplKVxuICAgICAgZW1pdHRlZCA9IHRydWVcblxuICAgICAgLy8gdGhyb3cgYXdheSBjb25zdW1lZCBieXRlc1xuICAgICAgaWYgKG1heENodW5rU2l6ZSA9PT0gYmwubGVuZ3RoKSB7XG4gICAgICAgIGJsID0gbmV3IEJ1ZmZlckxpc3QoKVxuICAgICAgICBjdXJyZW50TGVuZ3RoID0gMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3QmwgPSBuZXcgQnVmZmVyTGlzdCgpXG4gICAgICAgIG5ld0JsLmFwcGVuZChibC5zaGFsbG93U2xpY2UobWF4Q2h1bmtTaXplKSlcbiAgICAgICAgYmwgPSBuZXdCbFxuXG4gICAgICAgIC8vIHVwZGF0ZSBvdXIgb2Zmc2V0XG4gICAgICAgIGN1cnJlbnRMZW5ndGggLT0gbWF4Q2h1bmtTaXplXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFlbWl0dGVkIHx8IGN1cnJlbnRMZW5ndGgpIHtcbiAgICAvLyByZXR1cm4gYW55IHJlbWFpbmluZyBieXRlcyBvciBhbiBlbXB0eSBidWZmZXJcbiAgICB5aWVsZCBibC5zbGljZSgwLCBjdXJyZW50TGVuZ3RoKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBEQUdOb2RlXG59ID0gcmVxdWlyZSgnaXBsZC1kYWctcGInKVxuY29uc3QgQnVja2V0ID0gcmVxdWlyZSgnaGFtdC1zaGFyZGluZy9zcmMvYnVja2V0JylcbmNvbnN0IERpclNoYXJkZWQgPSByZXF1aXJlKCdpcGZzLXVuaXhmcy1pbXBvcnRlci9zcmMvZGlyLXNoYXJkZWQnKVxuY29uc3QgbG9nID0gcmVxdWlyZSgnZGVidWcnKSgnaXBmczptZnM6Y29yZTp1dGlsczpoYW10LXV0aWxzJylcbmNvbnN0IFVuaXhGUyA9IHJlcXVpcmUoJ2lwZnMtdW5peGZzJylcbmNvbnN0IG1jID0gcmVxdWlyZSgnbXVsdGljb2RlYycpXG5jb25zdCBtaCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJylcbmNvbnN0IGxhc3QgPSByZXF1aXJlKCdhc3luYy1pdGVyYXRvci1sYXN0JylcblxuY29uc3QgdXBkYXRlSGFtdERpcmVjdG9yeSA9IGFzeW5jIChjb250ZXh0LCBsaW5rcywgYnVja2V0LCBvcHRpb25zKSA9PiB7XG4gIC8vIHVwZGF0ZSBwYXJlbnQgd2l0aCBuZXcgYml0IGZpZWxkXG4gIGNvbnN0IGRhdGEgPSBCdWZmZXIuZnJvbShidWNrZXQuX2NoaWxkcmVuLmJpdEZpZWxkKCkucmV2ZXJzZSgpKVxuICBjb25zdCBkaXIgPSBuZXcgVW5peEZTKCdoYW10LXNoYXJkZWQtZGlyZWN0b3J5JywgZGF0YSlcbiAgZGlyLmZhbm91dCA9IGJ1Y2tldC50YWJsZVNpemUoKVxuICBkaXIuaGFzaFR5cGUgPSBEaXJTaGFyZGVkLmhhc2hGbi5jb2RlXG5cbiAgY29uc3QgZm9ybWF0ID0gbWNbb3B0aW9ucy5mb3JtYXQudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tL2csICdfJyldXG4gIGNvbnN0IGhhc2hBbGcgPSBtaC5uYW1lc1tvcHRpb25zLmhhc2hBbGddXG5cbiAgY29uc3QgcGFyZW50ID0gREFHTm9kZS5jcmVhdGUoZGlyLm1hcnNoYWwoKSwgbGlua3MpXG4gIGNvbnN0IGNpZCA9IGF3YWl0IGNvbnRleHQuaXBsZC5wdXQocGFyZW50LCBmb3JtYXQsIHtcbiAgICBjaWRWZXJzaW9uOiBvcHRpb25zLmNpZFZlcnNpb24sXG4gICAgaGFzaEFsZyxcbiAgICBoYXNoT25seTogIW9wdGlvbnMuZmx1c2hcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIG5vZGU6IHBhcmVudCxcbiAgICBjaWRcbiAgfVxufVxuXG5jb25zdCByZWNyZWF0ZUhhbXRMZXZlbCA9IGFzeW5jIChsaW5rcywgcm9vdEJ1Y2tldCwgcGFyZW50QnVja2V0LCBwb3NpdGlvbkF0UGFyZW50KSA9PiB7XG4gIC8vIHJlY3JlYXRlIHRoaXMgbGV2ZWwgb2YgdGhlIEhBTVRcbiAgY29uc3QgYnVja2V0ID0gbmV3IEJ1Y2tldCh7XG4gICAgaGFzaEZuOiBEaXJTaGFyZGVkLmhhc2hGbixcbiAgICBoYXNoOiBwYXJlbnRCdWNrZXQgPyBwYXJlbnRCdWNrZXQuX29wdGlvbnMuaGFzaCA6IHVuZGVmaW5lZFxuICB9LCBwYXJlbnRCdWNrZXQsIHBvc2l0aW9uQXRQYXJlbnQpXG5cbiAgaWYgKHBhcmVudEJ1Y2tldCkge1xuICAgIHBhcmVudEJ1Y2tldC5fcHV0T2JqZWN0QXQocG9zaXRpb25BdFBhcmVudCwgYnVja2V0KVxuICB9XG5cbiAgYXdhaXQgYWRkTGlua3NUb0hhbXRCdWNrZXQobGlua3MsIGJ1Y2tldCwgcm9vdEJ1Y2tldClcblxuICByZXR1cm4gYnVja2V0XG59XG5cbmNvbnN0IGFkZExpbmtzVG9IYW10QnVja2V0ID0gYXN5bmMgKGxpbmtzLCBidWNrZXQsIHJvb3RCdWNrZXQpID0+IHtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgbGlua3MubWFwKGxpbmsgPT4ge1xuICAgICAgaWYgKGxpbmsuTmFtZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgY29uc3QgcG9zID0gcGFyc2VJbnQobGluay5OYW1lLCAxNilcblxuICAgICAgICBidWNrZXQuX3B1dE9iamVjdEF0KHBvcywgbmV3IEJ1Y2tldCh7XG4gICAgICAgICAgaGFzaEZuOiBEaXJTaGFyZGVkLmhhc2hGblxuICAgICAgICB9LCBidWNrZXQsIHBvcykpXG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAocm9vdEJ1Y2tldCB8fCBidWNrZXQpLnB1dChsaW5rLk5hbWUuc3Vic3RyaW5nKDIpLCB7XG4gICAgICAgIHNpemU6IGxpbmsuVFNpemUsXG4gICAgICAgIGNpZDogbGluay5IYXNoXG4gICAgICB9KVxuICAgIH0pXG4gIClcbn1cblxuY29uc3QgdG9QcmVmaXggPSAocG9zaXRpb24pID0+IHtcbiAgcmV0dXJuIHBvc2l0aW9uXG4gICAgLnRvU3RyaW5nKCcxNicpXG4gICAgLnRvVXBwZXJDYXNlKClcbiAgICAucGFkU3RhcnQoMiwgJzAnKVxuICAgIC5zdWJzdHJpbmcoMCwgMilcbn1cblxuY29uc3QgZ2VuZXJhdGVQYXRoID0gYXN5bmMgKGNvbnRleHQsIGZpbGVOYW1lLCByb290Tm9kZSkgPT4ge1xuICAvLyBzdGFydCBhdCB0aGUgcm9vdCBidWNrZXQgYW5kIGRlc2NlbmQsIGxvYWRpbmcgbm9kZXMgYXMgd2UgZ29cbiAgY29uc3Qgcm9vdEJ1Y2tldCA9IGF3YWl0IHJlY3JlYXRlSGFtdExldmVsKHJvb3ROb2RlLkxpbmtzLCBudWxsLCBudWxsLCBudWxsKVxuICBjb25zdCBwb3NpdGlvbiA9IGF3YWl0IHJvb3RCdWNrZXQuX2ZpbmROZXdCdWNrZXRBbmRQb3MoZmlsZU5hbWUpXG5cbiAgLy8gdGhlIHBhdGggdG8gdGhlIHJvb3QgYnVja2V0XG4gIGxldCBwYXRoID0gW3tcbiAgICBidWNrZXQ6IHBvc2l0aW9uLmJ1Y2tldCxcbiAgICBwcmVmaXg6IHRvUHJlZml4KHBvc2l0aW9uLnBvcylcbiAgfV1cbiAgbGV0IGN1cnJlbnRCdWNrZXQgPSBwb3NpdGlvbi5idWNrZXRcblxuICB3aGlsZSAoY3VycmVudEJ1Y2tldCAhPT0gcm9vdEJ1Y2tldCkge1xuICAgIHBhdGgucHVzaCh7XG4gICAgICBidWNrZXQ6IGN1cnJlbnRCdWNrZXQsXG4gICAgICBwcmVmaXg6IHRvUHJlZml4KGN1cnJlbnRCdWNrZXQuX3Bvc0F0UGFyZW50KVxuICAgIH0pXG5cbiAgICBjdXJyZW50QnVja2V0ID0gY3VycmVudEJ1Y2tldC5fcGFyZW50XG4gIH1cblxuICBwYXRoLnJldmVyc2UoKVxuICBwYXRoWzBdLm5vZGUgPSByb290Tm9kZVxuXG4gIC8vIGxvYWQgREFHTm9kZSBmb3IgZWFjaCBwYXRoIHNlZ21lbnRcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHBhdGhbaV1cblxuICAgIC8vIGZpbmQgcHJlZml4IGluIGxpbmtzXG4gICAgY29uc3QgbGluayA9IHNlZ21lbnQubm9kZS5MaW5rc1xuICAgICAgLmZpbHRlcihsaW5rID0+IGxpbmsuTmFtZS5zdWJzdHJpbmcoMCwgMikgPT09IHNlZ21lbnQucHJlZml4KVxuICAgICAgLnBvcCgpXG5cbiAgICAvLyBlbnRyeSB3YXMgbm90IGluIHNoYXJkXG4gICAgaWYgKCFsaW5rKSB7XG4gICAgICAvLyByZWFjaGVkIGJvdHRvbSBvZiB0cmVlLCBmaWxlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgYnVja2V0XG4gICAgICBsb2coYExpbmsgJHtzZWdtZW50LnByZWZpeH0ke2ZpbGVOYW1lfSB3aWxsIGJlIGFkZGVkYClcbiAgICAgIC8vIHJldHVybiBwYXRoXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIGZvdW5kIGVudHJ5XG4gICAgaWYgKGxpbmsuTmFtZSA9PT0gYCR7c2VnbWVudC5wcmVmaXh9JHtmaWxlTmFtZX1gKSB7XG4gICAgICBsb2coYExpbmsgJHtzZWdtZW50LnByZWZpeH0ke2ZpbGVOYW1lfSB3aWxsIGJlIHJlcGxhY2VkYClcbiAgICAgIC8vIGZpbGUgYWxyZWFkeSBleGlzdGVkLCBmaWxlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgYnVja2V0XG4gICAgICAvLyByZXR1cm4gcGF0aFxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvLyBmb3VuZCBzdWJzaGFyZFxuICAgIGxvZyhgRm91bmQgc3Vic2hhcmQgJHtzZWdtZW50LnByZWZpeH1gKVxuICAgIGNvbnN0IG5vZGUgPSBhd2FpdCBjb250ZXh0LmlwbGQuZ2V0KGxpbmsuSGFzaClcblxuICAgIC8vIHN1YnNoYXJkIGhhc24ndCBiZWVuIGxvYWRlZCwgZGVzY2VuZCB0byB0aGUgbmV4dCBsZXZlbCBvZiB0aGUgSEFNVFxuICAgIGlmICghcGF0aFtpICsgMV0pIHtcbiAgICAgIGxvZyhgTG9hZGVkIG5ldyBzdWJzaGFyZCAke3NlZ21lbnQucHJlZml4fWApXG5cbiAgICAgIGF3YWl0IHJlY3JlYXRlSGFtdExldmVsKG5vZGUuTGlua3MsIHJvb3RCdWNrZXQsIHNlZ21lbnQuYnVja2V0LCBwYXJzZUludChzZWdtZW50LnByZWZpeCwgMTYpKVxuICAgICAgY29uc3QgcG9zaXRpb24gPSBhd2FpdCByb290QnVja2V0Ll9maW5kTmV3QnVja2V0QW5kUG9zKGZpbGVOYW1lKVxuXG4gICAgICAvLyBpLS1cbiAgICAgIHBhdGgucHVzaCh7XG4gICAgICAgIGJ1Y2tldDogcG9zaXRpb24uYnVja2V0LFxuICAgICAgICBwcmVmaXg6IHRvUHJlZml4KHBvc2l0aW9uLnBvcyksXG4gICAgICAgIG5vZGU6IG5vZGVcbiAgICAgIH0pXG5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgbmV4dFNlZ21lbnQgPSBwYXRoW2kgKyAxXVxuXG4gICAgLy8gYWRkIGludGVybWVkaWF0ZSBsaW5rcyB0byBidWNrZXRcbiAgICBhd2FpdCBhZGRMaW5rc1RvSGFtdEJ1Y2tldChub2RlLkxpbmtzLCBuZXh0U2VnbWVudC5idWNrZXQsIHJvb3RCdWNrZXQpXG5cbiAgICBuZXh0U2VnbWVudC5ub2RlID0gbm9kZVxuICB9XG5cbiAgYXdhaXQgcm9vdEJ1Y2tldC5wdXQoZmlsZU5hbWUsIHRydWUpXG5cbiAgcGF0aC5yZXZlcnNlKClcblxuICByZXR1cm4ge1xuICAgIHJvb3RCdWNrZXQsXG4gICAgcGF0aFxuICB9XG59XG5cbmNvbnN0IGNyZWF0ZVNoYXJkID0gYXN5bmMgKGNvbnRleHQsIGNvbnRlbnRzLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHNoYXJkID0gbmV3IERpclNoYXJkZWQoe1xuICAgIHJvb3Q6IHRydWUsXG4gICAgZGlyOiB0cnVlLFxuICAgIHBhcmVudDogbnVsbCxcbiAgICBwYXJlbnRLZXk6IG51bGwsXG4gICAgcGF0aDogJycsXG4gICAgZGlydHk6IHRydWUsXG4gICAgZmxhdDogZmFsc2VcbiAgfSwgb3B0aW9ucylcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXdhaXQgc2hhcmQuX2J1Y2tldC5wdXQoY29udGVudHNbaV0ubmFtZSwge1xuICAgICAgc2l6ZTogY29udGVudHNbaV0uc2l6ZSxcbiAgICAgIGNpZDogY29udGVudHNbaV0uY2lkXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBsYXN0KHNoYXJkLmZsdXNoKCcnLCBjb250ZXh0LmlwbGQsIG51bGwpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2VuZXJhdGVQYXRoLFxuICB1cGRhdGVIYW10RGlyZWN0b3J5LFxuICByZWNyZWF0ZUhhbXRMZXZlbCxcbiAgYWRkTGlua3NUb0hhbXRCdWNrZXQsXG4gIHRvUHJlZml4LFxuICBjcmVhdGVTaGFyZFxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE1LTIwMTcgRGF2aWQgTS4gTGVlLCBJSVxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIExvY2FsIHJlZmVyZW5jZSB0byBUaW1lb3V0RXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBUaW1lb3V0RXJyb3I7XG5cbi8qKlxuICogUmVqZWN0cyBhIHByb21pc2Ugd2l0aCBhIHtAbGluayBUaW1lb3V0RXJyb3J9IGlmIGl0IGRvZXMgbm90IHNldHRsZSB3aXRoaW5cbiAqIHRoZSBzcGVjaWZpZWQgdGltZW91dC5cbiAqXG4gKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2UgVGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dE1pbGxpcyBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgb24gc2V0dGxpbmcuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gRWl0aGVyIHJlc29sdmVzL3JlamVjdHMgd2l0aCBgcHJvbWlzZWAsIG9yIHJlamVjdHMgd2l0aFxuICogICAgICAgICAgICAgICAgICAgYFRpbWVvdXRFcnJvcmAsIHdoaWNoZXZlciBzZXR0bGVzIGZpcnN0LlxuICovXG52YXIgdGltZW91dCA9IG1vZHVsZS5leHBvcnRzLnRpbWVvdXQgPSBmdW5jdGlvbihwcm9taXNlLCB0aW1lb3V0TWlsbGlzKSB7XG4gIHZhciBlcnJvciA9IG5ldyBUaW1lb3V0RXJyb3IoKSxcbiAgICAgIHRpbWVvdXQ7XG5cbiAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgcHJvbWlzZSxcbiAgICBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSwgdGltZW91dE1pbGxpcyk7XG4gICAgfSksXG4gIF0pLnRoZW4oZnVuY3Rpb24odikge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICByZXR1cm4gdjtcbiAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRocm93IGVycjtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEV4Y2VwdGlvbiBpbmRpY2F0aW5nIHRoYXQgdGhlIHRpbWVvdXQgZXhwaXJlZC5cbiAqL1xuVGltZW91dEVycm9yID0gbW9kdWxlLmV4cG9ydHMuVGltZW91dEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIEVycm9yLmNhbGwodGhpcylcbiAgdGhpcy5zdGFjayA9IEVycm9yKCkuc3RhY2tcbiAgdGhpcy5tZXNzYWdlID0gJ1RpbWVvdXQnO1xufTtcblxuVGltZW91dEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblRpbWVvdXRFcnJvci5wcm90b3R5cGUubmFtZSA9IFwiVGltZW91dEVycm9yXCI7XG4iLCJjb25zdCBldmVudHMgPSB7fVxuXG5jb25zdCBvYnNlcnZhYmxlID0gKHdvcmtlcikgPT4ge1xuICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgIG9ic2VydmFibGUuZGlzcGF0Y2hFdmVudCgnbWVzc2FnZScsIHdvcmtlciwgZXZlbnQpXG4gIH0pXG5cbiAgaWYgKHdvcmtlci5wb3J0KSB7XG4gICAgd29ya2VyLnBvcnQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgb2JzZXJ2YWJsZS5kaXNwYXRjaEV2ZW50KCdtZXNzYWdlJywgd29ya2VyLCBldmVudClcbiAgICB9KVxuICB9XG59XG5cbm9ic2VydmFibGUuYWRkRXZlbnRMaXN0ZW5lciA9ICh0eXBlLCBmbikgPT4ge1xuICBpZiAoIWV2ZW50c1t0eXBlXSkge1xuICAgIGV2ZW50c1t0eXBlXSA9IFtdXG4gIH1cblxuICBldmVudHNbdHlwZV0ucHVzaChmbilcbn1cblxub2JzZXJ2YWJsZS5yZW1vdmVFdmVudExpc3RlbmVyID0gKHR5cGUsIGZuKSA9PiB7XG4gIGlmICghZXZlbnRzW3R5cGVdKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBldmVudHNbdHlwZV0gPSBldmVudHNbdHlwZV1cbiAgICAuZmlsdGVyKGxpc3RlbmVyID0+IGxpc3RlbmVyID09PSBmbilcbn1cblxub2JzZXJ2YWJsZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICBjb25zdCB0eXBlID0gYXJncy5zaGlmdCgpXG5cbiAgaWYgKCFldmVudHNbdHlwZV0pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGV2ZW50c1t0eXBlXS5mb3JFYWNoKGZuID0+IGZuLmFwcGx5KG51bGwsIGFyZ3MpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9ic2VydmFibGVcbiIsImNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuY29uc3Qgc2hvcnRpZCA9IHJlcXVpcmUoJ3Nob3J0aWQnKVxuY29uc3Qge1xuICBXT1JLRVJfUkVRVUVTVF9SRUFEX0xPQ0ssXG4gIFdPUktFUl9SRUxFQVNFX1JFQURfTE9DSyxcbiAgTUFTVEVSX0dSQU5UX1JFQURfTE9DSyxcbiAgV09SS0VSX1JFUVVFU1RfV1JJVEVfTE9DSyxcbiAgV09SS0VSX1JFTEVBU0VfV1JJVEVfTE9DSyxcbiAgTUFTVEVSX0dSQU5UX1dSSVRFX0xPQ0tcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5sZXQgY2x1c3RlclxuXG5jb25zdCBoYW5kbGVXb3JrZXJMb2NrUmVxdWVzdCA9IChlbWl0dGVyLCBtYXN0ZXJFdmVudCwgcmVxdWVzdFR5cGUsIHJlbGVhc2VUeXBlLCBncmFudFR5cGUpID0+IHtcbiAgcmV0dXJuICh3b3JrZXIsIHJlcXVlc3RFdmVudCkgPT4ge1xuICAgIGlmIChyZXF1ZXN0RXZlbnQgJiYgcmVxdWVzdEV2ZW50LnR5cGUgPT09IHJlcXVlc3RUeXBlKSB7XG4gICAgICBlbWl0dGVyLmVtaXQobWFzdGVyRXZlbnQsIHJlcXVlc3RFdmVudC5uYW1lLCAoKSA9PiB7XG4gICAgICAgIC8vIGdyYW50IGxvY2sgdG8gd29ya2VyXG4gICAgICAgIHdvcmtlci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBncmFudFR5cGUsXG4gICAgICAgICAgbmFtZTogcmVxdWVzdEV2ZW50Lm5hbWUsXG4gICAgICAgICAgaWRlbnRpZmllcjogcmVxdWVzdEV2ZW50LmlkZW50aWZpZXJcbiAgICAgICAgfSlcblxuICAgICAgICAvLyB3YWl0IGZvciB3b3JrZXIgdG8gZmluaXNoXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlbGVhc2VFdmVudExpc3RlbmVyID0gKHJlbGVhc2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlbGVhc2VFdmVudCAmJiByZWxlYXNlRXZlbnQudHlwZSA9PT0gcmVsZWFzZVR5cGUgJiYgcmVsZWFzZUV2ZW50LmlkZW50aWZpZXIgPT09IHJlcXVlc3RFdmVudC5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIHdvcmtlci5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIHJlbGVhc2VFdmVudExpc3RlbmVyKVxuICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3b3JrZXIub24oJ21lc3NhZ2UnLCByZWxlYXNlRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IG1ha2VXb3JrZXJMb2NrUmVxdWVzdCA9IChuYW1lLCByZXF1ZXN0VHlwZSwgZ3JhbnRUeXBlLCByZWxlYXNlVHlwZSkgPT4ge1xuICByZXR1cm4gKGZuKSA9PiB7XG4gICAgY29uc3QgaWQgPSBzaG9ydGlkLmdlbmVyYXRlKClcblxuICAgIHByb2Nlc3Muc2VuZCh7XG4gICAgICB0eXBlOiByZXF1ZXN0VHlwZSxcbiAgICAgIGlkZW50aWZpZXI6IGlkLFxuICAgICAgbmFtZVxuICAgIH0pXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IGdyYW50VHlwZSAmJiBldmVudC5pZGVudGlmaWVyID09PSBpZCkge1xuICAgICAgICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcilcblxuICAgICAgICAgIGxldCBlcnJvciA9IG51bGxcblxuICAgICAgICAgIGZuKClcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIGVycm9yID0gZXJyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICBwcm9jZXNzLnNlbmQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IHJlbGVhc2VUeXBlLFxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkLFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3Mub24oJ21lc3NhZ2UnLCBsaXN0ZW5lcilcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICBjbHVzdGVyID0gcmVxdWlyZSgnY2x1c3RlcicpXG5cbiAgICBpZiAoIU9iamVjdC5rZXlzKGNsdXN0ZXIpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoY2x1c3Rlci5pc01hc3RlciB8fCBvcHRpb25zLnNpbmdsZVByb2Nlc3MpIHtcbiAgICBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpXG5cbiAgICBjbHVzdGVyLm9uKCdtZXNzYWdlJywgaGFuZGxlV29ya2VyTG9ja1JlcXVlc3QoZW1pdHRlciwgJ3JlcXVlc3RSZWFkTG9jaycsIFdPUktFUl9SRVFVRVNUX1JFQURfTE9DSywgV09SS0VSX1JFTEVBU0VfUkVBRF9MT0NLLCBNQVNURVJfR1JBTlRfUkVBRF9MT0NLKSlcbiAgICBjbHVzdGVyLm9uKCdtZXNzYWdlJywgaGFuZGxlV29ya2VyTG9ja1JlcXVlc3QoZW1pdHRlciwgJ3JlcXVlc3RXcml0ZUxvY2snLCBXT1JLRVJfUkVRVUVTVF9XUklURV9MT0NLLCBXT1JLRVJfUkVMRUFTRV9XUklURV9MT0NLLCBNQVNURVJfR1JBTlRfV1JJVEVfTE9DSykpXG5cbiAgICByZXR1cm4gZW1pdHRlclxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc1dvcmtlcjogdHJ1ZSxcbiAgICByZWFkTG9jazogKG5hbWUsIG9wdGlvbnMpID0+IG1ha2VXb3JrZXJMb2NrUmVxdWVzdChuYW1lLCBXT1JLRVJfUkVRVUVTVF9SRUFEX0xPQ0ssIE1BU1RFUl9HUkFOVF9SRUFEX0xPQ0ssIFdPUktFUl9SRUxFQVNFX1JFQURfTE9DSyksXG4gICAgd3JpdGVMb2NrOiAobmFtZSwgb3B0aW9ucykgPT4gbWFrZVdvcmtlckxvY2tSZXF1ZXN0KG5hbWUsIFdPUktFUl9SRVFVRVNUX1dSSVRFX0xPQ0ssIE1BU1RFUl9HUkFOVF9XUklURV9MT0NLLCBXT1JLRVJfUkVMRUFTRV9XUklURV9MT0NLKVxuICB9XG59XG4iLCJjb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbmNvbnN0IHNob3J0aWQgPSByZXF1aXJlKCdzaG9ydGlkJylcbmNvbnN0IHtcbiAgV09SS0VSX1JFUVVFU1RfUkVBRF9MT0NLLFxuICBXT1JLRVJfUkVMRUFTRV9SRUFEX0xPQ0ssXG4gIE1BU1RFUl9HUkFOVF9SRUFEX0xPQ0ssXG4gIFdPUktFUl9SRVFVRVNUX1dSSVRFX0xPQ0ssXG4gIFdPUktFUl9SRUxFQVNFX1dSSVRFX0xPQ0ssXG4gIE1BU1RFUl9HUkFOVF9XUklURV9MT0NLXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3Qgb2JzZXJ2ZXIgPSByZXF1aXJlKCdvYnNlcnZhYmxlLXdlYndvcmtlcnMnKVxuXG5jb25zdCBoYW5kbGVXb3JrZXJMb2NrUmVxdWVzdCA9IChlbWl0dGVyLCBtYXN0ZXJFdmVudCwgcmVxdWVzdFR5cGUsIHJlbGVhc2VUeXBlLCBncmFudFR5cGUpID0+IHtcbiAgcmV0dXJuICh3b3JrZXIsIGV2ZW50KSA9PiB7XG4gICAgaWYgKCFldmVudCB8fCAhZXZlbnQuZGF0YSB8fCBldmVudC5kYXRhLnR5cGUgIT09IHJlcXVlc3RUeXBlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0RXZlbnQgPSB7XG4gICAgICB0eXBlOiBldmVudC5kYXRhLnR5cGUsXG4gICAgICBuYW1lOiBldmVudC5kYXRhLm5hbWUsXG4gICAgICBpZGVudGlmaWVyOiBldmVudC5kYXRhLmlkZW50aWZpZXJcbiAgICB9XG5cbiAgICBlbWl0dGVyLmVtaXQobWFzdGVyRXZlbnQsIHJlcXVlc3RFdmVudC5uYW1lLCAoKSA9PiB7XG4gICAgICAvLyBncmFudCBsb2NrIHRvIHdvcmtlclxuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogZ3JhbnRUeXBlLFxuICAgICAgICBuYW1lOiByZXF1ZXN0RXZlbnQubmFtZSxcbiAgICAgICAgaWRlbnRpZmllcjogcmVxdWVzdEV2ZW50LmlkZW50aWZpZXJcbiAgICAgIH0pXG5cbiAgICAgIC8vIHdhaXQgZm9yIHdvcmtlciB0byBmaW5pc2hcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCByZWxlYXNlRXZlbnRMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgIGlmICghZXZlbnQgfHwgIWV2ZW50LmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlbGVhc2VFdmVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50LmRhdGEudHlwZSxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50LmRhdGEubmFtZSxcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGV2ZW50LmRhdGEuaWRlbnRpZmllclxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZWxlYXNlRXZlbnQgJiYgcmVsZWFzZUV2ZW50LnR5cGUgPT09IHJlbGVhc2VUeXBlICYmIHJlbGVhc2VFdmVudC5pZGVudGlmaWVyID09PSByZXF1ZXN0RXZlbnQuaWRlbnRpZmllcikge1xuICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCByZWxlYXNlRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgcmVsZWFzZUV2ZW50TGlzdGVuZXIpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxuY29uc3QgbWFrZVdvcmtlckxvY2tSZXF1ZXN0ID0gKGdsb2JhbCwgbmFtZSwgcmVxdWVzdFR5cGUsIGdyYW50VHlwZSwgcmVsZWFzZVR5cGUpID0+IHtcbiAgcmV0dXJuIChmbikgPT4ge1xuICAgIGNvbnN0IGlkID0gc2hvcnRpZC5nZW5lcmF0ZSgpXG5cbiAgICBnbG9iYWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogcmVxdWVzdFR5cGUsXG4gICAgICBpZGVudGlmaWVyOiBpZCxcbiAgICAgIG5hbWVcbiAgICB9KVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghZXZlbnQgfHwgIWV2ZW50LmRhdGEpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogZXZlbnQuZGF0YS50eXBlLFxuICAgICAgICAgIGlkZW50aWZpZXI6IGV2ZW50LmRhdGEuaWRlbnRpZmllclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlRXZlbnQgJiYgcmVzcG9uc2VFdmVudC50eXBlID09PSBncmFudFR5cGUgJiYgcmVzcG9uc2VFdmVudC5pZGVudGlmaWVyID09PSBpZCkge1xuICAgICAgICAgIGdsb2JhbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpXG5cbiAgICAgICAgICBsZXQgZXJyb3JcblxuICAgICAgICAgIGZuKClcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIGVycm9yID0gZXJyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IHJlbGVhc2VUeXBlLFxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkLFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyKVxuICAgIH0pXG4gIH1cbn1cblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGdsb2JhbDogZ2xvYmFsLFxuICBzaW5nbGVQcm9jZXNzOiBmYWxzZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcbiAgY29uc3QgaXNNYXN0ZXIgPSAhIW9wdGlvbnMuZ2xvYmFsLmRvY3VtZW50IHx8IG9wdGlvbnMuc2luZ2xlUHJvY2Vzc1xuXG4gIGlmIChpc01hc3Rlcikge1xuICAgIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKClcblxuICAgIG9ic2VydmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVXb3JrZXJMb2NrUmVxdWVzdChlbWl0dGVyLCAncmVxdWVzdFJlYWRMb2NrJywgV09SS0VSX1JFUVVFU1RfUkVBRF9MT0NLLCBXT1JLRVJfUkVMRUFTRV9SRUFEX0xPQ0ssIE1BU1RFUl9HUkFOVF9SRUFEX0xPQ0spKVxuICAgIG9ic2VydmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVXb3JrZXJMb2NrUmVxdWVzdChlbWl0dGVyLCAncmVxdWVzdFdyaXRlTG9jaycsIFdPUktFUl9SRVFVRVNUX1dSSVRFX0xPQ0ssIFdPUktFUl9SRUxFQVNFX1dSSVRFX0xPQ0ssIE1BU1RFUl9HUkFOVF9XUklURV9MT0NLKSlcblxuICAgIHJldHVybiBlbWl0dGVyXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzV29ya2VyOiB0cnVlLFxuICAgIHJlYWRMb2NrOiAobmFtZSwgb3B0aW9ucykgPT4gbWFrZVdvcmtlckxvY2tSZXF1ZXN0KG9wdGlvbnMuZ2xvYmFsLCBuYW1lLCBXT1JLRVJfUkVRVUVTVF9SRUFEX0xPQ0ssIE1BU1RFUl9HUkFOVF9SRUFEX0xPQ0ssIFdPUktFUl9SRUxFQVNFX1JFQURfTE9DSyksXG4gICAgd3JpdGVMb2NrOiAobmFtZSwgb3B0aW9ucykgPT4gbWFrZVdvcmtlckxvY2tSZXF1ZXN0KG9wdGlvbnMuZ2xvYmFsLCBuYW1lLCBXT1JLRVJfUkVRVUVTVF9XUklURV9MT0NLLCBNQVNURVJfR1JBTlRfV1JJVEVfTE9DSywgV09SS0VSX1JFTEVBU0VfV1JJVEVfTE9DSylcbiAgfVxufVxuIiwibGV0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IHsgdXJsQWxwaGFiZXQgfVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VDb250cm9sbGVyID0gdm9pZCAwO1xuLyoqXG4gKiBDb250cm9sbGVyIGNsYXNzIHRoYXQgcHJvdmlkZXMgY29uZmlndXJhdGlvbiwgc3RhdGUgbWFuYWdlbWVudCwgYW5kIHN1YnNjcmlwdGlvbnNcbiAqL1xuY2xhc3MgQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBCYXNlQ29udHJvbGxlciBpbnN0YW5jZS4gQm90aCBpbml0aWFsIHN0YXRlIGFuZCBpbml0aWFsXG4gICAgICogY29uZmlndXJhdGlvbiBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBkZWZhdWx0cyB1cG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSwgc3RhdGUgPSB7fSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IHN0YXRlIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIGxpc3RlbmVycyBhcmUgbm90aWZpZWQgb2Ygc3RhdGUgY2hhbmdlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdCYXNlQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxDb25maWcgPSB0aGlzLmRlZmF1bHRDb25maWc7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzID0gW107XG4gICAgICAgIC8vIFVzZSBhc3NpZ24gc2luY2UgZ2VuZXJpY3MgY2FuJ3QgYmUgc3ByZWFkOiBodHRwczovL2dpdC5pby92cFJoWVxuICAgICAgICB0aGlzLmluaXRpYWxTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmluaXRpYWxDb25maWcgPSBjb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIGNvbnRyb2xsZXIuIFRoaXMgc2V0cyBlYWNoIGNvbmZpZyBvcHRpb24gYXMgYSBtZW1iZXJcbiAgICAgKiB2YXJpYWJsZSBvbiB0aGlzIGluc3RhbmNlIGFuZCB0cmlnZ2VycyBhbnkgZGVmaW5lZCBzZXR0ZXJzLiBUaGlzXG4gICAgICogYWxzbyBzZXRzIGluaXRpYWwgc3RhdGUgYW5kIHRyaWdnZXJzIGFueSBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRoaXMgY29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgICAgICB0aGlzLmludGVybmFsQ29uZmlnID0gdGhpcy5kZWZhdWx0Q29uZmlnO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZSh0aGlzLmluaXRpYWxDb25maWcpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLmluaXRpYWxTdGF0ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgY3VycmVudCBjb250cm9sbGVyIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMgLSBDdXJyZW50IGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGN1cnJlbnQgY29udHJvbGxlciBzdGF0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBDdXJyZW50IHN0YXRlXG4gICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNvbnRyb2xsZXIgY29uZmlndXJhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIE5ldyBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3ZlcndyaXRlIC0gT3ZlcndyaXRlIGNvbmZpZyBpbnN0ZWFkIG9mIG1lcmdpbmdcbiAgICAgKiBAcGFyYW0gZnVsbFVwZGF0ZSAtIEJvb2xlYW4gdGhhdCBkZWZpbmVzIGlmIHRoZSB1cGRhdGUgaXMgcGFydGlhbCBvciBub3RcbiAgICAgKi9cbiAgICBjb25maWd1cmUoY29uZmlnLCBvdmVyd3JpdGUgPSBmYWxzZSwgZnVsbFVwZGF0ZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKGZ1bGxVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxDb25maWcgPSBvdmVyd3JpdGVcbiAgICAgICAgICAgICAgICA/IGNvbmZpZ1xuICAgICAgICAgICAgICAgIDogT2JqZWN0LmFzc2lnbih0aGlzLmludGVybmFsQ29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5pbnRlcm5hbENvbmZpZykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5pbnRlcm5hbENvbmZpZ1trZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB0aGlzLmludGVybmFsQ29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW50ZXJuYWxDb25maWdba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbENvbmZpZ1trZXldID0gY29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IGNvbmZpZ1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBsaXN0ZW5lcnMgb2YgY3VycmVudCBzdGF0ZVxuICAgICAqL1xuICAgIG5vdGlmeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lcih0aGlzLmludGVybmFsU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBuZXcgbGlzdGVuZXIgdG8gYmUgbm90aWZpZWQgb2Ygc3RhdGUgY2hhbmdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gQ2FsbGJhY2sgdHJpZ2dlcmVkIHdoZW4gc3RhdGUgY2hhbmdlc1xuICAgICAqL1xuICAgIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV4aXN0aW5nIGxpc3RlbmVyIGZyb20gcmVjZWl2aW5nIHN0YXRlIGNoYW5nZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIENhbGxiYWNrIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiBhIGxpc3RlbmVyIGlzIGZvdW5kIGFuZCB1bnN1YnNjcmliZWRcbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuZmluZEluZGV4KChjYikgPT4gbGlzdGVuZXIgPT09IGNiKTtcbiAgICAgICAgaW5kZXggPiAtMSAmJiB0aGlzLmludGVybmFsTGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNvbnRyb2xsZXIgc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIE5ldyBzdGF0ZVxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgLSBPdmVyd3JpdGUgc3RhdGUgaW5zdGVhZCBvZiBtZXJnaW5nXG4gICAgICovXG4gICAgdXBkYXRlKHN0YXRlLCBvdmVyd3JpdGUgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmludGVybmFsU3RhdGUgPSBvdmVyd3JpdGVcbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpXG4gICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW50ZXJuYWxTdGF0ZSwgc3RhdGUpO1xuICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUNvbnRyb2xsZXIgPSBCYXNlQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2VDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUNvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnRyb2xsZXJNZXNzZW5nZXIgPSBleHBvcnRzLlJlc3RyaWN0ZWRDb250cm9sbGVyTWVzc2VuZ2VyID0gdm9pZCAwO1xuLyoqXG4gKiBBIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXIuXG4gKlxuICogVGhpcyBhY3RzIGFzIGEgd3JhcHBlciBhcm91bmQgdGhlIGNvbnRyb2xsZXIgbWVzc2VuZ2VyIGluc3RhbmNlIHRoYXQgcmVzdHJpY3RzIGFjY2VzcyB0byBhY3Rpb25zXG4gKiBhbmQgZXZlbnRzLlxuICpcbiAqIEB0ZW1wbGF0ZSBOIC0gVGhlIG5hbWVzcGFjZSBmb3IgdGhpcyBtZXNzZW5nZXIuIFR5cGljYWxseSB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjb250cm9sbGVyIG9yXG4gKiAgIG1vZHVsZSB0aGF0IHRoaXMgbWVzc2VuZ2VyIGhhcyBiZWVuIGNyZWF0ZWQgZm9yLiBUaGUgYXV0aG9yaXR5IHRvIHB1Ymxpc2ggZXZlbnRzIGFuZCByZWdpc3RlclxuICogICBhY3Rpb25zIHVuZGVyIHRoaXMgbmFtZXNwYWNlIGlzIGdyYW50ZWQgdG8gdGhpcyByZXN0cmljdGVkIG1lc3NlbmdlciBpbnN0YW5jZS5cbiAqIEB0ZW1wbGF0ZSBBY3Rpb24gLSBBIHR5cGUgdW5pb24gb2YgYWxsIEFjdGlvbiB0eXBlcy5cbiAqIEB0ZW1wbGF0ZSBFdmVudCAtIEEgdHlwZSB1bmlvbiBvZiBhbGwgRXZlbnQgdHlwZXMuXG4gKiBAdGVtcGxhdGUgQWxsb3dlZEFjdGlvbiAtIEEgdHlwZSB1bmlvbiBvZiB0aGUgJ3R5cGUnIHN0cmluZyBmb3IgYW55IGFsbG93ZWQgYWN0aW9ucy5cbiAqIEB0ZW1wbGF0ZSBBbGxvd2VkRXZlbnQgLSBBIHR5cGUgdW5pb24gb2YgdGhlICd0eXBlJyBzdHJpbmcgZm9yIGFueSBhbGxvd2VkIGV2ZW50cy5cbiAqL1xuY2xhc3MgUmVzdHJpY3RlZENvbnRyb2xsZXJNZXNzZW5nZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSByZXN0cmljdGVkIGNvbnRyb2xsZXIgbWVzc2VuZ2VyXG4gICAgICpcbiAgICAgKiBUaGUgcHJvdmlkZWQgYWxsb3dsaXN0cyBncmFudCB0aGUgYWJpbGl0eSB0byBjYWxsIHRoZSBsaXN0ZWQgYWN0aW9ucyBhbmQgc3Vic2NyaWJlIHRvIHRoZVxuICAgICAqIGxpc3RlZCBldmVudHMuIFRoZSBcIm5hbWVcIiBwcm92aWRlZCBncmFudHMgb3duZXJzaGlwIG9mIGFueSBhY3Rpb25zIGFuZCBldmVudHMgdW5kZXIgdGhhdFxuICAgICAqIG5hbWVzcGFjZS4gT3duZXJzaGlwIGFsbG93cyByZWdpc3RlcmluZyBhY3Rpb25zIGFuZCBwdWJsaXNoaW5nIGV2ZW50cywgYXMgd2VsbCBhc1xuICAgICAqIHVucmVnaXN0ZXJpbmcgYWN0aW9ucyBhbmQgY2xlYXJpbmcgZXZlbnQgc3Vic2NyaXB0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY29udHJvbGxlck1lc3NlbmdlciAtIFRoZSBjb250cm9sbGVyIG1lc3NlbmdlciBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIHdyYXBwZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB0aGluZyB0aGlzIG1lc3NlbmdlciB3aWxsIGJlIGhhbmRlZCB0byAoZS5nLiB0aGVcbiAgICAgKiAgIGNvbnRyb2xsZXIgbmFtZSkuIFRoaXMgZ3JhbnRzIFwib3duZXJzaGlwXCIgb2YgYWN0aW9ucyBhbmQgZXZlbnRzIHVuZGVyIHRoaXMgbmFtZXNwYWNlIHRvIHRoZVxuICAgICAqICAgcmVzdHJpY3RlZCBjb250cm9sbGVyIG1lc3NlbmdlciByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkQWN0aW9ucyAtIFRoZSBsaXN0IG9mIGFjdGlvbnMgdGhhdCB0aGlzIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXJcbiAgICAgKiAgIHNob3VsZCBiZSBhbG93ZWQgdG8gY2FsbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkRXZlbnRzIC0gVGhlIGxpc3Qgb2YgZXZlbnRzIHRoYXQgdGhpcyByZXN0cmljdGVkIGNvbnRyb2xsZXIgbWVzc2VuZ2VyXG4gICAgICogICBzaG91bGQgYmUgYWxsb3dlZCB0byBzdWJzY3JpYmUgdG8uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBjb250cm9sbGVyTWVzc2VuZ2VyLCBuYW1lLCBhbGxvd2VkQWN0aW9ucywgYWxsb3dlZEV2ZW50cywgfSkge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIgPSBjb250cm9sbGVyTWVzc2VuZ2VyO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXJOYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGxvd2VkQWN0aW9ucyA9IGFsbG93ZWRBY3Rpb25zIHx8IG51bGw7XG4gICAgICAgIHRoaXMuYWxsb3dlZEV2ZW50cyA9IGFsbG93ZWRFdmVudHMgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gYWN0aW9uIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgbWFrZSB0aGUgcmVnaXN0ZXJlZCBmdW5jdGlvbiBhdmFpbGFibGUgdG8gY2FsbCB2aWEgdGhlIGBjYWxsYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBUaGUgYWN0aW9uIHR5cGUgdGhpcyBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgdW5kZXIgKm11c3QqIGJlIGluIHRoZSBjdXJyZW50IG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25UeXBlIC0gVGhlIGFjdGlvbiB0eXBlLiBUaGlzIGlzIGEgdW5xaXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYWN0aW9uLlxuICAgICAqIEBwYXJhbSBoYW5kbGVyLSBUaGUgYWN0aW9uIGhhbmRsZXIuIFRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgd2hlbiB0aGUgYGNhbGxgIG1ldGhvZCBpc1xuICAgICAqICAgaW52b2tlZCB3aXRoIHRoZSBnaXZlbiBhY3Rpb24gdHlwZS5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgd2hlbiBhIGhhbmRsZXIgaGFzIGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhpcyBhY3Rpb24gdHlwZSBhbHJlYWR5LlxuICAgICAqIEB0ZW1wbGF0ZSBUIC0gQSB0eXBlIHVuaW9uIG9mIEFjdGlvbiB0eXBlIHN0cmluZ3MgdGhhdCBhcmUgbmFtZXNwYWNlZCBieSBOLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyQWN0aW9uSGFuZGxlcihhY3Rpb24sIGhhbmRsZXIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vIEJyYW5jaCB1bnJlYWNoYWJsZSB3aXRoIHZhbGlkIHR5cGVzXG4gICAgICAgIGlmICghYWN0aW9uLnN0YXJ0c1dpdGgoYCR7dGhpcy5jb250cm9sbGVyTmFtZX06YCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSBhbGxvd2VkIHJlZ2lzdGVyaW5nIGFjdGlvbiBoYW5kbGVycyBwcmVmaXhlZCBieSAnJHt0aGlzLmNvbnRyb2xsZXJOYW1lfTonYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYWN0aW9uLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlciBhbiBhY3Rpb24gaGFuZGxlci5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBwcmV2ZW50IHRoaXMgYWN0aW9uIGZyb20gYmVpbmcgY2FsbGVkLlxuICAgICAqXG4gICAgICogVGhlIGFjdGlvbiB0eXBlIGJlaW5nIHVucmVnaXN0ZXJlZCAqbXVzdCogYmUgaW4gdGhlIGN1cnJlbnQgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFjdGlvblR5cGUgLSBUaGUgYWN0aW9uIHR5cGUuIFRoaXMgaXMgYSB1bnFpdWUgaWRlbnRpZmllciBmb3IgdGhpcyBhY3Rpb24uXG4gICAgICogQHRlbXBsYXRlIFQgLSBBIHR5cGUgdW5pb24gb2YgQWN0aW9uIHR5cGUgc3RyaW5ncyB0aGF0IGFyZSBuYW1lc3BhY2VkIGJ5IE4uXG4gICAgICovXG4gICAgdW5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYWN0aW9uKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyBCcmFuY2ggdW5yZWFjaGFibGUgd2l0aCB2YWxpZCB0eXBlc1xuICAgICAgICBpZiAoIWFjdGlvbi5zdGFydHNXaXRoKGAke3RoaXMuY29udHJvbGxlck5hbWV9OmApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgYWxsb3dlZCB1bnJlZ2lzdGVyaW5nIGFjdGlvbiBoYW5kbGVycyBwcmVmaXhlZCBieSAnJHt0aGlzLmNvbnRyb2xsZXJOYW1lfTonYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci51bnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihhY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIGFuIGFjdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBjYWxsIHRoZSBhY3Rpb24gaGFuZGxlciBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBhY3Rpb24gdHlwZSwgcGFzc2luZ1xuICAgICAqIGFsb25nIGFueSBwYXJhbWV0ZXJzIGdpdmVuLlxuICAgICAqXG4gICAgICogVGhlIGFjdGlvbiB0eXBlIGJlaW5nIGNhbGxlZCBtdXN0IGJlIG9uIHRoZSBhY3Rpb24gYWxsb3dsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFjdGlvblR5cGUgLSBUaGUgYWN0aW9uIHR5cGUuIFRoaXMgaXMgYSB1bnFpdWUgaWRlbnRpZmllciBmb3IgdGhpcyBhY3Rpb24uXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBhY3Rpb24gcGFyYW1ldGVycy4gVGhlc2UgbXVzdCBtYXRjaCB0aGUgdHlwZSBvZiB0aGUgcGFyYW1ldGVycyBvZiB0aGVcbiAgICAgKiAgIHJlZ2lzdGVyZWQgYWN0aW9uIGhhbmRsZXIuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IHdoZW4gbm8gaGFuZGxlciBoYXMgYmVlbiByZWdpc3RlcmVkIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAgICAgKiBAdGVtcGxhdGUgVCAtIEEgdHlwZSB1bmlvbiBvZiBhbGxvd2VkIEFjdGlvbiB0eXBlIHN0cmluZ3MuXG4gICAgICovXG4gICAgY2FsbChhY3Rpb24sIC4uLnBhcmFtcykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAvLyBCcmFuY2hlcyB1bnJlYWNoYWJsZSB3aXRoIHZhbGlkIHR5cGVzXG4gICAgICAgIGlmICh0aGlzLmFsbG93ZWRBY3Rpb25zID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGlvbnMgYWxsb3dlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmFsbG93ZWRBY3Rpb25zLmluY2x1ZGVzKGFjdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWN0aW9uIG1pc3NpbmcgZnJvbSBhbGxvdyBsaXN0OiAke2FjdGlvbn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLmNhbGwoYWN0aW9uLCAuLi5wYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogUHVibGlzaGVzIHRoZSBnaXZlbiBwYXlsb2FkIHRvIGFsbCBzdWJzY3JpYmVycyBvZiB0aGUgZ2l2ZW4gZXZlbnQgdHlwZS5cbiAgICAgKlxuICAgICAqIFRoZSBldmVudCB0eXBlIGJlaW5nIHB1Ymxpc2hlZCAqbXVzdCogYmUgaW4gdGhlIGN1cnJlbnQgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFRoZSBldmVudCB0eXBlLiBUaGlzIGlzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZXZlbnQuXG4gICAgICogQHBhcmFtIHBheWxvYWQgLSBUaGUgZXZlbnQgcGF5bG9hZC4gVGhlIHR5cGUgb2YgdGhlIHBhcmFtZXRlcnMgZm9yIGVhY2ggZXZlbnQgaGFuZGxlciBtdXN0XG4gICAgICogICBtYXRjaCB0aGUgdHlwZSBvZiB0aGlzIHBheWxvYWQuXG4gICAgICogQHRlbXBsYXRlIEUgLSBBIHR5cGUgdW5pb24gb2YgRXZlbnQgdHlwZSBzdHJpbmdzIHRoYXQgYXJlIG5hbWVzcGFjZWQgYnkgTi5cbiAgICAgKi9cbiAgICBwdWJsaXNoKGV2ZW50LCAuLi5wYXlsb2FkKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyBCcmFuY2ggdW5yZWFjaGFibGUgd2l0aCB2YWxpZCB0eXBlc1xuICAgICAgICBpZiAoIWV2ZW50LnN0YXJ0c1dpdGgoYCR7dGhpcy5jb250cm9sbGVyTmFtZX06YCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSBhbGxvd2VkIHB1Ymxpc2hpbmcgZXZlbnRzIHByZWZpeGVkIGJ5ICcke3RoaXMuY29udHJvbGxlck5hbWV9OidgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLnB1Ymxpc2goZXZlbnQsIC4uLnBheWxvYWQpO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoZXZlbnQsIGhhbmRsZXIsIHNlbGVjdG9yKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIC8vIEJyYW5jaGVzIHVucmVhY2hhYmxlIHdpdGggdmFsaWQgdHlwZXNcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dlZEV2ZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldmVudHMgYWxsb3dlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmFsbG93ZWRFdmVudHMuaW5jbHVkZXMoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV2ZW50IG1pc3NpbmcgZnJvbSBhbGxvdyBsaXN0OiAke2V2ZW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUoZXZlbnQsIGhhbmRsZXIsIHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLnN1YnNjcmliZShldmVudCwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBVbnJlZ2lzdGVycyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYXMgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhlIGV2ZW50IHR5cGUgYmVpbmcgdW5zdWJzY3JpYmVkIHRvIG11c3QgYmUgb24gdGhlIGV2ZW50IGFsbG93bGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBUaGUgZXZlbnQgdHlwZS4gVGhpcyBpcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAqIEBwYXJhbSBoYW5kbGVyIC0gVGhlIGV2ZW50IGhhbmRsZXIgdG8gdW5yZWdpc3Rlci5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgd2hlbiB0aGUgZ2l2ZW4gZXZlbnQgaGFuZGxlciBpcyBub3QgcmVnaXN0ZXJlZCBmb3IgdGhpcyBldmVudC5cbiAgICAgKiBAdGVtcGxhdGUgVCAtIEEgdHlwZSB1bmlvbiBvZiBhbGxvd2VkIEV2ZW50IHR5cGUgc3RyaW5ncy5cbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZShldmVudCwgaGFuZGxlcikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAvLyBCcmFuY2hlcyB1bnJlYWNoYWJsZSB3aXRoIHZhbGlkIHR5cGVzXG4gICAgICAgIGlmICh0aGlzLmFsbG93ZWRFdmVudHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXZlbnRzIGFsbG93ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5hbGxvd2VkRXZlbnRzLmluY2x1ZGVzKGV2ZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFdmVudCBtaXNzaW5nIGZyb20gYWxsb3cgbGlzdDogJHtldmVudH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLnVuc3Vic2NyaWJlKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgc3Vic2NyaXB0aW9ucyBmb3IgYSBzcGVjaWZpYyBldmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCByZW1vdmUgYWxsIHN1YnNjcmliZWQgaGFuZGxlcnMgZm9yIHRoaXMgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGUgZXZlbnQgdHlwZSBiZWluZyBjbGVhcmVkICptdXN0KiBiZSBpbiB0aGUgY3VycmVudCBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gVGhlIGV2ZW50IHR5cGUuIFRoaXMgaXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBldmVudC5cbiAgICAgKiBAdGVtcGxhdGUgRSAtIEEgdHlwZSB1bmlvbiBvZiBFdmVudCB0eXBlIHN0cmluZ3MgdGhhdCBhcmUgbmFtZXNwYWNlZCBieSBOLlxuICAgICAqL1xuICAgIGNsZWFyRXZlbnRTdWJzY3JpcHRpb25zKGV2ZW50KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyBCcmFuY2ggdW5yZWFjaGFibGUgd2l0aCB2YWxpZCB0eXBlc1xuICAgICAgICBpZiAoIWV2ZW50LnN0YXJ0c1dpdGgoYCR7dGhpcy5jb250cm9sbGVyTmFtZX06YCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSBhbGxvd2VkIGNsZWFyaW5nIGV2ZW50cyBwcmVmaXhlZCBieSAnJHt0aGlzLmNvbnRyb2xsZXJOYW1lfTonYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5jbGVhckV2ZW50U3Vic2NyaXB0aW9ucyhldmVudCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXN0cmljdGVkQ29udHJvbGxlck1lc3NlbmdlciA9IFJlc3RyaWN0ZWRDb250cm9sbGVyTWVzc2VuZ2VyO1xuLyoqXG4gKiBBIG1lc3NhZ2luZyBzeXN0ZW0gZm9yIGNvbnRyb2xsZXJzLlxuICpcbiAqIFRoZSBjb250cm9sbGVyIG1lc3NlbmdlciBhbGxvd3MgcmVnaXN0ZXJpbmcgZnVuY3Rpb25zIGFzICdhY3Rpb25zJyB0aGF0IGNhbiBiZSBjYWxsZWQgZWxzZXdoZXJlLFxuICogYW5kIGl0IGFsbG93cyBwdWJsaXNoaW5nIGFuZCBzdWJzY3JpYmluZyB0byBldmVudHMuIEJvdGggYWN0aW9ucyBhbmQgZXZlbnRzIGFyZSBpZGVudGlmaWVkIGJ5XG4gKiB1bmlxdWUgc3RyaW5ncy5cbiAqXG4gKiBAdGVtcGxhdGUgQWN0aW9uIC0gQSB0eXBlIHVuaW9uIG9mIGFsbCBBY3Rpb24gdHlwZXMuXG4gKiBAdGVtcGxhdGUgRXZlbnQgLSBBIHR5cGUgdW5pb24gb2YgYWxsIEV2ZW50IHR5cGVzLlxuICovXG5jbGFzcyBDb250cm9sbGVyTWVzc2VuZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FjaGUgb2Ygc2VsZWN0b3IgcmV0dXJuIHZhbHVlcyBmb3IgdGhlaXIgcmVzcGVjdGl2ZSBoYW5kbGVycy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnRQYXlsb2FkQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFuIGFjdGlvbiBoYW5kbGVyLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIG1ha2UgdGhlIHJlZ2lzdGVyZWQgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGNhbGwgdmlhIHRoZSBgY2FsbGAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFjdGlvblR5cGUgLSBUaGUgYWN0aW9uIHR5cGUuIFRoaXMgaXMgYSB1bnFpdWUgaWRlbnRpZmllciBmb3IgdGhpcyBhY3Rpb24uXG4gICAgICogQHBhcmFtIGhhbmRsZXItIFRoZSBhY3Rpb24gaGFuZGxlci4gVGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCB3aGVuIHRoZSBgY2FsbGAgbWV0aG9kIGlzXG4gICAgICogICBpbnZva2VkIHdpdGggdGhlIGdpdmVuIGFjdGlvbiB0eXBlLlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyB3aGVuIGEgaGFuZGxlciBoYXMgYmVlbiByZWdpc3RlcmVkIGZvciB0aGlzIGFjdGlvbiB0eXBlIGFscmVhZHkuXG4gICAgICogQHRlbXBsYXRlIFQgLSBBIHR5cGUgdW5pb24gb2YgQWN0aW9uIHR5cGUgc3RyaW5ncy5cbiAgICAgKi9cbiAgICByZWdpc3RlckFjdGlvbkhhbmRsZXIoYWN0aW9uVHlwZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAodGhpcy5hY3Rpb25zLmhhcyhhY3Rpb25UeXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGhhbmRsZXIgZm9yICR7YWN0aW9uVHlwZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3Rpb25zLnNldChhY3Rpb25UeXBlLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlciBhbiBhY3Rpb24gaGFuZGxlci5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBwcmV2ZW50IHRoaXMgYWN0aW9uIGZyb20gYmVpbmcgY2FsbGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFjdGlvblR5cGUgLSBUaGUgYWN0aW9uIHR5cGUuIFRoaXMgaXMgYSB1bnFpdWUgaWRlbnRpZmllciBmb3IgdGhpcyBhY3Rpb24uXG4gICAgICogQHRlbXBsYXRlIFQgLSBBIHR5cGUgdW5pb24gb2YgQWN0aW9uIHR5cGUgc3RyaW5ncy5cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihhY3Rpb25UeXBlKSB7XG4gICAgICAgIHRoaXMuYWN0aW9ucy5kZWxldGUoYWN0aW9uVHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXIgYWxsIGFjdGlvbiBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIFRoaXMgcHJldmVudHMgYWxsIGFjdGlvbnMgZnJvbSBiZWluZyBjYWxsZWQuXG4gICAgICovXG4gICAgY2xlYXJBY3Rpb25zKCkge1xuICAgICAgICB0aGlzLmFjdGlvbnMuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBhbiBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgY2FsbCB0aGUgYWN0aW9uIGhhbmRsZXIgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYWN0aW9uIHR5cGUsIHBhc3NpbmdcbiAgICAgKiBhbG9uZyBhbnkgcGFyYW1ldGVycyBnaXZlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25UeXBlIC0gVGhlIGFjdGlvbiB0eXBlLiBUaGlzIGlzIGEgdW5xaXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYWN0aW9uLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgYWN0aW9uIHBhcmFtZXRlcnMuIFRoZXNlIG11c3QgbWF0Y2ggdGhlIHR5cGUgb2YgdGhlIHBhcmFtZXRlcnMgb2YgdGhlXG4gICAgICogICByZWdpc3RlcmVkIGFjdGlvbiBoYW5kbGVyLlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyB3aGVuIG5vIGhhbmRsZXIgaGFzIGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gICAgICogQHRlbXBsYXRlIFQgLSBBIHR5cGUgdW5pb24gb2YgQWN0aW9uIHR5cGUgc3RyaW5ncy5cbiAgICAgKi9cbiAgICBjYWxsKGFjdGlvblR5cGUsIC4uLnBhcmFtcykge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5hY3Rpb25zLmdldChhY3Rpb25UeXBlKTtcbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgaGFuZGxlciBmb3IgJHthY3Rpb25UeXBlfSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVyKC4uLnBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBQdWJsaXNoZXMgdGhlIGdpdmVuIHBheWxvYWQgdG8gYWxsIHN1YnNjcmliZXJzIG9mIHRoZSBnaXZlbiBldmVudCB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFRoZSBldmVudCB0eXBlLiBUaGlzIGlzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZXZlbnQuXG4gICAgICogQHBhcmFtIHBheWxvYWQgLSBUaGUgZXZlbnQgcGF5bG9hZC4gVGhlIHR5cGUgb2YgdGhlIHBhcmFtZXRlcnMgZm9yIGVhY2ggZXZlbnQgaGFuZGxlciBtdXN0XG4gICAgICogICBtYXRjaCB0aGUgdHlwZSBvZiB0aGlzIHBheWxvYWQuXG4gICAgICogQHRlbXBsYXRlIEUgLSBBIHR5cGUgdW5pb24gb2YgRXZlbnQgdHlwZSBzdHJpbmdzLlxuICAgICAqL1xuICAgIHB1Ymxpc2goZXZlbnRUeXBlLCAuLi5wYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJzID0gdGhpcy5ldmVudHMuZ2V0KGV2ZW50VHlwZSk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaGFuZGxlciwgc2VsZWN0b3JdIG9mIHN1YnNjcmliZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5ldmVudFBheWxvYWRDYWNoZS5nZXQoaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gc2VsZWN0b3IoLi4ucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gcHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudFBheWxvYWRDYWNoZS5zZXQoaGFuZGxlciwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoLi4ucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZShldmVudFR5cGUsIGhhbmRsZXIsIHNlbGVjdG9yKSB7XG4gICAgICAgIGxldCBzdWJzY3JpYmVycyA9IHRoaXMuZXZlbnRzLmdldChldmVudFR5cGUpO1xuICAgICAgICBpZiAoIXN1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnNldChldmVudFR5cGUsIHN1YnNjcmliZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVycy5zZXQoaGFuZGxlciwgc2VsZWN0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZSBmcm9tIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogVW5yZWdpc3RlcnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGFzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBUaGUgZXZlbnQgdHlwZS4gVGhpcyBpcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAqIEBwYXJhbSBoYW5kbGVyIC0gVGhlIGV2ZW50IGhhbmRsZXIgdG8gdW5yZWdpc3Rlci5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgd2hlbiB0aGUgZ2l2ZW4gZXZlbnQgaGFuZGxlciBpcyBub3QgcmVnaXN0ZXJlZCBmb3IgdGhpcyBldmVudC5cbiAgICAgKiBAdGVtcGxhdGUgRSAtIEEgdHlwZSB1bmlvbiBvZiBFdmVudCB0eXBlIHN0cmluZ3MuXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUoZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJzID0gdGhpcy5ldmVudHMuZ2V0KGV2ZW50VHlwZSk7XG4gICAgICAgIGlmICghc3Vic2NyaWJlcnMgfHwgIXN1YnNjcmliZXJzLmhhcyhoYW5kbGVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJzY3JpcHRpb24gbm90IGZvdW5kIGZvciBldmVudDogJHtldmVudFR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBzdWJzY3JpYmVycy5nZXQoaGFuZGxlcik7XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5ldmVudFBheWxvYWRDYWNoZS5kZWxldGUoaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlcnMuZGVsZXRlKGhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBzdWJzY3JpcHRpb25zIGZvciBhIHNwZWNpZmljIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIHJlbW92ZSBhbGwgc3Vic2NyaWJlZCBoYW5kbGVycyBmb3IgdGhpcyBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBUaGUgZXZlbnQgdHlwZS4gVGhpcyBpcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAqIEB0ZW1wbGF0ZSBFIC0gQSB0eXBlIHVuaW9uIG9mIEV2ZW50IHR5cGUgc3RyaW5ncy5cbiAgICAgKi9cbiAgICBjbGVhckV2ZW50U3Vic2NyaXB0aW9ucyhldmVudFR5cGUpIHtcbiAgICAgICAgdGhpcy5ldmVudHMuZGVsZXRlKGV2ZW50VHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBzdWJzY3JpcHRpb25zLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIHJlbW92ZSBhbGwgc3Vic2NyaWJlZCBoYW5kbGVycyBmb3IgYWxsIGV2ZW50cy5cbiAgICAgKi9cbiAgICBjbGVhclN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXJcbiAgICAgKlxuICAgICAqIFJldHVybnMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgY29udHJvbGxlciBtZXNzZW5nZXIgaW5zdGFuY2UgdGhhdCByZXN0cmljdHMgYWNjZXNzIHRvIGFjdGlvbnNcbiAgICAgKiBhbmQgZXZlbnRzLiBUaGUgcHJvdmlkZWQgYWxsb3dsaXN0cyBncmFudCB0aGUgYWJpbGl0eSB0byBjYWxsIHRoZSBsaXN0ZWQgYWN0aW9ucyBhbmQgc3Vic2NyaWJlXG4gICAgICogdG8gdGhlIGxpc3RlZCBldmVudHMuIFRoZSBcIm5hbWVcIiBwcm92aWRlZCBncmFudHMgb3duZXJzaGlwIG9mIGFueSBhY3Rpb25zIGFuZCBldmVudHMgdW5kZXJcbiAgICAgKiB0aGF0IG5hbWVzcGFjZS4gT3duZXJzaGlwIGFsbG93cyByZWdpc3RlcmluZyBhY3Rpb25zIGFuZCBwdWJsaXNoaW5nIGV2ZW50cywgYXMgd2VsbCBhc1xuICAgICAqIHVucmVnaXN0ZXJpbmcgYWN0aW9ucyBhbmQgY2xlYXJpbmcgZXZlbnQgc3Vic2NyaXB0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB0aGluZyB0aGlzIG1lc3NlbmdlciB3aWxsIGJlIGhhbmRlZCB0byAoZS5nLiB0aGVcbiAgICAgKiAgIGNvbnRyb2xsZXIgbmFtZSkuIFRoaXMgZ3JhbnRzIFwib3duZXJzaGlwXCIgb2YgYWN0aW9ucyBhbmQgZXZlbnRzIHVuZGVyIHRoaXMgbmFtZXNwYWNlIHRvIHRoZVxuICAgICAqICAgcmVzdHJpY3RlZCBjb250cm9sbGVyIG1lc3NlbmdlciByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkQWN0aW9ucyAtIFRoZSBsaXN0IG9mIGFjdGlvbnMgdGhhdCB0aGlzIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXJcbiAgICAgKiAgIHNob3VsZCBiZSBhbG93ZWQgdG8gY2FsbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkRXZlbnRzIC0gVGhlIGxpc3Qgb2YgZXZlbnRzIHRoYXQgdGhpcyByZXN0cmljdGVkIGNvbnRyb2xsZXIgbWVzc2VuZ2VyXG4gICAgICogICBzaG91bGQgYmUgYWxsb3dlZCB0byBzdWJzY3JpYmUgdG8uXG4gICAgICogQHRlbXBsYXRlIE4gLSBUaGUgbmFtZXNwYWNlIGZvciB0aGlzIG1lc3Nlbmdlci4gVHlwaWNhbGx5IHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGNvbnRyb2xsZXIgb3JcbiAgICAgKiAgIG1vZHVsZSB0aGF0IHRoaXMgbWVzc2VuZ2VyIGhhcyBiZWVuIGNyZWF0ZWQgZm9yLiBUaGUgYXV0aG9yaXR5IHRvIHB1Ymxpc2ggZXZlbnRzIGFuZCByZWdpc3RlclxuICAgICAqICAgYWN0aW9ucyB1bmRlciB0aGlzIG5hbWVzcGFjZSBpcyBncmFudGVkIHRvIHRoaXMgcmVzdHJpY3RlZCBtZXNzZW5nZXIgaW5zdGFuY2UuXG4gICAgICogQHRlbXBsYXRlIEFsbG93ZWRBY3Rpb24gLSBBIHR5cGUgdW5pb24gb2YgdGhlICd0eXBlJyBzdHJpbmcgZm9yIGFueSBhbGxvd2VkIGFjdGlvbnMuXG4gICAgICogQHRlbXBsYXRlIEFsbG93ZWRFdmVudCAtIEEgdHlwZSB1bmlvbiBvZiB0aGUgJ3R5cGUnIHN0cmluZyBmb3IgYW55IGFsbG93ZWQgZXZlbnRzLlxuICAgICAqL1xuICAgIGdldFJlc3RyaWN0ZWQoeyBuYW1lLCBhbGxvd2VkQWN0aW9ucywgYWxsb3dlZEV2ZW50cywgfSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3RyaWN0ZWRDb250cm9sbGVyTWVzc2VuZ2VyKHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXJNZXNzZW5nZXI6IHRoaXMsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYWxsb3dlZEFjdGlvbnMsXG4gICAgICAgICAgICBhbGxvd2VkRXZlbnRzLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRyb2xsZXJNZXNzZW5nZXIgPSBDb250cm9sbGVyTWVzc2VuZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udHJvbGxlck1lc3Nlbmdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcG9zYWJsZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4vQmFzZUNvbnRyb2xsZXJcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBjb21wb3NlIG11bHRpcGxlIGNvbnRyb2xsZXJzIHRvZ2V0aGVyXG4gKi9cbmNsYXNzIENvbXBvc2FibGVDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIENvbXBvc2FibGVDb250cm9sbGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJvbGxlcnMgLSBNYXAgb2YgbmFtZXMgdG8gY29udHJvbGxlciBpbnN0YW5jZXNcbiAgICAgKiBAcGFyYW0gbWVzc2VuZ2VyIC0gVGhlIGNvbnRyb2xsZXIgbWVzc2FnaW5nIHN5c3RlbSwgdXNlZCBmb3IgY29tbXVuaWNhdGluZyB3aXRoIEJhc2VDb250cm9sbGVyVjIgY29udHJvbGxlcnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cm9sbGVycywgbWVzc2VuZ2VyKSB7XG4gICAgICAgIHN1cGVyKHVuZGVmaW5lZCwgY29udHJvbGxlcnMucmVkdWNlKChzdGF0ZSwgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgc3RhdGVbY29udHJvbGxlci5uYW1lXSA9IGNvbnRyb2xsZXIuc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0sIHt9KSk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnQ29tcG9zYWJsZUNvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVycyA9IGNvbnRyb2xsZXJzO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbSA9IG1lc3NlbmdlcjtcbiAgICAgICAgdGhpcy5jb250cm9sbGVycy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUgfSA9IGNvbnRyb2xsZXI7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5zdWJzY3JpYmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuc3Vic2NyaWJlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IFtuYW1lXTogc3RhdGUgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1lc3NhZ2luZ1N5c3RlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnN1YnNjcmliZShgJHtuYW1lfTpzdGF0ZUNoYW5nZWAsIChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IFtuYW1lXTogc3RhdGUgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2luZyBzeXN0ZW0gcmVxdWlyZWQgaWYgYW55IEJhc2VDb250cm9sbGVyVjIgY29udHJvbGxlcnMgYXJlIHVzZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsYXQgc3RhdGUgcmVwcmVzZW50YXRpb24sIG9uZSB0aGF0IGlzbid0IGtleWVkXG4gICAgICogb2YgY29udHJvbGxlciBuYW1lLiBJbnN0ZWFkLCBhbGwgY2hpbGQgY29udHJvbGxlciBzdGF0ZSBpcyBtZXJnZWRcbiAgICAgKiB0b2dldGhlciBpbnRvIGEgc2luZ2xlLCBmbGF0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gTWVyZ2VkIHN0YXRlIHJlcHJlc2VudGF0aW9uIG9mIGFsbCBjaGlsZCBjb250cm9sbGVyc1xuICAgICAqL1xuICAgIGdldCBmbGF0U3RhdGUoKSB7XG4gICAgICAgIGxldCBmbGF0U3RhdGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMpIHtcbiAgICAgICAgICAgIGZsYXRTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmxhdFN0YXRlKSwgY29udHJvbGxlci5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXRTdGF0ZTtcbiAgICB9XG59XG5leHBvcnRzLkNvbXBvc2FibGVDb250cm9sbGVyID0gQ29tcG9zYWJsZUNvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBDb21wb3NhYmxlQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXBvc2FibGVDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzQm9va0NvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBtYW5hZ2VzIGEgbGlzdCBvZiByZWNpcGllbnQgYWRkcmVzc2VzIGFzc29jaWF0ZWQgd2l0aCBuaWNrbmFtZXNcbiAqL1xuY2xhc3MgQWRkcmVzc0Jvb2tDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBBZGRyZXNzQm9va0NvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnQWRkcmVzc0Jvb2tDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7IGFkZHJlc3NCb29rOiB7fSB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBjb250cmFjdCBlbnRyaWVzXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgYWRkcmVzc0Jvb2s6IHt9IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBjb250cmFjdCBlbnRyeSBieSBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhaW5JZCAtIENoYWluIGlkIGlkZW50aWZpZXMgdGhlIGN1cnJlbnQgY2hhaW5cbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIFJlY2lwaWVudCBhZGRyZXNzIHRvIGRlbGV0ZVxuICAgICAqL1xuICAgIGRlbGV0ZShjaGFpbklkLCBhZGRyZXNzKSB7XG4gICAgICAgIGFkZHJlc3MgPSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGlmICghdXRpbF8xLmlzVmFsaWRIZXhBZGRyZXNzKGFkZHJlc3MpIHx8XG4gICAgICAgICAgICAhdGhpcy5zdGF0ZS5hZGRyZXNzQm9va1tjaGFpbklkXSB8fFxuICAgICAgICAgICAgIXRoaXMuc3RhdGUuYWRkcmVzc0Jvb2tbY2hhaW5JZF1bYWRkcmVzc10pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzQm9vayA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUuYWRkcmVzc0Jvb2spO1xuICAgICAgICBkZWxldGUgYWRkcmVzc0Jvb2tbY2hhaW5JZF1bYWRkcmVzc107XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhhZGRyZXNzQm9va1tjaGFpbklkXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgYWRkcmVzc0Jvb2tbY2hhaW5JZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoeyBhZGRyZXNzQm9vayB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBvciB1cGRhdGUgYSBjb250YWN0IGVudHJ5IGJ5IGFkZHJlc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gUmVjaXBpZW50IGFkZHJlc3MgdG8gYWRkIG9yIHVwZGF0ZVxuICAgICAqIEBwYXJhbSBuYW1lIC0gTmlja25hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBhZGRyZXNzXG4gICAgICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbiBpZCBpZGVudGlmaWVzIHRoZSBjdXJyZW50IGNoYWluXG4gICAgICogQHBhcmFtIG1lbW8gLSBVc2VyJ3Mgbm90ZSBhYm91dCBhZGRyZXNzXG4gICAgICogQHJldHVybnMgLSBCb29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGFkZHJlc3Mgd2FzIHN1Y2Nlc3NmdWxseSBzZXRcbiAgICAgKi9cbiAgICBzZXQoYWRkcmVzcywgbmFtZSwgY2hhaW5JZCA9ICcxJywgbWVtbyA9ICcnKSB7XG4gICAgICAgIGFkZHJlc3MgPSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGlmICghdXRpbF8xLmlzVmFsaWRIZXhBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgIGlzRW5zOiBmYWxzZSxcbiAgICAgICAgICAgIG1lbW8sXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbnNOYW1lID0gdXRpbF8xLm5vcm1hbGl6ZUVuc05hbWUobmFtZSk7XG4gICAgICAgIGlmIChlbnNOYW1lKSB7XG4gICAgICAgICAgICBlbnRyeS5uYW1lID0gZW5zTmFtZTtcbiAgICAgICAgICAgIGVudHJ5LmlzRW5zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBhZGRyZXNzQm9vazogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLmFkZHJlc3NCb29rKSwgeyBbY2hhaW5JZF06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5hZGRyZXNzQm9va1tjaGFpbklkXSksIHsgW2FkZHJlc3NdOiBlbnRyeSB9KSB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQWRkcmVzc0Jvb2tDb250cm9sbGVyID0gQWRkcmVzc0Jvb2tDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWRkcmVzc0Jvb2tDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWRkcmVzc0Jvb2tDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzc2V0c0RldGVjdGlvbkNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5jb25zdCBERUZBVUxUX0lOVEVSVkFMID0gMTgwMDAwO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgcGFzc2l2ZWx5IHBvbGxzIG9uIGEgc2V0IGludGVydmFsIGZvciBhc3NldHMgYXV0byBkZXRlY3Rpb25cbiAqL1xuY2xhc3MgQXNzZXRzRGV0ZWN0aW9uQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBBc3NldHNEZXRlY3Rpb25Db250cm9sbGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uQ29sbGVjdGlibGVzU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gYXNzZXRzIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uVG9rZW5zU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gdG9rZW5zIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBwcmVmZXJlbmNlcyBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbk5ldHdvcmtTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBuZXR3b3JrIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldE9wZW5TZWFBcGlLZXkgLSBHZXRzIHRoZSBPcGVuU2VhIEFQSSBrZXksIGlmIG9uZSBpcyBzZXRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRCYWxhbmNlc0luU2luZ2xlQ2FsbCAtIEdldHMgdGhlIGJhbGFuY2VzIG9mIGEgbGlzdCBvZiB0b2tlbnMgZm9yIHRoZSBnaXZlbiBhZGRyZXNzXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWRkVG9rZW5zIC0gQWRkIGEgbGlzdCBvZiB0b2tlbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hZGRDb2xsZWN0aWJsZSAtIEFkZCBhIGNvbGxlY3RpYmxlXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0Q29sbGVjdGlibGVzU3RhdGUgLSBHZXRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBBc3NldHMgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldFRva2VuTGlzdFN0YXRlIC0gR2V0cyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgVG9rZW5MaXN0IGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRUb2tlbnNTdGF0ZSAtIEdldHMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIFRva2VucyBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG9uVG9rZW5zU3RhdGVDaGFuZ2UsIG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSwgb25OZXR3b3JrU3RhdGVDaGFuZ2UsIGdldE9wZW5TZWFBcGlLZXksIGdldEJhbGFuY2VzSW5TaW5nbGVDYWxsLCBhZGRUb2tlbnMsIGFkZENvbGxlY3RpYmxlLCBnZXRDb2xsZWN0aWJsZXNTdGF0ZSwgZ2V0VG9rZW5MaXN0U3RhdGUsIGdldFRva2Vuc1N0YXRlLCB9LCBjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdBc3NldHNEZXRlY3Rpb25Db250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgaW50ZXJ2YWw6IERFRkFVTFRfSU5URVJWQUwsXG4gICAgICAgICAgICBuZXR3b3JrVHlwZTogY29uc3RhbnRzXzEuTUFJTk5FVCxcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzczogJycsXG4gICAgICAgICAgICB0b2tlbnM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5nZXRDb2xsZWN0aWJsZXNTdGF0ZSA9IGdldENvbGxlY3RpYmxlc1N0YXRlO1xuICAgICAgICB0aGlzLmdldFRva2Vuc1N0YXRlID0gZ2V0VG9rZW5zU3RhdGU7XG4gICAgICAgIHRoaXMuZ2V0VG9rZW5MaXN0U3RhdGUgPSBnZXRUb2tlbkxpc3RTdGF0ZTtcbiAgICAgICAgdGhpcy5hZGRUb2tlbnMgPSBhZGRUb2tlbnM7XG4gICAgICAgIG9uVG9rZW5zU3RhdGVDaGFuZ2UoKHsgdG9rZW5zIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHsgdG9rZW5zIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlKCh7IHNlbGVjdGVkQWRkcmVzcyB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxTZWxlY3RlZEFkZHJlc3MgPSB0aGlzLmNvbmZpZy5zZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRBZGRyZXNzICE9PSBhY3R1YWxTZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IHNlbGVjdGVkQWRkcmVzcyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGVjdEFzc2V0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2UoKHsgcHJvdmlkZXIgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyBuZXR3b3JrVHlwZTogcHJvdmlkZXIudHlwZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2V0T3BlblNlYUFwaUtleSA9IGdldE9wZW5TZWFBcGlLZXk7XG4gICAgICAgIHRoaXMuZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGwgPSBnZXRCYWxhbmNlc0luU2luZ2xlQ2FsbDtcbiAgICAgICAgdGhpcy5hZGRDb2xsZWN0aWJsZSA9IGFkZENvbGxlY3RpYmxlO1xuICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICB9XG4gICAgZ2V0T3duZXJDb2xsZWN0aWJsZXNBcGkoYWRkcmVzcywgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBgaHR0cHM6Ly9hcGkub3BlbnNlYS5pby9hcGkvdjEvYXNzZXRzP293bmVyPSR7YWRkcmVzc30mb2Zmc2V0PSR7b2Zmc2V0fSZsaW1pdD01MGA7XG4gICAgfVxuICAgIGdldE93bmVyQ29sbGVjdGlibGVzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgICAgICBsZXQgY29sbGVjdGlibGVzID0gW107XG4gICAgICAgICAgICBjb25zdCBvcGVuU2VhQXBpS2V5ID0gdGhpcy5nZXRPcGVuU2VhQXBpS2V5KCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBwYWdpbmdGaW5pc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwaSA9IHRoaXMuZ2V0T3duZXJDb2xsZWN0aWJsZXNBcGkoc2VsZWN0ZWRBZGRyZXNzLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIHV0aWxfMS50aW1lb3V0RmV0Y2goYXBpLCBvcGVuU2VhQXBpS2V5ID8geyBoZWFkZXJzOiB7ICdYLUFQSS1LRVknOiBvcGVuU2VhQXBpS2V5IH0gfSA6IHt9LCAxNTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RpYmxlc0FycmF5ID0geWllbGQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgICAgICAoKF9hID0gY29sbGVjdGlibGVzQXJyYXkuYXNzZXRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAhPT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoY29sbGVjdGlibGVzID0gWy4uLmNvbGxlY3RpYmxlcywgLi4uY29sbGVjdGlibGVzQXJyYXkuYXNzZXRzXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKHBhZ2luZ0ZpbmlzaCA9IHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNTA7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoIXBhZ2luZ0ZpbmlzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RpYmxlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIG5ldyBwb2xsaW5nIGludGVydmFsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWwgLSBQb2xsaW5nIGludGVydmFsIHVzZWQgdG8gYXV0byBkZXRlY3QgYXNzZXRzXG4gICAgICovXG4gICAgcG9sbChpbnRlcnZhbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgJiYgdGhpcy5jb25maWd1cmUoeyBpbnRlcnZhbCB9LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgJiYgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZGV0ZWN0QXNzZXRzKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucG9sbCh0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgICAgICB9LCB0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBuZXR3b3JrIGlzIG1haW5uZXQgb3Igbm90XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFdoZXRoZXIgY3VycmVudCBuZXR3b3JrIGlzIG1haW5uZXRcbiAgICAgKi9cbiAgICBpc01haW5uZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5uZXR3b3JrVHlwZSAhPT0gY29uc3RhbnRzXzEuTUFJTk5FVCB8fCB0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVjdCBhc3NldHMgb3duZWQgYnkgY3VycmVudCBhY2NvdW50IG9uIG1haW5uZXRcbiAgICAgKi9cbiAgICBkZXRlY3RBc3NldHMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5pc01haW5uZXQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0VG9rZW5zKCk7XG4gICAgICAgICAgICB0aGlzLmRldGVjdENvbGxlY3RpYmxlcygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYXNzZXQgRVJDMjAgdG9rZW4gYXV0byBkZXRlY3Rpb24gZm9yIGVhY2ggY29udHJhY3QgYWRkcmVzcyBpbiBjb250cmFjdCBtZXRhZGF0YSBvbiBtYWlubmV0XG4gICAgICovXG4gICAgZGV0ZWN0VG9rZW5zKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNYWlubmV0KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b2tlbnNBZGRyZXNzZXMgPSB0aGlzLmNvbmZpZy50b2tlbnMubWFwKFxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQqLyAodG9rZW4pID0+IHRva2VuLmFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBjb25zdCB7IHRva2VuTGlzdCB9ID0gdGhpcy5nZXRUb2tlbkxpc3RTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zVG9EZXRlY3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBpbiB0b2tlbkxpc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2Vuc0FkZHJlc3Nlcy5pbmNsdWRlcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNUb0RldGVjdC5wdXNoKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNsaWNlT2ZUb2tlbnNUb0RldGVjdCA9IFtdO1xuICAgICAgICAgICAgc2xpY2VPZlRva2Vuc1RvRGV0ZWN0WzBdID0gdG9rZW5zVG9EZXRlY3Quc2xpY2UoMCwgMTAwMCk7XG4gICAgICAgICAgICBzbGljZU9mVG9rZW5zVG9EZXRlY3RbMV0gPSB0b2tlbnNUb0RldGVjdC5zbGljZSgxMDAwLCB0b2tlbnNUb0RldGVjdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW5zU2xpY2Ugb2Ygc2xpY2VPZlRva2Vuc1RvRGV0ZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2Vuc1NsaWNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlcyA9IHlpZWxkIHRoaXMuZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGwoc2VsZWN0ZWRBZGRyZXNzLCB0b2tlbnNTbGljZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2Vuc1RvQWRkID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW5BZGRyZXNzIGluIGJhbGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWdub3JlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGlnbm9yZWRUb2tlbnMgfSA9IHRoaXMuZ2V0VG9rZW5zU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkVG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZWQgPSBpZ25vcmVkVG9rZW5zLmZpbmQoKGlnbm9yZWRUb2tlbkFkZHJlc3MpID0+IGlnbm9yZWRUb2tlbkFkZHJlc3MgPT09IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyh0b2tlbkFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc2VJbnNlbnNpdGl2ZVRva2VuS2V5ID0gT2JqZWN0LmtleXModG9rZW5MaXN0KS5maW5kKChpKSA9PiBpLnRvTG93ZXJDYXNlKCkgPT09IHRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNUb0FkZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogdG9rZW5MaXN0W2Nhc2VJbnNlbnNpdGl2ZVRva2VuS2V5XS5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiB0b2tlbkxpc3RbY2FzZUluc2Vuc2l0aXZlVG9rZW5LZXldLnN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zVG9BZGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmFkZFRva2Vucyh0b2tlbnNUb0FkZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhc3NldCBFUkM3MjEgdG9rZW4gYXV0byBkZXRlY3Rpb24gb24gbWFpbm5ldFxuICAgICAqIGFkZGluZyBuZXcgY29sbGVjdGlibGVzIGFuZCByZW1vdmluZyBub3Qgb3duZWQgY29sbGVjdGlibGVzXG4gICAgICovXG4gICAgZGV0ZWN0Q29sbGVjdGlibGVzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNYWlubmV0KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRTZWxlY3RlZEFkZHJlc3MgPSB0aGlzLmNvbmZpZy5zZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0ZWRTZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBpQ29sbGVjdGlibGVzID0geWllbGQgdGhpcy5nZXRPd25lckNvbGxlY3RpYmxlcygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZENvbGxlY3RpYmxlc1Byb21pc2VzID0gYXBpQ29sbGVjdGlibGVzLm1hcCgoY29sbGVjdGlibGUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b2tlbl9pZCwgbnVtX3NhbGVzLCBiYWNrZ3JvdW5kX2NvbG9yLCBpbWFnZV91cmwsIGltYWdlX3ByZXZpZXdfdXJsLCBpbWFnZV90aHVtYm5haWxfdXJsLCBpbWFnZV9vcmlnaW5hbF91cmwsIGFuaW1hdGlvbl91cmwsIGFuaW1hdGlvbl9vcmlnaW5hbF91cmwsIG5hbWUsIGRlc2NyaXB0aW9uLCBleHRlcm5hbF9saW5rLCBjcmVhdG9yLCBhc3NldF9jb250cmFjdDogeyBhZGRyZXNzIH0sIGxhc3Rfc2FsZSwgfSA9IGNvbGxlY3RpYmxlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaWdub3JlZDtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpZ25vcmVkQ29sbGVjdGlibGVzIH0gPSB0aGlzLmdldENvbGxlY3RpYmxlc1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkQ29sbGVjdGlibGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlZCA9IGlnbm9yZWRDb2xsZWN0aWJsZXMuZmluZCgoYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjLmFkZHJlc3MgPT09IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnRva2VuSWQgPT09IE51bWJlcih0b2tlbl9pZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZ25vcmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRTZWxlY3RlZEFkZHJlc3MgPT09IHRoaXMuY29uZmlnLnNlbGVjdGVkQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RpYmxlTWV0YWRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCB7IG5hbWUgfSwgY3JlYXRvciAmJiB7IGNyZWF0b3IgfSwgZGVzY3JpcHRpb24gJiYgeyBkZXNjcmlwdGlvbiB9LCBpbWFnZV91cmwgJiYgeyBpbWFnZTogaW1hZ2VfdXJsIH0sIG51bV9zYWxlcyAmJiB7IG51bWJlck9mU2FsZXM6IG51bV9zYWxlcyB9LCBiYWNrZ3JvdW5kX2NvbG9yICYmIHsgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kX2NvbG9yIH0sIGltYWdlX3ByZXZpZXdfdXJsICYmIHsgaW1hZ2VQcmV2aWV3OiBpbWFnZV9wcmV2aWV3X3VybCB9LCBpbWFnZV90aHVtYm5haWxfdXJsICYmIHsgaW1hZ2VUaHVtYm5haWw6IGltYWdlX3RodW1ibmFpbF91cmwgfSwgaW1hZ2Vfb3JpZ2luYWxfdXJsICYmIHsgaW1hZ2VPcmlnaW5hbDogaW1hZ2Vfb3JpZ2luYWxfdXJsIH0sIGFuaW1hdGlvbl91cmwgJiYgeyBhbmltYXRpb246IGFuaW1hdGlvbl91cmwgfSwgYW5pbWF0aW9uX29yaWdpbmFsX3VybCAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uT3JpZ2luYWw6IGFuaW1hdGlvbl9vcmlnaW5hbF91cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBleHRlcm5hbF9saW5rICYmIHsgZXh0ZXJuYWxMaW5rOiBleHRlcm5hbF9saW5rIH0sIGxhc3Rfc2FsZSAmJiB7IGxhc3RTYWxlOiBsYXN0X3NhbGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmFkZENvbGxlY3RpYmxlKGFkZHJlc3MsIE51bWJlcih0b2tlbl9pZCksIGNvbGxlY3RpYmxlTWV0YWRhdGEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKGFkZENvbGxlY3RpYmxlc1Byb21pc2VzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3NldHNEZXRlY3Rpb25Db250cm9sbGVyID0gQXNzZXRzRGV0ZWN0aW9uQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEFzc2V0c0RldGVjdGlvbkNvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3NldHNEZXRlY3Rpb25Db250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBzdG9yZXMgc2hhcmVkIHNldHRpbmdzIGFuZCBleHBvc2VzIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAqL1xuY2xhc3MgUHJlZmVyZW5jZXNDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFByZWZlcmVuY2VzQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdQcmVmZXJlbmNlc0NvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIGZlYXR1cmVGbGFnczoge30sXG4gICAgICAgICAgICBmcmVxdWVudFJwY0xpc3Q6IFtdLFxuICAgICAgICAgICAgaWRlbnRpdGllczoge30sXG4gICAgICAgICAgICBpcGZzR2F0ZXdheTogJ2h0dHBzOi8vaXBmcy5pby9pcGZzLycsXG4gICAgICAgICAgICBsb3N0SWRlbnRpdGllczoge30sXG4gICAgICAgICAgICBzZWxlY3RlZEFkZHJlc3M6ICcnLFxuICAgICAgICAgICAgdXNlU3RhdGljVG9rZW5MaXN0OiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgaWRlbnRpdGllcyB0byBzdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3NlcyAtIExpc3Qgb2YgYWRkcmVzc2VzIHRvIHVzZSB0byBnZW5lcmF0ZSBuZXcgaWRlbnRpdGllc1xuICAgICAqL1xuICAgIGFkZElkZW50aXRpZXMoYWRkcmVzc2VzKSB7XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpdGllcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgYWRkcmVzc2VzLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAoaWRlbnRpdGllc1thZGRyZXNzXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkZW50aXR5Q291bnQgPSBPYmplY3Qua2V5cyhpZGVudGl0aWVzKS5sZW5ndGg7XG4gICAgICAgICAgICBpZGVudGl0aWVzW2FkZHJlc3NdID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGBBY2NvdW50ICR7aWRlbnRpdHlDb3VudCArIDF9YCxcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIGltcG9ydFRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBpZGVudGl0aWVzOiBPYmplY3QuYXNzaWduKHt9LCBpZGVudGl0aWVzKSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpZGVudGl0eSBmcm9tIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEFkZHJlc3Mgb2YgdGhlIGlkZW50aXR5IHRvIHJlbW92ZVxuICAgICAqL1xuICAgIHJlbW92ZUlkZW50aXR5KGFkZHJlc3MpIHtcbiAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgeyBpZGVudGl0aWVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoIWlkZW50aXRpZXNbYWRkcmVzc10pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgaWRlbnRpdGllc1thZGRyZXNzXTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBpZGVudGl0aWVzOiBPYmplY3QuYXNzaWduKHt9LCBpZGVudGl0aWVzKSB9KTtcbiAgICAgICAgaWYgKGFkZHJlc3MgPT09IHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHNlbGVjdGVkQWRkcmVzczogT2JqZWN0LmtleXMoaWRlbnRpdGllcylbMF0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzb2NpYXRlcyBhIG5ldyBsYWJlbCB3aXRoIGFuIGlkZW50aXR5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEFkZHJlc3Mgb2YgdGhlIGlkZW50aXR5IHRvIGFzc29jaWF0ZVxuICAgICAqIEBwYXJhbSBsYWJlbCAtIE5ldyBsYWJlbCB0byBhc3NpZ25cbiAgICAgKi9cbiAgICBzZXRBY2NvdW50TGFiZWwoYWRkcmVzcywgbGFiZWwpIHtcbiAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgeyBpZGVudGl0aWVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZGVudGl0aWVzW2FkZHJlc3NdID0gaWRlbnRpdGllc1thZGRyZXNzXSB8fCB7fTtcbiAgICAgICAgaWRlbnRpdGllc1thZGRyZXNzXS5uYW1lID0gbGFiZWw7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgaWRlbnRpdGllczogT2JqZWN0LmFzc2lnbih7fSwgaWRlbnRpdGllcykgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGEgc3BlY2lmaWMgZmVhdHVyZSBmbGFnXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmVhdHVyZSAtIEZlYXR1cmUgdG8gdG9nZ2xlXG4gICAgICogQHBhcmFtIGFjdGl2YXRlZCAtIFZhbHVlIHRvIGFzc2lnblxuICAgICAqL1xuICAgIHNldEZlYXR1cmVGbGFnKGZlYXR1cmUsIGFjdGl2YXRlZCkge1xuICAgICAgICBjb25zdCBvbGRGZWF0dXJlRmxhZ3MgPSB0aGlzLnN0YXRlLmZlYXR1cmVGbGFncztcbiAgICAgICAgY29uc3QgZmVhdHVyZUZsYWdzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRGZWF0dXJlRmxhZ3MpLCB7IFtmZWF0dXJlXTogYWN0aXZhdGVkIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGZlYXR1cmVGbGFnczogT2JqZWN0LmFzc2lnbih7fSwgZmVhdHVyZUZsYWdzKSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25pemVzIHRoZSBjdXJyZW50IGlkZW50aXR5IGxpc3Qgd2l0aCBuZXcgaWRlbnRpdGllc1xuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3NlcyAtIExpc3Qgb2YgYWRkcmVzc2VzIGNvcnJlc3BvbmRpbmcgdG8gaWRlbnRpdGllcyB0byBzeW5jXG4gICAgICogQHJldHVybnMgLSBOZXdseS1zZWxlY3RlZCBhZGRyZXNzIGFmdGVyIHN5bmNpbmdcbiAgICAgKi9cbiAgICBzeW5jSWRlbnRpdGllcyhhZGRyZXNzZXMpIHtcbiAgICAgICAgYWRkcmVzc2VzID0gYWRkcmVzc2VzLm1hcCgoYWRkcmVzcykgPT4gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpKTtcbiAgICAgICAgY29uc3QgeyBpZGVudGl0aWVzLCBsb3N0SWRlbnRpdGllcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgbmV3bHlMb3N0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgaWRlbnRpdHkgaW4gaWRlbnRpdGllcykge1xuICAgICAgICAgICAgaWYgKGFkZHJlc3Nlcy5pbmRleE9mKGlkZW50aXR5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXdseUxvc3RbaWRlbnRpdHldID0gaWRlbnRpdGllc1tpZGVudGl0eV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIGlkZW50aXRpZXNbaWRlbnRpdHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdseUxvc3QpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld2x5TG9zdCkge1xuICAgICAgICAgICAgICAgIGxvc3RJZGVudGl0aWVzW2tleV0gPSBuZXdseUxvc3Rba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBpZGVudGl0aWVzOiBPYmplY3QuYXNzaWduKHt9LCBpZGVudGl0aWVzKSxcbiAgICAgICAgICAgIGxvc3RJZGVudGl0aWVzOiBPYmplY3QuYXNzaWduKHt9LCBsb3N0SWRlbnRpdGllcyksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZElkZW50aXRpZXMoYWRkcmVzc2VzKTtcbiAgICAgICAgaWYgKGFkZHJlc3Nlcy5pbmRleE9mKHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgc2VsZWN0ZWRBZGRyZXNzOiBhZGRyZXNzZXNbMF0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW5kIHN0b3JlcyBhIG5ldyBsaXN0IG9mIHN0b3JlZCBpZGVudGl0aWVzIGJhc2VkIG9uIGFkZHJlc3MuIElmIHRoZSBzZWxlY3RlZCBhZGRyZXNzXG4gICAgICogaXMgdW5zZXQsIG9yIGlmIGl0IHJlZmVycyB0byBhbiBpZGVudGl0eSB0aGF0IHdhcyByZW1vdmVkLCBpdCB3aWxsIGJlIHNldCB0byB0aGUgZmlyc3RcbiAgICAgKiBpZGVudGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzZXMgLSBMaXN0IG9mIGFkZHJlc3NlcyB0byB1c2UgYXMgYSBiYXNpcyBmb3IgZWFjaCBpZGVudGl0eVxuICAgICAqL1xuICAgIHVwZGF0ZUlkZW50aXRpZXMoYWRkcmVzc2VzKSB7XG4gICAgICAgIGFkZHJlc3NlcyA9IGFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MpID0+IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKSk7XG4gICAgICAgIGNvbnN0IG9sZElkZW50aXRpZXMgPSB0aGlzLnN0YXRlLmlkZW50aXRpZXM7XG4gICAgICAgIGNvbnN0IGlkZW50aXRpZXMgPSBhZGRyZXNzZXMucmVkdWNlKChpZHMsIGFkZHJlc3MsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZHNbYWRkcmVzc10gPSBvbGRJZGVudGl0aWVzW2FkZHJlc3NdIHx8IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIG5hbWU6IGBBY2NvdW50ICR7aW5kZXggKyAxfWAsXG4gICAgICAgICAgICAgICAgaW1wb3J0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGxldCB7IHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhpZGVudGl0aWVzKS5pbmNsdWRlcyhzZWxlY3RlZEFkZHJlc3MpKSB7XG4gICAgICAgICAgICBzZWxlY3RlZEFkZHJlc3MgPSBPYmplY3Qua2V5cyhpZGVudGl0aWVzKVswXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSh7IGlkZW50aXRpZXM6IE9iamVjdC5hc3NpZ24oe30sIGlkZW50aXRpZXMpLCBzZWxlY3RlZEFkZHJlc3MgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgY3VzdG9tIFJQQyBVUkwgdG8gc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgLSBDdXN0b20gUlBDIFVSTFxuICAgICAqIEBwYXJhbSBjaGFpbklkPyAtIE5ldHdvcmsgSUQgYXMgcGVyIEVJUC0xNTVcbiAgICAgKiBAcGFyYW0gdGlja2VyPyAtIEN1cnJlbmN5IHRpY2tlclxuICAgICAqIEBwYXJhbSBuaWNrbmFtZT8gLSBQZXJzb25hbGl6ZWQgbmV0d29yayBuYW1lXG4gICAgICogQHBhcmFtIHJwY1ByZWZzPyAtIFBlcnNvbmFsaXplZCBwcmVmZXJlbmNlc1xuICAgICAqXG4gICAgICovXG4gICAgYWRkVG9GcmVxdWVudFJwY0xpc3QodXJsLCBjaGFpbklkLCB0aWNrZXIsIG5pY2tuYW1lLCBycGNQcmVmcykge1xuICAgICAgICBjb25zdCB7IGZyZXF1ZW50UnBjTGlzdCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBmcmVxdWVudFJwY0xpc3QuZmluZEluZGV4KCh7IHJwY1VybCB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcnBjVXJsID09PSB1cmw7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBmcmVxdWVudFJwY0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdGcmVxdWVzdFJwYyA9IHtcbiAgICAgICAgICAgIHJwY1VybDogdXJsLFxuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgIHRpY2tlcixcbiAgICAgICAgICAgIG5pY2tuYW1lLFxuICAgICAgICAgICAgcnBjUHJlZnMsXG4gICAgICAgIH07XG4gICAgICAgIGZyZXF1ZW50UnBjTGlzdC5wdXNoKG5ld0ZyZXF1ZXN0UnBjKTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBmcmVxdWVudFJwY0xpc3Q6IFsuLi5mcmVxdWVudFJwY0xpc3RdIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGN1c3RvbSBSUEMgVVJMIGZyb20gc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgLSBDdXN0b20gUlBDIFVSTFxuICAgICAqL1xuICAgIHJlbW92ZUZyb21GcmVxdWVudFJwY0xpc3QodXJsKSB7XG4gICAgICAgIGNvbnN0IHsgZnJlcXVlbnRScGNMaXN0IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCBpbmRleCA9IGZyZXF1ZW50UnBjTGlzdC5maW5kSW5kZXgoKHsgcnBjVXJsIH0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBycGNVcmwgPT09IHVybDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGZyZXF1ZW50UnBjTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHsgZnJlcXVlbnRScGNMaXN0OiBbLi4uZnJlcXVlbnRScGNMaXN0XSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBzZWxlY3RlZCBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VsZWN0ZWRBZGRyZXNzIC0gRXRoZXJldW0gYWRkcmVzc1xuICAgICAqL1xuICAgIHNldFNlbGVjdGVkQWRkcmVzcyhzZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBzZWxlY3RlZEFkZHJlc3M6IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhzZWxlY3RlZEFkZHJlc3MpIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIG5ldyBJUEZTIGdhdGV3YXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpcGZzR2F0ZXdheSAtIElQRlMgZ2F0ZXdheSBzdHJpbmdcbiAgICAgKi9cbiAgICBzZXRJcGZzR2F0ZXdheShpcGZzR2F0ZXdheSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGlwZnNHYXRld2F5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIHRva2VuIGRldGVjdGlvbiBzZXR0aW5nIHRvIHVzZSBkeW5hbWljIHRva2VuIGxpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VTdGF0aWNUb2tlbkxpc3QgLSBJUEZTIGdhdGV3YXkgc3RyaW5nXG4gICAgICovXG4gICAgc2V0VXNlU3RhdGljVG9rZW5MaXN0KHVzZVN0YXRpY1Rva2VuTGlzdCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IHVzZVN0YXRpY1Rva2VuTGlzdCB9KTtcbiAgICB9XG59XG5leHBvcnRzLlByZWZlcmVuY2VzQ29udHJvbGxlciA9IFByZWZlcmVuY2VzQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFByZWZlcmVuY2VzQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByZWZlcmVuY2VzQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm90aWZpY2F0aW9uQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gICAgbm90aWZpY2F0aW9uczoge30sXG59O1xuLyoqXG4gKiBDb250cm9sbGVyIGZvciBtYW5hZ2luZyBpbi1hcHAgYW5ub3VuY2VtZW50IG5vdGlmaWNhdGlvbnMuXG4gKi9cbmNsYXNzIE5vdGlmaWNhdGlvbkNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTm90aWZpY2F0aW9uQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUgfHwgZGVmYXVsdFN0YXRlKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuX2FkZE5vdGlmaWNhdGlvbnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdGhlIG5vdGlmaWNhdGlvbnMgaW4gc3RhdGUgd2l0aCB0aGUgbm90aWZpY2F0aW9ucyBmcm9tIGZpbGVcbiAgICAgKiB0byBjaGVjayBpZiB0aGVyZSBhcmUgYW55IG5ldyBub3RpZmljYXRpb25zL2Fubm91bmNlbWVudHNcbiAgICAgKiBpZiB5ZXMsIHRoZSBuZXcgbm90aWZpY2F0aW9uIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHN0YXRlIHdpdGggYSBmbGFnIGluZGljYXRpbmdcbiAgICAgKiB0aGF0IHRoZSBub3RpZmljYXRpb24gaXMgbm90IHNlZW4gYnkgdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIGFsbE5vdGlmaWNhdGlvbnNcbiAgICAgKi9cbiAgICBfYWRkTm90aWZpY2F0aW9ucygpIHtcbiAgICAgICAgY29uc3QgbmV3Tm90aWZpY2F0aW9ucyA9IHt9O1xuICAgICAgICBjb25zdCB7IGFsbE5vdGlmaWNhdGlvbnMgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBPYmplY3QudmFsdWVzKGFsbE5vdGlmaWNhdGlvbnMpLmZvckVhY2goKG5vdGlmaWNhdGlvbikgPT4ge1xuICAgICAgICAgICAgbmV3Tm90aWZpY2F0aW9uc1tub3RpZmljYXRpb24uaWRdID0gdGhpcy5zdGF0ZS5ub3RpZmljYXRpb25zW25vdGlmaWNhdGlvbi5pZF1cbiAgICAgICAgICAgICAgICA/IHRoaXMuc3RhdGUubm90aWZpY2F0aW9uc1tub3RpZmljYXRpb24uaWRdXG4gICAgICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5vdGlmaWNhdGlvbiksIHsgaXNTaG93bjogZmFsc2UgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IG5vdGlmaWNhdGlvbnM6IG5ld05vdGlmaWNhdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHN0YXR1cyBvZiB0aGUgc3RhdHVzIG9mIHRoZSBzcGVjaWZpZWQgbm90aWZpY2F0aW9uc1xuICAgICAqIG9uY2UgaXQgaXMgcmVhZCBieSB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2aWV3ZWRJZHNcbiAgICAgKi9cbiAgICB1cGRhdGVWaWV3ZWQodmlld2VkSWRzKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlTm90aWZpY2F0aW9ucyA9IHRoaXMuc3RhdGUubm90aWZpY2F0aW9ucztcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBPYmplY3Qua2V5cyh2aWV3ZWRJZHMpLm1hcChOdW1iZXIpKSB7XG4gICAgICAgICAgICBzdGF0ZU5vdGlmaWNhdGlvbnNbaWRdLmlzU2hvd24gPSB2aWV3ZWRJZHNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHsgbm90aWZpY2F0aW9uczogc3RhdGVOb3RpZmljYXRpb25zIH0sIHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uQ29udHJvbGxlciA9IE5vdGlmaWNhdGlvbkNvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob3RpZmljYXRpb25Db250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRva2VuUmF0ZXNDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuY29uc3QgY3J5cHRvX2NvbXBhcmVfMSA9IHJlcXVpcmUoXCIuLi9hcGlzL2NyeXB0by1jb21wYXJlXCIpO1xuY29uc3QgQ29pbkdlY2tvQXBpID0ge1xuICAgIEJBU0VfVVJMOiAnaHR0cHM6Ly9hcGkuY29pbmdlY2tvLmNvbS9hcGkvdjMnLFxuICAgIGdldFRva2VuUHJpY2VVUkwoY2hhaW5TbHVnLCBxdWVyeSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5CQVNFX1VSTH0vc2ltcGxlL3Rva2VuX3ByaWNlLyR7Y2hhaW5TbHVnfT8ke3F1ZXJ5fWA7XG4gICAgfSxcbiAgICBnZXRQbGF0Zm9ybXNVUkwoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLkJBU0VfVVJMfS9hc3NldF9wbGF0Zm9ybXNgO1xuICAgIH0sXG4gICAgZ2V0U3VwcG9ydGVkVnNDdXJyZW5jaWVzKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5CQVNFX1VSTH0vc2ltcGxlL3N1cHBvcnRlZF92c19jdXJyZW5jaWVzYDtcbiAgICB9LFxufTtcbi8qKlxuICogRmluZHMgdGhlIGNoYWluIHNsdWcgaW4gdGhlIGRhdGEgYXJyYXkgZ2l2ZW4gYSBjaGFpbklkXG4gKlxuICogQHBhcmFtIGNoYWluSWQgY3VycmVudCBjaGFpbklkXG4gKiBAcGFyYW0gZGF0YSBBcnJheSBvZiBzdXBwb3J0ZWQgcGxhdGZvcm1zIGZyb20gQ29pbkdlY2tvIEFQSVxuICogQHJldHVybnMgU2x1ZyBvZiBjaGFpbklkXG4gKi9cbmZ1bmN0aW9uIGZpbmRDaGFpblNsdWcoY2hhaW5JZCwgZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNoYWluID0gKF9hID0gZGF0YS5maW5kKCh7IGNoYWluX2lkZW50aWZpZXIgfSkgPT4gY2hhaW5faWRlbnRpZmllciAhPT0gbnVsbCAmJiBTdHJpbmcoY2hhaW5faWRlbnRpZmllcikgPT09IGNoYWluSWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgIHJldHVybiAoY2hhaW4gPT09IG51bGwgfHwgY2hhaW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYWluLmlkKSB8fCBudWxsO1xufVxuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgcGFzc2l2ZWx5IHBvbGxzIG9uIGEgc2V0IGludGVydmFsIGZvciB0b2tlbi10by1maWF0IGV4Y2hhbmdlIHJhdGVzXG4gKiBmb3IgdG9rZW5zIHN0b3JlZCBpbiB0aGUgVG9rZW5zQ29udHJvbGxlclxuICovXG5jbGFzcyBUb2tlblJhdGVzQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUb2tlblJhdGVzQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbkFzc2V0c1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIGFzc2V0cyBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbkN1cnJlbmN5UmF0ZVN0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIGN1cnJlbmN5IHJhdGUgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG9uVG9rZW5zU3RhdGVDaGFuZ2UsIG9uQ3VycmVuY3lSYXRlU3RhdGVDaGFuZ2UsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCB9LCBjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICB0aGlzLnRva2VuTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLnN1cHBvcnRlZENoYWlucyA9IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogMCxcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3VwcG9ydGVkVnNDdXJyZW5jaWVzID0ge1xuICAgICAgICAgICAgdGltZXN0YW1wOiAwLFxuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ1Rva2VuUmF0ZXNDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgZGlzYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBpbnRlcnZhbDogMyAqIDYwICogMTAwMCxcbiAgICAgICAgICAgIG5hdGl2ZUN1cnJlbmN5OiAnZXRoJyxcbiAgICAgICAgICAgIGNoYWluSWQ6ICcnLFxuICAgICAgICAgICAgdG9rZW5zOiBbXSxcbiAgICAgICAgICAgIHRocmVzaG9sZDogNiAqIDYwICogNjAgKiAxMDAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIGNvbnRyYWN0RXhjaGFuZ2VSYXRlczoge30sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IGRpc2FibGVkOiBmYWxzZSB9LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBvblRva2Vuc1N0YXRlQ2hhbmdlKCh0b2tlbnNTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyB0b2tlbnM6IHRva2Vuc1N0YXRlLnRva2VucyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uQ3VycmVuY3lSYXRlU3RhdGVDaGFuZ2UoKGN1cnJlbmN5UmF0ZVN0YXRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IG5hdGl2ZUN1cnJlbmN5OiBjdXJyZW5jeVJhdGVTdGF0ZS5uYXRpdmVDdXJyZW5jeSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKCh7IHByb3ZpZGVyIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gcHJvdmlkZXI7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGNvbnRyYWN0RXhjaGFuZ2VSYXRlczoge30gfSk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IGNoYWluSWQgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG5ldyBwb2xsaW5nIGludGVydmFsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWwgLSBQb2xsaW5nIGludGVydmFsIHVzZWQgdG8gZmV0Y2ggbmV3IHRva2VuIHJhdGVzXG4gICAgICovXG4gICAgcG9sbChpbnRlcnZhbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgJiYgdGhpcy5jb25maWd1cmUoeyBpbnRlcnZhbCB9LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgJiYgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbiAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMudXBkYXRlRXhjaGFuZ2VSYXRlcygpKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2xsKHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgICAgIH0sIHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBuZXcgY2hhaW5JZFxuICAgICAqXG4gICAgICogVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggYSBtZXRob2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFpbklkIGN1cnJlbnQgY2hhaW5JZFxuICAgICAqL1xuICAgIHNldCBjaGFpbklkKF9jaGFpbklkKSB7XG4gICAgICAgICF0aGlzLmRpc2FibGVkICYmIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMudXBkYXRlRXhjaGFuZ2VSYXRlcygpKTtcbiAgICB9XG4gICAgZ2V0IGNoYWluSWQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgb25seSB1c2VkIGZvciBzZXR0aW5nJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBuZXcgdG9rZW4gbGlzdCB0byB0cmFjayBwcmljZXNcbiAgICAgKlxuICAgICAqIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIGEgbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW5zIC0gTGlzdCBvZiB0b2tlbnMgdG8gdHJhY2sgZXhjaGFuZ2UgcmF0ZXMgZm9yXG4gICAgICovXG4gICAgc2V0IHRva2Vucyh0b2tlbnMpIHtcbiAgICAgICAgdGhpcy50b2tlbkxpc3QgPSB0b2tlbnM7XG4gICAgICAgICF0aGlzLmRpc2FibGVkICYmIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMudXBkYXRlRXhjaGFuZ2VSYXRlcygpKTtcbiAgICB9XG4gICAgZ2V0IHRva2VucygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBvbmx5IHVzZWQgZm9yIHNldHRpbmcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIHBhaXJzIG9mIHRva2VuIGFkZHJlc3MgYW5kIG5hdGl2ZSBjdXJyZW5jeVxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYWluU2x1ZyAtIENoYWluIHN0cmluZyBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHZzQ3VycmVuY3kgLSB0aGUgdnNDdXJyZW5jeSB1c2VkIHRvIHF1ZXJ5IHRva2VuIGV4Y2hhbmdlIHJhdGVzIGFnYWluc3QuXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byBleGNoYW5nZSByYXRlcyBmb3IgZ2l2ZW4gcGFpcnNcbiAgICAgKi9cbiAgICBmZXRjaEV4Y2hhbmdlUmF0ZShjaGFpblNsdWcsIHZzQ3VycmVuY3kpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuUGFpcnMgPSB0aGlzLnRva2VuTGlzdC5tYXAoKHRva2VuKSA9PiB0b2tlbi5hZGRyZXNzKS5qb2luKCcsJyk7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IGBjb250cmFjdF9hZGRyZXNzZXM9JHt0b2tlblBhaXJzfSZ2c19jdXJyZW5jaWVzPSR7dnNDdXJyZW5jeS50b0xvd2VyQ2FzZSgpfWA7XG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLmhhbmRsZUZldGNoKENvaW5HZWNrb0FwaS5nZXRUb2tlblByaWNlVVJMKGNoYWluU2x1ZywgcXVlcnkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBuYXRpdmUgY3VycmVuY3kgaXMgYSBzdXBwb3J0ZWQgdnMgY3VycmVuY3kgdG8gdXNlXG4gICAgICogdG8gcXVlcnkgZm9yIHRva2VuIGV4Y2hhbmdlIHJhdGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmF0aXZlQ3VycmVuY3kgLSB0aGUgbmF0aXZlIGN1cnJlbmN5IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIG5ldHdvcmtcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaXQncyBhIHN1cHBvcnRlZCB2c0N1cnJlbmN5XG4gICAgICovXG4gICAgY2hlY2tJc1N1cHBvcnRlZFZzQ3VycmVuY3kobmF0aXZlQ3VycmVuY3kpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdGhyZXNob2xkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IHsgdGltZXN0YW1wLCBkYXRhIH0gPSB0aGlzLnN1cHBvcnRlZFZzQ3VycmVuY2llcztcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBpZiAobm93IC0gdGltZXN0YW1wID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVuY2llcyA9IHlpZWxkIHV0aWxfMS5oYW5kbGVGZXRjaChDb2luR2Vja29BcGkuZ2V0U3VwcG9ydGVkVnNDdXJyZW5jaWVzKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VwcG9ydGVkVnNDdXJyZW5jaWVzID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdXJyZW5jaWVzLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVuY2llcy5pbmNsdWRlcyhuYXRpdmVDdXJyZW5jeS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhLmluY2x1ZGVzKG5hdGl2ZUN1cnJlbmN5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjdXJyZW50IGNoYWluSWQgc2x1ZyBmcm9tIGNhY2hlZCBzdXBwb3J0ZWQgcGxhdGZvcm1zIENvaW5HZWNrbyBBUEkgcmVzcG9uc2UuXG4gICAgICogSWYgY2FjaGVkIHN1cHBvcnRlZCBwbGF0Zm9ybXMgcmVzcG9uc2UgaXMgc3RhbGUsIGZldGNoZXMgYW5kIHVwZGF0ZXMgaXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBjdXJyZW50IGNoYWluSWRcbiAgICAgKi9cbiAgICBnZXRDaGFpblNsdWcoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRocmVzaG9sZCwgY2hhaW5JZCB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIHRpbWVzdGFtcCB9ID0gdGhpcy5zdXBwb3J0ZWRDaGFpbnM7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKG5vdyAtIHRpbWVzdGFtcCA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYXRmb3JtcyA9IHlpZWxkIHV0aWxfMS5oYW5kbGVGZXRjaChDb2luR2Vja29BcGkuZ2V0UGxhdGZvcm1zVVJMKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VwcG9ydGVkQ2hhaW5zID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwbGF0Zm9ybXMsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBmaW5kQ2hhaW5TbHVnKGNoYWluSWQsIHBsYXRmb3Jtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmluZENoYWluU2x1ZyhjaGFpbklkLCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgZXhjaGFuZ2UgcmF0ZXMgZm9yIGFsbCB0b2tlbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhpcyBvcGVyYXRpb24gY29tcGxldGVzXG4gICAgICovXG4gICAgdXBkYXRlRXhjaGFuZ2VSYXRlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuTGlzdC5sZW5ndGggPT09IDAgfHwgdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNsdWcgPSB5aWVsZCB0aGlzLmdldENoYWluU2x1ZygpO1xuICAgICAgICAgICAgbGV0IG5ld0NvbnRyYWN0RXhjaGFuZ2VSYXRlcyA9IHt9O1xuICAgICAgICAgICAgaWYgKCFzbHVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbkxpc3QuZm9yRWFjaCgodG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyh0b2tlbi5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udHJhY3RFeGNoYW5nZVJhdGVzW2FkZHJlc3NdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBuYXRpdmVDdXJyZW5jeSB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICAgICAgbmV3Q29udHJhY3RFeGNoYW5nZVJhdGVzID0geWllbGQgdGhpcy5mZXRjaEFuZE1hcEV4Y2hhbmdlUmF0ZXMobmF0aXZlQ3VycmVuY3ksIHNsdWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBjb250cmFjdEV4Y2hhbmdlUmF0ZXM6IG5ld0NvbnRyYWN0RXhjaGFuZ2VSYXRlcyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgYWN0aXZlIG5ldHdvcmsncyBuYXRpdmUgY3VycmVuY3kgaXMgc3VwcG9ydGVkIGJ5IHRoZSBjb2luZ2Vja28gQVBJXG4gICAgICogSWYgc3VwcG9ydGVkLiBmZXRjaGVzIGFuZCBtYXBzIGNvbnRyYWN0RXhjaGFuZ2UgcmF0ZXMgaW4gZm9ybWF0IHRvIGJlIGNvbnN1bWVkIGJ5IFVJXG4gICAgICogSWYgbm90IHN1cHBvcnRlZCBmZXRjaGVzIGNvbnRyYWN0RXhjaGFuZ2UgcmF0ZXMgYW5kIG1hcHMgZnJvbSBmcm9tIHRva2VuL2ZhbGxiYWNrLWN1cnJlbmN5IHRvIHRva2VuL25hdGl2ZUN1cnJlbmN5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmF0aXZlQ3VycmVuY3kgLSB0aGUgbmF0aXZlIGN1cnJlbmN5IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0gc2x1ZyAtIHRoZSB1bmlxdWUgc2x1ZyB1c2VkIHRvIGlkIHRoZSBjaGFpbiBieSB0aGUgY29pbmdlY2tvIGFwaVxuICAgICAqIHNob3VsZCBiZSB1c2VkIHRvIHF1ZXJ5IHRva2VuIGV4Y2hhbmdlIHJhdGVzXG4gICAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggY29udmVyc2lvbiByYXRlcyBmb3IgZWFjaCB0b2tlblxuICAgICAqIHJlbGF0ZWQgdG8gdGhlIG5ldHdvcmsncyBuYXRpdmUgY3VycmVuY3lcbiAgICAgKi9cbiAgICBmZXRjaEFuZE1hcEV4Y2hhbmdlUmF0ZXMobmF0aXZlQ3VycmVuY3ksIHNsdWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0RXhjaGFuZ2VSYXRlcyA9IHt9O1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgbmF0aXZlIGN1cnJlbmN5IGlzIHN1cHBvcnRlZCBhcyBhIHZzX2N1cnJlbmN5IGJ5IHRoZSBBUElcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZUN1cnJlbmN5U3VwcG9ydGVkID0geWllbGQgdGhpcy5jaGVja0lzU3VwcG9ydGVkVnNDdXJyZW5jeShuYXRpdmVDdXJyZW5jeSk7XG4gICAgICAgICAgICBpZiAobmF0aXZlQ3VycmVuY3lTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBpcyB3ZSBjYW4gZG8gYSBzaW1wbGUgZmV0Y2ggYWdhaW5zdCB0aGUgQ29pbkdlY2tvIEFQSVxuICAgICAgICAgICAgICAgIGNvbnN0IHByaWNlcyA9IHlpZWxkIHRoaXMuZmV0Y2hFeGNoYW5nZVJhdGUoc2x1ZywgbmF0aXZlQ3VycmVuY3kpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5MaXN0LmZvckVhY2goKHRva2VuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByaWNlID0gcHJpY2VzW3Rva2VuLmFkZHJlc3MudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0RXhjaGFuZ2VSYXRlc1t1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3ModG9rZW4uYWRkcmVzcyldID0gcHJpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcHJpY2VbbmF0aXZlQ3VycmVuY3kudG9Mb3dlckNhc2UoKV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5hdGl2ZSBjdXJyZW5jeSBpcyBub3Qgc3VwcG9ydGVkIHdlIG5lZWQgdG8gdXNlIGEgZmFsbGJhY2sgdnNDdXJyZW5jeSwgZ2V0IHRoZSBleGNoYW5nZSByYXRlc1xuICAgICAgICAgICAgICAgIC8vIGluIHRva2VuL2ZhbGxiYWNrLWN1cnJlbmN5IGZvcm1hdCBhbmQgY29udmVydCB0aGVtIHRvIGV4cGVjdGVkIHRva2VuL25hdGl2ZUN1cnJlbmN5IGZvcm1hdC5cbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5FeGNoYW5nZVJhdGVzO1xuICAgICAgICAgICAgICAgIGxldCB2c0N1cnJlbmN5VG9OYXRpdmVDdXJyZW5jeUNvbnZlcnNpb25SYXRlID0gMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkV4Y2hhbmdlUmF0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNvbnZlcnNpb25SYXRlOiB2c0N1cnJlbmN5VG9OYXRpdmVDdXJyZW5jeUNvbnZlcnNpb25SYXRlIH0sXG4gICAgICAgICAgICAgICAgICAgIF0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZldGNoRXhjaGFuZ2VSYXRlKHNsdWcsIGNvbnN0YW50c18xLkZBTExfQkFDS19WU19DVVJSRU5DWSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjcnlwdG9fY29tcGFyZV8xLmZldGNoRXhjaGFuZ2VSYXRlKG5hdGl2ZUN1cnJlbmN5LCBjb25zdGFudHNfMS5GQUxMX0JBQ0tfVlNfQ1VSUkVOQ1ksIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnbWFya2V0IGRvZXMgbm90IGV4aXN0IGZvciB0aGlzIGNvaW4gcGFpcicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3Rva2VuQWRkcmVzcywgY29udmVyc2lvbl0gb2YgT2JqZWN0LmVudHJpZXModG9rZW5FeGNoYW5nZVJhdGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlblRvVnNDdXJyZW5jeUNvbnZlcnNpb25SYXRlID0gY29udmVyc2lvbltjb25zdGFudHNfMS5GQUxMX0JBQ0tfVlNfQ1VSUkVOQ1kudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0RXhjaGFuZ2VSYXRlc1t1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3ModG9rZW5BZGRyZXNzKV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5Ub1ZzQ3VycmVuY3lDb252ZXJzaW9uUmF0ZSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdnNDdXJyZW5jeVRvTmF0aXZlQ3VycmVuY3lDb252ZXJzaW9uUmF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3RFeGNoYW5nZVJhdGVzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlRva2VuUmF0ZXNDb250cm9sbGVyID0gVG9rZW5SYXRlc0NvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBUb2tlblJhdGVzQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRva2VuUmF0ZXNDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRQZXJzaXN0ZW50U3RhdGUgPSBleHBvcnRzLmdldEFub255bWl6ZWRTdGF0ZSA9IGV4cG9ydHMuQmFzZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBpbW1lcl8xID0gcmVxdWlyZShcImltbWVyXCIpO1xuaW1tZXJfMS5lbmFibGVQYXRjaGVzKCk7XG4vKipcbiAqIENvbnRyb2xsZXIgY2xhc3MgdGhhdCBwcm92aWRlcyBzdGF0ZSBtYW5hZ2VtZW50LCBzdWJzY3JpcHRpb25zLCBhbmQgc3RhdGUgbWV0YWRhdGFcbiAqL1xuY2xhc3MgQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBCYXNlQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWVzc2VuZ2VyIC0gQ29udHJvbGxlciBtZXNzYWdpbmcgc3lzdGVtXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWV0YWRhdGEgLSBTdGF0ZSBtZXRhZGF0YSwgZGVzY3JpYmluZyBob3cgdG8gXCJhbm9ueW1pemVcIiB0aGUgc3RhdGUsIGFuZCB3aGljaFxuICAgICAqICAgcGFydHMgc2hvdWxkIGJlIHBlcnNpc3RlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbnRyb2xsZXIsIHVzZWQgYXMgYSBuYW1lc3BhY2UgZm9yIGV2ZW50cyBhbmQgYWN0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnN0YXRlIC0gSW5pdGlhbCBjb250cm9sbGVyIHN0YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBtZXNzZW5nZXIsIG1ldGFkYXRhLCBuYW1lLCBzdGF0ZSwgfSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbSA9IG1lc3NlbmdlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke25hbWV9OmdldFN0YXRlYCwgKCkgPT4gdGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBjdXJyZW50IGNvbnRyb2xsZXIgc3RhdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gQ3VycmVudCBzdGF0ZVxuICAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdGF0ZTtcbiAgICB9XG4gICAgc2V0IHN0YXRlKF8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb250cm9sbGVyIHN0YXRlIGNhbm5vdCBiZSBkaXJlY3RseSBtdXRhdGVkOyB1c2UgJ3VwZGF0ZScgbWV0aG9kIGluc3RlYWQuYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY29udHJvbGxlciBzdGF0ZS4gQWNjZXB0cyBhIGNhbGxiYWNrIHRoYXQgaXMgcGFzc2VkIGEgZHJhZnQgY29weVxuICAgICAqIG9mIHRoZSBjb250cm9sbGVyIHN0YXRlLiBJZiBhIHZhbHVlIGlzIHJldHVybmVkLCBpdCBpcyBzZXQgYXMgdGhlIG5ld1xuICAgICAqIHN0YXRlLiBPdGhlcndpc2UsIGFueSBjaGFuZ2VzIG1hZGUgd2l0aGluIHRoYXQgY2FsbGJhY2sgdG8gdGhlIGRyYWZ0IGFyZVxuICAgICAqIGFwcGxpZWQgdG8gdGhlIGNvbnRyb2xsZXIgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsYmFjayBmb3IgdXBkYXRpbmcgc3RhdGUsIHBhc3NlZCBhIGRyYWZ0IHN0YXRlXG4gICAgICogICBvYmplY3QuIFJldHVybiBhIG5ldyBzdGF0ZSBvYmplY3Qgb3IgbXV0YXRlIHRoZSBkcmFmdCB0byB1cGRhdGUgc3RhdGUuXG4gICAgICovXG4gICAgdXBkYXRlKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIFdlIHJ1biBpbnRvIHRzMjU4OSwgXCJpbmZpbml0ZSB0eXBlIGRlcHRoXCIsIGlmIHdlIGRvbid0IGNhc3RcbiAgICAgICAgLy8gcHJvZHVjZVdpdGhQYXRjaGVzIGhlcmUuXG4gICAgICAgIC8vIFRoZSBmaW5hbCwgb21pdHRlZCBtZW1iZXIgb2YgdGhlIHJldHVybmVkIHR1cGxlIGFyZSB0aGUgaW52ZXJzZSBwYXRjaGVzLlxuICAgICAgICBjb25zdCBbbmV4dFN0YXRlLCBwYXRjaGVzXSA9IGltbWVyXzEucHJvZHVjZVdpdGhQYXRjaGVzKHRoaXMuaW50ZXJuYWxTdGF0ZSwgY2FsbGJhY2spO1xuICAgICAgICB0aGlzLmludGVybmFsU3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnB1Ymxpc2goYCR7dGhpcy5uYW1lfTpzdGF0ZUNoYW5nZWAsIG5leHRTdGF0ZSwgcGF0Y2hlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIHRoZSBjb250cm9sbGVyIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uIFRoaXMgc2hvdWxkIGJlIGV4dGVuZGVkXG4gICAgICogYnkgYW55IHN1YmNsYXNzZXMgdG8gY2xlYW4gdXAgYW55IGFkZGl0aW9uYWwgY29ubmVjdGlvbnMgb3IgZXZlbnRzLlxuICAgICAqXG4gICAgICogVGhlIG9ubHkgY2xlYW51cCBwZXJmb3JtZWQgaGVyZSBpcyB0byByZW1vdmUgbGlzdGVuZXJzLiBXaGlsZSB0ZWNobmljYWxseVxuICAgICAqIHRoaXMgaXMgbm90IHJlcXVpcmVkIHRvIGVuc3VyZSB0aGlzIGluc3RhbmNlIGlzIGdhcmJhZ2UgY29sbGVjdGVkLCBpdCBhdFxuICAgICAqIGxlYXN0IGVuc3VyZXMgdGhpcyBpbnN0YW5jZSB3b24ndCBiZSByZXNwb25zaWJsZSBmb3IgcHJldmVudGluZyB0aGVcbiAgICAgKiBsaXN0ZW5lcnMgZnJvbSBiZWluZyBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5jbGVhckV2ZW50U3Vic2NyaXB0aW9ucyhgJHt0aGlzLm5hbWV9OnN0YXRlQ2hhbmdlYCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlQ29udHJvbGxlciA9IEJhc2VDb250cm9sbGVyO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGFub255bWl6ZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbnRyb2xsZXIgc3RhdGUuXG4gKlxuICogQnkgXCJhbm9ueW1pemVkXCIgd2UgbWVhbiB0aGF0IGl0IHNob3VsZCBub3QgY29udGFpbiBhbnkgaW5mb3JtYXRpb24gdGhhdCBjb3VsZCBiZSBwZXJzb25hbGx5XG4gKiBpZGVudGlmaWFibGUuXG4gKlxuICogQHBhcmFtIHN0YXRlIC0gVGhlIGNvbnRyb2xsZXIgc3RhdGVcbiAqIEBwYXJhbSBtZXRhZGF0YSAtIFRoZSBjb250cm9sbGVyIHN0YXRlIG1ldGFkYXRhLCB3aGljaCBkZXNjcmliZXMgaG93IHRvIGRlcml2ZSB0aGVcbiAqICAgYW5vbnltaXplZCBzdGF0ZVxuICogQHJldHVybnMgVGhlIGFub255bWl6ZWQgY29udHJvbGxlciBzdGF0ZVxuICovXG5mdW5jdGlvbiBnZXRBbm9ueW1pemVkU3RhdGUoc3RhdGUsIG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIGRlcml2ZVN0YXRlRnJvbU1ldGFkYXRhKHN0YXRlLCBtZXRhZGF0YSwgJ2Fub255bW91cycpO1xufVxuZXhwb3J0cy5nZXRBbm9ueW1pemVkU3RhdGUgPSBnZXRBbm9ueW1pemVkU3RhdGU7XG4vKipcbiAqIFJldHVybnMgdGhlIHN1YnNldCBvZiBzdGF0ZSB0aGF0IHNob3VsZCBiZSBwZXJzaXN0ZWRcbiAqXG4gKiBAcGFyYW0gc3RhdGUgLSBUaGUgY29udHJvbGxlciBzdGF0ZVxuICogQHBhcmFtIG1ldGFkYXRhIC0gVGhlIGNvbnRyb2xsZXIgc3RhdGUgbWV0YWRhdGEsIHdoaWNoIGRlc2NyaWJlcyB3aGljaCBwaWVjZXMgb2Ygc3RhdGUgc2hvdWxkIGJlIHBlcnNpc3RlZFxuICogQHJldHVybnMgVGhlIHN1YnNldCBvZiBjb250cm9sbGVyIHN0YXRlIHRoYXQgc2hvdWxkIGJlIHBlcnNpc3RlZFxuICovXG5mdW5jdGlvbiBnZXRQZXJzaXN0ZW50U3RhdGUoc3RhdGUsIG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIGRlcml2ZVN0YXRlRnJvbU1ldGFkYXRhKHN0YXRlLCBtZXRhZGF0YSwgJ3BlcnNpc3QnKTtcbn1cbmV4cG9ydHMuZ2V0UGVyc2lzdGVudFN0YXRlID0gZ2V0UGVyc2lzdGVudFN0YXRlO1xuZnVuY3Rpb24gZGVyaXZlU3RhdGVGcm9tTWV0YWRhdGEoc3RhdGUsIG1ldGFkYXRhLCBtZXRhZGF0YVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0YXRlKS5yZWR1Y2UoKHBlcnNpc3RlZFN0YXRlLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlNZXRhZGF0YSA9IG1ldGFkYXRhW2tleV1bbWV0YWRhdGFQcm9wZXJ0eV07XG4gICAgICAgIGNvbnN0IHN0YXRlUHJvcGVydHkgPSBzdGF0ZVtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5TWV0YWRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBlcnNpc3RlZFN0YXRlW2tleV0gPSBwcm9wZXJ0eU1ldGFkYXRhKHN0YXRlUHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3BlcnR5TWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHBlcnNpc3RlZFN0YXRlW2tleV0gPSBzdGF0ZVByb3BlcnR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwZXJzaXN0ZWRTdGF0ZTtcbiAgICB9LCB7fSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlQ29udHJvbGxlclYyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzc2V0c0NvbnRyYWN0Q29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IHdlYjNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwid2ViM1wiKSk7XG5jb25zdCBodW1hbl9zdGFuZGFyZF90b2tlbl9hYmlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaHVtYW4tc3RhbmRhcmQtdG9rZW4tYWJpXCIpKTtcbmNvbnN0IGh1bWFuX3N0YW5kYXJkX2NvbGxlY3RpYmxlX2FiaV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJodW1hbi1zdGFuZGFyZC1jb2xsZWN0aWJsZS1hYmlcIikpO1xuY29uc3Qgc2luZ2xlX2NhbGxfYmFsYW5jZV9jaGVja2VyX2FiaV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJzaW5nbGUtY2FsbC1iYWxhbmNlLWNoZWNrZXItYWJpXCIpKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCBFUkM3MjFNRVRBREFUQV9JTlRFUkZBQ0VfSUQgPSAnMHg1YjVlMTM5Zic7XG5jb25zdCBFUkM3MjFFTlVNRVJBQkxFX0lOVEVSRkFDRV9JRCA9ICcweDc4MGU5ZDYzJztcbmNvbnN0IFNJTkdMRV9DQUxMX0JBTEFOQ0VTX0FERFJFU1MgPSAnMHhiMWY4ZTU1YzdmNjRkMjAzYzE0MDBiOWQ4NTU1ZDA1MGY5NGFkZjM5Jztcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IGludGVyYWN0cyB3aXRoIGNvbnRyYWN0cyBvbiBtYWlubmV0IHRocm91Z2ggd2ViM1xuICovXG5jbGFzcyBBc3NldHNDb250cmFjdENvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQXNzZXRzQ29udHJhY3RDb250cm9sbGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0Fzc2V0c0NvbnRyYWN0Q29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgIHByb3ZpZGVyOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFF1ZXJ5IGlmIGEgY29udHJhY3QgaW1wbGVtZW50cyBhbiBpbnRlcmZhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gQXNzZXQgY29udHJhY3QgYWRkcmVzc1xuICAgICAqIEBwYXJhbSBpbnRlcmZhY2VJZCAtIEludGVyZmFjZSBpZGVudGlmaWVyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB3aGV0aGVyIHRoZSBjb250cmFjdCBpbXBsZW1lbnRzIGBpbnRlcmZhY2VJRGBcbiAgICAgKi9cbiAgICBjb250cmFjdFN1cHBvcnRzSW50ZXJmYWNlKGFkZHJlc3MsIGludGVyZmFjZUlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IHRoaXMud2ViMy5ldGguY29udHJhY3QoaHVtYW5fc3RhbmRhcmRfY29sbGVjdGlibGVfYWJpXzEuZGVmYXVsdCkuYXQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0LnN1cHBvcnRzSW50ZXJmYWNlKGludGVyZmFjZUlkLCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG5ldyBwcm92aWRlclxuICAgICAqXG4gICAgICogVE9ETzogUmVwbGFjZSB0aGlzIHd0aCBhIG1ldGhvZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHByb3ZpZGVyIC0gUHJvdmlkZXIgdXNlZCB0byBjcmVhdGUgYSBuZXcgdW5kZXJseWluZyBXZWIzIGluc3RhbmNlXG4gICAgICovXG4gICAgc2V0IHByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMud2ViMyA9IG5ldyB3ZWIzXzEuZGVmYXVsdChwcm92aWRlcik7XG4gICAgfVxuICAgIGdldCBwcm92aWRlcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBvbmx5IHVzZWQgZm9yIHNldHRpbmcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgaWYgY29udHJhY3QgaW1wbGVtZW50cyBFUkM3MjFNZXRhZGF0YSBpbnRlcmZhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDNzIxIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHdoZXRoZXIgdGhlIGNvbnRyYWN0IGltcGxlbWVudHMgRVJDNzIxTWV0YWRhdGEgaW50ZXJmYWNlXG4gICAgICovXG4gICAgY29udHJhY3RTdXBwb3J0c01ldGFkYXRhSW50ZXJmYWNlKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyYWN0U3VwcG9ydHNJbnRlcmZhY2UoYWRkcmVzcywgRVJDNzIxTUVUQURBVEFfSU5URVJGQUNFX0lEKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGlmIGNvbnRyYWN0IGltcGxlbWVudHMgRVJDNzIxRW51bWVyYWJsZSBpbnRlcmZhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDNzIxIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHdoZXRoZXIgdGhlIGNvbnRyYWN0IGltcGxlbWVudHMgRVJDNzIxRW51bWVyYWJsZSBpbnRlcmZhY2VcbiAgICAgKi9cbiAgICBjb250cmFjdFN1cHBvcnRzRW51bWVyYWJsZUludGVyZmFjZShhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cmFjdFN1cHBvcnRzSW50ZXJmYWNlKGFkZHJlc3MsIEVSQzcyMUVOVU1FUkFCTEVfSU5URVJGQUNFX0lEKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBiYWxhbmNlIG9yIGNvdW50IGZvciBjdXJyZW50IGFjY291bnQgb24gc3BlY2lmaWMgYXNzZXQgY29udHJhY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gQXNzZXQgY29udHJhY3QgYWRkcmVzc1xuICAgICAqIEBwYXJhbSBzZWxlY3RlZEFkZHJlc3MgLSBDdXJyZW50IGFjY291bnQgcHVibGljIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIEJOIG9iamVjdCBjb250YWluaW5nIGJhbGFuY2UgZm9yIGN1cnJlbnQgYWNjb3VudCBvbiBzcGVjaWZpYyBhc3NldCBjb250cmFjdFxuICAgICAqL1xuICAgIGdldEJhbGFuY2VPZihhZGRyZXNzLCBzZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aC5jb250cmFjdChodW1hbl9zdGFuZGFyZF90b2tlbl9hYmlfMS5kZWZhdWx0KS5hdChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3QuYmFsYW5jZU9mKHNlbGVjdGVkQWRkcmVzcywgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVudW1lcmF0ZSBhc3NldHMgYXNzaWduZWQgdG8gYW4gb3duZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDNzIxIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gc2VsZWN0ZWRBZGRyZXNzIC0gQ3VycmVudCBhY2NvdW50IHB1YmxpYyBhZGRyZXNzXG4gICAgICogQHBhcmFtIGluZGV4IC0gQSBjb2xsZWN0aWJsZSBjb3VudGVyIGxlc3MgdGhhbiBgYmFsYW5jZU9mKHNlbGVjdGVkQWRkcmVzcylgXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0b2tlbiBpZGVudGlmaWVyIGZvciB0aGUgJ2luZGV4J3RoIGFzc2V0IGFzc2lnbmVkIHRvICdzZWxlY3RlZEFkZHJlc3MnXG4gICAgICovXG4gICAgZ2V0Q29sbGVjdGlibGVUb2tlbklkKGFkZHJlc3MsIHNlbGVjdGVkQWRkcmVzcywgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgY29udHJhY3QgPSB0aGlzLndlYjMuZXRoLmNvbnRyYWN0KGh1bWFuX3N0YW5kYXJkX2NvbGxlY3RpYmxlX2FiaV8xLmRlZmF1bHQpLmF0KGFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29udHJhY3QudG9rZW5PZk93bmVyQnlJbmRleChzZWxlY3RlZEFkZHJlc3MsIGluZGV4LCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0LnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBmb3IgdG9rZW5VUkkgZm9yIGEgZ2l2ZW4gYXNzZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDNzIxIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIEVSQzcyMSBhc3NldCBpZGVudGlmaWVyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgJ3Rva2VuVVJJJ1xuICAgICAqL1xuICAgIGdldENvbGxlY3RpYmxlVG9rZW5VUkkoYWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydHNNZXRhZGF0YSA9IHlpZWxkIHRoaXMuY29udHJhY3RTdXBwb3J0c01ldGFkYXRhSW50ZXJmYWNlKGFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKCFzdXBwb3J0c01ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSB0aGlzLndlYjMuZXRoLmNvbnRyYWN0KGh1bWFuX3N0YW5kYXJkX2NvbGxlY3RpYmxlX2FiaV8xLmRlZmF1bHQpLmF0KGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb250cmFjdC50b2tlblVSSSh0b2tlbklkLCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgZm9yIG5hbWUgZm9yIGEgZ2l2ZW4gRVJDMjAgYXNzZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDMjAgYXNzZXQgY29udHJhY3QgYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICdkZWNpbWFscydcbiAgICAgKi9cbiAgICBnZXRUb2tlbkRlY2ltYWxzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aC5jb250cmFjdChodW1hbl9zdGFuZGFyZF90b2tlbl9hYmlfMS5kZWZhdWx0KS5hdChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3QuZGVjaW1hbHMoKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGZvciBuYW1lIGZvciBhIGdpdmVuIGFzc2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzcyMSBvciBFUkMyMCBhc3NldCBjb250cmFjdCBhZGRyZXNzXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgJ25hbWUnXG4gICAgICovXG4gICAgZ2V0QXNzZXROYW1lKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aC5jb250cmFjdChodW1hbl9zdGFuZGFyZF9jb2xsZWN0aWJsZV9hYmlfMS5kZWZhdWx0KS5hdChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3QubmFtZSgoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgZm9yIHN5bWJvbCBmb3IgYSBnaXZlbiBhc3NldFxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBFUkM3MjEgb3IgRVJDMjAgYXNzZXQgY29udHJhY3QgYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICdzeW1ib2wnXG4gICAgICovXG4gICAgZ2V0QXNzZXRTeW1ib2woYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSB0aGlzLndlYjMuZXRoLmNvbnRyYWN0KGh1bWFuX3N0YW5kYXJkX2NvbGxlY3RpYmxlX2FiaV8xLmRlZmF1bHQpLmF0KGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb250cmFjdC5zeW1ib2woKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGZvciBvd25lciBmb3IgYSBnaXZlbiBFUkM3MjEgYXNzZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDNzIxIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIEVSQzcyMSBhc3NldCBpZGVudGlmaWVyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgb3duZXIgYWRkcmVzc1xuICAgICAqL1xuICAgIGdldE93bmVyT2YoYWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSB0aGlzLndlYjMuZXRoLmNvbnRyYWN0KGh1bWFuX3N0YW5kYXJkX2NvbGxlY3RpYmxlX2FiaV8xLmRlZmF1bHQpLmF0KGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb250cmFjdC5vd25lck9mKHRva2VuSWQsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyYWN0IGluc3RhbmNlIG9mXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSAndG9rZW5VUkknXG4gICAgICovXG4gICAgZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGwoc2VsZWN0ZWRBZGRyZXNzLCB0b2tlbnNUb0RldGVjdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSB0aGlzLndlYjMuZXRoXG4gICAgICAgICAgICAgICAgLmNvbnRyYWN0KHNpbmdsZV9jYWxsX2JhbGFuY2VfY2hlY2tlcl9hYmlfMS5kZWZhdWx0KVxuICAgICAgICAgICAgICAgIC5hdChTSU5HTEVfQ0FMTF9CQUxBTkNFU19BRERSRVNTKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3QuYmFsYW5jZXMoW3NlbGVjdGVkQWRkcmVzc10sIHRva2Vuc1RvRGV0ZWN0LCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vblplcm9CYWxhbmNlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vuc1RvRGV0ZWN0LmZvckVhY2goKHRva2VuQWRkcmVzcywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gcmVzdWx0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFsYW5jZS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25aZXJvQmFsYW5jZXNbdG9rZW5BZGRyZXNzXSA9IGJhbGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShub25aZXJvQmFsYW5jZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzZXRzQ29udHJhY3RDb250cm9sbGVyID0gQXNzZXRzQ29udHJhY3RDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXNzZXRzQ29udHJhY3RDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcHByb3ZhbENvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3QgbmFub2lkXzEgPSByZXF1aXJlKFwibmFub2lkXCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJWMl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyVjJcIik7XG5jb25zdCBjb250cm9sbGVyTmFtZSA9ICdBcHByb3ZhbENvbnRyb2xsZXInO1xuY29uc3Qgc3RhdGVNZXRhZGF0YSA9IHtcbiAgICBwZW5kaW5nQXBwcm92YWxzOiB7IHBlcnNpc3Q6IGZhbHNlLCBhbm9ueW1vdXM6IHRydWUgfSxcbiAgICBwZW5kaW5nQXBwcm92YWxDb3VudDogeyBwZXJzaXN0OiBmYWxzZSwgYW5vbnltb3VzOiBmYWxzZSB9LFxufTtcbmNvbnN0IGdldEFscmVhZHlQZW5kaW5nTWVzc2FnZSA9IChvcmlnaW4sIHR5cGUpID0+IGBSZXF1ZXN0IG9mIHR5cGUgJyR7dHlwZX0nIGFscmVhZHkgcGVuZGluZyBmb3Igb3JpZ2luICR7b3JpZ2lufS4gUGxlYXNlIHdhaXQuYDtcbmNvbnN0IGdldERlZmF1bHRTdGF0ZSA9ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwZW5kaW5nQXBwcm92YWxzOiB7fSxcbiAgICAgICAgcGVuZGluZ0FwcHJvdmFsQ291bnQ6IDAsXG4gICAgfTtcbn07XG4vKipcbiAqIENvbnRyb2xsZXIgZm9yIG1hbmFnaW5nIHJlcXVlc3RzIHRoYXQgcmVxdWlyZSB1c2VyIGFwcHJvdmFsLlxuICpcbiAqIEVuYWJsZXMgbGltaXRpbmcgdGhlIG51bWJlciBvZiBwZW5kaW5nIHJlcXVlc3RzIGJ5IG9yaWdpbiBhbmQgdHlwZSwgY291bnRpbmdcbiAqIHBlbmRpbmcgcmVxdWVzdHMsIGFuZCBtb3JlLlxuICpcbiAqIEFkZGluZyBhIHJlcXVlc3QgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvciByZWplY3RzIHdoZW4gdGhlIHJlcXVlc3RcbiAqIGlzIGFwcHJvdmVkIG9yIGRlbmllZCwgcmVzcGVjdGl2ZWx5LlxuICovXG5jbGFzcyBBcHByb3ZhbENvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlclYyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBiYWdcbiAgICAgKiBAcGFyYW0gb3B0cy5zaG93QXBwcm92YWxSZXF1ZXN0IC0gRnVuY3Rpb24gZm9yIG9wZW5pbmcgdGhlIFVJIHN1Y2ggdGhhdFxuICAgICAqIHRoZSByZXF1ZXN0IGNhbiBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBtZXNzZW5nZXIsIHNob3dBcHByb3ZhbFJlcXVlc3QsIHN0YXRlID0ge30sIH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogY29udHJvbGxlck5hbWUsXG4gICAgICAgICAgICBtZXRhZGF0YTogc3RhdGVNZXRhZGF0YSxcbiAgICAgICAgICAgIG1lc3NlbmdlcixcbiAgICAgICAgICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldERlZmF1bHRTdGF0ZSgpKSwgc3RhdGUpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYXBwcm92YWxzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9vcmlnaW5zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zaG93QXBwcm92YWxSZXF1ZXN0ID0gc2hvd0FwcHJvdmFsUmVxdWVzdDtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBoZWxwZXIgZm9yIHJlZ2lzdGVyaW5nIHRoaXMgY29udHJvbGxlcidzIG1lc3NhZ2luZyBzeXN0ZW1cbiAgICAgKiBhY3Rpb25zLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OmNsZWFyUmVxdWVzdHNgLCB0aGlzLmNsZWFyLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OmFkZFJlcXVlc3RgLCAob3B0cywgc2hvdWxkU2hvd1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRTaG93UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEFuZFNob3dBcHByb3ZhbFJlcXVlc3Qob3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3B0cyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9Omhhc1JlcXVlc3RgLCB0aGlzLmhhcy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTphY2NlcHRSZXF1ZXN0YCwgdGhpcy5hY2NlcHQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06cmVqZWN0UmVxdWVzdGAsIHRoaXMucmVqZWN0LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGFwcHJvdmFsIHJlcXVlc3QgcGVyIHRoZSBnaXZlbiBhcmd1bWVudHMsIGNhbGxzIHRoZSBzaG93IGFwcHJvdmFsXG4gICAgICogcmVxdWVzdCBmdW5jdGlvbiwgYW5kIHJldHVybnMgdGhlIGFzc29jaWF0ZWQgYXBwcm92YWwgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBhcHByb3ZhbCBwZXIgb3JpZ2luIGFuZCB0eXBlLiBBbiBlcnJvciBpcyB0aHJvd24gaWZcbiAgICAgKiBhdHRlbXB0aW5nIHRvIGFkZCBhbiBpbnZhbGlkIG9yIGR1cGxpY2F0ZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGJhZy5cbiAgICAgKiBAcGFyYW0gb3B0cy5pZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC4gQSByYW5kb20gaWQgd2lsbCBiZVxuICAgICAqIGdlbmVyYXRlZCBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSBvcHRzLm9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdHMudHlwZSAtIFRoZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3B0cy5yZXF1ZXN0RGF0YSAtIEFkZGl0aW9uYWwgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIHJlcXVlc3QsXG4gICAgICogaWYgYW55LlxuICAgICAqIEByZXR1cm5zIFRoZSBhcHByb3ZhbCBwcm9taXNlLlxuICAgICAqL1xuICAgIGFkZEFuZFNob3dBcHByb3ZhbFJlcXVlc3Qob3B0cykge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5fYWRkKG9wdHMub3JpZ2luLCBvcHRzLnR5cGUsIG9wdHMuaWQsIG9wdHMucmVxdWVzdERhdGEpO1xuICAgICAgICB0aGlzLl9zaG93QXBwcm92YWxSZXF1ZXN0KCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGFwcHJvdmFsIHJlcXVlc3QgcGVyIHRoZSBnaXZlbiBhcmd1bWVudHMgYW5kIHJldHVybnMgdGhlIGFwcHJvdmFsXG4gICAgICogcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBhcHByb3ZhbCBwZXIgb3JpZ2luIGFuZCB0eXBlLiBBbiBlcnJvciBpcyB0aHJvd24gaWZcbiAgICAgKiBhdHRlbXB0aW5nIHRvIGFkZCBhbiBpbnZhbGlkIG9yIGR1cGxpY2F0ZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGJhZy5cbiAgICAgKiBAcGFyYW0gb3B0cy5pZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC4gQSByYW5kb20gaWQgd2lsbCBiZVxuICAgICAqIGdlbmVyYXRlZCBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSBvcHRzLm9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdHMudHlwZSAtIFRoZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3B0cy5yZXF1ZXN0RGF0YSAtIEFkZGl0aW9uYWwgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIHJlcXVlc3QsXG4gICAgICogaWYgYW55LlxuICAgICAqIEByZXR1cm5zIFRoZSBhcHByb3ZhbCBwcm9taXNlLlxuICAgICAqL1xuICAgIGFkZChvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGQob3B0cy5vcmlnaW4sIG9wdHMudHlwZSwgb3B0cy5pZCwgb3B0cy5yZXF1ZXN0RGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZm8gZm9yIHRoZSBhcHByb3ZhbCByZXF1ZXN0IHdpdGggdGhlIGdpdmVuIGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBhcHByb3ZhbCByZXF1ZXN0IGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBpZC5cbiAgICAgKi9cbiAgICBnZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucGVuZGluZ0FwcHJvdmFsc1tpZF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBwZW5kaW5nIGFwcHJvdmFscywgYnkgb3JpZ2luIGFuZC9vciB0eXBlLlxuICAgICAqXG4gICAgICogSWYgb25seSBgb3JpZ2luYCBpcyBzcGVjaWZpZWQsIGFsbCBhcHByb3ZhbHMgZm9yIHRoYXQgb3JpZ2luIHdpbGwgYmVcbiAgICAgKiBjb3VudGVkLCByZWdhcmRsZXNzIG9mIHR5cGUuXG4gICAgICogSWYgb25seSBgdHlwZWAgaXMgc3BlY2lmaWVkLCBhbGwgYXBwcm92YWxzIGZvciB0aGF0IHR5cGUgd2lsbCBiZSBjb3VudGVkLFxuICAgICAqIHJlZ2FyZGxlc3Mgb2Ygb3JpZ2luLlxuICAgICAqIElmIGJvdGggYG9yaWdpbmAgYW5kIGB0eXBlYCBhcmUgc3BlY2lmaWVkLCAwIG9yIDEgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzLm9yaWdpbiAtIEFuIGFwcHJvdmFsIG9yaWdpbi5cbiAgICAgKiBAcGFyYW0gb3B0cy50eXBlIC0gVGhlIHR5cGUgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgYXBwcm92YWwgcmVxdWVzdCBjb3VudCBmb3IgdGhlIGdpdmVuIG9yaWdpbiBhbmQvb3JcbiAgICAgKiB0eXBlLlxuICAgICAqL1xuICAgIGdldEFwcHJvdmFsQ291bnQob3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghb3B0cy5vcmlnaW4gJiYgIW9wdHMudHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgb3JpZ2luLCB0eXBlLCBvciBib3RoLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luLCB0eXBlOiBfdHlwZSB9ID0gb3B0cztcbiAgICAgICAgaWYgKG9yaWdpbiAmJiBfdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihCb29sZWFuKChfYSA9IHRoaXMuX29yaWdpbnMuZ2V0KG9yaWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYXMoX3R5cGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgcmV0dXJuICgoX2IgPSB0aGlzLl9vcmlnaW5zLmdldChvcmlnaW4pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2l6ZSkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IFwidHlwZVwiIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBhcHByb3ZhbCBvZiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUucGVuZGluZ0FwcHJvdmFscykpIHtcbiAgICAgICAgICAgIGlmIChhcHByb3ZhbC50eXBlID09PSBfdHlwZSkge1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCB0b3RhbCBhcHByb3ZhbCByZXF1ZXN0IGNvdW50LCBmb3IgYWxsIHR5cGVzIGFuZFxuICAgICAqIG9yaWdpbnMuXG4gICAgICovXG4gICAgZ2V0VG90YWxBcHByb3ZhbENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5wZW5kaW5nQXBwcm92YWxDb3VudDtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5pZmllZC1zaWduYXR1cmVzICovXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZXJlJ3MgYSBwZW5kaW5nIGFwcHJvdmFsIHJlcXVlc3QgcGVyIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICAgICAqIEF0IGxlYXN0IG9uZSBwYXJhbWV0ZXIgbXVzdCBiZSBzcGVjaWZpZWQuIEFuIGVycm9yIHdpbGwgYmUgdGhyb3duIGlmIHRoZVxuICAgICAqIHBhcmFtZXRlcnMgYXJlIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBJZiBgaWRgIGlzIHNwZWNpZmllZCwgYWxsIG90aGVyIHBhcmFtZXRlcnMgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIElmIGBpZGAgaXMgbm90IHNwZWNpZmllZCwgdGhlIG1ldGhvZCB3aWxsIGNoZWNrIGZvciByZXF1ZXN0cyB0aGF0IG1hdGNoXG4gICAgICogYWxsIG9mIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBiYWcuXG4gICAgICogQHBhcmFtIG9wdHMuaWQgLSBUaGUgSUQgdG8gY2hlY2sgZm9yLlxuICAgICAqIEBwYXJhbSBvcHRzLm9yaWdpbiAtIFRoZSBvcmlnaW4gdG8gY2hlY2sgZm9yLlxuICAgICAqIEBwYXJhbSBvcHRzLnR5cGUgLSBUaGUgdHlwZSB0byBjaGVjayBmb3IuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIGEgbWF0Y2hpbmcgYXBwcm92YWwgaXMgZm91bmQsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBoYXMob3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBpZCwgb3JpZ2luLCB0eXBlOiBfdHlwZSB9ID0gb3B0cztcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF5IG5vdCBzcGVjaWZ5IG5vbi1zdHJpbmcgaWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwcm92YWxzLmhhcyhpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90eXBlICYmIHR5cGVvZiBfdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF5IG5vdCBzcGVjaWZ5IG5vbi1zdHJpbmcgdHlwZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01heSBub3Qgc3BlY2lmeSBub24tc3RyaW5nIG9yaWdpbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIG9yaWdpbiBhbmQgdHlwZSBwYWlyIGlmIHR5cGUgYWxzbyBzcGVjaWZpZWRcbiAgICAgICAgICAgIGlmIChfdHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKChfYSA9IHRoaXMuX29yaWdpbnMuZ2V0KG9yaWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYXMoX3R5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5zLmhhcyhvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdHlwZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcHByb3ZhbCBvZiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUucGVuZGluZ0FwcHJvdmFscykpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwcm92YWwudHlwZSA9PT0gX3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IGEgdmFsaWQgY29tYmluYXRpb24gb2YgaWQsIG9yaWdpbiwgYW5kIHR5cGUuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBwcm9taXNlIG9mIHRoZSBhcHByb3ZhbCB3aXRoIHRoZSBnaXZlbiBpZCwgYW5kIGRlbGV0ZXMgdGhlXG4gICAgICogYXBwcm92YWwuIFRocm93cyBhbiBlcnJvciBpZiBubyBzdWNoIGFwcHJvdmFsIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmVzb2x2ZSB0aGUgYXBwcm92YWwgcHJvbWlzZSB3aXRoLlxuICAgICAqL1xuICAgIGFjY2VwdChpZCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGVsZXRlQXBwcm92YWxBbmRHZXRDYWxsYmFja3MoaWQpLnJlc29sdmUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIHRoZSBwcm9taXNlIG9mIHRoZSBhcHByb3ZhbCB3aXRoIHRoZSBnaXZlbiBpZCwgYW5kIGRlbGV0ZXMgdGhlXG4gICAgICogYXBwcm92YWwuIFRocm93cyBhbiBlcnJvciBpZiBubyBzdWNoIGFwcHJvdmFsIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gcmVqZWN0IHRoZSBhcHByb3ZhbCBwcm9taXNlIHdpdGguXG4gICAgICovXG4gICAgcmVqZWN0KGlkLCBlcnJvcikge1xuICAgICAgICB0aGlzLl9kZWxldGVBcHByb3ZhbEFuZEdldENhbGxiYWNrcyhpZCkucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVqZWN0cyBhbmQgZGVsZXRlcyBhbGwgYXBwcm92YWwgcmVxdWVzdHMuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGNvbnN0IHJlamVjdGlvbkVycm9yID0gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLnJlc291cmNlVW5hdmFpbGFibGUoJ1RoZSByZXF1ZXN0IHdhcyByZWplY3RlZDsgcGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiB0aGlzLl9hcHByb3ZhbHMua2V5cygpKSB7XG4gICAgICAgICAgICB0aGlzLnJlamVjdChpZCwgcmVqZWN0aW9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29yaWdpbnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKCkgPT4gZ2V0RGVmYXVsdFN0YXRlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBhZGQgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSByZXF1ZXN0RGF0YSAtIFRoZSByZXF1ZXN0IGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBhcHByb3ZhbCBwcm9taXNlLlxuICAgICAqL1xuICAgIF9hZGQob3JpZ2luLCB0eXBlLCBpZCA9IG5hbm9pZF8xLm5hbm9pZCgpLCByZXF1ZXN0RGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlQWRkUGFyYW1zKGlkLCBvcmlnaW4sIHR5cGUsIHJlcXVlc3REYXRhKTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuX29yaWdpbnMuZ2V0KG9yaWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYXModHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5yZXNvdXJjZVVuYXZhaWxhYmxlKGdldEFscmVhZHlQZW5kaW5nTWVzc2FnZShvcmlnaW4sIHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgcGVuZGluZyBhcHByb3ZhbFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYXBwcm92YWxzLnNldChpZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRQZW5kaW5nQXBwcm92YWxPcmlnaW4ob3JpZ2luLCB0eXBlKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvU3RvcmUoaWQsIG9yaWdpbiwgdHlwZSwgcmVxdWVzdERhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHBhcmFtZXRlcnMgdG8gdGhlIGFkZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcXVlc3REYXRhIC0gVGhlIHJlcXVlc3QgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICovXG4gICAgX3ZhbGlkYXRlQWRkUGFyYW1zKGlkLCBvcmlnaW4sIHR5cGUsIHJlcXVlc3REYXRhKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBpZiAoIWlkIHx8IHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdNdXN0IHNwZWNpZnkgbm9uLWVtcHR5IHN0cmluZyBpZC4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2FwcHJvdmFscy5oYXMoaWQpKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgQXBwcm92YWwgcmVxdWVzdCB3aXRoIGlkICcke2lkfScgYWxyZWFkeSBleGlzdHMuYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb3JpZ2luIHx8IHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnTXVzdCBzcGVjaWZ5IG5vbi1lbXB0eSBzdHJpbmcgb3JpZ2luLic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXR5cGUgfHwgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnTXVzdCBzcGVjaWZ5IG5vbi1lbXB0eSBzdHJpbmcgdHlwZS4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcXVlc3REYXRhICYmXG4gICAgICAgICAgICAodHlwZW9mIHJlcXVlc3REYXRhICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KHJlcXVlc3REYXRhKSkpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdSZXF1ZXN0IGRhdGEgbXVzdCBiZSBhIHBsYWluIG9iamVjdCBpZiBzcGVjaWZpZWQuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVudHJ5IHRvIF9vcmlnaW5zLlxuICAgICAqIFBlcmZvcm1zIG5vIHZhbGlkYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBfYWRkUGVuZGluZ0FwcHJvdmFsT3JpZ2luKG9yaWdpbiwgdHlwZSkge1xuICAgICAgICBjb25zdCBvcmlnaW5TZXQgPSB0aGlzLl9vcmlnaW5zLmdldChvcmlnaW4pIHx8IG5ldyBTZXQoKTtcbiAgICAgICAgb3JpZ2luU2V0LmFkZCh0eXBlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9vcmlnaW5zLmhhcyhvcmlnaW4pKSB7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5zLnNldChvcmlnaW4sIG9yaWdpblNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBlbnRyeSB0byB0aGUgc3RvcmUuXG4gICAgICogUGVyZm9ybXMgbm8gdmFsaWRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdERhdGEgLSBUaGUgcmVxdWVzdCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBfYWRkVG9TdG9yZShpZCwgb3JpZ2luLCB0eXBlLCByZXF1ZXN0RGF0YSkge1xuICAgICAgICBjb25zdCBhcHByb3ZhbCA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICByZXF1ZXN0RGF0YTogcmVxdWVzdERhdGEgfHwgbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIC8vIFR5cGVjYXN0OiB0cygyNTg5KVxuICAgICAgICAgICAgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxzW2lkXSA9IGFwcHJvdmFsO1xuICAgICAgICAgICAgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxDb3VudCA9IE9iamVjdC5rZXlzKGRyYWZ0U3RhdGUucGVuZGluZ0FwcHJvdmFscykubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgYXBwcm92YWwgd2l0aCB0aGUgZ2l2ZW4gaWQuIFRoZSBhcHByb3ZhbCBwcm9taXNlIG11c3QgYmVcbiAgICAgKiByZXNvbHZlZCBvciByZWplY3QgYmVmb3JlIHRoaXMgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgKiBEZWxldGlvbiBpcyBhbiBpbnRlcm5hbCBvcGVyYXRpb24gYmVjYXVzZSBhcHByb3ZhbCBzdGF0ZSBpcyBzb2xlbHlcbiAgICAgKiBtYW5hZ2VkIGJ5IHRoaXMgY29udHJvbGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdCB0byBiZSBkZWxldGVkLlxuICAgICAqL1xuICAgIF9kZWxldGUoaWQpIHtcbiAgICAgICAgdGhpcy5fYXBwcm92YWxzLmRlbGV0ZShpZCk7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIG9ubHkgY2FsbGVkIGFmdGVyIHZlcmlmeWluZyB0aGF0IHRoZSBhcHByb3ZhbCB3aXRoIHRoZVxuICAgICAgICAvLyBzcGVjaWZpZWQgaWQgZXhpc3RzLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCB7IG9yaWdpbiwgdHlwZSB9ID0gdGhpcy5zdGF0ZS5wZW5kaW5nQXBwcm92YWxzW2lkXTtcbiAgICAgICAgdGhpcy5fb3JpZ2lucy5nZXQob3JpZ2luKS5kZWxldGUodHlwZSk7XG4gICAgICAgIGlmICh0aGlzLl9pc0VtcHR5T3JpZ2luKG9yaWdpbikpIHtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbnMuZGVsZXRlKG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBkcmFmdFN0YXRlLnBlbmRpbmdBcHByb3ZhbHNbaWRdO1xuICAgICAgICAgICAgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxDb3VudCA9IE9iamVjdC5rZXlzKGRyYWZ0U3RhdGUucGVuZGluZ0FwcHJvdmFscykubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm92YWwgY2FsbGJhY2tzIGZvciB0aGUgZ2l2ZW4gaWQsIGRlbGV0ZXMgdGhlIGVudHJ5LCBhbmQgdGhlblxuICAgICAqIHJldHVybnMgdGhlIGNhbGxiYWNrcyBmb3IgcHJvbWlzZSByZXNvbHV0aW9uLlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBubyBhcHByb3ZhbCBpcyBmb3VuZCBmb3IgdGhlIGdpdmVuIGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBwcm9taXNlIGNhbGxiYWNrcyBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICovXG4gICAgX2RlbGV0ZUFwcHJvdmFsQW5kR2V0Q2FsbGJhY2tzKGlkKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuX2FwcHJvdmFscy5nZXQoaWQpO1xuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcHByb3ZhbCByZXF1ZXN0IHdpdGggaWQgJyR7aWR9JyBub3QgZm91bmQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVsZXRlKGlkKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBhcHByb3ZhbHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlblxuICAgICAqIG9yaWdpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG9yaWdpbiBoYXMgbm8gYXBwcm92YWxzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgX2lzRW1wdHlPcmlnaW4ob3JpZ2luKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICEoKF9hID0gdGhpcy5fb3JpZ2lucy5nZXQob3JpZ2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpemUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXBwcm92YWxDb250cm9sbGVyID0gQXBwcm92YWxDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXBwcm92YWxDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwcm92YWxDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFjY291bnRUcmFja2VyQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IGV0aF9xdWVyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJldGgtcXVlcnlcIikpO1xuY29uc3QgYXN5bmNfbXV0ZXhfMSA9IHJlcXVpcmUoXCJhc3luYy1tdXRleFwiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHRyYWNrcyBpbmZvcm1hdGlvbiBmb3IgYWxsIGFjY291bnRzIGluIHRoZSBjdXJyZW50IGtleWNoYWluXG4gKi9cbmNsYXNzIEFjY291bnRUcmFja2VyQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gQWNjb3VudFRyYWNrZXIgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIHByZWZlcmVuY2UgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0SWRlbnRpdGllcyAtIEdldHMgdGhlIGlkZW50aXRpZXMgZnJvbSB0aGUgUHJlZmVyZW5jZXMgc3RvcmVcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlLCBnZXRJZGVudGl0aWVzLCB9LCBjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICB0aGlzLm11dGV4ID0gbmV3IGFzeW5jX211dGV4XzEuTXV0ZXgoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnQWNjb3VudFRyYWNrZXJDb250cm9sbGVyJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2hlcyBhbGwgYWNjb3VudHMgaW4gdGhlIGN1cnJlbnQga2V5Y2hhaW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVmcmVzaCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY0FjY291bnRzKCk7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzIGluIGFjY291bnRzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGVXaXRoVGltZW91dCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSB5aWVsZCB1dGlsXzEucXVlcnkodGhpcy5ldGhRdWVyeSwgJ2dldEJhbGFuY2UnLCBbYWRkcmVzc10pO1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50c1thZGRyZXNzXSA9IHsgYmFsYW5jZTogdXRpbF8xLkJOVG9IZXgoYmFsYW5jZSkgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBhY2NvdW50czogT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudHMpIH0pO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgIGludGVydmFsOiAxMDAwMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7IGFjY291bnRzOiB7fSB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5nZXRJZGVudGl0aWVzID0gZ2V0SWRlbnRpdGllcztcbiAgICAgICAgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfVxuICAgIHN5bmNBY2NvdW50cygpIHtcbiAgICAgICAgY29uc3QgeyBhY2NvdW50cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gT2JqZWN0LmtleXModGhpcy5nZXRJZGVudGl0aWVzKCkpO1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IE9iamVjdC5rZXlzKGFjY291bnRzKTtcbiAgICAgICAgY29uc3QgbmV3QWRkcmVzc2VzID0gYWRkcmVzc2VzLmZpbHRlcigoYWRkcmVzcykgPT4gZXhpc3RpbmcuaW5kZXhPZihhZGRyZXNzKSA9PT0gLTEpO1xuICAgICAgICBjb25zdCBvbGRBZGRyZXNzZXMgPSBleGlzdGluZy5maWx0ZXIoKGFkZHJlc3MpID0+IGFkZHJlc3Nlcy5pbmRleE9mKGFkZHJlc3MpID09PSAtMSk7XG4gICAgICAgIG5ld0FkZHJlc3Nlcy5mb3JFYWNoKChhZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICBhY2NvdW50c1thZGRyZXNzXSA9IHsgYmFsYW5jZTogJzB4MCcgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9sZEFkZHJlc3Nlcy5mb3JFYWNoKChhZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgYWNjb3VudHNbYWRkcmVzc107XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGFjY291bnRzOiBPYmplY3QuYXNzaWduKHt9LCBhY2NvdW50cykgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBuZXcgcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIFRPRE86IFJlcGxhY2UgdGhpcyB3dGggYSBtZXRob2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm92aWRlciAtIFByb3ZpZGVyIHVzZWQgdG8gY3JlYXRlIGEgbmV3IHVuZGVybHlpbmcgRXRoUXVlcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzZXQgcHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5ldGhRdWVyeSA9IG5ldyBldGhfcXVlcnlfMS5kZWZhdWx0KHByb3ZpZGVyKTtcbiAgICB9XG4gICAgZ2V0IHByb3ZpZGVyKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IG9ubHkgdXNlZCBmb3Igc2V0dGluZycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgcG9sbGluZyBpbnRlcnZhbFxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVydmFsIC0gUG9sbGluZyBpbnRlcnZhbCB0cmlnZ2VyIGEgJ3JlZnJlc2gnXG4gICAgICovXG4gICAgcG9sbChpbnRlcnZhbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIGludGVydmFsICYmIHRoaXMuY29uZmlndXJlKHsgaW50ZXJ2YWwgfSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlICYmIGNsZWFyVGltZW91dCh0aGlzLmhhbmRsZSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvbGwodGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfSwgdGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkFjY291bnRUcmFja2VyQ29udHJvbGxlciA9IEFjY291bnRUcmFja2VyQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEFjY291bnRUcmFja2VyQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjY291bnRUcmFja2VyQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DdXJyZW5jeVJhdGVDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgYXN5bmNfbXV0ZXhfMSA9IHJlcXVpcmUoXCJhc3luYy1tdXRleFwiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyVjJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclYyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBjcnlwdG9fY29tcGFyZV8xID0gcmVxdWlyZShcIi4uL2FwaXMvY3J5cHRvLWNvbXBhcmVcIik7XG5jb25zdCBuYW1lID0gJ0N1cnJlbmN5UmF0ZUNvbnRyb2xsZXInO1xuY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgY29udmVyc2lvbkRhdGU6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiB0cnVlIH0sXG4gICAgY29udmVyc2lvblJhdGU6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiB0cnVlIH0sXG4gICAgY3VycmVudEN1cnJlbmN5OiB7IHBlcnNpc3Q6IHRydWUsIGFub255bW91czogdHJ1ZSB9LFxuICAgIG5hdGl2ZUN1cnJlbmN5OiB7IHBlcnNpc3Q6IHRydWUsIGFub255bW91czogdHJ1ZSB9LFxuICAgIHBlbmRpbmdDdXJyZW50Q3VycmVuY3k6IHsgcGVyc2lzdDogZmFsc2UsIGFub255bW91czogdHJ1ZSB9LFxuICAgIHBlbmRpbmdOYXRpdmVDdXJyZW5jeTogeyBwZXJzaXN0OiBmYWxzZSwgYW5vbnltb3VzOiB0cnVlIH0sXG4gICAgdXNkQ29udmVyc2lvblJhdGU6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiB0cnVlIH0sXG59O1xuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICAgIGNvbnZlcnNpb25EYXRlOiAwLFxuICAgIGNvbnZlcnNpb25SYXRlOiAwLFxuICAgIGN1cnJlbnRDdXJyZW5jeTogJ3VzZCcsXG4gICAgbmF0aXZlQ3VycmVuY3k6ICdFVEgnLFxuICAgIHBlbmRpbmdDdXJyZW50Q3VycmVuY3k6IG51bGwsXG4gICAgcGVuZGluZ05hdGl2ZUN1cnJlbmN5OiBudWxsLFxuICAgIHVzZENvbnZlcnNpb25SYXRlOiBudWxsLFxufTtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHBhc3NpdmVseSBwb2xscyBvbiBhIHNldCBpbnRlcnZhbCBmb3IgYW4gZXhjaGFuZ2UgcmF0ZSBmcm9tIHRoZSBjdXJyZW50IGJhc2VcbiAqIGFzc2V0IHRvIHRoZSBjdXJyZW50IGN1cnJlbmN5XG4gKi9cbmNsYXNzIEN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlclYyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBDdXJyZW5jeVJhdGVDb250cm9sbGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbmNsdWRlVXNkUmF0ZSAtIEtlZXAgdHJhY2sgb2YgdGhlIFVTRCByYXRlIGluIGFkZGl0aW9uIHRvIHRoZSBjdXJyZW50IGN1cnJlbmN5IHJhdGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbCAtIFRoZSBwb2xsaW5nIGludGVydmFsLCBpbiBtaWxsaXNlY29uZHNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXNzZW5nZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgbWVzc2FnaW5nIHN5c3RlbVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZmV0Y2hFeGNoYW5nZVJhdGUgLSBGZXRjaGVzIHRoZSBleGNoYW5nZSByYXRlIGZyb20gYW4gZXh0ZXJuYWwgQVBJLiBUaGlzIG9wdGlvbiBpcyBwcmltYXJpbHkgbWVhbnQgZm9yIHVzZSBpbiB1bml0IHRlc3RzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgaW5jbHVkZVVzZFJhdGUgPSBmYWxzZSwgaW50ZXJ2YWwgPSAxODAwMDAsIG1lc3Nlbmdlciwgc3RhdGUsIGZldGNoRXhjaGFuZ2VSYXRlID0gY3J5cHRvX2NvbXBhcmVfMS5mZXRjaEV4Y2hhbmdlUmF0ZSwgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICBtZXNzZW5nZXIsXG4gICAgICAgICAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U3RhdGUpLCBzdGF0ZSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm11dGV4ID0gbmV3IGFzeW5jX211dGV4XzEuTXV0ZXgoKTtcbiAgICAgICAgdGhpcy5pbmNsdWRlVXNkUmF0ZSA9IGluY2x1ZGVVc2RSYXRlO1xuICAgICAgICB0aGlzLmludGVydmFsRGVsYXkgPSBpbnRlcnZhbDtcbiAgICAgICAgdGhpcy5mZXRjaEV4Y2hhbmdlUmF0ZSA9IGZldGNoRXhjaGFuZ2VSYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBwb2xsaW5nIGZvciB0aGUgY3VycmVuY3kgcmF0ZVxuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zdGFydFBvbGxpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgcG9sbGluZyBmb3IgdGhlIGN1cnJlbmN5IHJhdGVcbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdG8gZGlzY2FyZCB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHN0b3BzIGFueSBhY3RpdmUgcG9sbGluZy5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIGN1cnJlbmN5IHRvIHRyYWNrXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3VycmVudEN1cnJlbmN5IC0gSVNPIDQyMTcgY3VycmVuY3kgY29kZVxuICAgICAqL1xuICAgIHNldEN1cnJlbnRDdXJyZW5jeShjdXJyZW50Q3VycmVuY3kpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlLnBlbmRpbmdDdXJyZW50Q3VycmVuY3kgPSBjdXJyZW50Q3VycmVuY3k7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMudXBkYXRlRXhjaGFuZ2VSYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IG5hdGl2ZSBjdXJyZW5jeVxuICAgICAqXG4gICAgICogQHBhcmFtIHN5bWJvbCAtIFN5bWJvbCBmb3IgdGhlIGJhc2UgYXNzZXRcbiAgICAgKi9cbiAgICBzZXROYXRpdmVDdXJyZW5jeShzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlLnBlbmRpbmdOYXRpdmVDdXJyZW5jeSA9IHN5bWJvbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeWllbGQgdGhpcy51cGRhdGVFeGNoYW5nZVJhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3BQb2xsaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgbmV3IHBvbGxpbmcgaW50ZXJ2YWxcbiAgICAgKi9cbiAgICBzdGFydFBvbGxpbmcoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBFeHBvc2UgcG9sbGluZyBjdXJyZW5jeSByYXRlIHVwZGF0ZSBlcnJvcnNcbiAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMudXBkYXRlRXhjaGFuZ2VSYXRlKCkpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMudXBkYXRlRXhjaGFuZ2VSYXRlKCkpO1xuICAgICAgICAgICAgfSksIHRoaXMuaW50ZXJ2YWxEZWxheSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGV4Y2hhbmdlIHJhdGUgZm9yIHRoZSBjdXJyZW50IGN1cnJlbmN5XG4gICAgICovXG4gICAgdXBkYXRlRXhjaGFuZ2VSYXRlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY3VycmVudEN1cnJlbmN5OiBzdGF0ZUN1cnJlbnRDdXJyZW5jeSwgbmF0aXZlQ3VycmVuY3k6IHN0YXRlTmF0aXZlQ3VycmVuY3ksIHBlbmRpbmdDdXJyZW50Q3VycmVuY3ksIHBlbmRpbmdOYXRpdmVDdXJyZW5jeSwgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJzaW9uRGF0ZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICAgICAgbGV0IGNvbnZlcnNpb25SYXRlID0gbnVsbDtcbiAgICAgICAgICAgIGxldCB1c2RDb252ZXJzaW9uUmF0ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q3VycmVuY3kgPSBwZW5kaW5nQ3VycmVudEN1cnJlbmN5ICE9PSBudWxsICYmIHBlbmRpbmdDdXJyZW50Q3VycmVuY3kgIT09IHZvaWQgMCA/IHBlbmRpbmdDdXJyZW50Q3VycmVuY3kgOiBzdGF0ZUN1cnJlbnRDdXJyZW5jeTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZUN1cnJlbmN5ID0gcGVuZGluZ05hdGl2ZUN1cnJlbmN5ICE9PSBudWxsICYmIHBlbmRpbmdOYXRpdmVDdXJyZW5jeSAhPT0gdm9pZCAwID8gcGVuZGluZ05hdGl2ZUN1cnJlbmN5IDogc3RhdGVOYXRpdmVDdXJyZW5jeTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDdXJyZW5jeSAmJlxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBlaXRoZXIgY3VycmVuY3kgaXMgYW4gZW1wdHkgc3RyaW5nIHdlIGNhbiBza2lwIHRoZSBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgaXQgd2lsbCByZXN1bHQgaW4gYW4gZXJyb3IgZnJvbSB0aGUgYXBpIGFuZCB1bHRpbWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgbnVsbCBjb252ZXJzaW9uUmF0ZSBlaXRoZXIgd2F5LlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q3VycmVuY3kgIT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUN1cnJlbmN5ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAoeyBjb252ZXJzaW9uUmF0ZSwgdXNkQ29udmVyc2lvblJhdGUgfSA9IHlpZWxkIHRoaXMuZmV0Y2hFeGNoYW5nZVJhdGUoY3VycmVudEN1cnJlbmN5LCBuYXRpdmVDdXJyZW5jeSwgdGhpcy5pbmNsdWRlVXNkUmF0ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnbWFya2V0IGRvZXMgbm90IGV4aXN0IGZvciB0aGlzIGNvaW4gcGFpcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVyc2lvbkRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVyc2lvblJhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY3VycmVudGx5IGFsbG93IGFuZCBoYW5kbGUgYW4gZW1wdHkgc3RyaW5nIGFzIGEgdmFsaWQgbmF0aXZlQ3VycmVuY3lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXNlcyB3aGVyZSBhIHVzZXIgaGFzIG5vdCBlbnRlcmVkIGEgbmF0aXZlIHRpY2tlciBzeW1ib2wgZm9yIGEgY3VzdG9tIG5ldHdvcmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50Q3VycmVuY3kgaXMgbm90IGZyb20gdXNlciBpbnB1dCBidXQgdGhpcyBwcm90ZWN0cyB1cyBmcm9tIHVuZXhwZWN0ZWQgY2hhbmdlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0N1cnJlbnRDdXJyZW5jeTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTmF0aXZlQ3VycmVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNkQ29udmVyc2lvblJhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ3VycmVuY3lSYXRlQ29udHJvbGxlciA9IEN1cnJlbmN5UmF0ZUNvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBDdXJyZW5jeVJhdGVDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3VycmVuY3lSYXRlQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZU1hbmFnZXIgPSB2b2lkIDA7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgQWJzdHJhY3RNZXNzYWdlTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RNZXNzYWdlTWFuYWdlclwiKTtcbi8qKlxuICogQ29udHJvbGxlciBpbiBjaGFyZ2Ugb2YgbWFuYWdpbmcgLSBzdG9yaW5nLCBhZGRpbmcsIHJlbW92aW5nLCB1cGRhdGluZyAtIE1lc3NhZ2VzLlxuICovXG5jbGFzcyBNZXNzYWdlTWFuYWdlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZU1hbmFnZXJfMS5BYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnTWVzc2FnZU1hbmFnZXInO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1lc3NhZ2Ugd2l0aCBhbiAndW5hcHByb3ZlZCcgc3RhdHVzIHVzaW5nIHRoZSBwYXNzZWQgbWVzc2FnZVBhcmFtcy5cbiAgICAgKiB0aGlzLmFkZE1lc3NhZ2UgaXMgY2FsbGVkIHRvIGFkZCB0aGUgbmV3IE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlIHVuYXBwcm92ZWQgTWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVBhcmFtcyAtIFRoZSBwYXJhbXMgZm9yIHRoZSBldGhfc2lnbiBjYWxsIHRvIGJlIG1hZGUgYWZ0ZXIgdGhlIG1lc3NhZ2UgaXMgYXBwcm92ZWRcbiAgICAgKiBAcGFyYW0gcmVxPyAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdCBwb3NzaWJseSBjb250YWluaW5nIHRoZSBvcmlnaW5cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByYXcgZGF0YSBvZiB0aGUgc2lnbmF0dXJlIHJlcXVlc3RcbiAgICAgKi9cbiAgICBhZGRVbmFwcHJvdmVkTWVzc2FnZUFzeW5jKG1lc3NhZ2VQYXJhbXMsIHJlcSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdXRpbF8xLnZhbGlkYXRlU2lnbk1lc3NhZ2VEYXRhKG1lc3NhZ2VQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gdGhpcy5hZGRVbmFwcHJvdmVkTWVzc2FnZShtZXNzYWdlUGFyYW1zLCByZXEpO1xuICAgICAgICAgICAgdGhpcy5odWIub25jZShgJHttZXNzYWdlSWR9OmZpbmlzaGVkYCwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpZ25lZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShkYXRhLnJhd1NpZyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdNZXRhTWFzayBNZXNzYWdlIFNpZ25hdHVyZTogVXNlciBkZW5pZWQgbWVzc2FnZSBzaWduYXR1cmUuJykpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYE1ldGFNYXNrIE1lc3NhZ2UgU2lnbmF0dXJlOiBVbmtub3duIHByb2JsZW06ICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZVBhcmFtcyl9YCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNZXNzYWdlIHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1lc3NhZ2VQYXJhbXMuXG4gICAgICogdGhpcy5hZGRNZXNzYWdlIGlzIGNhbGxlZCB0byBhZGQgdGhlIG5ldyBNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZVxuICAgICAqIHVuYXBwcm92ZWQgTWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVBhcmFtcyAtIFRoZSBwYXJhbXMgZm9yIHRoZSBldGhfc2lnbiBjYWxsIHRvIGJlIG1hZGUgYWZ0ZXIgdGhlIG1lc3NhZ2VcbiAgICAgKiBpcyBhcHByb3ZlZFxuICAgICAqIEBwYXJhbSByZXE/IC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpblxuICAgICAqIEByZXR1cm5zIC0gVGhlIGlkIG9mIHRoZSBuZXdseSBjcmVhdGVkIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhZGRVbmFwcHJvdmVkTWVzc2FnZShtZXNzYWdlUGFyYW1zLCByZXEpIHtcbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgICAgbWVzc2FnZVBhcmFtcy5vcmlnaW4gPSByZXEub3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VQYXJhbXMuZGF0YSA9IHV0aWxfMS5ub3JtYWxpemVNZXNzYWdlRGF0YShtZXNzYWdlUGFyYW1zLmRhdGEpO1xuICAgICAgICBjb25zdCBtZXNzYWdlSWQgPSB1dWlkXzEudjEoKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZURhdGEgPSB7XG4gICAgICAgICAgICBpZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyxcbiAgICAgICAgICAgIHN0YXR1czogJ3VuYXBwcm92ZWQnLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHR5cGU6ICdldGhfc2lnbicsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkTWVzc2FnZShtZXNzYWdlRGF0YSk7XG4gICAgICAgIHRoaXMuaHViLmVtaXQoYHVuYXBwcm92ZWRNZXNzYWdlYCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtZXNzYWdlUGFyYW1zKSwgeyBtZXRhbWFza0lkOiBtZXNzYWdlSWQgfSkpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZUlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBtZXRhbWFza0lkIHByb3BlcnR5IGZyb20gcGFzc2VkIG1lc3NhZ2VQYXJhbXMgYW5kIHJldHVybnMgYSBwcm9taXNlIHdoaWNoXG4gICAgICogcmVzb2x2ZXMgdGhlIHVwZGF0ZWQgbWVzc2FnZVBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgbWVzc2FnZVBhcmFtcyB0byBtb2RpZnlcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBtZXNzYWdlUGFyYW1zIHdpdGggdGhlIG1ldGFtYXNrSWQgcHJvcGVydHkgcmVtb3ZlZFxuICAgICAqL1xuICAgIHByZXBNZXNzYWdlRm9yU2lnbmluZyhtZXNzYWdlUGFyYW1zKSB7XG4gICAgICAgIGRlbGV0ZSBtZXNzYWdlUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWVzc2FnZVBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5NZXNzYWdlTWFuYWdlciA9IE1lc3NhZ2VNYW5hZ2VyO1xuZXhwb3J0cy5kZWZhdWx0ID0gTWVzc2FnZU1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNzYWdlTWFuYWdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ub2tlbkJhbGFuY2VzQ29udHJvbGxlciA9IGV4cG9ydHMuQk4gPSB2b2lkIDA7XG5jb25zdCBldGhlcmV1bWpzX3V0aWxfMSA9IHJlcXVpcmUoXCJldGhlcmV1bWpzLXV0aWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCTlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJldW1qc191dGlsXzEuQk47IH0gfSk7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBwYXNzaXZlbHkgcG9sbHMgb24gYSBzZXQgaW50ZXJ2YWwgdG9rZW4gYmFsYW5jZXNcbiAqIGZvciB0b2tlbnMgc3RvcmVkIGluIHRoZSBUb2tlbnNDb250cm9sbGVyXG4gKi9cbmNsYXNzIFRva2VuQmFsYW5jZXNDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFRva2VuQmFsYW5jZXNDb250cm9sbGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uVG9rZW5zU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gYXNzZXRzIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldFNlbGVjdGVkQWRkcmVzcyAtIEdldHMgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgYWRkcmVzc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldEJhbGFuY2VPZiAtIEdldHMgdGhlIGJhbGFuY2Ugb2YgdGhlIGdpdmVuIGFjY291bnQgYXQgdGhlIGdpdmVuIGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgb25Ub2tlbnNTdGF0ZUNoYW5nZSwgZ2V0U2VsZWN0ZWRBZGRyZXNzLCBnZXRCYWxhbmNlT2YsIH0sIGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ1Rva2VuQmFsYW5jZXNDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgaW50ZXJ2YWw6IDE4MDAwMCxcbiAgICAgICAgICAgIHRva2VuczogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0geyBjb250cmFjdEJhbGFuY2VzOiB7fSB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgb25Ub2tlbnNTdGF0ZUNoYW5nZSgoeyB0b2tlbnMgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyB0b2tlbnMgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJhbGFuY2VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdldFNlbGVjdGVkQWRkcmVzcyA9IGdldFNlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgdGhpcy5nZXRCYWxhbmNlT2YgPSBnZXRCYWxhbmNlT2Y7XG4gICAgICAgIHRoaXMucG9sbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgcG9sbGluZyBpbnRlcnZhbFxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVydmFsIC0gUG9sbGluZyBpbnRlcnZhbCB1c2VkIHRvIGZldGNoIG5ldyB0b2tlbiBiYWxhbmNlc1xuICAgICAqL1xuICAgIHBvbGwoaW50ZXJ2YWwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGludGVydmFsICYmIHRoaXMuY29uZmlndXJlKHsgaW50ZXJ2YWwgfSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlICYmIGNsZWFyVGltZW91dCh0aGlzLmhhbmRsZSk7XG4gICAgICAgICAgICB5aWVsZCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiB0aGlzLnVwZGF0ZUJhbGFuY2VzKCkpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvbGwodGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfSwgdGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBiYWxhbmNlcyBmb3IgYWxsIHRva2Vuc1xuICAgICAqXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGlzIG9wZXJhdGlvbiBjb21wbGV0ZXNcbiAgICAgKi9cbiAgICB1cGRhdGVCYWxhbmNlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0b2tlbnMgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgY29uc3QgbmV3Q29udHJhY3RCYWxhbmNlcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIHRva2Vucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYWRkcmVzcyB9ID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRyYWN0QmFsYW5jZXNbYWRkcmVzc10gPSB5aWVsZCB0aGlzLmdldEJhbGFuY2VPZihhZGRyZXNzLCB0aGlzLmdldFNlbGVjdGVkQWRkcmVzcygpKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zW2ldLmJhbGFuY2VFcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250cmFjdEJhbGFuY2VzW2FkZHJlc3NdID0gbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKDApO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbaV0uYmFsYW5jZUVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBjb250cmFjdEJhbGFuY2VzOiBuZXdDb250cmFjdEJhbGFuY2VzIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlRva2VuQmFsYW5jZXNDb250cm9sbGVyID0gVG9rZW5CYWxhbmNlc0NvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBUb2tlbkJhbGFuY2VzQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRva2VuQmFsYW5jZXNDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UeXBlZE1lc3NhZ2VNYW5hZ2VyID0gdm9pZCAwO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IEFic3RyYWN0TWVzc2FnZU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0TWVzc2FnZU1hbmFnZXJcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgaW4gY2hhcmdlIG9mIG1hbmFnaW5nIC0gc3RvcmluZywgYWRkaW5nLCByZW1vdmluZywgdXBkYXRpbmcgLSBUeXBlZE1lc3NhZ2VzLlxuICovXG5jbGFzcyBUeXBlZE1lc3NhZ2VNYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlTWFuYWdlcl8xLkFic3RyYWN0TWVzc2FnZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdUeXBlZE1lc3NhZ2VNYW5hZ2VyJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUeXBlZE1lc3NhZ2Ugd2l0aCBhbiAndW5hcHByb3ZlZCcgc3RhdHVzIHVzaW5nIHRoZSBwYXNzZWQgbWVzc2FnZVBhcmFtcy5cbiAgICAgKiB0aGlzLmFkZE1lc3NhZ2UgaXMgY2FsbGVkIHRvIGFkZCB0aGUgbmV3IFR5cGVkTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBUeXBlZE1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgZXRoX3NpZ25UeXBlZERhdGEgY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkXG4gICAgICogQHBhcmFtIHZlcnNpb24gLSBDb21wYXRpYmlsaXR5IHZlcnNpb24gRUlQNzEyXG4gICAgICogQHBhcmFtIHJlcT8gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgcmF3IGRhdGEgb2YgdGhlIHNpZ25hdHVyZSByZXF1ZXN0XG4gICAgICovXG4gICAgYWRkVW5hcHByb3ZlZE1lc3NhZ2VBc3luYyhtZXNzYWdlUGFyYW1zLCB2ZXJzaW9uLCByZXEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAnVjEnKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLnZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMShtZXNzYWdlUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAnVjMnKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLnZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMyhtZXNzYWdlUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IHRoaXMuYWRkVW5hcHByb3ZlZE1lc3NhZ2UobWVzc2FnZVBhcmFtcywgdmVyc2lvbiwgcmVxKTtcbiAgICAgICAgICAgIHRoaXMuaHViLm9uY2UoYCR7bWVzc2FnZUlkfTpmaW5pc2hlZGAsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGF0YS5yYXdTaWcpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTWV0YU1hc2sgVHlwZWQgTWVzc2FnZSBTaWduYXR1cmU6IFVzZXIgZGVuaWVkIG1lc3NhZ2Ugc2lnbmF0dXJlLicpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXJyb3JlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgTWV0YU1hc2sgVHlwZWQgTWVzc2FnZSBTaWduYXR1cmU6ICR7ZGF0YS5lcnJvcn1gKSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgTWV0YU1hc2sgVHlwZWQgTWVzc2FnZSBTaWduYXR1cmU6IFVua25vd24gcHJvYmxlbTogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlUGFyYW1zKX1gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFR5cGVkTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtZXNzYWdlUGFyYW1zLlxuICAgICAqIHRoaXMuYWRkTWVzc2FnZSBpcyBjYWxsZWQgdG8gYWRkIHRoZSBuZXcgVHlwZWRNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZVxuICAgICAqIHVuYXBwcm92ZWQgVHlwZWRNZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlICdldGhfc2lnblR5cGVkRGF0YScgY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlXG4gICAgICogaXMgYXBwcm92ZWRcbiAgICAgKiBAcGFyYW0gdmVyc2lvbiAtIENvbXBhdGliaWxpdHkgdmVyc2lvbiBFSVA3MTJcbiAgICAgKiBAcGFyYW0gcmVxPyAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdCBwb3NzaWJseSBjb250YWluaW5nIHRoZSBvcmlnaW5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSBpZCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBUeXBlZE1lc3NhZ2VcbiAgICAgKi9cbiAgICBhZGRVbmFwcHJvdmVkTWVzc2FnZShtZXNzYWdlUGFyYW1zLCB2ZXJzaW9uLCByZXEpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gdXVpZF8xLnYxKCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VQYXJhbXNNZXRhbWFzayA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWVzc2FnZVBhcmFtcyksIHsgbWV0YW1hc2tJZDogbWVzc2FnZUlkLCB2ZXJzaW9uIH0pO1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgICBtZXNzYWdlUGFyYW1zLm9yaWdpbiA9IHJlcS5vcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZURhdGEgPSB7XG4gICAgICAgICAgICBpZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyxcbiAgICAgICAgICAgIHN0YXR1czogJ3VuYXBwcm92ZWQnLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHR5cGU6ICdldGhfc2lnblR5cGVkRGF0YScsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkTWVzc2FnZShtZXNzYWdlRGF0YSk7XG4gICAgICAgIHRoaXMuaHViLmVtaXQoYHVuYXBwcm92ZWRNZXNzYWdlYCwgbWVzc2FnZVBhcmFtc01ldGFtYXNrKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIFR5cGVkTWVzc2FnZSBzdGF0dXMgdG8gJ2Vycm9yZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5zZXRNZXNzYWdlU3RhdHVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VJZCAtIFRoZSBpZCBvZiB0aGUgVHlwZWRNZXNzYWdlIHRvIGVycm9yXG4gICAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIHRvIGJlIGluY2x1ZGVkIGluIFR5cGVkTWVzc2FnZVxuICAgICAqL1xuICAgIHNldE1lc3NhZ2VTdGF0dXNFcnJvcmVkKG1lc3NhZ2VJZCwgZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuZ2V0TWVzc2FnZShtZXNzYWdlSWQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnVwZGF0ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc2V0TWVzc2FnZVN0YXR1cyhtZXNzYWdlSWQsICdlcnJvcmVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIG1ldGFtYXNrSWQgYW5kIHZlcnNpb24gcHJvcGVydGllcyBmcm9tIHBhc3NlZCBtZXNzYWdlUGFyYW1zIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aGljaFxuICAgICAqIHJlc29sdmVzIHRoZSB1cGRhdGVkIG1lc3NhZ2VQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gVGhlIG1lc3NhZ2VQYXJhbXMgdG8gbW9kaWZ5XG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgbWVzc2FnZVBhcmFtcyB3aXRoIHRoZSBtZXRhbWFza0lkIGFuZCB2ZXJzaW9uIHByb3BlcnRpZXMgcmVtb3ZlZFxuICAgICAqL1xuICAgIHByZXBNZXNzYWdlRm9yU2lnbmluZyhtZXNzYWdlUGFyYW1zKSB7XG4gICAgICAgIGRlbGV0ZSBtZXNzYWdlUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgICAgIGRlbGV0ZSBtZXNzYWdlUGFyYW1zLnZlcnNpb247XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWVzc2FnZVBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5UeXBlZE1lc3NhZ2VNYW5hZ2VyID0gVHlwZWRNZXNzYWdlTWFuYWdlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFR5cGVkTWVzc2FnZU1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UeXBlZE1lc3NhZ2VNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QZXJzb25hbE1lc3NhZ2VNYW5hZ2VyID0gdm9pZCAwO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IEFic3RyYWN0TWVzc2FnZU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0TWVzc2FnZU1hbmFnZXJcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgaW4gY2hhcmdlIG9mIG1hbmFnaW5nIC0gc3RvcmluZywgYWRkaW5nLCByZW1vdmluZywgdXBkYXRpbmcgLSBNZXNzYWdlcy5cbiAqL1xuY2xhc3MgUGVyc29uYWxNZXNzYWdlTWFuYWdlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZU1hbmFnZXJfMS5BYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnUGVyc29uYWxNZXNzYWdlTWFuYWdlcic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtZXNzYWdlUGFyYW1zLlxuICAgICAqIHRoaXMuYWRkTWVzc2FnZSBpcyBjYWxsZWQgdG8gYWRkIHRoZSBuZXcgTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBNZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIHBlcnNvbmFsX3NpZ24gY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkXG4gICAgICogQHBhcmFtIHJlcT8gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgcmF3IGRhdGEgb2YgdGhlIHNpZ25hdHVyZSByZXF1ZXN0XG4gICAgICovXG4gICAgYWRkVW5hcHByb3ZlZE1lc3NhZ2VBc3luYyhtZXNzYWdlUGFyYW1zLCByZXEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHV0aWxfMS52YWxpZGF0ZVNpZ25NZXNzYWdlRGF0YShtZXNzYWdlUGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IHRoaXMuYWRkVW5hcHByb3ZlZE1lc3NhZ2UobWVzc2FnZVBhcmFtcywgcmVxKTtcbiAgICAgICAgICAgIHRoaXMuaHViLm9uY2UoYCR7bWVzc2FnZUlkfTpmaW5pc2hlZGAsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGF0YS5yYXdTaWcpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTWV0YU1hc2sgUGVyc29uYWwgTWVzc2FnZSBTaWduYXR1cmU6IFVzZXIgZGVuaWVkIG1lc3NhZ2Ugc2lnbmF0dXJlLicpKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBNZXRhTWFzayBQZXJzb25hbCBNZXNzYWdlIFNpZ25hdHVyZTogVW5rbm93biBwcm9ibGVtOiAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2VQYXJhbXMpfWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtZXNzYWdlUGFyYW1zLlxuICAgICAqIHRoaXMuYWRkTWVzc2FnZSBpcyBjYWxsZWQgdG8gYWRkIHRoZSBuZXcgTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgdG8gc2F2ZSB0aGVcbiAgICAgKiB1bmFwcHJvdmVkIE1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgcGVyc29uYWxfc2lnbiBjYWxsIHRvIGJlIG1hZGUgYWZ0ZXIgdGhlIG1lc3NhZ2VcbiAgICAgKiBpcyBhcHByb3ZlZFxuICAgICAqIEBwYXJhbSByZXE/IC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpblxuICAgICAqIEByZXR1cm5zIC0gVGhlIGlkIG9mIHRoZSBuZXdseSBjcmVhdGVkIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhZGRVbmFwcHJvdmVkTWVzc2FnZShtZXNzYWdlUGFyYW1zLCByZXEpIHtcbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgICAgbWVzc2FnZVBhcmFtcy5vcmlnaW4gPSByZXEub3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VQYXJhbXMuZGF0YSA9IHV0aWxfMS5ub3JtYWxpemVNZXNzYWdlRGF0YShtZXNzYWdlUGFyYW1zLmRhdGEpO1xuICAgICAgICBjb25zdCBtZXNzYWdlSWQgPSB1dWlkXzEudjEoKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZURhdGEgPSB7XG4gICAgICAgICAgICBpZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyxcbiAgICAgICAgICAgIHN0YXR1czogJ3VuYXBwcm92ZWQnLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHR5cGU6ICdwZXJzb25hbF9zaWduJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRNZXNzYWdlKG1lc3NhZ2VEYXRhKTtcbiAgICAgICAgdGhpcy5odWIuZW1pdChgdW5hcHByb3ZlZE1lc3NhZ2VgLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1lc3NhZ2VQYXJhbXMpLCB7IG1ldGFtYXNrSWQ6IG1lc3NhZ2VJZCB9KSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIG1ldGFtYXNrSWQgcHJvcGVydHkgZnJvbSBwYXNzZWQgbWVzc2FnZVBhcmFtcyBhbmQgcmV0dXJucyBhIHByb21pc2Ugd2hpY2hcbiAgICAgKiByZXNvbHZlcyB0aGUgdXBkYXRlZCBtZXNzYWdlUGFyYW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVBhcmFtcyAtIFRoZSBtZXNzYWdlUGFyYW1zIHRvIG1vZGlmeVxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG1lc3NhZ2VQYXJhbXMgd2l0aCB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSByZW1vdmVkXG4gICAgICovXG4gICAgcHJlcE1lc3NhZ2VGb3JTaWduaW5nKG1lc3NhZ2VQYXJhbXMpIHtcbiAgICAgICAgZGVsZXRlIG1lc3NhZ2VQYXJhbXMubWV0YW1hc2tJZDtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtZXNzYWdlUGFyYW1zKTtcbiAgICB9XG59XG5leHBvcnRzLlBlcnNvbmFsTWVzc2FnZU1hbmFnZXIgPSBQZXJzb25hbE1lc3NhZ2VNYW5hZ2VyO1xuZXhwb3J0cy5kZWZhdWx0ID0gUGVyc29uYWxNZXNzYWdlTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBlcnNvbmFsTWVzc2FnZU1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29sbGVjdGlibGVzQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGFzeW5jX211dGV4XzEgPSByZXF1aXJlKFwiYXN5bmMtbXV0ZXhcIik7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5jb25zdCBhc3NldHNVdGlsXzEgPSByZXF1aXJlKFwiLi9hc3NldHNVdGlsXCIpO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgc3RvcmVzIGFzc2V0cyBhbmQgZXhwb3NlcyBjb252ZW5pZW5jZSBtZXRob2RzXG4gKi9cbmNsYXNzIENvbGxlY3RpYmxlc0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQ29sbGVjdGlibGVzQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gcHJlZmVyZW5jZSBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbk5ldHdvcmtTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBuZXR3b3JrIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldEFzc2V0TmFtZSAtIEdldHMgdGhlIG5hbWUgb2YgdGhlIGFzc2V0IGF0IHRoZSBnaXZlbiBhZGRyZXNzXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0QXNzZXRTeW1ib2wgLSBHZXRzIHRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IGF0IHRoZSBnaXZlbiBhZGRyZXNzXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0Q29sbGVjdGlibGVUb2tlblVSSSAtIEdldHMgdGhlIFVSSSBvZiB0aGUgTkZUIGF0IHRoZSBnaXZlbiBhZGRyZXNzLCB3aXRoIHRoZSBnaXZlbiBJRFxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBnZXRBc3NldE5hbWUsIGdldEFzc2V0U3ltYm9sLCBnZXRDb2xsZWN0aWJsZVRva2VuVVJJLCB9LCBjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICB0aGlzLm11dGV4ID0gbmV3IGFzeW5jX211dGV4XzEuTXV0ZXgoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50RW1pdHRlciBpbnN0YW5jZSB1c2VkIHRvIGxpc3RlbiB0byBzcGVjaWZpYyBFSVA3NDcgZXZlbnRzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmh1YiA9IG5ldyBldmVudHNfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnQ29sbGVjdGlibGVzQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgIG5ldHdvcmtUeXBlOiBjb25zdGFudHNfMS5NQUlOTkVULFxuICAgICAgICAgICAgc2VsZWN0ZWRBZGRyZXNzOiAnJyxcbiAgICAgICAgICAgIGNoYWluSWQ6ICcnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIGFsbENvbGxlY3RpYmxlQ29udHJhY3RzOiB7fSxcbiAgICAgICAgICAgIGFsbENvbGxlY3RpYmxlczoge30sXG4gICAgICAgICAgICBjb2xsZWN0aWJsZUNvbnRyYWN0czogW10sXG4gICAgICAgICAgICBjb2xsZWN0aWJsZXM6IFtdLFxuICAgICAgICAgICAgaWdub3JlZENvbGxlY3RpYmxlczogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmdldEFzc2V0TmFtZSA9IGdldEFzc2V0TmFtZTtcbiAgICAgICAgdGhpcy5nZXRBc3NldFN5bWJvbCA9IGdldEFzc2V0U3ltYm9sO1xuICAgICAgICB0aGlzLmdldENvbGxlY3RpYmxlVG9rZW5VUkkgPSBnZXRDb2xsZWN0aWJsZVRva2VuVVJJO1xuICAgICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UoKHsgc2VsZWN0ZWRBZGRyZXNzIH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlQ29udHJhY3RzLCBhbGxDb2xsZWN0aWJsZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyBzZWxlY3RlZEFkZHJlc3MgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlibGVDb250cmFjdHM6ICgoX2EgPSBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0c1tzZWxlY3RlZEFkZHJlc3NdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbY2hhaW5JZF0pIHx8IFtdLFxuICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlczogKChfYiA9IGFsbENvbGxlY3RpYmxlc1tzZWxlY3RlZEFkZHJlc3NdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbY2hhaW5JZF0pIHx8IFtdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZSgoeyBwcm92aWRlciB9KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgeyBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0cywgYWxsQ29sbGVjdGlibGVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSBwcm92aWRlcjtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHsgY2hhaW5JZCB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZUNvbnRyYWN0czogKChfYSA9IGFsbENvbGxlY3RpYmxlQ29udHJhY3RzW3NlbGVjdGVkQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjaGFpbklkXSkgfHwgW10sXG4gICAgICAgICAgICAgICAgY29sbGVjdGlibGVzOiAoKF9iID0gYWxsQ29sbGVjdGlibGVzW3NlbGVjdGVkQWRkcmVzc10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltjaGFpbklkXSkgfHwgW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENvbGxlY3RpYmxlQXBpKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICByZXR1cm4gYGh0dHBzOi8vYXBpLm9wZW5zZWEuaW8vYXBpL3YxL2Fzc2V0LyR7Y29udHJhY3RBZGRyZXNzfS8ke3Rva2VuSWR9YDtcbiAgICB9XG4gICAgZ2V0Q29sbGVjdGlibGVDb250cmFjdEluZm9ybWF0aW9uQXBpKGNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgICByZXR1cm4gYGh0dHBzOi8vYXBpLm9wZW5zZWEuaW8vYXBpL3YxL2Fzc2V0X2NvbnRyYWN0LyR7Y29udHJhY3RBZGRyZXNzfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgaW5kaXZpZHVhbCBjb2xsZWN0aWJsZSBpbmZvcm1hdGlvbiBmcm9tIE9wZW5TZWEgYXBpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUaGUgY29sbGVjdGlibGUgaWRlbnRpZmllclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlibGUgbmFtZSBhbmQgaW1hZ2VcbiAgICAgKi9cbiAgICBnZXRDb2xsZWN0aWJsZUluZm9ybWF0aW9uRnJvbUFwaShjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuVVJJID0gdGhpcy5nZXRDb2xsZWN0aWJsZUFwaShjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpO1xuICAgICAgICAgICAgbGV0IGNvbGxlY3RpYmxlSW5mb3JtYXRpb247XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLm9wZW5TZWFBcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZUluZm9ybWF0aW9uID0geWllbGQgdXRpbF8xLmhhbmRsZUZldGNoKHRva2VuVVJJLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ1gtQVBJLUtFWSc6IHRoaXMub3BlblNlYUFwaUtleSB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlibGVJbmZvcm1hdGlvbiA9IHlpZWxkIHV0aWxfMS5oYW5kbGVGZXRjaCh0b2tlblVSSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IG51bV9zYWxlcywgYmFja2dyb3VuZF9jb2xvciwgaW1hZ2VfdXJsLCBpbWFnZV9wcmV2aWV3X3VybCwgaW1hZ2VfdGh1bWJuYWlsX3VybCwgaW1hZ2Vfb3JpZ2luYWxfdXJsLCBhbmltYXRpb25fdXJsLCBhbmltYXRpb25fb3JpZ2luYWxfdXJsLCBuYW1lLCBkZXNjcmlwdGlvbiwgZXh0ZXJuYWxfbGluaywgY3JlYXRvciwgbGFzdF9zYWxlLCB9ID0gY29sbGVjdGlibGVJbmZvcm1hdGlvbjtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aWJsZU1ldGFkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgeyBuYW1lIH0sIGNyZWF0b3IgJiYgeyBjcmVhdG9yIH0sIGRlc2NyaXB0aW9uICYmIHsgZGVzY3JpcHRpb24gfSwgaW1hZ2VfdXJsICYmIHsgaW1hZ2U6IGltYWdlX3VybCB9LCBudW1fc2FsZXMgJiYgeyBudW1iZXJPZlNhbGVzOiBudW1fc2FsZXMgfSwgYmFja2dyb3VuZF9jb2xvciAmJiB7IGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZF9jb2xvciB9LCBpbWFnZV9wcmV2aWV3X3VybCAmJiB7IGltYWdlUHJldmlldzogaW1hZ2VfcHJldmlld191cmwgfSwgaW1hZ2VfdGh1bWJuYWlsX3VybCAmJiB7IGltYWdlVGh1bWJuYWlsOiBpbWFnZV90aHVtYm5haWxfdXJsIH0sIGltYWdlX29yaWdpbmFsX3VybCAmJiB7IGltYWdlT3JpZ2luYWw6IGltYWdlX29yaWdpbmFsX3VybCB9LCBhbmltYXRpb25fdXJsICYmIHsgYW5pbWF0aW9uOiBhbmltYXRpb25fdXJsIH0sIGFuaW1hdGlvbl9vcmlnaW5hbF91cmwgJiYge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9yaWdpbmFsOiBhbmltYXRpb25fb3JpZ2luYWxfdXJsLFxuICAgICAgICAgICAgfSwgZXh0ZXJuYWxfbGluayAmJiB7IGV4dGVybmFsTGluazogZXh0ZXJuYWxfbGluayB9LCBsYXN0X3NhbGUgJiYgeyBsYXN0U2FsZTogbGFzdF9zYWxlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RpYmxlTWV0YWRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGluZGl2aWR1YWwgY29sbGVjdGlibGUgaW5mb3JtYXRpb24gZnJvbSBjb250cmFjdHMgdGhhdCBmb2xsb3dzIE1ldGFkYXRhIEludGVyZmFjZVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdFxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVGhlIGNvbGxlY3RpYmxlIGlkZW50aWZpZXJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjdXJyZW50IGNvbGxlY3RpYmxlIG5hbWUgYW5kIGltYWdlXG4gICAgICovXG4gICAgZ2V0Q29sbGVjdGlibGVJbmZvcm1hdGlvbkZyb21Ub2tlblVSSShjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuVVJJID0geWllbGQgdGhpcy5nZXRDb2xsZWN0aWJsZVRva2VuVVJJKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgICAgICBjb25zdCBvYmplY3QgPSB5aWVsZCB1dGlsXzEuaGFuZGxlRmV0Y2godG9rZW5VUkkpO1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnaW1hZ2UnKVxuICAgICAgICAgICAgICAgID8gJ2ltYWdlJ1xuICAgICAgICAgICAgICAgIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gJ2ltYWdlX3VybCc7XG4gICAgICAgICAgICByZXR1cm4geyBpbWFnZTogb2JqZWN0W2ltYWdlXSwgbmFtZTogb2JqZWN0Lm5hbWUgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgaW5kaXZpZHVhbCBjb2xsZWN0aWJsZSBpbmZvcm1hdGlvbiAobmFtZSwgaW1hZ2UgdXJsIGFuZCBkZXNjcmlwdGlvbilcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3RcbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRoZSBjb2xsZWN0aWJsZSBpZGVudGlmaWVyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBuYW1lIGFuZCBpbWFnZVxuICAgICAqL1xuICAgIGdldENvbGxlY3RpYmxlSW5mb3JtYXRpb24oY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgaW5mb3JtYXRpb247XG4gICAgICAgICAgICAvLyBGaXJzdCB0cnkgd2l0aCBPcGVuU2VhXG4gICAgICAgICAgICBpbmZvcm1hdGlvbiA9IHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5nZXRDb2xsZWN0aWJsZUluZm9ybWF0aW9uRnJvbUFwaShjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZm9ybWF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlbiBmb2xsb3dpbmcgRVJDNzIxIHN0YW5kYXJkXG4gICAgICAgICAgICBpbmZvcm1hdGlvbiA9IHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5nZXRDb2xsZWN0aWJsZUluZm9ybWF0aW9uRnJvbVRva2VuVVJJKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZm9ybWF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgY29sbGVjdGlibGUgY29udHJhY3QgaW5mb3JtYXRpb24gZnJvbSBPcGVuU2VhIGFwaVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdFxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlibGUgbmFtZSBhbmQgaW1hZ2VcbiAgICAgKi9cbiAgICBnZXRDb2xsZWN0aWJsZUNvbnRyYWN0SW5mb3JtYXRpb25Gcm9tQXBpKGNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYXBpID0gdGhpcy5nZXRDb2xsZWN0aWJsZUNvbnRyYWN0SW5mb3JtYXRpb25BcGkoY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgIGxldCBhcGlDb2xsZWN0aWJsZUNvbnRyYWN0T2JqZWN0O1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5vcGVuU2VhQXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgYXBpQ29sbGVjdGlibGVDb250cmFjdE9iamVjdCA9IHlpZWxkIHV0aWxfMS5oYW5kbGVGZXRjaChhcGksIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeyAnWC1BUEktS0VZJzogdGhpcy5vcGVuU2VhQXBpS2V5IH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcGlDb2xsZWN0aWJsZUNvbnRyYWN0T2JqZWN0ID0geWllbGQgdXRpbF8xLmhhbmRsZUZldGNoKGFwaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXBpQ29sbGVjdGlibGVDb250cmFjdE9iamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgY29sbGVjdGlibGUgY29udHJhY3QgaW5mb3JtYXRpb24gZnJvbSB0aGUgY29udHJhY3QgaXRzZWxmXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0XG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBuYW1lIGFuZCBpbWFnZVxuICAgICAqL1xuICAgIGdldENvbGxlY3RpYmxlQ29udHJhY3RJbmZvcm1hdGlvbkZyb21Db250cmFjdChjb250cmFjdEFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB5aWVsZCB0aGlzLmdldEFzc2V0TmFtZShjb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0geWllbGQgdGhpcy5nZXRBc3NldFN5bWJvbChjb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHN5bWJvbCxcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYXNzZXRfY29udHJhY3RfdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2RhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgc2NoZW1hX25hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgdG90YWxfc3VwcGx5OiBudWxsLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsX2xpbms6IG51bGwsXG4gICAgICAgICAgICAgICAgaW1hZ2VfdXJsOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgY29sbGVjdGlibGUgY29udHJhY3QgaW5mb3JtYXRpb24gZnJvbSBPcGVuU2VhIGFwaVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdFxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0IG5hbWUsIGltYWdlIGFuZCBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIGdldENvbGxlY3RpYmxlQ29udHJhY3RJbmZvcm1hdGlvbihjb250cmFjdEFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBpbmZvcm1hdGlvbjtcbiAgICAgICAgICAgIC8vIEZpcnN0IHRyeSB3aXRoIE9wZW5TZWFcbiAgICAgICAgICAgIGluZm9ybWF0aW9uID0geWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmdldENvbGxlY3RpYmxlQ29udHJhY3RJbmZvcm1hdGlvbkZyb21BcGkoY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmZvcm1hdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZW4gZm9sbG93aW5nIEVSQzcyMSBzdGFuZGFyZFxuICAgICAgICAgICAgaW5mb3JtYXRpb24gPSB5aWVsZCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZ2V0Q29sbGVjdGlibGVDb250cmFjdEluZm9ybWF0aW9uRnJvbUNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5mb3JtYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYXNzZXRfY29udHJhY3RfdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2RhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICBzY2hlbWFfbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IG51bGwsXG4gICAgICAgICAgICAgICAgdG90YWxfc3VwcGx5OiBudWxsLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsX2xpbms6IG51bGwsXG4gICAgICAgICAgICAgICAgaW1hZ2VfdXJsOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gaW5kaXZpZHVhbCBjb2xsZWN0aWJsZSB0byB0aGUgc3RvcmVkIGNvbGxlY3RpYmxlIGxpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUaGUgY29sbGVjdGlibGUgaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSBvcHRzIC0gQ29sbGVjdGlibGUgb3B0aW9uYWwgaW5mb3JtYXRpb24gKG5hbWUsIGltYWdlIGFuZCBkZXNjcmlwdGlvbilcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjdXJyZW50IGNvbGxlY3RpYmxlIGxpc3RcbiAgICAgKi9cbiAgICBhZGRJbmRpdmlkdWFsQ29sbGVjdGlibGUoYWRkcmVzcywgdG9rZW5JZCwgY29sbGVjdGlibGVNZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlcywgY29sbGVjdGlibGVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCwgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gY29sbGVjdGlibGVzLmZpbmQoKGNvbGxlY3RpYmxlKSA9PiBjb2xsZWN0aWJsZS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZS50b2tlbklkID09PSB0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlTWV0YWRhdGEgPVxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZU1ldGFkYXRhIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoeWllbGQgdGhpcy5nZXRDb2xsZWN0aWJsZUluZm9ybWF0aW9uKGFkZHJlc3MsIHRva2VuSWQpKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmZXJlbnRNZXRhZGF0YSA9IGFzc2V0c1V0aWxfMS5jb21wYXJlQ29sbGVjdGlibGVzTWV0YWRhdGEoY29sbGVjdGlibGVNZXRhZGF0YSwgZXhpc3RpbmdFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWZmZXJlbnRNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXhUb1JlbW92ZSA9IGNvbGxlY3RpYmxlcy5maW5kSW5kZXgoKGNvbGxlY3RpYmxlKSA9PiBjb2xsZWN0aWJsZS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlLnRva2VuSWQgPT09IHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleFRvUmVtb3ZlICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlcy5zcGxpY2UoaW5kZXhUb1JlbW92ZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGlibGVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VudHJ5ID0gT2JqZWN0LmFzc2lnbih7IGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuSWQgfSwgY29sbGVjdGlibGVNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q29sbGVjdGlibGVzID0gWy4uLmNvbGxlY3RpYmxlcywgbmV3RW50cnldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NDb2xsZWN0aWJsZXMgPSBhbGxDb2xsZWN0aWJsZXNbc2VsZWN0ZWRBZGRyZXNzXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdBZGRyZXNzQ29sbGVjdGlibGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhZGRyZXNzQ29sbGVjdGlibGVzKSwgeyBbY2hhaW5JZF06IG5ld0NvbGxlY3RpYmxlcyB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdBbGxDb2xsZWN0aWJsZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFsbENvbGxlY3RpYmxlcyksIHsgW3NlbGVjdGVkQWRkcmVzc106IG5ld0FkZHJlc3NDb2xsZWN0aWJsZXMgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICBhbGxDb2xsZWN0aWJsZXM6IG5ld0FsbENvbGxlY3RpYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlibGVzOiBuZXdDb2xsZWN0aWJsZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NvbGxlY3RpYmxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29sbGVjdGlibGUgY29udHJhY3QgdG8gdGhlIHN0b3JlZCBjb2xsZWN0aWJsZSBjb250cmFjdHMgbGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3RcbiAgICAgKiBAcGFyYW0gZGV0ZWN0aW9uPyAtIFdoZXRoZXIgdGhlIGNvbGxlY3RpYmxlIGlzIG1hbnVhbGx5IGFkZGVkIG9yIGF1dG8tZGV0ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjdXJyZW50IGNvbGxlY3RpYmxlIGNvbnRyYWN0cyBsaXN0XG4gICAgICovXG4gICAgYWRkQ29sbGVjdGlibGVDb250cmFjdChhZGRyZXNzLCBkZXRlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0cywgY29sbGVjdGlibGVDb250cmFjdHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjaGFpbklkLCBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRW50cnkgPSBjb2xsZWN0aWJsZUNvbnRyYWN0cy5maW5kKChjb2xsZWN0aWJsZUNvbnRyYWN0KSA9PiBjb2xsZWN0aWJsZUNvbnRyYWN0LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGlibGVDb250cmFjdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0SW5mb3JtYXRpb24gPSB5aWVsZCB0aGlzLmdldENvbGxlY3RpYmxlQ29udHJhY3RJbmZvcm1hdGlvbihhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFzc2V0X2NvbnRyYWN0X3R5cGUsIGNyZWF0ZWRfZGF0ZSwgbmFtZSwgc2NoZW1hX25hbWUsIHN5bWJvbCwgdG90YWxfc3VwcGx5LCBkZXNjcmlwdGlvbiwgZXh0ZXJuYWxfbGluaywgaW1hZ2VfdXJsLCB9ID0gY29udHJhY3RJbmZvcm1hdGlvbjtcbiAgICAgICAgICAgICAgICAvLyBJZiBiZWluZyBhdXRvLWRldGVjdGVkIG9wZW5zZWEgaW5mb3JtYXRpb24gaXMgZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICAvLyBPaGVyd2lzZSBhdCBsZWFzdCBuYW1lIGFuZCBzeW1ib2wgZnJvbSBjb250cmFjdCBpcyBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoKGRldGVjdGlvbiAmJiAhaW1hZ2VfdXJsKSB8fFxuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjb250cmFjdEluZm9ybWF0aW9uKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RpYmxlQ29udHJhY3RzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VudHJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgeyBhZGRyZXNzIH0sIGRlc2NyaXB0aW9uICYmIHsgZGVzY3JpcHRpb24gfSwgbmFtZSAmJiB7IG5hbWUgfSwgaW1hZ2VfdXJsICYmIHsgbG9nbzogaW1hZ2VfdXJsIH0sIHN5bWJvbCAmJiB7IHN5bWJvbCB9LCB0b3RhbF9zdXBwbHkgIT09IG51bGwgJiYgeyB0b3RhbFN1cHBseTogdG90YWxfc3VwcGx5IH0sIGFzc2V0X2NvbnRyYWN0X3R5cGUgJiYgeyBhc3NldENvbnRyYWN0VHlwZTogYXNzZXRfY29udHJhY3RfdHlwZSB9LCBjcmVhdGVkX2RhdGUgJiYgeyBjcmVhdGVkRGF0ZTogY3JlYXRlZF9kYXRlIH0sIHNjaGVtYV9uYW1lICYmIHsgc2NoZW1hTmFtZTogc2NoZW1hX25hbWUgfSwgZXh0ZXJuYWxfbGluayAmJiB7IGV4dGVybmFsTGluazogZXh0ZXJuYWxfbGluayB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb2xsZWN0aWJsZUNvbnRyYWN0cyA9IFsuLi5jb2xsZWN0aWJsZUNvbnRyYWN0cywgbmV3RW50cnldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NDb2xsZWN0aWJsZUNvbnRyYWN0cyA9IGFsbENvbGxlY3RpYmxlQ29udHJhY3RzW3NlbGVjdGVkQWRkcmVzc107XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QWRkcmVzc0NvbGxlY3RpYmxlQ29udHJhY3RzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhZGRyZXNzQ29sbGVjdGlibGVDb250cmFjdHMpLCB7IFtjaGFpbklkXTogbmV3Q29sbGVjdGlibGVDb250cmFjdHMgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QWxsQ29sbGVjdGlibGVDb250cmFjdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFsbENvbGxlY3RpYmxlQ29udHJhY3RzKSwgeyBbc2VsZWN0ZWRBZGRyZXNzXTogbmV3QWRkcmVzc0NvbGxlY3RpYmxlQ29udHJhY3RzIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgYWxsQ29sbGVjdGlibGVDb250cmFjdHM6IG5ld0FsbENvbGxlY3RpYmxlQ29udHJhY3RzLFxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZUNvbnRyYWN0czogbmV3Q29sbGVjdGlibGVDb250cmFjdHMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NvbGxlY3RpYmxlQ29udHJhY3RzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaW5kaXZpZHVhbCBjb2xsZWN0aWJsZSBmcm9tIHRoZSBzdG9yZWQgdG9rZW4gbGlzdCBhbmQgc2F2ZXMgaXQgaW4gaWdub3JlZCBjb2xsZWN0aWJsZXMgbGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3RcbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRva2VuIGlkZW50aWZpZXIgb2YgdGhlIGNvbGxlY3RpYmxlXG4gICAgICovXG4gICAgcmVtb3ZlQW5kSWdub3JlSW5kaXZpZHVhbENvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgeyBhbGxDb2xsZWN0aWJsZXMsIGNvbGxlY3RpYmxlcywgaWdub3JlZENvbGxlY3RpYmxlcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBuZXdJZ25vcmVkQ29sbGVjdGlibGVzID0gWy4uLmlnbm9yZWRDb2xsZWN0aWJsZXNdO1xuICAgICAgICBjb25zdCBuZXdDb2xsZWN0aWJsZXMgPSBjb2xsZWN0aWJsZXMuZmlsdGVyKChjb2xsZWN0aWJsZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbGxlY3RpYmxlLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpICYmXG4gICAgICAgICAgICAgICAgY29sbGVjdGlibGUudG9rZW5JZCA9PT0gdG9rZW5JZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFscmVhZHlJZ25vcmVkID0gbmV3SWdub3JlZENvbGxlY3RpYmxlcy5maW5kKChjKSA9PiBjLmFkZHJlc3MgPT09IGFkZHJlc3MgJiYgYy50b2tlbklkID09PSB0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAhYWxyZWFkeUlnbm9yZWQgJiYgbmV3SWdub3JlZENvbGxlY3RpYmxlcy5wdXNoKGNvbGxlY3RpYmxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NDb2xsZWN0aWJsZXMgPSBhbGxDb2xsZWN0aWJsZXNbc2VsZWN0ZWRBZGRyZXNzXTtcbiAgICAgICAgY29uc3QgbmV3QWRkcmVzc0NvbGxlY3RpYmxlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWRkcmVzc0NvbGxlY3RpYmxlcyksIHsgW2NoYWluSWRdOiBuZXdDb2xsZWN0aWJsZXMgfSk7XG4gICAgICAgIGNvbnN0IG5ld0FsbENvbGxlY3RpYmxlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWxsQ29sbGVjdGlibGVzKSwgeyBbc2VsZWN0ZWRBZGRyZXNzXTogbmV3QWRkcmVzc0NvbGxlY3RpYmxlcyB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgYWxsQ29sbGVjdGlibGVzOiBuZXdBbGxDb2xsZWN0aWJsZXMsXG4gICAgICAgICAgICBjb2xsZWN0aWJsZXM6IG5ld0NvbGxlY3RpYmxlcyxcbiAgICAgICAgICAgIGlnbm9yZWRDb2xsZWN0aWJsZXM6IG5ld0lnbm9yZWRDb2xsZWN0aWJsZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGluZGl2aWR1YWwgY29sbGVjdGlibGUgZnJvbSB0aGUgc3RvcmVkIHRva2VuIGxpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUb2tlbiBpZGVudGlmaWVyIG9mIHRoZSBjb2xsZWN0aWJsZVxuICAgICAqL1xuICAgIHJlbW92ZUluZGl2aWR1YWxDb2xsZWN0aWJsZShhZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIGFkZHJlc3MgPSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IHsgYWxsQ29sbGVjdGlibGVzLCBjb2xsZWN0aWJsZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCwgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgbmV3Q29sbGVjdGlibGVzID0gY29sbGVjdGlibGVzLmZpbHRlcigoY29sbGVjdGlibGUpID0+ICEoY29sbGVjdGlibGUuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgICAgIGNvbGxlY3RpYmxlLnRva2VuSWQgPT09IHRva2VuSWQpKTtcbiAgICAgICAgY29uc3QgYWRkcmVzc0NvbGxlY3RpYmxlcyA9IGFsbENvbGxlY3RpYmxlc1tzZWxlY3RlZEFkZHJlc3NdO1xuICAgICAgICBjb25zdCBuZXdBZGRyZXNzQ29sbGVjdGlibGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhZGRyZXNzQ29sbGVjdGlibGVzKSwgeyBbY2hhaW5JZF06IG5ld0NvbGxlY3RpYmxlcyB9KTtcbiAgICAgICAgY29uc3QgbmV3QWxsQ29sbGVjdGlibGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhbGxDb2xsZWN0aWJsZXMpLCB7IFtzZWxlY3RlZEFkZHJlc3NdOiBuZXdBZGRyZXNzQ29sbGVjdGlibGVzIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBhbGxDb2xsZWN0aWJsZXM6IG5ld0FsbENvbGxlY3RpYmxlcyxcbiAgICAgICAgICAgIGNvbGxlY3RpYmxlczogbmV3Q29sbGVjdGlibGVzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNvbGxlY3RpYmxlIGNvbnRyYWN0IHRvIHRoZSBzdG9yZWQgY29sbGVjdGlibGUgY29udHJhY3RzIGxpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0XG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBjb250cmFjdHMgbGlzdFxuICAgICAqL1xuICAgIHJlbW92ZUNvbGxlY3RpYmxlQ29udHJhY3QoYWRkcmVzcykge1xuICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlQ29udHJhY3RzLCBjb2xsZWN0aWJsZUNvbnRyYWN0cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBuZXdDb2xsZWN0aWJsZUNvbnRyYWN0cyA9IGNvbGxlY3RpYmxlQ29udHJhY3RzLmZpbHRlcigoY29sbGVjdGlibGVDb250cmFjdCkgPT4gIShjb2xsZWN0aWJsZUNvbnRyYWN0LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NDb2xsZWN0aWJsZUNvbnRyYWN0cyA9IGFsbENvbGxlY3RpYmxlQ29udHJhY3RzW3NlbGVjdGVkQWRkcmVzc107XG4gICAgICAgIGNvbnN0IG5ld0FkZHJlc3NDb2xsZWN0aWJsZUNvbnRyYWN0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWRkcmVzc0NvbGxlY3RpYmxlQ29udHJhY3RzKSwgeyBbY2hhaW5JZF06IG5ld0NvbGxlY3RpYmxlQ29udHJhY3RzIH0pO1xuICAgICAgICBjb25zdCBuZXdBbGxDb2xsZWN0aWJsZUNvbnRyYWN0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWxsQ29sbGVjdGlibGVDb250cmFjdHMpLCB7IFtzZWxlY3RlZEFkZHJlc3NdOiBuZXdBZGRyZXNzQ29sbGVjdGlibGVDb250cmFjdHMgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIGFsbENvbGxlY3RpYmxlQ29udHJhY3RzOiBuZXdBbGxDb2xsZWN0aWJsZUNvbnRyYWN0cyxcbiAgICAgICAgICAgIGNvbGxlY3RpYmxlQ29udHJhY3RzOiBuZXdDb2xsZWN0aWJsZUNvbnRyYWN0cyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdDb2xsZWN0aWJsZUNvbnRyYWN0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhbiBPcGVuU2VhIEFQSSBrZXkgdG8gcmV0cmlldmUgY29sbGVjdGlibGUgaW5mb3JtYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcGVuU2VhQXBpS2V5IC0gT3BlblNlYSBBUEkga2V5XG4gICAgICovXG4gICAgc2V0QXBpS2V5KG9wZW5TZWFBcGlLZXkpIHtcbiAgICAgICAgdGhpcy5vcGVuU2VhQXBpS2V5ID0gb3BlblNlYUFwaUtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvbGxlY3RpYmxlIGFuZCByZXNwZWN0aXZlIGNvbGxlY3RpYmxlIGNvbnRyYWN0IHRvIHRoZSBzdG9yZWQgY29sbGVjdGlibGUgYW5kIGNvbGxlY3RpYmxlIGNvbnRyYWN0cyBsaXN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3RcbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRoZSBjb2xsZWN0aWJsZSBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIGNvbGxlY3RpYmxlTWV0YWRhdGEgLSBDb2xsZWN0aWJsZSBvcHRpb25hbCBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSBkZXRlY3Rpb24/IC0gV2hldGhlciB0aGUgY29sbGVjdGlibGUgaXMgbWFudWFsbHkgYWRkZWQgb3IgYXV0b2RldGVjdGVkXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBsaXN0XG4gICAgICovXG4gICAgYWRkQ29sbGVjdGlibGUoYWRkcmVzcywgdG9rZW5JZCwgY29sbGVjdGlibGVNZXRhZGF0YSwgZGV0ZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgbmV3Q29sbGVjdGlibGVDb250cmFjdHMgPSB5aWVsZCB0aGlzLmFkZENvbGxlY3RpYmxlQ29udHJhY3QoYWRkcmVzcywgZGV0ZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbGxlY3RpYmxlTWV0YWRhdGEgPVxuICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlTWV0YWRhdGEgfHxcbiAgICAgICAgICAgICAgICAgICAgKHlpZWxkIHRoaXMuZ2V0Q29sbGVjdGlibGVJbmZvcm1hdGlvbihhZGRyZXNzLCB0b2tlbklkKSk7XG4gICAgICAgICAgICAvLyBJZiBjb2xsZWN0aWJsZSBjb250cmFjdCB3YXMgbm90IGFkZGVkLCBkbyBub3QgYWRkIGluZGl2aWR1YWwgY29sbGVjdGlibGVcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RpYmxlQ29udHJhY3QgPSBuZXdDb2xsZWN0aWJsZUNvbnRyYWN0cy5maW5kKChjb250cmFjdCkgPT4gY29udHJhY3QuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgLy8gSWYgY29sbGVjdGlibGUgY29udHJhY3QgaW5mb3JtYXRpb24sIGFkZCBpbmRpdmlkdWFsIGNvbGxlY3RpYmxlXG4gICAgICAgICAgICBpZiAoY29sbGVjdGlibGVDb250cmFjdCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuYWRkSW5kaXZpZHVhbENvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQsIGNvbGxlY3RpYmxlTWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNvbGxlY3RpYmxlIGZyb20gdGhlIHN0b3JlZCB0b2tlbiBsaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdFxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVG9rZW4gaWRlbnRpZmllciBvZiB0aGUgY29sbGVjdGlibGVcbiAgICAgKi9cbiAgICByZW1vdmVDb2xsZWN0aWJsZShhZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIGFkZHJlc3MgPSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlSW5kaXZpZHVhbENvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQpO1xuICAgICAgICBjb25zdCB7IGNvbGxlY3RpYmxlcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nQ29sbGVjdGlibGUgPSBjb2xsZWN0aWJsZXMuZmluZCgoY29sbGVjdGlibGUpID0+IGNvbGxlY3RpYmxlLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKCFyZW1haW5pbmdDb2xsZWN0aWJsZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDb2xsZWN0aWJsZUNvbnRyYWN0KGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb2xsZWN0aWJsZSBmcm9tIHRoZSBzdG9yZWQgdG9rZW4gbGlzdCBhbmQgc2F2ZXMgaXQgaW4gaWdub3JlZCBjb2xsZWN0aWJsZXMgbGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3RcbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRva2VuIGlkZW50aWZpZXIgb2YgdGhlIGNvbGxlY3RpYmxlXG4gICAgICovXG4gICAgcmVtb3ZlQW5kSWdub3JlQ29sbGVjdGlibGUoYWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICB0aGlzLnJlbW92ZUFuZElnbm9yZUluZGl2aWR1YWxDb2xsZWN0aWJsZShhZGRyZXNzLCB0b2tlbklkKTtcbiAgICAgICAgY29uc3QgeyBjb2xsZWN0aWJsZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ0NvbGxlY3RpYmxlID0gY29sbGVjdGlibGVzLmZpbmQoKGNvbGxlY3RpYmxlKSA9PiBjb2xsZWN0aWJsZS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICghcmVtYWluaW5nQ29sbGVjdGlibGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29sbGVjdGlibGVDb250cmFjdChhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBjb2xsZWN0aWJsZXMgZnJvbSB0aGUgaWdub3JlZCBsaXN0XG4gICAgICovXG4gICAgY2xlYXJJZ25vcmVkQ29sbGVjdGlibGVzKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGlnbm9yZWRDb2xsZWN0aWJsZXM6IFtdIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29sbGVjdGlibGVzQ29udHJvbGxlciA9IENvbGxlY3RpYmxlc0NvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBDb2xsZWN0aWJsZXNDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sbGVjdGlibGVzQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HYXNGZWVDb250cm9sbGVyID0gZXhwb3J0cy5HQVNfRVNUSU1BVEVfVFlQRVMgPSBleHBvcnRzLkxFR0FDWV9HQVNfUFJJQ0VTX0FQSV9VUkwgPSB2b2lkIDA7XG5jb25zdCBldGhfcXVlcnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLXF1ZXJ5XCIpKTtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuY29uc3QgZXRoZXJldW1qc191dGlsXzEgPSByZXF1aXJlKFwiZXRoZXJldW1qcy11dGlsXCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJWMl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyVjJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGdhc191dGlsXzEgPSByZXF1aXJlKFwiLi9nYXMtdXRpbFwiKTtcbmNvbnN0IEdBU19GRUVfQVBJID0gJ2h0dHBzOi8vbW9jay1nYXMtc2VydmVyLmhlcm9rdWFwcC5jb20vJztcbmV4cG9ydHMuTEVHQUNZX0dBU19QUklDRVNfQVBJX1VSTCA9IGBodHRwczovL2FwaS5tZXRhc3dhcC5jb2RlZmkubmV0d29yay9nYXNQcmljZXNgO1xuLyoqXG4gKiBJbmRpY2F0ZXMgd2hpY2ggdHlwZSBvZiBnYXNFc3RpbWF0ZSB0aGUgY29udHJvbGxlciBpcyBjdXJyZW50bHkgcmV0dXJuaW5nLlxuICogVGhpcyBpcyB1c2VmdWwgYXMgYSB3YXkgb2YgYXNzZXJ0aW5nIHRoYXQgdGhlIHNoYXBlIG9mIGdhc0VzdGltYXRlcyBtYXRjaGVzXG4gKiBleHBlY3RhdGlvbnMuIE5PTkUgaXMgYSBzcGVjaWFsIGNhc2UgaW5kaWNhdGluZyB0aGF0IG5vIHByZXZpb3VzIGdhc0VzdGltYXRlXG4gKiBoYXMgYmVlbiBmZXRjaGVkLlxuICovXG5leHBvcnRzLkdBU19FU1RJTUFURV9UWVBFUyA9IHtcbiAgICBGRUVfTUFSS0VUOiAnZmVlLW1hcmtldCcsXG4gICAgTEVHQUNZOiAnbGVnYWN5JyxcbiAgICBFVEhfR0FTUFJJQ0U6ICdldGhfZ2FzUHJpY2UnLFxuICAgIE5PTkU6ICdub25lJyxcbn07XG5jb25zdCBtZXRhZGF0YSA9IHtcbiAgICBnYXNGZWVFc3RpbWF0ZXM6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiBmYWxzZSB9LFxuICAgIGVzdGltYXRlZEdhc0ZlZVRpbWVCb3VuZHM6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiBmYWxzZSB9LFxuICAgIGdhc0VzdGltYXRlVHlwZTogeyBwZXJzaXN0OiB0cnVlLCBhbm9ueW1vdXM6IGZhbHNlIH0sXG59O1xuY29uc3QgbmFtZSA9ICdHYXNGZWVDb250cm9sbGVyJztcbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgICBnYXNGZWVFc3RpbWF0ZXM6IHt9LFxuICAgIGVzdGltYXRlZEdhc0ZlZVRpbWVCb3VuZHM6IHt9LFxuICAgIGdhc0VzdGltYXRlVHlwZTogZXhwb3J0cy5HQVNfRVNUSU1BVEVfVFlQRVMuTk9ORSxcbn07XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCByZXRyaWV2ZXMgZ2FzIGZlZSBlc3RpbWF0ZSBkYXRhIGFuZCBwb2xscyBmb3IgdXBkYXRlZCBkYXRhIG9uIGEgc2V0IGludGVydmFsXG4gKi9cbmNsYXNzIEdhc0ZlZUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlclYyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBHYXNGZWVDb250cm9sbGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGludGVydmFsID0gMTUwMDAsIG1lc3Nlbmdlciwgc3RhdGUsIGZldGNoR2FzRXN0aW1hdGVzID0gZ2FzX3V0aWxfMS5mZXRjaEdhc0VzdGltYXRlcywgZmV0Y2hFdGhHYXNQcmljZUVzdGltYXRlID0gZ2FzX3V0aWxfMS5mZXRjaEV0aEdhc1ByaWNlRXN0aW1hdGUsIGZldGNoTGVnYWN5R2FzUHJpY2VFc3RpbWF0ZXMgPSBnYXNfdXRpbF8xLmZldGNoTGVnYWN5R2FzUHJpY2VFc3RpbWF0ZXMsIGdldEN1cnJlbnROZXR3b3JrRUlQMTU1OUNvbXBhdGliaWxpdHksIGdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHksIGdldENoYWluSWQsIGdldEN1cnJlbnROZXR3b3JrTGVnYWN5R2FzQVBJQ29tcGF0aWJpbGl0eSwgZ2V0UHJvdmlkZXIsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBsZWdhY3lBUElFbmRwb2ludCA9IGV4cG9ydHMuTEVHQUNZX0dBU19QUklDRVNfQVBJX1VSTCwgRUlQMTU1OUFQSUVuZHBvaW50ID0gR0FTX0ZFRV9BUEksIGNsaWVudElkLCB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIG1lc3NlbmdlcixcbiAgICAgICAgICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdGF0ZSksIHN0YXRlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxEZWxheSA9IGludGVydmFsO1xuICAgICAgICB0aGlzLmZldGNoR2FzRXN0aW1hdGVzID0gZmV0Y2hHYXNFc3RpbWF0ZXM7XG4gICAgICAgIHRoaXMuZmV0Y2hFdGhHYXNQcmljZUVzdGltYXRlID0gZmV0Y2hFdGhHYXNQcmljZUVzdGltYXRlO1xuICAgICAgICB0aGlzLmZldGNoTGVnYWN5R2FzUHJpY2VFc3RpbWF0ZXMgPSBmZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzO1xuICAgICAgICB0aGlzLnBvbGxUb2tlbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE5ldHdvcmtFSVAxNTU5Q29tcGF0aWJpbGl0eSA9IGdldEN1cnJlbnROZXR3b3JrRUlQMTU1OUNvbXBhdGliaWxpdHk7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE5ldHdvcmtMZWdhY3lHYXNBUElDb21wYXRpYmlsaXR5ID0gZ2V0Q3VycmVudE5ldHdvcmtMZWdhY3lHYXNBUElDb21wYXRpYmlsaXR5O1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHkgPSBnZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5O1xuICAgICAgICB0aGlzLkVJUDE1NTlBUElFbmRwb2ludCA9IEVJUDE1NTlBUElFbmRwb2ludDtcbiAgICAgICAgdGhpcy5sZWdhY3lBUElFbmRwb2ludCA9IGxlZ2FjeUFQSUVuZHBvaW50O1xuICAgICAgICB0aGlzLmdldENoYWluSWQgPSBnZXRDaGFpbklkO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGFpbklkID0gdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgdGhpcy5ldGhRdWVyeSA9IG5ldyBldGhfcXVlcnlfMS5kZWZhdWx0KHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdQcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGFpbklkID0gdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgICAgICAgICB0aGlzLmV0aFF1ZXJ5ID0gbmV3IGV0aF9xdWVyeV8xLmRlZmF1bHQobmV3UHJvdmlkZXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudENoYWluSWQgIT09IG5ld0NoYWluSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGFpbklkID0gbmV3Q2hhaW5JZDtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJlc2V0UG9sbGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJlc2V0UG9sbGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvbGxUb2tlbnMuc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IEFycmF5LmZyb20odGhpcy5wb2xsVG9rZW5zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5nZXRHYXNGZWVFc3RpbWF0ZXNBbmRTdGFydFBvbGxpbmcodG9rZW5zWzBdKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMuc2xpY2UoMSkuZm9yRWFjaCgodG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2xsVG9rZW5zLmFkZCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaEdhc0ZlZUVzdGltYXRlcyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5fZmV0Y2hHYXNGZWVFc3RpbWF0ZURhdGEob3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRHYXNGZWVFc3RpbWF0ZXNBbmRTdGFydFBvbGxpbmcocG9sbFRva2VuKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBfcG9sbFRva2VuID0gcG9sbFRva2VuIHx8IHV1aWRfMS52MSgpO1xuICAgICAgICAgICAgdGhpcy5wb2xsVG9rZW5zLmFkZChfcG9sbFRva2VuKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvbGxUb2tlbnMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX2ZldGNoR2FzRmVlRXN0aW1hdGVEYXRhKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9sbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9wb2xsVG9rZW47XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFuZCBzZXRzIGdhc0ZlZUVzdGltYXRlcyBpbiBzdGF0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMgR2FzRmVlRXN0aW1hdGVzXG4gICAgICovXG4gICAgX2ZldGNoR2FzRmVlRXN0aW1hdGVEYXRhKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBzaG91bGRVcGRhdGVTdGF0ZSA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBsZXQgaXNFSVAxNTU5Q29tcGF0aWJsZTtcbiAgICAgICAgICAgIGNvbnN0IGlzTGVnYWN5R2FzQVBJQ29tcGF0aWJsZSA9IHRoaXMuZ2V0Q3VycmVudE5ldHdvcmtMZWdhY3lHYXNBUElDb21wYXRpYmlsaXR5KCk7XG4gICAgICAgICAgICBsZXQgY2hhaW5JZCA9IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFpbklkID09PSAnc3RyaW5nJyAmJiBldGhlcmV1bWpzX3V0aWxfMS5pc0hleFN0cmluZyhjaGFpbklkKSkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBwYXJzZUludChjaGFpbklkLCAxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlzRUlQMTU1OUNvbXBhdGlibGUgPSB5aWVsZCB0aGlzLmdldEVJUDE1NTlDb21wYXRpYmlsaXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgaXNFSVAxNTU5Q29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5ld1N0YXRlID0ge1xuICAgICAgICAgICAgICAgIGdhc0ZlZUVzdGltYXRlczoge30sXG4gICAgICAgICAgICAgICAgZXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kczoge30sXG4gICAgICAgICAgICAgICAgZ2FzRXN0aW1hdGVUeXBlOiBleHBvcnRzLkdBU19FU1RJTUFURV9UWVBFUy5OT05FLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRUlQMTU1OUNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVzID0geWllbGQgdGhpcy5mZXRjaEdhc0VzdGltYXRlcyh0aGlzLkVJUDE1NTlBUElFbmRwb2ludC5yZXBsYWNlKCc8Y2hhaW5faWQ+JywgYCR7Y2hhaW5JZH1gKSwgdGhpcy5jbGllbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMsIHN1Z2dlc3RlZE1heEZlZVBlckdhcywgfSA9IGVzdGltYXRlcy5tZWRpdW07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlZEdhc0ZlZVRpbWVCb3VuZHMgPSB0aGlzLmdldFRpbWVFc3RpbWF0ZShzdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhcywgc3VnZ2VzdGVkTWF4RmVlUGVyR2FzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnYXNGZWVFc3RpbWF0ZXM6IGVzdGltYXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzdGltYXRlZEdhc0ZlZVRpbWVCb3VuZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXNFc3RpbWF0ZVR5cGU6IGV4cG9ydHMuR0FTX0VTVElNQVRFX1RZUEVTLkZFRV9NQVJLRVQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTGVnYWN5R2FzQVBJQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlc3RpbWF0ZXMgPSB5aWVsZCB0aGlzLmZldGNoTGVnYWN5R2FzUHJpY2VFc3RpbWF0ZXModGhpcy5sZWdhY3lBUElFbmRwb2ludC5yZXBsYWNlKCc8Y2hhaW5faWQ+JywgYCR7Y2hhaW5JZH1gKSwgdGhpcy5jbGllbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2FzRmVlRXN0aW1hdGVzOiBlc3RpbWF0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlc3RpbWF0ZWRHYXNGZWVUaW1lQm91bmRzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhc0VzdGltYXRlVHlwZTogZXhwb3J0cy5HQVNfRVNUSU1BVEVfVFlQRVMuTEVHQUNZLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWluIGdhcyBmZWUvcHJpY2UgZXN0aW1hdGlvbiBmYWlsZWQuIFVzZSBmYWxsYmFjaycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlcyA9IHlpZWxkIHRoaXMuZmV0Y2hFdGhHYXNQcmljZUVzdGltYXRlKHRoaXMuZXRoUXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhc0ZlZUVzdGltYXRlczogZXN0aW1hdGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXNFc3RpbWF0ZVR5cGU6IGV4cG9ydHMuR0FTX0VTVElNQVRFX1RZUEVTLkVUSF9HQVNQUklDRSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR2FzIGZlZS9wcmljZSBlc3RpbWF0aW9uIGZhaWxlZC4gTWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGVTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBwb2xsIHRva2VuLCBhbmQgc3RvcCBwb2xsaW5nIGlmIHRoZSBzZXQgb2YgcG9sbCB0b2tlbnMgaXMgZW1wdHlcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0UG9sbGVyKHBvbGxUb2tlbikge1xuICAgICAgICB0aGlzLnBvbGxUb2tlbnMuZGVsZXRlKHBvbGxUb2tlbik7XG4gICAgICAgIGlmICh0aGlzLnBvbGxUb2tlbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3BQb2xsaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb2xsVG9rZW5zLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRvIGRpc2NhcmQgdGhpcyBjb250cm9sbGVyLlxuICAgICAqXG4gICAgICogVGhpcyBzdG9wcyBhbnkgYWN0aXZlIHBvbGxpbmcuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgfVxuICAgIF9wb2xsKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gdGhpcy5fZmV0Y2hHYXNGZWVFc3RpbWF0ZURhdGEoKSk7XG4gICAgICAgIH0pLCB0aGlzLmludGVydmFsRGVsYXkpO1xuICAgIH1cbiAgICByZXNldFN0YXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0YXRlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TmV0d29ya0lzRUlQMTU1OUNvbXBhdGlibGUgPSB5aWVsZCB0aGlzLmdldEN1cnJlbnROZXR3b3JrRUlQMTU1OUNvbXBhdGliaWxpdHkoKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBY2NvdW50SXNFSVAxNTU5Q29tcGF0aWJsZSA9IChfYiA9IChfYSA9IHRoaXMuZ2V0Q3VycmVudEFjY291bnRFSVAxNTU5Q29tcGF0aWJpbGl0eSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gKGN1cnJlbnROZXR3b3JrSXNFSVAxNTU5Q29tcGF0aWJsZSAmJiBjdXJyZW50QWNjb3VudElzRUlQMTU1OUNvbXBhdGlibGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VGltZUVzdGltYXRlKG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmdhc0ZlZUVzdGltYXRlcyB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5nYXNFc3RpbWF0ZVR5cGUgIT09IGV4cG9ydHMuR0FTX0VTVElNQVRFX1RZUEVTLkZFRV9NQVJLRVQpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2FzX3V0aWxfMS5jYWxjdWxhdGVUaW1lRXN0aW1hdGUobWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgdGhpcy5zdGF0ZS5nYXNGZWVFc3RpbWF0ZXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuR2FzRmVlQ29udHJvbGxlciA9IEdhc0ZlZUNvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBHYXNGZWVDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2FzRmVlQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZU1pbmltdW1JbmNyZWFzZSA9IGV4cG9ydHMuaXNHYXNQcmljZVZhbHVlID0gZXhwb3J0cy5pc0ZlZU1hcmtldEVJUDE1NTlWYWx1ZXMgPSBleHBvcnRzLnZhbGlkYXRlR2FzVmFsdWVzID0gZXhwb3J0cy5nZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZyA9IGV4cG9ydHMuZ2V0SW5jcmVhc2VkUHJpY2VIZXggPSBleHBvcnRzLmNvbnZlcnRQcmljZVRvRGVjaW1hbCA9IGV4cG9ydHMuaXNFSVAxNTU5VHJhbnNhY3Rpb24gPSBleHBvcnRzLnF1ZXJ5ID0gZXhwb3J0cy5ub3JtYWxpemVFbnNOYW1lID0gZXhwb3J0cy50aW1lb3V0RmV0Y2ggPSBleHBvcnRzLmhhbmRsZUZldGNoID0gZXhwb3J0cy5zdWNjZXNzZnVsRmV0Y2ggPSBleHBvcnRzLmlzU21hcnRDb250cmFjdENvZGUgPSBleHBvcnRzLnZhbGlkYXRlVG9rZW5Ub1dhdGNoID0gZXhwb3J0cy52YWxpZGF0ZVR5cGVkU2lnbk1lc3NhZ2VEYXRhVjMgPSBleHBvcnRzLnZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMSA9IGV4cG9ydHMudmFsaWRhdGVTaWduTWVzc2FnZURhdGEgPSBleHBvcnRzLm5vcm1hbGl6ZU1lc3NhZ2VEYXRhID0gZXhwb3J0cy52YWxpZGF0ZVRyYW5zYWN0aW9uID0gZXhwb3J0cy5pc1ZhbGlkSGV4QWRkcmVzcyA9IGV4cG9ydHMudG9DaGVja3N1bUhleEFkZHJlc3MgPSBleHBvcnRzLnNhZmVseUV4ZWN1dGVXaXRoVGltZW91dCA9IGV4cG9ydHMuc2FmZWx5RXhlY3V0ZSA9IGV4cG9ydHMubm9ybWFsaXplVHJhbnNhY3Rpb24gPSBleHBvcnRzLmhleFRvVGV4dCA9IGV4cG9ydHMuaGV4VG9CTiA9IGV4cG9ydHMuaGFuZGxlVHJhbnNhY3Rpb25GZXRjaCA9IGV4cG9ydHMuZ2V0RXRoZXJzY2FuQXBpVXJsID0gZXhwb3J0cy5nZXRCdXlVUkwgPSBleHBvcnRzLndlaUhleFRvR3dlaURlYyA9IGV4cG9ydHMuZ3dlaURlY1RvV0VJQk4gPSBleHBvcnRzLmZyYWN0aW9uQk4gPSBleHBvcnRzLkJOVG9IZXggPSB2b2lkIDA7XG5jb25zdCBldGhlcmV1bWpzX3V0aWxfMSA9IHJlcXVpcmUoXCJldGhlcmV1bWpzLXV0aWxcIik7XG5jb25zdCBldGhqc191dGlsXzEgPSByZXF1aXJlKFwiZXRoanMtdXRpbFwiKTtcbmNvbnN0IGV0aGpzX3VuaXRfMSA9IHJlcXVpcmUoXCJldGhqcy11bml0XCIpO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IGV0aF9lbnNfbmFtZWhhc2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLWVucy1uYW1laGFzaFwiKSk7XG5jb25zdCBldGhfc2lnX3V0aWxfMSA9IHJlcXVpcmUoXCJldGgtc2lnLXV0aWxcIik7XG5jb25zdCBqc29uc2NoZW1hXzEgPSByZXF1aXJlKFwianNvbnNjaGVtYVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgaGV4UmUgPSAvXlswLTlBLUZhLWZdKyQvZ3U7XG5jb25zdCBOT1JNQUxJWkVSUyA9IHtcbiAgICBkYXRhOiAoZGF0YSkgPT4gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KGRhdGEpLFxuICAgIGZyb206IChmcm9tKSA9PiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgoZnJvbSkudG9Mb3dlckNhc2UoKSxcbiAgICBnYXM6IChnYXMpID0+IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChnYXMpLFxuICAgIGdhc1ByaWNlOiAoZ2FzUHJpY2UpID0+IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChnYXNQcmljZSksXG4gICAgbm9uY2U6IChub25jZSkgPT4gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KG5vbmNlKSxcbiAgICB0bzogKHRvKSA9PiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgodG8pLnRvTG93ZXJDYXNlKCksXG4gICAgdmFsdWU6ICh2YWx1ZSkgPT4gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KHZhbHVlKSxcbiAgICBtYXhGZWVQZXJHYXM6IChtYXhGZWVQZXJHYXMpID0+IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChtYXhGZWVQZXJHYXMpLFxuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiAobWF4UHJpb3JpdHlGZWVQZXJHYXMpID0+IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChtYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgZXN0aW1hdGVkQmFzZUZlZTogKG1heFByaW9yaXR5RmVlUGVyR2FzKSA9PiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgobWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxufTtcbi8qKlxuICogQ29udmVydHMgYSBCTiBvYmplY3QgdG8gYSBoZXggc3RyaW5nIHdpdGggYSAnMHgnIHByZWZpeFxuICpcbiAqIEBwYXJhbSBpbnB1dEJuIC0gQk4gaW5zdGFuY2UgdG8gY29udmVydCB0byBhIGhleCBzdHJpbmdcbiAqIEByZXR1cm5zIC0gJzB4Jy1wcmVmaXhlZCBoZXggc3RyaW5nXG4gKlxuICovXG5mdW5jdGlvbiBCTlRvSGV4KGlucHV0Qm4pIHtcbiAgICByZXR1cm4gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KGlucHV0Qm4udG9TdHJpbmcoMTYpKTtcbn1cbmV4cG9ydHMuQk5Ub0hleCA9IEJOVG9IZXg7XG4vKipcbiAqIFVzZWQgdG8gbXVsdGlwbHkgYSBCTiBieSBhIGZyYWN0aW9uXG4gKlxuICogQHBhcmFtIHRhcmdldEJOIC0gTnVtYmVyIHRvIG11bHRpcGx5IGJ5IGEgZnJhY3Rpb25cbiAqIEBwYXJhbSBudW1lcmF0b3IgLSBOdW1lcmF0b3Igb2YgdGhlIGZyYWN0aW9uIG11bHRpcGxpZXJcbiAqIEBwYXJhbSBkZW5vbWluYXRvciAtIERlbm9taW5hdG9yIG9mIHRoZSBmcmFjdGlvbiBtdWx0aXBsaWVyXG4gKiBAcmV0dXJucyAtIFByb2R1Y3Qgb2YgdGhlIG11bHRpcGxpY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIGZyYWN0aW9uQk4odGFyZ2V0Qk4sIG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICBjb25zdCBudW1CTiA9IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTihudW1lcmF0b3IpO1xuICAgIGNvbnN0IGRlbm9tQk4gPSBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oZGVub21pbmF0b3IpO1xuICAgIHJldHVybiB0YXJnZXRCTi5tdWwobnVtQk4pLmRpdihkZW5vbUJOKTtcbn1cbmV4cG9ydHMuZnJhY3Rpb25CTiA9IGZyYWN0aW9uQk47XG4vKipcbiAqIFVzZWQgdG8gY29udmVydCBhIGJhc2UtMTAgbnVtYmVyIGZyb20gR1dFSSB0byBXRUkuIENhbiBoYW5kbGUgbnVtYmVycyB3aXRoIGRlY2ltYWwgcGFydHNcbiAqXG4gKiBAcGFyYW0gbiAtIFRoZSBiYXNlIDEwIG51bWJlciB0byBjb252ZXJ0IHRvIFdFSVxuICogQHJldHVybnMgLSBUaGUgbnVtYmVyIGluIFdFSSwgYXMgYSBCTlxuICovXG5mdW5jdGlvbiBnd2VpRGVjVG9XRUlCTihuKSB7XG4gICAgaWYgKE51bWJlci5pc05hTihuKSkge1xuICAgICAgICByZXR1cm4gbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKDApO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IG4udG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHdob2xlUGFydCA9IHBhcnRzWzBdIHx8ICcwJztcbiAgICBsZXQgZGVjaW1hbFBhcnQgPSBwYXJ0c1sxXSB8fCAnJztcbiAgICBpZiAoIWRlY2ltYWxQYXJ0KSB7XG4gICAgICAgIHJldHVybiBldGhqc191bml0XzEudG9XZWkod2hvbGVQYXJ0LCAnZ3dlaScpO1xuICAgIH1cbiAgICBpZiAoZGVjaW1hbFBhcnQubGVuZ3RoIDw9IDkpIHtcbiAgICAgICAgcmV0dXJuIGV0aGpzX3VuaXRfMS50b1dlaShgJHt3aG9sZVBhcnR9LiR7ZGVjaW1hbFBhcnR9YCwgJ2d3ZWknKTtcbiAgICB9XG4gICAgY29uc3QgZGVjaW1hbFBhcnRUb1JlbW92ZSA9IGRlY2ltYWxQYXJ0LnNsaWNlKDkpO1xuICAgIGNvbnN0IGRlY2ltYWxSb3VuZGluZ0RpZ2l0ID0gZGVjaW1hbFBhcnRUb1JlbW92ZVswXTtcbiAgICBkZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0LnNsaWNlKDAsIDkpO1xuICAgIGxldCB3ZWkgPSBldGhqc191bml0XzEudG9XZWkoYCR7d2hvbGVQYXJ0fS4ke2RlY2ltYWxQYXJ0fWAsICdnd2VpJyk7XG4gICAgaWYgKE51bWJlcihkZWNpbWFsUm91bmRpbmdEaWdpdCkgPj0gNSkge1xuICAgICAgICB3ZWkgPSB3ZWkuYWRkKG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTigxKSk7XG4gICAgfVxuICAgIHJldHVybiB3ZWk7XG59XG5leHBvcnRzLmd3ZWlEZWNUb1dFSUJOID0gZ3dlaURlY1RvV0VJQk47XG4vKipcbiAqIFVzZWQgdG8gY29udmVydCB2YWx1ZXMgZnJvbSB3ZWkgaGV4IGZvcm1hdCB0byBkZWMgZ3dlaSBmb3JtYXRcbiAqIEBwYXJhbSBoZXggLSB2YWx1ZSBpbiBoZXggd2VpXG4gKiBAcmV0dXJucyAtIHZhbHVlIGluIGRlYyBnd2VpIGFzIHN0cmluZ1xuICovXG5mdW5jdGlvbiB3ZWlIZXhUb0d3ZWlEZWMoaGV4KSB7XG4gICAgY29uc3QgaGV4V2VpID0gbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKGV0aGpzX3V0aWxfMS5zdHJpcEhleFByZWZpeChoZXgpLCAxNik7XG4gICAgcmV0dXJuIGV0aGpzX3VuaXRfMS5mcm9tV2VpKGhleFdlaSwgJ2d3ZWknKS50b1N0cmluZygxMCk7XG59XG5leHBvcnRzLndlaUhleFRvR3dlaURlYyA9IHdlaUhleFRvR3dlaURlYztcbi8qKlxuICogUmV0dXJuIGEgVVJMIHRoYXQgY2FuIGJlIHVzZWQgdG8gb2J0YWluIEVUSCBmb3IgYSBnaXZlbiBuZXR3b3JrXG4gKlxuICogQHBhcmFtIG5ldHdvcmtDb2RlIC0gTmV0d29yayBjb2RlIG9mIGRlc2lyZWQgbmV0d29ya1xuICogQHBhcmFtIGFkZHJlc3MgLSBBZGRyZXNzIHRvIGRlcG9zaXQgb2J0YWluZWQgRVRIXG4gKiBAcGFyYW0gYW1vdW50IC0gSG93IG11Y2ggRVRIIGlzIGRlc2lyZWRcbiAqIEByZXR1cm5zIC0gVVJMIHRvIGJ1eSBFVEggYmFzZWQgb24gbmV0d29ya1xuICovXG5mdW5jdGlvbiBnZXRCdXlVUkwobmV0d29ya0NvZGUgPSAnMScsIGFkZHJlc3MsIGFtb3VudCA9IDUpIHtcbiAgICBzd2l0Y2ggKG5ldHdvcmtDb2RlKSB7XG4gICAgICAgIGNhc2UgJzEnOlxuICAgICAgICAgICAgcmV0dXJuIGBodHRwczovL2J1eS5jb2luYmFzZS5jb20vP2NvZGU9OWVjNTZkMDEtN2U4MS01MDE3LTkzMGMtNTEzZGFhMjdiYjZhJmFtb3VudD0ke2Ftb3VudH0mYWRkcmVzcz0ke2FkZHJlc3N9JmNyeXB0b19jdXJyZW5jeT1FVEhgO1xuICAgICAgICBjYXNlICczJzpcbiAgICAgICAgICAgIHJldHVybiAnaHR0cHM6Ly9mYXVjZXQubWV0YW1hc2suaW8vJztcbiAgICAgICAgY2FzZSAnNCc6XG4gICAgICAgICAgICByZXR1cm4gJ2h0dHBzOi8vd3d3LnJpbmtlYnkuaW8vJztcbiAgICAgICAgY2FzZSAnNSc6XG4gICAgICAgICAgICByZXR1cm4gJ2h0dHBzOi8vZ29lcmxpLWZhdWNldC5zbG9jay5pdC8nO1xuICAgICAgICBjYXNlICc0Mic6XG4gICAgICAgICAgICByZXR1cm4gJ2h0dHBzOi8vZ2l0aHViLmNvbS9rb3Zhbi10ZXN0bmV0L2ZhdWNldCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0QnV5VVJMID0gZ2V0QnV5VVJMO1xuLyoqXG4gKiBSZXR1cm4gYSBVUkwgdGhhdCBjYW4gYmUgdXNlZCB0byBmZXRjaCBFVEggdHJhbnNhY3Rpb25zXG4gKlxuICogQHBhcmFtIG5ldHdvcmtUeXBlIC0gTmV0d29yayB0eXBlIG9mIGRlc2lyZWQgbmV0d29ya1xuICogQHBhcmFtIHVybFBhcmFtcyAtIFBhcmFtZXRlcnMgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIFVSTFxuICogQHJldHVybnMgLSBVUkwgdG8gZmV0Y2ggdGhlIGFjY2VzcyB0aGUgZW5kcG9pbnRcbiAqL1xuZnVuY3Rpb24gZ2V0RXRoZXJzY2FuQXBpVXJsKG5ldHdvcmtUeXBlLCB1cmxQYXJhbXMpIHtcbiAgICBsZXQgZXRoZXJzY2FuU3ViZG9tYWluID0gJ2FwaSc7XG4gICAgaWYgKG5ldHdvcmtUeXBlICE9PSBjb25zdGFudHNfMS5NQUlOTkVUKSB7XG4gICAgICAgIGV0aGVyc2NhblN1YmRvbWFpbiA9IGBhcGktJHtuZXR3b3JrVHlwZX1gO1xuICAgIH1cbiAgICBjb25zdCBhcGlVcmwgPSBgaHR0cHM6Ly8ke2V0aGVyc2NhblN1YmRvbWFpbn0uZXRoZXJzY2FuLmlvYDtcbiAgICBsZXQgdXJsID0gYCR7YXBpVXJsfS9hcGk/YDtcbiAgICBmb3IgKGNvbnN0IHBhcmFtS2V5IGluIHVybFBhcmFtcykge1xuICAgICAgICBpZiAodXJsUGFyYW1zW3BhcmFtS2V5XSkge1xuICAgICAgICAgICAgdXJsICs9IGAke3BhcmFtS2V5fT0ke3VybFBhcmFtc1twYXJhbUtleV19JmA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXJsICs9ICd0YWc9bGF0ZXN0JnBhZ2U9MSc7XG4gICAgcmV0dXJuIHVybDtcbn1cbmV4cG9ydHMuZ2V0RXRoZXJzY2FuQXBpVXJsID0gZ2V0RXRoZXJzY2FuQXBpVXJsO1xuLyoqXG4gKiBIYW5kbGVzIHRoZSBmZXRjaCBvZiBpbmNvbWluZyB0cmFuc2FjdGlvbnNcbiAqXG4gKiBAcGFyYW0gbmV0d29ya1R5cGUgLSBOZXR3b3JrIHR5cGUgb2YgZGVzaXJlZCBuZXR3b3JrXG4gKiBAcGFyYW0gYWRkcmVzcyAtIEFkZHJlc3MgdG8gZ2V0IHRoZSB0cmFuc2FjdGlvbnMgZnJvbVxuICogQHBhcmFtIG9wdD8gLSBPYmplY3QgdGhhdCBjYW4gY29udGFpbiBmcm9tQmxvY2sgYW5kIEV0aGVyc2NhbiBzZXJ2aWNlIEFQSSBrZXlcbiAqIEByZXR1cm5zIC0gUmVzcG9uc2VzIGZvciBib3RoIEVUSCBhbmQgRVJDMjAgdG9rZW4gdHJhbnNhY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVRyYW5zYWN0aW9uRmV0Y2gobmV0d29ya1R5cGUsIGFkZHJlc3MsIHR4SGlzdG9yeUxpbWl0LCBvcHQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAvLyB0cmFuc2FjdGlvbnNcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0ge1xuICAgICAgICAgICAgbW9kdWxlOiAnYWNjb3VudCcsXG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgc3RhcnRCbG9jazogb3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmZyb21CbG9jayxcbiAgICAgICAgICAgIGFwaWtleTogb3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmV0aGVyc2NhbkFwaUtleSxcbiAgICAgICAgICAgIG9mZnNldDogdHhIaXN0b3J5TGltaXQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIG9yZGVyOiAnZGVzYycsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGV0aGVyc2NhblR4VXJsID0gZ2V0RXRoZXJzY2FuQXBpVXJsKG5ldHdvcmtUeXBlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHVybFBhcmFtcyksIHsgYWN0aW9uOiAndHhsaXN0JyB9KSk7XG4gICAgICAgIGNvbnN0IGV0aGVyc2NhblR4UmVzcG9uc2VQcm9taXNlID0gaGFuZGxlRmV0Y2goZXRoZXJzY2FuVHhVcmwpO1xuICAgICAgICAvLyB0b2tlbnNcbiAgICAgICAgY29uc3QgZXRoZXJzY2FuVG9rZW5VcmwgPSBnZXRFdGhlcnNjYW5BcGlVcmwobmV0d29ya1R5cGUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXJsUGFyYW1zKSwgeyBhY3Rpb246ICd0b2tlbnR4JyB9KSk7XG4gICAgICAgIGNvbnN0IGV0aGVyc2NhblRva2VuUmVzcG9uc2VQcm9taXNlID0gaGFuZGxlRmV0Y2goZXRoZXJzY2FuVG9rZW5VcmwpO1xuICAgICAgICBsZXQgW2V0aGVyc2NhblR4UmVzcG9uc2UsIGV0aGVyc2NhblRva2VuUmVzcG9uc2VdID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgZXRoZXJzY2FuVHhSZXNwb25zZVByb21pc2UsXG4gICAgICAgICAgICBldGhlcnNjYW5Ub2tlblJlc3BvbnNlUHJvbWlzZSxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChldGhlcnNjYW5UeFJlc3BvbnNlLnN0YXR1cyA9PT0gJzAnIHx8XG4gICAgICAgICAgICBldGhlcnNjYW5UeFJlc3BvbnNlLnJlc3VsdC5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgZXRoZXJzY2FuVHhSZXNwb25zZSA9IHsgc3RhdHVzOiBldGhlcnNjYW5UeFJlc3BvbnNlLnN0YXR1cywgcmVzdWx0OiBbXSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChldGhlcnNjYW5Ub2tlblJlc3BvbnNlLnN0YXR1cyA9PT0gJzAnIHx8XG4gICAgICAgICAgICBldGhlcnNjYW5Ub2tlblJlc3BvbnNlLnJlc3VsdC5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgZXRoZXJzY2FuVG9rZW5SZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGV0aGVyc2NhblRva2VuUmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZXRoZXJzY2FuVHhSZXNwb25zZSwgZXRoZXJzY2FuVG9rZW5SZXNwb25zZV07XG4gICAgfSk7XG59XG5leHBvcnRzLmhhbmRsZVRyYW5zYWN0aW9uRmV0Y2ggPSBoYW5kbGVUcmFuc2FjdGlvbkZldGNoO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSBCTiBvYmplY3RcbiAqXG4gKiBAcGFyYW0gaW5wdXRIZXggLSBOdW1iZXIgcmVwcmVzZW50ZWQgYXMgYSBoZXggc3RyaW5nXG4gKiBAcmV0dXJucyAtIEEgQk4gaW5zdGFuY2VcbiAqXG4gKi9cbmZ1bmN0aW9uIGhleFRvQk4oaW5wdXRIZXgpIHtcbiAgICByZXR1cm4gbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKGV0aGpzX3V0aWxfMS5zdHJpcEhleFByZWZpeChpbnB1dEhleCksIDE2KTtcbn1cbmV4cG9ydHMuaGV4VG9CTiA9IGhleFRvQk47XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgY29udmVydHMgaGV4IGRhdGEgdG8gaHVtYW4gcmVhZGFibGUgc3RyaW5nXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSBoZXggc3RyaW5nIHRvIGNvbnZlcnQgdG8gc3RyaW5nXG4gKiBAcmV0dXJucyAtIEEgaHVtYW4gcmVhZGFibGUgc3RyaW5nIGNvbnZlcnNpb25cbiAqXG4gKi9cbmZ1bmN0aW9uIGhleFRvVGV4dChoZXgpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzdHJpcHBlZCA9IGV0aGpzX3V0aWxfMS5zdHJpcEhleFByZWZpeChoZXgpO1xuICAgICAgICBjb25zdCBidWZmID0gQnVmZmVyLmZyb20oc3RyaXBwZWQsICdoZXgnKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmYudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGhleDtcbiAgICB9XG59XG5leHBvcnRzLmhleFRvVGV4dCA9IGhleFRvVGV4dDtcbi8qKlxuICogTm9ybWFsaXplcyBwcm9wZXJ0aWVzIG9uIGEgVHJhbnNhY3Rpb24gb2JqZWN0XG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gb2JqZWN0IHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMgLSBOb3JtYWxpemVkIFRyYW5zYWN0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRUcmFuc2FjdGlvbiA9IHsgZnJvbTogJycgfTtcbiAgICBsZXQga2V5O1xuICAgIGZvciAoa2V5IGluIE5PUk1BTElaRVJTKSB7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkVHJhbnNhY3Rpb25ba2V5XSA9IE5PUk1BTElaRVJTW2tleV0odHJhbnNhY3Rpb25ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRUcmFuc2FjdGlvbjtcbn1cbmV4cG9ydHMubm9ybWFsaXplVHJhbnNhY3Rpb24gPSBub3JtYWxpemVUcmFuc2FjdGlvbjtcbi8qKlxuICogRXhlY3V0ZSBhbmQgcmV0dXJuIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24gd2l0aG91dCB0aHJvd2luZyBlcnJvcnNcbiAqXG4gKiBAcGFyYW0gb3BlcmF0aW9uIC0gRnVuY3Rpb24gcmV0dXJuaW5nIGEgUHJvbWlzZVxuICogQHBhcmFtIGxvZ0Vycm9yIC0gRGV0ZXJtaW5lcyBpZiB0aGUgZXJyb3Igc2hvdWxkIGJlIGxvZ2dlZFxuICogQHBhcmFtIHJldHJ5IC0gRnVuY3Rpb24gY2FsbGVkIGlmIGFuIGVycm9yIGlzIGNhdWdodFxuICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgcmVzdWx0IG9mIHRoZSBhc3luYyBvcGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gc2FmZWx5RXhlY3V0ZShvcGVyYXRpb24sIGxvZ0Vycm9yID0gZmFsc2UsIHJldHJ5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBvcGVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAobG9nRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHJ5ID09PSBudWxsIHx8IHJldHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXRyeShlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnNhZmVseUV4ZWN1dGUgPSBzYWZlbHlFeGVjdXRlO1xuLyoqXG4gKiBFeGVjdXRlIGFuZCByZXR1cm4gYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aXRoIGEgdGltZW91dFxuICpcbiAqIEBwYXJhbSBvcGVyYXRpb24gLSBGdW5jdGlvbiByZXR1cm5pbmcgYSBQcm9taXNlXG4gKiBAcGFyYW0gbG9nRXJyb3IgLSBEZXRlcm1pbmVzIGlmIHRoZSBlcnJvciBzaG91bGQgYmUgbG9nZ2VkXG4gKiBAcGFyYW0gcmV0cnkgLSBGdW5jdGlvbiBjYWxsZWQgaWYgYW4gZXJyb3IgaXMgY2F1Z2h0XG4gKiBAcGFyYW0gdGltZW91dCAtIFRpbWVvdXQgdG8gZmFpbCB0aGUgb3BlcmF0aW9uXG4gKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByZXN1bHQgb2YgdGhlIGFzeW5jIG9wZXJhdGlvblxuICovXG5mdW5jdGlvbiBzYWZlbHlFeGVjdXRlV2l0aFRpbWVvdXQob3BlcmF0aW9uLCBsb2dFcnJvciA9IGZhbHNlLCB0aW1lb3V0ID0gNTAwKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbigpLFxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCd0aW1lb3V0JykpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmIChsb2dFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5zYWZlbHlFeGVjdXRlV2l0aFRpbWVvdXQgPSBzYWZlbHlFeGVjdXRlV2l0aFRpbWVvdXQ7XG5mdW5jdGlvbiB0b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgY29uc3QgaGV4UHJlZml4ZWQgPSBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgoYWRkcmVzcyk7XG4gICAgaWYgKCFldGhlcmV1bWpzX3V0aWxfMS5pc0hleFN0cmluZyhoZXhQcmVmaXhlZCkpIHtcbiAgICAgICAgLy8gVmVyc2lvbiA1LjEgb2YgZXRoZXJldW1qcy11dGlscyB3b3VsZCBoYXZlIHJldHVybmVkICcweFknIGZvciBpbnB1dCAneSdcbiAgICAgICAgLy8gYnV0IHdlIHNob3VsZG4ndCB3YXN0ZSBlZmZvcnQgdHJ5aW5nIHRvIGNoYW5nZSBjYXNlIG9uIGEgY2xlYXJseSBpbnZhbGlkXG4gICAgICAgIC8vIHN0cmluZy4gSW5zdGVhZCBqdXN0IHJldHVybiB0aGUgaGV4IHByZWZpeGVkIG9yaWdpbmFsIHN0cmluZyB3aGljaCBtb3N0XG4gICAgICAgIC8vIGNsb3NlbHkgbWltaWNzIHRoZSBvcmlnaW5hbCBiZWhhdmlvci5cbiAgICAgICAgcmV0dXJuIGhleFByZWZpeGVkO1xuICAgIH1cbiAgICByZXR1cm4gZXRoZXJldW1qc191dGlsXzEudG9DaGVja3N1bUFkZHJlc3MoaGV4UHJlZml4ZWQpO1xufVxuZXhwb3J0cy50b0NoZWNrc3VtSGV4QWRkcmVzcyA9IHRvQ2hlY2tzdW1IZXhBZGRyZXNzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgaW5wdXQgaXMgYSBoZXggYWRkcmVzcy4gVGhpcyB1dGlsaXR5IG1ldGhvZCBpcyBhIHRoaW5cbiAqIHdyYXBwZXIgYXJvdW5kIGV0aGVyZXVtanMtdXRpbC5pc1ZhbGlkQWRkcmVzcywgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaXRcbiAqIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHdoZW4gcHJvdmlkZWQgdmFsdWVzIHRoYXQgYXJlIG5vdCBoZXggc3RyaW5ncy4gSW5cbiAqIGFkZGl0aW9uLCBhbmQgYnkgZGVmYXVsdCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdHJ1ZSBmb3IgaGV4IHN0cmluZ3MgdGhhdFxuICogbWVldCB0aGUgbGVuZ3RoIHJlcXVpcmVtZW50IG9mIGEgaGV4IGFkZHJlc3MsIGJ1dCBhcmUgbm90IHByZWZpeGVkIHdpdGggYDB4YFxuICogRmluYWxseSwgaWYgdGhlIG1peGVkQ2FzZVVzZUNoZWNrc3VtIGZsYWcgaXMgdHJ1ZSBhbmQgYSBtaXhlZCBjYXNlIHN0cmluZyBpc1xuICogcHJvdmlkZWQgdGhpcyBtZXRob2Qgd2lsbCB2YWxpZGF0ZSBpdCBoYXMgdGhlIHByb3BlciBjaGVja3N1bSBmb3JtYXR0aW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHBvc3NpYmxlQWRkcmVzcyAtIElucHV0IHBhcmFtZXRlciB0byBjaGVjayBhZ2FpbnN0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBiYWdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWxsb3dOb25QcmVmaXhlZF0gLSBJZiB0cnVlIHdpbGwgZmlyc3QgZW5zdXJlICcweCdcbiAqICBpcyBwcmVwZW5kZWQgdG8gdGhlIHN0cmluZ1xuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHZhbGlkIGhleCBhZGRyZXNzXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIZXhBZGRyZXNzKHBvc3NpYmxlQWRkcmVzcywgeyBhbGxvd05vblByZWZpeGVkID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBjb25zdCBhZGRyZXNzVG9DaGVjayA9IGFsbG93Tm9uUHJlZml4ZWRcbiAgICAgICAgPyBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgocG9zc2libGVBZGRyZXNzKVxuICAgICAgICA6IHBvc3NpYmxlQWRkcmVzcztcbiAgICBpZiAoIWV0aGVyZXVtanNfdXRpbF8xLmlzSGV4U3RyaW5nKGFkZHJlc3NUb0NoZWNrKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzVG9DaGVjayk7XG59XG5leHBvcnRzLmlzVmFsaWRIZXhBZGRyZXNzID0gaXNWYWxpZEhleEFkZHJlc3M7XG4vKipcbiAqIFZhbGlkYXRlcyBhIFRyYW5zYWN0aW9uIG9iamVjdCBmb3IgcmVxdWlyZWQgcHJvcGVydGllcyBhbmQgdGhyb3dzIGluXG4gKiB0aGUgZXZlbnQgb2YgYW55IHZhbGlkYXRpb24gZXJyb3IuXG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gb2JqZWN0IHRvIHZhbGlkYXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uLmZyb20gfHxcbiAgICAgICAgdHlwZW9mIHRyYW5zYWN0aW9uLmZyb20gIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICFpc1ZhbGlkSGV4QWRkcmVzcyh0cmFuc2FjdGlvbi5mcm9tKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJmcm9tXCIgYWRkcmVzczogJHt0cmFuc2FjdGlvbi5mcm9tfSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLmApO1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24udG8gPT09ICcweCcgfHwgdHJhbnNhY3Rpb24udG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24uZGF0YSkge1xuICAgICAgICAgICAgZGVsZXRlIHRyYW5zYWN0aW9uLnRvO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwidG9cIiBhZGRyZXNzOiAke3RyYW5zYWN0aW9uLnRvfSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zYWN0aW9uLnRvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIWlzVmFsaWRIZXhBZGRyZXNzKHRyYW5zYWN0aW9uLnRvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJ0b1wiIGFkZHJlc3M6ICR7dHJhbnNhY3Rpb24udG99IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcuYCk7XG4gICAgfVxuICAgIGlmICh0cmFuc2FjdGlvbi52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdHJhbnNhY3Rpb24udmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcInZhbHVlXCI6ICR7dmFsdWV9IGlzIG5vdCBhIHBvc2l0aXZlIG51bWJlci5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwidmFsdWVcIjogJHt2YWx1ZX0gbnVtYmVyIG11c3QgYmUgZGVub21pbmF0ZWQgaW4gd2VpLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodHJhbnNhY3Rpb24udmFsdWUsIDEwKTtcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IE51bWJlci5pc0Zpbml0ZShpbnRWYWx1ZSkgJiZcbiAgICAgICAgICAgICFOdW1iZXIuaXNOYU4oaW50VmFsdWUpICYmXG4gICAgICAgICAgICAhaXNOYU4oTnVtYmVyKHZhbHVlKSkgJiZcbiAgICAgICAgICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKGludFZhbHVlKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJ2YWx1ZVwiOiAke3ZhbHVlfSBudW1iZXIgbXVzdCBiZSBhIHZhbGlkIG51bWJlci5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUcmFuc2FjdGlvbiA9IHZhbGlkYXRlVHJhbnNhY3Rpb247XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgY29udmVydHMgcmF3bWVzc2FnZURhdGEgYnVmZmVyIGRhdGEgdG8gYSBoZXgsIG9yIGp1c3QgcmV0dXJucyB0aGUgZGF0YSBpZlxuICogaXQgaXMgYWxyZWFkeSBmb3JtYXR0ZWQgYXMgYSBoZXguXG4gKlxuICogQHBhcmFtIGRhdGEgLSBUaGUgYnVmZmVyIGRhdGEgdG8gY29udmVydCB0byBhIGhleFxuICogQHJldHVybnMgLSBBIGhleCBzdHJpbmcgY29udmVyc2lvbiBvZiB0aGUgYnVmZmVyIGRhdGFcbiAqXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1lc3NhZ2VEYXRhKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzdHJpcHBlZCA9IGV0aGpzX3V0aWxfMS5zdHJpcEhleFByZWZpeChkYXRhKTtcbiAgICAgICAgaWYgKHN0cmlwcGVkLm1hdGNoKGhleFJlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChzdHJpcHBlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB9XG4gICAgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLmJ1ZmZlclRvSGV4KEJ1ZmZlci5mcm9tKGRhdGEsICd1dGY4JykpO1xufVxuZXhwb3J0cy5ub3JtYWxpemVNZXNzYWdlRGF0YSA9IG5vcm1hbGl6ZU1lc3NhZ2VEYXRhO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBQZXJzb25hbE1lc3NhZ2VQYXJhbXMgYW5kIE1lc3NhZ2VQYXJhbXMgb2JqZWN0cyBmb3IgcmVxdWlyZWQgcHJvcGVydGllcyBhbmQgdGhyb3dzIGluXG4gKiB0aGUgZXZlbnQgb2YgYW55IHZhbGlkYXRpb24gZXJyb3IuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VEYXRhIC0gUGVyc29uYWxNZXNzYWdlUGFyYW1zIG9iamVjdCB0byB2YWxpZGF0ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ25NZXNzYWdlRGF0YShtZXNzYWdlRGF0YSkge1xuICAgIGNvbnN0IHsgZnJvbSwgZGF0YSB9ID0gbWVzc2FnZURhdGE7XG4gICAgaWYgKCFmcm9tIHx8IHR5cGVvZiBmcm9tICE9PSAnc3RyaW5nJyB8fCAhaXNWYWxpZEhleEFkZHJlc3MoZnJvbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwiZnJvbVwiIGFkZHJlc3M6ICR7ZnJvbX0gbXVzdCBiZSBhIHZhbGlkIHN0cmluZy5gKTtcbiAgICB9XG4gICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSBcImRhdGFcIjogJHtkYXRhfSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLmApO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVTaWduTWVzc2FnZURhdGEgPSB2YWxpZGF0ZVNpZ25NZXNzYWdlRGF0YTtcbi8qKlxuICogVmFsaWRhdGVzIGEgVHlwZWRNZXNzYWdlUGFyYW1zIG9iamVjdCBmb3IgcmVxdWlyZWQgcHJvcGVydGllcyBhbmQgdGhyb3dzIGluXG4gKiB0aGUgZXZlbnQgb2YgYW55IHZhbGlkYXRpb24gZXJyb3IgZm9yIGV0aF9zaWduVHlwZWRNZXNzYWdlX1YxLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlRGF0YSAtIFR5cGVkTWVzc2FnZVBhcmFtcyBvYmplY3QgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSBhY3RpdmVDaGFpbklkIC0gQWN0aXZlIGNoYWluIGlkXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMShtZXNzYWdlRGF0YSkge1xuICAgIGlmICghbWVzc2FnZURhdGEuZnJvbSB8fFxuICAgICAgICB0eXBlb2YgbWVzc2FnZURhdGEuZnJvbSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIWlzVmFsaWRIZXhBZGRyZXNzKG1lc3NhZ2VEYXRhLmZyb20pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcImZyb21cIiBhZGRyZXNzOiAke21lc3NhZ2VEYXRhLmZyb219IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcuYCk7XG4gICAgfVxuICAgIGlmICghbWVzc2FnZURhdGEuZGF0YSB8fCAhQXJyYXkuaXNBcnJheShtZXNzYWdlRGF0YS5kYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSBcImRhdGFcIjogJHttZXNzYWdlRGF0YS5kYXRhfSBtdXN0IGJlIGEgdmFsaWQgYXJyYXkuYCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHR5cGVkU2lnbmF0dXJlSGFzaCB3aWxsIHRocm93IGlmIHRoZSBkYXRhIGlzIGludmFsaWQuXG4gICAgICAgIGV0aF9zaWdfdXRpbF8xLnR5cGVkU2lnbmF0dXJlSGFzaChtZXNzYWdlRGF0YS5kYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBFSVA3MTIgdHlwZWQgZGF0YS5gKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMSA9IHZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMTtcbi8qKlxuICogVmFsaWRhdGVzIGEgVHlwZWRNZXNzYWdlUGFyYW1zIG9iamVjdCBmb3IgcmVxdWlyZWQgcHJvcGVydGllcyBhbmQgdGhyb3dzIGluXG4gKiB0aGUgZXZlbnQgb2YgYW55IHZhbGlkYXRpb24gZXJyb3IgZm9yIGV0aF9zaWduVHlwZWRNZXNzYWdlX1YzLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlRGF0YSAtIFR5cGVkTWVzc2FnZVBhcmFtcyBvYmplY3QgdG8gdmFsaWRhdGVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYzKG1lc3NhZ2VEYXRhKSB7XG4gICAgaWYgKCFtZXNzYWdlRGF0YS5mcm9tIHx8XG4gICAgICAgIHR5cGVvZiBtZXNzYWdlRGF0YS5mcm9tICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhaXNWYWxpZEhleEFkZHJlc3MobWVzc2FnZURhdGEuZnJvbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwiZnJvbVwiIGFkZHJlc3M6ICR7bWVzc2FnZURhdGEuZnJvbX0gbXVzdCBiZSBhIHZhbGlkIHN0cmluZy5gKTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlRGF0YS5kYXRhIHx8IHR5cGVvZiBtZXNzYWdlRGF0YS5kYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSBcImRhdGFcIjogJHttZXNzYWdlRGF0YS5kYXRhfSBtdXN0IGJlIGEgdmFsaWQgYXJyYXkuYCk7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG1lc3NhZ2VEYXRhLmRhdGEpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBwYXNzZWQgYXMgYSB2YWxpZCBKU09OIHN0cmluZy4nKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGlvbiA9IGpzb25zY2hlbWFfMS52YWxpZGF0ZShkYXRhLCBldGhfc2lnX3V0aWxfMS5UWVBFRF9NRVNTQUdFX1NDSEVNQSk7XG4gICAgaWYgKHZhbGlkYXRpb24uZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgY29uZm9ybSB0byBFSVAtNzEyIHNjaGVtYS4gU2VlIGh0dHBzOi8vZ2l0LmlvL2ZOdGN4LicpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYzID0gdmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBFUkMyMCB0b2tlbiB0byBiZSBhZGRlZCB3aXRoIEVJUDc0Ny5cbiAqXG4gKiBAcGFyYW0gdG9rZW4gLSBUb2tlbiBvYmplY3QgdG8gdmFsaWRhdGVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVUb2tlblRvV2F0Y2godG9rZW4pIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIHN5bWJvbCwgZGVjaW1hbHMgfSA9IHRva2VuO1xuICAgIGlmICghYWRkcmVzcyB8fCAhc3ltYm9sIHx8IHR5cGVvZiBkZWNpbWFscyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYE11c3Qgc3BlY2lmeSBhZGRyZXNzLCBzeW1ib2wsIGFuZCBkZWNpbWFscy5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzeW1ib2wgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKGBJbnZhbGlkIHN5bWJvbDogbm90IGEgc3RyaW5nLmApO1xuICAgIH1cbiAgICBpZiAoc3ltYm9sLmxlbmd0aCA+IDExKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKGBJbnZhbGlkIHN5bWJvbCBcIiR7c3ltYm9sfVwiOiBsb25nZXIgdGhhbiAxMSBjaGFyYWN0ZXJzLmApO1xuICAgIH1cbiAgICBjb25zdCBudW1EZWNpbWFscyA9IHBhcnNlSW50KGRlY2ltYWxzLCAxMCk7XG4gICAgaWYgKGlzTmFOKG51bURlY2ltYWxzKSB8fCBudW1EZWNpbWFscyA+IDM2IHx8IG51bURlY2ltYWxzIDwgMCkge1xuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgSW52YWxpZCBkZWNpbWFscyBcIiR7ZGVjaW1hbHN9XCI6IG11c3QgYmUgMCA8PSAzNi5gKTtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkSGV4QWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgSW52YWxpZCBhZGRyZXNzIFwiJHthZGRyZXNzfVwiLmApO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUb2tlblRvV2F0Y2ggPSB2YWxpZGF0ZVRva2VuVG9XYXRjaDtcbi8qKlxuICogUmV0dXJucyB3ZXRoZXIgdGhlIGdpdmVuIGNvZGUgY29ycmVzcG9uZHMgdG8gYSBzbWFydCBjb250cmFjdFxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gQ29ycmVzcG9uZGluZyBjb2RlIHRvIHJldmlld1xuICovXG5mdW5jdGlvbiBpc1NtYXJ0Q29udHJhY3RDb2RlKGNvZGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBHZXRoIHdpbGwgcmV0dXJuICcweCcsIGFuZCBnYW5hY2hlLWNvcmUgdjIuMi4xIHdpbGwgcmV0dXJuICcweDAnXG4gICAgY29uc3Qgc21hcnRDb250cmFjdENvZGUgPSBjb2RlICE9PSAnMHgnICYmIGNvZGUgIT09ICcweDAnO1xuICAgIHJldHVybiBzbWFydENvbnRyYWN0Q29kZTtcbn1cbmV4cG9ydHMuaXNTbWFydENvbnRyYWN0Q29kZSA9IGlzU21hcnRDb250cmFjdENvZGU7XG4vKipcbiAqIEV4ZWN1dGUgZmV0Y2ggYW5kIHZlcmlmeSB0aGF0IHRoZSByZXNwb25zZSB3YXMgc3VjY2Vzc2Z1bFxuICpcbiAqIEBwYXJhbSByZXF1ZXN0IC0gUmVxdWVzdCBpbmZvcm1hdGlvblxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBmZXRjaCByZXNwb25zZVxuICovXG5mdW5jdGlvbiBzdWNjZXNzZnVsRmV0Y2gocmVxdWVzdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2gocmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmV0Y2ggZmFpbGVkIHdpdGggc3RhdHVzICcke3Jlc3BvbnNlLnN0YXR1c30nIGZvciByZXF1ZXN0ICcke3JlcXVlc3R9J2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuc3VjY2Vzc2Z1bEZldGNoID0gc3VjY2Vzc2Z1bEZldGNoO1xuLyoqXG4gKiBFeGVjdXRlIGZldGNoIGFuZCByZXR1cm4gb2JqZWN0IHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHJlcXVlc3QgLSBSZXF1ZXN0IGluZm9ybWF0aW9uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnNcbiAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHJlc3VsdCBvYmplY3Qgb2YgZmV0Y2hcbiAqL1xuZnVuY3Rpb24gaGFuZGxlRmV0Y2gocmVxdWVzdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgc3VjY2Vzc2Z1bEZldGNoKHJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBvYmplY3QgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG59XG5leHBvcnRzLmhhbmRsZUZldGNoID0gaGFuZGxlRmV0Y2g7XG4vKipcbiAqIEZldGNoIHRoYXQgZmFpbHMgYWZ0ZXIgdGltZW91dFxuICpcbiAqIEBwYXJhbSB1cmwgLSBVcmwgdG8gZmV0Y2hcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBzZW5kIHdpdGggdGhlIHJlcXVlc3RcbiAqIEBwYXJhbSB0aW1lb3V0IC0gVGltZW91dCB0byBmYWlsIHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRoZSByZXF1ZXN0XG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXRGZXRjaCh1cmwsIG9wdGlvbnMsIHRpbWVvdXQgPSA1MDApIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIHN1Y2Nlc3NmdWxGZXRjaCh1cmwsIG9wdGlvbnMpLFxuICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigndGltZW91dCcpKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpKSxcbiAgICAgICAgXSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnRpbWVvdXRGZXRjaCA9IHRpbWVvdXRGZXRjaDtcbi8qKlxuICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gRU5TIG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuc05hbWUgLSBUaGUgRU5TIG5hbWVcbiAqXG4gKiBAcmV0dXJucyAtIHRoZSBub3JtYWxpemVkIEVOUyBuYW1lIHN0cmluZ1xuICovXG5mdW5jdGlvbiBub3JtYWxpemVFbnNOYW1lKGVuc05hbWUpIHtcbiAgICBpZiAoZW5zTmFtZSAmJiB0eXBlb2YgZW5zTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBldGhfZW5zX25hbWVoYXNoXzEuZGVmYXVsdC5ub3JtYWxpemUoZW5zTmFtZS50cmltKCkpO1xuICAgICAgICAgICAgLy8gdGhpcyByZWdleCBpcyBvbmx5IHN1ZmZpY2llbnQgd2l0aCB0aGUgYWJvdmUgY2FsbCB0byBlbnNOYW1laGFzaC5ub3JtYWxpemVcbiAgICAgICAgICAgIC8vIFRPRE86IGNoYW5nZSA3IGluIHJlZ2V4IHRvIDMgd2hlbiBzaG9ydGVyIEVOUyBkb21haW5zIGFyZSBsaXZlXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZC5tYXRjaCgvXigoW1xcd1xcZC1dKylcXC4pKltcXHdcXGQtXXs3LH1cXC4oZXRofHRlc3QpJC91KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLm5vcm1hbGl6ZUVuc05hbWUgPSBub3JtYWxpemVFbnNOYW1lO1xuLyoqXG4gKiBXcmFwcGVyIG1ldGhvZCB0byBoYW5kbGUgRXRoUXVlcnkgcmVxdWVzdHNcbiAqXG4gKiBAcGFyYW0gZXRoUXVlcnkgLSBFdGhRdWVyeSBvYmplY3QgaW5pdGlhbGl6ZWQgd2l0aCBhIHByb3ZpZGVyXG4gKiBAcGFyYW0gbWV0aG9kIC0gTWV0aG9kIHRvIHJlcXVlc3RcbiAqIEBwYXJhbSBhcmdzIC0gQXJndW1lbnRzIHRvIHNlbmRcbiAqXG4gKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRoZSByZXF1ZXN0XG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5KGV0aFF1ZXJ5LCBtZXRob2QsIGFyZ3MgPSBbXSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGV0aFF1ZXJ5W21ldGhvZF0oLi4uYXJncywgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucXVlcnkgPSBxdWVyeTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdHJhbnNhY3Rpb24gaXMgRUlQLTE1NTkgYnkgY2hlY2tpbmcgZm9yIHRoZSBleGlzdGVuY2Ugb2ZcbiAqIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgd2l0aGluIGl0cyBwYXJhbWV0ZXJzXG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gb2JqZWN0IHRvIGFkZFxuICogQHJldHVybnMgLSBCb29sZWFuIHRoYXQgaXMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgRUlQLTE1NTkgKGhhcyBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzKSwgb3RoZXJ3aXNlIHJldHVybnMgZmFsc2VcbiAqL1xuY29uc3QgaXNFSVAxNTU5VHJhbnNhY3Rpb24gPSAodHJhbnNhY3Rpb24pID0+IHtcbiAgICBjb25zdCBoYXNPd25Qcm9wID0gKG9iaiwga2V5KSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICAgIHJldHVybiAoaGFzT3duUHJvcCh0cmFuc2FjdGlvbiwgJ21heEZlZVBlckdhcycpICYmXG4gICAgICAgIGhhc093blByb3AodHJhbnNhY3Rpb24sICdtYXhQcmlvcml0eUZlZVBlckdhcycpKTtcbn07XG5leHBvcnRzLmlzRUlQMTU1OVRyYW5zYWN0aW9uID0gaXNFSVAxNTU5VHJhbnNhY3Rpb247XG5jb25zdCBjb252ZXJ0UHJpY2VUb0RlY2ltYWwgPSAodmFsdWUpID0+IHBhcnNlSW50KHZhbHVlID09PSB1bmRlZmluZWQgPyAnMHgwJyA6IHZhbHVlLCAxNik7XG5leHBvcnRzLmNvbnZlcnRQcmljZVRvRGVjaW1hbCA9IGNvbnZlcnRQcmljZVRvRGVjaW1hbDtcbmNvbnN0IGdldEluY3JlYXNlZFByaWNlSGV4ID0gKHZhbHVlLCByYXRlKSA9PiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgoYCR7cGFyc2VJbnQoYCR7dmFsdWUgKiByYXRlfWAsIDEwKS50b1N0cmluZygxNil9YCk7XG5leHBvcnRzLmdldEluY3JlYXNlZFByaWNlSGV4ID0gZ2V0SW5jcmVhc2VkUHJpY2VIZXg7XG5jb25zdCBnZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZyA9ICh2YWx1ZSwgcmF0ZSkgPT4ge1xuICAgIHJldHVybiBleHBvcnRzLmdldEluY3JlYXNlZFByaWNlSGV4KGV4cG9ydHMuY29udmVydFByaWNlVG9EZWNpbWFsKHZhbHVlKSwgcmF0ZSk7XG59O1xuZXhwb3J0cy5nZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZyA9IGdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nO1xuY29uc3QgdmFsaWRhdGVHYXNWYWx1ZXMgPSAoZ2FzVmFsdWVzKSA9PiB7XG4gICAgT2JqZWN0LmtleXMoZ2FzVmFsdWVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnYXNWYWx1ZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIWV0aGVyZXVtanNfdXRpbF8xLmlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgaGV4IHN0cmluZyBmb3IgJHtrZXl9IGJ1dCByZWNlaXZlZDogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmV4cG9ydHMudmFsaWRhdGVHYXNWYWx1ZXMgPSB2YWxpZGF0ZUdhc1ZhbHVlcztcbmNvbnN0IGlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcyA9IChnYXNWYWx1ZXMpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoKF9hID0gZ2FzVmFsdWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF4RmVlUGVyR2FzKSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICgoX2IgPSBnYXNWYWx1ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXhQcmlvcml0eUZlZVBlckdhcykgIT09IHVuZGVmaW5lZDtcbn07XG5leHBvcnRzLmlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcyA9IGlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcztcbmNvbnN0IGlzR2FzUHJpY2VWYWx1ZSA9IChnYXNWYWx1ZXMpID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IGdhc1ZhbHVlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdhc1ByaWNlKSAhPT0gdW5kZWZpbmVkOyB9O1xuZXhwb3J0cy5pc0dhc1ByaWNlVmFsdWUgPSBpc0dhc1ByaWNlVmFsdWU7XG5mdW5jdGlvbiB2YWxpZGF0ZU1pbmltdW1JbmNyZWFzZShwcm9wb3NlZCwgbWluKSB7XG4gICAgY29uc3QgcHJvcG9zZWREZWNpbWFsID0gZXhwb3J0cy5jb252ZXJ0UHJpY2VUb0RlY2ltYWwocHJvcG9zZWQpO1xuICAgIGNvbnN0IG1pbkRlY2ltYWwgPSBleHBvcnRzLmNvbnZlcnRQcmljZVRvRGVjaW1hbChtaW4pO1xuICAgIGlmIChwcm9wb3NlZERlY2ltYWwgPj0gbWluRGVjaW1hbCkge1xuICAgICAgICByZXR1cm4gcHJvcG9zZWQ7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yTXNnID0gYFRoZSBwcm9wb3NlZCB2YWx1ZTogJHtwcm9wb3NlZERlY2ltYWx9IHNob3VsZCBtZWV0IG9yIGV4Y2VlZCB0aGUgbWluaW11bSB2YWx1ZTogJHttaW5EZWNpbWFsfWA7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVNaW5pbXVtSW5jcmVhc2UgPSB2YWxpZGF0ZU1pbmltdW1JbmNyZWFzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVG9rZW5MaXN0Q29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IGNvbnRyYWN0X21ldGFkYXRhXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9jb250cmFjdC1tZXRhZGF0YVwiKSk7XG5jb25zdCBhc3luY19tdXRleF8xID0gcmVxdWlyZShcImFzeW5jLW11dGV4XCIpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1uYW1lZC1hcy1kZWZhdWx0XG5jb25zdCBhYm9ydF9jb250cm9sbGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFib3J0LWNvbnRyb2xsZXJcIikpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJWMl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyVjJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IHRva2VuX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9hcGlzL3Rva2VuLXNlcnZpY2VcIik7XG5jb25zdCBERUZBVUxUX0lOVEVSVkFMID0gNjAgKiA2MCAqIDEwMDA7XG5jb25zdCBERUZBVUxUX1RIUkVTSE9MRCA9IDYwICogMzAgKiAxMDAwO1xuY29uc3QgbmFtZSA9ICdUb2tlbkxpc3RDb250cm9sbGVyJztcbmNvbnN0IG1ldGFkYXRhID0ge1xuICAgIHRva2VuTGlzdDogeyBwZXJzaXN0OiB0cnVlLCBhbm9ueW1vdXM6IHRydWUgfSxcbiAgICB0b2tlbnNDaGFpbnNDYWNoZTogeyBwZXJzaXN0OiB0cnVlLCBhbm9ueW1vdXM6IHRydWUgfSxcbn07XG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gICAgdG9rZW5MaXN0OiB7fSxcbiAgICB0b2tlbnNDaGFpbnNDYWNoZToge30sXG59O1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgcGFzc2l2ZWx5IHBvbGxzIG9uIGEgc2V0IGludGVydmFsIGZvciB0aGUgbGlzdCBvZiB0b2tlbnMgZnJvbSBtZXRhc3dhcHMgYXBpXG4gKi9cbmNsYXNzIFRva2VuTGlzdENvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlclYyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8vIHByaXZhdGUgYWJvcnRTaWduYWw6IEFib3J0U2lnbmFsO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUb2tlbkxpc3RDb250cm9sbGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbCAtIFRoZSBwb2xsaW5nIGludGVydmFsLCBpbiBtaWxsaXNlY29uZHNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXNzZW5nZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgbWVzc2FnaW5nIHN5c3RlbVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBjaGFpbklkLCB1c2VTdGF0aWNUb2tlbkxpc3QsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UsIGludGVydmFsID0gREVGQVVMVF9JTlRFUlZBTCwgY2FjaGVSZWZyZXNoVGhyZXNob2xkID0gREVGQVVMVF9USFJFU0hPTEQsIG1lc3Nlbmdlciwgc3RhdGUsIH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgbWVzc2VuZ2VyLFxuICAgICAgICAgICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFN0YXRlKSwgc3RhdGUpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxEZWxheSA9IGludGVydmFsO1xuICAgICAgICB0aGlzLmNhY2hlUmVmcmVzaFRocmVzaG9sZCA9IGNhY2hlUmVmcmVzaFRocmVzaG9sZDtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgdGhpcy51c2VTdGF0aWNUb2tlbkxpc3QgPSB1c2VTdGF0aWNUb2tlbkxpc3Q7XG4gICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IGFib3J0X2NvbnRyb2xsZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKChuZXR3b3JrU3RhdGUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYWluSWQgIT09IG5ldHdvcmtTdGF0ZS5wcm92aWRlci5jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IG5ldyBhYm9ydF9jb250cm9sbGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhaW5JZCA9IG5ldHdvcmtTdGF0ZS5wcm92aWRlci5jaGFpbklkO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucmVzdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSgocHJlZmVyZW5jZXNTdGF0ZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlU3RhdGljVG9rZW5MaXN0ICE9PSBwcmVmZXJlbmNlc1N0YXRlLnVzZVN0YXRpY1Rva2VuTGlzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgYWJvcnRfY29udHJvbGxlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZVN0YXRpY1Rva2VuTGlzdCA9IHByZWZlcmVuY2VzU3RhdGUudXNlU3RhdGljVG9rZW5MaXN0O1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucmVzdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHBvbGxpbmcgZm9yIHRoZSB0b2tlbiBsaXN0XG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnN0YXJ0UG9sbGluZygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdGFydCBwb2xsaW5nIGZvciB0aGUgdG9rZW4gbGlzdFxuICAgICAqL1xuICAgIHJlc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnN0YXJ0UG9sbGluZygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCBwb2xsaW5nIGZvciB0aGUgdG9rZW4gbGlzdFxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0byBkaXNjYXJkIHRoaXMgY29udHJvbGxlci5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RvcHMgYW55IGFjdGl2ZSBwb2xsaW5nLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgIH1cbiAgICBzdG9wUG9sbGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIG5ldyBwb2xsaW5nIGludGVydmFsXG4gICAgICovXG4gICAgc3RhcnRQb2xsaW5nKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gdGhpcy5mZXRjaFRva2VuTGlzdCgpKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiB0aGlzLmZldGNoVG9rZW5MaXN0KCkpO1xuICAgICAgICAgICAgfSksIHRoaXMuaW50ZXJ2YWxEZWxheSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGluZyB0b2tlbiBsaXN0XG4gICAgICovXG4gICAgZmV0Y2hUb2tlbkxpc3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VTdGF0aWNUb2tlbkxpc3QpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmZldGNoRnJvbVN0YXRpY1Rva2VuTGlzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5mZXRjaEZyb21EeW5hbWljVG9rZW5MaXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGluZyB0b2tlbiBsaXN0IGZyb20gdGhlIGNvbnRyYWN0LW1ldGFkYXRhIGFzIGEgZmFsbGJhY2tcbiAgICAgKi9cbiAgICBmZXRjaEZyb21TdGF0aWNUb2tlbkxpc3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkxpc3QgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW5BZGRyZXNzIGluIGNvbnRyYWN0X21ldGFkYXRhXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9hID0gY29udHJhY3RfbWV0YWRhdGFfMS5kZWZhdWx0W3Rva2VuQWRkcmVzc10sIHsgZXJjMjAsIGxvZ286IGZpbGVQYXRoIH0gPSBfYSwgdG9rZW4gPSBfX3Jlc3QoX2EsIFtcImVyYzIwXCIsIFwibG9nb1wiXSk7XG4gICAgICAgICAgICAgICAgaWYgKGVyYzIwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuTGlzdFt0b2tlbkFkZHJlc3NdID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0b2tlbiksIHsgYWRkcmVzczogdG9rZW5BZGRyZXNzLCBpY29uVXJsOiBmaWxlUGF0aCwgb2NjdXJyZW5jZXM6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zQ2hhaW5zQ2FjaGU6IHt9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoaW5nIHRva2VuIGxpc3QgZnJvbSB0aGUgVG9rZW4gU2VydmljZSBBUElcbiAgICAgKi9cbiAgICBmZXRjaEZyb21EeW5hbWljVG9rZW5MaXN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkVG9rZW5zID0geWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gdGhpcy5mZXRjaEZyb21DYWNoZSgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBfYSA9IHRoaXMuc3RhdGUsIHsgdG9rZW5zQ2hhaW5zQ2FjaGUgfSA9IF9hLCB0b2tlbnNEYXRhID0gX19yZXN0KF9hLCBbXCJ0b2tlbnNDaGFpbnNDYWNoZVwiXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5MaXN0ID0ge307XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIGNhY2hlZFRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5MaXN0W3Rva2VuLmFkZHJlc3NdID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2Vuc0Zyb21BUEkgPSB5aWVsZCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiB0b2tlbl9zZXJ2aWNlXzEuZmV0Y2hUb2tlbkxpc3QodGhpcy5jaGFpbklkLCB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWwpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0b2tlbnNGcm9tQVBJKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWNrdXBUb2tlbkxpc3QgPSB0b2tlbnNDaGFpbnNDYWNoZVt0aGlzLmNoYWluSWRdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0b2tlbnNDaGFpbnNDYWNoZVt0aGlzLmNoYWluSWRdLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBiYWNrdXBUb2tlbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkxpc3RbdG9rZW4uYWRkcmVzc10gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0b2tlbnNEYXRhKSwgeyB0b2tlbkxpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vuc0NoYWluc0NhY2hlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZmlsdGVyaW5nIG91dCB0b2tlbnMgd2l0aCBsZXNzIHRoYW4gMiBvY2N1cnJlbmNlc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFRva2VuTGlzdCA9IHRva2Vuc0Zyb21BUEkuZmlsdGVyKCh0b2tlbikgPT4gdG9rZW4ub2NjdXJyZW5jZXMgJiYgdG9rZW4ub2NjdXJyZW5jZXMgPj0gMik7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92aW5nIHRoZSB0b2tlbnMgd2l0aCBzeW1ib2wgY29uZmxpY3RzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbHNMaXN0ID0gZmlsdGVyZWRUb2tlbkxpc3QubWFwKCh0b2tlbikgPT4gdG9rZW4uc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHVwbGljYXRlU3ltYm9scyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm5ldyBTZXQoc3ltYm9sc0xpc3QuZmlsdGVyKChzeW1ib2wsIGluZGV4KSA9PiBzeW1ib2xzTGlzdC5pbmRleE9mKHN5bWJvbCkgIT09IGluZGV4KSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVRva2VuTGlzdCA9IGZpbHRlcmVkVG9rZW5MaXN0LmZpbHRlcigodG9rZW4pID0+ICFkdXBsaWNhdGVTeW1ib2xzLmluY2x1ZGVzKHRva2VuLnN5bWJvbCkpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHVuaXF1ZVRva2VuTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5MaXN0W3Rva2VuLmFkZHJlc3NdID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFRva2Vuc0NoYWluc0NhY2hlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0b2tlbnNDaGFpbnNDYWNoZSksIHsgW3RoaXMuY2hhaW5JZF06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC52YWx1ZXModG9rZW5MaXN0KSxcbiAgICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRva2Vuc0RhdGEpLCB7IHRva2VuTGlzdCwgdG9rZW5zQ2hhaW5zQ2FjaGU6IHVwZGF0ZWRUb2tlbnNDaGFpbnNDYWNoZSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIENhY2hlIHRpbWVzdGFtcCBpcyB2YWxpZCxcbiAgICAgKiAgaWYgeWVzIGRhdGEgaW4gY2FjaGUgd2lsbCBiZSByZXR1cm5lZFxuICAgICAqICBvdGhlcndpc2UgbnVsbCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyBpbnRvIFRva2VuTGlzdFRva2VuW10gb3IgbnVsbFxuICAgICAqL1xuICAgIGZldGNoRnJvbUNhY2hlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB0b2tlbnNDaGFpbnNDYWNoZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFDYWNoZSA9IHRva2Vuc0NoYWluc0NhY2hlW3RoaXMuY2hhaW5JZF07XG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKChkYXRhQ2FjaGUgPT09IG51bGwgfHwgZGF0YUNhY2hlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhQ2FjaGUuZGF0YSkgJiZcbiAgICAgICAgICAgICAgICBub3cgLSAoZGF0YUNhY2hlID09PSBudWxsIHx8IGRhdGFDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YUNhY2hlLnRpbWVzdGFtcCkgPCB0aGlzLmNhY2hlUmVmcmVzaFRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhQ2FjaGUuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggbWV0YWRhdGEgZm9yIGEgdG9rZW4gd2hvc2UgYWRkcmVzcyBpcyBzZW5kIHRvIHRoZSBBUElcbiAgICAgKiBAcGFyYW0gdG9rZW5BZGRyZXNzXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIFRva2VuIE1ldGFkYXRhXG4gICAgICovXG4gICAgZmV0Y2hUb2tlbk1ldGFkYXRhKHRva2VuQWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSAoeWllbGQgdG9rZW5fc2VydmljZV8xLmZldGNoVG9rZW5NZXRhZGF0YSh0aGlzLmNoYWluSWQsIHRva2VuQWRkcmVzcywgdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ub2tlbkxpc3RDb250cm9sbGVyID0gVG9rZW5MaXN0Q29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFRva2VuTGlzdENvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub2tlbkxpc3RDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRva2Vuc0NvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBjb250cmFjdF9tZXRhZGF0YV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbWV0YW1hc2svY29udHJhY3QtbWV0YWRhdGFcIikpO1xuY29uc3QgaHVtYW5fc3RhbmRhcmRfY29sbGVjdGlibGVfYWJpXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImh1bWFuLXN0YW5kYXJkLWNvbGxlY3RpYmxlLWFiaVwiKSk7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbmNvbnN0IGFzeW5jX211dGV4XzEgPSByZXF1aXJlKFwiYXN5bmMtbXV0ZXhcIik7XG5jb25zdCBldGhlcnNfMSA9IHJlcXVpcmUoXCJldGhlcnNcIik7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5jb25zdCBFUkM3MjFfSU5URVJGQUNFX0lEID0gJzB4ODBhYzU4Y2QnO1xudmFyIFN1Z2dlc3RlZEFzc2V0U3RhdHVzO1xuKGZ1bmN0aW9uIChTdWdnZXN0ZWRBc3NldFN0YXR1cykge1xuICAgIFN1Z2dlc3RlZEFzc2V0U3RhdHVzW1wiYWNjZXB0ZWRcIl0gPSBcImFjY2VwdGVkXCI7XG4gICAgU3VnZ2VzdGVkQXNzZXRTdGF0dXNbXCJmYWlsZWRcIl0gPSBcImZhaWxlZFwiO1xuICAgIFN1Z2dlc3RlZEFzc2V0U3RhdHVzW1wicGVuZGluZ1wiXSA9IFwicGVuZGluZ1wiO1xuICAgIFN1Z2dlc3RlZEFzc2V0U3RhdHVzW1wicmVqZWN0ZWRcIl0gPSBcInJlamVjdGVkXCI7XG59KShTdWdnZXN0ZWRBc3NldFN0YXR1cyB8fCAoU3VnZ2VzdGVkQXNzZXRTdGF0dXMgPSB7fSkpO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgc3RvcmVzIGFzc2V0cyBhbmQgZXhwb3NlcyBjb252ZW5pZW5jZSBtZXRob2RzXG4gKi9cbmNsYXNzIFRva2Vuc0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVG9rZW5zQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gcHJlZmVyZW5jZSBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbk5ldHdvcmtTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBuZXR3b3JrIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlc1xuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBjb25maWcsIHN0YXRlLCB9KSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICB0aGlzLm11dGV4ID0gbmV3IGFzeW5jX211dGV4XzEuTXV0ZXgoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50RW1pdHRlciBpbnN0YW5jZSB1c2VkIHRvIGxpc3RlbiB0byBzcGVjaWZpYyBFSVA3NDcgZXZlbnRzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmh1YiA9IG5ldyBldmVudHNfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnVG9rZW5zQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IE9iamVjdC5hc3NpZ24oeyBuZXR3b3JrVHlwZTogY29uc3RhbnRzXzEuTUFJTk5FVCwgc2VsZWN0ZWRBZGRyZXNzOiAnJywgY2hhaW5JZDogJycsIHByb3ZpZGVyOiB1bmRlZmluZWQgfSwgY29uZmlnKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSBPYmplY3QuYXNzaWduKHsgYWxsVG9rZW5zOiB7fSwgYWxsSWdub3JlZFRva2Vuczoge30sIGlnbm9yZWRUb2tlbnM6IFtdLCBzdWdnZXN0ZWRBc3NldHM6IFtdLCB0b2tlbnM6IFtdIH0sIHN0YXRlKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSgoeyBzZWxlY3RlZEFkZHJlc3MgfSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHsgYWxsVG9rZW5zLCBhbGxJZ25vcmVkVG9rZW5zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHsgc2VsZWN0ZWRBZGRyZXNzIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHRva2VuczogKChfYSA9IGFsbFRva2Vuc1tjaGFpbklkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3NlbGVjdGVkQWRkcmVzc10pIHx8IFtdLFxuICAgICAgICAgICAgICAgIGlnbm9yZWRUb2tlbnM6ICgoX2IgPSBhbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Jbc2VsZWN0ZWRBZGRyZXNzXSkgfHwgW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKCh7IHByb3ZpZGVyIH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCB7IGFsbFRva2VucywgYWxsSWdub3JlZFRva2VucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gcHJvdmlkZXI7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IGNoYWluSWQgfSk7XG4gICAgICAgICAgICB0aGlzLmV0aGVyc1Byb3ZpZGVyID0gdGhpcy5faW5zdGFudGlhdGVOZXdFdGhlcnNQcm92aWRlcigpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHRva2VuczogKChfYSA9IGFsbFRva2Vuc1tjaGFpbklkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3NlbGVjdGVkQWRkcmVzc10pIHx8IFtdLFxuICAgICAgICAgICAgICAgIGlnbm9yZWRUb2tlbnM6ICgoX2IgPSBhbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Jbc2VsZWN0ZWRBZGRyZXNzXSkgfHwgW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZhaWxTdWdnZXN0ZWRBc3NldChzdWdnZXN0ZWRBc3NldE1ldGEsIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGZhaWxlZFN1Z2dlc3RlZEFzc2V0TWV0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3VnZ2VzdGVkQXNzZXRNZXRhKSwgeyBzdGF0dXM6IFN1Z2dlc3RlZEFzc2V0U3RhdHVzLmZhaWxlZCwgZXJyb3IgfSk7XG4gICAgICAgIHRoaXMuaHViLmVtaXQoYCR7c3VnZ2VzdGVkQXNzZXRNZXRhLmlkfTpmaW5pc2hlZGAsIGZhaWxlZFN1Z2dlc3RlZEFzc2V0TWV0YSk7XG4gICAgfVxuICAgIF9pbnN0YW50aWF0ZU5ld0V0aGVyc1Byb3ZpZGVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBuZXcgZXRoZXJzXzEuZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIoKF9hID0gdGhpcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0b2tlbiB0byB0aGUgc3RvcmVkIHRva2VuIGxpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIHRva2VuIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHN5bWJvbCAtIFN5bWJvbCBvZiB0aGUgdG9rZW5cbiAgICAgKiBAcGFyYW0gZGVjaW1hbHMgLSBOdW1iZXIgb2YgZGVjaW1hbHMgdGhlIHRva2VuIHVzZXNcbiAgICAgKiBAcGFyYW0gaW1hZ2UgLSBJbWFnZSBvZiB0aGUgdG9rZW5cbiAgICAgKiBAcmV0dXJucyAtIEN1cnJlbnQgdG9rZW4gbGlzdFxuICAgICAqL1xuICAgIGFkZFRva2VuKGFkZHJlc3MsIHN5bWJvbCwgZGVjaW1hbHMsIGltYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5zLCBpZ25vcmVkVG9rZW5zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRVJDNzIxID0geWllbGQgdGhpcy5fZGV0ZWN0SXNFUkM3MjEoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RW50cnkgPSB7IGFkZHJlc3MsIHN5bWJvbCwgZGVjaW1hbHMsIGltYWdlLCBpc0VSQzcyMSB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRW50cnkgPSB0b2tlbnMuZmluZCgodG9rZW4pID0+IHRva2VuLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdG9rZW5zLmluZGV4T2YocHJldmlvdXNFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1twcmV2aW91c0luZGV4XSA9IG5ld0VudHJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2gobmV3RW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJZ25vcmVkVG9rZW5zID0gaWdub3JlZFRva2Vucy5maWx0ZXIoKHRva2VuQWRkcmVzcykgPT4gdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBuZXdBbGxUb2tlbnMsIG5ld0FsbElnbm9yZWRUb2tlbnMgfSA9IHRoaXMuX2dldE5ld0FsbFRva2Vuc1N0YXRlKHRva2VucywgbmV3SWdub3JlZFRva2Vucyk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICBhbGxUb2tlbnM6IG5ld0FsbFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBhbGxJZ25vcmVkVG9rZW5zOiBuZXdBbGxJZ25vcmVkVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBpZ25vcmVkVG9rZW5zOiBuZXdJZ25vcmVkVG9rZW5zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGJhdGNoIG9mIHRva2VucyB0byB0aGUgc3RvcmVkIHRva2VuIGxpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbnMgLSBBcnJheSBvZiBUb2tlbnMgdG8gYmUgYWRkZWQgb3IgdXBkYXRlZFxuICAgICAqIEByZXR1cm5zIC0gQ3VycmVudCB0b2tlbiBsaXN0XG4gICAgICovXG4gICAgYWRkVG9rZW5zKHRva2Vuc1RvQWRkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgY29uc3QgeyB0b2tlbnMsIGlnbm9yZWRUb2tlbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRva2Vuc1RvQWRkID0geWllbGQgUHJvbWlzZS5hbGwodG9rZW5zVG9BZGQubWFwKCh0b2tlbikgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5pc0VSQzcyMSA9IHlpZWxkIHRoaXMuX2RldGVjdElzRVJDNzIxKHRva2VuLmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3SWdub3JlZFRva2VucyA9IGlnbm9yZWRUb2tlbnM7XG4gICAgICAgICAgICAgICAgdG9rZW5zVG9BZGQuZm9yRWFjaCgodG9rZW5Ub0FkZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGFkZHJlc3MsIHN5bWJvbCwgZGVjaW1hbHMsIGltYWdlLCBpc0VSQzcyMSB9ID0gdG9rZW5Ub0FkZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hlY2tzdW1BZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdFbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VSQzcyMSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNFbnRyeSA9IHRva2Vucy5maW5kKCh0b2tlbikgPT4gdG9rZW4uYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBjaGVja3N1bUFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdG9rZW5zLmluZGV4T2YocHJldmlvdXNFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNbcHJldmlvdXNJbmRleF0gPSBuZXdFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKG5ld0VudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdJZ25vcmVkVG9rZW5zID0gbmV3SWdub3JlZFRva2Vucy5maWx0ZXIoKHRva2VuQWRkcmVzcykgPT4gdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBuZXdBbGxUb2tlbnMsIG5ld0FsbElnbm9yZWRUb2tlbnMgfSA9IHRoaXMuX2dldE5ld0FsbFRva2Vuc1N0YXRlKHRva2VucywgbmV3SWdub3JlZFRva2Vucyk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIGFsbFRva2VuczogbmV3QWxsVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBhbGxJZ25vcmVkVG9rZW5zOiBuZXdBbGxJZ25vcmVkVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBpZ25vcmVkVG9rZW5zOiBuZXdJZ25vcmVkVG9rZW5zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBpc0VSQzcyMSBmaWVsZCB0byB0b2tlbiBvYmplY3RcbiAgICAgKiAoQ2FsbGVkIHdoZW4gYSB1c2VyIGF0dGVtcHRzIHRvIGFkZCB0b2tlbnMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgYWRkZWQgd2hpY2ggZG8gbm90IHlldCBoYWQgaXNFUkM3MjEgZmllbGQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5BZGRyZXNzIC0gVGhlIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIHRva2VuIHJlcXVpcmluZyB0aGUgaXNFUkM3MjEgZmllbGQgYWRkZWQuXG4gICAgICogQHJldHVybnMgVGhlIG5ldyB0b2tlbiBvYmplY3Qgd2l0aCB0aGUgYWRkZWQgaXNFUkM3MjEgZmllbGQuXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVUb2tlblR5cGUodG9rZW5BZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBpc0VSQzcyMSA9IHlpZWxkIHRoaXMuX2RldGVjdElzRVJDNzIxKHRva2VuQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCB7IHRva2VucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuSW5kZXggPSB0b2tlbnMuZmluZEluZGV4KCh0b2tlbikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbi5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IHRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5JbmRleF0uaXNFUkM3MjEgPSBpc0VSQzcyMTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgdG9rZW5zIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1t0b2tlbkluZGV4XTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVjdHMgd2hldGhlciBvciBub3QgYSB0b2tlbiBpcyBFUkMtNzIxIGNvbXBhdGlibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5zQWRkcmVzcyAtIHRoZSB0b2tlbiBjb250cmFjdCBhZGRyZXNzLlxuICAgICAqIEByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB0b2tlbiBhZGRyZXNzIHBhc3NlZCBpbiBzdXBwb3J0cyB0aGUgRUlQLTcyMSBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBfZGV0ZWN0SXNFUkM3MjEodG9rZW5BZGRyZXNzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bUFkZHJlc3MgPSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3ModG9rZW5BZGRyZXNzKTtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgdG9rZW4gaXMgYWxyZWFkeSBpbiBvdXIgY29udHJhY3QgbWV0YWRhdGEgbWFwIHdlIGRvbid0IG5lZWRcbiAgICAgICAgICAgIC8vIHRvIGNoZWNrIGFnYWluc3QgdGhlIGNvbnRyYWN0XG4gICAgICAgICAgICBpZiAoKChfYSA9IGNvbnRyYWN0X21ldGFkYXRhXzEuZGVmYXVsdFtjaGVja3N1bUFkZHJlc3NdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXJjNzIxKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoKF9iID0gY29udHJhY3RfbWV0YWRhdGFfMS5kZWZhdWx0W2NoZWNrc3VtQWRkcmVzc10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5lcmMyMCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuQ29udHJhY3QgPSB5aWVsZCB0aGlzLl9jcmVhdGVFdGhlcnNDb250cmFjdCh0b2tlbkFkZHJlc3MsIGh1bWFuX3N0YW5kYXJkX2NvbGxlY3RpYmxlX2FiaV8xLmRlZmF1bHQsIHRoaXMuZXRoZXJzUHJvdmlkZXIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdG9rZW5Db250cmFjdC5zdXBwb3J0c0ludGVyZmFjZShFUkM3MjFfSU5URVJGQUNFX0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRseSB3ZSBzZWUgYSB2YXJpZXR5IG9mIGVycm9ycyBhY3Jvc3MgZGlmZmVyZW50IG5ldHdvcmtzIHdoZW5cbiAgICAgICAgICAgICAgICAvLyB0b2tlbiBjb250cmFjdHMgYXJlIG5vdCBFUkM3MjEgY29tcGF0aWJsZS4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGEgYmV0dGVyXG4gICAgICAgICAgICAgICAgLy8gd2F5IG9mIGRpZmZlcmVudGlhdGluZyB0b2tlbiBpbnRlcmZhY2UgdHlwZXMgYnV0IGZvciBub3cgaWYgd2UgZ2V0IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBhc3N1bWUgdGhlIHRva2VuIGlzIG5vdCBFUkM3MjEgY29tcGF0aWJsZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY3JlYXRlRXRoZXJzQ29udHJhY3QodG9rZW5BZGRyZXNzLCBhYmksIGV0aGVyc1Byb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkNvbnRyYWN0ID0geWllbGQgbmV3IGV0aGVyc18xLmV0aGVycy5Db250cmFjdCh0b2tlbkFkZHJlc3MsIGFiaSwgZXRoZXJzUHJvdmlkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuQ29udHJhY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2VuZXJhdGVSYW5kb21JZCgpIHtcbiAgICAgICAgcmV0dXJuIHV1aWRfMS52MSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IHN1Z2dlc3RlZEFzc2V0IHRvIHN0YXRlLiBQYXJhbWV0ZXJzIHdpbGwgYmUgdmFsaWRhdGVkIGFjY29yZGluZyB0b1xuICAgICAqIGFzc2V0IHR5cGUgYmVpbmcgd2F0Y2hlZC4gQSBgPHN1Z2dlc3RlZEFzc2V0TWV0YS5pZD46cGVuZGluZ2AgaHViIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCBvbmNlIGFkZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0IC0gQXNzZXQgdG8gYmUgd2F0Y2hlZC4gRm9yIG5vdyBvbmx5IEVSQzIwIHRva2VucyBhcmUgYWNjZXB0ZWQuXG4gICAgICogQHBhcmFtIHR5cGUgLSBBc3NldCB0eXBlXG4gICAgICogQHJldHVybnMgLSBPYmplY3QgY29udGFpbmluZyBhIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzdWdnZXN0ZWRBc3NldCBhZGRyZXNzIGlmIGFjY2VwdGVkXG4gICAgICovXG4gICAgd2F0Y2hBc3NldChhc3NldCwgdHlwZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc3VnZ2VzdGVkQXNzZXRNZXRhID0ge1xuICAgICAgICAgICAgICAgIGFzc2V0LFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLl9nZW5lcmF0ZVJhbmRvbUlkKCksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBTdWdnZXN0ZWRBc3NldFN0YXR1cy5wZW5kaW5nLFxuICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdFUkMyMCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVUb2tlblRvV2F0Y2goYXNzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzc2V0IG9mIHR5cGUgJHt0eXBlfSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsU3VnZ2VzdGVkQXNzZXQoc3VnZ2VzdGVkQXNzZXRNZXRhLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmh1Yi5vbmNlKGAke3N1Z2dlc3RlZEFzc2V0TWV0YS5pZH06ZmluaXNoZWRgLCAobWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1ldGEuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN1Z2dlc3RlZEFzc2V0U3RhdHVzLmFjY2VwdGVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG1ldGEuYXNzZXQuYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN1Z2dlc3RlZEFzc2V0U3RhdHVzLnJlamVjdGVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdVc2VyIHJlamVjdGVkIHRvIHdhdGNoIHRoZSBhc3NldC4nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN1Z2dlc3RlZEFzc2V0U3RhdHVzLmZhaWxlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihtZXRhLmVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBVbmtub3duIHN0YXR1czogJHttZXRhLnN0YXR1c31gKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBzdWdnZXN0ZWRBc3NldHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBzdWdnZXN0ZWRBc3NldHMucHVzaChzdWdnZXN0ZWRBc3NldE1ldGEpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBzdWdnZXN0ZWRBc3NldHM6IFsuLi5zdWdnZXN0ZWRBc3NldHNdIH0pO1xuICAgICAgICAgICAgdGhpcy5odWIuZW1pdCgncGVuZGluZ1N1Z2dlc3RlZEFzc2V0Jywgc3VnZ2VzdGVkQXNzZXRNZXRhKTtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdCwgc3VnZ2VzdGVkQXNzZXRNZXRhIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIHRvIHdhdGNoIGFuIGFzc2V0IGFuZCB1cGRhdGVzIGl0J3Mgc3RhdHVzIGFuZCBkZWxldGVzIHRoZSBzdWdnZXN0ZWRBc3NldCBmcm9tIHN0YXRlLFxuICAgICAqIGFkZGluZyB0aGUgYXNzZXQgdG8gY29ycmVzcG9uZGluZyBhc3NldCBzdGF0ZS4gSW4gdGhpcyBjYXNlIEVSQzIwIHRva2Vucy5cbiAgICAgKiBBIGA8c3VnZ2VzdGVkQXNzZXRNZXRhLmlkPjpmaW5pc2hlZGAgaHViIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGFjY2VwdGVkIG9yIGZhaWx1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3VnZ2VzdGVkQXNzZXRJRCAtIElEIG9mIHRoZSBzdWdnZXN0ZWRBc3NldCB0byBhY2NlcHRcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhpcyBvcGVyYXRpb24gY29tcGxldGVzXG4gICAgICovXG4gICAgYWNjZXB0V2F0Y2hBc3NldChzdWdnZXN0ZWRBc3NldElEKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHN1Z2dlc3RlZEFzc2V0cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3VnZ2VzdGVkQXNzZXRzLmZpbmRJbmRleCgoeyBpZCB9KSA9PiBzdWdnZXN0ZWRBc3NldElEID09PSBpZCk7XG4gICAgICAgICAgICBjb25zdCBzdWdnZXN0ZWRBc3NldE1ldGEgPSBzdWdnZXN0ZWRBc3NldHNbaW5kZXhdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1Z2dlc3RlZEFzc2V0TWV0YS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0VSQzIwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYWRkcmVzcywgc3ltYm9sLCBkZWNpbWFscywgaW1hZ2UgfSA9IHN1Z2dlc3RlZEFzc2V0TWV0YS5hc3NldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuYWRkVG9rZW4oYWRkcmVzcywgc3ltYm9sLCBkZWNpbWFscywgaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQXNzZXRNZXRhLnN0YXR1cyA9IFN1Z2dlc3RlZEFzc2V0U3RhdHVzLmFjY2VwdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5odWIuZW1pdChgJHtzdWdnZXN0ZWRBc3NldE1ldGEuaWR9OmZpbmlzaGVkYCwgc3VnZ2VzdGVkQXNzZXRNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NldCBvZiB0eXBlICR7c3VnZ2VzdGVkQXNzZXRNZXRhLnR5cGV9IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxTdWdnZXN0ZWRBc3NldChzdWdnZXN0ZWRBc3NldE1ldGEsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld1N1Z2dlc3RlZEFzc2V0cyA9IHN1Z2dlc3RlZEFzc2V0cy5maWx0ZXIoKHsgaWQgfSkgPT4gaWQgIT09IHN1Z2dlc3RlZEFzc2V0SUQpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBzdWdnZXN0ZWRBc3NldHM6IFsuLi5uZXdTdWdnZXN0ZWRBc3NldHNdIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVqZWN0cyBhIHdhdGNoQXNzZXQgcmVxdWVzdCBiYXNlZCBvbiBpdHMgSUQgYnkgc2V0dGluZyBpdHMgc3RhdHVzIHRvIFwicmVqZWN0ZWRcIlxuICAgICAqIGFuZCBlbWl0dGluZyBhIGA8c3VnZ2VzdGVkQXNzZXRNZXRhLmlkPjpmaW5pc2hlZGAgaHViIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Z2dlc3RlZEFzc2V0SUQgLSBJRCBvZiB0aGUgc3VnZ2VzdGVkQXNzZXQgdG8gYWNjZXB0XG4gICAgICovXG4gICAgcmVqZWN0V2F0Y2hBc3NldChzdWdnZXN0ZWRBc3NldElEKSB7XG4gICAgICAgIGNvbnN0IHsgc3VnZ2VzdGVkQXNzZXRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCBpbmRleCA9IHN1Z2dlc3RlZEFzc2V0cy5maW5kSW5kZXgoKHsgaWQgfSkgPT4gc3VnZ2VzdGVkQXNzZXRJRCA9PT0gaWQpO1xuICAgICAgICBjb25zdCBzdWdnZXN0ZWRBc3NldE1ldGEgPSBzdWdnZXN0ZWRBc3NldHNbaW5kZXhdO1xuICAgICAgICBpZiAoIXN1Z2dlc3RlZEFzc2V0TWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1Z2dlc3RlZEFzc2V0TWV0YS5zdGF0dXMgPSBTdWdnZXN0ZWRBc3NldFN0YXR1cy5yZWplY3RlZDtcbiAgICAgICAgdGhpcy5odWIuZW1pdChgJHtzdWdnZXN0ZWRBc3NldE1ldGEuaWR9OmZpbmlzaGVkYCwgc3VnZ2VzdGVkQXNzZXRNZXRhKTtcbiAgICAgICAgY29uc3QgbmV3U3VnZ2VzdGVkQXNzZXRzID0gc3VnZ2VzdGVkQXNzZXRzLmZpbHRlcigoeyBpZCB9KSA9PiBpZCAhPT0gc3VnZ2VzdGVkQXNzZXRJRCk7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgc3VnZ2VzdGVkQXNzZXRzOiBbLi4ubmV3U3VnZ2VzdGVkQXNzZXRzXSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHRva2VuIGZyb20gdGhlIHN0b3JlZCB0b2tlbiBsaXN0IGFuZCBzYXZlcyBpdCBpbiBpZ25vcmVkIHRva2VucyBsaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSB0b2tlbiBjb250cmFjdFxuICAgICAqL1xuICAgIHJlbW92ZUFuZElnbm9yZVRva2VuKGFkZHJlc3MpIHtcbiAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgeyB0b2tlbnMsIGlnbm9yZWRUb2tlbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGFscmVhZHlJZ25vcmVkID0gaWdub3JlZFRva2Vucy5maW5kKCh0b2tlbkFkZHJlc3MpID0+IHRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBjb25zdCBuZXdUb2tlbnMgPSB0b2tlbnMuZmlsdGVyKCh0b2tlbikgPT4ge1xuICAgICAgICAgICAgaWYgKHRva2VuLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgIWFscmVhZHlJZ25vcmVkICYmIGlnbm9yZWRUb2tlbnMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgbmV3QWxsVG9rZW5zLCBuZXdBbGxJZ25vcmVkVG9rZW5zIH0gPSB0aGlzLl9nZXROZXdBbGxUb2tlbnNTdGF0ZShuZXdUb2tlbnMsIGlnbm9yZWRUb2tlbnMpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBhbGxUb2tlbnM6IG5ld0FsbFRva2VucyxcbiAgICAgICAgICAgIHRva2VuczogbmV3VG9rZW5zLFxuICAgICAgICAgICAgYWxsSWdub3JlZFRva2VuczogbmV3QWxsSWdub3JlZFRva2VucyxcbiAgICAgICAgICAgIGlnbm9yZWRUb2tlbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIG5ldyB0b2tlbnMgYW5kIGlnbm9yZWRUb2tlbnMgYXJyYXkgZm9yIHRoZSBjdXJyZW50IG5ldHdvcmsvYWNjb3VudCBjb21iaW5hdGlvblxuICAgICAqIGFuZCByZXR1cm5zIG5ldyBhbGxUb2tlbnMgYW5kIGFsbElnbm9yZWRUb2tlbnMgc3RhdGUgdG8gdXBkYXRlIHRvLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld1Rva2VucyAtIFRoZSBuZXcgdG9rZW5zIHRvIHNldCBmb3IgdGhlIGN1cnJlbnQgbmV0d29yayBhbmQgc2VsZWN0ZWQgYWNjb3VudC5cbiAgICAgKiBAcGFyYW0gbmV3SWdub3JlZFRva2VucyAtIFRoZSBuZXcgaWdub3JlZCB0b2tlbnMgdG8gc2V0IGZvciB0aGUgY3VycmVudCBuZXR3b3JrIGFuZCBzZWxlY3RlZCBhY2NvdW50LlxuICAgICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGBhbGxUb2tlbnNgIGFuZCBgYWxsSWdub3JlZFRva2Vuc2Agc3RhdGUuXG4gICAgICovXG4gICAgX2dldE5ld0FsbFRva2Vuc1N0YXRlKG5ld1Rva2VucywgbmV3SWdub3JlZFRva2Vucykge1xuICAgICAgICBjb25zdCB7IGFsbFRva2VucywgYWxsSWdub3JlZFRva2VucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBuZXR3b3JrVG9rZW5zID0gYWxsVG9rZW5zW2NoYWluSWRdO1xuICAgICAgICBjb25zdCBuZXR3b3JrSWdub3JlZFRva2VucyA9IGFsbElnbm9yZWRUb2tlbnNbY2hhaW5JZF07XG4gICAgICAgIGNvbnN0IG5ld05ldHdvcmtUb2tlbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5ldHdvcmtUb2tlbnMpLCB7IFtzZWxlY3RlZEFkZHJlc3NdOiBuZXdUb2tlbnMgfSk7XG4gICAgICAgIGNvbnN0IG5ld0lnbm9yZWROZXR3b3JrVG9rZW5zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBuZXR3b3JrSWdub3JlZFRva2VucyksIHsgW3NlbGVjdGVkQWRkcmVzc106IG5ld0lnbm9yZWRUb2tlbnMgfSk7XG4gICAgICAgIGNvbnN0IG5ld0FsbFRva2VucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWxsVG9rZW5zKSwgeyBbY2hhaW5JZF06IG5ld05ldHdvcmtUb2tlbnMgfSk7XG4gICAgICAgIGNvbnN0IG5ld0FsbElnbm9yZWRUb2tlbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFsbElnbm9yZWRUb2tlbnMpLCB7IFtjaGFpbklkXTogbmV3SWdub3JlZE5ldHdvcmtUb2tlbnMgfSk7XG4gICAgICAgIHJldHVybiB7IG5ld0FsbFRva2VucywgbmV3QWxsSWdub3JlZFRva2VucyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0b2tlbnMgZnJvbSB0aGUgaWdub3JlZCBsaXN0XG4gICAgICovXG4gICAgY2xlYXJJZ25vcmVkVG9rZW5zKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGlnbm9yZWRUb2tlbnM6IFtdLCBhbGxJZ25vcmVkVG9rZW5zOiB7fSB9KTtcbiAgICB9XG59XG5leHBvcnRzLlRva2Vuc0NvbnRyb2xsZXIgPSBUb2tlbnNDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG9rZW5zQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRva2Vuc0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmV0d29ya0NvbnRyb2xsZXIgPSBleHBvcnRzLk5ldHdvcmtzQ2hhaW5JZCA9IHZvaWQgMDtcbmNvbnN0IGV0aF9xdWVyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJldGgtcXVlcnlcIikpO1xuY29uc3QgcHJvdmlkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwid2ViMy1wcm92aWRlci1lbmdpbmUvc3VicHJvdmlkZXJzL3Byb3ZpZGVyXCIpKTtcbmNvbnN0IGNyZWF0ZVByb3ZpZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aC1qc29uLXJwYy1pbmZ1cmEvc3JjL2NyZWF0ZVByb3ZpZGVyXCIpKTtcbmNvbnN0IHplcm9fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwid2ViMy1wcm92aWRlci1lbmdpbmUvemVyb1wiKSk7XG5jb25zdCBhc3luY19tdXRleF8xID0gcmVxdWlyZShcImFzeW5jLW11dGV4XCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBOZXR3b3Jrc0NoYWluSWQ7XG4oZnVuY3Rpb24gKE5ldHdvcmtzQ2hhaW5JZCkge1xuICAgIE5ldHdvcmtzQ2hhaW5JZFtcIm1haW5uZXRcIl0gPSBcIjFcIjtcbiAgICBOZXR3b3Jrc0NoYWluSWRbXCJrb3ZhblwiXSA9IFwiNDJcIjtcbiAgICBOZXR3b3Jrc0NoYWluSWRbXCJyaW5rZWJ5XCJdID0gXCI0XCI7XG4gICAgTmV0d29ya3NDaGFpbklkW1wiZ29lcmxpXCJdID0gXCI1XCI7XG4gICAgTmV0d29ya3NDaGFpbklkW1wicm9wc3RlblwiXSA9IFwiM1wiO1xuICAgIE5ldHdvcmtzQ2hhaW5JZFtcImxvY2FsaG9zdFwiXSA9IFwiXCI7XG4gICAgTmV0d29ya3NDaGFpbklkW1wicnBjXCJdID0gXCJcIjtcbiAgICBOZXR3b3Jrc0NoYWluSWRbXCJvcHRpbWlzbVwiXSA9IFwiMTBcIjtcbiAgICBOZXR3b3Jrc0NoYWluSWRbXCJvcHRpbWlzbVRlc3RcIl0gPSBcIjY5XCI7XG59KShOZXR3b3Jrc0NoYWluSWQgPSBleHBvcnRzLk5ldHdvcmtzQ2hhaW5JZCB8fCAoZXhwb3J0cy5OZXR3b3Jrc0NoYWluSWQgPSB7fSkpO1xuY29uc3QgTE9DQUxIT1NUX1JQQ19VUkwgPSAnaHR0cDovL2xvY2FsaG9zdDo4NTQ1Jztcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IGNyZWF0ZXMgYW5kIG1hbmFnZXMgYW4gRXRoZXJldW0gbmV0d29yayBwcm92aWRlclxuICovXG5jbGFzcyBOZXR3b3JrQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBOZXR3b3JrQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICB0aGlzLmludGVybmFsUHJvdmlkZXJDb25maWcgPSB7fTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ05ldHdvcmtDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICAgICAgICBuZXR3b3JrOiAnbG9hZGluZycsXG4gICAgICAgICAgICBpc0N1c3RvbU5ldHdvcms6IGZhbHNlLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHsgdHlwZTogY29uc3RhbnRzXzEuTUFJTk5FVCwgY2hhaW5JZDogTmV0d29ya3NDaGFpbklkLm1haW5uZXQgfSxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHsgaXNFSVAxNTU5Q29tcGF0aWJsZTogZmFsc2UgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkoKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVByb3ZpZGVyKHR5cGUsIHJwY1RhcmdldCwgY2hhaW5JZCwgdGlja2VyLCBuaWNrbmFtZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGlzQ3VzdG9tTmV0d29yazogdGhpcy5nZXRJc0N1c3RvbU5ldHdvcmsoY2hhaW5JZCkgfSk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAna292YW4nOlxuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5NQUlOTkVUOlxuICAgICAgICAgICAgY2FzZSAncmlua2VieSc6XG4gICAgICAgICAgICBjYXNlICdnb2VybGknOlxuICAgICAgICAgICAgY2FzZSAnb3B0aW1pc20nOlxuICAgICAgICAgICAgY2FzZSAnb3B0aW1pc21UZXN0JzpcbiAgICAgICAgICAgIGNhc2UgJ3JvcHN0ZW4nOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBJbmZ1cmFQcm92aWRlcih0eXBlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xvY2FsaG9zdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR1cFN0YW5kYXJkUHJvdmlkZXIoTE9DQUxIT1NUX1JQQ19VUkwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5SUEM6XG4gICAgICAgICAgICAgICAgcnBjVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBTdGFuZGFyZFByb3ZpZGVyKHJwY1RhcmdldCwgY2hhaW5JZCwgdGlja2VyLCBuaWNrbmFtZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG5ldHdvcmsgdHlwZTogJyR7dHlwZX0nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmcmVzaE5ldHdvcmsoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgbmV0d29yazogJ2xvYWRpbmcnLCBwcm9wZXJ0aWVzOiB7fSB9KTtcbiAgICAgICAgY29uc3QgeyBycGNUYXJnZXQsIHR5cGUsIGNoYWluSWQsIHRpY2tlciB9ID0gdGhpcy5zdGF0ZS5wcm92aWRlcjtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplUHJvdmlkZXIodHlwZSwgcnBjVGFyZ2V0LCBjaGFpbklkLCB0aWNrZXIpO1xuICAgICAgICB0aGlzLmxvb2t1cE5ldHdvcmsoKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJQcm92aWRlcigpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlci5vbignZXJyb3InLCB0aGlzLnZlcmlmeU5ldHdvcmsuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZXRoUXVlcnkgPSBuZXcgZXRoX3F1ZXJ5XzEuZGVmYXVsdCh0aGlzLnByb3ZpZGVyKTtcbiAgICB9XG4gICAgc2V0dXBJbmZ1cmFQcm92aWRlcih0eXBlKSB7XG4gICAgICAgIGNvbnN0IGluZnVyYVByb3ZpZGVyID0gY3JlYXRlUHJvdmlkZXJfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIG5ldHdvcms6IHR5cGUsXG4gICAgICAgICAgICBwcm9qZWN0SWQ6IHRoaXMuY29uZmlnLmluZnVyYVByb2plY3RJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGluZnVyYVN1YnByb3ZpZGVyID0gbmV3IHByb3ZpZGVyXzEuZGVmYXVsdChpbmZ1cmFQcm92aWRlcik7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbnRlcm5hbFByb3ZpZGVyQ29uZmlnKSwge1xuICAgICAgICAgICAgZGF0YVN1YnByb3ZpZGVyOiBpbmZ1cmFTdWJwcm92aWRlcixcbiAgICAgICAgICAgIGVuZ2luZVBhcmFtczoge1xuICAgICAgICAgICAgICAgIGJsb2NrVHJhY2tlclByb3ZpZGVyOiBpbmZ1cmFQcm92aWRlcixcbiAgICAgICAgICAgICAgICBwb2xsaW5nSW50ZXJ2YWw6IDEyMDAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlUHJvdmlkZXIoemVyb18xLmRlZmF1bHQoY29uZmlnKSk7XG4gICAgfVxuICAgIGdldElzQ3VzdG9tTmV0d29yayhjaGFpbklkKSB7XG4gICAgICAgIHJldHVybiAoY2hhaW5JZCAhPT0gTmV0d29ya3NDaGFpbklkLm1haW5uZXQgJiZcbiAgICAgICAgICAgIGNoYWluSWQgIT09IE5ldHdvcmtzQ2hhaW5JZC5rb3ZhbiAmJlxuICAgICAgICAgICAgY2hhaW5JZCAhPT0gTmV0d29ya3NDaGFpbklkLnJpbmtlYnkgJiZcbiAgICAgICAgICAgIGNoYWluSWQgIT09IE5ldHdvcmtzQ2hhaW5JZC5nb2VybGkgJiZcbiAgICAgICAgICAgIGNoYWluSWQgIT09IE5ldHdvcmtzQ2hhaW5JZC5yb3BzdGVuICYmXG4gICAgICAgICAgICBjaGFpbklkICE9PSBOZXR3b3Jrc0NoYWluSWQubG9jYWxob3N0KTtcbiAgICB9XG4gICAgc2V0dXBTdGFuZGFyZFByb3ZpZGVyKHJwY1RhcmdldCwgY2hhaW5JZCwgdGlja2VyLCBuaWNrbmFtZSkge1xuICAgICAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW50ZXJuYWxQcm92aWRlckNvbmZpZyksIHtcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICBlbmdpbmVQYXJhbXM6IHsgcG9sbGluZ0ludGVydmFsOiAxMjAwMCB9LFxuICAgICAgICAgICAgbmlja25hbWUsXG4gICAgICAgICAgICBycGNVcmw6IHJwY1RhcmdldCxcbiAgICAgICAgICAgIHRpY2tlcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlUHJvdmlkZXIoemVyb18xLmRlZmF1bHQoY29uZmlnKSk7XG4gICAgfVxuICAgIHVwZGF0ZVByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuc2FmZWx5U3RvcFByb3ZpZGVyKHRoaXMucHJvdmlkZXIpO1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJQcm92aWRlcigpO1xuICAgIH1cbiAgICBzYWZlbHlTdG9wUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBwcm92aWRlciA9PT0gbnVsbCB8fCBwcm92aWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvdmlkZXIuc3RvcCgpO1xuICAgICAgICB9LCA1MDApO1xuICAgIH1cbiAgICB2ZXJpZnlOZXR3b3JrKCkge1xuICAgICAgICB0aGlzLnN0YXRlLm5ldHdvcmsgPT09ICdsb2FkaW5nJyAmJiB0aGlzLmxvb2t1cE5ldHdvcmsoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG5ldyBjb25maWd1cmF0aW9uIGZvciB3ZWIzLXByb3ZpZGVyLWVuZ2luZVxuICAgICAqXG4gICAgICogVE9ETzogUmVwbGFjZSB0aGlzIHd0aCBhIG1ldGhvZFxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3ZpZGVyQ29uZmlnIC0gd2ViMy1wcm92aWRlci1lbmdpbmUgY29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIHNldCBwcm92aWRlckNvbmZpZyhwcm92aWRlckNvbmZpZykge1xuICAgICAgICB0aGlzLmludGVybmFsUHJvdmlkZXJDb25maWcgPSBwcm92aWRlckNvbmZpZztcbiAgICAgICAgY29uc3QgeyB0eXBlLCBycGNUYXJnZXQsIGNoYWluSWQsIHRpY2tlciwgbmlja25hbWUgfSA9IHRoaXMuc3RhdGUucHJvdmlkZXI7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVByb3ZpZGVyKHR5cGUsIHJwY1RhcmdldCwgY2hhaW5JZCwgdGlja2VyLCBuaWNrbmFtZSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJQcm92aWRlcigpO1xuICAgICAgICB0aGlzLmxvb2t1cE5ldHdvcmsoKTtcbiAgICB9XG4gICAgZ2V0IHByb3ZpZGVyQ29uZmlnKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IG9ubHkgdXNlZCBmb3Igc2V0dGluZycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGN1cnJlbnQgbmV0d29yayBjb2RlXG4gICAgICovXG4gICAgbG9va3VwTmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV0aFF1ZXJ5IHx8ICF0aGlzLmV0aFF1ZXJ5LnNlbmRBc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICB0aGlzLmV0aFF1ZXJ5LnNlbmRBc3luYyh7IG1ldGhvZDogJ25ldF92ZXJzaW9uJyB9LCAoZXJyb3IsIG5ldHdvcmspID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcms6IGVycm9yID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQqLyAnbG9hZGluZycgOiBuZXR3b3JrLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byB1cGRhdGUgcHJvdmlkZXIgbmV0d29yayB0eXBlIHNldHRpbmdzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIEh1bWFuIHJlYWRhYmxlIG5ldHdvcmsgbmFtZVxuICAgICAqL1xuICAgIHNldFByb3ZpZGVyVHlwZSh0eXBlKSB7XG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5zdGF0ZS5wcm92aWRlciwgeyBycGNUYXJnZXQsIGNoYWluSWQsIG5pY2tuYW1lIH0gPSBfYSwgcHJvdmlkZXJTdGF0ZSA9IF9fcmVzdChfYSwgW1wicnBjVGFyZ2V0XCIsIFwiY2hhaW5JZFwiLCBcIm5pY2tuYW1lXCJdKTtcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgcHJvdmlkZXI6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvdmlkZXJTdGF0ZSksIHsgdHlwZSwgdGlja2VyOiAnRVRIJywgY2hhaW5JZDogTmV0d29ya3NDaGFpbklkW3R5cGVdIH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWZyZXNoTmV0d29yaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gdXBkYXRlIHByb3ZpZGVyIFJQQyBzZXR0aW5nc1xuICAgICAqXG4gICAgICogQHBhcmFtIHJwY1RhcmdldCAtIFJQQyBlbmRwb2ludCBVUkxcbiAgICAgKiBAcGFyYW0gY2hhaW5JZCAtIE5ldHdvcmsgSUQgYXMgcGVyIEVJUC0xNTVcbiAgICAgKiBAcGFyYW0gdGlja2VyPyAtIEN1cnJlbmN5IHRpY2tlclxuICAgICAqIEBwYXJhbSBuaWNrbmFtZT8gLSBQZXJzb25hbGl6ZWQgbmV0d29yayBuYW1lXG4gICAgICovXG4gICAgc2V0UnBjVGFyZ2V0KHJwY1RhcmdldCwgY2hhaW5JZCwgdGlja2VyLCBuaWNrbmFtZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBwcm92aWRlcjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLnByb3ZpZGVyKSwgeyB0eXBlOiBjb25zdGFudHNfMS5SUEMsIHRpY2tlciwgcnBjVGFyZ2V0LCBjaGFpbklkLCBuaWNrbmFtZSB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVmcmVzaE5ldHdvcmsoKTtcbiAgICB9XG4gICAgZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzID0ge30gfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmICghcHJvcGVydGllcy5pc0VJUDE1NTlDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICgoX2EgPSB0aGlzLmV0aFF1ZXJ5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZEFzeW5jKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXRoUXVlcnkuc2VuZEFzeW5jKHsgbWV0aG9kOiAnZXRoX2dldEJsb2NrQnlOdW1iZXInLCBwYXJhbXM6IFsnbGF0ZXN0JywgZmFsc2VdIH0sIChlcnJvciwgYmxvY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNFSVAxNTU5Q29tcGF0aWJsZSA9IHR5cGVvZiBibG9jay5iYXNlRmVlUGVyR2FzICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmlzRUlQMTU1OUNvbXBhdGlibGUgIT09IGlzRUlQMTU1OUNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRUlQMTU1OUNvbXBhdGlibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGlzRUlQMTU1OUNvbXBhdGlibGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTmV0d29ya0NvbnRyb2xsZXIgPSBOZXR3b3JrQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IE5ldHdvcmtDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmV0d29ya0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGhpc2hpbmdDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgcHVueWNvZGVfMSA9IHJlcXVpcmUoXCJwdW55Y29kZS9cIik7XG5jb25zdCBjb25maWdfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJldGgtcGhpc2hpbmctZGV0ZWN0L3NyYy9jb25maWcuanNvblwiKSk7XG5jb25zdCBkZXRlY3Rvcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJldGgtcGhpc2hpbmctZGV0ZWN0L3NyYy9kZXRlY3RvclwiKSk7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBwYXNzaXZlbHkgcG9sbHMgb24gYSBzZXQgaW50ZXJ2YWwgZm9yIGFwcHJvdmVkIGFuZCB1bmFwcHJvdmVkIHdlYnNpdGUgb3JpZ2luc1xuICovXG5jbGFzcyBQaGlzaGluZ0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUGhpc2hpbmdDb250cm9sbGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMuY29uZmlnVXJsID0gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9NZXRhTWFzay9ldGgtcGhpc2hpbmctZGV0ZWN0QG1hc3Rlci9zcmMvY29uZmlnLmpzb24nO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdQaGlzaGluZ0NvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7IGludGVydmFsOiA2MCAqIDYwICogMTAwMCB9O1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIHBoaXNoaW5nOiBjb25maWdfanNvbl8xLmRlZmF1bHQsXG4gICAgICAgICAgICB3aGl0ZWxpc3Q6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRldGVjdG9yID0gbmV3IGRldGVjdG9yXzEuZGVmYXVsdCh0aGlzLmRlZmF1bHRTdGF0ZS5waGlzaGluZyk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgbmV3IHBvbGxpbmcgaW50ZXJ2YWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbCAtIFBvbGxpbmcgaW50ZXJ2YWwgdXNlZCB0byBmZXRjaCBuZXcgYXBwcm92YWwgbGlzdHNcbiAgICAgKi9cbiAgICBwb2xsKGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCAmJiB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSAmJiBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgICAgICAgICAgeWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gdGhpcy51cGRhdGVQaGlzaGluZ0xpc3RzKCkpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvbGwodGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfSwgdGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIG9yaWdpbiBpcyB1bmFwcHJvdmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gRG9tYWluIG9yaWdpbiBvZiBhIHdlYnNpdGVcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIG9yaWdpbiBpcyBhbiB1bmFwcHJvdmVkIG9yaWdpblxuICAgICAqL1xuICAgIHRlc3Qob3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHB1bnljb2RlT3JpZ2luID0gcHVueWNvZGVfMS50b0FTQ0lJKG9yaWdpbik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLndoaXRlbGlzdC5pbmRleE9mKHB1bnljb2RlT3JpZ2luKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kZXRlY3Rvci5jaGVjayhwdW55Y29kZU9yaWdpbikucmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZW1wb3JhcmlseSBtYXJrcyBhIGdpdmVuIG9yaWdpbiBhcyBhcHByb3ZlZFxuICAgICAqL1xuICAgIGJ5cGFzcyhvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgcHVueWNvZGVPcmlnaW4gPSBwdW55Y29kZV8xLnRvQVNDSUkob3JpZ2luKTtcbiAgICAgICAgY29uc3QgeyB3aGl0ZWxpc3QgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmICh3aGl0ZWxpc3QuaW5kZXhPZihwdW55Y29kZU9yaWdpbikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoeyB3aGl0ZWxpc3Q6IFsuLi53aGl0ZWxpc3QsIHB1bnljb2RlT3JpZ2luXSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBsaXN0cyBvZiBhcHByb3ZlZCBhbmQgdW5hcHByb3ZlZCB3ZWJzaXRlIG9yaWdpbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhpcyBvcGVyYXRpb24gY29tcGxldGVzXG4gICAgICovXG4gICAgdXBkYXRlUGhpc2hpbmdMaXN0cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGhpc2hpbmdPcHRzID0geWllbGQgdGhpcy5xdWVyeUNvbmZpZyh0aGlzLmNvbmZpZ1VybCk7XG4gICAgICAgICAgICBpZiAocGhpc2hpbmdPcHRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRlY3RvciA9IG5ldyBkZXRlY3Rvcl8xLmRlZmF1bHQocGhpc2hpbmdPcHRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHBoaXNoaW5nOiBwaGlzaGluZ09wdHMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBxdWVyeUNvbmZpZyhpbnB1dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaChpbnB1dCwgeyBjYWNoZTogJ25vLWNhY2hlJyB9KTtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDA6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAzMDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA0MDM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGZXRjaCBmYWlsZWQgd2l0aCBzdGF0dXMgJyR7cmVzcG9uc2Uuc3RhdHVzfScgZm9yIHJlcXVlc3QgJyR7aW5wdXR9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5QaGlzaGluZ0NvbnRyb2xsZXIgPSBQaGlzaGluZ0NvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBQaGlzaGluZ0NvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QaGlzaGluZ0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5LZXlyaW5nQ29udHJvbGxlciA9IGV4cG9ydHMuU2lnblR5cGVkRGF0YVZlcnNpb24gPSBleHBvcnRzLkFjY291bnRJbXBvcnRTdHJhdGVneSA9IGV4cG9ydHMuS2V5cmluZ1R5cGVzID0gdm9pZCAwO1xuY29uc3QgZXRoZXJldW1qc191dGlsXzEgPSByZXF1aXJlKFwiZXRoZXJldW1qcy11dGlsXCIpO1xuY29uc3QgZXRoanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGpzLXV0aWxcIik7XG5jb25zdCBldGhfc2lnX3V0aWxfMSA9IHJlcXVpcmUoXCJldGgtc2lnLXV0aWxcIik7XG5jb25zdCBldGhlcmV1bWpzX3dhbGxldF8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJldGhlcmV1bWpzLXdhbGxldFwiKSk7XG5jb25zdCBldGhfa2V5cmluZ19jb250cm9sbGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aC1rZXlyaW5nLWNvbnRyb2xsZXJcIikpO1xuY29uc3QgYXN5bmNfbXV0ZXhfMSA9IHJlcXVpcmUoXCJhc3luYy1tdXRleFwiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IHByaXZhdGVzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQXZhaWxhYmxlIGtleXJpbmcgdHlwZXNcbiAqL1xudmFyIEtleXJpbmdUeXBlcztcbihmdW5jdGlvbiAoS2V5cmluZ1R5cGVzKSB7XG4gICAgS2V5cmluZ1R5cGVzW1wic2ltcGxlXCJdID0gXCJTaW1wbGUgS2V5IFBhaXJcIjtcbiAgICBLZXlyaW5nVHlwZXNbXCJoZFwiXSA9IFwiSEQgS2V5IFRyZWVcIjtcbn0pKEtleXJpbmdUeXBlcyA9IGV4cG9ydHMuS2V5cmluZ1R5cGVzIHx8IChleHBvcnRzLktleXJpbmdUeXBlcyA9IHt9KSk7XG4vKipcbiAqIEEgc3RyYXRlZ3kgZm9yIGltcG9ydGluZyBhbiBhY2NvdW50XG4gKi9cbnZhciBBY2NvdW50SW1wb3J0U3RyYXRlZ3k7XG4oZnVuY3Rpb24gKEFjY291bnRJbXBvcnRTdHJhdGVneSkge1xuICAgIEFjY291bnRJbXBvcnRTdHJhdGVneVtcInByaXZhdGVLZXlcIl0gPSBcInByaXZhdGVLZXlcIjtcbiAgICBBY2NvdW50SW1wb3J0U3RyYXRlZ3lbXCJqc29uXCJdID0gXCJqc29uXCI7XG59KShBY2NvdW50SW1wb3J0U3RyYXRlZ3kgPSBleHBvcnRzLkFjY291bnRJbXBvcnRTdHJhdGVneSB8fCAoZXhwb3J0cy5BY2NvdW50SW1wb3J0U3RyYXRlZ3kgPSB7fSkpO1xuLyoqXG4gKiBUaGUgYHNpZ25UeXBlZE1lc3NhZ2VgIHZlcnNpb25cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLm1ldGFtYXNrLmlvL2d1aWRlL3NpZ25pbmctZGF0YS5odG1sXG4gKi9cbnZhciBTaWduVHlwZWREYXRhVmVyc2lvbjtcbihmdW5jdGlvbiAoU2lnblR5cGVkRGF0YVZlcnNpb24pIHtcbiAgICBTaWduVHlwZWREYXRhVmVyc2lvbltcIlYxXCJdID0gXCJWMVwiO1xuICAgIFNpZ25UeXBlZERhdGFWZXJzaW9uW1wiVjNcIl0gPSBcIlYzXCI7XG4gICAgU2lnblR5cGVkRGF0YVZlcnNpb25bXCJWNFwiXSA9IFwiVjRcIjtcbn0pKFNpZ25UeXBlZERhdGFWZXJzaW9uID0gZXhwb3J0cy5TaWduVHlwZWREYXRhVmVyc2lvbiB8fCAoZXhwb3J0cy5TaWduVHlwZWREYXRhVmVyc2lvbiA9IHt9KSk7XG4vKipcbiAqIENvbnRyb2xsZXIgcmVzcG9uc2libGUgZm9yIGVzdGFibGlzaGluZyBhbmQgbWFuYWdpbmcgdXNlciBpZGVudGl0eVxuICovXG5jbGFzcyBLZXlyaW5nQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBLZXlyaW5nQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZW1vdmVJZGVudGl0eSAtIFJlbW92ZSB0aGUgaWRlbnRpdHkgd2l0aCB0aGUgZ2l2ZW4gYWRkcmVzc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnN5bmNJZGVudGl0aWVzIC0gU3luYyBpZGVudGl0aWVzIHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgYWRkcmVzc2VzXG4gICAgICogQHBhcmFtIG9wdGlvbnMudXBkYXRlSWRlbnRpdGllcyAtIEdlbmVyYXRlIGFuIGlkZW50aXR5IGZvciBlYWNoIGFkZHJlc3MgZ2l2ZW4gdGhhdCBkb2Vzbid0IGFscmVhZHkgaGF2ZSBhbiBpZGVudGl0eVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNldFNlbGVjdGVkQWRkcmVzcyAtIFNldCB0aGUgc2VsZWN0ZWQgYWRkcmVzc1xuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyByZW1vdmVJZGVudGl0eSwgc3luY0lkZW50aXRpZXMsIHVwZGF0ZUlkZW50aXRpZXMsIHNldFNlbGVjdGVkQWRkcmVzcywgfSwgY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0tleXJpbmdDb250cm9sbGVyJztcbiAgICAgICAgcHJpdmF0ZXMuc2V0KHRoaXMsIHtcbiAgICAgICAgICAgIGtleXJpbmc6IG5ldyBldGhfa2V5cmluZ19jb250cm9sbGVyXzEuZGVmYXVsdChPYmplY3QuYXNzaWduKHsgaW5pdFN0YXRlOiBzdGF0ZSB9LCBjb25maWcpKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5zdG9yZS5nZXRTdGF0ZSgpKSwgeyBrZXlyaW5nczogW10gfSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSWRlbnRpdHkgPSByZW1vdmVJZGVudGl0eTtcbiAgICAgICAgdGhpcy5zeW5jSWRlbnRpdGllcyA9IHN5bmNJZGVudGl0aWVzO1xuICAgICAgICB0aGlzLnVwZGF0ZUlkZW50aXRpZXMgPSB1cGRhdGVJZGVudGl0aWVzO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkQWRkcmVzcyA9IHNldFNlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGFjY291bnQgdG8gdGhlIGRlZmF1bHQgKGZpcnN0KSBIRCBzZWVkIHBocmFzZSBrZXlyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIGN1cnJlbnQgc3RhdGUgd2hlbiB0aGUgYWNjb3VudCBpcyBhZGRlZFxuICAgICAqL1xuICAgIGFkZE5ld0FjY291bnQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwcmltYXJ5S2V5cmluZyA9IHByaXZhdGVzXG4gICAgICAgICAgICAgICAgLmdldCh0aGlzKVxuICAgICAgICAgICAgICAgIC5rZXlyaW5nLmdldEtleXJpbmdzQnlUeXBlKCdIRCBLZXkgVHJlZScpWzBdO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXByaW1hcnlLZXlyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBIRCBrZXlyaW5nIGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvbGRBY2NvdW50cyA9IHlpZWxkIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICB5aWVsZCBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5hZGROZXdBY2NvdW50KHByaW1hcnlLZXlyaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FjY291bnRzID0geWllbGQgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMudmVyaWZ5U2VlZFBocmFzZSgpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJZGVudGl0aWVzKG5ld0FjY291bnRzKTtcbiAgICAgICAgICAgIG5ld0FjY291bnRzLmZvckVhY2goKHNlbGVjdGVkQWRkcmVzcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghb2xkQWNjb3VudHMuaW5jbHVkZXMoc2VsZWN0ZWRBZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGVkQWRkcmVzcyhzZWxlY3RlZEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBhY2NvdW50IHRvIHRoZSBkZWZhdWx0IChmaXJzdCkgSEQgc2VlZCBwaHJhc2Uga2V5cmluZyB3aXRob3V0IHVwZGF0aW5nIGlkZW50aXRpZXMgaW4gcHJlZmVyZW5jZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gY3VycmVudCBzdGF0ZSB3aGVuIHRoZSBhY2NvdW50IGlzIGFkZGVkXG4gICAgICovXG4gICAgYWRkTmV3QWNjb3VudFdpdGhvdXRVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwcmltYXJ5S2V5cmluZyA9IHByaXZhdGVzXG4gICAgICAgICAgICAgICAgLmdldCh0aGlzKVxuICAgICAgICAgICAgICAgIC5rZXlyaW5nLmdldEtleXJpbmdzQnlUeXBlKCdIRCBLZXkgVHJlZScpWzBdO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXByaW1hcnlLZXlyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBIRCBrZXlyaW5nIGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5hZGROZXdBY2NvdW50KHByaW1hcnlLZXlyaW5nKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMudmVyaWZ5U2VlZFBocmFzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgY3JlYXRpbmcgYSBuZXcga2V5Y2hhaW4gdGhlbiBwb3B1bGF0aW5nIGl0XG4gICAgICogdXNpbmcgdGhlIGdpdmVuIHNlZWQgcGhyYXNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgLSBQYXNzd29yZCB0byB1bmxvY2sga2V5Y2hhaW5cbiAgICAgKiBAcGFyYW0gc2VlZCAtIFNlZWQgcGhyYXNlIHRvIHJlc3RvcmUga2V5Y2hhaW5cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoIHJlc3RvcmVkIGtleWNoYWluIG9iamVjdFxuICAgICAqL1xuICAgIGNyZWF0ZU5ld1ZhdWx0QW5kUmVzdG9yZShwYXNzd29yZCwgc2VlZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJZGVudGl0aWVzKFtdKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXVsdCA9IHlpZWxkIHByaXZhdGVzXG4gICAgICAgICAgICAgICAgICAgIC5nZXQodGhpcylcbiAgICAgICAgICAgICAgICAgICAgLmtleXJpbmcuY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlKHBhc3N3b3JkLCBzZWVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUlkZW50aXRpZXMoeWllbGQgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuZ2V0QWNjb3VudHMoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mdWxsVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBwcmltYXJ5IGtleWNoYWluIGFuZCB3aXBlIGFueSBwcmV2aW91cyBrZXljaGFpbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCAtIFBhc3N3b3JkIHRvIHVubG9jayB0aGUgbmV3IHZhdWx0XG4gICAgICogQHJldHVybnMgLSBOZXdseS1jcmVhdGVkIGtleWNoYWluIG9iamVjdFxuICAgICAqL1xuICAgIGNyZWF0ZU5ld1ZhdWx0QW5kS2V5Y2hhaW4ocGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhdWx0ID0geWllbGQgcHJpdmF0ZXNcbiAgICAgICAgICAgICAgICAgICAgLmdldCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAua2V5cmluZy5jcmVhdGVOZXdWYXVsdEFuZEtleWNoYWluKHBhc3N3b3JkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUlkZW50aXRpZXMoeWllbGQgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuZ2V0QWNjb3VudHMoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mdWxsVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiB0aGUgdmF1bHRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gQm9vbGVhbiByZXR1cm5pbmcgdHJ1ZSBpZiB0aGUgdmF1bHQgaXMgdW5sb2NrZWRcbiAgICAgKi9cbiAgICBpc1VubG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcubWVtU3RvcmUuZ2V0U3RhdGUoKS5pc1VubG9ja2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzZWVkIHBocmFzZSBvZiB0aGUgSEQga2V5cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIC0gUGFzc3dvcmQgb2YgdGhlIGtleXJpbmdcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzZWVkIHBocmFzZVxuICAgICAqL1xuICAgIGV4cG9ydFNlZWRQaHJhc2UocGFzc3dvcmQpIHtcbiAgICAgICAgaWYgKHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLnBhc3N3b3JkID09PSBwYXNzd29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLmtleXJpbmdzWzBdLm1uZW1vbmljO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXNzd29yZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcml2YXRlIGtleSBmcm9tIHRoZSBrZXlyaW5nIGNvbnRyb2xsaW5nIGFuIGFkZHJlc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCAtIFBhc3N3b3JkIG9mIHRoZSBrZXlyaW5nXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBBZGRyZXNzIHRvIGV4cG9ydFxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHByaXZhdGUga2V5IGZvciBhbiBhZGRyZXNzXG4gICAgICovXG4gICAgZXhwb3J0QWNjb3VudChwYXNzd29yZCwgYWRkcmVzcykge1xuICAgICAgICBpZiAocHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcucGFzc3dvcmQgPT09IHBhc3N3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuZXhwb3J0QWNjb3VudChhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFzc3dvcmQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHVibGljIGFkZHJlc3NlcyBvZiBhbGwgYWNjb3VudHMgZm9yIHRoZSBjdXJyZW50IGtleXJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHJlc29sdmluZyB0byBhbiBhcnJheSBvZiBhZGRyZXNzZXNcbiAgICAgKi9cbiAgICBnZXRBY2NvdW50cygpIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcG9ydHMgYW4gYWNjb3VudCB3aXRoIHRoZSBzcGVjaWZpZWQgaW1wb3J0IHN0cmF0ZWd5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RyYXRlZ3kgLSBJbXBvcnQgc3RyYXRlZ3kgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIC0gQXJyYXkgb2YgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIHVuZGVybHlpbmcgc3RhdGVneVxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyB3aGVuIHBhc3NlZCBhbiB1bnJlY29nbml6ZWQgc3RyYXRlZ3lcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIGN1cnJlbnQgc3RhdGUgd2hlbiB0aGUgaW1wb3J0IGlzIGNvbXBsZXRlXG4gICAgICovXG4gICAgaW1wb3J0QWNjb3VudFdpdGhTdHJhdGVneShzdHJhdGVneSwgYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHByaXZhdGVLZXk7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncHJpdmF0ZUtleSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtpbXBvcnRlZEtleV0gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWltcG9ydGVkS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbXBvcnQgYW4gZW1wdHkga2V5LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkID0gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KGltcG9ydGVkS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXRoZXJldW1qc191dGlsXzEuaXNWYWxpZFByaXZhdGUoZXRoZXJldW1qc191dGlsXzEudG9CdWZmZXIocHJlZml4ZWQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW1wb3J0IGludmFsaWQgcHJpdmF0ZSBrZXkuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleSA9IGV0aGpzX3V0aWxfMS5zdHJpcEhleFByZWZpeChwcmVmaXhlZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgd2FsbGV0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbaW5wdXQsIHBhc3N3b3JkXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQgPSBldGhlcmV1bWpzX3dhbGxldF8xLnRoaXJkcGFydHkuZnJvbUV0aGVyV2FsbGV0KGlucHV0LCBwYXNzd29yZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldCA9IHdhbGxldCB8fCAoeWllbGQgZXRoZXJldW1qc193YWxsZXRfMS5kZWZhdWx0LmZyb21WMyhpbnB1dCwgcGFzc3dvcmQsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcml2YXRlS2V5ID0gZXRoZXJldW1qc191dGlsXzEuYnVmZmVyVG9IZXgod2FsbGV0LmdldFByaXZhdGVLZXkoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbXBvcnQgc3RyYXRlZ3k6ICcke3N0cmF0ZWd5fSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld0tleXJpbmcgPSB5aWVsZCBwcml2YXRlc1xuICAgICAgICAgICAgICAgIC5nZXQodGhpcylcbiAgICAgICAgICAgICAgICAua2V5cmluZy5hZGROZXdLZXlyaW5nKEtleXJpbmdUeXBlcy5zaW1wbGUsIFtwcml2YXRlS2V5XSk7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IHlpZWxkIG5ld0tleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbEFjY291bnRzID0geWllbGQgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSWRlbnRpdGllcyhhbGxBY2NvdW50cyk7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGVkQWRkcmVzcyhhY2NvdW50c1swXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdWxsVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGFjY291bnQgZnJvbSBrZXlyaW5nIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyBjdXJyZW50IHN0YXRlIHdoZW4gdGhpcyBhY2NvdW50IHJlbW92YWwgY29tcGxldGVzXG4gICAgICovXG4gICAgcmVtb3ZlQWNjb3VudChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUlkZW50aXR5KGFkZHJlc3MpO1xuICAgICAgICAgICAgeWllbGQgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcucmVtb3ZlQWNjb3VudChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlYWxsb2NhdGVzIGFsbCBzZWNyZXRzIGFuZCBsb2NrcyB0aGUgd2FsbGV0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIGN1cnJlbnQgc3RhdGVcbiAgICAgKi9cbiAgICBzZXRMb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5zZXRMb2NrZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBieSBjYWxsaW5nIGRvd24gaW50byBhIHNwZWNpZmljIGtleXJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gUGVyc29uYWxNZXNzYWdlUGFyYW1zIG9iamVjdCB0byBzaWduXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byBhIHNpZ25lZCBtZXNzYWdlIHN0cmluZ1xuICAgICAqL1xuICAgIHNpZ25NZXNzYWdlKG1lc3NhZ2VQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLnNpZ25NZXNzYWdlKG1lc3NhZ2VQYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBwZXJzb25hbCBtZXNzYWdlIGJ5IGNhbGxpbmcgZG93biBpbnRvIGEgc3BlY2lmaWMga2V5cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBQZXJzb25hbE1lc3NhZ2VQYXJhbXMgb2JqZWN0IHRvIHNpZ25cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgc2lnbmVkIG1lc3NhZ2Ugc3RyaW5nXG4gICAgICovXG4gICAgc2lnblBlcnNvbmFsTWVzc2FnZShtZXNzYWdlUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5zaWduUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2VQYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyB0eXBlZCBtZXNzYWdlIGJ5IGNhbGxpbmcgZG93biBpbnRvIGEgc3BlY2lmaWMga2V5cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUeXBlZE1lc3NhZ2VQYXJhbXMgb2JqZWN0IHRvIHNpZ25cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiAtIENvbXBhdGliaWxpdHkgdmVyc2lvbiBFSVA3MTJcbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgd2hlbiBwYXNzZWQgYW4gdW5yZWNvZ25pemVkIHZlcnNpb25cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgc2lnbmVkIG1lc3NhZ2Ugc3RyaW5nIG9yIGFuIGVycm9yIGlmIGFueVxuICAgICAqL1xuICAgIHNpZ25UeXBlZE1lc3NhZ2UobWVzc2FnZVBhcmFtcywgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gZXRoX3NpZ191dGlsXzEubm9ybWFsaXplKG1lc3NhZ2VQYXJhbXMuZnJvbSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXNzd29yZCB9ID0gcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmc7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IHlpZWxkIHRoaXMuZXhwb3J0QWNjb3VudChwYXNzd29yZCwgYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleUJ1ZmZlciA9IGV0aGVyZXVtanNfdXRpbF8xLnRvQnVmZmVyKGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChwcml2YXRlS2V5KSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU2lnblR5cGVkRGF0YVZlcnNpb24uVjE6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaWduVHlwZWREYXRhTGVnYWN5IHdpbGwgdGhyb3cgaWYgdGhlIGRhdGEgaXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldGhfc2lnX3V0aWxfMS5zaWduVHlwZWREYXRhTGVnYWN5KHByaXZhdGVLZXlCdWZmZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBtZXNzYWdlUGFyYW1zLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTaWduVHlwZWREYXRhVmVyc2lvbi5WMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldGhfc2lnX3V0aWxfMS5zaWduVHlwZWREYXRhKHByaXZhdGVLZXlCdWZmZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBKU09OLnBhcnNlKG1lc3NhZ2VQYXJhbXMuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTaWduVHlwZWREYXRhVmVyc2lvbi5WNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldGhfc2lnX3V0aWxfMS5zaWduVHlwZWREYXRhX3Y0KHByaXZhdGVLZXlCdWZmZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBKU09OLnBhcnNlKG1lc3NhZ2VQYXJhbXMuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBzaWduVHlwZWRNZXNzYWdlIHZlcnNpb246ICcke3ZlcnNpb259J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5cmluZyBDb250cm9sbGVyIHNpZ25UeXBlZE1lc3NhZ2U6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBhIHRyYW5zYWN0aW9uIGJ5IGNhbGxpbmcgZG93biBpbnRvIGEgc3BlY2lmaWMga2V5cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gb2JqZWN0IHRvIHNpZ24uIE11c3QgYmUgYSBgZXRoZXJldW1qcy10eGAgdHJhbnNhY3Rpb24gaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIGZyb20gLSBBZGRyZXNzIHRvIHNpZ24gZnJvbSwgc2hvdWxkIGJlIGluIGtleWNoYWluXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byBhIHNpZ25lZCB0cmFuc2FjdGlvbiBzdHJpbmdcbiAgICAgKi9cbiAgICBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGZyb20pIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGRlY3J5cHQgdGhlIGN1cnJlbnQgdmF1bHQgYW5kIGxvYWQgaXRzIGtleXJpbmdzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgLSBQYXNzd29yZCB0byB1bmxvY2sgdGhlIGtleWNoYWluXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAqL1xuICAgIHN1Ym1pdFBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5zdWJtaXRQYXNzd29yZChwYXNzd29yZCk7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IHlpZWxkIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnN5bmNJZGVudGl0aWVzKGFjY291bnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGxpc3RlbmVyIHRvIGJlIG5vdGlmaWVkIG9mIHN0YXRlIGNoYW5nZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIENhbGxiYWNrIHRyaWdnZXJlZCB3aGVuIHN0YXRlIGNoYW5nZXNcbiAgICAgKi9cbiAgICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICAgICAgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuc3RvcmUuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBleGlzdGluZyBsaXN0ZW5lciBmcm9tIHJlY2VpdmluZyBzdGF0ZSBjaGFuZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBDYWxsYmFjayB0byByZW1vdmVcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgYSBsaXN0ZW5lciBpcyBmb3VuZCBhbmQgdW5zdWJzY3JpYmVkXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLnN0b3JlLnVuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBuZXcgbGlzdGVuZXIgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgd2FsbGV0IGlzIGxvY2tlZFxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gQ2FsbGJhY2sgdHJpZ2dlcmVkIHdoZW4gd2FsbGV0IGlzIGxvY2tlZFxuICAgICAqIEByZXR1cm5zIC0gRXZlbnRFbWl0dGVyIGlmIGxpc3RlbmVyIGFkZGVkXG4gICAgICovXG4gICAgb25Mb2NrKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5vbignbG9jaycsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBuZXcgbGlzdGVuZXIgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgd2FsbGV0IGlzIHVubG9ja2VkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBDYWxsYmFjayB0cmlnZ2VyZWQgd2hlbiB3YWxsZXQgaXMgdW5sb2NrZWRcbiAgICAgKiBAcmV0dXJucyAtIEV2ZW50RW1pdHRlciBpZiBsaXN0ZW5lciBhZGRlZFxuICAgICAqL1xuICAgIG9uVW5sb2NrKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5vbigndW5sb2NrJywgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGUgdGhhdCB0aGUgc2VlZCBwaHJhc2UgcmVzdG9yZXMgdGhlIGN1cnJlbnQga2V5Y2hhaW4ncyBhY2NvdW50c1xuICAgICAqXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyBpZiB0aGUgdmVyaWZpY2F0aW9uIHN1Y2NlZWRzXG4gICAgICovXG4gICAgdmVyaWZ5U2VlZFBocmFzZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByaW1hcnlLZXlyaW5nID0gcHJpdmF0ZXNcbiAgICAgICAgICAgICAgICAuZ2V0KHRoaXMpXG4gICAgICAgICAgICAgICAgLmtleXJpbmcuZ2V0S2V5cmluZ3NCeVR5cGUoS2V5cmluZ1R5cGVzLmhkKVswXTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFwcmltYXJ5S2V5cmluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gSEQga2V5cmluZyBmb3VuZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlZWRXb3JkcyA9ICh5aWVsZCBwcmltYXJ5S2V5cmluZy5zZXJpYWxpemUoKSkubW5lbW9uaWM7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IHlpZWxkIHByaW1hcnlLZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB2ZXJpZnkgYW4gZW1wdHkga2V5cmluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFRlc3RLZXlyaW5nQ2xhc3MgPSBwcml2YXRlc1xuICAgICAgICAgICAgICAgIC5nZXQodGhpcylcbiAgICAgICAgICAgICAgICAua2V5cmluZy5nZXRLZXlyaW5nQ2xhc3NGb3JUeXBlKEtleXJpbmdUeXBlcy5oZCk7XG4gICAgICAgICAgICBjb25zdCB0ZXN0S2V5cmluZyA9IG5ldyBUZXN0S2V5cmluZ0NsYXNzKHtcbiAgICAgICAgICAgICAgICBtbmVtb25pYzogc2VlZFdvcmRzLFxuICAgICAgICAgICAgICAgIG51bWJlck9mQWNjb3VudHM6IGFjY291bnRzLmxlbmd0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdGVzdEFjY291bnRzID0geWllbGQgdGVzdEtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRlc3RBY2NvdW50cy5sZW5ndGggIT09IGFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VlZCBwaHJhc2UgaW1wb3J0ZWQgaW5jb3JyZWN0IG51bWJlciBvZiBhY2NvdW50cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlc3RBY2NvdW50cy5mb3JFYWNoKChhY2NvdW50LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKGFjY291bnQudG9Mb3dlckNhc2UoKSAhPT0gYWNjb3VudHNbaV0udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlZWQgcGhyYXNlIGltcG9ydGVkIGRpZmZlcmVudCBhY2NvdW50cy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzZWVkV29yZHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUga2V5cmluZ3MgaW4gc3RhdGUgYW5kIGNhbGxzIEtleXJpbmdDb250cm9sbGVyIGZ1bGxVcGRhdGUgbWV0aG9kIHJldHVybmluZyBjdXJyZW50IHN0YXRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIGN1cnJlbnQgc3RhdGVcbiAgICAgKi9cbiAgICBmdWxsVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qga2V5cmluZ3MgPSB5aWVsZCBQcm9taXNlLmFsbChwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5rZXlyaW5ncy5tYXAoKGtleXJpbmcsIGluZGV4KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cmluZ0FjY291bnRzID0geWllbGQga2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gQXJyYXkuaXNBcnJheShrZXlyaW5nQWNjb3VudHMpXG4gICAgICAgICAgICAgICAgICAgID8ga2V5cmluZ0FjY291bnRzLm1hcCgoYWRkcmVzcykgPT4gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpKVxuICAgICAgICAgICAgICAgICAgICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZToga2V5cmluZy50eXBlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBrZXlyaW5nczogWy4uLmtleXJpbmdzXSB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5mdWxsVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuS2V5cmluZ0NvbnRyb2xsZXIgPSBLZXlyaW5nQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEtleXJpbmdDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S2V5cmluZ0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNhY3Rpb25Db250cm9sbGVyID0gZXhwb3J0cy5TUEVFRF9VUF9SQVRFID0gZXhwb3J0cy5DQU5DRUxfUkFURSA9IGV4cG9ydHMuV2FsbGV0RGV2aWNlID0gZXhwb3J0cy5UcmFuc2FjdGlvblN0YXR1cyA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCBldGhfbWV0aG9kX3JlZ2lzdHJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aC1tZXRob2QtcmVnaXN0cnlcIikpO1xuY29uc3QgZXRoX3F1ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aC1xdWVyeVwiKSk7XG5jb25zdCBjb21tb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQGV0aGVyZXVtanMvY29tbW9uXCIpKTtcbmNvbnN0IHR4XzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdHhcIik7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbmNvbnN0IGFzeW5jX211dGV4XzEgPSByZXF1aXJlKFwiYXN5bmMtbXV0ZXhcIik7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5jb25zdCBIQVJERk9SSyA9ICdsb25kb24nO1xuLyoqXG4gKiBUaGUgc3RhdHVzIG9mIHRoZSB0cmFuc2FjdGlvbi4gRWFjaCBzdGF0dXMgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIHRyYW5zYWN0aW9uIGludGVybmFsbHlcbiAqIGluIHRoZSB3YWxsZXQuIFNvbWUgb2YgdGhlc2UgY29ycmVzcG9uZCB3aXRoIHRoZSBzdGF0ZSBvZiB0aGUgdHJhbnNhY3Rpb24gb24gdGhlIG5ldHdvcmssIGJ1dFxuICogc29tZSBhcmUgd2FsbGV0LXNwZWNpZmljLlxuICovXG52YXIgVHJhbnNhY3Rpb25TdGF0dXM7XG4oZnVuY3Rpb24gKFRyYW5zYWN0aW9uU3RhdHVzKSB7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJhcHByb3ZlZFwiXSA9IFwiYXBwcm92ZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcImNhbmNlbGxlZFwiXSA9IFwiY2FuY2VsbGVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJjb25maXJtZWRcIl0gPSBcImNvbmZpcm1lZFwiO1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1wiZmFpbGVkXCJdID0gXCJmYWlsZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcInJlamVjdGVkXCJdID0gXCJyZWplY3RlZFwiO1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1wic2lnbmVkXCJdID0gXCJzaWduZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcInN1Ym1pdHRlZFwiXSA9IFwic3VibWl0dGVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJ1bmFwcHJvdmVkXCJdID0gXCJ1bmFwcHJvdmVkXCI7XG59KShUcmFuc2FjdGlvblN0YXR1cyA9IGV4cG9ydHMuVHJhbnNhY3Rpb25TdGF0dXMgfHwgKGV4cG9ydHMuVHJhbnNhY3Rpb25TdGF0dXMgPSB7fSkpO1xuLyoqXG4gKiBPcHRpb25zIGZvciB3YWxsZXQgZGV2aWNlLlxuICovXG52YXIgV2FsbGV0RGV2aWNlO1xuKGZ1bmN0aW9uIChXYWxsZXREZXZpY2UpIHtcbiAgICBXYWxsZXREZXZpY2VbXCJNTV9NT0JJTEVcIl0gPSBcIm1ldGFtYXNrX21vYmlsZVwiO1xuICAgIFdhbGxldERldmljZVtcIk1NX0VYVEVOU0lPTlwiXSA9IFwibWV0YW1hc2tfZXh0ZW5zaW9uXCI7XG4gICAgV2FsbGV0RGV2aWNlW1wiT1RIRVJcIl0gPSBcIm90aGVyX2RldmljZVwiO1xufSkoV2FsbGV0RGV2aWNlID0gZXhwb3J0cy5XYWxsZXREZXZpY2UgfHwgKGV4cG9ydHMuV2FsbGV0RGV2aWNlID0ge30pKTtcbi8qKlxuICogTXVsdGlwbGllciB1c2VkIHRvIGRldGVybWluZSBhIHRyYW5zYWN0aW9uJ3MgaW5jcmVhc2VkIGdhcyBmZWUgZHVyaW5nIGNhbmNlbGxhdGlvblxuICovXG5leHBvcnRzLkNBTkNFTF9SQVRFID0gMS41O1xuLyoqXG4gKiBNdWx0aXBsaWVyIHVzZWQgdG8gZGV0ZXJtaW5lIGEgdHJhbnNhY3Rpb24ncyBpbmNyZWFzZWQgZ2FzIGZlZSBkdXJpbmcgc3BlZWQgdXBcbiAqL1xuZXhwb3J0cy5TUEVFRF9VUF9SQVRFID0gMS4xO1xuLyoqXG4gKiBDb250cm9sbGVyIHJlc3BvbnNpYmxlIGZvciBzdWJtaXR0aW5nIGFuZCBtYW5hZ2luZyB0cmFuc2FjdGlvbnNcbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb25Db250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFRyYW5zYWN0aW9uQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXROZXR3b3JrU3RhdGUgLSBHZXRzIHRoZSBzdGF0ZSBvZiB0aGUgbmV0d29yayBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25OZXR3b3JrU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gbmV0d29yayBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRQcm92aWRlciAtIFJldHVybnMgYSBwcm92aWRlciBmb3IgdGhlIGN1cnJlbnQgbmV0d29ya1xuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBnZXROZXR3b3JrU3RhdGUsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBnZXRQcm92aWRlciwgfSwgY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIHRoaXMubm9ybWFsaXplVG9rZW5UeCA9ICh0eE1ldGEsIGN1cnJlbnROZXR3b3JrSUQsIGN1cnJlbnRDaGFpbklkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lID0gcGFyc2VJbnQodHhNZXRhLnRpbWVTdGFtcCwgMTApICogMTAwMDtcbiAgICAgICAgICAgIGNvbnN0IHsgdG8sIGZyb20sIGdhcywgZ2FzUHJpY2UsIGdhc1VzZWQsIGhhc2gsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5EZWNpbWFsLCB0b2tlblN5bWJvbCwgdmFsdWUsIH0gPSB0eE1ldGE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiB1dWlkXzEudjEoeyBtc2VjczogdGltZSB9KSxcbiAgICAgICAgICAgICAgICBpc1RyYW5zZmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtJRDogY3VycmVudE5ldHdvcmtJRCxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBjdXJyZW50Q2hhaW5JZCxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFRyYW5zYWN0aW9uU3RhdHVzLmNvbmZpcm1lZCxcbiAgICAgICAgICAgICAgICB0aW1lLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IDEsXG4gICAgICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgICAgIGdhcyxcbiAgICAgICAgICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIGdhc1VzZWQsXG4gICAgICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogaGFzaCxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlckluZm9ybWF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IE51bWJlcih0b2tlbkRlY2ltYWwpLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IHRva2VuU3ltYm9sLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmVyaWZpZWRPbkJsb2NrY2hhaW46IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50RW1pdHRlciBpbnN0YW5jZSB1c2VkIHRvIGxpc3RlbiB0byBzcGVjaWZpYyB0cmFuc2FjdGlvbmFsIGV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5odWIgPSBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ1RyYW5zYWN0aW9uQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgIGludGVydmFsOiAxNTAwMCxcbiAgICAgICAgICAgIHR4SGlzdG9yeUxpbWl0OiA0MCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICAgICAgICBtZXRob2REYXRhOiB7fSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uczogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICAgIHRoaXMuZ2V0TmV0d29ya1N0YXRlID0gZ2V0TmV0d29ya1N0YXRlO1xuICAgICAgICB0aGlzLmV0aFF1ZXJ5ID0gbmV3IGV0aF9xdWVyeV8xLmRlZmF1bHQocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0gbmV3IGV0aF9tZXRob2RfcmVnaXN0cnlfMS5kZWZhdWx0KHsgcHJvdmlkZXIgfSk7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZXRoUXVlcnkgPSBuZXcgZXRoX3F1ZXJ5XzEuZGVmYXVsdChuZXdQcm92aWRlcik7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0gbmV3IGV0aF9tZXRob2RfcmVnaXN0cnlfMS5kZWZhdWx0KHsgcHJvdmlkZXI6IG5ld1Byb3ZpZGVyIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfVxuICAgIGZhaWxUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEsIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG5ld1RyYW5zYWN0aW9uTWV0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb25NZXRhKSwgeyBlcnJvciwgc3RhdHVzOiBUcmFuc2FjdGlvblN0YXR1cy5mYWlsZWQgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNhY3Rpb24obmV3VHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgdGhpcy5odWIuZW1pdChgJHt0cmFuc2FjdGlvbk1ldGEuaWR9OmZpbmlzaGVkYCwgbmV3VHJhbnNhY3Rpb25NZXRhKTtcbiAgICB9XG4gICAgcmVnaXN0cnlMb29rdXAoZm91ckJ5dGVQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJ5TWV0aG9kID0geWllbGQgdGhpcy5yZWdpc3RyeS5sb29rdXAoZm91ckJ5dGVQcmVmaXgpO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkUmVnaXN0cnlNZXRob2QgPSB0aGlzLnJlZ2lzdHJ5LnBhcnNlKHJlZ2lzdHJ5TWV0aG9kKTtcbiAgICAgICAgICAgIHJldHVybiB7IHJlZ2lzdHJ5TWV0aG9kLCBwYXJzZWRSZWdpc3RyeU1ldGhvZCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGUgdHJhbnNhY3Rpb24gaW5mb3JtYXRpb24gZnJvbSBldGhlcnNjYW5cbiAgICAgKiB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIFRyYW5zYWN0aW9uTWV0YSBpbnRlcmZhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eE1ldGEgLSBPYmplY3QgY29udGFpbmluZyB0aGUgdHJhbnNhY3Rpb24gaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0gY3VycmVudE5ldHdvcmtJRCAtIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgbmV0d29yayBpZFxuICAgICAqIEBwYXJhbSBjdXJyZW50Q2hhaW5JZCAtIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgY2hhaW4gaWRcbiAgICAgKiBAcmV0dXJucyAtIFRyYW5zYWN0aW9uTWV0YVxuICAgICAqL1xuICAgIG5vcm1hbGl6ZVR4KHR4TWV0YSwgY3VycmVudE5ldHdvcmtJRCwgY3VycmVudENoYWluSWQpIHtcbiAgICAgICAgY29uc3QgdGltZSA9IHBhcnNlSW50KHR4TWV0YS50aW1lU3RhbXAsIDEwKSAqIDEwMDA7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUcmFuc2FjdGlvbkJhc2UgPSB7XG4gICAgICAgICAgICBibG9ja051bWJlcjogdHhNZXRhLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgaWQ6IHV1aWRfMS52MSh7IG1zZWNzOiB0aW1lIH0pLFxuICAgICAgICAgICAgbmV0d29ya0lEOiBjdXJyZW50TmV0d29ya0lELFxuICAgICAgICAgICAgY2hhaW5JZDogY3VycmVudENoYWluSWQsXG4gICAgICAgICAgICB0aW1lLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0eE1ldGEuaW5wdXQsXG4gICAgICAgICAgICAgICAgZnJvbTogdHhNZXRhLmZyb20sXG4gICAgICAgICAgICAgICAgZ2FzOiB1dGlsXzEuQk5Ub0hleChuZXcgZXRoZXJldW1qc191dGlsXzEuQk4odHhNZXRhLmdhcykpLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiB1dGlsXzEuQk5Ub0hleChuZXcgZXRoZXJldW1qc191dGlsXzEuQk4odHhNZXRhLmdhc1ByaWNlKSksXG4gICAgICAgICAgICAgICAgZ2FzVXNlZDogdXRpbF8xLkJOVG9IZXgobmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKHR4TWV0YS5nYXNVc2VkKSksXG4gICAgICAgICAgICAgICAgbm9uY2U6IHV0aWxfMS5CTlRvSGV4KG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTih0eE1ldGEubm9uY2UpKSxcbiAgICAgICAgICAgICAgICB0bzogdHhNZXRhLnRvLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1dGlsXzEuQk5Ub0hleChuZXcgZXRoZXJldW1qc191dGlsXzEuQk4odHhNZXRhLnZhbHVlKSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiB0eE1ldGEuaGFzaCxcbiAgICAgICAgICAgIHZlcmlmaWVkT25CbG9ja2NoYWluOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHR4TWV0YS5pc0Vycm9yID09PSAnMCcpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5vcm1hbGl6ZWRUcmFuc2FjdGlvbkJhc2UpLCB7IHN0YXR1czogVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5vcm1hbGl6ZWRUcmFuc2FjdGlvbkJhc2UpLCB7IGVycm9yOiBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZhaWxlZCcpLCBzdGF0dXM6IFRyYW5zYWN0aW9uU3RhdHVzLmZhaWxlZCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgbmV3IHBvbGxpbmcgaW50ZXJ2YWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbCAtIFBvbGxpbmcgaW50ZXJ2YWwgdXNlZCB0byBmZXRjaCBuZXcgdHJhbnNhY3Rpb24gc3RhdHVzZXNcbiAgICAgKi9cbiAgICBwb2xsKGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCAmJiB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSAmJiBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgICAgICAgICAgeWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gdGhpcy5xdWVyeVRyYW5zYWN0aW9uU3RhdHVzZXMoKSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucG9sbCh0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgICAgICB9LCB0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgbmV3IG1ldGhvZCBkYXRhIHJlcXVlc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3VyQnl0ZVByZWZpeCAtIFN0cmluZyBjb3JyZXNwb25kaW5nIHRvIG1ldGhvZCBwcmVmaXhcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIG1ldGhvZCBkYXRhIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHNpZ25hdHVyZSBwcmVmaXhcbiAgICAgKi9cbiAgICBoYW5kbGVNZXRob2REYXRhKGZvdXJCeXRlUHJlZml4KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG1ldGhvZERhdGEgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3Qga25vd25NZXRob2QgPSBPYmplY3Qua2V5cyhtZXRob2REYXRhKS5maW5kKChrbm93bkZvdXJCeXRlUHJlZml4KSA9PiBmb3VyQnl0ZVByZWZpeCA9PT0ga25vd25Gb3VyQnl0ZVByZWZpeCk7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2REYXRhW2ZvdXJCeXRlUHJlZml4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnaXN0cnkgPSB5aWVsZCB0aGlzLnJlZ2lzdHJ5TG9va3VwKGZvdXJCeXRlUHJlZml4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZERhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWV0aG9kRGF0YSksIHsgW2ZvdXJCeXRlUHJlZml4XTogcmVnaXN0cnkgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyB1bmFwcHJvdmVkIHRyYW5zYWN0aW9uIHRvIHN0YXRlLiBQYXJhbWV0ZXJzIHdpbGwgYmUgdmFsaWRhdGVkLCBhXG4gICAgICogdW5pcXVlIHRyYW5zYWN0aW9uIGlkIHdpbGwgYmUgZ2VuZXJhdGVkLCBhbmQgZ2FzIGFuZCBnYXNQcmljZSB3aWxsIGJlIGNhbGN1bGF0ZWRcbiAgICAgKiBpZiBub3QgcHJvdmlkZWQuIElmIEEgYDx0eC5pZD46dW5hcHByb3ZlZGAgaHViIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCBvbmNlIGFkZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gb2JqZWN0IHRvIGFkZFxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBEb21haW4gb3JpZ2luIHRvIGFwcGVuZCB0byB0aGUgZ2VuZXJhdGVkIFRyYW5zYWN0aW9uTWV0YVxuICAgICAqIEBwYXJhbSBkZXZpY2VDb25maXJtZWRPbiAtIGVudW0gdG8gaW5kaWNhdGUgd2hhdCBkZXZpY2UgdGhlIHRyYW5zYWN0aW9uIHdhcyBjb25maXJtZWQgdG8gYXBwZW5kIHRvIHRoZSBnZW5lcmF0ZWQgVHJhbnNhY3Rpb25NZXRhXG4gICAgICogQHJldHVybnMgLSBPYmplY3QgY29udGFpbmluZyBhIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0cmFuc2FjdGlvbiBoYXNoIGlmIGFwcHJvdmVkXG4gICAgICovXG4gICAgYWRkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG9yaWdpbiwgZGV2aWNlQ29uZmlybWVkT24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIG5ldHdvcmsgfSA9IHRoaXMuZ2V0TmV0d29ya1N0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gdXRpbF8xLm5vcm1hbGl6ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIHV0aWxfMS52YWxpZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uTWV0YSA9IHtcbiAgICAgICAgICAgICAgICBpZDogdXVpZF8xLnYxKCksXG4gICAgICAgICAgICAgICAgbmV0d29ya0lEOiBuZXR3b3JrLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IHByb3ZpZGVyLmNoYWluSWQsXG4gICAgICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgICAgIHN0YXR1czogVHJhbnNhY3Rpb25TdGF0dXMudW5hcHByb3ZlZCxcbiAgICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgIGRldmljZUNvbmZpcm1lZE9uLFxuICAgICAgICAgICAgICAgIHZlcmlmaWVkT25CbG9ja2NoYWluOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZ2FzIH0gPSB5aWVsZCB0aGlzLmVzdGltYXRlR2FzKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5nYXMgPSBnYXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaHViLm9uY2UoYCR7dHJhbnNhY3Rpb25NZXRhLmlkfTpmaW5pc2hlZGAsIChtZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWV0YS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG1ldGEudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0dXMucmVqZWN0ZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCdVc2VyIHJlamVjdGVkIHRoZSB0cmFuc2FjdGlvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0dXMuY2FuY2VsbGVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKCdVc2VyIGNhbmNlbGxlZCB0aGUgdHJhbnNhY3Rpb24nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdHVzLmZhaWxlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChtZXRhLmVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKGBNZXRhTWFzayBUeCBTaWduYXR1cmU6IFVua25vd24gcHJvYmxlbTogJHtKU09OLnN0cmluZ2lmeShtZXRhKX1gKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLnB1c2godHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgdHJhbnNhY3Rpb25zOiB0aGlzLnRyaW1UcmFuc2FjdGlvbnNGb3JTdGF0ZSh0cmFuc2FjdGlvbnMpIH0pO1xuICAgICAgICAgICAgdGhpcy5odWIuZW1pdChgdW5hcHByb3ZlZFRyYW5zYWN0aW9uYCwgdHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdCwgdHJhbnNhY3Rpb25NZXRhIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcmVwYXJlVW5zaWduZWRFdGhUeCh0eFBhcmFtcykge1xuICAgICAgICByZXR1cm4gdHhfMS5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVR4RGF0YSh0eFBhcmFtcywge1xuICAgICAgICAgICAgY29tbW9uOiB0aGlzLmdldENvbW1vbkNvbmZpZ3VyYXRpb24oKSxcbiAgICAgICAgICAgIGZyZWV6ZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZXRoZXJldW1qcy90eCB1c2VzIEBldGhlcmV1bWpzL2NvbW1vbiBhcyBhIGNvbmZpZ3VyYXRpb24gdG9vbCBmb3JcbiAgICAgKiBzcGVjaWZ5aW5nIHdoaWNoIGNoYWluLCBuZXR3b3JrLCBoYXJkZm9yayBhbmQgRUlQcyB0byBzdXBwb3J0IGZvclxuICAgICAqIGEgdHJhbnNhY3Rpb24uIEJ5IHJlZmVyZW5jaW5nIHRoaXMgY29uZmlndXJhdGlvbiwgYW5kIGFuYWx5emluZyB0aGUgZmllbGRzXG4gICAgICogc3BlY2lmaWVkIGluIHR4UGFyYW1zLCBAZXRoZXJldW1qcy90eCBpcyBhYmxlIHRvIGRldGVybWluZSB3aGljaCBFSVAtMjcxOFxuICAgICAqIHRyYW5zYWN0aW9uIHR5cGUgdG8gdXNlLlxuICAgICAqIEByZXR1cm5zIHtDb21tb259IGNvbW1vbiBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIGdldENvbW1vbkNvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yazogbmV0d29ya0lkLCBwcm92aWRlcjogeyB0eXBlOiBjaGFpbiwgY2hhaW5JZCwgbmlja25hbWU6IG5hbWUgfSwgfSA9IHRoaXMuZ2V0TmV0d29ya1N0YXRlKCk7XG4gICAgICAgIGlmIChjaGFpbiAhPT0gY29uc3RhbnRzXzEuUlBDKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvbW1vbl8xLmRlZmF1bHQoeyBjaGFpbiwgaGFyZGZvcms6IEhBUkRGT1JLIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1c3RvbUNoYWluUGFyYW1zID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGNoYWluSWQ6IHBhcnNlSW50KGNoYWluSWQsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KG5ldHdvcmtJZCwgdW5kZWZpbmVkKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmRlZmF1bHQuZm9yQ3VzdG9tQ2hhaW4oY29uc3RhbnRzXzEuTUFJTk5FVCwgY3VzdG9tQ2hhaW5QYXJhbXMsIEhBUkRGT1JLKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwcm92ZXMgYSB0cmFuc2FjdGlvbiBhbmQgdXBkYXRlcyBpdCdzIHN0YXR1cyBpbiBzdGF0ZS4gSWYgdGhpcyBpcyBub3QgYVxuICAgICAqIHJldHJ5IHRyYW5zYWN0aW9uLCBhIG5vbmNlIHdpbGwgYmUgZ2VuZXJhdGVkLiBUaGUgdHJhbnNhY3Rpb24gaXMgc2lnbmVkXG4gICAgICogdXNpbmcgdGhlIHNpZ24gY29uZmlndXJhdGlvbiBwcm9wZXJ0eSwgdGhlbiBwdWJsaXNoZWQgdG8gdGhlIGJsb2NrY2hhaW4uXG4gICAgICogQSBgPHR4LmlkPjpmaW5pc2hlZGAgaHViIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHN1Y2Nlc3Mgb3IgZmFpbHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbklEIC0gSUQgb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGFwcHJvdmVcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhpcyBvcGVyYXRpb24gY29tcGxldGVzXG4gICAgICovXG4gICAgYXBwcm92ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSUQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXIgfSA9IHRoaXMuZ2V0TmV0d29ya1N0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCB7IGNoYWluSWQ6IGN1cnJlbnRDaGFpbklkIH0gPSBwcm92aWRlcjtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdHJhbnNhY3Rpb25zLmZpbmRJbmRleCgoeyBpZCB9KSA9PiB0cmFuc2FjdGlvbklEID09PSBpZCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbk1ldGEgPSB0cmFuc2FjdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgeyBub25jZSB9ID0gdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZyb20gfSA9IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2lnbikge1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEsIG5ldyBFcnJvcignTm8gc2lnbiBtZXRob2QgZGVmaW5lZC4nKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnJlbnRDaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YSwgbmV3IEVycm9yKCdObyBjaGFpbklkIGRlZmluZWQuJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBwYXJzZUludChjdXJyZW50Q2hhaW5JZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFwcHJvdmVkOiBzdGF0dXMgfSA9IFRyYW5zYWN0aW9uU3RhdHVzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4Tm9uY2UgPSBub25jZSB8fFxuICAgICAgICAgICAgICAgICAgICAoeWllbGQgdXRpbF8xLnF1ZXJ5KHRoaXMuZXRoUXVlcnksICdnZXRUcmFuc2FjdGlvbkNvdW50JywgW2Zyb20sICdwZW5kaW5nJ10pKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbk1ldGEuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5ub25jZSA9IHR4Tm9uY2U7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VUeFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKSwgeyBnYXNMaW1pdDogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmdhcywgY2hhaW5JZCwgbm9uY2U6IHR4Tm9uY2UsIHN0YXR1cyB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0VJUDE1NTkgPSB1dGlsXzEuaXNFSVAxNTU5VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eFBhcmFtcyA9IGlzRUlQMTU1OVxuICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFzZVR4UGFyYW1zKSwgeyBtYXhGZWVQZXJHYXM6IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMsIGVzdGltYXRlZEJhc2VGZWU6IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5lc3RpbWF0ZWRCYXNlRmVlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZnkgdHlwZSAyIGlmIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgYXJlIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMiB9KSA6IGJhc2VUeFBhcmFtcztcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgZ2FzUHJpY2UgaWYgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhcyBhcmUgc2V0XG4gICAgICAgICAgICAgICAgaWYgKGlzRUlQMTU1OSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHhQYXJhbXMuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkRXRoVHggPSB0aGlzLnByZXBhcmVVbnNpZ25lZEV0aFR4KHR4UGFyYW1zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRUeCA9IHlpZWxkIHRoaXMuc2lnbih1bnNpZ25lZEV0aFR4LCBmcm9tKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbk1ldGEuc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuc2lnbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYXdUcmFuc2FjdGlvbiA9IGV0aGVyZXVtanNfdXRpbF8xLmJ1ZmZlclRvSGV4KHNpZ25lZFR4LnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbk1ldGEucmF3VHJhbnNhY3Rpb24gPSByYXdUcmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25IYXNoID0geWllbGQgdXRpbF8xLnF1ZXJ5KHRoaXMuZXRoUXVlcnksICdzZW5kUmF3VHJhbnNhY3Rpb24nLCBbXG4gICAgICAgICAgICAgICAgICAgIHJhd1RyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbkhhc2ggPSB0cmFuc2FjdGlvbkhhc2g7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25NZXRhLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5odWIuZW1pdChgJHt0cmFuc2FjdGlvbk1ldGEuaWR9OmZpbmlzaGVkYCwgdHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmFpbFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYSB0cmFuc2FjdGlvbiBiYXNlZCBvbiBpdHMgSUQgYnkgc2V0dGluZyBpdHMgc3RhdHVzIHRvIFwicmVqZWN0ZWRcIlxuICAgICAqIGFuZCBlbWl0dGluZyBhIGA8dHguaWQ+OmZpbmlzaGVkYCBodWIgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25JRCAtIElEIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBjYW5jZWxcbiAgICAgKi9cbiAgICBjYW5jZWxUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklEKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uTWV0YSA9IHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zLmZpbmQoKHsgaWQgfSkgPT4gaWQgPT09IHRyYW5zYWN0aW9uSUQpO1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uTWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zYWN0aW9uTWV0YS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5yZWplY3RlZDtcbiAgICAgICAgdGhpcy5odWIuZW1pdChgJHt0cmFuc2FjdGlvbk1ldGEuaWR9OmZpbmlzaGVkYCwgdHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gdGhpcy5zdGF0ZS50cmFuc2FjdGlvbnMuZmlsdGVyKCh7IGlkIH0pID0+IGlkICE9PSB0cmFuc2FjdGlvbklEKTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyB0cmFuc2FjdGlvbnM6IHRoaXMudHJpbVRyYW5zYWN0aW9uc0ZvclN0YXRlKHRyYW5zYWN0aW9ucykgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGNhbmNlbCBhIHRyYW5zYWN0aW9uIGJhc2VkIG9uIGl0cyBJRCBieSBzZXR0aW5nIGl0cyBzdGF0dXMgdG8gXCJyZWplY3RlZFwiXG4gICAgICogYW5kIGVtaXR0aW5nIGEgYDx0eC5pZD46ZmluaXNoZWRgIGh1YiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbklEIC0gSUQgb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGNhbmNlbFxuICAgICAqL1xuICAgIHN0b3BUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklELCBnYXNWYWx1ZXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChnYXNWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVHYXNWYWx1ZXMoZ2FzVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uTWV0YSA9IHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zLmZpbmQoKHsgaWQgfSkgPT4gaWQgPT09IHRyYW5zYWN0aW9uSUQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2FjdGlvbk1ldGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2lnbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbiBtZXRob2QgZGVmaW5lZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGdhc1ByaWNlIChsZWdhY3kgbm9uIEVJUDE1NTkpXG4gICAgICAgICAgICBjb25zdCBtaW5HYXNQcmljZSA9IHV0aWxfMS5nZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZyh0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZ2FzUHJpY2UsIGV4cG9ydHMuQ0FOQ0VMX1JBVEUpO1xuICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2VGcm9tVmFsdWVzID0gdXRpbF8xLmlzR2FzUHJpY2VWYWx1ZShnYXNWYWx1ZXMpICYmIGdhc1ZhbHVlcy5nYXNQcmljZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0dhc1ByaWNlID0gKGdhc1ByaWNlRnJvbVZhbHVlcyAmJlxuICAgICAgICAgICAgICAgIHV0aWxfMS52YWxpZGF0ZU1pbmltdW1JbmNyZWFzZShnYXNQcmljZUZyb21WYWx1ZXMsIG1pbkdhc1ByaWNlKSkgfHxcbiAgICAgICAgICAgICAgICBtaW5HYXNQcmljZTtcbiAgICAgICAgICAgIC8vIG1heEZlZVBlckdhcyAoRUlQMTU1OSlcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTWF4RmVlUGVyR2FzID0gKF9hID0gdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbWluTWF4RmVlUGVyR2FzID0gdXRpbF8xLmdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nKGV4aXN0aW5nTWF4RmVlUGVyR2FzLCBleHBvcnRzLkNBTkNFTF9SQVRFKTtcbiAgICAgICAgICAgIGNvbnN0IG1heEZlZVBlckdhc1ZhbHVlcyA9IHV0aWxfMS5pc0ZlZU1hcmtldEVJUDE1NTlWYWx1ZXMoZ2FzVmFsdWVzKSAmJiBnYXNWYWx1ZXMubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbmV3TWF4RmVlUGVyR2FzID0gKG1heEZlZVBlckdhc1ZhbHVlcyAmJlxuICAgICAgICAgICAgICAgIHV0aWxfMS52YWxpZGF0ZU1pbmltdW1JbmNyZWFzZShtYXhGZWVQZXJHYXNWYWx1ZXMsIG1pbk1heEZlZVBlckdhcykpIHx8XG4gICAgICAgICAgICAgICAgKGV4aXN0aW5nTWF4RmVlUGVyR2FzICYmIG1pbk1heEZlZVBlckdhcyk7XG4gICAgICAgICAgICAvLyBtYXhQcmlvcml0eUZlZVBlckdhcyAoRUlQMTU1OSlcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAoX2IgPSB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIGNvbnN0IG1pbk1heFByaW9yaXR5RmVlUGVyR2FzID0gdXRpbF8xLmdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nKGV4aXN0aW5nTWF4UHJpb3JpdHlGZWVQZXJHYXMsIGV4cG9ydHMuQ0FOQ0VMX1JBVEUpO1xuICAgICAgICAgICAgY29uc3QgbWF4UHJpb3JpdHlGZWVQZXJHYXNWYWx1ZXMgPSB1dGlsXzEuaXNGZWVNYXJrZXRFSVAxNTU5VmFsdWVzKGdhc1ZhbHVlcykgJiYgZ2FzVmFsdWVzLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAobWF4UHJpb3JpdHlGZWVQZXJHYXNWYWx1ZXMgJiZcbiAgICAgICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVNaW5pbXVtSW5jcmVhc2UobWF4UHJpb3JpdHlGZWVQZXJHYXNWYWx1ZXMsIG1pbk1heFByaW9yaXR5RmVlUGVyR2FzKSkgfHxcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdNYXhQcmlvcml0eUZlZVBlckdhcyAmJiBtaW5NYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgICAgICBjb25zdCB0eFBhcmFtcyA9IG5ld01heEZlZVBlckdhcyAmJiBuZXdNYXhQcmlvcml0eUZlZVBlckdhc1xuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZ2FzTGltaXQ6IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5nYXMsXG4gICAgICAgICAgICAgICAgICAgIG1heEZlZVBlckdhczogbmV3TWF4RmVlUGVyR2FzLFxuICAgICAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24ubm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICcweDAnLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmZyb20sXG4gICAgICAgICAgICAgICAgICAgIGdhc0xpbWl0OiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZ2FzLFxuICAgICAgICAgICAgICAgICAgICBnYXNQcmljZTogbmV3R2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24ubm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICcweDAnLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZEV0aFR4ID0gdGhpcy5wcmVwYXJlVW5zaWduZWRFdGhUeCh0eFBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCBzaWduZWRUeCA9IHlpZWxkIHRoaXMuc2lnbih1bnNpZ25lZEV0aFR4LCB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZnJvbSk7XG4gICAgICAgICAgICBjb25zdCByYXdUcmFuc2FjdGlvbiA9IGV0aGVyZXVtanNfdXRpbF8xLmJ1ZmZlclRvSGV4KHNpZ25lZFR4LnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnc2VuZFJhd1RyYW5zYWN0aW9uJywgW3Jhd1RyYW5zYWN0aW9uXSk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbk1ldGEuc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuY2FuY2VsbGVkO1xuICAgICAgICAgICAgdGhpcy5odWIuZW1pdChgJHt0cmFuc2FjdGlvbk1ldGEuaWR9OmZpbmlzaGVkYCwgdHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHMgdG8gc3BlZWQgdXAgYSB0cmFuc2FjdGlvbiBpbmNyZWFzaW5nIHRyYW5zYWN0aW9uIGdhc1ByaWNlIGJ5IHRlbiBwZXJjZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25JRCAtIElEIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBzcGVlZCB1cFxuICAgICAqL1xuICAgIHNwZWVkVXBUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklELCBnYXNWYWx1ZXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChnYXNWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVHYXNWYWx1ZXMoZ2FzVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uTWV0YSA9IHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zLmZpbmQoKHsgaWQgfSkgPT4gaWQgPT09IHRyYW5zYWN0aW9uSUQpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmICghdHJhbnNhY3Rpb25NZXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5zaWduKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduIG1ldGhvZCBkZWZpbmVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAvLyBnYXNQcmljZSAobGVnYWN5IG5vbiBFSVAxNTU5KVxuICAgICAgICAgICAgY29uc3QgbWluR2FzUHJpY2UgPSB1dGlsXzEuZ2V0SW5jcmVhc2VkUHJpY2VGcm9tRXhpc3RpbmcodHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmdhc1ByaWNlLCBleHBvcnRzLlNQRUVEX1VQX1JBVEUpO1xuICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2VGcm9tVmFsdWVzID0gdXRpbF8xLmlzR2FzUHJpY2VWYWx1ZShnYXNWYWx1ZXMpICYmIGdhc1ZhbHVlcy5nYXNQcmljZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0dhc1ByaWNlID0gKGdhc1ByaWNlRnJvbVZhbHVlcyAmJlxuICAgICAgICAgICAgICAgIHV0aWxfMS52YWxpZGF0ZU1pbmltdW1JbmNyZWFzZShnYXNQcmljZUZyb21WYWx1ZXMsIG1pbkdhc1ByaWNlKSkgfHxcbiAgICAgICAgICAgICAgICBtaW5HYXNQcmljZTtcbiAgICAgICAgICAgIC8vIG1heEZlZVBlckdhcyAoRUlQMTU1OSlcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTWF4RmVlUGVyR2FzID0gKF9hID0gdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbWluTWF4RmVlUGVyR2FzID0gdXRpbF8xLmdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nKGV4aXN0aW5nTWF4RmVlUGVyR2FzLCBleHBvcnRzLlNQRUVEX1VQX1JBVEUpO1xuICAgICAgICAgICAgY29uc3QgbWF4RmVlUGVyR2FzVmFsdWVzID0gdXRpbF8xLmlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcyhnYXNWYWx1ZXMpICYmIGdhc1ZhbHVlcy5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICBjb25zdCBuZXdNYXhGZWVQZXJHYXMgPSAobWF4RmVlUGVyR2FzVmFsdWVzICYmXG4gICAgICAgICAgICAgICAgdXRpbF8xLnZhbGlkYXRlTWluaW11bUluY3JlYXNlKG1heEZlZVBlckdhc1ZhbHVlcywgbWluTWF4RmVlUGVyR2FzKSkgfHxcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdNYXhGZWVQZXJHYXMgJiYgbWluTWF4RmVlUGVyR2FzKTtcbiAgICAgICAgICAgIC8vIG1heFByaW9yaXR5RmVlUGVyR2FzIChFSVAxNTU5KVxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdNYXhQcmlvcml0eUZlZVBlckdhcyA9IChfYiA9IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbWluTWF4UHJpb3JpdHlGZWVQZXJHYXMgPSB1dGlsXzEuZ2V0SW5jcmVhc2VkUHJpY2VGcm9tRXhpc3RpbmcoZXhpc3RpbmdNYXhQcmlvcml0eUZlZVBlckdhcywgZXhwb3J0cy5TUEVFRF9VUF9SQVRFKTtcbiAgICAgICAgICAgIGNvbnN0IG1heFByaW9yaXR5RmVlUGVyR2FzVmFsdWVzID0gdXRpbF8xLmlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcyhnYXNWYWx1ZXMpICYmIGdhc1ZhbHVlcy5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIGNvbnN0IG5ld01heFByaW9yaXR5RmVlUGVyR2FzID0gKG1heFByaW9yaXR5RmVlUGVyR2FzVmFsdWVzICYmXG4gICAgICAgICAgICAgICAgdXRpbF8xLnZhbGlkYXRlTWluaW11bUluY3JlYXNlKG1heFByaW9yaXR5RmVlUGVyR2FzVmFsdWVzLCBtaW5NYXhQcmlvcml0eUZlZVBlckdhcykpIHx8XG4gICAgICAgICAgICAgICAgKGV4aXN0aW5nTWF4UHJpb3JpdHlGZWVQZXJHYXMgJiYgbWluTWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICAgICAgY29uc3QgdHhQYXJhbXMgPSBuZXdNYXhGZWVQZXJHYXMgJiYgbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXNcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKSwgeyBnYXNMaW1pdDogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmdhcywgbWF4RmVlUGVyR2FzOiBuZXdNYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzOiBuZXdNYXhQcmlvcml0eUZlZVBlckdhcywgdHlwZTogMiB9KSA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKSwgeyBnYXNMaW1pdDogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmdhcywgZ2FzUHJpY2U6IG5ld0dhc1ByaWNlIH0pO1xuICAgICAgICAgICAgY29uc3QgdW5zaWduZWRFdGhUeCA9IHRoaXMucHJlcGFyZVVuc2lnbmVkRXRoVHgodHhQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHggPSB5aWVsZCB0aGlzLnNpZ24odW5zaWduZWRFdGhUeCwgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmZyb20pO1xuICAgICAgICAgICAgY29uc3QgcmF3VHJhbnNhY3Rpb24gPSBldGhlcmV1bWpzX3V0aWxfMS5idWZmZXJUb0hleChzaWduZWRUeC5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkhhc2ggPSB5aWVsZCB1dGlsXzEucXVlcnkodGhpcy5ldGhRdWVyeSwgJ3NlbmRSYXdUcmFuc2FjdGlvbicsIFtcbiAgICAgICAgICAgICAgICByYXdUcmFuc2FjdGlvbixcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgY29uc3QgYmFzZVRyYW5zYWN0aW9uTWV0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb25NZXRhKSwgeyBpZDogdXVpZF8xLnYxKCksIHRpbWU6IERhdGUubm93KCksIHRyYW5zYWN0aW9uSGFzaCB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RyYW5zYWN0aW9uTWV0YSA9IG5ld01heEZlZVBlckdhcyAmJiBuZXdNYXhQcmlvcml0eUZlZVBlckdhc1xuICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlVHJhbnNhY3Rpb25NZXRhKSwgeyB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24pLCB7IG1heEZlZVBlckdhczogbmV3TWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhczogbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXMgfSkgfSkgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhc2VUcmFuc2FjdGlvbk1ldGEpLCB7IHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbiksIHsgZ2FzUHJpY2U6IG5ld0dhc1ByaWNlIH0pIH0pO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLnB1c2gobmV3VHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgdHJhbnNhY3Rpb25zOiB0aGlzLnRyaW1UcmFuc2FjdGlvbnNGb3JTdGF0ZSh0cmFuc2FjdGlvbnMpIH0pO1xuICAgICAgICAgICAgdGhpcy5odWIuZW1pdChgJHt0cmFuc2FjdGlvbk1ldGEuaWR9OnNwZWVkdXBgLCBuZXdUcmFuc2FjdGlvbk1ldGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0aW1hdGVzIHJlcXVpcmVkIGdhcyBmb3IgYSBnaXZlbiB0cmFuc2FjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gb2JqZWN0IHRvIGVzdGltYXRlIGdhcyBmb3JcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIGFuIG9iamVjdCBjb250YWluaW5nIGdhcyBhbmQgZ2FzUHJpY2VcbiAgICAgKi9cbiAgICBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVkVHJhbnNhY3Rpb24gPSBPYmplY3QuYXNzaWduKHt9LCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBjb25zdCB7IGdhcywgZ2FzUHJpY2U6IHByb3ZpZGVkR2FzUHJpY2UsIHRvLCB2YWx1ZSwgZGF0YSwgfSA9IGVzdGltYXRlZFRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2UgPSB0eXBlb2YgcHJvdmlkZWRHYXNQcmljZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnZ2FzUHJpY2UnKVxuICAgICAgICAgICAgICAgIDogcHJvdmlkZWRHYXNQcmljZTtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNDdXN0b21OZXR3b3JrIH0gPSB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpO1xuICAgICAgICAgICAgLy8gMS4gSWYgZ2FzIGlzIGFscmVhZHkgZGVmaW5lZCBvbiB0aGUgdHJhbnNhY3Rpb24sIHVzZSBpdFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnYXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZ2FzLCBnYXNQcmljZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBnYXNMaW1pdCB9ID0geWllbGQgdXRpbF8xLnF1ZXJ5KHRoaXMuZXRoUXVlcnksICdnZXRCbG9ja0J5TnVtYmVyJywgW1xuICAgICAgICAgICAgICAgICdsYXRlc3QnLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAvLyAyLiBJZiB0byBpcyBub3QgZGVmaW5lZCBvciB0aGlzIGlzIG5vdCBhIGNvbnRyYWN0IGFkZHJlc3MsIGFuZCB0aGVyZSBpcyBubyBkYXRhIHVzZSAweDUyMDggLyAyMTAwMC5cbiAgICAgICAgICAgIC8vIElmIHRoZSBuZXd0d29yayBpcyBhIGN1c3RvbSBuZXR3b3JrIHRoZW4gYnlwYXNzIHRoaXMgY2hlY2sgYW5kIGZldGNoICdlc3RpbWF0ZUdhcycuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHRvID8geWllbGQgdXRpbF8xLnF1ZXJ5KHRoaXMuZXRoUXVlcnksICdnZXRDb2RlJywgW3RvXSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKCFpc0N1c3RvbU5ldHdvcmsgJiZcbiAgICAgICAgICAgICAgICAoIXRvIHx8ICh0byAmJiAhZGF0YSAmJiAoIWNvZGUgfHwgY29kZSA9PT0gJzB4JykpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGdhczogJzB4NTIwOCcsIGdhc1ByaWNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBkYXRhLCBzaG91bGQgYmUgaGV4IHN0cmluZyBmb3JtYXRcbiAgICAgICAgICAgIGVzdGltYXRlZFRyYW5zYWN0aW9uLmRhdGEgPSAhZGF0YVxuICAgICAgICAgICAgICAgID8gZGF0YVxuICAgICAgICAgICAgICAgIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KGRhdGEpO1xuICAgICAgICAgICAgLy8gMy4gSWYgdGhpcyBpcyBhIGNvbnRyYWN0IGFkZHJlc3MsIHNhZmVseSBlc3RpbWF0ZSBnYXMgdXNpbmcgUlBDXG4gICAgICAgICAgICBlc3RpbWF0ZWRUcmFuc2FjdGlvbi52YWx1ZSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICcweDAnIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdmFsdWU7XG4gICAgICAgICAgICBjb25zdCBnYXNMaW1pdEJOID0gdXRpbF8xLmhleFRvQk4oZ2FzTGltaXQpO1xuICAgICAgICAgICAgZXN0aW1hdGVkVHJhbnNhY3Rpb24uZ2FzID0gdXRpbF8xLkJOVG9IZXgodXRpbF8xLmZyYWN0aW9uQk4oZ2FzTGltaXRCTiwgMTksIDIwKSk7XG4gICAgICAgICAgICBjb25zdCBnYXNIZXggPSB5aWVsZCB1dGlsXzEucXVlcnkodGhpcy5ldGhRdWVyeSwgJ2VzdGltYXRlR2FzJywgW1xuICAgICAgICAgICAgICAgIGVzdGltYXRlZFRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAvLyA0LiBQYWQgZXN0aW1hdGVkIGdhcyB3aXRob3V0IGV4Y2VlZGluZyB0aGUgbW9zdCByZWNlbnQgYmxvY2sgZ2FzTGltaXQuIElmIHRoZSBuZXR3b3JrIGlzIGFcbiAgICAgICAgICAgIC8vIGEgY3VzdG9tIG5ldHdvcmsgdGhlbiByZXR1cm4gdGhlIGV0aF9lc3RpbWF0ZUdhcyB2YWx1ZS5cbiAgICAgICAgICAgIGNvbnN0IGdhc0JOID0gdXRpbF8xLmhleFRvQk4oZ2FzSGV4KTtcbiAgICAgICAgICAgIGNvbnN0IG1heEdhc0JOID0gZ2FzTGltaXRCTi5tdWxuKDAuOSk7XG4gICAgICAgICAgICBjb25zdCBwYWRkZWRHYXNCTiA9IGdhc0JOLm11bG4oMS41KTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoZ2FzQk4uZ3QobWF4R2FzQk4pIHx8IGlzQ3VzdG9tTmV0d29yaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGdhczogZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KGdhc0hleCksIGdhc1ByaWNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKHBhZGRlZEdhc0JOLmx0KG1heEdhc0JOKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGdhczogZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KHV0aWxfMS5CTlRvSGV4KHBhZGRlZEdhc0JOKSksIGdhc1ByaWNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBnYXM6IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCh1dGlsXzEuQk5Ub0hleChtYXhHYXNCTikpLCBnYXNQcmljZSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzaWxpZW50bHkgY2hlY2tzIGFsbCBzdWJtaXR0ZWQgdHJhbnNhY3Rpb25zIG9uIHRoZSBibG9ja2NoYWluXG4gICAgICogYW5kIHZlcmlmaWVzIHRoYXQgaXQgaGFzIGJlZW4gaW5jbHVkZWQgaW4gYSBibG9ja1xuICAgICAqIHdoZW4gdGhhdCBoYXBwZW5zLCB0aGUgdHggc3RhdHVzIGlzIHVwZGF0ZWQgdG8gY29uZmlybWVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhpcyBvcGVyYXRpb24gY29tcGxldGVzXG4gICAgICovXG4gICAgcXVlcnlUcmFuc2FjdGlvblN0YXR1c2VzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IHByb3ZpZGVyLCBuZXR3b3JrOiBjdXJyZW50TmV0d29ya0lEIH0gPSB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbklkOiBjdXJyZW50Q2hhaW5JZCB9ID0gcHJvdmlkZXI7XG4gICAgICAgICAgICBsZXQgZ290VXBkYXRlcyA9IGZhbHNlO1xuICAgICAgICAgICAgeWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zLm1hcCgobWV0YSwgaW5kZXgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2luZyBmYWxsYmFjayB0byBuZXR3b3JrSUQgb25seSB3aGVuIHRoZXJlIGlzIG5vIGNoYWluSWQgcHJlc2VudC5cbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVtb3ZlZCB3aGVuIG5ldHdvcmtJRCBpcyBjb21wbGV0ZWx5IHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgY29uc3QgdHhCZWxvbmdzVG9DdXJyZW50Q2hhaW4gPSBtZXRhLmNoYWluSWQgPT09IGN1cnJlbnRDaGFpbklkIHx8XG4gICAgICAgICAgICAgICAgICAgICghbWV0YS5jaGFpbklkICYmIG1ldGEubmV0d29ya0lEID09PSBjdXJyZW50TmV0d29ya0lEKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGEudmVyaWZpZWRPbkJsb2NrY2hhaW4gJiYgdHhCZWxvbmdzVG9DdXJyZW50Q2hhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3JlY29uY2lsZWRUeCwgdXBkYXRlUmVxdWlyZWQsXSA9IHlpZWxkIHRoaXMuYmxvY2tjaGFpblRyYW5zYWN0aW9uU3RhdGVSZWNvbmNpbGVyKG1ldGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlUmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uc1tpbmRleF0gPSByZWNvbmNpbGVkVHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RVcGRhdGVzID0gdXBkYXRlUmVxdWlyZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkpKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoZ290VXBkYXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiB0aGlzLnRyaW1UcmFuc2FjdGlvbnNGb3JTdGF0ZSh0cmFuc2FjdGlvbnMpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbiBleGlzdGluZyB0cmFuc2FjdGlvbiBpbiBzdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uTWV0YSAtIE5ldyB0cmFuc2FjdGlvbiBtZXRhIHRvIHN0b3JlIGluIHN0YXRlXG4gICAgICovXG4gICAgdXBkYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXRhKSB7XG4gICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24gPSB1dGlsXzEubm9ybWFsaXplVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0cmFuc2FjdGlvbnMuZmluZEluZGV4KCh7IGlkIH0pID0+IHRyYW5zYWN0aW9uTWV0YS5pZCA9PT0gaWQpO1xuICAgICAgICB0cmFuc2FjdGlvbnNbaW5kZXhdID0gdHJhbnNhY3Rpb25NZXRhO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IHRyYW5zYWN0aW9uczogdGhpcy50cmltVHJhbnNhY3Rpb25zRm9yU3RhdGUodHJhbnNhY3Rpb25zKSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdHJhbnNhY3Rpb25zIGZyb20gc3RhdGUsIG9wdGlvbmFsbHkgYmFzZWQgb24gdGhlIGN1cnJlbnQgbmV0d29ya1xuICAgICAqXG4gICAgICogQHBhcmFtIGlnbm9yZU5ldHdvcmsgLSBJZ25vcmVzIG5ldHdvcmtcbiAgICAgKi9cbiAgICB3aXBlVHJhbnNhY3Rpb25zKGlnbm9yZU5ldHdvcmspIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKGlnbm9yZU5ldHdvcmspIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgdHJhbnNhY3Rpb25zOiBbXSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHByb3ZpZGVyLCBuZXR3b3JrOiBjdXJyZW50TmV0d29ya0lEIH0gPSB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpO1xuICAgICAgICBjb25zdCB7IGNoYWluSWQ6IGN1cnJlbnRDaGFpbklkIH0gPSBwcm92aWRlcjtcbiAgICAgICAgY29uc3QgbmV3VHJhbnNhY3Rpb25zID0gdGhpcy5zdGF0ZS50cmFuc2FjdGlvbnMuZmlsdGVyKCh7IG5ldHdvcmtJRCwgY2hhaW5JZCB9KSA9PiB7XG4gICAgICAgICAgICAvLyBVc2luZyBmYWxsYmFjayB0byBuZXR3b3JrSUQgb25seSB3aGVuIHRoZXJlIGlzIG5vIGNoYWluSWQgcHJlc2VudC4gU2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBuZXR3b3JrSUQgaXMgY29tcGxldGVseSByZW1vdmVkLlxuICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50TmV0d29yayA9IGNoYWluSWQgPT09IGN1cnJlbnRDaGFpbklkIHx8XG4gICAgICAgICAgICAgICAgKCFjaGFpbklkICYmIG5ldHdvcmtJRCA9PT0gY3VycmVudE5ldHdvcmtJRCk7XG4gICAgICAgICAgICByZXR1cm4gIWlzQ3VycmVudE5ldHdvcms7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbnM6IHRoaXMudHJpbVRyYW5zYWN0aW9uc0ZvclN0YXRlKG5ld1RyYW5zYWN0aW9ucyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCB0cmFuc2FjdGlvbnMgZnJvbSBldGhlcnNjYW4gZm9yIGEgc3BlY2lmaWMgYWRkcmVzc1xuICAgICAqIG9wdGlvbmFsbHkgc3RhcnRpbmcgZnJvbSBhIHNwZWNpZmljIGJsb2NrXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHRyYW5zYWN0aW9ucyBmcm9tXG4gICAgICogQHBhcmFtIG9wdCAtIE9iamVjdCBjb250YWluaW5nIG9wdGlvbmFsIGRhdGEsIGZyb21CbG9jayBhbmQgQWxldGhpbyBBUEkga2V5XG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byBhbiBzdHJpbmcgY29udGFpbmluZyB0aGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBsYXRlc3QgaW5jb21pbmcgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZmV0Y2hBbGwoYWRkcmVzcywgb3B0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3ZpZGVyLCBuZXR3b3JrOiBjdXJyZW50TmV0d29ya0lEIH0gPSB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbklkOiBjdXJyZW50Q2hhaW5JZCwgdHlwZTogbmV0d29ya1R5cGUgfSA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBzdXBwb3J0ZWROZXR3b3JrSWRzID0gWycxJywgJzMnLCAnNCcsICc0MiddO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmIChzdXBwb3J0ZWROZXR3b3JrSWRzLmluZGV4T2YoY3VycmVudE5ldHdvcmtJRCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtldGhlcnNjYW5UeFJlc3BvbnNlLCBldGhlcnNjYW5Ub2tlblJlc3BvbnNlLF0gPSB5aWVsZCB1dGlsXzEuaGFuZGxlVHJhbnNhY3Rpb25GZXRjaChuZXR3b3JrVHlwZSwgYWRkcmVzcywgdGhpcy5jb25maWcudHhIaXN0b3J5TGltaXQsIG9wdCk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkVHhzID0gZXRoZXJzY2FuVHhSZXNwb25zZS5yZXN1bHQubWFwKCh0eCkgPT4gdGhpcy5ub3JtYWxpemVUeCh0eCwgY3VycmVudE5ldHdvcmtJRCwgY3VycmVudENoYWluSWQpKTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUb2tlblR4cyA9IGV0aGVyc2NhblRva2VuUmVzcG9uc2UucmVzdWx0Lm1hcCgodHgpID0+IHRoaXMubm9ybWFsaXplVG9rZW5UeCh0eCwgY3VycmVudE5ldHdvcmtJRCwgY3VycmVudENoYWluSWQpKTtcbiAgICAgICAgICAgIGNvbnN0IFt1cGRhdGVSZXF1aXJlZCwgYWxsVHhzXSA9IHRoaXMuZXRoZXJzY2FuVHJhbnNhY3Rpb25TdGF0ZVJlY29uY2lsZXIoWy4uLm5vcm1hbGl6ZWRUeHMsIC4uLm5vcm1hbGl6ZWRUb2tlblR4c10sIHRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICBhbGxUeHMuc29ydCgoYSwgYikgPT4gKGEudGltZSA8IGIudGltZSA/IC0xIDogMSkpO1xuICAgICAgICAgICAgbGV0IGxhdGVzdEluY29taW5nVHhCbG9ja051bWJlcjtcbiAgICAgICAgICAgIGFsbFR4cy5mb3JFYWNoKCh0eCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIFVzaW5nIGZhbGxiYWNrIHRvIG5ldHdvcmtJRCBvbmx5IHdoZW4gdGhlcmUgaXMgbm8gY2hhaW5JZCBwcmVzZW50LiBTaG91bGQgYmUgcmVtb3ZlZCB3aGVuIG5ldHdvcmtJRCBpcyBjb21wbGV0ZWx5IHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgKHR4LmNoYWluSWQgPT09IGN1cnJlbnRDaGFpbklkIHx8XG4gICAgICAgICAgICAgICAgICAgICghdHguY2hhaW5JZCAmJiB0eC5uZXR3b3JrSUQgPT09IGN1cnJlbnROZXR3b3JrSUQpKSAmJlxuICAgICAgICAgICAgICAgICAgICB0eC50cmFuc2FjdGlvbi50byAmJlxuICAgICAgICAgICAgICAgICAgICB0eC50cmFuc2FjdGlvbi50by50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmJsb2NrTnVtYmVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWxhdGVzdEluY29taW5nVHhCbG9ja051bWJlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGxhdGVzdEluY29taW5nVHhCbG9ja051bWJlciwgMTApIDxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQodHguYmxvY2tOdW1iZXIsIDEwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdGVzdEluY29taW5nVHhCbG9ja051bWJlciA9IHR4LmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKHR4LnRvU21hcnRDb250cmFjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCBgdG9gIGlzIGEgY29udHJhY3QgZGVwbG95LCBpZiBub3QgYGRhdGFgIGlzIHNlbmQgZXRoXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC50cmFuc2FjdGlvbi50byAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCF0eC50cmFuc2FjdGlvbi5kYXRhIHx8IHR4LnRyYW5zYWN0aW9uLmRhdGEgIT09ICcweCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0geWllbGQgdXRpbF8xLnF1ZXJ5KHRoaXMuZXRoUXVlcnksICdnZXRDb2RlJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LnRyYW5zYWN0aW9uLnRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC50b1NtYXJ0Q29udHJhY3QgPSB1dGlsXzEuaXNTbWFydENvbnRyYWN0Q29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4LnRvU21hcnRDb250cmFjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXRlIG9ubHkgaWYgbmV3IHRyYW5zYWN0aW9ucyB3ZXJlIGZldGNoZWQgb3JcbiAgICAgICAgICAgIC8vIHRoZSBzdGF0dXMgb3IgZ2FzIGRhdGEgb2YgYSB0cmFuc2FjdGlvbiBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgaWYgKHVwZGF0ZVJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyB0cmFuc2FjdGlvbnM6IHRoaXMudHJpbVRyYW5zYWN0aW9uc0ZvclN0YXRlKGFsbFR4cykgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGF0ZXN0SW5jb21pbmdUeEJsb2NrTnVtYmVyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpbSB0aGUgYW1vdW50IG9mIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBzZXQgb24gdGhlIHN0YXRlLiBDaGVja3NcbiAgICAgKiBpZiB0aGUgbGVuZ3RoIG9mIHRoZSB0eCBoaXN0b3J5IGlzIGxvbmdlciB0aGVuIGRlc2lyZWQgcGVyc2lzdGVuY2VcbiAgICAgKiBsaW1pdCBhbmQgdGhlbiBpZiBpdCBpcyByZW1vdmVzIHRoZSBvbGRlc3QgY29uZmlybWVkIG9yIHJlamVjdGVkIHR4LlxuICAgICAqIFBlbmRpbmcgb3IgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnMgd2lsbCBub3QgYmUgcmVtb3ZlZCBieSB0aGlzXG4gICAgICogb3BlcmF0aW9uLiBGb3Igc2FmZXR5IG9mIHByZXNlbnRpbmcgYSBmdWxseSBmdW5jdGlvbmFsIHRyYW5zYWN0aW9uIFVJXG4gICAgICogcmVwcmVzZW50YXRpb24sIHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgYnJlYWsgYXBhcnQgdHJhbnNhY3Rpb25zIHdpdGggdGhlXG4gICAgICogc2FtZSBub25jZSwgY3JlYXRlZCBvbiB0aGUgc2FtZSBkYXksIHBlciBuZXR3b3JrLiBOb3QgYWNjb3VudGluZyBmb3IgdHJhbnNhY3Rpb25zIG9mIHRoZSBzYW1lXG4gICAgICogbm9uY2UsIHNhbWUgZGF5IGFuZCBuZXR3b3JrIGNvbWJvIGNhbiByZXN1bHQgaW4gY29uZnVzaW5nIG9yIGJyb2tlbiBleHBlcmllbmNlc1xuICAgICAqIGluIHRoZSBVSS4gVGhlIHRyYW5zYWN0aW9ucyBhcmUgdGhlbiB1cGRhdGVkIHVzaW5nIHRoZSBCYXNlQ29udHJvbGxlciB1cGRhdGUuXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9ucyAtIGFycmF5IG9mIHRyYW5zYWN0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBzdGF0ZVxuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIFRyYW5zYWN0aW9uTWV0YSB3aXRoIHRoZSBkZXNpcmVkIGxlbmd0aC5cbiAgICAgKi9cbiAgICB0cmltVHJhbnNhY3Rpb25zRm9yU3RhdGUodHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IG5vbmNlTmV0d29ya1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgdHhzVG9LZWVwID0gdHJhbnNhY3Rpb25zLnJldmVyc2UoKS5maWx0ZXIoKHR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNoYWluSWQsIG5ldHdvcmtJRCwgc3RhdHVzLCB0cmFuc2FjdGlvbiwgdGltZSB9ID0gdHg7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHt0cmFuc2FjdGlvbi5ub25jZX0tJHtjaGFpbklkICE9PSBudWxsICYmIGNoYWluSWQgIT09IHZvaWQgMCA/IGNoYWluSWQgOiBuZXR3b3JrSUR9LSR7bmV3IERhdGUodGltZSkudG9EYXRlU3RyaW5nKCl9YDtcbiAgICAgICAgICAgICAgICBpZiAobm9uY2VOZXR3b3JrU2V0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub25jZU5ldHdvcmtTZXQuc2l6ZSA8IHRoaXMuY29uZmlnLnR4SGlzdG9yeUxpbWl0IHx8XG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmlzRmluYWxTdGF0ZShzdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vbmNlTmV0d29ya1NldC5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdHhzVG9LZWVwLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIHR4c1RvS2VlcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGRldGVybWluZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgaW4gYSBmaW5hbCBzdGF0ZVxuICAgICAqIEBwYXJhbSBzdGF0dXMgLSBUcmFuc2FjdGlvbiBzdGF0dXNcbiAgICAgKiBAcmV0dXJucyBib29sZWFuIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBpbiBhIGZpbmFsIHN0YXRlXG4gICAgICovXG4gICAgaXNGaW5hbFN0YXRlKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gKHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMucmVqZWN0ZWQgfHxcbiAgICAgICAgICAgIHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkIHx8XG4gICAgICAgICAgICBzdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLmZhaWxlZCB8fFxuICAgICAgICAgICAgc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5jYW5jZWxsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gdmVyaWZ5IHRoZSBzdGF0ZSBvZiBhIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBCbG9ja2NoYWluIGFzIGEgc291cmNlIG9mIHRydXRoXG4gICAgICogQHBhcmFtIG1ldGEgTG9jYWwgdHJhbnNhY3Rpb24gdG8gdmVyaWZ5IGRhdGEgaW4gYmxvY2tjaGFpblxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBbVHJhbnNhY3Rpb25NZXRhLCBib29sZWFuXVxuICAgICAqL1xuICAgIGJsb2NrY2hhaW5UcmFuc2FjdGlvblN0YXRlUmVjb25jaWxlcihtZXRhKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXR1cywgdHJhbnNhY3Rpb25IYXNoIH0gPSBtZXRhO1xuICAgICAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdHVzLmNvbmZpcm1lZDpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHhSZWNlaXB0ID0geWllbGQgdXRpbF8xLnF1ZXJ5KHRoaXMuZXRoUXVlcnksICdnZXRUcmFuc2FjdGlvblJlY2VpcHQnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXR4UmVjZWlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZXRhLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWV0YS52ZXJpZmllZE9uQmxvY2tjaGFpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1ldGEudHJhbnNhY3Rpb24uZ2FzVXNlZCA9IHR4UmVjZWlwdC5nYXNVc2VkO1xuICAgICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIFdlYjMgZG9jczpcbiAgICAgICAgICAgICAgICAgICAgLy8gVFJVRSBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIHN1Y2Nlc3NmdWwsIEZBTFNFIGlmIHRoZSBFVk0gcmV2ZXJ0ZWQgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoTnVtYmVyKHR4UmVjZWlwdC5zdGF0dXMpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gZmFpbGVkLiBUaGUgdHJhbnNhY3Rpb24gd2FzIHJldmVyc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxUcmFuc2FjdGlvbihtZXRhLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW21ldGEsIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW21ldGEsIHRydWVdO1xuICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eE9iaiA9IHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXR4T2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0U2hvd3NGYWlsZWRTdGF0dXMgPSB5aWVsZCB0aGlzLmNoZWNrVHhSZWNlaXB0U3RhdHVzSXNGYWlsZWQodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc2UgdGhlIHR4T2JqIGlzIGV2YWx1YXRlZCBhcyBmYWxzZSwgYSBzZWNvbmQgY2hlY2sgd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHRoZSB0eCBmYWlsZWQgb3IgaXQgaXMgcGVuZGluZyBvciBjb25maXJtZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0U2hvd3NGYWlsZWRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gZmFpbGVkLiBUaGUgdHJhbnNhY3Rpb24gd2FzIGRyb3BwZWQgb3IgcmVwbGFjZWQgYnkgYSBuZXcgb25lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsVHJhbnNhY3Rpb24obWV0YSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eE9iaiA9PT0gbnVsbCB8fCB0eE9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHhPYmouYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGEuc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5odWIuZW1pdChgJHttZXRhLmlkfTpjb25maXJtZWRgLCBtZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWV0YSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZXRhLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZXRhLCBmYWxzZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gY2hlY2sgaWYgYSB0eCBoYXMgZmFpbGVkIGFjY29yZGluZyB0byB0aGVpciByZWNlaXB0XG4gICAgICogQWNjb3JkaW5nIHRvIHRoZSBXZWIzIGRvY3M6XG4gICAgICogVFJVRSBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIHN1Y2Nlc3NmdWwsIEZBTFNFIGlmIHRoZSBFVk0gcmV2ZXJ0ZWQgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIFRoZSByZWNlaXB0IGlzIG5vdCBhdmFpbGFibGUgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zIGFuZCByZXR1cm5zIG51bGwuXG4gICAgICogQHBhcmFtIHR4SGFzaCBUcmFuc2FjdGlvbiBoYXNoXG4gICAgICogQHJldHVybnMgUHJvbWlzZTxib29sZWFuPiBpbmRpY2F0aW5nIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXZlIGZhaWxlZFxuICAgICAqL1xuICAgIGNoZWNrVHhSZWNlaXB0U3RhdHVzSXNGYWlsZWQodHhIYXNoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0eFJlY2VpcHQgPSB5aWVsZCB1dGlsXzEucXVlcnkodGhpcy5ldGhRdWVyeSwgJ2dldFRyYW5zYWN0aW9uUmVjZWlwdCcsIFtcbiAgICAgICAgICAgICAgICB0eEhhc2gsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmICghdHhSZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgLy8gVHJhbnNhY3Rpb24gaXMgcGVuZGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodHhSZWNlaXB0LnN0YXR1cykgPT09IDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gdmVyaWZ5IHRoZSBzdGF0ZSBvZiB0cmFuc2FjdGlvbnMgdXNpbmcgRXRoZXJzY2FuIGFzIGEgc291cmNlIG9mIHRydXRoXG4gICAgICogQHBhcmFtIHJlbW90ZVR4cyBBcnJheSBvZiB0cmFuc2FjdGlvbnMgZnJvbSByZW1vdGUgc291cmNlXG4gICAgICogQHBhcmFtIGxvY2FsVHhzIEFycmF5IG9mIHRyYW5zYWN0aW9ucyBzdG9yZWQgbG9jYWxseVxuICAgICAqIEByZXR1cm5zIFtib29sZWFuLCBUcmFuc2FjdGlvbk1ldGFbXV1cbiAgICAgKi9cbiAgICBldGhlcnNjYW5UcmFuc2FjdGlvblN0YXRlUmVjb25jaWxlcihyZW1vdGVUeHMsIGxvY2FsVHhzKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRUeHMgPSB0aGlzLmdldFVwZGF0ZWRUcmFuc2FjdGlvbnMocmVtb3RlVHhzLCBsb2NhbFR4cyk7XG4gICAgICAgIGNvbnN0IG5ld1R4cyA9IHRoaXMuZ2V0TmV3VHJhbnNhY3Rpb25zKHJlbW90ZVR4cywgbG9jYWxUeHMpO1xuICAgICAgICBjb25zdCB1cGRhdGVkTG9jYWxUeHMgPSBsb2NhbFR4cy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0eElkeCA9IHVwZGF0ZWRUeHMuZmluZEluZGV4KCh7IHRyYW5zYWN0aW9uSGFzaCB9KSA9PiB0cmFuc2FjdGlvbkhhc2ggPT09IHR4LnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gdHhJZHggPT09IC0xID8gdHggOiB1cGRhdGVkVHhzW3R4SWR4XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVJlcXVpcmVkID0gbmV3VHhzLmxlbmd0aCA+IDAgfHwgdXBkYXRlZExvY2FsVHhzLmxlbmd0aCA+IDA7XG4gICAgICAgIHJldHVybiBbdXBkYXRlUmVxdWlyZWQsIFsuLi5uZXdUeHMsIC4uLnVwZGF0ZWRMb2NhbFR4c11dO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBpbiB0aGUgcmVtb3RlIHRyYW5zYWN0aW9ucyBhcnJheVxuICAgICAqIGJ1dCBub3QgaW4gdGhlIGxvY2FsIHRyYW5zYWN0aW9ucyBhcnJheVxuICAgICAqIEBwYXJhbSByZW1vdGVUeHMgLSBBcnJheSBvZiB0cmFuc2FjdGlvbnMgZnJvbSByZW1vdGUgc291cmNlXG4gICAgICogQHBhcmFtIGxvY2FsVHhzIC0gQXJyYXkgb2YgdHJhbnNhY3Rpb25zIHN0b3JlZCBsb2NhbGx5XG4gICAgICogQHJldHVybnMgVHJhbnNhY3Rpb25NZXRhIGFycmF5XG4gICAgICovXG4gICAgZ2V0TmV3VHJhbnNhY3Rpb25zKHJlbW90ZVR4cywgbG9jYWxUeHMpIHtcbiAgICAgICAgcmV0dXJuIHJlbW90ZVR4cy5maWx0ZXIoKHR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbHJlYWR5SW5UcmFuc2FjdGlvbnMgPSBsb2NhbFR4cy5maW5kKCh7IHRyYW5zYWN0aW9uSGFzaCB9KSA9PiB0cmFuc2FjdGlvbkhhc2ggPT09IHR4LnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gIWFscmVhZHlJblRyYW5zYWN0aW9ucztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBsb2NhbGx5IG91dGRhdGVkIHdpdGggcmVzcGVjdFxuICAgICAqIHRvIGEgcmVtb3RlIHNvdXJjZSAoZXRoZXJzY2FuIG9yIGJsb2NrY2hhaW4pLiBUaGUgcmV0dXJuZWQgYXJyYXlcbiAgICAgKiBjb250YWlucyB0aGUgdHJhbnNhY3Rpb25zIHdpdGggdGhlIHVwZGF0ZWQgZGF0YS5cbiAgICAgKiBAcGFyYW0gcmVtb3RlVHhzIC0gQXJyYXkgb2YgdHJhbnNhY3Rpb25zIGZyb20gcmVtb3RlIHNvdXJjZVxuICAgICAqIEBwYXJhbSBsb2NhbFR4cyAtIEFycmF5IG9mIHRyYW5zYWN0aW9ucyBzdG9yZWQgbG9jYWxseVxuICAgICAqIEByZXR1cm5zIFRyYW5zYWN0aW9uTWV0YSBhcnJheVxuICAgICAqL1xuICAgIGdldFVwZGF0ZWRUcmFuc2FjdGlvbnMocmVtb3RlVHhzLCBsb2NhbFR4cykge1xuICAgICAgICByZXR1cm4gcmVtb3RlVHhzLmZpbHRlcigocmVtb3RlVHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzVHhPdXRkYXRlZCA9IGxvY2FsVHhzLmZpbmQoKGxvY2FsVHgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHJlbW90ZVR4LnRyYW5zYWN0aW9uSGFzaCA9PT0gbG9jYWxUeC50cmFuc2FjdGlvbkhhc2ggJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1RyYW5zYWN0aW9uT3V0ZGF0ZWQocmVtb3RlVHgsIGxvY2FsVHgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGlzVHhPdXRkYXRlZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGlmIGEgbG9jYWwgdHJhbnNhY3Rpb24gaXMgb3V0ZGF0ZWQgd2l0aCByZXNwZWN0IHRvIHRoZSByZW1vdGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gcmVtb3RlVHggLSBSZW1vdGUgdHJhbnNhY3Rpb24gZnJvbSBFdGhlcnNjYW5cbiAgICAgKiBAcGFyYW0gbG9jYWxUeCAtIExvY2FsIHRyYW5zYWN0aW9uXG4gICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAqL1xuICAgIGlzVHJhbnNhY3Rpb25PdXRkYXRlZChyZW1vdGVUeCwgbG9jYWxUeCkge1xuICAgICAgICBjb25zdCBzdGF0dXNPdXRkYXRlZCA9IHRoaXMuaXNTdGF0dXNPdXRkYXRlZChyZW1vdGVUeC50cmFuc2FjdGlvbkhhc2gsIGxvY2FsVHgudHJhbnNhY3Rpb25IYXNoLCByZW1vdGVUeC5zdGF0dXMsIGxvY2FsVHguc3RhdHVzKTtcbiAgICAgICAgY29uc3QgZ2FzRGF0YU91dGRhdGVkID0gdGhpcy5pc0dhc0RhdGFPdXRkYXRlZChyZW1vdGVUeC50cmFuc2FjdGlvbi5nYXNVc2VkLCBsb2NhbFR4LnRyYW5zYWN0aW9uLmdhc1VzZWQpO1xuICAgICAgICByZXR1cm4gc3RhdHVzT3V0ZGF0ZWQgfHwgZ2FzRGF0YU91dGRhdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBpZiB0aGUgc3RhdHVzIG9mIGEgbG9jYWwgdHJhbnNhY3Rpb24gaXMgb3V0ZGF0ZWQgd2l0aCByZXNwZWN0IHRvIHRoZSByZW1vdGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gcmVtb3RlVHhIYXNoIC0gUmVtb3RlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgKiBAcGFyYW0gbG9jYWxUeEhhc2ggLSBMb2NhbCB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICogQHBhcmFtIHJlbW90ZVR4U3RhdHVzIC0gUmVtb3RlIHRyYW5zYWN0aW9uIHN0YXR1c1xuICAgICAqIEBwYXJhbSBsb2NhbFR4U3RhdHVzIC0gTG9jYWwgdHJhbnNhY3Rpb24gc3RhdHVzXG4gICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAqL1xuICAgIGlzU3RhdHVzT3V0ZGF0ZWQocmVtb3RlVHhIYXNoLCBsb2NhbFR4SGFzaCwgcmVtb3RlVHhTdGF0dXMsIGxvY2FsVHhTdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIHJlbW90ZVR4SGFzaCA9PT0gbG9jYWxUeEhhc2ggJiYgcmVtb3RlVHhTdGF0dXMgIT09IGxvY2FsVHhTdGF0dXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGlmIHRoZSBnYXMgZGF0YSBvZiBhIGxvY2FsIHRyYW5zYWN0aW9uIGlzIG91dGRhdGVkIHdpdGggcmVzcGVjdCB0byB0aGUgcmVtb3RlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHJlbW90ZUdhc1VzZWQgLSBSZW1vdGUgZ2FzIHVzZWQgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIGxvY2FsR2FzVXNlZCAtIExvY2FsIGdhcyB1c2VkIGluIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0dhc0RhdGFPdXRkYXRlZChyZW1vdGVHYXNVc2VkLCBsb2NhbEdhc1VzZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUdhc1VzZWQgIT09IGxvY2FsR2FzVXNlZDtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zYWN0aW9uQ29udHJvbGxlciA9IFRyYW5zYWN0aW9uQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFRyYW5zYWN0aW9uQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zYWN0aW9uQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RvcmVBc1N0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNsYXNzIE9ic2VydmFibGVTdG9yZVN0cmVhbSBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3Iob2JzU3RvcmUpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLy8gcGFzcyB2YWx1ZXMsIG5vdCBzZXJpYWxpemF0aW9uc1xuICAgICAgICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGRvbnQgYnVmZmVyIG91dGdvaW5nIHVwZGF0ZXNcbiAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgLy8gc2F2ZSBoYW5kbGVyIHNvIHdlIGNhbiB1bnN1YnNjcmliZSBsYXRlclxuICAgICAgICB0aGlzLmhhbmRsZXIgPSAoc3RhdGUpID0+IHRoaXMucHVzaChzdGF0ZSk7XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBvYnNTdG9yZSBjaGFuZ2VzXG4gICAgICAgIHRoaXMub2JzU3RvcmUgPSBvYnNTdG9yZTtcbiAgICAgICAgdGhpcy5vYnNTdG9yZS5zdWJzY3JpYmUodGhpcy5oYW5kbGVyKTtcbiAgICB9XG4gICAgLy8gZW1pdCBjdXJyZW50IHN0YXRlIG9uIG5ldyBkZXN0aW5hdGlvblxuICAgIHBpcGUoZGVzdCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5waXBlKGRlc3QsIG9wdGlvbnMpO1xuICAgICAgICBkZXN0LndyaXRlKHRoaXMub2JzU3RvcmUuZ2V0U3RhdGUoKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIHdyaXRlIGZyb20gaW5jb21pbmcgc3RyZWFtIHRvIHN0YXRlXG4gICAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub2JzU3RvcmUucHV0U3RhdGUoY2h1bmspO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICAvLyBub29wIC0gb3V0Z29pbmcgc3RyZWFtIGlzIGFza2luZyB1cyBpZiB3ZSBoYXZlIGRhdGEgd2UgYXJlbnQgZ2l2aW5nIGl0XG4gICAgX3JlYWQoX3NpemUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBldmVudCBlbWl0dGVyXG4gICAgX2Rlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9ic1N0b3JlLnVuc3Vic2NyaWJlKHRoaXMuaGFuZGxlcik7XG4gICAgICAgIHN1cGVyLl9kZXN0cm95KGVyciwgY2FsbGJhY2spO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0b3JlQXNTdHJlYW0ob2JzU3RvcmUpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTdG9yZVN0cmVhbShvYnNTdG9yZSk7XG59XG5leHBvcnRzLnN0b3JlQXNTdHJlYW0gPSBzdG9yZUFzU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNTdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXBvc2VkU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBPYnNlcnZhYmxlU3RvcmVfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKTtcbmNsYXNzIENvbXBvc2VkU3RvcmUgZXh0ZW5kcyBPYnNlcnZhYmxlU3RvcmVfMS5PYnNlcnZhYmxlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuKSB7XG4gICAgICAgIC8vIFR5cGVjYXN0OiBQcmVzZXJ2ZSBleGlzdGluZyBiZWhhdmlvclxuICAgICAgICBzdXBlcih7fSk7XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBjaGlsZHJlblxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9jaGlsZHJlbikuZm9yRWFjaCgoY2hpbGRLZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW5bY2hpbGRLZXldO1xuICAgICAgICAgICAgdGhpcy5fYWRkQ2hpbGQoY2hpbGRLZXksIGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGlsZChjaGlsZEtleSwgY2hpbGQpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlRnJvbUNoaWxkID0gKGNoaWxkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgc3RhdGVbY2hpbGRLZXldID0gY2hpbGRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUoc3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjaGlsZC5zdWJzY3JpYmUodXBkYXRlRnJvbUNoaWxkKTtcbiAgICAgICAgdXBkYXRlRnJvbUNoaWxkKGNoaWxkLmdldFN0YXRlKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcG9zZWRTdG9yZSA9IENvbXBvc2VkU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21wb3NlZFN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXJnZWRTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IE9ic2VydmFibGVTdG9yZV8xID0gcmVxdWlyZShcIi4vT2JzZXJ2YWJsZVN0b3JlXCIpO1xuY2xhc3MgTWVyZ2VkU3RvcmUgZXh0ZW5kcyBPYnNlcnZhYmxlU3RvcmVfMS5PYnNlcnZhYmxlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuID0gW10pIHtcbiAgICAgICAgLy8gVHlwZWNhc3Q6IFByZXNlcnZlIGV4aXN0aW5nIGJlaGF2aW9yXG4gICAgICAgIHN1cGVyKHt9KTtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGNoaWxkcmVuXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB0aGlzLl9hZGRDaGlsZChjaGlsZCkpO1xuICAgICAgICB0aGlzLl91cGRhdGVXaG9sZVN0YXRlKCk7XG4gICAgfVxuICAgIF9hZGRDaGlsZChjaGlsZCkge1xuICAgICAgICBjaGlsZC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fdXBkYXRlV2hvbGVTdGF0ZSgpKTtcbiAgICB9XG4gICAgX3VwZGF0ZVdob2xlU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkU3RhdGVzID0gdGhpcy5fY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQuZ2V0U3RhdGUoKSk7XG4gICAgICAgIC8vIGFwcGx5IHNoYWxsb3cgbWVyZ2Ugb3ZlciBzdGF0ZXNcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5jaGlsZFN0YXRlcyk7XG4gICAgICAgIHRoaXMucHV0U3RhdGUoc3RhdGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVyZ2VkU3RvcmUgPSBNZXJnZWRTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lcmdlZFN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PYnNlcnZhYmxlU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBzYWZlX2V2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1ldGFtYXNrL3NhZmUtZXZlbnQtZW1pdHRlclwiKSk7XG5jbGFzcyBPYnNlcnZhYmxlU3RvcmUgZXh0ZW5kcyBzYWZlX2V2ZW50X2VtaXR0ZXJfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0U3RhdGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKGluaXRTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBpbml0U3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUeXBlY2FzdC9kZWZhdWx0IHN0YXRlOiBQcmVzZXJ2ZSBleGlzdGluZyBiZWhhdmlvclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB3cmFwcGVyIGFyb3VuZCBpbnRlcm5hbCBnZXRTdGF0ZVxuICAgIGdldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3RhdGUoKTtcbiAgICB9XG4gICAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgcHV0U3RhdGVcbiAgICBwdXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLl9wdXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgbmV3U3RhdGUpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShwYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgLy8gaWYgbm9uLW51bGwgb2JqZWN0LCBtZXJnZVxuICAgICAgICBpZiAocGFydGlhbFN0YXRlICYmIHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHBhcnRpYWxTdGF0ZSkpO1xuICAgICAgICAgICAgLy8gaWYgbm90IG9iamVjdCwgdXNlIG5ldyB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wdXRTdGF0ZShwYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHN1YnNjcmliZSB0byBjaGFuZ2VzXG4gICAgc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5vbigndXBkYXRlJywgaGFuZGxlcik7XG4gICAgfVxuICAgIC8vIHVuc3Vic2NyaWJlIHRvIGNoYW5nZXNcbiAgICB1bnN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3VwZGF0ZScsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvL1xuICAgIC8vIHByaXZhdGVcbiAgICAvL1xuICAgIC8vIHJlYWQgZnJvbSBwZXJzaXN0ZW5jZVxuICAgIF9nZXRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICAvLyB3cml0ZSB0byBwZXJzaXN0ZW5jZVxuICAgIF9wdXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cbn1cbmV4cG9ydHMuT2JzZXJ2YWJsZVN0b3JlID0gT2JzZXJ2YWJsZVN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2YWJsZVN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdG9yZVRyYW5zZm9ybVN0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHRocm91Z2gyXzEgPSByZXF1aXJlKFwidGhyb3VnaDJcIik7XG5mdW5jdGlvbiBzdG9yZVRyYW5zZm9ybVN0cmVhbShzeW5jVHJhbnNmb3JtRm4pIHtcbiAgICByZXR1cm4gdGhyb3VnaDJfMS5vYmooKHN0YXRlLCBfZW5jb2RpbmcsIGNiKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHN5bmNUcmFuc2Zvcm1GbihzdGF0ZSk7XG4gICAgICAgICAgICBjYihudWxsLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnN0b3JlVHJhbnNmb3JtU3RyZWFtID0gc3RvcmVUcmFuc2Zvcm1TdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNUUkVBTV9OQU1FUyA9IHZvaWQgMDtcbi8vIEkgaGF2ZSBubyBpZGVhIHdoeSB0aGlzIHJ1bGUgZmlyZXMgYnV0IHlvdSBkbyB5b3UgZXNsaW50XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG52YXIgU1RSRUFNX05BTUVTO1xuKGZ1bmN0aW9uIChTVFJFQU1fTkFNRVMpIHtcbiAgICBTVFJFQU1fTkFNRVNbXCJKU09OX1JQQ1wiXSA9IFwianNvblJwY1wiO1xuICAgIFNUUkVBTV9OQU1FU1tcIkNPTU1BTkRcIl0gPSBcImNvbW1hbmRcIjtcbn0pKFNUUkVBTV9OQU1FUyA9IGV4cG9ydHMuU1RSRUFNX05BTUVTIHx8IChleHBvcnRzLlNUUkVBTV9OQU1FUyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlYWRhYmxlX3N0cmVhbV8xID0gcmVxdWlyZShcInJlYWRhYmxlLXN0cmVhbVwiKTtcbi8qKlxuICogVGFrZXMgYSBKc29uUnBjRW5naW5lIGFuZCByZXR1cm5zIGEgRHVwbGV4IHN0cmVhbSB3cmFwcGluZyBpdC5cbiAqXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICogQHBhcmFtIG9wdHMuZW5naW5lIC0gVGhlIEpzb25ScGNFbmdpbmUgdG8gd3JhcCBpbiBhIHN0cmVhbS5cbiAqIEByZXR1cm5zIFRoZSBzdHJlYW0gd3JhcHBpbmcgdGhlIGVuZ2luZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW5naW5lU3RyZWFtKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMgfHwgIW9wdHMuZW5naW5lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBlbmdpbmUgcGFyYW1ldGVyIScpO1xuICAgIH1cbiAgICBjb25zdCB7IGVuZ2luZSB9ID0gb3B0cztcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgcmVhZGFibGVfc3RyZWFtXzEuRHVwbGV4KHsgb2JqZWN0TW9kZTogdHJ1ZSwgcmVhZCwgd3JpdGUgfSk7XG4gICAgLy8gZm9yd2FyZCBub3RpZmljYXRpb25zXG4gICAgaWYgKGVuZ2luZS5vbikge1xuICAgICAgICBlbmdpbmUub24oJ25vdGlmaWNhdGlvbicsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0ucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW07XG4gICAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGUocmVxLCBfZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIGVuZ2luZS5oYW5kbGUocmVxLCAoX2VyciwgcmVzKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0ucHVzaChyZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2IoKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVFbmdpbmVTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVFbmdpbmVTdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBzYWZlX2V2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1ldGFtYXNrL3NhZmUtZXZlbnQtZW1pdHRlclwiKSk7XG5jb25zdCByZWFkYWJsZV9zdHJlYW1fMSA9IHJlcXVpcmUoXCJyZWFkYWJsZS1zdHJlYW1cIik7XG4vKipcbiAqIENyZWF0ZXMgYSBKc29uUnBjRW5naW5lIG1pZGRsZXdhcmUgd2l0aCBhbiBhc3NvY2lhdGVkIER1cGxleCBzdHJlYW0gYW5kXG4gKiBFdmVudEVtaXR0ZXIuIFRoZSBtaWRkbGV3YXJlLCBhbmQgYnkgZXh0ZW5zaW9uIHN0cmVhbSwgYXNzdW1lIHRoYXQgbWlkZGxld2FyZVxuICogcGFyYW1ldGVycyBhcmUgcHJvcGVybHkgZm9ybWF0dGVkLiBObyBydW50aW1lIHR5cGUgY2hlY2tpbmcgb3IgdmFsaWRhdGlvbiBpc1xuICogcGVyZm9ybWVkLlxuICpcbiAqIEByZXR1cm5zIFRoZSBldmVudCBlbWl0dGVyLCBtaWRkbGV3YXJlLCBhbmQgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlKCkge1xuICAgIGNvbnN0IGlkTWFwID0ge307XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IHJlYWRhYmxlX3N0cmVhbV8xLkR1cGxleCh7XG4gICAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgIHJlYWQ6IHJlYWROb29wLFxuICAgICAgICB3cml0ZTogcHJvY2Vzc01lc3NhZ2UsXG4gICAgfSk7XG4gICAgY29uc3QgZXZlbnRzID0gbmV3IHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQoKTtcbiAgICBjb25zdCBtaWRkbGV3YXJlID0gKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcbiAgICAgICAgLy8gd3JpdGUgcmVxIHRvIHN0cmVhbVxuICAgICAgICBzdHJlYW0ucHVzaChyZXEpO1xuICAgICAgICAvLyByZWdpc3RlciByZXF1ZXN0IG9uIGlkIG1hcFxuICAgICAgICBpZE1hcFtyZXEuaWRdID0geyByZXEsIHJlcywgbmV4dCwgZW5kIH07XG4gICAgfTtcbiAgICByZXR1cm4geyBldmVudHMsIG1pZGRsZXdhcmUsIHN0cmVhbSB9O1xuICAgIGZ1bmN0aW9uIHJlYWROb29wKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlKHJlcywgX2VuY29kaW5nLCBjYikge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXNOb3RpZmljYXRpb24gPSAhcmVzLmlkO1xuICAgICAgICAgICAgaWYgKGlzTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc05vdGlmaWNhdGlvbihyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgIGVyciA9IF9lcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29udGludWUgcHJvY2Vzc2luZyBzdHJlYW1cbiAgICAgICAgY2IoZXJyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Jlc3BvbnNlKHJlcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gaWRNYXBbcmVzLmlkXTtcbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmVhbU1pZGRsZXdhcmUgLSBVbmtub3duIHJlc3BvbnNlIGlkIFwiJHtyZXMuaWR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgaWRNYXBbcmVzLmlkXTtcbiAgICAgICAgLy8gY29weSB3aG9sZSByZXMgb250byBvcmlnaW5hbCByZXNcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LnJlcywgcmVzKTtcbiAgICAgICAgLy8gcnVuIGNhbGxiYWNrIG9uIGVtcHR5IHN0YWNrLFxuICAgICAgICAvLyBwcmV2ZW50IGludGVybmFsIHN0cmVhbS1oYW5kbGVyIGZyb20gY2F0Y2hpbmcgZXJyb3JzXG4gICAgICAgIHNldFRpbWVvdXQoY29udGV4dC5lbmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzTm90aWZpY2F0aW9uKHJlcykge1xuICAgICAgICBldmVudHMuZW1pdCgnbm90aWZpY2F0aW9uJywgcmVzKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlU3RyZWFtTWlkZGxld2FyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQmlwMzlLZXlGcm9tU2VlZCA9IGV4cG9ydHMuZGVyaXZlQ2hpbGRLZXkgPSBleHBvcnRzLmJpcDM5TW5lbW9uaWNUb011bHRpcGF0aCA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjcnlwdG9cIikpO1xuY29uc3QgYmlwMzlfMSA9IHJlcXVpcmUoXCJiaXAzOVwiKTtcbi8vIFRoaXMgbWFnaWMgY29uc3RhbnQgaXMgYW5hbG9nb3VzIHRvIGEgc2FsdCwgYW5kIGlzIGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuLy8gbWFqb3IgQklQLTMyIGltcGxlbWVudGF0aW9ucy5cbmNvbnN0IFJPT1RfQkFTRV9TRUNSRVQgPSBCdWZmZXIuZnJvbSgnQml0Y29pbiBzZWVkJywgJ3V0ZjgnKTtcbi8qKlxuICogQHBhcmFtIG1uZW1vbmljXG4gKi9cbmZ1bmN0aW9uIGJpcDM5TW5lbW9uaWNUb011bHRpcGF0aChtbmVtb25pYykge1xuICAgIHJldHVybiBgYmlwMzk6JHttbmVtb25pYy50b0xvd2VyQ2FzZSgpLnRyaW0oKX1gO1xufVxuZXhwb3J0cy5iaXAzOU1uZW1vbmljVG9NdWx0aXBhdGggPSBiaXAzOU1uZW1vbmljVG9NdWx0aXBhdGg7XG4vLyB0aGlzIGNyZWF0ZXMgYSBjaGlsZCBrZXkgdXNpbmcgYmlwMzksIGlnbm9yaW5nIHRoZSBwYXJlbnQga2V5XG4vKipcbiAqIEBwYXJhbSBwYXRoUGFydFxuICogQHBhcmFtIF9wYXJlbnRLZXlcbiAqL1xuZnVuY3Rpb24gZGVyaXZlQ2hpbGRLZXkocGF0aFBhcnQsIF9wYXJlbnRLZXkpIHtcbiAgICByZXR1cm4gY3JlYXRlQmlwMzlLZXlGcm9tU2VlZChiaXAzOV8xLm1uZW1vbmljVG9TZWVkU3luYyhwYXRoUGFydCkpO1xufVxuZXhwb3J0cy5kZXJpdmVDaGlsZEtleSA9IGRlcml2ZUNoaWxkS2V5O1xuLyoqXG4gKiBAcGFyYW0gc2VlZCAtIFRoZSBjcnlwdG9ncmFwaGljIHNlZWQgYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgb2YgdGhlIGNvcnJlc3BvbmRpbmcgQklQLTM5IG1hc3RlciBrZXkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJpcDM5S2V5RnJvbVNlZWQoc2VlZCkge1xuICAgIHJldHVybiBjcnlwdG9fMS5kZWZhdWx0LmNyZWF0ZUhtYWMoJ3NoYTUxMicsIFJPT1RfQkFTRV9TRUNSRVQpLnVwZGF0ZShzZWVkKS5kaWdlc3QoKTtcbn1cbmV4cG9ydHMuY3JlYXRlQmlwMzlLZXlGcm9tU2VlZCA9IGNyZWF0ZUJpcDM5S2V5RnJvbVNlZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaXAzOS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVyaXZlQ2hpbGRLZXkgPSBleHBvcnRzLnByaXZhdGVLZXlUb0V0aEFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbmNvbnN0IHNlY3AyNTZrMV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJzZWNwMjU2azFcIikpO1xuY29uc3Qga2VjY2FrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImtlY2Nha1wiKSk7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgSEFSREVORURfT0ZGU0VUID0gMHg4MDAwMDAwMDtcbi8qKlxuICogQ29udmVydHMgYSBCSVAtMzIgcHJpdmF0ZSBrZXkgdG8gYW4gRXRoZXJldW0gYWRkcmVzcy5cbiAqXG4gKiAqKldBUk5JTkc6KiogT25seSB2YWxpZGF0ZXMgdGhhdCB0aGUga2V5IGlzIG5vbi16ZXJvIGFuZCBvZiB0aGUgY29ycmVjdFxuICogbGVuZ3RoLiBJdCBpcyB0aGUgY29uc3VtZXIncyByZXNwb25zaWJpbGl0eSB0byBlbnN1cmUgdGhhdCB0aGUgc3BlY2lmaWVkXG4gKiBrZXkgaXMgYSB2YWxpZCBCSVAtNDQgRXRoZXJldW0gYGFkZHJlc3NfaW5kZXhgIGtleS5cbiAqXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGBhZGRyZXNzX2luZGV4YCBrZXkgYnVmZmVyIHRvIGNvbnZlcnQgdG8gYW4gRXRoZXJldW1cbiAqIGFkZHJlc3MuXG4gKiBAcmV0dXJucyBUaGUgRXRoZXJldW0gYWRkcmVzcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBrZXkuXG4gKi9cbmZ1bmN0aW9uIHByaXZhdGVLZXlUb0V0aEFkZHJlc3Moa2V5KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoa2V5KSB8fCAhdXRpbHNfMS5pc1ZhbGlkQnVmZmVyS2V5KGtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleTogVGhlIGtleSBtdXN0IGJlIGEgNjQtYnl0ZSwgbm9uLXplcm8gQnVmZmVyLicpO1xuICAgIH1cbiAgICBjb25zdCBwcml2YXRlS2V5ID0ga2V5LnNsaWNlKDAsIDMyKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBzZWNwMjU2azFfMS5kZWZhdWx0XG4gICAgICAgIC5wdWJsaWNLZXlDcmVhdGUobmV3IFVpbnQ4QXJyYXkocHJpdmF0ZUtleSksIGZhbHNlKVxuICAgICAgICAuc2xpY2UoMSk7XG4gICAgcmV0dXJuIGtlY2NhayhCdWZmZXIuZnJvbShwdWJsaWNLZXkpKS5zbGljZSgtMjApO1xufVxuZXhwb3J0cy5wcml2YXRlS2V5VG9FdGhBZGRyZXNzID0gcHJpdmF0ZUtleVRvRXRoQWRkcmVzcztcbi8qKlxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBrZWNjYWtCaXRzXG4gKi9cbmZ1bmN0aW9uIGtlY2NhayhkYXRhLCBrZWNjYWtCaXRzID0gJzI1NicpIHtcbiAgICByZXR1cm4ga2VjY2FrXzEuZGVmYXVsdChga2VjY2FrJHtrZWNjYWtCaXRzfWApLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn1cbi8qKlxuICogQHBhcmFtIHBhdGhQYXJ0XG4gKiBAcGFyYW0gcGFyZW50S2V5XG4gKi9cbmZ1bmN0aW9uIGRlcml2ZUNoaWxkS2V5KHBhdGhQYXJ0LCBwYXJlbnRLZXkpIHtcbiAgICBpZiAoIXBhcmVudEtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyczogTXVzdCBzcGVjaWZ5IGEgcGFyZW50IGtleS4nKTtcbiAgICB9XG4gICAgaWYgKHBhcmVudEtleS5sZW5ndGggIT09IGNvbnN0YW50c18xLkJVRkZFUl9LRVlfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXJlbnQga2V5OiBNdXN0IGJlIDY0IGJ5dGVzIGxvbmcuJyk7XG4gICAgfVxuICAgIGNvbnN0IGlzSGFyZGVuZWQgPSBwYXRoUGFydC5pbmNsdWRlcyhgJ2ApO1xuICAgIGNvbnN0IGluZGV4UGFydCA9IHBhdGhQYXJ0LnNwbGl0KGAnYClbMF07XG4gICAgY29uc3QgY2hpbGRJbmRleCA9IHBhcnNlSW50KGluZGV4UGFydCwgMTApO1xuICAgIGlmICghL15cXGQrJC91LnRlc3QoaW5kZXhQYXJ0KSB8fFxuICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihjaGlsZEluZGV4KSB8fFxuICAgICAgICBjaGlsZEluZGV4IDwgMCB8fFxuICAgICAgICBjaGlsZEluZGV4ID49IEhBUkRFTkVEX09GRlNFVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQklQLTMyIGluZGV4OiBUaGUgaW5kZXggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBkZWNpbWFsIGludGVnZXIgbGVzcyB0aGFuICR7SEFSREVORURfT0ZGU0VUfS5gKTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50UHJpdmF0ZUtleSA9IHBhcmVudEtleS5zbGljZSgwLCAzMik7XG4gICAgY29uc3QgcGFyZW50RXh0cmFFbnRyb3B5ID0gcGFyZW50S2V5LnNsaWNlKDMyKTtcbiAgICBjb25zdCBzZWNyZXRFeHRlbnNpb24gPSBkZXJpdmVTZWNyZXRFeHRlbnNpb24oe1xuICAgICAgICBwYXJlbnRQcml2YXRlS2V5LFxuICAgICAgICBjaGlsZEluZGV4LFxuICAgICAgICBpc0hhcmRlbmVkLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgcHJpdmF0ZUtleSwgZXh0cmFFbnRyb3B5IH0gPSBnZW5lcmF0ZUtleSh7XG4gICAgICAgIHBhcmVudFByaXZhdGVLZXksXG4gICAgICAgIHBhcmVudEV4dHJhRW50cm9weSxcbiAgICAgICAgc2VjcmV0RXh0ZW5zaW9uLFxuICAgIH0pO1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtwcml2YXRlS2V5LCBleHRyYUVudHJvcHldKTtcbn1cbmV4cG9ydHMuZGVyaXZlQ2hpbGRLZXkgPSBkZXJpdmVDaGlsZEtleTtcbi8vIHRoZSBiaXAzMiBzZWNyZXQgZXh0ZW5zaW9uIGlzIGNyZWF0ZWQgZnJvbSB0aGUgcGFyZW50IHByaXZhdGUgb3IgcHVibGljIGtleSBhbmQgdGhlIGNoaWxkIGluZGV4XG4vKipcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9ucy5wYXJlbnRQcml2YXRlS2V5XG4gKiBAcGFyYW0gb3B0aW9ucy5jaGlsZEluZGV4XG4gKiBAcGFyYW0gb3B0aW9ucy5pc0hhcmRlbmVkXG4gKi9cbmZ1bmN0aW9uIGRlcml2ZVNlY3JldEV4dGVuc2lvbih7IHBhcmVudFByaXZhdGVLZXksIGNoaWxkSW5kZXgsIGlzSGFyZGVuZWQsIH0pIHtcbiAgICBpZiAoaXNIYXJkZW5lZCkge1xuICAgICAgICAvLyBIYXJkZW5lZCBjaGlsZFxuICAgICAgICBjb25zdCBpbmRleEJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KTtcbiAgICAgICAgaW5kZXhCdWZmZXIud3JpdGVVSW50MzJCRShjaGlsZEluZGV4ICsgSEFSREVORURfT0ZGU0VULCAwKTtcbiAgICAgICAgY29uc3QgcGsgPSBwYXJlbnRQcml2YXRlS2V5O1xuICAgICAgICBjb25zdCB6YiA9IEJ1ZmZlci5hbGxvYygxLCAwKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3piLCBwaywgaW5kZXhCdWZmZXJdKTtcbiAgICB9XG4gICAgLy8gTm9ybWFsIGNoaWxkXG4gICAgY29uc3QgaW5kZXhCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCk7XG4gICAgaW5kZXhCdWZmZXIud3JpdGVVSW50MzJCRShjaGlsZEluZGV4LCAwKTtcbiAgICBjb25zdCBwYXJlbnRQdWJsaWNLZXkgPSBzZWNwMjU2azFfMS5kZWZhdWx0LnB1YmxpY0tleUNyZWF0ZShuZXcgVWludDhBcnJheShwYXJlbnRQcml2YXRlS2V5KSwgdHJ1ZSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3BhcmVudFB1YmxpY0tleSwgaW5kZXhCdWZmZXJdKTtcbn1cbi8qKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zLnBhcmVudFByaXZhdGVLZXlcbiAqIEBwYXJhbSBvcHRpb25zLnBhcmVudEV4dHJhRW50cm9weVxuICogQHBhcmFtIG9wdGlvbnMuc2VjcmV0RXh0ZW5zaW9uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5KHsgcGFyZW50UHJpdmF0ZUtleSwgcGFyZW50RXh0cmFFbnRyb3B5LCBzZWNyZXRFeHRlbnNpb24sIH0pIHtcbiAgICBjb25zdCBlbnRyb3B5ID0gY3J5cHRvXzEuZGVmYXVsdFxuICAgICAgICAuY3JlYXRlSG1hYygnc2hhNTEyJywgcGFyZW50RXh0cmFFbnRyb3B5KVxuICAgICAgICAudXBkYXRlKHNlY3JldEV4dGVuc2lvbilcbiAgICAgICAgLmRpZ2VzdCgpO1xuICAgIGNvbnN0IGtleU1hdGVyaWFsID0gZW50cm9weS5zbGljZSgwLCAzMik7XG4gICAgLy8gZXh0cmFFbnRyb3B5IGlzIGFsc28gY2FsbGVkIFwiY2hhaW5jb2RlXCJcbiAgICBjb25zdCBleHRyYUVudHJvcHkgPSBlbnRyb3B5LnNsaWNlKDMyKTtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gc2VjcDI1NmsxXzEuZGVmYXVsdC5wcml2YXRlS2V5VHdlYWtBZGQobmV3IFVpbnQ4QXJyYXkocGFyZW50UHJpdmF0ZUtleSksIG5ldyBVaW50OEFycmF5KGtleU1hdGVyaWFsKSk7XG4gICAgcmV0dXJuIHsgcHJpdmF0ZUtleSwgZXh0cmFFbnRyb3B5IH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaXAzMi5qcy5tYXAiLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2VuZC1vZi1zdHJlYW0gd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZW9zKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gIHZhciByZWFkYWJsZSA9IG9wdHMucmVhZGFibGUgfHwgb3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlO1xuICB2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IG9wdHMud3JpdGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS53cml0YWJsZTtcblxuICB2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbiBvbmxlZ2FjeWZpbmlzaCgpIHtcbiAgICBpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcbiAgfTtcblxuICB2YXIgd3JpdGFibGVFbmRlZCA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZSAmJiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQ7XG5cbiAgdmFyIG9uZmluaXNoID0gZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgd3JpdGFibGUgPSBmYWxzZTtcbiAgICB3cml0YWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXJlYWRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIHJlYWRhYmxlRW5kZWQgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQ7XG5cbiAgdmFyIG9uZW5kID0gZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICByZWFkYWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICB9O1xuXG4gIHZhciBvbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICB2YXIgZXJyO1xuXG4gICAgaWYgKHJlYWRhYmxlICYmICFyZWFkYWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fcmVhZGFibGVTdGF0ZSB8fCAhc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBpZiAod3JpdGFibGUgJiYgIXdyaXRhYmxlRW5kZWQpIHtcbiAgICAgIGlmICghc3RyZWFtLl93cml0YWJsZVN0YXRlIHx8ICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24gb25yZXF1ZXN0KCkge1xuICAgIHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgfTtcblxuICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcbiAgICBzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgb25yZXF1ZXN0KCk7ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICB9IGVsc2UgaWYgKHdyaXRhYmxlICYmICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAvLyBsZWdhY3kgc3RyZWFtc1xuICAgIHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gIH1cblxuICBzdHJlYW0ub24oJ2VuZCcsIG9uZW5kKTtcbiAgc3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIGlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlb3M7IiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9wdW1wIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW9zO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7XG5cbmZ1bmN0aW9uIG5vb3AoZXJyKSB7XG4gIC8vIFJldGhyb3cgdGhlIGVycm9yIGlmIGl0IGV4aXN0cyB0byBhdm9pZCBzd2FsbG93aW5nIGl0XG4gIGlmIChlcnIpIHRocm93IGVycjtcbn1cblxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICB2YXIgY2xvc2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChlb3MgPT09IHVuZGVmaW5lZCkgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG4gIGVvcyhzdHJlYW0sIHtcbiAgICByZWFkYWJsZTogcmVhZGluZyxcbiAgICB3cml0YWJsZTogd3JpdGluZ1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgICBjYWxsYmFjaygpO1xuICB9KTtcbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjbG9zZWQpIHJldHVybjtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTsgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnRcblxuICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5hYm9ydCgpO1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpO1xuICAgIGNhbGxiYWNrKGVyciB8fCBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3BpcGUnKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGwoZm4pIHtcbiAgZm4oKTtcbn1cblxuZnVuY3Rpb24gcGlwZShmcm9tLCB0bykge1xuICByZXR1cm4gZnJvbS5waXBlKHRvKTtcbn1cblxuZnVuY3Rpb24gcG9wQ2FsbGJhY2soc3RyZWFtcykge1xuICBpZiAoIXN0cmVhbXMubGVuZ3RoKSByZXR1cm4gbm9vcDtcbiAgaWYgKHR5cGVvZiBzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gIT09ICdmdW5jdGlvbicpIHJldHVybiBub29wO1xuICByZXR1cm4gc3RyZWFtcy5wb3AoKTtcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN0cmVhbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgY2FsbGJhY2sgPSBwb3BDYWxsYmFjayhzdHJlYW1zKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc1swXSkpIHN0cmVhbXMgPSBzdHJlYW1zWzBdO1xuXG4gIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnc3RyZWFtcycpO1xuICB9XG5cbiAgdmFyIGVycm9yO1xuICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtLCBpKSB7XG4gICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxO1xuICAgIHZhciB3cml0aW5nID0gaSA+IDA7XG4gICAgcmV0dXJuIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuICAgICAgaWYgKGVycikgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm47XG4gICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cbid1c2Ugc3RyaWN0Jztcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcblxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gQWxsb3cgdGhlIGtleXMgYXJyYXkgdG8gYmUgR0MnZWQuXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuXG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcblxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIElmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLCB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuOyAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuXG4gIHByb2Nlc3MubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn0gLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cblxuXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgICBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxcbiAgICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICAgIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsgLy8gZHJhaW4gZXZlbnQgZmxhZy5cblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOyAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7IC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcblxuICB0aGlzLmVuZGVkID0gZmFsc2U7IC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cblxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7IC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcblxuICB0aGlzLmNvcmtlZCA9IDA7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7IC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcblxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9OyAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcblxuXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7IC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cblxuICB0aGlzLndyaXRlbGVuID0gMDtcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOyAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcblxuICB0aGlzLnBlbmRpbmdjYiA9IDA7IC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcblxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdmaW5pc2gnIChhbmQgcG90ZW50aWFsbHkgJ2VuZCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG5cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpOyAvLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cblxuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTsgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBXcml0YWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5LlxuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn0gLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuXG5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQoKTsgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcblxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xufSAvLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5cblxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIGVyO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJ10sIGNodW5rKTtcbiAgfVxuXG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuXG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7IC8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyazsgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG5cbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59IC8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuXG5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn0gLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcblxuXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG5cbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTsgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcblxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cblxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ193cml0ZSgpJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTsgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9IC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cblxuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuXG4gICAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgICAvLyBpZiB0aGUgcmVhZGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuXG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9IC8vIHJldXNlIHRoZSBmcmVlIGNvcmtSZXEuXG5cblxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyxcbiAgICBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzA7XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCkpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG4gIGNiKGVyKTtcbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuXG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9OyAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9IC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cblxuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCkge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTsgLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ190cmFuc2Zvcm0oKScpKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG5cbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59OyAvLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpOyAvLyBUT0RPKEJyaWRnZUFSKTogV3JpdGUgYSB0ZXN0IGZvciB0aGVzZSB0d28gZXJyb3IgY2FzZXNcbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcblxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCgpO1xuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HKCk7XG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgZGVidWc7XG5cbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0Jyk7XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7IC8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXG5cblxudmFyIFN0cmluZ0RlY29kZXI7XG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yO1xudmFyIGZyb207XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7IC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG5cbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7IC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcblxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuXG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7IC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFJlYWRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5XG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IC8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTsgLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgZGVidWcoJ3JlYWRhYmxlQWRkQ2h1bmsnLCBjaHVuayk7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcblxuICAgIGlmIChlcikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQoKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSAvLyBXZSBjYW4gcHVzaCBtb3JlIGRhdGEgaWYgd2UgYXJlIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLlxuICAvLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZSBtb3JlIGJ5dGVzLlxuICAvLyBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLCBzdWNoIGFzIHRoZSByZXBsLlxuXG5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG5cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG5cbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInLCAnVWludDhBcnJheSddLCBjaHVuayk7XG4gIH1cblxuICByZXR1cm4gZXI7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHZhciBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gZGVjb2RlcjsgLy8gSWYgc2V0RW5jb2RpbmcobnVsbCksIGRlY29kZXIuZW5jb2RpbmcgZXF1YWxzIHV0ZjhcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nOyAvLyBJdGVyYXRlIG92ZXIgY3VycmVudCBidWZmZXIgdG8gY29udmVydCBhbHJlYWR5IHN0b3JlZCBCdWZmZXJzOlxuXG4gIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICB3aGlsZSAocCAhPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShwLmRhdGEpO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuXG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXG5cblxudmFyIE1BWF9IV00gPSAweDQwMDAwMDAwO1xuXG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAvLyBUT0RPKHJvbmFnKTogVGhyb3cgRVJSX1ZBTFVFX09VVF9PRl9SQU5HRS5cbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG5cbiAgcmV0dXJuIG47XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG5cbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH0gLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG5cblxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjsgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcblxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59IC8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7IC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKChzdGF0ZS5oaWdoV2F0ZXJNYXJrICE9PSAwID8gc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgOiBzdGF0ZS5sZW5ndGggPiAwKSB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7IC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cblxuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfSAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG5cblxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlOyAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcblxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1Zygnb25Fb2ZDaHVuaycpO1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcblxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG5cbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGxcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAgIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH1cbiAgfVxufSAvLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuXG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGVfJywgc3RhdGUuZGVzdHJveWVkLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcblxuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB9IC8vIFRoZSBzdHJlYW0gbmVlZHMgYW5vdGhlciByZWFkYWJsZSBldmVudCBpZlxuICAvLyAxLiBJdCBpcyBub3QgZmxvd2luZywgYXMgdGhlIGZsb3cgbWVjaGFuaXNtIHdpbGwgdGFrZVxuICAvLyAgICBjYXJlIG9mIGl0LlxuICAvLyAyLiBJdCBpcyBub3QgZW5kZWQuXG4gIC8vIDMuIEl0IGlzIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLCBzbyB3ZSBjYW4gc2NoZWR1bGVcbiAgLy8gICAgYW5vdGhlciByZWFkYWJsZSBsYXRlci5cblxuXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgZmxvdyhzdHJlYW0pO1xufSAvLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cblxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIEF0dGVtcHQgdG8gcmVhZCBtb3JlIGRhdGEgaWYgd2Ugc2hvdWxkLlxuICAvL1xuICAvLyBUaGUgY29uZGl0aW9ucyBmb3IgcmVhZGluZyBtb3JlIGRhdGEgYXJlIChvbmUgb2YpOlxuICAvLyAtIE5vdCBlbm91Z2ggZGF0YSBidWZmZXJlZCAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykuIFRoZSBsb29wXG4gIC8vICAgaXMgcmVzcG9uc2libGUgZm9yIGZpbGxpbmcgdGhlIGJ1ZmZlciB3aXRoIGVub3VnaCBkYXRhIGlmIHN1Y2ggZGF0YVxuICAvLyAgIGlzIGF2YWlsYWJsZS4gSWYgaGlnaFdhdGVyTWFyayBpcyAwIGFuZCB3ZSBhcmUgbm90IGluIHRoZSBmbG93aW5nIG1vZGVcbiAgLy8gICB3ZSBzaG91bGQgX25vdF8gYXR0ZW1wdCB0byBidWZmZXIgYW55IGV4dHJhIGRhdGEuIFdlJ2xsIGdldCBtb3JlIGRhdGFcbiAgLy8gICB3aGVuIHRoZSBzdHJlYW0gY29uc3VtZXIgY2FsbHMgcmVhZCgpIGluc3RlYWQuXG4gIC8vIC0gTm8gZGF0YSBpbiB0aGUgYnVmZmVyLCBhbmQgdGhlIHN0cmVhbSBpcyBpbiBmbG93aW5nIG1vZGUuIEluIHRoaXMgbW9kZVxuICAvLyAgIHRoZSBsb29wIGJlbG93IGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyByZWFkKCkgaXMgY2FsbGVkLiBGYWlsaW5nIHRvXG4gIC8vICAgY2FsbCByZWFkIGhlcmUgd291bGQgYWJvcnQgdGhlIGZsb3cgYW5kIHRoZXJlJ3Mgbm8gb3RoZXIgbWVjaGFuaXNtIGZvclxuICAvLyAgIGNvbnRpbnVpbmcgdGhlIGZsb3cgaWYgdGhlIHN0cmVhbSBjb25zdW1lciBoYXMganVzdCBzdWJzY3JpYmVkIHRvIHRoZVxuICAvLyAgICdkYXRhJyBldmVudC5cbiAgLy9cbiAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIGFib3ZlIGNvbmRpdGlvbnMgdG8ga2VlcCByZWFkaW5nIGRhdGEsIHRoZSBmb2xsb3dpbmdcbiAgLy8gY29uZGl0aW9ucyBwcmV2ZW50IHRoZSBkYXRhIGZyb20gYmVpbmcgcmVhZDpcbiAgLy8gLSBUaGUgc3RyZWFtIGhhcyBlbmRlZCAoc3RhdGUuZW5kZWQpLlxuICAvLyAtIFRoZXJlIGlzIGFscmVhZHkgYSBwZW5kaW5nICdyZWFkJyBvcGVyYXRpb24gKHN0YXRlLnJlYWRpbmcpLiBUaGlzIGlzIGFcbiAgLy8gICBjYXNlIHdoZXJlIHRoZSB0aGUgc3RyZWFtIGhhcyBjYWxsZWQgdGhlIGltcGxlbWVudGF0aW9uIGRlZmluZWQgX3JlYWQoKVxuICAvLyAgIG1ldGhvZCwgYnV0IHRoZXkgYXJlIHByb2Nlc3NpbmcgdGhlIGNhbGwgYXN5bmNocm9ub3VzbHkgYW5kIGhhdmUgX25vdF9cbiAgLy8gICBjYWxsZWQgcHVzaCgpIHdpdGggbmV3IGRhdGEuIEluIHRoaXMgY2FzZSB3ZSBza2lwIHBlcmZvcm1pbmcgbW9yZVxuICAvLyAgIHJlYWQoKXMuIFRoZSBleGVjdXRpb24gZW5kcyBpbiB0aGlzIG1ldGhvZCBhZ2FpbiBhZnRlciB0aGUgX3JlYWQoKSBlbmRzXG4gIC8vICAgdXAgY2FsbGluZyBwdXNoKCkgd2l0aCBtb3JlIGRhdGEuXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDApKSB7XG4gICAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59IC8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG5cbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcblxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9IC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuXG5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpOyAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGNsZWFuZWRVcCA9IHRydWU7IC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgZGVidWcoJ2Rlc3Qud3JpdGUnLCByZXQpO1xuXG4gICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICB9XG5cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfSAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuXG5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZXJyb3JPckRlc3Ryb3koZGVzdCwgZXIpO1xuICB9IC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cblxuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTsgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcblxuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9IC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG5cblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpOyAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHtcbiAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICB9OyAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzOyAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7IC8vIGdvdCBhIG1hdGNoLlxuXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywge1xuICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cblxuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gdXBkYXRlIHJlYWRhYmxlTGlzdGVuaW5nIHNvIHRoYXQgcmVzdW1lKCkgbWF5IGJlIGEgbm8tb3BcbiAgICAvLyBhIGZldyBsaW5lcyBkb3duLiBUaGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJykuXG4gICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwOyAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG5cbiAgICBpZiAoc3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGRlYnVnKCdvbiByZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUucmVhZGluZyk7XG5cbiAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2KSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nKHNlbGYpIHtcbiAgdmFyIHN0YXRlID0gc2VsZi5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwO1xuXG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgIC8vIGZsb3dpbmcgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgbm93LCBvdGhlcndpc2VcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7IC8vIGNydWRlIHdheSB0byBjaGVjayBpZiB3ZSBzaG91bGQgcmVzdW1lXG4gIH0gZWxzZSBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKSB7XG4gICAgc2VsZi5yZXN1bWUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59IC8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTsgLy8gd2UgZmxvdyBvbmx5IGlmIHRoZXJlIGlzIG5vIG9uZSBsaXN0ZW5pbmdcbiAgICAvLyBmb3IgcmVhZGFibGUsIGJ1dCB3ZSBzdGlsbCBoYXZlIHRvIGNhbGxcbiAgICAvLyByZXN1bWUoKVxuXG4gICAgc3RhdGUuZmxvd2luZyA9ICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZztcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG5cbiAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdyZXN1bWUnLCBzdGF0ZS5yZWFkaW5nKTtcblxuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5wYXVzZWQgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcblxuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7XG4gICAgO1xuICB9XG59IC8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG5cbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7IC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiBtZXRob2RXcmFwKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfSAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG5cblxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9IC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG5cblxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuXG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvcicpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcyk7XG4gIH07XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTtcbiAgICB9XG4gIH1cbn0pOyAvLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmZpcnN0KCk7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlTlQnLCBzdGF0ZS5lbmRFbWl0dGVkLCBzdGF0ZS5sZW5ndGgpOyAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblxuICAgICAgaWYgKCF3U3RhdGUgfHwgd1N0YXRlLmF1dG9EZXN0cm95ICYmIHdTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5mcm9tID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBvcHRzKSB7XG4gICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJvbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9mcm9tJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cblxuICByZXR1cm4gLTE7XG59IiwiJ3VzZSBzdHJpY3QnXG52YXIgQk4gPSByZXF1aXJlKCcuL2JuJylcblxuZnVuY3Rpb24gRUNKUG9pbnQgKHgsIHksIHopIHtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gRUNKUG9pbnQub25lXG4gICAgdGhpcy55ID0gRUNKUG9pbnQub25lXG4gICAgdGhpcy56ID0gRUNKUG9pbnQuemVyb1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IHhcbiAgICB0aGlzLnkgPSB5XG4gICAgdGhpcy56ID0gelxuICB9XG5cbiAgdGhpcy56T25lID0gdGhpcy56ID09PSBFQ0pQb2ludC5vbmVcbn1cblxuRUNKUG9pbnQuemVybyA9IEJOLmZyb21OdW1iZXIoMClcbkVDSlBvaW50Lm9uZSA9IEJOLmZyb21OdW1iZXIoMSlcblxuRUNKUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaW5mKSByZXR1cm4gdGhpc1xuXG4gIHJldHVybiBuZXcgRUNKUG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCksIHRoaXMueilcbn1cblxuRUNKUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pbmYpIHJldHVybiBwXG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmluZikgcmV0dXJuIHRoaXNcblxuICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWwjYWRkaXRpb24tYWRkLTE5OTgtY21vLTJcbiAgLy8gMTJNICsgNFMgKyA3QVxuICB2YXIgcHoyID0gcC56LnJlZFNxcigpXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKVxuICB2YXIgdTEgPSB0aGlzLngucmVkTXVsKHB6MilcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6MilcbiAgdmFyIHMxID0gdGhpcy55LnJlZE11bChwejIpLnJlZE11bChwLnopXG4gIHZhciBzMiA9IHAueS5yZWRNdWwoejIpLnJlZE11bCh0aGlzLnopXG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpXG4gIHZhciByID0gczEucmVkU3ViKHMyKVxuICBpZiAoaC5pc1plcm8oKSkge1xuICAgIGlmIChyLmlzWmVybygpKSByZXR1cm4gdGhpcy5kYmwoKVxuICAgIHJldHVybiBuZXcgRUNKUG9pbnQobnVsbCwgbnVsbCwgbnVsbClcbiAgfVxuXG4gIHZhciBoMiA9IGgucmVkU3FyKClcbiAgdmFyIHYgPSB1MS5yZWRNdWwoaDIpXG4gIHZhciBoMyA9IGgyLnJlZE11bChoKVxuXG4gIHZhciBueCA9IHIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpXG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSlcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChwLnopLnJlZE11bChoKVxuXG4gIHJldHVybiBuZXcgRUNKUG9pbnQobngsIG55LCBueilcbn1cblxuRUNKUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gZnVuY3Rpb24gKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmluZikgcmV0dXJuIHAudG9FQ0pQb2ludCgpXG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmluZikgcmV0dXJuIHRoaXNcblxuICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWwjYWRkaXRpb24tYWRkLTE5OTgtY21vLTJcbiAgLy8gICB3aXRoIHAueiA9IDFcbiAgLy8gOE0gKyAzUyArIDdBXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKVxuICB2YXIgdTEgPSB0aGlzLnhcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6MilcbiAgdmFyIHMxID0gdGhpcy55XG4gIHZhciBzMiA9IHAueS5yZWRNdWwoejIpLnJlZE11bCh0aGlzLnopXG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpXG4gIHZhciByID0gczEucmVkU3ViKHMyKVxuICBpZiAoaC5pc1plcm8oKSkge1xuICAgIGlmIChyLmlzWmVybygpKSByZXR1cm4gdGhpcy5kYmwoKVxuICAgIHJldHVybiBuZXcgRUNKUG9pbnQobnVsbCwgbnVsbCwgbnVsbClcbiAgfVxuXG4gIHZhciBoMiA9IGgucmVkU3FyKClcbiAgdmFyIHYgPSB1MS5yZWRNdWwoaDIpXG4gIHZhciBoMyA9IGgyLnJlZE11bChoKVxuXG4gIHZhciBueCA9IHIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpXG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSlcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChoKVxuXG4gIHJldHVybiBuZXcgRUNKUG9pbnQobngsIG55LCBueilcbn1cblxuRUNKUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaW5mKSByZXR1cm4gdGhpc1xuXG4gIHZhciBueFxuICB2YXIgbnlcbiAgdmFyIG56XG5cbiAgLy8gWiA9IDFcbiAgaWYgKHRoaXMuek9uZSkge1xuICAgIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCNkb3VibGluZy1tZGJsLTIwMDctYmxcbiAgICAvLyAxTSArIDVTICsgNkEgKyAzKjIgKyAxKjMgKyAxKjhcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKVxuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKVxuICAgIC8vIFlZWVkgPSBZWV4yXG4gICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKVxuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KVxuICAgIHMgPSBzLnJlZElBZGQocylcbiAgICAvLyBNID0gMyAqIFhYXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpXG4gICAgLy8gVCA9IE0gXiAyIC0gMipTXG4gICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKVxuXG4gICAgLy8gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSkucmVkSUFkZCh5eXl5KS5yZWRJQWRkKHl5eXkpXG5cbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHRcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OClcbiAgICAvLyBaMyA9IDIqWTFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KVxuICB9IGVsc2Uge1xuICAgIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCNkb3VibGluZy1kYmwtMjAwOS1sXG4gICAgLy8gMk0gKyA1UyArIDZBICsgMyoyICsgMSozICsgMSo4XG5cbiAgICAvLyBBID0gWDFeMlxuICAgIHZhciBhID0gdGhpcy54LnJlZFNxcigpXG4gICAgLy8gQiA9IFkxXjJcbiAgICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKVxuICAgIC8vIEMgPSBCXjJcbiAgICB2YXIgYyA9IGIucmVkU3FyKClcbiAgICAvLyBEID0gMiAqICgoWDEgKyBCKV4yIC0gQSAtIEMpXG4gICAgdmFyIGQgPSB0aGlzLngucmVkQWRkKGIpLnJlZFNxcigpLnJlZElTdWIoYSkucmVkSVN1YihjKVxuICAgIGQgPSBkLnJlZElBZGQoZClcbiAgICAvLyBFID0gMyAqIEFcbiAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSlcbiAgICAvLyBGID0gRV4yXG4gICAgdmFyIGYgPSBlLnJlZFNxcigpXG5cbiAgICAvLyA4ICogQ1xuICAgIHZhciBjOCA9IGMucmVkSUFkZChjKS5yZWRJQWRkKGMpLnJlZElBZGQoYylcblxuICAgIC8vIFgzID0gRiAtIDIgKiBEXG4gICAgbnggPSBmLnJlZElTdWIoZCkucmVkSVN1YihkKVxuICAgIC8vIFkzID0gRSAqIChEIC0gWDMpIC0gOCAqIENcbiAgICBueSA9IGUucmVkTXVsKGQucmVkSVN1YihueCkpLnJlZElTdWIoYzgpXG4gICAgLy8gWjMgPSAyICogWTEgKiBaMVxuICAgIG56ID0gdGhpcy55LnJlZE11bCh0aGlzLnopXG4gICAgbnogPSBuei5yZWRJQWRkKG56KVxuICB9XG5cbiAgcmV0dXJuIG5ldyBFQ0pQb2ludChueCwgbnksIG56KVxufVxuXG5FQ0pQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIChwb3cpIHtcbiAgaWYgKHBvdyA9PT0gMCB8fCB0aGlzLmluZikgcmV0dXJuIHRoaXNcblxuICB2YXIgcG9pbnQgPSB0aGlzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG93OyBpKyspIHBvaW50ID0gcG9pbnQuZGJsKClcblxuICByZXR1cm4gcG9pbnRcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVDSlBvaW50LnByb3RvdHlwZSwgJ2luZicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuei5pc1plcm8oKVxuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVDSlBvaW50XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwic2hhMVwiOiB7XG4gICAgXCJzZWN1cml0eVN0cmVuZ3RoXCI6IDEyOCxcbiAgICBcIm91dGxlblwiOiAxNjAsXG4gICAgXCJzZWVkbGVuXCI6IDQ0MFxuICB9LFxuICBcInNoYTIyNFwiOiB7XG4gICAgXCJzZWN1cml0eVN0cmVuZ3RoXCI6IDE5MixcbiAgICBcIm91dGxlblwiOiAyMjQsXG4gICAgXCJzZWVkbGVuXCI6IDQ0MFxuICB9LFxuICBcInNoYTI1NlwiOiB7XG4gICAgXCJzZWN1cml0eVN0cmVuZ3RoXCI6IDI1NixcbiAgICBcIm91dGxlblwiOiAyNTYsXG4gICAgXCJzZWVkbGVuXCI6IDQ0MFxuICB9LFxuICBcInNoYTM4NFwiOiB7XG4gICAgXCJzZWN1cml0eVN0cmVuZ3RoXCI6IDI1NixcbiAgICBcIm91dGxlblwiOiAzODQsXG4gICAgXCJzZWVkbGVuXCI6IDg4OFxuICB9LFxuICBcInNoYTUxMlwiOiB7XG4gICAgXCJzZWN1cml0eVN0cmVuZ3RoXCI6IDI1NixcbiAgICBcIm91dGxlblwiOiA1MTIsXG4gICAgXCJzZWVkbGVuXCI6IDg4OFxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbmV4cG9ydHMudW11bFRvMTB4MTAgPSBmdW5jdGlvbiAobnVtMSwgbnVtMiwgb3V0KSB7XG4gIHZhciBhID0gbnVtMS53b3Jkc1xuICB2YXIgYiA9IG51bTIud29yZHNcbiAgdmFyIG8gPSBvdXQud29yZHNcbiAgdmFyIGMgPSAwXG4gIHZhciBsb1xuICB2YXIgbWlkXG4gIHZhciBoaVxuICB2YXIgYTAgPSBhWzBdIHwgMFxuICB2YXIgYWwwID0gYTAgJiAweDFmZmZcbiAgdmFyIGFoMCA9IGEwID4+PiAxM1xuICB2YXIgYTEgPSBhWzFdIHwgMFxuICB2YXIgYWwxID0gYTEgJiAweDFmZmZcbiAgdmFyIGFoMSA9IGExID4+PiAxM1xuICB2YXIgYTIgPSBhWzJdIHwgMFxuICB2YXIgYWwyID0gYTIgJiAweDFmZmZcbiAgdmFyIGFoMiA9IGEyID4+PiAxM1xuICB2YXIgYTMgPSBhWzNdIHwgMFxuICB2YXIgYWwzID0gYTMgJiAweDFmZmZcbiAgdmFyIGFoMyA9IGEzID4+PiAxM1xuICB2YXIgYTQgPSBhWzRdIHwgMFxuICB2YXIgYWw0ID0gYTQgJiAweDFmZmZcbiAgdmFyIGFoNCA9IGE0ID4+PiAxM1xuICB2YXIgYTUgPSBhWzVdIHwgMFxuICB2YXIgYWw1ID0gYTUgJiAweDFmZmZcbiAgdmFyIGFoNSA9IGE1ID4+PiAxM1xuICB2YXIgYTYgPSBhWzZdIHwgMFxuICB2YXIgYWw2ID0gYTYgJiAweDFmZmZcbiAgdmFyIGFoNiA9IGE2ID4+PiAxM1xuICB2YXIgYTcgPSBhWzddIHwgMFxuICB2YXIgYWw3ID0gYTcgJiAweDFmZmZcbiAgdmFyIGFoNyA9IGE3ID4+PiAxM1xuICB2YXIgYTggPSBhWzhdIHwgMFxuICB2YXIgYWw4ID0gYTggJiAweDFmZmZcbiAgdmFyIGFoOCA9IGE4ID4+PiAxM1xuICB2YXIgYTkgPSBhWzldIHwgMFxuICB2YXIgYWw5ID0gYTkgJiAweDFmZmZcbiAgdmFyIGFoOSA9IGE5ID4+PiAxM1xuICB2YXIgYjAgPSBiWzBdIHwgMFxuICB2YXIgYmwwID0gYjAgJiAweDFmZmZcbiAgdmFyIGJoMCA9IGIwID4+PiAxM1xuICB2YXIgYjEgPSBiWzFdIHwgMFxuICB2YXIgYmwxID0gYjEgJiAweDFmZmZcbiAgdmFyIGJoMSA9IGIxID4+PiAxM1xuICB2YXIgYjIgPSBiWzJdIHwgMFxuICB2YXIgYmwyID0gYjIgJiAweDFmZmZcbiAgdmFyIGJoMiA9IGIyID4+PiAxM1xuICB2YXIgYjMgPSBiWzNdIHwgMFxuICB2YXIgYmwzID0gYjMgJiAweDFmZmZcbiAgdmFyIGJoMyA9IGIzID4+PiAxM1xuICB2YXIgYjQgPSBiWzRdIHwgMFxuICB2YXIgYmw0ID0gYjQgJiAweDFmZmZcbiAgdmFyIGJoNCA9IGI0ID4+PiAxM1xuICB2YXIgYjUgPSBiWzVdIHwgMFxuICB2YXIgYmw1ID0gYjUgJiAweDFmZmZcbiAgdmFyIGJoNSA9IGI1ID4+PiAxM1xuICB2YXIgYjYgPSBiWzZdIHwgMFxuICB2YXIgYmw2ID0gYjYgJiAweDFmZmZcbiAgdmFyIGJoNiA9IGI2ID4+PiAxM1xuICB2YXIgYjcgPSBiWzddIHwgMFxuICB2YXIgYmw3ID0gYjcgJiAweDFmZmZcbiAgdmFyIGJoNyA9IGI3ID4+PiAxM1xuICB2YXIgYjggPSBiWzhdIHwgMFxuICB2YXIgYmw4ID0gYjggJiAweDFmZmZcbiAgdmFyIGJoOCA9IGI4ID4+PiAxM1xuICB2YXIgYjkgPSBiWzldIHwgMFxuICB2YXIgYmw5ID0gYjkgJiAweDFmZmZcbiAgdmFyIGJoOSA9IGI5ID4+PiAxM1xuXG4gIG91dC5sZW5ndGggPSAxOVxuICAvKiBrID0gMCAqL1xuICBsbyA9IE1hdGguaW11bChhbDAsIGJsMClcbiAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMCwgYmwwKVxuICBoaSA9IE1hdGguaW11bChhaDAsIGJoMClcbiAgdmFyIHcwID0gYyArIGxvICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKVxuICBjID0gaGkgKyAobWlkID4+PiAxMykgKyAodzAgPj4+IDI2KVxuICB3MCAmPSAweDNmZmZmZmZcbiAgLyogayA9IDEgKi9cbiAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApXG4gIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMClcbiAgbWlkICs9IE1hdGguaW11bChhaDEsIGJsMClcbiAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApXG4gIGxvICs9IE1hdGguaW11bChhbDAsIGJsMSlcbiAgbWlkICs9IE1hdGguaW11bChhbDAsIGJoMSlcbiAgbWlkICs9IE1hdGguaW11bChhaDAsIGJsMSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMCwgYmgxKVxuICB2YXIgdzEgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MSA+Pj4gMjYpXG4gIHcxICY9IDB4M2ZmZmZmZlxuICAvKiBrID0gMiAqL1xuICBsbyA9IE1hdGguaW11bChhbDIsIGJsMClcbiAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMiwgYmwwKVxuICBoaSA9IE1hdGguaW11bChhaDIsIGJoMClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMSwgYmwxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMSwgYmgxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMSwgYmwxKVxuICBoaSArPSBNYXRoLmltdWwoYWgxLCBiaDEpXG4gIGxvICs9IE1hdGguaW11bChhbDAsIGJsMilcbiAgbWlkICs9IE1hdGguaW11bChhbDAsIGJoMilcbiAgbWlkICs9IE1hdGguaW11bChhaDAsIGJsMilcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMCwgYmgyKVxuICB2YXIgdzIgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MiA+Pj4gMjYpXG4gIHcyICY9IDB4M2ZmZmZmZlxuICAvKiBrID0gMyAqL1xuICBsbyA9IE1hdGguaW11bChhbDMsIGJsMClcbiAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMywgYmwwKVxuICBoaSA9IE1hdGguaW11bChhaDMsIGJoMClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMiwgYmwxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMiwgYmgxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMiwgYmwxKVxuICBoaSArPSBNYXRoLmltdWwoYWgyLCBiaDEpXG4gIGxvICs9IE1hdGguaW11bChhbDEsIGJsMilcbiAgbWlkICs9IE1hdGguaW11bChhbDEsIGJoMilcbiAgbWlkICs9IE1hdGguaW11bChhaDEsIGJsMilcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMSwgYmgyKVxuICBsbyArPSBNYXRoLmltdWwoYWwwLCBibDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwwLCBiaDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgwLCBibDMpXG4gIGhpICs9IE1hdGguaW11bChhaDAsIGJoMylcbiAgdmFyIHczID0gYyArIGxvICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKVxuICBjID0gaGkgKyAobWlkID4+PiAxMykgKyAodzMgPj4+IDI2KVxuICB3MyAmPSAweDNmZmZmZmZcbiAgLyogayA9IDQgKi9cbiAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApXG4gIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMClcbiAgbWlkICs9IE1hdGguaW11bChhaDQsIGJsMClcbiAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApXG4gIGxvICs9IE1hdGguaW11bChhbDMsIGJsMSlcbiAgbWlkICs9IE1hdGguaW11bChhbDMsIGJoMSlcbiAgbWlkICs9IE1hdGguaW11bChhaDMsIGJsMSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMywgYmgxKVxuICBsbyArPSBNYXRoLmltdWwoYWwyLCBibDIpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwyLCBiaDIpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgyLCBibDIpXG4gIGhpICs9IE1hdGguaW11bChhaDIsIGJoMilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMSwgYmwzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMSwgYmgzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMSwgYmwzKVxuICBoaSArPSBNYXRoLmltdWwoYWgxLCBiaDMpXG4gIGxvICs9IE1hdGguaW11bChhbDAsIGJsNClcbiAgbWlkICs9IE1hdGguaW11bChhbDAsIGJoNClcbiAgbWlkICs9IE1hdGguaW11bChhaDAsIGJsNClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMCwgYmg0KVxuICB2YXIgdzQgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3NCA+Pj4gMjYpXG4gIHc0ICY9IDB4M2ZmZmZmZlxuICAvKiBrID0gNSAqL1xuICBsbyA9IE1hdGguaW11bChhbDUsIGJsMClcbiAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNSwgYmwwKVxuICBoaSA9IE1hdGguaW11bChhaDUsIGJoMClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNCwgYmwxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNCwgYmgxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNCwgYmwxKVxuICBoaSArPSBNYXRoLmltdWwoYWg0LCBiaDEpXG4gIGxvICs9IE1hdGguaW11bChhbDMsIGJsMilcbiAgbWlkICs9IE1hdGguaW11bChhbDMsIGJoMilcbiAgbWlkICs9IE1hdGguaW11bChhaDMsIGJsMilcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMywgYmgyKVxuICBsbyArPSBNYXRoLmltdWwoYWwyLCBibDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwyLCBiaDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgyLCBibDMpXG4gIGhpICs9IE1hdGguaW11bChhaDIsIGJoMylcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMSwgYmw0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMSwgYmg0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMSwgYmw0KVxuICBoaSArPSBNYXRoLmltdWwoYWgxLCBiaDQpXG4gIGxvICs9IE1hdGguaW11bChhbDAsIGJsNSlcbiAgbWlkICs9IE1hdGguaW11bChhbDAsIGJoNSlcbiAgbWlkICs9IE1hdGguaW11bChhaDAsIGJsNSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMCwgYmg1KVxuICB2YXIgdzUgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3NSA+Pj4gMjYpXG4gIHc1ICY9IDB4M2ZmZmZmZlxuICAvKiBrID0gNiAqL1xuICBsbyA9IE1hdGguaW11bChhbDYsIGJsMClcbiAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNiwgYmwwKVxuICBoaSA9IE1hdGguaW11bChhaDYsIGJoMClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNSwgYmwxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNSwgYmgxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNSwgYmwxKVxuICBoaSArPSBNYXRoLmltdWwoYWg1LCBiaDEpXG4gIGxvICs9IE1hdGguaW11bChhbDQsIGJsMilcbiAgbWlkICs9IE1hdGguaW11bChhbDQsIGJoMilcbiAgbWlkICs9IE1hdGguaW11bChhaDQsIGJsMilcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNCwgYmgyKVxuICBsbyArPSBNYXRoLmltdWwoYWwzLCBibDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwzLCBiaDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgzLCBibDMpXG4gIGhpICs9IE1hdGguaW11bChhaDMsIGJoMylcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMiwgYmw0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMiwgYmg0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMiwgYmw0KVxuICBoaSArPSBNYXRoLmltdWwoYWgyLCBiaDQpXG4gIGxvICs9IE1hdGguaW11bChhbDEsIGJsNSlcbiAgbWlkICs9IE1hdGguaW11bChhbDEsIGJoNSlcbiAgbWlkICs9IE1hdGguaW11bChhaDEsIGJsNSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMSwgYmg1KVxuICBsbyArPSBNYXRoLmltdWwoYWwwLCBibDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwwLCBiaDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgwLCBibDYpXG4gIGhpICs9IE1hdGguaW11bChhaDAsIGJoNilcbiAgdmFyIHc2ID0gYyArIGxvICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKVxuICBjID0gaGkgKyAobWlkID4+PiAxMykgKyAodzYgPj4+IDI2KVxuICB3NiAmPSAweDNmZmZmZmZcbiAgLyogayA9IDcgKi9cbiAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApXG4gIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMClcbiAgbWlkICs9IE1hdGguaW11bChhaDcsIGJsMClcbiAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApXG4gIGxvICs9IE1hdGguaW11bChhbDYsIGJsMSlcbiAgbWlkICs9IE1hdGguaW11bChhbDYsIGJoMSlcbiAgbWlkICs9IE1hdGguaW11bChhaDYsIGJsMSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNiwgYmgxKVxuICBsbyArPSBNYXRoLmltdWwoYWw1LCBibDIpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw1LCBiaDIpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg1LCBibDIpXG4gIGhpICs9IE1hdGguaW11bChhaDUsIGJoMilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNCwgYmwzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNCwgYmgzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNCwgYmwzKVxuICBoaSArPSBNYXRoLmltdWwoYWg0LCBiaDMpXG4gIGxvICs9IE1hdGguaW11bChhbDMsIGJsNClcbiAgbWlkICs9IE1hdGguaW11bChhbDMsIGJoNClcbiAgbWlkICs9IE1hdGguaW11bChhaDMsIGJsNClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMywgYmg0KVxuICBsbyArPSBNYXRoLmltdWwoYWwyLCBibDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwyLCBiaDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgyLCBibDUpXG4gIGhpICs9IE1hdGguaW11bChhaDIsIGJoNSlcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMSwgYmw2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMSwgYmg2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMSwgYmw2KVxuICBoaSArPSBNYXRoLmltdWwoYWgxLCBiaDYpXG4gIGxvICs9IE1hdGguaW11bChhbDAsIGJsNylcbiAgbWlkICs9IE1hdGguaW11bChhbDAsIGJoNylcbiAgbWlkICs9IE1hdGguaW11bChhaDAsIGJsNylcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMCwgYmg3KVxuICB2YXIgdzcgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3NyA+Pj4gMjYpXG4gIHc3ICY9IDB4M2ZmZmZmZlxuICAvKiBrID0gOCAqL1xuICBsbyA9IE1hdGguaW11bChhbDgsIGJsMClcbiAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOCwgYmwwKVxuICBoaSA9IE1hdGguaW11bChhaDgsIGJoMClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNywgYmwxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNywgYmgxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNywgYmwxKVxuICBoaSArPSBNYXRoLmltdWwoYWg3LCBiaDEpXG4gIGxvICs9IE1hdGguaW11bChhbDYsIGJsMilcbiAgbWlkICs9IE1hdGguaW11bChhbDYsIGJoMilcbiAgbWlkICs9IE1hdGguaW11bChhaDYsIGJsMilcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNiwgYmgyKVxuICBsbyArPSBNYXRoLmltdWwoYWw1LCBibDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw1LCBiaDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg1LCBibDMpXG4gIGhpICs9IE1hdGguaW11bChhaDUsIGJoMylcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNCwgYmw0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNCwgYmg0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNCwgYmw0KVxuICBoaSArPSBNYXRoLmltdWwoYWg0LCBiaDQpXG4gIGxvICs9IE1hdGguaW11bChhbDMsIGJsNSlcbiAgbWlkICs9IE1hdGguaW11bChhbDMsIGJoNSlcbiAgbWlkICs9IE1hdGguaW11bChhaDMsIGJsNSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMywgYmg1KVxuICBsbyArPSBNYXRoLmltdWwoYWwyLCBibDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwyLCBiaDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgyLCBibDYpXG4gIGhpICs9IE1hdGguaW11bChhaDIsIGJoNilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMSwgYmw3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMSwgYmg3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMSwgYmw3KVxuICBoaSArPSBNYXRoLmltdWwoYWgxLCBiaDcpXG4gIGxvICs9IE1hdGguaW11bChhbDAsIGJsOClcbiAgbWlkICs9IE1hdGguaW11bChhbDAsIGJoOClcbiAgbWlkICs9IE1hdGguaW11bChhaDAsIGJsOClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMCwgYmg4KVxuICB2YXIgdzggPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3OCA+Pj4gMjYpXG4gIHc4ICY9IDB4M2ZmZmZmZlxuICAvKiBrID0gOSAqL1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsMClcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOSwgYmwwKVxuICBoaSA9IE1hdGguaW11bChhaDksIGJoMClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsOCwgYmwxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsOCwgYmgxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOCwgYmwxKVxuICBoaSArPSBNYXRoLmltdWwoYWg4LCBiaDEpXG4gIGxvICs9IE1hdGguaW11bChhbDcsIGJsMilcbiAgbWlkICs9IE1hdGguaW11bChhbDcsIGJoMilcbiAgbWlkICs9IE1hdGguaW11bChhaDcsIGJsMilcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNywgYmgyKVxuICBsbyArPSBNYXRoLmltdWwoYWw2LCBibDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw2LCBiaDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg2LCBibDMpXG4gIGhpICs9IE1hdGguaW11bChhaDYsIGJoMylcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNSwgYmw0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNSwgYmg0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNSwgYmw0KVxuICBoaSArPSBNYXRoLmltdWwoYWg1LCBiaDQpXG4gIGxvICs9IE1hdGguaW11bChhbDQsIGJsNSlcbiAgbWlkICs9IE1hdGguaW11bChhbDQsIGJoNSlcbiAgbWlkICs9IE1hdGguaW11bChhaDQsIGJsNSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNCwgYmg1KVxuICBsbyArPSBNYXRoLmltdWwoYWwzLCBibDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwzLCBiaDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgzLCBibDYpXG4gIGhpICs9IE1hdGguaW11bChhaDMsIGJoNilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMiwgYmw3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMiwgYmg3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMiwgYmw3KVxuICBoaSArPSBNYXRoLmltdWwoYWgyLCBiaDcpXG4gIGxvICs9IE1hdGguaW11bChhbDEsIGJsOClcbiAgbWlkICs9IE1hdGguaW11bChhbDEsIGJoOClcbiAgbWlkICs9IE1hdGguaW11bChhaDEsIGJsOClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMSwgYmg4KVxuICBsbyArPSBNYXRoLmltdWwoYWwwLCBibDkpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwwLCBiaDkpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgwLCBibDkpXG4gIGhpICs9IE1hdGguaW11bChhaDAsIGJoOSlcbiAgdmFyIHc5ID0gYyArIGxvICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKVxuICBjID0gaGkgKyAobWlkID4+PiAxMykgKyAodzkgPj4+IDI2KVxuICB3OSAmPSAweDNmZmZmZmZcbiAgLyogayA9IDEwICovXG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKVxuICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg5LCBibDEpXG4gIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKVxuICBsbyArPSBNYXRoLmltdWwoYWw4LCBibDIpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw4LCBiaDIpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg4LCBibDIpXG4gIGhpICs9IE1hdGguaW11bChhaDgsIGJoMilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNywgYmwzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNywgYmgzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNywgYmwzKVxuICBoaSArPSBNYXRoLmltdWwoYWg3LCBiaDMpXG4gIGxvICs9IE1hdGguaW11bChhbDYsIGJsNClcbiAgbWlkICs9IE1hdGguaW11bChhbDYsIGJoNClcbiAgbWlkICs9IE1hdGguaW11bChhaDYsIGJsNClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNiwgYmg0KVxuICBsbyArPSBNYXRoLmltdWwoYWw1LCBibDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw1LCBiaDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg1LCBibDUpXG4gIGhpICs9IE1hdGguaW11bChhaDUsIGJoNSlcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNCwgYmw2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNCwgYmg2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNCwgYmw2KVxuICBoaSArPSBNYXRoLmltdWwoYWg0LCBiaDYpXG4gIGxvICs9IE1hdGguaW11bChhbDMsIGJsNylcbiAgbWlkICs9IE1hdGguaW11bChhbDMsIGJoNylcbiAgbWlkICs9IE1hdGguaW11bChhaDMsIGJsNylcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMywgYmg3KVxuICBsbyArPSBNYXRoLmltdWwoYWwyLCBibDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwyLCBiaDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgyLCBibDgpXG4gIGhpICs9IE1hdGguaW11bChhaDIsIGJoOClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMSwgYmw5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMSwgYmg5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMSwgYmw5KVxuICBoaSArPSBNYXRoLmltdWwoYWgxLCBiaDkpXG4gIHZhciB3MTAgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MTAgPj4+IDI2KVxuICB3MTAgJj0gMHgzZmZmZmZmXG4gIC8qIGsgPSAxMSAqL1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsMilcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOSwgYmwyKVxuICBoaSA9IE1hdGguaW11bChhaDksIGJoMilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsOCwgYmwzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsOCwgYmgzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOCwgYmwzKVxuICBoaSArPSBNYXRoLmltdWwoYWg4LCBiaDMpXG4gIGxvICs9IE1hdGguaW11bChhbDcsIGJsNClcbiAgbWlkICs9IE1hdGguaW11bChhbDcsIGJoNClcbiAgbWlkICs9IE1hdGguaW11bChhaDcsIGJsNClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNywgYmg0KVxuICBsbyArPSBNYXRoLmltdWwoYWw2LCBibDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw2LCBiaDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg2LCBibDUpXG4gIGhpICs9IE1hdGguaW11bChhaDYsIGJoNSlcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNSwgYmw2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNSwgYmg2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNSwgYmw2KVxuICBoaSArPSBNYXRoLmltdWwoYWg1LCBiaDYpXG4gIGxvICs9IE1hdGguaW11bChhbDQsIGJsNylcbiAgbWlkICs9IE1hdGguaW11bChhbDQsIGJoNylcbiAgbWlkICs9IE1hdGguaW11bChhaDQsIGJsNylcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNCwgYmg3KVxuICBsbyArPSBNYXRoLmltdWwoYWwzLCBibDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwzLCBiaDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgzLCBibDgpXG4gIGhpICs9IE1hdGguaW11bChhaDMsIGJoOClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMiwgYmw5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMiwgYmg5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMiwgYmw5KVxuICBoaSArPSBNYXRoLmltdWwoYWgyLCBiaDkpXG4gIHZhciB3MTEgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MTEgPj4+IDI2KVxuICB3MTEgJj0gMHgzZmZmZmZmXG4gIC8qIGsgPSAxMiAqL1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsMylcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOSwgYmwzKVxuICBoaSA9IE1hdGguaW11bChhaDksIGJoMylcbiAgbG8gKz0gTWF0aC5pbXVsKGFsOCwgYmw0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsOCwgYmg0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOCwgYmw0KVxuICBoaSArPSBNYXRoLmltdWwoYWg4LCBiaDQpXG4gIGxvICs9IE1hdGguaW11bChhbDcsIGJsNSlcbiAgbWlkICs9IE1hdGguaW11bChhbDcsIGJoNSlcbiAgbWlkICs9IE1hdGguaW11bChhaDcsIGJsNSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNywgYmg1KVxuICBsbyArPSBNYXRoLmltdWwoYWw2LCBibDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw2LCBiaDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg2LCBibDYpXG4gIGhpICs9IE1hdGguaW11bChhaDYsIGJoNilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNSwgYmw3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNSwgYmg3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNSwgYmw3KVxuICBoaSArPSBNYXRoLmltdWwoYWg1LCBiaDcpXG4gIGxvICs9IE1hdGguaW11bChhbDQsIGJsOClcbiAgbWlkICs9IE1hdGguaW11bChhbDQsIGJoOClcbiAgbWlkICs9IE1hdGguaW11bChhaDQsIGJsOClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNCwgYmg4KVxuICBsbyArPSBNYXRoLmltdWwoYWwzLCBibDkpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwzLCBiaDkpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgzLCBibDkpXG4gIGhpICs9IE1hdGguaW11bChhaDMsIGJoOSlcbiAgdmFyIHcxMiA9IGMgKyBsbyArICgobWlkICYgMHgxZmZmKSA8PCAxMylcbiAgYyA9IGhpICsgKG1pZCA+Pj4gMTMpICsgKHcxMiA+Pj4gMjYpXG4gIHcxMiAmPSAweDNmZmZmZmZcbiAgLyogayA9IDEzICovXG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KVxuICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg5LCBibDQpXG4gIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KVxuICBsbyArPSBNYXRoLmltdWwoYWw4LCBibDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw4LCBiaDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg4LCBibDUpXG4gIGhpICs9IE1hdGguaW11bChhaDgsIGJoNSlcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNywgYmw2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNywgYmg2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNywgYmw2KVxuICBoaSArPSBNYXRoLmltdWwoYWg3LCBiaDYpXG4gIGxvICs9IE1hdGguaW11bChhbDYsIGJsNylcbiAgbWlkICs9IE1hdGguaW11bChhbDYsIGJoNylcbiAgbWlkICs9IE1hdGguaW11bChhaDYsIGJsNylcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNiwgYmg3KVxuICBsbyArPSBNYXRoLmltdWwoYWw1LCBibDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw1LCBiaDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg1LCBibDgpXG4gIGhpICs9IE1hdGguaW11bChhaDUsIGJoOClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNCwgYmw5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNCwgYmg5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNCwgYmw5KVxuICBoaSArPSBNYXRoLmltdWwoYWg0LCBiaDkpXG4gIHZhciB3MTMgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MTMgPj4+IDI2KVxuICB3MTMgJj0gMHgzZmZmZmZmXG4gIC8qIGsgPSAxNCAqL1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsNSlcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOSwgYmw1KVxuICBoaSA9IE1hdGguaW11bChhaDksIGJoNSlcbiAgbG8gKz0gTWF0aC5pbXVsKGFsOCwgYmw2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsOCwgYmg2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOCwgYmw2KVxuICBoaSArPSBNYXRoLmltdWwoYWg4LCBiaDYpXG4gIGxvICs9IE1hdGguaW11bChhbDcsIGJsNylcbiAgbWlkICs9IE1hdGguaW11bChhbDcsIGJoNylcbiAgbWlkICs9IE1hdGguaW11bChhaDcsIGJsNylcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNywgYmg3KVxuICBsbyArPSBNYXRoLmltdWwoYWw2LCBibDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw2LCBiaDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg2LCBibDgpXG4gIGhpICs9IE1hdGguaW11bChhaDYsIGJoOClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNSwgYmw5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNSwgYmg5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNSwgYmw5KVxuICBoaSArPSBNYXRoLmltdWwoYWg1LCBiaDkpXG4gIHZhciB3MTQgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MTQgPj4+IDI2KVxuICB3MTQgJj0gMHgzZmZmZmZmXG4gIC8qIGsgPSAxNSAqL1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsNilcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOSwgYmw2KVxuICBoaSA9IE1hdGguaW11bChhaDksIGJoNilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsOCwgYmw3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsOCwgYmg3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOCwgYmw3KVxuICBoaSArPSBNYXRoLmltdWwoYWg4LCBiaDcpXG4gIGxvICs9IE1hdGguaW11bChhbDcsIGJsOClcbiAgbWlkICs9IE1hdGguaW11bChhbDcsIGJoOClcbiAgbWlkICs9IE1hdGguaW11bChhaDcsIGJsOClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNywgYmg4KVxuICBsbyArPSBNYXRoLmltdWwoYWw2LCBibDkpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw2LCBiaDkpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg2LCBibDkpXG4gIGhpICs9IE1hdGguaW11bChhaDYsIGJoOSlcbiAgdmFyIHcxNSA9IGMgKyBsbyArICgobWlkICYgMHgxZmZmKSA8PCAxMylcbiAgYyA9IGhpICsgKG1pZCA+Pj4gMTMpICsgKHcxNSA+Pj4gMjYpXG4gIHcxNSAmPSAweDNmZmZmZmZcbiAgLyogayA9IDE2ICovXG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KVxuICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg5LCBibDcpXG4gIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KVxuICBsbyArPSBNYXRoLmltdWwoYWw4LCBibDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw4LCBiaDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg4LCBibDgpXG4gIGhpICs9IE1hdGguaW11bChhaDgsIGJoOClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNywgYmw5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNywgYmg5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNywgYmw5KVxuICBoaSArPSBNYXRoLmltdWwoYWg3LCBiaDkpXG4gIHZhciB3MTYgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MTYgPj4+IDI2KVxuICB3MTYgJj0gMHgzZmZmZmZmXG4gIC8qIGsgPSAxNyAqL1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsOClcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOSwgYmw4KVxuICBoaSA9IE1hdGguaW11bChhaDksIGJoOClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsOCwgYmw5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsOCwgYmg5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOCwgYmw5KVxuICBoaSArPSBNYXRoLmltdWwoYWg4LCBiaDkpXG4gIHZhciB3MTcgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MTcgPj4+IDI2KVxuICB3MTcgJj0gMHgzZmZmZmZmXG4gIC8qIGsgPSAxOCAqL1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsOSlcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOSwgYmw5KVxuICBoaSA9IE1hdGguaW11bChhaDksIGJoOSlcbiAgdmFyIHcxOCA9IGMgKyBsbyArICgobWlkICYgMHgxZmZmKSA8PCAxMylcbiAgYyA9IGhpICsgKG1pZCA+Pj4gMTMpICsgKHcxOCA+Pj4gMjYpXG4gIHcxOCAmPSAweDNmZmZmZmZcbiAgb1swXSA9IHcwXG4gIG9bMV0gPSB3MVxuICBvWzJdID0gdzJcbiAgb1szXSA9IHczXG4gIG9bNF0gPSB3NFxuICBvWzVdID0gdzVcbiAgb1s2XSA9IHc2XG4gIG9bN10gPSB3N1xuICBvWzhdID0gdzhcbiAgb1s5XSA9IHc5XG4gIG9bMTBdID0gdzEwXG4gIG9bMTFdID0gdzExXG4gIG9bMTJdID0gdzEyXG4gIG9bMTNdID0gdzEzXG4gIG9bMTRdID0gdzE0XG4gIG9bMTVdID0gdzE1XG4gIG9bMTZdID0gdzE2XG4gIG9bMTddID0gdzE3XG4gIG9bMThdID0gdzE4XG4gIGlmIChjICE9PSAwKSB7XG4gICAgb1sxOV0gPSBjXG4gICAgb3V0Lmxlbmd0aCsrXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuIiwiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIFBLQ1MjMSBQU1Mgc2lnbmF0dXJlIHBhZGRpbmcuXG4gKlxuICogQGF1dGhvciBTdGVmYW4gU2llZ2xcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9yYW5kb20nKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBzaG9ydGN1dCBmb3IgUFNTIEFQSVxudmFyIHBzcyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHNzID0gZm9yZ2UucHNzIHx8IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBQU1Mgc2lnbmF0dXJlIHNjaGVtZSBvYmplY3QuXG4gKlxuICogVGhlcmUgYXJlIHNldmVyYWwgd2F5cyB0byBwcm92aWRlIGEgc2FsdCBmb3IgZW5jb2Rpbmc6XG4gKlxuICogMS4gU3BlY2lmeSB0aGUgc2FsdExlbmd0aCBvbmx5IGFuZCB0aGUgYnVpbHQtaW4gUFJORyB3aWxsIGdlbmVyYXRlIGl0LlxuICogMi4gU3BlY2lmeSB0aGUgc2FsdExlbmd0aCBhbmQgYSBjdXN0b20gUFJORyB3aXRoICdnZXRCeXRlc1N5bmMnIGRlZmluZWQgdGhhdFxuICogICB3aWxsIGJlIHVzZWQuXG4gKiAzLiBTcGVjaWZ5IHRoZSBzYWx0IGl0c2VsZiBhcyBhIGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSwgYSBmb3JnZSBtZCBpbnN0YW5jZS5cbiAqICAgICAgICAgIG1nZiB0aGUgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSwgYSBmb3JnZSBtZ2YgaW5zdGFuY2UuXG4gKiAgICAgICAgICBbc2FsdExlbmd0aF0gdGhlIGxlbmd0aCBvZiB0aGUgc2FsdCBpbiBvY3RldHMuXG4gKiAgICAgICAgICBbcHJuZ10gdGhlIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciB0byB1c2UgdG8gcHJvZHVjZSBhIHNhbHQuXG4gKiAgICAgICAgICBbc2FsdF0gdGhlIHNhbHQgdG8gdXNlIHdoZW4gZW5jb2RpbmcuXG4gKlxuICogQHJldHVybiBhIHNpZ25hdHVyZSBzY2hlbWUgb2JqZWN0LlxuICovXG5wc3MuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3L2xlZ2FjeSBhcmdzOiBoYXNoLCBtZ2YsIHNMZW5cbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBtZDogYXJndW1lbnRzWzBdLFxuICAgICAgbWdmOiBhcmd1bWVudHNbMV0sXG4gICAgICBzYWx0TGVuZ3RoOiBhcmd1bWVudHNbMl1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGhhc2ggPSBvcHRpb25zLm1kO1xuICB2YXIgbWdmID0gb3B0aW9ucy5tZ2Y7XG4gIHZhciBoTGVuID0gaGFzaC5kaWdlc3RMZW5ndGg7XG5cbiAgdmFyIHNhbHRfID0gb3B0aW9ucy5zYWx0IHx8IG51bGw7XG4gIGlmKHR5cGVvZiBzYWx0XyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBhc3N1bWUgYmluYXJ5LWVuY29kZWQgc3RyaW5nXG4gICAgc2FsdF8gPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihzYWx0Xyk7XG4gIH1cblxuICB2YXIgc0xlbjtcbiAgaWYoJ3NhbHRMZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICBzTGVuID0gb3B0aW9ucy5zYWx0TGVuZ3RoO1xuICB9IGVsc2UgaWYoc2FsdF8gIT09IG51bGwpIHtcbiAgICBzTGVuID0gc2FsdF8ubGVuZ3RoKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTYWx0IGxlbmd0aCBub3Qgc3BlY2lmaWVkIG9yIHNwZWNpZmljIHNhbHQgbm90IGdpdmVuLicpO1xuICB9XG5cbiAgaWYoc2FsdF8gIT09IG51bGwgJiYgc2FsdF8ubGVuZ3RoKCkgIT09IHNMZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHNhbHQgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGxlbmd0aCBvZiBnaXZlbiBzYWx0LicpO1xuICB9XG5cbiAgdmFyIHBybmcgPSBvcHRpb25zLnBybmcgfHwgZm9yZ2UucmFuZG9tO1xuXG4gIHZhciBwc3NvYmogPSB7fTtcblxuICAvKipcbiAgICogRW5jb2RlcyBhIFBTUyBzaWduYXR1cmUuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyBFTVNBLVBTUy1FTkNPREUgYXMgcGVyIFJGQyAzNDQ3LCBzZWN0aW9uIDkuMS4xLlxuICAgKlxuICAgKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB3aXRoIHRoZSBoYXNoIHRvIHNpZ24uXG4gICAqIEBwYXJhbSBtb2RzQml0cyB0aGUgbGVuZ3RoIG9mIHRoZSBSU0EgbW9kdWx1cyBpbiBiaXRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBlbmNvZGVkIG1lc3NhZ2UgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgbGVuZ3RoXG4gICAqICAgICAgICAgICBjZWlsKChtb2RCaXRzIC0gMSkgLyA4KS5cbiAgICovXG4gIHBzc29iai5lbmNvZGUgPSBmdW5jdGlvbihtZCwgbW9kQml0cykge1xuICAgIHZhciBpO1xuICAgIHZhciBlbUJpdHMgPSBtb2RCaXRzIC0gMTtcbiAgICB2YXIgZW1MZW4gPSBNYXRoLmNlaWwoZW1CaXRzIC8gOCk7XG5cbiAgICAvKiAyLiBMZXQgbUhhc2ggPSBIYXNoKE0pLCBhbiBvY3RldCBzdHJpbmcgb2YgbGVuZ3RoIGhMZW4uICovXG4gICAgdmFyIG1IYXNoID0gbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgIC8qIDMuIElmIGVtTGVuIDwgaExlbiArIHNMZW4gKyAyLCBvdXRwdXQgXCJlbmNvZGluZyBlcnJvclwiIGFuZCBzdG9wLiAqL1xuICAgIGlmKGVtTGVuIDwgaExlbiArIHNMZW4gKyAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2UgaXMgdG9vIGxvbmcgdG8gZW5jcnlwdC4nKTtcbiAgICB9XG5cbiAgICAvKiA0LiBHZW5lcmF0ZSBhIHJhbmRvbSBvY3RldCBzdHJpbmcgc2FsdCBvZiBsZW5ndGggc0xlbjsgaWYgc0xlbiA9IDAsXG4gICAgICogICAgdGhlbiBzYWx0IGlzIHRoZSBlbXB0eSBzdHJpbmcuICovXG4gICAgdmFyIHNhbHQ7XG4gICAgaWYoc2FsdF8gPT09IG51bGwpIHtcbiAgICAgIHNhbHQgPSBwcm5nLmdldEJ5dGVzU3luYyhzTGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2FsdCA9IHNhbHRfLmJ5dGVzKCk7XG4gICAgfVxuXG4gICAgLyogNS4gTGV0IE0nID0gKDB4KTAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIHx8IG1IYXNoIHx8IHNhbHQ7ICovXG4gICAgdmFyIG1fID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIG1fLmZpbGxXaXRoQnl0ZSgwLCA4KTtcbiAgICBtXy5wdXRCeXRlcyhtSGFzaCk7XG4gICAgbV8ucHV0Qnl0ZXMoc2FsdCk7XG5cbiAgICAvKiA2LiBMZXQgSCA9IEhhc2goTScpLCBhbiBvY3RldCBzdHJpbmcgb2YgbGVuZ3RoIGhMZW4uICovXG4gICAgaGFzaC5zdGFydCgpO1xuICAgIGhhc2gudXBkYXRlKG1fLmdldEJ5dGVzKCkpO1xuICAgIHZhciBoID0gaGFzaC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLyogNy4gR2VuZXJhdGUgYW4gb2N0ZXQgc3RyaW5nIFBTIGNvbnNpc3Rpbmcgb2YgZW1MZW4gLSBzTGVuIC0gaExlbiAtIDJcbiAgICAgKiAgICB6ZXJvIG9jdGV0cy4gIFRoZSBsZW5ndGggb2YgUFMgbWF5IGJlIDAuICovXG4gICAgdmFyIHBzID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIHBzLmZpbGxXaXRoQnl0ZSgwLCBlbUxlbiAtIHNMZW4gLSBoTGVuIC0gMik7XG5cbiAgICAvKiA4LiBMZXQgREIgPSBQUyB8fCAweDAxIHx8IHNhbHQ7IERCIGlzIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGhcbiAgICAgKiAgICBlbUxlbiAtIGhMZW4gLSAxLiAqL1xuICAgIHBzLnB1dEJ5dGUoMHgwMSk7XG4gICAgcHMucHV0Qnl0ZXMoc2FsdCk7XG4gICAgdmFyIGRiID0gcHMuZ2V0Qnl0ZXMoKTtcblxuICAgIC8qIDkuIExldCBkYk1hc2sgPSBNR0YoSCwgZW1MZW4gLSBoTGVuIC0gMSkuICovXG4gICAgdmFyIG1hc2tMZW4gPSBlbUxlbiAtIGhMZW4gLSAxO1xuICAgIHZhciBkYk1hc2sgPSBtZ2YuZ2VuZXJhdGUoaCwgbWFza0xlbik7XG5cbiAgICAvKiAxMC4gTGV0IG1hc2tlZERCID0gREIgXFx4b3IgZGJNYXNrLiAqL1xuICAgIHZhciBtYXNrZWREQiA9ICcnO1xuICAgIGZvcihpID0gMDsgaSA8IG1hc2tMZW47IGkrKykge1xuICAgICAgbWFza2VkREIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYi5jaGFyQ29kZUF0KGkpIF4gZGJNYXNrLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cblxuICAgIC8qIDExLiBTZXQgdGhlIGxlZnRtb3N0IDhlbUxlbiAtIGVtQml0cyBiaXRzIG9mIHRoZSBsZWZ0bW9zdCBvY3RldCBpblxuICAgICAqICAgICBtYXNrZWREQiB0byB6ZXJvLiAqL1xuICAgIHZhciBtYXNrID0gKDB4RkYwMCA+PiAoOCAqIGVtTGVuIC0gZW1CaXRzKSkgJiAweEZGO1xuICAgIG1hc2tlZERCID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXNrZWREQi5jaGFyQ29kZUF0KDApICYgfm1hc2spICtcbiAgICAgIG1hc2tlZERCLnN1YnN0cigxKTtcblxuICAgIC8qIDEyLiBMZXQgRU0gPSBtYXNrZWREQiB8fCBIIHx8IDB4YmMuXG4gICAgICogMTMuIE91dHB1dCBFTS4gKi9cbiAgICByZXR1cm4gbWFza2VkREIgKyBoICsgU3RyaW5nLmZyb21DaGFyQ29kZSgweGJjKTtcbiAgfTtcblxuICAvKipcbiAgICogVmVyaWZpZXMgYSBQU1Mgc2lnbmF0dXJlLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgRU1TQS1QU1MtVkVSSUZZIGFzIHBlciBSRkMgMzQ0Nywgc2VjdGlvbiA5LjEuMi5cbiAgICpcbiAgICogQHBhcmFtIG1IYXNoIHRoZSBtZXNzYWdlIGRpZ2VzdCBoYXNoLCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZywgdG9cbiAgICogICAgICAgICBjb21wYXJlIGFnYWluc3QgdGhlIHNpZ25hdHVyZS5cbiAgICogQHBhcmFtIGVtIHRoZSBlbmNvZGVkIG1lc3NhZ2UsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nXG4gICAqICAgICAgICAgIChSU0EgZGVjcnlwdGlvbiByZXN1bHQpLlxuICAgKiBAcGFyYW0gbW9kc0JpdHMgdGhlIGxlbmd0aCBvZiB0aGUgUlNBIG1vZHVsdXMgaW4gYml0cy5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBzaWduYXR1cmUgd2FzIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBwc3NvYmoudmVyaWZ5ID0gZnVuY3Rpb24obUhhc2gsIGVtLCBtb2RCaXRzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGVtQml0cyA9IG1vZEJpdHMgLSAxO1xuICAgIHZhciBlbUxlbiA9IE1hdGguY2VpbChlbUJpdHMgLyA4KTtcblxuICAgIC8qIGMuIENvbnZlcnQgdGhlIG1lc3NhZ2UgcmVwcmVzZW50YXRpdmUgbSB0byBhbiBlbmNvZGVkIG1lc3NhZ2UgRU1cbiAgICAgKiAgICBvZiBsZW5ndGggZW1MZW4gPSBjZWlsKChtb2RCaXRzIC0gMSkgLyA4KSBvY3RldHMsIHdoZXJlIG1vZEJpdHNcbiAgICAgKiAgICBpcyB0aGUgbGVuZ3RoIGluIGJpdHMgb2YgdGhlIFJTQSBtb2R1bHVzIG4gKi9cbiAgICBlbSA9IGVtLnN1YnN0cigtZW1MZW4pO1xuXG4gICAgLyogMy4gSWYgZW1MZW4gPCBoTGVuICsgc0xlbiArIDIsIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIGlmKGVtTGVuIDwgaExlbiArIHNMZW4gKyAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29uc2lzdGVudCBwYXJhbWV0ZXJzIHRvIFBTUyBzaWduYXR1cmUgdmVyaWZpY2F0aW9uLicpO1xuICAgIH1cblxuICAgIC8qIDQuIElmIHRoZSByaWdodG1vc3Qgb2N0ZXQgb2YgRU0gZG9lcyBub3QgaGF2ZSBoZXhhZGVjaW1hbCB2YWx1ZVxuICAgICAqICAgIDB4YmMsIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIGlmKGVtLmNoYXJDb2RlQXQoZW1MZW4gLSAxKSAhPT0gMHhiYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGVkIG1lc3NhZ2UgZG9lcyBub3QgZW5kIGluIDB4QkMuJyk7XG4gICAgfVxuXG4gICAgLyogNS4gTGV0IG1hc2tlZERCIGJlIHRoZSBsZWZ0bW9zdCBlbUxlbiAtIGhMZW4gLSAxIG9jdGV0cyBvZiBFTSwgYW5kXG4gICAgICogICAgbGV0IEggYmUgdGhlIG5leHQgaExlbiBvY3RldHMuICovXG4gICAgdmFyIG1hc2tMZW4gPSBlbUxlbiAtIGhMZW4gLSAxO1xuICAgIHZhciBtYXNrZWREQiA9IGVtLnN1YnN0cigwLCBtYXNrTGVuKTtcbiAgICB2YXIgaCA9IGVtLnN1YnN0cihtYXNrTGVuLCBoTGVuKTtcblxuICAgIC8qIDYuIElmIHRoZSBsZWZ0bW9zdCA4ZW1MZW4gLSBlbUJpdHMgYml0cyBvZiB0aGUgbGVmdG1vc3Qgb2N0ZXQgaW5cbiAgICAgKiAgICBtYXNrZWREQiBhcmUgbm90IGFsbCBlcXVhbCB0byB6ZXJvLCBvdXRwdXQgXCJpbmNvbnNpc3RlbnRcIiBhbmQgc3RvcC4gKi9cbiAgICB2YXIgbWFzayA9ICgweEZGMDAgPj4gKDggKiBlbUxlbiAtIGVtQml0cykpICYgMHhGRjtcbiAgICBpZigobWFza2VkREIuY2hhckNvZGVBdCgwKSAmIG1hc2spICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdHMgYmV5b25kIGtleXNpemUgbm90IHplcm8gYXMgZXhwZWN0ZWQuJyk7XG4gICAgfVxuXG4gICAgLyogNy4gTGV0IGRiTWFzayA9IE1HRihILCBlbUxlbiAtIGhMZW4gLSAxKS4gKi9cbiAgICB2YXIgZGJNYXNrID0gbWdmLmdlbmVyYXRlKGgsIG1hc2tMZW4pO1xuXG4gICAgLyogOC4gTGV0IERCID0gbWFza2VkREIgXFx4b3IgZGJNYXNrLiAqL1xuICAgIHZhciBkYiA9ICcnO1xuICAgIGZvcihpID0gMDsgaSA8IG1hc2tMZW47IGkrKykge1xuICAgICAgZGIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXNrZWREQi5jaGFyQ29kZUF0KGkpIF4gZGJNYXNrLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cblxuICAgIC8qIDkuIFNldCB0aGUgbGVmdG1vc3QgOGVtTGVuIC0gZW1CaXRzIGJpdHMgb2YgdGhlIGxlZnRtb3N0IG9jdGV0XG4gICAgICogaW4gREIgdG8gemVyby4gKi9cbiAgICBkYiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGIuY2hhckNvZGVBdCgwKSAmIH5tYXNrKSArIGRiLnN1YnN0cigxKTtcblxuICAgIC8qIDEwLiBJZiB0aGUgZW1MZW4gLSBoTGVuIC0gc0xlbiAtIDIgbGVmdG1vc3Qgb2N0ZXRzIG9mIERCIGFyZSBub3QgemVyb1xuICAgICAqIG9yIGlmIHRoZSBvY3RldCBhdCBwb3NpdGlvbiBlbUxlbiAtIGhMZW4gLSBzTGVuIC0gMSAodGhlIGxlZnRtb3N0XG4gICAgICogcG9zaXRpb24gaXMgXCJwb3NpdGlvbiAxXCIpIGRvZXMgbm90IGhhdmUgaGV4YWRlY2ltYWwgdmFsdWUgMHgwMSxcbiAgICAgKiBvdXRwdXQgXCJpbmNvbnNpc3RlbnRcIiBhbmQgc3RvcC4gKi9cbiAgICB2YXIgY2hlY2tMZW4gPSBlbUxlbiAtIGhMZW4gLSBzTGVuIC0gMjtcbiAgICBmb3IoaSA9IDA7IGkgPCBjaGVja0xlbjsgaSsrKSB7XG4gICAgICBpZihkYi5jaGFyQ29kZUF0KGkpICE9PSAweDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGVmdG1vc3Qgb2N0ZXRzIG5vdCB6ZXJvIGFzIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoZGIuY2hhckNvZGVBdChjaGVja0xlbikgIT09IDB4MDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb25zaXN0ZW50IFBTUyBzaWduYXR1cmUsIDB4MDEgbWFya2VyIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIC8qIDExLiBMZXQgc2FsdCBiZSB0aGUgbGFzdCBzTGVuIG9jdGV0cyBvZiBEQi4gKi9cbiAgICB2YXIgc2FsdCA9IGRiLnN1YnN0cigtc0xlbik7XG5cbiAgICAvKiAxMi4gIExldCBNJyA9ICgweCkwMCAwMCAwMCAwMCAwMCAwMCAwMCAwMCB8fCBtSGFzaCB8fCBzYWx0ICovXG4gICAgdmFyIG1fID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIG1fLmZpbGxXaXRoQnl0ZSgwLCA4KTtcbiAgICBtXy5wdXRCeXRlcyhtSGFzaCk7XG4gICAgbV8ucHV0Qnl0ZXMoc2FsdCk7XG5cbiAgICAvKiAxMy4gTGV0IEgnID0gSGFzaChNJyksIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGggaExlbi4gKi9cbiAgICBoYXNoLnN0YXJ0KCk7XG4gICAgaGFzaC51cGRhdGUobV8uZ2V0Qnl0ZXMoKSk7XG4gICAgdmFyIGhfID0gaGFzaC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLyogMTQuIElmIEggPSBIJywgb3V0cHV0IFwiY29uc2lzdGVudC5cIiBPdGhlcndpc2UsIG91dHB1dCBcImluY29uc2lzdGVudC5cIiAqL1xuICAgIHJldHVybiBoID09PSBoXztcbiAgfTtcblxuICByZXR1cm4gcHNzb2JqO1xufTtcbiIsIi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlIG1hc2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnMuXG4gKlxuICogQGF1dGhvciBTdGVmYW4gU2llZ2xcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL21nZjEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5tZ2YgPSBmb3JnZS5tZ2YgfHwge307XG5mb3JnZS5tZ2YubWdmMSA9IGZvcmdlLm1nZjE7XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy50b0NhbGxiYWNrID0gKGRvV29yaykgPT4ge1xuICByZXR1cm4gZnVuY3Rpb24gKGlucHV0LCBjYWxsYmFjaykge1xuICAgIGxldCByZXNcbiAgICB0cnkge1xuICAgICAgcmVzID0gZG9Xb3JrKGlucHV0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgbnVsbCwgcmVzKVxuICB9XG59XG5cbmV4cG9ydHMudG9CdWYgPSAoZG9Xb3JrLCBvdGhlcikgPT4gKGlucHV0KSA9PiB7XG4gIGxldCByZXN1bHQgPSBkb1dvcmsoaW5wdXQsIG90aGVyKVxuICByZXR1cm4gQnVmZmVyLmZyb20ocmVzdWx0LCAnaGV4Jylcbn1cblxuZXhwb3J0cy5mcm9tU3RyaW5nID0gKGRvV29yaywgb3RoZXIpID0+IChfaW5wdXQpID0+IHtcbiAgY29uc3QgaW5wdXQgPSBCdWZmZXIuaXNCdWZmZXIoX2lucHV0KSA/IF9pbnB1dC50b1N0cmluZygpIDogX2lucHV0XG4gIHJldHVybiBkb1dvcmsoaW5wdXQsIG90aGVyKVxufVxuXG5leHBvcnRzLmZyb21OdW1iZXJUbzMyQml0QnVmID0gKGRvV29yaywgb3RoZXIpID0+IChpbnB1dCkgPT4ge1xuICBsZXQgbnVtYmVyID0gZG9Xb3JrKGlucHV0LCBvdGhlcilcbiAgY29uc3QgYnl0ZXMgPSBuZXcgQXJyYXkoNClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGJ5dGVzW2ldID0gbnVtYmVyICYgMHhmZlxuICAgIG51bWJlciA9IG51bWJlciA+PiA4XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpXG59XG4iLCIvKiBnbG9iYWwgc2VsZiAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3Qgbm9kZWlmeSA9IHJlcXVpcmUoJ25vZGVpZnknKVxuXG5jb25zdCB3ZWJDcnlwdG8gPSBnZXRXZWJDcnlwdG8oKVxuXG5mdW5jdGlvbiBnZXRXZWJDcnlwdG8gKCkge1xuICBpZiAoc2VsZi5jcnlwdG8pIHtcbiAgICByZXR1cm4gc2VsZi5jcnlwdG8uc3VidGxlIHx8IHNlbGYuY3J5cHRvLndlYmtpdFN1YnRsZVxuICB9XG5cbiAgaWYgKHNlbGYubXNDcnlwdG8pIHtcbiAgICByZXR1cm4gc2VsZi5tc0NyeXB0by5zdWJ0bGVcbiAgfVxufVxuXG5mdW5jdGlvbiB3ZWJDcnlwdG9IYXNoICh0eXBlKSB7XG4gIGlmICghd2ViQ3J5cHRvKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgdXNlIGEgYnJvd3NlciB3aXRoIHdlYmNyeXB0byBzdXBwb3J0IGFuZCBlbnN1cmUgdGhlIGNvZGUgaGFzIGJlZW4gZGVsaXZlcmVkIHNlY3VyZWx5IHZpYSBIVFRQUy9UTFMgYW5kIHJ1biB3aXRoaW4gYSBTZWN1cmUgQ29udGV4dCcpXG4gIH1cblxuICByZXR1cm4gKGRhdGEsIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgcmVzID0gd2ViQ3J5cHRvLmRpZ2VzdCh7IG5hbWU6IHR5cGUgfSwgZGF0YSlcblxuICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gIT09ICdmdW5jdGlvbicpIHsgLy8gSUUxMVxuICAgICAgcmVzLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgaGFzaGluZyBkYXRhIHVzaW5nICR7dHlwZX1gKSlcbiAgICAgIH1cbiAgICAgIHJlcy5vbmNvbXBsZXRlID0gKGUpID0+IHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZS50YXJnZXQucmVzdWx0KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbm9kZWlmeShcbiAgICAgIHJlcy50aGVuKChyYXcpID0+IEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHJhdykpKSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNoYTEgKGJ1ZiwgY2FsbGJhY2spIHtcbiAgd2ViQ3J5cHRvSGFzaCgnU0hBLTEnKShidWYsIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiBzaGEyMjU2IChidWYsIGNhbGxiYWNrKSB7XG4gIHdlYkNyeXB0b0hhc2goJ1NIQS0yNTYnKShidWYsIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiBzaGEyNTEyIChidWYsIGNhbGxiYWNrKSB7XG4gIHdlYkNyeXB0b0hhc2goJ1NIQS01MTInKShidWYsIGNhbGxiYWNrKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2hhMTogc2hhMSxcbiAgc2hhMjI1Njogc2hhMjI1NixcbiAgc2hhMjUxMjogc2hhMjUxMlxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJsYWtlID0gcmVxdWlyZSgnYmxha2VqcycpXG5cbmNvbnN0IHRvQ2FsbGJhY2sgPSByZXF1aXJlKCcuL3V0aWxzJykudG9DYWxsYmFja1xuXG5jb25zdCBtaW5CID0gMHhiMjAxXG5jb25zdCBtaW5TID0gMHhiMjQxXG5cbmNvbnN0IGJsYWtlMmIgPSB7XG4gIGluaXQ6IGJsYWtlLmJsYWtlMmJJbml0LFxuICB1cGRhdGU6IGJsYWtlLmJsYWtlMmJVcGRhdGUsXG4gIGRpZ2VzdDogYmxha2UuYmxha2UyYkZpbmFsXG59XG5cbmNvbnN0IGJsYWtlMnMgPSB7XG4gIGluaXQ6IGJsYWtlLmJsYWtlMnNJbml0LFxuICB1cGRhdGU6IGJsYWtlLmJsYWtlMnNVcGRhdGUsXG4gIGRpZ2VzdDogYmxha2UuYmxha2Uyc0ZpbmFsXG59XG5cbmNvbnN0IG1ha2VCMkhhc2ggPSAoc2l6ZSwgaGYpID0+IHRvQ2FsbGJhY2soKGJ1ZikgPT4ge1xuICBjb25zdCBjdHggPSBoZi5pbml0KHNpemUsIG51bGwpXG4gIGhmLnVwZGF0ZShjdHgsIGJ1ZilcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhmLmRpZ2VzdChjdHgpKVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSAodGFibGUpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgdGFibGVbbWluQiArIGldID0gbWFrZUIySGFzaChpICsgMSwgYmxha2UyYilcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICB0YWJsZVttaW5TICsgaV0gPSBtYWtlQjJIYXNoKGkgKyAxLCBibGFrZTJzKVxuICB9XG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBidWZmZXJzID0gW10sIGxlbmd0aCA9IDBcblxuICAvL2p1c3QgdXNlZCBmb3IgZGVidWdnaW5nLi4uXG4gIGZ1bmN0aW9uIGNhbGNMZW5ndGggKCkge1xuICAgIHJldHVybiBidWZmZXJzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgKyBiLmxlbmd0aFxuICAgIH0sIDApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgIGRhdGE6IHRoaXMsXG4gICAgYWRkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIG11c3QgYmUgYSBidWZmZXIsIHdhczogJyArIEpTT04uc3RyaW5naWZ5KGRhdGEpKVxuICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGggPSBsZW5ndGggKyBkYXRhLmxlbmd0aFxuICAgICAgYnVmZmVycy5wdXNoKGRhdGEpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgaGFzOiBmdW5jdGlvbiAobikge1xuICAgICAgaWYobnVsbCA9PSBuKSByZXR1cm4gbGVuZ3RoID4gMFxuICAgICAgcmV0dXJuIGxlbmd0aCA+PSBuXG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIChuKSB7XG4gICAgICB2YXIgX2xlbmd0aFxuICAgICAgaWYobiA9PSBudWxsIHx8IG4gPT09IGxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSAwXG4gICAgICAgIHZhciBfYnVmZmVycyA9IGJ1ZmZlcnNcbiAgICAgICAgYnVmZmVycyA9IFtdXG4gICAgICAgIGlmKF9idWZmZXJzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgIHJldHVybiBfYnVmZmVyc1swXVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoX2J1ZmZlcnMpXG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlcnMubGVuZ3RoID4gMSAmJiBuIDw9IChfbGVuZ3RoID0gYnVmZmVyc1swXS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBidWYgPSBidWZmZXJzWzBdLnNsaWNlKDAsIG4pXG4gICAgICAgIGlmKG4gPT09IF9sZW5ndGgpIHtcbiAgICAgICAgICBidWZmZXJzLnNoaWZ0KClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBidWZmZXJzWzBdID0gYnVmZmVyc1swXS5zbGljZShuLCBfbGVuZ3RoKVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCAtPSBuXG4gICAgICAgIHJldHVybiBidWZcbiAgICAgIH0gIGVsc2UgaWYobiA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgb3V0ID0gW10sIGxlbiA9IDBcblxuICAgICAgICB3aGlsZSgobGVuICsgYnVmZmVyc1swXS5sZW5ndGgpIDwgbikge1xuICAgICAgICAgIHZhciBiID0gYnVmZmVycy5zaGlmdCgpXG4gICAgICAgICAgbGVuICs9IGIubGVuZ3RoXG4gICAgICAgICAgb3V0LnB1c2goYilcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGxlbiA8IG4pIHtcbiAgICAgICAgICBvdXQucHVzaChidWZmZXJzWzBdLnNsaWNlKDAsIG4gLSBsZW4pKVxuICAgICAgICAgIGJ1ZmZlcnNbMF0gPSBidWZmZXJzWzBdLnNsaWNlKG4gLSBsZW4sIGJ1ZmZlcnNbMF0ubGVuZ3RoKVxuICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoID0gbGVuZ3RoIC0gblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgZ2V0ICcgKyBuICsgJyBieXRlcycpXG4gICAgfVxuICB9XG5cbn1cblxuXG5cblxuXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbXVsdGloYXNoID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnLi9jcnlwdG8nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IE11bHRpaGFzaGluZ1xuXG4vKipcbiAqIEhhc2ggdGhlIGdpdmVuIGBidWZgIHVzaW5nIHRoZSBhbGdvcml0aG0gc3BlY2lmaWVkXG4gKiBieSBgZnVuY2AuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIFRoZSB2YWx1ZSB0byBoYXNoLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBmdW5jIC0gVGhlIGFsZ29yaXRobSB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gLSBPcHRpb25hbGx5IHRyaW0gdGhlIHJlc3VsdCB0byB0aGlzIGxlbmd0aC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEJ1ZmZlcil9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBNdWx0aWhhc2hpbmcgKGJ1ZiwgZnVuYywgbGVuZ3RoLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNhbGxiYWNrJylcbiAgfVxuXG4gIE11bHRpaGFzaGluZy5kaWdlc3QoYnVmLCBmdW5jLCBsZW5ndGgsIChlcnIsIGRpZ2VzdCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgbXVsdGloYXNoLmVuY29kZShkaWdlc3QsIGZ1bmMsIGxlbmd0aCkpXG4gIH0pXG59XG5cbi8qKlxuICogVGhlIGBidWZmZXJgIG1vZHVsZSBmb3IgZWFzeSB1c2UgaW4gdGhlIGJyb3dzZXIuXG4gKlxuICogQHR5cGUge0J1ZmZlcn1cbiAqL1xuTXVsdGloYXNoaW5nLkJ1ZmZlciA9IEJ1ZmZlciAvLyBmb3IgYnJvd3NlciB0aGluZ3NcblxuLyoqXG4gKiBFeHBvc2UgbXVsdGloYXNoIGl0c2VsZiwgdG8gYXZvaWQgc2lsbHkgZG91YmxlIHJlcXVpcmVzLlxuICovXG5NdWx0aWhhc2hpbmcubXVsdGloYXNoID0gbXVsdGloYXNoXG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIFRoZSB2YWx1ZSB0byBoYXNoLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBmdW5jIC0gVGhlIGFsZ29yaXRobSB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gLSBPcHRpb25hbGx5IHRyaW0gdGhlIHJlc3VsdCB0byB0aGlzIGxlbmd0aC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEJ1ZmZlcil9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5NdWx0aWhhc2hpbmcuZGlnZXN0ID0gZnVuY3Rpb24gKGJ1ZiwgZnVuYywgbGVuZ3RoLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNhbGxiYWNrJylcbiAgfVxuXG4gIGxldCBjYiA9IGNhbGxiYWNrXG4gIGlmIChsZW5ndGgpIHtcbiAgICBjYiA9IChlcnIsIGRpZ2VzdCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkaWdlc3Quc2xpY2UoMCwgbGVuZ3RoKSlcbiAgICB9XG4gIH1cblxuICBsZXQgaGFzaFxuICB0cnkge1xuICAgIGhhc2ggPSBNdWx0aWhhc2hpbmcuY3JlYXRlSGFzaChmdW5jKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gY2IoZXJyKVxuICB9XG5cbiAgaGFzaChidWYsIGNiKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZnVuY1xuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gLSBUaGUgdG8gYGZ1bmNgIGNvcnJlc3BvbmRpbmcgaGFzaCBmdW5jdGlvbi5cbiAqL1xuTXVsdGloYXNoaW5nLmNyZWF0ZUhhc2ggPSBmdW5jdGlvbiAoZnVuYykge1xuICBmdW5jID0gbXVsdGloYXNoLmNvZXJjZUNvZGUoZnVuYylcbiAgaWYgKCFNdWx0aWhhc2hpbmcuZnVuY3Rpb25zW2Z1bmNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggZnVuY3Rpb24gJyArIGZ1bmMgKyAnIG5vdCB5ZXQgc3VwcG9ydGVkJylcbiAgfVxuXG4gIHJldHVybiBNdWx0aWhhc2hpbmcuZnVuY3Rpb25zW2Z1bmNdXG59XG5cbi8qKlxuICogTWFwcGluZyBvZiBtdWx0aWhhc2ggY29kZXMgdG8gdGhlaXIgaGFzaGluZyBmdW5jdGlvbnMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5NdWx0aWhhc2hpbmcuZnVuY3Rpb25zID0ge1xuICAvLyBzaGExXG4gIDB4MTE6IGNyeXB0by5zaGExLFxuICAvLyBzaGEyLTI1NlxuICAweDEyOiBjcnlwdG8uc2hhMjI1NixcbiAgLy8gc2hhMi01MTJcbiAgMHgxMzogY3J5cHRvLnNoYTI1MTIsXG4gIC8vIHNoYTMtNTEyXG4gIDB4MTQ6IGNyeXB0by5zaGEzNTEyLFxuICAvLyBzaGEzLTM4NFxuICAweDE1OiBjcnlwdG8uc2hhMzM4NCxcbiAgLy8gc2hhMy0yNTZcbiAgMHgxNjogY3J5cHRvLnNoYTMyNTYsXG4gIC8vIHNoYTMtMjI0XG4gIDB4MTc6IGNyeXB0by5zaGEzMjI0LFxuICAvLyBzaGFrZS0xMjhcbiAgMHgxODogY3J5cHRvLnNoYWtlMTI4LFxuICAvLyBzaGFrZS0yNTZcbiAgMHgxOTogY3J5cHRvLnNoYWtlMjU2LFxuICAvLyBrZWNjYWstMjI0XG4gIDB4MUE6IGNyeXB0by5rZWNjYWsyMjQsXG4gIC8vIGtlY2Nhay0yNTZcbiAgMHgxQjogY3J5cHRvLmtlY2NhazI1NixcbiAgLy8ga2VjY2FrLTM4NFxuICAweDFDOiBjcnlwdG8ua2VjY2FrMzg0LFxuICAvLyBrZWNjYWstNTEyXG4gIDB4MUQ6IGNyeXB0by5rZWNjYWs1MTIsXG4gIC8vIG11cm11cjMtMTI4XG4gIDB4MjI6IGNyeXB0by5tdXJtdXIzMTI4LFxuICAvLyBtdXJtdXIzLTMyXG4gIDB4MjM6IGNyeXB0by5tdXJtdXIzMzIsXG4gIC8vIGRibC1zaGEyLTI1NlxuICAweDU2OiBjcnlwdG8uZGJsU2hhMjI1NlxufVxuXG4vLyBhZGQgYmxha2UgZnVuY3Rpb25zXG5jcnlwdG8uYWRkQmxha2UoTXVsdGloYXNoaW5nLmZ1bmN0aW9ucylcblxuTXVsdGloYXNoaW5nLnZhbGlkYXRlID0gKGRhdGEsIGhhc2gsIGNhbGxiYWNrKSA9PiB7XG4gIGxldCBhbGdvID0gbXVsdGloYXNoLmRlY29kZShoYXNoKS5uYW1lXG4gIE11bHRpaGFzaGluZyhkYXRhLCBhbGdvLCAoZXJyLCBuZXdIYXNoKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICBjYWxsYmFjayhlcnIsIEJ1ZmZlci5jb21wYXJlKGhhc2gsIG5ld0hhc2gpID09PSAwKVxuICB9KVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzb2NrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciByZW1vdmUgPSBzb2NrZXQgJiYgKHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyIHx8IHNvY2tldC5yZW1vdmVMaXN0ZW5lcik7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgaWYgKHR5cGVvZiByZW1vdmUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVtb3ZlLmNhbGwoc29ja2V0LCAnb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgcmVtb3ZlLmNhbGwoc29ja2V0LCAnZXJyb3InLCBoYW5kbGVFcnIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU9wZW4oZXZ0KSB7XG4gICAgY2xlYW51cCgpOyBjYWxsYmFjaygpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRXJyIChldnQpIHtcbiAgICBjbGVhbnVwKCk7IGNhbGxiYWNrKGV2dCk7XG4gIH1cblxuICAvLyBpZiB0aGUgc29ja2V0IGlzIGNsb3Npbmcgb3IgY2xvc2VkLCByZXR1cm4gZW5kXG4gIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHRydWUpO1xuICB9XG5cbiAgLy8gaWYgb3BlbiwgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cblxuICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnIpO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLnRvQ2FsbGJhY2sgPSAoZG9Xb3JrKSA9PiB7XG4gIHJldHVybiBmdW5jdGlvbiAoaW5wdXQsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBkb1dvcmsoaW5wdXQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBudWxsLCByZXMpXG4gIH1cbn1cblxuZXhwb3J0cy50b0J1ZiA9IChkb1dvcmssIG90aGVyKSA9PiAoaW5wdXQpID0+IHtcbiAgbGV0IHJlc3VsdCA9IGRvV29yayhpbnB1dCwgb3RoZXIpXG4gIHJldHVybiBCdWZmZXIuZnJvbShyZXN1bHQsICdoZXgnKVxufVxuXG5leHBvcnRzLmZyb21TdHJpbmcgPSAoZG9Xb3JrLCBvdGhlcikgPT4gKF9pbnB1dCkgPT4ge1xuICBjb25zdCBpbnB1dCA9IEJ1ZmZlci5pc0J1ZmZlcihfaW5wdXQpID8gX2lucHV0LnRvU3RyaW5nKCkgOiBfaW5wdXRcbiAgcmV0dXJuIGRvV29yayhpbnB1dCwgb3RoZXIpXG59XG5cbmV4cG9ydHMuZnJvbU51bWJlclRvMzJCaXRCdWYgPSAoZG9Xb3JrLCBvdGhlcikgPT4gKGlucHV0KSA9PiB7XG4gIGxldCBudW1iZXIgPSBkb1dvcmsoaW5wdXQsIG90aGVyKVxuICBjb25zdCBieXRlcyA9IG5ldyBBcnJheSg0KVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBudW1iZXIgJiAweGZmXG4gICAgbnVtYmVyID0gbnVtYmVyID4+IDhcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShieXRlcylcbn1cbiIsIi8qIGdsb2JhbCBzZWxmICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBub2RlaWZ5ID0gcmVxdWlyZSgnbm9kZWlmeScpXG5cbmNvbnN0IHdlYkNyeXB0byA9IGdldFdlYkNyeXB0bygpXG5cbmZ1bmN0aW9uIGdldFdlYkNyeXB0byAoKSB7XG4gIGlmIChzZWxmLmNyeXB0bykge1xuICAgIHJldHVybiBzZWxmLmNyeXB0by5zdWJ0bGUgfHwgc2VsZi5jcnlwdG8ud2Via2l0U3VidGxlXG4gIH1cblxuICBpZiAoc2VsZi5tc0NyeXB0bykge1xuICAgIHJldHVybiBzZWxmLm1zQ3J5cHRvLnN1YnRsZVxuICB9XG59XG5cbmZ1bmN0aW9uIHdlYkNyeXB0b0hhc2ggKHR5cGUpIHtcbiAgaWYgKCF3ZWJDcnlwdG8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2UgYSBicm93c2VyIHdpdGggd2ViY3J5cHRvIHN1cHBvcnQgYW5kIGVuc3VyZSB0aGUgY29kZSBoYXMgYmVlbiBkZWxpdmVyZWQgc2VjdXJlbHkgdmlhIEhUVFBTL1RMUyBhbmQgcnVuIHdpdGhpbiBhIFNlY3VyZSBDb250ZXh0JylcbiAgfVxuXG4gIHJldHVybiAoZGF0YSwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCByZXMgPSB3ZWJDcnlwdG8uZGlnZXN0KHsgbmFtZTogdHlwZSB9LCBkYXRhKVxuXG4gICAgaWYgKHR5cGVvZiByZXMudGhlbiAhPT0gJ2Z1bmN0aW9uJykgeyAvLyBJRTExXG4gICAgICByZXMub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGBoYXNoaW5nIGRhdGEgdXNpbmcgJHt0eXBlfWApKVxuICAgICAgfVxuICAgICAgcmVzLm9uY29tcGxldGUgPSAoZSkgPT4ge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBlLnRhcmdldC5yZXN1bHQpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBub2RlaWZ5KFxuICAgICAgcmVzLnRoZW4oKHJhdykgPT4gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkocmF3KSkpLFxuICAgICAgY2FsbGJhY2tcbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gc2hhMSAoYnVmLCBjYWxsYmFjaykge1xuICB3ZWJDcnlwdG9IYXNoKCdTSEEtMScpKGJ1ZiwgY2FsbGJhY2spXG59XG5cbmZ1bmN0aW9uIHNoYTIyNTYgKGJ1ZiwgY2FsbGJhY2spIHtcbiAgd2ViQ3J5cHRvSGFzaCgnU0hBLTI1NicpKGJ1ZiwgY2FsbGJhY2spXG59XG5cbmZ1bmN0aW9uIHNoYTI1MTIgKGJ1ZiwgY2FsbGJhY2spIHtcbiAgd2ViQ3J5cHRvSGFzaCgnU0hBLTUxMicpKGJ1ZiwgY2FsbGJhY2spXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaGExOiBzaGExLFxuICBzaGEyMjU2OiBzaGEyMjU2LFxuICBzaGEyNTEyOiBzaGEyNTEyXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYmxha2UgPSByZXF1aXJlKCdibGFrZWpzJylcblxuY29uc3QgdG9DYWxsYmFjayA9IHJlcXVpcmUoJy4vdXRpbHMnKS50b0NhbGxiYWNrXG5cbmNvbnN0IG1pbkIgPSAweGIyMDFcbmNvbnN0IG1pblMgPSAweGIyNDFcblxuY29uc3QgYmxha2UyYiA9IHtcbiAgaW5pdDogYmxha2UuYmxha2UyYkluaXQsXG4gIHVwZGF0ZTogYmxha2UuYmxha2UyYlVwZGF0ZSxcbiAgZGlnZXN0OiBibGFrZS5ibGFrZTJiRmluYWxcbn1cblxuY29uc3QgYmxha2UycyA9IHtcbiAgaW5pdDogYmxha2UuYmxha2Uyc0luaXQsXG4gIHVwZGF0ZTogYmxha2UuYmxha2Uyc1VwZGF0ZSxcbiAgZGlnZXN0OiBibGFrZS5ibGFrZTJzRmluYWxcbn1cblxuY29uc3QgbWFrZUIySGFzaCA9IChzaXplLCBoZikgPT4gdG9DYWxsYmFjaygoYnVmKSA9PiB7XG4gIGNvbnN0IGN0eCA9IGhmLmluaXQoc2l6ZSwgbnVsbClcbiAgaGYudXBkYXRlKGN0eCwgYnVmKVxuICByZXR1cm4gQnVmZmVyLmZyb20oaGYuZGlnZXN0KGN0eCkpXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9ICh0YWJsZSkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICB0YWJsZVttaW5CICsgaV0gPSBtYWtlQjJIYXNoKGkgKyAxLCBibGFrZTJiKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIHRhYmxlW21pblMgKyBpXSA9IG1ha2VCMkhhc2goaSArIDEsIGJsYWtlMnMpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBIZWFwID0gcmVxdWlyZSgnaGVhcCcpXG5jb25zdCBkaXN0YW5jZSA9IHJlcXVpcmUoJ3hvci1kaXN0YW5jZScpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5jb25zdCBsb2cgPSBkZWJ1ZygnbGlicDJwOmRodDpwZWVyLXF1ZXVlJylcblxuLyoqXG4gKiBQZWVyUXVldWUgaXMgYSBoZWFwIHRoYXQgc29ydHMgaXRzIGVudHJpZXMgKFBlZXJJZHMpIGJ5IHRoZWlyXG4gKiB4b3IgZGlzdGFuY2UgdG8gdGhlIGluaXRhbCBwcm92aWRlZCBrZXkuXG4gKi9cbmNsYXNzIFBlZXJRdWV1ZSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgZnJvbSBhIGdpdmVuIHBlZXIgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlcklkfSBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQZWVyUXVldWU+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21QZWVySWQgKGlkKSB7XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgcHJvbWlzaWZ5KGNiID0+IHV0aWxzLmNvbnZlcnRQZWVySWQoaWQsIGNiKSkoKVxuICAgIHJldHVybiBuZXcgUGVlclF1ZXVlKGtleSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgZnJvbSBhIGdpdmVuIGJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGtleUJ1ZmZlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQZWVyUXVldWU+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21LZXkgKGtleUJ1ZmZlcikge1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IHByb21pc2lmeShjYiA9PiB1dGlscy5jb252ZXJ0QnVmZmVyKGtleUJ1ZmZlciwgY2IpKSgpXG4gICAgcmV0dXJuIG5ldyBQZWVyUXVldWUoa2V5KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBQZWVyUXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBmcm9tIC0gVGhlIHNoYTItMjU2IGVuY29kZWQgcGVlciBpZFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGZyb20pIHtcbiAgICBsb2coJ2NyZWF0ZTogJWInLCBmcm9tKVxuICAgIHRoaXMuZnJvbSA9IGZyb21cbiAgICB0aGlzLmhlYXAgPSBuZXcgSGVhcCh1dGlscy54b3JDb21wYXJlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBQZWVySWQgdG8gdGhlIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJZH0gaWRcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBlbnF1ZXVlIChpZCkge1xuICAgIGxvZygnZW5xdWV1ZSAlcycsIGlkLnRvQjU4U3RyaW5nKCkpXG4gICAgY29uc3Qga2V5ID0gYXdhaXQgcHJvbWlzaWZ5KGNiID0+IHV0aWxzLmNvbnZlcnRQZWVySWQoaWQsIGNiKSkoKVxuXG4gICAgY29uc3QgZWwgPSB7XG4gICAgICBpZDogaWQsXG4gICAgICBkaXN0YW5jZTogZGlzdGFuY2UodGhpcy5mcm9tLCBrZXkpXG4gICAgfVxuXG4gICAgdGhpcy5oZWFwLnB1c2goZWwpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xvc2VzdCBwZWVyIHRvIHRoZSBgZnJvbWAgcGVlci5cbiAgICpcbiAgICogQHJldHVybnMge1BlZXJJZH1cbiAgICovXG4gIGRlcXVldWUgKCkge1xuICAgIGNvbnN0IGVsID0gdGhpcy5oZWFwLnBvcCgpXG4gICAgbG9nKCdkZXF1ZXVlICVzJywgZWwuaWQudG9CNThTdHJpbmcoKSlcbiAgICByZXR1cm4gZWwuaWRcbiAgfVxuXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLmhlYXAuc2l6ZSgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZWVyUXVldWVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJylcblxubW9kdWxlLmV4cG9ydHMgPSAoZGh0KSA9PiB7XG4gIGNvbnN0IGxvZyA9IHV0aWxzLmxvZ2dlcihkaHQucGVlckluZm8uaWQsICdycGM6cGluZycpXG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYFBpbmdgIERIVCBtZXNzYWdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlclxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1zZ1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBNZXNzYWdlKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiBwaW5nIChwZWVyLCBtc2csIGNhbGxiYWNrKSB7XG4gICAgbG9nKCdmcm9tICVzJywgcGVlci5pZC50b0I1OFN0cmluZygpKVxuICAgIGNhbGxiYWNrKG51bGwsIG1zZylcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKVxuY29uc3QgZXJyY29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxubW9kdWxlLmV4cG9ydHMgPSAoZGh0KSA9PiB7XG4gIGNvbnN0IGxvZyA9IHV0aWxzLmxvZ2dlcihkaHQucGVlckluZm8uaWQsICdycGM6cHV0LXZhbHVlJylcblxuICAvKipcbiAgICogUHJvY2VzcyBgUHV0VmFsdWVgIERIVCBtZXNzYWdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlclxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1zZ1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBNZXNzYWdlKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiBwdXRWYWx1ZSAocGVlciwgbXNnLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGtleSA9IG1zZy5rZXlcbiAgICBsb2coJ2tleTogJWInLCBrZXkpXG5cbiAgICBjb25zdCByZWNvcmQgPSBtc2cucmVjb3JkXG5cbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgY29uc3QgZXJyTXNnID0gYEVtcHR5IHJlY29yZCBmcm9tOiAke3BlZXIuaWQudG9CNThTdHJpbmcoKX1gXG5cbiAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9FTVBUWV9SRUNPUkQnKSlcbiAgICB9XG5cbiAgICBkaHQuX3ZlcmlmeVJlY29yZExvY2FsbHkocmVjb3JkLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZy5lcnJvcihlcnIubWVzc2FnZSlcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgcmVjb3JkLnRpbWVSZWNlaXZlZCA9IG5ldyBEYXRlKClcblxuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuYnVmZmVyVG9LZXkocmVjb3JkLmtleSlcblxuICAgICAgZGh0LmRhdGFzdG9yZS5wdXQoa2V5LCByZWNvcmQuc2VyaWFsaXplKCksIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCBtc2cpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IGVycmNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCBwcm9taXNlVG9DYWxsYmFjayA9IHJlcXVpcmUoJ3Byb21pc2UtdG8tY2FsbGJhY2snKVxuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJylcblxubW9kdWxlLmV4cG9ydHMgPSAoZGh0KSA9PiB7XG4gIGNvbnN0IGxvZyA9IHV0aWxzLmxvZ2dlcihkaHQucGVlckluZm8uaWQsICdycGM6YWRkLXByb3ZpZGVyJylcbiAgLyoqXG4gICAqIFByb2Nlc3MgYEFkZFByb3ZpZGVyYCBESFQgbWVzc2FnZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlckluZm99IHBlZXJcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtc2dcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gYWRkUHJvdmlkZXIgKHBlZXIsIG1zZywgY2FsbGJhY2spIHtcbiAgICBsb2coJ3N0YXJ0JylcblxuICAgIGlmICghbXNnLmtleSB8fCBtc2cua2V5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKCdNaXNzaW5nIGtleScpLCAnRVJSX01JU1NJTkdfS0VZJykpXG4gICAgfVxuXG4gICAgbGV0IGNpZFxuICAgIHRyeSB7XG4gICAgICBjaWQgPSBuZXcgQ0lEKG1zZy5rZXkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSBgSW52YWxpZCBDSUQ6ICR7ZXJyLm1lc3NhZ2V9YFxuXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX0NJRCcpKVxuICAgIH1cblxuICAgIGxldCBmb3VuZFByb3ZpZGVyID0gZmFsc2VcbiAgICBtc2cucHJvdmlkZXJQZWVycy5mb3JFYWNoKChwaSkgPT4ge1xuICAgICAgLy8gSWdub3JlIHByb3ZpZGVycyBub3QgZnJvbSB0aGUgb3JpZ2luYXRvclxuICAgICAgaWYgKCFwaS5pZC5pc0VxdWFsKHBlZXIuaWQpKSB7XG4gICAgICAgIGxvZygnaW52YWxpZCBwcm92aWRlciBwZWVyICVzIGZyb20gJXMnLCBwaS5pZC50b0I1OFN0cmluZygpLCBwZWVyLmlkLnRvQjU4U3RyaW5nKCkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAocGkubXVsdGlhZGRycy5zaXplIDwgMSkge1xuICAgICAgICBsb2coJ25vIHZhbGlkIGFkZHJlc3NlcyBmb3IgcHJvdmlkZXIgJXMuIElnbm9yZScsIHBlZXIuaWQudG9CNThTdHJpbmcoKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxvZygncmVjZWl2ZWQgcHJvdmlkZXIgJXMgZm9yICVzIChhZGRycyAlcyknLCBwZWVyLmlkLnRvQjU4U3RyaW5nKCksIGNpZC50b0Jhc2VFbmNvZGVkU3RyaW5nKCksIHBpLm11bHRpYWRkcnMudG9BcnJheSgpLm1hcCgobSkgPT4gbS50b1N0cmluZygpKSlcblxuICAgICAgaWYgKCFkaHQuX2lzU2VsZihwaS5pZCkpIHtcbiAgICAgICAgZm91bmRQcm92aWRlciA9IHRydWVcbiAgICAgICAgZGh0LnBlZXJCb29rLnB1dChwaSlcbiAgICAgICAgcHJvbWlzZVRvQ2FsbGJhY2soZGh0LnByb3ZpZGVycy5hZGRQcm92aWRlcihjaWQsIHBpLmlkKSkoZXJyID0+IGNhbGxiYWNrKGVycikpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFByZXZpb3VzIHZlcnNpb25zIG9mIHRoZSBKUyBESFQgc2VudCBlcnJvbmVvdXMgcHJvdmlkZXJzIGluIHRoZVxuICAgIC8vIGBwcm92aWRlclBlZXJzYCBmaWVsZC4gSW4gb3JkZXIgdG8gYWNjb21tb2RhdGUgb2xkZXIgY2xpZW50cyB0aGF0IGhhdmVcbiAgICAvLyB0aGlzIGJ1Zywgd2UgZmFsbCBiYWNrIHRvIGFzc3VtaW5nIHRoZSBvcmlnaW5hdG9yIGlzIHRoZSBwcm92aWRlciBpZlxuICAgIC8vIHdlIGNhbid0IGZpbmQgYW55IHZhbGlkIHByb3ZpZGVycyBpbiB0aGUgcGF5bG9hZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbGlicDJwL2pzLWxpYnAycC1rYWQtZGh0L3B1bGwvMTI3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xpYnAycC9qcy1saWJwMnAta2FkLWRodC9pc3N1ZXMvMTI4XG4gICAgaWYgKCFmb3VuZFByb3ZpZGVyKSB7XG4gICAgICBwcm9taXNlVG9DYWxsYmFjayhkaHQucHJvdmlkZXJzLmFkZFByb3ZpZGVyKGNpZCwgcGVlci5pZCkpKGVyciA9PiBjYWxsYmFjayhlcnIpKVxuICAgIH1cbiAgfVxufVxuIl0sInByZUV4aXN0aW5nQ29tbWVudCI6Ii8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJ9
