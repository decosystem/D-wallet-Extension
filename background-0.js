LavaPack.loadBundle([
["/home/clarisco/Desktop/metamask-extension-develop/shared/constants/metametrics.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/shared/constants/metametrics.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REJECT_NOTFICIATION_CLOSE_SIG = exports.REJECT_NOTFICIATION_CLOSE = exports.METAMETRICS_BACKGROUND_PAGE_OBJECT = exports.METAMETRICS_ANONYMOUS_ID = void 0;
// Type Imports

/**
 * @typedef {__import__('../../shared/constants/app').EnvironmentType} EnvironmentType
 */
// Type Declarations

/**
 * Used to attach context of where the user was at in the application when the
 * event was triggered. Also included as full details of the current page in
 * page events.
 * @typedef {Object} MetaMetricsPageObject
 * @property {string} [path] - the path of the current page (e.g /home)
 * @property {string} [title] - the title of the current page (e.g 'home')
 * @property {string} [url] - the fully qualified url of the current page
 */

/**
 * For metamask, this is the dapp that triggered an interaction
 * @typedef {Object} MetaMetricsReferrerObject
 * @property {string} [url] - the origin of the dapp issuing the
 *  notification
 */

/**
 * We attach context to every meta metrics event that help to qualify our
 * analytics. This type has all optional values because it represents a
 * returned object from a method call. Ideally app and userAgent are
 * defined on every event. This is confirmed in the getTrackMetaMetricsEvent
 * function, but still provides the consumer a way to override these values if
 * necessary.
 * @typedef {Object} MetaMetricsContext
 * @property {Object} app
 * @property {string} app.name - the name of the application tracking the event
 * @property {string} app.version - the version of the application
 * @property {string} userAgent - the useragent string of the user
 * @property {MetaMetricsPageObject} [page] - an object representing details of
 *  the current page
 * @property {MetaMetricsReferrerObject} [referrer] - for metamask, this is the
 *  dapp that triggered an interaction
 */

/**
 * @typedef {Object} MetaMetricsEventPayload
 * @property {string}  event - event name to track
 * @property {string}  category - category to associate event to
 * @property {string} [environmentType] - The type of environment this event
 *  occurred in. Defaults to the background process type
 * @property {object}  [properties] - object of custom values to track, keys
 *  in this object must be in snake_case
 * @property {object}  [sensitiveProperties] - Object of sensitive values to
 *  track. Keys in this object must be in snake_case. These properties will be
 *  sent in an additional event that excludes the user's metaMetricsId
 * @property {number}  [revenue] - amount of currency that event creates in
 *  revenue for MetaMask
 * @property {string}  [currency] - ISO 4127 format currency for events with
 *  revenue, defaults to US dollars
 * @property {number}  [value] - Abstract business "value" attributable to
 *  customers who trigger this event
 * @property {MetaMetricsPageObject} [page] - the page/route that the event
 *  occurred on
 * @property {MetaMetricsReferrerObject} [referrer] - the origin of the dapp
 *  that triggered the event
 */

/**
 * @typedef {Object} MetaMetricsEventOptions
 * @property {boolean} [isOptIn] - happened during opt in/out workflow
 * @property {boolean} [flushImmediately] - When true will automatically flush
 *  the segment queue after tracking the event. Recommended if the result of
 *  tracking the event must be known before UI transition or update
 * @property {boolean} [excludeMetaMetricsId] - whether to exclude the user's
 *  metametrics id for anonymity
 * @property {string}  [metaMetricsId] - an override for the metaMetricsId in
 *  the event one is created as part of an asynchronous workflow, such as
 *  awaiting the result of the metametrics opt-in function that generates the
 *  user's metametrics id
 * @property {boolean} [matomoEvent] - is this event a holdover from matomo
 *  that needs further migration? when true, sends the data to a special
 *  segment source that marks the event data as not conforming to our schema
 */

/**
 * Represents the shape of data sent to the segment.track method.
 * @typedef {Object} SegmentEventPayload
 * @property {string} [userId] - The metametrics id for the user
 * @property {string} [anonymousId] - An anonymousId that is used to track
 *  sensitive data while preserving anonymity.
 * @property {string} event - name of the event to track
 * @property {Object} properties - properties to attach to the event
 * @property {MetaMetricsContext} context - the context the event occurred in
 */

/**
 * @typedef {Object} MetaMetricsPagePayload
 * @property {string} name - The name of the page that was viewed
 * @property {Object} [params] - The variadic parts of the page url
 *  example (route: `/asset/:asset`, path: `/asset/ETH`)
 *  params: { asset: 'ETH' }
 * @property {EnvironmentType} environmentType - the environment type that the
 *  page was viewed in
 * @property {MetaMetricsPageObject} [page] - the details of the page
 * @property {MetaMetricsReferrerObject} [referrer] - dapp that triggered the page
 *  view
 */

/**
 * @typedef {Object} MetaMetricsPageOptions
 * @property {boolean} [isOptInPath] - is the current path one of the pages in
 *  the onboarding workflow? If true and participateInMetaMetrics is null track
 *  the page view
 */
// An empty string is a, currently undocumented, way of telling mixpanel
// that these events are meant to be anonymous and not identified to any user
const METAMETRICS_ANONYMOUS_ID = '';
/**
 * This object is used to identify events that are triggered by the background
 * process.
 * @type {MetaMetricsPageObject}
 */

exports.METAMETRICS_ANONYMOUS_ID = METAMETRICS_ANONYMOUS_ID;
const METAMETRICS_BACKGROUND_PAGE_OBJECT = {
  path: '/background-process',
  title: 'Background Process',
  url: '/background-process'
};
/**
 * @typedef {Object} SegmentInterface
 * @property {SegmentEventPayload[]} queue - A queue of events to be sent when
 *  the flushAt limit has been reached, or flushInterval occurs
 * @property {() => void} flush - Immediately flush the queue, resetting it to
 *  an empty array and sending the pending events to Segment
 * @property {(
 *  payload: SegmentEventPayload,
 *  callback: (err?: Error) => void
 * ) => void} track - Track an event with Segment, using the internal batching
 *  mechanism to optimize network requests
 * @property {(payload: Object) => void} page - Track a page view with Segment
 * @property {() => void} identify - Identify an anonymous user. We do not
 *  currently use this method.
 */

exports.METAMETRICS_BACKGROUND_PAGE_OBJECT = METAMETRICS_BACKGROUND_PAGE_OBJECT;
const REJECT_NOTFICIATION_CLOSE = 'Cancel Via Notification Close';
exports.REJECT_NOTFICIATION_CLOSE = REJECT_NOTFICIATION_CLOSE;
const REJECT_NOTFICIATION_CLOSE_SIG = 'Cancel Sig Request Via Notification Close';
exports.REJECT_NOTFICIATION_CLOSE_SIG = REJECT_NOTFICIATION_CLOSE_SIG;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/metametrics.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/first-time-state.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/first-time-state.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @typedef {Object} FirstTimeState
 * @property {Object} config Initial configuration parameters
 * @property {Object} NetworkController Network controller state
 */

/**
 * @type {FirstTimeState}
 */
const initialState = {
  config: {},
  PreferencesController: {
    frequentRpcListDetail: [{
      rpcUrl: 'http://localhost:8545',
      chainId: '0x539',
      ticker: 'ETH',
      nickname: 'Localhost 8545',
      rpcPrefs: {}
    }]
  }
};
var _default = initialState;
exports.default = _default;


      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/first-time-state.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/getObjStructure.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/getObjStructure.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getObjStructure;

var _lodash = require("lodash");

// This will create an object that represents the structure of the given object
// it replaces all values with the result of their type
// {
//   "data": {
//     "CurrencyController": {
//       "conversionDate": "number",
//       "conversionRate": "number",
//       "currentCurrency": "string"
//     }
// }

/**
 * Creates an object that represents the structure of the given object. It replaces all values with the result of their
 * type.
 *
 * @param {Object} obj - The object for which a 'structure' will be returned. Usually a plain object and not a class.
 * @returns {Object} The "mapped" version of a deep clone of the passed object, with each non-object property value
 * replaced with the javascript type of that value.
 *
 */
function getObjStructure(obj) {
  const structure = (0, _lodash.cloneDeep)(obj);
  return deepMap(structure, value => {
    return value === null ? 'null' : typeof value;
  });
}
/**
 * Modifies all the properties and deeply nested of a passed object. Iterates recursively over all nested objects and
 * their properties, and covers the entire depth of the object. At each property value which is not an object is modified.
 *
 * @param {Object} target - The object to modify
 * @param {Function} visit - The modifier to apply to each non-object property value
 * @returns {Object} The modified object
 */


function deepMap(target = {}, visit) {
  Object.entries(target).forEach(([key, value]) => {
    if (typeof value === 'object' && value !== null) {
      target[key] = deepMap(value, visit);
    } else {
      target[key] = visit(value);
    }
  });
  return target;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/getObjStructure.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/debounce-stream/index.js", {"debounce":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debounce/index.js","duplexer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/duplexer/index.js","through":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/through/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/debounce-stream/index.js
      return function (require, module, exports) {
var through = require('through')
  , duplexer = require('duplexer')
  , debounce = require('debounce')

module.exports = debounceStream

function debounceStream(_ms, immediate) {
  var ms = _ms || 100
    , input = through(debounce(write, ms, immediate))
    , output = through()

  return duplexer(input, output)

  function write(data) {
    output.queue(data)
  }
}

      };
    };
  }
}, {package:"debounce-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debounce-stream/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/local-store.js", {"./util":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/util.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","extensionizer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/extensionizer/index.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/local-store.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extensionizer = _interopRequireDefault(require("extensionizer"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _util = require("./util");

/**
 * A wrapper around the extension's storage local API
 */
class ExtensionStore {
  /**
   * @constructor
   */
  constructor() {
    this.isSupported = Boolean(_extensionizer.default.storage.local);

    if (!this.isSupported) {
      _loglevel.default.error('Storage local API not available.');
    }
  }
  /**
   * Returns all of the keys currently saved
   * @returns {Promise<*>}
   */


  async get() {
    if (!this.isSupported) {
      return undefined;
    }

    const result = await this._get(); // extension.storage.local always returns an obj
    // if the object is empty, treat it as undefined

    if (isEmpty(result)) {
      return undefined;
    }

    return result;
  }
  /**
   * Sets the key in local state
   * @param {Object} state - The state to set
   * @returns {Promise<void>}
   */


  async set(state) {
    return this._set(state);
  }
  /**
   * Returns all of the keys currently saved
   * @private
   * @returns {Object} the key-value map from local storage
   */


  _get() {
    const {
      local
    } = _extensionizer.default.storage;
    return new Promise((resolve, reject) => {
      local.get(null, (
      /** @type {any} */
      result) => {
        const err = (0, _util.checkForError)();

        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
  }
  /**
   * Sets the key in local state
   * @param {Object} obj - The key to set
   * @returns {Promise<void>}
   * @private
   */


  _set(obj) {
    const {
      local
    } = _extensionizer.default.storage;
    return new Promise((resolve, reject) => {
      local.set(obj, () => {
        const err = (0, _util.checkForError)();

        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }

}
/**
 * Returns whether or not the given object contains no keys
 * @param {Object} obj - The object to check
 * @returns {boolean}
 */


exports.default = ExtensionStore;

function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/local-store.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/network-store.js", {"../../../shared/constants/time":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/time.js","../../../shared/modules/fetch-with-timeout":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/fetch-with-timeout.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/network-store.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _time = require("../../../shared/constants/time");

var _fetchWithTimeout = _interopRequireDefault(require("../../../shared/modules/fetch-with-timeout"));

const fetchWithTimeout = (0, _fetchWithTimeout.default)(_time.SECOND * 30);
const FIXTURE_SERVER_HOST = 'localhost';
const FIXTURE_SERVER_PORT = 12345;
const FIXTURE_SERVER_URL = `http://${FIXTURE_SERVER_HOST}:${FIXTURE_SERVER_PORT}/state.json`;
/**
 * A read-only network-based storage wrapper
 */

class ReadOnlyNetworkStore {
  constructor() {
    (0, _defineProperty2.default)(this, "isSupported", true);
    this._initialized = false;
    this._initializing = this._init();
    this._state = undefined;
  }
  /**
   * Declares this store as compatible with the current browser
   */


  /**
   * Initializes by loading state from the network
   */
  async _init() {
    try {
      const response = await fetchWithTimeout(FIXTURE_SERVER_URL);

      if (response.ok) {
        this._state = await response.json();
      }
    } catch (error) {
      _loglevel.default.debug(`Error loading network state: '${error.message}'`);
    } finally {
      this._initialized = true;
    }
  }
  /**
   * Returns state
   * @returns {Promise<object>}
   */


  async get() {
    if (!this._initialized) {
      await this._initializing;
    }

    return this._state;
  }
  /**
   * Set state
   * @param {Object} state - The state to set
   * @returns {Promise<void>}
   */


  async set(state) {
    if (!this._initialized) {
      await this._initializing;
    }

    this._state = state;
  }

}

exports.default = ReadOnlyNetworkStore;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/network-store.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/notification-manager.js", {"../platforms/extension":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/platforms/extension.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-event-emitter/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/notification-manager.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.NOTIFICATION_MANAGER_EVENTS = void 0;

var _safeEventEmitter = _interopRequireDefault(require("safe-event-emitter"));

var _extension = _interopRequireDefault(require("../platforms/extension"));

const NOTIFICATION_HEIGHT = 620;
const NOTIFICATION_WIDTH = 360;
const NOTIFICATION_MANAGER_EVENTS = {
  POPUP_CLOSED: 'onPopupClosed'
};
exports.NOTIFICATION_MANAGER_EVENTS = NOTIFICATION_MANAGER_EVENTS;

class NotificationManager extends _safeEventEmitter.default {
  /**
   * A collection of methods for controlling the showing and hiding of the notification popup.
   *
   * @typedef {Object} NotificationManager
   *
   */
  constructor() {
    super();
    this.platform = new _extension.default();
    this.platform.addOnRemovedListener(this._onWindowClosed.bind(this));
  }
  /**
   * Either brings an existing MetaMask notification window into focus, or creates a new notification window. New
   * notification windows are given a 'popup' type.
   *
   */


  async showPopup() {
    const popup = await this._getPopup(); // Bring focus to chrome popup

    if (popup) {
      // bring focus to existing chrome popup
      await this.platform.focusWindow(popup.id);
    } else {
      let left = 0;
      let top = 0;

      try {
        const lastFocused = await this.platform.getLastFocusedWindow(); // Position window in top right corner of lastFocused window.

        top = lastFocused.top;
        left = lastFocused.left + (lastFocused.width - NOTIFICATION_WIDTH);
      } catch (_) {
        // The following properties are more than likely 0, due to being
        // opened from the background chrome process for the extension that
        // has no physical dimensions
        const {
          screenX,
          screenY,
          outerWidth
        } = window;
        top = Math.max(screenY, 0);
        left = Math.max(screenX + (outerWidth - NOTIFICATION_WIDTH), 0);
      } // create new notification popup


      const popupWindow = await this.platform.openWindow({
        url: 'notification.html',
        type: 'popup',
        width: NOTIFICATION_WIDTH,
        height: NOTIFICATION_HEIGHT,
        left,
        top
      }); // Firefox currently ignores left/top for create, but it works for update

      if (popupWindow.left !== left && popupWindow.state !== 'fullscreen') {
        await this.platform.updateWindowPosition(popupWindow.id, left, top);
      }

      this._popupId = popupWindow.id;
    }
  }

  _onWindowClosed(windowId) {
    if (windowId === this._popupId) {
      this._popupId = undefined;
      this.emit(NOTIFICATION_MANAGER_EVENTS.POPUP_CLOSED);
    }
  }
  /**
   * Checks all open MetaMask windows, and returns the first one it finds that is a notification window (i.e. has the
   * type 'popup')
   *
   * @private
   * @param {Function} cb - A node style callback that to which the found notification window will be passed.
   *
   */


  async _getPopup() {
    const windows = await this.platform.getAllWindows();
    return this._getPopupIn(windows);
  }
  /**
   * Given an array of windows, returns the 'popup' that has been opened by MetaMask, or null if no such window exists.
   *
   * @private
   * @param {Array} windows - An array of objects containing data about the open MetaMask extension windows.
   *
   */


  _getPopupIn(windows) {
    return windows ? windows.find(win => {
      // Returns notification popup
      return win && win.type === 'popup' && win.id === this._popupId;
    }) : null;
  }

}

exports.default = NotificationManager;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/notification-manager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createStreamSink.js", {"@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","promise-to-callback":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promise-to-callback/index.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createStreamSink.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createStreamSink;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _readableStream = require("readable-stream");

var _promiseToCallback = _interopRequireDefault(require("promise-to-callback"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class AsyncWritableStream extends _readableStream.Writable {
  constructor(asyncWriteFn, _opts) {
    const opts = _objectSpread({
      objectMode: true
    }, _opts);

    super(opts);
    this._asyncWriteFn = asyncWriteFn;
  } // write from incoming stream to state


  _write(chunk, encoding, callback) {
    (0, _promiseToCallback.default)(this._asyncWriteFn(chunk, encoding))(callback);
  }

}

function createStreamSink(asyncWriteFn, _opts) {
  return new AsyncWritableStream(asyncWriteFn, _opts);
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createStreamSink.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/get-first-preferred-lang-code.js", {"../../_locales/index.json":"/home/clarisco/Desktop/metamask-extension-develop/app/_locales/index.json","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","extensionizer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/extensionizer/index.js","pify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/get-first-preferred-lang-code.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getFirstPreferredLangCode;

var _extensionizer = _interopRequireDefault(require("extensionizer"));

var _pify = _interopRequireDefault(require("pify"));

var _index = _interopRequireDefault(require("../../_locales/index.json"));

const getPreferredLocales = _extensionizer.default.i18n ? (0, _pify.default)(_extensionizer.default.i18n.getAcceptLanguages, {
  errorFirst: false
}) : async () => []; // mapping some browsers return hyphen instead underscore in locale codes (e.g. zh_TW -> zh-tw)

const existingLocaleCodes = {};

_index.default.forEach(locale => {
  if (locale && locale.code) {
    existingLocaleCodes[locale.code.toLowerCase().replace('_', '-')] = locale.code;
  }
});
/**
 * Returns a preferred language code, based on settings within the user's browser. If we have no translations for the
 * users preferred locales, 'en' is returned.
 *
 * @returns {Promise<string>} Promises a locale code, either one from the user's preferred list that we have a translation for, or 'en'
 *
 */


async function getFirstPreferredLangCode() {
  let userPreferredLocaleCodes;

  try {
    userPreferredLocaleCodes = await getPreferredLocales();
  } catch (e) {
    // Brave currently throws when calling getAcceptLanguages, so this handles that.
    userPreferredLocaleCodes = [];
  } // safeguard for Brave Browser until they implement chrome.i18n.getAcceptLanguages
  // https://github.com/MetaMask/metamask-extension/issues/4270


  if (!userPreferredLocaleCodes) {
    userPreferredLocaleCodes = [];
  }

  let firstPreferredLangCode = userPreferredLocaleCodes.map(code => code.toLowerCase().replace('_', '-')).find(code => existingLocaleCodes[code] !== undefined || existingLocaleCodes[code.split('-')[0]] !== undefined); // if we have matched against a code with a '-' present, meaning its a regional
  // code for which we have a non-regioned locale, we need to set firstPreferredLangCode
  // to the correct non-regional code.

  if (firstPreferredLangCode !== undefined && existingLocaleCodes[firstPreferredLangCode] === undefined) {
    firstPreferredLangCode = firstPreferredLangCode.split('-')[0];
  }

  return existingLocaleCodes[firstPreferredLangCode] || 'en';
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/get-first-preferred-lang-code.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js", {"./ComposedStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/ComposedStore.js","./LocalStorageStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/LocalStorageStore.js","./MergedStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/MergedStore.js","./ObservableStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/ObservableStore.js","./asStream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/asStream.js","./transform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/transform.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./asStream"), exports);
__exportStar(require("./ComposedStore"), exports);
__exportStar(require("./LocalStorageStore"), exports);
__exportStar(require("./MergedStore"), exports);
__exportStar(require("./ObservableStore"), exports);
__exportStar(require("./transform"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/migrator/index.js", {"@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/migrator/index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = _interopRequireDefault(require("events"));

/**
 * @typedef {Object} Migration
 * @property {number} version - The migration version
 * @property {Function} migrate - Returns a promise of the migrated data
 */

/**
 * @typedef {Object} MigratorOptions
 * @property {Array<Migration>} [migrations] - The list of migrations to apply
 * @property {number} [defaultVersion] - The version to use in the initial state
 */
class Migrator extends _events.default {
  /**
   * @constructor
   * @param {MigratorOptions} opts
   */
  constructor(opts = {}) {
    super();
    const migrations = opts.migrations || []; // sort migrations by version

    this.migrations = migrations.sort((a, b) => a.version - b.version); // grab migration with highest version

    const lastMigration = this.migrations.slice(-1)[0]; // use specified defaultVersion or highest migration version

    this.defaultVersion = opts.defaultVersion || lastMigration && lastMigration.version || 0;
  } // run all pending migrations on meta in place


  async migrateData(versionedData = this.generateInitialState()) {
    // get all migrations that have not yet been run
    const pendingMigrations = this.migrations.filter(migrationIsPending); // perform each migration

    for (const migration of pendingMigrations) {
      try {
        // attempt migration and validate
        const migratedData = await migration.migrate(versionedData);

        if (!migratedData.data) {
          throw new Error('Migrator - migration returned empty data');
        }

        if (migratedData.version !== undefined && migratedData.meta.version !== migration.version) {
          throw new Error('Migrator - Migration did not update version number correctly');
        } // accept the migration as good
        // eslint-disable-next-line no-param-reassign


        versionedData = migratedData;
      } catch (err) {
        // rewrite error message to add context without clobbering stack
        const originalErrorMessage = err.message;
        err.message = `MetaMask Migration Error #${migration.version}: ${originalErrorMessage}`; // emit error instead of throw so as to not break the run (gracefully fail)

        this.emit('error', err); // stop migrating and use state as is

        return versionedData;
      }
    }

    return versionedData;
    /**
     * Returns whether or not the migration is pending
     *
     * A migration is considered "pending" if it has a higher
     * version number than the current version.
     * @param {Migration} migration
     * @returns {boolean}
     */

    function migrationIsPending(migration) {
      return migration.version > versionedData.meta.version;
    }
  }
  /**
   * Returns the initial state for the migrator
   * @param {Object} [data] - The data for the initial state
   * @returns {{meta: {version: number}, data: any}}
   */


  generateInitialState(data) {
    return {
      meta: {
        version: this.defaultVersion
      },
      data
    };
  }

}

exports.default = Migrator;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/migrator/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/index.js", {"./002":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/002.js","./003":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/003.js","./004":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/004.js","./005":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/005.js","./006":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/006.js","./007":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/007.js","./008":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/008.js","./009":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/009.js","./010":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/010.js","./011":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/011.js","./012":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/012.js","./013":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/013.js","./014":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/014.js","./015":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/015.js","./016":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/016.js","./017":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/017.js","./018":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/018.js","./019":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/019.js","./020":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/020.js","./021":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/021.js","./022":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/022.js","./023":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/023.js","./024":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/024.js","./025":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/025.js","./026":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/026.js","./027":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/027.js","./028":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/028.js","./029":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/029.js","./030":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/030.js","./031":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/031.js","./032":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/032.js","./033":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/033.js","./034":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/034.js","./035":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/035.js","./036":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/036.js","./037":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/037.js","./038":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/038.js","./039":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/039.js","./040":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/040.js","./041":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/041.js","./042":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/042.js","./043":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/043.js","./044":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/044.js","./045":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/045.js","./046":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/046.js","./047":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/047.js","./048":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/048.js","./049":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/049.js","./050":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/050.js","./051":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/051.js","./052":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/052.js","./053":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/053.js","./054":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/054.js","./055":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/055.js","./056":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/056.js","./057":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/057.js","./058":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/058.js","./059":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/059.js","./060":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/060.js","./061":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/061.js","./062":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/062.js","./063":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/063.js","./064":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/064.js","./065":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/065.js","./066":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/066.js","./067":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/067.js","./068":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/068.js","./069":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/069.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ = _interopRequireDefault(require("./002"));

var _2 = _interopRequireDefault(require("./003"));

var _3 = _interopRequireDefault(require("./004"));

var _4 = _interopRequireDefault(require("./005"));

var _5 = _interopRequireDefault(require("./006"));

var _6 = _interopRequireDefault(require("./007"));

var _7 = _interopRequireDefault(require("./008"));

var _8 = _interopRequireDefault(require("./009"));

var _9 = _interopRequireDefault(require("./010"));

var _10 = _interopRequireDefault(require("./011"));

var _11 = _interopRequireDefault(require("./012"));

var _12 = _interopRequireDefault(require("./013"));

var _13 = _interopRequireDefault(require("./014"));

var _14 = _interopRequireDefault(require("./015"));

var _15 = _interopRequireDefault(require("./016"));

var _16 = _interopRequireDefault(require("./017"));

var _17 = _interopRequireDefault(require("./018"));

var _18 = _interopRequireDefault(require("./019"));

var _19 = _interopRequireDefault(require("./020"));

var _20 = _interopRequireDefault(require("./021"));

var _21 = _interopRequireDefault(require("./022"));

var _22 = _interopRequireDefault(require("./023"));

var _23 = _interopRequireDefault(require("./024"));

var _24 = _interopRequireDefault(require("./025"));

var _25 = _interopRequireDefault(require("./026"));

var _26 = _interopRequireDefault(require("./027"));

var _27 = _interopRequireDefault(require("./028"));

var _28 = _interopRequireDefault(require("./029"));

var _29 = _interopRequireDefault(require("./030"));

var _30 = _interopRequireDefault(require("./031"));

var _31 = _interopRequireDefault(require("./032"));

var _32 = _interopRequireDefault(require("./033"));

var _33 = _interopRequireDefault(require("./034"));

var _34 = _interopRequireDefault(require("./035"));

var _35 = _interopRequireDefault(require("./036"));

var _36 = _interopRequireDefault(require("./037"));

var _37 = _interopRequireDefault(require("./038"));

var _38 = _interopRequireDefault(require("./039"));

var _39 = _interopRequireDefault(require("./040"));

var _40 = _interopRequireDefault(require("./041"));

var _41 = _interopRequireDefault(require("./042"));

var _42 = _interopRequireDefault(require("./043"));

var _43 = _interopRequireDefault(require("./044"));

var _44 = _interopRequireDefault(require("./045"));

var _45 = _interopRequireDefault(require("./046"));

var _46 = _interopRequireDefault(require("./047"));

var _47 = _interopRequireDefault(require("./048"));

var _48 = _interopRequireDefault(require("./049"));

var _49 = _interopRequireDefault(require("./050"));

var _50 = _interopRequireDefault(require("./051"));

var _51 = _interopRequireDefault(require("./052"));

var _52 = _interopRequireDefault(require("./053"));

var _53 = _interopRequireDefault(require("./054"));

var _54 = _interopRequireDefault(require("./055"));

var _55 = _interopRequireDefault(require("./056"));

var _56 = _interopRequireDefault(require("./057"));

var _57 = _interopRequireDefault(require("./058"));

var _58 = _interopRequireDefault(require("./059"));

var _59 = _interopRequireDefault(require("./060"));

var _60 = _interopRequireDefault(require("./061"));

var _61 = _interopRequireDefault(require("./062"));

var _62 = _interopRequireDefault(require("./063"));

var _63 = _interopRequireDefault(require("./064"));

var _64 = _interopRequireDefault(require("./065"));

var _65 = _interopRequireDefault(require("./066"));

var _66 = _interopRequireDefault(require("./067"));

var _67 = _interopRequireDefault(require("./068"));

var _68 = _interopRequireDefault(require("./069"));

// Migrations must start at version 1 or later.
// They are objects with a `version` number
// and a `migrate` function.
//
// The `migrate` function receives the previous
// config data format, and returns the new one.
const migrations = [_.default, _2.default, _3.default, _4.default, _5.default, _6.default, _7.default, _8.default, _9.default, _10.default, _11.default, _12.default, _13.default, _14.default, _15.default, _16.default, _17.default, _18.default, _19.default, _20.default, _21.default, _22.default, _23.default, _24.default, _25.default, _26.default, _27.default, _28.default, _29.default, _30.default, _31.default, _32.default, _33.default, _34.default, _35.default, _36.default, _37.default, _38.default, _39.default, _40.default, _41.default, _42.default, _43.default, _44.default, _45.default, _46.default, _47.default, _48.default, _49.default, _50.default, _51.default, _52.default, _53.default, _54.default, _55.default, _56.default, _57.default, _58.default, _59.default, _60.default, _61.default, _62.default, _63.default, _64.default, _65.default, _66.default, _67.default, _68.default];
var _default = migrations;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/setup.js", {"../../../../shared/constants/time":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/time.js","../../../../shared/modules/fetch-with-timeout":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/fetch-with-timeout.js","./resolver":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/resolver.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","base32-encode":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base32-encode/index.js","base64-js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base64-js/index.js","extensionizer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/extensionizer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/setup.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setupEnsIpfsResolver;

var _base32Encode = _interopRequireDefault(require("base32-encode"));

var _base64Js = _interopRequireDefault(require("base64-js"));

var _extensionizer = _interopRequireDefault(require("extensionizer"));

var _time = require("../../../../shared/constants/time");

var _fetchWithTimeout = _interopRequireDefault(require("../../../../shared/modules/fetch-with-timeout"));

var _resolver = _interopRequireDefault(require("./resolver"));

const fetchWithTimeout = (0, _fetchWithTimeout.default)(_time.SECOND * 30);
const supportedTopLevelDomains = ['eth'];

function setupEnsIpfsResolver({
  provider,
  getCurrentChainId,
  getIpfsGateway
}) {
  // install listener
  const urlPatterns = supportedTopLevelDomains.map(tld => `*://*.${tld}/*`);

  _extensionizer.default.webRequest.onErrorOccurred.addListener(webRequestDidFail, {
    urls: urlPatterns,
    types: ['main_frame']
  }); // return api object


  return {
    // uninstall listener
    remove() {
      _extensionizer.default.webRequest.onErrorOccurred.removeListener(webRequestDidFail);
    }

  };

  async function webRequestDidFail(details) {
    const {
      tabId,
      url
    } = details; // ignore requests that are not associated with tabs
    // only attempt ENS resolution on mainnet

    if (tabId === -1 || getCurrentChainId() !== '0x1') {
      return;
    } // parse ens name


    const {
      hostname: name,
      pathname,
      search,
      hash: fragment
    } = new URL(url);
    const domainParts = name.split('.');
    const topLevelDomain = domainParts[domainParts.length - 1]; // if unsupported TLD, abort

    if (!supportedTopLevelDomains.includes(topLevelDomain)) {
      return;
    } // otherwise attempt resolve


    attemptResolve({
      tabId,
      name,
      pathname,
      search,
      fragment
    });
  }

  async function attemptResolve({
    tabId,
    name,
    pathname,
    search,
    fragment
  }) {
    const ipfsGateway = getIpfsGateway();

    _extensionizer.default.tabs.update(tabId, {
      url: `loading.html`
    });

    let url = `https://app.ens.domains/name/${name}`;

    try {
      const {
        type,
        hash
      } = await (0, _resolver.default)({
        provider,
        name
      });

      if (type === 'ipfs-ns' || type === 'ipns-ns') {
        const resolvedUrl = `https://${hash}.${type.slice(0, 4)}.${ipfsGateway}${pathname}${search || ''}${fragment || ''}`;

        try {
          // check if ipfs gateway has result
          const response = await fetchWithTimeout(resolvedUrl, {
            method: 'HEAD'
          });

          if (response.status === 200) {
            url = resolvedUrl;
          }
        } catch (err) {
          console.warn(err);
        }
      } else if (type === 'swarm-ns') {
        url = `https://swarm-gateways.net/bzz:/${hash}${pathname}${search || ''}${fragment || ''}`;
      } else if (type === 'onion' || type === 'onion3') {
        url = `http://${hash}.onion${pathname}${search || ''}${fragment || ''}`;
      } else if (type === 'zeronet') {
        url = `http://127.0.0.1:43110/${hash}${pathname}${search || ''}${fragment || ''}`;
      } else if (type === 'skynet-ns') {
        const padded = hash.padEnd(hash.length + 4 - hash.length % 4, '=');

        const decoded = _base64Js.default.toByteArray(padded);

        const options = {
          padding: false
        };
        const base32EncodedSkylink = (0, _base32Encode.default)(decoded, 'RFC4648-HEX', options).toLowerCase();
        url = `https://${base32EncodedSkylink}.siasky.net${pathname}${search || ''}${fragment || ''}`;
      }
    } catch (err) {
      console.warn(err);
    } finally {
      _extensionizer.default.tabs.update(tabId, {
        url
      });
    }
  }
}


      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/setup.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/metamask-controller.js", {"../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js","../../shared/constants/hardware-wallets":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/hardware-wallets.js","../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","../../shared/constants/permissions":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/permissions.js","../../shared/constants/swaps":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/swaps.js","../../shared/constants/time":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/time.js","../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","../../shared/modules/hexstring-utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/hexstring-utils.js","../../shared/notifications":"/home/clarisco/Desktop/metamask-extension-develop/shared/notifications/index.js","../../ui/helpers/utils/conversions.util":"/home/clarisco/Desktop/metamask-extension-develop/ui/helpers/utils/conversions.util.js","./account-import-strategies":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/account-import-strategies/index.js","./controllers/alert":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/alert.js","./controllers/app-state":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/app-state.js","./controllers/cached-balances":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/cached-balances.js","./controllers/detect-tokens":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/detect-tokens.js","./controllers/ens":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/ens/index.js","./controllers/incoming-transactions":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/incoming-transactions.js","./controllers/metametrics":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/metametrics.js","./controllers/network":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/index.js","./controllers/onboarding":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/onboarding.js","./controllers/permissions":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/index.js","./controllers/preferences":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/preferences.js","./controllers/swaps":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/swaps.js","./controllers/threebox":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/threebox.js","./controllers/transactions":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/index.js","./lib/ComposableObservableStore":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ComposableObservableStore.js","./lib/account-tracker":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/account-tracker.js","./lib/createLoggerMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createLoggerMiddleware.js","./lib/createMetaRPCHandler":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createMetaRPCHandler.js","./lib/createOnboardingMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createOnboardingMiddleware.js","./lib/createOriginMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createOriginMiddleware.js","./lib/createTabIdMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createTabIdMiddleware.js","./lib/decrypt-message-manager":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/decrypt-message-manager.js","./lib/encryption-public-key-manager":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/encryption-public-key-manager.js","./lib/message-manager":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/message-manager.js","./lib/personal-message-manager":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/personal-message-manager.js","./lib/rpc-method-middleware":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/index.js","./lib/seed-phrase-verifier":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/seed-phrase-verifier.js","./lib/segment":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/segment.js","./lib/stream-utils":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/stream-utils.js","./lib/typed-message-manager":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/typed-message-manager.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@keystonehq/metamask-airgapped-keyring":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/dist/index.js","@metamask/controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/controllers/dist/index.js","@metamask/eth-ledger-bridge-keyring":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/index.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","@metamask/obs-store/dist/asStream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/asStream.js","@metamask/snap-controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/index.js","@sentry/browser":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@sentry/browser/dist/index.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","await-semaphore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/await-semaphore/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","eth-json-rpc-filters":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-filters/index.js","eth-json-rpc-filters/subscriptionManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-filters/subscriptionManager.js","eth-json-rpc-middleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/index.js","eth-keyring-controller":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-keyring-controller/index.js","eth-lattice-keyring":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-lattice-keyring/index.js","eth-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-query/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","eth-trezor-keyring":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-trezor-keyring/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js","json-rpc-middleware-stream/engineStream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-middleware-stream/engineStream.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js","nanoid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/nanoid/index.browser.js","pump":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pump/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/metamask-controller.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.METAMASK_CONTROLLER_EVENTS = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _events = _interopRequireDefault(require("events"));

var _pump = _interopRequireDefault(require("pump"));

var _obsStore = require("@metamask/obs-store");

var _asStream = require("@metamask/obs-store/dist/asStream");

var _jsonRpcEngine = require("json-rpc-engine");

var _lodash = require("lodash");

var _engineStream = _interopRequireDefault(require("json-rpc-middleware-stream/engineStream"));

var _ethJsonRpcFilters = _interopRequireDefault(require("eth-json-rpc-filters"));

var _subscriptionManager = _interopRequireDefault(require("eth-json-rpc-filters/subscriptionManager"));

var _ethJsonRpcMiddleware = require("eth-json-rpc-middleware");

var _ethKeyringController = _interopRequireDefault(require("eth-keyring-controller"));

var _ethRpcErrors = require("eth-rpc-errors");

var _awaitSemaphore = require("await-semaphore");

var _ethereumjsUtil = require("ethereumjs-util");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _ethTrezorKeyring = _interopRequireDefault(require("eth-trezor-keyring"));

var _ethLedgerBridgeKeyring = _interopRequireDefault(require("@metamask/eth-ledger-bridge-keyring"));

var _ethLatticeKeyring = _interopRequireDefault(require("eth-lattice-keyring"));

var _metamaskAirgappedKeyring = require("@keystonehq/metamask-airgapped-keyring");

var _ethQuery = _interopRequireDefault(require("eth-query"));

var _nanoid = _interopRequireDefault(require("nanoid"));

var _browser = require("@sentry/browser");

var _controllers = require("@metamask/controllers");

var _snapControllers = require("@metamask/snap-controllers");

var _transaction = require("../../shared/constants/transaction");

var _swaps = require("../../shared/constants/swaps");

var _network = require("../../shared/constants/network");

var _hardwareWallets = require("../../shared/constants/hardware-wallets");

var _permissions = require("../../shared/constants/permissions");

var _notifications = require("../../shared/notifications");

var _hexstringUtils = require("../../shared/modules/hexstring-utils");

var _time = require("../../shared/constants/time");

var _app = require("../../shared/constants/app");

var _conversions = require("../../ui/helpers/utils/conversions.util");

var _ComposableObservableStore = _interopRequireDefault(require("./lib/ComposableObservableStore"));

var _accountTracker = _interopRequireDefault(require("./lib/account-tracker"));

var _createLoggerMiddleware = _interopRequireDefault(require("./lib/createLoggerMiddleware"));

var _rpcMethodMiddleware = _interopRequireDefault(require("./lib/rpc-method-middleware"));

var _createOriginMiddleware = _interopRequireDefault(require("./lib/createOriginMiddleware"));

var _createTabIdMiddleware = _interopRequireDefault(require("./lib/createTabIdMiddleware"));

var _createOnboardingMiddleware = _interopRequireDefault(require("./lib/createOnboardingMiddleware"));

var _streamUtils = require("./lib/stream-utils");

var _ens = _interopRequireDefault(require("./controllers/ens"));

var _network2 = _interopRequireWildcard(require("./controllers/network"));

var _preferences = _interopRequireDefault(require("./controllers/preferences"));

var _appState = _interopRequireDefault(require("./controllers/app-state"));

var _cachedBalances = _interopRequireDefault(require("./controllers/cached-balances"));

var _alert = _interopRequireDefault(require("./controllers/alert"));

var _onboarding = _interopRequireDefault(require("./controllers/onboarding"));

var _threebox = _interopRequireDefault(require("./controllers/threebox"));

var _incomingTransactions = _interopRequireDefault(require("./controllers/incoming-transactions"));

var _messageManager = _interopRequireWildcard(require("./lib/message-manager"));

var _decryptMessageManager = _interopRequireDefault(require("./lib/decrypt-message-manager"));

var _encryptionPublicKeyManager = _interopRequireDefault(require("./lib/encryption-public-key-manager"));

var _personalMessageManager = _interopRequireDefault(require("./lib/personal-message-manager"));

var _typedMessageManager = _interopRequireDefault(require("./lib/typed-message-manager"));

var _transactions = _interopRequireDefault(require("./controllers/transactions"));

var _detectTokens = _interopRequireDefault(require("./controllers/detect-tokens"));

var _swaps2 = _interopRequireDefault(require("./controllers/swaps"));

var _accountImportStrategies = _interopRequireDefault(require("./account-import-strategies"));

var _seedPhraseVerifier = _interopRequireDefault(require("./lib/seed-phrase-verifier"));

var _metametrics = _interopRequireDefault(require("./controllers/metametrics"));

var _segment = require("./lib/segment");

var _createMetaRPCHandler = _interopRequireDefault(require("./lib/createMetaRPCHandler"));

var _permissions2 = require("./controllers/permissions");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const METAMASK_CONTROLLER_EVENTS = {
  // Fired after state changes that impact the extension badge (unapproved msg count)
  // The process of updating the badge happens in app/scripts/background.js.
  UPDATE_BADGE: 'updateBadge',
  // TODO: Add this and similar enums to @metamask/controllers and export them
  APPROVAL_STATE_CHANGE: 'ApprovalController:stateChange'
};
exports.METAMASK_CONTROLLER_EVENTS = METAMASK_CONTROLLER_EVENTS;

class MetamaskController extends _events.default {
  /**
   * @constructor
   * @param {Object} opts
   */
  constructor(opts) {
    var _process$env$CONF;

    super();
    this.defaultMaxListeners = 20;
    this.sendUpdate = (0, _lodash.debounce)(this.privateSendUpdate.bind(this), _time.MILLISECOND * 200);
    this.opts = opts;
    this.extension = opts.extension;
    this.platform = opts.platform;
    const initState = opts.initState || {};
    const version = this.platform.getVersion();
    this.recordFirstTimeInfo(initState); // this keeps track of how many "controllerStream" connections are open
    // the only thing that uses controller connections are open metamask UI instances

    this.activeControllerConnections = 0;
    this.getRequestAccountTabIds = opts.getRequestAccountTabIds;
    this.getOpenMetamaskTabsIds = opts.getOpenMetamaskTabsIds;
    this.controllerMessenger = new _controllers.ControllerMessenger(); // observable state store

    this.store = new _ComposableObservableStore.default({
      state: initState,
      controllerMessenger: this.controllerMessenger,
      persist: true
    }); // external connections by origin
    // Do not modify directly. Use the associated methods.

    this.connections = {}; // lock to ensure only one vault created at once

    this.createVaultMutex = new _awaitSemaphore.Mutex();
    this.extension.runtime.onInstalled.addListener(details => {
      if (details.reason === 'update' && version === '8.1.0') {
        this.platform.openExtensionInBrowser();
      }
    }); // next, we will initialize the controllers
    // controller initialization order matters

    this.approvalController = new _controllers.ApprovalController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'ApprovalController'
      }),
      showApprovalRequest: opts.showUserConfirmation
    });
    this.networkController = new _network2.default(initState.NetworkController);
    this.networkController.setInfuraProjectId(opts.infuraProjectId); // now we can initialize the RPC provider, which other controllers require

    this.initializeProvider();
    this.provider = this.networkController.getProviderAndBlockTracker().provider;
    this.blockTracker = this.networkController.getProviderAndBlockTracker().blockTracker;
    this.preferencesController = new _preferences.default({
      initState: initState.PreferencesController,
      initLangCode: opts.initLangCode,
      openPopup: opts.openPopup,
      network: this.networkController,
      provider: this.provider,
      migrateAddressBookState: this.migrateAddressBookState.bind(this)
    });
    this.tokensController = new _controllers.TokensController({
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: this.networkController.store.subscribe.bind(this.networkController.store),
      config: {
        provider: this.provider
      },
      state: initState.TokensController
    });
    this.assetsContractController = new _controllers.AssetsContractController({
      provider: this.provider
    });
    this.collectiblesController = new _controllers.CollectiblesController({
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: this.networkController.store.subscribe.bind(this.networkController.store),
      getAssetName: this.assetsContractController.getAssetName.bind(this.assetsContractController),
      getAssetSymbol: this.assetsContractController.getAssetSymbol.bind(this.assetsContractController),
      getCollectibleTokenURI: this.assetsContractController.getCollectibleTokenURI.bind(this.assetsContractController),
      getOwnerOf: this.assetsContractController.getOwnerOf.bind(this.assetsContractController),
      balanceOfERC1155Collectible: this.assetsContractController.balanceOfERC1155Collectible.bind(this.assetsContractController),
      uriERC1155Collectible: this.assetsContractController.uriERC1155Collectible.bind(this.assetsContractController)
    }, {}, initState.CollectiblesController);
    false && (this.collectibleDetectionController = new _controllers.CollectibleDetectionController({
      onCollectiblesStateChange: listener => this.collectiblesController.subscribe(listener),
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: this.networkController.store.subscribe.bind(this.networkController.store),
      getOpenSeaApiKey: () => this.collectiblesController.openSeaApiKey,
      getBalancesInSingleCall: this.assetsContractController.getBalancesInSingleCall.bind(this.assetsContractController),
      addCollectible: this.collectiblesController.addCollectible.bind(this.collectiblesController),
      getCollectiblesState: () => this.collectiblesController.state
    }));
    this.metaMetricsController = new _metametrics.default({
      segment: _segment.segment,
      preferencesStore: this.preferencesController.store,
      onNetworkDidChange: this.networkController.on.bind(this.networkController, _network2.NETWORK_EVENTS.NETWORK_DID_CHANGE),
      getNetworkIdentifier: this.networkController.getNetworkIdentifier.bind(this.networkController),
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      version: this.platform.getVersion(),
      environment: "development",
      initState: initState.MetaMetricsController,
      captureException: _browser.captureException
    });
    const gasFeeMessenger = this.controllerMessenger.getRestricted({
      name: 'GasFeeController'
    });
    const gasApiBaseUrl = false ? _swaps.GAS_DEV_API_BASE_URL : _swaps.GAS_API_BASE_URL;
    this.gasFeeController = new _controllers.GasFeeController({
      interval: 10000,
      messenger: gasFeeMessenger,
      clientId: _swaps.SWAPS_CLIENT_ID,
      getProvider: () => this.networkController.getProviderAndBlockTracker().provider,
      onNetworkStateChange: this.networkController.on.bind(this.networkController, _network2.NETWORK_EVENTS.NETWORK_DID_CHANGE),
      getCurrentNetworkEIP1559Compatibility: this.networkController.getEIP1559Compatibility.bind(this.networkController),
      getCurrentAccountEIP1559Compatibility: this.getCurrentAccountEIP1559Compatibility.bind(this),
      legacyAPIEndpoint: `${gasApiBaseUrl}/networks/<chain_id>/gasPrices`,
      EIP1559APIEndpoint: `${gasApiBaseUrl}/networks/<chain_id>/suggestedGasFees`,
      getCurrentNetworkLegacyGasAPICompatibility: () => {
        const chainId = this.networkController.getCurrentChainId();
        return process.env.IN_TEST || chainId === _network.MAINNET_CHAIN_ID;
      },
      getChainId: () => {
        return process.env.IN_TEST ? _network.MAINNET_CHAIN_ID : this.networkController.getCurrentChainId();
      }
    });
    this.qrHardwareKeyring = new _metamaskAirgappedKeyring.MetaMaskKeyring();
    this.appStateController = new _appState.default({
      addUnlockListener: this.on.bind(this, 'unlock'),
      isUnlocked: this.isUnlocked.bind(this),
      initState: initState.AppStateController,
      onInactiveTimeout: () => this.setLocked(),
      showUnlockRequest: opts.showUserConfirmation,
      preferencesStore: this.preferencesController.store,
      qrHardwareStore: this.qrHardwareKeyring.getMemStore()
    });
    const currencyRateMessenger = this.controllerMessenger.getRestricted({
      name: 'CurrencyRateController'
    });
    this.currencyRateController = new _controllers.CurrencyRateController({
      includeUSDRate: true,
      messenger: currencyRateMessenger,
      state: initState.CurrencyController
    });
    const tokenListMessenger = this.controllerMessenger.getRestricted({
      name: 'TokenListController'
    });
    this.tokenListController = new _controllers.TokenListController({
      chainId: (0, _conversions.hexToDecimal)(this.networkController.getCurrentChainId()),
      useStaticTokenList: !this.preferencesController.store.getState().useTokenDetection,
      onNetworkStateChange: cb => this.networkController.store.subscribe(networkState => {
        const modifiedNetworkState = _objectSpread(_objectSpread({}, networkState), {}, {
          provider: _objectSpread(_objectSpread({}, networkState.provider), {}, {
            chainId: (0, _conversions.hexToDecimal)(networkState.provider.chainId)
          })
        });

        return cb(modifiedNetworkState);
      }),
      onPreferencesStateChange: cb => this.preferencesController.store.subscribe(preferencesState => {
        const modifiedPreferencesState = _objectSpread(_objectSpread({}, preferencesState), {}, {
          useStaticTokenList: !this.preferencesController.store.getState().useTokenDetection
        });

        return cb(modifiedPreferencesState);
      }),
      messenger: tokenListMessenger,
      state: initState.TokenListController
    });
    this.phishingController = new _controllers.PhishingController();
    this.notificationController = new _controllers.NotificationController({
      allNotifications: _notifications.UI_NOTIFICATIONS
    }, initState.NotificationController); // token exchange rate tracker

    this.tokenRatesController = new _controllers.TokenRatesController({
      onTokensStateChange: listener => this.tokensController.subscribe(listener),
      onCurrencyRateStateChange: listener => this.controllerMessenger.subscribe(`${this.currencyRateController.name}:stateChange`, listener),
      onNetworkStateChange: cb => this.networkController.store.subscribe(networkState => {
        const modifiedNetworkState = _objectSpread(_objectSpread({}, networkState), {}, {
          provider: _objectSpread(_objectSpread({}, networkState.provider), {}, {
            chainId: (0, _conversions.hexToDecimal)(networkState.provider.chainId)
          })
        });

        return cb(modifiedNetworkState);
      })
    });
    this.ensController = new _ens.default({
      provider: this.provider,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      onNetworkDidChange: this.networkController.on.bind(this.networkController, _network2.NETWORK_EVENTS.NETWORK_DID_CHANGE)
    });
    this.incomingTransactionsController = new _incomingTransactions.default({
      blockTracker: this.blockTracker,
      onNetworkDidChange: this.networkController.on.bind(this.networkController, _network2.NETWORK_EVENTS.NETWORK_DID_CHANGE),
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      preferencesController: this.preferencesController,
      initState: initState.IncomingTransactionsController
    }); // account tracker watches balances, nonces, and any code at their address

    this.accountTracker = new _accountTracker.default({
      provider: this.provider,
      blockTracker: this.blockTracker,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController)
    }); // start and stop polling for balances based on activeControllerConnections

    this.on('controllerConnectionChanged', activeControllerConnections => {
      if (activeControllerConnections > 0) {
        this.accountTracker.start();
        this.incomingTransactionsController.start();
        this.currencyRateController.start();
        this.tokenListController.start();
      } else {
        this.accountTracker.stop();
        this.incomingTransactionsController.stop();
        this.currencyRateController.stop();
        this.tokenListController.stop();
      }
    });
    this.cachedBalancesController = new _cachedBalances.default({
      accountTracker: this.accountTracker,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      initState: initState.CachedBalancesController
    });
    this.onboardingController = new _onboarding.default({
      initState: initState.OnboardingController
    });
    this.tokensController.hub.on('pendingSuggestedAsset', async () => {
      await opts.openPopup();
    });
    const additionalKeyrings = [_ethTrezorKeyring.default, _ethLedgerBridgeKeyring.default, _ethLatticeKeyring.default, _metamaskAirgappedKeyring.MetaMaskKeyring];
    this.keyringController = new _ethKeyringController.default({
      keyringTypes: additionalKeyrings,
      initState: initState.KeyringController,
      encryptor: opts.encryptor || undefined
    });
    this.keyringController.memStore.subscribe(state => this._onKeyringControllerUpdate(state));
    this.keyringController.on('unlock', () => this._onUnlock());
    this.keyringController.on('lock', () => this._onLock());

    const getIdentities = () => this.preferencesController.store.getState().identities;

    this.permissionController = new _snapControllers.PermissionController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'PermissionController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:hasRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`]
      }),
      state: initState.PermissionController,
      caveatSpecifications: (0, _permissions2.getCaveatSpecifications)({
        getIdentities
      }),
      permissionSpecifications: (0, _permissions2.getPermissionSpecifications)({
        getIdentities,
        getAllAccounts: this.keyringController.getAccounts.bind(this.keyringController)
      }),
      unrestrictedMethods: _permissions2.unrestrictedMethods
    });
    this.permissionLogController = new _permissions2.PermissionLogController({
      restrictedMethods: new Set(Object.keys(_permissions.RestrictedMethods)),
      initState: initState.PermissionLogController
    });
    this.subjectMetadataController = new _snapControllers.SubjectMetadataController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'SubjectMetadataController',
        allowedActions: [`${this.permissionController.name}:hasPermissions`]
      }),
      state: initState.SubjectMetadataController,
      subjectCacheLimit: 100
    });
    this.detectTokensController = new _detectTokens.default({
      preferences: this.preferencesController,
      tokensController: this.tokensController,
      network: this.networkController,
      keyringMemStore: this.keyringController.memStore,
      tokenList: this.tokenListController
    });
    this.addressBookController = new _controllers.AddressBookController(undefined, initState.AddressBookController);
    this.alertController = new _alert.default({
      initState: initState.AlertController,
      preferencesStore: this.preferencesController.store
    });
    this.threeBoxController = new _threebox.default({
      preferencesController: this.preferencesController,
      addressBookController: this.addressBookController,
      keyringController: this.keyringController,
      initState: initState.ThreeBoxController,
      getKeyringControllerState: this.keyringController.memStore.getState.bind(this.keyringController.memStore),
      version,
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.txController = new _transactions.default({
      initState: initState.TransactionController || initState.TransactionManager,
      getPermittedAccounts: this.getPermittedAccounts.bind(this),
      getProviderConfig: this.networkController.getProviderConfig.bind(this.networkController),
      getCurrentNetworkEIP1559Compatibility: this.networkController.getEIP1559Compatibility.bind(this.networkController),
      getCurrentAccountEIP1559Compatibility: this.getCurrentAccountEIP1559Compatibility.bind(this),
      networkStore: this.networkController.networkStore,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      preferencesStore: this.preferencesController.store,
      txHistoryLimit: 40,
      signTransaction: this.keyringController.signTransaction.bind(this.keyringController),
      provider: this.provider,
      blockTracker: this.blockTracker,
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController),
      getParticipateInMetrics: () => this.metaMetricsController.state.participateInMetaMetrics,
      getEIP1559GasFeeEstimates: this.gasFeeController.fetchGasFeeEstimates.bind(this.gasFeeController)
    });
    this.txController.on('newUnapprovedTx', () => opts.showUserConfirmation());
    this.txController.on(`tx:status-update`, async (txId, status) => {
      if (status === _transaction.TRANSACTION_STATUSES.CONFIRMED || status === _transaction.TRANSACTION_STATUSES.FAILED) {
        const txMeta = this.txController.txStateManager.getTransaction(txId);
        const frequentRpcListDetail = this.preferencesController.getFrequentRpcListDetail();
        let rpcPrefs = {};

        if (txMeta.chainId) {
          var _rpcSettings$rpcPrefs;

          const rpcSettings = frequentRpcListDetail.find(rpc => txMeta.chainId === rpc.chainId);
          rpcPrefs = (_rpcSettings$rpcPrefs = rpcSettings === null || rpcSettings === void 0 ? void 0 : rpcSettings.rpcPrefs) !== null && _rpcSettings$rpcPrefs !== void 0 ? _rpcSettings$rpcPrefs : {};
        }

        this.platform.showTransactionNotification(txMeta, rpcPrefs);
        const {
          txReceipt
        } = txMeta;
        const metamaskState = await this.getState();

        if (txReceipt && txReceipt.status === '0x0') {
          var _txMeta$simulationFai;

          this.metaMetricsController.trackEvent({
            event: 'Tx Status Update: On-Chain Failure',
            category: 'Background',
            properties: {
              action: 'Transactions',
              errorMessage: (_txMeta$simulationFai = txMeta.simulationFails) === null || _txMeta$simulationFai === void 0 ? void 0 : _txMeta$simulationFai.reason,
              numberOfTokens: metamaskState.tokens.length,
              numberOfAccounts: Object.keys(metamaskState.accounts).length
            }
          }, {
            matomoEvent: true
          });
        }
      }
    });
    this.networkController.on(_network2.NETWORK_EVENTS.NETWORK_DID_CHANGE, async () => {
      const {
        ticker
      } = this.networkController.getProviderConfig();

      try {
        await this.currencyRateController.setNativeCurrency(ticker);
      } catch (error) {
        // TODO: Handle failure to get conversion rate more gracefully
        console.error(error);
      }
    });
    this.networkController.lookupNetwork();
    this.messageManager = new _messageManager.default({
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.personalMessageManager = new _personalMessageManager.default({
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.decryptMessageManager = new _decryptMessageManager.default({
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.encryptionPublicKeyManager = new _encryptionPublicKeyManager.default({
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.typedMessageManager = new _typedMessageManager.default({
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.swapsController = new _swaps2.default({
      getBufferedGasLimit: this.txController.txGasUtil.getBufferedGasLimit.bind(this.txController.txGasUtil),
      networkController: this.networkController,
      provider: this.provider,
      getProviderConfig: this.networkController.getProviderConfig.bind(this.networkController),
      getTokenRatesState: () => this.tokenRatesController.state,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      getEIP1559GasFeeEstimates: this.gasFeeController.fetchGasFeeEstimates.bind(this.gasFeeController)
    }); // ensure accountTracker updates balances after network change

    this.networkController.on(_network2.NETWORK_EVENTS.NETWORK_DID_CHANGE, () => {
      this.accountTracker._updateAccounts();
    }); // clear unapproved transactions and messages when the network will change

    this.networkController.on(_network2.NETWORK_EVENTS.NETWORK_WILL_CHANGE, () => {
      this.txController.txStateManager.clearUnapprovedTxs();
      this.encryptionPublicKeyManager.clearUnapproved();
      this.personalMessageManager.clearUnapproved();
      this.typedMessageManager.clearUnapproved();
      this.decryptMessageManager.clearUnapproved();
      this.messageManager.clearUnapproved();
    }); // ensure isClientOpenAndUnlocked is updated when memState updates

    this.on('update', memState => this._onStateUpdate(memState));
    this.store.updateStructure({
      AppStateController: this.appStateController.store,
      TransactionController: this.txController.store,
      KeyringController: this.keyringController.store,
      PreferencesController: this.preferencesController.store,
      MetaMetricsController: this.metaMetricsController.store,
      AddressBookController: this.addressBookController,
      CurrencyController: this.currencyRateController,
      NetworkController: this.networkController.store,
      CachedBalancesController: this.cachedBalancesController.store,
      AlertController: this.alertController.store,
      OnboardingController: this.onboardingController.store,
      IncomingTransactionsController: this.incomingTransactionsController.store,
      PermissionController: this.permissionController,
      PermissionLogController: this.permissionLogController.store,
      SubjectMetadataController: this.subjectMetadataController,
      ThreeBoxController: this.threeBoxController.store,
      NotificationController: this.notificationController,
      GasFeeController: this.gasFeeController,
      TokenListController: this.tokenListController,
      TokensController: this.tokensController,
      CollectiblesController: this.collectiblesController
    });
    this.memStore = new _ComposableObservableStore.default({
      config: {
        AppStateController: this.appStateController.store,
        NetworkController: this.networkController.store,
        AccountTracker: this.accountTracker.store,
        TxController: this.txController.memStore,
        CachedBalancesController: this.cachedBalancesController.store,
        TokenRatesController: this.tokenRatesController,
        MessageManager: this.messageManager.memStore,
        PersonalMessageManager: this.personalMessageManager.memStore,
        DecryptMessageManager: this.decryptMessageManager.memStore,
        EncryptionPublicKeyManager: this.encryptionPublicKeyManager.memStore,
        TypesMessageManager: this.typedMessageManager.memStore,
        KeyringController: this.keyringController.memStore,
        PreferencesController: this.preferencesController.store,
        MetaMetricsController: this.metaMetricsController.store,
        AddressBookController: this.addressBookController,
        CurrencyController: this.currencyRateController,
        AlertController: this.alertController.store,
        OnboardingController: this.onboardingController.store,
        IncomingTransactionsController: this.incomingTransactionsController.store,
        PermissionController: this.permissionController,
        PermissionLogController: this.permissionLogController.store,
        SubjectMetadataController: this.subjectMetadataController,
        ThreeBoxController: this.threeBoxController.store,
        SwapsController: this.swapsController.store,
        EnsController: this.ensController.store,
        ApprovalController: this.approvalController,
        NotificationController: this.notificationController,
        GasFeeController: this.gasFeeController,
        TokenListController: this.tokenListController,
        TokensController: this.tokensController,
        CollectiblesController: this.collectiblesController
      },
      controllerMessenger: this.controllerMessenger
    });
    this.memStore.subscribe(this.sendUpdate.bind(this));
    const password = (_process$env$CONF = {"INFURA_PROJECT_ID":"e3e6f907dfa74923843323d6b0b9abaa","ONBOARDING_V2":"","COLLECTIBLES_V1":"","EIP_1559_V2":"","SEGMENT_WRITE_KEY":"","SENTRY_DSN_DEV":"https://f59f3dd640d2429d9d0e2445a87ea8e1@sentry.io/273496","PASSWORD":"METAMASK PASSWORD","SWAPS_USE_DEV_APIS":"","_":["scripts:core:dev:standardEntryPoints"],"build-type":"main","lint-fence-files":"false","skip-stats":true,"configs":["/home/clarisco/Desktop/metamask-extension-develop/.metamaskrc"],"config":"/home/clarisco/Desktop/metamask-extension-develop/.metamaskrc"}) === null || _process$env$CONF === void 0 ? void 0 : _process$env$CONF.PASSWORD;

    if (password && !this.isUnlocked() && this.onboardingController.store.getState().completedOnboarding) {
      this.submitPassword(password);
    } // Lazily update the store with the current extension environment


    this.extension.runtime.getPlatformInfo(({
      os
    }) => {
      this.appStateController.setBrowserEnvironment(os, // This method is presently only supported by Firefox
      this.extension.runtime.getBrowserInfo === undefined ? 'chrome' : 'firefox');
    });
    this.setupControllerEventSubscriptions(); // TODO:LegacyProvider: Delete

    this.publicConfigStore = this.createPublicConfigStore();
  }
  /**
   * Sets up BaseController V2 event subscriptions. Currently, this includes
   * the subscriptions necessary to notify permission subjects of account
   * changes.
   *
   * Some of the subscriptions in this method are ControllerMessenger selector
   * event subscriptions. See the relevant @metamask/controllers documentation
   * for more information.
   *
   * Note that account-related notifications emitted when the extension
   * becomes unlocked are handled in MetaMaskController._onUnlock.
   */


  setupControllerEventSubscriptions() {
    const handleAccountsChange = async (origin, newAccounts) => {
      if (this.isUnlocked()) {
        this.notifyConnections(origin, {
          method: _permissions2.NOTIFICATION_NAMES.accountsChanged,
          // This should be the same as the return value of `eth_accounts`,
          // namely an array of the current / most recently selected Ethereum
          // account.
          params: newAccounts.length < 2 ? // If the length is 1 or 0, the accounts are sorted by definition.
          newAccounts : // If the length is 2 or greater, we have to execute
          // `eth_accounts` vi this method.
          await this.getPermittedAccounts(origin)
        });
      }

      this.permissionLogController.updateAccountsHistory(origin, newAccounts);
    }; // This handles account changes whenever the selected address changes.


    let lastSelectedAddress;
    this.preferencesController.store.subscribe(async ({
      selectedAddress
    }) => {
      if (selectedAddress && selectedAddress !== lastSelectedAddress) {
        lastSelectedAddress = selectedAddress;
        const permittedAccountsMap = (0, _permissions2.getPermittedAccountsByOrigin)(this.permissionController.state);

        for (const [origin, accounts] of permittedAccountsMap.entries()) {
          if (accounts.includes(selectedAddress)) {
            handleAccountsChange(origin, accounts);
          }
        }
      }
    }); // This handles account changes every time relevant permission state
    // changes, for any reason.

    this.controllerMessenger.subscribe(`${this.permissionController.name}:stateChange`, async (currentValue, previousValue) => {
      const changedAccounts = (0, _permissions2.getChangedAccounts)(currentValue, previousValue);

      for (const [origin, accounts] of changedAccounts.entries()) {
        handleAccountsChange(origin, accounts);
      }
    }, _permissions2.getPermittedAccountsByOrigin);
  }
  /**
   * Constructor helper: initialize a provider.
   */


  initializeProvider() {
    const version = this.platform.getVersion();
    const providerOpts = {
      static: {
        eth_syncing: false,
        web3_clientVersion: `MetaMask/v${version}`
      },
      version,
      // account mgmt
      getAccounts: async ({
        origin
      }) => {
        if (origin === 'metamask') {
          const selectedAddress = this.preferencesController.getSelectedAddress();
          return selectedAddress ? [selectedAddress] : [];
        } else if (this.isUnlocked()) {
          return await this.getPermittedAccounts(origin);
        }

        return []; // changing this is a breaking change
      },
      // tx signing
      processTransaction: this.newUnapprovedTransaction.bind(this),
      // msg signing
      processEthSignMessage: this.newUnsignedMessage.bind(this),
      processTypedMessage: this.newUnsignedTypedMessage.bind(this),
      processTypedMessageV3: this.newUnsignedTypedMessage.bind(this),
      processTypedMessageV4: this.newUnsignedTypedMessage.bind(this),
      processPersonalMessage: this.newUnsignedPersonalMessage.bind(this),
      processDecryptMessage: this.newRequestDecryptMessage.bind(this),
      processEncryptionPublicKey: this.newRequestEncryptionPublicKey.bind(this),
      getPendingNonce: this.getPendingNonce.bind(this),
      getPendingTransactionByHash: hash => this.txController.getTransactions({
        searchCriteria: {
          hash,
          status: _transaction.TRANSACTION_STATUSES.SUBMITTED
        }
      })[0]
    };
    const providerProxy = this.networkController.initializeProvider(providerOpts);
    return providerProxy;
  }
  /**
   * TODO:LegacyProvider: Delete
   * Constructor helper: initialize a public config store.
   * This store is used to make some config info available to Dapps synchronously.
   */


  createPublicConfigStore() {
    // subset of state for metamask inpage provider
    const publicConfigStore = new _obsStore.ObservableStore();
    const {
      networkController
    } = this; // setup memStore subscription hooks

    this.on('update', updatePublicConfigStore);
    updatePublicConfigStore(this.getState());

    function updatePublicConfigStore(memState) {
      const chainId = networkController.getCurrentChainId();

      if (memState.network !== 'loading') {
        publicConfigStore.putState(selectPublicState(chainId, memState));
      }
    }

    function selectPublicState(chainId, {
      isUnlocked,
      network
    }) {
      return {
        isUnlocked,
        chainId,
        networkVersion: network
      };
    }

    return publicConfigStore;
  }
  /**
   * Gets relevant state for the provider of an external origin.
   *
   * @param {string} origin - The origin to get the provider state for.
   * @returns {Promise<{
   *  isUnlocked: boolean,
   *  networkVersion: string,
   *  chainId: string,
   *  accounts: string[],
   * }>} An object with relevant state properties.
   */


  async getProviderState(origin) {
    return _objectSpread(_objectSpread({
      isUnlocked: this.isUnlocked()
    }, this.getProviderNetworkState()), {}, {
      accounts: await this.getPermittedAccounts(origin)
    });
  }
  /**
   * Gets network state relevant for external providers.
   *
   * @param {Object} [memState] - The MetaMask memState. If not provided,
   * this function will retrieve the most recent state.
   * @returns {Object} An object with relevant network state properties.
   */


  getProviderNetworkState(memState) {
    const {
      network
    } = memState || this.getState();
    return {
      chainId: this.networkController.getCurrentChainId(),
      networkVersion: network
    };
  } //=============================================================================
  // EXPOSED TO THE UI SUBSYSTEM
  //=============================================================================

  /**
   * The metamask-state of the various controllers, made available to the UI
   *
   * @returns {Object} status
   */


  getState() {
    const {
      vault
    } = this.keyringController.store.getState();
    const isInitialized = Boolean(vault);
    return _objectSpread({
      isInitialized
    }, this.memStore.getFlatState());
  }
  /**
   * Returns an Object containing API Callback Functions.
   * These functions are the interface for the UI.
   * The API object can be transmitted over a stream via JSON-RPC.
   *
   * @returns {Object} Object containing API functions.
   */


  getApi() {
    const {
      addressBookController,
      alertController,
      approvalController,
      appStateController,
      collectiblesController,
      collectibleDetectionController,
      currencyRateController,
      detectTokensController,
      ensController,
      gasFeeController,
      keyringController,
      metaMetricsController,
      networkController,
      notificationController,
      onboardingController,
      permissionController,
      preferencesController,
      qrHardwareKeyring,
      swapsController,
      threeBoxController,
      tokensController,
      txController
    } = this;
    return _objectSpread(_objectSpread({
      // etc
      getState: this.getState.bind(this),
      setCurrentCurrency: currencyRateController.setCurrentCurrency.bind(currencyRateController),
      setUseBlockie: preferencesController.setUseBlockie.bind(preferencesController),
      setUseNonceField: preferencesController.setUseNonceField.bind(preferencesController),
      setUsePhishDetect: preferencesController.setUsePhishDetect.bind(preferencesController),
      setUseTokenDetection: preferencesController.setUseTokenDetection.bind(preferencesController),
      setUseCollectibleDetection: preferencesController.setUseCollectibleDetection.bind(preferencesController),
      setOpenSeaEnabled: preferencesController.setOpenSeaEnabled.bind(preferencesController),
      setIpfsGateway: preferencesController.setIpfsGateway.bind(preferencesController),
      setParticipateInMetaMetrics: metaMetricsController.setParticipateInMetaMetrics.bind(metaMetricsController),
      setCurrentLocale: preferencesController.setCurrentLocale.bind(preferencesController),
      markPasswordForgotten: this.markPasswordForgotten.bind(this),
      unMarkPasswordForgotten: this.unMarkPasswordForgotten.bind(this),
      safelistPhishingDomain: this.safelistPhishingDomain.bind(this),
      getRequestAccountTabIds: this.getRequestAccountTabIds,
      getOpenMetamaskTabsIds: this.getOpenMetamaskTabsIds,
      // primary HD keyring management
      addNewAccount: this.addNewAccount.bind(this),
      verifySeedPhrase: this.verifySeedPhrase.bind(this),
      resetAccount: this.resetAccount.bind(this),
      removeAccount: this.removeAccount.bind(this),
      importAccountWithStrategy: this.importAccountWithStrategy.bind(this),
      // hardware wallets
      connectHardware: this.connectHardware.bind(this),
      forgetDevice: this.forgetDevice.bind(this),
      checkHardwareStatus: this.checkHardwareStatus.bind(this),
      unlockHardwareWalletAccount: this.unlockHardwareWalletAccount.bind(this),
      setLedgerTransportPreference: this.setLedgerTransportPreference.bind(this),
      attemptLedgerTransportCreation: this.attemptLedgerTransportCreation.bind(this),
      establishLedgerTransportPreference: this.establishLedgerTransportPreference.bind(this),
      // qr hardware devices
      submitQRHardwareCryptoHDKey: qrHardwareKeyring.submitCryptoHDKey.bind(qrHardwareKeyring),
      submitQRHardwareCryptoAccount: qrHardwareKeyring.submitCryptoAccount.bind(qrHardwareKeyring),
      cancelSyncQRHardware: qrHardwareKeyring.cancelSync.bind(qrHardwareKeyring),
      submitQRHardwareSignature: qrHardwareKeyring.submitSignature.bind(qrHardwareKeyring),
      cancelQRHardwareSignRequest: qrHardwareKeyring.cancelSignRequest.bind(qrHardwareKeyring),
      // mobile
      fetchInfoToSync: this.fetchInfoToSync.bind(this),
      // vault management
      submitPassword: this.submitPassword.bind(this),
      verifyPassword: this.verifyPassword.bind(this),
      // network management
      setProviderType: networkController.setProviderType.bind(networkController),
      rollbackToPreviousProvider: networkController.rollbackToPreviousProvider.bind(networkController),
      setCustomRpc: this.setCustomRpc.bind(this),
      updateAndSetCustomRpc: this.updateAndSetCustomRpc.bind(this),
      delCustomRpc: this.delCustomRpc.bind(this),
      // PreferencesController
      setSelectedAddress: preferencesController.setSelectedAddress.bind(preferencesController),
      addToken: tokensController.addToken.bind(tokensController),
      rejectWatchAsset: tokensController.rejectWatchAsset.bind(tokensController),
      acceptWatchAsset: tokensController.acceptWatchAsset.bind(tokensController),
      updateTokenType: tokensController.updateTokenType.bind(tokensController),
      removeToken: tokensController.removeAndIgnoreToken.bind(tokensController),
      setAccountLabel: preferencesController.setAccountLabel.bind(preferencesController),
      setFeatureFlag: preferencesController.setFeatureFlag.bind(preferencesController),
      setPreference: preferencesController.setPreference.bind(preferencesController),
      addKnownMethodData: preferencesController.addKnownMethodData.bind(preferencesController),
      setDismissSeedBackUpReminder: preferencesController.setDismissSeedBackUpReminder.bind(preferencesController),
      setAdvancedGasFee: preferencesController.setAdvancedGasFee.bind(preferencesController),
      // CollectiblesController
      addCollectible: collectiblesController.addCollectible.bind(collectiblesController),
      addCollectibleVerifyOwnership: collectiblesController.addCollectibleVerifyOwnership.bind(collectiblesController),
      removeAndIgnoreCollectible: collectiblesController.removeAndIgnoreCollectible.bind(collectiblesController),
      removeCollectible: collectiblesController.removeCollectible.bind(collectiblesController),
      // AddressController
      setAddressBook: addressBookController.set.bind(addressBookController),
      removeFromAddressBook: addressBookController.delete.bind(addressBookController),
      // AppStateController
      setLastActiveTime: appStateController.setLastActiveTime.bind(appStateController),
      setDefaultHomeActiveTabName: appStateController.setDefaultHomeActiveTabName.bind(appStateController),
      setConnectedStatusPopoverHasBeenShown: appStateController.setConnectedStatusPopoverHasBeenShown.bind(appStateController),
      setRecoveryPhraseReminderHasBeenShown: appStateController.setRecoveryPhraseReminderHasBeenShown.bind(appStateController),
      setRecoveryPhraseReminderLastShown: appStateController.setRecoveryPhraseReminderLastShown.bind(appStateController),
      setShowTestnetMessageInDropdown: appStateController.setShowTestnetMessageInDropdown.bind(appStateController),
      setCollectiblesDetectionNoticeDismissed: appStateController.setCollectiblesDetectionNoticeDismissed.bind(appStateController),
      // EnsController
      tryReverseResolveAddress: ensController.reverseResolveAddress.bind(ensController),
      // KeyringController
      setLocked: this.setLocked.bind(this),
      createNewVaultAndKeychain: this.createNewVaultAndKeychain.bind(this),
      createNewVaultAndRestore: this.createNewVaultAndRestore.bind(this),
      exportAccount: keyringController.exportAccount.bind(keyringController),
      // txController
      cancelTransaction: txController.cancelTransaction.bind(txController),
      updateTransaction: txController.updateTransaction.bind(txController),
      updateAndApproveTransaction: txController.updateAndApproveTransaction.bind(txController),
      createCancelTransaction: this.createCancelTransaction.bind(this),
      createSpeedUpTransaction: this.createSpeedUpTransaction.bind(this),
      estimateGas: this.estimateGas.bind(this),
      getNextNonce: this.getNextNonce.bind(this),
      addUnapprovedTransaction: txController.addUnapprovedTransaction.bind(txController),
      // messageManager
      signMessage: this.signMessage.bind(this),
      cancelMessage: this.cancelMessage.bind(this),
      // personalMessageManager
      signPersonalMessage: this.signPersonalMessage.bind(this),
      cancelPersonalMessage: this.cancelPersonalMessage.bind(this),
      // typedMessageManager
      signTypedMessage: this.signTypedMessage.bind(this),
      cancelTypedMessage: this.cancelTypedMessage.bind(this),
      // decryptMessageManager
      decryptMessage: this.decryptMessage.bind(this),
      decryptMessageInline: this.decryptMessageInline.bind(this),
      cancelDecryptMessage: this.cancelDecryptMessage.bind(this),
      // EncryptionPublicKeyManager
      encryptionPublicKey: this.encryptionPublicKey.bind(this),
      cancelEncryptionPublicKey: this.cancelEncryptionPublicKey.bind(this),
      // onboarding controller
      setSeedPhraseBackedUp: onboardingController.setSeedPhraseBackedUp.bind(onboardingController),
      completeOnboarding: onboardingController.completeOnboarding.bind(onboardingController),
      setFirstTimeFlowType: onboardingController.setFirstTimeFlowType.bind(onboardingController),
      // alert controller
      setAlertEnabledness: alertController.setAlertEnabledness.bind(alertController),
      setUnconnectedAccountAlertShown: alertController.setUnconnectedAccountAlertShown.bind(alertController),
      setWeb3ShimUsageAlertDismissed: alertController.setWeb3ShimUsageAlertDismissed.bind(alertController),
      // 3Box
      setThreeBoxSyncingPermission: threeBoxController.setThreeBoxSyncingPermission.bind(threeBoxController),
      restoreFromThreeBox: threeBoxController.restoreFromThreeBox.bind(threeBoxController),
      setShowRestorePromptToFalse: threeBoxController.setShowRestorePromptToFalse.bind(threeBoxController),
      getThreeBoxLastUpdated: threeBoxController.getLastUpdated.bind(threeBoxController),
      turnThreeBoxSyncingOn: threeBoxController.turnThreeBoxSyncingOn.bind(threeBoxController),
      initializeThreeBox: this.initializeThreeBox.bind(this),
      // permissions
      removePermissionsFor: permissionController.revokePermissions.bind(permissionController),
      approvePermissionsRequest: permissionController.acceptPermissionsRequest.bind(permissionController),
      rejectPermissionsRequest: permissionController.rejectPermissionsRequest.bind(permissionController)
    }, (0, _permissions2.getPermissionBackgroundApiMethods)(permissionController)), {}, {
      // swaps
      fetchAndSetQuotes: swapsController.fetchAndSetQuotes.bind(swapsController),
      setSelectedQuoteAggId: swapsController.setSelectedQuoteAggId.bind(swapsController),
      resetSwapsState: swapsController.resetSwapsState.bind(swapsController),
      setSwapsTokens: swapsController.setSwapsTokens.bind(swapsController),
      clearSwapsQuotes: swapsController.clearSwapsQuotes.bind(swapsController),
      setApproveTxId: swapsController.setApproveTxId.bind(swapsController),
      setTradeTxId: swapsController.setTradeTxId.bind(swapsController),
      setSwapsTxGasPrice: swapsController.setSwapsTxGasPrice.bind(swapsController),
      setSwapsTxGasLimit: swapsController.setSwapsTxGasLimit.bind(swapsController),
      setSwapsTxMaxFeePerGas: swapsController.setSwapsTxMaxFeePerGas.bind(swapsController),
      setSwapsTxMaxFeePriorityPerGas: swapsController.setSwapsTxMaxFeePriorityPerGas.bind(swapsController),
      safeRefetchQuotes: swapsController.safeRefetchQuotes.bind(swapsController),
      stopPollingForQuotes: swapsController.stopPollingForQuotes.bind(swapsController),
      setBackgroundSwapRouteState: swapsController.setBackgroundSwapRouteState.bind(swapsController),
      resetPostFetchState: swapsController.resetPostFetchState.bind(swapsController),
      setSwapsErrorKey: swapsController.setSwapsErrorKey.bind(swapsController),
      setInitialGasEstimate: swapsController.setInitialGasEstimate.bind(swapsController),
      setCustomApproveTxData: swapsController.setCustomApproveTxData.bind(swapsController),
      setSwapsLiveness: swapsController.setSwapsLiveness.bind(swapsController),
      setSwapsUserFeeLevel: swapsController.setSwapsUserFeeLevel.bind(swapsController),
      setSwapsQuotesPollingLimitEnabled: swapsController.setSwapsQuotesPollingLimitEnabled.bind(swapsController),
      // MetaMetrics
      trackMetaMetricsEvent: metaMetricsController.trackEvent.bind(metaMetricsController),
      trackMetaMetricsPage: metaMetricsController.trackPage.bind(metaMetricsController),
      // approval controller
      resolvePendingApproval: approvalController.accept.bind(approvalController),
      rejectPendingApproval: approvalController.reject.bind(approvalController),
      // Notifications
      updateViewedNotifications: notificationController.updateViewed.bind(notificationController),
      // GasFeeController
      getGasFeeEstimatesAndStartPolling: gasFeeController.getGasFeeEstimatesAndStartPolling.bind(gasFeeController),
      disconnectGasFeeEstimatePoller: gasFeeController.disconnectPoller.bind(gasFeeController),
      getGasFeeTimeEstimate: gasFeeController.getTimeEstimate.bind(gasFeeController),
      addPollingTokenToAppState: appStateController.addPollingToken.bind(appStateController),
      removePollingTokenFromAppState: appStateController.removePollingToken.bind(appStateController),
      // DetectTokenController
      detectNewTokens: detectTokensController.detectNewTokens.bind(detectTokensController),
      // DetectCollectibleController
      detectCollectibles: false ? collectibleDetectionController.detectCollectibles.bind(collectibleDetectionController) : null
    });
  } //=============================================================================
  // VAULT / KEYRING RELATED METHODS
  //=============================================================================

  /**
   * Creates a new Vault and create a new keychain.
   *
   * A vault, or KeyringController, is a controller that contains
   * many different account strategies, currently called Keyrings.
   * Creating it new means wiping all previous keyrings.
   *
   * A keychain, or keyring, controls many accounts with a single backup and signing strategy.
   * For example, a mnemonic phrase can generate many accounts, and is a keyring.
   *
   * @param {string} password
   * @returns {Object} vault
   */


  async createNewVaultAndKeychain(password) {
    const releaseLock = await this.createVaultMutex.acquire();

    try {
      let vault;
      const accounts = await this.keyringController.getAccounts();

      if (accounts.length > 0) {
        vault = await this.keyringController.fullUpdate();
      } else {
        vault = await this.keyringController.createNewVaultAndKeychain(password);
        const addresses = await this.keyringController.getAccounts();
        this.preferencesController.setAddresses(addresses);
        this.selectFirstIdentity();
      }

      return vault;
    } finally {
      releaseLock();
    }
  }
  /**
   * Create a new Vault and restore an existent keyring.
   * @param {string} password
   * @param {string} seed
   */


  async createNewVaultAndRestore(password, seed) {
    const releaseLock = await this.createVaultMutex.acquire();

    try {
      let accounts, lastBalance;
      const {
        keyringController
      } = this; // clear known identities

      this.preferencesController.setAddresses([]); // clear permissions

      this.permissionController.clearState(); // clear accounts in accountTracker

      this.accountTracker.clearAccounts(); // clear cachedBalances

      this.cachedBalancesController.clearCachedBalances(); // clear unapproved transactions

      this.txController.txStateManager.clearUnapprovedTxs(); // create new vault

      const vault = await keyringController.createNewVaultAndRestore(password, seed);
      const ethQuery = new _ethQuery.default(this.provider);
      accounts = await keyringController.getAccounts();
      lastBalance = await this.getBalance(accounts[accounts.length - 1], ethQuery);
      const primaryKeyring = keyringController.getKeyringsByType('HD Key Tree')[0];

      if (!primaryKeyring) {
        throw new Error('MetamaskController - No HD Key Tree found');
      } // seek out the first zero balance


      while (lastBalance !== '0x0') {
        await keyringController.addNewAccount(primaryKeyring);
        accounts = await keyringController.getAccounts();
        lastBalance = await this.getBalance(accounts[accounts.length - 1], ethQuery);
      } // remove extra zero balance account potentially created from seeking ahead


      if (accounts.length > 1 && lastBalance === '0x0') {
        await this.removeAccount(accounts[accounts.length - 1]);
        accounts = await keyringController.getAccounts();
      } // This must be set as soon as possible to communicate to the
      // keyring's iframe and have the setting initialized properly
      // Optimistically called to not block Metamask login due to
      // Ledger Keyring GitHub downtime


      const transportPreference = this.preferencesController.getLedgerTransportPreference();
      this.setLedgerTransportPreference(transportPreference); // set new identities

      this.preferencesController.setAddresses(accounts);
      this.selectFirstIdentity();
      return vault;
    } finally {
      releaseLock();
    }
  }
  /**
   * Get an account balance from the AccountTracker or request it directly from the network.
   * @param {string} address - The account address
   * @param {EthQuery} ethQuery - The EthQuery instance to use when asking the network
   */


  getBalance(address, ethQuery) {
    return new Promise((resolve, reject) => {
      const cached = this.accountTracker.store.getState().accounts[address];

      if (cached && cached.balance) {
        resolve(cached.balance);
      } else {
        ethQuery.getBalance(address, (error, balance) => {
          if (error) {
            reject(error);

            _loglevel.default.error(error);
          } else {
            resolve(balance || '0x0');
          }
        });
      }
    });
  }
  /**
   * Collects all the information that we want to share
   * with the mobile client for syncing purposes
   * @returns {Promise<Object>} Parts of the state that we want to syncx
   */


  async fetchInfoToSync() {
    // Preferences
    const {
      currentLocale,
      frequentRpcList,
      identities,
      selectedAddress,
      useTokenDetection
    } = this.preferencesController.store.getState();
    const {
      tokenList
    } = this.tokenListController.state;
    const preferences = {
      currentLocale,
      frequentRpcList,
      identities,
      selectedAddress
    }; // Tokens

    const {
      allTokens,
      allIgnoredTokens
    } = this.tokensController.state; // Filter ERC20 tokens

    const allERC20Tokens = {};
    Object.keys(allTokens).forEach(chainId => {
      allERC20Tokens[chainId] = {};
      Object.keys(allTokens[chainId]).forEach(accountAddress => {
        const checksummedAccountAddress = (0, _hexstringUtils.toChecksumHexAddress)(accountAddress);
        allERC20Tokens[chainId][checksummedAccountAddress] = allTokens[chainId][checksummedAccountAddress].filter(asset => {
          if (asset.isERC721 === undefined) {
            // since the token.address from allTokens is checksumaddress
            // asset.address have to be changed to lowercase when we are using dynamic list
            const address = useTokenDetection ? asset.address.toLowerCase() : asset.address; // the tokenList will be holding only erc20 tokens

            if (tokenList[address] !== undefined) {
              return true;
            }
          } else if (asset.isERC721 === false) {
            return true;
          }

          return false;
        });
      });
    }); // Accounts

    const hdKeyring = this.keyringController.getKeyringsByType('HD Key Tree')[0];
    const simpleKeyPairKeyrings = this.keyringController.getKeyringsByType('Simple Key Pair');
    const hdAccounts = await hdKeyring.getAccounts();
    const simpleKeyPairKeyringAccounts = await Promise.all(simpleKeyPairKeyrings.map(keyring => keyring.getAccounts()));
    const simpleKeyPairAccounts = simpleKeyPairKeyringAccounts.reduce((acc, accounts) => [...acc, ...accounts], []);
    const accounts = {
      hd: hdAccounts.filter((item, pos) => hdAccounts.indexOf(item) === pos).map(address => (0, _hexstringUtils.toChecksumHexAddress)(address)),
      simpleKeyPair: simpleKeyPairAccounts.filter((item, pos) => simpleKeyPairAccounts.indexOf(item) === pos).map(address => (0, _hexstringUtils.toChecksumHexAddress)(address)),
      ledger: [],
      trezor: [],
      lattice: []
    }; // transactions

    let {
      transactions
    } = this.txController.store.getState(); // delete tx for other accounts that we're not importing

    transactions = Object.values(transactions).filter(tx => {
      const checksummedTxFrom = (0, _hexstringUtils.toChecksumHexAddress)(tx.txParams.from);
      return accounts.hd.includes(checksummedTxFrom);
    });
    return {
      accounts,
      preferences,
      transactions,
      tokens: {
        allTokens: allERC20Tokens,
        allIgnoredTokens
      },
      network: this.networkController.store.getState()
    };
  }
  /*
   * Submits the user's password and attempts to unlock the vault.
   * Also synchronizes the preferencesController, to ensure its schema
   * is up to date with known accounts once the vault is decrypted.
   *
   * @param {string} password - The user's password
   * @returns {Promise<object>} The keyringController update.
   */


  async submitPassword(password) {
    await this.keyringController.submitPassword(password);

    try {
      await this.blockTracker.checkForLatestBlock();
    } catch (error) {
      _loglevel.default.error('Error while unlocking extension.', error);
    }

    try {
      const threeBoxSyncingAllowed = this.threeBoxController.getThreeBoxSyncingState();

      if (threeBoxSyncingAllowed && !this.threeBoxController.box) {
        // 'await' intentionally omitted to avoid waiting for initialization
        this.threeBoxController.init();
        this.threeBoxController.turnThreeBoxSyncingOn();
      } else if (threeBoxSyncingAllowed && this.threeBoxController.box) {
        this.threeBoxController.turnThreeBoxSyncingOn();
      }
    } catch (error) {
      _loglevel.default.error('Error while unlocking extension.', error);
    } // This must be set as soon as possible to communicate to the
    // keyring's iframe and have the setting initialized properly
    // Optimistically called to not block Metamask login due to
    // Ledger Keyring GitHub downtime


    const transportPreference = this.preferencesController.getLedgerTransportPreference();
    this.setLedgerTransportPreference(transportPreference);
    return this.keyringController.fullUpdate();
  }
  /**
   * Submits a user's password to check its validity.
   *
   * @param {string} password The user's password
   */


  async verifyPassword(password) {
    await this.keyringController.verifyPassword(password);
  }
  /**
   * @type Identity
   * @property {string} name - The account nickname.
   * @property {string} address - The account's ethereum address, in lower case.
   * @property {boolean} mayBeFauceting - Whether this account is currently
   * receiving funds from our automatic Ropsten faucet.
   */

  /**
   * Sets the first address in the state to the selected address
   */


  selectFirstIdentity() {
    const {
      identities
    } = this.preferencesController.store.getState();
    const address = Object.keys(identities)[0];
    this.preferencesController.setSelectedAddress(address);
  } //
  // Hardware
  //


  async getKeyringForDevice(deviceName, hdPath = null) {
    let keyringName = null;

    switch (deviceName) {
      case _hardwareWallets.DEVICE_NAMES.TREZOR:
        keyringName = _ethTrezorKeyring.default.type;
        break;

      case _hardwareWallets.DEVICE_NAMES.LEDGER:
        keyringName = _ethLedgerBridgeKeyring.default.type;
        break;

      case _hardwareWallets.DEVICE_NAMES.QR:
        keyringName = _metamaskAirgappedKeyring.MetaMaskKeyring.type;
        break;

      case _hardwareWallets.DEVICE_NAMES.LATTICE:
        keyringName = _ethLatticeKeyring.default.type;
        break;

      default:
        throw new Error('MetamaskController:getKeyringForDevice - Unknown device');
    }

    let keyring = await this.keyringController.getKeyringsByType(keyringName)[0];

    if (!keyring) {
      keyring = await this.keyringController.addNewKeyring(keyringName);
    }

    if (hdPath && keyring.setHdPath) {
      keyring.setHdPath(hdPath);
    }

    if (deviceName === _hardwareWallets.DEVICE_NAMES.LATTICE) {
      keyring.appName = 'MetaMask';
    }

    if (deviceName === 'trezor') {
      const model = keyring.getModel();
      this.appStateController.setTrezorModel(model);
    }

    keyring.network = this.networkController.getProviderConfig().type;
    return keyring;
  }

  async attemptLedgerTransportCreation() {
    const keyring = await this.getKeyringForDevice('ledger');
    return await keyring.attemptMakeApp();
  }

  async establishLedgerTransportPreference() {
    const transportPreference = this.preferencesController.getLedgerTransportPreference();
    return await this.setLedgerTransportPreference(transportPreference);
  }
  /**
   * Fetch account list from a trezor device.
   *
   * @returns [] accounts
   */


  async connectHardware(deviceName, page, hdPath) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    let accounts = [];

    switch (page) {
      case -1:
        accounts = await keyring.getPreviousPage();
        break;

      case 1:
        accounts = await keyring.getNextPage();
        break;

      default:
        accounts = await keyring.getFirstPage();
    } // Merge with existing accounts
    // and make sure addresses are not repeated


    const oldAccounts = await this.keyringController.getAccounts();
    const accountsToTrack = [...new Set(oldAccounts.concat(accounts.map(a => a.address.toLowerCase())))];
    this.accountTracker.syncWithAddresses(accountsToTrack);
    return accounts;
  }
  /**
   * Check if the device is unlocked
   *
   * @returns {Promise<boolean>}
   */


  async checkHardwareStatus(deviceName, hdPath) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    return keyring.isUnlocked();
  }
  /**
   * Clear
   *
   * @returns {Promise<boolean>}
   */


  async forgetDevice(deviceName) {
    const keyring = await this.getKeyringForDevice(deviceName);
    keyring.forgetDevice();
    return true;
  }
  /**
   * get hardware account label
   *
   * @return string label
   * */


  getAccountLabel(name, index, hdPathDescription) {
    return `${name[0].toUpperCase()}${name.slice(1)} ${parseInt(index, 10) + 1} ${hdPathDescription || ''}`.trim();
  }
  /**
   * Imports an account from a Trezor or Ledger device.
   *
   * @returns {} keyState
   */


  async unlockHardwareWalletAccount(index, deviceName, hdPath, hdPathDescription) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    keyring.setAccountToUnlock(index);
    const oldAccounts = await this.keyringController.getAccounts();
    const keyState = await this.keyringController.addNewAccount(keyring);
    const newAccounts = await this.keyringController.getAccounts();
    this.preferencesController.setAddresses(newAccounts);
    newAccounts.forEach(address => {
      if (!oldAccounts.includes(address)) {
        const label = this.getAccountLabel(deviceName === _hardwareWallets.DEVICE_NAMES.QR ? keyring.getName() : deviceName, index, hdPathDescription); // Set the account label to Trezor 1 /  Ledger 1 / QR Hardware 1, etc

        this.preferencesController.setAccountLabel(address, label); // Select the account

        this.preferencesController.setSelectedAddress(address);
      }
    });
    const {
      identities
    } = this.preferencesController.store.getState();
    return _objectSpread(_objectSpread({}, keyState), {}, {
      identities
    });
  } //
  // Account Management
  //

  /**
   * Adds a new account to the default (first) HD seed phrase Keyring.
   *
   * @returns {} keyState
   */


  async addNewAccount() {
    const primaryKeyring = this.keyringController.getKeyringsByType('HD Key Tree')[0];

    if (!primaryKeyring) {
      throw new Error('MetamaskController - No HD Key Tree found');
    }

    const {
      keyringController
    } = this;
    const oldAccounts = await keyringController.getAccounts();
    const keyState = await keyringController.addNewAccount(primaryKeyring);
    const newAccounts = await keyringController.getAccounts();
    await this.verifySeedPhrase();
    this.preferencesController.setAddresses(newAccounts);
    newAccounts.forEach(address => {
      if (!oldAccounts.includes(address)) {
        this.preferencesController.setSelectedAddress(address);
      }
    });
    const {
      identities
    } = this.preferencesController.store.getState();
    return _objectSpread(_objectSpread({}, keyState), {}, {
      identities
    });
  }
  /**
   * Verifies the validity of the current vault's seed phrase.
   *
   * Validity: seed phrase restores the accounts belonging to the current vault.
   *
   * Called when the first account is created and on unlocking the vault.
   *
   * @returns {Promise<string>} Seed phrase to be confirmed by the user.
   */


  async verifySeedPhrase() {
    const primaryKeyring = this.keyringController.getKeyringsByType('HD Key Tree')[0];

    if (!primaryKeyring) {
      throw new Error('MetamaskController - No HD Key Tree found');
    }

    const serialized = await primaryKeyring.serialize();
    const seedWords = serialized.mnemonic;
    const accounts = await primaryKeyring.getAccounts();

    if (accounts.length < 1) {
      throw new Error('MetamaskController - No accounts found');
    }

    try {
      await _seedPhraseVerifier.default.verifyAccounts(accounts, seedWords);
      return seedWords;
    } catch (err) {
      _loglevel.default.error(err.message);

      throw err;
    }
  }
  /**
   * Clears the transaction history, to allow users to force-reset their nonces.
   * Mostly used in development environments, when networks are restarted with
   * the same network ID.
   *
   * @returns {Promise<string>} The current selected address.
   */


  async resetAccount() {
    const selectedAddress = this.preferencesController.getSelectedAddress();
    this.txController.wipeTransactions(selectedAddress);
    this.networkController.resetConnection();
    return selectedAddress;
  }
  /**
   * Gets the permitted accounts for the specified origin. Returns an empty
   * array if no accounts are permitted.
   *
   * @param {string} origin - The origin whose exposed accounts to retrieve.
   * @returns {Promise<string[]>} The origin's permitted accounts, or an empty
   * array.
   */


  async getPermittedAccounts(origin) {
    try {
      return await this.permissionController.executeRestrictedMethod(origin, _permissions.RestrictedMethods.eth_accounts);
    } catch (error) {
      if (error.code === _ethRpcErrors.errorCodes.provider.unauthorized) {
        return [];
      }

      throw error;
    }
  }
  /**
   * Stops exposing the account with the specified address to all third parties.
   * Exposed accounts are stored in caveats of the eth_accounts permission. This
   * method uses `PermissionController.updatePermissionsByCaveat` to
   * remove the specified address from every eth_accounts permission. If a
   * permission only included this address, the permission is revoked entirely.
   *
   * @param {string} targetAccount - The address of the account to stop exposing
   * to third parties.
   */


  removeAllAccountPermissions(targetAccount) {
    this.permissionController.updatePermissionsByCaveat(_permissions.CaveatTypes.restrictReturnedAccounts, existingAccounts => _permissions2.CaveatMutatorFactories[_permissions.CaveatTypes.restrictReturnedAccounts].removeAccount(targetAccount, existingAccounts));
  }
  /**
   * Removes an account from state / storage.
   *
   * @param {string[]} address - A hex address
   *
   */


  async removeAccount(address) {
    // Remove all associated permissions
    this.removeAllAccountPermissions(address); // Remove account from the preferences controller

    this.preferencesController.removeAddress(address); // Remove account from the account tracker controller

    this.accountTracker.removeAccount([address]); // Remove account from the keyring

    await this.keyringController.removeAccount(address);
    return address;
  }
  /**
   * Imports an account with the specified import strategy.
   * These are defined in app/scripts/account-import-strategies
   * Each strategy represents a different way of serializing an Ethereum key pair.
   *
   * @param {string} strategy - A unique identifier for an account import strategy.
   * @param {any} args - The data required by that strategy to import an account.
   * @param {Function} cb - A callback function called with a state update on success.
   */


  async importAccountWithStrategy(strategy, args) {
    const privateKey = await _accountImportStrategies.default.importAccount(strategy, args);
    const keyring = await this.keyringController.addNewKeyring('Simple Key Pair', [privateKey]);
    const accounts = await keyring.getAccounts(); // update accounts in preferences controller

    const allAccounts = await this.keyringController.getAccounts();
    this.preferencesController.setAddresses(allAccounts); // set new account as selected

    await this.preferencesController.setSelectedAddress(accounts[0]);
  } // ---------------------------------------------------------------------------
  // Identity Management (signature operations)

  /**
   * Called when a Dapp suggests a new tx to be signed.
   * this wrapper needs to exist so we can provide a reference to
   *  "newUnapprovedTransaction" before "txController" is instantiated
   *
   * @param {Object} msgParams - The params passed to eth_sign.
   * @param {Object} req - (optional) the original request, containing the origin
   */


  async newUnapprovedTransaction(txParams, req) {
    return await this.txController.newUnapprovedTransaction(txParams, req);
  } // eth_sign methods:

  /**
   * Called when a Dapp uses the eth_sign method, to request user approval.
   * eth_sign is a pure signature of arbitrary data. It is on a deprecation
   * path, since this data can be a transaction, or can leak private key
   * information.
   *
   * @param {Object} msgParams - The params passed to eth_sign.
   * @param {Function} cb - The callback function called with the signature.
   */


  async newUnsignedMessage(msgParams, req) {
    const data = (0, _messageManager.normalizeMsgData)(msgParams.data);
    let promise; // 64 hex + "0x" at the beginning
    // This is needed because Ethereum's EcSign works only on 32 byte numbers
    // For 67 length see: https://github.com/MetaMask/metamask-extension/pull/12679/files#r749479607

    if (data.length === 66 || data.length === 67) {
      promise = this.messageManager.addUnapprovedMessageAsync(msgParams, req);
      this.sendUpdate();
      this.opts.showUserConfirmation();
    } else {
      throw _ethRpcErrors.ethErrors.rpc.invalidParams('eth_sign requires 32 byte message hash');
    }

    return await promise;
  }
  /**
   * Signifies user intent to complete an eth_sign method.
   *
   * @param {Object} msgParams - The params passed to eth_call.
   * @returns {Promise<Object>} Full state update.
   */


  async signMessage(msgParams) {
    _loglevel.default.info('MetaMaskController - signMessage');

    const msgId = msgParams.metamaskId;

    try {
      // sets the status op the message to 'approved'
      // and removes the metamaskId for signing
      const cleanMsgParams = await this.messageManager.approveMessage(msgParams);
      const rawSig = await this.keyringController.signMessage(cleanMsgParams);
      this.messageManager.setMsgStatusSigned(msgId, rawSig);
      return this.getState();
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_sign failed', error);

      this.messageManager.errorMessage(msgId, error);
      throw error;
    }
  }
  /**
   * Used to cancel a message submitted via eth_sign.
   *
   * @param {string} msgId - The id of the message to cancel.
   */


  cancelMessage(msgId) {
    const {
      messageManager
    } = this;
    messageManager.rejectMsg(msgId);
    return this.getState();
  } // personal_sign methods:

  /**
   * Called when a dapp uses the personal_sign method.
   * This is identical to the Geth eth_sign method, and may eventually replace
   * eth_sign.
   *
   * We currently define our eth_sign and personal_sign mostly for legacy Dapps.
   *
   * @param {Object} msgParams - The params of the message to sign & return to the Dapp.
   * @param {Function} cb - The callback function called with the signature.
   * Passed back to the requesting Dapp.
   */


  async newUnsignedPersonalMessage(msgParams, req) {
    const promise = this.personalMessageManager.addUnapprovedMessageAsync(msgParams, req);
    this.sendUpdate();
    this.opts.showUserConfirmation();
    return promise;
  }
  /**
   * Signifies a user's approval to sign a personal_sign message in queue.
   * Triggers signing, and the callback function from newUnsignedPersonalMessage.
   *
   * @param {Object} msgParams - The params of the message to sign & return to the Dapp.
   * @returns {Promise<Object>} A full state update.
   */


  async signPersonalMessage(msgParams) {
    _loglevel.default.info('MetaMaskController - signPersonalMessage');

    const msgId = msgParams.metamaskId; // sets the status op the message to 'approved'
    // and removes the metamaskId for signing

    try {
      const cleanMsgParams = await this.personalMessageManager.approveMessage(msgParams);
      const rawSig = await this.keyringController.signPersonalMessage(cleanMsgParams); // tells the listener that the message has been signed
      // and can be returned to the dapp

      this.personalMessageManager.setMsgStatusSigned(msgId, rawSig);
      return this.getState();
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_personalSign failed', error);

      this.personalMessageManager.errorMessage(msgId, error);
      throw error;
    }
  }
  /**
   * Used to cancel a personal_sign type message.
   * @param {string} msgId - The ID of the message to cancel.
   */


  cancelPersonalMessage(msgId) {
    const messageManager = this.personalMessageManager;
    messageManager.rejectMsg(msgId);
    return this.getState();
  } // eth_decrypt methods

  /**
   * Called when a dapp uses the eth_decrypt method.
   *
   * @param {Object} msgParams - The params of the message to sign & return to the Dapp.
   * @param {Object} req - (optional) the original request, containing the origin
   * Passed back to the requesting Dapp.
   */


  async newRequestDecryptMessage(msgParams, req) {
    const promise = this.decryptMessageManager.addUnapprovedMessageAsync(msgParams, req);
    this.sendUpdate();
    this.opts.showUserConfirmation();
    return promise;
  }
  /**
   * Only decrypt message and don't touch transaction state
   *
   * @param {Object} msgParams - The params of the message to decrypt.
   * @returns {Promise<Object>} A full state update.
   */


  async decryptMessageInline(msgParams) {
    _loglevel.default.info('MetaMaskController - decryptMessageInline'); // decrypt the message inline


    const msgId = msgParams.metamaskId;
    const msg = this.decryptMessageManager.getMsg(msgId);

    try {
      const stripped = (0, _ethereumjsUtil.stripHexPrefix)(msgParams.data);
      const buff = Buffer.from(stripped, 'hex');
      msgParams.data = JSON.parse(buff.toString('utf8'));
      msg.rawData = await this.keyringController.decryptMessage(msgParams);
    } catch (e) {
      msg.error = e.message;
    }

    this.decryptMessageManager._updateMsg(msg);

    return this.getState();
  }
  /**
   * Signifies a user's approval to decrypt a message in queue.
   * Triggers decrypt, and the callback function from newUnsignedDecryptMessage.
   *
   * @param {Object} msgParams - The params of the message to decrypt & return to the Dapp.
   * @returns {Promise<Object>} A full state update.
   */


  async decryptMessage(msgParams) {
    _loglevel.default.info('MetaMaskController - decryptMessage');

    const msgId = msgParams.metamaskId; // sets the status op the message to 'approved'
    // and removes the metamaskId for decryption

    try {
      const cleanMsgParams = await this.decryptMessageManager.approveMessage(msgParams);
      const stripped = (0, _ethereumjsUtil.stripHexPrefix)(cleanMsgParams.data);
      const buff = Buffer.from(stripped, 'hex');
      cleanMsgParams.data = JSON.parse(buff.toString('utf8')); // decrypt the message

      const rawMess = await this.keyringController.decryptMessage(cleanMsgParams); // tells the listener that the message has been decrypted and can be returned to the dapp

      this.decryptMessageManager.setMsgStatusDecrypted(msgId, rawMess);
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_decrypt failed.', error);

      this.decryptMessageManager.errorMessage(msgId, error);
    }

    return this.getState();
  }
  /**
   * Used to cancel a eth_decrypt type message.
   * @param {string} msgId - The ID of the message to cancel.
   */


  cancelDecryptMessage(msgId) {
    const messageManager = this.decryptMessageManager;
    messageManager.rejectMsg(msgId);
    return this.getState();
  } // eth_getEncryptionPublicKey methods

  /**
   * Called when a dapp uses the eth_getEncryptionPublicKey method.
   *
   * @param {Object} msgParams - The params of the message to sign & return to the Dapp.
   * @param {Object} req - (optional) the original request, containing the origin
   * Passed back to the requesting Dapp.
   */


  async newRequestEncryptionPublicKey(msgParams, req) {
    const address = msgParams;
    const keyring = await this.keyringController.getKeyringForAccount(address);

    switch (keyring.type) {
      case _hardwareWallets.KEYRING_TYPES.LEDGER:
        {
          return new Promise((_, reject) => {
            reject(new Error('Ledger does not support eth_getEncryptionPublicKey.'));
          });
        }

      case _hardwareWallets.KEYRING_TYPES.TREZOR:
        {
          return new Promise((_, reject) => {
            reject(new Error('Trezor does not support eth_getEncryptionPublicKey.'));
          });
        }

      case _hardwareWallets.KEYRING_TYPES.LATTICE:
        {
          return new Promise((_, reject) => {
            reject(new Error('Lattice does not support eth_getEncryptionPublicKey.'));
          });
        }

      case _hardwareWallets.KEYRING_TYPES.QR:
        {
          return Promise.reject(new Error('QR hardware does not support eth_getEncryptionPublicKey.'));
        }

      default:
        {
          const promise = this.encryptionPublicKeyManager.addUnapprovedMessageAsync(msgParams, req);
          this.sendUpdate();
          this.opts.showUserConfirmation();
          return promise;
        }
    }
  }
  /**
   * Signifies a user's approval to receiving encryption public key in queue.
   * Triggers receiving, and the callback function from newUnsignedEncryptionPublicKey.
   *
   * @param {Object} msgParams - The params of the message to receive & return to the Dapp.
   * @returns {Promise<Object>} A full state update.
   */


  async encryptionPublicKey(msgParams) {
    _loglevel.default.info('MetaMaskController - encryptionPublicKey');

    const msgId = msgParams.metamaskId; // sets the status op the message to 'approved'
    // and removes the metamaskId for decryption

    try {
      const params = await this.encryptionPublicKeyManager.approveMessage(msgParams); // EncryptionPublicKey message

      const publicKey = await this.keyringController.getEncryptionPublicKey(params.data); // tells the listener that the message has been processed
      // and can be returned to the dapp

      this.encryptionPublicKeyManager.setMsgStatusReceived(msgId, publicKey);
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_getEncryptionPublicKey failed.', error);

      this.encryptionPublicKeyManager.errorMessage(msgId, error);
    }

    return this.getState();
  }
  /**
   * Used to cancel a eth_getEncryptionPublicKey type message.
   * @param {string} msgId - The ID of the message to cancel.
   */


  cancelEncryptionPublicKey(msgId) {
    const messageManager = this.encryptionPublicKeyManager;
    messageManager.rejectMsg(msgId);
    return this.getState();
  } // eth_signTypedData methods

  /**
   * Called when a dapp uses the eth_signTypedData method, per EIP 712.
   *
   * @param {Object} msgParams - The params passed to eth_signTypedData.
   * @param {Function} cb - The callback function, called with the signature.
   */


  newUnsignedTypedMessage(msgParams, req, version) {
    const promise = this.typedMessageManager.addUnapprovedMessageAsync(msgParams, req, version);
    this.sendUpdate();
    this.opts.showUserConfirmation();
    return promise;
  }
  /**
   * The method for a user approving a call to eth_signTypedData, per EIP 712.
   * Triggers the callback in newUnsignedTypedMessage.
   *
   * @param {Object} msgParams - The params passed to eth_signTypedData.
   * @returns {Object} Full state update.
   */


  async signTypedMessage(msgParams) {
    _loglevel.default.info('MetaMaskController - eth_signTypedData');

    const msgId = msgParams.metamaskId;
    const {
      version
    } = msgParams;

    try {
      const cleanMsgParams = await this.typedMessageManager.approveMessage(msgParams); // For some reason every version after V1 used stringified params.

      if (version !== 'V1') {
        // But we don't have to require that. We can stop suggesting it now:
        if (typeof cleanMsgParams.data === 'string') {
          cleanMsgParams.data = JSON.parse(cleanMsgParams.data);
        }
      }

      const signature = await this.keyringController.signTypedMessage(cleanMsgParams, {
        version
      });
      this.typedMessageManager.setMsgStatusSigned(msgId, signature);
      return this.getState();
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_signTypedData failed.', error);

      this.typedMessageManager.errorMessage(msgId, error);
      throw error;
    }
  }
  /**
   * Used to cancel a eth_signTypedData type message.
   * @param {string} msgId - The ID of the message to cancel.
   */


  cancelTypedMessage(msgId) {
    const messageManager = this.typedMessageManager;
    messageManager.rejectMsg(msgId);
    return this.getState();
  }
  /**
   * @returns {boolean} true if the keyring type supports EIP-1559
   */


  async getCurrentAccountEIP1559Compatibility() {
    return true;
  } //=============================================================================
  // END (VAULT / KEYRING RELATED METHODS)
  //=============================================================================

  /**
   * Allows a user to attempt to cancel a previously submitted transaction
   * by creating a new transaction.
   * @param {number} originalTxId - the id of the txMeta that you want to
   *  attempt to cancel
   * @param {__import__(
   *  './controllers/transactions'
   * ).CustomGasSettings} [customGasSettings] - overrides to use for gas params
   *  instead of allowing this method to generate them
   * @returns {Object} MetaMask state
   */


  async createCancelTransaction(originalTxId, customGasSettings, newTxMetaProps) {
    await this.txController.createCancelTransaction(originalTxId, customGasSettings, newTxMetaProps);
    const state = await this.getState();
    return state;
  }
  /**
   * Allows a user to attempt to speed up a previously submitted transaction
   * by creating a new transaction.
   * @param {number} originalTxId - the id of the txMeta that you want to
   *  attempt to speed up
   * @param {__import__(
   *  './controllers/transactions'
   * ).CustomGasSettings} [customGasSettings] - overrides to use for gas params
   *  instead of allowing this method to generate them
   * @returns {Object} MetaMask state
   */


  async createSpeedUpTransaction(originalTxId, customGasSettings, newTxMetaProps) {
    await this.txController.createSpeedUpTransaction(originalTxId, customGasSettings, newTxMetaProps);
    const state = await this.getState();
    return state;
  }

  estimateGas(estimateGasParams) {
    return new Promise((resolve, reject) => {
      return this.txController.txGasUtil.query.estimateGas(estimateGasParams, (err, res) => {
        if (err) {
          return reject(err);
        }

        return resolve(res.toString(16));
      });
    });
  } //=============================================================================
  // PASSWORD MANAGEMENT
  //=============================================================================

  /**
   * Allows a user to begin the seed phrase recovery process.
   * @param {Function} cb - A callback function called when complete.
   */


  markPasswordForgotten() {
    this.preferencesController.setPasswordForgotten(true);
    this.sendUpdate();
  }
  /**
   * Allows a user to end the seed phrase recovery process.
   * @param {Function} cb - A callback function called when complete.
   */


  unMarkPasswordForgotten() {
    this.preferencesController.setPasswordForgotten(false);
    this.sendUpdate();
  } //=============================================================================
  // SETUP
  //=============================================================================

  /**
   * A runtime.MessageSender object, as provided by the browser:
   * @see https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/MessageSender
   * @typedef {Object} MessageSender
   */

  /**
   * Used to create a multiplexed stream for connecting to an untrusted context
   * like a Dapp or other extension.
   * @param {*} connectionStream - The Duplex stream to connect to.
   * @param {MessageSender} sender - The sender of the messages on this stream
   */


  setupUntrustedCommunication(connectionStream, sender) {
    const {
      usePhishDetect
    } = this.preferencesController.store.getState();
    const {
      hostname
    } = new URL(sender.url); // Check if new connection is blocked if phishing detection is on

    if (usePhishDetect && this.phishingController.test(hostname)) {
      _loglevel.default.debug('MetaMask - sending phishing warning for', hostname);

      this.sendPhishingWarning(connectionStream, hostname);
      return;
    } // setup multiplexing


    const mux = (0, _streamUtils.setupMultiplex)(connectionStream); // messages between inpage and background

    this.setupProviderConnection(mux.createStream('metamask-provider'), sender); // TODO:LegacyProvider: Delete
    // legacy streams

    this.setupPublicConfig(mux.createStream('publicConfig'));
  }
  /**
   * Used to create a multiplexed stream for connecting to a trusted context,
   * like our own user interfaces, which have the provider APIs, but also
   * receive the exported API from this controller, which includes trusted
   * functions, like the ability to approve transactions or sign messages.
   *
   * @param {*} connectionStream - The duplex stream to connect to.
   * @param {MessageSender} sender - The sender of the messages on this stream
   */


  setupTrustedCommunication(connectionStream, sender) {
    // setup multiplexing
    const mux = (0, _streamUtils.setupMultiplex)(connectionStream); // connect features

    this.setupControllerConnection(mux.createStream('controller'));
    this.setupProviderConnection(mux.createStream('provider'), sender, true);
  }
  /**
   * Called when we detect a suspicious domain. Requests the browser redirects
   * to our anti-phishing page.
   *
   * @private
   * @param {*} connectionStream - The duplex stream to the per-page script,
   * for sending the reload attempt to.
   * @param {string} hostname - The hostname that triggered the suspicion.
   */


  sendPhishingWarning(connectionStream, hostname) {
    const mux = (0, _streamUtils.setupMultiplex)(connectionStream);
    const phishingStream = mux.createStream('phishing');
    phishingStream.write({
      hostname
    });
  }
  /**
   * A method for providing our API over a stream using JSON-RPC.
   * @param {*} outStream - The stream to provide our API over.
   */


  setupControllerConnection(outStream) {
    const api = this.getApi(); // report new active controller connection

    this.activeControllerConnections += 1;
    this.emit('controllerConnectionChanged', this.activeControllerConnections); // set up postStream transport

    outStream.on('data', (0, _createMetaRPCHandler.default)(api, outStream));

    const handleUpdate = update => {
      if (outStream._writableState.ended) {
        return;
      } // send notification to client-side


      outStream.write({
        jsonrpc: '2.0',
        method: 'sendUpdate',
        params: [update]
      });
    };

    this.on('update', handleUpdate);
    outStream.on('end', () => {
      this.activeControllerConnections -= 1;
      this.emit('controllerConnectionChanged', this.activeControllerConnections);
      this.removeListener('update', handleUpdate);
    });
  }
  /**
   * A method for serving our ethereum provider over a given stream.
   * @param {*} outStream - The stream to provide over.
   * @param {MessageSender} sender - The sender of the messages on this stream
   * @param {boolean} isInternal - True if this is a connection with an internal process
   */


  setupProviderConnection(outStream, sender, isInternal) {
    const origin = isInternal ? 'metamask' : new URL(sender.url).origin;
    let subjectType = isInternal ? _app.SUBJECT_TYPES.INTERNAL : _app.SUBJECT_TYPES.WEBSITE;

    if (sender.id !== this.extension.runtime.id) {
      subjectType = _app.SUBJECT_TYPES.EXTENSION;
      this.subjectMetadataController.addSubjectMetadata(origin, {
        extensionId: sender.id,
        subjectType: _app.SUBJECT_TYPES.EXTENSION
      });
    }

    let tabId;

    if (sender.tab && sender.tab.id) {
      tabId = sender.tab.id;
    }

    const engine = this.setupProviderEngine({
      origin,
      location: sender.url,
      tabId,
      subjectType
    }); // setup connection

    const providerStream = (0, _engineStream.default)({
      engine
    });
    const connectionId = this.addConnection(origin, {
      engine
    });
    (0, _pump.default)(outStream, providerStream, outStream, err => {
      // handle any middleware cleanup
      engine._middleware.forEach(mid => {
        if (mid.destroy && typeof mid.destroy === 'function') {
          mid.destroy();
        }
      });

      connectionId && this.removeConnection(origin, connectionId);

      if (err) {
        _loglevel.default.error(err);
      }
    });
  }
  /**
   * A method for creating a provider that is safely restricted for the requesting subject.
   *
   * @param {Object} options - Provider engine options
   * @param {string} options.origin - The origin of the sender
   * @param {string} options.location - The full URL of the sender
   * @param {string} options.subjectType - The type of the sender subject.
   * @param {tabId} [options.tabId] - The tab ID of the sender - if the sender is within a tab
   **/


  setupProviderEngine({
    origin,
    location,
    subjectType,
    tabId
  }) {
    // setup json rpc engine stack
    const engine = new _jsonRpcEngine.JsonRpcEngine();
    const {
      provider,
      blockTracker
    } = this; // create filter polyfill middleware

    const filterMiddleware = (0, _ethJsonRpcFilters.default)({
      provider,
      blockTracker
    }); // create subscription polyfill middleware

    const subscriptionManager = (0, _subscriptionManager.default)({
      provider,
      blockTracker
    });
    subscriptionManager.events.on('notification', message => engine.emit('notification', message)); // append origin to each request

    engine.push((0, _createOriginMiddleware.default)({
      origin
    })); // append tabId to each request if it exists

    if (tabId) {
      engine.push((0, _createTabIdMiddleware.default)({
        tabId
      }));
    } // logging


    engine.push((0, _createLoggerMiddleware.default)({
      origin
    }));
    engine.push((0, _createOnboardingMiddleware.default)({
      location,
      registerOnboarding: this.onboardingController.registerOnboarding
    }));
    engine.push(this.permissionLogController.createMiddleware());
    engine.push((0, _rpcMethodMiddleware.default)({
      origin,
      subjectType,
      // Miscellaneous
      addSubjectMetadata: this.subjectMetadataController.addSubjectMetadata.bind(this.subjectMetadataController),
      getProviderState: this.getProviderState.bind(this),
      getUnlockPromise: this.appStateController.getUnlockPromise.bind(this.appStateController),
      handleWatchAssetRequest: this.tokensController.watchAsset.bind(this.tokensController),
      requestUserApproval: this.approvalController.addAndShowApprovalRequest.bind(this.approvalController),
      sendMetrics: this.metaMetricsController.trackEvent.bind(this.metaMetricsController),
      // Permission-related
      getAccounts: this.getPermittedAccounts.bind(this, origin),
      getPermissionsForOrigin: this.permissionController.getPermissions.bind(this.permissionController, origin),
      hasPermission: this.permissionController.hasPermission.bind(this.permissionController, origin),
      requestAccountsPermission: this.permissionController.requestPermissions.bind(this.permissionController, {
        origin
      }, {
        eth_accounts: {}
      }),
      // Custom RPC-related
      addCustomRpc: async ({
        chainId,
        blockExplorerUrl,
        ticker,
        chainName,
        rpcUrl
      } = {}) => {
        await this.preferencesController.addToFrequentRpcList(rpcUrl, chainId, ticker, chainName, {
          blockExplorerUrl
        });
      },
      findCustomRpcBy: this.findCustomRpcBy.bind(this),
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      setProviderType: this.networkController.setProviderType.bind(this.networkController),
      updateRpcTarget: ({
        rpcUrl,
        chainId,
        ticker,
        nickname
      }) => {
        this.networkController.setRpcTarget(rpcUrl, chainId, ticker, nickname);
      },
      // Web3 shim-related
      getWeb3ShimUsageState: this.alertController.getWeb3ShimUsageState.bind(this.alertController),
      setWeb3ShimUsageRecorded: this.alertController.setWeb3ShimUsageRecorded.bind(this.alertController)
    })); // filter and subscription polyfills

    engine.push(filterMiddleware);
    engine.push(subscriptionManager.middleware);

    if (subjectType !== _app.SUBJECT_TYPES.INTERNAL) {
      // permissions
      engine.push(this.permissionController.createPermissionMiddleware({
        origin
      }));
    } // forward to metamask primary provider


    engine.push((0, _ethJsonRpcMiddleware.providerAsMiddleware)(provider));
    return engine;
  }
  /**
   * TODO:LegacyProvider: Delete
   * A method for providing our public config info over a stream.
   * This includes info we like to be synchronous if possible, like
   * the current selected account, and network ID.
   *
   * Since synchronous methods have been deprecated in web3,
   * this is a good candidate for deprecation.
   *
   * @param {*} outStream - The stream to provide public config over.
   */


  setupPublicConfig(outStream) {
    const configStream = (0, _asStream.storeAsStream)(this.publicConfigStore);
    (0, _pump.default)(configStream, outStream, err => {
      configStream.destroy();

      if (err) {
        _loglevel.default.error(err);
      }
    });
  }
  /**
   * Adds a reference to a connection by origin. Ignores the 'metamask' origin.
   * Caller must ensure that the returned id is stored such that the reference
   * can be deleted later.
   *
   * @param {string} origin - The connection's origin string.
   * @param {Object} options - Data associated with the connection
   * @param {Object} options.engine - The connection's JSON Rpc Engine
   * @returns {string} The connection's id (so that it can be deleted later)
   */


  addConnection(origin, {
    engine
  }) {
    if (origin === 'metamask') {
      return null;
    }

    if (!this.connections[origin]) {
      this.connections[origin] = {};
    }

    const id = (0, _nanoid.default)();
    this.connections[origin][id] = {
      engine
    };
    return id;
  }
  /**
   * Deletes a reference to a connection, by origin and id.
   * Ignores unknown origins.
   *
   * @param {string} origin - The connection's origin string.
   * @param {string} id - The connection's id, as returned from addConnection.
   */


  removeConnection(origin, id) {
    const connections = this.connections[origin];

    if (!connections) {
      return;
    }

    delete connections[id];

    if (Object.keys(connections).length === 0) {
      delete this.connections[origin];
    }
  }
  /**
   * Causes the RPC engines associated with the connections to the given origin
   * to emit a notification event with the given payload.
   *
   * The caller is responsible for ensuring that only permitted notifications
   * are sent.
   *
   * Ignores unknown origins.
   *
   * @param {string} origin - The connection's origin string.
   * @param {unknown} payload - The event payload.
   */


  notifyConnections(origin, payload) {
    const connections = this.connections[origin];

    if (connections) {
      Object.values(connections).forEach(conn => {
        if (conn.engine) {
          conn.engine.emit('notification', payload);
        }
      });
    }
  }
  /**
   * Causes the RPC engines associated with all connections to emit a
   * notification event with the given payload.
   *
   * If the "payload" parameter is a function, the payload for each connection
   * will be the return value of that function called with the connection's
   * origin.
   *
   * The caller is responsible for ensuring that only permitted notifications
   * are sent.
   *
   * @param {unknown} payload - The event payload, or payload getter function.
   */


  notifyAllConnections(payload) {
    const getPayload = typeof payload === 'function' ? origin => payload(origin) : () => payload;
    Object.keys(this.connections).forEach(origin => {
      Object.values(this.connections[origin]).forEach(async conn => {
        if (conn.engine) {
          conn.engine.emit('notification', await getPayload(origin));
        }
      });
    });
  } // handlers

  /**
   * Handle a KeyringController update
   * @param {Object} state - the KC state
   * @returns {Promise<void>}
   * @private
   */


  async _onKeyringControllerUpdate(state) {
    const {
      keyrings
    } = state;
    const addresses = keyrings.reduce((acc, {
      accounts
    }) => acc.concat(accounts), []);

    if (!addresses.length) {
      return;
    } // Ensure preferences + identities controller know about all addresses


    this.preferencesController.syncAddresses(addresses);
    this.accountTracker.syncWithAddresses(addresses);
  }
  /**
   * Handle global application unlock.
   * Notifies all connections that the extension is unlocked, and which
   * account(s) are currently accessible, if any.
   */


  _onUnlock() {
    this.notifyAllConnections(async origin => {
      return {
        method: _permissions2.NOTIFICATION_NAMES.unlockStateChanged,
        params: {
          isUnlocked: true,
          accounts: await this.getPermittedAccounts(origin)
        }
      };
    }); // In the current implementation, this handler is triggered by a
    // KeyringController event. Other controllers subscribe to the 'unlock'
    // event of the MetaMaskController itself.

    this.emit('unlock');
  }
  /**
   * Handle global application lock.
   * Notifies all connections that the extension is locked.
   */


  _onLock() {
    this.notifyAllConnections({
      method: _permissions2.NOTIFICATION_NAMES.unlockStateChanged,
      params: {
        isUnlocked: false
      }
    }); // In the current implementation, this handler is triggered by a
    // KeyringController event. Other controllers subscribe to the 'lock'
    // event of the MetaMaskController itself.

    this.emit('lock');
  }
  /**
   * Handle memory state updates.
   * - Ensure isClientOpenAndUnlocked is updated
   * - Notifies all connections with the new provider network state
   *   - The external providers handle diffing the state
   */


  _onStateUpdate(newState) {
    this.isClientOpenAndUnlocked = newState.isUnlocked && this._isClientOpen;
    this.notifyAllConnections({
      method: _permissions2.NOTIFICATION_NAMES.chainChanged,
      params: this.getProviderNetworkState(newState)
    });
  } // misc

  /**
   * A method for emitting the full MetaMask state to all registered listeners.
   * @private
   */


  privateSendUpdate() {
    this.emit('update', this.getState());
  }
  /**
   * @returns {boolean} Whether the extension is unlocked.
   */


  isUnlocked() {
    return this.keyringController.memStore.getState().isUnlocked;
  } //=============================================================================
  // MISCELLANEOUS
  //=============================================================================

  /**
   * Returns the nonce that will be associated with a transaction once approved
   * @param {string} address - The hex string address for the transaction
   * @returns {Promise<number>}
   */


  async getPendingNonce(address) {
    const {
      nonceDetails,
      releaseLock
    } = await this.txController.nonceTracker.getNonceLock(address);
    const pendingNonce = nonceDetails.params.highestSuggested;
    releaseLock();
    return pendingNonce;
  }
  /**
   * Returns the next nonce according to the nonce-tracker
   * @param {string} address - The hex string address for the transaction
   * @returns {Promise<number>}
   */


  async getNextNonce(address) {
    const nonceLock = await this.txController.nonceTracker.getNonceLock(address);
    nonceLock.releaseLock();
    return nonceLock.nextNonce;
  }
  /**
   * Migrate address book state from old to new chainId.
   *
   * Address book state is keyed by the `networkStore` state from the network controller. This value is set to the
   * `networkId` for our built-in Infura networks, but it's set to the `chainId` for custom networks.
   * When this `chainId` value is changed for custom RPC endpoints, we need to migrate any contacts stored under the
   * old key to the new key.
   *
   * The `duplicate` parameter is used to specify that the contacts under the old key should not be removed. This is
   * useful in the case where two RPC endpoints shared the same set of contacts, and we're not sure which one each
   * contact belongs under. Duplicating the contacts under both keys is the only way to ensure they are not lost.
   *
   * @param {string} oldChainId - The old chainId
   * @param {string} newChainId - The new chainId
   * @param {boolean} [duplicate] - Whether to duplicate the addresses on both chainIds (default: false)
   */


  async migrateAddressBookState(oldChainId, newChainId, duplicate = false) {
    const {
      addressBook
    } = this.addressBookController.state;

    if (!addressBook[oldChainId]) {
      return;
    }

    for (const address of Object.keys(addressBook[oldChainId])) {
      const entry = addressBook[oldChainId][address];
      this.addressBookController.set(address, entry.name, newChainId, entry.memo);

      if (!duplicate) {
        this.addressBookController.delete(oldChainId, address);
      }
    }
  } //=============================================================================
  // CONFIG
  //=============================================================================
  // Log blocks

  /**
   * A method for selecting a custom URL for an ethereum RPC provider and updating it
   * @param {string} rpcUrl - A URL for a valid Ethereum RPC API.
   * @param {string} chainId - The chainId of the selected network.
   * @param {string} ticker - The ticker symbol of the selected network.
   * @param {string} [nickname] - Nickname of the selected network.
   * @param {Object} [rpcPrefs] - RPC preferences.
   * @param {string} [rpcPrefs.blockExplorerUrl] - URL of block explorer for the chain.
   * @returns {Promise<String>} - The RPC Target URL confirmed.
   */


  async updateAndSetCustomRpc(rpcUrl, chainId, ticker = 'ETH', nickname, rpcPrefs) {
    this.networkController.setRpcTarget(rpcUrl, chainId, ticker, nickname, rpcPrefs);
    await this.preferencesController.updateRpc({
      rpcUrl,
      chainId,
      ticker,
      nickname,
      rpcPrefs
    });
    return rpcUrl;
  }
  /**
   * A method for selecting a custom URL for an ethereum RPC provider.
   * @param {string} rpcUrl - A URL for a valid Ethereum RPC API.
   * @param {string} chainId - The chainId of the selected network.
   * @param {string} ticker - The ticker symbol of the selected network.
   * @param {string} nickname - Optional nickname of the selected network.
   * @returns {Promise<String>} The RPC Target URL confirmed.
   */


  async setCustomRpc(rpcUrl, chainId, ticker = 'ETH', nickname = '', rpcPrefs = {}) {
    const frequentRpcListDetail = this.preferencesController.getFrequentRpcListDetail();
    const rpcSettings = frequentRpcListDetail.find(rpc => rpcUrl === rpc.rpcUrl);

    if (rpcSettings) {
      this.networkController.setRpcTarget(rpcSettings.rpcUrl, rpcSettings.chainId, rpcSettings.ticker, rpcSettings.nickname, rpcPrefs);
    } else {
      this.networkController.setRpcTarget(rpcUrl, chainId, ticker, nickname, rpcPrefs);
      await this.preferencesController.addToFrequentRpcList(rpcUrl, chainId, ticker, nickname, rpcPrefs);
    }

    return rpcUrl;
  }
  /**
   * A method for deleting a selected custom URL.
   * @param {string} rpcUrl - A RPC URL to delete.
   */


  async delCustomRpc(rpcUrl) {
    await this.preferencesController.removeFromFrequentRpcList(rpcUrl);
  }
  /**
   * Returns the first RPC info object that matches at least one field of the
   * provided search criteria. Returns null if no match is found
   *
   * @param {Object} rpcInfo - The RPC endpoint properties and values to check.
   * @returns {Object} rpcInfo found in the frequentRpcList
   */


  findCustomRpcBy(rpcInfo) {
    const frequentRpcListDetail = this.preferencesController.getFrequentRpcListDetail();

    for (const existingRpcInfo of frequentRpcListDetail) {
      for (const key of Object.keys(rpcInfo)) {
        if (existingRpcInfo[key] === rpcInfo[key]) {
          return existingRpcInfo;
        }
      }
    }

    return null;
  }

  async initializeThreeBox() {
    await this.threeBoxController.init();
  }
  /**
   * Sets the Ledger Live preference to use for Ledger hardware wallet support
   * @param {bool} bool - the value representing if the users wants to use Ledger Live
   */


  async setLedgerTransportPreference(transportType) {
    const currentValue = this.preferencesController.getLedgerTransportPreference();
    const newValue = this.preferencesController.setLedgerTransportPreference(transportType);
    const keyring = await this.getKeyringForDevice('ledger');

    if (keyring !== null && keyring !== void 0 && keyring.updateTransportMethod) {
      return keyring.updateTransportMethod(newValue).catch(e => {
        // If there was an error updating the transport, we should
        // fall back to the original value
        this.preferencesController.setLedgerTransportPreference(currentValue);
        throw e;
      });
    }

    return undefined;
  }
  /**
   * A method for initializing storage the first time.
   * @param {Object} initState - The default state to initialize with.
   * @private
   */


  recordFirstTimeInfo(initState) {
    if (!('firstTimeInfo' in initState)) {
      const version = this.platform.getVersion();
      initState.firstTimeInfo = {
        version,
        date: Date.now()
      };
    }
  } // TODO: Replace isClientOpen methods with `controllerConnectionChanged` events.

  /* eslint-disable accessor-pairs */

  /**
   * A method for recording whether the MetaMask user interface is open or not.
   * @param {boolean} open
   */


  set isClientOpen(open) {
    this._isClientOpen = open;
    this.detectTokensController.isOpen = open;
  }
  /* eslint-enable accessor-pairs */

  /**
   * A method that is called by the background when all instances of metamask are closed.
   * Currently used to stop polling in the gasFeeController.
   */


  onClientClosed() {
    try {
      this.gasFeeController.stopPolling();
      this.appStateController.clearPollingTokens();
    } catch (error) {
      console.error(error);
    }
  }
  /**
   * A method that is called by the background when a particular environment type is closed (fullscreen, popup, notification).
   * Currently used to stop polling in the gasFeeController for only that environement type
   */


  onEnvironmentTypeClosed(environmentType) {
    const appStatePollingTokenType = _app.POLLING_TOKEN_ENVIRONMENT_TYPES[environmentType];
    const pollingTokensToDisconnect = this.appStateController.store.getState()[appStatePollingTokenType];
    pollingTokensToDisconnect.forEach(pollingToken => {
      this.gasFeeController.disconnectPoller(pollingToken);
      this.appStateController.removePollingToken(pollingToken, appStatePollingTokenType);
    });
  }
  /**
   * Adds a domain to the PhishingController safelist
   * @param {string} hostname - the domain to safelist
   */


  safelistPhishingDomain(hostname) {
    return this.phishingController.bypass(hostname);
  }
  /**
   * Locks MetaMask
   */


  setLocked() {
    const [trezorKeyring] = this.keyringController.getKeyringsByType(_hardwareWallets.KEYRING_TYPES.TREZOR);

    if (trezorKeyring) {
      trezorKeyring.dispose();
    }

    return this.keyringController.setLocked();
  }

}

exports.default = MetamaskController;


}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/metamask-controller.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/debounce/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/debounce/index.js
      return function (require, module, exports) {
/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing. The function also has a property 'clear' 
 * that is a function which will clear the timer to prevent previously scheduled executions. 
 *
 * @source underscore.js
 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
 * @param {Function} function to wrap
 * @param {Number} timeout in ms (`100`)
 * @param {Boolean} whether to execute at the beginning (`false`)
 * @api public
 */

module.exports = function debounce(func, wait, immediate){
  var timeout, args, context, timestamp, result;
  if (null == wait) wait = 100;

  function later() {
    var last = Date.now() - timestamp;

    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  };

  var debounced = function(){
    context = this;
    args = arguments;
    timestamp = Date.now();
    var callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };

  debounced.clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  
  debounced.flush = function() {
    if (timeout) {
      result = func.apply(context, args);
      context = args = null;
      
      clearTimeout(timeout);
      timeout = null;
    }
  };

  return debounced;
};

      };
    };
  }
}, {package:"debounce",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debounce/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/through/index.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/through/index.js
      return function (require, module, exports) {
(function (process){(function (){
var Stream = require('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}


}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"through",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/through/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/duplexer/index.js", {"stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/duplexer/index.js
      return function (require, module, exports) {
var Stream = require("stream")
var writeMethods = ["write", "end", "destroy"]
var readMethods = ["resume", "pause"]
var readEvents = ["data", "close"]
var slice = Array.prototype.slice

module.exports = duplex

function forEach (arr, fn) {
    if (arr.forEach) {
        return arr.forEach(fn)
    }

    for (var i = 0; i < arr.length; i++) {
        fn(arr[i], i)
    }
}

function duplex(writer, reader) {
    var stream = new Stream()
    var ended = false

    forEach(writeMethods, proxyWriter)

    forEach(readMethods, proxyReader)

    forEach(readEvents, proxyStream)

    reader.on("end", handleEnd)

    writer.on("drain", function() {
      stream.emit("drain")
    })

    writer.on("error", reemit)
    reader.on("error", reemit)

    stream.writable = writer.writable
    stream.readable = reader.readable

    return stream

    function proxyWriter(methodName) {
        stream[methodName] = method

        function method() {
            return writer[methodName].apply(writer, arguments)
        }
    }

    function proxyReader(methodName) {
        stream[methodName] = method

        function method() {
            stream.emit(methodName)
            var func = reader[methodName]
            if (func) {
                return func.apply(reader, arguments)
            }
            reader.emit(methodName)
        }
    }

    function proxyStream(methodName) {
        reader.on(methodName, reemit)

        function reemit() {
            var args = slice.call(arguments)
            args.unshift(methodName)
            stream.emit.apply(stream, args)
        }
    }

    function handleEnd() {
        if (ended) {
            return
        }
        ended = true
        var args = slice.call(arguments)
        args.unshift("end")
        stream.emit.apply(stream, args)
    }

    function reemit(err) {
        stream.emit("error", err)
    }
}

      };
    };
  }
}, {package:"duplexer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/duplexer/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/asStream.js", {"stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/asStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeAsStream = void 0;
const stream_1 = require("stream");
class ObservableStoreStream extends stream_1.Duplex {
    constructor(obsStore) {
        super({
            // pass values, not serializations
            objectMode: true,
        });
        // dont buffer outgoing updates
        this.resume();
        // save handler so we can unsubscribe later
        this.handler = (state) => this.push(state);
        // subscribe to obsStore changes
        this.obsStore = obsStore;
        this.obsStore.subscribe(this.handler);
    }
    // emit current state on new destination
    pipe(dest, options) {
        const result = super.pipe(dest, options);
        dest.write(this.obsStore.getState());
        return result;
    }
    // write from incoming stream to state
    _write(chunk, _encoding, callback) {
        this.obsStore.putState(chunk);
        callback();
    }
    // noop - outgoing stream is asking us if we have data we arent giving it
    _read(_size) {
        return undefined;
    }
    // unsubscribe from event emitter
    _destroy(err, callback) {
        this.obsStore.unsubscribe(this.handler);
        super._destroy(err, callback);
    }
}
function storeAsStream(obsStore) {
    return new ObservableStoreStream(obsStore);
}
exports.storeAsStream = storeAsStream;
//# sourceMappingURL=asStream.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/asStream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/LocalStorageStore.js", {"./ObservableStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/LocalStorageStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalStorageStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class LocalStorageStore extends ObservableStore_1.ObservableStore {
    constructor(opts = {}) {
        if (!global.localStorage) {
            throw new Error('LocalStorageStore - can\'t find localStorage.');
        }
        super();
        if (!opts.storageKey) {
            throw new Error('LocalStorageStore - no storageKey specified.');
        }
        this._storageKey = opts.storageKey;
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        const serialized = global.localStorage.getItem(this._storageKey);
        return serialized ? JSON.parse(serialized) : undefined;
    }
    // write to persistence
    _putState(newState) {
        const serialized = JSON.stringify(newState);
        return global.localStorage.setItem(this._storageKey, serialized);
    }
}
exports.LocalStorageStore = LocalStorageStore;
//# sourceMappingURL=LocalStorageStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/LocalStorageStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/ComposedStore.js", {"./ObservableStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/ComposedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class ComposedStore extends ObservableStore_1.ObservableStore {
    constructor(children) {
        super();
        // set default state
        const state = this.getState();
        if (!state) {
            this.putState({});
        }
        // subscribe to children
        this._children = children || {};
        Object.keys(this._children).forEach((childKey) => {
            const child = this._children[childKey];
            this._addChild(childKey, child);
        });
    }
    _addChild(childKey, child) {
        const updateFromChild = (childValue) => {
            const state = this.getState();
            state[childKey] = childValue;
            this.putState(state);
        };
        child.subscribe(updateFromChild);
        updateFromChild(child.getState());
    }
}
exports.ComposedStore = ComposedStore;
//# sourceMappingURL=ComposedStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/ComposedStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/MergedStore.js", {"./ObservableStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/MergedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class MergedStore extends ObservableStore_1.ObservableStore {
    constructor(children = []) {
        super();
        // set default state
        const state = this.getState();
        if (!state) {
            this.putState({});
        }
        this._children = children;
        // subscribe to children
        children.forEach((child) => this._addChild(child));
        this._updateWholeState();
    }
    _addChild(child) {
        child.subscribe(() => this._updateWholeState());
    }
    _updateWholeState() {
        const childStates = this._children.map((child) => child.getState());
        // apply shallow merge over states
        const state = Object.assign({}, ...childStates);
        this.putState(state);
    }
}
exports.MergedStore = MergedStore;
//# sourceMappingURL=MergedStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/MergedStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/ObservableStore.js", {"@metamask/safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/safe-event-emitter/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/ObservableStore.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableStore = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
class ObservableStore extends safe_event_emitter_1.default {
    constructor(initState = {}) {
        super();
        // set init state
        this._state = initState;
    }
    // wrapper around internal getState
    getState() {
        return this._getState();
    }
    // wrapper around internal putState
    putState(newState) {
        this._putState(newState);
        this.emit('update', newState);
    }
    updateState(partialState) {
        // if non-null object, merge
        if (partialState && typeof partialState === 'object') {
            const state = this.getState();
            const newState = Object.assign({}, state, partialState);
            this.putState(newState);
            // if not object, use new value
        }
        else {
            this.putState(partialState);
        }
    }
    // subscribe to changes
    subscribe(handler) {
        this.on('update', handler);
    }
    // unsubscribe to changes
    unsubscribe(handler) {
        this.removeListener('update', handler);
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        return this._state;
    }
    // write to persistence
    _putState(newState) {
        this._state = newState;
    }
}
exports.ObservableStore = ObservableStore;
//# sourceMappingURL=ObservableStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/ObservableStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/transform.js", {"through2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/node_modules/through2/through2.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/transform.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeTransformStream = void 0;
const through2_1 = require("through2");
function storeTransformStream(syncTransformFn) {
    return through2_1.obj((state, _encoding, cb) => {
        try {
            const newState = syncTransformFn(state);
            cb(null, newState);
            return undefined;
        }
        catch (err) {
            cb(err);
            return undefined;
        }
    });
}
exports.storeTransformStream = storeTransformStream;
//# sourceMappingURL=transform.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/transform.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/002.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/002.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 2;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      if (versionedData.data.config.provider.type === 'etherscan') {
        versionedData.data.config.provider.type = 'rpc';
        versionedData.data.config.provider.rpcTarget = 'https://rpc.metamask.io/';
      }
    } catch (_) {// empty
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/002.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/004.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/004.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 4;
var _default = {
  version,

  migrate(versionedData) {
    const safeVersionedData = (0, _lodash.cloneDeep)(versionedData);
    safeVersionedData.meta.version = version;

    try {
      if (safeVersionedData.data.config.provider.type !== 'rpc') {
        return Promise.resolve(safeVersionedData);
      }

      switch (safeVersionedData.data.config.provider.rpcTarget) {
        case 'https://testrpc.metamask.io/':
          safeVersionedData.data.config.provider = {
            type: 'testnet'
          };
          break;

        case 'https://rpc.metamask.io/':
          safeVersionedData.data.config.provider = {
            type: 'mainnet'
          };
          break;
        // No default
      }
    } catch (_) {// empty
    }

    return Promise.resolve(safeVersionedData);
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/004.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/003.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/003.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 3;
const oldTestRpc = 'https://rawtestrpc.metamask.io/';
const newTestRpc = 'https://testrpc.metamask.io/';
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      if (versionedData.data.config.provider.rpcTarget === oldTestRpc) {
        versionedData.data.config.provider.rpcTarget = newTestRpc;
      }
    } catch (_) {// empty
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/003.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/012.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/012.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration modifies our notices to delete their body after being read.

*/
const version = 12;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  newState.NoticeController.noticesList.forEach(notice => {
    if (notice.read) {
      notice.body = '';
    }
  });
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/012.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/010.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/010.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration breaks out the ShapeShiftController substate

*/
const version = 10;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = (0, _lodash.merge)({}, state, {
    ShapeShiftController: {
      shapeShiftTxList: state.shapeShiftTxList || []
    }
  });
  delete newState.shapeShiftTxList;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/010.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/014.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/014.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration removes provider from config and moves it too NetworkController.

*/
const version = 14;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  newState.NetworkController = {};
  newState.NetworkController.provider = newState.config.provider;
  delete newState.config.provider;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/014.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/009.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/009.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration breaks out the CurrencyController substate

*/
const version = 9;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = (0, _lodash.merge)({}, state, {
    CurrencyController: {
      currentCurrency: state.currentFiat || state.fiatCurrency || 'USD',
      conversionRate: state.conversionRate,
      conversionDate: state.conversionDate
    }
  });
  delete newState.currentFiat;
  delete newState.fiatCurrency;
  delete newState.conversionRate;
  delete newState.conversionDate;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/009.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/011.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/011.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration removes the discaimer state from our app, which was integrated into our notices.

*/
const version = 11;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  delete newState.TOSHash;
  delete newState.isDisclaimerConfirmed;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/011.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/015.js", {"../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/015.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration sets transactions with the 'Gave up submitting tx.' err message
to a 'failed' stated

*/
const version = 15;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.err) {
        return txMeta;
      } else if (txMeta.err.message === 'Gave up submitting tx.') {
        txMeta.status = _transaction.TRANSACTION_STATUSES.FAILED;
      }

      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/015.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/013.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/013.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration modifies the network config from ambiguous 'testnet' to explicit 'ropsten'

*/
const version = 13;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    config
  } = newState;

  if (config && config.provider) {
    if (config.provider.type === 'testnet') {
      newState.config.provider.type = 'ropsten';
    }
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/013.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/017.js", {"../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/017.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration sets transactions who were retried and marked as failed to submitted

*/
const version = 17;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.status === _transaction.TRANSACTION_STATUSES.FAILED) {
        return txMeta;
      }

      if (txMeta.retryCount > 0 && txMeta.retryCount < 2) {
        txMeta.status = _transaction.TRANSACTION_STATUSES.SUBMITTED;
        delete txMeta.err;
      }

      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/017.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/019.js", {"../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/019.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration sets transactions as failed
whos nonce is too high

*/
const version = 19;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map((txMeta, _, txList) => {
      if (txMeta.status !== _transaction.TRANSACTION_STATUSES.SUBMITTED) {
        return txMeta;
      }

      const confirmedTxs = txList.filter(tx => tx.status === _transaction.TRANSACTION_STATUSES.CONFIRMED).filter(tx => tx.txParams.from === txMeta.txParams.from).filter(tx => tx.metamaskNetworkId.from === txMeta.metamaskNetworkId.from);
      const highestConfirmedNonce = getHighestNonce(confirmedTxs);
      const pendingTxs = txList.filter(tx => tx.status === _transaction.TRANSACTION_STATUSES.SUBMITTED).filter(tx => tx.txParams.from === txMeta.txParams.from).filter(tx => tx.metamaskNetworkId.from === txMeta.metamaskNetworkId.from);
      const highestContinuousNonce = getHighestContinuousFrom(pendingTxs, highestConfirmedNonce);
      const maxNonce = Math.max(highestContinuousNonce, highestConfirmedNonce);

      if (parseInt(txMeta.txParams.nonce, 16) > maxNonce + 1) {
        txMeta.status = _transaction.TRANSACTION_STATUSES.FAILED;
        txMeta.err = {
          message: 'nonce too high',
          note: 'migration 019 custom error'
        };
      }

      return txMeta;
    });
  }

  return newState;
}

function getHighestContinuousFrom(txList, startPoint) {
  const nonces = txList.map(txMeta => {
    const {
      nonce
    } = txMeta.txParams;
    return parseInt(nonce, 16);
  });
  let highest = startPoint;

  while (nonces.includes(highest)) {
    highest += 1;
  }

  return highest;
}

function getHighestNonce(txList) {
  const nonces = txList.map(txMeta => {
    const {
      nonce
    } = txMeta.txParams;
    return parseInt(nonce || '0x0', 16);
  });
  const highestNonce = Math.max.apply(null, nonces);
  return highestNonce;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/019.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/016.js", {"../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/016.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration sets transactions with the 'Gave up submitting tx.' err message
to a 'failed' stated

*/
const version = 16;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.err) {
        return txMeta;
      }

      if (txMeta.err === 'transaction with the same hash was already imported.') {
        txMeta.status = _transaction.TRANSACTION_STATUSES.SUBMITTED;
        delete txMeta.err;
      }

      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/016.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/020.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/020.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration ensures previous installations
get a `firstTimeInfo` key on the metamask state,
so that we can version notices in the future.

*/
const version = 20;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if ('metamask' in newState && !('firstTimeInfo' in newState.metamask)) {
    newState.metamask.firstTimeInfo = {
      version: '3.12.0',
      date: Date.now()
    };
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/020.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/023.js", {"../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/023.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration removes transactions that are no longer usefull down to 40 total

*/
const version = 23;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;

    if (transactions.length <= 40) {
      return newState;
    }

    const reverseTxList = transactions.reverse();
    let stripping = true;

    while (reverseTxList.length > 40 && stripping) {
      const txIndex = reverseTxList.findIndex(txMeta => {
        return txMeta.status === _transaction.TRANSACTION_STATUSES.FAILED || txMeta.status === _transaction.TRANSACTION_STATUSES.REJECTED || txMeta.status === _transaction.TRANSACTION_STATUSES.CONFIRMED || txMeta.status === _transaction.TRANSACTION_STATUSES.DROPPED;
      });

      if (txIndex < 0) {
        stripping = false;
      } else {
        reverseTxList.splice(txIndex, 1);
      }
    }

    newState.TransactionController.transactions = reverseTxList.reverse();
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/023.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/021.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/021.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration removes the BlackListController from disk state

*/
const version = 21;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  delete newState.BlacklistController;
  delete newState.RecentBlocks;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/021.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/025.js", {"../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","../lib/util":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/util.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/025.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _util = require("../lib/util");

var _transaction = require("../../../shared/constants/transaction");

// next version number

/*

normalizes txParams on unconfirmed txs

*/
const version = 25;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (newState.TransactionController) {
    if (newState.TransactionController.transactions) {
      const {
        transactions
      } = newState.TransactionController;
      newState.TransactionController.transactions = transactions.map(txMeta => {
        if (txMeta.status !== _transaction.TRANSACTION_STATUSES.UNAPPROVED) {
          return txMeta;
        }

        txMeta.txParams = normalizeTxParams(txMeta.txParams);
        return txMeta;
      });
    }
  }

  return newState;
}

function normalizeTxParams(txParams) {
  // functions that handle normalizing of that key in txParams
  const whiteList = {
    from: from => (0, _util.addHexPrefix)(from).toLowerCase(),
    to: () => (0, _util.addHexPrefix)(txParams.to).toLowerCase(),
    nonce: nonce => (0, _util.addHexPrefix)(nonce),
    value: value => (0, _util.addHexPrefix)(value),
    data: data => (0, _util.addHexPrefix)(data),
    gas: gas => (0, _util.addHexPrefix)(gas),
    gasPrice: gasPrice => (0, _util.addHexPrefix)(gasPrice)
  }; // apply only keys in the whiteList

  const normalizedTxParams = {};
  Object.keys(whiteList).forEach(key => {
    if (txParams[key]) {
      normalizedTxParams[key] = whiteList[key](txParams[key]);
    }
  });
  return normalizedTxParams;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/025.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/022.js", {"../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/022.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration adds submittedTime to the txMeta if it is not their

*/
const version = 22;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (txMeta.status !== _transaction.TRANSACTION_STATUSES.SUBMITTED || txMeta.submittedTime) {
        return txMeta;
      }

      txMeta.submittedTime = new Date().getTime();
      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/022.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/026.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/026.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration moves the identities stored in the KeyringController
 into the PreferencesController

*/
const version = 26;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      versionedData.data = transformState(state);
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
      return Promise.reject(err);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  if (!state.KeyringController || !state.PreferencesController) {
    return state;
  }

  if (!state.KeyringController.walletNicknames) {
    return state;
  }

  state.PreferencesController.identities = Object.keys(state.KeyringController.walletNicknames).reduce((identities, address) => {
    identities[address] = {
      name: state.KeyringController.walletNicknames[address],
      address
    };
    return identities;
  }, {});
  delete state.KeyringController.walletNicknames;
  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/026.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/028.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/028.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number

/*

normalizes txParams on unconfirmed txs

*/
const version = 28;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (newState.PreferencesController) {
    if (newState.PreferencesController.tokens && newState.PreferencesController.identities) {
      const {
        identities,
        tokens
      } = newState.PreferencesController;
      newState.PreferencesController.accountTokens = {};
      Object.keys(identities).forEach(identity => {
        newState.PreferencesController.accountTokens[identity] = {
          mainnet: tokens
        };
      });
      newState.PreferencesController.tokens = [];
    }
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/028.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/027.js", {"../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/027.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

// next version number

/*

normalizes txParams on unconfirmed txs

*/
const version = 27;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (newState.TransactionController) {
    if (newState.TransactionController.transactions) {
      const {
        transactions
      } = newState.TransactionController;
      newState.TransactionController.transactions = transactions.filter(txMeta => txMeta.status !== _transaction.TRANSACTION_STATUSES.REJECTED);
    }
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/027.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/024.js", {"../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/024.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration ensures that the from address in txParams is to lower case for
all unapproved transactions

*/
const version = 24;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (!newState.TransactionController) {
    return newState;
  }

  const {
    transactions
  } = newState.TransactionController;
  newState.TransactionController.transactions = transactions.map((txMeta, _) => {
    if (txMeta.status === _transaction.TRANSACTION_STATUSES.UNAPPROVED && txMeta.txParams && txMeta.txParams.from) {
      txMeta.txParams.from = txMeta.txParams.from.toLowerCase();
    }

    return txMeta;
  });
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/024.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/031.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/031.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number
const version = 31;
/*
 * The purpose of this migration is to properly set the completedOnboarding flag based on the state
 * of the KeyringController.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    KeyringController,
    PreferencesController
  } = state;

  if (KeyringController && PreferencesController) {
    const {
      vault
    } = KeyringController;
    PreferencesController.completedOnboarding = Boolean(vault);
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/031.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/030.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/030.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number

/*

removes invalid chaids from preferences and networkController for custom rpcs

*/
const version = 30;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (state.PreferencesController) {
    const {
      frequentRpcListDetail
    } = newState.PreferencesController;

    if (frequentRpcListDetail) {
      frequentRpcListDetail.forEach((rpc, index) => {
        // eslint-disable-next-line radix
        if (Boolean(rpc.chainId) && Number.isNaN(parseInt(rpc.chainId))) {
          delete frequentRpcListDetail[index].chainId;
        }
      });
      newState.PreferencesController.frequentRpcListDetail = frequentRpcListDetail;
    }
  }

  if (state.NetworkController) {
    if (newState.NetworkController.network && // eslint-disable-next-line radix
    Number.isNaN(parseInt(newState.NetworkController.network))) {
      delete newState.NetworkController.network;
    }

    if (newState.NetworkController.provider && newState.NetworkController.provider.chainId && // eslint-disable-next-line radix
    Number.isNaN(parseInt(newState.NetworkController.provider.chainId))) {
      delete newState.NetworkController.provider.chainId;
    }
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/030.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/034.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/034.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 34;
/**
 * The purpose of this migration is to enable the {@code privacyMode} feature flag and set the user as being migrated
 * if it was {@code false}.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PreferencesController
  } = state;

  if (PreferencesController) {
    const featureFlags = PreferencesController.featureFlags || {};

    if (!featureFlags.privacyMode && typeof PreferencesController.migratedPrivacyMode === 'undefined') {
      // Mark the state has being migrated and enable Privacy Mode
      PreferencesController.migratedPrivacyMode = true;
      featureFlags.privacyMode = true;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/034.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/032.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/032.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 32;
/**
 * The purpose of this migration is to set the {@code completedUiMigration} flag based on the user's UI preferences
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PreferencesController
  } = state;

  if (PreferencesController) {
    const {
      betaUI
    } = PreferencesController.featureFlags || {}; // Users who have been using the "beta" UI are considered to have completed the migration
    // as they'll see no difference in this version

    PreferencesController.completedUiMigration = betaUI;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/032.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/033.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/033.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number

/*

Cleans up notices and assocated notice controller code

*/
const version = 33;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state; // transform state here

  if (state.NoticeController) {
    delete newState.NoticeController;
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/033.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/035.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/035.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number

/*

Removes the deprecated 'seedWords' state

*/
const version = 35;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    versionedData.data = transformState(versionedData.data);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.PreferencesController && state.PreferencesController.seedWords !== undefined) {
    delete state.PreferencesController.seedWords;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/035.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/036.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/036.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 36;
/**
 * The purpose of this migration is to remove the {@code privacyMode} feature flag.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PreferencesController
  } = state;

  if (PreferencesController) {
    const featureFlags = PreferencesController.featureFlags || {};

    if (typeof featureFlags.privacyMode !== 'undefined') {
      delete featureFlags.privacyMode;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/036.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/039.js", {"../../../shared/modules/hexstring-utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/hexstring-utils.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/039.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _hexstringUtils = require("../../../shared/modules/hexstring-utils");

const version = 39;
const DAI_V1_CONTRACT_ADDRESS = '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359';
const DAI_V1_TOKEN_SYMBOL = 'DAI';
const SAI_TOKEN_SYMBOL = 'SAI';

function isOldDai(token = {}) {
  return token && typeof token === 'object' && token.symbol === DAI_V1_TOKEN_SYMBOL && (0, _hexstringUtils.toChecksumHexAddress)(token.address) === DAI_V1_CONTRACT_ADDRESS;
}
/**
 * This migration renames the Dai token to Sai.
 *
 * As of 2019-11-18 Dai is now called Sai (refs https://git.io/JeooP) to facilitate
 * Maker's upgrade to Multi-Collateral Dai and this migration renames the token
 * at the old address.
 */


var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PreferencesController
  } = state;

  if (PreferencesController) {
    const tokens = PreferencesController.tokens || [];

    if (Array.isArray(tokens)) {
      for (const token of tokens) {
        if (isOldDai(token)) {
          token.symbol = SAI_TOKEN_SYMBOL;
        }
      }
    }

    const accountTokens = PreferencesController.accountTokens || {};

    if (accountTokens && typeof accountTokens === 'object') {
      for (const address of Object.keys(accountTokens)) {
        const networkTokens = accountTokens[address];

        if (networkTokens && typeof networkTokens === 'object') {
          for (const network of Object.keys(networkTokens)) {
            const tokensOnNetwork = networkTokens[network];

            if (Array.isArray(tokensOnNetwork)) {
              for (const token of tokensOnNetwork) {
                if (isOldDai(token)) {
                  token.symbol = SAI_TOKEN_SYMBOL;
                }
              }
            }
          }
        }
      }
    }
  }

  return state;
}


      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/039.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/040.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/040.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 40;
/**
 * Site connections are now managed by the PermissionsController, and the
 * ProviderApprovalController is removed. This migration deletes all
 * ProviderApprovalController state.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  delete state.ProviderApprovalController;
  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/040.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/044.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/044.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 44;
/**
 * Remove unused 'mkrMigrationReminderTimestamp' state from the `AppStateController`
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$AppStateContro;

  if (typeof (state === null || state === void 0 ? void 0 : (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? void 0 : _state$AppStateContro.mkrMigrationReminderTimestamp) !== 'undefined') {
    delete state.AppStateController.mkrMigrationReminderTimestamp;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/044.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/041.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/041.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 41;
/**
 * PreferencesController.autoLogoutTimeLimit -> autoLockTimeLimit
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.PreferencesController && state.PreferencesController.preferences) {
    state.PreferencesController.preferences.autoLockTimeLimit = state.PreferencesController.preferences.autoLogoutTimeLimit;
    delete state.PreferencesController.preferences.autoLogoutTimeLimit;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/041.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/042.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/042.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 42;
/**
 * Initialize `connectedStatusPopoverHasBeenShown` to `false` if it hasn't yet been set,
 * so that existing users are introduced to the new connected status indicator
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.AppStateController) {
    state.AppStateController.connectedStatusPopoverHasBeenShown = false;
  } else {
    state.AppStateController = {
      connectedStatusPopoverHasBeenShown: false
    };
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/042.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/045.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/045.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 45;
/**
 * Replaces {@code PreferencesController.ipfsGateway} with 'dweb.link' if set
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;
const outdatedGateways = ['ipfs.io', 'ipfs.dweb.link'];

function transformState(state) {
  var _state$PreferencesCon;

  if (outdatedGateways.includes(state === null || state === void 0 ? void 0 : (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.ipfsGateway)) {
    state.PreferencesController.ipfsGateway = 'dweb.link';
  }

  return state;
}


      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/045.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/043.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/043.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 43;
/**
 * Remove unused 'currentAccountTab' state
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$PreferencesCon;

  if (state !== null && state !== void 0 && (_state$PreferencesCon = state.PreferencesController) !== null && _state$PreferencesCon !== void 0 && _state$PreferencesCon.currentAccountTab) {
    delete state.PreferencesController.currentAccountTab;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/043.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/046.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/046.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 46;
/**
 * Delete {@code ABTestController} state
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (typeof (state === null || state === void 0 ? void 0 : state.ABTestController) !== 'undefined') {
    delete state.ABTestController;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/046.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/047.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/047.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 47;
/**
 * Stringify the `metamaskNetworkId` property of all transactions
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon;

  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;

  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      if (typeof transaction.metamaskNetworkId === 'number') {
        transaction.metamaskNetworkId = transaction.metamaskNetworkId.toString();
      }
    });
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/047.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/049.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/049.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 49;
/**
 * Migrate metaMetrics state to the new MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state = {}) {
  if (state.PreferencesController) {
    var _state$MetaMetricsCon;

    const {
      metaMetricsId,
      participateInMetaMetrics,
      metaMetricsSendCount
    } = state.PreferencesController;
    state.MetaMetricsController = (_state$MetaMetricsCon = state.MetaMetricsController) !== null && _state$MetaMetricsCon !== void 0 ? _state$MetaMetricsCon : {};

    if (metaMetricsId !== undefined) {
      state.MetaMetricsController.metaMetricsId = metaMetricsId;
      delete state.PreferencesController.metaMetricsId;
    }

    if (participateInMetaMetrics !== undefined) {
      state.MetaMetricsController.participateInMetaMetrics = participateInMetaMetrics;
      delete state.PreferencesController.participateInMetaMetrics;
    }

    if (metaMetricsSendCount !== undefined) {
      state.MetaMetricsController.metaMetricsSendCount = metaMetricsSendCount;
      delete state.PreferencesController.metaMetricsSendCount;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/049.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/052.js", {"../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/052.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _network = require("../../../shared/constants/network");

const version = 52;
/**
 * Migrate tokens in Preferences to be keyed by chainId instead of
 * providerType. To prevent breaking user's MetaMask and selected
 * tokens, this migration copies the RPC entry into *every* custom RPC
 * chainId.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state = {}) {
  if (state.PreferencesController) {
    const {
      accountTokens,
      accountHiddenTokens,
      frequentRpcListDetail
    } = state.PreferencesController;
    const newAccountTokens = {};
    const newAccountHiddenTokens = {};

    if (accountTokens && Object.keys(accountTokens).length > 0) {
      for (const address of Object.keys(accountTokens)) {
        newAccountTokens[address] = {};

        if (accountTokens[address][_network.NETWORK_TYPE_RPC]) {
          frequentRpcListDetail.forEach(detail => {
            newAccountTokens[address][detail.chainId] = accountTokens[address][_network.NETWORK_TYPE_RPC];
          });
        }

        for (const providerType of Object.keys(accountTokens[address])) {
          switch (providerType) {
            case _network.MAINNET:
              newAccountTokens[address][_network.MAINNET_CHAIN_ID] = accountTokens[address][_network.MAINNET];
              break;

            case _network.ROPSTEN:
              newAccountTokens[address][_network.ROPSTEN_CHAIN_ID] = accountTokens[address][_network.ROPSTEN];
              break;

            case _network.RINKEBY:
              newAccountTokens[address][_network.RINKEBY_CHAIN_ID] = accountTokens[address][_network.RINKEBY];
              break;

            case _network.GOERLI:
              newAccountTokens[address][_network.GOERLI_CHAIN_ID] = accountTokens[address][_network.GOERLI];
              break;

            case _network.KOVAN:
              newAccountTokens[address][_network.KOVAN_CHAIN_ID] = accountTokens[address][_network.KOVAN];
              break;

            default:
              break;
          }
        }
      }

      state.PreferencesController.accountTokens = newAccountTokens;
    }

    if (accountHiddenTokens && Object.keys(accountHiddenTokens).length > 0) {
      for (const address of Object.keys(accountHiddenTokens)) {
        newAccountHiddenTokens[address] = {};

        if (accountHiddenTokens[address][_network.NETWORK_TYPE_RPC]) {
          frequentRpcListDetail.forEach(detail => {
            newAccountHiddenTokens[address][detail.chainId] = accountHiddenTokens[address][_network.NETWORK_TYPE_RPC];
          });
        }

        for (const providerType of Object.keys(accountHiddenTokens[address])) {
          switch (providerType) {
            case _network.MAINNET:
              newAccountHiddenTokens[address][_network.MAINNET_CHAIN_ID] = accountHiddenTokens[address][_network.MAINNET];
              break;

            case _network.ROPSTEN:
              newAccountHiddenTokens[address][_network.ROPSTEN_CHAIN_ID] = accountHiddenTokens[address][_network.ROPSTEN];
              break;

            case _network.RINKEBY:
              newAccountHiddenTokens[address][_network.RINKEBY_CHAIN_ID] = accountHiddenTokens[address][_network.RINKEBY];
              break;

            case _network.GOERLI:
              newAccountHiddenTokens[address][_network.GOERLI_CHAIN_ID] = accountHiddenTokens[address][_network.GOERLI];
              break;

            case _network.KOVAN:
              newAccountHiddenTokens[address][_network.KOVAN_CHAIN_ID] = accountHiddenTokens[address][_network.KOVAN];
              break;

            default:
              break;
          }
        }
      }

      state.PreferencesController.accountHiddenTokens = newAccountHiddenTokens;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/052.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/051.js", {"../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/051.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _network = require("../../../shared/constants/network");

const version = 51;
/**
 * Set the chainId in the Network Controller provider data for all infura networks
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$NetworkControl, _NETWORK_TYPE_TO_ID_M;

  const {
    chainId,
    type
  } = (state === null || state === void 0 ? void 0 : (_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? void 0 : _state$NetworkControl.provider) || {};
  const enumChainId = (_NETWORK_TYPE_TO_ID_M = _network.NETWORK_TYPE_TO_ID_MAP[type]) === null || _NETWORK_TYPE_TO_ID_M === void 0 ? void 0 : _NETWORK_TYPE_TO_ID_M.chainId;

  if (enumChainId && chainId !== enumChainId) {
    state.NetworkController.provider.chainId = enumChainId;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/051.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/054.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/054.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 54;

function isValidDecimals(decimals) {
  return typeof decimals === 'number' || typeof decimals === 'string' && decimals.match(/^(0x)?\d+$/u);
}
/**
 * Migrates preference tokens with decimals typed as string to number.
 * It also removes any tokens with corrupted or inconvertible decimal values.
 */


var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (!newState.PreferencesController) {
    return newState;
  }

  const tokens = newState.PreferencesController.tokens || []; // Filter out any tokens with corrupted decimal values

  const validTokens = tokens.filter(({
    decimals
  }) => isValidDecimals(decimals));

  for (const token of validTokens) {
    // In the case of a decimal value type string, convert to a number.
    if (typeof token.decimals === 'string') {
      // eslint-disable-next-line radix
      token.decimals = parseInt(token.decimals);
    }
  }

  newState.PreferencesController.tokens = validTokens;
  const {
    accountTokens
  } = newState.PreferencesController;

  if (accountTokens && typeof accountTokens === 'object') {
    for (const address of Object.keys(accountTokens)) {
      const networkTokens = accountTokens[address];

      if (networkTokens && typeof networkTokens === 'object') {
        for (const network of Object.keys(networkTokens)) {
          const tokensOnNetwork = networkTokens[network] || []; // Filter out any tokens with corrupted decimal values

          const validTokensOnNetwork = tokensOnNetwork.filter(({
            decimals
          }) => isValidDecimals(decimals)); // In the case of a decimal value type string, convert to a number.

          for (const token of validTokensOnNetwork) {
            if (typeof token.decimals === 'string') {
              // eslint-disable-next-line radix
              token.decimals = parseInt(token.decimals);
            }
          }

          networkTokens[network] = validTokensOnNetwork;
        }
      }
    }
  }

  newState.PreferencesController.accountTokens = accountTokens;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/054.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/050.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/050.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 50;
const LEGACY_LOCAL_STORAGE_KEYS = ['METASWAP_GAS_PRICE_ESTIMATES_LAST_RETRIEVED', 'METASWAP_GAS_PRICE_ESTIMATES', 'cachedFetch', 'BASIC_PRICE_ESTIMATES_LAST_RETRIEVED', 'BASIC_PRICE_ESTIMATES', 'BASIC_GAS_AND_TIME_API_ESTIMATES', 'BASIC_GAS_AND_TIME_API_ESTIMATES_LAST_RETRIEVED', 'GAS_API_ESTIMATES_LAST_RETRIEVED', 'GAS_API_ESTIMATES'];
/**
 * Migrate metaMetrics state to the new MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    LEGACY_LOCAL_STORAGE_KEYS.forEach(key => {
      var _window$localStorage;

      return (_window$localStorage = window.localStorage) === null || _window$localStorage === void 0 ? void 0 : _window$localStorage.removeItem(key);
    });
    return versionedData;
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/050.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/055.js", {"../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/055.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _network = require("../../../shared/constants/network");

const version = 55;
/**
 * replace 'incomingTxLastFetchedBlocksByNetwork' with 'incomingTxLastFetchedBlockByChainId'
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;
const UNKNOWN_CHAIN_ID_KEY = 'UNKNOWN';

function transformState(state) {
  var _state$IncomingTransa;

  if (state !== null && state !== void 0 && (_state$IncomingTransa = state.IncomingTransactionsController) !== null && _state$IncomingTransa !== void 0 && _state$IncomingTransa.incomingTxLastFetchedBlocksByNetwork) {
    state.IncomingTransactionsController.incomingTxLastFetchedBlockByChainId = (0, _lodash.mapKeys)(state.IncomingTransactionsController.incomingTxLastFetchedBlocksByNetwork, // using optional chaining in case user's state has fetched blocks for
    // RPC network types (which don't map to a single chainId). This should
    // not be possible, but it's safer
    (_, key) => {
      var _NETWORK_TYPE_TO_ID_M, _NETWORK_TYPE_TO_ID_M2;

      return (_NETWORK_TYPE_TO_ID_M = (_NETWORK_TYPE_TO_ID_M2 = _network.NETWORK_TYPE_TO_ID_MAP[key]) === null || _NETWORK_TYPE_TO_ID_M2 === void 0 ? void 0 : _NETWORK_TYPE_TO_ID_M2.chainId) !== null && _NETWORK_TYPE_TO_ID_M !== void 0 ? _NETWORK_TYPE_TO_ID_M : UNKNOWN_CHAIN_ID_KEY;
    }); // Now that mainnet and test net last fetched blocks are keyed by their
    // respective chainIds, we can safely delete anything we had for custom
    // networks. Any custom network that shares a chainId with one of the
    // aforementioned networks will use the value stored by chainId.

    delete state.IncomingTransactionsController.incomingTxLastFetchedBlockByChainId[UNKNOWN_CHAIN_ID_KEY];
    delete state.IncomingTransactionsController.incomingTxLastFetchedBlocksByNetwork;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/055.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/056.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/056.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 56;
/**
 * Remove tokens that don't have an address due to
 * lack of previous addToken validation.  Also removes
 * an unwanted, undefined image property
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const {
      PreferencesController
    } = versionedData.data;

    if (Array.isArray(PreferencesController === null || PreferencesController === void 0 ? void 0 : PreferencesController.tokens)) {
      PreferencesController.tokens = PreferencesController.tokens.filter(({
        address
      }) => address);
    }

    if (PreferencesController !== null && PreferencesController !== void 0 && PreferencesController.accountTokens && typeof PreferencesController.accountTokens === 'object') {
      Object.keys(PreferencesController.accountTokens).forEach(account => {
        const chains = Object.keys(PreferencesController.accountTokens[account]);
        chains.forEach(chain => {
          PreferencesController.accountTokens[account][chain] = PreferencesController.accountTokens[account][chain].filter(({
            address
          }) => address);
        });
      });
    }

    if (PreferencesController !== null && PreferencesController !== void 0 && PreferencesController.assetImages && 'undefined' in PreferencesController.assetImages) {
      delete PreferencesController.assetImages.undefined;
    }

    return versionedData;
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/056.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/058.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/058.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 58;
/**
 * Deletes the swapsWelcomeMessageHasBeenShown property from state
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$AppStateContro;

  (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? true : delete _state$AppStateContro.swapsWelcomeMessageHasBeenShown;
  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/058.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/059.js", {"../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/059.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

const version = 59;
/**
 * Removes orphaned cancel and retry transactions that no longer have the
 * original transaction in state, which results in bugs.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon;

  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;

  if ((0, _lodash.isPlainObject)(transactions)) {
    const nonceNetworkGroupedObject = (0, _lodash.groupBy)(Object.values(transactions), tx => {
      var _tx$txParams, _tx$chainId;

      return `${(_tx$txParams = tx.txParams) === null || _tx$txParams === void 0 ? void 0 : _tx$txParams.nonce}-${(_tx$chainId = tx.chainId) !== null && _tx$chainId !== void 0 ? _tx$chainId : tx.metamaskNetworkId}`;
    });
    const withoutOrphans = (0, _lodash.pickBy)(nonceNetworkGroupedObject, group => {
      return group.some(tx => tx.type !== _transaction.TRANSACTION_TYPES.CANCEL && tx.type !== _transaction.TRANSACTION_TYPES.RETRY);
    });
    state.TransactionController.transactions = (0, _lodash.keyBy)((0, _lodash.concat)(...Object.values(withoutOrphans)), tx => tx.id);
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/059.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/060.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/060.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 60;
const SUPPORT_NOTIFICATION_KEY = 2;
const SUPPORT_NOTIFICATION_DATE = '2020-08-31';
/**
 * Removes the support survey notification
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$NotificationCo;

  const notifications = state === null || state === void 0 ? void 0 : (_state$NotificationCo = state.NotificationController) === null || _state$NotificationCo === void 0 ? void 0 : _state$NotificationCo.notifications;

  if ((0, _lodash.isPlainObject)(notifications)) {
    var _notifications$SUPPOR;

    if (((_notifications$SUPPOR = notifications[SUPPORT_NOTIFICATION_KEY]) === null || _notifications$SUPPOR === void 0 ? void 0 : _notifications$SUPPOR.date) === SUPPORT_NOTIFICATION_DATE) {
      delete state.NotificationController.notifications[SUPPORT_NOTIFICATION_KEY];
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/060.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/061.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/061.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 61;
/**
 * Initialize attributes related to recovery seed phrase reminder
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const currentTime = new Date().getTime();

  if (state.AppStateController) {
    state.AppStateController.recoveryPhraseReminderHasBeenShown = false;
    state.AppStateController.recoveryPhraseReminderLastShown = currentTime;
  } else {
    state.AppStateController = {
      recoveryPhraseReminderHasBeenShown: false,
      recoveryPhraseReminderLastShown: currentTime
    };
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/061.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/062.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/062.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 62;
/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.MetaMetricsController) {
    const {
      metaMetricsSendCount
    } = state.MetaMetricsController;

    if (metaMetricsSendCount !== undefined) {
      delete state.MetaMetricsController.metaMetricsSendCount;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/062.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/064.js", {"../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/064.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

const version = 64;
const SENT_ETHER = 'sentEther'; // the legacy transaction type being replaced in this migration with TRANSACTION_TYPES.SIMPLE_SEND

/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon;

  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;

  if ((0, _lodash.isPlainObject)(transactions)) {
    for (const tx of Object.values(transactions)) {
      if (tx.type === SENT_ETHER) {
        tx.type = _transaction.TRANSACTION_TYPES.SIMPLE_SEND;
      }

      if (tx.history) {
        tx.history.map(txEvent => {
          if (txEvent.type && txEvent.type === SENT_ETHER) {
            txEvent.type = _transaction.TRANSACTION_TYPES.SIMPLE_SEND;
          }

          return txEvent;
        });
      }
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/064.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/065.js", {"lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/065.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 65;
/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.PreferencesController) {
    var _state$OnboardingCont;

    const {
      completedOnboarding,
      firstTimeFlowType
    } = state.PreferencesController;
    state.OnboardingController = (_state$OnboardingCont = state.OnboardingController) !== null && _state$OnboardingCont !== void 0 ? _state$OnboardingCont : {};

    if (completedOnboarding !== undefined) {
      state.OnboardingController.completedOnboarding = completedOnboarding;
      delete state.PreferencesController.completedOnboarding;
    }

    if (firstTimeFlowType !== undefined) {
      state.OnboardingController.firstTimeFlowType = firstTimeFlowType;
      delete state.PreferencesController.firstTimeFlowType;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/065.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/069.js", {"../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/069.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _app = require("../../../shared/constants/app");

const version = 69;
/**
 * Adds the `subjectType` property to all subject metadata.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$SubjectMetadat;

  if (typeof (state === null || state === void 0 ? void 0 : (_state$SubjectMetadat = state.SubjectMetadataController) === null || _state$SubjectMetadat === void 0 ? void 0 : _state$SubjectMetadat.subjectMetadata) === 'object') {
    const {
      SubjectMetadataController: {
        subjectMetadata
      }
    } = state; // mutate SubjectMetadataController.subjectMetadata in place

    Object.values(subjectMetadata).forEach(metadata => {
      if (metadata && typeof metadata === 'object' && !Array.isArray(metadata)) {
        metadata.subjectType = metadata.extensionId ? _app.SUBJECT_TYPES.EXTENSION : _app.SUBJECT_TYPES.WEBSITE;
      }
    });
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/069.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/037.js", {"@metamask/controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/controllers/dist/index.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/037.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _controllers = require("@metamask/controllers");

const version = 37;
/**
 * The purpose of this migration is to update the address book state
 * to the new schema with chainId as a key.
 * and to add the isEns flag to all entries
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.AddressBookController) {
    const ab = state.AddressBookController.addressBook;
    const chainIds = new Set();
    const newAddressBook = {}; // add all of the chainIds to a set

    Object.values(ab).forEach(v => {
      chainIds.add(v.chainId);
    }); // fill the chainId object with the entries with the matching chainId

    for (const id of chainIds.values()) {
      // make an empty object entry for each chainId
      newAddressBook[id] = {};

      for (const address in ab) {
        if (ab[address].chainId === id) {
          ab[address].isEns = false;

          if (_controllers.util.normalizeEnsName(ab[address].name)) {
            ab[address].isEns = true;
          }

          newAddressBook[id][address] = ab[address];
        }
      }
    }

    state.AddressBookController.addressBook = newAddressBook;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/037.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/005.js", {"@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/005.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 5;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = selectSubstateForKeyringController(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #5${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function selectSubstateForKeyringController(state) {
  const {
    config
  } = state;

  const newState = _objectSpread(_objectSpread({}, state), {}, {
    KeyringController: {
      vault: state.vault,
      selectedAccount: config.selectedAccount,
      walletNicknames: state.walletNicknames
    }
  });

  delete newState.vault;
  delete newState.walletNicknames;
  delete newState.config.selectedAccount;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/005.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/007.js", {"@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/007.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 7;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = _objectSpread(_objectSpread({}, state), {}, {
    TransactionManager: {
      transactions: state.transactions || [],
      gasMultiplier: state.gasMultiplier || 1
    }
  });

  delete newState.transactions;
  delete newState.gasMultiplier;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/007.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/006.js", {"@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/006.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 6;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = migrateState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function migrateState(state) {
  const keyringSubstate = state.KeyringController; // add new state

  const newState = _objectSpread(_objectSpread({}, state), {}, {
    PreferencesController: {
      selectedAddress: keyringSubstate.selectedAccount
    }
  }); // rm old state


  delete newState.KeyringController.selectedAccount;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/006.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/008.js", {"@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/008.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 8;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = _objectSpread(_objectSpread({}, state), {}, {
    NoticeController: {
      noticesList: state.noticesList || []
    }
  });

  delete newState.noticesList;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/008.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/029.js", {"../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","./fail-tx":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/fail-tx.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/029.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _transaction = require("../../../shared/constants/transaction");

var _failTx = _interopRequireDefault(require("./fail-tx"));

// next version number
const version = 29; // time

const seconds = 1000;
const minutes = 60 * seconds;
const hours = 60 * minutes;
const unacceptableDelay = 12 * hours;
/*

normalizes txParams on unconfirmed txs

*/

var _default = {
  version,
  migrate: (0, _failTx.default)(version, 'Stuck in approved state for too long.', txMeta => {
    const isApproved = txMeta.status === _transaction.TRANSACTION_STATUSES.APPROVED;
    const createdTime = txMeta.submittedTime;
    const now = Date.now();
    return isApproved && now - createdTime > unacceptableDelay;
  })
};
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/029.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/038.js", {"@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/038.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 38;
/**
 * The purpose of this migration is to assign all users to a test group for the fullScreenVsPopup a/b test
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    ABTestController: ABTestControllerState = {}
  } = state;
  const {
    abTests = {}
  } = ABTestControllerState;

  if (abTests.fullScreenVsPopup) {
    return state;
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    ABTestController: _objectSpread(_objectSpread({}, ABTestControllerState), {}, {
      abTests: _objectSpread(_objectSpread({}, abTests), {}, {
        fullScreenVsPopup: 'control'
      })
    })
  });
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/038.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/048.js", {"@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/048.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 48;
/**
 * 1.  Delete NetworkController.settings
 * 2a. Migrate NetworkController.provider to Rinkeby if set to type 'rpc' or
 *     'localhost'.
 * 2b. Re-key provider.rpcTarget to provider.rpcUrl
 * 3.  Add localhost network to frequentRpcListDetail.
 * 4.  Delete CachedBalancesController.cachedBalances
 * 5.  Convert transactions metamaskNetworkId to decimal if they are hex
 * 6.  Convert address book keys from decimal to hex
 * 7.  Delete localhost key in IncomingTransactionsController
 * 8.  Merge 'localhost' tokens into 'rpc' tokens
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;
const hexRegEx = /^0x[0-9a-f]+$/iu;
const chainIdRegEx = /^0x[1-9a-f]+[0-9a-f]*$/iu;

function transformState(state = {}) {
  var _state$NetworkControl, _state$NetworkControl2, _state$NetworkControl3, _state$CachedBalances, _state$TransactionCon, _state$AddressBookCon, _state$IncomingTransa, _state$IncomingTransa2, _state$PreferencesCon;

  // 1. Delete NetworkController.settings
  (_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? true : delete _state$NetworkControl.settings; // 2. Migrate NetworkController.provider to Rinkeby or rename rpcTarget key

  const provider = ((_state$NetworkControl2 = state.NetworkController) === null || _state$NetworkControl2 === void 0 ? void 0 : _state$NetworkControl2.provider) || {};
  const isCustomRpcWithInvalidChainId = provider.type === 'rpc' && (typeof provider.chainId !== 'string' || !chainIdRegEx.test(provider.chainId));

  if (isCustomRpcWithInvalidChainId || provider.type === 'localhost') {
    state.NetworkController.provider = {
      type: 'rinkeby',
      rpcUrl: '',
      chainId: '0x4',
      nickname: '',
      rpcPrefs: {},
      ticker: 'ETH'
    };
  } else if ((_state$NetworkControl3 = state.NetworkController) !== null && _state$NetworkControl3 !== void 0 && _state$NetworkControl3.provider) {
    var _state$NetworkControl4, _state$NetworkControl5;

    if ('rpcTarget' in state.NetworkController.provider) {
      const rpcUrl = state.NetworkController.provider.rpcTarget;
      state.NetworkController.provider.rpcUrl = rpcUrl;
    }

    (_state$NetworkControl4 = state.NetworkController) === null || _state$NetworkControl4 === void 0 ? true : (_state$NetworkControl5 = _state$NetworkControl4.provider) === null || _state$NetworkControl5 === void 0 ? true : delete _state$NetworkControl5.rpcTarget;
  } // 3.  Add localhost network to frequentRpcListDetail.


  if (!state.PreferencesController) {
    state.PreferencesController = {};
  }

  if (!state.PreferencesController.frequentRpcListDetail) {
    state.PreferencesController.frequentRpcListDetail = [];
  }

  state.PreferencesController.frequentRpcListDetail.unshift({
    rpcUrl: 'http://localhost:8545',
    chainId: '0x539',
    ticker: 'ETH',
    nickname: 'Localhost 8545',
    rpcPrefs: {}
  }); // 4.  Delete CachedBalancesController.cachedBalances

  (_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? true : delete _state$CachedBalances.cachedBalances; // 5.  Convert transactions metamaskNetworkId to decimal if they are hex

  const transactions = (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;

  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      const metamaskNetworkId = transaction === null || transaction === void 0 ? void 0 : transaction.metamaskNetworkId;

      if (typeof metamaskNetworkId === 'string' && hexRegEx.test(metamaskNetworkId)) {
        transaction.metamaskNetworkId = parseInt(metamaskNetworkId, 16).toString(10);
      }
    });
  } // 6.  Convert address book keys from decimal to hex


  const addressBook = ((_state$AddressBookCon = state.AddressBookController) === null || _state$AddressBookCon === void 0 ? void 0 : _state$AddressBookCon.addressBook) || {};
  Object.keys(addressBook).forEach(networkKey => {
    if (/^\d+$/iu.test(networkKey)) {
      const chainId = `0x${parseInt(networkKey, 10).toString(16)}`;
      updateChainIds(addressBook[networkKey], chainId);

      if (addressBook[chainId]) {
        mergeAddressBookKeys(addressBook, networkKey, chainId);
      } else {
        addressBook[chainId] = addressBook[networkKey];
      }

      delete addressBook[networkKey];
    }
  }); // 7.  Delete localhost key in IncomingTransactionsController

  (_state$IncomingTransa = state.IncomingTransactionsController) === null || _state$IncomingTransa === void 0 ? true : (_state$IncomingTransa2 = _state$IncomingTransa.incomingTxLastFetchedBlocksByNetwork) === null || _state$IncomingTransa2 === void 0 ? true : delete _state$IncomingTransa2.localhost; // 8.  Merge 'localhost' tokens into 'rpc' tokens

  const accountTokens = (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.accountTokens;

  if (accountTokens) {
    Object.keys(accountTokens).forEach(account => {
      var _accountTokens$accoun, _accountTokens$accoun2;

      const localhostTokens = ((_accountTokens$accoun = accountTokens[account]) === null || _accountTokens$accoun === void 0 ? void 0 : _accountTokens$accoun.localhost) || [];

      if (localhostTokens.length > 0) {
        const rpcTokens = accountTokens[account].rpc || [];

        if (rpcTokens.length > 0) {
          accountTokens[account].rpc = mergeTokenArrays(localhostTokens, rpcTokens);
        } else {
          accountTokens[account].rpc = localhostTokens;
        }
      }

      (_accountTokens$accoun2 = accountTokens[account]) === null || _accountTokens$accoun2 === void 0 ? true : delete _accountTokens$accoun2.localhost;
    });
  }

  return state;
}
/**
 * Merges the two given keys for the given address book in place.
 *
 * @returns {void}
 */


function mergeAddressBookKeys(addressBook, networkKey, chainIdKey) {
  const networkKeyEntries = addressBook[networkKey] || {}; // For the new entries, start by copying the existing entries for the chainId

  const newEntries = _objectSpread({}, addressBook[chainIdKey]); // For each address of the old/networkId key entries


  Object.keys(networkKeyEntries).forEach(address => {
    if (newEntries[address] && typeof newEntries[address] === 'object') {
      const mergedEntry = {}; // Collect all keys from both entries and merge the corresponding chainId
      // entry with the networkId entry

      new Set([...Object.keys(newEntries[address]), ...Object.keys(networkKeyEntries[address] || {})]).forEach(key => {
        var _networkKeyEntries$ad;

        // Use non-empty value for the current key, if any
        mergedEntry[key] = newEntries[address][key] || ((_networkKeyEntries$ad = networkKeyEntries[address]) === null || _networkKeyEntries$ad === void 0 ? void 0 : _networkKeyEntries$ad[key]) || '';
      });
      newEntries[address] = mergedEntry;
    } else if (networkKeyEntries[address] && typeof networkKeyEntries[address] === 'object') {
      // If there is no corresponding chainId entry, just use the networkId entry
      // directly
      newEntries[address] = networkKeyEntries[address];
    }
  });
  addressBook[chainIdKey] = newEntries;
}
/**
 * Updates the chainId key values to the given chainId in place for all values
 * of the given networkEntries object.
 *
 * @returns {void}
 */


function updateChainIds(networkEntries, chainId) {
  Object.values(networkEntries).forEach(entry => {
    if (entry && typeof entry === 'object') {
      entry.chainId = chainId;
    }
  });
}
/**
 * Merges the two given, non-empty arrays of token objects and returns a new
 * array.
 *
 * @returns {Array<Object>}
 */


function mergeTokenArrays(localhostTokens, rpcTokens) {
  const localhostTokensMap = tokenArrayToMap(localhostTokens);
  const rpcTokensMap = tokenArrayToMap(rpcTokens);
  const mergedTokens = [];
  new Set([...Object.keys(localhostTokensMap), ...Object.keys(rpcTokensMap)]).forEach(tokenAddress => {
    mergedTokens.push(_objectSpread(_objectSpread({}, localhostTokensMap[tokenAddress]), rpcTokensMap[tokenAddress]));
  });
  return mergedTokens;

  function tokenArrayToMap(array) {
    return array.reduce((map, token) => {
      if (token !== null && token !== void 0 && token.address && typeof (token === null || token === void 0 ? void 0 : token.address) === 'string') {
        map[token.address] = token;
      }

      return map;
    }, {});
  }
}


      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/048.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/053.js", {"../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/053.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 53;
/**
 * Deprecate transactionCategory and consolidate on 'type'
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon, _state$IncomingTransa;

  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  const incomingTransactions = state === null || state === void 0 ? void 0 : (_state$IncomingTransa = state.IncomingTransactionsController) === null || _state$IncomingTransa === void 0 ? void 0 : _state$IncomingTransa.incomingTransactions;

  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      if (transaction) {
        if (transaction.type !== _transaction.TRANSACTION_TYPES.RETRY && transaction.type !== _transaction.TRANSACTION_TYPES.CANCEL) {
          transaction.type = transaction.transactionCategory;
        }

        delete transaction.transactionCategory;
      }
    });
  }

  if (incomingTransactions) {
    const incomingTransactionsEntries = Object.entries(incomingTransactions);
    incomingTransactionsEntries.forEach(([key, transaction]) => {
      if (transaction) {
        delete transaction.transactionCategory;
        state.IncomingTransactionsController.incomingTransactions[key] = _objectSpread(_objectSpread({}, transaction), {}, {
          type: _transaction.TRANSACTION_TYPES.INCOMING
        });
      }
    });
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/053.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/057.js", {"../../../shared/modules/random-id":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/random-id.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/057.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

const version = 57;
/**
 * replace 'incomingTxLastFetchedBlocksByNetwork' with 'incomingTxLastFetchedBlockByChainId'
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon;

  if (state !== null && state !== void 0 && (_state$TransactionCon = state.TransactionController) !== null && _state$TransactionCon !== void 0 && _state$TransactionCon.transactions && Array.isArray(state.TransactionController.transactions) && !state.TransactionController.transactions.some(item => typeof item !== 'object' || typeof item.txParams === 'undefined')) {
    state.TransactionController.transactions = (0, _lodash.keyBy)(state.TransactionController.transactions, // In case for some reason any of a user's transactions do not have an id
    // generate a new one for the transaction.
    tx => {
      if (typeof tx.id === 'undefined' || tx.id === null) {
        // This mutates the item in the array, so will result in a change to
        // the state.
        tx.id = (0, _randomId.default)();
      }

      return tx.id;
    });
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/057.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/063.js", {"@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/063.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 63;
/**
 * Moves token state from preferences controller to TokensController
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$PreferencesCon, _state$PreferencesCon2, _state$PreferencesCon3, _state$PreferencesCon4, _state$PreferencesCon5, _state$PreferencesCon6, _state$PreferencesCon7, _state$PreferencesCon8;

  const accountTokens = state === null || state === void 0 ? void 0 : (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.accountTokens;
  const accountHiddenTokens = state === null || state === void 0 ? void 0 : (_state$PreferencesCon2 = state.PreferencesController) === null || _state$PreferencesCon2 === void 0 ? void 0 : _state$PreferencesCon2.accountHiddenTokens;
  const newAllTokens = {};

  if (accountTokens) {
    Object.keys(accountTokens).forEach(accountAddress => {
      Object.keys(accountTokens[accountAddress]).forEach(chainId => {
        const tokensArray = accountTokens[accountAddress][chainId];

        if (newAllTokens[chainId] === undefined) {
          newAllTokens[chainId] = {
            [accountAddress]: tokensArray
          };
        } else {
          newAllTokens[chainId] = _objectSpread(_objectSpread({}, newAllTokens[chainId]), {}, {
            [accountAddress]: tokensArray
          });
        }
      });
    });
  }

  const newAllIgnoredTokens = {};

  if (accountHiddenTokens) {
    Object.keys(accountHiddenTokens).forEach(accountAddress => {
      Object.keys(accountHiddenTokens[accountAddress]).forEach(chainId => {
        const ignoredTokensArray = accountHiddenTokens[accountAddress][chainId];

        if (newAllIgnoredTokens[chainId] === undefined) {
          newAllIgnoredTokens[chainId] = {
            [accountAddress]: ignoredTokensArray
          };
        } else {
          newAllIgnoredTokens[chainId] = _objectSpread(_objectSpread({}, newAllIgnoredTokens[chainId]), {}, {
            [accountAddress]: ignoredTokensArray
          });
        }
      });
    });
  }

  if (state.TokensController) {
    state.TokensController.allTokens = newAllTokens;
    state.TokensController.allIgnoredTokens = newAllIgnoredTokens;
  } else {
    state.TokensController = {
      allTokens: newAllTokens,
      allIgnoredTokens: newAllIgnoredTokens
    };
  }

  state === null || state === void 0 ? true : (_state$PreferencesCon3 = state.PreferencesController) === null || _state$PreferencesCon3 === void 0 ? true : delete _state$PreferencesCon3.accountHiddenTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon4 = state.PreferencesController) === null || _state$PreferencesCon4 === void 0 ? true : delete _state$PreferencesCon4.accountTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon5 = state.PreferencesController) === null || _state$PreferencesCon5 === void 0 ? true : delete _state$PreferencesCon5.assetImages;
  state === null || state === void 0 ? true : (_state$PreferencesCon6 = state.PreferencesController) === null || _state$PreferencesCon6 === void 0 ? true : delete _state$PreferencesCon6.hiddenTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon7 = state.PreferencesController) === null || _state$PreferencesCon7 === void 0 ? true : delete _state$PreferencesCon7.tokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon8 = state.PreferencesController) === null || _state$PreferencesCon8 === void 0 ? true : delete _state$PreferencesCon8.suggestedTokens;
  return state;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/063.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/067.js", {"../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","bignumber.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bignumber.js/bignumber.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/067.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _network = require("../../../shared/constants/network");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const hexNumberIsGreaterThanZero = hexNumber => new _bignumber.default(hexNumber || '0x0', 16).gt(0);

const version = 67;
/**
 * Sets the showTestNetworks property to true if it was false or undefined, and there is evidence
 * that the user has used a test net
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon, _state$NetworkControl, _state$CachedBalances;

  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  const preferences = PreferencesController.preferences || {};

  if (preferences.showTestNetworks) {
    return state;
  }

  const transactions = (state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions) || {};
  const provider = ((_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? void 0 : _state$NetworkControl.provider) || {};
  const cachedBalances = ((_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? void 0 : _state$CachedBalances.cachedBalances) || {};

  const userIsCurrentlyOnATestNet = _network.TEST_CHAINS.includes(provider === null || provider === void 0 ? void 0 : provider.chainId);

  const userHasMadeATestNetTransaction = Object.values(transactions).some(({
    chainId
  }) => _network.TEST_CHAINS.includes(chainId));

  const userHasACachedBalanceOnATestnet = _network.TEST_CHAINS.some(chainId => {
    const cachedBalancesForChain = Object.values(cachedBalances[chainId] || {});
    const userHasABalanceGreaterThanZeroOnThisChain = cachedBalancesForChain.some(hexNumberIsGreaterThanZero);
    return userHasABalanceGreaterThanZeroOnThisChain;
  });

  const userHasUsedATestnet = userIsCurrentlyOnATestNet || userHasMadeATestNetTransaction || userHasACachedBalanceOnATestnet;

  const newState = _objectSpread(_objectSpread({}, state), {}, {
    PreferencesController: _objectSpread(_objectSpread({}, PreferencesController), {}, {
      preferences: _objectSpread(_objectSpread({}, preferences), {}, {
        showTestNetworks: userHasUsedATestnet
      })
    })
  });

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/067.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/066.js", {"../../../shared/constants/hardware-wallets":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/hardware-wallets.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/066.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

var _hardwareWallets = require("../../../shared/constants/hardware-wallets");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 66;
/**
 * Changes the useLedgerLive boolean property to the ledgerTransportType enum
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$PreferencesCon;

  const defaultTransportType = window.navigator.hid ? _hardwareWallets.LEDGER_TRANSPORT_TYPES.WEBHID : _hardwareWallets.LEDGER_TRANSPORT_TYPES.U2F;
  const useLedgerLive = Boolean((_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.useLedgerLive);

  const newState = _objectSpread(_objectSpread({}, state), {}, {
    PreferencesController: _objectSpread(_objectSpread({}, state === null || state === void 0 ? void 0 : state.PreferencesController), {}, {
      ledgerTransportType: useLedgerLive ? _hardwareWallets.LEDGER_TRANSPORT_TYPES.LIVE : defaultTransportType
    })
  });

  delete newState.PreferencesController.useLedgerLive;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/066.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/068.js", {"@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/helpers/objectWithoutProperties":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/objectWithoutProperties.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/068.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _lodash = require("lodash");

const _excluded = ["PermissionsController", "PermissionsMetadata"],
      _excluded2 = ["name", "icon", "extensionId"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 68;
/**
 * Transforms the PermissionsController and PermissionsMetadata substates
 * to match the new permission system.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PermissionsController = {},
    PermissionsMetadata = {}
  } = state,
        remainingState = (0, _objectWithoutProperties2.default)(state, _excluded);
  const {
    domainMetadata = {},
    permissionsHistory = {},
    permissionsLog = []
  } = PermissionsMetadata;
  return _objectSpread(_objectSpread({}, remainingState), {}, {
    PermissionController: getPermissionControllerState(PermissionsController),
    PermissionLogController: {
      permissionActivityLog: permissionsLog,
      permissionHistory: permissionsHistory
    },
    SubjectMetadataController: getSubjectMetadataControllerState(domainMetadata)
  });
}

function getPermissionControllerState(PermissionsController) {
  const {
    domains = {}
  } = PermissionsController;
  /**
   * Example existing domain entry. Every existing domain will have a single
   * eth_accounts permission, which simplifies the transform.
   *
   * 'https://metamask.github.io': {
   *   permissions: [
   *     {
   *       '@context': ['https://github.com/MetaMask/rpc-cap'],
   *       'caveats': [
   *         {
   *           name: 'primaryAccountOnly',
   *           type: 'limitResponseLength',
   *           value: 1,
   *         },
   *         {
   *           name: 'exposedAccounts',
   *           type: 'filterResponse',
   *           value: ['0x0c97a5c81e50a02ff8be73cc3f0a0569e61f4ed8'],
   *         },
   *       ],
   *       'date': 1616006369498,
   *       'id': '3d0bdc27-e8e4-4fb0-a24b-340d61f6a3fa',
   *       'invoker': 'https://metamask.github.io',
   *       'parentCapability': 'eth_accounts',
   *     },
   *   ],
   * },
   */

  const ETH_ACCOUNTS = 'eth_accounts';
  const NEW_CAVEAT_TYPE = 'restrictReturnedAccounts';
  const OLD_CAVEAT_NAME = 'exposedAccounts';
  const subjects = Object.entries(domains).reduce((transformed, [origin, domainEntry]) => {
    const {
      permissions: [ethAccountsPermission]
    } = domainEntry; // There are two caveats for each eth_accounts permission, but we only
    // need the value of one of them in the new permission system.

    const oldCaveat = ethAccountsPermission.caveats.find(caveat => caveat.name === OLD_CAVEAT_NAME);

    const newPermission = _objectSpread(_objectSpread({}, ethAccountsPermission), {}, {
      caveats: [{
        type: NEW_CAVEAT_TYPE,
        value: oldCaveat.value
      }]
    }); // We never used this, and just omit it in the new system.


    delete newPermission['@context'];
    transformed[origin] = {
      origin,
      permissions: {
        [ETH_ACCOUNTS]: newPermission
      }
    };
    return transformed;
  }, {});
  return {
    subjects
  };
}

function getSubjectMetadataControllerState(domainMetadata) {
  /**
   * Example existing domainMetadata entry.
   *
   * "https://www.youtube.com": {
   *   "host": "www.youtube.com",
   *   "icon": null,
   *   "lastUpdated": 1637697914908,
   *   "name": "YouTube"
   * }
   */
  const subjectMetadata = Object.entries(domainMetadata).reduce((transformed, [origin, metadata]) => {
    const {
      name = null,
      icon = null,
      extensionId = null
    } = metadata,
          other = (0, _objectWithoutProperties2.default)(metadata, _excluded2); // We're getting rid of these.

    delete other.lastUpdated;
    delete other.host;

    if (origin) {
      transformed[origin] = _objectSpread(_objectSpread({
        name,
        iconUrl: icon,
        extensionId
      }, other), {}, {
        origin
      });
    }

    return transformed;
  }, {});
  return {
    subjectMetadata
  };
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/068.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/018.js", {"../controllers/transactions/lib/tx-state-history-helpers":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/lib/tx-state-history-helpers.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/018.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _txStateHistoryHelpers = require("../controllers/transactions/lib/tx-state-history-helpers");

/*

This migration updates "transaction state history" to diffs style

*/
const version = 18;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      // no history: initialize
      if (!txMeta.history || txMeta.history.length === 0) {
        const snapshot = (0, _txStateHistoryHelpers.snapshotFromTxMeta)(txMeta);
        txMeta.history = [snapshot];
        return txMeta;
      } // has history: migrate


      const newHistory = (0, _txStateHistoryHelpers.migrateFromSnapshotsToDiffs)(txMeta.history) // remove empty diffs
      .filter(entry => {
        return !Array.isArray(entry) || entry.length > 0;
      });
      txMeta.history = newHistory;
      return txMeta;
    });
  }

  return newState;
}


      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/018.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/base32-encode/index.js", {"to-data-view":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/to-data-view/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/base32-encode/index.js
      return function (require, module, exports) {
var toDataView = require('to-data-view')

var RFC4648 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'
var RFC4648_HEX = '0123456789ABCDEFGHIJKLMNOPQRSTUV'
var CROCKFORD = '0123456789ABCDEFGHJKMNPQRSTVWXYZ'

module.exports = function base32Encode (data, variant, options) {
  options = options || {}
  var alphabet, defaultPadding

  switch (variant) {
    case 'RFC3548':
    case 'RFC4648':
      alphabet = RFC4648
      defaultPadding = true
      break
    case 'RFC4648-HEX':
      alphabet = RFC4648_HEX
      defaultPadding = true
      break
    case 'Crockford':
      alphabet = CROCKFORD
      defaultPadding = false
      break
    default:
      throw new Error('Unknown base32 variant: ' + variant)
  }

  var padding = (options.padding !== undefined ? options.padding : defaultPadding)
  var view = toDataView(data)

  var bits = 0
  var value = 0
  var output = ''

  for (var i = 0; i < view.byteLength; i++) {
    value = (value << 8) | view.getUint8(i)
    bits += 8

    while (bits >= 5) {
      output += alphabet[(value >>> (bits - 5)) & 31]
      bits -= 5
    }
  }

  if (bits > 0) {
    output += alphabet[(value << (5 - bits)) & 31]
  }

  if (padding) {
    while ((output.length % 8) !== 0) {
      output += '='
    }
  }

  return output
}

      };
    };
  }
}, {package:"base32-encode",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base32-encode/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/resolver.js", {"./contracts/registry":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/contracts/registry.js","./contracts/resolver":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/contracts/resolver.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@ensdomains/content-hash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/src/index.js","eth-ens-namehash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-ens-namehash/index.js","ethjs-contract":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-contract/lib/index.js","ethjs-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-query/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/resolver.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = resolveEnsToIpfsContentId;

var _ethEnsNamehash = _interopRequireDefault(require("eth-ens-namehash"));

var _ethjsQuery = _interopRequireDefault(require("ethjs-query"));

var _ethjsContract = _interopRequireDefault(require("ethjs-contract"));

var _contentHash = _interopRequireDefault(require("@ensdomains/content-hash"));

var _registry = _interopRequireDefault(require("./contracts/registry"));

var _resolver = _interopRequireDefault(require("./contracts/resolver"));

async function resolveEnsToIpfsContentId({
  provider,
  name
}) {
  const eth = new _ethjsQuery.default(provider);

  const hash = _ethEnsNamehash.default.hash(name);

  const contract = new _ethjsContract.default(eth); // lookup registry

  const chainId = Number.parseInt(await eth.net_version(), 10);
  const registryAddress = getRegistryForChainId(chainId);

  if (!registryAddress) {
    throw new Error(`EnsIpfsResolver - no known ens-ipfs registry for chainId "${chainId}"`);
  }

  const Registry = contract(_registry.default).at(registryAddress); // lookup resolver

  const resolverLookupResult = await Registry.resolver(hash);
  const resolverAddress = resolverLookupResult[0];

  if (hexValueIsEmpty(resolverAddress)) {
    throw new Error(`EnsIpfsResolver - no resolver found for name "${name}"`);
  }

  const Resolver = contract(_resolver.default).at(resolverAddress);
  const isEIP1577Compliant = await Resolver.supportsInterface('0xbc1c58d1');
  const isLegacyResolver = await Resolver.supportsInterface('0xd8389dc5');

  if (isEIP1577Compliant[0]) {
    const contentLookupResult = await Resolver.contenthash(hash);
    const rawContentHash = contentLookupResult[0];

    let decodedContentHash = _contentHash.default.decode(rawContentHash);

    const type = _contentHash.default.getCodec(rawContentHash);

    if (type === 'ipfs-ns' || type === 'ipns-ns') {
      decodedContentHash = _contentHash.default.helpers.cidV0ToV1Base32(decodedContentHash);
    }

    return {
      type,
      hash: decodedContentHash
    };
  }

  if (isLegacyResolver[0]) {
    // lookup content id
    const contentLookupResult = await Resolver.content(hash);
    const content = contentLookupResult[0];

    if (hexValueIsEmpty(content)) {
      throw new Error(`EnsIpfsResolver - no content ID found for name "${name}"`);
    }

    return {
      type: 'swarm-ns',
      hash: content.slice(2)
    };
  }

  throw new Error(`EnsIpfsResolver - the resolver for name "${name}" is not standard, it should either supports contenthash() or content()`);
}

function hexValueIsEmpty(value) {
  return [undefined, null, '0x', '0x0', '0x0000000000000000000000000000000000000000000000000000000000000000'].includes(value);
}
/**
 * Returns the registry address for the given chain ID
 * @param {number} chainId - the chain ID
 * @returns {string|null} the registry address if known, null otherwise
 */


function getRegistryForChainId(chainId) {
  switch (chainId) {
    case 1:
    case 3:
    case 4:
    case 5:
      // Mainnet, Ropsten, Rinkeby, and Goerli, respectively, use the same address
      return '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e';

    default:
      return null;
  }
}


      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/resolver.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createOriginMiddleware.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createOriginMiddleware.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createOriginMiddleware;

/**
 * Returns a middleware that appends the DApp origin to request
 * @param {{ origin: string }} opts - The middleware options
 * @returns {Function}
 */
function createOriginMiddleware(opts) {
  return function originMiddleware(
  /** @type {any} */
  req,
  /** @type {any} */
  _,
  /** @type {Function} */
  next) {
    req.origin = opts.origin;
    next();
  };
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createOriginMiddleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createTabIdMiddleware.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createTabIdMiddleware.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTabIdMiddleware;

/**
 * Returns a middleware that appends the DApp TabId to the request
 * @param {{ tabId: number }} opts - The middleware options
 * @returns {Function}
 */
function createTabIdMiddleware(opts) {
  return function tabIdMiddleware(
  /** @type {any} */
  req,
  /** @type {any} */
  _,
  /** @type {Function} */
  next) {
    req.tabId = opts.tabId;
    next();
  };
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createTabIdMiddleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/nanoid/index.browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/nanoid/index.browser.js
      return function (require, module, exports) {
// This file replaces `index.js` in bundlers like webpack or Rollup,
// according to `browser` config in `package.json`.

if ("development" !== 'production') {
  // All bundlers will remove this block in production bundle
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    throw new Error(
      'React Native does not have a built-in secure random generator. ' +
      'If you dont need unpredictable IDs, you can use `nanoid/non-secure`. ' +
      'For secure ID install `expo-random` locally and use `nanoid/async`.'
    )
  }
  if (typeof self === 'undefined' || (!self.crypto && !self.msCrypto)) {
    throw new Error(
      'Your browser does not have secure random generator. ' +
      'If you dont need unpredictable IDs, you can use nanoid/non-secure.'
    )
  }
}

var crypto = self.crypto || self.msCrypto

// This alphabet uses a-z A-Z 0-9 _- symbols.
// Symbols are generated for smaller size.
// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA
var url = '-_'
// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).
var i = 36
while (i--) {
  // 36 is radix. Number.prototype.toString(36) returns number
  // in Base36 representation. Base36 is like hex, but it uses 09 and a-z.
  url += i.toString(36)
}
// Loop from 36 to 10 (from Z to A in Base36).
i = 36
while (i-- - 10) {
  url += i.toString(36).toUpperCase()
}

module.exports = function (size) {
  var id = ''
  var bytes = crypto.getRandomValues(new Uint8Array(size || 21))
  i = size || 21

  // Compact alternative for `for (var i = 0; i < size; i++)`
  while (i--) {
    // We cant use bytes bigger than the alphabet. 63 is 00111111 bitmask.
    // This mask reduces random byte 0-255 to 0-63 values.
    // There is no need in `|| ''` and `* 1.6` hacks in here,
    // because bitmask trim bytes exact to alphabet size.
    id += url[bytes[i] & 63]
  }
  return id
}

      };
    };
  }
}, {package:"nanoid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/nanoid/index.browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createMetaRPCHandler.js", {"eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createMetaRPCHandler.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethRpcErrors = require("eth-rpc-errors");

const createMetaRPCHandler = (api, outStream) => {
  return async data => {
    if (outStream._writableState.ended) {
      return;
    }

    if (!api[data.method]) {
      outStream.write({
        jsonrpc: '2.0',
        error: _ethRpcErrors.ethErrors.rpc.methodNotFound({
          message: `${data.method} not found`
        }),
        id: data.id
      });
      return;
    }

    let result;
    let error;

    try {
      result = await api[data.method](...data.params);
    } catch (err) {
      error = err;
    }

    if (outStream._writableState.ended) {
      if (error) {
        console.error(error);
      }

      return;
    }

    if (error) {
      outStream.write({
        jsonrpc: '2.0',
        error: (0, _ethRpcErrors.serializeError)(error, {
          shouldIncludeStack: true
        }),
        id: data.id
      });
    } else {
      outStream.write({
        jsonrpc: '2.0',
        result,
        id: data.id
      });
    }
  };
};

var _default = createMetaRPCHandler;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createMetaRPCHandler.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-middleware-stream/engineStream.js", {"readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-middleware-stream/engineStream.js
      return function (require, module, exports) {
const DuplexStream = require('readable-stream').Duplex

module.exports = createEngineStream

function createEngineStream({ engine }) {
  if (!engine) throw new Error('Missing engine parameter!')
  const stream = new DuplexStream({ objectMode: true, read, write })
  // forward notifications
  if (engine.on) {
    engine.on('notification', (message) => {
      stream.push(message)
    })
  }
  return stream

  function read () {
    return false
  }
  function write (req, encoding, cb) {
    engine.handle(req, (err, res) => {
      this.push(res)
    })
    cb()
  }
}

      };
    };
  }
}, {package:"json-rpc-middleware-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-middleware-stream/engineStream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ComposableObservableStore.js", {"@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/controllers/dist/index.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ComposableObservableStore.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _obsStore = require("@metamask/obs-store");

var _controllers = require("@metamask/controllers");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @typedef {__import__('@metamask/controllers').ControllerMessenger} ControllerMessenger
 */

/**
 * An ObservableStore that can composes a flat
 * structure of child stores based on configuration
 */
class ComposableObservableStore extends _obsStore.ObservableStore {
  /**
   * Describes which stores are being composed. The key is the name of the
   * store, and the value is either an ObserableStore, or a controller that
   * extends one of the two base controllers in the `@metamask/controllers`
   * package.
   * @type {Record<string, Object>}
   */

  /**
   * Create a new store
   *
   * @param {Object} options
   * @param {Object} [options.config] - Map of internal state keys to child stores
   * @param {ControllerMessenger} options.controllerMessenger - The controller
   *   messenger, used for subscribing to events from BaseControllerV2-based
   *   controllers.
   * @param {Object} [options.state] - The initial store state
   * @param {boolean} [options.persist] - Wether or not to apply the persistence for v2 controllers
   */
  constructor({
    config,
    controllerMessenger,
    state,
    persist
  }) {
    super(state);
    (0, _defineProperty2.default)(this, "config", {});
    this.persist = persist;
    this.controllerMessenger = controllerMessenger;

    if (config) {
      this.updateStructure(config);
    }
  }
  /**
   * Composes a new internal store subscription structure
   *
   * @param {Record<string, Object>} config - Describes which stores are being
   *   composed. The key is the name of the store, and the value is either an
   *   ObserableStore, or a controller that extends one of the two base
   *   controllers in the `@metamask/controllers` package.
   */


  updateStructure(config) {
    this.config = config;
    this.removeAllListeners();

    for (const key of Object.keys(config)) {
      if (!config[key]) {
        throw new Error(`Undefined '${key}'`);
      }

      const store = config[key];

      if (store.subscribe) {
        config[key].subscribe(state => {
          this.updateState({
            [key]: state
          });
        });
      } else {
        this.controllerMessenger.subscribe(`${store.name}:stateChange`, state => {
          let updatedState = state;

          if (this.persist) {
            updatedState = (0, _controllers.getPersistentState)(state, config[key].metadata);
          }

          this.updateState({
            [key]: updatedState
          });
        });
      }
    }
  }
  /**
   * Merges all child store state into a single object rather than
   * returning an object keyed by child store class name
   *
   * @returns {Object} Object containing merged child store state
   */


  getFlatState() {
    if (!this.config) {
      return {};
    }

    let flatState = {};

    for (const key of Object.keys(this.config)) {
      const controller = this.config[key];
      const state = controller.getState ? controller.getState() : controller.state;
      flatState = _objectSpread(_objectSpread({}, flatState), state);
    }

    return flatState;
  }

}

exports.default = ComposableObservableStore;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ComposableObservableStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createLoggerMiddleware.js", {"@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createLoggerMiddleware.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createLoggerMiddleware;

var _loglevel = _interopRequireDefault(require("loglevel"));

/**
 * Returns a middleware that logs RPC activity
 * @param {{ origin: string }} opts - The middleware options
 * @returns {Function}
 */
function createLoggerMiddleware(opts) {
  return function loggerMiddleware(
  /** @type {any} */
  req,
  /** @type {any} */
  res,
  /** @type {Function} */
  next) {
    next((
    /** @type {Function} */
    cb) => {
      if (res.error) {
        _loglevel.default.error('Error in RPC response:\n', res);
      }

      if (req.isMetamaskInternal) {
        return;
      }

      _loglevel.default.info(`RPC (${opts.origin}):`, req, '->', res);

      cb();
    });
  };
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createLoggerMiddleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createOnboardingMiddleware.js", {"@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","extensionizer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/extensionizer/index.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createOnboardingMiddleware.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createOnboardingMiddleware;

var _loglevel = _interopRequireDefault(require("loglevel"));

var _extensionizer = _interopRequireDefault(require("extensionizer"));

/**
 * Returns a middleware that intercepts `wallet_registerOnboarding` messages
 * @param {{ location: string, registerOnboarding: Function }} opts - The middleware options
 * @returns {(req: any, res: any, next: Function, end: Function) => void}
 */
function createOnboardingMiddleware({
  location,
  registerOnboarding
}) {
  return async function originMiddleware(req, res, next, end) {
    try {
      if (req.method !== 'wallet_registerOnboarding') {
        next();
        return;
      }

      if (req.tabId && req.tabId !== _extensionizer.default.tabs.TAB_ID_NONE) {
        await registerOnboarding(location, req.tabId);
      } else {
        _loglevel.default.debug(`'wallet_registerOnboarding' message from ${location} ignored due to missing tabId`);
      }

      res.result = true;
      end();
    } catch (error) {
      end(error);
    }
  };
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createOnboardingMiddleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/app-state.js", {"../../../shared/constants/time":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/time.js","../metamask-controller":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/metamask-controller.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/app-state.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _events = _interopRequireDefault(require("events"));

var _obsStore = require("@metamask/obs-store");

var _metamaskController = require("../metamask-controller");

var _time = require("../../../shared/constants/time");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class AppStateController extends _events.default {
  /**
   * @constructor
   * @param {Object} opts
   */
  constructor(opts = {}) {
    const {
      addUnlockListener,
      isUnlocked,
      initState,
      onInactiveTimeout,
      showUnlockRequest,
      preferencesStore,
      qrHardwareStore
    } = opts;
    super();

    this.onInactiveTimeout = onInactiveTimeout || (() => undefined);

    this.store = new _obsStore.ObservableStore(_objectSpread(_objectSpread({
      timeoutMinutes: 0,
      connectedStatusPopoverHasBeenShown: true,
      defaultHomeActiveTabName: null,
      browserEnvironment: {},
      popupGasPollTokens: [],
      notificationGasPollTokens: [],
      fullScreenGasPollTokens: [],
      recoveryPhraseReminderHasBeenShown: false,
      recoveryPhraseReminderLastShown: new Date().getTime(),
      collectiblesDetectionNoticeDismissed: false,
      showTestnetMessageInDropdown: true,
      trezorModel: null
    }, initState), {}, {
      qrHardware: {}
    }));
    this.timer = null;
    this.isUnlocked = isUnlocked;
    this.waitingForUnlock = [];
    addUnlockListener(this.handleUnlock.bind(this));
    this._showUnlockRequest = showUnlockRequest;
    preferencesStore.subscribe(({
      preferences
    }) => {
      const currentState = this.store.getState();

      if (currentState.timeoutMinutes !== preferences.autoLockTimeLimit) {
        this._setInactiveTimeout(preferences.autoLockTimeLimit);
      }
    });
    qrHardwareStore.subscribe(state => {
      this.store.updateState({
        qrHardware: state
      });
    });
    const {
      preferences
    } = preferencesStore.getState();

    this._setInactiveTimeout(preferences.autoLockTimeLimit);
  }
  /**
   * Get a Promise that resolves when the extension is unlocked.
   * This Promise will never reject.
   *
   * @param {boolean} shouldShowUnlockRequest - Whether the extension notification
   * popup should be opened.
   * @returns {Promise<void>} A promise that resolves when the extension is
   * unlocked, or immediately if the extension is already unlocked.
   */


  getUnlockPromise(shouldShowUnlockRequest) {
    return new Promise(resolve => {
      if (this.isUnlocked()) {
        resolve();
      } else {
        this.waitForUnlock(resolve, shouldShowUnlockRequest);
      }
    });
  }
  /**
   * Adds a Promise's resolve function to the waitingForUnlock queue.
   * Also opens the extension popup if specified.
   *
   * @param {Promise.resolve} resolve - A Promise's resolve function that will
   * be called when the extension is unlocked.
   * @param {boolean} shouldShowUnlockRequest - Whether the extension notification
   * popup should be opened.
   */


  waitForUnlock(resolve, shouldShowUnlockRequest) {
    this.waitingForUnlock.push({
      resolve
    });
    this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);

    if (shouldShowUnlockRequest) {
      this._showUnlockRequest();
    }
  }
  /**
   * Drains the waitingForUnlock queue, resolving all the related Promises.
   */


  handleUnlock() {
    if (this.waitingForUnlock.length > 0) {
      while (this.waitingForUnlock.length > 0) {
        this.waitingForUnlock.shift().resolve();
      }

      this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
    }
  }
  /**
   * Sets the default home tab
   * @param {string} [defaultHomeActiveTabName] - the tab name
   */


  setDefaultHomeActiveTabName(defaultHomeActiveTabName) {
    this.store.updateState({
      defaultHomeActiveTabName
    });
  }
  /**
   * Record that the user has seen the connected status info popover
   */


  setConnectedStatusPopoverHasBeenShown() {
    this.store.updateState({
      connectedStatusPopoverHasBeenShown: true
    });
  }
  /**
   * Record that the user has been shown the recovery phrase reminder
   * @returns {void}
   */


  setRecoveryPhraseReminderHasBeenShown() {
    this.store.updateState({
      recoveryPhraseReminderHasBeenShown: true
    });
  }
  /**
   * Record the timestamp of the last time the user has seen the recovery phrase reminder
   * @param {number} lastShown - timestamp when user was last shown the reminder
   * @returns {void}
   */


  setRecoveryPhraseReminderLastShown(lastShown) {
    this.store.updateState({
      recoveryPhraseReminderLastShown: lastShown
    });
  }
  /**
   * Sets the last active time to the current time
   * @returns {void}
   */


  setLastActiveTime() {
    this._resetTimer();
  }
  /**
   * Sets the inactive timeout for the app
   * @param {number} timeoutMinutes - the inactive timeout in minutes
   * @returns {void}
   * @private
   */


  _setInactiveTimeout(timeoutMinutes) {
    this.store.updateState({
      timeoutMinutes
    });

    this._resetTimer();
  }
  /**
   * Resets the internal inactive timer
   *
   * If the {@code timeoutMinutes} state is falsy (i.e., zero) then a new
   * timer will not be created.
   *
   * @returns {void}
   * @private
   */


  _resetTimer() {
    const {
      timeoutMinutes
    } = this.store.getState();

    if (this.timer) {
      clearTimeout(this.timer);
    }

    if (!timeoutMinutes) {
      return;
    }

    this.timer = setTimeout(() => this.onInactiveTimeout(), timeoutMinutes * _time.MINUTE);
  }
  /**
   * Sets the current browser and OS environment
   * @returns {void}
   */


  setBrowserEnvironment(os, browser) {
    this.store.updateState({
      browserEnvironment: {
        os,
        browser
      }
    });
  }
  /**
   * Adds a pollingToken for a given environmentType
   * @returns {void}
   */


  addPollingToken(pollingToken, pollingTokenType) {
    const prevState = this.store.getState()[pollingTokenType];
    this.store.updateState({
      [pollingTokenType]: [...prevState, pollingToken]
    });
  }
  /**
   * removes a pollingToken for a given environmentType
   * @returns {void}
   */


  removePollingToken(pollingToken, pollingTokenType) {
    const prevState = this.store.getState()[pollingTokenType];
    this.store.updateState({
      [pollingTokenType]: prevState.filter(token => token !== pollingToken)
    });
  }
  /**
   * clears all pollingTokens
   * @returns {void}
   */


  clearPollingTokens() {
    this.store.updateState({
      popupGasPollTokens: [],
      notificationGasPollTokens: [],
      fullScreenGasPollTokens: []
    });
  }
  /**
   * Sets whether the testnet dismissal link should be shown in the network dropdown
   * @returns {void}
   */


  setShowTestnetMessageInDropdown(showTestnetMessageInDropdown) {
    this.store.updateState({
      showTestnetMessageInDropdown
    });
  }
  /**
   * Sets a property indicating the model of the user's Trezor hardware wallet
   * @returns {void}
   */


  setTrezorModel(trezorModel) {
    this.store.updateState({
      trezorModel
    });
  }
  /**
   * A setter for the `collectiblesDetectionNoticeDismissed` property
   */


  setCollectiblesDetectionNoticeDismissed(collectiblesDetectionNoticeDismissed) {
    this.store.updateState({
      collectiblesDetectionNoticeDismissed
    });
  }

}

exports.default = AppStateController;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/app-state.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/cached-balances.js", {"@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/cached-balances.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _obsStore = require("@metamask/obs-store");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @typedef {Object} CachedBalancesOptions
 * @property {Object} accountTracker An {@code AccountTracker} reference
 * @property {Function} getCurrentChainId A function to get the current chain id
 * @property {Object} initState The initial controller state
 */

/**
 * Background controller responsible for maintaining
 * a cache of account balances in local storage
 */
class CachedBalancesController {
  /**
   * Creates a new controller instance
   *
   * @param {CachedBalancesOptions} [opts] - Controller configuration parameters
   */
  constructor(opts = {}) {
    const {
      accountTracker,
      getCurrentChainId
    } = opts;
    this.accountTracker = accountTracker;
    this.getCurrentChainId = getCurrentChainId;

    const initState = _objectSpread({
      cachedBalances: {}
    }, opts.initState);

    this.store = new _obsStore.ObservableStore(initState);

    this._registerUpdates();
  }
  /**
   * Updates the cachedBalances property for the current chain. Cached balances will be updated to those in the passed accounts
   * if balances in the passed accounts are truthy.
   *
   * @param {Object} obj - The the recently updated accounts object for the current chain
   * @returns {Promise<void>}
   */


  async updateCachedBalances({
    accounts
  }) {
    const chainId = this.getCurrentChainId();
    const balancesToCache = await this._generateBalancesToCache(accounts, chainId);
    this.store.updateState({
      cachedBalances: balancesToCache
    });
  }

  _generateBalancesToCache(newAccounts, chainId) {
    const {
      cachedBalances
    } = this.store.getState();

    const currentChainBalancesToCache = _objectSpread({}, cachedBalances[chainId]);

    Object.keys(newAccounts).forEach(accountID => {
      const account = newAccounts[accountID];

      if (account.balance) {
        currentChainBalancesToCache[accountID] = account.balance;
      }
    });

    const balancesToCache = _objectSpread(_objectSpread({}, cachedBalances), {}, {
      [chainId]: currentChainBalancesToCache
    });

    return balancesToCache;
  }
  /**
   * Removes cachedBalances
   */


  clearCachedBalances() {
    this.store.updateState({
      cachedBalances: {}
    });
  }
  /**
   * Sets up listeners and subscriptions which should trigger an update of cached balances. These updates will
   * happen when the current account changes. Which happens on block updates, as well as on network and account
   * selections.
   *
   * @private
   *
   */


  _registerUpdates() {
    const update = this.updateCachedBalances.bind(this);
    this.accountTracker.store.subscribe(update);
  }

}

exports.default = CachedBalancesController;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/cached-balances.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/alert.js", {"../../../shared/constants/alerts":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/alerts.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/alert.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _obsStore = require("@metamask/obs-store");

var _alerts = require("../../../shared/constants/alerts");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @typedef {Object} AlertControllerInitState
 * @property {Object} alertEnabledness - A map of alerts IDs to booleans, where
 * `true` indicates that the alert is enabled and shown, and `false` the opposite.
 * @property {Object} unconnectedAccountAlertShownOrigins - A map of origin
 * strings to booleans indicating whether the "switch to connected" alert has
 * been shown (`true`) or otherwise (`false`).
 */

/**
 * @typedef {Object} AlertControllerOptions
 * @property {AlertControllerInitState} initState - The initial controller state
 */
const defaultState = {
  alertEnabledness: _alerts.TOGGLEABLE_ALERT_TYPES.reduce((alertEnabledness, alertType) => {
    alertEnabledness[alertType] = true;
    return alertEnabledness;
  }, {}),
  unconnectedAccountAlertShownOrigins: {},
  web3ShimUsageOrigins: {}
};
/**
 * Controller responsible for maintaining alert-related state.
 */

class AlertController {
  /**
   * @constructor
   * @param {AlertControllerOptions} [opts] - Controller configuration parameters
   */
  constructor(opts = {}) {
    const {
      initState = {},
      preferencesStore
    } = opts;

    const state = _objectSpread(_objectSpread({}, defaultState), {}, {
      alertEnabledness: _objectSpread(_objectSpread({}, defaultState.alertEnabledness), initState.alertEnabledness)
    });

    this.store = new _obsStore.ObservableStore(state);
    this.selectedAddress = preferencesStore.getState().selectedAddress;
    preferencesStore.subscribe(({
      selectedAddress
    }) => {
      const currentState = this.store.getState();

      if (currentState.unconnectedAccountAlertShownOrigins && this.selectedAddress !== selectedAddress) {
        this.selectedAddress = selectedAddress;
        this.store.updateState({
          unconnectedAccountAlertShownOrigins: {}
        });
      }
    });
  }

  setAlertEnabledness(alertId, enabledness) {
    let {
      alertEnabledness
    } = this.store.getState();
    alertEnabledness = _objectSpread({}, alertEnabledness);
    alertEnabledness[alertId] = enabledness;
    this.store.updateState({
      alertEnabledness
    });
  }
  /**
   * Sets the "switch to connected" alert as shown for the given origin
   * @param {string} origin - The origin the alert has been shown for
   */


  setUnconnectedAccountAlertShown(origin) {
    let {
      unconnectedAccountAlertShownOrigins
    } = this.store.getState();
    unconnectedAccountAlertShownOrigins = _objectSpread({}, unconnectedAccountAlertShownOrigins);
    unconnectedAccountAlertShownOrigins[origin] = true;
    this.store.updateState({
      unconnectedAccountAlertShownOrigins
    });
  }
  /**
   * Gets the web3 shim usage state for the given origin.
   *
   * @param {string} origin - The origin to get the web3 shim usage state for.
   * @returns {undefined | 1 | 2} The web3 shim usage state for the given
   * origin, or undefined.
   */


  getWeb3ShimUsageState(origin) {
    return this.store.getState().web3ShimUsageOrigins[origin];
  }
  /**
   * Sets the web3 shim usage state for the given origin to RECORDED.
   *
   * @param {string} origin - The origin the that used the web3 shim.
   */


  setWeb3ShimUsageRecorded(origin) {
    this._setWeb3ShimUsageState(origin, _alerts.WEB3_SHIM_USAGE_ALERT_STATES.RECORDED);
  }
  /**
   * Sets the web3 shim usage state for the given origin to DISMISSED.
   *
   * @param {string} origin - The origin that the web3 shim notification was
   * dismissed for.
   */


  setWeb3ShimUsageAlertDismissed(origin) {
    this._setWeb3ShimUsageState(origin, _alerts.WEB3_SHIM_USAGE_ALERT_STATES.DISMISSED);
  }
  /**
   * @private
   * @param {string} origin - The origin to set the state for.
   * @param {number} value - The state value to set.
   */


  _setWeb3ShimUsageState(origin, value) {
    let {
      web3ShimUsageOrigins
    } = this.store.getState();
    web3ShimUsageOrigins = _objectSpread({}, web3ShimUsageOrigins);
    web3ShimUsageOrigins[origin] = value;
    this.store.updateState({
      web3ShimUsageOrigins
    });
  }

}

exports.default = AlertController;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/alert.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/onboarding.js", {"@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/onboarding.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _obsStore = require("@metamask/obs-store");

var _loglevel = _interopRequireDefault(require("loglevel"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @typedef {Object} InitState
 * @property {Boolean} seedPhraseBackedUp Indicates whether the user has completed the seed phrase backup challenge
 * @property {Boolean} completedOnboarding Indicates whether the user has completed the onboarding flow
 */

/**
 * @typedef {Object} OnboardingOptions
 * @property {InitState} initState The initial controller state
 */

/**
 * Controller responsible for maintaining
 * state related to onboarding
 */
class OnboardingController {
  /**
   * Creates a new controller instance
   *
   * @param {OnboardingOptions} [opts] Controller configuration parameters
   */
  constructor(opts = {}) {
    (0, _defineProperty2.default)(this, "registerOnboarding", async (location, tabId) => {
      if (this.completedOnboarding) {
        _loglevel.default.debug('Ignoring registerOnboarding; user already onboarded');

        return;
      }

      const onboardingTabs = _objectSpread({}, this.store.getState().onboardingTabs);

      if (!onboardingTabs[location] || onboardingTabs[location] !== tabId) {
        _loglevel.default.debug(`Registering onboarding tab at location '${location}' with tabId '${tabId}'`);

        onboardingTabs[location] = tabId;
        this.store.updateState({
          onboardingTabs
        });
      }
    });
    const initialTransientState = {
      onboardingTabs: {}
    };

    const initState = _objectSpread(_objectSpread({
      seedPhraseBackedUp: null,
      firstTimeFlowType: null,
      completedOnboarding: false
    }, opts.initState), initialTransientState);

    this.store = new _obsStore.ObservableStore(initState);
  }

  setSeedPhraseBackedUp(newSeedPhraseBackUpState) {
    this.store.updateState({
      seedPhraseBackedUp: newSeedPhraseBackUpState
    });
  } // /**
  //  * Sets the completedOnboarding state to true, indicating that the user has completed the
  //  * onboarding process.
  //  */


  completeOnboarding() {
    this.store.updateState({
      completedOnboarding: true
    });
    return Promise.resolve(true);
  }
  /**
   * Setter for the `firstTimeFlowType` property
   *
   * @param {string} type - Indicates the type of first time flow - create or import - the user wishes to follow
   *
   */


  setFirstTimeFlowType(type) {
    this.store.updateState({
      firstTimeFlowType: type
    });
  }
  /**
   * Registering a site as having initiated onboarding
   *
   * @param {string} location - The location of the site registering
   * @param {string} tabId - The id of the tab registering
   */


}

exports.default = OnboardingController;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/onboarding.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/incoming-transactions.js", {"../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","../../../shared/constants/time":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/time.js","../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","../../../shared/modules/fetch-with-timeout":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/fetch-with-timeout.js","../../../shared/modules/random-id":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/random-id.js","../lib/util":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/util.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/incoming-transactions.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _obsStore = require("@metamask/obs-store");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _bn = _interopRequireDefault(require("bn.js"));

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

var _util = require("../lib/util");

var _fetchWithTimeout = _interopRequireDefault(require("../../../shared/modules/fetch-with-timeout"));

var _transaction = require("../../../shared/constants/transaction");

var _network = require("../../../shared/constants/network");

var _time = require("../../../shared/constants/time");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const fetchWithTimeout = (0, _fetchWithTimeout.default)(_time.SECOND * 30);
/**
 * @typedef {__import__('../../../shared/constants/transaction').TransactionMeta} TransactionMeta
 */

/**
 * A transaction object in the format returned by the Etherscan API.
 *
 * Note that this is not an exhaustive type definiton; only the properties we use are defined
 *
 * @typedef {Object} EtherscanTransaction
 * @property {string} blockNumber - The number of the block this transaction was found in, in decimal
 * @property {string} from - The hex-prefixed address of the sender
 * @property {string} gas - The gas limit, in decimal GWEI
 * @property {string} [gasPrice] - The gas price, in decimal WEI
 * @property {string} [maxFeePerGas] - The maximum fee per gas, inclusive of tip, in decimal WEI
 * @property {string} [maxPriorityFeePerGas] - The maximum tip per gas in decimal WEI
 * @property {string} hash - The hex-prefixed transaction hash
 * @property {string} isError - Whether the transaction was confirmed or failed (0 for confirmed, 1 for failed)
 * @property {string} nonce - The transaction nonce, in decimal
 * @property {string} timeStamp - The timestamp for the transaction, in seconds
 * @property {string} to - The hex-prefixed address of the recipient
 * @property {string} value - The amount of ETH sent in this transaction, in decimal WEI
 */

/**
 * This controller is responsible for retrieving incoming transactions. Etherscan is polled once every block to check
 * for new incoming transactions for the current selected account on the current network
 *
 * Note that only the built-in Infura networks are supported (i.e. anything in `INFURA_PROVIDER_TYPES`). We will not
 * attempt to retrieve incoming transactions on any custom RPC endpoints.
 */

const etherscanSupportedNetworks = [_network.GOERLI_CHAIN_ID, _network.KOVAN_CHAIN_ID, _network.MAINNET_CHAIN_ID, _network.RINKEBY_CHAIN_ID, _network.ROPSTEN_CHAIN_ID];

class IncomingTransactionsController {
  constructor(opts = {}) {
    const {
      blockTracker,
      onNetworkDidChange,
      getCurrentChainId,
      preferencesController
    } = opts;
    this.blockTracker = blockTracker;
    this.getCurrentChainId = getCurrentChainId;
    this.preferencesController = preferencesController;

    this._onLatestBlock = async newBlockNumberHex => {
      const selectedAddress = this.preferencesController.getSelectedAddress();
      const newBlockNumberDec = parseInt(newBlockNumberHex, 16);
      await this._update(selectedAddress, newBlockNumberDec);
    };

    const initState = _objectSpread({
      incomingTransactions: {},
      incomingTxLastFetchedBlockByChainId: {
        [_network.GOERLI_CHAIN_ID]: null,
        [_network.KOVAN_CHAIN_ID]: null,
        [_network.MAINNET_CHAIN_ID]: null,
        [_network.RINKEBY_CHAIN_ID]: null,
        [_network.ROPSTEN_CHAIN_ID]: null
      }
    }, opts.initState);

    this.store = new _obsStore.ObservableStore(initState);
    this.preferencesController.store.subscribe(previousValueComparator((prevState, currState) => {
      const {
        featureFlags: {
          showIncomingTransactions: prevShowIncomingTransactions
        } = {}
      } = prevState;
      const {
        featureFlags: {
          showIncomingTransactions: currShowIncomingTransactions
        } = {}
      } = currState;

      if (currShowIncomingTransactions === prevShowIncomingTransactions) {
        return;
      }

      if (prevShowIncomingTransactions && !currShowIncomingTransactions) {
        this.stop();
        return;
      }

      this.start();
    }, this.preferencesController.store.getState()));
    this.preferencesController.store.subscribe(previousValueComparator(async (prevState, currState) => {
      const {
        selectedAddress: prevSelectedAddress
      } = prevState;
      const {
        selectedAddress: currSelectedAddress
      } = currState;

      if (currSelectedAddress === prevSelectedAddress) {
        return;
      }

      await this._update(currSelectedAddress);
    }, this.preferencesController.store.getState()));
    onNetworkDidChange(async () => {
      const address = this.preferencesController.getSelectedAddress();
      await this._update(address);
    });
  }

  start() {
    const {
      featureFlags = {}
    } = this.preferencesController.store.getState();
    const {
      showIncomingTransactions
    } = featureFlags;

    if (!showIncomingTransactions) {
      return;
    }

    this.blockTracker.removeListener('latest', this._onLatestBlock);
    this.blockTracker.addListener('latest', this._onLatestBlock);
  }

  stop() {
    this.blockTracker.removeListener('latest', this._onLatestBlock);
  }
  /**
   * Determines the correct block number to begin looking for new transactions
   * from, fetches the transactions and then saves them and the next block
   * number to begin fetching from in state. Block numbers and transactions are
   * stored per chainId.
   * @private
   * @param {string} address - address to lookup transactions for
   * @param {number} [newBlockNumberDec] - block number to begin fetching from
   * @returns {void}
   */


  async _update(address, newBlockNumberDec) {
    const chainId = this.getCurrentChainId();

    if (!etherscanSupportedNetworks.includes(chainId) || !address) {
      return;
    }

    try {
      var _ref;

      const currentState = this.store.getState();
      const currentBlock = parseInt(this.blockTracker.getCurrentBlock(), 16);
      const mostRecentlyFetchedBlock = currentState.incomingTxLastFetchedBlockByChainId[chainId];
      const blockToFetchFrom = (_ref = mostRecentlyFetchedBlock !== null && mostRecentlyFetchedBlock !== void 0 ? mostRecentlyFetchedBlock : newBlockNumberDec) !== null && _ref !== void 0 ? _ref : currentBlock;
      const newIncomingTxs = await this._getNewIncomingTransactions(address, blockToFetchFrom, chainId);
      let newMostRecentlyFetchedBlock = blockToFetchFrom;
      newIncomingTxs.forEach(tx => {
        if (tx.blockNumber && parseInt(newMostRecentlyFetchedBlock, 10) < parseInt(tx.blockNumber, 10)) {
          newMostRecentlyFetchedBlock = parseInt(tx.blockNumber, 10);
        }
      });
      this.store.updateState({
        incomingTxLastFetchedBlockByChainId: _objectSpread(_objectSpread({}, currentState.incomingTxLastFetchedBlockByChainId), {}, {
          [chainId]: newMostRecentlyFetchedBlock + 1
        }),
        incomingTransactions: newIncomingTxs.reduce((transactions, tx) => {
          transactions[tx.hash] = tx;
          return transactions;
        }, _objectSpread({}, currentState.incomingTransactions))
      });
    } catch (err) {
      _loglevel.default.error(err);
    }
  }
  /**
   * fetches transactions for the given address and chain, via etherscan, then
   * processes the data into the necessary shape for usage in this controller.
   *
   * @private
   * @param {string} [address] - Address to fetch transactions for
   * @param {number} [fromBlock] - Block to look for transactions at
   * @param {string} [chainId] - The chainId for the current network
   * @returns {TransactionMeta[]}
   */


  async _getNewIncomingTransactions(address, fromBlock, chainId) {
    const etherscanSubdomain = chainId === _network.MAINNET_CHAIN_ID ? 'api' : `api-${_network.CHAIN_ID_TO_TYPE_MAP[chainId]}`;
    const apiUrl = `https://${etherscanSubdomain}.etherscan.io`;
    let url = `${apiUrl}/api?module=account&action=txlist&address=${address}&tag=latest&page=1`;

    if (fromBlock) {
      url += `&startBlock=${parseInt(fromBlock, 10)}`;
    }

    const response = await fetchWithTimeout(url);
    const {
      status,
      result
    } = await response.json();
    let newIncomingTxs = [];

    if (status === '1' && Array.isArray(result) && result.length > 0) {
      const remoteTxList = {};
      const remoteTxs = [];
      result.forEach(tx => {
        if (!remoteTxList[tx.hash]) {
          remoteTxs.push(this._normalizeTxFromEtherscan(tx, chainId));
          remoteTxList[tx.hash] = 1;
        }
      });
      newIncomingTxs = remoteTxs.filter(tx => {
        var _tx$txParams, _tx$txParams$to;

        return ((_tx$txParams = tx.txParams) === null || _tx$txParams === void 0 ? void 0 : (_tx$txParams$to = _tx$txParams.to) === null || _tx$txParams$to === void 0 ? void 0 : _tx$txParams$to.toLowerCase()) === address.toLowerCase();
      });
      newIncomingTxs.sort((a, b) => a.time < b.time ? -1 : 1);
    }

    return newIncomingTxs;
  }
  /**
   * Transmutes a EtherscanTransaction into a TransactionMeta
   * @param {EtherscanTransaction} etherscanTransaction - the transaction to normalize
   * @param {string} chainId - The chainId of the current network
   * @returns {TransactionMeta}
   */


  _normalizeTxFromEtherscan(etherscanTransaction, chainId) {
    const time = parseInt(etherscanTransaction.timeStamp, 10) * 1000;
    const status = etherscanTransaction.isError === '0' ? _transaction.TRANSACTION_STATUSES.CONFIRMED : _transaction.TRANSACTION_STATUSES.FAILED;
    const txParams = {
      from: etherscanTransaction.from,
      gas: (0, _util.bnToHex)(new _bn.default(etherscanTransaction.gas)),
      nonce: (0, _util.bnToHex)(new _bn.default(etherscanTransaction.nonce)),
      to: etherscanTransaction.to,
      value: (0, _util.bnToHex)(new _bn.default(etherscanTransaction.value))
    };

    if (etherscanTransaction.gasPrice) {
      txParams.gasPrice = (0, _util.bnToHex)(new _bn.default(etherscanTransaction.gasPrice));
    } else if (etherscanTransaction.maxFeePerGas) {
      txParams.maxFeePerGas = (0, _util.bnToHex)(new _bn.default(etherscanTransaction.maxFeePerGas));
      txParams.maxPriorityFeePerGas = (0, _util.bnToHex)(new _bn.default(etherscanTransaction.maxPriorityFeePerGas));
    }

    return {
      blockNumber: etherscanTransaction.blockNumber,
      id: (0, _randomId.default)(),
      chainId,
      metamaskNetworkId: _network.CHAIN_ID_TO_NETWORK_ID_MAP[chainId],
      status,
      time,
      txParams,
      hash: etherscanTransaction.hash,
      type: _transaction.TRANSACTION_TYPES.INCOMING
    };
  }

}
/**
 * Returns a function with arity 1 that caches the argument that the function
 * is called with and invokes the comparator with both the cached, previous,
 * value and the current value. If specified, the initialValue will be passed
 * in as the previous value on the first invocation of the returned method.
 * @template A
 * @params {A=} type of compared value
 * @param {(prevValue: A, nextValue: A) => void} comparator - method to compare
 *  previous and next values.
 * @param {A} [initialValue] - initial value to supply to prevValue
 *  on first call of the method.
 * @returns {void}
 */


exports.default = IncomingTransactionsController;

function previousValueComparator(comparator, initialValue) {
  let first = true;
  let cache;
  return value => {
    try {
      if (first) {
        first = false;
        return comparator(initialValue !== null && initialValue !== void 0 ? initialValue : value, value);
      }

      return comparator(cache, value);
    } finally {
      cache = value;
    }
  };
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/incoming-transactions.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/decrypt-message-manager.js", {"../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js","../../../shared/modules/random-id":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/random-id.js","../metamask-controller":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/metamask-controller.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/util.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/decrypt-message-manager.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = _interopRequireDefault(require("events"));

var _obsStore = require("@metamask/obs-store");

var _ethereumjsUtil = require("ethereumjs-util");

var _ethRpcErrors = require("eth-rpc-errors");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _app = require("../../../shared/constants/app");

var _metamaskController = require("../metamask-controller");

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

var _util = require("./util");

const hexRe = /^[0-9A-Fa-f]+$/gu;
/**
 * Represents, and contains data about, an 'eth_decrypt' type decryption request. These are created when a
 * decryption for an eth_decrypt call is requested.
 *
 * @typedef {Object} DecryptMessage
 * @property {number} id An id to track and identify the message object
 * @property {Object} msgParams The parameters to pass to the decryptMessage method once the decryption request is
 * approved.
 * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
 * @property {string} msgParams.data A hex string conversion of the raw buffer data of the decryption request
 * @property {number} time The epoch time at which the this message was created
 * @property {string} status Indicates whether the decryption request is 'unapproved', 'approved', 'decrypted' or 'rejected'
 * @property {string} type The json-prc decryption method for which a decryption request has been made. A 'Message' will
 * always have a 'eth_decrypt' type.
 *
 */

class DecryptMessageManager extends _events.default {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - DecryptMessage.
   *
   * @typedef {Object} DecryptMessageManager
   * @property {Object} memStore The observable store where DecryptMessage are saved.
   * @property {Object} memStore.unapprovedDecryptMsgs A collection of all DecryptMessages in the 'unapproved' state
   * @property {number} memStore.unapprovedDecryptMsgCount The count of all DecryptMessages in this.memStore.unapprovedDecryptMsgs
   * @property {Array} messages Holds all messages that have been created by this DecryptMessageManager
   *
   */
  constructor(opts) {
    super();
    this.memStore = new _obsStore.ObservableStore({
      unapprovedDecryptMsgs: {},
      unapprovedDecryptMsgCount: 0
    });
    this.messages = [];
    this.metricsEvent = opts.metricsEvent;
  }
  /**
   * A getter for the number of 'unapproved' DecryptMessages in this.messages
   *
   * @returns {number} The number of 'unapproved' DecryptMessages in this.messages
   *
   */


  get unapprovedDecryptMsgCount() {
    return Object.keys(this.getUnapprovedMsgs()).length;
  }
  /**
   * A getter for the 'unapproved' DecryptMessages in this.messages
   *
   * @returns {Object} An index of DecryptMessage ids to DecryptMessages, for all 'unapproved' DecryptMessages in
   * this.messages
   *
   */


  getUnapprovedMsgs() {
    return this.messages.filter(msg => msg.status === 'unapproved').reduce((result, msg) => {
      result[msg.id] = msg;
      return result;
    }, {});
  }
  /**
   * Creates a new DecryptMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new DecryptMessage to this.messages, and to save the unapproved DecryptMessages from that list to
   * this.memStore.
   *
   * @param {Object} msgParams - The params for the eth_decrypt call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {Promise<Buffer>} The raw decrypted message contents
   *
   */


  addUnapprovedMessageAsync(msgParams, req) {
    return new Promise((resolve, reject) => {
      if (!msgParams.from) {
        reject(new Error('MetaMask Decryption: from field is required.'));
        return;
      }

      const msgId = this.addUnapprovedMessage(msgParams, req);
      this.once(`${msgId}:finished`, data => {
        switch (data.status) {
          case 'decrypted':
            resolve(data.rawData);
            return;

          case 'rejected':
            reject(_ethRpcErrors.ethErrors.provider.userRejectedRequest('MetaMask Decryption: User denied message decryption.'));
            return;

          case 'errored':
            reject(new Error('This message cannot be decrypted'));
            return;

          default:
            reject(new Error(`MetaMask Decryption: Unknown problem: ${JSON.stringify(msgParams)}`));
        }
      });
    });
  }
  /**
   * Creates a new DecryptMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new DecryptMessage to this.messages, and to save the unapproved DecryptMessages from that list to
   * this.memStore.
   *
   * @param {Object} msgParams - The params for the eth_decryptMsg call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {number} The id of the newly created DecryptMessage.
   *
   */


  addUnapprovedMessage(msgParams, req) {
    _loglevel.default.debug(`DecryptMessageManager addUnapprovedMessage: ${JSON.stringify(msgParams)}`); // add origin from request


    if (req) {
      msgParams.origin = req.origin;
    }

    msgParams.data = this.normalizeMsgData(msgParams.data); // create txData obj with parameters and meta data

    const time = new Date().getTime();
    const msgId = (0, _randomId.default)();
    const msgData = {
      id: msgId,
      msgParams,
      time,
      status: 'unapproved',
      type: _app.MESSAGE_TYPE.ETH_DECRYPT
    };
    this.addMsg(msgData); // signal update

    this.emit('update');
    return msgId;
  }
  /**
   * Adds a passed DecryptMessage to this.messages, and calls this._saveMsgList() to save the unapproved DecryptMessages from that
   * list to this.memStore.
   *
   * @param {Message} msg The DecryptMessage to add to this.messages
   *
   */


  addMsg(msg) {
    this.messages.push(msg);

    this._saveMsgList();
  }
  /**
   * Returns a specified DecryptMessage.
   *
   * @param {number} msgId The id of the DecryptMessage to get
   * @returns {DecryptMessage|undefined} The DecryptMessage with the id that matches the passed msgId, or undefined
   * if no DecryptMessage has that id.
   *
   */


  getMsg(msgId) {
    return this.messages.find(msg => msg.id === msgId);
  }
  /**
   * Approves a DecryptMessage. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise
   * with the message params modified for proper decryption.
   *
   * @param {Object} msgParams The msgParams to be used when eth_decryptMsg is called, plus data added by MetaMask.
   * @param {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.
   *
   */


  approveMessage(msgParams) {
    this.setMsgStatusApproved(msgParams.metamaskId);
    return this.prepMsgForDecryption(msgParams);
  }
  /**
   * Sets a DecryptMessage status to 'approved' via a call to this._setMsgStatus.
   *
   * @param {number} msgId The id of the DecryptMessage to approve.
   *
   */


  setMsgStatusApproved(msgId) {
    this._setMsgStatus(msgId, 'approved');
  }
  /**
   * Sets a DecryptMessage status to 'decrypted' via a call to this._setMsgStatus and updates that DecryptMessage in
   * this.messages by adding the raw decryption data of the decryption request to the DecryptMessage
   *
   * @param {number} msgId The id of the DecryptMessage to decrypt.
   * @param {buffer} rawData The raw data of the message request
   *
   */


  setMsgStatusDecrypted(msgId, rawData) {
    const msg = this.getMsg(msgId);
    msg.rawData = rawData;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'decrypted');
  }
  /**
   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams
   *
   * @param {Object} msgParams The msgParams to modify
   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed
   *
   */


  prepMsgForDecryption(msgParams) {
    delete msgParams.metamaskId;
    return Promise.resolve(msgParams);
  }
  /**
   * Sets a DecryptMessage status to 'rejected' via a call to this._setMsgStatus.
   *
   * @param {number} msgId The id of the DecryptMessage to reject.
   *
   */


  rejectMsg(msgId, reason = undefined) {
    if (reason) {
      this.metricsEvent({
        event: reason,
        category: 'Messages',
        properties: {
          action: 'Decrypt Message Request'
        }
      });
    }

    this._setMsgStatus(msgId, 'rejected');
  }
  /**
   * Sets a TypedMessage status to 'errored' via a call to this._setMsgStatus.
   *
   * @param {number} msgId The id of the TypedMessage to error
   *
   */


  errorMessage(msgId, error) {
    const msg = this.getMsg(msgId);
    msg.error = error;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'errored');
  }
  /**
   * Clears all unapproved messages from memory.
   */


  clearUnapproved() {
    this.messages = this.messages.filter(msg => msg.status !== 'unapproved');

    this._saveMsgList();
  }
  /**
   * Updates the status of a DecryptMessage in this.messages via a call to this._updateMsg
   *
   * @private
   * @param {number} msgId The id of the DecryptMessage to update.
   * @param {string} status The new status of the DecryptMessage.
   * @throws A 'DecryptMessageManager - DecryptMessage not found for id: "${msgId}".' if there is no DecryptMessage
   * in this.messages with an id equal to the passed msgId
   * @fires An event with a name equal to `${msgId}:${status}`. The DecryptMessage is also fired.
   * @fires If status is 'rejected' or 'decrypted', an event with a name equal to `${msgId}:finished` is fired along
   * with the DecryptMessage
   *
   */


  _setMsgStatus(msgId, status) {
    const msg = this.getMsg(msgId);

    if (!msg) {
      throw new Error(`DecryptMessageManager - Message not found for id: "${msgId}".`);
    }

    msg.status = status;

    this._updateMsg(msg);

    this.emit(`${msgId}:${status}`, msg);

    if (status === 'rejected' || status === 'decrypted' || status === 'errored') {
      this.emit(`${msgId}:finished`, msg);
    }
  }
  /**
   * Sets a DecryptMessage in this.messages to the passed DecryptMessage if the ids are equal. Then saves the
   * unapprovedDecryptMsgs index to storage via this._saveMsgList
   *
   * @private
   * @param {DecryptMessage} msg - A DecryptMessage that will replace an existing DecryptMessage (with the same
   * id) in this.messages
   *
   */


  _updateMsg(msg) {
    const index = this.messages.findIndex(message => message.id === msg.id);

    if (index !== -1) {
      this.messages[index] = msg;
    }

    this._saveMsgList();
  }
  /**
   * Saves the unapproved DecryptMessages, and their count, to this.memStore
   *
   * @private
   * @fires 'updateBadge'
   *
   */


  _saveMsgList() {
    const unapprovedDecryptMsgs = this.getUnapprovedMsgs();
    const unapprovedDecryptMsgCount = Object.keys(unapprovedDecryptMsgs).length;
    this.memStore.updateState({
      unapprovedDecryptMsgs,
      unapprovedDecryptMsgCount
    });
    this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
  }
  /**
   * A helper function that converts raw buffer data to a hex, or just returns the data if it is already formatted as a hex.
   *
   * @param {any} data The buffer data to convert to a hex
   * @returns {string} A hex string conversion of the buffer data
   *
   */


  normalizeMsgData(data) {
    try {
      const stripped = (0, _ethereumjsUtil.stripHexPrefix)(data);

      if (stripped.match(hexRe)) {
        return (0, _util.addHexPrefix)(stripped);
      }
    } catch (e) {
      _loglevel.default.debug(`Message was not hex encoded, interpreting as utf8.`);
    }

    return (0, _ethereumjsUtil.bufferToHex)(Buffer.from(data, 'utf8'));
  }

}

exports.default = DecryptMessageManager;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/decrypt-message-manager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/message-manager.js", {"../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js","../../../shared/modules/random-id":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/random-id.js","../metamask-controller":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/metamask-controller.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/message-manager.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.normalizeMsgData = normalizeMsgData;

var _events = _interopRequireDefault(require("events"));

var _obsStore = require("@metamask/obs-store");

var _ethereumjsUtil = require("ethereumjs-util");

var _ethRpcErrors = require("eth-rpc-errors");

var _app = require("../../../shared/constants/app");

var _metamaskController = require("../metamask-controller");

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

/**
 * Represents, and contains data about, an 'eth_sign' type signature request. These are created when a signature for
 * an eth_sign call is requested.
 *
 * @see {@link https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign}
 *
 * @typedef {Object} Message
 * @property {number} id An id to track and identify the message object
 * @property {Object} msgParams The parameters to pass to the eth_sign method once the signature request is approved.
 * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
 * @property {string} msgParams.data A hex string conversion of the raw buffer data of the signature request
 * @property {number} time The epoch time at which the this message was created
 * @property {string} status Indicates whether the signature request is 'unapproved', 'approved', 'signed' or 'rejected'
 * @property {string} type The json-prc signing method for which a signature request has been made. A 'Message' with
 * always have a 'eth_sign' type.
 *
 */
class MessageManager extends _events.default {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - Messages.
   *
   * @typedef {Object} MessageManager
   * @property {Object} memStore The observable store where Messages are saved.
   * @property {Object} memStore.unapprovedMsgs A collection of all Messages in the 'unapproved' state
   * @property {number} memStore.unapprovedMsgCount The count of all Messages in this.memStore.unapprovedMsgs
   * @property {Array} messages Holds all messages that have been created by this MessageManager
   *
   */
  constructor({
    metricsEvent
  }) {
    super();
    this.memStore = new _obsStore.ObservableStore({
      unapprovedMsgs: {},
      unapprovedMsgCount: 0
    });
    this.messages = [];
    this.metricsEvent = metricsEvent;
  }
  /**
   * A getter for the number of 'unapproved' Messages in this.messages
   *
   * @returns {number} The number of 'unapproved' Messages in this.messages
   *
   */


  get unapprovedMsgCount() {
    return Object.keys(this.getUnapprovedMsgs()).length;
  }
  /**
   * A getter for the 'unapproved' Messages in this.messages
   *
   * @returns {Object} An index of Message ids to Messages, for all 'unapproved' Messages in this.messages
   *
   */


  getUnapprovedMsgs() {
    return this.messages.filter(msg => msg.status === 'unapproved').reduce((result, msg) => {
      result[msg.id] = msg;
      return result;
    }, {});
  }
  /**
   * Creates a new Message with an 'unapproved' status using the passed msgParams. this.addMsg is called to add the
   * new Message to this.messages, and to save the unapproved Messages from that list to this.memStore.
   *
   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {promise} after signature has been
   *
   */


  async addUnapprovedMessageAsync(msgParams, req) {
    const msgId = this.addUnapprovedMessage(msgParams, req);
    return await new Promise((resolve, reject) => {
      // await finished
      this.once(`${msgId}:finished`, data => {
        switch (data.status) {
          case 'signed':
            return resolve(data.rawSig);

          case 'rejected':
            return reject(_ethRpcErrors.ethErrors.provider.userRejectedRequest('MetaMask Message Signature: User denied message signature.'));

          case 'errored':
            return reject(new Error(`MetaMask Message Signature: ${data.error}`));

          default:
            return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(msgParams)}`));
        }
      });
    });
  }
  /**
   * Creates a new Message with an 'unapproved' status using the passed msgParams. this.addMsg is called to add the
   * new Message to this.messages, and to save the unapproved Messages from that list to this.memStore.
   *
   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.
   * @param {Object} [req] - The original request object where the origin may be specified
   * @returns {number} The id of the newly created message.
   *
   */


  addUnapprovedMessage(msgParams, req) {
    // add origin from request
    if (req) {
      msgParams.origin = req.origin;
    }

    msgParams.data = normalizeMsgData(msgParams.data); // create txData obj with parameters and meta data

    const time = new Date().getTime();
    const msgId = (0, _randomId.default)();
    const msgData = {
      id: msgId,
      msgParams,
      time,
      status: 'unapproved',
      type: _app.MESSAGE_TYPE.ETH_SIGN
    };
    this.addMsg(msgData); // signal update

    this.emit('update');
    return msgId;
  }
  /**
   * Adds a passed Message to this.messages, and calls this._saveMsgList() to save the unapproved Messages from that
   * list to this.memStore.
   *
   * @param {Message} msg - The Message to add to this.messages
   *
   */


  addMsg(msg) {
    this.messages.push(msg);

    this._saveMsgList();
  }
  /**
   * Returns a specified Message.
   *
   * @param {number} msgId - The id of the Message to get
   * @returns {Message|undefined} The Message with the id that matches the passed msgId, or undefined if no Message has that id.
   *
   */


  getMsg(msgId) {
    return this.messages.find(msg => msg.id === msgId);
  }
  /**
   * Approves a Message. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise with
   * any the message params modified for proper signing.
   *
   * @param {Object} msgParams - The msgParams to be used when eth_sign is called, plus data added by MetaMask.
   * @param {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.
   *
   */


  approveMessage(msgParams) {
    this.setMsgStatusApproved(msgParams.metamaskId);
    return this.prepMsgForSigning(msgParams);
  }
  /**
   * Sets a Message status to 'approved' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the Message to approve.
   *
   */


  setMsgStatusApproved(msgId) {
    this._setMsgStatus(msgId, 'approved');
  }
  /**
   * Sets a Message status to 'signed' via a call to this._setMsgStatus and updates that Message in this.messages by
   * adding the raw signature data of the signature request to the Message
   *
   * @param {number} msgId - The id of the Message to sign.
   * @param {buffer} rawSig - The raw data of the signature request
   *
   */


  setMsgStatusSigned(msgId, rawSig) {
    const msg = this.getMsg(msgId);
    msg.rawSig = rawSig;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'signed');
  }
  /**
   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams
   *
   * @param {Object} msgParams - The msgParams to modify
   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed
   *
   */


  prepMsgForSigning(msgParams) {
    delete msgParams.metamaskId;
    return Promise.resolve(msgParams);
  }
  /**
   * Sets a Message status to 'rejected' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the Message to reject.
   *
   */


  rejectMsg(msgId, reason = undefined) {
    if (reason) {
      const msg = this.getMsg(msgId);
      this.metricsEvent({
        event: reason,
        category: 'Transactions',
        properties: {
          action: 'Sign Request',
          type: msg.type
        }
      });
    }

    this._setMsgStatus(msgId, 'rejected');
  }
  /**
   * Sets a Message status to 'errored' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the Message to error
   *
   */


  errorMessage(msgId, error) {
    const msg = this.getMsg(msgId);
    msg.error = error;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'errored');
  }
  /**
   * Clears all unapproved messages from memory.
   */


  clearUnapproved() {
    this.messages = this.messages.filter(msg => msg.status !== 'unapproved');

    this._saveMsgList();
  }
  /**
   * Updates the status of a Message in this.messages via a call to this._updateMsg
   *
   * @private
   * @param {number} msgId - The id of the Message to update.
   * @param {string} status - The new status of the Message.
   * @throws A 'MessageManager - Message not found for id: "${msgId}".' if there is no Message in this.messages with an
   * id equal to the passed msgId
   * @fires An event with a name equal to `${msgId}:${status}`. The Message is also fired.
   * @fires If status is 'rejected' or 'signed', an event with a name equal to `${msgId}:finished` is fired along with the message
   *
   */


  _setMsgStatus(msgId, status) {
    const msg = this.getMsg(msgId);

    if (!msg) {
      throw new Error(`MessageManager - Message not found for id: "${msgId}".`);
    }

    msg.status = status;

    this._updateMsg(msg);

    this.emit(`${msgId}:${status}`, msg);

    if (status === 'rejected' || status === 'signed') {
      this.emit(`${msgId}:finished`, msg);
    }
  }
  /**
   * Sets a Message in this.messages to the passed Message if the ids are equal. Then saves the unapprovedMsg list to
   * storage via this._saveMsgList
   *
   * @private
   * @param {msg} Message - A Message that will replace an existing Message (with the same id) in this.messages
   *
   */


  _updateMsg(msg) {
    const index = this.messages.findIndex(message => message.id === msg.id);

    if (index !== -1) {
      this.messages[index] = msg;
    }

    this._saveMsgList();
  }
  /**
   * Saves the unapproved messages, and their count, to this.memStore
   *
   * @private
   * @fires 'updateBadge'
   *
   */


  _saveMsgList() {
    const unapprovedMsgs = this.getUnapprovedMsgs();
    const unapprovedMsgCount = Object.keys(unapprovedMsgs).length;
    this.memStore.updateState({
      unapprovedMsgs,
      unapprovedMsgCount
    });
    this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
  }

}
/**
 * A helper function that converts raw buffer data to a hex, or just returns the data if it is already formatted as a hex.
 *
 * @param {any} data - The buffer data to convert to a hex
 * @returns {string} A hex string conversion of the buffer data
 *
 */


exports.default = MessageManager;

function normalizeMsgData(data) {
  if (data.slice(0, 2) === '0x') {
    // data is already hex
    return data;
  } // data is unicode, convert to hex


  return (0, _ethereumjsUtil.bufferToHex)(Buffer.from(data, 'utf8'));
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/message-manager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/personal-message-manager.js", {"../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js","../../../shared/modules/random-id":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/random-id.js","../metamask-controller":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/metamask-controller.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/util.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/personal-message-manager.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = _interopRequireDefault(require("events"));

var _obsStore = require("@metamask/obs-store");

var _ethereumjsUtil = require("ethereumjs-util");

var _ethRpcErrors = require("eth-rpc-errors");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _app = require("../../../shared/constants/app");

var _metamaskController = require("../metamask-controller");

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

var _util = require("./util");

const hexRe = /^[0-9A-Fa-f]+$/gu;
/**
 * Represents, and contains data about, an 'personal_sign' type signature request. These are created when a
 * signature for an personal_sign call is requested.
 *
 * @see {@link https://web3js.readthedocs.io/en/1.0/web3-eth-personal.html#sign}
 *
 * @typedef {Object} PersonalMessage
 * @property {number} id An id to track and identify the message object
 * @property {Object} msgParams The parameters to pass to the personal_sign method once the signature request is
 * approved.
 * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
 * @property {string} msgParams.data A hex string conversion of the raw buffer data of the signature request
 * @property {number} time The epoch time at which the this message was created
 * @property {string} status Indicates whether the signature request is 'unapproved', 'approved', 'signed' or 'rejected'
 * @property {string} type The json-prc signing method for which a signature request has been made. A 'Message' will
 * always have a 'personal_sign' type.
 *
 */

class PersonalMessageManager extends _events.default {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - PersonalMessage.
   *
   * @typedef {Object} PersonalMessageManager
   * @property {Object} memStore The observable store where PersonalMessage are saved.
   * @property {Object} memStore.unapprovedPersonalMsgs A collection of all PersonalMessages in the 'unapproved' state
   * @property {number} memStore.unapprovedPersonalMsgCount The count of all PersonalMessages in this.memStore.unapprobedMsgs
   * @property {Array} messages Holds all messages that have been created by this PersonalMessageManager
   *
   */
  constructor({
    metricsEvent
  }) {
    super();
    this.memStore = new _obsStore.ObservableStore({
      unapprovedPersonalMsgs: {},
      unapprovedPersonalMsgCount: 0
    });
    this.messages = [];
    this.metricsEvent = metricsEvent;
  }
  /**
   * A getter for the number of 'unapproved' PersonalMessages in this.messages
   *
   * @returns {number} The number of 'unapproved' PersonalMessages in this.messages
   *
   */


  get unapprovedPersonalMsgCount() {
    return Object.keys(this.getUnapprovedMsgs()).length;
  }
  /**
   * A getter for the 'unapproved' PersonalMessages in this.messages
   *
   * @returns {Object} An index of PersonalMessage ids to PersonalMessages, for all 'unapproved' PersonalMessages in
   * this.messages
   *
   */


  getUnapprovedMsgs() {
    return this.messages.filter(msg => msg.status === 'unapproved').reduce((result, msg) => {
      result[msg.id] = msg;
      return result;
    }, {});
  }
  /**
   * Creates a new PersonalMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new PersonalMessage to this.messages, and to save the unapproved PersonalMessages from that list to
   * this.memStore.
   *
   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {promise} When the message has been signed or rejected
   *
   */


  addUnapprovedMessageAsync(msgParams, req) {
    return new Promise((resolve, reject) => {
      if (!msgParams.from) {
        reject(new Error('MetaMask Message Signature: from field is required.'));
        return;
      }

      const msgId = this.addUnapprovedMessage(msgParams, req);
      this.once(`${msgId}:finished`, data => {
        switch (data.status) {
          case 'signed':
            resolve(data.rawSig);
            return;

          case 'rejected':
            reject(_ethRpcErrors.ethErrors.provider.userRejectedRequest('MetaMask Message Signature: User denied message signature.'));
            return;

          case 'errored':
            reject(new Error(`MetaMask Message Signature: ${data.error}`));
            return;

          default:
            reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(msgParams)}`));
        }
      });
    });
  }
  /**
   * Creates a new PersonalMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new PersonalMessage to this.messages, and to save the unapproved PersonalMessages from that list to
   * this.memStore.
   *
   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {number} The id of the newly created PersonalMessage.
   *
   */


  addUnapprovedMessage(msgParams, req) {
    _loglevel.default.debug(`PersonalMessageManager addUnapprovedMessage: ${JSON.stringify(msgParams)}`); // add origin from request


    if (req) {
      msgParams.origin = req.origin;
    }

    msgParams.data = this.normalizeMsgData(msgParams.data); // create txData obj with parameters and meta data

    const time = new Date().getTime();
    const msgId = (0, _randomId.default)();
    const msgData = {
      id: msgId,
      msgParams,
      time,
      status: 'unapproved',
      type: _app.MESSAGE_TYPE.PERSONAL_SIGN
    };
    this.addMsg(msgData); // signal update

    this.emit('update');
    return msgId;
  }
  /**
   * Adds a passed PersonalMessage to this.messages, and calls this._saveMsgList() to save the unapproved PersonalMessages from that
   * list to this.memStore.
   *
   * @param {Message} msg - The PersonalMessage to add to this.messages
   *
   */


  addMsg(msg) {
    this.messages.push(msg);

    this._saveMsgList();
  }
  /**
   * Returns a specified PersonalMessage.
   *
   * @param {number} msgId - The id of the PersonalMessage to get
   * @returns {PersonalMessage|undefined} The PersonalMessage with the id that matches the passed msgId, or undefined
   * if no PersonalMessage has that id.
   *
   */


  getMsg(msgId) {
    return this.messages.find(msg => msg.id === msgId);
  }
  /**
   * Approves a PersonalMessage. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise
   * with any the message params modified for proper signing.
   *
   * @param {Object} msgParams - The msgParams to be used when eth_sign is called, plus data added by MetaMask.
   * @param {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.
   *
   */


  approveMessage(msgParams) {
    this.setMsgStatusApproved(msgParams.metamaskId);
    return this.prepMsgForSigning(msgParams);
  }
  /**
   * Sets a PersonalMessage status to 'approved' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the PersonalMessage to approve.
   *
   */


  setMsgStatusApproved(msgId) {
    this._setMsgStatus(msgId, 'approved');
  }
  /**
   * Sets a PersonalMessage status to 'signed' via a call to this._setMsgStatus and updates that PersonalMessage in
   * this.messages by adding the raw signature data of the signature request to the PersonalMessage
   *
   * @param {number} msgId - The id of the PersonalMessage to sign.
   * @param {buffer} rawSig - The raw data of the signature request
   *
   */


  setMsgStatusSigned(msgId, rawSig) {
    const msg = this.getMsg(msgId);
    msg.rawSig = rawSig;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'signed');
  }
  /**
   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams
   *
   * @param {Object} msgParams - The msgParams to modify
   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed
   *
   */


  prepMsgForSigning(msgParams) {
    delete msgParams.metamaskId;
    return Promise.resolve(msgParams);
  }
  /**
   * Sets a PersonalMessage status to 'rejected' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the PersonalMessage to reject.
   *
   */


  rejectMsg(msgId, reason = undefined) {
    if (reason) {
      const msg = this.getMsg(msgId);
      this.metricsEvent({
        event: reason,
        category: 'Transactions',
        properties: {
          action: 'Sign Request',
          type: msg.type
        }
      });
    }

    this._setMsgStatus(msgId, 'rejected');
  }
  /**
   * Sets a Message status to 'errored' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the Message to error
   *
   */


  errorMessage(msgId, error) {
    const msg = this.getMsg(msgId);
    msg.error = error;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'errored');
  }
  /**
   * Clears all unapproved messages from memory.
   */


  clearUnapproved() {
    this.messages = this.messages.filter(msg => msg.status !== 'unapproved');

    this._saveMsgList();
  }
  /**
   * Updates the status of a PersonalMessage in this.messages via a call to this._updateMsg
   *
   * @private
   * @param {number} msgId - The id of the PersonalMessage to update.
   * @param {string} status - The new status of the PersonalMessage.
   * @throws A 'PersonalMessageManager - PersonalMessage not found for id: "${msgId}".' if there is no PersonalMessage
   * in this.messages with an id equal to the passed msgId
   * @fires An event with a name equal to `${msgId}:${status}`. The PersonalMessage is also fired.
   * @fires If status is 'rejected' or 'signed', an event with a name equal to `${msgId}:finished` is fired along
   * with the PersonalMessage
   *
   */


  _setMsgStatus(msgId, status) {
    const msg = this.getMsg(msgId);

    if (!msg) {
      throw new Error(`PersonalMessageManager - Message not found for id: "${msgId}".`);
    }

    msg.status = status;

    this._updateMsg(msg);

    this.emit(`${msgId}:${status}`, msg);

    if (status === 'rejected' || status === 'signed') {
      this.emit(`${msgId}:finished`, msg);
    }
  }
  /**
   * Sets a PersonalMessage in this.messages to the passed PersonalMessage if the ids are equal. Then saves the
   * unapprovedPersonalMsgs index to storage via this._saveMsgList
   *
   * @private
   * @param {msg} PersonalMessage - A PersonalMessage that will replace an existing PersonalMessage (with the same
   * id) in this.messages
   *
   */


  _updateMsg(msg) {
    const index = this.messages.findIndex(message => message.id === msg.id);

    if (index !== -1) {
      this.messages[index] = msg;
    }

    this._saveMsgList();
  }
  /**
   * Saves the unapproved PersonalMessages, and their count, to this.memStore
   *
   * @private
   * @fires 'updateBadge'
   *
   */


  _saveMsgList() {
    const unapprovedPersonalMsgs = this.getUnapprovedMsgs();
    const unapprovedPersonalMsgCount = Object.keys(unapprovedPersonalMsgs).length;
    this.memStore.updateState({
      unapprovedPersonalMsgs,
      unapprovedPersonalMsgCount
    });
    this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
  }
  /**
   * A helper function that converts raw buffer data to a hex, or just returns the data if it is already formatted as a hex.
   *
   * @param {any} data - The buffer data to convert to a hex
   * @returns {string} A hex string conversion of the buffer data
   *
   */


  normalizeMsgData(data) {
    try {
      const stripped = (0, _ethereumjsUtil.stripHexPrefix)(data);

      if (stripped.match(hexRe)) {
        return (0, _util.addHexPrefix)(stripped);
      }
    } catch (e) {
      _loglevel.default.debug(`Message was not hex encoded, interpreting as utf8.`);
    }

    return (0, _ethereumjsUtil.bufferToHex)(Buffer.from(data, 'utf8'));
  }

}

exports.default = PersonalMessageManager;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/personal-message-manager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/encryption-public-key-manager.js", {"../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js","../../../shared/modules/random-id":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/random-id.js","../metamask-controller":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/metamask-controller.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/encryption-public-key-manager.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = _interopRequireDefault(require("events"));

var _obsStore = require("@metamask/obs-store");

var _ethRpcErrors = require("eth-rpc-errors");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _app = require("../../../shared/constants/app");

var _metamaskController = require("../metamask-controller");

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

/**
 * Represents, and contains data about, an 'eth_getEncryptionPublicKey' type request. These are created when
 * an eth_getEncryptionPublicKey call is requested.
 *
 * @typedef {Object} EncryptionPublicKey
 * @property {number} id An id to track and identify the message object
 * @property {Object} msgParams The parameters to pass to the encryptionPublicKey method once the request is
 * approved.
 * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
 * @property {string} msgParams.data A hex string conversion of the raw buffer data of the request
 * @property {number} time The epoch time at which the this message was created
 * @property {string} status Indicates whether the request is 'unapproved', 'approved', 'received' or 'rejected'
 * @property {string} type The json-prc method for which a request has been made. A 'Message' will
 * always have a 'eth_getEncryptionPublicKey' type.
 *
 */
class EncryptionPublicKeyManager extends _events.default {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - EncryptionPublicKey.
   *
   * @typedef {Object} EncryptionPublicKeyManager
   * @property {Object} memStore The observable store where EncryptionPublicKey are saved with persistance.
   * @property {Object} memStore.unapprovedEncryptionPublicKeyMsgs A collection of all EncryptionPublicKeys in the 'unapproved' state
   * @property {number} memStore.unapprovedEncryptionPublicKeyMsgCount The count of all EncryptionPublicKeys in this.memStore.unapprobedMsgs
   * @property {Array} messages Holds all messages that have been created by this EncryptionPublicKeyManager
   *
   */
  constructor(opts) {
    super();
    this.memStore = new _obsStore.ObservableStore({
      unapprovedEncryptionPublicKeyMsgs: {},
      unapprovedEncryptionPublicKeyMsgCount: 0
    });
    this.messages = [];
    this.metricsEvent = opts.metricsEvent;
  }
  /**
   * A getter for the number of 'unapproved' EncryptionPublicKeys in this.messages
   *
   * @returns {number} The number of 'unapproved' EncryptionPublicKeys in this.messages
   *
   */


  get unapprovedEncryptionPublicKeyMsgCount() {
    return Object.keys(this.getUnapprovedMsgs()).length;
  }
  /**
   * A getter for the 'unapproved' EncryptionPublicKeys in this.messages
   *
   * @returns {Object} An index of EncryptionPublicKey ids to EncryptionPublicKeys, for all 'unapproved' EncryptionPublicKeys in
   * this.messages
   *
   */


  getUnapprovedMsgs() {
    return this.messages.filter(msg => msg.status === 'unapproved').reduce((result, msg) => {
      result[msg.id] = msg;
      return result;
    }, {});
  }
  /**
   * Creates a new EncryptionPublicKey with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new EncryptionPublicKey to this.messages, and to save the unapproved EncryptionPublicKeys from that list to
   * this.memStore.
   *
   * @param {Object} address - The param for the eth_getEncryptionPublicKey call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {Promise<Buffer>} The raw public key contents
   *
   */


  addUnapprovedMessageAsync(address, req) {
    return new Promise((resolve, reject) => {
      if (!address) {
        reject(new Error('MetaMask Message: address field is required.'));
        return;
      }

      const msgId = this.addUnapprovedMessage(address, req);
      this.once(`${msgId}:finished`, data => {
        switch (data.status) {
          case 'received':
            resolve(data.rawData);
            return;

          case 'rejected':
            reject(_ethRpcErrors.ethErrors.provider.userRejectedRequest('MetaMask EncryptionPublicKey: User denied message EncryptionPublicKey.'));
            return;

          default:
            reject(new Error(`MetaMask EncryptionPublicKey: Unknown problem: ${JSON.stringify(address)}`));
        }
      });
    });
  }
  /**
   * Creates a new EncryptionPublicKey with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new EncryptionPublicKey to this.messages, and to save the unapproved EncryptionPublicKeys from that list to
   * this.memStore.
   *
   * @param {Object} address - The param for the eth_getEncryptionPublicKey call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {number} The id of the newly created EncryptionPublicKey.
   *
   */


  addUnapprovedMessage(address, req) {
    _loglevel.default.debug(`EncryptionPublicKeyManager addUnapprovedMessage: address`); // create txData obj with parameters and meta data


    const time = new Date().getTime();
    const msgId = (0, _randomId.default)();
    const msgData = {
      id: msgId,
      msgParams: address,
      time,
      status: 'unapproved',
      type: _app.MESSAGE_TYPE.ETH_GET_ENCRYPTION_PUBLIC_KEY
    };

    if (req) {
      msgData.origin = req.origin;
    }

    this.addMsg(msgData); // signal update

    this.emit('update');
    return msgId;
  }
  /**
   * Adds a passed EncryptionPublicKey to this.messages, and calls this._saveMsgList() to save the unapproved EncryptionPublicKeys from that
   * list to this.memStore.
   *
   * @param {Message} msg The EncryptionPublicKey to add to this.messages
   *
   */


  addMsg(msg) {
    this.messages.push(msg);

    this._saveMsgList();
  }
  /**
   * Returns a specified EncryptionPublicKey.
   *
   * @param {number} msgId The id of the EncryptionPublicKey to get
   * @returns {EncryptionPublicKey|undefined} The EncryptionPublicKey with the id that matches the passed msgId, or undefined
   * if no EncryptionPublicKey has that id.
   *
   */


  getMsg(msgId) {
    return this.messages.find(msg => msg.id === msgId);
  }
  /**
   * Approves a EncryptionPublicKey. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise
   * with any the message params modified for proper providing.
   *
   * @param {Object} msgParams The msgParams to be used when eth_getEncryptionPublicKey is called, plus data added by MetaMask.
   * @param {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.
   *
   */


  approveMessage(msgParams) {
    this.setMsgStatusApproved(msgParams.metamaskId);
    return this.prepMsgForEncryptionPublicKey(msgParams);
  }
  /**
   * Sets a EncryptionPublicKey status to 'approved' via a call to this._setMsgStatus.
   *
   * @param {number} msgId The id of the EncryptionPublicKey to approve.
   *
   */


  setMsgStatusApproved(msgId) {
    this._setMsgStatus(msgId, 'approved');
  }
  /**
   * Sets a EncryptionPublicKey status to 'received' via a call to this._setMsgStatus and updates that EncryptionPublicKey in
   * this.messages by adding the raw data of request to the EncryptionPublicKey
   *
   * @param {number} msgId The id of the EncryptionPublicKey.
   * @param {buffer} rawData The raw data of the message request
   *
   */


  setMsgStatusReceived(msgId, rawData) {
    const msg = this.getMsg(msgId);
    msg.rawData = rawData;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'received');
  }
  /**
   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams
   *
   * @param {Object} msgParams The msgParams to modify
   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed
   *
   */


  prepMsgForEncryptionPublicKey(msgParams) {
    delete msgParams.metamaskId;
    return Promise.resolve(msgParams);
  }
  /**
   * Sets a EncryptionPublicKey status to 'rejected' via a call to this._setMsgStatus.
   *
   * @param {number} msgId The id of the EncryptionPublicKey to reject.
   *
   */


  rejectMsg(msgId, reason = undefined) {
    if (reason) {
      this.metricsEvent({
        event: reason,
        category: 'Messages',
        properties: {
          action: 'Encryption public key Request'
        }
      });
    }

    this._setMsgStatus(msgId, 'rejected');
  }
  /**
   * Sets a TypedMessage status to 'errored' via a call to this._setMsgStatus.
   *
   * @param {number} msgId The id of the TypedMessage to error
   *
   */


  errorMessage(msgId, error) {
    const msg = this.getMsg(msgId);
    msg.error = error;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'errored');
  }
  /**
   * Clears all unapproved messages from memory.
   */


  clearUnapproved() {
    this.messages = this.messages.filter(msg => msg.status !== 'unapproved');

    this._saveMsgList();
  }
  /**
   * Updates the status of a EncryptionPublicKey in this.messages via a call to this._updateMsg
   *
   * @private
   * @param {number} msgId The id of the EncryptionPublicKey to update.
   * @param {string} status The new status of the EncryptionPublicKey.
   * @throws A 'EncryptionPublicKeyManager - EncryptionPublicKey not found for id: "${msgId}".' if there is no EncryptionPublicKey
   * in this.messages with an id equal to the passed msgId
   * @fires An event with a name equal to `${msgId}:${status}`. The EncryptionPublicKey is also fired.
   * @fires If status is 'rejected' or 'received', an event with a name equal to `${msgId}:finished` is fired along
   * with the EncryptionPublicKey
   *
   */


  _setMsgStatus(msgId, status) {
    const msg = this.getMsg(msgId);

    if (!msg) {
      throw new Error(`EncryptionPublicKeyManager - Message not found for id: "${msgId}".`);
    }

    msg.status = status;

    this._updateMsg(msg);

    this.emit(`${msgId}:${status}`, msg);

    if (status === 'rejected' || status === 'received') {
      this.emit(`${msgId}:finished`, msg);
    }
  }
  /**
   * Sets a EncryptionPublicKey in this.messages to the passed EncryptionPublicKey if the ids are equal. Then saves the
   * unapprovedEncryptionPublicKeyMsgs index to storage via this._saveMsgList
   *
   * @private
   * @param {EncryptionPublicKey} msg - A EncryptionPublicKey that will replace an existing EncryptionPublicKey (with the same
   * id) in this.messages
   *
   */


  _updateMsg(msg) {
    const index = this.messages.findIndex(message => message.id === msg.id);

    if (index !== -1) {
      this.messages[index] = msg;
    }

    this._saveMsgList();
  }
  /**
   * Saves the unapproved EncryptionPublicKeys, and their count, to this.memStore
   *
   * @private
   * @fires 'updateBadge'
   *
   */


  _saveMsgList() {
    const unapprovedEncryptionPublicKeyMsgs = this.getUnapprovedMsgs();
    const unapprovedEncryptionPublicKeyMsgCount = Object.keys(unapprovedEncryptionPublicKeyMsgs).length;
    this.memStore.updateState({
      unapprovedEncryptionPublicKeyMsgs,
      unapprovedEncryptionPublicKeyMsgCount
    });
    this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
  }

}

exports.default = EncryptionPublicKeyManager;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/encryption-public-key-manager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/metametrics.js", {"../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js","../../../shared/constants/metametrics":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/metametrics.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/metametrics.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

var _obsStore = require("@metamask/obs-store");

var _ethereumjsUtil = require("ethereumjs-util");

var _app = require("../../../shared/constants/app");

var _metametrics = require("../../../shared/constants/metametrics");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const defaultCaptureException = err => {
  // throw error on clean stack so its captured by platform integrations (eg sentry)
  // but does not interupt the call stack
  setTimeout(() => {
    throw err;
  });
};

const exceptionsToFilter = {
  [`You must pass either an "anonymousId" or a "userId".`]: true
};
/**
 * @typedef {__import__('../../../shared/constants/metametrics').MetaMetricsContext} MetaMetricsContext
 * @typedef {__import__('../../../shared/constants/metametrics').MetaMetricsEventPayload} MetaMetricsEventPayload
 * @typedef {__import__('../../../shared/constants/metametrics').MetaMetricsEventOptions} MetaMetricsEventOptions
 * @typedef {__import__('../../../shared/constants/metametrics').SegmentEventPayload} SegmentEventPayload
 * @typedef {__import__('../../../shared/constants/metametrics').SegmentInterface} SegmentInterface
 * @typedef {__import__('../../../shared/constants/metametrics').MetaMetricsPagePayload} MetaMetricsPagePayload
 * @typedef {__import__('../../../shared/constants/metametrics').MetaMetricsPageOptions} MetaMetricsPageOptions
 */

/**
 * @typedef {Object} MetaMetricsControllerState
 * @property {?string} metaMetricsId - The user's metaMetricsId that will be
 *  attached to all non-anonymized event payloads
 * @property {?boolean} participateInMetaMetrics - The user's preference for
 *  participating in the MetaMetrics analytics program. This setting controls
 *  whether or not events are tracked
 */

class MetaMetricsController {
  /**
   * @param {Object} segment - an instance of analytics-node for tracking
   *  events that conform to the new MetaMetrics tracking plan.
   * @param {Object} preferencesStore - The preferences controller store, used
   *  to access and subscribe to preferences that will be attached to events
   * @param {function} onNetworkDidChange - Used to attach a listener to the
   *  networkDidChange event emitted by the networkController
   * @param {function} getCurrentChainId - Gets the current chain id from the
   *  network controller
   * @param {function} getNetworkIdentifier - Gets the current network
   *  identifier from the network controller
   * @param {string} version - The version of the extension
   * @param {string} environment - The environment the extension is running in
   * @param {MetaMetricsControllerState} initState - State to initialized with
   */
  constructor({
    segment,
    preferencesStore,
    onNetworkDidChange,
    getCurrentChainId,
    getNetworkIdentifier,
    version,
    environment,
    initState,
    captureException = defaultCaptureException
  }) {
    this._captureException = err => {
      // This is a temporary measure. Currently there are errors flooding sentry due to a problem in how we are tracking anonymousId
      // We intend on removing this as soon as we understand how to correctly solve that problem.
      if (!exceptionsToFilter[err.message]) {
        captureException(err);
      }
    };

    const prefState = preferencesStore.getState();
    this.chainId = getCurrentChainId();
    this.network = getNetworkIdentifier();
    this.locale = prefState.currentLocale.replace('_', '-');
    this.version = environment === 'production' ? version : `${version}-${environment}`;
    this.store = new _obsStore.ObservableStore(_objectSpread({
      participateInMetaMetrics: null,
      metaMetricsId: null
    }, initState));
    preferencesStore.subscribe(({
      currentLocale
    }) => {
      this.locale = currentLocale.replace('_', '-');
    });
    onNetworkDidChange(() => {
      this.chainId = getCurrentChainId();
      this.network = getNetworkIdentifier();
    });
    this.segment = segment;
  }

  generateMetaMetricsId() {
    return (0, _ethereumjsUtil.bufferToHex)((0, _ethereumjsUtil.keccak)(Buffer.from(String(Date.now()) + String(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)))));
  }
  /**
   * Setter for the `participateInMetaMetrics` property
   *
   * @param {boolean} participateInMetaMetrics - Whether or not the user wants
   *  to participate in MetaMetrics
   * @returns {string|null} the string of the new metametrics id, or null
   *  if not set
   */


  setParticipateInMetaMetrics(participateInMetaMetrics) {
    let {
      metaMetricsId
    } = this.state;

    if (participateInMetaMetrics && !metaMetricsId) {
      metaMetricsId = this.generateMetaMetricsId();
    } else if (participateInMetaMetrics === false) {
      metaMetricsId = null;
    }

    this.store.updateState({
      participateInMetaMetrics,
      metaMetricsId
    });
    return metaMetricsId;
  }

  get state() {
    return this.store.getState();
  }
  /**
   * Build the context object to attach to page and track events.
   * @private
   * @param {Pick<MetaMetricsContext, 'referrer'>} [referrer] - dapp origin that initialized
   *  the notification window.
   * @param {Pick<MetaMetricsContext, 'page'>} [page] - page object describing the current
   *  view of the extension. Defaults to the background-process object.
   * @returns {MetaMetricsContext}
   */


  _buildContext(referrer, page = _metametrics.METAMETRICS_BACKGROUND_PAGE_OBJECT) {
    return {
      app: {
        name: 'MetaMask Extension',
        version: this.version
      },
      userAgent: window.navigator.userAgent,
      page,
      referrer
    };
  }
  /**
   * Build's the event payload, processing all fields into a format that can be
   * fed to Segment's track method
   * @private
   * @param {
   *  Omit<MetaMetricsEventPayload, 'sensitiveProperties'>
   * } rawPayload - raw payload provided to trackEvent
   * @returns {SegmentEventPayload} - formatted event payload for segment
   */


  _buildEventPayload(rawPayload) {
    var _properties$network, _properties$chain_id;

    const {
      event,
      properties,
      revenue,
      value,
      currency,
      category,
      page,
      referrer,
      environmentType = _app.ENVIRONMENT_TYPE_BACKGROUND
    } = rawPayload;
    return {
      event,
      properties: _objectSpread(_objectSpread({}, (0, _lodash.omit)(properties, ['revenue', 'locale', 'currency', 'value'])), {}, {
        revenue,
        value,
        currency,
        category,
        network: (_properties$network = properties === null || properties === void 0 ? void 0 : properties.network) !== null && _properties$network !== void 0 ? _properties$network : this.network,
        locale: this.locale,
        chain_id: (_properties$chain_id = properties === null || properties === void 0 ? void 0 : properties.chain_id) !== null && _properties$chain_id !== void 0 ? _properties$chain_id : this.chainId,
        environment_type: environmentType
      }),
      context: this._buildContext(referrer, page)
    };
  }
  /**
   * Perform validation on the payload and update the id type to use before
   * sending to Segment. Also examines the options to route and handle the
   * event appropriately.
   * @private
   * @param {SegmentEventPayload} payload - properties to attach to event
   * @param {MetaMetricsEventOptions} [options] - options for routing and
   *  handling the event
   * @returns {Promise<void>}
   */


  _track(payload, options) {
    var _options$excludeMetaM;

    const {
      isOptIn,
      metaMetricsId: metaMetricsIdOverride,
      matomoEvent,
      flushImmediately
    } = options || {};
    let idType = 'userId';
    let idValue = this.state.metaMetricsId;
    let excludeMetaMetricsId = (_options$excludeMetaM = options === null || options === void 0 ? void 0 : options.excludeMetaMetricsId) !== null && _options$excludeMetaM !== void 0 ? _options$excludeMetaM : false; // This is carried over from the old implementation, and will likely need
    // to be updated to work with the new tracking plan. I think we should use
    // a config setting for this instead of trying to match the event name

    const isSendFlow = Boolean(payload.event.match(/^send|^confirm/iu));

    if (isSendFlow) {
      excludeMetaMetricsId = true;
    } // If we are tracking sensitive data we will always use the anonymousId
    // property as well as our METAMETRICS_ANONYMOUS_ID. This prevents us from
    // associating potentially identifiable information with a specific id.
    // During the opt in flow we will track all events, but do so with the
    // anonymous id. The one exception to that rule is after the user opts in
    // to MetaMetrics. When that happens we receive back the user's new
    // MetaMetrics id before it is fully persisted to state. To avoid a race
    // condition we explicitly pass the new id to the track method. In that
    // case we will track the opt in event to the user's id. In all other cases
    // we use the metaMetricsId from state.


    if (excludeMetaMetricsId || isOptIn && !metaMetricsIdOverride) {
      idType = 'anonymousId';
      idValue = _metametrics.METAMETRICS_ANONYMOUS_ID;
    } else if (isOptIn && metaMetricsIdOverride) {
      idValue = metaMetricsIdOverride;
    }

    payload[idType] = idValue; // If this is an event on the old matomo schema, add a key to the payload
    // to designate it as such

    if (matomoEvent === true) {
      payload.properties.legacy_event = true;
    } // Promises will only resolve when the event is sent to segment. For any
    // event that relies on this promise being fulfilled before performing UI
    // updates, or otherwise delaying user interaction, supply the
    // 'flushImmediately' flag to the trackEvent method.


    return new Promise((resolve, reject) => {
      const callback = err => {
        if (err) {
          // The error that segment gives us has some manipulation done to it
          // that seemingly breaks with lockdown enabled. Creating a new error
          // here prevents the system from freezing when the network request to
          // segment fails for any reason.
          const safeError = new Error(err.message);
          safeError.stack = err.stack;
          return reject(safeError);
        }

        return resolve();
      };

      this.segment.track(payload, callback);

      if (flushImmediately) {
        this.segment.flush();
      }
    });
  }
  /**
   * track a page view with Segment
   * @param {MetaMetricsPagePayload} payload - details of the page viewed
   * @param {MetaMetricsPageOptions} [options] - options for handling the page
   *  view
   */


  trackPage({
    name,
    params,
    environmentType,
    page,
    referrer
  }, options) {
    try {
      if (this.state.participateInMetaMetrics === false) {
        return;
      }

      if (this.state.participateInMetaMetrics === null && !(options !== null && options !== void 0 && options.isOptInPath)) {
        return;
      }

      const {
        metaMetricsId
      } = this.state;
      const idTrait = metaMetricsId ? 'userId' : 'anonymousId';
      const idValue = metaMetricsId !== null && metaMetricsId !== void 0 ? metaMetricsId : _metametrics.METAMETRICS_ANONYMOUS_ID;
      this.segment.page({
        [idTrait]: idValue,
        name,
        properties: {
          params,
          locale: this.locale,
          network: this.network,
          chain_id: this.chainId,
          environment_type: environmentType
        },
        context: this._buildContext(referrer, page)
      });
    } catch (err) {
      this._captureException(err);
    }
  }
  /**
   * submits a metametrics event, not waiting for it to complete or allowing its error to bubble up
   * @param {MetaMetricsEventPayload} payload - details of the event
   * @param {MetaMetricsEventOptions} [options] - options for handling/routing the event
   */


  trackEvent(payload, options) {
    // validation is not caught and handled
    this.validatePayload(payload);
    this.submitEvent(payload, options).catch(err => this._captureException(err));
  }
  /**
   * submits (or queues for submission) a metametrics event, performing necessary payload manipulation and
   * routing the event to the appropriate segment source. Will split events
   * with sensitiveProperties into two events, tracking the sensitiveProperties
   * with the anonymousId only.
   * @param {MetaMetricsEventPayload} payload - details of the event
   * @param {MetaMetricsEventOptions} [options] - options for handling/routing the event
   * @returns {Promise<void>}
   */


  async submitEvent(payload, options) {
    this.validatePayload(payload);

    if (!this.state.participateInMetaMetrics && !(options !== null && options !== void 0 && options.isOptIn)) {
      return;
    } // We might track multiple events if sensitiveProperties is included, this array will hold
    // the promises returned from this._track.


    const events = [];

    if (payload.sensitiveProperties) {
      // sensitiveProperties will only be tracked using the anonymousId property and generic id
      // If the event options already specify to exclude the metaMetricsId we throw an error as
      // a signal to the developer that the event was implemented incorrectly
      if ((options === null || options === void 0 ? void 0 : options.excludeMetaMetricsId) === true) {
        throw new Error('sensitiveProperties was specified in an event payload that also set the excludeMetaMetricsId flag');
      }

      const combinedProperties = (0, _lodash.merge)(payload.sensitiveProperties, payload.properties);
      events.push(this._track(this._buildEventPayload(_objectSpread(_objectSpread({}, payload), {}, {
        properties: combinedProperties
      })), _objectSpread(_objectSpread({}, options), {}, {
        excludeMetaMetricsId: true
      })));
    }

    events.push(this._track(this._buildEventPayload(payload), options));
    await Promise.all(events);
  }
  /**
   * validates a metametrics event
   * @param {MetaMetricsEventPayload} payload - details of the event
   */


  validatePayload(payload) {
    // event and category are required fields for all payloads
    if (!payload.event || !payload.category) {
      throw new Error(`Must specify event and category. Event was: ${payload.event}. Category was: ${payload.category}. Payload keys were: ${Object.keys(payload)}. ${typeof payload.properties === 'object' ? `Payload property keys were: ${Object.keys(payload.properties)}` : ''}`);
    }
  }

}

exports.default = MetaMetricsController;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/metametrics.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/detect-tokens.js", {"../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","../../../shared/constants/time":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/time.js","../../../ui/helpers/utils/util":"/home/clarisco/Desktop/metamask-extension-develop/ui/helpers/utils/util.js","../constants/contracts":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/constants/contracts.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js","single-call-balance-checker-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/single-call-balance-checker-abi/index.js","web3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/web3/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/detect-tokens.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _web = _interopRequireDefault(require("web3"));

var _loglevel = require("loglevel");

var _singleCallBalanceCheckerAbi = _interopRequireDefault(require("single-call-balance-checker-abi"));

var _contracts = require("../constants/contracts");

var _time = require("../../../shared/constants/time");

var _util = require("../../../ui/helpers/utils/util");

var _network = require("../../../shared/constants/network");

// By default, poll every 3 minutes
const DEFAULT_INTERVAL = _time.MINUTE * 3;
/**
 * A controller that polls for token exchange
 * rates based on a user's current token list
 */

class DetectTokensController {
  /**
   * Creates a DetectTokensController
   *
   * @param {Object} [config] - Options to configure controller
   */
  constructor({
    interval = DEFAULT_INTERVAL,
    preferences,
    network,
    keyringMemStore,
    tokenList,
    tokensController
  } = {}) {
    var _this$preferences, _this$tokensControlle, _this$tokensControlle2;

    this.tokensController = tokensController;
    this.preferences = preferences;
    this.interval = interval;
    this.network = network;
    this.keyringMemStore = keyringMemStore;
    this.tokenList = tokenList;
    this.selectedAddress = (_this$preferences = this.preferences) === null || _this$preferences === void 0 ? void 0 : _this$preferences.store.getState().selectedAddress;
    this.tokenAddresses = (_this$tokensControlle = this.tokensController) === null || _this$tokensControlle === void 0 ? void 0 : _this$tokensControlle.state.tokens.map(token => {
      return token.address;
    });
    this.hiddenTokens = (_this$tokensControlle2 = this.tokensController) === null || _this$tokensControlle2 === void 0 ? void 0 : _this$tokensControlle2.state.ignoredTokens;
    preferences === null || preferences === void 0 ? void 0 : preferences.store.subscribe(({
      selectedAddress,
      useTokenDetection
    }) => {
      if (this.selectedAddress !== selectedAddress || this.useTokenDetection !== useTokenDetection) {
        this.selectedAddress = selectedAddress;
        this.useTokenDetection = useTokenDetection;
        this.restartTokenDetection();
      }
    });
    tokensController === null || tokensController === void 0 ? void 0 : tokensController.subscribe(({
      tokens = [],
      ignoredTokens = []
    }) => {
      this.tokenAddresses = tokens.map(token => {
        return token.address;
      });
      this.hiddenTokens = ignoredTokens;
    });
  }

  async _getTokenBalances(tokens) {
    const ethContract = this.web3.eth.contract(_singleCallBalanceCheckerAbi.default).at(_contracts.SINGLE_CALL_BALANCES_ADDRESS);
    return new Promise((resolve, reject) => {
      ethContract.balances([this.selectedAddress], tokens, (error, result) => {
        if (error) {
          return reject(error);
        }

        return resolve(result);
      });
    });
  }
  /**
   * For each token in the tokenlist provided by the TokenListController, check selectedAddress balance.
   */


  async detectNewTokens() {
    if (!this.isActive) {
      return;
    }

    const {
      tokenList
    } = this._tokenList.state; // since the token detection is currently enabled only on Mainnet
    // we can use the chainId check to ensure token detection is not triggered for any other network
    // but once the balance check contract for other networks are deploayed and ready to use, we need to update this check.

    if (this._network.store.getState().provider.chainId !== _network.MAINNET_CHAIN_ID || Object.keys(tokenList).length === 0) {
      return;
    }

    const tokensToDetect = [];
    this.web3.setProvider(this._network._provider);

    for (const tokenAddress in tokenList) {
      if (!this.tokenAddresses.find(address => (0, _util.isEqualCaseInsensitive)(address, tokenAddress)) && !this.hiddenTokens.find(address => (0, _util.isEqualCaseInsensitive)(address, tokenAddress))) {
        tokensToDetect.push(tokenAddress);
      }
    }

    const sliceOfTokensToDetect = [tokensToDetect.slice(0, 1000), tokensToDetect.slice(1000, tokensToDetect.length - 1)];

    for (const tokensSlice of sliceOfTokensToDetect) {
      let result;

      try {
        result = await this._getTokenBalances(tokensSlice);
      } catch (error) {
        (0, _loglevel.warn)(`MetaMask - DetectTokensController single call balance fetch failed`, error);
        return;
      }

      const tokensWithBalance = tokensSlice.filter((_, index) => {
        const balance = result[index];
        return balance && !balance.isZero();
      });
      await Promise.all(tokensWithBalance.map(tokenAddress => {
        return this.tokensController.addToken(tokenAddress, tokenList[tokenAddress].symbol, tokenList[tokenAddress].decimals);
      }));
    }
  }
  /**
   * Restart token detection polling period and call detectNewTokens
   * in case of address change or user session initialization.
   *
   */


  restartTokenDetection() {
    if (!(this.isActive && this.selectedAddress)) {
      return;
    }

    this.detectNewTokens();
    this.interval = DEFAULT_INTERVAL;
  }
  /* eslint-disable accessor-pairs */

  /**
   * @type {Number}
   */


  set interval(interval) {
    this._handle && clearInterval(this._handle);

    if (!interval) {
      return;
    }

    this._handle = setInterval(() => {
      this.detectNewTokens();
    }, interval);
  }
  /**
   * @type {Object}
   */


  set network(network) {
    if (!network) {
      return;
    }

    this._network = network;
    this.web3 = new _web.default(network._provider);
  }
  /**
   * In setter when isUnlocked is updated to true, detectNewTokens and restart polling
   * @type {Object}
   */


  set keyringMemStore(keyringMemStore) {
    if (!keyringMemStore) {
      return;
    }

    this._keyringMemStore = keyringMemStore;

    this._keyringMemStore.subscribe(({
      isUnlocked
    }) => {
      if (this.isUnlocked !== isUnlocked) {
        this.isUnlocked = isUnlocked;

        if (isUnlocked) {
          this.restartTokenDetection();
        }
      }
    });
  }
  /**
   * @type {Object}
   */


  set tokenList(tokenList) {
    if (!tokenList) {
      return;
    }

    this._tokenList = tokenList;
  }
  /**
   * Internal isActive state
   * @type {Object}
   */


  get isActive() {
    return this.isOpen && this.isUnlocked;
  }
  /* eslint-enable accessor-pairs */


}

exports.default = DetectTokensController;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/detect-tokens.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/seed-phrase-verifier.js", {"@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","eth-keyring-controller":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-keyring-controller/index.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/seed-phrase-verifier.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethKeyringController = _interopRequireDefault(require("eth-keyring-controller"));

var _loglevel = _interopRequireDefault(require("loglevel"));

const seedPhraseVerifier = {
  /**
   * Verifies if the seed words can restore the accounts.
   *
   * Key notes:
   * - The seed words can recreate the primary keyring and the accounts belonging to it.
   * - The created accounts in the primary keyring are always the same.
   * - The keyring always creates the accounts in the same sequence.
   *
   * @param {Array} createdAccounts - The accounts to restore
   * @param {string} seedWords - The seed words to verify
   * @returns {Promise<void>} Promises undefined
   *
   */
  async verifyAccounts(createdAccounts, seedWords) {
    if (!createdAccounts || createdAccounts.length < 1) {
      throw new Error('No created accounts defined.');
    }

    const keyringController = new _ethKeyringController.default({});
    const Keyring = keyringController.getKeyringClassForType('HD Key Tree');
    const opts = {
      mnemonic: seedWords,
      numberOfAccounts: createdAccounts.length
    };
    const keyring = new Keyring(opts);
    const restoredAccounts = await keyring.getAccounts();

    _loglevel.default.debug(`Created accounts: ${JSON.stringify(createdAccounts)}`);

    _loglevel.default.debug(`Restored accounts: ${JSON.stringify(restoredAccounts)}`);

    if (restoredAccounts.length !== createdAccounts.length) {
      // this should not happen...
      throw new Error('Wrong number of accounts');
    }

    for (let i = 0; i < restoredAccounts.length; i++) {
      if (restoredAccounts[i].toLowerCase() !== createdAccounts[i].toLowerCase()) {
        throw new Error(`Not identical accounts! Original: ${createdAccounts[i]}, Restored: ${restoredAccounts[i]}`);
      }
    }
  }

};
var _default = seedPhraseVerifier;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/seed-phrase-verifier.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/preferences.js", {"../../../shared/constants/hardware-wallets":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/hardware-wallets.js","../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","../../../shared/modules/network.utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/network.utils.js","./network":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/index.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","eth-sig-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-sig-util/dist/index.js","ethers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethers/lib/index.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/preferences.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = require("assert");

var _obsStore = require("@metamask/obs-store");

var _ethSigUtil = require("eth-sig-util");

var _ethers = require("ethers");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _network = require("../../../shared/constants/network");

var _network2 = require("../../../shared/modules/network.utils");

var _hardwareWallets = require("../../../shared/constants/hardware-wallets");

var _network3 = require("./network");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class PreferencesController {
  /**
   *
   * @typedef {Object} PreferencesController
   * @param {Object} opts - Overrides the defaults for the initial state of this.store
   * @property {Object} store The stored object containing a users preferences, stored in local storage
   * @property {Array} store.frequentRpcList A list of custom rpcs to provide the user
   * @property {boolean} store.useBlockie The users preference for blockie identicons within the UI
   * @property {boolean} store.useNonceField The users preference for nonce field within the UI
   * @property {Object} store.featureFlags A key-boolean map, where keys refer to features and booleans to whether the
   * user wishes to see that feature.
   *
   * Feature flags can be set by the global function `setPreference(feature, enabled)`, and so should not expose any sensitive behavior.
   * @property {Object} store.knownMethodData Contains all data methods known by the user
   * @property {string} store.currentLocale The preferred language locale key
   * @property {string} store.selectedAddress A hex string that matches the currently selected address in the app
   *
   */
  constructor(opts = {}) {
    const initState = _objectSpread({
      frequentRpcListDetail: [],
      useBlockie: false,
      useNonceField: false,
      usePhishDetect: true,
      dismissSeedBackUpReminder: false,
      // set to true means the dynamic list from the API is being used
      // set to false will be using the static list from contract-metadata
      useTokenDetection: false,
      useCollectibleDetection: false,
      openSeaEnabled: false,
      advancedGasFee: null,
      // WARNING: Do not use feature flags for security-sensitive things.
      // Feature flag toggling is available in the global namespace
      // for convenient testing of pre-release features, and should never
      // perform sensitive operations.
      featureFlags: {
        showIncomingTransactions: true
      },
      knownMethodData: {},
      currentLocale: opts.initLangCode,
      identities: {},
      lostIdentities: {},
      forgottenPassword: false,
      preferences: {
        autoLockTimeLimit: undefined,
        showFiatInTestnets: false,
        showTestNetworks: false,
        useNativeCurrencyAsPrimaryCurrency: true,
        hideZeroBalanceTokens: false
      },
      // ENS decentralized website resolution
      ipfsGateway: _network.IPFS_DEFAULT_GATEWAY_URL,
      infuraBlocked: null,
      ledgerTransportType: window.navigator.hid ? _hardwareWallets.LEDGER_TRANSPORT_TYPES.WEBHID : _hardwareWallets.LEDGER_TRANSPORT_TYPES.U2F
    }, opts.initState);

    this.network = opts.network;
    this.ethersProvider = new _ethers.ethers.providers.Web3Provider(opts.provider);
    this.store = new _obsStore.ObservableStore(initState);
    this.store.setMaxListeners(12);
    this.openPopup = opts.openPopup;
    this.migrateAddressBookState = opts.migrateAddressBookState;

    this._subscribeToInfuraAvailability();

    global.setPreference = (key, value) => {
      return this.setFeatureFlag(key, value);
    };
  } // PUBLIC METHODS

  /**
   * Sets the {@code forgottenPassword} state property
   * @param {boolean} forgottenPassword - whether or not the user has forgotten their password
   */


  setPasswordForgotten(forgottenPassword) {
    this.store.updateState({
      forgottenPassword
    });
  }
  /**
   * Setter for the `useBlockie` property
   *
   * @param {boolean} val - Whether or not the user prefers blockie indicators
   *
   */


  setUseBlockie(val) {
    this.store.updateState({
      useBlockie: val
    });
  }
  /**
   * Setter for the `useNonceField` property
   *
   * @param {boolean} val - Whether or not the user prefers to set nonce
   *
   */


  setUseNonceField(val) {
    this.store.updateState({
      useNonceField: val
    });
  }
  /**
   * Setter for the `usePhishDetect` property
   *
   * @param {boolean} val - Whether or not the user prefers phishing domain protection
   *
   */


  setUsePhishDetect(val) {
    this.store.updateState({
      usePhishDetect: val
    });
  }
  /**
   * Setter for the `useTokenDetection` property
   *
   * @param {boolean} val - Whether or not the user prefers to use the static token list or dynamic token list from the API
   *
   */


  setUseTokenDetection(val) {
    this.store.updateState({
      useTokenDetection: val
    });
  }
  /**
   * Setter for the `useCollectibleDetection` property
   *
   * @param {boolean} val - Whether or not the user prefers to autodetect collectibles.
   *
   */


  setUseCollectibleDetection(val) {
    const {
      openSeaEnabled
    } = this.store.getState();

    if (val && !openSeaEnabled) {
      throw new Error('useCollectibleDetection cannot be enabled if openSeaEnabled is false');
    }

    this.store.updateState({
      useCollectibleDetection: val
    });
  }
  /**
   * Setter for the `openSeaEnabled` property
   *
   * @param {boolean} val - Whether or not the user prefers to use the OpenSea API for collectibles data.
   *
   */


  setOpenSeaEnabled(val) {
    this.store.updateState({
      openSeaEnabled: val
    });

    if (!val) {
      this.store.updateState({
        useCollectibleDetection: false
      });
    }
  }
  /**
   * Setter for the `advancedGasFee` property
   *
   * @param {object} val - holds the maxBaseFee and PriorityFee that the user set as default advanced settings.
   *
   */


  setAdvancedGasFee(val) {
    this.store.updateState({
      advancedGasFee: val
    });
  }
  /**
   * Add new methodData to state, to avoid requesting this information again through Infura
   *
   * @param {string} fourBytePrefix - Four-byte method signature
   * @param {string} methodData - Corresponding data method
   */


  addKnownMethodData(fourBytePrefix, methodData) {
    const {
      knownMethodData
    } = this.store.getState();
    knownMethodData[fourBytePrefix] = methodData;
    this.store.updateState({
      knownMethodData
    });
  }
  /**
   * Setter for the `currentLocale` property
   *
   * @param {string} key - he preferred language locale key
   *
   */


  setCurrentLocale(key) {
    const textDirection = ['ar', 'dv', 'fa', 'he', 'ku'].includes(key) ? 'rtl' : 'auto';
    this.store.updateState({
      currentLocale: key,
      textDirection
    });
    return textDirection;
  }
  /**
   * Updates identities to only include specified addresses. Removes identities
   * not included in addresses array
   *
   * @param {string[]} addresses - An array of hex addresses
   *
   */


  setAddresses(addresses) {
    const oldIdentities = this.store.getState().identities;
    const identities = addresses.reduce((ids, address, index) => {
      const oldId = oldIdentities[address] || {};
      ids[address] = _objectSpread({
        name: `Account ${index + 1}`,
        address
      }, oldId);
      return ids;
    }, {});
    this.store.updateState({
      identities
    });
  }
  /**
   * Removes an address from state
   *
   * @param {string} address - A hex address
   * @returns {string} the address that was removed
   */


  removeAddress(address) {
    const {
      identities
    } = this.store.getState();

    if (!identities[address]) {
      throw new Error(`${address} can't be deleted cause it was not found`);
    }

    delete identities[address];
    this.store.updateState({
      identities
    }); // If the selected account is no longer valid,
    // select an arbitrary other account:

    if (address === this.getSelectedAddress()) {
      const selected = Object.keys(identities)[0];
      this.setSelectedAddress(selected);
    }

    return address;
  }
  /**
   * Adds addresses to the identities object without removing identities
   *
   * @param {string[]} addresses - An array of hex addresses
   *
   */


  addAddresses(addresses) {
    const {
      identities
    } = this.store.getState();
    addresses.forEach(address => {
      // skip if already exists
      if (identities[address]) {
        return;
      } // add missing identity


      const identityCount = Object.keys(identities).length;
      identities[address] = {
        name: `Account ${identityCount + 1}`,
        address
      };
    });
    this.store.updateState({
      identities
    });
  }
  /**
   * Synchronizes identity entries with known accounts.
   * Removes any unknown identities, and returns the resulting selected address.
   *
   * @param {Array<string>} addresses - known to the vault.
   * @returns {Promise<string>} selectedAddress the selected address.
   */


  syncAddresses(addresses) {
    if (!Array.isArray(addresses) || addresses.length === 0) {
      throw new Error('Expected non-empty array of addresses. Error #11201');
    }

    const {
      identities,
      lostIdentities
    } = this.store.getState();
    const newlyLost = {};
    Object.keys(identities).forEach(identity => {
      if (!addresses.includes(identity)) {
        newlyLost[identity] = identities[identity];
        delete identities[identity];
      }
    }); // Identities are no longer present.

    if (Object.keys(newlyLost).length > 0) {
      // store lost accounts
      Object.keys(newlyLost).forEach(key => {
        lostIdentities[key] = newlyLost[key];
      });
    }

    this.store.updateState({
      identities,
      lostIdentities
    });
    this.addAddresses(addresses); // If the selected account is no longer valid,
    // select an arbitrary other account:

    let selected = this.getSelectedAddress();

    if (!addresses.includes(selected)) {
      selected = addresses[0];
      this.setSelectedAddress(selected);
    }

    return selected;
  }
  /**
   * Setter for the `selectedAddress` property
   *
   * @param {string} _address - A new hex address for an account
   *
   */


  setSelectedAddress(_address) {
    const address = (0, _ethSigUtil.normalize)(_address);
    const {
      identities
    } = this.store.getState();
    const selectedIdentity = identities[address];

    if (!selectedIdentity) {
      throw new Error(`Identity for '${address} not found`);
    }

    selectedIdentity.lastSelected = Date.now();
    this.store.updateState({
      identities,
      selectedAddress: address
    });
  }
  /**
   * Getter for the `selectedAddress` property
   *
   * @returns {string} The hex address for the currently selected account
   *
   */


  getSelectedAddress() {
    return this.store.getState().selectedAddress;
  }
  /**
   * Sets a custom label for an account
   * @param {string} account - the account to set a label for
   * @param {string} label - the custom label for the account
   * @returns {Promise<string>}
   */


  setAccountLabel(account, label) {
    if (!account) {
      throw new Error(`setAccountLabel requires a valid address, got ${String(account)}`);
    }

    const address = (0, _ethSigUtil.normalize)(account);
    const {
      identities
    } = this.store.getState();
    identities[address] = identities[address] || {};
    identities[address].name = label;
    this.store.updateState({
      identities
    });
    return Promise.resolve(label);
  }
  /**
   * updates custom RPC details
   *
   * @param {Object} newRpcDetails - Options bag.
   * @param {string} newRpcDetails.rpcUrl - The RPC url to add to frequentRpcList.
   * @param {string} newRpcDetails.chainId - The chainId of the selected network.
   * @param {string} [newRpcDetails.ticker] - Optional ticker symbol of the selected network.
   * @param {string} [newRpcDetails.nickname] - Optional nickname of the selected network.
   * @param {Object} [newRpcDetails.rpcPrefs] - Optional RPC preferences, such as the block explorer URL
   *
   */


  async updateRpc(newRpcDetails) {
    const rpcList = this.getFrequentRpcListDetail();
    const index = rpcList.findIndex(element => {
      return element.rpcUrl === newRpcDetails.rpcUrl;
    });

    if (index > -1) {
      const rpcDetail = rpcList[index];

      const updatedRpc = _objectSpread(_objectSpread({}, rpcDetail), newRpcDetails);

      if (rpcDetail.chainId !== updatedRpc.chainId) {
        // When the chainId is changed, associated address book entries should
        // also be migrated. The address book entries are keyed by the `network` state,
        // which for custom networks is the chainId with a fallback to the networkId
        // if the chainId is not set.
        let addressBookKey = rpcDetail.chainId;

        if (!addressBookKey) {
          // We need to find the networkId to determine what these addresses were keyed by
          try {
            addressBookKey = await this.ethersProvider.send('net_version');
            (0, _assert.strict)(typeof addressBookKey === 'string');
          } catch (error) {
            _loglevel.default.debug(error);

            _loglevel.default.warn(`Failed to get networkId from ${rpcDetail.rpcUrl}; skipping address book migration`);
          }
        } // There is an edge case where two separate RPC endpoints are keyed by the same
        // value. In this case, the contact book entries are duplicated so that they remain
        // on both networks, since we don't know which network each contact is intended for.


        let duplicate = false;
        const builtInProviderNetworkIds = Object.values(_network.NETWORK_TYPE_TO_ID_MAP).map(ids => ids.networkId);
        const otherRpcEntries = rpcList.filter(entry => entry.rpcUrl !== newRpcDetails.rpcUrl);

        if (builtInProviderNetworkIds.includes(addressBookKey) || otherRpcEntries.some(entry => entry.chainId === addressBookKey)) {
          duplicate = true;
        }

        this.migrateAddressBookState(addressBookKey, updatedRpc.chainId, duplicate);
      }

      rpcList[index] = updatedRpc;
      this.store.updateState({
        frequentRpcListDetail: rpcList
      });
    } else {
      const {
        rpcUrl,
        chainId,
        ticker,
        nickname,
        rpcPrefs = {}
      } = newRpcDetails;
      this.addToFrequentRpcList(rpcUrl, chainId, ticker, nickname, rpcPrefs);
    }
  }
  /**
   * Adds custom RPC url to state.
   *
   * @param {string} rpcUrl - The RPC url to add to frequentRpcList.
   * @param {string} chainId - The chainId of the selected network.
   * @param {string} [ticker] - Ticker symbol of the selected network.
   * @param {string} [nickname] - Nickname of the selected network.
   * @param {Object} [rpcPrefs] - Optional RPC preferences, such as the block explorer URL
   *
   */


  addToFrequentRpcList(rpcUrl, chainId, ticker = 'ETH', nickname = '', rpcPrefs = {}) {
    const rpcList = this.getFrequentRpcListDetail();
    const index = rpcList.findIndex(element => {
      return element.rpcUrl === rpcUrl;
    });

    if (index !== -1) {
      rpcList.splice(index, 1);
    }

    if (!(0, _network2.isPrefixedFormattedHexString)(chainId)) {
      throw new Error(`Invalid chainId: "${chainId}"`);
    }

    rpcList.push({
      rpcUrl,
      chainId,
      ticker,
      nickname,
      rpcPrefs
    });
    this.store.updateState({
      frequentRpcListDetail: rpcList
    });
  }
  /**
   * Removes custom RPC url from state.
   *
   * @param {string} url - The RPC url to remove from frequentRpcList.
   * @returns {Promise<array>} Promise resolving to updated frequentRpcList.
   *
   */


  removeFromFrequentRpcList(url) {
    const rpcList = this.getFrequentRpcListDetail();
    const index = rpcList.findIndex(element => {
      return element.rpcUrl === url;
    });

    if (index !== -1) {
      rpcList.splice(index, 1);
    }

    this.store.updateState({
      frequentRpcListDetail: rpcList
    });
    return Promise.resolve(rpcList);
  }
  /**
   * Getter for the `frequentRpcListDetail` property.
   *
   * @returns {array<array>} An array of rpc urls.
   *
   */


  getFrequentRpcListDetail() {
    return this.store.getState().frequentRpcListDetail;
  }
  /**
   * Updates the `featureFlags` property, which is an object. One property within that object will be set to a boolean.
   *
   * @param {string} feature - A key that corresponds to a UI feature.
   * @param {boolean} activated - Indicates whether or not the UI feature should be displayed
   * @returns {Promise<object>} Promises a new object; the updated featureFlags object.
   *
   */


  setFeatureFlag(feature, activated) {
    const currentFeatureFlags = this.store.getState().featureFlags;

    const updatedFeatureFlags = _objectSpread(_objectSpread({}, currentFeatureFlags), {}, {
      [feature]: activated
    });

    this.store.updateState({
      featureFlags: updatedFeatureFlags
    });
    return Promise.resolve(updatedFeatureFlags);
  }
  /**
   * Updates the `preferences` property, which is an object. These are user-controlled features
   * found in the settings page.
   * @param {string} preference - The preference to enable or disable.
   * @param {boolean} value - Indicates whether or not the preference should be enabled or disabled.
   * @returns {Promise<object>} Promises a new object; the updated preferences object.
   */


  setPreference(preference, value) {
    const currentPreferences = this.getPreferences();

    const updatedPreferences = _objectSpread(_objectSpread({}, currentPreferences), {}, {
      [preference]: value
    });

    this.store.updateState({
      preferences: updatedPreferences
    });
    return Promise.resolve(updatedPreferences);
  }
  /**
   * A getter for the `preferences` property
   * @returns {Object} A key-boolean map of user-selected preferences.
   */


  getPreferences() {
    return this.store.getState().preferences;
  }
  /**
   * A getter for the `ipfsGateway` property
   * @returns {string} The current IPFS gateway domain
   */


  getIpfsGateway() {
    return this.store.getState().ipfsGateway;
  }
  /**
   * A setter for the `ipfsGateway` property
   * @param {string} domain - The new IPFS gateway domain
   * @returns {Promise<string>} A promise of the update IPFS gateway domain
   */


  setIpfsGateway(domain) {
    this.store.updateState({
      ipfsGateway: domain
    });
    return Promise.resolve(domain);
  }
  /**
   * A setter for the `useWebHid` property
   * @param {string} ledgerTransportType - Either 'ledgerLive', 'webhid' or 'u2f'
   * @returns {string} The transport type that was set.
   */


  setLedgerTransportPreference(ledgerTransportType) {
    this.store.updateState({
      ledgerTransportType
    });
    return ledgerTransportType;
  }
  /**
   * A getter for the `ledgerTransportType` property
   * @returns {boolean} User preference of using WebHid to connect Ledger
   */


  getLedgerTransportPreference() {
    return this.store.getState().ledgerTransportType;
  }
  /**
   * A setter for the user preference to dismiss the seed phrase backup reminder
   * @param {bool} dismissBackupReminder- User preference for dismissing the back up reminder
   * @returns {void}
   */


  async setDismissSeedBackUpReminder(dismissSeedBackUpReminder) {
    await this.store.updateState({
      dismissSeedBackUpReminder
    });
  } //
  // PRIVATE METHODS
  //


  _subscribeToInfuraAvailability() {
    this.network.on(_network3.NETWORK_EVENTS.INFURA_IS_BLOCKED, () => {
      this._setInfuraBlocked(true);
    });
    this.network.on(_network3.NETWORK_EVENTS.INFURA_IS_UNBLOCKED, () => {
      this._setInfuraBlocked(false);
    });
  }
  /**
   *
   * A setter for the `infuraBlocked` property
   * @param {boolean} isBlocked - Bool indicating whether Infura is blocked
   *
   */


  _setInfuraBlocked(isBlocked) {
    const {
      infuraBlocked
    } = this.store.getState();

    if (infuraBlocked === isBlocked) {
      return;
    }

    this.store.updateState({
      infuraBlocked: isBlocked
    });
  }

}

exports.default = PreferencesController;


      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/preferences.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js", {"./JsonRpcEngine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/JsonRpcEngine.js","./createAsyncMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/createAsyncMiddleware.js","./createScaffoldMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js","./getUniqueId":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/getUniqueId.js","./idRemapMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/idRemapMiddleware.js","./mergeMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/mergeMiddleware.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./idRemapMiddleware"), exports);
__exportStar(require("./createAsyncMiddleware"), exports);
__exportStar(require("./createScaffoldMiddleware"), exports);
__exportStar(require("./getUniqueId"), exports);
__exportStar(require("./JsonRpcEngine"), exports);
__exportStar(require("./mergeMiddleware"), exports);

      };
    };
  }
}, {package:"json-rpc-engine",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/typed-message-manager.js", {"../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js","../../../shared/modules/hexstring-utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/hexstring-utils.js","../../../shared/modules/random-id":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/random-id.js","../metamask-controller":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/metamask-controller.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","eth-sig-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-sig-util/dist/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","jsonschema":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/jsonschema/lib/index.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/typed-message-manager.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = _interopRequireDefault(require("events"));

var _assert = require("assert");

var _obsStore = require("@metamask/obs-store");

var _ethRpcErrors = require("eth-rpc-errors");

var _ethSigUtil = require("eth-sig-util");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _jsonschema = _interopRequireDefault(require("jsonschema"));

var _app = require("../../../shared/constants/app");

var _metamaskController = require("../metamask-controller");

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

var _hexstringUtils = require("../../../shared/modules/hexstring-utils");

/**
 * Represents, and contains data about, an 'eth_signTypedData' type signature request. These are created when a
 * signature for an eth_signTypedData call is requested.
 *
 * @typedef {Object} TypedMessage
 * @property {number} id An id to track and identify the message object
 * @property {Object} msgParams The parameters to pass to the eth_signTypedData method once the signature request is
 * approved.
 * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
 * @property {Object} msgParams.from The address that is making the signature request.
 * @property {string} msgParams.data A hex string conversion of the raw buffer data of the signature request
 * @property {number} time The epoch time at which the this message was created
 * @property {string} status Indicates whether the signature request is 'unapproved', 'approved', 'signed', 'rejected', or 'errored'
 * @property {string} type The json-prc signing method for which a signature request has been made. A 'Message' will
 * always have a 'eth_signTypedData' type.
 *
 */
class TypedMessageManager extends _events.default {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - TypedMessage.
   */
  constructor({
    getCurrentChainId,
    metricEvents
  }) {
    super();
    this._getCurrentChainId = getCurrentChainId;
    this.memStore = new _obsStore.ObservableStore({
      unapprovedTypedMessages: {},
      unapprovedTypedMessagesCount: 0
    });
    this.messages = [];
    this.metricEvents = metricEvents;
  }
  /**
   * A getter for the number of 'unapproved' TypedMessages in this.messages
   *
   * @returns {number} The number of 'unapproved' TypedMessages in this.messages
   *
   */


  get unapprovedTypedMessagesCount() {
    return Object.keys(this.getUnapprovedMsgs()).length;
  }
  /**
   * A getter for the 'unapproved' TypedMessages in this.messages
   *
   * @returns {Object} An index of TypedMessage ids to TypedMessages, for all 'unapproved' TypedMessages in
   * this.messages
   *
   */


  getUnapprovedMsgs() {
    return this.messages.filter(msg => msg.status === 'unapproved').reduce((result, msg) => {
      result[msg.id] = msg;
      return result;
    }, {});
  }
  /**
   * Creates a new TypedMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new TypedMessage to this.messages, and to save the unapproved TypedMessages from that list to
   * this.memStore. Before any of this is done, msgParams are validated
   *
   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {promise} When the message has been signed or rejected
   *
   */


  addUnapprovedMessageAsync(msgParams, req, version) {
    return new Promise((resolve, reject) => {
      const msgId = this.addUnapprovedMessage(msgParams, req, version);
      this.once(`${msgId}:finished`, data => {
        switch (data.status) {
          case 'signed':
            return resolve(data.rawSig);

          case 'rejected':
            return reject(_ethRpcErrors.ethErrors.provider.userRejectedRequest('MetaMask Message Signature: User denied message signature.'));

          case 'errored':
            return reject(new Error(`MetaMask Message Signature: ${data.error}`));

          default:
            return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(msgParams)}`));
        }
      });
    });
  }
  /**
   * Creates a new TypedMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new TypedMessage to this.messages, and to save the unapproved TypedMessages from that list to
   * this.memStore. Before any of this is done, msgParams are validated
   *
   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {number} The id of the newly created TypedMessage.
   *
   */


  addUnapprovedMessage(msgParams, req, version) {
    msgParams.version = version;

    if (req) {
      msgParams.origin = req.origin;
    }

    this.validateParams(msgParams);

    _loglevel.default.debug(`TypedMessageManager addUnapprovedMessage: ${JSON.stringify(msgParams)}`); // create txData obj with parameters and meta data


    const time = new Date().getTime();
    const msgId = (0, _randomId.default)();
    const msgData = {
      id: msgId,
      msgParams,
      time,
      status: 'unapproved',
      type: _app.MESSAGE_TYPE.ETH_SIGN_TYPED_DATA
    };
    this.addMsg(msgData); // signal update

    this.emit('update');
    return msgId;
  }
  /**
   * Helper method for this.addUnapprovedMessage. Validates that the passed params have the required properties.
   *
   * @param {Object} params - The params to validate
   *
   */


  validateParams(params) {
    _assert.strict.ok(params && typeof params === 'object', 'Params must be an object.');

    _assert.strict.ok('data' in params, 'Params must include a "data" field.');

    _assert.strict.ok('from' in params, 'Params must include a "from" field.');

    _assert.strict.ok(typeof params.from === 'string' && (0, _hexstringUtils.isValidHexAddress)(params.from, {
      allowNonPrefixed: false
    }), '"from" field must be a valid, lowercase, hexadecimal Ethereum address string.');

    switch (params.version) {
      case 'V1':
        _assert.strict.ok(Array.isArray(params.data), '"params.data" must be an array.');

        _assert.strict.doesNotThrow(() => {
          (0, _ethSigUtil.typedSignatureHash)(params.data);
        }, 'Signing data must be valid EIP-712 typed data.');

        break;

      case 'V3':
      case 'V4':
        {
          _assert.strict.equal(typeof params.data, 'string', '"params.data" must be a string.');

          let data;

          _assert.strict.doesNotThrow(() => {
            data = JSON.parse(params.data);
          }, '"data" must be a valid JSON string.');

          const validation = _jsonschema.default.validate(data, _ethSigUtil.TYPED_MESSAGE_SCHEMA);

          _assert.strict.ok(data.primaryType in data.types, `Primary type of "${data.primaryType}" has no type definition.`);

          _assert.strict.equal(validation.errors.length, 0, 'Signing data must conform to EIP-712 schema. See https://git.io/fNtcx.');

          let {
            chainId
          } = data.domain;

          if (chainId) {
            const activeChainId = parseInt(this._getCurrentChainId(), 16);

            _assert.strict.ok(!Number.isNaN(activeChainId), `Cannot sign messages for chainId "${chainId}", because MetaMask is switching networks.`);

            if (typeof chainId === 'string') {
              chainId = parseInt(chainId, chainId.startsWith('0x') ? 16 : 10);
            }

            _assert.strict.equal(chainId, activeChainId, `Provided chainId "${chainId}" must match the active chainId "${activeChainId}"`);
          }

          break;
        }

      default:
        _assert.strict.fail(`Unknown typed data version "${params.version}"`);

    }
  }
  /**
   * Adds a passed TypedMessage to this.messages, and calls this._saveMsgList() to save the unapproved TypedMessages from that
   * list to this.memStore.
   *
   * @param {Message} msg - The TypedMessage to add to this.messages
   *
   */


  addMsg(msg) {
    this.messages.push(msg);

    this._saveMsgList();
  }
  /**
   * Returns a specified TypedMessage.
   *
   * @param {number} msgId - The id of the TypedMessage to get
   * @returns {TypedMessage|undefined} The TypedMessage with the id that matches the passed msgId, or undefined
   * if no TypedMessage has that id.
   *
   */


  getMsg(msgId) {
    return this.messages.find(msg => msg.id === msgId);
  }
  /**
   * Approves a TypedMessage. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise
   * with any the message params modified for proper signing.
   *
   * @param {Object} msgParams - The msgParams to be used when eth_sign is called, plus data added by MetaMask.
   * @param {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.
   *
   */


  approveMessage(msgParams) {
    this.setMsgStatusApproved(msgParams.metamaskId);
    return this.prepMsgForSigning(msgParams);
  }
  /**
   * Sets a TypedMessage status to 'approved' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the TypedMessage to approve.
   *
   */


  setMsgStatusApproved(msgId) {
    this._setMsgStatus(msgId, 'approved');
  }
  /**
   * Sets a TypedMessage status to 'signed' via a call to this._setMsgStatus and updates that TypedMessage in
   * this.messages by adding the raw signature data of the signature request to the TypedMessage
   *
   * @param {number} msgId - The id of the TypedMessage to sign.
   * @param {buffer} rawSig - The raw data of the signature request
   *
   */


  setMsgStatusSigned(msgId, rawSig) {
    const msg = this.getMsg(msgId);
    msg.rawSig = rawSig;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'signed');
  }
  /**
   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams
   *
   * @param {Object} msgParams - The msgParams to modify
   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed
   *
   */


  prepMsgForSigning(msgParams) {
    delete msgParams.metamaskId;
    delete msgParams.version;
    return Promise.resolve(msgParams);
  }
  /**
   * Sets a TypedMessage status to 'rejected' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the TypedMessage to reject.
   *
   */


  rejectMsg(msgId, reason = undefined) {
    if (reason) {
      const msg = this.getMsg(msgId);
      this.metricsEvent({
        event: reason,
        category: 'Transactions',
        properties: {
          action: 'Sign Request',
          version: msg.msgParams.version,
          type: msg.type
        }
      });
    }

    this._setMsgStatus(msgId, 'rejected');
  }
  /**
   * Sets a TypedMessage status to 'errored' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the TypedMessage to error
   *
   */


  errorMessage(msgId, error) {
    const msg = this.getMsg(msgId);
    msg.error = error;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'errored');
  }
  /**
   * Clears all unapproved messages from memory.
   */


  clearUnapproved() {
    this.messages = this.messages.filter(msg => msg.status !== 'unapproved');

    this._saveMsgList();
  } //
  // PRIVATE METHODS
  //

  /**
   * Updates the status of a TypedMessage in this.messages via a call to this._updateMsg
   *
   * @private
   * @param {number} msgId - The id of the TypedMessage to update.
   * @param {string} status - The new status of the TypedMessage.
   * @throws A 'TypedMessageManager - TypedMessage not found for id: "${msgId}".' if there is no TypedMessage
   * in this.messages with an id equal to the passed msgId
   * @fires An event with a name equal to `${msgId}:${status}`. The TypedMessage is also fired.
   * @fires If status is 'rejected' or 'signed', an event with a name equal to `${msgId}:finished` is fired along
   * with the TypedMessage
   *
   */


  _setMsgStatus(msgId, status) {
    const msg = this.getMsg(msgId);

    if (!msg) {
      throw new Error(`TypedMessageManager - Message not found for id: "${msgId}".`);
    }

    msg.status = status;

    this._updateMsg(msg);

    this.emit(`${msgId}:${status}`, msg);

    if (status === 'rejected' || status === 'signed' || status === 'errored') {
      this.emit(`${msgId}:finished`, msg);
    }
  }
  /**
   * Sets a TypedMessage in this.messages to the passed TypedMessage if the ids are equal. Then saves the
   * unapprovedTypedMsgs index to storage via this._saveMsgList
   *
   * @private
   * @param {msg} TypedMessage - A TypedMessage that will replace an existing TypedMessage (with the same
   * id) in this.messages
   *
   */


  _updateMsg(msg) {
    const index = this.messages.findIndex(message => message.id === msg.id);

    if (index !== -1) {
      this.messages[index] = msg;
    }

    this._saveMsgList();
  }
  /**
   * Saves the unapproved TypedMessages, and their count, to this.memStore
   *
   * @private
   * @fires 'updateBadge'
   *
   */


  _saveMsgList() {
    const unapprovedTypedMessages = this.getUnapprovedMsgs();
    const unapprovedTypedMessagesCount = Object.keys(unapprovedTypedMessages).length;
    this.memStore.updateState({
      unapprovedTypedMessages,
      unapprovedTypedMessagesCount
    });
    this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
  }

}

exports.default = TypedMessageManager;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/typed-message-manager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/ens/index.js", {"../../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","../../../../shared/modules/hexstring-utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/hexstring-utils.js","./ens":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/ens/ens.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js","punycode/punycode":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/punycode/punycode.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/ens/index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _punycode = _interopRequireDefault(require("punycode/punycode"));

var _obsStore = require("@metamask/obs-store");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _network = require("../../../../shared/constants/network");

var _hexstringUtils = require("../../../../shared/modules/hexstring-utils");

var _ens = _interopRequireDefault(require("./ens"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
const ZERO_X_ERROR_ADDRESS = '0x';

class EnsController {
  constructor({
    ens,
    provider,
    onNetworkDidChange,
    getCurrentChainId
  } = {}) {
    const initState = {
      ensResolutionsByAddress: {}
    };
    this._ens = ens;

    if (!this._ens) {
      const chainId = getCurrentChainId();
      const network = _network.CHAIN_ID_TO_NETWORK_ID_MAP[chainId];

      if (_ens.default.getNetworkEnsSupport(network)) {
        this._ens = new _ens.default({
          network,
          provider
        });
      }
    }

    this.store = new _obsStore.ObservableStore(initState);
    onNetworkDidChange(() => {
      this.store.putState(initState);
      const chainId = getCurrentChainId();
      const network = _network.CHAIN_ID_TO_NETWORK_ID_MAP[chainId];

      if (_ens.default.getNetworkEnsSupport(network)) {
        this._ens = new _ens.default({
          network,
          provider
        });
      } else {
        delete this._ens;
      }
    });
  }

  reverseResolveAddress(address) {
    return this._reverseResolveAddress((0, _hexstringUtils.toChecksumHexAddress)(address));
  }

  async _reverseResolveAddress(address) {
    if (!this._ens) {
      return undefined;
    }

    const state = this.store.getState();

    if (state.ensResolutionsByAddress[address]) {
      return state.ensResolutionsByAddress[address];
    }

    let domain;

    try {
      domain = await this._ens.reverse(address);
    } catch (error) {
      _loglevel.default.debug(error);

      return undefined;
    }

    let registeredAddress;

    try {
      registeredAddress = await this._ens.lookup(domain);
    } catch (error) {
      _loglevel.default.debug(error);

      return undefined;
    }

    if (registeredAddress === ZERO_ADDRESS || registeredAddress === ZERO_X_ERROR_ADDRESS) {
      return undefined;
    }

    if ((0, _hexstringUtils.toChecksumHexAddress)(registeredAddress) !== address) {
      return undefined;
    }

    this._updateResolutionsByAddress(address, _punycode.default.toASCII(domain));

    return domain;
  }

  _updateResolutionsByAddress(address, domain) {
    const oldState = this.store.getState();
    this.store.putState({
      ensResolutionsByAddress: _objectSpread(_objectSpread({}, oldState.ensResolutionsByAddress), {}, {
        [address]: domain
      })
    });
  }

}

exports.default = EnsController;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/ens/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/index.js", {"../../../../shared/constants/gas":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/gas.js","../../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","../../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","../../../../shared/modules/contract-utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/contract-utils.js","../../../../shared/modules/conversion.utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/conversion.utils.js","../../../../shared/modules/transaction.utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/transaction.utils.js","../../../../ui/helpers/constants/error-keys":"/home/clarisco/Desktop/metamask-extension-develop/ui/helpers/constants/error-keys.js","../../../../ui/helpers/constants/transactions":"/home/clarisco/Desktop/metamask-extension-develop/ui/helpers/constants/transactions.js","../../../../ui/helpers/utils/conversions.util":"/home/clarisco/Desktop/metamask-extension-develop/ui/helpers/utils/conversions.util.js","../../../../ui/pages/swaps/swaps.util":"/home/clarisco/Desktop/metamask-extension-develop/ui/pages/swaps/swaps.util.js","../../lib/cleanErrorStack":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/cleanErrorStack.js","../../lib/util":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/util.js","../../metamask-controller":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/metamask-controller.js","./lib/util":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/lib/util.js","./pending-tx-tracker":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/pending-tx-tracker.js","./tx-gas-utils":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/tx-gas-utils.js","./tx-state-manager":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/tx-state-manager.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@ethereumjs/common":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ethereumjs/common/dist.browser/index.js","@ethereumjs/tx":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ethereumjs/tx/dist.browser/index.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","bignumber.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bignumber.js/bignumber.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","ethers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethers/lib/index.js","ethjs-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-query/lib/index.js","human-standard-token-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/human-standard-token-abi/index.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js","nonce-tracker":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/nonce-tracker/index.js","safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-event-emitter/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TRANSACTION_EVENTS = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _safeEventEmitter = _interopRequireDefault(require("safe-event-emitter"));

var _obsStore = require("@metamask/obs-store");

var _ethereumjsUtil = require("ethereumjs-util");

var _ethjsQuery = _interopRequireDefault(require("ethjs-query"));

var _ethRpcErrors = require("eth-rpc-errors");

var _humanStandardTokenAbi = _interopRequireDefault(require("human-standard-token-abi"));

var _common = _interopRequireDefault(require("@ethereumjs/common"));

var _tx = require("@ethereumjs/tx");

var _ethers = require("ethers");

var _nonceTracker = _interopRequireDefault(require("nonce-tracker"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _cleanErrorStack = _interopRequireDefault(require("../../lib/cleanErrorStack"));

var _util = require("../../lib/util");

var _errorKeys = require("../../../../ui/helpers/constants/error-keys");

var _swaps = require("../../../../ui/pages/swaps/swaps.util");

var _conversions = require("../../../../ui/helpers/utils/conversions.util");

var _transaction = require("../../../../shared/constants/transaction");

var _transactions = require("../../../../ui/helpers/constants/transactions");

var _metamaskController = require("../../metamask-controller");

var _gas = require("../../../../shared/constants/gas");

var _conversion = require("../../../../shared/modules/conversion.utils");

var _network = require("../../../../shared/constants/network");

var _transaction2 = require("../../../../shared/modules/transaction.utils");

var _contractUtils = require("../../../../shared/modules/contract-utils");

var _txStateManager = _interopRequireDefault(require("./tx-state-manager"));

var _txGasUtils = _interopRequireDefault(require("./tx-gas-utils"));

var _pendingTxTracker = _interopRequireDefault(require("./pending-tx-tracker"));

var txUtils = _interopRequireWildcard(require("./lib/util"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const hstInterface = new _ethers.ethers.utils.Interface(_humanStandardTokenAbi.default);
const MAX_MEMSTORE_TX_LIST_SIZE = 100; // Number of transactions (by unique nonces) to keep in memory

const TRANSACTION_EVENTS = {
  ADDED: 'Transaction Added',
  APPROVED: 'Transaction Approved',
  FINALIZED: 'Transaction Finalized',
  REJECTED: 'Transaction Rejected',
  SUBMITTED: 'Transaction Submitted'
};
/**
 * @typedef {Object} CustomGasSettings
 * @property {string} [gas] - The gas limit to use for the transaction
 * @property {string} [gasPrice] - The gasPrice to use for a legacy transaction
 * @property {string} [maxFeePerGas] - The maximum amount to pay per gas on a
 *  EIP-1559 transaction
 * @property {string} [maxPriorityFeePerGas] - The maximum amount of paid fee
 *  to be distributed to miner in an EIP-1559 transaction
 */

/**
  Transaction Controller is an aggregate of sub-controllers and trackers
  composing them in a way to be exposed to the metamask controller
    <br>- txStateManager
      responsible for the state of a transaction and
      storing the transaction
    <br>- pendingTxTracker
      watching blocks for transactions to be include
      and emitting confirmed events
    <br>- txGasUtil
      gas calculations and safety buffering
    <br>- nonceTracker
      calculating nonces

  @class
  @param {Object} opts
  @param {Object} opts.initState - initial transaction list default is an empty array
  @param {Object} opts.networkStore - an observable store for network number
  @param {Object} opts.blockTracker - An instance of eth-blocktracker
  @param {Object} opts.provider - A network provider.
  @param {Function} opts.signTransaction - function the signs an @ethereumjs/tx
  @param {Object} opts.getPermittedAccounts - get accounts that an origin has permissions for
  @param {Function} opts.signTransaction - ethTx signer that returns a rawTx
  @param {number} [opts.txHistoryLimit] - number *optional* for limiting how many transactions are in state
  @param {Object} opts.preferencesStore
*/

exports.TRANSACTION_EVENTS = TRANSACTION_EVENTS;

class TransactionController extends _safeEventEmitter.default {
  constructor(opts) {
    super();
    this.networkStore = opts.networkStore || new _obsStore.ObservableStore({});
    this._getCurrentChainId = opts.getCurrentChainId;
    this.getProviderConfig = opts.getProviderConfig;
    this._getCurrentNetworkEIP1559Compatibility = opts.getCurrentNetworkEIP1559Compatibility;
    this._getCurrentAccountEIP1559Compatibility = opts.getCurrentAccountEIP1559Compatibility;
    this.preferencesStore = opts.preferencesStore || new _obsStore.ObservableStore({});
    this.provider = opts.provider;
    this.getPermittedAccounts = opts.getPermittedAccounts;
    this.blockTracker = opts.blockTracker;
    this.signEthTx = opts.signTransaction;
    this.inProcessOfSigning = new Set();
    this._trackMetaMetricsEvent = opts.trackMetaMetricsEvent;
    this._getParticipateInMetrics = opts.getParticipateInMetrics;
    this._getEIP1559GasFeeEstimates = opts.getEIP1559GasFeeEstimates;
    this.memStore = new _obsStore.ObservableStore({});
    this.query = new _ethjsQuery.default(this.provider);
    this.txGasUtil = new _txGasUtils.default(this.provider);

    this._mapMethods();

    this.txStateManager = new _txStateManager.default({
      initState: opts.initState,
      txHistoryLimit: opts.txHistoryLimit,
      getNetwork: this.getNetwork.bind(this),
      getCurrentChainId: opts.getCurrentChainId
    });

    this._onBootCleanUp();

    this.store = this.txStateManager.store;
    this.nonceTracker = new _nonceTracker.default({
      provider: this.provider,
      blockTracker: this.blockTracker,
      getPendingTransactions: this.txStateManager.getPendingTransactions.bind(this.txStateManager),
      getConfirmedTransactions: this.txStateManager.getConfirmedTransactions.bind(this.txStateManager)
    });
    this.pendingTxTracker = new _pendingTxTracker.default({
      provider: this.provider,
      nonceTracker: this.nonceTracker,
      publishTransaction: rawTx => this.query.sendRawTransaction(rawTx),
      getPendingTransactions: () => {
        const pending = this.txStateManager.getPendingTransactions();
        const approved = this.txStateManager.getApprovedTransactions();
        return [...pending, ...approved];
      },
      approveTransaction: this.approveTransaction.bind(this),
      getCompletedTransactions: this.txStateManager.getConfirmedTransactions.bind(this.txStateManager)
    });
    this.txStateManager.store.subscribe(() => this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE));

    this._setupListeners(); // memstore is computed from a few different stores


    this._updateMemstore();

    this.txStateManager.store.subscribe(() => this._updateMemstore());
    this.networkStore.subscribe(() => {
      this._onBootCleanUp();

      this._updateMemstore();
    }); // request state update to finalize initialization

    this._updatePendingTxsAfterFirstBlock();
  }
  /**
   * Gets the current chainId in the network store as a number, returning 0 if
   * the chainId parses to NaN.
   *
   * @returns {number} The numerical chainId.
   */


  getChainId() {
    const networkState = this.networkStore.getState();

    const chainId = this._getCurrentChainId();

    const integerChainId = parseInt(chainId, 16);

    if (networkState === 'loading' || Number.isNaN(integerChainId)) {
      return 0;
    }

    return integerChainId;
  }

  async getEIP1559Compatibility(fromAddress) {
    const currentNetworkIsCompatible = await this._getCurrentNetworkEIP1559Compatibility();
    const fromAccountIsCompatible = await this._getCurrentAccountEIP1559Compatibility(fromAddress);
    return currentNetworkIsCompatible && fromAccountIsCompatible;
  }
  /**
   * @ethereumjs/tx uses @ethereumjs/common as a configuration tool for
   * specifying which chain, network, hardfork and EIPs to support for
   * a transaction. By referencing this configuration, and analyzing the fields
   * specified in txParams, @ethereumjs/tx is able to determine which EIP-2718
   * transaction type to use.
   * @returns {Common} common configuration object
   */


  async getCommonConfiguration(fromAddress) {
    const {
      type,
      nickname: name
    } = this.getProviderConfig();
    const supportsEIP1559 = await this.getEIP1559Compatibility(fromAddress); // This logic below will have to be updated each time a hardfork happens
    // that carries with it a new Transaction type. It is inconsequential for
    // hardforks that do not include new types.

    const hardfork = supportsEIP1559 ? _network.HARDFORKS.LONDON : _network.HARDFORKS.BERLIN; // type will be one of our default network names or 'rpc'. the default
    // network names are sufficient configuration, simply pass the name as the
    // chain argument in the constructor.

    if (type !== _network.NETWORK_TYPE_RPC) {
      return new _common.default({
        chain: type,
        hardfork
      });
    } // For 'rpc' we need to use the same basic configuration as mainnet,
    // since we only support EVM compatible chains, and then override the
    // name, chainId and networkId properties. This is done using the
    // `forCustomChain` static method on the Common class.


    const chainId = parseInt(this._getCurrentChainId(), 16);
    const networkId = this.networkStore.getState();
    const customChainParams = {
      name,
      chainId,
      // It is improbable for a transaction to be signed while the network
      // is loading for two reasons.
      // 1. Pending, unconfirmed transactions are wiped on network change
      // 2. The UI is unusable (loading indicator) when network is loading.
      // setting the networkId to 0 is for type safety and to explicity lead
      // the transaction to failing if a user is able to get to this branch
      // on a custom network that requires valid network id. I have not ran
      // into this limitation on any network I have attempted, even when
      // hardcoding networkId to 'loading'.
      networkId: networkId === 'loading' ? 0 : parseInt(networkId, 10)
    };
    return _common.default.forCustomChain(_network.MAINNET, customChainParams, hardfork);
  }
  /**
  Adds a tx to the txlist
  @emits ${txMeta.id}:unapproved
  */


  addTransaction(txMeta) {
    this.txStateManager.addTransaction(txMeta);
    this.emit(`${txMeta.id}:unapproved`, txMeta);

    this._trackTransactionMetricsEvent(txMeta, TRANSACTION_EVENTS.ADDED);
  }
  /**
  Wipes the transactions for a given account
  @param {string} address - hex string of the from address for txs being removed
  */


  wipeTransactions(address) {
    this.txStateManager.wipeTransactions(address);
  }
  /**
   * Add a new unapproved transaction to the pipeline
   *
   * @returns {Promise<string>} the hash of the transaction after being submitted to the network
   * @param {Object} txParams - txParams for the transaction
   * @param {Object} opts - with the key origin to put the origin on the txMeta
   */


  async newUnapprovedTransaction(txParams, opts = {}) {
    _loglevel.default.debug(`MetaMaskController newUnapprovedTransaction ${JSON.stringify(txParams)}`);

    const initialTxMeta = await this.addUnapprovedTransaction(txParams, opts.origin); // listen for tx completion (success, fail)

    return new Promise((resolve, reject) => {
      this.txStateManager.once(`${initialTxMeta.id}:finished`, finishedTxMeta => {
        switch (finishedTxMeta.status) {
          case _transaction.TRANSACTION_STATUSES.SUBMITTED:
            return resolve(finishedTxMeta.hash);

          case _transaction.TRANSACTION_STATUSES.REJECTED:
            return reject((0, _cleanErrorStack.default)(_ethRpcErrors.ethErrors.provider.userRejectedRequest('MetaMask Tx Signature: User denied transaction signature.')));

          case _transaction.TRANSACTION_STATUSES.FAILED:
            return reject((0, _cleanErrorStack.default)(_ethRpcErrors.ethErrors.rpc.internal(finishedTxMeta.err.message)));

          default:
            return reject((0, _cleanErrorStack.default)(_ethRpcErrors.ethErrors.rpc.internal(`MetaMask Tx Signature: Unknown problem: ${JSON.stringify(finishedTxMeta.txParams)}`)));
        }
      });
    });
  }
  /**
   * Validates and generates a txMeta with defaults and puts it in txStateManager
   * store.
   *
   * @returns {txMeta}
   */


  async addUnapprovedTransaction(txParams, origin) {
    // validate
    const normalizedTxParams = txUtils.normalizeTxParams(txParams);
    const eip1559Compatibility = await this.getEIP1559Compatibility();
    txUtils.validateTxParams(normalizedTxParams, eip1559Compatibility);
    /**
    `generateTxMeta` adds the default txMeta properties to the passed object.
    These include the tx's `id`. As we use the id for determining order of
    txes in the tx-state-manager, it is necessary to call the asynchronous
    method `this._determineTransactionType` after `generateTxMeta`.
    */

    let txMeta = this.txStateManager.generateTxMeta({
      txParams: normalizedTxParams,
      origin
    });

    if (origin === 'metamask') {
      // Assert the from address is the selected address
      if (normalizedTxParams.from !== this.getSelectedAddress()) {
        throw _ethRpcErrors.ethErrors.rpc.internal({
          message: `Internally initiated transaction is using invalid account.`,
          data: {
            origin,
            fromAddress: normalizedTxParams.from,
            selectedAddress: this.getSelectedAddress()
          }
        });
      }
    } else {
      // Assert that the origin has permissions to initiate transactions from
      // the specified address
      const permittedAddresses = await this.getPermittedAccounts(origin);

      if (!permittedAddresses.includes(normalizedTxParams.from)) {
        throw _ethRpcErrors.ethErrors.provider.unauthorized({
          data: {
            origin
          }
        });
      }
    }

    const {
      type,
      getCodeResponse
    } = await this._determineTransactionType(txParams);
    txMeta.type = type; // ensure value

    txMeta.txParams.value = txMeta.txParams.value ? (0, _util.addHexPrefix)(txMeta.txParams.value) : '0x0';
    this.addTransaction(txMeta);
    this.emit('newUnapprovedTx', txMeta);

    try {
      txMeta = await this.addTxGasDefaults(txMeta, getCodeResponse);
    } catch (error) {
      _loglevel.default.warn(error);

      txMeta = this.txStateManager.getTransaction(txMeta.id);
      txMeta.loadingDefaults = false;
      this.txStateManager.updateTransaction(txMeta, 'Failed to calculate gas defaults.');
      throw error;
    }

    txMeta.loadingDefaults = false; // save txMeta

    this.txStateManager.updateTransaction(txMeta, 'Added new unapproved transaction.');
    return txMeta;
  }
  /**
   * Adds the tx gas defaults: gas && gasPrice
   * @param {Object} txMeta - the txMeta object
   * @returns {Promise<object>} resolves with txMeta
   */


  async addTxGasDefaults(txMeta, getCodeResponse) {
    const eip1559Compatibility = txMeta.txParams.type !== _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY && (await this.getEIP1559Compatibility());
    const {
      gasPrice: defaultGasPrice,
      maxFeePerGas: defaultMaxFeePerGas,
      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas
    } = await this._getDefaultGasFees(txMeta, eip1559Compatibility);
    const {
      gasLimit: defaultGasLimit,
      simulationFails
    } = await this._getDefaultGasLimit(txMeta, getCodeResponse); // eslint-disable-next-line no-param-reassign

    txMeta = this.txStateManager.getTransaction(txMeta.id);

    if (simulationFails) {
      txMeta.simulationFails = simulationFails;
    }

    if (eip1559Compatibility) {
      // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas
      //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.
      if (txMeta.txParams.gasPrice && !txMeta.txParams.maxFeePerGas && !txMeta.txParams.maxPriorityFeePerGas) {
        txMeta.txParams.maxFeePerGas = txMeta.txParams.gasPrice;
        txMeta.txParams.maxPriorityFeePerGas = txMeta.txParams.gasPrice;

        if (false) {
          txMeta.userFeeLevel = _gas.PRIORITY_LEVELS.DAPP_SUGGESTED;
        } else {
          txMeta.userFeeLevel = _gas.CUSTOM_GAS_ESTIMATE;
        }
      } else {
        if (defaultMaxFeePerGas && defaultMaxPriorityFeePerGas && !txMeta.txParams.maxFeePerGas && !txMeta.txParams.maxPriorityFeePerGas || txMeta.origin === 'metamask') {
          txMeta.userFeeLevel = _gas.GAS_RECOMMENDATIONS.MEDIUM;
        } else if (false) {
          txMeta.userFeeLevel = _gas.PRIORITY_LEVELS.DAPP_SUGGESTED;
        } else {
          txMeta.userFeeLevel = _gas.CUSTOM_GAS_ESTIMATE;
        }

        if (defaultMaxFeePerGas && !txMeta.txParams.maxFeePerGas) {
          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas
          // with the one returned by the gasFeeController, if that is available.
          txMeta.txParams.maxFeePerGas = defaultMaxFeePerGas;
        }

        if (defaultMaxPriorityFeePerGas && !txMeta.txParams.maxPriorityFeePerGas) {
          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas
          // with the one returned by the gasFeeController, if that is available.
          txMeta.txParams.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;
        }

        if (defaultGasPrice && !txMeta.txParams.maxFeePerGas) {
          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available
          // from the gasFeeController, then we set maxFeePerGas to the defaultGasPrice, assuming it is
          // available.
          txMeta.txParams.maxFeePerGas = defaultGasPrice;
        }

        if (txMeta.txParams.maxFeePerGas && !txMeta.txParams.maxPriorityFeePerGas) {
          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is
          // available from the gasFeeController, then we set maxPriorityFeePerGas to
          // txMeta.txParams.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas
          // set by the dapp, or the maxFeePerGas from the controller.
          txMeta.txParams.maxPriorityFeePerGas = txMeta.txParams.maxFeePerGas;
        }
      } // We remove the gasPrice param entirely when on an eip1559 compatible network


      delete txMeta.txParams.gasPrice;
    } else {
      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params
      // when not on a EIP1559 compatible network
      delete txMeta.txParams.maxPriorityFeePerGas;
      delete txMeta.txParams.maxFeePerGas;
    } // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are
    // set on txParams, it means that either we are on a non-EIP1559 network and the dapp didn't suggest
    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas
    // were available from either the dapp or the network.


    if (defaultGasPrice && !txMeta.txParams.gasPrice && !txMeta.txParams.maxPriorityFeePerGas && !txMeta.txParams.maxFeePerGas) {
      txMeta.txParams.gasPrice = defaultGasPrice;
    }

    if (defaultGasLimit && !txMeta.txParams.gas) {
      txMeta.txParams.gas = defaultGasLimit;
    }

    return txMeta;
  }
  /**
   * Gets default gas fees, or returns `undefined` if gas fees are already set
   * @param {Object} txMeta - The txMeta object
   * @returns {Promise<string|undefined>} The default gas price
   */


  async _getDefaultGasFees(txMeta, eip1559Compatibility) {
    if (!eip1559Compatibility && txMeta.txParams.gasPrice || eip1559Compatibility && txMeta.txParams.maxFeePerGas && txMeta.txParams.maxPriorityFeePerGas) {
      return {};
    }

    try {
      const {
        gasFeeEstimates,
        gasEstimateType
      } = await this._getEIP1559GasFeeEstimates();

      if (eip1559Compatibility && gasEstimateType === _gas.GAS_ESTIMATE_TYPES.FEE_MARKET) {
        const {
          medium: {
            suggestedMaxPriorityFeePerGas,
            suggestedMaxFeePerGas
          } = {}
        } = gasFeeEstimates;

        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
          return {
            maxFeePerGas: (0, _conversion.decGWEIToHexWEI)(suggestedMaxFeePerGas),
            maxPriorityFeePerGas: (0, _conversion.decGWEIToHexWEI)(suggestedMaxPriorityFeePerGas)
          };
        }
      } else if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.LEGACY) {
        // The LEGACY type includes low, medium and high estimates of
        // gas price values.
        return {
          gasPrice: (0, _conversion.decGWEIToHexWEI)(gasFeeEstimates.medium)
        };
      } else if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
        // The ETH_GASPRICE type just includes a single gas price property,
        // which we can assume was retrieved from eth_gasPrice
        return {
          gasPrice: (0, _conversion.decGWEIToHexWEI)(gasFeeEstimates.gasPrice)
        };
      }
    } catch (e) {
      console.error(e);
    }

    const gasPrice = await this.query.gasPrice();
    return {
      gasPrice: gasPrice && (0, _util.addHexPrefix)(gasPrice.toString(16))
    };
  }
  /**
   * Gets default gas limit, or debug information about why gas estimate failed.
   * @param {Object} txMeta - The txMeta object
   * @param {string} getCodeResponse - The transaction category code response, used for debugging purposes
   * @returns {Promise<Object>} Object containing the default gas limit, or the simulation failure object
   */


  async _getDefaultGasLimit(txMeta, getCodeResponse) {
    const chainId = this._getCurrentChainId();

    const customNetworkGasBuffer = _network.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP[chainId];
    const chainType = (0, _util.getChainType)(chainId);

    if (txMeta.txParams.gas) {
      return {};
    } else if (txMeta.txParams.to && txMeta.type === _transaction.TRANSACTION_TYPES.SIMPLE_SEND && chainType !== 'custom') {
      // if there's data in the params, but there's no contract code, it's not a valid transaction
      if (txMeta.txParams.data) {
        const err = new Error('TxGasUtil - Trying to call a function on a non-contract address'); // set error key so ui can display localized error message

        err.errorKey = _errorKeys.TRANSACTION_NO_CONTRACT_ERROR_KEY; // set the response on the error so that we can see in logs what the actual response was

        err.getCodeResponse = getCodeResponse;
        throw err;
      } // This is a standard ether simple send, gas requirement is exactly 21k


      return {
        gasLimit: _gas.GAS_LIMITS.SIMPLE
      };
    }

    const {
      blockGasLimit,
      estimatedGasHex,
      simulationFails
    } = await this.txGasUtil.analyzeGasUsage(txMeta); // add additional gas buffer to our estimation for safety

    const gasLimit = this.txGasUtil.addGasBuffer((0, _util.addHexPrefix)(estimatedGasHex), blockGasLimit, customNetworkGasBuffer);
    return {
      gasLimit,
      simulationFails
    };
  }
  /**
   * Given a TransactionMeta object, generate new gas params such that if the
   * transaction was an EIP1559 transaction, it only has EIP1559 gas fields,
   * otherwise it only has gasPrice. Will use whatever custom values are
   * specified in customGasSettings, or falls back to incrementing by a percent
   * which is defined by specifying a numerator. 11 is a 10% bump, 12 would be
   * a 20% bump, and so on.
   * @param {__import__(
   *  '../../../../shared/constants/transaction'
   * ).TransactionMeta} originalTxMeta - Original transaction to use as base
   * @param {CustomGasSettings} [customGasSettings] - overrides for the gas
   *  fields to use instead of the multiplier
   * @param {number} [incrementNumerator] - Numerator from which to generate a
   *  percentage bump of gas price. E.g 11 would be a 10% bump over base.
   * @returns {{ newGasParams: CustomGasSettings, previousGasParams: CustomGasSettings }}
   */


  generateNewGasParams(originalTxMeta, customGasSettings = {}, incrementNumerator = 11) {
    const {
      txParams
    } = originalTxMeta;
    const previousGasParams = {};
    const newGasParams = {};

    if (customGasSettings.gasLimit) {
      var _customGasSettings$ga;

      newGasParams.gas = (_customGasSettings$ga = customGasSettings === null || customGasSettings === void 0 ? void 0 : customGasSettings.gas) !== null && _customGasSettings$ga !== void 0 ? _customGasSettings$ga : _gas.GAS_LIMITS.SIMPLE;
    }

    if (customGasSettings.estimateSuggested) {
      newGasParams.estimateSuggested = customGasSettings.estimateSuggested;
    }

    if (customGasSettings.estimateUsed) {
      newGasParams.estimateUsed = customGasSettings.estimateUsed;
    }

    if ((0, _transaction2.isEIP1559Transaction)(originalTxMeta)) {
      previousGasParams.maxFeePerGas = txParams.maxFeePerGas;
      previousGasParams.maxPriorityFeePerGas = txParams.maxPriorityFeePerGas;
      newGasParams.maxFeePerGas = (customGasSettings === null || customGasSettings === void 0 ? void 0 : customGasSettings.maxFeePerGas) || (0, _util.bnToHex)((0, _util.BnMultiplyByFraction)((0, _util.hexToBn)(txParams.maxFeePerGas), incrementNumerator, 10));
      newGasParams.maxPriorityFeePerGas = (customGasSettings === null || customGasSettings === void 0 ? void 0 : customGasSettings.maxPriorityFeePerGas) || (0, _util.bnToHex)((0, _util.BnMultiplyByFraction)((0, _util.hexToBn)(txParams.maxPriorityFeePerGas), incrementNumerator, 10));
    } else {
      previousGasParams.gasPrice = txParams.gasPrice;
      newGasParams.gasPrice = (customGasSettings === null || customGasSettings === void 0 ? void 0 : customGasSettings.gasPrice) || (0, _util.bnToHex)((0, _util.BnMultiplyByFraction)((0, _util.hexToBn)(txParams.gasPrice), incrementNumerator, 10));
    }

    return {
      previousGasParams,
      newGasParams
    };
  }
  /**
   * Creates a new approved transaction to attempt to cancel a previously submitted transaction. The
   * new transaction contains the same nonce as the previous, is a basic ETH transfer of 0x value to
   * the sender's address, and has a higher gasPrice than that of the previous transaction.
   * @param {number} originalTxId - the id of the txMeta that you want to attempt to cancel
   * @param {CustomGasSettings} [customGasSettings] - overrides to use for gas
   *  params instead of allowing this method to generate them
   * @returns {txMeta}
   */


  async createCancelTransaction(originalTxId, customGasSettings, {
    estimatedBaseFee
  } = {}) {
    const originalTxMeta = this.txStateManager.getTransaction(originalTxId);
    const {
      txParams
    } = originalTxMeta;
    const {
      from,
      nonce
    } = txParams;
    const {
      previousGasParams,
      newGasParams
    } = this.generateNewGasParams(originalTxMeta, _objectSpread(_objectSpread({}, customGasSettings), {}, {
      // We want to override the previous transactions gasLimit because it
      // will now be a simple send instead of whatever it was before such
      // as a token transfer or contract call.
      gasLimit: customGasSettings.gasLimit || _gas.GAS_LIMITS.SIMPLE
    }));
    const newTxMeta = this.txStateManager.generateTxMeta({
      txParams: _objectSpread({
        from,
        to: from,
        nonce,
        value: '0x0'
      }, newGasParams),
      previousGasParams,
      loadingDefaults: false,
      status: _transaction.TRANSACTION_STATUSES.APPROVED,
      type: _transaction.TRANSACTION_TYPES.CANCEL
    });

    if (estimatedBaseFee) {
      newTxMeta.estimatedBaseFee = estimatedBaseFee;
    }

    this.addTransaction(newTxMeta);
    await this.approveTransaction(newTxMeta.id);
    return newTxMeta;
  }
  /**
   * Creates a new approved transaction to attempt to speed up a previously submitted transaction. The
   * new transaction contains the same nonce as the previous. By default, the new transaction will use
   * the same gas limit and a 10% higher gas price, though it is possible to set a custom value for
   * each instead.
   * @param {number} originalTxId - the id of the txMeta that you want to speed up
   * @param {CustomGasSettings} [customGasSettings] - overrides to use for gas
   *  params instead of allowing this method to generate them
   * @returns {txMeta}
   */


  async createSpeedUpTransaction(originalTxId, customGasSettings, {
    estimatedBaseFee
  } = {}) {
    const originalTxMeta = this.txStateManager.getTransaction(originalTxId);
    const {
      txParams
    } = originalTxMeta;
    const {
      previousGasParams,
      newGasParams
    } = this.generateNewGasParams(originalTxMeta, customGasSettings);
    const newTxMeta = this.txStateManager.generateTxMeta({
      txParams: _objectSpread(_objectSpread({}, txParams), newGasParams),
      previousGasParams,
      loadingDefaults: false,
      status: _transaction.TRANSACTION_STATUSES.APPROVED,
      type: _transaction.TRANSACTION_TYPES.RETRY
    });

    if (estimatedBaseFee) {
      newTxMeta.estimatedBaseFee = estimatedBaseFee;
    }

    this.addTransaction(newTxMeta);
    await this.approveTransaction(newTxMeta.id);
    return newTxMeta;
  }
  /**
  updates the txMeta in the txStateManager
  @param {Object} txMeta - the updated txMeta
  */


  async updateTransaction(txMeta) {
    this.txStateManager.updateTransaction(txMeta, 'confTx: user updated transaction');
  }
  /**
  updates and approves the transaction
  @param {Object} txMeta
  */


  async updateAndApproveTransaction(txMeta) {
    this.txStateManager.updateTransaction(txMeta, 'confTx: user approved transaction');
    await this.approveTransaction(txMeta.id);
  }
  /**
  sets the tx status to approved
  auto fills the nonce
  signs the transaction
  publishes the transaction
  if any of these steps fails the tx status will be set to failed
    @param {number} txId - the tx's Id
  */


  async approveTransaction(txId) {
    // TODO: Move this safety out of this function.
    // Since this transaction is async,
    // we need to keep track of what is currently being signed,
    // So that we do not increment nonce + resubmit something
    // that is already being incremented & signed.
    if (this.inProcessOfSigning.has(txId)) {
      return;
    }

    this.inProcessOfSigning.add(txId);
    let nonceLock;

    try {
      // approve
      this.txStateManager.setTxStatusApproved(txId); // get next nonce

      const txMeta = this.txStateManager.getTransaction(txId);
      const fromAddress = txMeta.txParams.from; // wait for a nonce

      let {
        customNonceValue
      } = txMeta;
      customNonceValue = Number(customNonceValue);
      nonceLock = await this.nonceTracker.getNonceLock(fromAddress); // add nonce to txParams
      // if txMeta has previousGasParams then it is a retry at same nonce with
      // higher gas settings and therefor the nonce should not be recalculated

      const nonce = txMeta.previousGasParams ? txMeta.txParams.nonce : nonceLock.nextNonce;
      const customOrNonce = customNonceValue === 0 ? customNonceValue : customNonceValue || nonce;
      txMeta.txParams.nonce = (0, _util.addHexPrefix)(customOrNonce.toString(16)); // add nonce debugging information to txMeta

      txMeta.nonceDetails = nonceLock.nonceDetails;

      if (customNonceValue) {
        txMeta.nonceDetails.customNonceValue = customNonceValue;
      }

      this.txStateManager.updateTransaction(txMeta, 'transactions#approveTransaction'); // sign transaction

      const rawTx = await this.signTransaction(txId);
      await this.publishTransaction(txId, rawTx);

      this._trackTransactionMetricsEvent(txMeta, TRANSACTION_EVENTS.APPROVED); // must set transaction to submitted/failed before releasing lock


      nonceLock.releaseLock();
    } catch (err) {
      // this is try-catch wrapped so that we can guarantee that the nonceLock is released
      try {
        this._failTransaction(txId, err);
      } catch (err2) {
        _loglevel.default.error(err2);
      } // must set transaction to submitted/failed before releasing lock


      if (nonceLock) {
        nonceLock.releaseLock();
      } // continue with error chain


      throw err;
    } finally {
      this.inProcessOfSigning.delete(txId);
    }
  }
  /**
    adds the chain id and signs the transaction and set the status to signed
    @param {number} txId - the tx's Id
    @returns {string} rawTx
  */


  async signTransaction(txId) {
    const txMeta = this.txStateManager.getTransaction(txId); // add network/chain id

    const chainId = this.getChainId();
    const type = (0, _transaction2.isEIP1559Transaction)(txMeta) ? _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY;

    const txParams = _objectSpread(_objectSpread({}, txMeta.txParams), {}, {
      type,
      chainId,
      gasLimit: txMeta.txParams.gas
    }); // sign tx


    const fromAddress = txParams.from;
    const common = await this.getCommonConfiguration(txParams.from);

    const unsignedEthTx = _tx.TransactionFactory.fromTxData(txParams, {
      common
    });

    const signedEthTx = await this.signEthTx(unsignedEthTx, fromAddress); // add r,s,v values for provider request purposes see createMetamaskMiddleware
    // and JSON rpc standard for further explanation

    txMeta.r = (0, _ethereumjsUtil.bufferToHex)(signedEthTx.r);
    txMeta.s = (0, _ethereumjsUtil.bufferToHex)(signedEthTx.s);
    txMeta.v = (0, _ethereumjsUtil.bufferToHex)(signedEthTx.v);
    this.txStateManager.updateTransaction(txMeta, 'transactions#signTransaction: add r, s, v values'); // set state to signed

    this.txStateManager.setTxStatusSigned(txMeta.id);
    const rawTx = (0, _ethereumjsUtil.bufferToHex)(signedEthTx.serialize());
    return rawTx;
  }
  /**
    publishes the raw tx and sets the txMeta to submitted
    @param {number} txId - the tx's Id
    @param {string} rawTx - the hex string of the serialized signed transaction
    @returns {Promise<void>}
  */


  async publishTransaction(txId, rawTx) {
    const txMeta = this.txStateManager.getTransaction(txId);
    txMeta.rawTx = rawTx;

    if (txMeta.type === _transaction.TRANSACTION_TYPES.SWAP) {
      const preTxBalance = await this.query.getBalance(txMeta.txParams.from);
      txMeta.preTxBalance = preTxBalance.toString(16);
    }

    this.txStateManager.updateTransaction(txMeta, 'transactions#publishTransaction');
    let txHash;

    try {
      txHash = await this.query.sendRawTransaction(rawTx);
    } catch (error) {
      if (error.message.toLowerCase().includes('known transaction')) {
        txHash = (0, _ethereumjsUtil.keccak)((0, _ethereumjsUtil.toBuffer)((0, _util.addHexPrefix)(rawTx), 'hex')).toString('hex');
        txHash = (0, _util.addHexPrefix)(txHash);
      } else {
        throw error;
      }
    }

    this.setTxHash(txId, txHash);
    this.txStateManager.setTxStatusSubmitted(txId);

    this._trackTransactionMetricsEvent(txMeta, TRANSACTION_EVENTS.SUBMITTED);
  }
  /**
   * Sets the status of the transaction to confirmed and sets the status of nonce duplicates as
   * dropped if the txParams have data it will fetch the txReceipt
   * @param {number} txId - The tx's ID
   * @returns {Promise<void>}
   */


  async confirmTransaction(txId, txReceipt, baseFeePerGas, blockTimestamp) {
    // get the txReceipt before marking the transaction confirmed
    // to ensure the receipt is gotten before the ui revives the tx
    const txMeta = this.txStateManager.getTransaction(txId);

    if (!txMeta) {
      return;
    }

    try {
      // It seems that sometimes the numerical values being returned from
      // this.query.getTransactionReceipt are BN instances and not strings.
      const gasUsed = typeof txReceipt.gasUsed === 'string' ? txReceipt.gasUsed : txReceipt.gasUsed.toString(16);
      txMeta.txReceipt = _objectSpread(_objectSpread({}, txReceipt), {}, {
        gasUsed
      });

      if (baseFeePerGas) {
        txMeta.baseFeePerGas = baseFeePerGas;
      }

      if (blockTimestamp) {
        txMeta.blockTimestamp = blockTimestamp;
      }

      this.txStateManager.setTxStatusConfirmed(txId);

      this._markNonceDuplicatesDropped(txId);

      const {
        submittedTime
      } = txMeta;
      const metricsParams = {
        gas_used: gasUsed
      };

      if (submittedTime) {
        metricsParams.completion_time = this._getTransactionCompletionTime(submittedTime);
      }

      if (txReceipt.status === '0x0') {
        metricsParams.status = 'failed on-chain'; // metricsParams.error = TODO: figure out a way to get the on-chain failure reason
      }

      this._trackTransactionMetricsEvent(txMeta, TRANSACTION_EVENTS.FINALIZED, metricsParams);

      this.txStateManager.updateTransaction(txMeta, 'transactions#confirmTransaction - add txReceipt');

      if (txMeta.type === _transaction.TRANSACTION_TYPES.SWAP) {
        const postTxBalance = await this.query.getBalance(txMeta.txParams.from);
        const latestTxMeta = this.txStateManager.getTransaction(txId);
        const approvalTxMeta = latestTxMeta.approvalTxId ? this.txStateManager.getTransaction(latestTxMeta.approvalTxId) : null;
        latestTxMeta.postTxBalance = postTxBalance.toString(16);
        this.txStateManager.updateTransaction(latestTxMeta, 'transactions#confirmTransaction - add postTxBalance');

        this._trackSwapsMetrics(latestTxMeta, approvalTxMeta);
      }
    } catch (err) {
      _loglevel.default.error(err);
    }
  }
  /**
    Convenience method for the ui thats sets the transaction to rejected
    @param {number} txId - the tx's Id
    @returns {Promise<void>}
  */


  async cancelTransaction(txId) {
    const txMeta = this.txStateManager.getTransaction(txId);
    this.txStateManager.setTxStatusRejected(txId);

    this._trackTransactionMetricsEvent(txMeta, TRANSACTION_EVENTS.REJECTED);
  }
  /**
    Sets the txHas on the txMeta
    @param {number} txId - the tx's Id
    @param {string} txHash - the hash for the txMeta
  */


  setTxHash(txId, txHash) {
    // Add the tx hash to the persisted meta-tx object
    const txMeta = this.txStateManager.getTransaction(txId);
    txMeta.hash = txHash;
    this.txStateManager.updateTransaction(txMeta, 'transactions#setTxHash');
  } //
  //           PRIVATE METHODS
  //

  /** maps methods for convenience*/


  _mapMethods() {
    /** @returns {Object} the state in transaction controller */
    this.getState = () => this.memStore.getState();
    /** @returns {string|number} the network number stored in networkStore */


    this.getNetwork = () => this.networkStore.getState();
    /** @returns {string} the user selected address */


    this.getSelectedAddress = () => this.preferencesStore.getState().selectedAddress;
    /** @returns {Array} transactions whos status is unapproved */


    this.getUnapprovedTxCount = () => Object.keys(this.txStateManager.getUnapprovedTxList()).length;
    /**
      @returns {number} number of transactions that have the status submitted
      @param {string} account - hex prefixed account
    */


    this.getPendingTxCount = account => this.txStateManager.getPendingTransactions(account).length;
    /** see txStateManager */


    this.getTransactions = opts => this.txStateManager.getTransactions(opts);
  } // called once on startup


  async _updatePendingTxsAfterFirstBlock() {
    // wait for first block so we know we're ready
    await this.blockTracker.getLatestBlock(); // get status update for all pending transactions (for the current network)

    await this.pendingTxTracker.updatePendingTxs();
  }
  /**
    If transaction controller was rebooted with transactions that are uncompleted
    in steps of the transaction signing or user confirmation process it will either
    transition txMetas to a failed state or try to redo those tasks.
  */


  _onBootCleanUp() {
    this.txStateManager.getTransactions({
      searchCriteria: {
        status: _transaction.TRANSACTION_STATUSES.UNAPPROVED,
        loadingDefaults: true
      }
    }).forEach(tx => {
      this.addTxGasDefaults(tx).then(txMeta => {
        txMeta.loadingDefaults = false;
        this.txStateManager.updateTransaction(txMeta, 'transactions: gas estimation for tx on boot');
      }).catch(error => {
        const txMeta = this.txStateManager.getTransaction(tx.id);
        txMeta.loadingDefaults = false;
        this.txStateManager.updateTransaction(txMeta, 'failed to estimate gas during boot cleanup.');

        this._failTransaction(txMeta.id, error);
      });
    });
    this.txStateManager.getTransactions({
      searchCriteria: {
        status: _transaction.TRANSACTION_STATUSES.APPROVED
      }
    }).forEach(txMeta => {
      const txSignError = new Error('Transaction found as "approved" during boot - possibly stuck during signing');

      this._failTransaction(txMeta.id, txSignError);
    });
  }
  /**
    is called in constructor applies the listeners for pendingTxTracker txStateManager
    and blockTracker
  */


  _setupListeners() {
    this.txStateManager.on('tx:status-update', this.emit.bind(this, 'tx:status-update'));

    this._setupBlockTrackerListener();

    this.pendingTxTracker.on('tx:warning', txMeta => {
      this.txStateManager.updateTransaction(txMeta, 'transactions/pending-tx-tracker#event: tx:warning');
    });
    this.pendingTxTracker.on('tx:failed', (txId, error) => {
      this._failTransaction(txId, error);
    });
    this.pendingTxTracker.on('tx:confirmed', (txId, transactionReceipt, baseFeePerGas, blockTimestamp) => this.confirmTransaction(txId, transactionReceipt, baseFeePerGas, blockTimestamp));
    this.pendingTxTracker.on('tx:dropped', txId => {
      this._dropTransaction(txId);
    });
    this.pendingTxTracker.on('tx:block-update', (txMeta, latestBlockNumber) => {
      if (!txMeta.firstRetryBlockNumber) {
        txMeta.firstRetryBlockNumber = latestBlockNumber;
        this.txStateManager.updateTransaction(txMeta, 'transactions/pending-tx-tracker#event: tx:block-update');
      }
    });
    this.pendingTxTracker.on('tx:retry', txMeta => {
      if (!('retryCount' in txMeta)) {
        txMeta.retryCount = 0;
      }

      txMeta.retryCount += 1;
      this.txStateManager.updateTransaction(txMeta, 'transactions/pending-tx-tracker#event: tx:retry');
    });
  }
  /**
   * @typedef { 'transfer' | 'approve' | 'transferfrom' | 'contractInteraction'| 'simpleSend' } InferrableTransactionTypes
   */

  /**
   * @typedef {Object} InferTransactionTypeResult
   * @property {InferrableTransactionTypes} type - The type of transaction
   * @property {string} getCodeResponse - The contract code, in hex format if
   *  it exists. '0x0' or '0x' are also indicators of non-existent contract
   *  code
   */

  /**
   * Determines the type of the transaction by analyzing the txParams.
   * This method will return one of the types defined in shared/constants/transactions
   * It will never return TRANSACTION_TYPE_CANCEL or TRANSACTION_TYPE_RETRY as these
   * represent specific events that we control from the extension and are added manually
   * at transaction creation.
   * @param {Object} txParams - Parameters for the transaction
   * @returns {InferTransactionTypeResult}
   */


  async _determineTransactionType(txParams) {
    const {
      data,
      to
    } = txParams;
    let name;

    try {
      name = data && hstInterface.parseTransaction({
        data
      }).name;
    } catch (error) {
      _loglevel.default.debug('Failed to parse transaction data.', error, data);
    }

    const tokenMethodName = [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM].find(methodName => methodName === name && name.toLowerCase());
    let result;

    if (data && tokenMethodName) {
      result = tokenMethodName;
    } else if (data && !to) {
      result = _transaction.TRANSACTION_TYPES.DEPLOY_CONTRACT;
    }

    let contractCode;

    if (!result) {
      const {
        contractCode: resultCode,
        isContractAddress
      } = await (0, _contractUtils.readAddressAsContract)(this.query, to);
      contractCode = resultCode;
      result = isContractAddress ? _transaction.TRANSACTION_TYPES.CONTRACT_INTERACTION : _transaction.TRANSACTION_TYPES.SIMPLE_SEND;
    }

    return {
      type: result,
      getCodeResponse: contractCode
    };
  }
  /**
    Sets other txMeta statuses to dropped if the txMeta that has been confirmed has other transactions
    in the list have the same nonce
     @param {number} txId - the txId of the transaction that has been confirmed in a block
  */


  _markNonceDuplicatesDropped(txId) {
    // get the confirmed transactions nonce and from address
    const txMeta = this.txStateManager.getTransaction(txId);
    const {
      nonce,
      from
    } = txMeta.txParams;
    const sameNonceTxs = this.txStateManager.getTransactions({
      searchCriteria: {
        nonce,
        from
      }
    });

    if (!sameNonceTxs.length) {
      return;
    } // mark all same nonce transactions as dropped and give i a replacedBy hash


    sameNonceTxs.forEach(otherTxMeta => {
      if (otherTxMeta.id === txId) {
        return;
      }

      otherTxMeta.replacedBy = txMeta.hash;
      this.txStateManager.updateTransaction(txMeta, 'transactions/pending-tx-tracker#event: tx:confirmed reference to confirmed txHash with same nonce');

      this._dropTransaction(otherTxMeta.id);
    });
  }

  _setupBlockTrackerListener() {
    let listenersAreActive = false;

    const latestBlockHandler = this._onLatestBlock.bind(this);

    const {
      blockTracker,
      txStateManager
    } = this;
    txStateManager.on('tx:status-update', updateSubscription);
    updateSubscription();

    function updateSubscription() {
      const pendingTxs = txStateManager.getPendingTransactions();

      if (!listenersAreActive && pendingTxs.length > 0) {
        blockTracker.on('latest', latestBlockHandler);
        listenersAreActive = true;
      } else if (listenersAreActive && !pendingTxs.length) {
        blockTracker.removeListener('latest', latestBlockHandler);
        listenersAreActive = false;
      }
    }
  }

  async _onLatestBlock(blockNumber) {
    try {
      await this.pendingTxTracker.updatePendingTxs();
    } catch (err) {
      _loglevel.default.error(err);
    }

    try {
      await this.pendingTxTracker.resubmitPendingTxs(blockNumber);
    } catch (err) {
      _loglevel.default.error(err);
    }
  }
  /**
    Updates the memStore in transaction controller
  */


  _updateMemstore() {
    const unapprovedTxs = this.txStateManager.getUnapprovedTxList();
    const currentNetworkTxList = this.txStateManager.getTransactions({
      limit: MAX_MEMSTORE_TX_LIST_SIZE
    });
    this.memStore.updateState({
      unapprovedTxs,
      currentNetworkTxList
    });
  }

  _trackSwapsMetrics(txMeta, approvalTxMeta) {
    if (this._getParticipateInMetrics() && txMeta.swapMetaData) {
      if (txMeta.txReceipt.status === '0x0') {
        this._trackMetaMetricsEvent({
          event: 'Swap Failed',
          sensitiveProperties: _objectSpread({}, txMeta.swapMetaData),
          category: 'swaps'
        });
      } else {
        const tokensReceived = (0, _swaps.getSwapsTokensReceivedFromTxMeta)(txMeta.destinationTokenSymbol, txMeta, txMeta.destinationTokenAddress, txMeta.txParams.from, txMeta.destinationTokenDecimals, approvalTxMeta, txMeta.chainId);
        const quoteVsExecutionRatio = tokensReceived ? `${new _bignumber.default(tokensReceived, 10).div(txMeta.swapMetaData.token_to_amount, 10).times(100).round(2)}%` : null;
        const estimatedVsUsedGasRatio = `${new _bignumber.default(txMeta.txReceipt.gasUsed, 16).div(txMeta.swapMetaData.estimated_gas, 10).times(100).round(2)}%`;

        this._trackMetaMetricsEvent({
          event: 'Swap Completed',
          category: 'swaps',
          sensitiveProperties: _objectSpread(_objectSpread({}, txMeta.swapMetaData), {}, {
            token_to_amount_received: tokensReceived,
            quote_vs_executionRatio: quoteVsExecutionRatio,
            estimated_vs_used_gasRatio: estimatedVsUsedGasRatio
          })
        });
      }
    }
  }
  /**
   * Extracts relevant properties from a transaction meta
   * object and uses them to create and send metrics for various transaction
   * events.
   * @param {Object} txMeta - the txMeta object
   * @param {string} event - the name of the transaction event
   * @param {Object} extraParams - optional props and values to include in sensitiveProperties
   */


  _trackTransactionMetricsEvent(txMeta, event, extraParams = {}) {
    if (!txMeta) {
      return;
    }

    const {
      type,
      time,
      status,
      chainId,
      origin: referrer,
      txParams: {
        gasPrice,
        gas: gasLimit,
        maxFeePerGas,
        maxPriorityFeePerGas,
        estimateSuggested,
        estimateUsed
      },
      metamaskNetworkId: network
    } = txMeta;
    const source = referrer === 'metamask' ? 'user' : 'dapp';
    const gasParams = {};

    if ((0, _transaction2.isEIP1559Transaction)(txMeta)) {
      gasParams.max_fee_per_gas = maxFeePerGas;
      gasParams.max_priority_fee_per_gas = maxPriorityFeePerGas;
    } else {
      gasParams.gas_price = gasPrice;
    }

    if (estimateSuggested) {
      gasParams.estimate_suggested = estimateSuggested;
    }

    if (estimateUsed) {
      gasParams.estimate_used = estimateUsed;
    }

    const gasParamsInGwei = this._getGasValuesInGWEI(gasParams);

    this._trackMetaMetricsEvent({
      event,
      category: 'Transactions',
      properties: {
        chain_id: chainId,
        referrer,
        source,
        network,
        type
      },
      sensitiveProperties: _objectSpread(_objectSpread({
        status,
        transaction_envelope_type: (0, _transaction2.isEIP1559Transaction)(txMeta) ? _transactions.TRANSACTION_ENVELOPE_TYPE_NAMES.FEE_MARKET : _transactions.TRANSACTION_ENVELOPE_TYPE_NAMES.LEGACY,
        first_seen: time,
        gas_limit: gasLimit
      }, gasParamsInGwei), extraParams)
    });
  }

  _getTransactionCompletionTime(submittedTime) {
    return Math.round((Date.now() - submittedTime) / 1000).toString();
  }

  _getGasValuesInGWEI(gasParams) {
    const gasValuesInGwei = {};

    for (const param in gasParams) {
      if ((0, _ethereumjsUtil.isHexString)(gasParams[param])) {
        gasValuesInGwei[param] = (0, _conversions.hexWEIToDecGWEI)(gasParams[param]);
      } else {
        gasValuesInGwei[param] = gasParams[param];
      }
    }

    return gasValuesInGwei;
  }

  _failTransaction(txId, error) {
    this.txStateManager.setTxStatusFailed(txId, error);
    const txMeta = this.txStateManager.getTransaction(txId);

    this._trackTransactionMetricsEvent(txMeta, TRANSACTION_EVENTS.FINALIZED, {
      error: error.message
    });
  }

  _dropTransaction(txId) {
    this.txStateManager.setTxStatusDropped(txId);
    const txMeta = this.txStateManager.getTransaction(txId);

    this._trackTransactionMetricsEvent(txMeta, TRANSACTION_EVENTS.FINALIZED);
  }

}

exports.default = TransactionController;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/index.js", {"./background-api":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/background-api.js","./caveat-mutators":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/caveat-mutators.js","./enums":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/enums.js","./permission-log":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/permission-log.js","./selectors":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/selectors.js","./specifications":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/specifications.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/index.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _caveatMutators = require("./caveat-mutators");

Object.keys(_caveatMutators).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _caveatMutators[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _caveatMutators[key];
    }
  });
});

var _backgroundApi = require("./background-api");

Object.keys(_backgroundApi).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _backgroundApi[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _backgroundApi[key];
    }
  });
});

var _enums = require("./enums");

Object.keys(_enums).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _enums[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _enums[key];
    }
  });
});

var _permissionLog = require("./permission-log");

Object.keys(_permissionLog).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _permissionLog[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _permissionLog[key];
    }
  });
});

var _specifications = require("./specifications");

Object.keys(_specifications).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _specifications[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _specifications[key];
    }
  });
});

var _selectors = require("./selectors");

Object.keys(_selectors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _selectors[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _selectors[key];
    }
  });
});

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/segment.js", {"../../../shared/constants/time":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/time.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","analytics-node":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/segment.js
      return function (require, module, exports) {
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.segment = exports.createSegmentMock = void 0;

var _analyticsNode = _interopRequireDefault(require("analytics-node"));

var _time = require("../../../shared/constants/time");

var _process$env$SEGMENT_, _process$env$SEGMENT_2;

const isDevOrTestEnvironment = Boolean(true || process.env.IN_TEST);
const SEGMENT_WRITE_KEY = (_process$env$SEGMENT_ = "") !== null && _process$env$SEGMENT_ !== void 0 ? _process$env$SEGMENT_ : null;
const SEGMENT_HOST = (_process$env$SEGMENT_2 = process.env.SEGMENT_HOST) !== null && _process$env$SEGMENT_2 !== void 0 ? _process$env$SEGMENT_2 : null; // flushAt controls how many events are sent to segment at once. Segment will
// hold onto a queue of events until it hits this number, then it sends them as
// a batch. This setting defaults to 20, but in development we likely want to
// see events in real time for debugging, so this is set to 1 to disable the
// queueing mechanism.

const SEGMENT_FLUSH_AT = "development" === 'production' ? undefined : 1; // flushInterval controls how frequently the queue is flushed to segment.
// This happens regardless of the size of the queue. The default setting is
// 10,000ms (10 seconds). This default is rather high, though thankfully
// using the background process as our event handler means we don't have to
// deal with short lived sessions that happen faster than the interval
// e.g confirmations. This is set to 5,000ms (5 seconds) arbitrarily with the
// intent of having a value less than 10 seconds.

const SEGMENT_FLUSH_INTERVAL = _time.SECOND * 5;
/**
 * Creates a mock segment module for usage in test environments. This is used
 * when building the application in test mode to catch event calls and prevent
 * them from being sent to segment. It is also used in unit tests to mock and
 * spy on the methods to ensure proper behavior
 * @param {number} flushAt - number of events to queue before sending to segment
 * @param {number} flushInterval - ms interval to flush queue and send to segment
 * @returns {SegmentInterface}
 */

const createSegmentMock = (flushAt = SEGMENT_FLUSH_AT) => {
  const segmentMock = {
    // Internal queue to keep track of events and properly mimic segment's
    // queueing behavior.
    queue: [],

    /**
     * Used to immediately send all queued events and reset the queue to zero.
     * For our purposes this simply triggers the callback method registered with
     * the event.
     */
    flush() {
      segmentMock.queue.forEach(([_, callback]) => {
        callback();
      });
      segmentMock.queue = [];
    },

    /**
     * Track an event and add it to the queue. If the queue size reaches the
     * flushAt threshold, flush the queue.
     */
    track(payload, callback = () => undefined) {
      segmentMock.queue.push([payload, callback]);

      if (segmentMock.queue.length >= flushAt) {
        segmentMock.flush();
      }
    },

    /**
     * A true NOOP, these methods are either not used or do not await callback
     * and therefore require no functionality.
     */
    page() {// noop
    },

    identify() {// noop
    }

  };
  return segmentMock;
};

exports.createSegmentMock = createSegmentMock;
const segment = !SEGMENT_WRITE_KEY || isDevOrTestEnvironment && !SEGMENT_HOST ? createSegmentMock(SEGMENT_FLUSH_AT, SEGMENT_FLUSH_INTERVAL) : new _analyticsNode.default(SEGMENT_WRITE_KEY, {
  host: SEGMENT_HOST,
  flushAt: SEGMENT_FLUSH_AT,
  flushInterval: SEGMENT_FLUSH_INTERVAL
});
exports.segment = segment;

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/segment.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/account-import-strategies/index.js", {"../lib/util":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/util.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","ethereumjs-wallet":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/index.js","ethereumjs-wallet/thirdparty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/thirdparty.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/account-import-strategies/index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _loglevel = _interopRequireDefault(require("loglevel"));

var _ethereumjsWallet = _interopRequireDefault(require("ethereumjs-wallet"));

var _thirdparty = _interopRequireDefault(require("ethereumjs-wallet/thirdparty"));

var _ethereumjsUtil = require("ethereumjs-util");

var _util = require("../lib/util");

const accountImporter = {
  importAccount(strategy, args) {
    try {
      const importer = this.strategies[strategy];
      const privateKeyHex = importer(...args);
      return Promise.resolve(privateKeyHex);
    } catch (e) {
      return Promise.reject(e);
    }
  },

  strategies: {
    'Private Key': privateKey => {
      if (!privateKey) {
        throw new Error('Cannot import an empty key.');
      }

      const prefixed = (0, _util.addHexPrefix)(privateKey);
      const buffer = (0, _ethereumjsUtil.toBuffer)(prefixed);

      if (!(0, _ethereumjsUtil.isValidPrivate)(buffer)) {
        throw new Error('Cannot import invalid private key.');
      }

      const stripped = (0, _ethereumjsUtil.stripHexPrefix)(prefixed);
      return stripped;
    },
    'JSON File': (input, password) => {
      let wallet;

      try {
        wallet = _thirdparty.default.fromEtherWallet(input, password);
      } catch (e) {
        _loglevel.default.debug('Attempt to import as EtherWallet format failed, trying V3');

        wallet = _ethereumjsWallet.default.fromV3(input, password, true);
      }

      return walletToPrivateKey(wallet);
    }
  }
};

function walletToPrivateKey(wallet) {
  const privateKeyBuffer = wallet.getPrivateKey();
  return (0, _ethereumjsUtil.bufferToHex)(privateKeyBuffer);
}

var _default = accountImporter;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/account-import-strategies/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/index.js", {"./network":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/network.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/index.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "NETWORK_EVENTS", {
  enumerable: true,
  get: function () {
    return _network.NETWORK_EVENTS;
  }
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _network.default;
  }
});

var _network = _interopRequireWildcard(require("./network"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-trezor-keyring/index.js", {"@ethereumjs/tx":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ethereumjs/tx/dist.browser/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","hdkey":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-trezor-keyring/node_modules/hdkey/lib/hdkey.js","trezor-connect":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-trezor-keyring/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { EventEmitter } = require('events');
const ethUtil = require('ethereumjs-util');
const HDKey = require('hdkey');
const TrezorConnect = require('trezor-connect').default;
const { TransactionFactory } = require('@ethereumjs/tx');

const hdPathString = `m/44'/60'/0'/0`;
const SLIP0044TestnetPath = `m/44'/1'/0'/0`;

const ALLOWED_HD_PATHS = {
  [hdPathString]: true,
  [SLIP0044TestnetPath]: true,
};

const keyringType = 'Trezor Hardware';
const pathBase = 'm';
const MAX_INDEX = 1000;
const DELAY_BETWEEN_POPUPS = 1000;
const TREZOR_CONNECT_MANIFEST = {
  email: 'support@metamask.io',
  appUrl: 'https://d-wallet.io/',
};

function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * @typedef {__import__('@ethereumjs/tx').TypedTransaction} TypedTransaction
 * @typedef {InstanceType<__import__("ethereumjs-tx")>} OldEthJsTransaction
 */

/**
 * Check if the given transaction is made with ethereumjs-tx or @ethereumjs/tx
 *
 * Transactions built with older versions of ethereumjs-tx have a
 * getChainId method that newer versions do not.
 * Older versions are mutable
 * while newer versions default to being immutable.
 * Expected shape and type
 * of data for v, r and s differ (Buffer (old) vs BN (new)).
 *
 * @param {TypedTransaction | OldEthJsTransaction} tx
 * @returns {tx is OldEthJsTransaction} Returns `true` if tx is an old-style ethereumjs-tx transaction.
 */
function isOldStyleEthereumjsTx(tx) {
  return typeof tx.getChainId === 'function';
}

class TrezorKeyring extends EventEmitter {
  constructor(opts = {}) {
    super();
    this.type = keyringType;
    this.accounts = [];
    this.hdk = new HDKey();
    this.page = 0;
    this.perPage = 5;
    this.unlockedAccount = 0;
    this.paths = {};
    this.deserialize(opts);

    TrezorConnect.on('DEVICE_EVENT', (event) => {
      if (event && event.payload && event.payload.features) {
        this.model = event.payload.features.model;
      }
    });
    TrezorConnect.init({ manifest: TREZOR_CONNECT_MANIFEST });
  }

  getModel() {
    return this.model;
  }

  dispose() {
    // This removes the Trezor Connect iframe from the DOM
    // This method is not well documented, but the code it calls can be seen
    // here: https://github.com/trezor/connect/blob/dec4a56af8a65a6059fb5f63fa3c6690d2c37e00/src/js/iframe/builder.js#L181
    TrezorConnect.dispose();
  }

  serialize() {
    return Promise.resolve({
      hdPath: this.hdPath,
      accounts: this.accounts,
      page: this.page,
      paths: this.paths,
      perPage: this.perPage,
      unlockedAccount: this.unlockedAccount,
    });
  }

  deserialize(opts = {}) {
    this.hdPath = opts.hdPath || hdPathString;
    this.accounts = opts.accounts || [];
    this.page = opts.page || 0;
    this.perPage = opts.perPage || 5;
    return Promise.resolve();
  }

  isUnlocked() {
    return Boolean(this.hdk && this.hdk.publicKey);
  }

  unlock() {
    if (this.isUnlocked()) {
      return Promise.resolve('already unlocked');
    }
    return new Promise((resolve, reject) => {
      TrezorConnect.getPublicKey({
        path: this.hdPath,
        coin: 'ETH',
      })
        .then((response) => {
          if (response.success) {
            this.hdk.publicKey = Buffer.from(response.payload.publicKey, 'hex');
            this.hdk.chainCode = Buffer.from(response.payload.chainCode, 'hex');
            resolve('just unlocked');
          } else {
            reject(
              new Error(
                (response.payload && response.payload.error) || 'Unknown error',
              ),
            );
          }
        })
        .catch((e) => {
          reject(new Error((e && e.toString()) || 'Unknown error'));
        });
    });
  }

  setAccountToUnlock(index) {
    this.unlockedAccount = parseInt(index, 10);
  }

  addAccounts(n = 1) {
    return new Promise((resolve, reject) => {
      this.unlock()
        .then((_) => {
          const from = this.unlockedAccount;
          const to = from + n;

          for (let i = from; i < to; i++) {
            const address = this._addressFromIndex(pathBase, i);
            if (!this.accounts.includes(address)) {
              this.accounts.push(address);
            }
            this.page = 0;
          }
          resolve(this.accounts);
        })
        .catch((e) => {
          reject(e);
        });
    });
  }

  getFirstPage() {
    this.page = 0;
    return this.__getPage(1);
  }

  getNextPage() {
    return this.__getPage(1);
  }

  getPreviousPage() {
    return this.__getPage(-1);
  }

  __getPage(increment) {
    this.page += increment;

    if (this.page <= 0) {
      this.page = 1;
    }

    return new Promise((resolve, reject) => {
      this.unlock()
        .then((_) => {
          const from = (this.page - 1) * this.perPage;
          const to = from + this.perPage;

          const accounts = [];

          for (let i = from; i < to; i++) {
            const address = this._addressFromIndex(pathBase, i);
            accounts.push({
              address,
              balance: null,
              index: i,
            });
            this.paths[ethUtil.toChecksumAddress(address)] = i;
          }
          resolve(accounts);
        })
        .catch((e) => {
          reject(e);
        });
    });
  }

  getAccounts() {
    return Promise.resolve(this.accounts.slice());
  }

  removeAccount(address) {
    if (
      !this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())
    ) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this.accounts = this.accounts.filter(
      (a) => a.toLowerCase() !== address.toLowerCase(),
    );
  }

  /**
   * Signs a transaction using Trezor.
   *
   * Accepts either an ethereumjs-tx or @ethereumjs/tx transaction, and returns
   * the same type.
   *
   * @template {TypedTransaction | OldEthJsTransaction} Transaction
   * @param {string} address - Hex string address.
   * @param {Transaction} tx - Instance of either new-style or old-style ethereumjs transaction.
   * @returns {Promise<Transaction>} The signed transaction, an instance of either new-style or old-style
   * ethereumjs transaction.
   */
  signTransaction(address, tx) {
    if (isOldStyleEthereumjsTx(tx)) {
      // In this version of ethereumjs-tx we must add the chainId in hex format
      // to the initial v value. The chainId must be included in the serialized
      // transaction which is only communicated to ethereumjs-tx in this
      // value. In newer versions the chainId is communicated via the 'Common'
      // object.
      return this._signTransaction(address, tx.getChainId(), tx, (payload) => {
        tx.v = Buffer.from(payload.v, 'hex');
        tx.r = Buffer.from(payload.r, 'hex');
        tx.s = Buffer.from(payload.s, 'hex');
        return tx;
      });
    }
    return this._signTransaction(
      address,
      tx.common.chainIdBN().toNumber(),
      tx,
      (payload) => {
        // Because tx will be immutable, first get a plain javascript object that
        // represents the transaction. Using txData here as it aligns with the
        // nomenclature of ethereumjs/tx.
        const txData = tx.toJSON();
        // The fromTxData utility expects a type to support transactions with a type other than 0
        txData.type = tx.type;
        // The fromTxData utility expects v,r and s to be hex prefixed
        txData.v = ethUtil.addHexPrefix(payload.v);
        txData.r = ethUtil.addHexPrefix(payload.r);
        txData.s = ethUtil.addHexPrefix(payload.s);
        // Adopt the 'common' option from the original transaction and set the
        // returned object to be frozen if the original is frozen.
        return TransactionFactory.fromTxData(txData, {
          common: tx.common,
          freeze: Object.isFrozen(tx),
        });
      },
    );
  }

  /**
   *
   * @template {TypedTransaction | OldEthJsTransaction} Transaction
   * @param {string} address - Hex string address.
   * @param {number} chainId - Chain ID
   * @param {Transaction} tx - Instance of either new-style or old-style ethereumjs transaction.
   * @param {(__import__('trezor-connect').EthereumSignedTx) => Transaction} handleSigning - Converts signed transaction
   * to the same new-style or old-style ethereumjs-tx.
   * @returns {Promise<Transaction>} The signed transaction, an instance of either new-style or old-style
   * ethereumjs transaction.
   */
  async _signTransaction(address, chainId, tx, handleSigning) {
    let transaction;
    if (isOldStyleEthereumjsTx(tx)) {
      // legacy transaction from ethereumjs-tx package has no .toJSON() function,
      // so we need to convert to hex-strings manually manually
      transaction = {
        to: this._normalize(tx.to),
        value: this._normalize(tx.value),
        data: this._normalize(tx.data),
        chainId,
        nonce: this._normalize(tx.nonce),
        gasLimit: this._normalize(tx.gasLimit),
        gasPrice: this._normalize(tx.gasPrice),
      };
    } else {
      // new-style transaction from @ethereumjs/tx package
      // we can just copy tx.toJSON() for everything except chainId, which must be a number
      transaction = {
        ...tx.toJSON(),
        chainId,
        to: this._normalize(tx.to),
      };
    }

    try {
      const status = await this.unlock();
      await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);
      const response = await TrezorConnect.ethereumSignTransaction({
        path: this._pathFromAddress(address),
        transaction,
      });
      if (response.success) {
        const newOrMutatedTx = handleSigning(response.payload);

        const addressSignedWith = ethUtil.toChecksumAddress(
          ethUtil.addHexPrefix(
            newOrMutatedTx.getSenderAddress().toString('hex'),
          ),
        );
        const correctAddress = ethUtil.toChecksumAddress(address);
        if (addressSignedWith !== correctAddress) {
          throw new Error("signature doesn't match the right address");
        }

        return newOrMutatedTx;
      }
      throw new Error(
        (response.payload && response.payload.error) || 'Unknown error',
      );
    } catch (e) {
      throw new Error((e && e.toString()) || 'Unknown error');
    }
  }

  signMessage(withAccount, data) {
    return this.signPersonalMessage(withAccount, data);
  }

  // For personal_sign, we need to prefix the message:
  signPersonalMessage(withAccount, message) {
    return new Promise((resolve, reject) => {
      this.unlock()
        .then((status) => {
          setTimeout(
            (_) => {
              TrezorConnect.ethereumSignMessage({
                path: this._pathFromAddress(withAccount),
                message: ethUtil.stripHexPrefix(message),
                hex: true,
              })
                .then((response) => {
                  if (response.success) {
                    if (
                      response.payload.address !==
                      ethUtil.toChecksumAddress(withAccount)
                    ) {
                      reject(
                        new Error('signature doesnt match the right address'),
                      );
                    }
                    const signature = `0x${response.payload.signature}`;
                    resolve(signature);
                  } else {
                    reject(
                      new Error(
                        (response.payload && response.payload.error) ||
                          'Unknown error',
                      ),
                    );
                  }
                })
                .catch((e) => {
                  reject(new Error((e && e.toString()) || 'Unknown error'));
                });
              // This is necessary to avoid popup collision
              // between the unlock & sign trezor popups
            },
            status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0,
          );
        })
        .catch((e) => {
          reject(new Error((e && e.toString()) || 'Unknown error'));
        });
    });
  }

  signTypedData() {
    // Waiting on trezor to enable this
    return Promise.reject(new Error('Not supported on this device'));
  }

  exportAccount() {
    return Promise.reject(new Error('Not supported on this device'));
  }

  forgetDevice() {
    this.accounts = [];
    this.hdk = new HDKey();
    this.page = 0;
    this.unlockedAccount = 0;
    this.paths = {};
  }

  /**
   * Set the HD path to be used by the keyring. Only known supported HD paths are allowed.
   *
   * If the given HD path is already the current HD path, nothing happens. Otherwise the new HD
   * path is set, and the wallet state is completely reset.
   *
   * @throws {Error] Throws if the HD path is not supported.
   *
   * @param {string} hdPath - The HD path to set.
   */
  setHdPath(hdPath) {
    if (!ALLOWED_HD_PATHS[hdPath]) {
      throw new Error(
        `The setHdPath method does not support setting HD Path to ${hdPath}`,
      );
    }

    // Reset HDKey if the path changes
    if (this.hdPath !== hdPath) {
      this.hdk = new HDKey();
      this.accounts = [];
      this.page = 0;
      this.perPage = 5;
      this.unlockedAccount = 0;
      this.paths = {};
    }
    this.hdPath = hdPath;
  }

  /* PRIVATE METHODS */

  _normalize(buf) {
    return ethUtil.bufferToHex(buf).toString();
  }

  // eslint-disable-next-line no-shadow
  _addressFromIndex(pathBase, i) {
    const dkey = this.hdk.derive(`${pathBase}/${i}`);
    const address = ethUtil
      .publicToAddress(dkey.publicKey, true)
      .toString('hex');
    return ethUtil.toChecksumAddress(`0x${address}`);
  }

  _pathFromAddress(address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address);
    let index = this.paths[checksummedAddress];
    if (typeof index === 'undefined') {
      for (let i = 0; i < MAX_INDEX; i++) {
        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {
          index = i;
          break;
        }
      }
    }

    if (typeof index === 'undefined') {
      throw new Error('Unknown address');
    }
    return `${this.hdPath}/${index}`;
  }
}

TrezorKeyring.type = keyringType;
module.exports = TrezorKeyring;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"eth-trezor-keyring",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-trezor-keyring/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/index.js", {"@ethereumjs/tx":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ethereumjs/tx/dist.browser/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","eth-sig-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/eth-sig-util/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","hdkey":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/hdkey/lib/hdkey.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { EventEmitter } = require('events')
const HDKey = require('hdkey')
const ethUtil = require('ethereumjs-util')
const sigUtil = require('eth-sig-util')
const { TransactionFactory } = require('@ethereumjs/tx')

const pathBase = 'm'
const hdPathString = `${pathBase}/44'/60'/0'`
const type = 'Ledger Hardware'

const BRIDGE_URL = 'https://metamask.github.io/eth-ledger-bridge-keyring'

const MAX_INDEX = 1000
const NETWORK_API_URLS = {
  ropsten: 'http://api-ropsten.etherscan.io',
  kovan: 'http://api-kovan.etherscan.io',
  rinkeby: 'https://api-rinkeby.etherscan.io',
  mainnet: 'https://api.etherscan.io',
}

class LedgerBridgeKeyring extends EventEmitter {
  constructor (opts = {}) {
    super()
    this.accountDetails = {}
    this.bridgeUrl = null
    this.type = type
    this.page = 0
    this.perPage = 5
    this.unlockedAccount = 0
    this.hdk = new HDKey()
    this.paths = {}
    this.iframe = null
    this.network = 'mainnet'
    this.implementFullBIP44 = false
    this.deserialize(opts)

    this.iframeLoaded = false
    this._setupIframe()
  }

  serialize () {
    return Promise.resolve({
      hdPath: this.hdPath,
      accounts: this.accounts,
      accountDetails: this.accountDetails,
      bridgeUrl: this.bridgeUrl,
      implementFullBIP44: false,
    })
  }

  deserialize (opts = {}) {
    this.hdPath = opts.hdPath || hdPathString
    this.bridgeUrl = opts.bridgeUrl || BRIDGE_URL
    this.accounts = opts.accounts || []
    this.accountDetails = opts.accountDetails || {}
    if (!opts.accountDetails) {
      this._migrateAccountDetails(opts)
    }

    this.implementFullBIP44 = opts.implementFullBIP44 || false

    // Remove accounts that don't have corresponding account details
    this.accounts = this.accounts
      .filter((account) => Object.keys(this.accountDetails).includes(ethUtil.toChecksumAddress(account)))

    return Promise.resolve()
  }

  _migrateAccountDetails (opts) {
    if (this._isLedgerLiveHdPath() && opts.accountIndexes) {
      for (const account of Object.keys(opts.accountIndexes)) {
        this.accountDetails[account] = {
          bip44: true,
          hdPath: this._getPathForIndex(opts.accountIndexes[account]),
        }
      }
    }

    // try to migrate non-LedgerLive accounts too
    if (!this._isLedgerLiveHdPath()) {
      this.accounts
        .filter((account) => !Object.keys(this.accountDetails).includes(ethUtil.toChecksumAddress(account)))
        .forEach((account) => {
          try {
            this.accountDetails[ethUtil.toChecksumAddress(account)] = {
              bip44: false,
              hdPath: this._pathFromAddress(account),
            }
          } catch (e) {
            console.log(`failed to migrate account ${account}`)
          }
        })
    }
  }

  isUnlocked () {
    return Boolean(this.hdk && this.hdk.publicKey)
  }

  setAccountToUnlock (index) {
    this.unlockedAccount = parseInt(index, 10)
  }

  setHdPath (hdPath) {
    // Reset HDKey if the path changes
    if (this.hdPath !== hdPath) {
      this.hdk = new HDKey()
    }
    this.hdPath = hdPath
  }

  unlock (hdPath) {
    if (this.isUnlocked() && !hdPath) {
      return Promise.resolve('already unlocked')
    }
    const path = hdPath ? this._toLedgerPath(hdPath) : this.hdPath
    return new Promise((resolve, reject) => {
      this._sendMessage({
        action: 'ledger-unlock',
        params: {
          hdPath: path,
        },
      },
      ({ success, payload }) => {
        if (success) {
          this.hdk.publicKey = Buffer.from(payload.publicKey, 'hex')
          this.hdk.chainCode = Buffer.from(payload.chainCode, 'hex')
          resolve(payload.address)
        } else {
          reject(payload.error || new Error('Unknown error'))
        }
      })
    })
  }

  addAccounts (n = 1) {

    return new Promise((resolve, reject) => {
      this.unlock()
        .then(async (_) => {
          const from = this.unlockedAccount
          const to = from + n
          for (let i = from; i < to; i++) {
            const path = this._getPathForIndex(i)
            let address
            if (this._isLedgerLiveHdPath()) {
              address = await this.unlock(path)
            } else {
              address = this._addressFromIndex(pathBase, i)
            }
            this.accountDetails[ethUtil.toChecksumAddress(address)] = {
              // TODO: consider renaming this property, as the current name is misleading
              // It's currently used to represent whether an account uses the Ledger Live path.
              bip44: this._isLedgerLiveHdPath(),
              hdPath: path,
            }

            if (!this.accounts.includes(address)) {
              this.accounts.push(address)
            }
            this.page = 0
          }
          resolve(this.accounts)
        })
        .catch(reject)
    })
  }

  getFirstPage () {
    this.page = 0
    return this.__getPage(1)
  }

  getNextPage () {
    return this.__getPage(1)
  }

  getPreviousPage () {
    return this.__getPage(-1)
  }

  getAccounts () {
    return Promise.resolve(this.accounts.slice())
  }

  removeAccount (address) {
    if (!this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`)
    }
    this.accounts = this.accounts.filter((a) => a.toLowerCase() !== address.toLowerCase())
    delete this.accountDetails[ethUtil.toChecksumAddress(address)]
  }

  attemptMakeApp () {
    return new Promise((resolve, reject) => {
      this._sendMessage({
        action: 'ledger-make-app',
      }, ({ success, error }) => {
        if (success) {
          resolve(true)
        } else {
          reject(error)
        }
      })
    })
  }

  updateTransportMethod (transportType) {
    return new Promise((resolve, reject) => {
      // If the iframe isn't loaded yet, let's store the desired transportType value and
      // optimistically return a successful promise
      if (!this.iframeLoaded) {
        this.delayedPromise = {
          resolve,
          reject,
          transportType,
        }
        return
      }

      this._sendMessage({
        action: 'ledger-update-transport',
        params: { transportType },
      }, ({ success }) => {
        if (success) {
          resolve(true)
        } else {
          reject(new Error('Ledger transport could not be updated'))
        }
      })
    })
  }

  // tx is an instance of the ethereumjs-transaction class.
  signTransaction (address, tx) {
    let rawTxHex
    // transactions built with older versions of ethereumjs-tx have a
    // getChainId method that newer versions do not. Older versions are mutable
    // while newer versions default to being immutable. Expected shape and type
    // of data for v, r and s differ (Buffer (old) vs BN (new))
    if (typeof tx.getChainId === 'function') {
      // In this version of ethereumjs-tx we must add the chainId in hex format
      // to the initial v value. The chainId must be included in the serialized
      // transaction which is only communicated to ethereumjs-tx in this
      // value. In newer versions the chainId is communicated via the 'Common'
      // object.
      tx.v = ethUtil.bufferToHex(tx.getChainId())
      tx.r = '0x00'
      tx.s = '0x00'

      rawTxHex = tx.serialize().toString('hex')

      return this._signTransaction(address, rawTxHex, (payload) => {
        tx.v = Buffer.from(payload.v, 'hex')
        tx.r = Buffer.from(payload.r, 'hex')
        tx.s = Buffer.from(payload.s, 'hex')
        return tx
      })
    }

    // The below `encode` call is only necessary for legacy transactions, as `getMessageToSign`
    // calls `rlp.encode` internally for non-legacy transactions. As per the "Transaction Execution"
    // section of the ethereum yellow paper, transactions need to be "well-formed RLP, with no additional
    // trailing bytes".

    // Note also that `getMessageToSign` will return valid RLP for all transaction types, whereas the
    // `serialize` method will not for any transaction type except legacy. This is because `serialize` includes
    // empty r, s and v values in the encoded rlp. This is why we use `getMessageToSign` here instead of `serialize`.
    const messageToSign = tx.getMessageToSign(false)

    rawTxHex = Buffer.isBuffer(messageToSign)
      ? messageToSign.toString('hex')
      : ethUtil.rlp.encode(messageToSign).toString('hex')

    return this._signTransaction(address, rawTxHex, (payload) => {
      // Because tx will be immutable, first get a plain javascript object that
      // represents the transaction. Using txData here as it aligns with the
      // nomenclature of ethereumjs/tx.
      const txData = tx.toJSON()
      // The fromTxData utility expects a type to support transactions with a type other than 0
      txData.type = tx.type
      // The fromTxData utility expects v,r and s to be hex prefixed
      txData.v = ethUtil.addHexPrefix(payload.v)
      txData.r = ethUtil.addHexPrefix(payload.r)
      txData.s = ethUtil.addHexPrefix(payload.s)
      // Adopt the 'common' option from the original transaction and set the
      // returned object to be frozen if the original is frozen.
      return TransactionFactory.fromTxData(txData, { common: tx.common, freeze: Object.isFrozen(tx) })
    })
  }

  _signTransaction (address, rawTxHex, handleSigning) {
    return new Promise((resolve, reject) => {
      this.unlockAccountByAddress(address)
        .then((hdPath) => {
          this._sendMessage({
            action: 'ledger-sign-transaction',
            params: {
              tx: rawTxHex,
              hdPath,
            },
          },
          ({ success, payload }) => {
            if (success) {

              const newOrMutatedTx = handleSigning(payload)
              const valid = newOrMutatedTx.verifySignature()
              if (valid) {
                resolve(newOrMutatedTx)
              } else {
                reject(new Error('Ledger: The transaction signature is not valid'))
              }
            } else {
              reject(payload.error || new Error('Ledger: Unknown error while signing transaction'))
            }
          })
        })
        .catch(reject)
    })
  }

  signMessage (withAccount, data) {
    return this.signPersonalMessage(withAccount, data)
  }

  // For personal_sign, we need to prefix the message:
  signPersonalMessage (withAccount, message) {
    return new Promise((resolve, reject) => {
      this.unlockAccountByAddress(withAccount)
        .then((hdPath) => {
          this._sendMessage({
            action: 'ledger-sign-personal-message',
            params: {
              hdPath,
              message: ethUtil.stripHexPrefix(message),
            },
          },
          ({ success, payload }) => {
            if (success) {
              let v = payload.v - 27
              v = v.toString(16)
              if (v.length < 2) {
                v = `0${v}`
              }
              const signature = `0x${payload.r}${payload.s}${v}`
              const addressSignedWith = sigUtil.recoverPersonalSignature({ data: message, sig: signature })
              if (ethUtil.toChecksumAddress(addressSignedWith) !== ethUtil.toChecksumAddress(withAccount)) {
                reject(new Error('Ledger: The signature doesnt match the right address'))
              }
              resolve(signature)
            } else {
              reject(payload.error || new Error('Ledger: Unknown error while signing message'))
            }
          })
        })
        .catch(reject)
    })
  }

  async unlockAccountByAddress (address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address)
    if (!Object.keys(this.accountDetails).includes(checksummedAddress)) {
      throw new Error(`Ledger: Account for address '${checksummedAddress}' not found`)
    }
    const { hdPath } = this.accountDetails[checksummedAddress]
    const unlockedAddress = await this.unlock(hdPath)

    // unlock resolves to the address for the given hdPath as reported by the ledger device
    // if that address is not the requested address, then this account belongs to a different device or seed
    if (unlockedAddress.toLowerCase() !== address.toLowerCase()) {
      throw new Error(`Ledger: Account ${address} does not belong to the connected device`)
    }
    return hdPath
  }

  async signTypedData (withAccount, data, options = {}) {
    const isV4 = options.version === 'V4'
    if (!isV4) {
      throw new Error('Ledger: Only version 4 of typed data signing is supported')
    }

    const {
      domain,
      types,
      primaryType,
      message,
    } = sigUtil.TypedDataUtils.sanitizeData(data)
    const domainSeparatorHex = sigUtil.TypedDataUtils.hashStruct('EIP712Domain', domain, types, isV4).toString('hex')
    const hashStructMessageHex = sigUtil.TypedDataUtils.hashStruct(primaryType, message, types, isV4).toString('hex')

    const hdPath = await this.unlockAccountByAddress(withAccount)
    const { success, payload } = await new Promise((resolve) => {
      this._sendMessage({
        action: 'ledger-sign-typed-data',
        params: {
          hdPath,
          domainSeparatorHex,
          hashStructMessageHex,
        },
      },
      (result) => resolve(result))
    })

    if (success) {
      let v = payload.v - 27
      v = v.toString(16)
      if (v.length < 2) {
        v = `0${v}`
      }
      const signature = `0x${payload.r}${payload.s}${v}`
      const addressSignedWith = sigUtil.recoverTypedSignature_v4({
        data,
        sig: signature,
      })
      if (ethUtil.toChecksumAddress(addressSignedWith) !== ethUtil.toChecksumAddress(withAccount)) {
        throw new Error('Ledger: The signature doesnt match the right address')
      }
      return signature
    }
    throw payload.error || new Error('Ledger: Unknown error while signing message')
  }

  exportAccount () {
    throw new Error('Not supported on this device')
  }

  forgetDevice () {
    this.accounts = []
    this.page = 0
    this.unlockedAccount = 0
    this.paths = {}
    this.accountDetails = {}
    this.hdk = new HDKey()
  }

  /* PRIVATE METHODS */

  _setupIframe () {
    this.iframe = document.createElement('iframe')
    this.iframe.src = this.bridgeUrl
    this.iframe.allow = `hid 'src'`
    this.iframe.onload = async () => {
      // If the ledger live preference was set before the iframe is loaded,
      // set it after the iframe has loaded
      this.iframeLoaded = true
      if (this.delayedPromise) {
        try {
          const result = await this.updateTransportMethod(
            this.delayedPromise.transportType,
          )
          this.delayedPromise.resolve(result)
        } catch (e) {
          this.delayedPromise.reject(e)
        } finally {
          delete this.delayedPromise
        }
      }
    }
    document.head.appendChild(this.iframe)
  }

  _getOrigin () {
    const tmp = this.bridgeUrl.split('/')
    tmp.splice(-1, 1)
    return tmp.join('/')
  }

  _sendMessage (msg, cb) {
    msg.target = 'LEDGER-IFRAME'
    this.iframe.contentWindow.postMessage(msg, '*')
    const eventListener = ({ origin, data }) => {
      if (origin !== this._getOrigin()) {
        return false
      }

      if (data && data.action && data.action === `${msg.action}-reply` && cb) {
        cb(data)
        return undefined
      }

      window.removeEventListener('message', eventListener)
      return undefined
    }
    window.addEventListener('message', eventListener)
  }

  async __getPage (increment) {

    this.page += increment

    if (this.page <= 0) {
      this.page = 1
    }
    const from = (this.page - 1) * this.perPage
    const to = from + this.perPage

    await this.unlock()
    let accounts
    if (this._isLedgerLiveHdPath()) {
      accounts = await this._getAccountsBIP44(from, to)
    } else {
      accounts = this._getAccountsLegacy(from, to)
    }
    return accounts
  }

  async _getAccountsBIP44 (from, to) {
    const accounts = []

    for (let i = from; i < to; i++) {
      const path = this._getPathForIndex(i)
      const address = await this.unlock(path)
      const valid = this.implementFullBIP44 ? await this._hasPreviousTransactions(address) : true
      accounts.push({
        address,
        balance: null,
        index: i,
      })
      // PER BIP44
      // "Software should prevent a creation of an account if
      // a previous account does not have a transaction history
      // (meaning none of its addresses have been used before)."
      if (!valid) {
        break
      }
    }
    return accounts
  }

  _getAccountsLegacy (from, to) {
    const accounts = []

    for (let i = from; i < to; i++) {
      const address = this._addressFromIndex(pathBase, i)
      accounts.push({
        address,
        balance: null,
        index: i,
      })
      this.paths[ethUtil.toChecksumAddress(address)] = i
    }
    return accounts
  }

  _padLeftEven (hex) {
    return hex.length % 2 === 0 ? hex : `0${hex}`
  }

  _normalize (buf) {
    return this._padLeftEven(ethUtil.bufferToHex(buf).toLowerCase())
  }

  // eslint-disable-next-line no-shadow
  _addressFromIndex (pathBase, i) {
    const dkey = this.hdk.derive(`${pathBase}/${i}`)
    const address = ethUtil
      .publicToAddress(dkey.publicKey, true)
      .toString('hex')
    return ethUtil.toChecksumAddress(`0x${address}`)
  }

  _pathFromAddress (address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address)
    let index = this.paths[checksummedAddress]
    if (typeof index === 'undefined') {
      for (let i = 0; i < MAX_INDEX; i++) {
        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {
          index = i
          break
        }
      }
    }

    if (typeof index === 'undefined') {
      throw new Error('Unknown address')
    }
    return this._getPathForIndex(index)
  }

  _toAscii (hex) {
    let str = ''
    let i = 0
    const l = hex.length
    if (hex.substring(0, 2) === '0x') {
      i = 2
    }
    for (; i < l; i += 2) {
      const code = parseInt(hex.substr(i, 2), 16)
      str += String.fromCharCode(code)
    }

    return str
  }

  _getPathForIndex (index) {
    // Check if the path is BIP 44 (Ledger Live)
    return this._isLedgerLiveHdPath() ? `m/44'/60'/${index}'/0/0` : `${this.hdPath}/${index}`
  }

  _isLedgerLiveHdPath () {
    return this.hdPath === `m/44'/60'/0'/0/0`
  }

  _toLedgerPath (path) {
    return path.toString().replace('m/', '')
  }

  async _hasPreviousTransactions (address) {
    const apiUrl = this._getApiUrl()
    const response = await window.fetch(`${apiUrl}/api?module=account&action=txlist&address=${address}&tag=latest&page=1&offset=1`)
    const parsedResponse = await response.json()
    if (parsedResponse.status !== '0' && parsedResponse.result.length > 0) {
      return true
    }
    return false
  }

  _getApiUrl () {
    return NETWORK_API_URLS[this.network] || NETWORK_API_URLS.mainnet
  }

}

LedgerBridgeKeyring.type = type
module.exports = LedgerBridgeKeyring

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/index.js", {"./block-cache":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-cache.js","./block-ref":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-ref.js","./block-ref-rewrite":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-ref-rewrite.js","./block-tracker-inspector":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-tracker-inspector.js","./fetch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/fetch.js","./inflight-cache":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/inflight-cache.js","./providerAsMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/providerAsMiddleware.js","./providerFromEngine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/providerFromEngine.js","./providerFromMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/providerFromMiddleware.js","./retryOnEmpty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/retryOnEmpty.js","./wallet":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/wallet.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./block-cache"), exports);
__exportStar(require("./block-ref-rewrite"), exports);
__exportStar(require("./block-ref"), exports);
__exportStar(require("./block-tracker-inspector"), exports);
__exportStar(require("./fetch"), exports);
__exportStar(require("./inflight-cache"), exports);
__exportStar(require("./providerAsMiddleware"), exports);
__exportStar(require("./providerFromEngine"), exports);
__exportStar(require("./providerFromMiddleware"), exports);
__exportStar(require("./retryOnEmpty"), exports);
__exportStar(require("./wallet"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-lattice-keyring/index.js", {"@ethereumjs/common":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ethereumjs/common/dist.browser/index.js","@ethereumjs/tx":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ethereumjs/tx/dist.browser/index.js","bignumber.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-lattice-keyring/node_modules/bignumber.js/bignumber.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crypto-browserify/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","gridplus-sdk":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-lattice-keyring/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const crypto = require('crypto');
const EventEmitter = require('events').EventEmitter;
const BN = require('bignumber.js');
const SDK = require('gridplus-sdk');
const EthTx = require('@ethereumjs/tx');
const Common = require('@ethereumjs/common').default;
const Util = require('ethereumjs-util');
const keyringType = 'Lattice Hardware';
const HARDENED_OFFSET = 0x80000000;
const PER_PAGE = 5;
const CLOSE_CODE = -1000;
const STANDARD_HD_PATH = `m/44'/60'/0'/0/x`

class LatticeKeyring extends EventEmitter {
  constructor (opts={}) {
    super()
    this.type = keyringType;
    this._resetDefaults();
    this.deserialize(opts);
  }

  //-------------------------------------------------------------------
  // Keyring API (per `https://github.com/MetaMask/eth-simple-keyring`)
  //-------------------------------------------------------------------
  deserialize (opts = {}) {
    if (opts.hdPath)
      this.hdPath = opts.hdPath;
    if (opts.creds)
      this.creds = opts.creds;
    if (opts.accounts)
      this.accounts = opts.accounts;
    if (opts.accountIndices)
      this.accountIndices = opts.accountIndices;
    if (opts.accountOpts)
      this.accountOpts = opts.accountOpts;
    if (opts.walletUID)
      this.walletUID = opts.walletUID;
    if (opts.name)  // Legacy; use is deprecated and appName is more descriptive
      this.appName = opts.name;
    if (opts.appName)
      this.appName = opts.appName;
    if (opts.network)
      this.network = opts.network;
    if (opts.page)
      this.page = opts.page;
    return Promise.resolve()
  }

  setHdPath(hdPath) {
    this.hdPath = hdPath;
  }

  serialize() {
    return Promise.resolve({
      creds: this.creds,
      accounts: this.accounts,
      accountIndices: this.accountIndices,
      accountOpts: this.accountOpts,
      walletUID: this.walletUID,
      appName: this.appName,
      name: this.name,  // Legacy; use is deprecated
      network: this.network,
      page: this.page,
      hdPath: this.hdPath,
    })
  }

  isUnlocked () {
    return this._hasCreds() && this._hasSession()
  }

  // Initialize a session with the Lattice1 device using the GridPlus SDK
  unlock() {
    return new Promise((resolve, reject) => {
      // Force compatability. `this.accountOpts` were added after other
      // state params and must be synced in order for this keyring to function.
      if ((!this.accountOpts) || 
          (this.accounts.length > 0 && this.accountOpts.length != this.accounts.length)) 
      {
        this.forgetDevice();
        return reject(new Error(
          'You can now add multiple Lattice and SafeCard accounts at the same time! ' +
          'Your accounts have been cleared. Please press Continue to add them back in.'
        ));
      }

      this._getCreds()
      .then((creds) => {
        if (creds) {
          this.creds.deviceID = creds.deviceID;
          this.creds.password = creds.password;
          this.creds.endpoint = creds.endpoint || null;
        }
        return this._initSession();
      })
      .then(() => {
        return this._connect();
      })
      .then(() => {
        return resolve('Unlocked');
      })
      .catch((err) => {
        return reject(new Error(err));
      })
    })
  }

  // Add addresses to the local store and return the full result
  addAccounts(n=1) {
    return new Promise((resolve, reject) => {
      if (n === CLOSE_CODE) {
        // Special case: use a code to forget the device. 
        // (This function is overloaded due to constraints upstream)
        this.forgetDevice();
        return resolve([]);
      } else if (n <= 0) {
        // Avoid non-positive numbers.
        return reject('Number of accounts to add must be a positive number.');
      } else {
        // Normal behavior: establish the connection and fetch addresses.
        this.unlock()
        .then(() => {
          return this._fetchAddresses(n, this.unlockedAccount)
        })
        .then((addrs) => {
          const walletUID = this._getCurrentWalletUID();
          // Add these indices
          addrs.forEach((addr, i) => {
            let alreadySaved = false;
            for (let j = 0; j < this.accounts.length; j++) {
              if ((this.accounts[j] === addr) && 
                  (this.accountOpts[j].walletUID === walletUID) &&
                  (this.accountOpts[j].hdPath === this.hdPath))
                alreadySaved = true;
            }
            if (!alreadySaved) {
              this.accounts.push(addr);
              this.accountIndices.push(this.unlockedAccount+i);
              this.accountOpts.push({
                walletUID,
                hdPath: this.hdPath,
              })
            }
          })
          return resolve(this.accounts);
        })
        .catch((err) => {
          return reject(new Error(err));
        })
      }
    })
  }

  // Return the local store of addresses
  getAccounts() {
    return Promise.resolve(this.accounts ? this.accounts.slice() : [].slice());
  }

  signTransaction (address, tx) {
    return new Promise((resolve, reject) => {
      this._unlockAndFindAccount(address)
      .then((accountIdx) => {
        if (!tx.to) {
          return reject('Contract deployment is not supported by the Lattice at this time. ' +
                        '`to` field must be included.')
        }
        // Build the Lattice request data and make request
        // We expect `tx` to be an `ethereumjs-tx` object, meaning all fields are bufferized
        // To ensure everything plays nicely with gridplus-sdk, we convert everything to hex strings
        const addressIdx = this.accountIndices[accountIdx];
        const addressParentPath = this.accountOpts[accountIdx].hdPath;
        const txData = {
          chainId: `0x${this._getEthereumJsChainId(tx).toString('hex')}` || 1,
          nonce: `0x${tx.nonce.toString('hex')}` || 0,
          gasLimit: `0x${tx.gasLimit.toString('hex')}`,
          to: tx.to.toString('hex'),
          value: `0x${tx.value.toString('hex')}`,
          data: tx.data.length === 0 ? null : `0x${tx.data.toString('hex')}`,
          signerPath: this._getHDPathIndices(addressParentPath, addressIdx),
        }
        switch (tx._type) {
          case 2: // eip1559
            if ((tx.maxPriorityFeePerGas === null || tx.maxFeePerGas === null) ||
                (tx.maxPriorityFeePerGas === undefined || tx.maxFeePerGas === undefined))
              throw new Error('`maxPriorityFeePerGas` and `maxFeePerGas` must be included for EIP1559 transactions.');
            txData.maxPriorityFeePerGas = `0x${tx.maxPriorityFeePerGas.toString('hex')}`;
            txData.maxFeePerGas = `0x${tx.maxFeePerGas.toString('hex')}`;
            txData.accessList = tx.accessList || [];
            txData.type = 2;
            break;
          case 1: // eip2930
            txData.accessList = tx.accessList || [];
            txData.gasPrice = `0x${tx.gasPrice.toString('hex')}`;
            txData.type = 1;
            break;
          default: // legacy
            txData.gasPrice = `0x${tx.gasPrice.toString('hex')}`;
            txData.type = null;
            break;
        }
        // Lattice firmware v0.11.0 implemented EIP1559 and EIP2930 so for previous verisons
        // we need to overwrite relevant params and revert to legacy type.
        // Note: `this.sdkSession.fwVersion is of format [fix, minor, major, reserved]
        const forceLegacyTx = this.sdkSession.fwVersion[2] < 1 && 
                              this.sdkSession.fwVersion[1] < 11;
        if (forceLegacyTx && txData.type === 2) {
          console.warn('Lattice firmware must be >=0.11.0 to support EIP1559 transactions. Revering to legacy.');
          txData.gasPrice = txData.maxFeePerGas;
          txData.revertToLegacy = true;
          delete txData.type;
          delete txData.maxFeePerGas;
          delete txData.maxPriorityFeePerGas;
          delete txData.accessList;
        } else if (forceLegacyTx && txData.type === 1) {
          console.warn('Lattice firmware must be >=0.11.0 to support EIP2930 transactions. Reverting to legacy.');
          txData.revertToLegacy = true;
          delete txData.type;
          delete txData.accessList;
        }
        // Get the signature
        return this._signTxData(txData)
      })
      .then((signedTx) => {
        // Add the sig params. `signedTx = { sig: { v, r, s }, tx, txHash}`
        if (!signedTx.sig || !signedTx.sig.v || !signedTx.sig.r || !signedTx.sig.s)
          return reject(new Error('No signature returned.'));
        const txToReturn = tx.toJSON();
        const v = signedTx.sig.v.length === 0 ? '0' : signedTx.sig.v.toString('hex')
        txToReturn.r = Util.addHexPrefix(signedTx.sig.r.toString('hex'));
        txToReturn.s = Util.addHexPrefix(signedTx.sig.s.toString('hex'));
        txToReturn.v = Util.addHexPrefix(v);

        if (signedTx.revertToLegacy === true) {
          // If firmware does not support an EIP1559/2930 transaction we revert to legacy
          txToReturn.type = 0;
          txToReturn.gasPrice = signedTx.gasPrice;
        } else {
          // Otherwise relay the tx type
          txToReturn.type = signedTx.type;
        }

        // Build the tx for export
        let validatingTx;
        const _chainId = `0x${this._getEthereumJsChainId(tx).toString('hex')}`;
        const chainId = new BN(_chainId).toNumber();
        const customNetwork = Common.forCustomChain('mainnet', {
          name: 'notMainnet',
          networkId: chainId,
          chainId: chainId,
        }, 'london')

        validatingTx = EthTx.TransactionFactory.fromTxData(txToReturn, {
          common: customNetwork, freeze: Object.isFrozen(tx)
        })
        return resolve(validatingTx)
      })
      .catch((err) => {
        return reject(new Error(err));
      })
    })
  }

  signPersonalMessage(address, msg) {
    return this.signMessage(address, { payload: msg, protocol: 'signPersonal' });
  }

  signTypedData(address, msg, opts) {
    if (opts.version && (opts.version !== 'V4' && opts.version !== 'V3'))
      throw new Error(`Only signTypedData V3 and V4 messages (EIP712) are supported. Got version ${opts.version}`);
    return this.signMessage(address, { payload: msg, protocol: 'eip712' })
  }

  signMessage(address, msg) {
    return new Promise((resolve, reject) => {
      this._unlockAndFindAccount(address)
      .then((accountIdx) => {
        let { payload, protocol } = msg;
        // If the message is not an object we assume it is a legacy signPersonal request
        if (!payload || !protocol) {
          payload = msg;
          protocol = 'signPersonal';
        }
        const addressIdx = this.accountIndices[accountIdx];
        const addressParentPath = this.accountOpts[accountIdx].hdPath;
        const req = {
          currency: 'ETH_MSG',
          data: {
            protocol,
            payload,
            signerPath: this._getHDPathIndices(addressParentPath, addressIdx),
          }
        }
        if (!this._hasSession())
          return reject(new Error('No SDK session started. Cannot sign transaction.'));
        this.sdkSession.sign(req, (err, res) => {
          if (err)
            return reject(new Error(err));
          if (!res.sig)
            return reject(new Error('No signature returned'));
          // Convert the `v` to a number. It should convert to 0 or 1
          try {
            let v = res.sig.v.toString('hex');
            if (v.length < 2)
              v = `0${v}`;
            return resolve(`0x${res.sig.r}${res.sig.s}${v}`);
          } catch (err) {
            return reject(new Error('Invalid signature format returned.'))
          }
        })
      })
      .catch((err) => {
        return reject(new Error(err));
      })
    })
  }

  exportAccount(address) {
    return Promise.reject(Error('exportAccount not supported by this device'))
  }

  removeAccount(address) {
    this.accounts.forEach((account, i) => {
      if (account.toLowerCase() === address.toLowerCase()) {
        this.accounts.splice(i, 1);
        this.accountIndices.splice(i, 1);
        this.accountOpts.splice(i, 1);
        return;
      }
    })
  }

  getFirstPage() {
    this.page = 0;
    return this._getPage(0);
  }

  getNextPage () {
    return this._getPage(1);
  }

  getPreviousPage () {
    return this._getPage(-1);
  }

  setAccountToUnlock (index) {
    this.unlockedAccount = parseInt(index, 10)
  }

  forgetDevice () {
    this._resetDefaults();
  }

  //-------------------------------------------------------------------
  // Internal methods and interface to SDK
  //-------------------------------------------------------------------
  // Find the account index of the requested address.
  // Note that this is the BIP39 path index, not the index in the address cache.
  _unlockAndFindAccount(address) {
    return new Promise((resolve, reject) => {
      this.unlock()
      .then(() => {
        return this.getAccounts()
      })
      .then((addrs) => {
        // Find the signer in our current set of accounts
        // If we can't find it, return an error
        let accountIdx = null;
        addrs.forEach((addr, i) => {
          if (address.toLowerCase() === addr.toLowerCase())
            accountIdx = i;
        })
        if (accountIdx === null)
          return reject('Signer not present');
        // Make sure the account is associated with the current wallet
        if (this.accountOpts[accountIdx].walletUID !== this._getCurrentWalletUID()) {
          return reject(new Error('Account on a different wallet. ' +
                                  'Please switch to the correct wallet on your Lattice.'));
        }
        return resolve(accountIdx);
      })
      .catch((err) => {
        return reject(err);
      })
    })
  }

  _getHDPathIndices(hdPath, insertIdx=0) {
    const path = hdPath.split('/').slice(1);
    const indices = [];
    let usedX = false;
    path.forEach((_idx) => {
      const isHardened = (_idx[_idx.length - 1] === "'");
      let idx = isHardened ? HARDENED_OFFSET : 0;
      // If there is an `x` in the path string, we will use it to insert our
      // index. This is useful for e.g. Ledger Live path. Most paths have the
      // changing index as the last one, so having an `x` in the path isn't
      // usually necessary.
      if (_idx.indexOf('x') > -1) {
        idx += insertIdx;
        usedX = true;
      } else if (isHardened) {
        idx += Number(_idx.slice(0, _idx.length - 1));
      } else {
        idx += Number(_idx);
      }
      indices.push(idx);
    })
    // If this path string does not include an `x`, we just append the index
    // to the end of the extracted set
    if (usedX === false) {
      indices.push(insertIdx);
    }
    // Sanity check -- Lattice firmware will throw an error for large paths
    if (indices.length > 5)
      throw new Error('Only HD paths with up to 5 indices are allowed.')
    return indices;
  }

  _resetDefaults() {
    this.accounts = [];
    this.accountIndices = [];
    this.accountOpts = [];
    this.isLocked = true;
    this.creds = {
      deviceID: null,
      password: null,
      endpoint: null,
    };
    this.walletUID = null;
    this.sdkSession = null;
    this.page = 0;
    this.unlockedAccount = 0;
    this.network = null;
    this.hdPath = STANDARD_HD_PATH;
  }

  _openConnectorTab(url) {
    return new Promise((resolve, reject) => {
      const browserTab = window.open(url);
      // Preferred option for Chromium browsers. This extension runs in a window
      // for Chromium so we can do window-based communication very easily.
      if (browserTab) {
        return resolve({ chromium: browserTab });
      } else if (browser && browser.tabs && browser.tabs.create) {
        // FireFox extensions do not run in windows, so it will return `null` from
        // `window.open`. Instead, we need to use the `browser` API to open a tab. 
        // We will surveille this tab to see if its URL parameters change, which 
        // will indicate that the user has logged in.
        browser.tabs.create({url})
        .then((tab) => {
          return resolve({ firefox: tab });
        })
        .catch((err) => {
          return reject(new Error('Failed to open Lattice connector.'))
        })
      } else {
        return reject(new Error('Unknown browser context. Cannot open Lattice connector.'))
      }

    })
  }

  _findTabById(id) {
    return new Promise((resolve, reject) => {
      browser.tabs.query({})
      .then((tabs) => {
        tabs.forEach((tab) => {
          if (tab.id === id) {
            return resolve(tab);
          }
        })
        return resolve(null);
      })
      .catch((err) => {
        return reject(err);
      })
    })
  }
  
  _getCreds() {
    return new Promise((resolve, reject) => {
      // We only need to setup if we don't have a deviceID
      if (this._hasCreds())
        return resolve();

      // If we are not aware of what Lattice we should be talking to,
      // we need to open a window that lets the user go through the
      // pairing or connection process.
      const name = this.appName ? this.appName : 'Unknown'
      const base = 'https://wallet.gridplus.io';
      const url = `${base}?keyring=${name}&forceLogin=true`;
      let listenInterval;

      // PostMessage handler
      function receiveMessage(event) {
        // Ensure origin
        if (event.origin !== base)
          return;
        // Stop the listener
        try {
          clearInterval(listenInterval);
        } catch (err) {
          console.warn('Failed to close interval', err);
        }
        // Parse and return creds
        try {
          const creds = JSON.parse(event.data);
          if (!creds.deviceID || !creds.password)
            return reject(new Error('Invalid credentials returned from Lattice.'));
          return resolve(creds);
        } catch (err) {
          return reject(err);
        }
      }

      // Open the tab
      this._openConnectorTab(url)
      .then((conn) => {
        if (conn.chromium) {
          // On a Chromium browser we can just listen for a window message
          window.addEventListener("message", receiveMessage, false);
          // Watch for the open window closing before creds are sent back
          listenInterval = setInterval(() => {
            if (conn.chromium.closed) {
              clearInterval(listenInterval);
              return reject(new Error('Lattice connector closed.'));
            }
          }, 500);
        } else if (conn.firefox) {
          // For Firefox we cannot use `window` in the extension and can't
          // directly communicate with the tabs very easily so we use a
          // workaround: listen for changes to the URL, which will contain
          // the login info.
          // NOTE: This will only work if have `https://wallet.gridplus.io/*`
          // host permissions in your manifest file (and also `activeTab` permission)
          const loginUrlParam = '&loginCache=';
          listenInterval = setInterval(() => {
            this._findTabById(conn.firefox.id)
            .then((tab) => {
              if (!tab || !tab.url) {
                return reject(new Error('Lattice connector closed.'));
              }
              // If the tab we opened contains a new URL param
              const paramLoc = tab.url.indexOf(loginUrlParam);
              if (paramLoc < 0) 
                return;
              const dataLoc = paramLoc + loginUrlParam.length;
              // Stop this interval
              clearInterval(listenInterval);
              try {
                // Parse the login data. It is a stringified JSON object 
                // encoded as a base64 string.
                const _creds = Buffer.from(tab.url.slice(dataLoc), 'base64').toString();
                // Close the tab and return the credentials
                browser.tabs.remove(tab.id)
                .then(() => {
                  const creds = JSON.parse(_creds);
                  if (!creds.deviceID || !creds.password)
                    return reject(new Error('Invalid credentials returned from Lattice.'));
                  return resolve(creds);
                })
              } catch (err) {
                return reject('Failed to get login data from Lattice. Please try again.')
              }
            })
          }, 500);
        }
      })
    })
  }

  // [re]connect to the Lattice. This should be done frequently to ensure
  // the expected wallet UID is still the one active in the Lattice.
  // This will handle SafeCard insertion/removal events.
  _connect() {
    return new Promise((resolve, reject) => {
      this.sdkSession.connect(this.creds.deviceID, (err) => {
        if (err)
          return reject(err);
        // Save the current wallet UID
        const activeWallet = this.sdkSession.getActiveWallet();
        if (!activeWallet || !activeWallet.uid)
          return reject(new Error('No active wallet'));
        const newUID = activeWallet.uid.toString('hex');
        // If we fetched a walletUID that does not match our current one,
        // reset accounts and update the known UID
        if (newUID != this.walletUID) {
          this.walletUID = newUID;
        }
        return resolve();
      });
    })
  }

  _initSession() {
    return new Promise((resolve, reject) => {
      if (this._hasSession())
        return resolve();
      try {
        let url = 'https://signing.gridpl.us';
        if (this.creds.endpoint)
          url = this.creds.endpoint
        const setupData = {
          name: this.appName,
          baseUrl: url,
          crypto,
          timeout: 120000,
          privKey: this._genSessionKey(),
          network: this.network
        }
        this.sdkSession = new SDK.Client(setupData);
        return resolve();
      } catch (err) {
        return reject(err);
      }
    })
  }

  _fetchAddresses(n=1, i=0, recursedAddrs=[]) {
    return new Promise((resolve, reject) => {
      if (!this._hasSession())
        return reject('No SDK session started. Cannot fetch addresses.')

      this.__fetchAddresses(n, i, (err, addrs) => {
        if (err)
          return reject(err);
        else
          return resolve(addrs);
      })
    })
  }

  __fetchAddresses(n=1, i=0, cb, recursedAddrs=[]) {
     // Determine if we need to do a recursive call here. We prefer not to
      // because they will be much slower, but Ledger paths require it since
      // they are non-standard.
      if (n === 0)
        return cb(null, recursedAddrs);
      const shouldRecurse = this._hdPathHasInternalVarIdx();

      // Make the request to get the requested address
      const addrData = { 
        currency: 'ETH', 
        startPath: this._getHDPathIndices(this.hdPath, i), 
        n: shouldRecurse ? 1 : n,
        skipCache: true,
      };
      this.sdkSession.getAddresses(addrData, (err, addrs) => {
        if (err)
          return cb(err);
        // Sanity check -- if this returned 0 addresses, handle the error
        if (addrs.length < 1)
          return cb(new Error('No addresses returned'));
        // Return the addresses we fetched *without* updating state
        if (shouldRecurse) {
          return this.__fetchAddresses(n-1, i+1, cb, recursedAddrs.concat(addrs));
        } else {
          return cb(null, addrs);
        }
      })
  }

  _signTxData(txData) {
    return new Promise((resolve, reject) => {
      if (!this._hasSession())
        return reject(new Error('No SDK session started. Cannot sign transaction.'));
      this.sdkSession.sign({ currency: 'ETH', data: txData }, (err, res) => {
        if (err)
          return reject(err);
        if (!res.tx)
          return reject(new Error('No transaction payload returned.'));
        // Here we catch an edge case where the requester is asking for an EIP1559
        // transaction but firmware is not updated to support it. We fallback to legacy.
        res.type = txData.type;
        if (txData.revertToLegacy) {
          res.revertToLegacy = true;
          res.gasPrice = txData.gasPrice;
        }
        // Return the signed tx
        return resolve(res)
      })
    })
  }

  _getPage(increment=0) {
    return new Promise((resolve, reject) => {
      this.page += increment;
      if (this.page < 0)
        this.page = 0;
      const start = PER_PAGE * this.page;
      // Otherwise unlock the device and fetch more addresses
      this.unlock()
      .then(() => {
        return this._fetchAddresses(PER_PAGE, start)
      })
      .then((addrs) => {
        const accounts = []
        addrs.forEach((address, i) => {
          accounts.push({
            address,
            balance: null,
            index: start + i,
          })
        })
        return resolve(accounts)
      })
      .catch((err) => {
        return reject(err);
      })
    })
  }

  _hasCreds() {
    return this.creds.deviceID !== null && this.creds.password !== null && this.appName;
  }

  _hasSession() {
    return this.sdkSession && this.walletUID;
  }

  _genSessionKey() {
    if (this.name && !this.appName) // Migrate from legacy param if needed
      this.appName = this.name;
    if (!this._hasCreds())
      throw new Error('No credentials -- cannot create session key!');
    const buf = Buffer.concat([
      Buffer.from(this.creds.password), 
      Buffer.from(this.creds.deviceID), 
      Buffer.from(this.appName)
    ])
    return crypto.createHash('sha256').update(buf).digest();
  }

  // Determine if an HD path has a variable index internal to it.
  // e.g. m/44'/60'/x'/0/0 -> true, while m/44'/60'/0'/0/x -> false
  // This is just a hacky helper to avoid having to recursively call for non-ledger
  // derivation paths. Ledger is SO ANNOYING TO SUPPORT.
  _hdPathHasInternalVarIdx() {
    const path = this.hdPath.split('/').slice(1);
    for (let i = 0; i < path.length -1; i++) {
      if (path[i].indexOf('x') > -1)
        return true;
    }
    return false;
  }

  // Get the chainId for whatever object this is.
  // Returns a hex string without the 0x prefix
  _getEthereumJsChainId(tx) {
    if (typeof tx.getChainId === 'function')
      return tx.getChainId();
    else if (tx.common && typeof tx.common.chainIdBN === 'function')
      return tx.common.chainIdBN().toString(16);
    else if (typeof tx.chainId === 'number')
      return tx.chainId.toString(16);
    else if (typeof tx.chainId === 'string')
      return tx.chainId;
    return '1';
  }

  _getCurrentWalletUID() {
    if (!this.sdkSession)
      return null;
    return this.sdkSession.getActiveWallet().uid.toString('hex');
  }

}

LatticeKeyring.type = keyringType
module.exports = LatticeKeyring;
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"eth-lattice-keyring",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-lattice-keyring/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/swaps.js", {"../../../shared/constants/gas":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/gas.js","../../../shared/constants/swaps":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/swaps.js","../../../shared/constants/time":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/time.js","../../../shared/modules/conversion.utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/conversion.utils.js","../../../shared/modules/swaps.utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/swaps.utils.js","../../../ui/helpers/utils/fetch-with-cache":"/home/clarisco/Desktop/metamask-extension-develop/ui/helpers/utils/fetch-with-cache.js","../../../ui/helpers/utils/token-util":"/home/clarisco/Desktop/metamask-extension-develop/ui/helpers/utils/token-util.js","../../../ui/helpers/utils/util":"/home/clarisco/Desktop/metamask-extension-develop/ui/helpers/utils/util.js","../../../ui/pages/send/send.utils":"/home/clarisco/Desktop/metamask-extension-develop/ui/pages/send/send.utils.js","../../../ui/pages/swaps/swaps.util":"/home/clarisco/Desktop/metamask-extension-develop/ui/pages/swaps/swaps.util.js","./network":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/index.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","bignumber.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bignumber.js/bignumber.js","ethers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethers/lib/index.js","human-standard-token-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/human-standard-token-abi/index.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/swaps.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utils = exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _ethers = require("ethers");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _obsStore = require("@metamask/obs-store");

var _lodash = require("lodash");

var _humanStandardTokenAbi = _interopRequireDefault(require("human-standard-token-abi"));

var _tokenUtil = require("../../../ui/helpers/utils/token-util");

var _send = require("../../../ui/pages/send/send.utils");

var _conversion = require("../../../shared/modules/conversion.utils");

var _swaps = require("../../../shared/constants/swaps");

var _gas = require("../../../shared/constants/gas");

var _swaps2 = require("../../../shared/modules/swaps.utils");

var _swaps3 = require("../../../ui/pages/swaps/swaps.util");

var _fetchWithCache = _interopRequireDefault(require("../../../ui/helpers/utils/fetch-with-cache"));

var _time = require("../../../shared/constants/time");

var _util = require("../../../ui/helpers/utils/util");

var _network = require("./network");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// The MAX_GAS_LIMIT is a number that is higher than the maximum gas costs we have observed on any aggregator
const MAX_GAS_LIMIT = 2500000; // To ensure that our serves are not spammed if MetaMask is left idle, we limit the number of fetches for quotes that are made on timed intervals.
// 3 seems to be an appropriate balance of giving users the time they need when MetaMask is not left idle, and turning polling off when it is.

const POLL_COUNT_LIMIT = 3; // If for any reason the MetaSwap API fails to provide a refresh time,
// provide a reasonable fallback to avoid further errors

const FALLBACK_QUOTE_REFRESH_TIME = _time.MINUTE;

function calculateGasEstimateWithRefund(maxGas = MAX_GAS_LIMIT, estimatedRefund = 0, estimatedGas = 0) {
  const maxGasMinusRefund = new _bignumber.default(maxGas, 10).minus(estimatedRefund, 10);
  const gasEstimateWithRefund = maxGasMinusRefund.lt(estimatedGas, 16) ? maxGasMinusRefund.toString(16) : estimatedGas;
  return gasEstimateWithRefund;
}

const initialState = {
  swapsState: {
    quotes: {},
    quotesPollingLimitEnabled: false,
    fetchParams: null,
    tokens: null,
    tradeTxId: null,
    approveTxId: null,
    quotesLastFetched: null,
    customMaxGas: '',
    customGasPrice: null,
    customMaxFeePerGas: null,
    customMaxPriorityFeePerGas: null,
    swapsUserFeeLevel: '',
    selectedAggId: null,
    customApproveTxData: '',
    errorKey: '',
    topAggId: null,
    routeState: '',
    swapsFeatureIsLive: true,
    saveFetchedQuotes: false,
    swapsQuoteRefreshTime: FALLBACK_QUOTE_REFRESH_TIME,
    swapsQuotePrefetchingRefreshTime: FALLBACK_QUOTE_REFRESH_TIME
  }
};

class SwapsController {
  constructor({
    getBufferedGasLimit,
    networkController,
    provider,
    getProviderConfig,
    getTokenRatesState,
    fetchTradesInfo = _swaps3.fetchTradesInfo,
    getCurrentChainId,
    getEIP1559GasFeeEstimates
  }) {
    this.store = new _obsStore.ObservableStore({
      swapsState: _objectSpread({}, initialState.swapsState)
    });
    this._fetchTradesInfo = fetchTradesInfo;
    this._getCurrentChainId = getCurrentChainId;
    this._getEIP1559GasFeeEstimates = getEIP1559GasFeeEstimates;
    this.getBufferedGasLimit = getBufferedGasLimit;
    this.getTokenRatesState = getTokenRatesState;
    this.pollCount = 0;
    this.getProviderConfig = getProviderConfig;
    this.indexOfNewestCallInFlight = 0;
    this.ethersProvider = new _ethers.ethers.providers.Web3Provider(provider);
    this._currentNetwork = networkController.store.getState().network;
    networkController.on(_network.NETWORK_EVENTS.NETWORK_DID_CHANGE, network => {
      if (network !== 'loading' && network !== this._currentNetwork) {
        this._currentNetwork = network;
        this.ethersProvider = new _ethers.ethers.providers.Web3Provider(provider);
      }
    });
  }

  async fetchSwapsRefreshRates(chainId) {
    const response = await (0, _fetchWithCache.default)((0, _swaps3.getBaseApi)('network', chainId), {
      method: 'GET'
    }, {
      cacheRefreshTime: 600000
    });
    const {
      refreshRates
    } = response || {};

    if (!refreshRates || typeof refreshRates.quotes !== 'number' || typeof refreshRates.quotesPrefetching !== 'number') {
      throw new Error(`MetaMask - invalid response for refreshRates: ${response}`);
    } // We presently use milliseconds in the UI.


    return {
      quotes: refreshRates.quotes * 1000,
      quotesPrefetching: refreshRates.quotesPrefetching * 1000
    };
  } // Sets the refresh rate for quote updates from the MetaSwap API


  async _setSwapsRefreshRates() {
    var _swapsRefreshRates, _swapsRefreshRates2;

    const chainId = this._getCurrentChainId();

    let swapsRefreshRates;

    try {
      swapsRefreshRates = await this.fetchSwapsRefreshRates(chainId);
    } catch (e) {
      console.error('Request for swaps quote refresh time failed: ', e);
    }

    const {
      swapsState: latestSwapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, latestSwapsState), {}, {
        swapsQuoteRefreshTime: ((_swapsRefreshRates = swapsRefreshRates) === null || _swapsRefreshRates === void 0 ? void 0 : _swapsRefreshRates.quotes) || FALLBACK_QUOTE_REFRESH_TIME,
        swapsQuotePrefetchingRefreshTime: ((_swapsRefreshRates2 = swapsRefreshRates) === null || _swapsRefreshRates2 === void 0 ? void 0 : _swapsRefreshRates2.quotesPrefetching) || FALLBACK_QUOTE_REFRESH_TIME
      })
    });
  } // Once quotes are fetched, we poll for new ones to keep the quotes up to date. Market and aggregator contract conditions can change fast enough
  // that quotes will no longer be available after 1 or 2 minutes. When fetchAndSetQuotes is first called, it receives fetch parameters that are stored in
  // state. These stored parameters are used on subsequent calls made during polling.
  // Note: we stop polling after 3 requests, until new quotes are explicitly asked for. The logic that enforces that maximum is in the body of fetchAndSetQuotes


  pollForNewQuotes() {
    const {
      swapsState: {
        swapsQuoteRefreshTime,
        swapsQuotePrefetchingRefreshTime,
        quotesPollingLimitEnabled
      }
    } = this.store.getState(); // swapsQuoteRefreshTime is used on the View Quote page, swapsQuotePrefetchingRefreshTime is used on the Build Quote page.

    const quotesRefreshRateInMs = quotesPollingLimitEnabled ? swapsQuoteRefreshTime : swapsQuotePrefetchingRefreshTime;
    this.pollingTimeout = setTimeout(() => {
      var _swapsState$fetchPara;

      const {
        swapsState
      } = this.store.getState();
      this.fetchAndSetQuotes(swapsState.fetchParams, (_swapsState$fetchPara = swapsState.fetchParams) === null || _swapsState$fetchPara === void 0 ? void 0 : _swapsState$fetchPara.metaData, true);
    }, quotesRefreshRateInMs);
  }

  stopPollingForQuotes() {
    if (this.pollingTimeout) {
      clearTimeout(this.pollingTimeout);
    }
  }

  async fetchAndSetQuotes(fetchParams, fetchParamsMetaData = {}, isPolledRequest) {
    const {
      chainId
    } = fetchParamsMetaData;
    const {
      swapsState: {
        quotesPollingLimitEnabled,
        saveFetchedQuotes
      }
    } = this.store.getState();

    if (!fetchParams) {
      return null;
    } // Every time we get a new request that is not from the polling, we reset the poll count so we can poll for up to three more sets of quotes with these new params.


    if (!isPolledRequest) {
      this.pollCount = 0;
    } // If there are any pending poll requests, clear them so that they don't get call while this new fetch is in process


    clearTimeout(this.pollingTimeout);

    if (!isPolledRequest) {
      this.setSwapsErrorKey('');
    }

    const indexOfCurrentCall = this.indexOfNewestCallInFlight + 1;
    this.indexOfNewestCallInFlight = indexOfCurrentCall;

    if (!saveFetchedQuotes) {
      this.setSaveFetchedQuotes(true);
    }

    let [newQuotes] = await Promise.all([this._fetchTradesInfo(fetchParams, _objectSpread({}, fetchParamsMetaData)), this._setSwapsRefreshRates()]);
    const {
      swapsState: {
        saveFetchedQuotes: saveFetchedQuotesAfterResponse
      }
    } = this.store.getState(); // If saveFetchedQuotesAfterResponse is false, it means a user left Swaps (we cleaned the state)
    // and we don't want to set any API response with quotes into state.

    if (!saveFetchedQuotesAfterResponse) {
      return [{}, // quotes
      null // selectedAggId
      ];
    }

    newQuotes = (0, _lodash.mapValues)(newQuotes, quote => _objectSpread(_objectSpread({}, quote), {}, {
      sourceTokenInfo: fetchParamsMetaData.sourceTokenInfo,
      destinationTokenInfo: fetchParamsMetaData.destinationTokenInfo
    }));
    const quotesLastFetched = Date.now();
    let approvalRequired = false;

    if (!(0, _swaps2.isSwapsDefaultTokenAddress)(fetchParams.sourceToken, chainId) && Object.values(newQuotes).length) {
      const allowance = await this._getERC20Allowance(fetchParams.sourceToken, fetchParams.fromAddress, chainId); // For a user to be able to swap a token, they need to have approved the MetaSwap contract to withdraw that token.
      // _getERC20Allowance() returns the amount of the token they have approved for withdrawal. If that amount is greater
      // than 0, it means that approval has already occurred and is not needed. Otherwise, for tokens to be swapped, a new
      // call of the ERC-20 approve method is required.

      approvalRequired = allowance.eq(0) && Object.values(newQuotes)[0].aggregator !== 'wrappedNative';

      if (!approvalRequired) {
        newQuotes = (0, _lodash.mapValues)(newQuotes, quote => _objectSpread(_objectSpread({}, quote), {}, {
          approvalNeeded: null
        }));
      } else if (!isPolledRequest) {
        const {
          gasLimit: approvalGas
        } = await this.timedoutGasReturn(Object.values(newQuotes)[0].approvalNeeded);
        newQuotes = (0, _lodash.mapValues)(newQuotes, quote => _objectSpread(_objectSpread({}, quote), {}, {
          approvalNeeded: _objectSpread(_objectSpread({}, quote.approvalNeeded), {}, {
            gas: approvalGas || _swaps.DEFAULT_ERC20_APPROVE_GAS
          })
        }));
      }
    }

    let topAggId = null; // We can reduce time on the loading screen by only doing this after the
    // loading screen and best quote have rendered.

    if (!approvalRequired && !(fetchParams !== null && fetchParams !== void 0 && fetchParams.balanceError)) {
      newQuotes = await this.getAllQuotesWithGasEstimates(newQuotes);
    }

    if (Object.values(newQuotes).length === 0) {
      this.setSwapsErrorKey(_swaps.QUOTES_NOT_AVAILABLE_ERROR);
    } else {
      const [_topAggId, quotesWithSavingsAndFeeData] = await this._findTopQuoteAndCalculateSavings(newQuotes);
      topAggId = _topAggId;
      newQuotes = quotesWithSavingsAndFeeData;
    } // If a newer call has been made, don't update state with old information
    // Prevents timing conflicts between fetches


    if (this.indexOfNewestCallInFlight !== indexOfCurrentCall) {
      throw new Error(_swaps.SWAPS_FETCH_ORDER_CONFLICT);
    }

    const {
      swapsState
    } = this.store.getState();
    let {
      selectedAggId
    } = swapsState;

    if (!newQuotes[selectedAggId]) {
      selectedAggId = null;
    }

    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        quotes: newQuotes,
        fetchParams: _objectSpread(_objectSpread({}, fetchParams), {}, {
          metaData: fetchParamsMetaData
        }),
        quotesLastFetched,
        selectedAggId,
        topAggId
      })
    });

    if (quotesPollingLimitEnabled) {
      // We only want to do up to a maximum of three requests from polling if polling limit is enabled.
      // Otherwise we won't increase pollCount, so polling will run without a limit.
      this.pollCount += 1;
    }

    if (!quotesPollingLimitEnabled || this.pollCount < POLL_COUNT_LIMIT + 1) {
      this.pollForNewQuotes();
    } else {
      this.resetPostFetchState();
      this.setSwapsErrorKey(_swaps.QUOTES_EXPIRED_ERROR);
      return null;
    }

    return [newQuotes, topAggId];
  }

  safeRefetchQuotes() {
    const {
      swapsState
    } = this.store.getState();

    if (!this.pollingTimeout && swapsState.fetchParams) {
      this.fetchAndSetQuotes(swapsState.fetchParams);
    }
  }

  setSelectedQuoteAggId(selectedAggId) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        selectedAggId
      })
    });
  }

  setSwapsTokens(tokens) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        tokens
      })
    });
  }

  clearSwapsQuotes() {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        quotes: {}
      })
    });
  }

  setSwapsErrorKey(errorKey) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        errorKey
      })
    });
  }

  async getAllQuotesWithGasEstimates(quotes) {
    const quoteGasData = await Promise.all(Object.values(quotes).map(async quote => {
      const {
        gasLimit,
        simulationFails
      } = await this.timedoutGasReturn(quote.trade);
      return [gasLimit, simulationFails, quote.aggregator];
    }));
    const newQuotes = {};
    quoteGasData.forEach(([gasLimit, simulationFails, aggId]) => {
      if (gasLimit && !simulationFails) {
        const gasEstimateWithRefund = calculateGasEstimateWithRefund(quotes[aggId].maxGas, quotes[aggId].estimatedRefund, gasLimit);
        newQuotes[aggId] = _objectSpread(_objectSpread({}, quotes[aggId]), {}, {
          gasEstimate: gasLimit,
          gasEstimateWithRefund
        });
      } else if (quotes[aggId].approvalNeeded) {
        // If gas estimation fails, but an ERC-20 approve is needed, then we do not add any estimate property to the quote object
        // Such quotes will rely on the maxGas and averageGas properties from the api
        newQuotes[aggId] = quotes[aggId];
      } // If gas estimation fails and no approval is needed, then we filter that quote out, so that it is not shown to the user

    });
    return newQuotes;
  }

  timedoutGasReturn(tradeTxParams) {
    return new Promise(resolve => {
      let gasTimedOut = false;
      const gasTimeout = setTimeout(() => {
        gasTimedOut = true;
        resolve({
          gasLimit: null,
          simulationFails: true
        });
      }, _time.SECOND * 5); // Remove gas from params that will be passed to the `estimateGas` call
      // Including it can cause the estimate to fail if the actual gas needed
      // exceeds the passed gas

      const tradeTxParamsForGasEstimate = {
        data: tradeTxParams.data,
        from: tradeTxParams.from,
        to: tradeTxParams.to,
        value: tradeTxParams.value
      };
      this.getBufferedGasLimit({
        txParams: tradeTxParamsForGasEstimate
      }, 1).then(({
        gasLimit,
        simulationFails
      }) => {
        if (!gasTimedOut) {
          clearTimeout(gasTimeout);
          resolve({
            gasLimit,
            simulationFails
          });
        }
      }).catch(e => {
        _loglevel.default.error(e);

        if (!gasTimedOut) {
          clearTimeout(gasTimeout);
          resolve({
            gasLimit: null,
            simulationFails: true
          });
        }
      });
    });
  }

  async setInitialGasEstimate(initialAggId) {
    const {
      swapsState
    } = this.store.getState();

    const quoteToUpdate = _objectSpread({}, swapsState.quotes[initialAggId]);

    const {
      gasLimit: newGasEstimate,
      simulationFails
    } = await this.timedoutGasReturn(quoteToUpdate.trade);

    if (newGasEstimate && !simulationFails) {
      const gasEstimateWithRefund = calculateGasEstimateWithRefund(quoteToUpdate.maxGas, quoteToUpdate.estimatedRefund, newGasEstimate);
      quoteToUpdate.gasEstimate = newGasEstimate;
      quoteToUpdate.gasEstimateWithRefund = gasEstimateWithRefund;
    }

    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        quotes: _objectSpread(_objectSpread({}, swapsState.quotes), {}, {
          [initialAggId]: quoteToUpdate
        })
      })
    });
  }

  setApproveTxId(approveTxId) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        approveTxId
      })
    });
  }

  setTradeTxId(tradeTxId) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        tradeTxId
      })
    });
  }

  setQuotesLastFetched(quotesLastFetched) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        quotesLastFetched
      })
    });
  }

  setSwapsTxGasPrice(gasPrice) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        customGasPrice: gasPrice
      })
    });
  }

  setSwapsTxMaxFeePerGas(maxFeePerGas) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        customMaxFeePerGas: maxFeePerGas
      })
    });
  }

  setSwapsUserFeeLevel(swapsUserFeeLevel) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        swapsUserFeeLevel
      })
    });
  }

  setSwapsQuotesPollingLimitEnabled(quotesPollingLimitEnabled) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        quotesPollingLimitEnabled
      })
    });
  }

  setSwapsTxMaxFeePriorityPerGas(maxPriorityFeePerGas) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        customMaxPriorityFeePerGas: maxPriorityFeePerGas
      })
    });
  }

  setSwapsTxGasLimit(gasLimit) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        customMaxGas: gasLimit
      })
    });
  }

  setCustomApproveTxData(data) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        customApproveTxData: data
      })
    });
  }

  setBackgroundSwapRouteState(routeState) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        routeState
      })
    });
  }

  setSaveFetchedQuotes(status) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        saveFetchedQuotes: status
      })
    });
  }

  setSwapsLiveness(swapsLiveness) {
    const {
      swapsState
    } = this.store.getState();
    const {
      swapsFeatureIsLive
    } = swapsLiveness;
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        swapsFeatureIsLive
      })
    });
  }

  resetPostFetchState() {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, initialState.swapsState), {}, {
        tokens: swapsState.tokens,
        fetchParams: swapsState.fetchParams,
        swapsFeatureIsLive: swapsState.swapsFeatureIsLive,
        swapsQuoteRefreshTime: swapsState.swapsQuoteRefreshTime,
        swapsQuotePrefetchingRefreshTime: swapsState.swapsQuotePrefetchingRefreshTime
      })
    });
    clearTimeout(this.pollingTimeout);
  }

  resetSwapsState() {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, initialState.swapsState), {}, {
        swapsQuoteRefreshTime: swapsState.swapsQuoteRefreshTime,
        swapsQuotePrefetchingRefreshTime: swapsState.swapsQuotePrefetchingRefreshTime
      })
    });
    clearTimeout(this.pollingTimeout);
  }

  async _findTopQuoteAndCalculateSavings(quotes = {}) {
    const {
      contractExchangeRates: tokenConversionRates
    } = this.getTokenRatesState();
    const {
      swapsState: {
        customGasPrice,
        customMaxPriorityFeePerGas
      }
    } = this.store.getState();

    const chainId = this._getCurrentChainId();

    const numQuotes = Object.keys(quotes).length;

    if (!numQuotes) {
      return {};
    }

    const newQuotes = (0, _lodash.cloneDeep)(quotes);
    const {
      gasFeeEstimates,
      gasEstimateType
    } = await this._getEIP1559GasFeeEstimates();
    let usedGasPrice = '0x0';

    if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.FEE_MARKET) {
      const {
        high: {
          suggestedMaxPriorityFeePerGas
        },
        estimatedBaseFee
      } = gasFeeEstimates;
      usedGasPrice = (0, _conversion.addCurrencies)(customMaxPriorityFeePerGas || // Is already in hex WEI.
      (0, _conversion.decGWEIToHexWEI)(suggestedMaxPriorityFeePerGas), (0, _conversion.decGWEIToHexWEI)(estimatedBaseFee), {
        aBase: 16,
        bBase: 16,
        toNumericBase: 'hex',
        numberOfDecimals: 6
      });
    } else if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.LEGACY) {
      usedGasPrice = customGasPrice || (0, _conversion.decGWEIToHexWEI)(gasFeeEstimates.high);
    } else if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
      usedGasPrice = customGasPrice || (0, _conversion.decGWEIToHexWEI)(gasFeeEstimates.gasPrice);
    }

    let topAggId = null;
    let overallValueOfBestQuoteForSorting = null;
    Object.values(newQuotes).forEach(quote => {
      const {
        aggregator,
        approvalNeeded,
        averageGas,
        destinationAmount = 0,
        destinationToken,
        destinationTokenInfo,
        gasEstimate,
        sourceAmount,
        sourceToken,
        trade,
        fee: metaMaskFee
      } = quote;
      const tradeGasLimitForCalculation = gasEstimate ? new _bignumber.default(gasEstimate, 16) : new _bignumber.default(averageGas || MAX_GAS_LIMIT, 10);
      const totalGasLimitForCalculation = tradeGasLimitForCalculation.plus((approvalNeeded === null || approvalNeeded === void 0 ? void 0 : approvalNeeded.gas) || '0x0', 16).toString(16);
      const gasTotalInWeiHex = (0, _send.calcGasTotal)(totalGasLimitForCalculation, usedGasPrice); // trade.value is a sum of different values depending on the transaction.
      // It always includes any external fees charged by the quote source. In
      // addition, if the source asset is the selected chain's default token, trade.value
      // includes the amount of that token.

      const totalWeiCost = new _bignumber.default(gasTotalInWeiHex, 16).plus(trade.value, 16);
      const totalEthCost = (0, _conversion.conversionUtil)(totalWeiCost, {
        fromCurrency: 'ETH',
        fromDenomination: 'WEI',
        toDenomination: 'ETH',
        fromNumericBase: 'BN',
        numberOfDecimals: 6
      }); // The total fee is aggregator/exchange fees plus gas fees.
      // If the swap is from the selected chain's default token, subtract
      // the sourceAmount from the total cost. Otherwise, the total fee
      // is simply trade.value plus gas fees.

      const ethFee = (0, _swaps2.isSwapsDefaultTokenAddress)(sourceToken, chainId) ? (0, _conversion.conversionUtil)(totalWeiCost.minus(sourceAmount, 10), // sourceAmount is in wei
      {
        fromCurrency: 'ETH',
        fromDenomination: 'WEI',
        toDenomination: 'ETH',
        fromNumericBase: 'BN',
        numberOfDecimals: 6
      }) : totalEthCost;
      const decimalAdjustedDestinationAmount = (0, _tokenUtil.calcTokenAmount)(destinationAmount, destinationTokenInfo.decimals);
      const tokenPercentageOfPreFeeDestAmount = new _bignumber.default(100, 10).minus(metaMaskFee, 10).div(100);
      const destinationAmountBeforeMetaMaskFee = decimalAdjustedDestinationAmount.div(tokenPercentageOfPreFeeDestAmount);
      const metaMaskFeeInTokens = destinationAmountBeforeMetaMaskFee.minus(decimalAdjustedDestinationAmount);
      const tokenConversionRate = tokenConversionRates[Object.keys(tokenConversionRates).find(tokenAddress => (0, _util.isEqualCaseInsensitive)(tokenAddress, destinationToken))];
      const conversionRateForSorting = tokenConversionRate || 1;
      const ethValueOfTokens = decimalAdjustedDestinationAmount.times(conversionRateForSorting.toString(10), 10);
      const conversionRateForCalculations = (0, _swaps2.isSwapsDefaultTokenAddress)(destinationToken, chainId) ? 1 : tokenConversionRate;
      const overallValueOfQuoteForSorting = conversionRateForCalculations === undefined ? ethValueOfTokens : ethValueOfTokens.minus(ethFee, 10);
      quote.ethFee = ethFee.toString(10);

      if (conversionRateForCalculations !== undefined) {
        quote.ethValueOfTokens = ethValueOfTokens.toString(10);
        quote.overallValueOfQuote = overallValueOfQuoteForSorting.toString(10);
        quote.metaMaskFeeInEth = metaMaskFeeInTokens.times(conversionRateForCalculations.toString(10)).toString(10);
      }

      if (overallValueOfBestQuoteForSorting === null || overallValueOfQuoteForSorting.gt(overallValueOfBestQuoteForSorting)) {
        topAggId = aggregator;
        overallValueOfBestQuoteForSorting = overallValueOfQuoteForSorting;
      }
    });
    const isBest = (0, _swaps2.isSwapsDefaultTokenAddress)(newQuotes[topAggId].destinationToken, chainId) || Boolean(tokenConversionRates[Object.keys(tokenConversionRates).find(tokenAddress => {
      var _newQuotes$topAggId;

      return (0, _util.isEqualCaseInsensitive)(tokenAddress, (_newQuotes$topAggId = newQuotes[topAggId]) === null || _newQuotes$topAggId === void 0 ? void 0 : _newQuotes$topAggId.destinationToken);
    })]);
    let savings = null;

    if (isBest) {
      const bestQuote = newQuotes[topAggId];
      savings = {};
      const {
        ethFee: medianEthFee,
        metaMaskFeeInEth: medianMetaMaskFee,
        ethValueOfTokens: medianEthValueOfTokens
      } = getMedianEthValueQuote(Object.values(newQuotes)); // Performance savings are calculated as:
      //   (ethValueOfTokens for the best trade) - (ethValueOfTokens for the media trade)

      savings.performance = new _bignumber.default(bestQuote.ethValueOfTokens, 10).minus(medianEthValueOfTokens, 10); // Fee savings are calculated as:
      //   (fee for the median trade) - (fee for the best trade)

      savings.fee = new _bignumber.default(medianEthFee).minus(bestQuote.ethFee, 10);
      savings.metaMaskFee = bestQuote.metaMaskFeeInEth; // Total savings are calculated as:
      //   performance savings + fee savings - metamask fee

      savings.total = savings.performance.plus(savings.fee).minus(savings.metaMaskFee).toString(10);
      savings.performance = savings.performance.toString(10);
      savings.fee = savings.fee.toString(10);
      savings.medianMetaMaskFee = medianMetaMaskFee;
      newQuotes[topAggId].isBestQuote = true;
      newQuotes[topAggId].savings = savings;
    }

    return [topAggId, newQuotes];
  }

  async _getERC20Allowance(contractAddress, walletAddress, chainId) {
    const contract = new _ethers.ethers.Contract(contractAddress, _humanStandardTokenAbi.default, this.ethersProvider);
    return await contract.allowance(walletAddress, _swaps.SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[chainId]);
  }

}
/**
 * Calculates the median overallValueOfQuote of a sample of quotes.
 *
 * @param {Array} quotes - A sample of quote objects with overallValueOfQuote, ethFee, metaMaskFeeInEth, and ethValueOfTokens properties
 * @returns {Object} An object with the ethValueOfTokens, ethFee, and metaMaskFeeInEth of the quote with the median overallValueOfQuote
 */


exports.default = SwapsController;

function getMedianEthValueQuote(_quotes) {
  if (!Array.isArray(_quotes) || _quotes.length === 0) {
    throw new Error('Expected non-empty array param.');
  }

  const quotes = [..._quotes];
  quotes.sort((quoteA, quoteB) => {
    const overallValueOfQuoteA = new _bignumber.default(quoteA.overallValueOfQuote, 10);
    const overallValueOfQuoteB = new _bignumber.default(quoteB.overallValueOfQuote, 10);

    if (overallValueOfQuoteA.equals(overallValueOfQuoteB)) {
      return 0;
    }

    return overallValueOfQuoteA.lessThan(overallValueOfQuoteB) ? -1 : 1;
  });

  if (quotes.length % 2 === 1) {
    // return middle values
    const medianOverallValue = quotes[(quotes.length - 1) / 2].overallValueOfQuote;
    const quotesMatchingMedianQuoteValue = quotes.filter(quote => medianOverallValue === quote.overallValueOfQuote);
    return meansOfQuotesFeesAndValue(quotesMatchingMedianQuoteValue);
  } // return mean of middle two values


  const upperIndex = quotes.length / 2;
  const lowerIndex = upperIndex - 1;
  const overallValueAtUpperIndex = quotes[upperIndex].overallValueOfQuote;
  const overallValueAtLowerIndex = quotes[lowerIndex].overallValueOfQuote;
  const quotesMatchingUpperIndexValue = quotes.filter(quote => overallValueAtUpperIndex === quote.overallValueOfQuote);
  const quotesMatchingLowerIndexValue = quotes.filter(quote => overallValueAtLowerIndex === quote.overallValueOfQuote);
  const feesAndValueAtUpperIndex = meansOfQuotesFeesAndValue(quotesMatchingUpperIndexValue);
  const feesAndValueAtLowerIndex = meansOfQuotesFeesAndValue(quotesMatchingLowerIndexValue);
  return {
    ethFee: new _bignumber.default(feesAndValueAtUpperIndex.ethFee, 10).plus(feesAndValueAtLowerIndex.ethFee, 10).dividedBy(2).toString(10),
    metaMaskFeeInEth: new _bignumber.default(feesAndValueAtUpperIndex.metaMaskFeeInEth, 10).plus(feesAndValueAtLowerIndex.metaMaskFeeInEth, 10).dividedBy(2).toString(10),
    ethValueOfTokens: new _bignumber.default(feesAndValueAtUpperIndex.ethValueOfTokens, 10).plus(feesAndValueAtLowerIndex.ethValueOfTokens, 10).dividedBy(2).toString(10)
  };
}
/**
 * Calculates the arithmetic mean for each of three properties - ethFee, metaMaskFeeInEth and ethValueOfTokens - across
 * an array of objects containing those properties.
 *
 * @param {Array} quotes - A sample of quote objects with overallValueOfQuote, ethFee, metaMaskFeeInEth and
 * ethValueOfTokens properties
 * @returns {Object} An object with the arithmetic mean each of the ethFee, metaMaskFeeInEth and ethValueOfTokens of
 * the passed quote objects
 */


function meansOfQuotesFeesAndValue(quotes) {
  const feeAndValueSumsAsBigNumbers = quotes.reduce((feeAndValueSums, quote) => ({
    ethFee: feeAndValueSums.ethFee.plus(quote.ethFee, 10),
    metaMaskFeeInEth: feeAndValueSums.metaMaskFeeInEth.plus(quote.metaMaskFeeInEth, 10),
    ethValueOfTokens: feeAndValueSums.ethValueOfTokens.plus(quote.ethValueOfTokens, 10)
  }), {
    ethFee: new _bignumber.default(0, 10),
    metaMaskFeeInEth: new _bignumber.default(0, 10),
    ethValueOfTokens: new _bignumber.default(0, 10)
  });
  return {
    ethFee: feeAndValueSumsAsBigNumbers.ethFee.div(quotes.length, 10).toString(10),
    metaMaskFeeInEth: feeAndValueSumsAsBigNumbers.metaMaskFeeInEth.div(quotes.length, 10).toString(10),
    ethValueOfTokens: feeAndValueSumsAsBigNumbers.ethValueOfTokens.div(quotes.length, 10).toString(10)
  };
}

const utils = {
  getMedianEthValueQuote,
  meansOfQuotesFeesAndValue
};
exports.utils = utils;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/swaps.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/account-tracker.js", {"../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","../constants/contracts":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/constants/contracts.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/util.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","eth-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-query/index.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js","pify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pify/index.js","single-call-balance-checker-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/single-call-balance-checker-abi/index.js","web3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/web3/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/account-tracker.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethQuery = _interopRequireDefault(require("eth-query"));

var _obsStore = require("@metamask/obs-store");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _pify = _interopRequireDefault(require("pify"));

var _web = _interopRequireDefault(require("web3"));

var _singleCallBalanceCheckerAbi = _interopRequireDefault(require("single-call-balance-checker-abi"));

var _network = require("../../../shared/constants/network");

var _contracts = require("../constants/contracts");

var _util = require("./util");

/* Account Tracker
 *
 * This module is responsible for tracking any number of accounts
 * and caching their current balances & transaction counts.
 *
 * It also tracks transaction hashes, and checks their inclusion status
 * on each new block.
 */

/**
 * This module is responsible for tracking any number of accounts and caching their current balances & transaction
 * counts.
 *
 * It also tracks transaction hashes, and checks their inclusion status on each new block.
 *
 * @typedef {Object} AccountTracker
 * @property {Object} store The stored object containing all accounts to track, as well as the current block's gas limit.
 * @property {Object} store.accounts The accounts currently stored in this AccountTracker
 * @property {string} store.currentBlockGasLimit A hex string indicating the gas limit of the current block
 * @property {Object} _provider A provider needed to create the EthQuery instance used within this AccountTracker.
 * @property {EthQuery} _query An EthQuery instance used to access account information from the blockchain
 * @property {BlockTracker} _blockTracker A BlockTracker instance. Needed to ensure that accounts and their info updates
 * when a new block is created.
 * @property {Object} _currentBlockNumber Reference to a property on the _blockTracker: the number (i.e. an id) of the the current block
 *
 */
class AccountTracker {
  /**
   * @param {Object} opts - Options for initializing the controller
   * @param {Object} opts.provider - An EIP-1193 provider instance that uses the current global network
   * @param {Object} opts.blockTracker - A block tracker, which emits events for each new block
   * @param {Function} opts.getCurrentChainId - A function that returns the `chainId` for the current global network
   */
  constructor(opts = {}) {
    const initState = {
      accounts: {},
      currentBlockGasLimit: ''
    };
    this.store = new _obsStore.ObservableStore(initState);
    this._provider = opts.provider;
    this._query = (0, _pify.default)(new _ethQuery.default(this._provider));
    this._blockTracker = opts.blockTracker; // blockTracker.currentBlock may be null

    this._currentBlockNumber = this._blockTracker.getCurrentBlock();

    this._blockTracker.once('latest', blockNumber => {
      this._currentBlockNumber = blockNumber;
    }); // bind function for easier listener syntax


    this._updateForBlock = this._updateForBlock.bind(this);
    this.getCurrentChainId = opts.getCurrentChainId;
    this.web3 = new _web.default(this._provider);
  }

  start() {
    // remove first to avoid double add
    this._blockTracker.removeListener('latest', this._updateForBlock); // add listener


    this._blockTracker.addListener('latest', this._updateForBlock); // fetch account balances


    this._updateAccounts();
  }

  stop() {
    // remove listener
    this._blockTracker.removeListener('latest', this._updateForBlock);
  }
  /**
   * Ensures that the locally stored accounts are in sync with a set of accounts stored externally to this
   * AccountTracker.
   *
   * Once this AccountTracker's accounts are up to date with those referenced by the passed addresses, each
   * of these accounts are given an updated balance via EthQuery.
   *
   * @param {Array} address - The array of hex addresses for accounts with which this AccountTracker's accounts should be
   * in sync
   *
   */


  syncWithAddresses(addresses) {
    const {
      accounts
    } = this.store.getState();
    const locals = Object.keys(accounts);
    const accountsToAdd = [];
    addresses.forEach(upstream => {
      if (!locals.includes(upstream)) {
        accountsToAdd.push(upstream);
      }
    });
    const accountsToRemove = [];
    locals.forEach(local => {
      if (!addresses.includes(local)) {
        accountsToRemove.push(local);
      }
    });
    this.addAccounts(accountsToAdd);
    this.removeAccount(accountsToRemove);
  }
  /**
   * Adds new addresses to track the balances of
   * given a balance as long this._currentBlockNumber is defined.
   *
   * @param {Array} addresses - An array of hex addresses of new accounts to track
   *
   */


  addAccounts(addresses) {
    const {
      accounts
    } = this.store.getState(); // add initial state for addresses

    addresses.forEach(address => {
      accounts[address] = {};
    }); // save accounts state

    this.store.updateState({
      accounts
    }); // fetch balances for the accounts if there is block number ready

    if (!this._currentBlockNumber) {
      return;
    }

    this._updateAccounts();
  }
  /**
   * Removes accounts from being tracked
   *
   * @param {Array} an - array of hex addresses to stop tracking
   *
   */


  removeAccount(addresses) {
    const {
      accounts
    } = this.store.getState(); // remove each state object

    addresses.forEach(address => {
      delete accounts[address];
    }); // save accounts state

    this.store.updateState({
      accounts
    });
  }
  /**
   * Removes all addresses and associated balances
   */


  clearAccounts() {
    this.store.updateState({
      accounts: {}
    });
  }
  /**
   * Given a block, updates this AccountTracker's currentBlockGasLimit, and then updates each local account's balance
   * via EthQuery
   *
   * @private
   * @param {number} blockNumber - the block number to update to.
   * @fires 'block' The updated state, if all account updates are successful
   *
   */


  async _updateForBlock(blockNumber) {
    this._currentBlockNumber = blockNumber; // block gasLimit polling shouldn't be in account-tracker shouldn't be here...

    const currentBlock = await this._query.getBlockByNumber(blockNumber, false);

    if (!currentBlock) {
      return;
    }

    const currentBlockGasLimit = currentBlock.gasLimit;
    this.store.updateState({
      currentBlockGasLimit
    });

    try {
      await this._updateAccounts();
    } catch (err) {
      _loglevel.default.error(err);
    }
  }
  /**
   * balanceChecker is deployed on main eth (test)nets and requires a single call
   * for all other networks, calls this._updateAccount for each account in this.store
   *
   * @returns {Promise} after all account balances updated
   *
   */


  async _updateAccounts() {
    const {
      accounts
    } = this.store.getState();
    const addresses = Object.keys(accounts);
    const chainId = this.getCurrentChainId();

    switch (chainId) {
      case _network.MAINNET_CHAIN_ID:
        await this._updateAccountsViaBalanceChecker(addresses, _contracts.SINGLE_CALL_BALANCES_ADDRESS);
        break;

      case _network.RINKEBY_CHAIN_ID:
        await this._updateAccountsViaBalanceChecker(addresses, _contracts.SINGLE_CALL_BALANCES_ADDRESS_RINKEBY);
        break;

      case _network.ROPSTEN_CHAIN_ID:
        await this._updateAccountsViaBalanceChecker(addresses, _contracts.SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN);
        break;

      case _network.KOVAN_CHAIN_ID:
        await this._updateAccountsViaBalanceChecker(addresses, _contracts.SINGLE_CALL_BALANCES_ADDRESS_KOVAN);
        break;

      default:
        await Promise.all(addresses.map(this._updateAccount.bind(this)));
    }
  }
  /**
   * Updates the current balance of an account.
   *
   * @private
   * @param {string} address - A hex address of a the account to be updated
   * @returns {Promise} after the account balance is updated
   *
   */


  async _updateAccount(address) {
    // query balance
    const balance = await this._query.getBalance(address);
    const result = {
      address,
      balance
    }; // update accounts state

    const {
      accounts
    } = this.store.getState(); // only populate if the entry is still present

    if (!accounts[address]) {
      return;
    }

    accounts[address] = result;
    this.store.updateState({
      accounts
    });
  }
  /**
   * Updates current address balances from balanceChecker deployed contract instance
   * @param {*} addresses
   * @param {*} deployedContractAddress
   */


  async _updateAccountsViaBalanceChecker(addresses, deployedContractAddress) {
    const {
      accounts
    } = this.store.getState();
    this.web3.setProvider(this._provider);
    const ethContract = this.web3.eth.contract(_singleCallBalanceCheckerAbi.default).at(deployedContractAddress);
    const ethBalance = ['0x0'];
    ethContract.balances(addresses, ethBalance, (error, result) => {
      if (error) {
        _loglevel.default.warn(`MetaMask - Account Tracker single call balance fetch failed`, error);

        Promise.all(addresses.map(this._updateAccount.bind(this)));
        return;
      }

      addresses.forEach((address, index) => {
        const balance = result[index] ? (0, _util.bnToHex)(result[index]) : '0x0';
        accounts[address] = {
          address,
          balance
        };
      });
      this.store.updateState({
        accounts
      });
    });
  }

}

exports.default = AccountTracker;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/account-tracker.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/index.js", {"./permissions":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/index.js","./resource":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/resource/index.js","./services":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/services/index.js","./snaps":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/snaps/index.js","./subject-metadata":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/subject-metadata/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./permissions"), exports);
__exportStar(require("./resource"), exports);
__exportStar(require("./services"), exports);
__exportStar(require("./snaps"), exports);
__exportStar(require("./subject-metadata"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/dist/index.js", {"./metamask-airgapped-keyring.cjs.development.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/dist/metamask-airgapped-keyring.cjs.development.js","./metamask-airgapped-keyring.cjs.production.min.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/dist/metamask-airgapped-keyring.cjs.production.min.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/dist/index.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./metamask-airgapped-keyring.cjs.production.min.js')
} else {
  module.exports = require('./metamask-airgapped-keyring.cjs.development.js')
}

      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/threebox.js", {"../../../development/mock-3box":"/home/clarisco/Desktop/metamask-extension-develop/development/mock-3box.js","../lib/createOriginMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/createOriginMiddleware.js","../lib/migrator":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/migrator/index.js","../migrations":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/index.js","./network/createMetamaskMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/createMetamaskMiddleware.js","3box":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/3box.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","eth-json-rpc-middleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/index.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/threebox.js
      return function (require, module, exports) {
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _obsStore = require("@metamask/obs-store");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _jsonRpcEngine = require("json-rpc-engine");

var _ethJsonRpcMiddleware = require("eth-json-rpc-middleware");

var _migrator = _interopRequireDefault(require("../lib/migrator"));

var _migrations = _interopRequireDefault(require("../migrations"));

var _createOriginMiddleware = _interopRequireDefault(require("../lib/createOriginMiddleware"));

var _createMetamaskMiddleware = _interopRequireDefault(require("./network/createMetamaskMiddleware"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* eslint-disable import/first,import/order */
const Box = process.env.IN_TEST ? require('../../../development/mock-3box') : require('3box');
/* eslint-enable import/order */

/* eslint-enable import/first */
const SYNC_TIMEOUT = 60 * 1000; // one minute

class ThreeBoxController {
  constructor(opts = {}) {
    const {
      preferencesController,
      keyringController,
      addressBookController,
      version,
      getKeyringControllerState,
      trackMetaMetricsEvent
    } = opts;
    this.preferencesController = preferencesController;
    this.addressBookController = addressBookController;
    this.keyringController = keyringController;
    this.provider = this._createProvider({
      version,
      getAccounts: async ({
        origin
      }) => {
        if (origin !== '3Box') {
          return [];
        }

        const {
          isUnlocked
        } = getKeyringControllerState();
        const accounts = await this.keyringController.getAccounts();

        if (isUnlocked && accounts[0]) {
          const appKeyAddress = await this.keyringController.getAppKeyAddress(accounts[0], 'wallet://3box.metamask.io');
          return [appKeyAddress];
        }

        return [];
      },
      processPersonalMessage: async msgParams => {
        const accounts = await this.keyringController.getAccounts();
        return keyringController.signPersonalMessage(_objectSpread(_objectSpread({}, msgParams), {}, {
          from: accounts[0]
        }), {
          withAppKeyOrigin: 'wallet://3box.metamask.io'
        });
      }
    });
    this._trackMetaMetricsEvent = trackMetaMetricsEvent;

    const initState = _objectSpread(_objectSpread({
      threeBoxSyncingAllowed: false,
      showRestorePrompt: true,
      threeBoxLastUpdated: 0
    }, opts.initState), {}, {
      threeBoxAddress: null,
      threeBoxSynced: false,
      threeBoxDisabled: false
    });

    this.store = new _obsStore.ObservableStore(initState);
    this.registeringUpdates = false;
    this.lastMigration = _migrations.default.sort((a, b) => a.version - b.version).slice(-1)[0];

    if (initState.threeBoxSyncingAllowed) {
      this.init();
    }
  }

  async init() {
    const accounts = await this.keyringController.getAccounts();
    this.address = accounts[0];

    this._trackMetaMetricsEvent({
      event: '3Box Initiated',
      category: '3Box'
    });

    if (this.address && !(this.box && this.store.getState().threeBoxSynced)) {
      await this.new3Box();
    }
  }

  async _update3Box() {
    try {
      const {
        threeBoxSyncingAllowed,
        threeBoxSynced
      } = this.store.getState();

      if (threeBoxSyncingAllowed && threeBoxSynced) {
        const newState = {
          preferences: this.preferencesController.store.getState(),
          addressBook: this.addressBookController.state,
          lastUpdated: Date.now(),
          lastMigration: this.lastMigration
        };
        await this.space.private.set('metamaskBackup', JSON.stringify(newState));
        await this.setShowRestorePromptToFalse();
      }
    } catch (error) {
      console.error(error);
    }
  }

  _createProvider(providerOpts) {
    const metamaskMiddleware = (0, _createMetamaskMiddleware.default)(providerOpts);
    const engine = new _jsonRpcEngine.JsonRpcEngine();
    engine.push((0, _createOriginMiddleware.default)({
      origin: '3Box'
    }));
    engine.push(metamaskMiddleware);
    const provider = (0, _ethJsonRpcMiddleware.providerFromEngine)(engine);
    return provider;
  }

  _waitForOnSyncDone() {
    return new Promise(resolve => {
      this.box.onSyncDone(() => {
        _loglevel.default.debug('3Box box sync done');

        return resolve();
      });
    });
  }

  async new3Box() {
    const accounts = await this.keyringController.getAccounts();
    this.address = await this.keyringController.getAppKeyAddress(accounts[0], 'wallet://3box.metamask.io');
    let backupExists;

    try {
      const threeBoxConfig = await Box.getConfig(this.address);
      backupExists = threeBoxConfig.spaces && threeBoxConfig.spaces.metamask;
    } catch (e) {
      if (e.message.match(/^Error: Invalid response \(404\)/u)) {
        this._trackMetaMetricsEvent({
          event: '3Box Backup does not exist',
          category: '3Box'
        });

        backupExists = false;
      } else {
        this._trackMetaMetricsEvent({
          event: '3Box Config Error',
          category: '3Box'
        });

        throw e;
      }
    }

    if (this.getThreeBoxSyncingState() || backupExists) {
      this.store.updateState({
        threeBoxSynced: false
      });
      let timedOut = false;
      const syncTimeout = setTimeout(() => {
        _loglevel.default.error(`3Box sync timed out after ${SYNC_TIMEOUT} ms`);

        timedOut = true;
        this.store.updateState({
          threeBoxDisabled: true,
          threeBoxSyncingAllowed: false
        });
      }, SYNC_TIMEOUT);

      try {
        this.box = await Box.openBox(this.address, this.provider);
        await this._waitForOnSyncDone();
        this.space = await this.box.openSpace('metamask', {
          onSyncDone: async () => {
            const stateUpdate = {
              threeBoxSynced: true,
              threeBoxAddress: this.address
            };

            if (timedOut) {
              _loglevel.default.info(`3Box sync completed after timeout; no longer disabled`);

              stateUpdate.threeBoxDisabled = false;
            }

            clearTimeout(syncTimeout);
            this.store.updateState(stateUpdate);

            _loglevel.default.debug('3Box space sync done');

            this._trackMetaMetricsEvent({
              event: '3Box Synced',
              category: '3Box'
            });
          }
        });
      } catch (e) {
        this._trackMetaMetricsEvent({
          event: '3Box Initiation Error',
          category: '3Box'
        });

        console.error(e);
        throw e;
      }
    }
  }

  async getLastUpdated() {
    const res = await this.space.private.get('metamaskBackup');
    const parsedRes = JSON.parse(res || '{}');
    return parsedRes.lastUpdated;
  }

  async migrateBackedUpState(backedUpState) {
    const migrator = new _migrator.default({
      migrations: _migrations.default
    });
    const {
      preferences,
      addressBook
    } = JSON.parse(backedUpState);
    const formattedStateBackup = {
      PreferencesController: preferences,
      AddressBookController: addressBook
    };
    const initialMigrationState = migrator.generateInitialState(formattedStateBackup);
    const migratedState = await migrator.migrateData(initialMigrationState);
    return {
      preferences: migratedState.data.PreferencesController,
      addressBook: migratedState.data.AddressBookController
    };
  }

  async restoreFromThreeBox() {
    const backedUpState = await this.space.private.get('metamaskBackup');
    const {
      preferences,
      addressBook
    } = await this.migrateBackedUpState(backedUpState);
    this.store.updateState({
      threeBoxLastUpdated: backedUpState.lastUpdated
    });
    preferences && this.preferencesController.store.updateState(preferences);
    addressBook && this.addressBookController.update(addressBook, true);
    this.setShowRestorePromptToFalse();

    this._trackMetaMetricsEvent({
      event: '3Box Restored Data',
      category: '3Box'
    });
  }

  turnThreeBoxSyncingOn() {
    this._trackMetaMetricsEvent({
      event: '3Box Sync Turned On',
      category: '3Box'
    });

    this._registerUpdates();
  }

  turnThreeBoxSyncingOff() {
    this._trackMetaMetricsEvent({
      event: '3Box Sync Turned Off',
      category: '3Box'
    });

    this.box.logout();
  }

  setShowRestorePromptToFalse() {
    this.store.updateState({
      showRestorePrompt: false
    });
  }

  setThreeBoxSyncingPermission(newThreeboxSyncingState) {
    if (this.store.getState().threeBoxDisabled) {
      return;
    }

    this.store.updateState({
      threeBoxSyncingAllowed: newThreeboxSyncingState
    });

    if (newThreeboxSyncingState && this.box) {
      this.turnThreeBoxSyncingOn();
    }

    if (!newThreeboxSyncingState && this.box) {
      this.turnThreeBoxSyncingOff();
    }
  }

  getThreeBoxSyncingState() {
    return this.store.getState().threeBoxSyncingAllowed;
  }

  _registerUpdates() {
    if (!this.registeringUpdates) {
      const updatePreferences = this._update3Box.bind(this);

      this.preferencesController.store.subscribe(updatePreferences);

      const updateAddressBook = this._update3Box.bind(this);

      this.addressBookController.subscribe(updateAddressBook);
      this.registeringUpdates = true;
    }
  }

}

exports.default = ThreeBoxController;

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/threebox.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/index.js", {"./createMethodMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/createMethodMiddleware.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _createMethodMiddleware.default;
  }
});

var _createMethodMiddleware = _interopRequireDefault(require("./createMethodMiddleware"));

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/safe-event-emitter/index.js", {"events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/safe-event-emitter/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
function safeApply(handler, context, args) {
    try {
        Reflect.apply(handler, context, args);
    }
    catch (err) {
        // Throw error after timeout so as not to interrupt the stack
        setTimeout(() => {
            throw err;
        });
    }
}
function arrayClone(arr) {
    const n = arr.length;
    const copy = new Array(n);
    for (let i = 0; i < n; i += 1) {
        copy[i] = arr[i];
    }
    return copy;
}
class SafeEventEmitter extends events_1.EventEmitter {
    emit(type, ...args) {
        let doError = type === 'error';
        const events = this._events;
        if (events !== undefined) {
            doError = doError && events.error === undefined;
        }
        else if (!doError) {
            return false;
        }
        // If there is no 'error' event listener then throw.
        if (doError) {
            let er;
            if (args.length > 0) {
                [er] = args;
            }
            if (er instanceof Error) {
                // Note: The comments on the `throw` lines are intentional, they show
                // up in Node's output if this results in an unhandled exception.
                throw er; // Unhandled 'error' event
            }
            // At least give some kind of context to the user
            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);
            err.context = er;
            throw err; // Unhandled 'error' event
        }
        const handler = events[type];
        if (handler === undefined) {
            return false;
        }
        if (typeof handler === 'function') {
            safeApply(handler, this, args);
        }
        else {
            const len = handler.length;
            const listeners = arrayClone(handler);
            for (let i = 0; i < len; i += 1) {
                safeApply(listeners[i], this, args);
            }
        }
        return true;
    }
}
exports.default = SafeEventEmitter;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/safe-event-emitter",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/safe-event-emitter/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/node_modules/through2/through2.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/readable-stream/readable-browser.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/util/util.js","xtend":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xtend/immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/node_modules/through2/through2.js
      return function (require, module, exports) {
(function (process){(function (){
var Transform = require('readable-stream').Transform
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"through2",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/node_modules/through2/through2.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/fail-tx.js", {"../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/fail-tx.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = failTxsThat;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

function failTxsThat(version, reason, condition) {
  return function (originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state, condition, reason);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  };
}

function transformState(state, condition, reason) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!condition(txMeta)) {
        return txMeta;
      }

      txMeta.status = _transaction.TRANSACTION_STATUSES.FAILED;
      txMeta.err = {
        message: reason,
        note: `Tx automatically failed by migration because ${reason}`
      };
      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/migrations/fail-tx.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/lib/tx-state-history-helpers.js", {"@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","fast-json-patch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/lib/duplex.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/lib/tx-state-history-helpers.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateHistoryEntry = generateHistoryEntry;
exports.migrateFromSnapshotsToDiffs = migrateFromSnapshotsToDiffs;
exports.replayHistory = replayHistory;
exports.snapshotFromTxMeta = snapshotFromTxMeta;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _fastJsonPatch = _interopRequireDefault(require("fast-json-patch"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
  converts non-initial history entries into diffs
  @param {Array} longHistory
  @returns {Array}
*/
function migrateFromSnapshotsToDiffs(longHistory) {
  return longHistory // convert non-initial history entries into diffs
  .map((entry, index) => {
    if (index === 0) {
      return entry;
    }

    return generateHistoryEntry(longHistory[index - 1], entry);
  });
}
/**
  Generates an array of history objects sense the previous state.
  The object has the keys
    op (the operation performed),
    path (the key and if a nested object then each key will be separated with a `/`)
    value
  with the first entry having the note and a timestamp when the change took place
  @param {Object} previousState - the previous state of the object
  @param {Object} newState - the update object
  @param {string} [note] - a optional note for the state change
  @returns {Array}
*/


function generateHistoryEntry(previousState, newState, note) {
  const entry = _fastJsonPatch.default.compare(previousState, newState); // Add a note to the first op, since it breaks if we append it to the entry


  if (entry[0]) {
    if (note) {
      entry[0].note = note;
    }

    entry[0].timestamp = Date.now();
  }

  return entry;
}
/**
  Recovers previous txMeta state obj
  @returns {Object}
*/


function replayHistory(_shortHistory) {
  const shortHistory = (0, _lodash.cloneDeep)(_shortHistory);
  return shortHistory.reduce((val, entry) => _fastJsonPatch.default.applyPatch(val, entry).newDocument);
}
/**
 * Snapshot {@code txMeta}
 * @param {Object} txMeta - the tx metadata object
 * @returns {Object} a deep clone without history
 */


function snapshotFromTxMeta(txMeta) {
  const shallow = _objectSpread({}, txMeta);

  delete shallow.history;
  return (0, _lodash.cloneDeep)(shallow);
}


      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/lib/tx-state-history-helpers.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/to-data-view/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/to-data-view/index.js
      return function (require, module, exports) {
module.exports = function toDataView (data) {
  if (data instanceof Int8Array || data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
    return new DataView(data.buffer, data.byteOffset, data.byteLength)
  }

  if (data instanceof ArrayBuffer) {
    return new DataView(data)
  }

  throw new TypeError('Expected `data` to be an ArrayBuffer, Buffer, Int8Array, Uint8Array or Uint8ClampedArray')
}

      };
    };
  }
}, {package:"to-data-view",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/to-data-view/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/contracts/registry.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/contracts/registry.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const abi = [{
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'resolver',
  outputs: [{
    name: '',
    type: 'address'
  }],
  payable: false,
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'owner',
  outputs: [{
    name: '',
    type: 'address'
  }],
  payable: false,
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'label',
    type: 'bytes32'
  }, {
    name: 'owner',
    type: 'address'
  }],
  name: 'setSubnodeOwner',
  outputs: [],
  payable: false,
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'ttl',
    type: 'uint64'
  }],
  name: 'setTTL',
  outputs: [],
  payable: false,
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'ttl',
  outputs: [{
    name: '',
    type: 'uint64'
  }],
  payable: false,
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'resolver',
    type: 'address'
  }],
  name: 'setResolver',
  outputs: [],
  payable: false,
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'owner',
    type: 'address'
  }],
  name: 'setOwner',
  outputs: [],
  payable: false,
  type: 'function'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'owner',
    type: 'address'
  }],
  name: 'Transfer',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: true,
    name: 'label',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'owner',
    type: 'address'
  }],
  name: 'NewOwner',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'resolver',
    type: 'address'
  }],
  name: 'NewResolver',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'ttl',
    type: 'uint64'
  }],
  name: 'NewTTL',
  type: 'event'
}];
var _default = abi;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/contracts/registry.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/contracts/resolver.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/contracts/resolver.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const abi = [{
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'hash',
    type: 'bytes32'
  }],
  name: 'setContent',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'content',
  outputs: [{
    name: '',
    type: 'bytes32'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'interfaceID',
    type: 'bytes4'
  }],
  name: 'supportsInterface',
  outputs: [{
    name: '',
    type: 'bool'
  }],
  payable: false,
  stateMutability: 'pure',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'key',
    type: 'string'
  }, {
    name: 'value',
    type: 'string'
  }],
  name: 'setText',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'contentTypes',
    type: 'uint256'
  }],
  name: 'ABI',
  outputs: [{
    name: 'contentType',
    type: 'uint256'
  }, {
    name: 'data',
    type: 'bytes'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'x',
    type: 'bytes32'
  }, {
    name: 'y',
    type: 'bytes32'
  }],
  name: 'setPubkey',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'hash',
    type: 'bytes'
  }],
  name: 'setContenthash',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'addr',
  outputs: [{
    name: '',
    type: 'address'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'key',
    type: 'string'
  }],
  name: 'text',
  outputs: [{
    name: '',
    type: 'string'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'contentType',
    type: 'uint256'
  }, {
    name: 'data',
    type: 'bytes'
  }],
  name: 'setABI',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'name',
  outputs: [{
    name: '',
    type: 'string'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'name',
    type: 'string'
  }],
  name: 'setName',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'contenthash',
  outputs: [{
    name: '',
    type: 'bytes'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'pubkey',
  outputs: [{
    name: 'x',
    type: 'bytes32'
  }, {
    name: 'y',
    type: 'bytes32'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'addr',
    type: 'address'
  }],
  name: 'setAddr',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  inputs: [{
    name: 'ensAddr',
    type: 'address'
  }],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'constructor'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'a',
    type: 'address'
  }],
  name: 'AddrChanged',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'name',
    type: 'string'
  }],
  name: 'NameChanged',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: true,
    name: 'contentType',
    type: 'uint256'
  }],
  name: 'ABIChanged',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'x',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'y',
    type: 'bytes32'
  }],
  name: 'PubkeyChanged',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'indexedKey',
    type: 'string'
  }, {
    indexed: false,
    name: 'key',
    type: 'string'
  }],
  name: 'TextChanged',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'hash',
    type: 'bytes'
  }],
  name: 'ContenthashChanged',
  type: 'event'
}];
var _default = abi;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/ens-ipfs/contracts/resolver.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/src/index.js", {"./helpers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/src/helpers.js","./profiles":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/src/profiles.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/src/index.js
      return function (require, module, exports) {
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const multiC = require('multicodec');
const multiH = require('multihashes');

const { hexStringToBuffer, profiles } = require('./profiles');
const { cidForWeb, cidV0ToV1Base32 } = require('./helpers');

module.exports = {

	//export some helpers functions
	helpers: {
		cidForWeb,
		cidV0ToV1Base32,
	},

	/**
	* Decode a Content Hash.
	* @param {string} hash an hex string containing a content hash
	* @return {string} the decoded content
	*/
	decode: function (contentHash) {
		const buffer = hexStringToBuffer(contentHash);
		const codec = multiC.getCodec(buffer);
		const value = multiC.rmPrefix(buffer);
		let profile = profiles[codec];
		if (!profile) profile = profiles['default'];
		return profile.decode(value);
	},

	/**
	* Encode an IPFS address into a content hash
	* @param {string} ipfsHash string containing an IPFS address
	* @return {string} the resulting content hash
	*/
	fromIpfs: function (ipfsHash) {
		return this.encode('ipfs-ns', ipfsHash);
	},

	/**
	* Encode a Skylink into a content hash
	* @param {string} skylink string containing a Skylink
	* @return {string} the resulting content hash
	*/
	fromSkylink: function (skylink) {
		return this.encode('skynet-ns', skylink);
	},

	/**
	* Encode a Swarm address into a content hash
	* @param {string} swarmHash string containing a Swarm address
	* @return {string} the resulting content hash
	*/
	fromSwarm: function (swarmHash) {
		return this.encode('swarm-ns', swarmHash);
	},

	/**
	* General purpose encoding function
  * @param {string} codec 
  * @param {string} value 
  */
	encode: function (codec, value) {
		let profile = profiles[codec];
		if (!profile) profile = profiles['default'];
		const encodedValue = profile.encode(value);
		return multiH.toHexString(multiC.addPrefix(codec, encodedValue))
	},

	/**
	* Extract the codec of a content hash
	* @param {string} hash hex string containing a content hash
	* @return {string} the extracted codec
	*/
	getCodec: function (hash) {
		let buffer = hexStringToBuffer(hash);
		return multiC.getCodec(buffer);
	},
}

      };
    };
  }
}, {package:"@ensdomains/content-hash",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/constants/contracts.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/constants/contracts.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN = exports.SINGLE_CALL_BALANCES_ADDRESS_RINKEBY = exports.SINGLE_CALL_BALANCES_ADDRESS_KOVAN = exports.SINGLE_CALL_BALANCES_ADDRESS = void 0;
const SINGLE_CALL_BALANCES_ADDRESS = '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39';
exports.SINGLE_CALL_BALANCES_ADDRESS = SINGLE_CALL_BALANCES_ADDRESS;
const SINGLE_CALL_BALANCES_ADDRESS_RINKEBY = '0x9f510b19f1ad66f0dcf6e45559fab0d6752c1db7';
exports.SINGLE_CALL_BALANCES_ADDRESS_RINKEBY = SINGLE_CALL_BALANCES_ADDRESS_RINKEBY;
const SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN = '0xb8e671734ce5c8d7dfbbea5574fa4cf39f7a54a4';
exports.SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN = SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN;
const SINGLE_CALL_BALANCES_ADDRESS_KOVAN = '0xb1d3fbb2f83aecd196f474c16ca5d9cffa0d0ffc';
exports.SINGLE_CALL_BALANCES_ADDRESS_KOVAN = SINGLE_CALL_BALANCES_ADDRESS_KOVAN;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/constants/contracts.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/createAsyncMiddleware.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/createAsyncMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAsyncMiddleware = void 0;
/**
 * JsonRpcEngine only accepts callback-based middleware directly.
 * createAsyncMiddleware exists to enable consumers to pass in async middleware
 * functions.
 *
 * Async middleware have no "end" function. Instead, they "end" if they return
 * without calling "next". Rather than passing in explicit return handlers,
 * async middleware can simply await "next", and perform operations on the
 * response object when execution resumes.
 *
 * To accomplish this, createAsyncMiddleware passes the async middleware a
 * wrapped "next" function. That function calls the internal JsonRpcEngine
 * "next" function with a return handler that resolves a promise when called.
 *
 * The return handler will always be called. Its resolution of the promise
 * enables the control flow described above.
 */
function createAsyncMiddleware(asyncMiddleware) {
    return async (req, res, next, end) => {
        // nextPromise is the key to the implementation
        // it is resolved by the return handler passed to the
        // "next" function
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
            resolveNextPromise = resolve;
        });
        let returnHandlerCallback = null;
        let nextWasCalled = false;
        // This will be called by the consumer's async middleware.
        const asyncNext = async () => {
            nextWasCalled = true;
            // We pass a return handler to next(). When it is called by the engine,
            // the consumer's async middleware will resume executing.
            // eslint-disable-next-line node/callback-return
            next((runReturnHandlersCallback) => {
                // This callback comes from JsonRpcEngine._runReturnHandlers
                returnHandlerCallback = runReturnHandlersCallback;
                resolveNextPromise();
            });
            await nextPromise;
        };
        try {
            await asyncMiddleware(req, res, asyncNext);
            if (nextWasCalled) {
                await nextPromise; // we must wait until the return handler is called
                returnHandlerCallback(null);
            }
            else {
                end(null);
            }
        }
        catch (error) {
            if (returnHandlerCallback) {
                returnHandlerCallback(error);
            }
            else {
                end(error);
            }
        }
    };
}
exports.createAsyncMiddleware = createAsyncMiddleware;

      };
    };
  }
}, {package:"json-rpc-engine",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/createAsyncMiddleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createScaffoldMiddleware = void 0;
function createScaffoldMiddleware(handlers) {
    return (req, res, next, end) => {
        const handler = handlers[req.method];
        // if no handler, return
        if (handler === undefined) {
            return next();
        }
        // if handler is fn, call as middleware
        if (typeof handler === 'function') {
            return handler(req, res, next, end);
        }
        // if handler is some other value, use as result
        res.result = handler;
        return end();
    };
}
exports.createScaffoldMiddleware = createScaffoldMiddleware;

      };
    };
  }
}, {package:"json-rpc-engine",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/getUniqueId.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/getUniqueId.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUniqueId = void 0;
// uint32 (two's complement) max
// more conservative than Number.MAX_SAFE_INTEGER
const MAX = 4294967295;
let idCounter = Math.floor(Math.random() * MAX);
function getUniqueId() {
    idCounter = (idCounter + 1) % MAX;
    return idCounter;
}
exports.getUniqueId = getUniqueId;

      };
    };
  }
}, {package:"json-rpc-engine",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/getUniqueId.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/idRemapMiddleware.js", {"./getUniqueId":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/getUniqueId.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/idRemapMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIdRemapMiddleware = void 0;
const getUniqueId_1 = require("./getUniqueId");
function createIdRemapMiddleware() {
    return (req, res, next, _end) => {
        const originalId = req.id;
        const newId = getUniqueId_1.getUniqueId();
        req.id = newId;
        res.id = newId;
        next((done) => {
            req.id = originalId;
            res.id = originalId;
            done();
        });
    };
}
exports.createIdRemapMiddleware = createIdRemapMiddleware;

      };
    };
  }
}, {package:"json-rpc-engine",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/idRemapMiddleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/mergeMiddleware.js", {"./JsonRpcEngine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/JsonRpcEngine.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/mergeMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeMiddleware = void 0;
const JsonRpcEngine_1 = require("./JsonRpcEngine");
function mergeMiddleware(middlewareStack) {
    const engine = new JsonRpcEngine_1.JsonRpcEngine();
    middlewareStack.forEach((middleware) => engine.push(middleware));
    return engine.asMiddleware();
}
exports.mergeMiddleware = mergeMiddleware;

      };
    };
  }
}, {package:"json-rpc-engine",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/mergeMiddleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/JsonRpcEngine.js", {"@metamask/safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/safe-event-emitter/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/JsonRpcEngine.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonRpcEngine = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
/**
 * A JSON-RPC request and response processor.
 * Give it a stack of middleware, pass it requests, and get back responses.
 */
class JsonRpcEngine extends safe_event_emitter_1.default {
    constructor() {
        super();
        this._middleware = [];
    }
    /**
     * Add a middleware function to the engine's middleware stack.
     *
     * @param middleware - The middleware function to add.
     */
    push(middleware) {
        this._middleware.push(middleware);
    }
    handle(req, cb) {
        if (cb && typeof cb !== 'function') {
            throw new Error('"callback" must be a function if provided.');
        }
        if (Array.isArray(req)) {
            if (cb) {
                return this._handleBatch(req, cb);
            }
            return this._handleBatch(req);
        }
        if (cb) {
            return this._handle(req, cb);
        }
        return this._promiseHandle(req);
    }
    /**
     * Returns this engine as a middleware function that can be pushed to other
     * engines.
     *
     * @returns This engine as a middleware function.
     */
    asMiddleware() {
        return async (req, res, next, end) => {
            try {
                const [middlewareError, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
                if (isComplete) {
                    await JsonRpcEngine._runReturnHandlers(returnHandlers);
                    return end(middlewareError);
                }
                return next(async (handlerCallback) => {
                    try {
                        await JsonRpcEngine._runReturnHandlers(returnHandlers);
                    }
                    catch (error) {
                        return handlerCallback(error);
                    }
                    return handlerCallback();
                });
            }
            catch (error) {
                return end(error);
            }
        };
    }
    async _handleBatch(reqs, cb) {
        // The order here is important
        try {
            // 2. Wait for all requests to finish, or throw on some kind of fatal
            // error
            const responses = await Promise.all(
            // 1. Begin executing each request in the order received
            reqs.map(this._promiseHandle.bind(this)));
            // 3. Return batch response
            if (cb) {
                return cb(null, responses);
            }
            return responses;
        }
        catch (error) {
            if (cb) {
                return cb(error);
            }
            throw error;
        }
    }
    /**
     * A promise-wrapped _handle.
     */
    _promiseHandle(req) {
        return new Promise((resolve) => {
            this._handle(req, (_err, res) => {
                // There will always be a response, and it will always have any error
                // that is caught and propagated.
                resolve(res);
            });
        });
    }
    /**
     * Ensures that the request object is valid, processes it, and passes any
     * error and the response object to the given callback.
     *
     * Does not reject.
     */
    async _handle(callerReq, cb) {
        if (!callerReq ||
            Array.isArray(callerReq) ||
            typeof callerReq !== 'object') {
            const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
            return cb(error, { id: undefined, jsonrpc: '2.0', error });
        }
        if (typeof callerReq.method !== 'string') {
            const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
            return cb(error, { id: callerReq.id, jsonrpc: '2.0', error });
        }
        const req = Object.assign({}, callerReq);
        const res = {
            id: req.id,
            jsonrpc: req.jsonrpc,
        };
        let error = null;
        try {
            await this._processRequest(req, res);
        }
        catch (_error) {
            // A request handler error, a re-thrown middleware error, or something
            // unexpected.
            error = _error;
        }
        if (error) {
            // Ensure no result is present on an errored response
            delete res.result;
            if (!res.error) {
                res.error = eth_rpc_errors_1.serializeError(error);
            }
        }
        return cb(error, res);
    }
    /**
     * For the given request and response, runs all middleware and their return
     * handlers, if any, and ensures that internal request processing semantics
     * are satisfied.
     */
    async _processRequest(req, res) {
        const [error, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
        // Throw if "end" was not called, or if the response has neither a result
        // nor an error.
        JsonRpcEngine._checkForCompletion(req, res, isComplete);
        // The return handlers should run even if an error was encountered during
        // middleware processing.
        await JsonRpcEngine._runReturnHandlers(returnHandlers);
        // Now we re-throw the middleware processing error, if any, to catch it
        // further up the call chain.
        if (error) {
            throw error;
        }
    }
    /**
     * Serially executes the given stack of middleware.
     *
     * @returns An array of any error encountered during middleware execution,
     * a boolean indicating whether the request was completed, and an array of
     * middleware-defined return handlers.
     */
    static async _runAllMiddleware(req, res, middlewareStack) {
        const returnHandlers = [];
        let error = null;
        let isComplete = false;
        // Go down stack of middleware, call and collect optional returnHandlers
        for (const middleware of middlewareStack) {
            [error, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
            if (isComplete) {
                break;
            }
        }
        return [error, isComplete, returnHandlers.reverse()];
    }
    /**
     * Runs an individual middleware.
     *
     * @returns An array of any error encountered during middleware exection,
     * and a boolean indicating whether the request should end.
     */
    static _runMiddleware(req, res, middleware, returnHandlers) {
        return new Promise((resolve) => {
            const end = (err) => {
                const error = err || res.error;
                if (error) {
                    res.error = eth_rpc_errors_1.serializeError(error);
                }
                // True indicates that the request should end
                resolve([error, true]);
            };
            const next = (returnHandler) => {
                if (res.error) {
                    end(res.error);
                }
                else {
                    if (returnHandler) {
                        if (typeof returnHandler !== 'function') {
                            end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. ` +
                                `Received "${typeof returnHandler}" for request:\n${jsonify(req)}`, { request: req }));
                        }
                        returnHandlers.push(returnHandler);
                    }
                    // False indicates that the request should not end
                    resolve([null, false]);
                }
            };
            try {
                middleware(req, res, next, end);
            }
            catch (error) {
                end(error);
            }
        });
    }
    /**
     * Serially executes array of return handlers. The request and response are
     * assumed to be in their scope.
     */
    static async _runReturnHandlers(handlers) {
        for (const handler of handlers) {
            await new Promise((resolve, reject) => {
                handler((err) => (err ? reject(err) : resolve()));
            });
        }
    }
    /**
     * Throws an error if the response has neither a result nor an error, or if
     * the "isComplete" flag is falsy.
     */
    static _checkForCompletion(req, res, isComplete) {
        if (!('result' in res) && !('error' in res)) {
            throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:\n${jsonify(req)}`, { request: req });
        }
        if (!isComplete) {
            throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:\n${jsonify(req)}`, { request: req });
        }
    }
}
exports.JsonRpcEngine = JsonRpcEngine;
function jsonify(request) {
    return JSON.stringify(request, null, 2);
}

      };
    };
  }
}, {package:"json-rpc-engine",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/JsonRpcEngine.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/ens/ens.js", {"@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","ethereum-ens-network-map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereum-ens-network-map/index.js","ethjs-ens":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-ens/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/ens/ens.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethjsEns = _interopRequireDefault(require("ethjs-ens"));

var _ethereumEnsNetworkMap = _interopRequireDefault(require("ethereum-ens-network-map"));

class Ens {
  static getNetworkEnsSupport(network) {
    return Boolean(_ethereumEnsNetworkMap.default[network]);
  }

  constructor({
    network,
    provider
  } = {}) {
    this._ethJsEns = new _ethjsEns.default({
      network,
      provider
    });
  }

  lookup(ensName) {
    return this._ethJsEns.lookup(ensName);
  }

  reverse(address) {
    return this._ethJsEns.reverse(address);
  }

}

exports.default = Ens;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/ens/ens.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/cleanErrorStack.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/cleanErrorStack.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cleanErrorStack;

/**
 * Returns error without stack trace for better UI display
 * @param {Error} err - error
 * @returns {Error} Error with clean stack trace.
 */
function cleanErrorStack(err) {
  let {
    name
  } = err;
  name = name === undefined ? 'Error' : String(name);
  let msg = err.message;
  msg = msg === undefined ? '' : String(msg);

  if (name === '') {
    err.stack = err.message;
  } else if (msg === '') {
    err.stack = err.name;
  } else if (!err.stack) {
    err.stack = `${err.name}: ${err.message}`;
  }

  return err;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/cleanErrorStack.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/nonce-tracker/index.js", {"assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","await-semaphore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/await-semaphore/index.js","ethjs-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-query/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/nonce-tracker/index.js
      return function (require, module, exports) {
const EthQuery = require('ethjs-query')
const assert = require('assert')
const Mutex = require('await-semaphore').Mutex
/**
  @param opts {Object}
    @param {Object} opts.provider a ethereum provider
    @param {Function} opts.getPendingTransactions a function that returns an array of txMeta
    whosee status is `submitted`
    @param {Function} opts.getConfirmedTransactions a function that returns an array of txMeta
    whose status is `confirmed`
  @class
*/
class NonceTracker {

  constructor ({ provider, blockTracker, getPendingTransactions, getConfirmedTransactions }) {
    this.provider = provider
    this.blockTracker = blockTracker
    this.ethQuery = new EthQuery(provider)
    this.getPendingTransactions = getPendingTransactions
    this.getConfirmedTransactions = getConfirmedTransactions
    this.lockMap = {}
  }

  /**
    @returns {Promise<Object>} with the key releaseLock (the gloabl mutex)
  */
  async getGlobalLock () {
    const globalMutex = this._lookupMutex('global')
    // await global mutex free
    const releaseLock = await globalMutex.acquire()
    return { releaseLock }
  }

  /**
   * @typedef NonceDetails
   * @property {number} highestLocallyConfirmed - A hex string of the highest nonce on a confirmed transaction.
   * @property {number} nextNetworkNonce - The next nonce suggested by the eth_getTransactionCount method.
   * @property {number} highestSuggested - The maximum between the other two, the number returned.
   */

  /**
  this will return an object with the `nextNonce` `nonceDetails`, and the releaseLock
  Note: releaseLock must be called after adding a signed tx to pending transactions (or discarding).

  @param address {string} the hex string for the address whose nonce we are calculating
  @returns {Promise<NonceDetails>}
  */
  async getNonceLock (address) {
    // await global mutex free
    await this._globalMutexFree()
    // await lock free, then take lock
    const releaseLock = await this._takeMutex(address)
    try {
      // evaluate multiple nextNonce strategies
      const nonceDetails = {}
      const networkNonceResult = await this._getNetworkNextNonce(address)
      const highestLocallyConfirmed = this._getHighestLocallyConfirmed(address)
      const nextNetworkNonce = networkNonceResult.nonce
      const highestSuggested = Math.max(nextNetworkNonce, highestLocallyConfirmed)

      const pendingTxs = this.getPendingTransactions(address)
      const localNonceResult = this._getHighestContinuousFrom(pendingTxs, highestSuggested) || 0

      nonceDetails.params = {
        highestLocallyConfirmed,
        highestSuggested,
        nextNetworkNonce,
      }
      nonceDetails.local = localNonceResult
      nonceDetails.network = networkNonceResult

      const nextNonce = Math.max(networkNonceResult.nonce, localNonceResult.nonce)
      assert(Number.isInteger(nextNonce), `nonce-tracker - nextNonce is not an integer - got: (${typeof nextNonce}) "${nextNonce}"`)

      // return nonce and release cb
      return { nextNonce, nonceDetails, releaseLock }
    } catch (err) {
      // release lock if we encounter an error
      releaseLock()
      throw err
    }
  }

  async _globalMutexFree () {
    const globalMutex = this._lookupMutex('global')
    const releaseLock = await globalMutex.acquire()
    releaseLock()
  }

  async _takeMutex (lockId) {
    const mutex = this._lookupMutex(lockId)
    const releaseLock = await mutex.acquire()
    return releaseLock
  }

  _lookupMutex (lockId) {
    let mutex = this.lockMap[lockId]
    if (!mutex) {
      mutex = new Mutex()
      this.lockMap[lockId] = mutex
    }
    return mutex
  }

  async _getNetworkNextNonce (address) {
    // calculate next nonce
    // we need to make sure our base count
    // and pending count are from the same block
    const blockNumber = await this.blockTracker.getLatestBlock()
    const baseCountBN = await this.ethQuery.getTransactionCount(address, blockNumber)
    const baseCount = baseCountBN.toNumber()
    assert(Number.isInteger(baseCount), `nonce-tracker - baseCount is not an integer - got: (${typeof baseCount}) "${baseCount}"`)
    const nonceDetails = { blockNumber, baseCount }
    return { name: 'network', nonce: baseCount, details: nonceDetails }
  }

  _getHighestLocallyConfirmed (address) {
    const confirmedTransactions = this.getConfirmedTransactions(address)
    const highest = this._getHighestNonce(confirmedTransactions)
    return Number.isInteger(highest) ? highest + 1 : 0
  }

  _getHighestNonce (txList) {
    const nonces = txList.map((txMeta) => {
      const nonce = txMeta.txParams.nonce
      assert(typeof nonce, 'string', 'nonces should be hex strings')
      return parseInt(nonce, 16)
    })
    const highestNonce = Math.max.apply(null, nonces)
    return highestNonce
  }

  /**
    @typedef {object} highestContinuousFrom
    @property {string} - name the name for how the nonce was calculated based on the data used
    @property {number} - nonce the next suggested nonce
    @property {object} - details the provided starting nonce that was used (for debugging)
  */
  /**
    @param txList {array} - list of txMeta's
    @param startPoint {number} - the highest known locally confirmed nonce
    @returns {highestContinuousFrom}
  */
  _getHighestContinuousFrom (txList, startPoint) {
    const nonces = txList.map((txMeta) => {
      const nonce = txMeta.txParams.nonce
      assert(typeof nonce, 'string', 'nonces should be hex strings')
      return parseInt(nonce, 16)
    })

    let highest = startPoint
    while (nonces.includes(highest)) {
      highest++
    }

    return { name: 'local', nonce: highest, details: { startPoint, highest } }
  }

}

module.exports = NonceTracker

      };
    };
  }
}, {package:"nonce-tracker",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/nonce-tracker/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/lib/util.js", {"../../../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","../../../../../shared/modules/hexstring-utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/hexstring-utils.js","../../../../../shared/modules/transaction.utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/transaction.utils.js","../../../lib/util":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/util.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/lib/util.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFinalStates = getFinalStates;
exports.normalizeAndValidateTxParams = normalizeAndValidateTxParams;
exports.normalizeTxParams = normalizeTxParams;
exports.validateFrom = validateFrom;
exports.validateRecipient = validateRecipient;
exports.validateTxParams = validateTxParams;

var _ethRpcErrors = require("eth-rpc-errors");

var _util = require("../../../lib/util");

var _transaction = require("../../../../../shared/constants/transaction");

var _transaction2 = require("../../../../../shared/modules/transaction.utils");

var _hexstringUtils = require("../../../../../shared/modules/hexstring-utils");

const normalizers = {
  from: _util.addHexPrefix,
  to: (to, lowerCase) => lowerCase ? (0, _util.addHexPrefix)(to).toLowerCase() : (0, _util.addHexPrefix)(to),
  nonce: _util.addHexPrefix,
  value: _util.addHexPrefix,
  data: _util.addHexPrefix,
  gas: _util.addHexPrefix,
  gasPrice: _util.addHexPrefix,
  maxFeePerGas: _util.addHexPrefix,
  maxPriorityFeePerGas: _util.addHexPrefix,
  type: _util.addHexPrefix,
  estimateSuggested: estimate => estimate,
  estimateUsed: estimate => estimate
};

function normalizeAndValidateTxParams(txParams, lowerCase = true) {
  const normalizedTxParams = normalizeTxParams(txParams, lowerCase);
  validateTxParams(normalizedTxParams);
  return normalizedTxParams;
}
/**
 * Normalizes the given txParams
 * @param {Object} txParams - The transaction params
 * @param {boolean} [lowerCase] - Whether to lowercase the 'to' address.
 * Default: true
 * @returns {Object} the normalized tx params
 */


function normalizeTxParams(txParams, lowerCase = true) {
  // apply only keys in the normalizers
  const normalizedTxParams = {};

  for (const key in normalizers) {
    if (txParams[key]) {
      normalizedTxParams[key] = normalizers[key](txParams[key], lowerCase);
    }
  }

  return normalizedTxParams;
}
/**
 * Given two fields, ensure that the second field is not included in txParams,
 * and if it is throw an invalidParams error.
 * @param {Object} txParams - the transaction parameters object
 * @param {string} fieldBeingValidated - the current field being validated
 * @param {string} mutuallyExclusiveField - the field to ensure is not provided
 * @throws {ethErrors.rpc.invalidParams} - throws if mutuallyExclusiveField is
 *  present in txParams.
 */


function ensureMutuallyExclusiveFieldsNotProvided(txParams, fieldBeingValidated, mutuallyExclusiveField) {
  if (typeof txParams[mutuallyExclusiveField] !== 'undefined') {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction params: specified ${fieldBeingValidated} but also included ${mutuallyExclusiveField}, these cannot be mixed`);
  }
}
/**
 * Ensures that the provided value for field is a string, throws an
 * invalidParams error if field is not a string.
 * @param {Object} txParams - the transaction parameters object
 * @param {string} field - the current field being validated
 * @throws {ethErrors.rpc.invalidParams} - throws if field is not a string
 */


function ensureFieldIsString(txParams, field) {
  if (typeof txParams[field] !== 'string') {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction params: ${field} is not a string. got: (${txParams[field]})`);
  }
}
/**
 * Ensures that the provided txParams has the proper 'type' specified for the
 * given field, if it is provided. If types do not match throws an
 * invalidParams error.
 * @param {Object} txParams - the transaction parameters object
 * @param {'gasPrice' | 'maxFeePerGas' | 'maxPriorityFeePerGas'} field - the
 *  current field being validated
 * @throws {ethErrors.rpc.invalidParams} - throws if type does not match the
 *  expectations for provided field.
 */


function ensureProperTransactionEnvelopeTypeProvided(txParams, field) {
  switch (field) {
    case 'maxFeePerGas':
    case 'maxPriorityFeePerGas':
      if (txParams.type && txParams.type !== _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {
        throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction envelope type: specified type "${txParams.type}" but including maxFeePerGas and maxPriorityFeePerGas requires type: "${_transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET}"`);
      }

      break;

    case 'gasPrice':
    default:
      if (txParams.type && txParams.type === _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {
        throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction envelope type: specified type "${txParams.type}" but included a gasPrice instead of maxFeePerGas and maxPriorityFeePerGas`);
      }

  }
}
/**
 * Validates the given tx parameters
 * @param {Object} txParams - the tx params
 * @param {boolean} eip1559Compatibility - whether or not the current network supports EIP-1559 transactions
 * @throws {Error} if the tx params contains invalid fields
 */


function validateTxParams(txParams, eip1559Compatibility = true) {
  if (!txParams || typeof txParams !== 'object' || Array.isArray(txParams)) {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams('Invalid transaction params: must be an object.');
  }

  if (!txParams.to && !txParams.data) {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams('Invalid transaction params: must specify "data" for contract deployments, or "to" (and optionally "data") for all other types of transactions.');
  }

  if ((0, _transaction2.isEIP1559Transaction)({
    txParams
  }) && !eip1559Compatibility) {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams('Invalid transaction params: params specify an EIP-1559 transaction but the current network does not support EIP-1559');
  }

  Object.entries(txParams).forEach(([key, value]) => {
    // validate types
    switch (key) {
      case 'from':
        validateFrom(txParams);
        break;

      case 'to':
        validateRecipient(txParams);
        break;

      case 'gasPrice':
        ensureProperTransactionEnvelopeTypeProvided(txParams, 'gasPrice');
        ensureMutuallyExclusiveFieldsNotProvided(txParams, 'gasPrice', 'maxFeePerGas');
        ensureMutuallyExclusiveFieldsNotProvided(txParams, 'gasPrice', 'maxPriorityFeePerGas');
        ensureFieldIsString(txParams, 'gasPrice');
        break;

      case 'maxFeePerGas':
        ensureProperTransactionEnvelopeTypeProvided(txParams, 'maxFeePerGas');
        ensureMutuallyExclusiveFieldsNotProvided(txParams, 'maxFeePerGas', 'gasPrice');
        ensureFieldIsString(txParams, 'maxFeePerGas');
        break;

      case 'maxPriorityFeePerGas':
        ensureProperTransactionEnvelopeTypeProvided(txParams, 'maxPriorityFeePerGas');
        ensureMutuallyExclusiveFieldsNotProvided(txParams, 'maxPriorityFeePerGas', 'gasPrice');
        ensureFieldIsString(txParams, 'maxPriorityFeePerGas');
        break;

      case 'value':
        ensureFieldIsString(txParams, 'value');

        if (value.toString().includes('-')) {
          throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction value "${value}": not a positive number.`);
        }

        if (value.toString().includes('.')) {
          throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction value of "${value}": number must be in wei.`);
        }

        if (!value.match(/^0x[a-fA-F0-9]+$/u)) {
          throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction value of "${value}": not a valid hex string.`);
        }

        break;

      case 'chainId':
        if (typeof value !== 'number' && typeof value !== 'string') {
          throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction params: ${key} is not a Number or hex string. got: (${value})`);
        }

        break;

      default:
        ensureFieldIsString(txParams, key);
    }
  });
}
/**
 * Validates the {@code from} field in the given tx params
 * @param {Object} txParams
 * @throws {Error} if the from address isn't valid
 */


function validateFrom(txParams) {
  if (!(typeof txParams.from === 'string')) {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid "from" address "${txParams.from}": not a string.`);
  }

  if (!(0, _hexstringUtils.isValidHexAddress)(txParams.from, {
    allowNonPrefixed: false
  })) {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams('Invalid "from" address.');
  }
}
/**
 * Validates the {@code to} field in the given tx params
 * @param {Object} txParams - the tx params
 * @returns {Object} the tx params
 * @throws {Error} if the recipient is invalid OR there isn't tx data
 */


function validateRecipient(txParams) {
  if (txParams.to === '0x' || txParams.to === null) {
    if (txParams.data) {
      delete txParams.to;
    } else {
      throw _ethRpcErrors.ethErrors.rpc.invalidParams('Invalid "to" address.');
    }
  } else if (txParams.to !== undefined && !(0, _hexstringUtils.isValidHexAddress)(txParams.to, {
    allowNonPrefixed: false
  })) {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams('Invalid "to" address.');
  }

  return txParams;
}
/**
 * Returns a list of final states
 * @returns {string[]} the states that can be considered final states
 */


function getFinalStates() {
  return [_transaction.TRANSACTION_STATUSES.REJECTED, // the user has responded no!
  _transaction.TRANSACTION_STATUSES.CONFIRMED, // the tx has been included in a block.
  _transaction.TRANSACTION_STATUSES.FAILED, // the tx failed for some reason, included on tx data.
  _transaction.TRANSACTION_STATUSES.DROPPED // the tx nonce was already used
  ];
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/lib/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/tx-gas-utils.js", {"../../lib/util":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/util.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","ethjs-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-query/lib/index.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/tx-gas-utils.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethjsQuery = _interopRequireDefault(require("ethjs-query"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _ethereumjsUtil = require("ethereumjs-util");

var _lodash = require("lodash");

var _util = require("../../lib/util");

/**
 * Result of gas analysis, including either a gas estimate for a successful analysis, or
 * debug information for a failed analysis.
 * @typedef {Object} GasAnalysisResult
 * @property {string} blockGasLimit - The gas limit of the block used for the analysis
 * @property {string} estimatedGasHex - The estimated gas, in hexadecimal
 * @property {Object} simulationFails - Debug information about why an analysis failed
 */

/**
tx-gas-utils are gas utility methods for Transaction manager
its passed ethquery
and used to do things like calculate gas of a tx.
@param {Object} provider - A network provider.
*/
class TxGasUtil {
  constructor(provider) {
    this.query = new _ethjsQuery.default(provider);
  }
  /**
    @param {Object} txMeta - the txMeta object
    @returns {GasAnalysisResult} The result of the gas analysis
  */


  async analyzeGasUsage(txMeta) {
    const block = await this.query.getBlockByNumber('latest', false); // fallback to block gasLimit

    const blockGasLimitBN = (0, _util.hexToBn)(block.gasLimit);
    const saferGasLimitBN = (0, _util.BnMultiplyByFraction)(blockGasLimitBN, 19, 20);
    let estimatedGasHex = (0, _util.bnToHex)(saferGasLimitBN);
    let simulationFails;

    try {
      estimatedGasHex = await this.estimateTxGas(txMeta);
    } catch (error) {
      _loglevel.default.warn(error);

      simulationFails = {
        reason: error.message,
        errorKey: error.errorKey,
        debug: {
          blockNumber: block.number,
          blockGasLimit: block.gasLimit
        }
      };
    }

    return {
      blockGasLimit: block.gasLimit,
      estimatedGasHex,
      simulationFails
    };
  }
  /**
    Estimates the tx's gas usage
    @param {Object} txMeta - the txMeta object
    @returns {string} the estimated gas limit as a hex string
  */


  async estimateTxGas(txMeta) {
    const txParams = (0, _lodash.cloneDeep)(txMeta.txParams); // `eth_estimateGas` can fail if the user has insufficient balance for the
    // value being sent, or for the gas cost. We don't want to check their
    // balance here, we just want the gas estimate. The gas price is removed
    // to skip those balance checks. We check balance elsewhere. We also delete
    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.

    delete txParams.gasPrice;
    delete txParams.maxFeePerGas;
    delete txParams.maxPriorityFeePerGas; // estimate tx gas requirements

    return await this.query.estimateGas(txParams);
  }
  /**
    Adds a gas buffer with out exceeding the block gas limit
     @param {string} initialGasLimitHex - the initial gas limit to add the buffer too
    @param {string} blockGasLimitHex - the block gas limit
    @returns {string} the buffered gas limit as a hex string
  */


  addGasBuffer(initialGasLimitHex, blockGasLimitHex, multiplier = 1.5) {
    const initialGasLimitBn = (0, _util.hexToBn)(initialGasLimitHex);
    const blockGasLimitBn = (0, _util.hexToBn)(blockGasLimitHex);
    const upperGasLimitBn = blockGasLimitBn.muln(0.9);
    const bufferedGasLimitBn = initialGasLimitBn.muln(multiplier); // if initialGasLimit is above blockGasLimit, dont modify it

    if (initialGasLimitBn.gt(upperGasLimitBn)) {
      return (0, _util.bnToHex)(initialGasLimitBn);
    } // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit


    if (bufferedGasLimitBn.lt(upperGasLimitBn)) {
      return (0, _util.bnToHex)(bufferedGasLimitBn);
    } // otherwise use blockGasLimit


    return (0, _util.bnToHex)(upperGasLimitBn);
  }

  async getBufferedGasLimit(txMeta, multiplier) {
    const {
      blockGasLimit,
      estimatedGasHex,
      simulationFails
    } = await this.analyzeGasUsage(txMeta); // add additional gas buffer to our estimation for safety

    const gasLimit = this.addGasBuffer((0, _ethereumjsUtil.addHexPrefix)(estimatedGasHex), blockGasLimit, multiplier);
    return {
      gasLimit,
      simulationFails
    };
  }

}

exports.default = TxGasUtil;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/tx-gas-utils.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNoYXJlZC9jb25zdGFudHMvbWV0YW1ldHJpY3MuanMiLCJhcHAvc2NyaXB0cy9maXJzdC10aW1lLXN0YXRlLmpzIiwiYXBwL3NjcmlwdHMvbGliL2dldE9ialN0cnVjdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWJvdW5jZS1zdHJlYW0vaW5kZXguanMiLCJhcHAvc2NyaXB0cy9saWIvbG9jYWwtc3RvcmUuanMiLCJhcHAvc2NyaXB0cy9saWIvbmV0d29yay1zdG9yZS5qcyIsImFwcC9zY3JpcHRzL2xpYi9ub3RpZmljYXRpb24tbWFuYWdlci5qcyIsImFwcC9zY3JpcHRzL2xpYi9jcmVhdGVTdHJlYW1TaW5rLmpzIiwiYXBwL3NjcmlwdHMvbGliL2dldC1maXJzdC1wcmVmZXJyZWQtbGFuZy1jb2RlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9pbmRleC5qcyIsImFwcC9zY3JpcHRzL2xpYi9taWdyYXRvci9pbmRleC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9saWIvZW5zLWlwZnMvc2V0dXAuanMiLCJhcHAvc2NyaXB0cy9tZXRhbWFzay1jb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL2RlYm91bmNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZHVwbGV4ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L2FzU3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9Mb2NhbFN0b3JhZ2VTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvQ29tcG9zZWRTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvTWVyZ2VkU3RvcmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L09ic2VydmFibGVTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvdHJhbnNmb3JtLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwNC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDAzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxMC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDE0LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxMS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDE1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxNy5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDE5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyMC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDIzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjEuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyNS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDIyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyOC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDI3LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzMS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDMwLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzMi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDMzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzUuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzNi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDAuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0NC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQxLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0NS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0Ny5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQ5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1MS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDU0LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTAuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1NS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDU2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1OS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDYwLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjEuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2Mi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDY0LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjUuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2OS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM3LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDUuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwNy5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDA2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyOS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM4LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1My5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDU3LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2Ny5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDY2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxOC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlMzItZW5jb2RlL2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvbGliL2Vucy1pcGZzL3Jlc29sdmVyLmpzIiwiYXBwL3NjcmlwdHMvbGliL2NyZWF0ZU9yaWdpbk1pZGRsZXdhcmUuanMiLCJhcHAvc2NyaXB0cy9saWIvY3JlYXRlVGFiSWRNaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL25hbm9pZC9pbmRleC5icm93c2VyLmpzIiwiYXBwL3NjcmlwdHMvbGliL2NyZWF0ZU1ldGFSUENIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzb24tcnBjLW1pZGRsZXdhcmUtc3RyZWFtL2VuZ2luZVN0cmVhbS5qcyIsImFwcC9zY3JpcHRzL2xpYi9Db21wb3NhYmxlT2JzZXJ2YWJsZVN0b3JlLmpzIiwiYXBwL3NjcmlwdHMvbGliL2NyZWF0ZUxvZ2dlck1pZGRsZXdhcmUuanMiLCJhcHAvc2NyaXB0cy9saWIvY3JlYXRlT25ib2FyZGluZ01pZGRsZXdhcmUuanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9hcHAtc3RhdGUuanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9jYWNoZWQtYmFsYW5jZXMuanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9hbGVydC5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL29uYm9hcmRpbmcuanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9pbmNvbWluZy10cmFuc2FjdGlvbnMuanMiLCJhcHAvc2NyaXB0cy9saWIvZGVjcnlwdC1tZXNzYWdlLW1hbmFnZXIuanMiLCJhcHAvc2NyaXB0cy9saWIvbWVzc2FnZS1tYW5hZ2VyLmpzIiwiYXBwL3NjcmlwdHMvbGliL3BlcnNvbmFsLW1lc3NhZ2UtbWFuYWdlci5qcyIsImFwcC9zY3JpcHRzL2xpYi9lbmNyeXB0aW9uLXB1YmxpYy1rZXktbWFuYWdlci5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL21ldGFtZXRyaWNzLmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvZGV0ZWN0LXRva2Vucy5qcyIsImFwcC9zY3JpcHRzL2xpYi9zZWVkLXBocmFzZS12ZXJpZmllci5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL3ByZWZlcmVuY2VzLmpzIiwibm9kZV9tb2R1bGVzL2pzb24tcnBjLWVuZ2luZS9kaXN0L2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvbGliL3R5cGVkLW1lc3NhZ2UtbWFuYWdlci5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL2Vucy9pbmRleC5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucy9pbmRleC5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL3Blcm1pc3Npb25zL2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvbGliL3NlZ21lbnQuanMiLCJhcHAvc2NyaXB0cy9hY2NvdW50LWltcG9ydC1zdHJhdGVnaWVzL2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvbmV0d29yay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtdHJlem9yLWtleXJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtbGF0dGljZS1rZXlyaW5nL2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvc3dhcHMuanMiLCJhcHAvc2NyaXB0cy9saWIvYWNjb3VudC10cmFja2VyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvZGlzdC9pbmRleC5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL3RocmVlYm94LmpzIiwiYXBwL3NjcmlwdHMvbGliL3JwYy1tZXRob2QtbWlkZGxld2FyZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvbm9kZV9tb2R1bGVzL3Rocm91Z2gyL3Rocm91Z2gyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy9mYWlsLXR4LmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvdHJhbnNhY3Rpb25zL2xpYi90eC1zdGF0ZS1oaXN0b3J5LWhlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvdG8tZGF0YS12aWV3L2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvbGliL2Vucy1pcGZzL2NvbnRyYWN0cy9yZWdpc3RyeS5qcyIsImFwcC9zY3JpcHRzL2xpYi9lbnMtaXBmcy9jb250cmFjdHMvcmVzb2x2ZXIuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL3NyYy9pbmRleC5qcyIsImFwcC9zY3JpcHRzL2NvbnN0YW50cy9jb250cmFjdHMuanMiLCJub2RlX21vZHVsZXMvanNvbi1ycGMtZW5naW5lL2Rpc3QvY3JlYXRlQXN5bmNNaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL2pzb24tcnBjLWVuZ2luZS9kaXN0L2NyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZS5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXJwYy1lbmdpbmUvZGlzdC9nZXRVbmlxdWVJZC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXJwYy1lbmdpbmUvZGlzdC9pZFJlbWFwTWlkZGxld2FyZS5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXJwYy1lbmdpbmUvZGlzdC9tZXJnZU1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvanNvbi1ycGMtZW5naW5lL2Rpc3QvSnNvblJwY0VuZ2luZS5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL2Vucy9lbnMuanMiLCJhcHAvc2NyaXB0cy9saWIvY2xlYW5FcnJvclN0YWNrLmpzIiwibm9kZV9tb2R1bGVzL25vbmNlLXRyYWNrZXIvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy90cmFuc2FjdGlvbnMvbGliL3V0aWwuanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy90cmFuc2FjdGlvbnMvdHgtZ2FzLXV0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxDQUFBOztBQUNBLElBQUEsWUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx5QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGtCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLCtCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsU0FBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxxQkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGNBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsMEJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxZQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHdCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsd0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEscUNBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxrQkFBQSx1QkFBQSxDQUFBLE9BQUEsQ0FBQSx1QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLHlCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLCtCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsOEJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEscUNBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSwwQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxnQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLHVCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLDZCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsZ0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxnQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSw2QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFVBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEscUJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSwyQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSw2QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLHNC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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDcGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LEdBQy9DLDRDQURLOztBQUVBLE1BQU0sa0NBQWtDLEdBQzdDLDRDQURLOzs7Ozs7Ozs7Ozs7O0FDTlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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S0EsV0FBTztBQUFFLE1BQUEsUUFBRjtBQUFZLE1BQUE7QUFBWixLQUFQO0FBQ0Q7O0FBM0Y0QiIsImZpbGUiOiJiYWNrZ3JvdW5kLTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUeXBlIEltcG9ydHNcbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hcHAnKS5FbnZpcm9ubWVudFR5cGV9IEVudmlyb25tZW50VHlwZVxuICovXG5cbi8vIFR5cGUgRGVjbGFyYXRpb25zXG4vKipcbiAqIFVzZWQgdG8gYXR0YWNoIGNvbnRleHQgb2Ygd2hlcmUgdGhlIHVzZXIgd2FzIGF0IGluIHRoZSBhcHBsaWNhdGlvbiB3aGVuIHRoZVxuICogZXZlbnQgd2FzIHRyaWdnZXJlZC4gQWxzbyBpbmNsdWRlZCBhcyBmdWxsIGRldGFpbHMgb2YgdGhlIGN1cnJlbnQgcGFnZSBpblxuICogcGFnZSBldmVudHMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhTWV0cmljc1BhZ2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGF0aF0gLSB0aGUgcGF0aCBvZiB0aGUgY3VycmVudCBwYWdlIChlLmcgL2hvbWUpXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXSAtIHRoZSB0aXRsZSBvZiB0aGUgY3VycmVudCBwYWdlIChlLmcgJ2hvbWUnKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIC0gdGhlIGZ1bGx5IHF1YWxpZmllZCB1cmwgb2YgdGhlIGN1cnJlbnQgcGFnZVxuICovXG5cbi8qKlxuICogRm9yIG1ldGFtYXNrLCB0aGlzIGlzIHRoZSBkYXBwIHRoYXQgdHJpZ2dlcmVkIGFuIGludGVyYWN0aW9uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhTWV0cmljc1JlZmVycmVyT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VybF0gLSB0aGUgb3JpZ2luIG9mIHRoZSBkYXBwIGlzc3VpbmcgdGhlXG4gKiAgbm90aWZpY2F0aW9uXG4gKi9cblxuLyoqXG4gKiBXZSBhdHRhY2ggY29udGV4dCB0byBldmVyeSBtZXRhIG1ldHJpY3MgZXZlbnQgdGhhdCBoZWxwIHRvIHF1YWxpZnkgb3VyXG4gKiBhbmFseXRpY3MuIFRoaXMgdHlwZSBoYXMgYWxsIG9wdGlvbmFsIHZhbHVlcyBiZWNhdXNlIGl0IHJlcHJlc2VudHMgYVxuICogcmV0dXJuZWQgb2JqZWN0IGZyb20gYSBtZXRob2QgY2FsbC4gSWRlYWxseSBhcHAgYW5kIHVzZXJBZ2VudCBhcmVcbiAqIGRlZmluZWQgb24gZXZlcnkgZXZlbnQuIFRoaXMgaXMgY29uZmlybWVkIGluIHRoZSBnZXRUcmFja01ldGFNZXRyaWNzRXZlbnRcbiAqIGZ1bmN0aW9uLCBidXQgc3RpbGwgcHJvdmlkZXMgdGhlIGNvbnN1bWVyIGEgd2F5IHRvIG92ZXJyaWRlIHRoZXNlIHZhbHVlcyBpZlxuICogbmVjZXNzYXJ5LlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YU1ldHJpY3NDb250ZXh0XG4gKiBAcHJvcGVydHkge09iamVjdH0gYXBwXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXBwLm5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYXBwbGljYXRpb24gdHJhY2tpbmcgdGhlIGV2ZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXBwLnZlcnNpb24gLSB0aGUgdmVyc2lvbiBvZiB0aGUgYXBwbGljYXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1c2VyQWdlbnQgLSB0aGUgdXNlcmFnZW50IHN0cmluZyBvZiB0aGUgdXNlclxuICogQHByb3BlcnR5IHtNZXRhTWV0cmljc1BhZ2VPYmplY3R9IFtwYWdlXSAtIGFuIG9iamVjdCByZXByZXNlbnRpbmcgZGV0YWlscyBvZlxuICogIHRoZSBjdXJyZW50IHBhZ2VcbiAqIEBwcm9wZXJ0eSB7TWV0YU1ldHJpY3NSZWZlcnJlck9iamVjdH0gW3JlZmVycmVyXSAtIGZvciBtZXRhbWFzaywgdGhpcyBpcyB0aGVcbiAqICBkYXBwIHRoYXQgdHJpZ2dlcmVkIGFuIGludGVyYWN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhTWV0cmljc0V2ZW50UGF5bG9hZFxuICogQHByb3BlcnR5IHtzdHJpbmd9ICBldmVudCAtIGV2ZW50IG5hbWUgdG8gdHJhY2tcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgY2F0ZWdvcnkgLSBjYXRlZ29yeSB0byBhc3NvY2lhdGUgZXZlbnQgdG9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZW52aXJvbm1lbnRUeXBlXSAtIFRoZSB0eXBlIG9mIGVudmlyb25tZW50IHRoaXMgZXZlbnRcbiAqICBvY2N1cnJlZCBpbi4gRGVmYXVsdHMgdG8gdGhlIGJhY2tncm91bmQgcHJvY2VzcyB0eXBlXG4gKiBAcHJvcGVydHkge29iamVjdH0gIFtwcm9wZXJ0aWVzXSAtIG9iamVjdCBvZiBjdXN0b20gdmFsdWVzIHRvIHRyYWNrLCBrZXlzXG4gKiAgaW4gdGhpcyBvYmplY3QgbXVzdCBiZSBpbiBzbmFrZV9jYXNlXG4gKiBAcHJvcGVydHkge29iamVjdH0gIFtzZW5zaXRpdmVQcm9wZXJ0aWVzXSAtIE9iamVjdCBvZiBzZW5zaXRpdmUgdmFsdWVzIHRvXG4gKiAgdHJhY2suIEtleXMgaW4gdGhpcyBvYmplY3QgbXVzdCBiZSBpbiBzbmFrZV9jYXNlLiBUaGVzZSBwcm9wZXJ0aWVzIHdpbGwgYmVcbiAqICBzZW50IGluIGFuIGFkZGl0aW9uYWwgZXZlbnQgdGhhdCBleGNsdWRlcyB0aGUgdXNlcidzIG1ldGFNZXRyaWNzSWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgW3JldmVudWVdIC0gYW1vdW50IG9mIGN1cnJlbmN5IHRoYXQgZXZlbnQgY3JlYXRlcyBpblxuICogIHJldmVudWUgZm9yIE1ldGFNYXNrXG4gKiBAcHJvcGVydHkge3N0cmluZ30gIFtjdXJyZW5jeV0gLSBJU08gNDEyNyBmb3JtYXQgY3VycmVuY3kgZm9yIGV2ZW50cyB3aXRoXG4gKiAgcmV2ZW51ZSwgZGVmYXVsdHMgdG8gVVMgZG9sbGFyc1xuICogQHByb3BlcnR5IHtudW1iZXJ9ICBbdmFsdWVdIC0gQWJzdHJhY3QgYnVzaW5lc3MgXCJ2YWx1ZVwiIGF0dHJpYnV0YWJsZSB0b1xuICogIGN1c3RvbWVycyB3aG8gdHJpZ2dlciB0aGlzIGV2ZW50XG4gKiBAcHJvcGVydHkge01ldGFNZXRyaWNzUGFnZU9iamVjdH0gW3BhZ2VdIC0gdGhlIHBhZ2Uvcm91dGUgdGhhdCB0aGUgZXZlbnRcbiAqICBvY2N1cnJlZCBvblxuICogQHByb3BlcnR5IHtNZXRhTWV0cmljc1JlZmVycmVyT2JqZWN0fSBbcmVmZXJyZXJdIC0gdGhlIG9yaWdpbiBvZiB0aGUgZGFwcFxuICogIHRoYXQgdHJpZ2dlcmVkIHRoZSBldmVudFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YU1ldHJpY3NFdmVudE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lzT3B0SW5dIC0gaGFwcGVuZWQgZHVyaW5nIG9wdCBpbi9vdXQgd29ya2Zsb3dcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZsdXNoSW1tZWRpYXRlbHldIC0gV2hlbiB0cnVlIHdpbGwgYXV0b21hdGljYWxseSBmbHVzaFxuICogIHRoZSBzZWdtZW50IHF1ZXVlIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC4gUmVjb21tZW5kZWQgaWYgdGhlIHJlc3VsdCBvZlxuICogIHRyYWNraW5nIHRoZSBldmVudCBtdXN0IGJlIGtub3duIGJlZm9yZSBVSSB0cmFuc2l0aW9uIG9yIHVwZGF0ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBbZXhjbHVkZU1ldGFNZXRyaWNzSWRdIC0gd2hldGhlciB0byBleGNsdWRlIHRoZSB1c2VyJ3NcbiAqICBtZXRhbWV0cmljcyBpZCBmb3IgYW5vbnltaXR5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gIFttZXRhTWV0cmljc0lkXSAtIGFuIG92ZXJyaWRlIGZvciB0aGUgbWV0YU1ldHJpY3NJZCBpblxuICogIHRoZSBldmVudCBvbmUgaXMgY3JlYXRlZCBhcyBwYXJ0IG9mIGFuIGFzeW5jaHJvbm91cyB3b3JrZmxvdywgc3VjaCBhc1xuICogIGF3YWl0aW5nIHRoZSByZXN1bHQgb2YgdGhlIG1ldGFtZXRyaWNzIG9wdC1pbiBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyB0aGVcbiAqICB1c2VyJ3MgbWV0YW1ldHJpY3MgaWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21hdG9tb0V2ZW50XSAtIGlzIHRoaXMgZXZlbnQgYSBob2xkb3ZlciBmcm9tIG1hdG9tb1xuICogIHRoYXQgbmVlZHMgZnVydGhlciBtaWdyYXRpb24/IHdoZW4gdHJ1ZSwgc2VuZHMgdGhlIGRhdGEgdG8gYSBzcGVjaWFsXG4gKiAgc2VnbWVudCBzb3VyY2UgdGhhdCBtYXJrcyB0aGUgZXZlbnQgZGF0YSBhcyBub3QgY29uZm9ybWluZyB0byBvdXIgc2NoZW1hXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBzaGFwZSBvZiBkYXRhIHNlbnQgdG8gdGhlIHNlZ21lbnQudHJhY2sgbWV0aG9kLlxuICogQHR5cGVkZWYge09iamVjdH0gU2VnbWVudEV2ZW50UGF5bG9hZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1c2VySWRdIC0gVGhlIG1ldGFtZXRyaWNzIGlkIGZvciB0aGUgdXNlclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFthbm9ueW1vdXNJZF0gLSBBbiBhbm9ueW1vdXNJZCB0aGF0IGlzIHVzZWQgdG8gdHJhY2tcbiAqICBzZW5zaXRpdmUgZGF0YSB3aGlsZSBwcmVzZXJ2aW5nIGFub255bWl0eS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudCAtIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHRyYWNrXG4gKiBAcHJvcGVydHkge09iamVjdH0gcHJvcGVydGllcyAtIHByb3BlcnRpZXMgdG8gYXR0YWNoIHRvIHRoZSBldmVudFxuICogQHByb3BlcnR5IHtNZXRhTWV0cmljc0NvbnRleHR9IGNvbnRleHQgLSB0aGUgY29udGV4dCB0aGUgZXZlbnQgb2NjdXJyZWQgaW5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFNZXRyaWNzUGFnZVBheWxvYWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhZ2UgdGhhdCB3YXMgdmlld2VkXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3BhcmFtc10gLSBUaGUgdmFyaWFkaWMgcGFydHMgb2YgdGhlIHBhZ2UgdXJsXG4gKiAgZXhhbXBsZSAocm91dGU6IGAvYXNzZXQvOmFzc2V0YCwgcGF0aDogYC9hc3NldC9FVEhgKVxuICogIHBhcmFtczogeyBhc3NldDogJ0VUSCcgfVxuICogQHByb3BlcnR5IHtFbnZpcm9ubWVudFR5cGV9IGVudmlyb25tZW50VHlwZSAtIHRoZSBlbnZpcm9ubWVudCB0eXBlIHRoYXQgdGhlXG4gKiAgcGFnZSB3YXMgdmlld2VkIGluXG4gKiBAcHJvcGVydHkge01ldGFNZXRyaWNzUGFnZU9iamVjdH0gW3BhZ2VdIC0gdGhlIGRldGFpbHMgb2YgdGhlIHBhZ2VcbiAqIEBwcm9wZXJ0eSB7TWV0YU1ldHJpY3NSZWZlcnJlck9iamVjdH0gW3JlZmVycmVyXSAtIGRhcHAgdGhhdCB0cmlnZ2VyZWQgdGhlIHBhZ2VcbiAqICB2aWV3XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhTWV0cmljc1BhZ2VPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpc09wdEluUGF0aF0gLSBpcyB0aGUgY3VycmVudCBwYXRoIG9uZSBvZiB0aGUgcGFnZXMgaW5cbiAqICB0aGUgb25ib2FyZGluZyB3b3JrZmxvdz8gSWYgdHJ1ZSBhbmQgcGFydGljaXBhdGVJbk1ldGFNZXRyaWNzIGlzIG51bGwgdHJhY2tcbiAqICB0aGUgcGFnZSB2aWV3XG4gKi9cblxuLy8gQW4gZW1wdHkgc3RyaW5nIGlzIGEsIGN1cnJlbnRseSB1bmRvY3VtZW50ZWQsIHdheSBvZiB0ZWxsaW5nIG1peHBhbmVsXG4vLyB0aGF0IHRoZXNlIGV2ZW50cyBhcmUgbWVhbnQgdG8gYmUgYW5vbnltb3VzIGFuZCBub3QgaWRlbnRpZmllZCB0byBhbnkgdXNlclxuZXhwb3J0IGNvbnN0IE1FVEFNRVRSSUNTX0FOT05ZTU9VU19JRCA9ICcnO1xuXG4vKipcbiAqIFRoaXMgb2JqZWN0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZXZlbnRzIHRoYXQgYXJlIHRyaWdnZXJlZCBieSB0aGUgYmFja2dyb3VuZFxuICogcHJvY2Vzcy5cbiAqIEB0eXBlIHtNZXRhTWV0cmljc1BhZ2VPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBNRVRBTUVUUklDU19CQUNLR1JPVU5EX1BBR0VfT0JKRUNUID0ge1xuICBwYXRoOiAnL2JhY2tncm91bmQtcHJvY2VzcycsXG4gIHRpdGxlOiAnQmFja2dyb3VuZCBQcm9jZXNzJyxcbiAgdXJsOiAnL2JhY2tncm91bmQtcHJvY2VzcycsXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlZ21lbnRJbnRlcmZhY2VcbiAqIEBwcm9wZXJ0eSB7U2VnbWVudEV2ZW50UGF5bG9hZFtdfSBxdWV1ZSAtIEEgcXVldWUgb2YgZXZlbnRzIHRvIGJlIHNlbnQgd2hlblxuICogIHRoZSBmbHVzaEF0IGxpbWl0IGhhcyBiZWVuIHJlYWNoZWQsIG9yIGZsdXNoSW50ZXJ2YWwgb2NjdXJzXG4gKiBAcHJvcGVydHkgeygpID0+IHZvaWR9IGZsdXNoIC0gSW1tZWRpYXRlbHkgZmx1c2ggdGhlIHF1ZXVlLCByZXNldHRpbmcgaXQgdG9cbiAqICBhbiBlbXB0eSBhcnJheSBhbmQgc2VuZGluZyB0aGUgcGVuZGluZyBldmVudHMgdG8gU2VnbWVudFxuICogQHByb3BlcnR5IHsoXG4gKiAgcGF5bG9hZDogU2VnbWVudEV2ZW50UGF5bG9hZCxcbiAqICBjYWxsYmFjazogKGVycj86IEVycm9yKSA9PiB2b2lkXG4gKiApID0+IHZvaWR9IHRyYWNrIC0gVHJhY2sgYW4gZXZlbnQgd2l0aCBTZWdtZW50LCB1c2luZyB0aGUgaW50ZXJuYWwgYmF0Y2hpbmdcbiAqICBtZWNoYW5pc20gdG8gb3B0aW1pemUgbmV0d29yayByZXF1ZXN0c1xuICogQHByb3BlcnR5IHsocGF5bG9hZDogT2JqZWN0KSA9PiB2b2lkfSBwYWdlIC0gVHJhY2sgYSBwYWdlIHZpZXcgd2l0aCBTZWdtZW50XG4gKiBAcHJvcGVydHkgeygpID0+IHZvaWR9IGlkZW50aWZ5IC0gSWRlbnRpZnkgYW4gYW5vbnltb3VzIHVzZXIuIFdlIGRvIG5vdFxuICogIGN1cnJlbnRseSB1c2UgdGhpcyBtZXRob2QuXG4gKi9cblxuZXhwb3J0IGNvbnN0IFJFSkVDVF9OT1RGSUNJQVRJT05fQ0xPU0UgPSAnQ2FuY2VsIFZpYSBOb3RpZmljYXRpb24gQ2xvc2UnO1xuZXhwb3J0IGNvbnN0IFJFSkVDVF9OT1RGSUNJQVRJT05fQ0xPU0VfU0lHID1cbiAgJ0NhbmNlbCBTaWcgUmVxdWVzdCBWaWEgTm90aWZpY2F0aW9uIENsb3NlJztcbiIsIi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRmlyc3RUaW1lU3RhdGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjb25maWcgSW5pdGlhbCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBOZXR3b3JrQ29udHJvbGxlciBOZXR3b3JrIGNvbnRyb2xsZXIgc3RhdGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtGaXJzdFRpbWVTdGF0ZX1cbiAqL1xuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICBjb25maWc6IHt9LFxuICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHtcbiAgICBmcmVxdWVudFJwY0xpc3REZXRhaWw6IFtcbiAgICAgIHtcbiAgICAgICAgcnBjVXJsOiAnaHR0cDovL2xvY2FsaG9zdDo4NTQ1JyxcbiAgICAgICAgY2hhaW5JZDogJzB4NTM5JyxcbiAgICAgICAgdGlja2VyOiAnRVRIJyxcbiAgICAgICAgbmlja25hbWU6ICdMb2NhbGhvc3QgODU0NScsXG4gICAgICAgIHJwY1ByZWZzOiB7fSxcbiAgICAgIH0sXG4gICAgXSxcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGluaXRpYWxTdGF0ZTtcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbi8vIFRoaXMgd2lsbCBjcmVhdGUgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgc3RydWN0dXJlIG9mIHRoZSBnaXZlbiBvYmplY3Rcbi8vIGl0IHJlcGxhY2VzIGFsbCB2YWx1ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZWlyIHR5cGVcblxuLy8ge1xuLy8gICBcImRhdGFcIjoge1xuLy8gICAgIFwiQ3VycmVuY3lDb250cm9sbGVyXCI6IHtcbi8vICAgICAgIFwiY29udmVyc2lvbkRhdGVcIjogXCJudW1iZXJcIixcbi8vICAgICAgIFwiY29udmVyc2lvblJhdGVcIjogXCJudW1iZXJcIixcbi8vICAgICAgIFwiY3VycmVudEN1cnJlbmN5XCI6IFwic3RyaW5nXCJcbi8vICAgICB9XG4vLyB9XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuIG9iamVjdC4gSXQgcmVwbGFjZXMgYWxsIHZhbHVlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlaXJcbiAqIHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgZm9yIHdoaWNoIGEgJ3N0cnVjdHVyZScgd2lsbCBiZSByZXR1cm5lZC4gVXN1YWxseSBhIHBsYWluIG9iamVjdCBhbmQgbm90IGEgY2xhc3MuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgXCJtYXBwZWRcIiB2ZXJzaW9uIG9mIGEgZGVlcCBjbG9uZSBvZiB0aGUgcGFzc2VkIG9iamVjdCwgd2l0aCBlYWNoIG5vbi1vYmplY3QgcHJvcGVydHkgdmFsdWVcbiAqIHJlcGxhY2VkIHdpdGggdGhlIGphdmFzY3JpcHQgdHlwZSBvZiB0aGF0IHZhbHVlLlxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2JqU3RydWN0dXJlKG9iaikge1xuICBjb25zdCBzdHJ1Y3R1cmUgPSBjbG9uZURlZXAob2JqKTtcbiAgcmV0dXJuIGRlZXBNYXAoc3RydWN0dXJlLCAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdmFsdWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIGFsbCB0aGUgcHJvcGVydGllcyBhbmQgZGVlcGx5IG5lc3RlZCBvZiBhIHBhc3NlZCBvYmplY3QuIEl0ZXJhdGVzIHJlY3Vyc2l2ZWx5IG92ZXIgYWxsIG5lc3RlZCBvYmplY3RzIGFuZFxuICogdGhlaXIgcHJvcGVydGllcywgYW5kIGNvdmVycyB0aGUgZW50aXJlIGRlcHRoIG9mIHRoZSBvYmplY3QuIEF0IGVhY2ggcHJvcGVydHkgdmFsdWUgd2hpY2ggaXMgbm90IGFuIG9iamVjdCBpcyBtb2RpZmllZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gVGhlIG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHZpc2l0IC0gVGhlIG1vZGlmaWVyIHRvIGFwcGx5IHRvIGVhY2ggbm9uLW9iamVjdCBwcm9wZXJ0eSB2YWx1ZVxuICogQHJldHVybnMge09iamVjdH0gVGhlIG1vZGlmaWVkIG9iamVjdFxuICovXG5mdW5jdGlvbiBkZWVwTWFwKHRhcmdldCA9IHt9LCB2aXNpdCkge1xuICBPYmplY3QuZW50cmllcyh0YXJnZXQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlZXBNYXAodmFsdWUsIHZpc2l0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2aXNpdCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbiIsInZhciB0aHJvdWdoID0gcmVxdWlyZSgndGhyb3VnaCcpXG4gICwgZHVwbGV4ZXIgPSByZXF1aXJlKCdkdXBsZXhlcicpXG4gICwgZGVib3VuY2UgPSByZXF1aXJlKCdkZWJvdW5jZScpXG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2VTdHJlYW1cblxuZnVuY3Rpb24gZGVib3VuY2VTdHJlYW0oX21zLCBpbW1lZGlhdGUpIHtcbiAgdmFyIG1zID0gX21zIHx8IDEwMFxuICAgICwgaW5wdXQgPSB0aHJvdWdoKGRlYm91bmNlKHdyaXRlLCBtcywgaW1tZWRpYXRlKSlcbiAgICAsIG91dHB1dCA9IHRocm91Z2goKVxuXG4gIHJldHVybiBkdXBsZXhlcihpbnB1dCwgb3V0cHV0KVxuXG4gIGZ1bmN0aW9uIHdyaXRlKGRhdGEpIHtcbiAgICBvdXRwdXQucXVldWUoZGF0YSlcbiAgfVxufVxuIiwiaW1wb3J0IGV4dGVuc2lvbiBmcm9tICdleHRlbnNpb25pemVyJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsgY2hlY2tGb3JFcnJvciB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgZXh0ZW5zaW9uJ3Mgc3RvcmFnZSBsb2NhbCBBUElcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXh0ZW5zaW9uU3RvcmUge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlzU3VwcG9ydGVkID0gQm9vbGVhbihleHRlbnNpb24uc3RvcmFnZS5sb2NhbCk7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkKSB7XG4gICAgICBsb2cuZXJyb3IoJ1N0b3JhZ2UgbG9jYWwgQVBJIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIG9mIHRoZSBrZXlzIGN1cnJlbnRseSBzYXZlZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICovXG4gIGFzeW5jIGdldCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2dldCgpO1xuICAgIC8vIGV4dGVuc2lvbi5zdG9yYWdlLmxvY2FsIGFsd2F5cyByZXR1cm5zIGFuIG9ialxuICAgIC8vIGlmIHRoZSBvYmplY3QgaXMgZW1wdHksIHRyZWF0IGl0IGFzIHVuZGVmaW5lZFxuICAgIGlmIChpc0VtcHR5KHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUga2V5IGluIGxvY2FsIHN0YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAtIFRoZSBzdGF0ZSB0byBzZXRcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBzZXQoc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0KHN0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBvZiB0aGUga2V5cyBjdXJyZW50bHkgc2F2ZWRcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge09iamVjdH0gdGhlIGtleS12YWx1ZSBtYXAgZnJvbSBsb2NhbCBzdG9yYWdlXG4gICAqL1xuICBfZ2V0KCkge1xuICAgIGNvbnN0IHsgbG9jYWwgfSA9IGV4dGVuc2lvbi5zdG9yYWdlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsb2NhbC5nZXQobnVsbCwgKC8qKiBAdHlwZSB7YW55fSAqLyByZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgZXJyID0gY2hlY2tGb3JFcnJvcigpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBrZXkgaW4gbG9jYWwgc3RhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBrZXkgdG8gc2V0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldChvYmopIHtcbiAgICBjb25zdCB7IGxvY2FsIH0gPSBleHRlbnNpb24uc3RvcmFnZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbG9jYWwuc2V0KG9iaiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnIgPSBjaGVja0ZvckVycm9yKCk7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gb2JqZWN0IGNvbnRhaW5zIG5vIGtleXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuIiwiaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgeyBTRUNPTkQgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RpbWUnO1xuaW1wb3J0IGdldEZldGNoV2l0aFRpbWVvdXQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvZmV0Y2gtd2l0aC10aW1lb3V0JztcblxuY29uc3QgZmV0Y2hXaXRoVGltZW91dCA9IGdldEZldGNoV2l0aFRpbWVvdXQoU0VDT05EICogMzApO1xuXG5jb25zdCBGSVhUVVJFX1NFUlZFUl9IT1NUID0gJ2xvY2FsaG9zdCc7XG5jb25zdCBGSVhUVVJFX1NFUlZFUl9QT1JUID0gMTIzNDU7XG5jb25zdCBGSVhUVVJFX1NFUlZFUl9VUkwgPSBgaHR0cDovLyR7RklYVFVSRV9TRVJWRVJfSE9TVH06JHtGSVhUVVJFX1NFUlZFUl9QT1JUfS9zdGF0ZS5qc29uYDtcblxuLyoqXG4gKiBBIHJlYWQtb25seSBuZXR3b3JrLWJhc2VkIHN0b3JhZ2Ugd3JhcHBlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFkT25seU5ldHdvcmtTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdGlhbGl6aW5nID0gdGhpcy5faW5pdCgpO1xuICAgIHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY2xhcmVzIHRoaXMgc3RvcmUgYXMgY29tcGF0aWJsZSB3aXRoIHRoZSBjdXJyZW50IGJyb3dzZXJcbiAgICovXG4gIGlzU3VwcG9ydGVkID0gdHJ1ZTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYnkgbG9hZGluZyBzdGF0ZSBmcm9tIHRoZSBuZXR3b3JrXG4gICAqL1xuICBhc3luYyBfaW5pdCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhUaW1lb3V0KEZJWFRVUkVfU0VSVkVSX1VSTCk7XG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgRXJyb3IgbG9hZGluZyBuZXR3b3JrIHN0YXRlOiAnJHtlcnJvci5tZXNzYWdlfSdgKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHN0YXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59XG4gICAqL1xuICBhc3luYyBnZXQoKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5faW5pdGlhbGl6aW5nO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHN0YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAtIFRoZSBzdGF0ZSB0byBzZXRcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBzZXQoc3RhdGUpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLl9pbml0aWFsaXppbmc7XG4gICAgfVxuICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gIH1cbn1cbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnc2FmZS1ldmVudC1lbWl0dGVyJztcbmltcG9ydCBFeHRlbnNpb25QbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybXMvZXh0ZW5zaW9uJztcblxuY29uc3QgTk9USUZJQ0FUSU9OX0hFSUdIVCA9IDYyMDtcbmNvbnN0IE5PVElGSUNBVElPTl9XSURUSCA9IDM2MDtcblxuZXhwb3J0IGNvbnN0IE5PVElGSUNBVElPTl9NQU5BR0VSX0VWRU5UUyA9IHtcbiAgUE9QVVBfQ0xPU0VEOiAnb25Qb3B1cENsb3NlZCcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb3RpZmljYXRpb25NYW5hZ2VyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIEEgY29sbGVjdGlvbiBvZiBtZXRob2RzIGZvciBjb250cm9sbGluZyB0aGUgc2hvd2luZyBhbmQgaGlkaW5nIG9mIHRoZSBub3RpZmljYXRpb24gcG9wdXAuXG4gICAqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE5vdGlmaWNhdGlvbk1hbmFnZXJcbiAgICpcbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBsYXRmb3JtID0gbmV3IEV4dGVuc2lvblBsYXRmb3JtKCk7XG4gICAgdGhpcy5wbGF0Zm9ybS5hZGRPblJlbW92ZWRMaXN0ZW5lcih0aGlzLl9vbldpbmRvd0Nsb3NlZC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFaXRoZXIgYnJpbmdzIGFuIGV4aXN0aW5nIE1ldGFNYXNrIG5vdGlmaWNhdGlvbiB3aW5kb3cgaW50byBmb2N1cywgb3IgY3JlYXRlcyBhIG5ldyBub3RpZmljYXRpb24gd2luZG93LiBOZXdcbiAgICogbm90aWZpY2F0aW9uIHdpbmRvd3MgYXJlIGdpdmVuIGEgJ3BvcHVwJyB0eXBlLlxuICAgKlxuICAgKi9cbiAgYXN5bmMgc2hvd1BvcHVwKCkge1xuICAgIGNvbnN0IHBvcHVwID0gYXdhaXQgdGhpcy5fZ2V0UG9wdXAoKTtcblxuICAgIC8vIEJyaW5nIGZvY3VzIHRvIGNocm9tZSBwb3B1cFxuICAgIGlmIChwb3B1cCkge1xuICAgICAgLy8gYnJpbmcgZm9jdXMgdG8gZXhpc3RpbmcgY2hyb21lIHBvcHVwXG4gICAgICBhd2FpdCB0aGlzLnBsYXRmb3JtLmZvY3VzV2luZG93KHBvcHVwLmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgbGV0IHRvcCA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBsYXN0Rm9jdXNlZCA9IGF3YWl0IHRoaXMucGxhdGZvcm0uZ2V0TGFzdEZvY3VzZWRXaW5kb3coKTtcbiAgICAgICAgLy8gUG9zaXRpb24gd2luZG93IGluIHRvcCByaWdodCBjb3JuZXIgb2YgbGFzdEZvY3VzZWQgd2luZG93LlxuICAgICAgICB0b3AgPSBsYXN0Rm9jdXNlZC50b3A7XG4gICAgICAgIGxlZnQgPSBsYXN0Rm9jdXNlZC5sZWZ0ICsgKGxhc3RGb2N1c2VkLndpZHRoIC0gTk9USUZJQ0FUSU9OX1dJRFRIKTtcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBtb3JlIHRoYW4gbGlrZWx5IDAsIGR1ZSB0byBiZWluZ1xuICAgICAgICAvLyBvcGVuZWQgZnJvbSB0aGUgYmFja2dyb3VuZCBjaHJvbWUgcHJvY2VzcyBmb3IgdGhlIGV4dGVuc2lvbiB0aGF0XG4gICAgICAgIC8vIGhhcyBubyBwaHlzaWNhbCBkaW1lbnNpb25zXG4gICAgICAgIGNvbnN0IHsgc2NyZWVuWCwgc2NyZWVuWSwgb3V0ZXJXaWR0aCB9ID0gd2luZG93O1xuICAgICAgICB0b3AgPSBNYXRoLm1heChzY3JlZW5ZLCAwKTtcbiAgICAgICAgbGVmdCA9IE1hdGgubWF4KHNjcmVlblggKyAob3V0ZXJXaWR0aCAtIE5PVElGSUNBVElPTl9XSURUSCksIDApO1xuICAgICAgfVxuXG4gICAgICAvLyBjcmVhdGUgbmV3IG5vdGlmaWNhdGlvbiBwb3B1cFxuICAgICAgY29uc3QgcG9wdXBXaW5kb3cgPSBhd2FpdCB0aGlzLnBsYXRmb3JtLm9wZW5XaW5kb3coe1xuICAgICAgICB1cmw6ICdub3RpZmljYXRpb24uaHRtbCcsXG4gICAgICAgIHR5cGU6ICdwb3B1cCcsXG4gICAgICAgIHdpZHRoOiBOT1RJRklDQVRJT05fV0lEVEgsXG4gICAgICAgIGhlaWdodDogTk9USUZJQ0FUSU9OX0hFSUdIVCxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgdG9wLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEZpcmVmb3ggY3VycmVudGx5IGlnbm9yZXMgbGVmdC90b3AgZm9yIGNyZWF0ZSwgYnV0IGl0IHdvcmtzIGZvciB1cGRhdGVcbiAgICAgIGlmIChwb3B1cFdpbmRvdy5sZWZ0ICE9PSBsZWZ0ICYmIHBvcHVwV2luZG93LnN0YXRlICE9PSAnZnVsbHNjcmVlbicpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wbGF0Zm9ybS51cGRhdGVXaW5kb3dQb3NpdGlvbihwb3B1cFdpbmRvdy5pZCwgbGVmdCwgdG9wKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BvcHVwSWQgPSBwb3B1cFdpbmRvdy5pZDtcbiAgICB9XG4gIH1cblxuICBfb25XaW5kb3dDbG9zZWQod2luZG93SWQpIHtcbiAgICBpZiAod2luZG93SWQgPT09IHRoaXMuX3BvcHVwSWQpIHtcbiAgICAgIHRoaXMuX3BvcHVwSWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmVtaXQoTk9USUZJQ0FUSU9OX01BTkFHRVJfRVZFTlRTLlBPUFVQX0NMT1NFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBhbGwgb3BlbiBNZXRhTWFzayB3aW5kb3dzLCBhbmQgcmV0dXJucyB0aGUgZmlyc3Qgb25lIGl0IGZpbmRzIHRoYXQgaXMgYSBub3RpZmljYXRpb24gd2luZG93IChpLmUuIGhhcyB0aGVcbiAgICogdHlwZSAncG9wdXAnKVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIEEgbm9kZSBzdHlsZSBjYWxsYmFjayB0aGF0IHRvIHdoaWNoIHRoZSBmb3VuZCBub3RpZmljYXRpb24gd2luZG93IHdpbGwgYmUgcGFzc2VkLlxuICAgKlxuICAgKi9cbiAgYXN5bmMgX2dldFBvcHVwKCkge1xuICAgIGNvbnN0IHdpbmRvd3MgPSBhd2FpdCB0aGlzLnBsYXRmb3JtLmdldEFsbFdpbmRvd3MoKTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UG9wdXBJbih3aW5kb3dzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhbiBhcnJheSBvZiB3aW5kb3dzLCByZXR1cm5zIHRoZSAncG9wdXAnIHRoYXQgaGFzIGJlZW4gb3BlbmVkIGJ5IE1ldGFNYXNrLCBvciBudWxsIGlmIG5vIHN1Y2ggd2luZG93IGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gd2luZG93cyAtIEFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBkYXRhIGFib3V0IHRoZSBvcGVuIE1ldGFNYXNrIGV4dGVuc2lvbiB3aW5kb3dzLlxuICAgKlxuICAgKi9cbiAgX2dldFBvcHVwSW4od2luZG93cykge1xuICAgIHJldHVybiB3aW5kb3dzXG4gICAgICA/IHdpbmRvd3MuZmluZCgod2luKSA9PiB7XG4gICAgICAgICAgLy8gUmV0dXJucyBub3RpZmljYXRpb24gcG9wdXBcbiAgICAgICAgICByZXR1cm4gd2luICYmIHdpbi50eXBlID09PSAncG9wdXAnICYmIHdpbi5pZCA9PT0gdGhpcy5fcG9wdXBJZDtcbiAgICAgICAgfSlcbiAgICAgIDogbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgV3JpdGFibGUgYXMgV3JpdGFibGVTdHJlYW0gfSBmcm9tICdyZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHByb21pc2VUb0NhbGxiYWNrIGZyb20gJ3Byb21pc2UtdG8tY2FsbGJhY2snO1xuXG5jbGFzcyBBc3luY1dyaXRhYmxlU3RyZWFtIGV4dGVuZHMgV3JpdGFibGVTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihhc3luY1dyaXRlRm4sIF9vcHRzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHsgb2JqZWN0TW9kZTogdHJ1ZSwgLi4uX29wdHMgfTtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLl9hc3luY1dyaXRlRm4gPSBhc3luY1dyaXRlRm47XG4gIH1cblxuICAvLyB3cml0ZSBmcm9tIGluY29taW5nIHN0cmVhbSB0byBzdGF0ZVxuICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIHByb21pc2VUb0NhbGxiYWNrKHRoaXMuX2FzeW5jV3JpdGVGbihjaHVuaywgZW5jb2RpbmcpKShjYWxsYmFjayk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU3RyZWFtU2luayhhc3luY1dyaXRlRm4sIF9vcHRzKSB7XG4gIHJldHVybiBuZXcgQXN5bmNXcml0YWJsZVN0cmVhbShhc3luY1dyaXRlRm4sIF9vcHRzKTtcbn1cbiIsImltcG9ydCBleHRlbnNpb24gZnJvbSAnZXh0ZW5zaW9uaXplcic7XG5pbXBvcnQgcHJvbWlzaWZ5IGZyb20gJ3BpZnknO1xuaW1wb3J0IGFsbExvY2FsZXMgZnJvbSAnLi4vLi4vX2xvY2FsZXMvaW5kZXguanNvbic7XG5cbmNvbnN0IGdldFByZWZlcnJlZExvY2FsZXMgPSBleHRlbnNpb24uaTE4blxuICA/IHByb21pc2lmeShleHRlbnNpb24uaTE4bi5nZXRBY2NlcHRMYW5ndWFnZXMsIHsgZXJyb3JGaXJzdDogZmFsc2UgfSlcbiAgOiBhc3luYyAoKSA9PiBbXTtcblxuLy8gbWFwcGluZyBzb21lIGJyb3dzZXJzIHJldHVybiBoeXBoZW4gaW5zdGVhZCB1bmRlcnNjb3JlIGluIGxvY2FsZSBjb2RlcyAoZS5nLiB6aF9UVyAtPiB6aC10dylcbmNvbnN0IGV4aXN0aW5nTG9jYWxlQ29kZXMgPSB7fTtcbmFsbExvY2FsZXMuZm9yRWFjaCgobG9jYWxlKSA9PiB7XG4gIGlmIChsb2NhbGUgJiYgbG9jYWxlLmNvZGUpIHtcbiAgICBleGlzdGluZ0xvY2FsZUNvZGVzW2xvY2FsZS5jb2RlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJyldID1cbiAgICAgIGxvY2FsZS5jb2RlO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZmVycmVkIGxhbmd1YWdlIGNvZGUsIGJhc2VkIG9uIHNldHRpbmdzIHdpdGhpbiB0aGUgdXNlcidzIGJyb3dzZXIuIElmIHdlIGhhdmUgbm8gdHJhbnNsYXRpb25zIGZvciB0aGVcbiAqIHVzZXJzIHByZWZlcnJlZCBsb2NhbGVzLCAnZW4nIGlzIHJldHVybmVkLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFByb21pc2VzIGEgbG9jYWxlIGNvZGUsIGVpdGhlciBvbmUgZnJvbSB0aGUgdXNlcidzIHByZWZlcnJlZCBsaXN0IHRoYXQgd2UgaGF2ZSBhIHRyYW5zbGF0aW9uIGZvciwgb3IgJ2VuJ1xuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZ2V0Rmlyc3RQcmVmZXJyZWRMYW5nQ29kZSgpIHtcbiAgbGV0IHVzZXJQcmVmZXJyZWRMb2NhbGVDb2RlcztcblxuICB0cnkge1xuICAgIHVzZXJQcmVmZXJyZWRMb2NhbGVDb2RlcyA9IGF3YWl0IGdldFByZWZlcnJlZExvY2FsZXMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEJyYXZlIGN1cnJlbnRseSB0aHJvd3Mgd2hlbiBjYWxsaW5nIGdldEFjY2VwdExhbmd1YWdlcywgc28gdGhpcyBoYW5kbGVzIHRoYXQuXG4gICAgdXNlclByZWZlcnJlZExvY2FsZUNvZGVzID0gW107XG4gIH1cblxuICAvLyBzYWZlZ3VhcmQgZm9yIEJyYXZlIEJyb3dzZXIgdW50aWwgdGhleSBpbXBsZW1lbnQgY2hyb21lLmkxOG4uZ2V0QWNjZXB0TGFuZ3VhZ2VzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9tZXRhbWFzay1leHRlbnNpb24vaXNzdWVzLzQyNzBcbiAgaWYgKCF1c2VyUHJlZmVycmVkTG9jYWxlQ29kZXMpIHtcbiAgICB1c2VyUHJlZmVycmVkTG9jYWxlQ29kZXMgPSBbXTtcbiAgfVxuXG4gIGxldCBmaXJzdFByZWZlcnJlZExhbmdDb2RlID0gdXNlclByZWZlcnJlZExvY2FsZUNvZGVzXG4gICAgLm1hcCgoY29kZSkgPT4gY29kZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpKVxuICAgIC5maW5kKFxuICAgICAgKGNvZGUpID0+XG4gICAgICAgIGV4aXN0aW5nTG9jYWxlQ29kZXNbY29kZV0gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBleGlzdGluZ0xvY2FsZUNvZGVzW2NvZGUuc3BsaXQoJy0nKVswXV0gIT09IHVuZGVmaW5lZCxcbiAgICApO1xuXG4gIC8vIGlmIHdlIGhhdmUgbWF0Y2hlZCBhZ2FpbnN0IGEgY29kZSB3aXRoIGEgJy0nIHByZXNlbnQsIG1lYW5pbmcgaXRzIGEgcmVnaW9uYWxcbiAgLy8gY29kZSBmb3Igd2hpY2ggd2UgaGF2ZSBhIG5vbi1yZWdpb25lZCBsb2NhbGUsIHdlIG5lZWQgdG8gc2V0IGZpcnN0UHJlZmVycmVkTGFuZ0NvZGVcbiAgLy8gdG8gdGhlIGNvcnJlY3Qgbm9uLXJlZ2lvbmFsIGNvZGUuXG4gIGlmIChcbiAgICBmaXJzdFByZWZlcnJlZExhbmdDb2RlICE9PSB1bmRlZmluZWQgJiZcbiAgICBleGlzdGluZ0xvY2FsZUNvZGVzW2ZpcnN0UHJlZmVycmVkTGFuZ0NvZGVdID09PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgZmlyc3RQcmVmZXJyZWRMYW5nQ29kZSA9IGZpcnN0UHJlZmVycmVkTGFuZ0NvZGUuc3BsaXQoJy0nKVswXTtcbiAgfVxuXG4gIHJldHVybiBleGlzdGluZ0xvY2FsZUNvZGVzW2ZpcnN0UHJlZmVycmVkTGFuZ0NvZGVdIHx8ICdlbic7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FzU3RyZWFtXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Db21wb3NlZFN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Mb2NhbFN0b3JhZ2VTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTWVyZ2VkU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHJhbnNmb3JtXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNaWdyYXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2ZXJzaW9uIC0gVGhlIG1pZ3JhdGlvbiB2ZXJzaW9uXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBtaWdyYXRlIC0gUmV0dXJucyBhIHByb21pc2Ugb2YgdGhlIG1pZ3JhdGVkIGRhdGFcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1pZ3JhdG9yT3B0aW9uc1xuICogQHByb3BlcnR5IHtBcnJheTxNaWdyYXRpb24+fSBbbWlncmF0aW9uc10gLSBUaGUgbGlzdCBvZiBtaWdyYXRpb25zIHRvIGFwcGx5XG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlZmF1bHRWZXJzaW9uXSAtIFRoZSB2ZXJzaW9uIHRvIHVzZSBpbiB0aGUgaW5pdGlhbCBzdGF0ZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1pZ3JhdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge01pZ3JhdG9yT3B0aW9uc30gb3B0c1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBtaWdyYXRpb25zID0gb3B0cy5taWdyYXRpb25zIHx8IFtdO1xuICAgIC8vIHNvcnQgbWlncmF0aW9ucyBieSB2ZXJzaW9uXG4gICAgdGhpcy5taWdyYXRpb25zID0gbWlncmF0aW9ucy5zb3J0KChhLCBiKSA9PiBhLnZlcnNpb24gLSBiLnZlcnNpb24pO1xuICAgIC8vIGdyYWIgbWlncmF0aW9uIHdpdGggaGlnaGVzdCB2ZXJzaW9uXG4gICAgY29uc3QgbGFzdE1pZ3JhdGlvbiA9IHRoaXMubWlncmF0aW9ucy5zbGljZSgtMSlbMF07XG4gICAgLy8gdXNlIHNwZWNpZmllZCBkZWZhdWx0VmVyc2lvbiBvciBoaWdoZXN0IG1pZ3JhdGlvbiB2ZXJzaW9uXG4gICAgdGhpcy5kZWZhdWx0VmVyc2lvbiA9XG4gICAgICBvcHRzLmRlZmF1bHRWZXJzaW9uIHx8IChsYXN0TWlncmF0aW9uICYmIGxhc3RNaWdyYXRpb24udmVyc2lvbikgfHwgMDtcbiAgfVxuXG4gIC8vIHJ1biBhbGwgcGVuZGluZyBtaWdyYXRpb25zIG9uIG1ldGEgaW4gcGxhY2VcbiAgYXN5bmMgbWlncmF0ZURhdGEodmVyc2lvbmVkRGF0YSA9IHRoaXMuZ2VuZXJhdGVJbml0aWFsU3RhdGUoKSkge1xuICAgIC8vIGdldCBhbGwgbWlncmF0aW9ucyB0aGF0IGhhdmUgbm90IHlldCBiZWVuIHJ1blxuICAgIGNvbnN0IHBlbmRpbmdNaWdyYXRpb25zID0gdGhpcy5taWdyYXRpb25zLmZpbHRlcihtaWdyYXRpb25Jc1BlbmRpbmcpO1xuXG4gICAgLy8gcGVyZm9ybSBlYWNoIG1pZ3JhdGlvblxuICAgIGZvciAoY29uc3QgbWlncmF0aW9uIG9mIHBlbmRpbmdNaWdyYXRpb25zKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBhdHRlbXB0IG1pZ3JhdGlvbiBhbmQgdmFsaWRhdGVcbiAgICAgICAgY29uc3QgbWlncmF0ZWREYXRhID0gYXdhaXQgbWlncmF0aW9uLm1pZ3JhdGUodmVyc2lvbmVkRGF0YSk7XG4gICAgICAgIGlmICghbWlncmF0ZWREYXRhLmRhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pZ3JhdG9yIC0gbWlncmF0aW9uIHJldHVybmVkIGVtcHR5IGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgbWlncmF0ZWREYXRhLnZlcnNpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIG1pZ3JhdGVkRGF0YS5tZXRhLnZlcnNpb24gIT09IG1pZ3JhdGlvbi52ZXJzaW9uXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdNaWdyYXRvciAtIE1pZ3JhdGlvbiBkaWQgbm90IHVwZGF0ZSB2ZXJzaW9uIG51bWJlciBjb3JyZWN0bHknLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWNjZXB0IHRoZSBtaWdyYXRpb24gYXMgZ29vZFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdmVyc2lvbmVkRGF0YSA9IG1pZ3JhdGVkRGF0YTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyByZXdyaXRlIGVycm9yIG1lc3NhZ2UgdG8gYWRkIGNvbnRleHQgd2l0aG91dCBjbG9iYmVyaW5nIHN0YWNrXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRXJyb3JNZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgIGVyci5tZXNzYWdlID0gYE1ldGFNYXNrIE1pZ3JhdGlvbiBFcnJvciAjJHttaWdyYXRpb24udmVyc2lvbn06ICR7b3JpZ2luYWxFcnJvck1lc3NhZ2V9YDtcbiAgICAgICAgLy8gZW1pdCBlcnJvciBpbnN0ZWFkIG9mIHRocm93IHNvIGFzIHRvIG5vdCBicmVhayB0aGUgcnVuIChncmFjZWZ1bGx5IGZhaWwpXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAvLyBzdG9wIG1pZ3JhdGluZyBhbmQgdXNlIHN0YXRlIGFzIGlzXG4gICAgICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWlncmF0aW9uIGlzIHBlbmRpbmdcbiAgICAgKlxuICAgICAqIEEgbWlncmF0aW9uIGlzIGNvbnNpZGVyZWQgXCJwZW5kaW5nXCIgaWYgaXQgaGFzIGEgaGlnaGVyXG4gICAgICogdmVyc2lvbiBudW1iZXIgdGhhbiB0aGUgY3VycmVudCB2ZXJzaW9uLlxuICAgICAqIEBwYXJhbSB7TWlncmF0aW9ufSBtaWdyYXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaWdyYXRpb25Jc1BlbmRpbmcobWlncmF0aW9uKSB7XG4gICAgICByZXR1cm4gbWlncmF0aW9uLnZlcnNpb24gPiB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5pdGlhbCBzdGF0ZSBmb3IgdGhlIG1pZ3JhdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gLSBUaGUgZGF0YSBmb3IgdGhlIGluaXRpYWwgc3RhdGVcbiAgICogQHJldHVybnMge3ttZXRhOiB7dmVyc2lvbjogbnVtYmVyfSwgZGF0YTogYW55fX1cbiAgICovXG4gIGdlbmVyYXRlSW5pdGlhbFN0YXRlKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0YToge1xuICAgICAgICB2ZXJzaW9uOiB0aGlzLmRlZmF1bHRWZXJzaW9uLFxuICAgICAgfSxcbiAgICAgIGRhdGEsXG4gICAgfTtcbiAgfVxufVxuIiwiLy8gTWlncmF0aW9ucyBtdXN0IHN0YXJ0IGF0IHZlcnNpb24gMSBvciBsYXRlci5cbi8vIFRoZXkgYXJlIG9iamVjdHMgd2l0aCBhIGB2ZXJzaW9uYCBudW1iZXJcbi8vIGFuZCBhIGBtaWdyYXRlYCBmdW5jdGlvbi5cbi8vXG4vLyBUaGUgYG1pZ3JhdGVgIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBwcmV2aW91c1xuLy8gY29uZmlnIGRhdGEgZm9ybWF0LCBhbmQgcmV0dXJucyB0aGUgbmV3IG9uZS5cblxuaW1wb3J0IG0wMDIgZnJvbSAnLi8wMDInO1xuaW1wb3J0IG0wMDMgZnJvbSAnLi8wMDMnO1xuaW1wb3J0IG0wMDQgZnJvbSAnLi8wMDQnO1xuaW1wb3J0IG0wMDUgZnJvbSAnLi8wMDUnO1xuaW1wb3J0IG0wMDYgZnJvbSAnLi8wMDYnO1xuaW1wb3J0IG0wMDcgZnJvbSAnLi8wMDcnO1xuaW1wb3J0IG0wMDggZnJvbSAnLi8wMDgnO1xuaW1wb3J0IG0wMDkgZnJvbSAnLi8wMDknO1xuaW1wb3J0IG0wMTAgZnJvbSAnLi8wMTAnO1xuaW1wb3J0IG0wMTEgZnJvbSAnLi8wMTEnO1xuaW1wb3J0IG0wMTIgZnJvbSAnLi8wMTInO1xuaW1wb3J0IG0wMTMgZnJvbSAnLi8wMTMnO1xuaW1wb3J0IG0wMTQgZnJvbSAnLi8wMTQnO1xuaW1wb3J0IG0wMTUgZnJvbSAnLi8wMTUnO1xuaW1wb3J0IG0wMTYgZnJvbSAnLi8wMTYnO1xuaW1wb3J0IG0wMTcgZnJvbSAnLi8wMTcnO1xuaW1wb3J0IG0wMTggZnJvbSAnLi8wMTgnO1xuaW1wb3J0IG0wMTkgZnJvbSAnLi8wMTknO1xuaW1wb3J0IG0wMjAgZnJvbSAnLi8wMjAnO1xuaW1wb3J0IG0wMjEgZnJvbSAnLi8wMjEnO1xuaW1wb3J0IG0wMjIgZnJvbSAnLi8wMjInO1xuaW1wb3J0IG0wMjMgZnJvbSAnLi8wMjMnO1xuaW1wb3J0IG0wMjQgZnJvbSAnLi8wMjQnO1xuaW1wb3J0IG0wMjUgZnJvbSAnLi8wMjUnO1xuaW1wb3J0IG0wMjYgZnJvbSAnLi8wMjYnO1xuaW1wb3J0IG0wMjcgZnJvbSAnLi8wMjcnO1xuaW1wb3J0IG0wMjggZnJvbSAnLi8wMjgnO1xuaW1wb3J0IG0wMjkgZnJvbSAnLi8wMjknO1xuaW1wb3J0IG0wMzAgZnJvbSAnLi8wMzAnO1xuaW1wb3J0IG0wMzEgZnJvbSAnLi8wMzEnO1xuaW1wb3J0IG0wMzIgZnJvbSAnLi8wMzInO1xuaW1wb3J0IG0wMzMgZnJvbSAnLi8wMzMnO1xuaW1wb3J0IG0wMzQgZnJvbSAnLi8wMzQnO1xuaW1wb3J0IG0wMzUgZnJvbSAnLi8wMzUnO1xuaW1wb3J0IG0wMzYgZnJvbSAnLi8wMzYnO1xuaW1wb3J0IG0wMzcgZnJvbSAnLi8wMzcnO1xuaW1wb3J0IG0wMzggZnJvbSAnLi8wMzgnO1xuaW1wb3J0IG0wMzkgZnJvbSAnLi8wMzknO1xuaW1wb3J0IG0wNDAgZnJvbSAnLi8wNDAnO1xuaW1wb3J0IG0wNDEgZnJvbSAnLi8wNDEnO1xuaW1wb3J0IG0wNDIgZnJvbSAnLi8wNDInO1xuaW1wb3J0IG0wNDMgZnJvbSAnLi8wNDMnO1xuaW1wb3J0IG0wNDQgZnJvbSAnLi8wNDQnO1xuaW1wb3J0IG0wNDUgZnJvbSAnLi8wNDUnO1xuaW1wb3J0IG0wNDYgZnJvbSAnLi8wNDYnO1xuaW1wb3J0IG0wNDcgZnJvbSAnLi8wNDcnO1xuaW1wb3J0IG0wNDggZnJvbSAnLi8wNDgnO1xuaW1wb3J0IG0wNDkgZnJvbSAnLi8wNDknO1xuaW1wb3J0IG0wNTAgZnJvbSAnLi8wNTAnO1xuaW1wb3J0IG0wNTEgZnJvbSAnLi8wNTEnO1xuaW1wb3J0IG0wNTIgZnJvbSAnLi8wNTInO1xuaW1wb3J0IG0wNTMgZnJvbSAnLi8wNTMnO1xuaW1wb3J0IG0wNTQgZnJvbSAnLi8wNTQnO1xuaW1wb3J0IG0wNTUgZnJvbSAnLi8wNTUnO1xuaW1wb3J0IG0wNTYgZnJvbSAnLi8wNTYnO1xuaW1wb3J0IG0wNTcgZnJvbSAnLi8wNTcnO1xuaW1wb3J0IG0wNTggZnJvbSAnLi8wNTgnO1xuaW1wb3J0IG0wNTkgZnJvbSAnLi8wNTknO1xuaW1wb3J0IG0wNjAgZnJvbSAnLi8wNjAnO1xuaW1wb3J0IG0wNjEgZnJvbSAnLi8wNjEnO1xuaW1wb3J0IG0wNjIgZnJvbSAnLi8wNjInO1xuaW1wb3J0IG0wNjMgZnJvbSAnLi8wNjMnO1xuaW1wb3J0IG0wNjQgZnJvbSAnLi8wNjQnO1xuaW1wb3J0IG0wNjUgZnJvbSAnLi8wNjUnO1xuaW1wb3J0IG0wNjYgZnJvbSAnLi8wNjYnO1xuaW1wb3J0IG0wNjcgZnJvbSAnLi8wNjcnO1xuaW1wb3J0IG0wNjggZnJvbSAnLi8wNjgnO1xuaW1wb3J0IG0wNjkgZnJvbSAnLi8wNjknO1xuXG5jb25zdCBtaWdyYXRpb25zID0gW1xuICBtMDAyLFxuICBtMDAzLFxuICBtMDA0LFxuICBtMDA1LFxuICBtMDA2LFxuICBtMDA3LFxuICBtMDA4LFxuICBtMDA5LFxuICBtMDEwLFxuICBtMDExLFxuICBtMDEyLFxuICBtMDEzLFxuICBtMDE0LFxuICBtMDE1LFxuICBtMDE2LFxuICBtMDE3LFxuICBtMDE4LFxuICBtMDE5LFxuICBtMDIwLFxuICBtMDIxLFxuICBtMDIyLFxuICBtMDIzLFxuICBtMDI0LFxuICBtMDI1LFxuICBtMDI2LFxuICBtMDI3LFxuICBtMDI4LFxuICBtMDI5LFxuICBtMDMwLFxuICBtMDMxLFxuICBtMDMyLFxuICBtMDMzLFxuICBtMDM0LFxuICBtMDM1LFxuICBtMDM2LFxuICBtMDM3LFxuICBtMDM4LFxuICBtMDM5LFxuICBtMDQwLFxuICBtMDQxLFxuICBtMDQyLFxuICBtMDQzLFxuICBtMDQ0LFxuICBtMDQ1LFxuICBtMDQ2LFxuICBtMDQ3LFxuICBtMDQ4LFxuICBtMDQ5LFxuICBtMDUwLFxuICBtMDUxLFxuICBtMDUyLFxuICBtMDUzLFxuICBtMDU0LFxuICBtMDU1LFxuICBtMDU2LFxuICBtMDU3LFxuICBtMDU4LFxuICBtMDU5LFxuICBtMDYwLFxuICBtMDYxLFxuICBtMDYyLFxuICBtMDYzLFxuICBtMDY0LFxuICBtMDY1LFxuICBtMDY2LFxuICBtMDY3LFxuICBtMDY4LFxuICBtMDY5LFxuXTtcblxuZXhwb3J0IGRlZmF1bHQgbWlncmF0aW9ucztcbiIsImltcG9ydCBiYXNlMzJFbmNvZGUgZnJvbSAnYmFzZTMyLWVuY29kZSc7XG5pbXBvcnQgYmFzZTY0IGZyb20gJ2Jhc2U2NC1qcyc7XG5pbXBvcnQgZXh0ZW5zaW9uIGZyb20gJ2V4dGVuc2lvbml6ZXInO1xuaW1wb3J0IHsgU0VDT05EIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90aW1lJztcbmltcG9ydCBnZXRGZXRjaFdpdGhUaW1lb3V0IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2ZldGNoLXdpdGgtdGltZW91dCc7XG5pbXBvcnQgcmVzb2x2ZUVuc1RvSXBmc0NvbnRlbnRJZCBmcm9tICcuL3Jlc29sdmVyJztcblxuY29uc3QgZmV0Y2hXaXRoVGltZW91dCA9IGdldEZldGNoV2l0aFRpbWVvdXQoU0VDT05EICogMzApO1xuXG5jb25zdCBzdXBwb3J0ZWRUb3BMZXZlbERvbWFpbnMgPSBbJ2V0aCddO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cEVuc0lwZnNSZXNvbHZlcih7XG4gIHByb3ZpZGVyLFxuICBnZXRDdXJyZW50Q2hhaW5JZCxcbiAgZ2V0SXBmc0dhdGV3YXksXG59KSB7XG4gIC8vIGluc3RhbGwgbGlzdGVuZXJcbiAgY29uc3QgdXJsUGF0dGVybnMgPSBzdXBwb3J0ZWRUb3BMZXZlbERvbWFpbnMubWFwKCh0bGQpID0+IGAqOi8vKi4ke3RsZH0vKmApO1xuICBleHRlbnNpb24ud2ViUmVxdWVzdC5vbkVycm9yT2NjdXJyZWQuYWRkTGlzdGVuZXIod2ViUmVxdWVzdERpZEZhaWwsIHtcbiAgICB1cmxzOiB1cmxQYXR0ZXJucyxcbiAgICB0eXBlczogWydtYWluX2ZyYW1lJ10sXG4gIH0pO1xuXG4gIC8vIHJldHVybiBhcGkgb2JqZWN0XG4gIHJldHVybiB7XG4gICAgLy8gdW5pbnN0YWxsIGxpc3RlbmVyXG4gICAgcmVtb3ZlKCkge1xuICAgICAgZXh0ZW5zaW9uLndlYlJlcXVlc3Qub25FcnJvck9jY3VycmVkLnJlbW92ZUxpc3RlbmVyKHdlYlJlcXVlc3REaWRGYWlsKTtcbiAgICB9LFxuICB9O1xuXG4gIGFzeW5jIGZ1bmN0aW9uIHdlYlJlcXVlc3REaWRGYWlsKGRldGFpbHMpIHtcbiAgICBjb25zdCB7IHRhYklkLCB1cmwgfSA9IGRldGFpbHM7XG4gICAgLy8gaWdub3JlIHJlcXVlc3RzIHRoYXQgYXJlIG5vdCBhc3NvY2lhdGVkIHdpdGggdGFic1xuICAgIC8vIG9ubHkgYXR0ZW1wdCBFTlMgcmVzb2x1dGlvbiBvbiBtYWlubmV0XG4gICAgaWYgKHRhYklkID09PSAtMSB8fCBnZXRDdXJyZW50Q2hhaW5JZCgpICE9PSAnMHgxJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBwYXJzZSBlbnMgbmFtZVxuICAgIGNvbnN0IHsgaG9zdG5hbWU6IG5hbWUsIHBhdGhuYW1lLCBzZWFyY2gsIGhhc2g6IGZyYWdtZW50IH0gPSBuZXcgVVJMKHVybCk7XG4gICAgY29uc3QgZG9tYWluUGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdG9wTGV2ZWxEb21haW4gPSBkb21haW5QYXJ0c1tkb21haW5QYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAvLyBpZiB1bnN1cHBvcnRlZCBUTEQsIGFib3J0XG4gICAgaWYgKCFzdXBwb3J0ZWRUb3BMZXZlbERvbWFpbnMuaW5jbHVkZXModG9wTGV2ZWxEb21haW4pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSBhdHRlbXB0IHJlc29sdmVcbiAgICBhdHRlbXB0UmVzb2x2ZSh7IHRhYklkLCBuYW1lLCBwYXRobmFtZSwgc2VhcmNoLCBmcmFnbWVudCB9KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGF0dGVtcHRSZXNvbHZlKHsgdGFiSWQsIG5hbWUsIHBhdGhuYW1lLCBzZWFyY2gsIGZyYWdtZW50IH0pIHtcbiAgICBjb25zdCBpcGZzR2F0ZXdheSA9IGdldElwZnNHYXRld2F5KCk7XG5cbiAgICBleHRlbnNpb24udGFicy51cGRhdGUodGFiSWQsIHsgdXJsOiBgbG9hZGluZy5odG1sYCB9KTtcbiAgICBsZXQgdXJsID0gYGh0dHBzOi8vYXBwLmVucy5kb21haW5zL25hbWUvJHtuYW1lfWA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdHlwZSwgaGFzaCB9ID0gYXdhaXQgcmVzb2x2ZUVuc1RvSXBmc0NvbnRlbnRJZCh7XG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBuYW1lLFxuICAgICAgfSk7XG4gICAgICBpZiAodHlwZSA9PT0gJ2lwZnMtbnMnIHx8IHR5cGUgPT09ICdpcG5zLW5zJykge1xuICAgICAgICBjb25zdCByZXNvbHZlZFVybCA9IGBodHRwczovLyR7aGFzaH0uJHt0eXBlLnNsaWNlKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgNCxcbiAgICAgICAgKX0uJHtpcGZzR2F0ZXdheX0ke3BhdGhuYW1lfSR7c2VhcmNoIHx8ICcnfSR7ZnJhZ21lbnQgfHwgJyd9YDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBjaGVjayBpZiBpcGZzIGdhdGV3YXkgaGFzIHJlc3VsdFxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoVGltZW91dChyZXNvbHZlZFVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCcsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICB1cmwgPSByZXNvbHZlZFVybDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzd2FybS1ucycpIHtcbiAgICAgICAgdXJsID0gYGh0dHBzOi8vc3dhcm0tZ2F0ZXdheXMubmV0L2J6ejovJHtoYXNofSR7cGF0aG5hbWV9JHtcbiAgICAgICAgICBzZWFyY2ggfHwgJydcbiAgICAgICAgfSR7ZnJhZ21lbnQgfHwgJyd9YDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29uaW9uJyB8fCB0eXBlID09PSAnb25pb24zJykge1xuICAgICAgICB1cmwgPSBgaHR0cDovLyR7aGFzaH0ub25pb24ke3BhdGhuYW1lfSR7c2VhcmNoIHx8ICcnfSR7ZnJhZ21lbnQgfHwgJyd9YDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3plcm9uZXQnKSB7XG4gICAgICAgIHVybCA9IGBodHRwOi8vMTI3LjAuMC4xOjQzMTEwLyR7aGFzaH0ke3BhdGhuYW1lfSR7c2VhcmNoIHx8ICcnfSR7XG4gICAgICAgICAgZnJhZ21lbnQgfHwgJydcbiAgICAgICAgfWA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdza3luZXQtbnMnKSB7XG4gICAgICAgIGNvbnN0IHBhZGRlZCA9IGhhc2gucGFkRW5kKGhhc2gubGVuZ3RoICsgNCAtIChoYXNoLmxlbmd0aCAlIDQpLCAnPScpO1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gYmFzZTY0LnRvQnl0ZUFycmF5KHBhZGRlZCk7XG5cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgcGFkZGluZzogZmFsc2UgfTtcbiAgICAgICAgY29uc3QgYmFzZTMyRW5jb2RlZFNreWxpbmsgPSBiYXNlMzJFbmNvZGUoXG4gICAgICAgICAgZGVjb2RlZCxcbiAgICAgICAgICAnUkZDNDY0OC1IRVgnLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdXJsID0gYGh0dHBzOi8vJHtiYXNlMzJFbmNvZGVkU2t5bGlua30uc2lhc2t5Lm5ldCR7cGF0aG5hbWV9JHtcbiAgICAgICAgICBzZWFyY2ggfHwgJydcbiAgICAgICAgfSR7ZnJhZ21lbnQgfHwgJyd9YDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHRlbnNpb24udGFicy51cGRhdGUodGFiSWQsIHsgdXJsIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHB1bXAgZnJvbSAncHVtcCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7IHN0b3JlQXNTdHJlYW0gfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvYXNTdHJlYW0nO1xuaW1wb3J0IHsgSnNvblJwY0VuZ2luZSB9IGZyb20gJ2pzb24tcnBjLWVuZ2luZSc7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgY3JlYXRlRW5naW5lU3RyZWFtIGZyb20gJ2pzb24tcnBjLW1pZGRsZXdhcmUtc3RyZWFtL2VuZ2luZVN0cmVhbSc7XG5pbXBvcnQgY3JlYXRlRmlsdGVyTWlkZGxld2FyZSBmcm9tICdldGgtanNvbi1ycGMtZmlsdGVycyc7XG5pbXBvcnQgY3JlYXRlU3Vic2NyaXB0aW9uTWFuYWdlciBmcm9tICdldGgtanNvbi1ycGMtZmlsdGVycy9zdWJzY3JpcHRpb25NYW5hZ2VyJztcbmltcG9ydCB7IHByb3ZpZGVyQXNNaWRkbGV3YXJlIH0gZnJvbSAnZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUnO1xuaW1wb3J0IEtleXJpbmdDb250cm9sbGVyIGZyb20gJ2V0aC1rZXlyaW5nLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgZXJyb3JDb2RlcyBhcyBycGNFcnJvckNvZGVzLCBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgeyBNdXRleCB9IGZyb20gJ2F3YWl0LXNlbWFwaG9yZSc7XG5pbXBvcnQgeyBzdHJpcEhleFByZWZpeCB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBUcmV6b3JLZXlyaW5nIGZyb20gJ2V0aC10cmV6b3Ita2V5cmluZyc7XG5pbXBvcnQgTGVkZ2VyQnJpZGdlS2V5cmluZyBmcm9tICdAbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZyc7XG5pbXBvcnQgTGF0dGljZUtleXJpbmcgZnJvbSAnZXRoLWxhdHRpY2Uta2V5cmluZyc7XG5pbXBvcnQgeyBNZXRhTWFza0tleXJpbmcgYXMgUVJIYXJkd2FyZUtleXJpbmcgfSBmcm9tICdAa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZyc7XG5pbXBvcnQgRXRoUXVlcnkgZnJvbSAnZXRoLXF1ZXJ5JztcbmltcG9ydCBuYW5vaWQgZnJvbSAnbmFub2lkJztcbmltcG9ydCB7IGNhcHR1cmVFeGNlcHRpb24gfSBmcm9tICdAc2VudHJ5L2Jyb3dzZXInO1xuaW1wb3J0IHtcbiAgQWRkcmVzc0Jvb2tDb250cm9sbGVyLFxuICBBcHByb3ZhbENvbnRyb2xsZXIsXG4gIENvbnRyb2xsZXJNZXNzZW5nZXIsXG4gIEN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIsXG4gIFBoaXNoaW5nQ29udHJvbGxlcixcbiAgTm90aWZpY2F0aW9uQ29udHJvbGxlcixcbiAgR2FzRmVlQ29udHJvbGxlcixcbiAgVG9rZW5MaXN0Q29udHJvbGxlcixcbiAgVG9rZW5zQ29udHJvbGxlcixcbiAgVG9rZW5SYXRlc0NvbnRyb2xsZXIsXG4gIENvbGxlY3RpYmxlc0NvbnRyb2xsZXIsXG4gIEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcbiAgQ29sbGVjdGlibGVEZXRlY3Rpb25Db250cm9sbGVyLFxufSBmcm9tICdAbWV0YW1hc2svY29udHJvbGxlcnMnO1xuaW1wb3J0IHtcbiAgUGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIsXG59IGZyb20gJ0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzJztcblxuaW1wb3J0IHsgVFJBTlNBQ1RJT05fU1RBVFVTRVMgfSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7XG4gIEdBU19BUElfQkFTRV9VUkwsXG4gIEdBU19ERVZfQVBJX0JBU0VfVVJMLFxuICBTV0FQU19DTElFTlRfSUQsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvc3dhcHMnO1xuaW1wb3J0IHsgTUFJTk5FVF9DSEFJTl9JRCB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5pbXBvcnQge1xuICBERVZJQ0VfTkFNRVMsXG4gIEtFWVJJTkdfVFlQRVMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvaGFyZHdhcmUtd2FsbGV0cyc7XG5pbXBvcnQge1xuICBDYXZlYXRUeXBlcyxcbiAgUmVzdHJpY3RlZE1ldGhvZHMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvcGVybWlzc2lvbnMnO1xuaW1wb3J0IHsgVUlfTk9USUZJQ0FUSU9OUyB9IGZyb20gJy4uLy4uL3NoYXJlZC9ub3RpZmljYXRpb25zJztcbmltcG9ydCB7IHRvQ2hlY2tzdW1IZXhBZGRyZXNzIH0gZnJvbSAnLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcbmltcG9ydCB7IE1JTExJU0VDT05EIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90aW1lJztcbmltcG9ydCB7XG4gIFBPTExJTkdfVE9LRU5fRU5WSVJPTk1FTlRfVFlQRVMsXG4gIFNVQkpFQ1RfVFlQRVMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcblxuaW1wb3J0IHsgaGV4VG9EZWNpbWFsIH0gZnJvbSAnLi4vLi4vdWkvaGVscGVycy91dGlscy9jb252ZXJzaW9ucy51dGlsJztcbmltcG9ydCBDb21wb3NhYmxlT2JzZXJ2YWJsZVN0b3JlIGZyb20gJy4vbGliL0NvbXBvc2FibGVPYnNlcnZhYmxlU3RvcmUnO1xuaW1wb3J0IEFjY291bnRUcmFja2VyIGZyb20gJy4vbGliL2FjY291bnQtdHJhY2tlcic7XG5pbXBvcnQgY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSBmcm9tICcuL2xpYi9jcmVhdGVMb2dnZXJNaWRkbGV3YXJlJztcbmltcG9ydCBjcmVhdGVNZXRob2RNaWRkbGV3YXJlIGZyb20gJy4vbGliL3JwYy1tZXRob2QtbWlkZGxld2FyZSc7XG5pbXBvcnQgY3JlYXRlT3JpZ2luTWlkZGxld2FyZSBmcm9tICcuL2xpYi9jcmVhdGVPcmlnaW5NaWRkbGV3YXJlJztcbmltcG9ydCBjcmVhdGVUYWJJZE1pZGRsZXdhcmUgZnJvbSAnLi9saWIvY3JlYXRlVGFiSWRNaWRkbGV3YXJlJztcbmltcG9ydCBjcmVhdGVPbmJvYXJkaW5nTWlkZGxld2FyZSBmcm9tICcuL2xpYi9jcmVhdGVPbmJvYXJkaW5nTWlkZGxld2FyZSc7XG5pbXBvcnQgeyBzZXR1cE11bHRpcGxleCB9IGZyb20gJy4vbGliL3N0cmVhbS11dGlscyc7XG5pbXBvcnQgRW5zQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2Vucyc7XG5pbXBvcnQgTmV0d29ya0NvbnRyb2xsZXIsIHsgTkVUV09SS19FVkVOVFMgfSBmcm9tICcuL2NvbnRyb2xsZXJzL25ldHdvcmsnO1xuaW1wb3J0IFByZWZlcmVuY2VzQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL3ByZWZlcmVuY2VzJztcbmltcG9ydCBBcHBTdGF0ZUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy9hcHAtc3RhdGUnO1xuaW1wb3J0IENhY2hlZEJhbGFuY2VzQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2NhY2hlZC1iYWxhbmNlcyc7XG5pbXBvcnQgQWxlcnRDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvYWxlcnQnO1xuaW1wb3J0IE9uYm9hcmRpbmdDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvb25ib2FyZGluZyc7XG5pbXBvcnQgVGhyZWVCb3hDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvdGhyZWVib3gnO1xuaW1wb3J0IEluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2luY29taW5nLXRyYW5zYWN0aW9ucyc7XG5pbXBvcnQgTWVzc2FnZU1hbmFnZXIsIHsgbm9ybWFsaXplTXNnRGF0YSB9IGZyb20gJy4vbGliL21lc3NhZ2UtbWFuYWdlcic7XG5pbXBvcnQgRGVjcnlwdE1lc3NhZ2VNYW5hZ2VyIGZyb20gJy4vbGliL2RlY3J5cHQtbWVzc2FnZS1tYW5hZ2VyJztcbmltcG9ydCBFbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlciBmcm9tICcuL2xpYi9lbmNyeXB0aW9uLXB1YmxpYy1rZXktbWFuYWdlcic7XG5pbXBvcnQgUGVyc29uYWxNZXNzYWdlTWFuYWdlciBmcm9tICcuL2xpYi9wZXJzb25hbC1tZXNzYWdlLW1hbmFnZXInO1xuaW1wb3J0IFR5cGVkTWVzc2FnZU1hbmFnZXIgZnJvbSAnLi9saWIvdHlwZWQtbWVzc2FnZS1tYW5hZ2VyJztcbmltcG9ydCBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy90cmFuc2FjdGlvbnMnO1xuaW1wb3J0IERldGVjdFRva2Vuc0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy9kZXRlY3QtdG9rZW5zJztcbmltcG9ydCBTd2Fwc0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy9zd2Fwcyc7XG5pbXBvcnQgYWNjb3VudEltcG9ydGVyIGZyb20gJy4vYWNjb3VudC1pbXBvcnQtc3RyYXRlZ2llcyc7XG5pbXBvcnQgc2VlZFBocmFzZVZlcmlmaWVyIGZyb20gJy4vbGliL3NlZWQtcGhyYXNlLXZlcmlmaWVyJztcbmltcG9ydCBNZXRhTWV0cmljc0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy9tZXRhbWV0cmljcyc7XG5pbXBvcnQgeyBzZWdtZW50IH0gZnJvbSAnLi9saWIvc2VnbWVudCc7XG5pbXBvcnQgY3JlYXRlTWV0YVJQQ0hhbmRsZXIgZnJvbSAnLi9saWIvY3JlYXRlTWV0YVJQQ0hhbmRsZXInO1xuaW1wb3J0IHtcbiAgQ2F2ZWF0TXV0YXRvckZhY3RvcmllcyxcbiAgZ2V0Q2F2ZWF0U3BlY2lmaWNhdGlvbnMsXG4gIGdldENoYW5nZWRBY2NvdW50cyxcbiAgZ2V0UGVybWlzc2lvbkJhY2tncm91bmRBcGlNZXRob2RzLFxuICBnZXRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMsXG4gIGdldFBlcm1pdHRlZEFjY291bnRzQnlPcmlnaW4sXG4gIFBlcm1pc3Npb25Mb2dDb250cm9sbGVyLFxuICBOT1RJRklDQVRJT05fTkFNRVMsXG4gIHVucmVzdHJpY3RlZE1ldGhvZHMsXG59IGZyb20gJy4vY29udHJvbGxlcnMvcGVybWlzc2lvbnMnO1xuXG5leHBvcnQgY29uc3QgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMgPSB7XG4gIC8vIEZpcmVkIGFmdGVyIHN0YXRlIGNoYW5nZXMgdGhhdCBpbXBhY3QgdGhlIGV4dGVuc2lvbiBiYWRnZSAodW5hcHByb3ZlZCBtc2cgY291bnQpXG4gIC8vIFRoZSBwcm9jZXNzIG9mIHVwZGF0aW5nIHRoZSBiYWRnZSBoYXBwZW5zIGluIGFwcC9zY3JpcHRzL2JhY2tncm91bmQuanMuXG4gIFVQREFURV9CQURHRTogJ3VwZGF0ZUJhZGdlJyxcbiAgLy8gVE9ETzogQWRkIHRoaXMgYW5kIHNpbWlsYXIgZW51bXMgdG8gQG1ldGFtYXNrL2NvbnRyb2xsZXJzIGFuZCBleHBvcnQgdGhlbVxuICBBUFBST1ZBTF9TVEFURV9DSEFOR0U6ICdBcHByb3ZhbENvbnRyb2xsZXI6c3RhdGVDaGFuZ2UnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWV0YW1hc2tDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAyMDtcblxuICAgIHRoaXMuc2VuZFVwZGF0ZSA9IGRlYm91bmNlKFxuICAgICAgdGhpcy5wcml2YXRlU2VuZFVwZGF0ZS5iaW5kKHRoaXMpLFxuICAgICAgTUlMTElTRUNPTkQgKiAyMDAsXG4gICAgKTtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIHRoaXMuZXh0ZW5zaW9uID0gb3B0cy5leHRlbnNpb247XG4gICAgdGhpcy5wbGF0Zm9ybSA9IG9wdHMucGxhdGZvcm07XG4gICAgY29uc3QgaW5pdFN0YXRlID0gb3B0cy5pbml0U3RhdGUgfHwge307XG4gICAgY29uc3QgdmVyc2lvbiA9IHRoaXMucGxhdGZvcm0uZ2V0VmVyc2lvbigpO1xuICAgIHRoaXMucmVjb3JkRmlyc3RUaW1lSW5mbyhpbml0U3RhdGUpO1xuXG4gICAgLy8gdGhpcyBrZWVwcyB0cmFjayBvZiBob3cgbWFueSBcImNvbnRyb2xsZXJTdHJlYW1cIiBjb25uZWN0aW9ucyBhcmUgb3BlblxuICAgIC8vIHRoZSBvbmx5IHRoaW5nIHRoYXQgdXNlcyBjb250cm9sbGVyIGNvbm5lY3Rpb25zIGFyZSBvcGVuIG1ldGFtYXNrIFVJIGluc3RhbmNlc1xuICAgIHRoaXMuYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zID0gMDtcblxuICAgIHRoaXMuZ2V0UmVxdWVzdEFjY291bnRUYWJJZHMgPSBvcHRzLmdldFJlcXVlc3RBY2NvdW50VGFiSWRzO1xuICAgIHRoaXMuZ2V0T3Blbk1ldGFtYXNrVGFic0lkcyA9IG9wdHMuZ2V0T3Blbk1ldGFtYXNrVGFic0lkcztcblxuICAgIHRoaXMuY29udHJvbGxlck1lc3NlbmdlciA9IG5ldyBDb250cm9sbGVyTWVzc2VuZ2VyKCk7XG5cbiAgICAvLyBvYnNlcnZhYmxlIHN0YXRlIHN0b3JlXG4gICAgdGhpcy5zdG9yZSA9IG5ldyBDb21wb3NhYmxlT2JzZXJ2YWJsZVN0b3JlKHtcbiAgICAgIHN0YXRlOiBpbml0U3RhdGUsXG4gICAgICBjb250cm9sbGVyTWVzc2VuZ2VyOiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIsXG4gICAgICBwZXJzaXN0OiB0cnVlLFxuICAgIH0pO1xuXG4gICAgLy8gZXh0ZXJuYWwgY29ubmVjdGlvbnMgYnkgb3JpZ2luXG4gICAgLy8gRG8gbm90IG1vZGlmeSBkaXJlY3RseS4gVXNlIHRoZSBhc3NvY2lhdGVkIG1ldGhvZHMuXG4gICAgdGhpcy5jb25uZWN0aW9ucyA9IHt9O1xuXG4gICAgLy8gbG9jayB0byBlbnN1cmUgb25seSBvbmUgdmF1bHQgY3JlYXRlZCBhdCBvbmNlXG4gICAgdGhpcy5jcmVhdGVWYXVsdE11dGV4ID0gbmV3IE11dGV4KCk7XG5cbiAgICB0aGlzLmV4dGVuc2lvbi5ydW50aW1lLm9uSW5zdGFsbGVkLmFkZExpc3RlbmVyKChkZXRhaWxzKSA9PiB7XG4gICAgICBpZiAoZGV0YWlscy5yZWFzb24gPT09ICd1cGRhdGUnICYmIHZlcnNpb24gPT09ICc4LjEuMCcpIHtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybS5vcGVuRXh0ZW5zaW9uSW5Ccm93c2VyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBuZXh0LCB3ZSB3aWxsIGluaXRpYWxpemUgdGhlIGNvbnRyb2xsZXJzXG4gICAgLy8gY29udHJvbGxlciBpbml0aWFsaXphdGlvbiBvcmRlciBtYXR0ZXJzXG5cbiAgICB0aGlzLmFwcHJvdmFsQ29udHJvbGxlciA9IG5ldyBBcHByb3ZhbENvbnRyb2xsZXIoe1xuICAgICAgbWVzc2VuZ2VyOiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XG4gICAgICAgIG5hbWU6ICdBcHByb3ZhbENvbnRyb2xsZXInLFxuICAgICAgfSksXG4gICAgICBzaG93QXBwcm92YWxSZXF1ZXN0OiBvcHRzLnNob3dVc2VyQ29uZmlybWF0aW9uLFxuICAgIH0pO1xuXG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlciA9IG5ldyBOZXR3b3JrQ29udHJvbGxlcihpbml0U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIpO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc2V0SW5mdXJhUHJvamVjdElkKG9wdHMuaW5mdXJhUHJvamVjdElkKTtcblxuICAgIC8vIG5vdyB3ZSBjYW4gaW5pdGlhbGl6ZSB0aGUgUlBDIHByb3ZpZGVyLCB3aGljaCBvdGhlciBjb250cm9sbGVycyByZXF1aXJlXG4gICAgdGhpcy5pbml0aWFsaXplUHJvdmlkZXIoKTtcbiAgICB0aGlzLnByb3ZpZGVyID0gdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRQcm92aWRlckFuZEJsb2NrVHJhY2tlcigpLnByb3ZpZGVyO1xuICAgIHRoaXMuYmxvY2tUcmFja2VyID0gdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRQcm92aWRlckFuZEJsb2NrVHJhY2tlcigpLmJsb2NrVHJhY2tlcjtcblxuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyID0gbmV3IFByZWZlcmVuY2VzQ29udHJvbGxlcih7XG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICBpbml0TGFuZ0NvZGU6IG9wdHMuaW5pdExhbmdDb2RlLFxuICAgICAgb3BlblBvcHVwOiBvcHRzLm9wZW5Qb3B1cCxcbiAgICAgIG5ldHdvcms6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIG1pZ3JhdGVBZGRyZXNzQm9va1N0YXRlOiB0aGlzLm1pZ3JhdGVBZGRyZXNzQm9va1N0YXRlLmJpbmQodGhpcyksXG4gICAgfSk7XG5cbiAgICB0aGlzLnRva2Vuc0NvbnRyb2xsZXIgPSBuZXcgVG9rZW5zQ29udHJvbGxlcih7XG4gICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2U6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZS5iaW5kKFxuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICksXG4gICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICksXG4gICAgICBjb25maWc6IHsgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIgfSxcbiAgICAgIHN0YXRlOiBpbml0U3RhdGUuVG9rZW5zQ29udHJvbGxlcixcbiAgICB9KTtcblxuICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyID0gbmV3IEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcih7XG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICB9KTtcblxuICAgIHRoaXMuY29sbGVjdGlibGVzQ29udHJvbGxlciA9IG5ldyBDb2xsZWN0aWJsZXNDb250cm9sbGVyKFxuICAgICAge1xuICAgICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2U6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZS5iaW5kKFxuICAgICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICApLFxuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUuYmluZChcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICApLFxuICAgICAgICBnZXRBc3NldE5hbWU6IHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldEFzc2V0TmFtZS5iaW5kKFxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgICBnZXRBc3NldFN5bWJvbDogdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0QXNzZXRTeW1ib2wuYmluZChcbiAgICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgZ2V0Q29sbGVjdGlibGVUb2tlblVSSTogdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0Q29sbGVjdGlibGVUb2tlblVSSS5iaW5kKFxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgICBnZXRPd25lck9mOiB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5nZXRPd25lck9mLmJpbmQoXG4gICAgICAgICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIGJhbGFuY2VPZkVSQzExNTVDb2xsZWN0aWJsZTogdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIuYmFsYW5jZU9mRVJDMTE1NUNvbGxlY3RpYmxlLmJpbmQoXG4gICAgICAgICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIHVyaUVSQzExNTVDb2xsZWN0aWJsZTogdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIudXJpRVJDMTE1NUNvbGxlY3RpYmxlLmJpbmQoXG4gICAgICAgICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICB9LFxuICAgICAge30sXG4gICAgICBpbml0U3RhdGUuQ29sbGVjdGlibGVzQ29udHJvbGxlcixcbiAgICApO1xuXG4gICAgcHJvY2Vzcy5lbnYuQ09MTEVDVElCTEVTX1YxICYmXG4gICAgICAodGhpcy5jb2xsZWN0aWJsZURldGVjdGlvbkNvbnRyb2xsZXIgPSBuZXcgQ29sbGVjdGlibGVEZXRlY3Rpb25Db250cm9sbGVyKFxuICAgICAgICB7XG4gICAgICAgICAgb25Db2xsZWN0aWJsZXNTdGF0ZUNoYW5nZTogKGxpc3RlbmVyKSA9PlxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aWJsZXNDb250cm9sbGVyLnN1YnNjcmliZShsaXN0ZW5lciksXG4gICAgICAgICAgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUuYmluZChcbiAgICAgICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICAgICksXG4gICAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlLmJpbmQoXG4gICAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICAgICksXG4gICAgICAgICAgZ2V0T3BlblNlYUFwaUtleTogKCkgPT4gdGhpcy5jb2xsZWN0aWJsZXNDb250cm9sbGVyLm9wZW5TZWFBcGlLZXksXG4gICAgICAgICAgZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGw6IHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldEJhbGFuY2VzSW5TaW5nbGVDYWxsLmJpbmQoXG4gICAgICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcbiAgICAgICAgICApLFxuICAgICAgICAgIGFkZENvbGxlY3RpYmxlOiB0aGlzLmNvbGxlY3RpYmxlc0NvbnRyb2xsZXIuYWRkQ29sbGVjdGlibGUuYmluZChcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlibGVzQ29udHJvbGxlcixcbiAgICAgICAgICApLFxuICAgICAgICAgIGdldENvbGxlY3RpYmxlc1N0YXRlOiAoKSA9PiB0aGlzLmNvbGxlY3RpYmxlc0NvbnRyb2xsZXIuc3RhdGUsXG4gICAgICAgIH0sXG4gICAgICApKTtcblxuICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyID0gbmV3IE1ldGFNZXRyaWNzQ29udHJvbGxlcih7XG4gICAgICBzZWdtZW50LFxuICAgICAgcHJlZmVyZW5jZXNTdG9yZTogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBvbk5ldHdvcmtEaWRDaGFuZ2U6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIub24uYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICAgTkVUV09SS19FVkVOVFMuTkVUV09SS19ESURfQ0hBTkdFLFxuICAgICAgKSxcbiAgICAgIGdldE5ldHdvcmtJZGVudGlmaWVyOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldE5ldHdvcmtJZGVudGlmaWVyLmJpbmQoXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgZ2V0Q3VycmVudENoYWluSWQ6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0Q3VycmVudENoYWluSWQuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICB2ZXJzaW9uOiB0aGlzLnBsYXRmb3JtLmdldFZlcnNpb24oKSxcbiAgICAgIGVudmlyb25tZW50OiBwcm9jZXNzLmVudi5NRVRBTUFTS19FTlZJUk9OTUVOVCxcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgIGNhcHR1cmVFeGNlcHRpb24sXG4gICAgfSk7XG5cbiAgICBjb25zdCBnYXNGZWVNZXNzZW5nZXIgPSB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XG4gICAgICBuYW1lOiAnR2FzRmVlQ29udHJvbGxlcicsXG4gICAgfSk7XG5cbiAgICBjb25zdCBnYXNBcGlCYXNlVXJsID0gcHJvY2Vzcy5lbnYuU1dBUFNfVVNFX0RFVl9BUElTXG4gICAgICA/IEdBU19ERVZfQVBJX0JBU0VfVVJMXG4gICAgICA6IEdBU19BUElfQkFTRV9VUkw7XG5cbiAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIgPSBuZXcgR2FzRmVlQ29udHJvbGxlcih7XG4gICAgICBpbnRlcnZhbDogMTAwMDAsXG4gICAgICBtZXNzZW5nZXI6IGdhc0ZlZU1lc3NlbmdlcixcbiAgICAgIGNsaWVudElkOiBTV0FQU19DTElFTlRfSUQsXG4gICAgICBnZXRQcm92aWRlcjogKCkgPT5cbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRQcm92aWRlckFuZEJsb2NrVHJhY2tlcigpLnByb3ZpZGVyLFxuICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIub24uYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICAgTkVUV09SS19FVkVOVFMuTkVUV09SS19ESURfQ0hBTkdFLFxuICAgICAgKSxcbiAgICAgIGdldEN1cnJlbnROZXR3b3JrRUlQMTU1OUNvbXBhdGliaWxpdHk6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBnZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5OiB0aGlzLmdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHkuYmluZChcbiAgICAgICAgdGhpcyxcbiAgICAgICksXG4gICAgICBsZWdhY3lBUElFbmRwb2ludDogYCR7Z2FzQXBpQmFzZVVybH0vbmV0d29ya3MvPGNoYWluX2lkPi9nYXNQcmljZXNgLFxuICAgICAgRUlQMTU1OUFQSUVuZHBvaW50OiBgJHtnYXNBcGlCYXNlVXJsfS9uZXR3b3Jrcy88Y2hhaW5faWQ+L3N1Z2dlc3RlZEdhc0ZlZXNgLFxuICAgICAgZ2V0Q3VycmVudE5ldHdvcmtMZWdhY3lHYXNBUElDb21wYXRpYmlsaXR5OiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVudi5JTl9URVNUIHx8IGNoYWluSWQgPT09IE1BSU5ORVRfQ0hBSU5fSUQ7XG4gICAgICB9LFxuICAgICAgZ2V0Q2hhaW5JZDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuSU5fVEVTVFxuICAgICAgICAgID8gTUFJTk5FVF9DSEFJTl9JRFxuICAgICAgICAgIDogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRDdXJyZW50Q2hhaW5JZCgpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMucXJIYXJkd2FyZUtleXJpbmcgPSBuZXcgUVJIYXJkd2FyZUtleXJpbmcoKTtcblxuICAgIHRoaXMuYXBwU3RhdGVDb250cm9sbGVyID0gbmV3IEFwcFN0YXRlQ29udHJvbGxlcih7XG4gICAgICBhZGRVbmxvY2tMaXN0ZW5lcjogdGhpcy5vbi5iaW5kKHRoaXMsICd1bmxvY2snKSxcbiAgICAgIGlzVW5sb2NrZWQ6IHRoaXMuaXNVbmxvY2tlZC5iaW5kKHRoaXMpLFxuICAgICAgaW5pdFN0YXRlOiBpbml0U3RhdGUuQXBwU3RhdGVDb250cm9sbGVyLFxuICAgICAgb25JbmFjdGl2ZVRpbWVvdXQ6ICgpID0+IHRoaXMuc2V0TG9ja2VkKCksXG4gICAgICBzaG93VW5sb2NrUmVxdWVzdDogb3B0cy5zaG93VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIHByZWZlcmVuY2VzU3RvcmU6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxuICAgICAgcXJIYXJkd2FyZVN0b3JlOiB0aGlzLnFySGFyZHdhcmVLZXlyaW5nLmdldE1lbVN0b3JlKCksXG4gICAgfSk7XG5cbiAgICBjb25zdCBjdXJyZW5jeVJhdGVNZXNzZW5nZXIgPSB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XG4gICAgICBuYW1lOiAnQ3VycmVuY3lSYXRlQ29udHJvbGxlcicsXG4gICAgfSk7XG4gICAgdGhpcy5jdXJyZW5jeVJhdGVDb250cm9sbGVyID0gbmV3IEN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIoe1xuICAgICAgaW5jbHVkZVVTRFJhdGU6IHRydWUsXG4gICAgICBtZXNzZW5nZXI6IGN1cnJlbmN5UmF0ZU1lc3NlbmdlcixcbiAgICAgIHN0YXRlOiBpbml0U3RhdGUuQ3VycmVuY3lDb250cm9sbGVyLFxuICAgIH0pO1xuXG4gICAgY29uc3QgdG9rZW5MaXN0TWVzc2VuZ2VyID0gdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLmdldFJlc3RyaWN0ZWQoe1xuICAgICAgbmFtZTogJ1Rva2VuTGlzdENvbnRyb2xsZXInLFxuICAgIH0pO1xuICAgIHRoaXMudG9rZW5MaXN0Q29udHJvbGxlciA9IG5ldyBUb2tlbkxpc3RDb250cm9sbGVyKHtcbiAgICAgIGNoYWluSWQ6IGhleFRvRGVjaW1hbCh0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkKCkpLFxuICAgICAgdXNlU3RhdGljVG9rZW5MaXN0OiAhdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKVxuICAgICAgICAudXNlVG9rZW5EZXRlY3Rpb24sXG4gICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogKGNiKSA9PlxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZSgobmV0d29ya1N0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgbW9kaWZpZWROZXR3b3JrU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5uZXR3b3JrU3RhdGUsXG4gICAgICAgICAgICBwcm92aWRlcjoge1xuICAgICAgICAgICAgICAuLi5uZXR3b3JrU3RhdGUucHJvdmlkZXIsXG4gICAgICAgICAgICAgIGNoYWluSWQ6IGhleFRvRGVjaW1hbChuZXR3b3JrU3RhdGUucHJvdmlkZXIuY2hhaW5JZCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGNiKG1vZGlmaWVkTmV0d29ya1N0YXRlKTtcbiAgICAgICAgfSksXG4gICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2U6IChjYikgPT5cbiAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlKChwcmVmZXJlbmNlc1N0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgbW9kaWZpZWRQcmVmZXJlbmNlc1N0YXRlID0ge1xuICAgICAgICAgICAgLi4ucHJlZmVyZW5jZXNTdGF0ZSxcbiAgICAgICAgICAgIHVzZVN0YXRpY1Rva2VuTGlzdDogIXRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgLnVzZVRva2VuRGV0ZWN0aW9uLFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGNiKG1vZGlmaWVkUHJlZmVyZW5jZXNTdGF0ZSk7XG4gICAgICAgIH0pLFxuICAgICAgbWVzc2VuZ2VyOiB0b2tlbkxpc3RNZXNzZW5nZXIsXG4gICAgICBzdGF0ZTogaW5pdFN0YXRlLlRva2VuTGlzdENvbnRyb2xsZXIsXG4gICAgfSk7XG5cbiAgICB0aGlzLnBoaXNoaW5nQ29udHJvbGxlciA9IG5ldyBQaGlzaGluZ0NvbnRyb2xsZXIoKTtcblxuICAgIHRoaXMubm90aWZpY2F0aW9uQ29udHJvbGxlciA9IG5ldyBOb3RpZmljYXRpb25Db250cm9sbGVyKFxuICAgICAgeyBhbGxOb3RpZmljYXRpb25zOiBVSV9OT1RJRklDQVRJT05TIH0sXG4gICAgICBpbml0U3RhdGUuTm90aWZpY2F0aW9uQ29udHJvbGxlcixcbiAgICApO1xuXG4gICAgLy8gdG9rZW4gZXhjaGFuZ2UgcmF0ZSB0cmFja2VyXG4gICAgdGhpcy50b2tlblJhdGVzQ29udHJvbGxlciA9IG5ldyBUb2tlblJhdGVzQ29udHJvbGxlcih7XG4gICAgICBvblRva2Vuc1N0YXRlQ2hhbmdlOiAobGlzdGVuZXIpID0+XG4gICAgICAgIHRoaXMudG9rZW5zQ29udHJvbGxlci5zdWJzY3JpYmUobGlzdGVuZXIpLFxuICAgICAgb25DdXJyZW5jeVJhdGVTdGF0ZUNoYW5nZTogKGxpc3RlbmVyKSA9PlxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuc3Vic2NyaWJlKFxuICAgICAgICAgIGAke3RoaXMuY3VycmVuY3lSYXRlQ29udHJvbGxlci5uYW1lfTpzdGF0ZUNoYW5nZWAsXG4gICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICksXG4gICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogKGNiKSA9PlxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZSgobmV0d29ya1N0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgbW9kaWZpZWROZXR3b3JrU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5uZXR3b3JrU3RhdGUsXG4gICAgICAgICAgICBwcm92aWRlcjoge1xuICAgICAgICAgICAgICAuLi5uZXR3b3JrU3RhdGUucHJvdmlkZXIsXG4gICAgICAgICAgICAgIGNoYWluSWQ6IGhleFRvRGVjaW1hbChuZXR3b3JrU3RhdGUucHJvdmlkZXIuY2hhaW5JZCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGNiKG1vZGlmaWVkTmV0d29ya1N0YXRlKTtcbiAgICAgICAgfSksXG4gICAgfSk7XG5cbiAgICB0aGlzLmVuc0NvbnRyb2xsZXIgPSBuZXcgRW5zQ29udHJvbGxlcih7XG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkLmJpbmQoXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgb25OZXR3b3JrRGlkQ2hhbmdlOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLm9uLmJpbmQoXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICAgIE5FVFdPUktfRVZFTlRTLk5FVFdPUktfRElEX0NIQU5HRSxcbiAgICAgICksXG4gICAgfSk7XG5cbiAgICB0aGlzLmluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlciA9IG5ldyBJbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIoe1xuICAgICAgYmxvY2tUcmFja2VyOiB0aGlzLmJsb2NrVHJhY2tlcixcbiAgICAgIG9uTmV0d29ya0RpZENoYW5nZTogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5vbi5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgICBORVRXT1JLX0VWRU5UUy5ORVRXT1JLX0RJRF9DSEFOR0UsXG4gICAgICApLFxuICAgICAgZ2V0Q3VycmVudENoYWluSWQ6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0Q3VycmVudENoYWluSWQuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgaW5pdFN0YXRlOiBpbml0U3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgIH0pO1xuXG4gICAgLy8gYWNjb3VudCB0cmFja2VyIHdhdGNoZXMgYmFsYW5jZXMsIG5vbmNlcywgYW5kIGFueSBjb2RlIGF0IHRoZWlyIGFkZHJlc3NcbiAgICB0aGlzLmFjY291bnRUcmFja2VyID0gbmV3IEFjY291bnRUcmFja2VyKHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgYmxvY2tUcmFja2VyOiB0aGlzLmJsb2NrVHJhY2tlcixcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkLmJpbmQoXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgIH0pO1xuXG4gICAgLy8gc3RhcnQgYW5kIHN0b3AgcG9sbGluZyBmb3IgYmFsYW5jZXMgYmFzZWQgb24gYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zXG4gICAgdGhpcy5vbignY29udHJvbGxlckNvbm5lY3Rpb25DaGFuZ2VkJywgKGFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucykgPT4ge1xuICAgICAgaWYgKGFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucyA+IDApIHtcbiAgICAgICAgdGhpcy5hY2NvdW50VHJhY2tlci5zdGFydCgpO1xuICAgICAgICB0aGlzLmluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlci5zdGFydCgpO1xuICAgICAgICB0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIuc3RhcnQoKTtcbiAgICAgICAgdGhpcy50b2tlbkxpc3RDb250cm9sbGVyLnN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFjY291bnRUcmFja2VyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5pbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLnRva2VuTGlzdENvbnRyb2xsZXIuc3RvcCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5jYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIgPSBuZXcgQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyKHtcbiAgICAgIGFjY291bnRUcmFja2VyOiB0aGlzLmFjY291bnRUcmFja2VyLFxuICAgICAgZ2V0Q3VycmVudENoYWluSWQ6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0Q3VycmVudENoYWluSWQuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5DYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIsXG4gICAgfSk7XG5cbiAgICB0aGlzLm9uYm9hcmRpbmdDb250cm9sbGVyID0gbmV3IE9uYm9hcmRpbmdDb250cm9sbGVyKHtcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLk9uYm9hcmRpbmdDb250cm9sbGVyLFxuICAgIH0pO1xuXG4gICAgdGhpcy50b2tlbnNDb250cm9sbGVyLmh1Yi5vbigncGVuZGluZ1N1Z2dlc3RlZEFzc2V0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgb3B0cy5vcGVuUG9wdXAoKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGFkZGl0aW9uYWxLZXlyaW5ncyA9IFtcbiAgICAgIFRyZXpvcktleXJpbmcsXG4gICAgICBMZWRnZXJCcmlkZ2VLZXlyaW5nLFxuICAgICAgTGF0dGljZUtleXJpbmcsXG4gICAgICBRUkhhcmR3YXJlS2V5cmluZyxcbiAgICBdO1xuICAgIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIgPSBuZXcgS2V5cmluZ0NvbnRyb2xsZXIoe1xuICAgICAga2V5cmluZ1R5cGVzOiBhZGRpdGlvbmFsS2V5cmluZ3MsXG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5LZXlyaW5nQ29udHJvbGxlcixcbiAgICAgIGVuY3J5cHRvcjogb3B0cy5lbmNyeXB0b3IgfHwgdW5kZWZpbmVkLFxuICAgIH0pO1xuICAgIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIubWVtU3RvcmUuc3Vic2NyaWJlKChzdGF0ZSkgPT5cbiAgICAgIHRoaXMuX29uS2V5cmluZ0NvbnRyb2xsZXJVcGRhdGUoc3RhdGUpLFxuICAgICk7XG4gICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5vbigndW5sb2NrJywgKCkgPT4gdGhpcy5fb25VbmxvY2soKSk7XG4gICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5vbignbG9jaycsICgpID0+IHRoaXMuX29uTG9jaygpKTtcblxuICAgIGNvbnN0IGdldElkZW50aXRpZXMgPSAoKSA9PlxuICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5pZGVudGl0aWVzO1xuXG4gICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlciA9IG5ldyBQZXJtaXNzaW9uQ29udHJvbGxlcih7XG4gICAgICBtZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcbiAgICAgICAgbmFtZTogJ1Blcm1pc3Npb25Db250cm9sbGVyJyxcbiAgICAgICAgYWxsb3dlZEFjdGlvbnM6IFtcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTphZGRSZXF1ZXN0YCxcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTpoYXNSZXF1ZXN0YCxcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTphY2NlcHRSZXF1ZXN0YCxcbiAgICAgICAgICBgJHt0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5uYW1lfTpyZWplY3RSZXF1ZXN0YCxcbiAgICAgICAgXSxcbiAgICAgIH0pLFxuICAgICAgc3RhdGU6IGluaXRTdGF0ZS5QZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgICAgIGNhdmVhdFNwZWNpZmljYXRpb25zOiBnZXRDYXZlYXRTcGVjaWZpY2F0aW9ucyh7IGdldElkZW50aXRpZXMgfSksXG4gICAgICBwZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnM6IGdldFBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucyh7XG4gICAgICAgIGdldElkZW50aXRpZXMsXG4gICAgICAgIGdldEFsbEFjY291bnRzOiB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzLmJpbmQoXG4gICAgICAgICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgIH0pLFxuICAgICAgdW5yZXN0cmljdGVkTWV0aG9kcyxcbiAgICB9KTtcblxuICAgIHRoaXMucGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIgPSBuZXcgUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIoe1xuICAgICAgcmVzdHJpY3RlZE1ldGhvZHM6IG5ldyBTZXQoT2JqZWN0LmtleXMoUmVzdHJpY3RlZE1ldGhvZHMpKSxcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLlBlcm1pc3Npb25Mb2dDb250cm9sbGVyLFxuICAgIH0pO1xuXG4gICAgdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyID0gbmV3IFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIoe1xuICAgICAgbWVzc2VuZ2VyOiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XG4gICAgICAgIG5hbWU6ICdTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyJyxcbiAgICAgICAgYWxsb3dlZEFjdGlvbnM6IFtgJHt0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLm5hbWV9Omhhc1Blcm1pc3Npb25zYF0sXG4gICAgICB9KSxcbiAgICAgIHN0YXRlOiBpbml0U3RhdGUuU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcixcbiAgICAgIHN1YmplY3RDYWNoZUxpbWl0OiAxMDAsXG4gICAgfSk7XG5cbiAgICB0aGlzLmRldGVjdFRva2Vuc0NvbnRyb2xsZXIgPSBuZXcgRGV0ZWN0VG9rZW5zQ29udHJvbGxlcih7XG4gICAgICBwcmVmZXJlbmNlczogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICB0b2tlbnNDb250cm9sbGVyOiB0aGlzLnRva2Vuc0NvbnRyb2xsZXIsXG4gICAgICBuZXR3b3JrOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAga2V5cmluZ01lbVN0b3JlOiB0aGlzLmtleXJpbmdDb250cm9sbGVyLm1lbVN0b3JlLFxuICAgICAgdG9rZW5MaXN0OiB0aGlzLnRva2VuTGlzdENvbnRyb2xsZXIsXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlciA9IG5ldyBBZGRyZXNzQm9va0NvbnRyb2xsZXIoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBpbml0U3RhdGUuQWRkcmVzc0Jvb2tDb250cm9sbGVyLFxuICAgICk7XG5cbiAgICB0aGlzLmFsZXJ0Q29udHJvbGxlciA9IG5ldyBBbGVydENvbnRyb2xsZXIoe1xuICAgICAgaW5pdFN0YXRlOiBpbml0U3RhdGUuQWxlcnRDb250cm9sbGVyLFxuICAgICAgcHJlZmVyZW5jZXNTdG9yZTogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgfSk7XG5cbiAgICB0aGlzLnRocmVlQm94Q29udHJvbGxlciA9IG5ldyBUaHJlZUJveENvbnRyb2xsZXIoe1xuICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgIGFkZHJlc3NCb29rQ29udHJvbGxlcjogdGhpcy5hZGRyZXNzQm9va0NvbnRyb2xsZXIsXG4gICAgICBrZXlyaW5nQ29udHJvbGxlcjogdGhpcy5rZXlyaW5nQ29udHJvbGxlcixcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLlRocmVlQm94Q29udHJvbGxlcixcbiAgICAgIGdldEtleXJpbmdDb250cm9sbGVyU3RhdGU6IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIubWVtU3RvcmUuZ2V0U3RhdGUuYmluZChcbiAgICAgICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5tZW1TdG9yZSxcbiAgICAgICksXG4gICAgICB2ZXJzaW9uLFxuICAgICAgdHJhY2tNZXRhTWV0cmljc0V2ZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICB9KTtcblxuICAgIHRoaXMudHhDb250cm9sbGVyID0gbmV3IFRyYW5zYWN0aW9uQ29udHJvbGxlcih7XG4gICAgICBpbml0U3RhdGU6XG4gICAgICAgIGluaXRTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIgfHwgaW5pdFN0YXRlLlRyYW5zYWN0aW9uTWFuYWdlcixcbiAgICAgIGdldFBlcm1pdHRlZEFjY291bnRzOiB0aGlzLmdldFBlcm1pdHRlZEFjY291bnRzLmJpbmQodGhpcyksXG4gICAgICBnZXRQcm92aWRlckNvbmZpZzogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRQcm92aWRlckNvbmZpZy5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGdldEN1cnJlbnROZXR3b3JrRUlQMTU1OUNvbXBhdGliaWxpdHk6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBnZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5OiB0aGlzLmdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHkuYmluZChcbiAgICAgICAgdGhpcyxcbiAgICAgICksXG4gICAgICBuZXR3b3JrU3RvcmU6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIubmV0d29ya1N0b3JlLFxuICAgICAgZ2V0Q3VycmVudENoYWluSWQ6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0Q3VycmVudENoYWluSWQuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBwcmVmZXJlbmNlc1N0b3JlOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIHR4SGlzdG9yeUxpbWl0OiA0MCxcbiAgICAgIHNpZ25UcmFuc2FjdGlvbjogdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zaWduVHJhbnNhY3Rpb24uYmluZChcbiAgICAgICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIGJsb2NrVHJhY2tlcjogdGhpcy5ibG9ja1RyYWNrZXIsXG4gICAgICB0cmFja01ldGFNZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgZ2V0UGFydGljaXBhdGVJbk1ldHJpY3M6ICgpID0+XG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnN0YXRlLnBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcyxcbiAgICAgIGdldEVJUDE1NTlHYXNGZWVFc3RpbWF0ZXM6IHRoaXMuZ2FzRmVlQ29udHJvbGxlci5mZXRjaEdhc0ZlZUVzdGltYXRlcy5iaW5kKFxuICAgICAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgIH0pO1xuICAgIHRoaXMudHhDb250cm9sbGVyLm9uKCduZXdVbmFwcHJvdmVkVHgnLCAoKSA9PiBvcHRzLnNob3dVc2VyQ29uZmlybWF0aW9uKCkpO1xuXG4gICAgdGhpcy50eENvbnRyb2xsZXIub24oYHR4OnN0YXR1cy11cGRhdGVgLCBhc3luYyAodHhJZCwgc3RhdHVzKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXR1cyA9PT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuQ09ORklSTUVEIHx8XG4gICAgICAgIHN0YXR1cyA9PT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuRkFJTEVEXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgdHhNZXRhID0gdGhpcy50eENvbnRyb2xsZXIudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG4gICAgICAgIGNvbnN0IGZyZXF1ZW50UnBjTGlzdERldGFpbCA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldEZyZXF1ZW50UnBjTGlzdERldGFpbCgpO1xuICAgICAgICBsZXQgcnBjUHJlZnMgPSB7fTtcbiAgICAgICAgaWYgKHR4TWV0YS5jaGFpbklkKSB7XG4gICAgICAgICAgY29uc3QgcnBjU2V0dGluZ3MgPSBmcmVxdWVudFJwY0xpc3REZXRhaWwuZmluZChcbiAgICAgICAgICAgIChycGMpID0+IHR4TWV0YS5jaGFpbklkID09PSBycGMuY2hhaW5JZCxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJwY1ByZWZzID0gcnBjU2V0dGluZ3M/LnJwY1ByZWZzID8/IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxhdGZvcm0uc2hvd1RyYW5zYWN0aW9uTm90aWZpY2F0aW9uKHR4TWV0YSwgcnBjUHJlZnMpO1xuXG4gICAgICAgIGNvbnN0IHsgdHhSZWNlaXB0IH0gPSB0eE1ldGE7XG4gICAgICAgIGNvbnN0IG1ldGFtYXNrU3RhdGUgPSBhd2FpdCB0aGlzLmdldFN0YXRlKCk7XG5cbiAgICAgICAgaWYgKHR4UmVjZWlwdCAmJiB0eFJlY2VpcHQuc3RhdHVzID09PSAnMHgwJykge1xuICAgICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGV2ZW50OiAnVHggU3RhdHVzIFVwZGF0ZTogT24tQ2hhaW4gRmFpbHVyZScsXG4gICAgICAgICAgICAgIGNhdGVnb3J5OiAnQmFja2dyb3VuZCcsXG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdUcmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZTogdHhNZXRhLnNpbXVsYXRpb25GYWlscz8ucmVhc29uLFxuICAgICAgICAgICAgICAgIG51bWJlck9mVG9rZW5zOiBtZXRhbWFza1N0YXRlLnRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZBY2NvdW50czogT2JqZWN0LmtleXMobWV0YW1hc2tTdGF0ZS5hY2NvdW50cykubGVuZ3RoLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWF0b21vRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIub24oTkVUV09SS19FVkVOVFMuTkVUV09SS19ESURfQ0hBTkdFLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHRpY2tlciB9ID0gdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRQcm92aWRlckNvbmZpZygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5jdXJyZW5jeVJhdGVDb250cm9sbGVyLnNldE5hdGl2ZUN1cnJlbmN5KHRpY2tlcik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUT0RPOiBIYW5kbGUgZmFpbHVyZSB0byBnZXQgY29udmVyc2lvbiByYXRlIG1vcmUgZ3JhY2VmdWxseVxuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIubG9va3VwTmV0d29yaygpO1xuICAgIHRoaXMubWVzc2FnZU1hbmFnZXIgPSBuZXcgTWVzc2FnZU1hbmFnZXIoe1xuICAgICAgbWV0cmljc0V2ZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICB9KTtcbiAgICB0aGlzLnBlcnNvbmFsTWVzc2FnZU1hbmFnZXIgPSBuZXcgUGVyc29uYWxNZXNzYWdlTWFuYWdlcih7XG4gICAgICBtZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgIH0pO1xuICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyID0gbmV3IERlY3J5cHRNZXNzYWdlTWFuYWdlcih7XG4gICAgICBtZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgIH0pO1xuICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleU1hbmFnZXIgPSBuZXcgRW5jcnlwdGlvblB1YmxpY0tleU1hbmFnZXIoe1xuICAgICAgbWV0cmljc0V2ZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICB9KTtcbiAgICB0aGlzLnR5cGVkTWVzc2FnZU1hbmFnZXIgPSBuZXcgVHlwZWRNZXNzYWdlTWFuYWdlcih7XG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRDdXJyZW50Q2hhaW5JZC5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIG1ldHJpY3NFdmVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgfSk7XG5cbiAgICB0aGlzLnN3YXBzQ29udHJvbGxlciA9IG5ldyBTd2Fwc0NvbnRyb2xsZXIoe1xuICAgICAgZ2V0QnVmZmVyZWRHYXNMaW1pdDogdGhpcy50eENvbnRyb2xsZXIudHhHYXNVdGlsLmdldEJ1ZmZlcmVkR2FzTGltaXQuYmluZChcbiAgICAgICAgdGhpcy50eENvbnRyb2xsZXIudHhHYXNVdGlsLFxuICAgICAgKSxcbiAgICAgIG5ldHdvcmtDb250cm9sbGVyOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICBnZXRQcm92aWRlckNvbmZpZzogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRQcm92aWRlckNvbmZpZy5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGdldFRva2VuUmF0ZXNTdGF0ZTogKCkgPT4gdGhpcy50b2tlblJhdGVzQ29udHJvbGxlci5zdGF0ZSxcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkLmJpbmQoXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgZ2V0RUlQMTU1OUdhc0ZlZUVzdGltYXRlczogdGhpcy5nYXNGZWVDb250cm9sbGVyLmZldGNoR2FzRmVlRXN0aW1hdGVzLmJpbmQoXG4gICAgICAgIHRoaXMuZ2FzRmVlQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgfSk7XG5cbiAgICAvLyBlbnN1cmUgYWNjb3VudFRyYWNrZXIgdXBkYXRlcyBiYWxhbmNlcyBhZnRlciBuZXR3b3JrIGNoYW5nZVxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIub24oTkVUV09SS19FVkVOVFMuTkVUV09SS19ESURfQ0hBTkdFLCAoKSA9PiB7XG4gICAgICB0aGlzLmFjY291bnRUcmFja2VyLl91cGRhdGVBY2NvdW50cygpO1xuICAgIH0pO1xuXG4gICAgLy8gY2xlYXIgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnMgYW5kIG1lc3NhZ2VzIHdoZW4gdGhlIG5ldHdvcmsgd2lsbCBjaGFuZ2VcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLm9uKE5FVFdPUktfRVZFTlRTLk5FVFdPUktfV0lMTF9DSEFOR0UsICgpID0+IHtcbiAgICAgIHRoaXMudHhDb250cm9sbGVyLnR4U3RhdGVNYW5hZ2VyLmNsZWFyVW5hcHByb3ZlZFR4cygpO1xuICAgICAgdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlci5jbGVhclVuYXBwcm92ZWQoKTtcbiAgICAgIHRoaXMucGVyc29uYWxNZXNzYWdlTWFuYWdlci5jbGVhclVuYXBwcm92ZWQoKTtcbiAgICAgIHRoaXMudHlwZWRNZXNzYWdlTWFuYWdlci5jbGVhclVuYXBwcm92ZWQoKTtcbiAgICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyLmNsZWFyVW5hcHByb3ZlZCgpO1xuICAgICAgdGhpcy5tZXNzYWdlTWFuYWdlci5jbGVhclVuYXBwcm92ZWQoKTtcbiAgICB9KTtcblxuICAgIC8vIGVuc3VyZSBpc0NsaWVudE9wZW5BbmRVbmxvY2tlZCBpcyB1cGRhdGVkIHdoZW4gbWVtU3RhdGUgdXBkYXRlc1xuICAgIHRoaXMub24oJ3VwZGF0ZScsIChtZW1TdGF0ZSkgPT4gdGhpcy5fb25TdGF0ZVVwZGF0ZShtZW1TdGF0ZSkpO1xuXG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdHJ1Y3R1cmUoe1xuICAgICAgQXBwU3RhdGVDb250cm9sbGVyOiB0aGlzLmFwcFN0YXRlQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIFRyYW5zYWN0aW9uQ29udHJvbGxlcjogdGhpcy50eENvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBLZXlyaW5nQ29udHJvbGxlcjogdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIFByZWZlcmVuY2VzQ29udHJvbGxlcjogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBNZXRhTWV0cmljc0NvbnRyb2xsZXI6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnN0b3JlLFxuICAgICAgQWRkcmVzc0Jvb2tDb250cm9sbGVyOiB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlcixcbiAgICAgIEN1cnJlbmN5Q29udHJvbGxlcjogdGhpcy5jdXJyZW5jeVJhdGVDb250cm9sbGVyLFxuICAgICAgTmV0d29ya0NvbnRyb2xsZXI6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXI6IHRoaXMuY2FjaGVkQmFsYW5jZXNDb250cm9sbGVyLnN0b3JlLFxuICAgICAgQWxlcnRDb250cm9sbGVyOiB0aGlzLmFsZXJ0Q29udHJvbGxlci5zdG9yZSxcbiAgICAgIE9uYm9hcmRpbmdDb250cm9sbGVyOiB0aGlzLm9uYm9hcmRpbmdDb250cm9sbGVyLnN0b3JlLFxuICAgICAgSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyOiB0aGlzLmluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIFBlcm1pc3Npb25Db250cm9sbGVyOiB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLFxuICAgICAgUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXI6IHRoaXMucGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyOiB0aGlzLnN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIsXG4gICAgICBUaHJlZUJveENvbnRyb2xsZXI6IHRoaXMudGhyZWVCb3hDb250cm9sbGVyLnN0b3JlLFxuICAgICAgTm90aWZpY2F0aW9uQ29udHJvbGxlcjogdGhpcy5ub3RpZmljYXRpb25Db250cm9sbGVyLFxuICAgICAgR2FzRmVlQ29udHJvbGxlcjogdGhpcy5nYXNGZWVDb250cm9sbGVyLFxuICAgICAgVG9rZW5MaXN0Q29udHJvbGxlcjogdGhpcy50b2tlbkxpc3RDb250cm9sbGVyLFxuICAgICAgVG9rZW5zQ29udHJvbGxlcjogdGhpcy50b2tlbnNDb250cm9sbGVyLFxuICAgICAgQ29sbGVjdGlibGVzQ29udHJvbGxlcjogdGhpcy5jb2xsZWN0aWJsZXNDb250cm9sbGVyLFxuICAgIH0pO1xuXG4gICAgdGhpcy5tZW1TdG9yZSA9IG5ldyBDb21wb3NhYmxlT2JzZXJ2YWJsZVN0b3JlKHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBBcHBTdGF0ZUNvbnRyb2xsZXI6IHRoaXMuYXBwU3RhdGVDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICBOZXR3b3JrQ29udHJvbGxlcjogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgQWNjb3VudFRyYWNrZXI6IHRoaXMuYWNjb3VudFRyYWNrZXIuc3RvcmUsXG4gICAgICAgIFR4Q29udHJvbGxlcjogdGhpcy50eENvbnRyb2xsZXIubWVtU3RvcmUsXG4gICAgICAgIENhY2hlZEJhbGFuY2VzQ29udHJvbGxlcjogdGhpcy5jYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgIFRva2VuUmF0ZXNDb250cm9sbGVyOiB0aGlzLnRva2VuUmF0ZXNDb250cm9sbGVyLFxuICAgICAgICBNZXNzYWdlTWFuYWdlcjogdGhpcy5tZXNzYWdlTWFuYWdlci5tZW1TdG9yZSxcbiAgICAgICAgUGVyc29uYWxNZXNzYWdlTWFuYWdlcjogdGhpcy5wZXJzb25hbE1lc3NhZ2VNYW5hZ2VyLm1lbVN0b3JlLFxuICAgICAgICBEZWNyeXB0TWVzc2FnZU1hbmFnZXI6IHRoaXMuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyLm1lbVN0b3JlLFxuICAgICAgICBFbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlcjogdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlci5tZW1TdG9yZSxcbiAgICAgICAgVHlwZXNNZXNzYWdlTWFuYWdlcjogdGhpcy50eXBlZE1lc3NhZ2VNYW5hZ2VyLm1lbVN0b3JlLFxuICAgICAgICBLZXlyaW5nQ29udHJvbGxlcjogdGhpcy5rZXlyaW5nQ29udHJvbGxlci5tZW1TdG9yZSxcbiAgICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgTWV0YU1ldHJpY3NDb250cm9sbGVyOiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgQWRkcmVzc0Jvb2tDb250cm9sbGVyOiB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlcixcbiAgICAgICAgQ3VycmVuY3lDb250cm9sbGVyOiB0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIsXG4gICAgICAgIEFsZXJ0Q29udHJvbGxlcjogdGhpcy5hbGVydENvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgIE9uYm9hcmRpbmdDb250cm9sbGVyOiB0aGlzLm9uYm9hcmRpbmdDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICBJbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXI6IHRoaXMuaW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXG4gICAgICAgICAgLnN0b3JlLFxuICAgICAgICBQZXJtaXNzaW9uQ29udHJvbGxlcjogdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgICAgICAgUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXI6IHRoaXMucGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXI6IHRoaXMuc3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcixcbiAgICAgICAgVGhyZWVCb3hDb250cm9sbGVyOiB0aGlzLnRocmVlQm94Q29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgU3dhcHNDb250cm9sbGVyOiB0aGlzLnN3YXBzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgRW5zQ29udHJvbGxlcjogdGhpcy5lbnNDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICBBcHByb3ZhbENvbnRyb2xsZXI6IHRoaXMuYXBwcm92YWxDb250cm9sbGVyLFxuICAgICAgICBOb3RpZmljYXRpb25Db250cm9sbGVyOiB0aGlzLm5vdGlmaWNhdGlvbkNvbnRyb2xsZXIsXG4gICAgICAgIEdhc0ZlZUNvbnRyb2xsZXI6IHRoaXMuZ2FzRmVlQ29udHJvbGxlcixcbiAgICAgICAgVG9rZW5MaXN0Q29udHJvbGxlcjogdGhpcy50b2tlbkxpc3RDb250cm9sbGVyLFxuICAgICAgICBUb2tlbnNDb250cm9sbGVyOiB0aGlzLnRva2Vuc0NvbnRyb2xsZXIsXG4gICAgICAgIENvbGxlY3RpYmxlc0NvbnRyb2xsZXI6IHRoaXMuY29sbGVjdGlibGVzQ29udHJvbGxlcixcbiAgICAgIH0sXG4gICAgICBjb250cm9sbGVyTWVzc2VuZ2VyOiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIsXG4gICAgfSk7XG4gICAgdGhpcy5tZW1TdG9yZS5zdWJzY3JpYmUodGhpcy5zZW5kVXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgY29uc3QgcGFzc3dvcmQgPSBwcm9jZXNzLmVudi5DT05GPy5QQVNTV09SRDtcbiAgICBpZiAoXG4gICAgICBwYXNzd29yZCAmJlxuICAgICAgIXRoaXMuaXNVbmxvY2tlZCgpICYmXG4gICAgICB0aGlzLm9uYm9hcmRpbmdDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkuY29tcGxldGVkT25ib2FyZGluZ1xuICAgICkge1xuICAgICAgdGhpcy5zdWJtaXRQYXNzd29yZChwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgLy8gTGF6aWx5IHVwZGF0ZSB0aGUgc3RvcmUgd2l0aCB0aGUgY3VycmVudCBleHRlbnNpb24gZW52aXJvbm1lbnRcbiAgICB0aGlzLmV4dGVuc2lvbi5ydW50aW1lLmdldFBsYXRmb3JtSW5mbygoeyBvcyB9KSA9PiB7XG4gICAgICB0aGlzLmFwcFN0YXRlQ29udHJvbGxlci5zZXRCcm93c2VyRW52aXJvbm1lbnQoXG4gICAgICAgIG9zLFxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBwcmVzZW50bHkgb25seSBzdXBwb3J0ZWQgYnkgRmlyZWZveFxuICAgICAgICB0aGlzLmV4dGVuc2lvbi5ydW50aW1lLmdldEJyb3dzZXJJbmZvID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/ICdjaHJvbWUnXG4gICAgICAgICAgOiAnZmlyZWZveCcsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zZXR1cENvbnRyb2xsZXJFdmVudFN1YnNjcmlwdGlvbnMoKTtcblxuICAgIC8vIFRPRE86TGVnYWN5UHJvdmlkZXI6IERlbGV0ZVxuICAgIHRoaXMucHVibGljQ29uZmlnU3RvcmUgPSB0aGlzLmNyZWF0ZVB1YmxpY0NvbmZpZ1N0b3JlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCBCYXNlQ29udHJvbGxlciBWMiBldmVudCBzdWJzY3JpcHRpb25zLiBDdXJyZW50bHksIHRoaXMgaW5jbHVkZXNcbiAgICogdGhlIHN1YnNjcmlwdGlvbnMgbmVjZXNzYXJ5IHRvIG5vdGlmeSBwZXJtaXNzaW9uIHN1YmplY3RzIG9mIGFjY291bnRcbiAgICogY2hhbmdlcy5cbiAgICpcbiAgICogU29tZSBvZiB0aGUgc3Vic2NyaXB0aW9ucyBpbiB0aGlzIG1ldGhvZCBhcmUgQ29udHJvbGxlck1lc3NlbmdlciBzZWxlY3RvclxuICAgKiBldmVudCBzdWJzY3JpcHRpb25zLiBTZWUgdGhlIHJlbGV2YW50IEBtZXRhbWFzay9jb250cm9sbGVycyBkb2N1bWVudGF0aW9uXG4gICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgYWNjb3VudC1yZWxhdGVkIG5vdGlmaWNhdGlvbnMgZW1pdHRlZCB3aGVuIHRoZSBleHRlbnNpb25cbiAgICogYmVjb21lcyB1bmxvY2tlZCBhcmUgaGFuZGxlZCBpbiBNZXRhTWFza0NvbnRyb2xsZXIuX29uVW5sb2NrLlxuICAgKi9cbiAgc2V0dXBDb250cm9sbGVyRXZlbnRTdWJzY3JpcHRpb25zKCkge1xuICAgIGNvbnN0IGhhbmRsZUFjY291bnRzQ2hhbmdlID0gYXN5bmMgKG9yaWdpbiwgbmV3QWNjb3VudHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVW5sb2NrZWQoKSkge1xuICAgICAgICB0aGlzLm5vdGlmeUNvbm5lY3Rpb25zKG9yaWdpbiwge1xuICAgICAgICAgIG1ldGhvZDogTk9USUZJQ0FUSU9OX05BTUVTLmFjY291bnRzQ2hhbmdlZCxcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGBldGhfYWNjb3VudHNgLFxuICAgICAgICAgIC8vIG5hbWVseSBhbiBhcnJheSBvZiB0aGUgY3VycmVudCAvIG1vc3QgcmVjZW50bHkgc2VsZWN0ZWQgRXRoZXJldW1cbiAgICAgICAgICAvLyBhY2NvdW50LlxuICAgICAgICAgIHBhcmFtczpcbiAgICAgICAgICAgIG5ld0FjY291bnRzLmxlbmd0aCA8IDJcbiAgICAgICAgICAgICAgPyAvLyBJZiB0aGUgbGVuZ3RoIGlzIDEgb3IgMCwgdGhlIGFjY291bnRzIGFyZSBzb3J0ZWQgYnkgZGVmaW5pdGlvbi5cbiAgICAgICAgICAgICAgICBuZXdBY2NvdW50c1xuICAgICAgICAgICAgICA6IC8vIElmIHRoZSBsZW5ndGggaXMgMiBvciBncmVhdGVyLCB3ZSBoYXZlIHRvIGV4ZWN1dGVcbiAgICAgICAgICAgICAgICAvLyBgZXRoX2FjY291bnRzYCB2aSB0aGlzIG1ldGhvZC5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdldFBlcm1pdHRlZEFjY291bnRzKG9yaWdpbiksXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBlcm1pc3Npb25Mb2dDb250cm9sbGVyLnVwZGF0ZUFjY291bnRzSGlzdG9yeShvcmlnaW4sIG5ld0FjY291bnRzKTtcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBoYW5kbGVzIGFjY291bnQgY2hhbmdlcyB3aGVuZXZlciB0aGUgc2VsZWN0ZWQgYWRkcmVzcyBjaGFuZ2VzLlxuICAgIGxldCBsYXN0U2VsZWN0ZWRBZGRyZXNzO1xuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZShhc3luYyAoeyBzZWxlY3RlZEFkZHJlc3MgfSkgPT4ge1xuICAgICAgaWYgKHNlbGVjdGVkQWRkcmVzcyAmJiBzZWxlY3RlZEFkZHJlc3MgIT09IGxhc3RTZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgbGFzdFNlbGVjdGVkQWRkcmVzcyA9IHNlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgY29uc3QgcGVybWl0dGVkQWNjb3VudHNNYXAgPSBnZXRQZXJtaXR0ZWRBY2NvdW50c0J5T3JpZ2luKFxuICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIuc3RhdGUsXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yIChjb25zdCBbb3JpZ2luLCBhY2NvdW50c10gb2YgcGVybWl0dGVkQWNjb3VudHNNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgaWYgKGFjY291bnRzLmluY2x1ZGVzKHNlbGVjdGVkQWRkcmVzcykpIHtcbiAgICAgICAgICAgIGhhbmRsZUFjY291bnRzQ2hhbmdlKG9yaWdpbiwgYWNjb3VudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVGhpcyBoYW5kbGVzIGFjY291bnQgY2hhbmdlcyBldmVyeSB0aW1lIHJlbGV2YW50IHBlcm1pc3Npb24gc3RhdGVcbiAgICAvLyBjaGFuZ2VzLCBmb3IgYW55IHJlYXNvbi5cbiAgICB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuc3Vic2NyaWJlKFxuICAgICAgYCR7dGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5uYW1lfTpzdGF0ZUNoYW5nZWAsXG4gICAgICBhc3luYyAoY3VycmVudFZhbHVlLCBwcmV2aW91c1ZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYW5nZWRBY2NvdW50cyA9IGdldENoYW5nZWRBY2NvdW50cyhjdXJyZW50VmFsdWUsIHByZXZpb3VzVmFsdWUpO1xuXG4gICAgICAgIGZvciAoY29uc3QgW29yaWdpbiwgYWNjb3VudHNdIG9mIGNoYW5nZWRBY2NvdW50cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBoYW5kbGVBY2NvdW50c0NoYW5nZShvcmlnaW4sIGFjY291bnRzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldFBlcm1pdHRlZEFjY291bnRzQnlPcmlnaW4sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBoZWxwZXI6IGluaXRpYWxpemUgYSBwcm92aWRlci5cbiAgICovXG4gIGluaXRpYWxpemVQcm92aWRlcigpIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5wbGF0Zm9ybS5nZXRWZXJzaW9uKCk7XG4gICAgY29uc3QgcHJvdmlkZXJPcHRzID0ge1xuICAgICAgc3RhdGljOiB7XG4gICAgICAgIGV0aF9zeW5jaW5nOiBmYWxzZSxcbiAgICAgICAgd2ViM19jbGllbnRWZXJzaW9uOiBgTWV0YU1hc2svdiR7dmVyc2lvbn1gLFxuICAgICAgfSxcbiAgICAgIHZlcnNpb24sXG4gICAgICAvLyBhY2NvdW50IG1nbXRcbiAgICAgIGdldEFjY291bnRzOiBhc3luYyAoeyBvcmlnaW4gfSkgPT4ge1xuICAgICAgICBpZiAob3JpZ2luID09PSAnbWV0YW1hc2snKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWRBZGRyZXNzID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0U2VsZWN0ZWRBZGRyZXNzKCk7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkQWRkcmVzcyA/IFtzZWxlY3RlZEFkZHJlc3NdIDogW107XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1VubG9ja2VkKCkpIHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRQZXJtaXR0ZWRBY2NvdW50cyhvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTsgLy8gY2hhbmdpbmcgdGhpcyBpcyBhIGJyZWFraW5nIGNoYW5nZVxuICAgICAgfSxcbiAgICAgIC8vIHR4IHNpZ25pbmdcbiAgICAgIHByb2Nlc3NUcmFuc2FjdGlvbjogdGhpcy5uZXdVbmFwcHJvdmVkVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgIC8vIG1zZyBzaWduaW5nXG4gICAgICBwcm9jZXNzRXRoU2lnbk1lc3NhZ2U6IHRoaXMubmV3VW5zaWduZWRNZXNzYWdlLmJpbmQodGhpcyksXG4gICAgICBwcm9jZXNzVHlwZWRNZXNzYWdlOiB0aGlzLm5ld1Vuc2lnbmVkVHlwZWRNZXNzYWdlLmJpbmQodGhpcyksXG4gICAgICBwcm9jZXNzVHlwZWRNZXNzYWdlVjM6IHRoaXMubmV3VW5zaWduZWRUeXBlZE1lc3NhZ2UuYmluZCh0aGlzKSxcbiAgICAgIHByb2Nlc3NUeXBlZE1lc3NhZ2VWNDogdGhpcy5uZXdVbnNpZ25lZFR5cGVkTWVzc2FnZS5iaW5kKHRoaXMpLFxuICAgICAgcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZTogdGhpcy5uZXdVbnNpZ25lZFBlcnNvbmFsTWVzc2FnZS5iaW5kKHRoaXMpLFxuICAgICAgcHJvY2Vzc0RlY3J5cHRNZXNzYWdlOiB0aGlzLm5ld1JlcXVlc3REZWNyeXB0TWVzc2FnZS5iaW5kKHRoaXMpLFxuICAgICAgcHJvY2Vzc0VuY3J5cHRpb25QdWJsaWNLZXk6IHRoaXMubmV3UmVxdWVzdEVuY3J5cHRpb25QdWJsaWNLZXkuYmluZCh0aGlzKSxcbiAgICAgIGdldFBlbmRpbmdOb25jZTogdGhpcy5nZXRQZW5kaW5nTm9uY2UuYmluZCh0aGlzKSxcbiAgICAgIGdldFBlbmRpbmdUcmFuc2FjdGlvbkJ5SGFzaDogKGhhc2gpID0+XG4gICAgICAgIHRoaXMudHhDb250cm9sbGVyLmdldFRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgc2VhcmNoQ3JpdGVyaWE6IHtcbiAgICAgICAgICAgIGhhc2gsXG4gICAgICAgICAgICBzdGF0dXM6IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVswXSxcbiAgICB9O1xuICAgIGNvbnN0IHByb3ZpZGVyUHJveHkgPSB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmluaXRpYWxpemVQcm92aWRlcihcbiAgICAgIHByb3ZpZGVyT3B0cyxcbiAgICApO1xuICAgIHJldHVybiBwcm92aWRlclByb3h5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86TGVnYWN5UHJvdmlkZXI6IERlbGV0ZVxuICAgKiBDb25zdHJ1Y3RvciBoZWxwZXI6IGluaXRpYWxpemUgYSBwdWJsaWMgY29uZmlnIHN0b3JlLlxuICAgKiBUaGlzIHN0b3JlIGlzIHVzZWQgdG8gbWFrZSBzb21lIGNvbmZpZyBpbmZvIGF2YWlsYWJsZSB0byBEYXBwcyBzeW5jaHJvbm91c2x5LlxuICAgKi9cbiAgY3JlYXRlUHVibGljQ29uZmlnU3RvcmUoKSB7XG4gICAgLy8gc3Vic2V0IG9mIHN0YXRlIGZvciBtZXRhbWFzayBpbnBhZ2UgcHJvdmlkZXJcbiAgICBjb25zdCBwdWJsaWNDb25maWdTdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoKTtcbiAgICBjb25zdCB7IG5ldHdvcmtDb250cm9sbGVyIH0gPSB0aGlzO1xuXG4gICAgLy8gc2V0dXAgbWVtU3RvcmUgc3Vic2NyaXB0aW9uIGhvb2tzXG4gICAgdGhpcy5vbigndXBkYXRlJywgdXBkYXRlUHVibGljQ29uZmlnU3RvcmUpO1xuICAgIHVwZGF0ZVB1YmxpY0NvbmZpZ1N0b3JlKHRoaXMuZ2V0U3RhdGUoKSk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQdWJsaWNDb25maWdTdG9yZShtZW1TdGF0ZSkge1xuICAgICAgY29uc3QgY2hhaW5JZCA9IG5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgICBpZiAobWVtU3RhdGUubmV0d29yayAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIHB1YmxpY0NvbmZpZ1N0b3JlLnB1dFN0YXRlKHNlbGVjdFB1YmxpY1N0YXRlKGNoYWluSWQsIG1lbVN0YXRlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0UHVibGljU3RhdGUoY2hhaW5JZCwgeyBpc1VubG9ja2VkLCBuZXR3b3JrIH0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVW5sb2NrZWQsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIG5ldHdvcmtWZXJzaW9uOiBuZXR3b3JrLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVibGljQ29uZmlnU3RvcmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyByZWxldmFudCBzdGF0ZSBmb3IgdGhlIHByb3ZpZGVyIG9mIGFuIGV4dGVybmFsIG9yaWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gdG8gZ2V0IHRoZSBwcm92aWRlciBzdGF0ZSBmb3IuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHtcbiAgICogIGlzVW5sb2NrZWQ6IGJvb2xlYW4sXG4gICAqICBuZXR3b3JrVmVyc2lvbjogc3RyaW5nLFxuICAgKiAgY2hhaW5JZDogc3RyaW5nLFxuICAgKiAgYWNjb3VudHM6IHN0cmluZ1tdLFxuICAgKiB9Pn0gQW4gb2JqZWN0IHdpdGggcmVsZXZhbnQgc3RhdGUgcHJvcGVydGllcy5cbiAgICovXG4gIGFzeW5jIGdldFByb3ZpZGVyU3RhdGUob3JpZ2luKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVW5sb2NrZWQ6IHRoaXMuaXNVbmxvY2tlZCgpLFxuICAgICAgLi4udGhpcy5nZXRQcm92aWRlck5ldHdvcmtTdGF0ZSgpLFxuICAgICAgYWNjb3VudHM6IGF3YWl0IHRoaXMuZ2V0UGVybWl0dGVkQWNjb3VudHMob3JpZ2luKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgbmV0d29yayBzdGF0ZSByZWxldmFudCBmb3IgZXh0ZXJuYWwgcHJvdmlkZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW21lbVN0YXRlXSAtIFRoZSBNZXRhTWFzayBtZW1TdGF0ZS4gSWYgbm90IHByb3ZpZGVkLFxuICAgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0cmlldmUgdGhlIG1vc3QgcmVjZW50IHN0YXRlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCByZWxldmFudCBuZXR3b3JrIHN0YXRlIHByb3BlcnRpZXMuXG4gICAqL1xuICBnZXRQcm92aWRlck5ldHdvcmtTdGF0ZShtZW1TdGF0ZSkge1xuICAgIGNvbnN0IHsgbmV0d29yayB9ID0gbWVtU3RhdGUgfHwgdGhpcy5nZXRTdGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBjaGFpbklkOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkKCksXG4gICAgICBuZXR3b3JrVmVyc2lvbjogbmV0d29yayxcbiAgICB9O1xuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFWFBPU0VEIFRPIFRIRSBVSSBTVUJTWVNURU1cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBUaGUgbWV0YW1hc2stc3RhdGUgb2YgdGhlIHZhcmlvdXMgY29udHJvbGxlcnMsIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBVSVxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzdGF0dXNcbiAgICovXG4gIGdldFN0YXRlKCkge1xuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBpc0luaXRpYWxpemVkID0gQm9vbGVhbih2YXVsdCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNJbml0aWFsaXplZCxcbiAgICAgIC4uLnRoaXMubWVtU3RvcmUuZ2V0RmxhdFN0YXRlKCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIE9iamVjdCBjb250YWluaW5nIEFQSSBDYWxsYmFjayBGdW5jdGlvbnMuXG4gICAqIFRoZXNlIGZ1bmN0aW9ucyBhcmUgdGhlIGludGVyZmFjZSBmb3IgdGhlIFVJLlxuICAgKiBUaGUgQVBJIG9iamVjdCBjYW4gYmUgdHJhbnNtaXR0ZWQgb3ZlciBhIHN0cmVhbSB2aWEgSlNPTi1SUEMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIEFQSSBmdW5jdGlvbnMuXG4gICAqL1xuICBnZXRBcGkoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWRkcmVzc0Jvb2tDb250cm9sbGVyLFxuICAgICAgYWxlcnRDb250cm9sbGVyLFxuICAgICAgYXBwcm92YWxDb250cm9sbGVyLFxuICAgICAgYXBwU3RhdGVDb250cm9sbGVyLFxuICAgICAgY29sbGVjdGlibGVzQ29udHJvbGxlcixcbiAgICAgIGNvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlcixcbiAgICAgIGN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIsXG4gICAgICBkZXRlY3RUb2tlbnNDb250cm9sbGVyLFxuICAgICAgZW5zQ29udHJvbGxlcixcbiAgICAgIGdhc0ZlZUNvbnRyb2xsZXIsXG4gICAgICBrZXlyaW5nQ29udHJvbGxlcixcbiAgICAgIG1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgIG5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgbm90aWZpY2F0aW9uQ29udHJvbGxlcixcbiAgICAgIG9uYm9hcmRpbmdDb250cm9sbGVyLFxuICAgICAgcGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICBxckhhcmR3YXJlS2V5cmluZyxcbiAgICAgIHN3YXBzQ29udHJvbGxlcixcbiAgICAgIHRocmVlQm94Q29udHJvbGxlcixcbiAgICAgIHRva2Vuc0NvbnRyb2xsZXIsXG4gICAgICB0eENvbnRyb2xsZXIsXG4gICAgfSA9IHRoaXM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLy8gZXRjXG4gICAgICBnZXRTdGF0ZTogdGhpcy5nZXRTdGF0ZS5iaW5kKHRoaXMpLFxuICAgICAgc2V0Q3VycmVudEN1cnJlbmN5OiBjdXJyZW5jeVJhdGVDb250cm9sbGVyLnNldEN1cnJlbnRDdXJyZW5jeS5iaW5kKFxuICAgICAgICBjdXJyZW5jeVJhdGVDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFVzZUJsb2NraWU6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRVc2VCbG9ja2llLmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRVc2VOb25jZUZpZWxkOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0VXNlTm9uY2VGaWVsZC5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0VXNlUGhpc2hEZXRlY3Q6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRVc2VQaGlzaERldGVjdC5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0VXNlVG9rZW5EZXRlY3Rpb246IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRVc2VUb2tlbkRldGVjdGlvbi5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0VXNlQ29sbGVjdGlibGVEZXRlY3Rpb246IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRVc2VDb2xsZWN0aWJsZURldGVjdGlvbi5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0T3BlblNlYUVuYWJsZWQ6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRPcGVuU2VhRW5hYmxlZC5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0SXBmc0dhdGV3YXk6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRJcGZzR2F0ZXdheS5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0UGFydGljaXBhdGVJbk1ldGFNZXRyaWNzOiBtZXRhTWV0cmljc0NvbnRyb2xsZXIuc2V0UGFydGljaXBhdGVJbk1ldGFNZXRyaWNzLmJpbmQoXG4gICAgICAgIG1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRDdXJyZW50TG9jYWxlOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0Q3VycmVudExvY2FsZS5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgbWFya1Bhc3N3b3JkRm9yZ290dGVuOiB0aGlzLm1hcmtQYXNzd29yZEZvcmdvdHRlbi5iaW5kKHRoaXMpLFxuICAgICAgdW5NYXJrUGFzc3dvcmRGb3Jnb3R0ZW46IHRoaXMudW5NYXJrUGFzc3dvcmRGb3Jnb3R0ZW4uYmluZCh0aGlzKSxcbiAgICAgIHNhZmVsaXN0UGhpc2hpbmdEb21haW46IHRoaXMuc2FmZWxpc3RQaGlzaGluZ0RvbWFpbi5iaW5kKHRoaXMpLFxuICAgICAgZ2V0UmVxdWVzdEFjY291bnRUYWJJZHM6IHRoaXMuZ2V0UmVxdWVzdEFjY291bnRUYWJJZHMsXG4gICAgICBnZXRPcGVuTWV0YW1hc2tUYWJzSWRzOiB0aGlzLmdldE9wZW5NZXRhbWFza1RhYnNJZHMsXG5cbiAgICAgIC8vIHByaW1hcnkgSEQga2V5cmluZyBtYW5hZ2VtZW50XG4gICAgICBhZGROZXdBY2NvdW50OiB0aGlzLmFkZE5ld0FjY291bnQuYmluZCh0aGlzKSxcbiAgICAgIHZlcmlmeVNlZWRQaHJhc2U6IHRoaXMudmVyaWZ5U2VlZFBocmFzZS5iaW5kKHRoaXMpLFxuICAgICAgcmVzZXRBY2NvdW50OiB0aGlzLnJlc2V0QWNjb3VudC5iaW5kKHRoaXMpLFxuICAgICAgcmVtb3ZlQWNjb3VudDogdGhpcy5yZW1vdmVBY2NvdW50LmJpbmQodGhpcyksXG4gICAgICBpbXBvcnRBY2NvdW50V2l0aFN0cmF0ZWd5OiB0aGlzLmltcG9ydEFjY291bnRXaXRoU3RyYXRlZ3kuYmluZCh0aGlzKSxcblxuICAgICAgLy8gaGFyZHdhcmUgd2FsbGV0c1xuICAgICAgY29ubmVjdEhhcmR3YXJlOiB0aGlzLmNvbm5lY3RIYXJkd2FyZS5iaW5kKHRoaXMpLFxuICAgICAgZm9yZ2V0RGV2aWNlOiB0aGlzLmZvcmdldERldmljZS5iaW5kKHRoaXMpLFxuICAgICAgY2hlY2tIYXJkd2FyZVN0YXR1czogdGhpcy5jaGVja0hhcmR3YXJlU3RhdHVzLmJpbmQodGhpcyksXG4gICAgICB1bmxvY2tIYXJkd2FyZVdhbGxldEFjY291bnQ6IHRoaXMudW5sb2NrSGFyZHdhcmVXYWxsZXRBY2NvdW50LmJpbmQodGhpcyksXG4gICAgICBzZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlOiB0aGlzLnNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UuYmluZChcbiAgICAgICAgdGhpcyxcbiAgICAgICksXG4gICAgICBhdHRlbXB0TGVkZ2VyVHJhbnNwb3J0Q3JlYXRpb246IHRoaXMuYXR0ZW1wdExlZGdlclRyYW5zcG9ydENyZWF0aW9uLmJpbmQoXG4gICAgICAgIHRoaXMsXG4gICAgICApLFxuICAgICAgZXN0YWJsaXNoTGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZTogdGhpcy5lc3RhYmxpc2hMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlLmJpbmQoXG4gICAgICAgIHRoaXMsXG4gICAgICApLFxuXG4gICAgICAvLyBxciBoYXJkd2FyZSBkZXZpY2VzXG4gICAgICBzdWJtaXRRUkhhcmR3YXJlQ3J5cHRvSERLZXk6IHFySGFyZHdhcmVLZXlyaW5nLnN1Ym1pdENyeXB0b0hES2V5LmJpbmQoXG4gICAgICAgIHFySGFyZHdhcmVLZXlyaW5nLFxuICAgICAgKSxcbiAgICAgIHN1Ym1pdFFSSGFyZHdhcmVDcnlwdG9BY2NvdW50OiBxckhhcmR3YXJlS2V5cmluZy5zdWJtaXRDcnlwdG9BY2NvdW50LmJpbmQoXG4gICAgICAgIHFySGFyZHdhcmVLZXlyaW5nLFxuICAgICAgKSxcbiAgICAgIGNhbmNlbFN5bmNRUkhhcmR3YXJlOiBxckhhcmR3YXJlS2V5cmluZy5jYW5jZWxTeW5jLmJpbmQoXG4gICAgICAgIHFySGFyZHdhcmVLZXlyaW5nLFxuICAgICAgKSxcbiAgICAgIHN1Ym1pdFFSSGFyZHdhcmVTaWduYXR1cmU6IHFySGFyZHdhcmVLZXlyaW5nLnN1Ym1pdFNpZ25hdHVyZS5iaW5kKFxuICAgICAgICBxckhhcmR3YXJlS2V5cmluZyxcbiAgICAgICksXG4gICAgICBjYW5jZWxRUkhhcmR3YXJlU2lnblJlcXVlc3Q6IHFySGFyZHdhcmVLZXlyaW5nLmNhbmNlbFNpZ25SZXF1ZXN0LmJpbmQoXG4gICAgICAgIHFySGFyZHdhcmVLZXlyaW5nLFxuICAgICAgKSxcblxuICAgICAgLy8gbW9iaWxlXG4gICAgICBmZXRjaEluZm9Ub1N5bmM6IHRoaXMuZmV0Y2hJbmZvVG9TeW5jLmJpbmQodGhpcyksXG5cbiAgICAgIC8vIHZhdWx0IG1hbmFnZW1lbnRcbiAgICAgIHN1Ym1pdFBhc3N3b3JkOiB0aGlzLnN1Ym1pdFBhc3N3b3JkLmJpbmQodGhpcyksXG4gICAgICB2ZXJpZnlQYXNzd29yZDogdGhpcy52ZXJpZnlQYXNzd29yZC5iaW5kKHRoaXMpLFxuXG4gICAgICAvLyBuZXR3b3JrIG1hbmFnZW1lbnRcbiAgICAgIHNldFByb3ZpZGVyVHlwZTogbmV0d29ya0NvbnRyb2xsZXIuc2V0UHJvdmlkZXJUeXBlLmJpbmQoXG4gICAgICAgIG5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHJvbGxiYWNrVG9QcmV2aW91c1Byb3ZpZGVyOiBuZXR3b3JrQ29udHJvbGxlci5yb2xsYmFja1RvUHJldmlvdXNQcm92aWRlci5iaW5kKFxuICAgICAgICBuZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRDdXN0b21ScGM6IHRoaXMuc2V0Q3VzdG9tUnBjLmJpbmQodGhpcyksXG4gICAgICB1cGRhdGVBbmRTZXRDdXN0b21ScGM6IHRoaXMudXBkYXRlQW5kU2V0Q3VzdG9tUnBjLmJpbmQodGhpcyksXG4gICAgICBkZWxDdXN0b21ScGM6IHRoaXMuZGVsQ3VzdG9tUnBjLmJpbmQodGhpcyksXG5cbiAgICAgIC8vIFByZWZlcmVuY2VzQ29udHJvbGxlclxuICAgICAgc2V0U2VsZWN0ZWRBZGRyZXNzOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRBZGRyZXNzLmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBhZGRUb2tlbjogdG9rZW5zQ29udHJvbGxlci5hZGRUb2tlbi5iaW5kKHRva2Vuc0NvbnRyb2xsZXIpLFxuICAgICAgcmVqZWN0V2F0Y2hBc3NldDogdG9rZW5zQ29udHJvbGxlci5yZWplY3RXYXRjaEFzc2V0LmJpbmQoXG4gICAgICAgIHRva2Vuc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgYWNjZXB0V2F0Y2hBc3NldDogdG9rZW5zQ29udHJvbGxlci5hY2NlcHRXYXRjaEFzc2V0LmJpbmQoXG4gICAgICAgIHRva2Vuc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgdXBkYXRlVG9rZW5UeXBlOiB0b2tlbnNDb250cm9sbGVyLnVwZGF0ZVRva2VuVHlwZS5iaW5kKHRva2Vuc0NvbnRyb2xsZXIpLFxuICAgICAgcmVtb3ZlVG9rZW46IHRva2Vuc0NvbnRyb2xsZXIucmVtb3ZlQW5kSWdub3JlVG9rZW4uYmluZCh0b2tlbnNDb250cm9sbGVyKSxcbiAgICAgIHNldEFjY291bnRMYWJlbDogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFjY291bnRMYWJlbC5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0RmVhdHVyZUZsYWc6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRGZWF0dXJlRmxhZy5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0UHJlZmVyZW5jZTogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFByZWZlcmVuY2UuYmluZChcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgYWRkS25vd25NZXRob2REYXRhOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWRkS25vd25NZXRob2REYXRhLmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXREaXNtaXNzU2VlZEJhY2tVcFJlbWluZGVyOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0RGlzbWlzc1NlZWRCYWNrVXBSZW1pbmRlci5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0QWR2YW5jZWRHYXNGZWU6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZHZhbmNlZEdhc0ZlZS5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICAvLyBDb2xsZWN0aWJsZXNDb250cm9sbGVyXG4gICAgICBhZGRDb2xsZWN0aWJsZTogY29sbGVjdGlibGVzQ29udHJvbGxlci5hZGRDb2xsZWN0aWJsZS5iaW5kKFxuICAgICAgICBjb2xsZWN0aWJsZXNDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgYWRkQ29sbGVjdGlibGVWZXJpZnlPd25lcnNoaXA6IGNvbGxlY3RpYmxlc0NvbnRyb2xsZXIuYWRkQ29sbGVjdGlibGVWZXJpZnlPd25lcnNoaXAuYmluZChcbiAgICAgICAgY29sbGVjdGlibGVzQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIHJlbW92ZUFuZElnbm9yZUNvbGxlY3RpYmxlOiBjb2xsZWN0aWJsZXNDb250cm9sbGVyLnJlbW92ZUFuZElnbm9yZUNvbGxlY3RpYmxlLmJpbmQoXG4gICAgICAgIGNvbGxlY3RpYmxlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICByZW1vdmVDb2xsZWN0aWJsZTogY29sbGVjdGlibGVzQ29udHJvbGxlci5yZW1vdmVDb2xsZWN0aWJsZS5iaW5kKFxuICAgICAgICBjb2xsZWN0aWJsZXNDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgLy8gQWRkcmVzc0NvbnRyb2xsZXJcbiAgICAgIHNldEFkZHJlc3NCb29rOiBhZGRyZXNzQm9va0NvbnRyb2xsZXIuc2V0LmJpbmQoYWRkcmVzc0Jvb2tDb250cm9sbGVyKSxcbiAgICAgIHJlbW92ZUZyb21BZGRyZXNzQm9vazogYWRkcmVzc0Jvb2tDb250cm9sbGVyLmRlbGV0ZS5iaW5kKFxuICAgICAgICBhZGRyZXNzQm9va0NvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICAvLyBBcHBTdGF0ZUNvbnRyb2xsZXJcbiAgICAgIHNldExhc3RBY3RpdmVUaW1lOiBhcHBTdGF0ZUNvbnRyb2xsZXIuc2V0TGFzdEFjdGl2ZVRpbWUuYmluZChcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldERlZmF1bHRIb21lQWN0aXZlVGFiTmFtZTogYXBwU3RhdGVDb250cm9sbGVyLnNldERlZmF1bHRIb21lQWN0aXZlVGFiTmFtZS5iaW5kKFxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0Q29ubmVjdGVkU3RhdHVzUG9wb3Zlckhhc0JlZW5TaG93bjogYXBwU3RhdGVDb250cm9sbGVyLnNldENvbm5lY3RlZFN0YXR1c1BvcG92ZXJIYXNCZWVuU2hvd24uYmluZChcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFJlY292ZXJ5UGhyYXNlUmVtaW5kZXJIYXNCZWVuU2hvd246IGFwcFN0YXRlQ29udHJvbGxlci5zZXRSZWNvdmVyeVBocmFzZVJlbWluZGVySGFzQmVlblNob3duLmJpbmQoXG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRSZWNvdmVyeVBocmFzZVJlbWluZGVyTGFzdFNob3duOiBhcHBTdGF0ZUNvbnRyb2xsZXIuc2V0UmVjb3ZlcnlQaHJhc2VSZW1pbmRlckxhc3RTaG93bi5iaW5kKFxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0U2hvd1Rlc3RuZXRNZXNzYWdlSW5Ecm9wZG93bjogYXBwU3RhdGVDb250cm9sbGVyLnNldFNob3dUZXN0bmV0TWVzc2FnZUluRHJvcGRvd24uYmluZChcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldENvbGxlY3RpYmxlc0RldGVjdGlvbk5vdGljZURpc21pc3NlZDogYXBwU3RhdGVDb250cm9sbGVyLnNldENvbGxlY3RpYmxlc0RldGVjdGlvbk5vdGljZURpc21pc3NlZC5iaW5kKFxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgLy8gRW5zQ29udHJvbGxlclxuICAgICAgdHJ5UmV2ZXJzZVJlc29sdmVBZGRyZXNzOiBlbnNDb250cm9sbGVyLnJldmVyc2VSZXNvbHZlQWRkcmVzcy5iaW5kKFxuICAgICAgICBlbnNDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgLy8gS2V5cmluZ0NvbnRyb2xsZXJcbiAgICAgIHNldExvY2tlZDogdGhpcy5zZXRMb2NrZWQuYmluZCh0aGlzKSxcbiAgICAgIGNyZWF0ZU5ld1ZhdWx0QW5kS2V5Y2hhaW46IHRoaXMuY3JlYXRlTmV3VmF1bHRBbmRLZXljaGFpbi5iaW5kKHRoaXMpLFxuICAgICAgY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlOiB0aGlzLmNyZWF0ZU5ld1ZhdWx0QW5kUmVzdG9yZS5iaW5kKHRoaXMpLFxuICAgICAgZXhwb3J0QWNjb3VudDoga2V5cmluZ0NvbnRyb2xsZXIuZXhwb3J0QWNjb3VudC5iaW5kKGtleXJpbmdDb250cm9sbGVyKSxcblxuICAgICAgLy8gdHhDb250cm9sbGVyXG4gICAgICBjYW5jZWxUcmFuc2FjdGlvbjogdHhDb250cm9sbGVyLmNhbmNlbFRyYW5zYWN0aW9uLmJpbmQodHhDb250cm9sbGVyKSxcbiAgICAgIHVwZGF0ZVRyYW5zYWN0aW9uOiB0eENvbnRyb2xsZXIudXBkYXRlVHJhbnNhY3Rpb24uYmluZCh0eENvbnRyb2xsZXIpLFxuICAgICAgdXBkYXRlQW5kQXBwcm92ZVRyYW5zYWN0aW9uOiB0eENvbnRyb2xsZXIudXBkYXRlQW5kQXBwcm92ZVRyYW5zYWN0aW9uLmJpbmQoXG4gICAgICAgIHR4Q29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBjcmVhdGVDYW5jZWxUcmFuc2FjdGlvbjogdGhpcy5jcmVhdGVDYW5jZWxUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgY3JlYXRlU3BlZWRVcFRyYW5zYWN0aW9uOiB0aGlzLmNyZWF0ZVNwZWVkVXBUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgZXN0aW1hdGVHYXM6IHRoaXMuZXN0aW1hdGVHYXMuYmluZCh0aGlzKSxcbiAgICAgIGdldE5leHROb25jZTogdGhpcy5nZXROZXh0Tm9uY2UuYmluZCh0aGlzKSxcbiAgICAgIGFkZFVuYXBwcm92ZWRUcmFuc2FjdGlvbjogdHhDb250cm9sbGVyLmFkZFVuYXBwcm92ZWRUcmFuc2FjdGlvbi5iaW5kKFxuICAgICAgICB0eENvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICAvLyBtZXNzYWdlTWFuYWdlclxuICAgICAgc2lnbk1lc3NhZ2U6IHRoaXMuc2lnbk1lc3NhZ2UuYmluZCh0aGlzKSxcbiAgICAgIGNhbmNlbE1lc3NhZ2U6IHRoaXMuY2FuY2VsTWVzc2FnZS5iaW5kKHRoaXMpLFxuXG4gICAgICAvLyBwZXJzb25hbE1lc3NhZ2VNYW5hZ2VyXG4gICAgICBzaWduUGVyc29uYWxNZXNzYWdlOiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2UuYmluZCh0aGlzKSxcbiAgICAgIGNhbmNlbFBlcnNvbmFsTWVzc2FnZTogdGhpcy5jYW5jZWxQZXJzb25hbE1lc3NhZ2UuYmluZCh0aGlzKSxcblxuICAgICAgLy8gdHlwZWRNZXNzYWdlTWFuYWdlclxuICAgICAgc2lnblR5cGVkTWVzc2FnZTogdGhpcy5zaWduVHlwZWRNZXNzYWdlLmJpbmQodGhpcyksXG4gICAgICBjYW5jZWxUeXBlZE1lc3NhZ2U6IHRoaXMuY2FuY2VsVHlwZWRNZXNzYWdlLmJpbmQodGhpcyksXG5cbiAgICAgIC8vIGRlY3J5cHRNZXNzYWdlTWFuYWdlclxuICAgICAgZGVjcnlwdE1lc3NhZ2U6IHRoaXMuZGVjcnlwdE1lc3NhZ2UuYmluZCh0aGlzKSxcbiAgICAgIGRlY3J5cHRNZXNzYWdlSW5saW5lOiB0aGlzLmRlY3J5cHRNZXNzYWdlSW5saW5lLmJpbmQodGhpcyksXG4gICAgICBjYW5jZWxEZWNyeXB0TWVzc2FnZTogdGhpcy5jYW5jZWxEZWNyeXB0TWVzc2FnZS5iaW5kKHRoaXMpLFxuXG4gICAgICAvLyBFbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlclxuICAgICAgZW5jcnlwdGlvblB1YmxpY0tleTogdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5LmJpbmQodGhpcyksXG4gICAgICBjYW5jZWxFbmNyeXB0aW9uUHVibGljS2V5OiB0aGlzLmNhbmNlbEVuY3J5cHRpb25QdWJsaWNLZXkuYmluZCh0aGlzKSxcblxuICAgICAgLy8gb25ib2FyZGluZyBjb250cm9sbGVyXG4gICAgICBzZXRTZWVkUGhyYXNlQmFja2VkVXA6IG9uYm9hcmRpbmdDb250cm9sbGVyLnNldFNlZWRQaHJhc2VCYWNrZWRVcC5iaW5kKFxuICAgICAgICBvbmJvYXJkaW5nQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBjb21wbGV0ZU9uYm9hcmRpbmc6IG9uYm9hcmRpbmdDb250cm9sbGVyLmNvbXBsZXRlT25ib2FyZGluZy5iaW5kKFxuICAgICAgICBvbmJvYXJkaW5nQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRGaXJzdFRpbWVGbG93VHlwZTogb25ib2FyZGluZ0NvbnRyb2xsZXIuc2V0Rmlyc3RUaW1lRmxvd1R5cGUuYmluZChcbiAgICAgICAgb25ib2FyZGluZ0NvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICAvLyBhbGVydCBjb250cm9sbGVyXG4gICAgICBzZXRBbGVydEVuYWJsZWRuZXNzOiBhbGVydENvbnRyb2xsZXIuc2V0QWxlcnRFbmFibGVkbmVzcy5iaW5kKFxuICAgICAgICBhbGVydENvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0VW5jb25uZWN0ZWRBY2NvdW50QWxlcnRTaG93bjogYWxlcnRDb250cm9sbGVyLnNldFVuY29ubmVjdGVkQWNjb3VudEFsZXJ0U2hvd24uYmluZChcbiAgICAgICAgYWxlcnRDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFdlYjNTaGltVXNhZ2VBbGVydERpc21pc3NlZDogYWxlcnRDb250cm9sbGVyLnNldFdlYjNTaGltVXNhZ2VBbGVydERpc21pc3NlZC5iaW5kKFxuICAgICAgICBhbGVydENvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICAvLyAzQm94XG4gICAgICBzZXRUaHJlZUJveFN5bmNpbmdQZXJtaXNzaW9uOiB0aHJlZUJveENvbnRyb2xsZXIuc2V0VGhyZWVCb3hTeW5jaW5nUGVybWlzc2lvbi5iaW5kKFxuICAgICAgICB0aHJlZUJveENvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgcmVzdG9yZUZyb21UaHJlZUJveDogdGhyZWVCb3hDb250cm9sbGVyLnJlc3RvcmVGcm9tVGhyZWVCb3guYmluZChcbiAgICAgICAgdGhyZWVCb3hDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFNob3dSZXN0b3JlUHJvbXB0VG9GYWxzZTogdGhyZWVCb3hDb250cm9sbGVyLnNldFNob3dSZXN0b3JlUHJvbXB0VG9GYWxzZS5iaW5kKFxuICAgICAgICB0aHJlZUJveENvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgZ2V0VGhyZWVCb3hMYXN0VXBkYXRlZDogdGhyZWVCb3hDb250cm9sbGVyLmdldExhc3RVcGRhdGVkLmJpbmQoXG4gICAgICAgIHRocmVlQm94Q29udHJvbGxlcixcbiAgICAgICksXG4gICAgICB0dXJuVGhyZWVCb3hTeW5jaW5nT246IHRocmVlQm94Q29udHJvbGxlci50dXJuVGhyZWVCb3hTeW5jaW5nT24uYmluZChcbiAgICAgICAgdGhyZWVCb3hDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGluaXRpYWxpemVUaHJlZUJveDogdGhpcy5pbml0aWFsaXplVGhyZWVCb3guYmluZCh0aGlzKSxcblxuICAgICAgLy8gcGVybWlzc2lvbnNcbiAgICAgIHJlbW92ZVBlcm1pc3Npb25zRm9yOiBwZXJtaXNzaW9uQ29udHJvbGxlci5yZXZva2VQZXJtaXNzaW9ucy5iaW5kKFxuICAgICAgICBwZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBhcHByb3ZlUGVybWlzc2lvbnNSZXF1ZXN0OiBwZXJtaXNzaW9uQ29udHJvbGxlci5hY2NlcHRQZXJtaXNzaW9uc1JlcXVlc3QuYmluZChcbiAgICAgICAgcGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgcmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0OiBwZXJtaXNzaW9uQ29udHJvbGxlci5yZWplY3RQZXJtaXNzaW9uc1JlcXVlc3QuYmluZChcbiAgICAgICAgcGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgLi4uZ2V0UGVybWlzc2lvbkJhY2tncm91bmRBcGlNZXRob2RzKHBlcm1pc3Npb25Db250cm9sbGVyKSxcblxuICAgICAgLy8gc3dhcHNcbiAgICAgIGZldGNoQW5kU2V0UXVvdGVzOiBzd2Fwc0NvbnRyb2xsZXIuZmV0Y2hBbmRTZXRRdW90ZXMuYmluZChcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFNlbGVjdGVkUXVvdGVBZ2dJZDogc3dhcHNDb250cm9sbGVyLnNldFNlbGVjdGVkUXVvdGVBZ2dJZC5iaW5kKFxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgcmVzZXRTd2Fwc1N0YXRlOiBzd2Fwc0NvbnRyb2xsZXIucmVzZXRTd2Fwc1N0YXRlLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHNldFN3YXBzVG9rZW5zOiBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNUb2tlbnMuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgY2xlYXJTd2Fwc1F1b3Rlczogc3dhcHNDb250cm9sbGVyLmNsZWFyU3dhcHNRdW90ZXMuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0QXBwcm92ZVR4SWQ6IHN3YXBzQ29udHJvbGxlci5zZXRBcHByb3ZlVHhJZC5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzZXRUcmFkZVR4SWQ6IHN3YXBzQ29udHJvbGxlci5zZXRUcmFkZVR4SWQuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0U3dhcHNUeEdhc1ByaWNlOiBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNUeEdhc1ByaWNlLmJpbmQoXG4gICAgICAgIHN3YXBzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRTd2Fwc1R4R2FzTGltaXQ6IHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc1R4R2FzTGltaXQuYmluZChcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFN3YXBzVHhNYXhGZWVQZXJHYXM6IHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc1R4TWF4RmVlUGVyR2FzLmJpbmQoXG4gICAgICAgIHN3YXBzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRTd2Fwc1R4TWF4RmVlUHJpb3JpdHlQZXJHYXM6IHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc1R4TWF4RmVlUHJpb3JpdHlQZXJHYXMuYmluZChcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNhZmVSZWZldGNoUXVvdGVzOiBzd2Fwc0NvbnRyb2xsZXIuc2FmZVJlZmV0Y2hRdW90ZXMuYmluZChcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHN0b3BQb2xsaW5nRm9yUXVvdGVzOiBzd2Fwc0NvbnRyb2xsZXIuc3RvcFBvbGxpbmdGb3JRdW90ZXMuYmluZChcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldEJhY2tncm91bmRTd2FwUm91dGVTdGF0ZTogc3dhcHNDb250cm9sbGVyLnNldEJhY2tncm91bmRTd2FwUm91dGVTdGF0ZS5iaW5kKFxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgcmVzZXRQb3N0RmV0Y2hTdGF0ZTogc3dhcHNDb250cm9sbGVyLnJlc2V0UG9zdEZldGNoU3RhdGUuYmluZChcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFN3YXBzRXJyb3JLZXk6IHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc0Vycm9yS2V5LmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHNldEluaXRpYWxHYXNFc3RpbWF0ZTogc3dhcHNDb250cm9sbGVyLnNldEluaXRpYWxHYXNFc3RpbWF0ZS5iaW5kKFxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0Q3VzdG9tQXBwcm92ZVR4RGF0YTogc3dhcHNDb250cm9sbGVyLnNldEN1c3RvbUFwcHJvdmVUeERhdGEuYmluZChcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFN3YXBzTGl2ZW5lc3M6IHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc0xpdmVuZXNzLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHNldFN3YXBzVXNlckZlZUxldmVsOiBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNVc2VyRmVlTGV2ZWwuYmluZChcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFN3YXBzUXVvdGVzUG9sbGluZ0xpbWl0RW5hYmxlZDogc3dhcHNDb250cm9sbGVyLnNldFN3YXBzUXVvdGVzUG9sbGluZ0xpbWl0RW5hYmxlZC5iaW5kKFxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICAvLyBNZXRhTWV0cmljc1xuICAgICAgdHJhY2tNZXRhTWV0cmljc0V2ZW50OiBtZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxuICAgICAgICBtZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgdHJhY2tNZXRhTWV0cmljc1BhZ2U6IG1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja1BhZ2UuYmluZChcbiAgICAgICAgbWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgLy8gYXBwcm92YWwgY29udHJvbGxlclxuICAgICAgcmVzb2x2ZVBlbmRpbmdBcHByb3ZhbDogYXBwcm92YWxDb250cm9sbGVyLmFjY2VwdC5iaW5kKFxuICAgICAgICBhcHByb3ZhbENvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgcmVqZWN0UGVuZGluZ0FwcHJvdmFsOiBhcHByb3ZhbENvbnRyb2xsZXIucmVqZWN0LmJpbmQoYXBwcm92YWxDb250cm9sbGVyKSxcblxuICAgICAgLy8gTm90aWZpY2F0aW9uc1xuICAgICAgdXBkYXRlVmlld2VkTm90aWZpY2F0aW9uczogbm90aWZpY2F0aW9uQ29udHJvbGxlci51cGRhdGVWaWV3ZWQuYmluZChcbiAgICAgICAgbm90aWZpY2F0aW9uQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIC8vIEdhc0ZlZUNvbnRyb2xsZXJcbiAgICAgIGdldEdhc0ZlZUVzdGltYXRlc0FuZFN0YXJ0UG9sbGluZzogZ2FzRmVlQ29udHJvbGxlci5nZXRHYXNGZWVFc3RpbWF0ZXNBbmRTdGFydFBvbGxpbmcuYmluZChcbiAgICAgICAgZ2FzRmVlQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIGRpc2Nvbm5lY3RHYXNGZWVFc3RpbWF0ZVBvbGxlcjogZ2FzRmVlQ29udHJvbGxlci5kaXNjb25uZWN0UG9sbGVyLmJpbmQoXG4gICAgICAgIGdhc0ZlZUNvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICBnZXRHYXNGZWVUaW1lRXN0aW1hdGU6IGdhc0ZlZUNvbnRyb2xsZXIuZ2V0VGltZUVzdGltYXRlLmJpbmQoXG4gICAgICAgIGdhc0ZlZUNvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICBhZGRQb2xsaW5nVG9rZW5Ub0FwcFN0YXRlOiBhcHBTdGF0ZUNvbnRyb2xsZXIuYWRkUG9sbGluZ1Rva2VuLmJpbmQoXG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIHJlbW92ZVBvbGxpbmdUb2tlbkZyb21BcHBTdGF0ZTogYXBwU3RhdGVDb250cm9sbGVyLnJlbW92ZVBvbGxpbmdUb2tlbi5iaW5kKFxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICAvLyBEZXRlY3RUb2tlbkNvbnRyb2xsZXJcbiAgICAgIGRldGVjdE5ld1Rva2VuczogZGV0ZWN0VG9rZW5zQ29udHJvbGxlci5kZXRlY3ROZXdUb2tlbnMuYmluZChcbiAgICAgICAgZGV0ZWN0VG9rZW5zQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIC8vIERldGVjdENvbGxlY3RpYmxlQ29udHJvbGxlclxuICAgICAgZGV0ZWN0Q29sbGVjdGlibGVzOiBwcm9jZXNzLmVudi5DT0xMRUNUSUJMRVNfVjFcbiAgICAgICAgPyBjb2xsZWN0aWJsZURldGVjdGlvbkNvbnRyb2xsZXIuZGV0ZWN0Q29sbGVjdGlibGVzLmJpbmQoXG4gICAgICAgICAgICBjb2xsZWN0aWJsZURldGVjdGlvbkNvbnRyb2xsZXIsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGwsXG4gICAgfTtcbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gVkFVTFQgLyBLRVlSSU5HIFJFTEFURUQgTUVUSE9EU1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVmF1bHQgYW5kIGNyZWF0ZSBhIG5ldyBrZXljaGFpbi5cbiAgICpcbiAgICogQSB2YXVsdCwgb3IgS2V5cmluZ0NvbnRyb2xsZXIsIGlzIGEgY29udHJvbGxlciB0aGF0IGNvbnRhaW5zXG4gICAqIG1hbnkgZGlmZmVyZW50IGFjY291bnQgc3RyYXRlZ2llcywgY3VycmVudGx5IGNhbGxlZCBLZXlyaW5ncy5cbiAgICogQ3JlYXRpbmcgaXQgbmV3IG1lYW5zIHdpcGluZyBhbGwgcHJldmlvdXMga2V5cmluZ3MuXG4gICAqXG4gICAqIEEga2V5Y2hhaW4sIG9yIGtleXJpbmcsIGNvbnRyb2xzIG1hbnkgYWNjb3VudHMgd2l0aCBhIHNpbmdsZSBiYWNrdXAgYW5kIHNpZ25pbmcgc3RyYXRlZ3kuXG4gICAqIEZvciBleGFtcGxlLCBhIG1uZW1vbmljIHBocmFzZSBjYW4gZ2VuZXJhdGUgbWFueSBhY2NvdW50cywgYW5kIGlzIGEga2V5cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHZhdWx0XG4gICAqL1xuICBhc3luYyBjcmVhdGVOZXdWYXVsdEFuZEtleWNoYWluKHBhc3N3b3JkKSB7XG4gICAgY29uc3QgcmVsZWFzZUxvY2sgPSBhd2FpdCB0aGlzLmNyZWF0ZVZhdWx0TXV0ZXguYWNxdWlyZSgpO1xuICAgIHRyeSB7XG4gICAgICBsZXQgdmF1bHQ7XG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhdWx0ID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5mdWxsVXBkYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXVsdCA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuY3JlYXRlTmV3VmF1bHRBbmRLZXljaGFpbihcbiAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZGRyZXNzZXMoYWRkcmVzc2VzKTtcbiAgICAgICAgdGhpcy5zZWxlY3RGaXJzdElkZW50aXR5KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YXVsdDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFZhdWx0IGFuZCByZXN0b3JlIGFuIGV4aXN0ZW50IGtleXJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VlZFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlKHBhc3N3b3JkLCBzZWVkKSB7XG4gICAgY29uc3QgcmVsZWFzZUxvY2sgPSBhd2FpdCB0aGlzLmNyZWF0ZVZhdWx0TXV0ZXguYWNxdWlyZSgpO1xuICAgIHRyeSB7XG4gICAgICBsZXQgYWNjb3VudHMsIGxhc3RCYWxhbmNlO1xuXG4gICAgICBjb25zdCB7IGtleXJpbmdDb250cm9sbGVyIH0gPSB0aGlzO1xuXG4gICAgICAvLyBjbGVhciBrbm93biBpZGVudGl0aWVzXG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZGRyZXNzZXMoW10pO1xuXG4gICAgICAvLyBjbGVhciBwZXJtaXNzaW9uc1xuICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5jbGVhclN0YXRlKCk7XG5cbiAgICAgIC8vIGNsZWFyIGFjY291bnRzIGluIGFjY291bnRUcmFja2VyXG4gICAgICB0aGlzLmFjY291bnRUcmFja2VyLmNsZWFyQWNjb3VudHMoKTtcblxuICAgICAgLy8gY2xlYXIgY2FjaGVkQmFsYW5jZXNcbiAgICAgIHRoaXMuY2FjaGVkQmFsYW5jZXNDb250cm9sbGVyLmNsZWFyQ2FjaGVkQmFsYW5jZXMoKTtcblxuICAgICAgLy8gY2xlYXIgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnNcbiAgICAgIHRoaXMudHhDb250cm9sbGVyLnR4U3RhdGVNYW5hZ2VyLmNsZWFyVW5hcHByb3ZlZFR4cygpO1xuXG4gICAgICAvLyBjcmVhdGUgbmV3IHZhdWx0XG4gICAgICBjb25zdCB2YXVsdCA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmNyZWF0ZU5ld1ZhdWx0QW5kUmVzdG9yZShcbiAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgIHNlZWQsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBldGhRdWVyeSA9IG5ldyBFdGhRdWVyeSh0aGlzLnByb3ZpZGVyKTtcbiAgICAgIGFjY291bnRzID0gYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICAgIGxhc3RCYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRCYWxhbmNlKFxuICAgICAgICBhY2NvdW50c1thY2NvdW50cy5sZW5ndGggLSAxXSxcbiAgICAgICAgZXRoUXVlcnksXG4gICAgICApO1xuXG4gICAgICBjb25zdCBwcmltYXJ5S2V5cmluZyA9IGtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdzQnlUeXBlKFxuICAgICAgICAnSEQgS2V5IFRyZWUnLFxuICAgICAgKVswXTtcbiAgICAgIGlmICghcHJpbWFyeUtleXJpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhbWFza0NvbnRyb2xsZXIgLSBObyBIRCBLZXkgVHJlZSBmb3VuZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZWVrIG91dCB0aGUgZmlyc3QgemVybyBiYWxhbmNlXG4gICAgICB3aGlsZSAobGFzdEJhbGFuY2UgIT09ICcweDAnKSB7XG4gICAgICAgIGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmFkZE5ld0FjY291bnQocHJpbWFyeUtleXJpbmcpO1xuICAgICAgICBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG4gICAgICAgIGxhc3RCYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRCYWxhbmNlKFxuICAgICAgICAgIGFjY291bnRzW2FjY291bnRzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgIGV0aFF1ZXJ5LFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgZXh0cmEgemVybyBiYWxhbmNlIGFjY291bnQgcG90ZW50aWFsbHkgY3JlYXRlZCBmcm9tIHNlZWtpbmcgYWhlYWRcbiAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPiAxICYmIGxhc3RCYWxhbmNlID09PSAnMHgwJykge1xuICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUFjY291bnQoYWNjb3VudHNbYWNjb3VudHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgbXVzdCBiZSBzZXQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBjb21tdW5pY2F0ZSB0byB0aGVcbiAgICAgIC8vIGtleXJpbmcncyBpZnJhbWUgYW5kIGhhdmUgdGhlIHNldHRpbmcgaW5pdGlhbGl6ZWQgcHJvcGVybHlcbiAgICAgIC8vIE9wdGltaXN0aWNhbGx5IGNhbGxlZCB0byBub3QgYmxvY2sgTWV0YW1hc2sgbG9naW4gZHVlIHRvXG4gICAgICAvLyBMZWRnZXIgS2V5cmluZyBHaXRIdWIgZG93bnRpbWVcbiAgICAgIGNvbnN0IHRyYW5zcG9ydFByZWZlcmVuY2UgPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5nZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgICB0aGlzLnNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0UHJlZmVyZW5jZSk7XG5cbiAgICAgIC8vIHNldCBuZXcgaWRlbnRpdGllc1xuICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0QWRkcmVzc2VzKGFjY291bnRzKTtcbiAgICAgIHRoaXMuc2VsZWN0Rmlyc3RJZGVudGl0eSgpO1xuICAgICAgcmV0dXJuIHZhdWx0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZWxlYXNlTG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gYWNjb3VudCBiYWxhbmNlIGZyb20gdGhlIEFjY291bnRUcmFja2VyIG9yIHJlcXVlc3QgaXQgZGlyZWN0bHkgZnJvbSB0aGUgbmV0d29yay5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgYWNjb3VudCBhZGRyZXNzXG4gICAqIEBwYXJhbSB7RXRoUXVlcnl9IGV0aFF1ZXJ5IC0gVGhlIEV0aFF1ZXJ5IGluc3RhbmNlIHRvIHVzZSB3aGVuIGFza2luZyB0aGUgbmV0d29ya1xuICAgKi9cbiAgZ2V0QmFsYW5jZShhZGRyZXNzLCBldGhRdWVyeSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmFjY291bnRUcmFja2VyLnN0b3JlLmdldFN0YXRlKCkuYWNjb3VudHNbYWRkcmVzc107XG5cbiAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmJhbGFuY2UpIHtcbiAgICAgICAgcmVzb2x2ZShjYWNoZWQuYmFsYW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldGhRdWVyeS5nZXRCYWxhbmNlKGFkZHJlc3MsIChlcnJvciwgYmFsYW5jZSkgPT4ge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoYmFsYW5jZSB8fCAnMHgwJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0cyBhbGwgdGhlIGluZm9ybWF0aW9uIHRoYXQgd2Ugd2FudCB0byBzaGFyZVxuICAgKiB3aXRoIHRoZSBtb2JpbGUgY2xpZW50IGZvciBzeW5jaW5nIHB1cnBvc2VzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFBhcnRzIG9mIHRoZSBzdGF0ZSB0aGF0IHdlIHdhbnQgdG8gc3luY3hcbiAgICovXG4gIGFzeW5jIGZldGNoSW5mb1RvU3luYygpIHtcbiAgICAvLyBQcmVmZXJlbmNlc1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRMb2NhbGUsXG4gICAgICBmcmVxdWVudFJwY0xpc3QsXG4gICAgICBpZGVudGl0aWVzLFxuICAgICAgc2VsZWN0ZWRBZGRyZXNzLFxuICAgICAgdXNlVG9rZW5EZXRlY3Rpb24sXG4gICAgfSA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBjb25zdCB7IHRva2VuTGlzdCB9ID0gdGhpcy50b2tlbkxpc3RDb250cm9sbGVyLnN0YXRlO1xuXG4gICAgY29uc3QgcHJlZmVyZW5jZXMgPSB7XG4gICAgICBjdXJyZW50TG9jYWxlLFxuICAgICAgZnJlcXVlbnRScGNMaXN0LFxuICAgICAgaWRlbnRpdGllcyxcbiAgICAgIHNlbGVjdGVkQWRkcmVzcyxcbiAgICB9O1xuXG4gICAgLy8gVG9rZW5zXG4gICAgY29uc3QgeyBhbGxUb2tlbnMsIGFsbElnbm9yZWRUb2tlbnMgfSA9IHRoaXMudG9rZW5zQ29udHJvbGxlci5zdGF0ZTtcblxuICAgIC8vIEZpbHRlciBFUkMyMCB0b2tlbnNcbiAgICBjb25zdCBhbGxFUkMyMFRva2VucyA9IHt9O1xuXG4gICAgT2JqZWN0LmtleXMoYWxsVG9rZW5zKS5mb3JFYWNoKChjaGFpbklkKSA9PiB7XG4gICAgICBhbGxFUkMyMFRva2Vuc1tjaGFpbklkXSA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMoYWxsVG9rZW5zW2NoYWluSWRdKS5mb3JFYWNoKChhY2NvdW50QWRkcmVzcykgPT4ge1xuICAgICAgICBjb25zdCBjaGVja3N1bW1lZEFjY291bnRBZGRyZXNzID0gdG9DaGVja3N1bUhleEFkZHJlc3MoYWNjb3VudEFkZHJlc3MpO1xuICAgICAgICBhbGxFUkMyMFRva2Vuc1tjaGFpbklkXVtjaGVja3N1bW1lZEFjY291bnRBZGRyZXNzXSA9IGFsbFRva2Vuc1tjaGFpbklkXVtcbiAgICAgICAgICBjaGVja3N1bW1lZEFjY291bnRBZGRyZXNzXG4gICAgICAgIF0uZmlsdGVyKChhc3NldCkgPT4ge1xuICAgICAgICAgIGlmIChhc3NldC5pc0VSQzcyMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgdG9rZW4uYWRkcmVzcyBmcm9tIGFsbFRva2VucyBpcyBjaGVja3N1bWFkZHJlc3NcbiAgICAgICAgICAgIC8vIGFzc2V0LmFkZHJlc3MgaGF2ZSB0byBiZSBjaGFuZ2VkIHRvIGxvd2VyY2FzZSB3aGVuIHdlIGFyZSB1c2luZyBkeW5hbWljIGxpc3RcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB1c2VUb2tlbkRldGVjdGlvblxuICAgICAgICAgICAgICA/IGFzc2V0LmFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICA6IGFzc2V0LmFkZHJlc3M7XG4gICAgICAgICAgICAvLyB0aGUgdG9rZW5MaXN0IHdpbGwgYmUgaG9sZGluZyBvbmx5IGVyYzIwIHRva2Vuc1xuICAgICAgICAgICAgaWYgKHRva2VuTGlzdFthZGRyZXNzXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYXNzZXQuaXNFUkM3MjEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gQWNjb3VudHNcbiAgICBjb25zdCBoZEtleXJpbmcgPSB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdzQnlUeXBlKFxuICAgICAgJ0hEIEtleSBUcmVlJyxcbiAgICApWzBdO1xuICAgIGNvbnN0IHNpbXBsZUtleVBhaXJLZXlyaW5ncyA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoXG4gICAgICAnU2ltcGxlIEtleSBQYWlyJyxcbiAgICApO1xuICAgIGNvbnN0IGhkQWNjb3VudHMgPSBhd2FpdCBoZEtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICBjb25zdCBzaW1wbGVLZXlQYWlyS2V5cmluZ0FjY291bnRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBzaW1wbGVLZXlQYWlyS2V5cmluZ3MubWFwKChrZXlyaW5nKSA9PiBrZXlyaW5nLmdldEFjY291bnRzKCkpLFxuICAgICk7XG4gICAgY29uc3Qgc2ltcGxlS2V5UGFpckFjY291bnRzID0gc2ltcGxlS2V5UGFpcktleXJpbmdBY2NvdW50cy5yZWR1Y2UoXG4gICAgICAoYWNjLCBhY2NvdW50cykgPT4gWy4uLmFjYywgLi4uYWNjb3VudHNdLFxuICAgICAgW10sXG4gICAgKTtcbiAgICBjb25zdCBhY2NvdW50cyA9IHtcbiAgICAgIGhkOiBoZEFjY291bnRzXG4gICAgICAgIC5maWx0ZXIoKGl0ZW0sIHBvcykgPT4gaGRBY2NvdW50cy5pbmRleE9mKGl0ZW0pID09PSBwb3MpXG4gICAgICAgIC5tYXAoKGFkZHJlc3MpID0+IHRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpKSxcbiAgICAgIHNpbXBsZUtleVBhaXI6IHNpbXBsZUtleVBhaXJBY2NvdW50c1xuICAgICAgICAuZmlsdGVyKChpdGVtLCBwb3MpID0+IHNpbXBsZUtleVBhaXJBY2NvdW50cy5pbmRleE9mKGl0ZW0pID09PSBwb3MpXG4gICAgICAgIC5tYXAoKGFkZHJlc3MpID0+IHRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpKSxcbiAgICAgIGxlZGdlcjogW10sXG4gICAgICB0cmV6b3I6IFtdLFxuICAgICAgbGF0dGljZTogW10sXG4gICAgfTtcblxuICAgIC8vIHRyYW5zYWN0aW9uc1xuXG4gICAgbGV0IHsgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnR4Q29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIC8vIGRlbGV0ZSB0eCBmb3Igb3RoZXIgYWNjb3VudHMgdGhhdCB3ZSdyZSBub3QgaW1wb3J0aW5nXG4gICAgdHJhbnNhY3Rpb25zID0gT2JqZWN0LnZhbHVlcyh0cmFuc2FjdGlvbnMpLmZpbHRlcigodHgpID0+IHtcbiAgICAgIGNvbnN0IGNoZWNrc3VtbWVkVHhGcm9tID0gdG9DaGVja3N1bUhleEFkZHJlc3ModHgudHhQYXJhbXMuZnJvbSk7XG4gICAgICByZXR1cm4gYWNjb3VudHMuaGQuaW5jbHVkZXMoY2hlY2tzdW1tZWRUeEZyb20pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRzLFxuICAgICAgcHJlZmVyZW5jZXMsXG4gICAgICB0cmFuc2FjdGlvbnMsXG4gICAgICB0b2tlbnM6IHsgYWxsVG9rZW5zOiBhbGxFUkMyMFRva2VucywgYWxsSWdub3JlZFRva2VucyB9LFxuICAgICAgbmV0d29yazogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLFxuICAgIH07XG4gIH1cblxuICAvKlxuICAgKiBTdWJtaXRzIHRoZSB1c2VyJ3MgcGFzc3dvcmQgYW5kIGF0dGVtcHRzIHRvIHVubG9jayB0aGUgdmF1bHQuXG4gICAqIEFsc28gc3luY2hyb25pemVzIHRoZSBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsIHRvIGVuc3VyZSBpdHMgc2NoZW1hXG4gICAqIGlzIHVwIHRvIGRhdGUgd2l0aCBrbm93biBhY2NvdW50cyBvbmNlIHRoZSB2YXVsdCBpcyBkZWNyeXB0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFRoZSB1c2VyJ3MgcGFzc3dvcmRcbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gVGhlIGtleXJpbmdDb250cm9sbGVyIHVwZGF0ZS5cbiAgICovXG4gIGFzeW5jIHN1Ym1pdFBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zdWJtaXRQYXNzd29yZChwYXNzd29yZCk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5ibG9ja1RyYWNrZXIuY2hlY2tGb3JMYXRlc3RCbG9jaygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoJ0Vycm9yIHdoaWxlIHVubG9ja2luZyBleHRlbnNpb24uJywgZXJyb3IpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0aHJlZUJveFN5bmNpbmdBbGxvd2VkID0gdGhpcy50aHJlZUJveENvbnRyb2xsZXIuZ2V0VGhyZWVCb3hTeW5jaW5nU3RhdGUoKTtcbiAgICAgIGlmICh0aHJlZUJveFN5bmNpbmdBbGxvd2VkICYmICF0aGlzLnRocmVlQm94Q29udHJvbGxlci5ib3gpIHtcbiAgICAgICAgLy8gJ2F3YWl0JyBpbnRlbnRpb25hbGx5IG9taXR0ZWQgdG8gYXZvaWQgd2FpdGluZyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgdGhpcy50aHJlZUJveENvbnRyb2xsZXIuaW5pdCgpO1xuICAgICAgICB0aGlzLnRocmVlQm94Q29udHJvbGxlci50dXJuVGhyZWVCb3hTeW5jaW5nT24oKTtcbiAgICAgIH0gZWxzZSBpZiAodGhyZWVCb3hTeW5jaW5nQWxsb3dlZCAmJiB0aGlzLnRocmVlQm94Q29udHJvbGxlci5ib3gpIHtcbiAgICAgICAgdGhpcy50aHJlZUJveENvbnRyb2xsZXIudHVyblRocmVlQm94U3luY2luZ09uKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcignRXJyb3Igd2hpbGUgdW5sb2NraW5nIGV4dGVuc2lvbi4nLCBlcnJvcik7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBtdXN0IGJlIHNldCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIGNvbW11bmljYXRlIHRvIHRoZVxuICAgIC8vIGtleXJpbmcncyBpZnJhbWUgYW5kIGhhdmUgdGhlIHNldHRpbmcgaW5pdGlhbGl6ZWQgcHJvcGVybHlcbiAgICAvLyBPcHRpbWlzdGljYWxseSBjYWxsZWQgdG8gbm90IGJsb2NrIE1ldGFtYXNrIGxvZ2luIGR1ZSB0b1xuICAgIC8vIExlZGdlciBLZXlyaW5nIEdpdEh1YiBkb3dudGltZVxuICAgIGNvbnN0IHRyYW5zcG9ydFByZWZlcmVuY2UgPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5nZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG5cbiAgICB0aGlzLnNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0UHJlZmVyZW5jZSk7XG5cbiAgICByZXR1cm4gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5mdWxsVXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogU3VibWl0cyBhIHVzZXIncyBwYXNzd29yZCB0byBjaGVjayBpdHMgdmFsaWRpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgdXNlcidzIHBhc3N3b3JkXG4gICAqL1xuICBhc3luYyB2ZXJpZnlQYXNzd29yZChwYXNzd29yZCkge1xuICAgIGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIudmVyaWZ5UGFzc3dvcmQocGFzc3dvcmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIElkZW50aXR5XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGFjY291bnQgbmlja25hbWUuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFjY291bnQncyBldGhlcmV1bSBhZGRyZXNzLCBpbiBsb3dlciBjYXNlLlxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG1heUJlRmF1Y2V0aW5nIC0gV2hldGhlciB0aGlzIGFjY291bnQgaXMgY3VycmVudGx5XG4gICAqIHJlY2VpdmluZyBmdW5kcyBmcm9tIG91ciBhdXRvbWF0aWMgUm9wc3RlbiBmYXVjZXQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaXJzdCBhZGRyZXNzIGluIHRoZSBzdGF0ZSB0byB0aGUgc2VsZWN0ZWQgYWRkcmVzc1xuICAgKi9cbiAgc2VsZWN0Rmlyc3RJZGVudGl0eSgpIHtcbiAgICBjb25zdCB7IGlkZW50aXRpZXMgfSA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgYWRkcmVzcyA9IE9iamVjdC5rZXlzKGlkZW50aXRpZXMpWzBdO1xuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFNlbGVjdGVkQWRkcmVzcyhhZGRyZXNzKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEhhcmR3YXJlXG4gIC8vXG5cbiAgYXN5bmMgZ2V0S2V5cmluZ0ZvckRldmljZShkZXZpY2VOYW1lLCBoZFBhdGggPSBudWxsKSB7XG4gICAgbGV0IGtleXJpbmdOYW1lID0gbnVsbDtcbiAgICBzd2l0Y2ggKGRldmljZU5hbWUpIHtcbiAgICAgIGNhc2UgREVWSUNFX05BTUVTLlRSRVpPUjpcbiAgICAgICAga2V5cmluZ05hbWUgPSBUcmV6b3JLZXlyaW5nLnR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBERVZJQ0VfTkFNRVMuTEVER0VSOlxuICAgICAgICBrZXlyaW5nTmFtZSA9IExlZGdlckJyaWRnZUtleXJpbmcudHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERFVklDRV9OQU1FUy5RUjpcbiAgICAgICAga2V5cmluZ05hbWUgPSBRUkhhcmR3YXJlS2V5cmluZy50eXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgREVWSUNFX05BTUVTLkxBVFRJQ0U6XG4gICAgICAgIGtleXJpbmdOYW1lID0gTGF0dGljZUtleXJpbmcudHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ01ldGFtYXNrQ29udHJvbGxlcjpnZXRLZXlyaW5nRm9yRGV2aWNlIC0gVW5rbm93biBkZXZpY2UnLFxuICAgICAgICApO1xuICAgIH1cbiAgICBsZXQga2V5cmluZyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoXG4gICAgICBrZXlyaW5nTmFtZSxcbiAgICApWzBdO1xuICAgIGlmICgha2V5cmluZykge1xuICAgICAga2V5cmluZyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuYWRkTmV3S2V5cmluZyhrZXlyaW5nTmFtZSk7XG4gICAgfVxuICAgIGlmIChoZFBhdGggJiYga2V5cmluZy5zZXRIZFBhdGgpIHtcbiAgICAgIGtleXJpbmcuc2V0SGRQYXRoKGhkUGF0aCk7XG4gICAgfVxuICAgIGlmIChkZXZpY2VOYW1lID09PSBERVZJQ0VfTkFNRVMuTEFUVElDRSkge1xuICAgICAga2V5cmluZy5hcHBOYW1lID0gJ01ldGFNYXNrJztcbiAgICB9XG4gICAgaWYgKGRldmljZU5hbWUgPT09ICd0cmV6b3InKSB7XG4gICAgICBjb25zdCBtb2RlbCA9IGtleXJpbmcuZ2V0TW9kZWwoKTtcbiAgICAgIHRoaXMuYXBwU3RhdGVDb250cm9sbGVyLnNldFRyZXpvck1vZGVsKG1vZGVsKTtcbiAgICB9XG5cbiAgICBrZXlyaW5nLm5ldHdvcmsgPSB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldFByb3ZpZGVyQ29uZmlnKCkudHlwZTtcblxuICAgIHJldHVybiBrZXlyaW5nO1xuICB9XG5cbiAgYXN5bmMgYXR0ZW1wdExlZGdlclRyYW5zcG9ydENyZWF0aW9uKCkge1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JEZXZpY2UoJ2xlZGdlcicpO1xuICAgIHJldHVybiBhd2FpdCBrZXlyaW5nLmF0dGVtcHRNYWtlQXBwKCk7XG4gIH1cblxuICBhc3luYyBlc3RhYmxpc2hMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKCkge1xuICAgIGNvbnN0IHRyYW5zcG9ydFByZWZlcmVuY2UgPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5nZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSh0cmFuc3BvcnRQcmVmZXJlbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhY2NvdW50IGxpc3QgZnJvbSBhIHRyZXpvciBkZXZpY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIFtdIGFjY291bnRzXG4gICAqL1xuICBhc3luYyBjb25uZWN0SGFyZHdhcmUoZGV2aWNlTmFtZSwgcGFnZSwgaGRQYXRoKSB7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckRldmljZShkZXZpY2VOYW1lLCBoZFBhdGgpO1xuICAgIGxldCBhY2NvdW50cyA9IFtdO1xuICAgIHN3aXRjaCAocGFnZSkge1xuICAgICAgY2FzZSAtMTpcbiAgICAgICAgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nLmdldFByZXZpb3VzUGFnZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nLmdldE5leHRQYWdlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nLmdldEZpcnN0UGFnZSgpO1xuICAgIH1cblxuICAgIC8vIE1lcmdlIHdpdGggZXhpc3RpbmcgYWNjb3VudHNcbiAgICAvLyBhbmQgbWFrZSBzdXJlIGFkZHJlc3NlcyBhcmUgbm90IHJlcGVhdGVkXG4gICAgY29uc3Qgb2xkQWNjb3VudHMgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG4gICAgY29uc3QgYWNjb3VudHNUb1RyYWNrID0gW1xuICAgICAgLi4ubmV3IFNldChcbiAgICAgICAgb2xkQWNjb3VudHMuY29uY2F0KGFjY291bnRzLm1hcCgoYSkgPT4gYS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkpKSxcbiAgICAgICksXG4gICAgXTtcbiAgICB0aGlzLmFjY291bnRUcmFja2VyLnN5bmNXaXRoQWRkcmVzc2VzKGFjY291bnRzVG9UcmFjayk7XG4gICAgcmV0dXJuIGFjY291bnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBkZXZpY2UgaXMgdW5sb2NrZWRcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBjaGVja0hhcmR3YXJlU3RhdHVzKGRldmljZU5hbWUsIGhkUGF0aCkge1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JEZXZpY2UoZGV2aWNlTmFtZSwgaGRQYXRoKTtcbiAgICByZXR1cm4ga2V5cmluZy5pc1VubG9ja2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBmb3JnZXREZXZpY2UoZGV2aWNlTmFtZSkge1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JEZXZpY2UoZGV2aWNlTmFtZSk7XG4gICAga2V5cmluZy5mb3JnZXREZXZpY2UoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgaGFyZHdhcmUgYWNjb3VudCBsYWJlbFxuICAgKlxuICAgKiBAcmV0dXJuIHN0cmluZyBsYWJlbFxuICAgKiAqL1xuXG4gIGdldEFjY291bnRMYWJlbChuYW1lLCBpbmRleCwgaGRQYXRoRGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gYCR7bmFtZVswXS50b1VwcGVyQ2FzZSgpfSR7bmFtZS5zbGljZSgxKX0gJHtcbiAgICAgIHBhcnNlSW50KGluZGV4LCAxMCkgKyAxXG4gICAgfSAke2hkUGF0aERlc2NyaXB0aW9uIHx8ICcnfWAudHJpbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcG9ydHMgYW4gYWNjb3VudCBmcm9tIGEgVHJlem9yIG9yIExlZGdlciBkZXZpY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHt9IGtleVN0YXRlXG4gICAqL1xuICBhc3luYyB1bmxvY2tIYXJkd2FyZVdhbGxldEFjY291bnQoXG4gICAgaW5kZXgsXG4gICAgZGV2aWNlTmFtZSxcbiAgICBoZFBhdGgsXG4gICAgaGRQYXRoRGVzY3JpcHRpb24sXG4gICkge1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JEZXZpY2UoZGV2aWNlTmFtZSwgaGRQYXRoKTtcblxuICAgIGtleXJpbmcuc2V0QWNjb3VudFRvVW5sb2NrKGluZGV4KTtcbiAgICBjb25zdCBvbGRBY2NvdW50cyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICBjb25zdCBrZXlTdGF0ZSA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuYWRkTmV3QWNjb3VudChrZXlyaW5nKTtcbiAgICBjb25zdCBuZXdBY2NvdW50cyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZGRyZXNzZXMobmV3QWNjb3VudHMpO1xuICAgIG5ld0FjY291bnRzLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICAgIGlmICghb2xkQWNjb3VudHMuaW5jbHVkZXMoYWRkcmVzcykpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldEFjY291bnRMYWJlbChcbiAgICAgICAgICBkZXZpY2VOYW1lID09PSBERVZJQ0VfTkFNRVMuUVIgPyBrZXlyaW5nLmdldE5hbWUoKSA6IGRldmljZU5hbWUsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgaGRQYXRoRGVzY3JpcHRpb24sXG4gICAgICAgICk7XG4gICAgICAgIC8vIFNldCB0aGUgYWNjb3VudCBsYWJlbCB0byBUcmV6b3IgMSAvICBMZWRnZXIgMSAvIFFSIEhhcmR3YXJlIDEsIGV0Y1xuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBY2NvdW50TGFiZWwoYWRkcmVzcywgbGFiZWwpO1xuICAgICAgICAvLyBTZWxlY3QgdGhlIGFjY291bnRcbiAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBpZGVudGl0aWVzIH0gPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHJldHVybiB7IC4uLmtleVN0YXRlLCBpZGVudGl0aWVzIH07XG4gIH1cblxuICAvL1xuICAvLyBBY2NvdW50IE1hbmFnZW1lbnRcbiAgLy9cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBhY2NvdW50IHRvIHRoZSBkZWZhdWx0IChmaXJzdCkgSEQgc2VlZCBwaHJhc2UgS2V5cmluZy5cbiAgICpcbiAgICogQHJldHVybnMge30ga2V5U3RhdGVcbiAgICovXG4gIGFzeW5jIGFkZE5ld0FjY291bnQoKSB7XG4gICAgY29uc3QgcHJpbWFyeUtleXJpbmcgPSB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdzQnlUeXBlKFxuICAgICAgJ0hEIEtleSBUcmVlJyxcbiAgICApWzBdO1xuICAgIGlmICghcHJpbWFyeUtleXJpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YW1hc2tDb250cm9sbGVyIC0gTm8gSEQgS2V5IFRyZWUgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBrZXlyaW5nQ29udHJvbGxlciB9ID0gdGhpcztcbiAgICBjb25zdCBvbGRBY2NvdW50cyA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG4gICAgY29uc3Qga2V5U3RhdGUgPSBhd2FpdCBrZXlyaW5nQ29udHJvbGxlci5hZGROZXdBY2NvdW50KHByaW1hcnlLZXlyaW5nKTtcbiAgICBjb25zdCBuZXdBY2NvdW50cyA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG5cbiAgICBhd2FpdCB0aGlzLnZlcmlmeVNlZWRQaHJhc2UoKTtcblxuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFkZHJlc3NlcyhuZXdBY2NvdW50cyk7XG4gICAgbmV3QWNjb3VudHMuZm9yRWFjaCgoYWRkcmVzcykgPT4ge1xuICAgICAgaWYgKCFvbGRBY2NvdW50cy5pbmNsdWRlcyhhZGRyZXNzKSkge1xuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRTZWxlY3RlZEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IGlkZW50aXRpZXMgfSA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgcmV0dXJuIHsgLi4ua2V5U3RhdGUsIGlkZW50aXRpZXMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgdmFsaWRpdHkgb2YgdGhlIGN1cnJlbnQgdmF1bHQncyBzZWVkIHBocmFzZS5cbiAgICpcbiAgICogVmFsaWRpdHk6IHNlZWQgcGhyYXNlIHJlc3RvcmVzIHRoZSBhY2NvdW50cyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgdmF1bHQuXG4gICAqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBmaXJzdCBhY2NvdW50IGlzIGNyZWF0ZWQgYW5kIG9uIHVubG9ja2luZyB0aGUgdmF1bHQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFNlZWQgcGhyYXNlIHRvIGJlIGNvbmZpcm1lZCBieSB0aGUgdXNlci5cbiAgICovXG4gIGFzeW5jIHZlcmlmeVNlZWRQaHJhc2UoKSB7XG4gICAgY29uc3QgcHJpbWFyeUtleXJpbmcgPSB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdzQnlUeXBlKFxuICAgICAgJ0hEIEtleSBUcmVlJyxcbiAgICApWzBdO1xuICAgIGlmICghcHJpbWFyeUtleXJpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YW1hc2tDb250cm9sbGVyIC0gTm8gSEQgS2V5IFRyZWUgZm91bmQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJpYWxpemVkID0gYXdhaXQgcHJpbWFyeUtleXJpbmcuc2VyaWFsaXplKCk7XG4gICAgY29uc3Qgc2VlZFdvcmRzID0gc2VyaWFsaXplZC5tbmVtb25pYztcblxuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgcHJpbWFyeUtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICBpZiAoYWNjb3VudHMubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhbWFza0NvbnRyb2xsZXIgLSBObyBhY2NvdW50cyBmb3VuZCcpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzZWVkUGhyYXNlVmVyaWZpZXIudmVyaWZ5QWNjb3VudHMoYWNjb3VudHMsIHNlZWRXb3Jkcyk7XG4gICAgICByZXR1cm4gc2VlZFdvcmRzO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLmVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSB0cmFuc2FjdGlvbiBoaXN0b3J5LCB0byBhbGxvdyB1c2VycyB0byBmb3JjZS1yZXNldCB0aGVpciBub25jZXMuXG4gICAqIE1vc3RseSB1c2VkIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cywgd2hlbiBuZXR3b3JrcyBhcmUgcmVzdGFydGVkIHdpdGhcbiAgICogdGhlIHNhbWUgbmV0d29yayBJRC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVGhlIGN1cnJlbnQgc2VsZWN0ZWQgYWRkcmVzcy5cbiAgICovXG4gIGFzeW5jIHJlc2V0QWNjb3VudCgpIHtcbiAgICBjb25zdCBzZWxlY3RlZEFkZHJlc3MgPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5nZXRTZWxlY3RlZEFkZHJlc3MoKTtcbiAgICB0aGlzLnR4Q29udHJvbGxlci53aXBlVHJhbnNhY3Rpb25zKHNlbGVjdGVkQWRkcmVzcyk7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5yZXNldENvbm5lY3Rpb24oKTtcblxuICAgIHJldHVybiBzZWxlY3RlZEFkZHJlc3M7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcGVybWl0dGVkIGFjY291bnRzIGZvciB0aGUgc3BlY2lmaWVkIG9yaWdpbi4gUmV0dXJucyBhbiBlbXB0eVxuICAgKiBhcnJheSBpZiBubyBhY2NvdW50cyBhcmUgcGVybWl0dGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIG9yaWdpbiB3aG9zZSBleHBvc2VkIGFjY291bnRzIHRvIHJldHJpZXZlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IFRoZSBvcmlnaW4ncyBwZXJtaXR0ZWQgYWNjb3VudHMsIG9yIGFuIGVtcHR5XG4gICAqIGFycmF5LlxuICAgKi9cbiAgYXN5bmMgZ2V0UGVybWl0dGVkQWNjb3VudHMob3JpZ2luKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLmV4ZWN1dGVSZXN0cmljdGVkTWV0aG9kKFxuICAgICAgICBvcmlnaW4sXG4gICAgICAgIFJlc3RyaWN0ZWRNZXRob2RzLmV0aF9hY2NvdW50cyxcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSBycGNFcnJvckNvZGVzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgZXhwb3NpbmcgdGhlIGFjY291bnQgd2l0aCB0aGUgc3BlY2lmaWVkIGFkZHJlc3MgdG8gYWxsIHRoaXJkIHBhcnRpZXMuXG4gICAqIEV4cG9zZWQgYWNjb3VudHMgYXJlIHN0b3JlZCBpbiBjYXZlYXRzIG9mIHRoZSBldGhfYWNjb3VudHMgcGVybWlzc2lvbi4gVGhpc1xuICAgKiBtZXRob2QgdXNlcyBgUGVybWlzc2lvbkNvbnRyb2xsZXIudXBkYXRlUGVybWlzc2lvbnNCeUNhdmVhdGAgdG9cbiAgICogcmVtb3ZlIHRoZSBzcGVjaWZpZWQgYWRkcmVzcyBmcm9tIGV2ZXJ5IGV0aF9hY2NvdW50cyBwZXJtaXNzaW9uLiBJZiBhXG4gICAqIHBlcm1pc3Npb24gb25seSBpbmNsdWRlZCB0aGlzIGFkZHJlc3MsIHRoZSBwZXJtaXNzaW9uIGlzIHJldm9rZWQgZW50aXJlbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRBY2NvdW50IC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdG8gc3RvcCBleHBvc2luZ1xuICAgKiB0byB0aGlyZCBwYXJ0aWVzLlxuICAgKi9cbiAgcmVtb3ZlQWxsQWNjb3VudFBlcm1pc3Npb25zKHRhcmdldEFjY291bnQpIHtcbiAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLnVwZGF0ZVBlcm1pc3Npb25zQnlDYXZlYXQoXG4gICAgICBDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHMsXG4gICAgICAoZXhpc3RpbmdBY2NvdW50cykgPT5cbiAgICAgICAgQ2F2ZWF0TXV0YXRvckZhY3Rvcmllc1tcbiAgICAgICAgICBDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHNcbiAgICAgICAgXS5yZW1vdmVBY2NvdW50KHRhcmdldEFjY291bnQsIGV4aXN0aW5nQWNjb3VudHMpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhY2NvdW50IGZyb20gc3RhdGUgLyBzdG9yYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhZGRyZXNzIC0gQSBoZXggYWRkcmVzc1xuICAgKlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWNjb3VudChhZGRyZXNzKSB7XG4gICAgLy8gUmVtb3ZlIGFsbCBhc3NvY2lhdGVkIHBlcm1pc3Npb25zXG4gICAgdGhpcy5yZW1vdmVBbGxBY2NvdW50UGVybWlzc2lvbnMoYWRkcmVzcyk7XG4gICAgLy8gUmVtb3ZlIGFjY291bnQgZnJvbSB0aGUgcHJlZmVyZW5jZXMgY29udHJvbGxlclxuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnJlbW92ZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgLy8gUmVtb3ZlIGFjY291bnQgZnJvbSB0aGUgYWNjb3VudCB0cmFja2VyIGNvbnRyb2xsZXJcbiAgICB0aGlzLmFjY291bnRUcmFja2VyLnJlbW92ZUFjY291bnQoW2FkZHJlc3NdKTtcblxuICAgIC8vIFJlbW92ZSBhY2NvdW50IGZyb20gdGhlIGtleXJpbmdcbiAgICBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLnJlbW92ZUFjY291bnQoYWRkcmVzcyk7XG4gICAgcmV0dXJuIGFkZHJlc3M7XG4gIH1cblxuICAvKipcbiAgICogSW1wb3J0cyBhbiBhY2NvdW50IHdpdGggdGhlIHNwZWNpZmllZCBpbXBvcnQgc3RyYXRlZ3kuXG4gICAqIFRoZXNlIGFyZSBkZWZpbmVkIGluIGFwcC9zY3JpcHRzL2FjY291bnQtaW1wb3J0LXN0cmF0ZWdpZXNcbiAgICogRWFjaCBzdHJhdGVneSByZXByZXNlbnRzIGEgZGlmZmVyZW50IHdheSBvZiBzZXJpYWxpemluZyBhbiBFdGhlcmV1bSBrZXkgcGFpci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmF0ZWd5IC0gQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgYW4gYWNjb3VudCBpbXBvcnQgc3RyYXRlZ3kuXG4gICAqIEBwYXJhbSB7YW55fSBhcmdzIC0gVGhlIGRhdGEgcmVxdWlyZWQgYnkgdGhhdCBzdHJhdGVneSB0byBpbXBvcnQgYW4gYWNjb3VudC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBBIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIGEgc3RhdGUgdXBkYXRlIG9uIHN1Y2Nlc3MuXG4gICAqL1xuICBhc3luYyBpbXBvcnRBY2NvdW50V2l0aFN0cmF0ZWd5KHN0cmF0ZWd5LCBhcmdzKSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGF3YWl0IGFjY291bnRJbXBvcnRlci5pbXBvcnRBY2NvdW50KHN0cmF0ZWd5LCBhcmdzKTtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5hZGROZXdLZXlyaW5nKFxuICAgICAgJ1NpbXBsZSBLZXkgUGFpcicsXG4gICAgICBbcHJpdmF0ZUtleV0sXG4gICAgKTtcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICAvLyB1cGRhdGUgYWNjb3VudHMgaW4gcHJlZmVyZW5jZXMgY29udHJvbGxlclxuICAgIGNvbnN0IGFsbEFjY291bnRzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFkZHJlc3NlcyhhbGxBY2NvdW50cyk7XG4gICAgLy8gc2V0IG5ldyBhY2NvdW50IGFzIHNlbGVjdGVkXG4gICAgYXdhaXQgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRBZGRyZXNzKGFjY291bnRzWzBdKTtcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZGVudGl0eSBNYW5hZ2VtZW50IChzaWduYXR1cmUgb3BlcmF0aW9ucylcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBEYXBwIHN1Z2dlc3RzIGEgbmV3IHR4IHRvIGJlIHNpZ25lZC5cbiAgICogdGhpcyB3cmFwcGVyIG5lZWRzIHRvIGV4aXN0IHNvIHdlIGNhbiBwcm92aWRlIGEgcmVmZXJlbmNlIHRvXG4gICAqICBcIm5ld1VuYXBwcm92ZWRUcmFuc2FjdGlvblwiIGJlZm9yZSBcInR4Q29udHJvbGxlclwiIGlzIGluc3RhbnRpYXRlZFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBwYXNzZWQgdG8gZXRoX3NpZ24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXEgLSAob3B0aW9uYWwpIHRoZSBvcmlnaW5hbCByZXF1ZXN0LCBjb250YWluaW5nIHRoZSBvcmlnaW5cbiAgICovXG4gIGFzeW5jIG5ld1VuYXBwcm92ZWRUcmFuc2FjdGlvbih0eFBhcmFtcywgcmVxKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHhDb250cm9sbGVyLm5ld1VuYXBwcm92ZWRUcmFuc2FjdGlvbih0eFBhcmFtcywgcmVxKTtcbiAgfVxuXG4gIC8vIGV0aF9zaWduIG1ldGhvZHM6XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgRGFwcCB1c2VzIHRoZSBldGhfc2lnbiBtZXRob2QsIHRvIHJlcXVlc3QgdXNlciBhcHByb3ZhbC5cbiAgICogZXRoX3NpZ24gaXMgYSBwdXJlIHNpZ25hdHVyZSBvZiBhcmJpdHJhcnkgZGF0YS4gSXQgaXMgb24gYSBkZXByZWNhdGlvblxuICAgKiBwYXRoLCBzaW5jZSB0aGlzIGRhdGEgY2FuIGJlIGEgdHJhbnNhY3Rpb24sIG9yIGNhbiBsZWFrIHByaXZhdGUga2V5XG4gICAqIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBwYXNzZWQgdG8gZXRoX3NpZ24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSBzaWduYXR1cmUuXG4gICAqL1xuICBhc3luYyBuZXdVbnNpZ25lZE1lc3NhZ2UobXNnUGFyYW1zLCByZXEpIHtcbiAgICBjb25zdCBkYXRhID0gbm9ybWFsaXplTXNnRGF0YShtc2dQYXJhbXMuZGF0YSk7XG4gICAgbGV0IHByb21pc2U7XG4gICAgLy8gNjQgaGV4ICsgXCIweFwiIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAvLyBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIEV0aGVyZXVtJ3MgRWNTaWduIHdvcmtzIG9ubHkgb24gMzIgYnl0ZSBudW1iZXJzXG4gICAgLy8gRm9yIDY3IGxlbmd0aCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9tZXRhbWFzay1leHRlbnNpb24vcHVsbC8xMjY3OS9maWxlcyNyNzQ5NDc5NjA3XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSA2NiB8fCBkYXRhLmxlbmd0aCA9PT0gNjcpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLm1lc3NhZ2VNYW5hZ2VyLmFkZFVuYXBwcm92ZWRNZXNzYWdlQXN5bmMobXNnUGFyYW1zLCByZXEpO1xuICAgICAgdGhpcy5zZW5kVXBkYXRlKCk7XG4gICAgICB0aGlzLm9wdHMuc2hvd1VzZXJDb25maXJtYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKFxuICAgICAgICAnZXRoX3NpZ24gcmVxdWlyZXMgMzIgYnl0ZSBtZXNzYWdlIGhhc2gnLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogU2lnbmlmaWVzIHVzZXIgaW50ZW50IHRvIGNvbXBsZXRlIGFuIGV0aF9zaWduIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBwYXJhbXMgcGFzc2VkIHRvIGV0aF9jYWxsLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBGdWxsIHN0YXRlIHVwZGF0ZS5cbiAgICovXG4gIGFzeW5jIHNpZ25NZXNzYWdlKG1zZ1BhcmFtcykge1xuICAgIGxvZy5pbmZvKCdNZXRhTWFza0NvbnRyb2xsZXIgLSBzaWduTWVzc2FnZScpO1xuICAgIGNvbnN0IG1zZ0lkID0gbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgdHJ5IHtcbiAgICAgIC8vIHNldHMgdGhlIHN0YXR1cyBvcCB0aGUgbWVzc2FnZSB0byAnYXBwcm92ZWQnXG4gICAgICAvLyBhbmQgcmVtb3ZlcyB0aGUgbWV0YW1hc2tJZCBmb3Igc2lnbmluZ1xuICAgICAgY29uc3QgY2xlYW5Nc2dQYXJhbXMgPSBhd2FpdCB0aGlzLm1lc3NhZ2VNYW5hZ2VyLmFwcHJvdmVNZXNzYWdlKFxuICAgICAgICBtc2dQYXJhbXMsXG4gICAgICApO1xuICAgICAgY29uc3QgcmF3U2lnID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zaWduTWVzc2FnZShjbGVhbk1zZ1BhcmFtcyk7XG4gICAgICB0aGlzLm1lc3NhZ2VNYW5hZ2VyLnNldE1zZ1N0YXR1c1NpZ25lZChtc2dJZCwgcmF3U2lnKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5pbmZvKCdNZXRhTWFza0NvbnRyb2xsZXIgLSBldGhfc2lnbiBmYWlsZWQnLCBlcnJvcik7XG4gICAgICB0aGlzLm1lc3NhZ2VNYW5hZ2VyLmVycm9yTWVzc2FnZShtc2dJZCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gY2FuY2VsIGEgbWVzc2FnZSBzdWJtaXR0ZWQgdmlhIGV0aF9zaWduLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIG1lc3NhZ2UgdG8gY2FuY2VsLlxuICAgKi9cbiAgY2FuY2VsTWVzc2FnZShtc2dJZCkge1xuICAgIGNvbnN0IHsgbWVzc2FnZU1hbmFnZXIgfSA9IHRoaXM7XG4gICAgbWVzc2FnZU1hbmFnZXIucmVqZWN0TXNnKG1zZ0lkKTtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLy8gcGVyc29uYWxfc2lnbiBtZXRob2RzOlxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGRhcHAgdXNlcyB0aGUgcGVyc29uYWxfc2lnbiBtZXRob2QuXG4gICAqIFRoaXMgaXMgaWRlbnRpY2FsIHRvIHRoZSBHZXRoIGV0aF9zaWduIG1ldGhvZCwgYW5kIG1heSBldmVudHVhbGx5IHJlcGxhY2VcbiAgICogZXRoX3NpZ24uXG4gICAqXG4gICAqIFdlIGN1cnJlbnRseSBkZWZpbmUgb3VyIGV0aF9zaWduIGFuZCBwZXJzb25hbF9zaWduIG1vc3RseSBmb3IgbGVnYWN5IERhcHBzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBvZiB0aGUgbWVzc2FnZSB0byBzaWduICYgcmV0dXJuIHRvIHRoZSBEYXBwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgc2lnbmF0dXJlLlxuICAgKiBQYXNzZWQgYmFjayB0byB0aGUgcmVxdWVzdGluZyBEYXBwLlxuICAgKi9cbiAgYXN5bmMgbmV3VW5zaWduZWRQZXJzb25hbE1lc3NhZ2UobXNnUGFyYW1zLCByZXEpIHtcbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5wZXJzb25hbE1lc3NhZ2VNYW5hZ2VyLmFkZFVuYXBwcm92ZWRNZXNzYWdlQXN5bmMoXG4gICAgICBtc2dQYXJhbXMsXG4gICAgICByZXEsXG4gICAgKTtcbiAgICB0aGlzLnNlbmRVcGRhdGUoKTtcbiAgICB0aGlzLm9wdHMuc2hvd1VzZXJDb25maXJtYXRpb24oKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduaWZpZXMgYSB1c2VyJ3MgYXBwcm92YWwgdG8gc2lnbiBhIHBlcnNvbmFsX3NpZ24gbWVzc2FnZSBpbiBxdWV1ZS5cbiAgICogVHJpZ2dlcnMgc2lnbmluZywgYW5kIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmcm9tIG5ld1Vuc2lnbmVkUGVyc29uYWxNZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBvZiB0aGUgbWVzc2FnZSB0byBzaWduICYgcmV0dXJuIHRvIHRoZSBEYXBwLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIGZ1bGwgc3RhdGUgdXBkYXRlLlxuICAgKi9cbiAgYXN5bmMgc2lnblBlcnNvbmFsTWVzc2FnZShtc2dQYXJhbXMpIHtcbiAgICBsb2cuaW5mbygnTWV0YU1hc2tDb250cm9sbGVyIC0gc2lnblBlcnNvbmFsTWVzc2FnZScpO1xuICAgIGNvbnN0IG1zZ0lkID0gbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgLy8gc2V0cyB0aGUgc3RhdHVzIG9wIHRoZSBtZXNzYWdlIHRvICdhcHByb3ZlZCdcbiAgICAvLyBhbmQgcmVtb3ZlcyB0aGUgbWV0YW1hc2tJZCBmb3Igc2lnbmluZ1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGVhbk1zZ1BhcmFtcyA9IGF3YWl0IHRoaXMucGVyc29uYWxNZXNzYWdlTWFuYWdlci5hcHByb3ZlTWVzc2FnZShcbiAgICAgICAgbXNnUGFyYW1zLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJhd1NpZyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuc2lnblBlcnNvbmFsTWVzc2FnZShcbiAgICAgICAgY2xlYW5Nc2dQYXJhbXMsXG4gICAgICApO1xuICAgICAgLy8gdGVsbHMgdGhlIGxpc3RlbmVyIHRoYXQgdGhlIG1lc3NhZ2UgaGFzIGJlZW4gc2lnbmVkXG4gICAgICAvLyBhbmQgY2FuIGJlIHJldHVybmVkIHRvIHRoZSBkYXBwXG4gICAgICB0aGlzLnBlcnNvbmFsTWVzc2FnZU1hbmFnZXIuc2V0TXNnU3RhdHVzU2lnbmVkKG1zZ0lkLCByYXdTaWcpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmluZm8oJ01ldGFNYXNrQ29udHJvbGxlciAtIGV0aF9wZXJzb25hbFNpZ24gZmFpbGVkJywgZXJyb3IpO1xuICAgICAgdGhpcy5wZXJzb25hbE1lc3NhZ2VNYW5hZ2VyLmVycm9yTWVzc2FnZShtc2dJZCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gY2FuY2VsIGEgcGVyc29uYWxfc2lnbiB0eXBlIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dJZCAtIFRoZSBJRCBvZiB0aGUgbWVzc2FnZSB0byBjYW5jZWwuXG4gICAqL1xuICBjYW5jZWxQZXJzb25hbE1lc3NhZ2UobXNnSWQpIHtcbiAgICBjb25zdCBtZXNzYWdlTWFuYWdlciA9IHRoaXMucGVyc29uYWxNZXNzYWdlTWFuYWdlcjtcbiAgICBtZXNzYWdlTWFuYWdlci5yZWplY3RNc2cobXNnSWQpO1xuICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gIH1cblxuICAvLyBldGhfZGVjcnlwdCBtZXRob2RzXG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgZGFwcCB1c2VzIHRoZSBldGhfZGVjcnlwdCBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIG9mIHRoZSBtZXNzYWdlIHRvIHNpZ24gJiByZXR1cm4gdG8gdGhlIERhcHAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXEgLSAob3B0aW9uYWwpIHRoZSBvcmlnaW5hbCByZXF1ZXN0LCBjb250YWluaW5nIHRoZSBvcmlnaW5cbiAgICogUGFzc2VkIGJhY2sgdG8gdGhlIHJlcXVlc3RpbmcgRGFwcC5cbiAgICovXG4gIGFzeW5jIG5ld1JlcXVlc3REZWNyeXB0TWVzc2FnZShtc2dQYXJhbXMsIHJlcSkge1xuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmRlY3J5cHRNZXNzYWdlTWFuYWdlci5hZGRVbmFwcHJvdmVkTWVzc2FnZUFzeW5jKFxuICAgICAgbXNnUGFyYW1zLFxuICAgICAgcmVxLFxuICAgICk7XG4gICAgdGhpcy5zZW5kVXBkYXRlKCk7XG4gICAgdGhpcy5vcHRzLnNob3dVc2VyQ29uZmlybWF0aW9uKCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogT25seSBkZWNyeXB0IG1lc3NhZ2UgYW5kIGRvbid0IHRvdWNoIHRyYW5zYWN0aW9uIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIG9mIHRoZSBtZXNzYWdlIHRvIGRlY3J5cHQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgZnVsbCBzdGF0ZSB1cGRhdGUuXG4gICAqL1xuICBhc3luYyBkZWNyeXB0TWVzc2FnZUlubGluZShtc2dQYXJhbXMpIHtcbiAgICBsb2cuaW5mbygnTWV0YU1hc2tDb250cm9sbGVyIC0gZGVjcnlwdE1lc3NhZ2VJbmxpbmUnKTtcbiAgICAvLyBkZWNyeXB0IHRoZSBtZXNzYWdlIGlubGluZVxuICAgIGNvbnN0IG1zZ0lkID0gbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgY29uc3QgbXNnID0gdGhpcy5kZWNyeXB0TWVzc2FnZU1hbmFnZXIuZ2V0TXNnKG1zZ0lkKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RyaXBwZWQgPSBzdHJpcEhleFByZWZpeChtc2dQYXJhbXMuZGF0YSk7XG4gICAgICBjb25zdCBidWZmID0gQnVmZmVyLmZyb20oc3RyaXBwZWQsICdoZXgnKTtcbiAgICAgIG1zZ1BhcmFtcy5kYXRhID0gSlNPTi5wYXJzZShidWZmLnRvU3RyaW5nKCd1dGY4JykpO1xuXG4gICAgICBtc2cucmF3RGF0YSA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZGVjcnlwdE1lc3NhZ2UobXNnUGFyYW1zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBtc2cuZXJyb3IgPSBlLm1lc3NhZ2U7XG4gICAgfVxuICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyLl91cGRhdGVNc2cobXNnKTtcblxuICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbmlmaWVzIGEgdXNlcidzIGFwcHJvdmFsIHRvIGRlY3J5cHQgYSBtZXNzYWdlIGluIHF1ZXVlLlxuICAgKiBUcmlnZ2VycyBkZWNyeXB0LCBhbmQgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGZyb20gbmV3VW5zaWduZWREZWNyeXB0TWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBwYXJhbXMgb2YgdGhlIG1lc3NhZ2UgdG8gZGVjcnlwdCAmIHJldHVybiB0byB0aGUgRGFwcC5cbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBmdWxsIHN0YXRlIHVwZGF0ZS5cbiAgICovXG4gIGFzeW5jIGRlY3J5cHRNZXNzYWdlKG1zZ1BhcmFtcykge1xuICAgIGxvZy5pbmZvKCdNZXRhTWFza0NvbnRyb2xsZXIgLSBkZWNyeXB0TWVzc2FnZScpO1xuICAgIGNvbnN0IG1zZ0lkID0gbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgLy8gc2V0cyB0aGUgc3RhdHVzIG9wIHRoZSBtZXNzYWdlIHRvICdhcHByb3ZlZCdcbiAgICAvLyBhbmQgcmVtb3ZlcyB0aGUgbWV0YW1hc2tJZCBmb3IgZGVjcnlwdGlvblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGVhbk1zZ1BhcmFtcyA9IGF3YWl0IHRoaXMuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyLmFwcHJvdmVNZXNzYWdlKFxuICAgICAgICBtc2dQYXJhbXMsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBzdHJpcHBlZCA9IHN0cmlwSGV4UHJlZml4KGNsZWFuTXNnUGFyYW1zLmRhdGEpO1xuICAgICAgY29uc3QgYnVmZiA9IEJ1ZmZlci5mcm9tKHN0cmlwcGVkLCAnaGV4Jyk7XG4gICAgICBjbGVhbk1zZ1BhcmFtcy5kYXRhID0gSlNPTi5wYXJzZShidWZmLnRvU3RyaW5nKCd1dGY4JykpO1xuXG4gICAgICAvLyBkZWNyeXB0IHRoZSBtZXNzYWdlXG4gICAgICBjb25zdCByYXdNZXNzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5kZWNyeXB0TWVzc2FnZShcbiAgICAgICAgY2xlYW5Nc2dQYXJhbXMsXG4gICAgICApO1xuICAgICAgLy8gdGVsbHMgdGhlIGxpc3RlbmVyIHRoYXQgdGhlIG1lc3NhZ2UgaGFzIGJlZW4gZGVjcnlwdGVkIGFuZCBjYW4gYmUgcmV0dXJuZWQgdG8gdGhlIGRhcHBcbiAgICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyLnNldE1zZ1N0YXR1c0RlY3J5cHRlZChtc2dJZCwgcmF3TWVzcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5pbmZvKCdNZXRhTWFza0NvbnRyb2xsZXIgLSBldGhfZGVjcnlwdCBmYWlsZWQuJywgZXJyb3IpO1xuICAgICAgdGhpcy5kZWNyeXB0TWVzc2FnZU1hbmFnZXIuZXJyb3JNZXNzYWdlKG1zZ0lkLCBlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBjYW5jZWwgYSBldGhfZGVjcnlwdCB0eXBlIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dJZCAtIFRoZSBJRCBvZiB0aGUgbWVzc2FnZSB0byBjYW5jZWwuXG4gICAqL1xuICBjYW5jZWxEZWNyeXB0TWVzc2FnZShtc2dJZCkge1xuICAgIGNvbnN0IG1lc3NhZ2VNYW5hZ2VyID0gdGhpcy5kZWNyeXB0TWVzc2FnZU1hbmFnZXI7XG4gICAgbWVzc2FnZU1hbmFnZXIucmVqZWN0TXNnKG1zZ0lkKTtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLy8gZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGRhcHAgdXNlcyB0aGUgZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBvZiB0aGUgbWVzc2FnZSB0byBzaWduICYgcmV0dXJuIHRvIHRoZSBEYXBwLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxIC0gKG9wdGlvbmFsKSB0aGUgb3JpZ2luYWwgcmVxdWVzdCwgY29udGFpbmluZyB0aGUgb3JpZ2luXG4gICAqIFBhc3NlZCBiYWNrIHRvIHRoZSByZXF1ZXN0aW5nIERhcHAuXG4gICAqL1xuICBhc3luYyBuZXdSZXF1ZXN0RW5jcnlwdGlvblB1YmxpY0tleShtc2dQYXJhbXMsIHJlcSkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBtc2dQYXJhbXM7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcyk7XG5cbiAgICBzd2l0Y2ggKGtleXJpbmcudHlwZSkge1xuICAgICAgY2FzZSBLRVlSSU5HX1RZUEVTLkxFREdFUjoge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcignTGVkZ2VyIGRvZXMgbm90IHN1cHBvcnQgZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkuJyksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgS0VZUklOR19UWVBFUy5UUkVaT1I6IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ1RyZXpvciBkb2VzIG5vdCBzdXBwb3J0IGV0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5LicpLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjYXNlIEtFWVJJTkdfVFlQRVMuTEFUVElDRToge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcignTGF0dGljZSBkb2VzIG5vdCBzdXBwb3J0IGV0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5LicpLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjYXNlIEtFWVJJTkdfVFlQRVMuUVI6IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgIG5ldyBFcnJvcignUVIgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleS4nKSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlci5hZGRVbmFwcHJvdmVkTWVzc2FnZUFzeW5jKFxuICAgICAgICAgIG1zZ1BhcmFtcyxcbiAgICAgICAgICByZXEsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc2VuZFVwZGF0ZSgpO1xuICAgICAgICB0aGlzLm9wdHMuc2hvd1VzZXJDb25maXJtYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25pZmllcyBhIHVzZXIncyBhcHByb3ZhbCB0byByZWNlaXZpbmcgZW5jcnlwdGlvbiBwdWJsaWMga2V5IGluIHF1ZXVlLlxuICAgKiBUcmlnZ2VycyByZWNlaXZpbmcsIGFuZCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZnJvbSBuZXdVbnNpZ25lZEVuY3J5cHRpb25QdWJsaWNLZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIG9mIHRoZSBtZXNzYWdlIHRvIHJlY2VpdmUgJiByZXR1cm4gdG8gdGhlIERhcHAuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgZnVsbCBzdGF0ZSB1cGRhdGUuXG4gICAqL1xuICBhc3luYyBlbmNyeXB0aW9uUHVibGljS2V5KG1zZ1BhcmFtcykge1xuICAgIGxvZy5pbmZvKCdNZXRhTWFza0NvbnRyb2xsZXIgLSBlbmNyeXB0aW9uUHVibGljS2V5Jyk7XG4gICAgY29uc3QgbXNnSWQgPSBtc2dQYXJhbXMubWV0YW1hc2tJZDtcbiAgICAvLyBzZXRzIHRoZSBzdGF0dXMgb3AgdGhlIG1lc3NhZ2UgdG8gJ2FwcHJvdmVkJ1xuICAgIC8vIGFuZCByZW1vdmVzIHRoZSBtZXRhbWFza0lkIGZvciBkZWNyeXB0aW9uXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IGF3YWl0IHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleU1hbmFnZXIuYXBwcm92ZU1lc3NhZ2UoXG4gICAgICAgIG1zZ1BhcmFtcyxcbiAgICAgICk7XG5cbiAgICAgIC8vIEVuY3J5cHRpb25QdWJsaWNLZXkgbWVzc2FnZVxuICAgICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRFbmNyeXB0aW9uUHVibGljS2V5KFxuICAgICAgICBwYXJhbXMuZGF0YSxcbiAgICAgICk7XG5cbiAgICAgIC8vIHRlbGxzIHRoZSBsaXN0ZW5lciB0aGF0IHRoZSBtZXNzYWdlIGhhcyBiZWVuIHByb2Nlc3NlZFxuICAgICAgLy8gYW5kIGNhbiBiZSByZXR1cm5lZCB0byB0aGUgZGFwcFxuICAgICAgdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlci5zZXRNc2dTdGF0dXNSZWNlaXZlZChtc2dJZCwgcHVibGljS2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmluZm8oXG4gICAgICAgICdNZXRhTWFza0NvbnRyb2xsZXIgLSBldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleSBmYWlsZWQuJyxcbiAgICAgICAgZXJyb3IsXG4gICAgICApO1xuICAgICAgdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlci5lcnJvck1lc3NhZ2UobXNnSWQsIGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNhbmNlbCBhIGV0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5IHR5cGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1zZ0lkIC0gVGhlIElEIG9mIHRoZSBtZXNzYWdlIHRvIGNhbmNlbC5cbiAgICovXG4gIGNhbmNlbEVuY3J5cHRpb25QdWJsaWNLZXkobXNnSWQpIHtcbiAgICBjb25zdCBtZXNzYWdlTWFuYWdlciA9IHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleU1hbmFnZXI7XG4gICAgbWVzc2FnZU1hbmFnZXIucmVqZWN0TXNnKG1zZ0lkKTtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLy8gZXRoX3NpZ25UeXBlZERhdGEgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGRhcHAgdXNlcyB0aGUgZXRoX3NpZ25UeXBlZERhdGEgbWV0aG9kLCBwZXIgRUlQIDcxMi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBwYXJhbXMgcGFzc2VkIHRvIGV0aF9zaWduVHlwZWREYXRhLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiwgY2FsbGVkIHdpdGggdGhlIHNpZ25hdHVyZS5cbiAgICovXG4gIG5ld1Vuc2lnbmVkVHlwZWRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxLCB2ZXJzaW9uKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMudHlwZWRNZXNzYWdlTWFuYWdlci5hZGRVbmFwcHJvdmVkTWVzc2FnZUFzeW5jKFxuICAgICAgbXNnUGFyYW1zLFxuICAgICAgcmVxLFxuICAgICAgdmVyc2lvbixcbiAgICApO1xuICAgIHRoaXMuc2VuZFVwZGF0ZSgpO1xuICAgIHRoaXMub3B0cy5zaG93VXNlckNvbmZpcm1hdGlvbigpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgZm9yIGEgdXNlciBhcHByb3ZpbmcgYSBjYWxsIHRvIGV0aF9zaWduVHlwZWREYXRhLCBwZXIgRUlQIDcxMi5cbiAgICogVHJpZ2dlcnMgdGhlIGNhbGxiYWNrIGluIG5ld1Vuc2lnbmVkVHlwZWRNZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBwYXNzZWQgdG8gZXRoX3NpZ25UeXBlZERhdGEuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEZ1bGwgc3RhdGUgdXBkYXRlLlxuICAgKi9cbiAgYXN5bmMgc2lnblR5cGVkTWVzc2FnZShtc2dQYXJhbXMpIHtcbiAgICBsb2cuaW5mbygnTWV0YU1hc2tDb250cm9sbGVyIC0gZXRoX3NpZ25UeXBlZERhdGEnKTtcbiAgICBjb25zdCBtc2dJZCA9IG1zZ1BhcmFtcy5tZXRhbWFza0lkO1xuICAgIGNvbnN0IHsgdmVyc2lvbiB9ID0gbXNnUGFyYW1zO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGVhbk1zZ1BhcmFtcyA9IGF3YWl0IHRoaXMudHlwZWRNZXNzYWdlTWFuYWdlci5hcHByb3ZlTWVzc2FnZShcbiAgICAgICAgbXNnUGFyYW1zLFxuICAgICAgKTtcblxuICAgICAgLy8gRm9yIHNvbWUgcmVhc29uIGV2ZXJ5IHZlcnNpb24gYWZ0ZXIgVjEgdXNlZCBzdHJpbmdpZmllZCBwYXJhbXMuXG4gICAgICBpZiAodmVyc2lvbiAhPT0gJ1YxJykge1xuICAgICAgICAvLyBCdXQgd2UgZG9uJ3QgaGF2ZSB0byByZXF1aXJlIHRoYXQuIFdlIGNhbiBzdG9wIHN1Z2dlc3RpbmcgaXQgbm93OlxuICAgICAgICBpZiAodHlwZW9mIGNsZWFuTXNnUGFyYW1zLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY2xlYW5Nc2dQYXJhbXMuZGF0YSA9IEpTT04ucGFyc2UoY2xlYW5Nc2dQYXJhbXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zaWduVHlwZWRNZXNzYWdlKFxuICAgICAgICBjbGVhbk1zZ1BhcmFtcyxcbiAgICAgICAgeyB2ZXJzaW9uIH0sXG4gICAgICApO1xuICAgICAgdGhpcy50eXBlZE1lc3NhZ2VNYW5hZ2VyLnNldE1zZ1N0YXR1c1NpZ25lZChtc2dJZCwgc2lnbmF0dXJlKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5pbmZvKCdNZXRhTWFza0NvbnRyb2xsZXIgLSBldGhfc2lnblR5cGVkRGF0YSBmYWlsZWQuJywgZXJyb3IpO1xuICAgICAgdGhpcy50eXBlZE1lc3NhZ2VNYW5hZ2VyLmVycm9yTWVzc2FnZShtc2dJZCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gY2FuY2VsIGEgZXRoX3NpZ25UeXBlZERhdGEgdHlwZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbXNnSWQgLSBUaGUgSUQgb2YgdGhlIG1lc3NhZ2UgdG8gY2FuY2VsLlxuICAgKi9cbiAgY2FuY2VsVHlwZWRNZXNzYWdlKG1zZ0lkKSB7XG4gICAgY29uc3QgbWVzc2FnZU1hbmFnZXIgPSB0aGlzLnR5cGVkTWVzc2FnZU1hbmFnZXI7XG4gICAgbWVzc2FnZU1hbmFnZXIucmVqZWN0TXNnKG1zZ0lkKTtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBrZXlyaW5nIHR5cGUgc3VwcG9ydHMgRUlQLTE1NTlcbiAgICovXG4gIGFzeW5jIGdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHkoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEVORCAoVkFVTFQgLyBLRVlSSU5HIFJFTEFURUQgTUVUSE9EUylcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgYSB1c2VyIHRvIGF0dGVtcHQgdG8gY2FuY2VsIGEgcHJldmlvdXNseSBzdWJtaXR0ZWQgdHJhbnNhY3Rpb25cbiAgICogYnkgY3JlYXRpbmcgYSBuZXcgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5hbFR4SWQgLSB0aGUgaWQgb2YgdGhlIHR4TWV0YSB0aGF0IHlvdSB3YW50IHRvXG4gICAqICBhdHRlbXB0IHRvIGNhbmNlbFxuICAgKiBAcGFyYW0ge2ltcG9ydChcbiAgICogICcuL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucydcbiAgICogKS5DdXN0b21HYXNTZXR0aW5nc30gW2N1c3RvbUdhc1NldHRpbmdzXSAtIG92ZXJyaWRlcyB0byB1c2UgZm9yIGdhcyBwYXJhbXNcbiAgICogIGluc3RlYWQgb2YgYWxsb3dpbmcgdGhpcyBtZXRob2QgdG8gZ2VuZXJhdGUgdGhlbVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBNZXRhTWFzayBzdGF0ZVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQ2FuY2VsVHJhbnNhY3Rpb24oXG4gICAgb3JpZ2luYWxUeElkLFxuICAgIGN1c3RvbUdhc1NldHRpbmdzLFxuICAgIG5ld1R4TWV0YVByb3BzLFxuICApIHtcbiAgICBhd2FpdCB0aGlzLnR4Q29udHJvbGxlci5jcmVhdGVDYW5jZWxUcmFuc2FjdGlvbihcbiAgICAgIG9yaWdpbmFsVHhJZCxcbiAgICAgIGN1c3RvbUdhc1NldHRpbmdzLFxuICAgICAgbmV3VHhNZXRhUHJvcHMsXG4gICAgKTtcbiAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIGEgdXNlciB0byBhdHRlbXB0IHRvIHNwZWVkIHVwIGEgcHJldmlvdXNseSBzdWJtaXR0ZWQgdHJhbnNhY3Rpb25cbiAgICogYnkgY3JlYXRpbmcgYSBuZXcgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5hbFR4SWQgLSB0aGUgaWQgb2YgdGhlIHR4TWV0YSB0aGF0IHlvdSB3YW50IHRvXG4gICAqICBhdHRlbXB0IHRvIHNwZWVkIHVwXG4gICAqIEBwYXJhbSB7aW1wb3J0KFxuICAgKiAgJy4vY29udHJvbGxlcnMvdHJhbnNhY3Rpb25zJ1xuICAgKiApLkN1c3RvbUdhc1NldHRpbmdzfSBbY3VzdG9tR2FzU2V0dGluZ3NdIC0gb3ZlcnJpZGVzIHRvIHVzZSBmb3IgZ2FzIHBhcmFtc1xuICAgKiAgaW5zdGVhZCBvZiBhbGxvd2luZyB0aGlzIG1ldGhvZCB0byBnZW5lcmF0ZSB0aGVtXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IE1ldGFNYXNrIHN0YXRlXG4gICAqL1xuICBhc3luYyBjcmVhdGVTcGVlZFVwVHJhbnNhY3Rpb24oXG4gICAgb3JpZ2luYWxUeElkLFxuICAgIGN1c3RvbUdhc1NldHRpbmdzLFxuICAgIG5ld1R4TWV0YVByb3BzLFxuICApIHtcbiAgICBhd2FpdCB0aGlzLnR4Q29udHJvbGxlci5jcmVhdGVTcGVlZFVwVHJhbnNhY3Rpb24oXG4gICAgICBvcmlnaW5hbFR4SWQsXG4gICAgICBjdXN0b21HYXNTZXR0aW5ncyxcbiAgICAgIG5ld1R4TWV0YVByb3BzLFxuICAgICk7XG4gICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLmdldFN0YXRlKCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgZXN0aW1hdGVHYXMoZXN0aW1hdGVHYXNQYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMudHhDb250cm9sbGVyLnR4R2FzVXRpbC5xdWVyeS5lc3RpbWF0ZUdhcyhcbiAgICAgICAgZXN0aW1hdGVHYXNQYXJhbXMsXG4gICAgICAgIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXMudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFBBU1NXT1JEIE1BTkFHRU1FTlRcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgYSB1c2VyIHRvIGJlZ2luIHRoZSBzZWVkIHBocmFzZSByZWNvdmVyeSBwcm9jZXNzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIHdoZW4gY29tcGxldGUuXG4gICAqL1xuICBtYXJrUGFzc3dvcmRGb3Jnb3R0ZW4oKSB7XG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0UGFzc3dvcmRGb3Jnb3R0ZW4odHJ1ZSk7XG4gICAgdGhpcy5zZW5kVXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIGEgdXNlciB0byBlbmQgdGhlIHNlZWQgcGhyYXNlIHJlY292ZXJ5IHByb2Nlc3MuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gQSBjYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgd2hlbiBjb21wbGV0ZS5cbiAgICovXG4gIHVuTWFya1Bhc3N3b3JkRm9yZ290dGVuKCkge1xuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFBhc3N3b3JkRm9yZ290dGVuKGZhbHNlKTtcbiAgICB0aGlzLnNlbmRVcGRhdGUoKTtcbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU0VUVVBcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBBIHJ1bnRpbWUuTWVzc2FnZVNlbmRlciBvYmplY3QsIGFzIHByb3ZpZGVkIGJ5IHRoZSBicm93c2VyOlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTW96aWxsYS9BZGQtb25zL1dlYkV4dGVuc2lvbnMvQVBJL3J1bnRpbWUvTWVzc2FnZVNlbmRlclxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXNzYWdlU2VuZGVyXG4gICAqL1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNyZWF0ZSBhIG11bHRpcGxleGVkIHN0cmVhbSBmb3IgY29ubmVjdGluZyB0byBhbiB1bnRydXN0ZWQgY29udGV4dFxuICAgKiBsaWtlIGEgRGFwcCBvciBvdGhlciBleHRlbnNpb24uXG4gICAqIEBwYXJhbSB7Kn0gY29ubmVjdGlvblN0cmVhbSAtIFRoZSBEdXBsZXggc3RyZWFtIHRvIGNvbm5lY3QgdG8uXG4gICAqIEBwYXJhbSB7TWVzc2FnZVNlbmRlcn0gc2VuZGVyIC0gVGhlIHNlbmRlciBvZiB0aGUgbWVzc2FnZXMgb24gdGhpcyBzdHJlYW1cbiAgICovXG4gIHNldHVwVW50cnVzdGVkQ29tbXVuaWNhdGlvbihjb25uZWN0aW9uU3RyZWFtLCBzZW5kZXIpIHtcbiAgICBjb25zdCB7IHVzZVBoaXNoRGV0ZWN0IH0gPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHsgaG9zdG5hbWUgfSA9IG5ldyBVUkwoc2VuZGVyLnVybCk7XG4gICAgLy8gQ2hlY2sgaWYgbmV3IGNvbm5lY3Rpb24gaXMgYmxvY2tlZCBpZiBwaGlzaGluZyBkZXRlY3Rpb24gaXMgb25cbiAgICBpZiAodXNlUGhpc2hEZXRlY3QgJiYgdGhpcy5waGlzaGluZ0NvbnRyb2xsZXIudGVzdChob3N0bmFtZSkpIHtcbiAgICAgIGxvZy5kZWJ1ZygnTWV0YU1hc2sgLSBzZW5kaW5nIHBoaXNoaW5nIHdhcm5pbmcgZm9yJywgaG9zdG5hbWUpO1xuICAgICAgdGhpcy5zZW5kUGhpc2hpbmdXYXJuaW5nKGNvbm5lY3Rpb25TdHJlYW0sIGhvc3RuYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXR1cCBtdWx0aXBsZXhpbmdcbiAgICBjb25zdCBtdXggPSBzZXR1cE11bHRpcGxleChjb25uZWN0aW9uU3RyZWFtKTtcblxuICAgIC8vIG1lc3NhZ2VzIGJldHdlZW4gaW5wYWdlIGFuZCBiYWNrZ3JvdW5kXG4gICAgdGhpcy5zZXR1cFByb3ZpZGVyQ29ubmVjdGlvbihtdXguY3JlYXRlU3RyZWFtKCdtZXRhbWFzay1wcm92aWRlcicpLCBzZW5kZXIpO1xuXG4gICAgLy8gVE9ETzpMZWdhY3lQcm92aWRlcjogRGVsZXRlXG4gICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICB0aGlzLnNldHVwUHVibGljQ29uZmlnKG11eC5jcmVhdGVTdHJlYW0oJ3B1YmxpY0NvbmZpZycpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNyZWF0ZSBhIG11bHRpcGxleGVkIHN0cmVhbSBmb3IgY29ubmVjdGluZyB0byBhIHRydXN0ZWQgY29udGV4dCxcbiAgICogbGlrZSBvdXIgb3duIHVzZXIgaW50ZXJmYWNlcywgd2hpY2ggaGF2ZSB0aGUgcHJvdmlkZXIgQVBJcywgYnV0IGFsc29cbiAgICogcmVjZWl2ZSB0aGUgZXhwb3J0ZWQgQVBJIGZyb20gdGhpcyBjb250cm9sbGVyLCB3aGljaCBpbmNsdWRlcyB0cnVzdGVkXG4gICAqIGZ1bmN0aW9ucywgbGlrZSB0aGUgYWJpbGl0eSB0byBhcHByb3ZlIHRyYW5zYWN0aW9ucyBvciBzaWduIG1lc3NhZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGNvbm5lY3Rpb25TdHJlYW0gLSBUaGUgZHVwbGV4IHN0cmVhbSB0byBjb25uZWN0IHRvLlxuICAgKiBAcGFyYW0ge01lc3NhZ2VTZW5kZXJ9IHNlbmRlciAtIFRoZSBzZW5kZXIgb2YgdGhlIG1lc3NhZ2VzIG9uIHRoaXMgc3RyZWFtXG4gICAqL1xuICBzZXR1cFRydXN0ZWRDb21tdW5pY2F0aW9uKGNvbm5lY3Rpb25TdHJlYW0sIHNlbmRlcikge1xuICAgIC8vIHNldHVwIG11bHRpcGxleGluZ1xuICAgIGNvbnN0IG11eCA9IHNldHVwTXVsdGlwbGV4KGNvbm5lY3Rpb25TdHJlYW0pO1xuICAgIC8vIGNvbm5lY3QgZmVhdHVyZXNcbiAgICB0aGlzLnNldHVwQ29udHJvbGxlckNvbm5lY3Rpb24obXV4LmNyZWF0ZVN0cmVhbSgnY29udHJvbGxlcicpKTtcbiAgICB0aGlzLnNldHVwUHJvdmlkZXJDb25uZWN0aW9uKG11eC5jcmVhdGVTdHJlYW0oJ3Byb3ZpZGVyJyksIHNlbmRlciwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gd2UgZGV0ZWN0IGEgc3VzcGljaW91cyBkb21haW4uIFJlcXVlc3RzIHRoZSBicm93c2VyIHJlZGlyZWN0c1xuICAgKiB0byBvdXIgYW50aS1waGlzaGluZyBwYWdlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IGNvbm5lY3Rpb25TdHJlYW0gLSBUaGUgZHVwbGV4IHN0cmVhbSB0byB0aGUgcGVyLXBhZ2Ugc2NyaXB0LFxuICAgKiBmb3Igc2VuZGluZyB0aGUgcmVsb2FkIGF0dGVtcHQgdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob3N0bmFtZSAtIFRoZSBob3N0bmFtZSB0aGF0IHRyaWdnZXJlZCB0aGUgc3VzcGljaW9uLlxuICAgKi9cbiAgc2VuZFBoaXNoaW5nV2FybmluZyhjb25uZWN0aW9uU3RyZWFtLCBob3N0bmFtZSkge1xuICAgIGNvbnN0IG11eCA9IHNldHVwTXVsdGlwbGV4KGNvbm5lY3Rpb25TdHJlYW0pO1xuICAgIGNvbnN0IHBoaXNoaW5nU3RyZWFtID0gbXV4LmNyZWF0ZVN0cmVhbSgncGhpc2hpbmcnKTtcbiAgICBwaGlzaGluZ1N0cmVhbS53cml0ZSh7IGhvc3RuYW1lIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBwcm92aWRpbmcgb3VyIEFQSSBvdmVyIGEgc3RyZWFtIHVzaW5nIEpTT04tUlBDLlxuICAgKiBAcGFyYW0geyp9IG91dFN0cmVhbSAtIFRoZSBzdHJlYW0gdG8gcHJvdmlkZSBvdXIgQVBJIG92ZXIuXG4gICAqL1xuICBzZXR1cENvbnRyb2xsZXJDb25uZWN0aW9uKG91dFN0cmVhbSkge1xuICAgIGNvbnN0IGFwaSA9IHRoaXMuZ2V0QXBpKCk7XG5cbiAgICAvLyByZXBvcnQgbmV3IGFjdGl2ZSBjb250cm9sbGVyIGNvbm5lY3Rpb25cbiAgICB0aGlzLmFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucyArPSAxO1xuICAgIHRoaXMuZW1pdCgnY29udHJvbGxlckNvbm5lY3Rpb25DaGFuZ2VkJywgdGhpcy5hY3RpdmVDb250cm9sbGVyQ29ubmVjdGlvbnMpO1xuXG4gICAgLy8gc2V0IHVwIHBvc3RTdHJlYW0gdHJhbnNwb3J0XG4gICAgb3V0U3RyZWFtLm9uKCdkYXRhJywgY3JlYXRlTWV0YVJQQ0hhbmRsZXIoYXBpLCBvdXRTdHJlYW0pKTtcbiAgICBjb25zdCBoYW5kbGVVcGRhdGUgPSAodXBkYXRlKSA9PiB7XG4gICAgICBpZiAob3V0U3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIHNlbmQgbm90aWZpY2F0aW9uIHRvIGNsaWVudC1zaWRlXG4gICAgICBvdXRTdHJlYW0ud3JpdGUoe1xuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgbWV0aG9kOiAnc2VuZFVwZGF0ZScsXG4gICAgICAgIHBhcmFtczogW3VwZGF0ZV0sXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMub24oJ3VwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XG4gICAgb3V0U3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucyAtPSAxO1xuICAgICAgdGhpcy5lbWl0KFxuICAgICAgICAnY29udHJvbGxlckNvbm5lY3Rpb25DaGFuZ2VkJyxcbiAgICAgICAgdGhpcy5hY3RpdmVDb250cm9sbGVyQ29ubmVjdGlvbnMsXG4gICAgICApO1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigndXBkYXRlJywgaGFuZGxlVXBkYXRlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCBmb3Igc2VydmluZyBvdXIgZXRoZXJldW0gcHJvdmlkZXIgb3ZlciBhIGdpdmVuIHN0cmVhbS5cbiAgICogQHBhcmFtIHsqfSBvdXRTdHJlYW0gLSBUaGUgc3RyZWFtIHRvIHByb3ZpZGUgb3Zlci5cbiAgICogQHBhcmFtIHtNZXNzYWdlU2VuZGVyfSBzZW5kZXIgLSBUaGUgc2VuZGVyIG9mIHRoZSBtZXNzYWdlcyBvbiB0aGlzIHN0cmVhbVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSW50ZXJuYWwgLSBUcnVlIGlmIHRoaXMgaXMgYSBjb25uZWN0aW9uIHdpdGggYW4gaW50ZXJuYWwgcHJvY2Vzc1xuICAgKi9cbiAgc2V0dXBQcm92aWRlckNvbm5lY3Rpb24ob3V0U3RyZWFtLCBzZW5kZXIsIGlzSW50ZXJuYWwpIHtcbiAgICBjb25zdCBvcmlnaW4gPSBpc0ludGVybmFsID8gJ21ldGFtYXNrJyA6IG5ldyBVUkwoc2VuZGVyLnVybCkub3JpZ2luO1xuICAgIGxldCBzdWJqZWN0VHlwZSA9IGlzSW50ZXJuYWxcbiAgICAgID8gU1VCSkVDVF9UWVBFUy5JTlRFUk5BTFxuICAgICAgOiBTVUJKRUNUX1RZUEVTLldFQlNJVEU7XG5cbiAgICBpZiAoc2VuZGVyLmlkICE9PSB0aGlzLmV4dGVuc2lvbi5ydW50aW1lLmlkKSB7XG4gICAgICBzdWJqZWN0VHlwZSA9IFNVQkpFQ1RfVFlQRVMuRVhURU5TSU9OO1xuICAgICAgdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLmFkZFN1YmplY3RNZXRhZGF0YShvcmlnaW4sIHtcbiAgICAgICAgZXh0ZW5zaW9uSWQ6IHNlbmRlci5pZCxcbiAgICAgICAgc3ViamVjdFR5cGU6IFNVQkpFQ1RfVFlQRVMuRVhURU5TSU9OLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IHRhYklkO1xuICAgIGlmIChzZW5kZXIudGFiICYmIHNlbmRlci50YWIuaWQpIHtcbiAgICAgIHRhYklkID0gc2VuZGVyLnRhYi5pZDtcbiAgICB9XG5cbiAgICBjb25zdCBlbmdpbmUgPSB0aGlzLnNldHVwUHJvdmlkZXJFbmdpbmUoe1xuICAgICAgb3JpZ2luLFxuICAgICAgbG9jYXRpb246IHNlbmRlci51cmwsXG4gICAgICB0YWJJZCxcbiAgICAgIHN1YmplY3RUeXBlLFxuICAgIH0pO1xuXG4gICAgLy8gc2V0dXAgY29ubmVjdGlvblxuICAgIGNvbnN0IHByb3ZpZGVyU3RyZWFtID0gY3JlYXRlRW5naW5lU3RyZWFtKHsgZW5naW5lIH0pO1xuXG4gICAgY29uc3QgY29ubmVjdGlvbklkID0gdGhpcy5hZGRDb25uZWN0aW9uKG9yaWdpbiwgeyBlbmdpbmUgfSk7XG5cbiAgICBwdW1wKG91dFN0cmVhbSwgcHJvdmlkZXJTdHJlYW0sIG91dFN0cmVhbSwgKGVycikgPT4ge1xuICAgICAgLy8gaGFuZGxlIGFueSBtaWRkbGV3YXJlIGNsZWFudXBcbiAgICAgIGVuZ2luZS5fbWlkZGxld2FyZS5mb3JFYWNoKChtaWQpID0+IHtcbiAgICAgICAgaWYgKG1pZC5kZXN0cm95ICYmIHR5cGVvZiBtaWQuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG1pZC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29ubmVjdGlvbklkICYmIHRoaXMucmVtb3ZlQ29ubmVjdGlvbihvcmlnaW4sIGNvbm5lY3Rpb25JZCk7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZy5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBjcmVhdGluZyBhIHByb3ZpZGVyIHRoYXQgaXMgc2FmZWx5IHJlc3RyaWN0ZWQgZm9yIHRoZSByZXF1ZXN0aW5nIHN1YmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUHJvdmlkZXIgZW5naW5lIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc2VuZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxvY2F0aW9uIC0gVGhlIGZ1bGwgVVJMIG9mIHRoZSBzZW5kZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc3ViamVjdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgc2VuZGVyIHN1YmplY3QuXG4gICAqIEBwYXJhbSB7dGFiSWR9IFtvcHRpb25zLnRhYklkXSAtIFRoZSB0YWIgSUQgb2YgdGhlIHNlbmRlciAtIGlmIHRoZSBzZW5kZXIgaXMgd2l0aGluIGEgdGFiXG4gICAqKi9cbiAgc2V0dXBQcm92aWRlckVuZ2luZSh7IG9yaWdpbiwgbG9jYXRpb24sIHN1YmplY3RUeXBlLCB0YWJJZCB9KSB7XG4gICAgLy8gc2V0dXAganNvbiBycGMgZW5naW5lIHN0YWNrXG4gICAgY29uc3QgZW5naW5lID0gbmV3IEpzb25ScGNFbmdpbmUoKTtcbiAgICBjb25zdCB7IHByb3ZpZGVyLCBibG9ja1RyYWNrZXIgfSA9IHRoaXM7XG5cbiAgICAvLyBjcmVhdGUgZmlsdGVyIHBvbHlmaWxsIG1pZGRsZXdhcmVcbiAgICBjb25zdCBmaWx0ZXJNaWRkbGV3YXJlID0gY3JlYXRlRmlsdGVyTWlkZGxld2FyZSh7IHByb3ZpZGVyLCBibG9ja1RyYWNrZXIgfSk7XG5cbiAgICAvLyBjcmVhdGUgc3Vic2NyaXB0aW9uIHBvbHlmaWxsIG1pZGRsZXdhcmVcbiAgICBjb25zdCBzdWJzY3JpcHRpb25NYW5hZ2VyID0gY3JlYXRlU3Vic2NyaXB0aW9uTWFuYWdlcih7XG4gICAgICBwcm92aWRlcixcbiAgICAgIGJsb2NrVHJhY2tlcixcbiAgICB9KTtcbiAgICBzdWJzY3JpcHRpb25NYW5hZ2VyLmV2ZW50cy5vbignbm90aWZpY2F0aW9uJywgKG1lc3NhZ2UpID0+XG4gICAgICBlbmdpbmUuZW1pdCgnbm90aWZpY2F0aW9uJywgbWVzc2FnZSksXG4gICAgKTtcblxuICAgIC8vIGFwcGVuZCBvcmlnaW4gdG8gZWFjaCByZXF1ZXN0XG4gICAgZW5naW5lLnB1c2goY3JlYXRlT3JpZ2luTWlkZGxld2FyZSh7IG9yaWdpbiB9KSk7XG4gICAgLy8gYXBwZW5kIHRhYklkIHRvIGVhY2ggcmVxdWVzdCBpZiBpdCBleGlzdHNcbiAgICBpZiAodGFiSWQpIHtcbiAgICAgIGVuZ2luZS5wdXNoKGNyZWF0ZVRhYklkTWlkZGxld2FyZSh7IHRhYklkIH0pKTtcbiAgICB9XG4gICAgLy8gbG9nZ2luZ1xuICAgIGVuZ2luZS5wdXNoKGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUoeyBvcmlnaW4gfSkpO1xuICAgIGVuZ2luZS5wdXNoKFxuICAgICAgY3JlYXRlT25ib2FyZGluZ01pZGRsZXdhcmUoe1xuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgcmVnaXN0ZXJPbmJvYXJkaW5nOiB0aGlzLm9uYm9hcmRpbmdDb250cm9sbGVyLnJlZ2lzdGVyT25ib2FyZGluZyxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgZW5naW5lLnB1c2godGhpcy5wZXJtaXNzaW9uTG9nQ29udHJvbGxlci5jcmVhdGVNaWRkbGV3YXJlKCkpO1xuICAgIGVuZ2luZS5wdXNoKFxuICAgICAgY3JlYXRlTWV0aG9kTWlkZGxld2FyZSh7XG4gICAgICAgIG9yaWdpbixcblxuICAgICAgICBzdWJqZWN0VHlwZSxcblxuICAgICAgICAvLyBNaXNjZWxsYW5lb3VzXG4gICAgICAgIGFkZFN1YmplY3RNZXRhZGF0YTogdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLmFkZFN1YmplY3RNZXRhZGF0YS5iaW5kKFxuICAgICAgICAgIHRoaXMuc3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgZ2V0UHJvdmlkZXJTdGF0ZTogdGhpcy5nZXRQcm92aWRlclN0YXRlLmJpbmQodGhpcyksXG4gICAgICAgIGdldFVubG9ja1Byb21pc2U6IHRoaXMuYXBwU3RhdGVDb250cm9sbGVyLmdldFVubG9ja1Byb21pc2UuYmluZChcbiAgICAgICAgICB0aGlzLmFwcFN0YXRlQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgaGFuZGxlV2F0Y2hBc3NldFJlcXVlc3Q6IHRoaXMudG9rZW5zQ29udHJvbGxlci53YXRjaEFzc2V0LmJpbmQoXG4gICAgICAgICAgdGhpcy50b2tlbnNDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgICByZXF1ZXN0VXNlckFwcHJvdmFsOiB0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5hZGRBbmRTaG93QXBwcm92YWxSZXF1ZXN0LmJpbmQoXG4gICAgICAgICAgdGhpcy5hcHByb3ZhbENvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIHNlbmRNZXRyaWNzOiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXG4gICAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICAgICksXG5cbiAgICAgICAgLy8gUGVybWlzc2lvbi1yZWxhdGVkXG4gICAgICAgIGdldEFjY291bnRzOiB0aGlzLmdldFBlcm1pdHRlZEFjY291bnRzLmJpbmQodGhpcywgb3JpZ2luKSxcbiAgICAgICAgZ2V0UGVybWlzc2lvbnNGb3JPcmlnaW46IHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIuZ2V0UGVybWlzc2lvbnMuYmluZChcbiAgICAgICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLFxuICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgKSxcbiAgICAgICAgaGFzUGVybWlzc2lvbjogdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5oYXNQZXJtaXNzaW9uLmJpbmQoXG4gICAgICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICksXG4gICAgICAgIHJlcXVlc3RBY2NvdW50c1Blcm1pc3Npb246IHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIucmVxdWVzdFBlcm1pc3Npb25zLmJpbmQoXG4gICAgICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgICAgICAgICB7IG9yaWdpbiB9LFxuICAgICAgICAgIHsgZXRoX2FjY291bnRzOiB7fSB9LFxuICAgICAgICApLFxuXG4gICAgICAgIC8vIEN1c3RvbSBSUEMtcmVsYXRlZFxuICAgICAgICBhZGRDdXN0b21ScGM6IGFzeW5jICh7XG4gICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICBibG9ja0V4cGxvcmVyVXJsLFxuICAgICAgICAgIHRpY2tlcixcbiAgICAgICAgICBjaGFpbk5hbWUsXG4gICAgICAgICAgcnBjVXJsLFxuICAgICAgICB9ID0ge30pID0+IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5hZGRUb0ZyZXF1ZW50UnBjTGlzdChcbiAgICAgICAgICAgIHJwY1VybCxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICB0aWNrZXIsXG4gICAgICAgICAgICBjaGFpbk5hbWUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJsb2NrRXhwbG9yZXJVcmwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRDdXN0b21ScGNCeTogdGhpcy5maW5kQ3VzdG9tUnBjQnkuYmluZCh0aGlzKSxcbiAgICAgICAgZ2V0Q3VycmVudENoYWluSWQ6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0Q3VycmVudENoYWluSWQuYmluZChcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgICBzZXRQcm92aWRlclR5cGU6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc2V0UHJvdmlkZXJUeXBlLmJpbmQoXG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgdXBkYXRlUnBjVGFyZ2V0OiAoeyBycGNVcmwsIGNoYWluSWQsIHRpY2tlciwgbmlja25hbWUgfSkgPT4ge1xuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc2V0UnBjVGFyZ2V0KFxuICAgICAgICAgICAgcnBjVXJsLFxuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgIHRpY2tlcixcbiAgICAgICAgICAgIG5pY2tuYW1lLFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gV2ViMyBzaGltLXJlbGF0ZWRcbiAgICAgICAgZ2V0V2ViM1NoaW1Vc2FnZVN0YXRlOiB0aGlzLmFsZXJ0Q29udHJvbGxlci5nZXRXZWIzU2hpbVVzYWdlU3RhdGUuYmluZChcbiAgICAgICAgICB0aGlzLmFsZXJ0Q29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgc2V0V2ViM1NoaW1Vc2FnZVJlY29yZGVkOiB0aGlzLmFsZXJ0Q29udHJvbGxlci5zZXRXZWIzU2hpbVVzYWdlUmVjb3JkZWQuYmluZChcbiAgICAgICAgICB0aGlzLmFsZXJ0Q29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgLy8gZmlsdGVyIGFuZCBzdWJzY3JpcHRpb24gcG9seWZpbGxzXG4gICAgZW5naW5lLnB1c2goZmlsdGVyTWlkZGxld2FyZSk7XG4gICAgZW5naW5lLnB1c2goc3Vic2NyaXB0aW9uTWFuYWdlci5taWRkbGV3YXJlKTtcbiAgICBpZiAoc3ViamVjdFR5cGUgIT09IFNVQkpFQ1RfVFlQRVMuSU5URVJOQUwpIHtcbiAgICAgIC8vIHBlcm1pc3Npb25zXG4gICAgICBlbmdpbmUucHVzaChcbiAgICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5jcmVhdGVQZXJtaXNzaW9uTWlkZGxld2FyZSh7XG4gICAgICAgICAgb3JpZ2luLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIGZvcndhcmQgdG8gbWV0YW1hc2sgcHJpbWFyeSBwcm92aWRlclxuICAgIGVuZ2luZS5wdXNoKHByb3ZpZGVyQXNNaWRkbGV3YXJlKHByb3ZpZGVyKSk7XG4gICAgcmV0dXJuIGVuZ2luZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPOkxlZ2FjeVByb3ZpZGVyOiBEZWxldGVcbiAgICogQSBtZXRob2QgZm9yIHByb3ZpZGluZyBvdXIgcHVibGljIGNvbmZpZyBpbmZvIG92ZXIgYSBzdHJlYW0uXG4gICAqIFRoaXMgaW5jbHVkZXMgaW5mbyB3ZSBsaWtlIHRvIGJlIHN5bmNocm9ub3VzIGlmIHBvc3NpYmxlLCBsaWtlXG4gICAqIHRoZSBjdXJyZW50IHNlbGVjdGVkIGFjY291bnQsIGFuZCBuZXR3b3JrIElELlxuICAgKlxuICAgKiBTaW5jZSBzeW5jaHJvbm91cyBtZXRob2RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGluIHdlYjMsXG4gICAqIHRoaXMgaXMgYSBnb29kIGNhbmRpZGF0ZSBmb3IgZGVwcmVjYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gb3V0U3RyZWFtIC0gVGhlIHN0cmVhbSB0byBwcm92aWRlIHB1YmxpYyBjb25maWcgb3Zlci5cbiAgICovXG4gIHNldHVwUHVibGljQ29uZmlnKG91dFN0cmVhbSkge1xuICAgIGNvbnN0IGNvbmZpZ1N0cmVhbSA9IHN0b3JlQXNTdHJlYW0odGhpcy5wdWJsaWNDb25maWdTdG9yZSk7XG5cbiAgICBwdW1wKGNvbmZpZ1N0cmVhbSwgb3V0U3RyZWFtLCAoZXJyKSA9PiB7XG4gICAgICBjb25maWdTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2cuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcmVmZXJlbmNlIHRvIGEgY29ubmVjdGlvbiBieSBvcmlnaW4uIElnbm9yZXMgdGhlICdtZXRhbWFzaycgb3JpZ2luLlxuICAgKiBDYWxsZXIgbXVzdCBlbnN1cmUgdGhhdCB0aGUgcmV0dXJuZWQgaWQgaXMgc3RvcmVkIHN1Y2ggdGhhdCB0aGUgcmVmZXJlbmNlXG4gICAqIGNhbiBiZSBkZWxldGVkIGxhdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIGNvbm5lY3Rpb24ncyBvcmlnaW4gc3RyaW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIERhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmVuZ2luZSAtIFRoZSBjb25uZWN0aW9uJ3MgSlNPTiBScGMgRW5naW5lXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb25uZWN0aW9uJ3MgaWQgKHNvIHRoYXQgaXQgY2FuIGJlIGRlbGV0ZWQgbGF0ZXIpXG4gICAqL1xuICBhZGRDb25uZWN0aW9uKG9yaWdpbiwgeyBlbmdpbmUgfSkge1xuICAgIGlmIChvcmlnaW4gPT09ICdtZXRhbWFzaycpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb25uZWN0aW9uc1tvcmlnaW5dKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25zW29yaWdpbl0gPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IG5hbm9pZCgpO1xuICAgIHRoaXMuY29ubmVjdGlvbnNbb3JpZ2luXVtpZF0gPSB7XG4gICAgICBlbmdpbmUsXG4gICAgfTtcblxuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgcmVmZXJlbmNlIHRvIGEgY29ubmVjdGlvbiwgYnkgb3JpZ2luIGFuZCBpZC5cbiAgICogSWdub3JlcyB1bmtub3duIG9yaWdpbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gLSBUaGUgY29ubmVjdGlvbidzIG9yaWdpbiBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBjb25uZWN0aW9uJ3MgaWQsIGFzIHJldHVybmVkIGZyb20gYWRkQ29ubmVjdGlvbi5cbiAgICovXG4gIHJlbW92ZUNvbm5lY3Rpb24ob3JpZ2luLCBpZCkge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdGhpcy5jb25uZWN0aW9uc1tvcmlnaW5dO1xuICAgIGlmICghY29ubmVjdGlvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWxldGUgY29ubmVjdGlvbnNbaWRdO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKGNvbm5lY3Rpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbm5lY3Rpb25zW29yaWdpbl07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhdXNlcyB0aGUgUlBDIGVuZ2luZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25uZWN0aW9ucyB0byB0aGUgZ2l2ZW4gb3JpZ2luXG4gICAqIHRvIGVtaXQgYSBub3RpZmljYXRpb24gZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gcGF5bG9hZC5cbiAgICpcbiAgICogVGhlIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgdGhhdCBvbmx5IHBlcm1pdHRlZCBub3RpZmljYXRpb25zXG4gICAqIGFyZSBzZW50LlxuICAgKlxuICAgKiBJZ25vcmVzIHVua25vd24gb3JpZ2lucy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBjb25uZWN0aW9uJ3Mgb3JpZ2luIHN0cmluZy5cbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXlsb2FkIC0gVGhlIGV2ZW50IHBheWxvYWQuXG4gICAqL1xuICBub3RpZnlDb25uZWN0aW9ucyhvcmlnaW4sIHBheWxvYWQpIHtcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuY29ubmVjdGlvbnNbb3JpZ2luXTtcblxuICAgIGlmIChjb25uZWN0aW9ucykge1xuICAgICAgT2JqZWN0LnZhbHVlcyhjb25uZWN0aW9ucykuZm9yRWFjaCgoY29ubikgPT4ge1xuICAgICAgICBpZiAoY29ubi5lbmdpbmUpIHtcbiAgICAgICAgICBjb25uLmVuZ2luZS5lbWl0KCdub3RpZmljYXRpb24nLCBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhdXNlcyB0aGUgUlBDIGVuZ2luZXMgYXNzb2NpYXRlZCB3aXRoIGFsbCBjb25uZWN0aW9ucyB0byBlbWl0IGFcbiAgICogbm90aWZpY2F0aW9uIGV2ZW50IHdpdGggdGhlIGdpdmVuIHBheWxvYWQuXG4gICAqXG4gICAqIElmIHRoZSBcInBheWxvYWRcIiBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiwgdGhlIHBheWxvYWQgZm9yIGVhY2ggY29ubmVjdGlvblxuICAgKiB3aWxsIGJlIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhhdCBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgY29ubmVjdGlvbidzXG4gICAqIG9yaWdpbi5cbiAgICpcbiAgICogVGhlIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgdGhhdCBvbmx5IHBlcm1pdHRlZCBub3RpZmljYXRpb25zXG4gICAqIGFyZSBzZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3Vua25vd259IHBheWxvYWQgLSBUaGUgZXZlbnQgcGF5bG9hZCwgb3IgcGF5bG9hZCBnZXR0ZXIgZnVuY3Rpb24uXG4gICAqL1xuICBub3RpZnlBbGxDb25uZWN0aW9ucyhwYXlsb2FkKSB7XG4gICAgY29uc3QgZ2V0UGF5bG9hZCA9XG4gICAgICB0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IChvcmlnaW4pID0+IHBheWxvYWQob3JpZ2luKVxuICAgICAgICA6ICgpID0+IHBheWxvYWQ7XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLmNvbm5lY3Rpb25zKS5mb3JFYWNoKChvcmlnaW4pID0+IHtcbiAgICAgIE9iamVjdC52YWx1ZXModGhpcy5jb25uZWN0aW9uc1tvcmlnaW5dKS5mb3JFYWNoKGFzeW5jIChjb25uKSA9PiB7XG4gICAgICAgIGlmIChjb25uLmVuZ2luZSkge1xuICAgICAgICAgIGNvbm4uZW5naW5lLmVtaXQoJ25vdGlmaWNhdGlvbicsIGF3YWl0IGdldFBheWxvYWQob3JpZ2luKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gaGFuZGxlcnNcblxuICAvKipcbiAgICogSGFuZGxlIGEgS2V5cmluZ0NvbnRyb2xsZXIgdXBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAtIHRoZSBLQyBzdGF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF9vbktleXJpbmdDb250cm9sbGVyVXBkYXRlKHN0YXRlKSB7XG4gICAgY29uc3QgeyBrZXlyaW5ncyB9ID0gc3RhdGU7XG4gICAgY29uc3QgYWRkcmVzc2VzID0ga2V5cmluZ3MucmVkdWNlKFxuICAgICAgKGFjYywgeyBhY2NvdW50cyB9KSA9PiBhY2MuY29uY2F0KGFjY291bnRzKSxcbiAgICAgIFtdLFxuICAgICk7XG5cbiAgICBpZiAoIWFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgcHJlZmVyZW5jZXMgKyBpZGVudGl0aWVzIGNvbnRyb2xsZXIga25vdyBhYm91dCBhbGwgYWRkcmVzc2VzXG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3luY0FkZHJlc3NlcyhhZGRyZXNzZXMpO1xuICAgIHRoaXMuYWNjb3VudFRyYWNrZXIuc3luY1dpdGhBZGRyZXNzZXMoYWRkcmVzc2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgZ2xvYmFsIGFwcGxpY2F0aW9uIHVubG9jay5cbiAgICogTm90aWZpZXMgYWxsIGNvbm5lY3Rpb25zIHRoYXQgdGhlIGV4dGVuc2lvbiBpcyB1bmxvY2tlZCwgYW5kIHdoaWNoXG4gICAqIGFjY291bnQocykgYXJlIGN1cnJlbnRseSBhY2Nlc3NpYmxlLCBpZiBhbnkuXG4gICAqL1xuICBfb25VbmxvY2soKSB7XG4gICAgdGhpcy5ub3RpZnlBbGxDb25uZWN0aW9ucyhhc3luYyAob3JpZ2luKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2Q6IE5PVElGSUNBVElPTl9OQU1FUy51bmxvY2tTdGF0ZUNoYW5nZWQsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGlzVW5sb2NrZWQ6IHRydWUsXG4gICAgICAgICAgYWNjb3VudHM6IGF3YWl0IHRoaXMuZ2V0UGVybWl0dGVkQWNjb3VudHMob3JpZ2luKSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBJbiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiwgdGhpcyBoYW5kbGVyIGlzIHRyaWdnZXJlZCBieSBhXG4gICAgLy8gS2V5cmluZ0NvbnRyb2xsZXIgZXZlbnQuIE90aGVyIGNvbnRyb2xsZXJzIHN1YnNjcmliZSB0byB0aGUgJ3VubG9jaydcbiAgICAvLyBldmVudCBvZiB0aGUgTWV0YU1hc2tDb250cm9sbGVyIGl0c2VsZi5cbiAgICB0aGlzLmVtaXQoJ3VubG9jaycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBnbG9iYWwgYXBwbGljYXRpb24gbG9jay5cbiAgICogTm90aWZpZXMgYWxsIGNvbm5lY3Rpb25zIHRoYXQgdGhlIGV4dGVuc2lvbiBpcyBsb2NrZWQuXG4gICAqL1xuICBfb25Mb2NrKCkge1xuICAgIHRoaXMubm90aWZ5QWxsQ29ubmVjdGlvbnMoe1xuICAgICAgbWV0aG9kOiBOT1RJRklDQVRJT05fTkFNRVMudW5sb2NrU3RhdGVDaGFuZ2VkLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGlzVW5sb2NrZWQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIEluIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uLCB0aGlzIGhhbmRsZXIgaXMgdHJpZ2dlcmVkIGJ5IGFcbiAgICAvLyBLZXlyaW5nQ29udHJvbGxlciBldmVudC4gT3RoZXIgY29udHJvbGxlcnMgc3Vic2NyaWJlIHRvIHRoZSAnbG9jaydcbiAgICAvLyBldmVudCBvZiB0aGUgTWV0YU1hc2tDb250cm9sbGVyIGl0c2VsZi5cbiAgICB0aGlzLmVtaXQoJ2xvY2snKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgbWVtb3J5IHN0YXRlIHVwZGF0ZXMuXG4gICAqIC0gRW5zdXJlIGlzQ2xpZW50T3BlbkFuZFVubG9ja2VkIGlzIHVwZGF0ZWRcbiAgICogLSBOb3RpZmllcyBhbGwgY29ubmVjdGlvbnMgd2l0aCB0aGUgbmV3IHByb3ZpZGVyIG5ldHdvcmsgc3RhdGVcbiAgICogICAtIFRoZSBleHRlcm5hbCBwcm92aWRlcnMgaGFuZGxlIGRpZmZpbmcgdGhlIHN0YXRlXG4gICAqL1xuICBfb25TdGF0ZVVwZGF0ZShuZXdTdGF0ZSkge1xuICAgIHRoaXMuaXNDbGllbnRPcGVuQW5kVW5sb2NrZWQgPSBuZXdTdGF0ZS5pc1VubG9ja2VkICYmIHRoaXMuX2lzQ2xpZW50T3BlbjtcbiAgICB0aGlzLm5vdGlmeUFsbENvbm5lY3Rpb25zKHtcbiAgICAgIG1ldGhvZDogTk9USUZJQ0FUSU9OX05BTUVTLmNoYWluQ2hhbmdlZCxcbiAgICAgIHBhcmFtczogdGhpcy5nZXRQcm92aWRlck5ldHdvcmtTdGF0ZShuZXdTdGF0ZSksXG4gICAgfSk7XG4gIH1cblxuICAvLyBtaXNjXG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBlbWl0dGluZyB0aGUgZnVsbCBNZXRhTWFzayBzdGF0ZSB0byBhbGwgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlU2VuZFVwZGF0ZSgpIHtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0U3RhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGV4dGVuc2lvbiBpcyB1bmxvY2tlZC5cbiAgICovXG4gIGlzVW5sb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIubWVtU3RvcmUuZ2V0U3RhdGUoKS5pc1VubG9ja2VkO1xuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBNSVNDRUxMQU5FT1VTXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbm9uY2UgdGhhdCB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aCBhIHRyYW5zYWN0aW9uIG9uY2UgYXBwcm92ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgaGV4IHN0cmluZyBhZGRyZXNzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn1cbiAgICovXG4gIGFzeW5jIGdldFBlbmRpbmdOb25jZShhZGRyZXNzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbm9uY2VEZXRhaWxzLFxuICAgICAgcmVsZWFzZUxvY2ssXG4gICAgfSA9IGF3YWl0IHRoaXMudHhDb250cm9sbGVyLm5vbmNlVHJhY2tlci5nZXROb25jZUxvY2soYWRkcmVzcyk7XG4gICAgY29uc3QgcGVuZGluZ05vbmNlID0gbm9uY2VEZXRhaWxzLnBhcmFtcy5oaWdoZXN0U3VnZ2VzdGVkO1xuXG4gICAgcmVsZWFzZUxvY2soKTtcbiAgICByZXR1cm4gcGVuZGluZ05vbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5leHQgbm9uY2UgYWNjb3JkaW5nIHRvIHRoZSBub25jZS10cmFja2VyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGhleCBzdHJpbmcgYWRkcmVzcyBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAqL1xuICBhc3luYyBnZXROZXh0Tm9uY2UoYWRkcmVzcykge1xuICAgIGNvbnN0IG5vbmNlTG9jayA9IGF3YWl0IHRoaXMudHhDb250cm9sbGVyLm5vbmNlVHJhY2tlci5nZXROb25jZUxvY2soXG4gICAgICBhZGRyZXNzLFxuICAgICk7XG4gICAgbm9uY2VMb2NrLnJlbGVhc2VMb2NrKCk7XG4gICAgcmV0dXJuIG5vbmNlTG9jay5uZXh0Tm9uY2U7XG4gIH1cblxuICAvKipcbiAgICogTWlncmF0ZSBhZGRyZXNzIGJvb2sgc3RhdGUgZnJvbSBvbGQgdG8gbmV3IGNoYWluSWQuXG4gICAqXG4gICAqIEFkZHJlc3MgYm9vayBzdGF0ZSBpcyBrZXllZCBieSB0aGUgYG5ldHdvcmtTdG9yZWAgc3RhdGUgZnJvbSB0aGUgbmV0d29yayBjb250cm9sbGVyLiBUaGlzIHZhbHVlIGlzIHNldCB0byB0aGVcbiAgICogYG5ldHdvcmtJZGAgZm9yIG91ciBidWlsdC1pbiBJbmZ1cmEgbmV0d29ya3MsIGJ1dCBpdCdzIHNldCB0byB0aGUgYGNoYWluSWRgIGZvciBjdXN0b20gbmV0d29ya3MuXG4gICAqIFdoZW4gdGhpcyBgY2hhaW5JZGAgdmFsdWUgaXMgY2hhbmdlZCBmb3IgY3VzdG9tIFJQQyBlbmRwb2ludHMsIHdlIG5lZWQgdG8gbWlncmF0ZSBhbnkgY29udGFjdHMgc3RvcmVkIHVuZGVyIHRoZVxuICAgKiBvbGQga2V5IHRvIHRoZSBuZXcga2V5LlxuICAgKlxuICAgKiBUaGUgYGR1cGxpY2F0ZWAgcGFyYW1ldGVyIGlzIHVzZWQgdG8gc3BlY2lmeSB0aGF0IHRoZSBjb250YWN0cyB1bmRlciB0aGUgb2xkIGtleSBzaG91bGQgbm90IGJlIHJlbW92ZWQuIFRoaXMgaXNcbiAgICogdXNlZnVsIGluIHRoZSBjYXNlIHdoZXJlIHR3byBSUEMgZW5kcG9pbnRzIHNoYXJlZCB0aGUgc2FtZSBzZXQgb2YgY29udGFjdHMsIGFuZCB3ZSdyZSBub3Qgc3VyZSB3aGljaCBvbmUgZWFjaFxuICAgKiBjb250YWN0IGJlbG9uZ3MgdW5kZXIuIER1cGxpY2F0aW5nIHRoZSBjb250YWN0cyB1bmRlciBib3RoIGtleXMgaXMgdGhlIG9ubHkgd2F5IHRvIGVuc3VyZSB0aGV5IGFyZSBub3QgbG9zdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9sZENoYWluSWQgLSBUaGUgb2xkIGNoYWluSWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0NoYWluSWQgLSBUaGUgbmV3IGNoYWluSWRcbiAgICogQHBhcmFtIHtib29sZWFufSBbZHVwbGljYXRlXSAtIFdoZXRoZXIgdG8gZHVwbGljYXRlIHRoZSBhZGRyZXNzZXMgb24gYm90aCBjaGFpbklkcyAoZGVmYXVsdDogZmFsc2UpXG4gICAqL1xuICBhc3luYyBtaWdyYXRlQWRkcmVzc0Jvb2tTdGF0ZShvbGRDaGFpbklkLCBuZXdDaGFpbklkLCBkdXBsaWNhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHsgYWRkcmVzc0Jvb2sgfSA9IHRoaXMuYWRkcmVzc0Jvb2tDb250cm9sbGVyLnN0YXRlO1xuXG4gICAgaWYgKCFhZGRyZXNzQm9va1tvbGRDaGFpbklkXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBPYmplY3Qua2V5cyhhZGRyZXNzQm9va1tvbGRDaGFpbklkXSkpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gYWRkcmVzc0Jvb2tbb2xkQ2hhaW5JZF1bYWRkcmVzc107XG4gICAgICB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlci5zZXQoXG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGVudHJ5Lm5hbWUsXG4gICAgICAgIG5ld0NoYWluSWQsXG4gICAgICAgIGVudHJ5Lm1lbW8sXG4gICAgICApO1xuICAgICAgaWYgKCFkdXBsaWNhdGUpIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzQm9va0NvbnRyb2xsZXIuZGVsZXRlKG9sZENoYWluSWQsIGFkZHJlc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gQ09ORklHXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvLyBMb2cgYmxvY2tzXG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBzZWxlY3RpbmcgYSBjdXN0b20gVVJMIGZvciBhbiBldGhlcmV1bSBSUEMgcHJvdmlkZXIgYW5kIHVwZGF0aW5nIGl0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBycGNVcmwgLSBBIFVSTCBmb3IgYSB2YWxpZCBFdGhlcmV1bSBSUEMgQVBJLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZCAtIFRoZSBjaGFpbklkIG9mIHRoZSBzZWxlY3RlZCBuZXR3b3JrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGlja2VyIC0gVGhlIHRpY2tlciBzeW1ib2wgb2YgdGhlIHNlbGVjdGVkIG5ldHdvcmsuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmlja25hbWVdIC0gTmlja25hbWUgb2YgdGhlIHNlbGVjdGVkIG5ldHdvcmsuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcnBjUHJlZnNdIC0gUlBDIHByZWZlcmVuY2VzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JwY1ByZWZzLmJsb2NrRXhwbG9yZXJVcmxdIC0gVVJMIG9mIGJsb2NrIGV4cGxvcmVyIGZvciB0aGUgY2hhaW4uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFN0cmluZz59IC0gVGhlIFJQQyBUYXJnZXQgVVJMIGNvbmZpcm1lZC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZUFuZFNldEN1c3RvbVJwYyhcbiAgICBycGNVcmwsXG4gICAgY2hhaW5JZCxcbiAgICB0aWNrZXIgPSAnRVRIJyxcbiAgICBuaWNrbmFtZSxcbiAgICBycGNQcmVmcyxcbiAgKSB7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zZXRScGNUYXJnZXQoXG4gICAgICBycGNVcmwsXG4gICAgICBjaGFpbklkLFxuICAgICAgdGlja2VyLFxuICAgICAgbmlja25hbWUsXG4gICAgICBycGNQcmVmcyxcbiAgICApO1xuICAgIGF3YWl0IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnVwZGF0ZVJwYyh7XG4gICAgICBycGNVcmwsXG4gICAgICBjaGFpbklkLFxuICAgICAgdGlja2VyLFxuICAgICAgbmlja25hbWUsXG4gICAgICBycGNQcmVmcyxcbiAgICB9KTtcbiAgICByZXR1cm4gcnBjVXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBzZWxlY3RpbmcgYSBjdXN0b20gVVJMIGZvciBhbiBldGhlcmV1bSBSUEMgcHJvdmlkZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBycGNVcmwgLSBBIFVSTCBmb3IgYSB2YWxpZCBFdGhlcmV1bSBSUEMgQVBJLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZCAtIFRoZSBjaGFpbklkIG9mIHRoZSBzZWxlY3RlZCBuZXR3b3JrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGlja2VyIC0gVGhlIHRpY2tlciBzeW1ib2wgb2YgdGhlIHNlbGVjdGVkIG5ldHdvcmsuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuaWNrbmFtZSAtIE9wdGlvbmFsIG5pY2tuYW1lIG9mIHRoZSBzZWxlY3RlZCBuZXR3b3JrLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdHJpbmc+fSBUaGUgUlBDIFRhcmdldCBVUkwgY29uZmlybWVkLlxuICAgKi9cbiAgYXN5bmMgc2V0Q3VzdG9tUnBjKFxuICAgIHJwY1VybCxcbiAgICBjaGFpbklkLFxuICAgIHRpY2tlciA9ICdFVEgnLFxuICAgIG5pY2tuYW1lID0gJycsXG4gICAgcnBjUHJlZnMgPSB7fSxcbiAgKSB7XG4gICAgY29uc3QgZnJlcXVlbnRScGNMaXN0RGV0YWlsID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0RnJlcXVlbnRScGNMaXN0RGV0YWlsKCk7XG4gICAgY29uc3QgcnBjU2V0dGluZ3MgPSBmcmVxdWVudFJwY0xpc3REZXRhaWwuZmluZChcbiAgICAgIChycGMpID0+IHJwY1VybCA9PT0gcnBjLnJwY1VybCxcbiAgICApO1xuXG4gICAgaWYgKHJwY1NldHRpbmdzKSB7XG4gICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnNldFJwY1RhcmdldChcbiAgICAgICAgcnBjU2V0dGluZ3MucnBjVXJsLFxuICAgICAgICBycGNTZXR0aW5ncy5jaGFpbklkLFxuICAgICAgICBycGNTZXR0aW5ncy50aWNrZXIsXG4gICAgICAgIHJwY1NldHRpbmdzLm5pY2tuYW1lLFxuICAgICAgICBycGNQcmVmcyxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc2V0UnBjVGFyZ2V0KFxuICAgICAgICBycGNVcmwsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHRpY2tlcixcbiAgICAgICAgbmlja25hbWUsXG4gICAgICAgIHJwY1ByZWZzLFxuICAgICAgKTtcbiAgICAgIGF3YWl0IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLmFkZFRvRnJlcXVlbnRScGNMaXN0KFxuICAgICAgICBycGNVcmwsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHRpY2tlcixcbiAgICAgICAgbmlja25hbWUsXG4gICAgICAgIHJwY1ByZWZzLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJwY1VybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCBmb3IgZGVsZXRpbmcgYSBzZWxlY3RlZCBjdXN0b20gVVJMLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcnBjVXJsIC0gQSBSUEMgVVJMIHRvIGRlbGV0ZS5cbiAgICovXG4gIGFzeW5jIGRlbEN1c3RvbVJwYyhycGNVcmwpIHtcbiAgICBhd2FpdCB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5yZW1vdmVGcm9tRnJlcXVlbnRScGNMaXN0KHJwY1VybCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgUlBDIGluZm8gb2JqZWN0IHRoYXQgbWF0Y2hlcyBhdCBsZWFzdCBvbmUgZmllbGQgb2YgdGhlXG4gICAqIHByb3ZpZGVkIHNlYXJjaCBjcml0ZXJpYS4gUmV0dXJucyBudWxsIGlmIG5vIG1hdGNoIGlzIGZvdW5kXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBycGNJbmZvIC0gVGhlIFJQQyBlbmRwb2ludCBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHJwY0luZm8gZm91bmQgaW4gdGhlIGZyZXF1ZW50UnBjTGlzdFxuICAgKi9cbiAgZmluZEN1c3RvbVJwY0J5KHJwY0luZm8pIHtcbiAgICBjb25zdCBmcmVxdWVudFJwY0xpc3REZXRhaWwgPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5nZXRGcmVxdWVudFJwY0xpc3REZXRhaWwoKTtcbiAgICBmb3IgKGNvbnN0IGV4aXN0aW5nUnBjSW5mbyBvZiBmcmVxdWVudFJwY0xpc3REZXRhaWwpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJwY0luZm8pKSB7XG4gICAgICAgIGlmIChleGlzdGluZ1JwY0luZm9ba2V5XSA9PT0gcnBjSW5mb1trZXldKSB7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nUnBjSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGluaXRpYWxpemVUaHJlZUJveCgpIHtcbiAgICBhd2FpdCB0aGlzLnRocmVlQm94Q29udHJvbGxlci5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgTGVkZ2VyIExpdmUgcHJlZmVyZW5jZSB0byB1c2UgZm9yIExlZGdlciBoYXJkd2FyZSB3YWxsZXQgc3VwcG9ydFxuICAgKiBAcGFyYW0ge2Jvb2x9IGJvb2wgLSB0aGUgdmFsdWUgcmVwcmVzZW50aW5nIGlmIHRoZSB1c2VycyB3YW50cyB0byB1c2UgTGVkZ2VyIExpdmVcbiAgICovXG4gIGFzeW5jIHNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0VHlwZSkge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UoXG4gICAgICB0cmFuc3BvcnRUeXBlLFxuICAgICk7XG5cbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yRGV2aWNlKCdsZWRnZXInKTtcbiAgICBpZiAoa2V5cmluZz8udXBkYXRlVHJhbnNwb3J0TWV0aG9kKSB7XG4gICAgICByZXR1cm4ga2V5cmluZy51cGRhdGVUcmFuc3BvcnRNZXRob2QobmV3VmFsdWUpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciB1cGRhdGluZyB0aGUgdHJhbnNwb3J0LCB3ZSBzaG91bGRcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBpbml0aWFsaXppbmcgc3RvcmFnZSB0aGUgZmlyc3QgdGltZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGluaXRTdGF0ZSAtIFRoZSBkZWZhdWx0IHN0YXRlIHRvIGluaXRpYWxpemUgd2l0aC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlY29yZEZpcnN0VGltZUluZm8oaW5pdFN0YXRlKSB7XG4gICAgaWYgKCEoJ2ZpcnN0VGltZUluZm8nIGluIGluaXRTdGF0ZSkpIHtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnBsYXRmb3JtLmdldFZlcnNpb24oKTtcbiAgICAgIGluaXRTdGF0ZS5maXJzdFRpbWVJbmZvID0ge1xuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBkYXRlOiBEYXRlLm5vdygpLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBSZXBsYWNlIGlzQ2xpZW50T3BlbiBtZXRob2RzIHdpdGggYGNvbnRyb2xsZXJDb25uZWN0aW9uQ2hhbmdlZGAgZXZlbnRzLlxuICAvKiBlc2xpbnQtZGlzYWJsZSBhY2Nlc3Nvci1wYWlycyAqL1xuICAvKipcbiAgICogQSBtZXRob2QgZm9yIHJlY29yZGluZyB3aGV0aGVyIHRoZSBNZXRhTWFzayB1c2VyIGludGVyZmFjZSBpcyBvcGVuIG9yIG5vdC5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcGVuXG4gICAqL1xuICBzZXQgaXNDbGllbnRPcGVuKG9wZW4pIHtcbiAgICB0aGlzLl9pc0NsaWVudE9wZW4gPSBvcGVuO1xuICAgIHRoaXMuZGV0ZWN0VG9rZW5zQ29udHJvbGxlci5pc09wZW4gPSBvcGVuO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgYWNjZXNzb3ItcGFpcnMgKi9cblxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgYnkgdGhlIGJhY2tncm91bmQgd2hlbiBhbGwgaW5zdGFuY2VzIG9mIG1ldGFtYXNrIGFyZSBjbG9zZWQuXG4gICAqIEN1cnJlbnRseSB1c2VkIHRvIHN0b3AgcG9sbGluZyBpbiB0aGUgZ2FzRmVlQ29udHJvbGxlci5cbiAgICovXG4gIG9uQ2xpZW50Q2xvc2VkKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIuc3RvcFBvbGxpbmcoKTtcbiAgICAgIHRoaXMuYXBwU3RhdGVDb250cm9sbGVyLmNsZWFyUG9sbGluZ1Rva2VucygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgYnkgdGhlIGJhY2tncm91bmQgd2hlbiBhIHBhcnRpY3VsYXIgZW52aXJvbm1lbnQgdHlwZSBpcyBjbG9zZWQgKGZ1bGxzY3JlZW4sIHBvcHVwLCBub3RpZmljYXRpb24pLlxuICAgKiBDdXJyZW50bHkgdXNlZCB0byBzdG9wIHBvbGxpbmcgaW4gdGhlIGdhc0ZlZUNvbnRyb2xsZXIgZm9yIG9ubHkgdGhhdCBlbnZpcm9uZW1lbnQgdHlwZVxuICAgKi9cbiAgb25FbnZpcm9ubWVudFR5cGVDbG9zZWQoZW52aXJvbm1lbnRUeXBlKSB7XG4gICAgY29uc3QgYXBwU3RhdGVQb2xsaW5nVG9rZW5UeXBlID1cbiAgICAgIFBPTExJTkdfVE9LRU5fRU5WSVJPTk1FTlRfVFlQRVNbZW52aXJvbm1lbnRUeXBlXTtcbiAgICBjb25zdCBwb2xsaW5nVG9rZW5zVG9EaXNjb25uZWN0ID0gdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKVtcbiAgICAgIGFwcFN0YXRlUG9sbGluZ1Rva2VuVHlwZVxuICAgIF07XG4gICAgcG9sbGluZ1Rva2Vuc1RvRGlzY29ubmVjdC5mb3JFYWNoKChwb2xsaW5nVG9rZW4pID0+IHtcbiAgICAgIHRoaXMuZ2FzRmVlQ29udHJvbGxlci5kaXNjb25uZWN0UG9sbGVyKHBvbGxpbmdUb2tlbik7XG4gICAgICB0aGlzLmFwcFN0YXRlQ29udHJvbGxlci5yZW1vdmVQb2xsaW5nVG9rZW4oXG4gICAgICAgIHBvbGxpbmdUb2tlbixcbiAgICAgICAgYXBwU3RhdGVQb2xsaW5nVG9rZW5UeXBlLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgZG9tYWluIHRvIHRoZSBQaGlzaGluZ0NvbnRyb2xsZXIgc2FmZWxpc3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lIC0gdGhlIGRvbWFpbiB0byBzYWZlbGlzdFxuICAgKi9cbiAgc2FmZWxpc3RQaGlzaGluZ0RvbWFpbihob3N0bmFtZSkge1xuICAgIHJldHVybiB0aGlzLnBoaXNoaW5nQ29udHJvbGxlci5ieXBhc3MoaG9zdG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvY2tzIE1ldGFNYXNrXG4gICAqL1xuICBzZXRMb2NrZWQoKSB7XG4gICAgY29uc3QgW3RyZXpvcktleXJpbmddID0gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nc0J5VHlwZShcbiAgICAgIEtFWVJJTkdfVFlQRVMuVFJFWk9SLFxuICAgICk7XG4gICAgaWYgKHRyZXpvcktleXJpbmcpIHtcbiAgICAgIHRyZXpvcktleXJpbmcuZGlzcG9zZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zZXRMb2NrZWQoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gKiBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gKiBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAqIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuIFRoZSBmdW5jdGlvbiBhbHNvIGhhcyBhIHByb3BlcnR5ICdjbGVhcicgXG4gKiB0aGF0IGlzIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBjbGVhciB0aGUgdGltZXIgdG8gcHJldmVudCBwcmV2aW91c2x5IHNjaGVkdWxlZCBleGVjdXRpb25zLiBcbiAqXG4gKiBAc291cmNlIHVuZGVyc2NvcmUuanNcbiAqIEBzZWUgaHR0cDovL3Vuc2NyaXB0YWJsZS5jb20vMjAwOS8wMy8yMC9kZWJvdW5jaW5nLWphdmFzY3JpcHQtbWV0aG9kcy9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uIHRvIHdyYXBcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IGluIG1zIChgMTAwYClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciB0byBleGVjdXRlIGF0IHRoZSBiZWdpbm5pbmcgKGBmYWxzZWApXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKXtcbiAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuICBpZiAobnVsbCA9PSB3YWl0KSB3YWl0ID0gMTAwO1xuXG4gIGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgIHZhciBsYXN0ID0gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcblxuICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZGVib3VuY2VkID0gZnVuY3Rpb24oKXtcbiAgICBjb250ZXh0ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBkZWJvdW5jZWQuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9O1xuICBcbiAgZGVib3VuY2VkLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICBcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZGVib3VuY2VkO1xufTtcbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuXG4vLyB0aHJvdWdoXG4vL1xuLy8gYSBzdHJlYW0gdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHJlLWVtaXQgdGhlIGlucHV0LlxuLy8gdXNlZnVsIGZvciBhZ2dyZWdhdGluZyBhIHNlcmllcyBvZiBjaGFuZ2luZyBidXQgbm90IGVuZGluZyBzdHJlYW1zIGludG8gb25lIHN0cmVhbSlcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdGhyb3VnaFxudGhyb3VnaC50aHJvdWdoID0gdGhyb3VnaFxuXG4vL2NyZWF0ZSBhIHJlYWRhYmxlIHdyaXRhYmxlIHN0cmVhbS5cblxuZnVuY3Rpb24gdGhyb3VnaCAod3JpdGUsIGVuZCwgb3B0cykge1xuICB3cml0ZSA9IHdyaXRlIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHRoaXMucXVldWUoZGF0YSkgfVxuICBlbmQgPSBlbmQgfHwgZnVuY3Rpb24gKCkgeyB0aGlzLnF1ZXVlKG51bGwpIH1cblxuICB2YXIgZW5kZWQgPSBmYWxzZSwgZGVzdHJveWVkID0gZmFsc2UsIGJ1ZmZlciA9IFtdLCBfZW5kZWQgPSBmYWxzZVxuICB2YXIgc3RyZWFtID0gbmV3IFN0cmVhbSgpXG4gIHN0cmVhbS5yZWFkYWJsZSA9IHN0cmVhbS53cml0YWJsZSA9IHRydWVcbiAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG5cbi8vICBzdHJlYW0uYXV0b1BhdXNlICAgPSAhKG9wdHMgJiYgb3B0cy5hdXRvUGF1c2UgICA9PT0gZmFsc2UpXG4gIHN0cmVhbS5hdXRvRGVzdHJveSA9ICEob3B0cyAmJiBvcHRzLmF1dG9EZXN0cm95ID09PSBmYWxzZSlcblxuICBzdHJlYW0ud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHdyaXRlLmNhbGwodGhpcywgZGF0YSlcbiAgICByZXR1cm4gIXN0cmVhbS5wYXVzZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWluKCkge1xuICAgIHdoaWxlKGJ1ZmZlci5sZW5ndGggJiYgIXN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHZhciBkYXRhID0gYnVmZmVyLnNoaWZ0KClcbiAgICAgIGlmKG51bGwgPT09IGRhdGEpXG4gICAgICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZW5kJylcbiAgICAgIGVsc2VcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5xdWV1ZSA9IHN0cmVhbS5wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbi8vICAgIGNvbnNvbGUuZXJyb3IoZW5kZWQpXG4gICAgaWYoX2VuZGVkKSByZXR1cm4gc3RyZWFtXG4gICAgaWYoZGF0YSA9PT0gbnVsbCkgX2VuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgZHJhaW4oKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIC8vdGhpcyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgdGhlIGZpcnN0ICdlbmQnIGxpc3RlbmVyXG4gIC8vbXVzdCBjYWxsIGRlc3Ryb3kgbmV4dCB0aWNrLCB0byBtYWtlIHN1cmUgd2UncmUgYWZ0ZXIgYW55XG4gIC8vc3RyZWFtIHBpcGVkIGZyb20gaGVyZS5cbiAgLy90aGlzIGlzIG9ubHkgYSBwcm9ibGVtIGlmIGVuZCBpcyBub3QgZW1pdHRlZCBzeW5jaHJvbm91c2x5LlxuICAvL2EgbmljZXIgd2F5IHRvIGRvIHRoaXMgaXMgdG8gbWFrZSBzdXJlIHRoaXMgaXMgdGhlIGxhc3QgbGlzdGVuZXIgZm9yICdlbmQnXG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBpZighc3RyZWFtLndyaXRhYmxlICYmIHN0cmVhbS5hdXRvRGVzdHJveSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpXG4gICAgICB9KVxuICB9KVxuXG4gIGZ1bmN0aW9uIF9lbmQgKCkge1xuICAgIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlXG4gICAgZW5kLmNhbGwoc3RyZWFtKVxuICAgIGlmKCFzdHJlYW0ucmVhZGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9XG5cbiAgc3RyZWFtLmVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYoZW5kZWQpIHJldHVyblxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHN0cmVhbS53cml0ZShkYXRhKVxuICAgIF9lbmQoKSAvLyB3aWxsIGVtaXQgb3IgcXVldWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihkZXN0cm95ZWQpIHJldHVyblxuICAgIGRlc3Ryb3llZCA9IHRydWVcbiAgICBlbmRlZCA9IHRydWVcbiAgICBidWZmZXIubGVuZ3RoID0gMFxuICAgIHN0cmVhbS53cml0YWJsZSA9IHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgc3RyZWFtLmVtaXQoJ2Nsb3NlJylcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkgcmV0dXJuXG4gICAgc3RyZWFtLnBhdXNlZCA9IHRydWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHN0cmVhbS5wYXVzZWQgPSBmYWxzZVxuICAgICAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpXG4gICAgfVxuICAgIGRyYWluKClcbiAgICAvL21heSBoYXZlIGJlY29tZSBwYXVzZWQgYWdhaW4sXG4gICAgLy9hcyBkcmFpbiBlbWl0cyAnZGF0YScuXG4gICAgaWYoIXN0cmVhbS5wYXVzZWQpXG4gICAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuICByZXR1cm4gc3RyZWFtXG59XG5cbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpXG52YXIgd3JpdGVNZXRob2RzID0gW1wid3JpdGVcIiwgXCJlbmRcIiwgXCJkZXN0cm95XCJdXG52YXIgcmVhZE1ldGhvZHMgPSBbXCJyZXN1bWVcIiwgXCJwYXVzZVwiXVxudmFyIHJlYWRFdmVudHMgPSBbXCJkYXRhXCIsIFwiY2xvc2VcIl1cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGR1cGxleFxuXG5mdW5jdGlvbiBmb3JFYWNoIChhcnIsIGZuKSB7XG4gICAgaWYgKGFyci5mb3JFYWNoKSB7XG4gICAgICAgIHJldHVybiBhcnIuZm9yRWFjaChmbilcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbihhcnJbaV0sIGkpXG4gICAgfVxufVxuXG5mdW5jdGlvbiBkdXBsZXgod3JpdGVyLCByZWFkZXIpIHtcbiAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmVhbSgpXG4gICAgdmFyIGVuZGVkID0gZmFsc2VcblxuICAgIGZvckVhY2god3JpdGVNZXRob2RzLCBwcm94eVdyaXRlcilcblxuICAgIGZvckVhY2gocmVhZE1ldGhvZHMsIHByb3h5UmVhZGVyKVxuXG4gICAgZm9yRWFjaChyZWFkRXZlbnRzLCBwcm94eVN0cmVhbSlcblxuICAgIHJlYWRlci5vbihcImVuZFwiLCBoYW5kbGVFbmQpXG5cbiAgICB3cml0ZXIub24oXCJkcmFpblwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHN0cmVhbS5lbWl0KFwiZHJhaW5cIilcbiAgICB9KVxuXG4gICAgd3JpdGVyLm9uKFwiZXJyb3JcIiwgcmVlbWl0KVxuICAgIHJlYWRlci5vbihcImVycm9yXCIsIHJlZW1pdClcblxuICAgIHN0cmVhbS53cml0YWJsZSA9IHdyaXRlci53cml0YWJsZVxuICAgIHN0cmVhbS5yZWFkYWJsZSA9IHJlYWRlci5yZWFkYWJsZVxuXG4gICAgcmV0dXJuIHN0cmVhbVxuXG4gICAgZnVuY3Rpb24gcHJveHlXcml0ZXIobWV0aG9kTmFtZSkge1xuICAgICAgICBzdHJlYW1bbWV0aG9kTmFtZV0gPSBtZXRob2RcblxuICAgICAgICBmdW5jdGlvbiBtZXRob2QoKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyW21ldGhvZE5hbWVdLmFwcGx5KHdyaXRlciwgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJveHlSZWFkZXIobWV0aG9kTmFtZSkge1xuICAgICAgICBzdHJlYW1bbWV0aG9kTmFtZV0gPSBtZXRob2RcblxuICAgICAgICBmdW5jdGlvbiBtZXRob2QoKSB7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdChtZXRob2ROYW1lKVxuICAgICAgICAgICAgdmFyIGZ1bmMgPSByZWFkZXJbbWV0aG9kTmFtZV1cbiAgICAgICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkocmVhZGVyLCBhcmd1bWVudHMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuZW1pdChtZXRob2ROYW1lKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJveHlTdHJlYW0obWV0aG9kTmFtZSkge1xuICAgICAgICByZWFkZXIub24obWV0aG9kTmFtZSwgcmVlbWl0KVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlZW1pdCgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQobWV0aG9kTmFtZSlcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0LmFwcGx5KHN0cmVhbSwgYXJncylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUVuZCgpIHtcbiAgICAgICAgaWYgKGVuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBlbmRlZCA9IHRydWVcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICAgYXJncy51bnNoaWZ0KFwiZW5kXCIpXG4gICAgICAgIHN0cmVhbS5lbWl0LmFwcGx5KHN0cmVhbSwgYXJncylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWVtaXQoZXJyKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KFwiZXJyb3JcIiwgZXJyKVxuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdG9yZUFzU3RyZWFtID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY2xhc3MgT2JzZXJ2YWJsZVN0b3JlU3RyZWFtIGV4dGVuZHMgc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3RvcihvYnNTdG9yZSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAvLyBwYXNzIHZhbHVlcywgbm90IHNlcmlhbGl6YXRpb25zXG4gICAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZG9udCBidWZmZXIgb3V0Z29pbmcgdXBkYXRlc1xuICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICAvLyBzYXZlIGhhbmRsZXIgc28gd2UgY2FuIHVuc3Vic2NyaWJlIGxhdGVyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IChzdGF0ZSkgPT4gdGhpcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG9ic1N0b3JlIGNoYW5nZXNcbiAgICAgICAgdGhpcy5vYnNTdG9yZSA9IG9ic1N0b3JlO1xuICAgICAgICB0aGlzLm9ic1N0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBlbWl0IGN1cnJlbnQgc3RhdGUgb24gbmV3IGRlc3RpbmF0aW9uXG4gICAgcGlwZShkZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBpcGUoZGVzdCwgb3B0aW9ucyk7XG4gICAgICAgIGRlc3Qud3JpdGUodGhpcy5vYnNTdG9yZS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gd3JpdGUgZnJvbSBpbmNvbWluZyBzdHJlYW0gdG8gc3RhdGVcbiAgICBfd3JpdGUoY2h1bmssIF9lbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vYnNTdG9yZS5wdXRTdGF0ZShjaHVuayk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIC8vIG5vb3AgLSBvdXRnb2luZyBzdHJlYW0gaXMgYXNraW5nIHVzIGlmIHdlIGhhdmUgZGF0YSB3ZSBhcmVudCBnaXZpbmcgaXRcbiAgICBfcmVhZChfc2l6ZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGV2ZW50IGVtaXR0ZXJcbiAgICBfZGVzdHJveShlcnIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub2JzU3RvcmUudW5zdWJzY3JpYmUodGhpcy5oYW5kbGVyKTtcbiAgICAgICAgc3VwZXIuX2Rlc3Ryb3koZXJyLCBjYWxsYmFjayk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RvcmVBc1N0cmVhbShvYnNTdG9yZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVN0b3JlU3RyZWFtKG9ic1N0b3JlKTtcbn1cbmV4cG9ydHMuc3RvcmVBc1N0cmVhbSA9IHN0b3JlQXNTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc1N0cmVhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9jYWxTdG9yYWdlU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBPYnNlcnZhYmxlU3RvcmVfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKTtcbmNsYXNzIExvY2FsU3RvcmFnZVN0b3JlIGV4dGVuZHMgT2JzZXJ2YWJsZVN0b3JlXzEuT2JzZXJ2YWJsZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsU3RvcmFnZVN0b3JlIC0gY2FuXFwndCBmaW5kIGxvY2FsU3RvcmFnZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoIW9wdHMuc3RvcmFnZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2NhbFN0b3JhZ2VTdG9yZSAtIG5vIHN0b3JhZ2VLZXkgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3JhZ2VLZXkgPSBvcHRzLnN0b3JhZ2VLZXk7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gcHJpdmF0ZVxuICAgIC8vXG4gICAgLy8gcmVhZCBmcm9tIHBlcnNpc3RlbmNlXG4gICAgX2dldFN0YXRlKCkge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkID0gZ2xvYmFsLmxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuX3N0b3JhZ2VLZXkpO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZCA/IEpTT04ucGFyc2Uoc2VyaWFsaXplZCkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIHdyaXRlIHRvIHBlcnNpc3RlbmNlXG4gICAgX3B1dFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeShuZXdTdGF0ZSk7XG4gICAgICAgIHJldHVybiBnbG9iYWwubG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5fc3RvcmFnZUtleSwgc2VyaWFsaXplZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Mb2NhbFN0b3JhZ2VTdG9yZSA9IExvY2FsU3RvcmFnZVN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9jYWxTdG9yYWdlU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXBvc2VkU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBPYnNlcnZhYmxlU3RvcmVfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKTtcbmNsYXNzIENvbXBvc2VkU3RvcmUgZXh0ZW5kcyBPYnNlcnZhYmxlU3RvcmVfMS5PYnNlcnZhYmxlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIHNldCBkZWZhdWx0IHN0YXRlXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKHt9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hpbGRyZW5cbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fY2hpbGRyZW4pLmZvckVhY2goKGNoaWxkS2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2NoaWxkS2V5XTtcbiAgICAgICAgICAgIHRoaXMuX2FkZENoaWxkKGNoaWxkS2V5LCBjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hpbGQoY2hpbGRLZXksIGNoaWxkKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUZyb21DaGlsZCA9IChjaGlsZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHN0YXRlW2NoaWxkS2V5XSA9IGNoaWxkVmFsdWU7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKHN0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGQuc3Vic2NyaWJlKHVwZGF0ZUZyb21DaGlsZCk7XG4gICAgICAgIHVwZGF0ZUZyb21DaGlsZChjaGlsZC5nZXRTdGF0ZSgpKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbXBvc2VkU3RvcmUgPSBDb21wb3NlZFN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tcG9zZWRTdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVyZ2VkU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBPYnNlcnZhYmxlU3RvcmVfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKTtcbmNsYXNzIE1lcmdlZFN0b3JlIGV4dGVuZHMgT2JzZXJ2YWJsZVN0b3JlXzEuT2JzZXJ2YWJsZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiA9IFtdKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIHNldCBkZWZhdWx0IHN0YXRlXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKHt9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hpbGRyZW5cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX2FkZENoaWxkKGNoaWxkKSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVdob2xlU3RhdGUoKTtcbiAgICB9XG4gICAgX2FkZENoaWxkKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnN1YnNjcmliZSgoKSA9PiB0aGlzLl91cGRhdGVXaG9sZVN0YXRlKCkpO1xuICAgIH1cbiAgICBfdXBkYXRlV2hvbGVTdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRTdGF0ZXMgPSB0aGlzLl9jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5nZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gYXBwbHkgc2hhbGxvdyBtZXJnZSBvdmVyIHN0YXRlc1xuICAgICAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLmNoaWxkU3RhdGVzKTtcbiAgICAgICAgdGhpcy5wdXRTdGF0ZShzdGF0ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5NZXJnZWRTdG9yZSA9IE1lcmdlZFN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVyZ2VkU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9ic2VydmFibGVTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IHNhZmVfZXZlbnRfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyXCIpKTtcbmNsYXNzIE9ic2VydmFibGVTdG9yZSBleHRlbmRzIHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKGluaXRTdGF0ZSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIHNldCBpbml0IHN0YXRlXG4gICAgICAgIHRoaXMuX3N0YXRlID0gaW5pdFN0YXRlO1xuICAgIH1cbiAgICAvLyB3cmFwcGVyIGFyb3VuZCBpbnRlcm5hbCBnZXRTdGF0ZVxuICAgIGdldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3RhdGUoKTtcbiAgICB9XG4gICAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgcHV0U3RhdGVcbiAgICBwdXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLl9wdXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgbmV3U3RhdGUpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShwYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgLy8gaWYgbm9uLW51bGwgb2JqZWN0LCBtZXJnZVxuICAgICAgICBpZiAocGFydGlhbFN0YXRlICYmIHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBvYmplY3QsIHVzZSBuZXcgdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUocGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlc1xuICAgIHN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMub24oJ3VwZGF0ZScsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyB1bnN1YnNjcmliZSB0byBjaGFuZ2VzXG4gICAgdW5zdWJzY3JpYmUoaGFuZGxlcikge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGUnLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBwcml2YXRlXG4gICAgLy9cbiAgICAvLyByZWFkIGZyb20gcGVyc2lzdGVuY2VcbiAgICBfZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLy8gd3JpdGUgdG8gcGVyc2lzdGVuY2VcbiAgICBfcHV0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG59XG5leHBvcnRzLk9ic2VydmFibGVTdG9yZSA9IE9ic2VydmFibGVTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGVTdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RvcmVUcmFuc2Zvcm1TdHJlYW0gPSB2b2lkIDA7XG5jb25zdCB0aHJvdWdoMl8xID0gcmVxdWlyZShcInRocm91Z2gyXCIpO1xuZnVuY3Rpb24gc3RvcmVUcmFuc2Zvcm1TdHJlYW0oc3luY1RyYW5zZm9ybUZuKSB7XG4gICAgcmV0dXJuIHRocm91Z2gyXzEub2JqKChzdGF0ZSwgX2VuY29kaW5nLCBjYikgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBzeW5jVHJhbnNmb3JtRm4oc3RhdGUpO1xuICAgICAgICAgICAgY2IobnVsbCwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5zdG9yZVRyYW5zZm9ybVN0cmVhbSA9IHN0b3JlVHJhbnNmb3JtU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3JtLmpzLm1hcCIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAyO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBpZiAodmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci50eXBlID09PSAnZXRoZXJzY2FuJykge1xuICAgICAgICB2ZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyLnR5cGUgPSAncnBjJztcbiAgICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci5ycGNUYXJnZXQgPVxuICAgICAgICAgICdodHRwczovL3JwYy5tZXRhbWFzay5pby8nO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIC8vIGVtcHR5XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDQ7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKHZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCBzYWZlVmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcCh2ZXJzaW9uZWREYXRhKTtcbiAgICBzYWZlVmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBpZiAoc2FmZVZlcnNpb25lZERhdGEuZGF0YS5jb25maWcucHJvdmlkZXIudHlwZSAhPT0gJ3JwYycpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzYWZlVmVyc2lvbmVkRGF0YSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHNhZmVWZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyLnJwY1RhcmdldCkge1xuICAgICAgICBjYXNlICdodHRwczovL3Rlc3RycGMubWV0YW1hc2suaW8vJzpcbiAgICAgICAgICBzYWZlVmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlciA9IHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXN0bmV0JyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdodHRwczovL3JwYy5tZXRhbWFzay5pby8nOlxuICAgICAgICAgIHNhZmVWZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyID0ge1xuICAgICAgICAgICAgdHlwZTogJ21haW5uZXQnLFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIE5vIGRlZmF1bHRcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAvLyBlbXB0eVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNhZmVWZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMztcbmNvbnN0IG9sZFRlc3RScGMgPSAnaHR0cHM6Ly9yYXd0ZXN0cnBjLm1ldGFtYXNrLmlvLyc7XG5jb25zdCBuZXdUZXN0UnBjID0gJ2h0dHBzOi8vdGVzdHJwYy5tZXRhbWFzay5pby8nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBpZiAodmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci5ycGNUYXJnZXQgPT09IG9sZFRlc3RScGMpIHtcbiAgICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci5ycGNUYXJnZXQgPSBuZXdUZXN0UnBjO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIC8vIGVtcHR5XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gbW9kaWZpZXMgb3VyIG5vdGljZXMgdG8gZGVsZXRlIHRoZWlyIGJvZHkgYWZ0ZXIgYmVpbmcgcmVhZC5cblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDEyO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgbmV3U3RhdGUuTm90aWNlQ29udHJvbGxlci5ub3RpY2VzTGlzdC5mb3JFYWNoKChub3RpY2UpID0+IHtcbiAgICBpZiAobm90aWNlLnJlYWQpIHtcbiAgICAgIG5vdGljZS5ib2R5ID0gJyc7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gYnJlYWtzIG91dCB0aGUgU2hhcGVTaGlmdENvbnRyb2xsZXIgc3Vic3RhdGVcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwLCBtZXJnZSB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAxMDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gbWVyZ2Uoe30sIHN0YXRlLCB7XG4gICAgU2hhcGVTaGlmdENvbnRyb2xsZXI6IHtcbiAgICAgIHNoYXBlU2hpZnRUeExpc3Q6IHN0YXRlLnNoYXBlU2hpZnRUeExpc3QgfHwgW10sXG4gICAgfSxcbiAgfSk7XG4gIGRlbGV0ZSBuZXdTdGF0ZS5zaGFwZVNoaWZ0VHhMaXN0O1xuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIHJlbW92ZXMgcHJvdmlkZXIgZnJvbSBjb25maWcgYW5kIG1vdmVzIGl0IHRvbyBOZXR3b3JrQ29udHJvbGxlci5cblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDE0O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgbmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIgPSB7fTtcbiAgbmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIgPSBuZXdTdGF0ZS5jb25maWcucHJvdmlkZXI7XG4gIGRlbGV0ZSBuZXdTdGF0ZS5jb25maWcucHJvdmlkZXI7XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIGJyZWFrcyBvdXQgdGhlIEN1cnJlbmN5Q29udHJvbGxlciBzdWJzdGF0ZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAsIG1lcmdlIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IG1lcmdlKHt9LCBzdGF0ZSwge1xuICAgIEN1cnJlbmN5Q29udHJvbGxlcjoge1xuICAgICAgY3VycmVudEN1cnJlbmN5OiBzdGF0ZS5jdXJyZW50RmlhdCB8fCBzdGF0ZS5maWF0Q3VycmVuY3kgfHwgJ1VTRCcsXG4gICAgICBjb252ZXJzaW9uUmF0ZTogc3RhdGUuY29udmVyc2lvblJhdGUsXG4gICAgICBjb252ZXJzaW9uRGF0ZTogc3RhdGUuY29udmVyc2lvbkRhdGUsXG4gICAgfSxcbiAgfSk7XG4gIGRlbGV0ZSBuZXdTdGF0ZS5jdXJyZW50RmlhdDtcbiAgZGVsZXRlIG5ld1N0YXRlLmZpYXRDdXJyZW5jeTtcbiAgZGVsZXRlIG5ld1N0YXRlLmNvbnZlcnNpb25SYXRlO1xuICBkZWxldGUgbmV3U3RhdGUuY29udmVyc2lvbkRhdGU7XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyB0aGUgZGlzY2FpbWVyIHN0YXRlIGZyb20gb3VyIGFwcCwgd2hpY2ggd2FzIGludGVncmF0ZWQgaW50byBvdXIgbm90aWNlcy5cblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDExO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgZGVsZXRlIG5ld1N0YXRlLlRPU0hhc2g7XG4gIGRlbGV0ZSBuZXdTdGF0ZS5pc0Rpc2NsYWltZXJDb25maXJtZWQ7XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIHNldHMgdHJhbnNhY3Rpb25zIHdpdGggdGhlICdHYXZlIHVwIHN1Ym1pdHRpbmcgdHguJyBlcnIgbWVzc2FnZVxudG8gYSAnZmFpbGVkJyBzdGF0ZWRcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmNvbnN0IHZlcnNpb24gPSAxNTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IFRyYW5zYWN0aW9uQ29udHJvbGxlcjtcbiAgICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcCgodHhNZXRhKSA9PiB7XG4gICAgICBpZiAoIXR4TWV0YS5lcnIpIHtcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICAgIH0gZWxzZSBpZiAodHhNZXRhLmVyci5tZXNzYWdlID09PSAnR2F2ZSB1cCBzdWJtaXR0aW5nIHR4LicpIHtcbiAgICAgICAgdHhNZXRhLnN0YXR1cyA9IFRSQU5TQUNUSU9OX1NUQVRVU0VTLkZBSUxFRDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gbW9kaWZpZXMgdGhlIG5ldHdvcmsgY29uZmlnIGZyb20gYW1iaWd1b3VzICd0ZXN0bmV0JyB0byBleHBsaWNpdCAncm9wc3RlbidcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDEzO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgY29uc3QgeyBjb25maWcgfSA9IG5ld1N0YXRlO1xuICBpZiAoY29uZmlnICYmIGNvbmZpZy5wcm92aWRlcikge1xuICAgIGlmIChjb25maWcucHJvdmlkZXIudHlwZSA9PT0gJ3Rlc3RuZXQnKSB7XG4gICAgICBuZXdTdGF0ZS5jb25maWcucHJvdmlkZXIudHlwZSA9ICdyb3BzdGVuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gc2V0cyB0cmFuc2FjdGlvbnMgd2hvIHdlcmUgcmV0cmllZCBhbmQgbWFya2VkIGFzIGZhaWxlZCB0byBzdWJtaXR0ZWRcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmNvbnN0IHZlcnNpb24gPSAxNztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcbiAgICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcCgodHhNZXRhKSA9PiB7XG4gICAgICBpZiAoIXR4TWV0YS5zdGF0dXMgPT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLkZBSUxFRCkge1xuICAgICAgICByZXR1cm4gdHhNZXRhO1xuICAgICAgfVxuICAgICAgaWYgKHR4TWV0YS5yZXRyeUNvdW50ID4gMCAmJiB0eE1ldGEucmV0cnlDb3VudCA8IDIpIHtcbiAgICAgICAgdHhNZXRhLnN0YXR1cyA9IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRDtcbiAgICAgICAgZGVsZXRlIHR4TWV0YS5lcnI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHhNZXRhO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIHNldHMgdHJhbnNhY3Rpb25zIGFzIGZhaWxlZFxud2hvcyBub25jZSBpcyB0b28gaGlnaFxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVFJBTlNBQ1RJT05fU1RBVFVTRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuY29uc3QgdmVyc2lvbiA9IDE5O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuXG4gICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoXG4gICAgICAodHhNZXRhLCBfLCB0eExpc3QpID0+IHtcbiAgICAgICAgaWYgKHR4TWV0YS5zdGF0dXMgIT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRCkge1xuICAgICAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb25maXJtZWRUeHMgPSB0eExpc3RcbiAgICAgICAgICAuZmlsdGVyKCh0eCkgPT4gdHguc3RhdHVzID09PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5DT05GSVJNRUQpXG4gICAgICAgICAgLmZpbHRlcigodHgpID0+IHR4LnR4UGFyYW1zLmZyb20gPT09IHR4TWV0YS50eFBhcmFtcy5mcm9tKVxuICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAodHgpID0+IHR4Lm1ldGFtYXNrTmV0d29ya0lkLmZyb20gPT09IHR4TWV0YS5tZXRhbWFza05ldHdvcmtJZC5mcm9tLFxuICAgICAgICAgICk7XG4gICAgICAgIGNvbnN0IGhpZ2hlc3RDb25maXJtZWROb25jZSA9IGdldEhpZ2hlc3ROb25jZShjb25maXJtZWRUeHMpO1xuXG4gICAgICAgIGNvbnN0IHBlbmRpbmdUeHMgPSB0eExpc3RcbiAgICAgICAgICAuZmlsdGVyKCh0eCkgPT4gdHguc3RhdHVzID09PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5TVUJNSVRURUQpXG4gICAgICAgICAgLmZpbHRlcigodHgpID0+IHR4LnR4UGFyYW1zLmZyb20gPT09IHR4TWV0YS50eFBhcmFtcy5mcm9tKVxuICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAodHgpID0+IHR4Lm1ldGFtYXNrTmV0d29ya0lkLmZyb20gPT09IHR4TWV0YS5tZXRhbWFza05ldHdvcmtJZC5mcm9tLFxuICAgICAgICAgICk7XG4gICAgICAgIGNvbnN0IGhpZ2hlc3RDb250aW51b3VzTm9uY2UgPSBnZXRIaWdoZXN0Q29udGludW91c0Zyb20oXG4gICAgICAgICAgcGVuZGluZ1R4cyxcbiAgICAgICAgICBoaWdoZXN0Q29uZmlybWVkTm9uY2UsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgbWF4Tm9uY2UgPSBNYXRoLm1heChcbiAgICAgICAgICBoaWdoZXN0Q29udGludW91c05vbmNlLFxuICAgICAgICAgIGhpZ2hlc3RDb25maXJtZWROb25jZSxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAocGFyc2VJbnQodHhNZXRhLnR4UGFyYW1zLm5vbmNlLCAxNikgPiBtYXhOb25jZSArIDEpIHtcbiAgICAgICAgICB0eE1ldGEuc3RhdHVzID0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuRkFJTEVEO1xuICAgICAgICAgIHR4TWV0YS5lcnIgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnbm9uY2UgdG9vIGhpZ2gnLFxuICAgICAgICAgICAgbm90ZTogJ21pZ3JhdGlvbiAwMTkgY3VzdG9tIGVycm9yJyxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgICB9LFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuXG5mdW5jdGlvbiBnZXRIaWdoZXN0Q29udGludW91c0Zyb20odHhMaXN0LCBzdGFydFBvaW50KSB7XG4gIGNvbnN0IG5vbmNlcyA9IHR4TGlzdC5tYXAoKHR4TWV0YSkgPT4ge1xuICAgIGNvbnN0IHsgbm9uY2UgfSA9IHR4TWV0YS50eFBhcmFtcztcbiAgICByZXR1cm4gcGFyc2VJbnQobm9uY2UsIDE2KTtcbiAgfSk7XG5cbiAgbGV0IGhpZ2hlc3QgPSBzdGFydFBvaW50O1xuICB3aGlsZSAobm9uY2VzLmluY2x1ZGVzKGhpZ2hlc3QpKSB7XG4gICAgaGlnaGVzdCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIGhpZ2hlc3Q7XG59XG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3ROb25jZSh0eExpc3QpIHtcbiAgY29uc3Qgbm9uY2VzID0gdHhMaXN0Lm1hcCgodHhNZXRhKSA9PiB7XG4gICAgY29uc3QgeyBub25jZSB9ID0gdHhNZXRhLnR4UGFyYW1zO1xuICAgIHJldHVybiBwYXJzZUludChub25jZSB8fCAnMHgwJywgMTYpO1xuICB9KTtcbiAgY29uc3QgaGlnaGVzdE5vbmNlID0gTWF0aC5tYXguYXBwbHkobnVsbCwgbm9uY2VzKTtcbiAgcmV0dXJuIGhpZ2hlc3ROb25jZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIHNldHMgdHJhbnNhY3Rpb25zIHdpdGggdGhlICdHYXZlIHVwIHN1Ym1pdHRpbmcgdHguJyBlcnIgbWVzc2FnZVxudG8gYSAnZmFpbGVkJyBzdGF0ZWRcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmNvbnN0IHZlcnNpb24gPSAxNjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcblxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcbiAgICAgIGlmICghdHhNZXRhLmVycikge1xuICAgICAgICByZXR1cm4gdHhNZXRhO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICB0eE1ldGEuZXJyID09PSAndHJhbnNhY3Rpb24gd2l0aCB0aGUgc2FtZSBoYXNoIHdhcyBhbHJlYWR5IGltcG9ydGVkLidcbiAgICAgICkge1xuICAgICAgICB0eE1ldGEuc3RhdHVzID0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuU1VCTUlUVEVEO1xuICAgICAgICBkZWxldGUgdHhNZXRhLmVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gZW5zdXJlcyBwcmV2aW91cyBpbnN0YWxsYXRpb25zXG5nZXQgYSBgZmlyc3RUaW1lSW5mb2Aga2V5IG9uIHRoZSBtZXRhbWFzayBzdGF0ZSxcbnNvIHRoYXQgd2UgY2FuIHZlcnNpb24gbm90aWNlcyBpbiB0aGUgZnV0dXJlLlxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMjA7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBpZiAoJ21ldGFtYXNrJyBpbiBuZXdTdGF0ZSAmJiAhKCdmaXJzdFRpbWVJbmZvJyBpbiBuZXdTdGF0ZS5tZXRhbWFzaykpIHtcbiAgICBuZXdTdGF0ZS5tZXRhbWFzay5maXJzdFRpbWVJbmZvID0ge1xuICAgICAgdmVyc2lvbjogJzMuMTIuMCcsXG4gICAgICBkYXRlOiBEYXRlLm5vdygpLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgbm8gbG9uZ2VyIHVzZWZ1bGwgZG93biB0byA0MCB0b3RhbFxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVFJBTlNBQ1RJT05fU1RBVFVTRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuY29uc3QgdmVyc2lvbiA9IDIzO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcblxuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XG4gIGlmIChUcmFuc2FjdGlvbkNvbnRyb2xsZXIgJiYgVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI7XG5cbiAgICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCA8PSA0MCkge1xuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH1cblxuICAgIGNvbnN0IHJldmVyc2VUeExpc3QgPSB0cmFuc2FjdGlvbnMucmV2ZXJzZSgpO1xuICAgIGxldCBzdHJpcHBpbmcgPSB0cnVlO1xuICAgIHdoaWxlIChyZXZlcnNlVHhMaXN0Lmxlbmd0aCA+IDQwICYmIHN0cmlwcGluZykge1xuICAgICAgY29uc3QgdHhJbmRleCA9IHJldmVyc2VUeExpc3QuZmluZEluZGV4KCh0eE1ldGEpID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0eE1ldGEuc3RhdHVzID09PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5GQUlMRUQgfHxcbiAgICAgICAgICB0eE1ldGEuc3RhdHVzID09PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5SRUpFQ1RFRCB8fFxuICAgICAgICAgIHR4TWV0YS5zdGF0dXMgPT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLkNPTkZJUk1FRCB8fFxuICAgICAgICAgIHR4TWV0YS5zdGF0dXMgPT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLkRST1BQRURcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHR4SW5kZXggPCAwKSB7XG4gICAgICAgIHN0cmlwcGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZVR4TGlzdC5zcGxpY2UodHhJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHJldmVyc2VUeExpc3QucmV2ZXJzZSgpO1xuICB9XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIHJlbW92ZXMgdGhlIEJsYWNrTGlzdENvbnRyb2xsZXIgZnJvbSBkaXNrIHN0YXRlXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAyMTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGRlbGV0ZSBuZXdTdGF0ZS5CbGFja2xpc3RDb250cm9sbGVyO1xuICBkZWxldGUgbmV3U3RhdGUuUmVjZW50QmxvY2tzO1xuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvLyBuZXh0IHZlcnNpb24gbnVtYmVyXG4vKlxuXG5ub3JtYWxpemVzIHR4UGFyYW1zIG9uIHVuY29uZmlybWVkIHR4c1xuXG4qL1xuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJy4uL2xpYi91dGlsJztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmNvbnN0IHZlcnNpb24gPSAyNTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG5cbiAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcikge1xuICAgIGlmIChuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XG4gICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuICAgICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoXG4gICAgICAgICh0eE1ldGEpID0+IHtcbiAgICAgICAgICBpZiAodHhNZXRhLnN0YXR1cyAhPT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuVU5BUFBST1ZFRCkge1xuICAgICAgICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHhNZXRhLnR4UGFyYW1zID0gbm9ybWFsaXplVHhQYXJhbXModHhNZXRhLnR4UGFyYW1zKTtcbiAgICAgICAgICByZXR1cm4gdHhNZXRhO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR4UGFyYW1zKHR4UGFyYW1zKSB7XG4gIC8vIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZSBub3JtYWxpemluZyBvZiB0aGF0IGtleSBpbiB0eFBhcmFtc1xuICBjb25zdCB3aGl0ZUxpc3QgPSB7XG4gICAgZnJvbTogKGZyb20pID0+IGFkZEhleFByZWZpeChmcm9tKS50b0xvd2VyQ2FzZSgpLFxuICAgIHRvOiAoKSA9PiBhZGRIZXhQcmVmaXgodHhQYXJhbXMudG8pLnRvTG93ZXJDYXNlKCksXG4gICAgbm9uY2U6IChub25jZSkgPT4gYWRkSGV4UHJlZml4KG5vbmNlKSxcbiAgICB2YWx1ZTogKHZhbHVlKSA9PiBhZGRIZXhQcmVmaXgodmFsdWUpLFxuICAgIGRhdGE6IChkYXRhKSA9PiBhZGRIZXhQcmVmaXgoZGF0YSksXG4gICAgZ2FzOiAoZ2FzKSA9PiBhZGRIZXhQcmVmaXgoZ2FzKSxcbiAgICBnYXNQcmljZTogKGdhc1ByaWNlKSA9PiBhZGRIZXhQcmVmaXgoZ2FzUHJpY2UpLFxuICB9O1xuXG4gIC8vIGFwcGx5IG9ubHkga2V5cyBpbiB0aGUgd2hpdGVMaXN0XG4gIGNvbnN0IG5vcm1hbGl6ZWRUeFBhcmFtcyA9IHt9O1xuICBPYmplY3Qua2V5cyh3aGl0ZUxpc3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICh0eFBhcmFtc1trZXldKSB7XG4gICAgICBub3JtYWxpemVkVHhQYXJhbXNba2V5XSA9IHdoaXRlTGlzdFtrZXldKHR4UGFyYW1zW2tleV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWRUeFBhcmFtcztcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIGFkZHMgc3VibWl0dGVkVGltZSB0byB0aGUgdHhNZXRhIGlmIGl0IGlzIG5vdCB0aGVpclxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVFJBTlNBQ1RJT05fU1RBVFVTRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuY29uc3QgdmVyc2lvbiA9IDIyO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuXG4gICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoKHR4TWV0YSkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICB0eE1ldGEuc3RhdHVzICE9PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5TVUJNSVRURUQgfHxcbiAgICAgICAgdHhNZXRhLnN1Ym1pdHRlZFRpbWVcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHhNZXRhO1xuICAgICAgfVxuICAgICAgdHhNZXRhLnN1Ym1pdHRlZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gbW92ZXMgdGhlIGlkZW50aXRpZXMgc3RvcmVkIGluIHRoZSBLZXlyaW5nQ29udHJvbGxlclxuIGludG8gdGhlIFByZWZlcmVuY2VzQ29udHJvbGxlclxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMjY7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmICghc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXIgfHwgIXN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGlmICghc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXIud2FsbGV0Tmlja25hbWVzKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmlkZW50aXRpZXMgPSBPYmplY3Qua2V5cyhcbiAgICBzdGF0ZS5LZXlyaW5nQ29udHJvbGxlci53YWxsZXROaWNrbmFtZXMsXG4gICkucmVkdWNlKChpZGVudGl0aWVzLCBhZGRyZXNzKSA9PiB7XG4gICAgaWRlbnRpdGllc1thZGRyZXNzXSA9IHtcbiAgICAgIG5hbWU6IHN0YXRlLktleXJpbmdDb250cm9sbGVyLndhbGxldE5pY2tuYW1lc1thZGRyZXNzXSxcbiAgICAgIGFkZHJlc3MsXG4gICAgfTtcbiAgICByZXR1cm4gaWRlbnRpdGllcztcbiAgfSwge30pO1xuICBkZWxldGUgc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXIud2FsbGV0Tmlja25hbWVzO1xuICByZXR1cm4gc3RhdGU7XG59XG4iLCIvLyBuZXh0IHZlcnNpb24gbnVtYmVyXG4vKlxuXG5ub3JtYWxpemVzIHR4UGFyYW1zIG9uIHVuY29uZmlybWVkIHR4c1xuXG4qL1xuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDI4O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcblxuICBpZiAobmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XG4gICAgaWYgKFxuICAgICAgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnRva2VucyAmJlxuICAgICAgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmlkZW50aXRpZXNcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgaWRlbnRpdGllcywgdG9rZW5zIH0gPSBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI7XG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2VucyA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMoaWRlbnRpdGllcykuZm9yRWFjaCgoaWRlbnRpdHkpID0+IHtcbiAgICAgICAgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnNbaWRlbnRpdHldID0ge1xuICAgICAgICAgIG1haW5uZXQ6IHRva2VucyxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnRva2VucyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8vIG5leHQgdmVyc2lvbiBudW1iZXJcbi8qXG5cbm5vcm1hbGl6ZXMgdHhQYXJhbXMgb24gdW5jb25maXJtZWQgdHhzXG5cbiovXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVFJBTlNBQ1RJT05fU1RBVFVTRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuY29uc3QgdmVyc2lvbiA9IDI3O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcblxuICBpZiAobmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyKSB7XG4gICAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcbiAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI7XG4gICAgICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLmZpbHRlcihcbiAgICAgICAgKHR4TWV0YSkgPT4gdHhNZXRhLnN0YXR1cyAhPT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuUkVKRUNURUQsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIGVuc3VyZXMgdGhhdCB0aGUgZnJvbSBhZGRyZXNzIGluIHR4UGFyYW1zIGlzIHRvIGxvd2VyIGNhc2UgZm9yXG5hbGwgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnNcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmNvbnN0IHZlcnNpb24gPSAyNDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGlmICghbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyKSB7XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9XG4gIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI7XG4gIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKFxuICAgICh0eE1ldGEsIF8pID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgdHhNZXRhLnN0YXR1cyA9PT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuVU5BUFBST1ZFRCAmJlxuICAgICAgICB0eE1ldGEudHhQYXJhbXMgJiZcbiAgICAgICAgdHhNZXRhLnR4UGFyYW1zLmZyb21cbiAgICAgICkge1xuICAgICAgICB0eE1ldGEudHhQYXJhbXMuZnJvbSA9IHR4TWV0YS50eFBhcmFtcy5mcm9tLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHhNZXRhO1xuICAgIH0sXG4gICk7XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8vIG5leHQgdmVyc2lvbiBudW1iZXJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAzMTtcblxuLypcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWlncmF0aW9uIGlzIHRvIHByb3Blcmx5IHNldCB0aGUgY29tcGxldGVkT25ib2FyZGluZyBmbGFnIGJhc2VkIG9uIHRoZSBzdGF0ZVxuICogb2YgdGhlIEtleXJpbmdDb250cm9sbGVyLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgeyBLZXlyaW5nQ29udHJvbGxlciwgUHJlZmVyZW5jZXNDb250cm9sbGVyIH0gPSBzdGF0ZTtcblxuICBpZiAoS2V5cmluZ0NvbnRyb2xsZXIgJiYgUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XG4gICAgY29uc3QgeyB2YXVsdCB9ID0gS2V5cmluZ0NvbnRyb2xsZXI7XG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyLmNvbXBsZXRlZE9uYm9hcmRpbmcgPSBCb29sZWFuKHZhdWx0KTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsIi8vIG5leHQgdmVyc2lvbiBudW1iZXJcbi8qXG5cbnJlbW92ZXMgaW52YWxpZCBjaGFpZHMgZnJvbSBwcmVmZXJlbmNlcyBhbmQgbmV0d29ya0NvbnRyb2xsZXIgZm9yIGN1c3RvbSBycGNzXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAzMDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGlmIChzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcbiAgICBjb25zdCB7IGZyZXF1ZW50UnBjTGlzdERldGFpbCB9ID0gbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyO1xuICAgIGlmIChmcmVxdWVudFJwY0xpc3REZXRhaWwpIHtcbiAgICAgIGZyZXF1ZW50UnBjTGlzdERldGFpbC5mb3JFYWNoKChycGMsIGluZGV4KSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxuICAgICAgICBpZiAoQm9vbGVhbihycGMuY2hhaW5JZCkgJiYgTnVtYmVyLmlzTmFOKHBhcnNlSW50KHJwYy5jaGFpbklkKSkpIHtcbiAgICAgICAgICBkZWxldGUgZnJlcXVlbnRScGNMaXN0RGV0YWlsW2luZGV4XS5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5mcmVxdWVudFJwY0xpc3REZXRhaWwgPSBmcmVxdWVudFJwY0xpc3REZXRhaWw7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcikge1xuICAgIGlmIChcbiAgICAgIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLm5ldHdvcmsgJiZcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxuICAgICAgTnVtYmVyLmlzTmFOKHBhcnNlSW50KG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLm5ldHdvcmspKVxuICAgICkge1xuICAgICAgZGVsZXRlIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLm5ldHdvcms7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgbmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIgJiZcbiAgICAgIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLmNoYWluSWQgJiZcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxuICAgICAgTnVtYmVyLmlzTmFOKHBhcnNlSW50KG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLmNoYWluSWQpKVxuICAgICkge1xuICAgICAgZGVsZXRlIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLmNoYWluSWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDM0O1xuXG4vKipcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWlncmF0aW9uIGlzIHRvIGVuYWJsZSB0aGUge0Bjb2RlIHByaXZhY3lNb2RlfSBmZWF0dXJlIGZsYWcgYW5kIHNldCB0aGUgdXNlciBhcyBiZWluZyBtaWdyYXRlZFxuICogaWYgaXQgd2FzIHtAY29kZSBmYWxzZX0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IHsgUHJlZmVyZW5jZXNDb250cm9sbGVyIH0gPSBzdGF0ZTtcblxuICBpZiAoUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XG4gICAgY29uc3QgZmVhdHVyZUZsYWdzID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLmZlYXR1cmVGbGFncyB8fCB7fTtcblxuICAgIGlmIChcbiAgICAgICFmZWF0dXJlRmxhZ3MucHJpdmFjeU1vZGUgJiZcbiAgICAgIHR5cGVvZiBQcmVmZXJlbmNlc0NvbnRyb2xsZXIubWlncmF0ZWRQcml2YWN5TW9kZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICApIHtcbiAgICAgIC8vIE1hcmsgdGhlIHN0YXRlIGhhcyBiZWluZyBtaWdyYXRlZCBhbmQgZW5hYmxlIFByaXZhY3kgTW9kZVxuICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyLm1pZ3JhdGVkUHJpdmFjeU1vZGUgPSB0cnVlO1xuICAgICAgZmVhdHVyZUZsYWdzLnByaXZhY3lNb2RlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMzI7XG5cbi8qKlxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gc2V0IHRoZSB7QGNvZGUgY29tcGxldGVkVWlNaWdyYXRpb259IGZsYWcgYmFzZWQgb24gdGhlIHVzZXIncyBVSSBwcmVmZXJlbmNlc1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCB7IFByZWZlcmVuY2VzQ29udHJvbGxlciB9ID0gc3RhdGU7XG5cbiAgaWYgKFByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIGNvbnN0IHsgYmV0YVVJIH0gPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuZmVhdHVyZUZsYWdzIHx8IHt9O1xuICAgIC8vIFVzZXJzIHdobyBoYXZlIGJlZW4gdXNpbmcgdGhlIFwiYmV0YVwiIFVJIGFyZSBjb25zaWRlcmVkIHRvIGhhdmUgY29tcGxldGVkIHRoZSBtaWdyYXRpb25cbiAgICAvLyBhcyB0aGV5J2xsIHNlZSBubyBkaWZmZXJlbmNlIGluIHRoaXMgdmVyc2lvblxuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlci5jb21wbGV0ZWRVaU1pZ3JhdGlvbiA9IGJldGFVSTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsIi8vIG5leHQgdmVyc2lvbiBudW1iZXJcbi8qXG5cbkNsZWFucyB1cCBub3RpY2VzIGFuZCBhc3NvY2F0ZWQgbm90aWNlIGNvbnRyb2xsZXIgY29kZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMzM7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuICAvLyB0cmFuc2Zvcm0gc3RhdGUgaGVyZVxuICBpZiAoc3RhdGUuTm90aWNlQ29udHJvbGxlcikge1xuICAgIGRlbGV0ZSBuZXdTdGF0ZS5Ob3RpY2VDb250cm9sbGVyO1xuICB9XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8vIG5leHQgdmVyc2lvbiBudW1iZXJcbi8qXG5cblJlbW92ZXMgdGhlIGRlcHJlY2F0ZWQgJ3NlZWRXb3Jkcycgc3RhdGVcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDM1O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHZlcnNpb25lZERhdGEuZGF0YSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBpZiAoXG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyICYmXG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnNlZWRXb3JkcyAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2VlZFdvcmRzO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAzNjtcblxuLyoqXG4gKiBUaGUgcHVycG9zZSBvZiB0aGlzIG1pZ3JhdGlvbiBpcyB0byByZW1vdmUgdGhlIHtAY29kZSBwcml2YWN5TW9kZX0gZmVhdHVyZSBmbGFnLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCB7IFByZWZlcmVuY2VzQ29udHJvbGxlciB9ID0gc3RhdGU7XG5cbiAgaWYgKFByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIGNvbnN0IGZlYXR1cmVGbGFncyA9IFByZWZlcmVuY2VzQ29udHJvbGxlci5mZWF0dXJlRmxhZ3MgfHwge307XG5cbiAgICBpZiAodHlwZW9mIGZlYXR1cmVGbGFncy5wcml2YWN5TW9kZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRlbGV0ZSBmZWF0dXJlRmxhZ3MucHJpdmFjeU1vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHRvQ2hlY2tzdW1IZXhBZGRyZXNzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcblxuY29uc3QgdmVyc2lvbiA9IDM5O1xuXG5jb25zdCBEQUlfVjFfQ09OVFJBQ1RfQUREUkVTUyA9ICcweDg5ZDI0QTZiNENjQjFCNmZBQTI2MjVmRTU2MmJERDlhMjMyNjAzNTknO1xuY29uc3QgREFJX1YxX1RPS0VOX1NZTUJPTCA9ICdEQUknO1xuY29uc3QgU0FJX1RPS0VOX1NZTUJPTCA9ICdTQUknO1xuXG5mdW5jdGlvbiBpc09sZERhaSh0b2tlbiA9IHt9KSB7XG4gIHJldHVybiAoXG4gICAgdG9rZW4gJiZcbiAgICB0eXBlb2YgdG9rZW4gPT09ICdvYmplY3QnICYmXG4gICAgdG9rZW4uc3ltYm9sID09PSBEQUlfVjFfVE9LRU5fU1lNQk9MICYmXG4gICAgdG9DaGVja3N1bUhleEFkZHJlc3ModG9rZW4uYWRkcmVzcykgPT09IERBSV9WMV9DT05UUkFDVF9BRERSRVNTXG4gICk7XG59XG5cbi8qKlxuICogVGhpcyBtaWdyYXRpb24gcmVuYW1lcyB0aGUgRGFpIHRva2VuIHRvIFNhaS5cbiAqXG4gKiBBcyBvZiAyMDE5LTExLTE4IERhaSBpcyBub3cgY2FsbGVkIFNhaSAocmVmcyBodHRwczovL2dpdC5pby9KZW9vUCkgdG8gZmFjaWxpdGF0ZVxuICogTWFrZXIncyB1cGdyYWRlIHRvIE11bHRpLUNvbGxhdGVyYWwgRGFpIGFuZCB0aGlzIG1pZ3JhdGlvbiByZW5hbWVzIHRoZSB0b2tlblxuICogYXQgdGhlIG9sZCBhZGRyZXNzLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCB7IFByZWZlcmVuY2VzQ29udHJvbGxlciB9ID0gc3RhdGU7XG5cbiAgaWYgKFByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIGNvbnN0IHRva2VucyA9IFByZWZlcmVuY2VzQ29udHJvbGxlci50b2tlbnMgfHwgW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW5zKSkge1xuICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgaWYgKGlzT2xkRGFpKHRva2VuKSkge1xuICAgICAgICAgIHRva2VuLnN5bWJvbCA9IFNBSV9UT0tFTl9TWU1CT0w7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhY2NvdW50VG9rZW5zID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnMgfHwge307XG4gICAgaWYgKGFjY291bnRUb2tlbnMgJiYgdHlwZW9mIGFjY291bnRUb2tlbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykpIHtcbiAgICAgICAgY29uc3QgbmV0d29ya1Rva2VucyA9IGFjY291bnRUb2tlbnNbYWRkcmVzc107XG4gICAgICAgIGlmIChuZXR3b3JrVG9rZW5zICYmIHR5cGVvZiBuZXR3b3JrVG9rZW5zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAoY29uc3QgbmV0d29yayBvZiBPYmplY3Qua2V5cyhuZXR3b3JrVG9rZW5zKSkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zT25OZXR3b3JrID0gbmV0d29ya1Rva2Vuc1tuZXR3b3JrXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRva2Vuc09uTmV0d29yaykpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnNPbk5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPbGREYWkodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICB0b2tlbi5zeW1ib2wgPSBTQUlfVE9LRU5fU1lNQk9MO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA0MDtcblxuLyoqXG4gKiBTaXRlIGNvbm5lY3Rpb25zIGFyZSBub3cgbWFuYWdlZCBieSB0aGUgUGVybWlzc2lvbnNDb250cm9sbGVyLCBhbmQgdGhlXG4gKiBQcm92aWRlckFwcHJvdmFsQ29udHJvbGxlciBpcyByZW1vdmVkLiBUaGlzIG1pZ3JhdGlvbiBkZWxldGVzIGFsbFxuICogUHJvdmlkZXJBcHByb3ZhbENvbnRyb2xsZXIgc3RhdGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGRlbGV0ZSBzdGF0ZS5Qcm92aWRlckFwcHJvdmFsQ29udHJvbGxlcjtcbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDQ0O1xuXG4vKipcbiAqIFJlbW92ZSB1bnVzZWQgJ21rck1pZ3JhdGlvblJlbWluZGVyVGltZXN0YW1wJyBzdGF0ZSBmcm9tIHRoZSBgQXBwU3RhdGVDb250cm9sbGVyYFxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBpZiAoXG4gICAgdHlwZW9mIHN0YXRlPy5BcHBTdGF0ZUNvbnRyb2xsZXI/Lm1rck1pZ3JhdGlvblJlbWluZGVyVGltZXN0YW1wICE9PVxuICAgICd1bmRlZmluZWQnXG4gICkge1xuICAgIGRlbGV0ZSBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIubWtyTWlncmF0aW9uUmVtaW5kZXJUaW1lc3RhbXA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDQxO1xuXG4vKipcbiAqIFByZWZlcmVuY2VzQ29udHJvbGxlci5hdXRvTG9nb3V0VGltZUxpbWl0IC0+IGF1dG9Mb2NrVGltZUxpbWl0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIgJiYgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzKSB7XG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzLmF1dG9Mb2NrVGltZUxpbWl0ID1cbiAgICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5wcmVmZXJlbmNlcy5hdXRvTG9nb3V0VGltZUxpbWl0O1xuICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIucHJlZmVyZW5jZXMuYXV0b0xvZ291dFRpbWVMaW1pdDtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNDI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBgY29ubmVjdGVkU3RhdHVzUG9wb3Zlckhhc0JlZW5TaG93bmAgdG8gYGZhbHNlYCBpZiBpdCBoYXNuJ3QgeWV0IGJlZW4gc2V0LFxuICogc28gdGhhdCBleGlzdGluZyB1c2VycyBhcmUgaW50cm9kdWNlZCB0byB0aGUgbmV3IGNvbm5lY3RlZCBzdGF0dXMgaW5kaWNhdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIpIHtcbiAgICBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIuY29ubmVjdGVkU3RhdHVzUG9wb3Zlckhhc0JlZW5TaG93biA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlciA9IHtcbiAgICAgIGNvbm5lY3RlZFN0YXR1c1BvcG92ZXJIYXNCZWVuU2hvd246IGZhbHNlLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDQ1O1xuXG4vKipcbiAqIFJlcGxhY2VzIHtAY29kZSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuaXBmc0dhdGV3YXl9IHdpdGggJ2R3ZWIubGluaycgaWYgc2V0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmNvbnN0IG91dGRhdGVkR2F0ZXdheXMgPSBbJ2lwZnMuaW8nLCAnaXBmcy5kd2ViLmxpbmsnXTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKG91dGRhdGVkR2F0ZXdheXMuaW5jbHVkZXMoc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uaXBmc0dhdGV3YXkpKSB7XG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmlwZnNHYXRld2F5ID0gJ2R3ZWIubGluayc7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDQzO1xuXG4vKipcbiAqIFJlbW92ZSB1bnVzZWQgJ2N1cnJlbnRBY2NvdW50VGFiJyBzdGF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBpZiAoc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uY3VycmVudEFjY291bnRUYWIpIHtcbiAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmN1cnJlbnRBY2NvdW50VGFiO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA0NjtcblxuLyoqXG4gKiBEZWxldGUge0Bjb2RlIEFCVGVzdENvbnRyb2xsZXJ9IHN0YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmICh0eXBlb2Ygc3RhdGU/LkFCVGVzdENvbnRyb2xsZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVsZXRlIHN0YXRlLkFCVGVzdENvbnRyb2xsZXI7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDQ3O1xuXG4vKipcbiAqIFN0cmluZ2lmeSB0aGUgYG1ldGFtYXNrTmV0d29ya0lkYCBwcm9wZXJ0eSBvZiBhbGwgdHJhbnNhY3Rpb25zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IHRyYW5zYWN0aW9ucyA9IHN0YXRlPy5UcmFuc2FjdGlvbkNvbnRyb2xsZXI/LnRyYW5zYWN0aW9ucztcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNhY3Rpb25zKSkge1xuICAgIHRyYW5zYWN0aW9ucy5mb3JFYWNoKCh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi5tZXRhbWFza05ldHdvcmtJZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24ubWV0YW1hc2tOZXR3b3JrSWQgPSB0cmFuc2FjdGlvbi5tZXRhbWFza05ldHdvcmtJZC50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA0OTtcblxuLyoqXG4gKiBNaWdyYXRlIG1ldGFNZXRyaWNzIHN0YXRlIHRvIHRoZSBuZXcgTWV0YU1ldHJpY3MgY29udHJvbGxlclxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSA9IHt9KSB7XG4gIGlmIChzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZXRhTWV0cmljc0lkLFxuICAgICAgcGFydGljaXBhdGVJbk1ldGFNZXRyaWNzLFxuICAgICAgbWV0YU1ldHJpY3NTZW5kQ291bnQsXG4gICAgfSA9IHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcjtcbiAgICBzdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXIgPSBzdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXIgPz8ge307XG5cbiAgICBpZiAobWV0YU1ldHJpY3NJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXIubWV0YU1ldHJpY3NJZCA9IG1ldGFNZXRyaWNzSWQ7XG4gICAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLm1ldGFNZXRyaWNzSWQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXIucGFydGljaXBhdGVJbk1ldGFNZXRyaWNzID0gcGFydGljaXBhdGVJbk1ldGFNZXRyaWNzO1xuICAgICAgZGVsZXRlIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5wYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3M7XG4gICAgfVxuXG4gICAgaWYgKG1ldGFNZXRyaWNzU2VuZENvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlci5tZXRhTWV0cmljc1NlbmRDb3VudCA9IG1ldGFNZXRyaWNzU2VuZENvdW50O1xuICAgICAgZGVsZXRlIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5tZXRhTWV0cmljc1NlbmRDb3VudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7XG4gIEdPRVJMSSxcbiAgR09FUkxJX0NIQUlOX0lELFxuICBLT1ZBTixcbiAgS09WQU5fQ0hBSU5fSUQsXG4gIE1BSU5ORVQsXG4gIE1BSU5ORVRfQ0hBSU5fSUQsXG4gIE5FVFdPUktfVFlQRV9SUEMsXG4gIFJJTktFQlksXG4gIFJJTktFQllfQ0hBSU5fSUQsXG4gIFJPUFNURU4sXG4gIFJPUFNURU5fQ0hBSU5fSUQsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5cbmNvbnN0IHZlcnNpb24gPSA1MjtcblxuLyoqXG4gKiBNaWdyYXRlIHRva2VucyBpbiBQcmVmZXJlbmNlcyB0byBiZSBrZXllZCBieSBjaGFpbklkIGluc3RlYWQgb2ZcbiAqIHByb3ZpZGVyVHlwZS4gVG8gcHJldmVudCBicmVha2luZyB1c2VyJ3MgTWV0YU1hc2sgYW5kIHNlbGVjdGVkXG4gKiB0b2tlbnMsIHRoaXMgbWlncmF0aW9uIGNvcGllcyB0aGUgUlBDIGVudHJ5IGludG8gKmV2ZXJ5KiBjdXN0b20gUlBDXG4gKiBjaGFpbklkLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSA9IHt9KSB7XG4gIGlmIChzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBhY2NvdW50VG9rZW5zLFxuICAgICAgYWNjb3VudEhpZGRlblRva2VucyxcbiAgICAgIGZyZXF1ZW50UnBjTGlzdERldGFpbCxcbiAgICB9ID0gc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyO1xuXG4gICAgY29uc3QgbmV3QWNjb3VudFRva2VucyA9IHt9O1xuICAgIGNvbnN0IG5ld0FjY291bnRIaWRkZW5Ub2tlbnMgPSB7fTtcblxuICAgIGlmIChhY2NvdW50VG9rZW5zICYmIE9iamVjdC5rZXlzKGFjY291bnRUb2tlbnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBPYmplY3Qua2V5cyhhY2NvdW50VG9rZW5zKSkge1xuICAgICAgICBuZXdBY2NvdW50VG9rZW5zW2FkZHJlc3NdID0ge307XG4gICAgICAgIGlmIChhY2NvdW50VG9rZW5zW2FkZHJlc3NdW05FVFdPUktfVFlQRV9SUENdKSB7XG4gICAgICAgICAgZnJlcXVlbnRScGNMaXN0RGV0YWlsLmZvckVhY2goKGRldGFpbCkgPT4ge1xuICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVtkZXRhaWwuY2hhaW5JZF0gPVxuICAgICAgICAgICAgICBhY2NvdW50VG9rZW5zW2FkZHJlc3NdW05FVFdPUktfVFlQRV9SUENdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcHJvdmlkZXJUeXBlIG9mIE9iamVjdC5rZXlzKGFjY291bnRUb2tlbnNbYWRkcmVzc10pKSB7XG4gICAgICAgICAgc3dpdGNoIChwcm92aWRlclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTUFJTk5FVDpcbiAgICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVtNQUlOTkVUX0NIQUlOX0lEXSA9XG4gICAgICAgICAgICAgICAgYWNjb3VudFRva2Vuc1thZGRyZXNzXVtNQUlOTkVUXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJPUFNURU46XG4gICAgICAgICAgICAgIG5ld0FjY291bnRUb2tlbnNbYWRkcmVzc11bUk9QU1RFTl9DSEFJTl9JRF0gPVxuICAgICAgICAgICAgICAgIGFjY291bnRUb2tlbnNbYWRkcmVzc11bUk9QU1RFTl07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSSU5LRUJZOlxuICAgICAgICAgICAgICBuZXdBY2NvdW50VG9rZW5zW2FkZHJlc3NdW1JJTktFQllfQ0hBSU5fSURdID1cbiAgICAgICAgICAgICAgICBhY2NvdW50VG9rZW5zW2FkZHJlc3NdW1JJTktFQlldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgR09FUkxJOlxuICAgICAgICAgICAgICBuZXdBY2NvdW50VG9rZW5zW2FkZHJlc3NdW0dPRVJMSV9DSEFJTl9JRF0gPVxuICAgICAgICAgICAgICAgIGFjY291bnRUb2tlbnNbYWRkcmVzc11bR09FUkxJXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtPVkFOOlxuICAgICAgICAgICAgICBuZXdBY2NvdW50VG9rZW5zW2FkZHJlc3NdW0tPVkFOX0NIQUlOX0lEXSA9XG4gICAgICAgICAgICAgICAgYWNjb3VudFRva2Vuc1thZGRyZXNzXVtLT1ZBTl07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2VucyA9IG5ld0FjY291bnRUb2tlbnM7XG4gICAgfVxuXG4gICAgaWYgKGFjY291bnRIaWRkZW5Ub2tlbnMgJiYgT2JqZWN0LmtleXMoYWNjb3VudEhpZGRlblRva2VucykubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIE9iamVjdC5rZXlzKGFjY291bnRIaWRkZW5Ub2tlbnMpKSB7XG4gICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc10gPSB7fTtcbiAgICAgICAgaWYgKGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bTkVUV09SS19UWVBFX1JQQ10pIHtcbiAgICAgICAgICBmcmVxdWVudFJwY0xpc3REZXRhaWwuZm9yRWFjaCgoZGV0YWlsKSA9PiB7XG4gICAgICAgICAgICBuZXdBY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW2RldGFpbC5jaGFpbklkXSA9XG4gICAgICAgICAgICAgIGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bTkVUV09SS19UWVBFX1JQQ107XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwcm92aWRlclR5cGUgb2YgT2JqZWN0LmtleXMoYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKHByb3ZpZGVyVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBNQUlOTkVUOlxuICAgICAgICAgICAgICBuZXdBY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW01BSU5ORVRfQ0hBSU5fSURdID1cbiAgICAgICAgICAgICAgICBhY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW01BSU5ORVRdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUk9QU1RFTjpcbiAgICAgICAgICAgICAgbmV3QWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtST1BTVEVOX0NIQUlOX0lEXSA9XG4gICAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtST1BTVEVOXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJJTktFQlk6XG4gICAgICAgICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bUklOS0VCWV9DSEFJTl9JRF0gPVxuICAgICAgICAgICAgICAgIGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bUklOS0VCWV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBHT0VSTEk6XG4gICAgICAgICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bR09FUkxJX0NIQUlOX0lEXSA9XG4gICAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtHT0VSTEldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS09WQU46XG4gICAgICAgICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bS09WQU5fQ0hBSU5fSURdID1cbiAgICAgICAgICAgICAgICBhY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW0tPVkFOXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50SGlkZGVuVG9rZW5zID0gbmV3QWNjb3VudEhpZGRlblRva2VucztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IE5FVFdPUktfVFlQRV9UT19JRF9NQVAgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuXG5jb25zdCB2ZXJzaW9uID0gNTE7XG5cbi8qKlxuICogU2V0IHRoZSBjaGFpbklkIGluIHRoZSBOZXR3b3JrIENvbnRyb2xsZXIgcHJvdmlkZXIgZGF0YSBmb3IgYWxsIGluZnVyYSBuZXR3b3Jrc1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCB7IGNoYWluSWQsIHR5cGUgfSA9IHN0YXRlPy5OZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXIgfHwge307XG4gIGNvbnN0IGVudW1DaGFpbklkID0gTkVUV09SS19UWVBFX1RPX0lEX01BUFt0eXBlXT8uY2hhaW5JZDtcblxuICBpZiAoZW51bUNoYWluSWQgJiYgY2hhaW5JZCAhPT0gZW51bUNoYWluSWQpIHtcbiAgICBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlci5jaGFpbklkID0gZW51bUNoYWluSWQ7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDU0O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRGVjaW1hbHMoZGVjaW1hbHMpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZGVjaW1hbHMgPT09ICdudW1iZXInIHx8XG4gICAgKHR5cGVvZiBkZWNpbWFscyA9PT0gJ3N0cmluZycgJiYgZGVjaW1hbHMubWF0Y2goL14oMHgpP1xcZCskL3UpKVxuICApO1xufVxuXG4vKipcbiAqIE1pZ3JhdGVzIHByZWZlcmVuY2UgdG9rZW5zIHdpdGggZGVjaW1hbHMgdHlwZWQgYXMgc3RyaW5nIHRvIG51bWJlci5cbiAqIEl0IGFsc28gcmVtb3ZlcyBhbnkgdG9rZW5zIHdpdGggY29ycnVwdGVkIG9yIGluY29udmVydGlibGUgZGVjaW1hbCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcblxuICBpZiAoIW5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHRva2VucyA9IG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci50b2tlbnMgfHwgW107XG4gIC8vIEZpbHRlciBvdXQgYW55IHRva2VucyB3aXRoIGNvcnJ1cHRlZCBkZWNpbWFsIHZhbHVlc1xuICBjb25zdCB2YWxpZFRva2VucyA9IHRva2Vucy5maWx0ZXIoKHsgZGVjaW1hbHMgfSkgPT5cbiAgICBpc1ZhbGlkRGVjaW1hbHMoZGVjaW1hbHMpLFxuICApO1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHZhbGlkVG9rZW5zKSB7XG4gICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSBkZWNpbWFsIHZhbHVlIHR5cGUgc3RyaW5nLCBjb252ZXJ0IHRvIGEgbnVtYmVyLlxuICAgIGlmICh0eXBlb2YgdG9rZW4uZGVjaW1hbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmFkaXhcbiAgICAgIHRva2VuLmRlY2ltYWxzID0gcGFyc2VJbnQodG9rZW4uZGVjaW1hbHMpO1xuICAgIH1cbiAgfVxuICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zID0gdmFsaWRUb2tlbnM7XG5cbiAgY29uc3QgeyBhY2NvdW50VG9rZW5zIH0gPSBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI7XG4gIGlmIChhY2NvdW50VG9rZW5zICYmIHR5cGVvZiBhY2NvdW50VG9rZW5zID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBPYmplY3Qua2V5cyhhY2NvdW50VG9rZW5zKSkge1xuICAgICAgY29uc3QgbmV0d29ya1Rva2VucyA9IGFjY291bnRUb2tlbnNbYWRkcmVzc107XG4gICAgICBpZiAobmV0d29ya1Rva2VucyAmJiB0eXBlb2YgbmV0d29ya1Rva2VucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBuZXR3b3JrIG9mIE9iamVjdC5rZXlzKG5ldHdvcmtUb2tlbnMpKSB7XG4gICAgICAgICAgY29uc3QgdG9rZW5zT25OZXR3b3JrID0gbmV0d29ya1Rva2Vuc1tuZXR3b3JrXSB8fCBbXTtcbiAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGFueSB0b2tlbnMgd2l0aCBjb3JydXB0ZWQgZGVjaW1hbCB2YWx1ZXNcbiAgICAgICAgICBjb25zdCB2YWxpZFRva2Vuc09uTmV0d29yayA9IHRva2Vuc09uTmV0d29yay5maWx0ZXIoKHsgZGVjaW1hbHMgfSkgPT5cbiAgICAgICAgICAgIGlzVmFsaWREZWNpbWFscyhkZWNpbWFscyksXG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIGRlY2ltYWwgdmFsdWUgdHlwZSBzdHJpbmcsIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB2YWxpZFRva2Vuc09uTmV0d29yaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbi5kZWNpbWFscyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJhZGl4XG4gICAgICAgICAgICAgIHRva2VuLmRlY2ltYWxzID0gcGFyc2VJbnQodG9rZW4uZGVjaW1hbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZXR3b3JrVG9rZW5zW25ldHdvcmtdID0gdmFsaWRUb2tlbnNPbk5ldHdvcms7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnMgPSBhY2NvdW50VG9rZW5zO1xuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA1MDtcblxuY29uc3QgTEVHQUNZX0xPQ0FMX1NUT1JBR0VfS0VZUyA9IFtcbiAgJ01FVEFTV0FQX0dBU19QUklDRV9FU1RJTUFURVNfTEFTVF9SRVRSSUVWRUQnLFxuICAnTUVUQVNXQVBfR0FTX1BSSUNFX0VTVElNQVRFUycsXG4gICdjYWNoZWRGZXRjaCcsXG4gICdCQVNJQ19QUklDRV9FU1RJTUFURVNfTEFTVF9SRVRSSUVWRUQnLFxuICAnQkFTSUNfUFJJQ0VfRVNUSU1BVEVTJyxcbiAgJ0JBU0lDX0dBU19BTkRfVElNRV9BUElfRVNUSU1BVEVTJyxcbiAgJ0JBU0lDX0dBU19BTkRfVElNRV9BUElfRVNUSU1BVEVTX0xBU1RfUkVUUklFVkVEJyxcbiAgJ0dBU19BUElfRVNUSU1BVEVTX0xBU1RfUkVUUklFVkVEJyxcbiAgJ0dBU19BUElfRVNUSU1BVEVTJyxcbl07XG5cbi8qKlxuICogTWlncmF0ZSBtZXRhTWV0cmljcyBzdGF0ZSB0byB0aGUgbmV3IE1ldGFNZXRyaWNzIGNvbnRyb2xsZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG5cbiAgICBMRUdBQ1lfTE9DQUxfU1RPUkFHRV9LRVlTLmZvckVhY2goKGtleSkgPT5cbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2U/LnJlbW92ZUl0ZW0oa2V5KSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuIiwiaW1wb3J0IHsgY2xvbmVEZWVwLCBtYXBLZXlzIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IE5FVFdPUktfVFlQRV9UT19JRF9NQVAgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuXG5jb25zdCB2ZXJzaW9uID0gNTU7XG5cbi8qKlxuICogcmVwbGFjZSAnaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tzQnlOZXR3b3JrJyB3aXRoICdpbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja0J5Q2hhaW5JZCdcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuY29uc3QgVU5LTk9XTl9DSEFJTl9JRF9LRVkgPSAnVU5LTk9XTic7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChcbiAgICBzdGF0ZT8uSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyPy5pbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcmtcbiAgKSB7XG4gICAgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyLmluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2NrQnlDaGFpbklkID0gbWFwS2V5cyhcbiAgICAgIHN0YXRlLkluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlci5pbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcmssXG4gICAgICAvLyB1c2luZyBvcHRpb25hbCBjaGFpbmluZyBpbiBjYXNlIHVzZXIncyBzdGF0ZSBoYXMgZmV0Y2hlZCBibG9ja3MgZm9yXG4gICAgICAvLyBSUEMgbmV0d29yayB0eXBlcyAod2hpY2ggZG9uJ3QgbWFwIHRvIGEgc2luZ2xlIGNoYWluSWQpLiBUaGlzIHNob3VsZFxuICAgICAgLy8gbm90IGJlIHBvc3NpYmxlLCBidXQgaXQncyBzYWZlclxuICAgICAgKF8sIGtleSkgPT4gTkVUV09SS19UWVBFX1RPX0lEX01BUFtrZXldPy5jaGFpbklkID8/IFVOS05PV05fQ0hBSU5fSURfS0VZLFxuICAgICk7XG4gICAgLy8gTm93IHRoYXQgbWFpbm5ldCBhbmQgdGVzdCBuZXQgbGFzdCBmZXRjaGVkIGJsb2NrcyBhcmUga2V5ZWQgYnkgdGhlaXJcbiAgICAvLyByZXNwZWN0aXZlIGNoYWluSWRzLCB3ZSBjYW4gc2FmZWx5IGRlbGV0ZSBhbnl0aGluZyB3ZSBoYWQgZm9yIGN1c3RvbVxuICAgIC8vIG5ldHdvcmtzLiBBbnkgY3VzdG9tIG5ldHdvcmsgdGhhdCBzaGFyZXMgYSBjaGFpbklkIHdpdGggb25lIG9mIHRoZVxuICAgIC8vIGFmb3JlbWVudGlvbmVkIG5ldHdvcmtzIHdpbGwgdXNlIHRoZSB2YWx1ZSBzdG9yZWQgYnkgY2hhaW5JZC5cbiAgICBkZWxldGUgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXG4gICAgICAuaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tCeUNoYWluSWRbVU5LTk9XTl9DSEFJTl9JRF9LRVldO1xuICAgIGRlbGV0ZSBzdGF0ZS5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXJcbiAgICAgIC5pbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcms7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDU2O1xuXG4vKipcbiAqIFJlbW92ZSB0b2tlbnMgdGhhdCBkb24ndCBoYXZlIGFuIGFkZHJlc3MgZHVlIHRvXG4gKiBsYWNrIG9mIHByZXZpb3VzIGFkZFRva2VuIHZhbGlkYXRpb24uICBBbHNvIHJlbW92ZXNcbiAqIGFuIHVud2FudGVkLCB1bmRlZmluZWQgaW1hZ2UgcHJvcGVydHlcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG5cbiAgICBjb25zdCB7IFByZWZlcmVuY2VzQ29udHJvbGxlciB9ID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoUHJlZmVyZW5jZXNDb250cm9sbGVyPy50b2tlbnMpKSB7XG4gICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLnRva2Vucy5maWx0ZXIoXG4gICAgICAgICh7IGFkZHJlc3MgfSkgPT4gYWRkcmVzcyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hY2NvdW50VG9rZW5zICYmXG4gICAgICB0eXBlb2YgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnMgPT09ICdvYmplY3QnXG4gICAgKSB7XG4gICAgICBPYmplY3Qua2V5cyhQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2VucykuZm9yRWFjaCgoYWNjb3VudCkgPT4ge1xuICAgICAgICBjb25zdCBjaGFpbnMgPSBPYmplY3Qua2V5cyhcbiAgICAgICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2Vuc1thY2NvdW50XSxcbiAgICAgICAgKTtcbiAgICAgICAgY2hhaW5zLmZvckVhY2goKGNoYWluKSA9PiB7XG4gICAgICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnNbYWNjb3VudF1bXG4gICAgICAgICAgICBjaGFpblxuICAgICAgICAgIF0gPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2Vuc1thY2NvdW50XVtjaGFpbl0uZmlsdGVyKFxuICAgICAgICAgICAgKHsgYWRkcmVzcyB9KSA9PiBhZGRyZXNzLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hc3NldEltYWdlcyAmJlxuICAgICAgJ3VuZGVmaW5lZCcgaW4gUHJlZmVyZW5jZXNDb250cm9sbGVyLmFzc2V0SW1hZ2VzXG4gICAgKSB7XG4gICAgICBkZWxldGUgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFzc2V0SW1hZ2VzLnVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNTg7XG5cbi8qKlxuICogRGVsZXRlcyB0aGUgc3dhcHNXZWxjb21lTWVzc2FnZUhhc0JlZW5TaG93biBwcm9wZXJ0eSBmcm9tIHN0YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGRlbGV0ZSBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXI/LnN3YXBzV2VsY29tZU1lc3NhZ2VIYXNCZWVuU2hvd247XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHtcbiAgY2xvbmVEZWVwLFxuICBjb25jYXQsXG4gIGdyb3VwQnksXG4gIGtleUJ5LFxuICBwaWNrQnksXG4gIGlzUGxhaW5PYmplY3QsXG59IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuXG5jb25zdCB2ZXJzaW9uID0gNTk7XG5cbi8qKlxuICogUmVtb3ZlcyBvcnBoYW5lZCBjYW5jZWwgYW5kIHJldHJ5IHRyYW5zYWN0aW9ucyB0aGF0IG5vIGxvbmdlciBoYXZlIHRoZVxuICogb3JpZ2luYWwgdHJhbnNhY3Rpb24gaW4gc3RhdGUsIHdoaWNoIHJlc3VsdHMgaW4gYnVncy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zO1xuICBpZiAoaXNQbGFpbk9iamVjdCh0cmFuc2FjdGlvbnMpKSB7XG4gICAgY29uc3Qgbm9uY2VOZXR3b3JrR3JvdXBlZE9iamVjdCA9IGdyb3VwQnkoXG4gICAgICBPYmplY3QudmFsdWVzKHRyYW5zYWN0aW9ucyksXG4gICAgICAodHgpID0+IHtcbiAgICAgICAgcmV0dXJuIGAke3R4LnR4UGFyYW1zPy5ub25jZX0tJHt0eC5jaGFpbklkID8/IHR4Lm1ldGFtYXNrTmV0d29ya0lkfWA7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICBjb25zdCB3aXRob3V0T3JwaGFucyA9IHBpY2tCeShub25jZU5ldHdvcmtHcm91cGVkT2JqZWN0LCAoZ3JvdXApID0+IHtcbiAgICAgIHJldHVybiBncm91cC5zb21lKFxuICAgICAgICAodHgpID0+XG4gICAgICAgICAgdHgudHlwZSAhPT0gVFJBTlNBQ1RJT05fVFlQRVMuQ0FOQ0VMICYmXG4gICAgICAgICAgdHgudHlwZSAhPT0gVFJBTlNBQ1RJT05fVFlQRVMuUkVUUlksXG4gICAgICApO1xuICAgIH0pO1xuICAgIHN0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSBrZXlCeShcbiAgICAgIGNvbmNhdCguLi5PYmplY3QudmFsdWVzKHdpdGhvdXRPcnBoYW5zKSksXG4gICAgICAodHgpID0+IHR4LmlkLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIGlzUGxhaW5PYmplY3QgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNjA7XG5jb25zdCBTVVBQT1JUX05PVElGSUNBVElPTl9LRVkgPSAyO1xuY29uc3QgU1VQUE9SVF9OT1RJRklDQVRJT05fREFURSA9ICcyMDIwLTA4LTMxJztcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBzdXBwb3J0IHN1cnZleSBub3RpZmljYXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBub3RpZmljYXRpb25zID0gc3RhdGU/Lk5vdGlmaWNhdGlvbkNvbnRyb2xsZXI/Lm5vdGlmaWNhdGlvbnM7XG4gIGlmIChpc1BsYWluT2JqZWN0KG5vdGlmaWNhdGlvbnMpKSB7XG4gICAgaWYgKFxuICAgICAgbm90aWZpY2F0aW9uc1tTVVBQT1JUX05PVElGSUNBVElPTl9LRVldPy5kYXRlID09PVxuICAgICAgU1VQUE9SVF9OT1RJRklDQVRJT05fREFURVxuICAgICkge1xuICAgICAgZGVsZXRlIHN0YXRlLk5vdGlmaWNhdGlvbkNvbnRyb2xsZXIubm90aWZpY2F0aW9uc1tcbiAgICAgICAgU1VQUE9SVF9OT1RJRklDQVRJT05fS0VZXG4gICAgICBdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNjE7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhdHRyaWJ1dGVzIHJlbGF0ZWQgdG8gcmVjb3Zlcnkgc2VlZCBwaHJhc2UgcmVtaW5kZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBpZiAoc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyKSB7XG4gICAgc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyLnJlY292ZXJ5UGhyYXNlUmVtaW5kZXJIYXNCZWVuU2hvd24gPSBmYWxzZTtcbiAgICBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIucmVjb3ZlcnlQaHJhc2VSZW1pbmRlckxhc3RTaG93biA9IGN1cnJlbnRUaW1lO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlciA9IHtcbiAgICAgIHJlY292ZXJ5UGhyYXNlUmVtaW5kZXJIYXNCZWVuU2hvd246IGZhbHNlLFxuICAgICAgcmVjb3ZlcnlQaHJhc2VSZW1pbmRlckxhc3RTaG93bjogY3VycmVudFRpbWUsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNjI7XG5cbi8qKlxuICogUmVtb3ZlcyBtZXRhTWV0cmljc1NlbmRDb3VudCBmcm9tIE1ldGFNZXRyaWNzIGNvbnRyb2xsZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBpZiAoc3RhdGUuTWV0YU1ldHJpY3NDb250cm9sbGVyKSB7XG4gICAgY29uc3QgeyBtZXRhTWV0cmljc1NlbmRDb3VudCB9ID0gc3RhdGUuTWV0YU1ldHJpY3NDb250cm9sbGVyO1xuICAgIGlmIChtZXRhTWV0cmljc1NlbmRDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgc3RhdGUuTWV0YU1ldHJpY3NDb250cm9sbGVyLm1ldGFNZXRyaWNzU2VuZENvdW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIGlzUGxhaW5PYmplY3QgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVFJBTlNBQ1RJT05fVFlQRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuY29uc3QgdmVyc2lvbiA9IDY0O1xuXG5jb25zdCBTRU5UX0VUSEVSID0gJ3NlbnRFdGhlcic7IC8vIHRoZSBsZWdhY3kgdHJhbnNhY3Rpb24gdHlwZSBiZWluZyByZXBsYWNlZCBpbiB0aGlzIG1pZ3JhdGlvbiB3aXRoIFRSQU5TQUNUSU9OX1RZUEVTLlNJTVBMRV9TRU5EXG5cbi8qKlxuICogUmVtb3ZlcyBtZXRhTWV0cmljc1NlbmRDb3VudCBmcm9tIE1ldGFNZXRyaWNzIGNvbnRyb2xsZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBzdGF0ZT8uVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnM7XG4gIGlmIChpc1BsYWluT2JqZWN0KHRyYW5zYWN0aW9ucykpIHtcbiAgICBmb3IgKGNvbnN0IHR4IG9mIE9iamVjdC52YWx1ZXModHJhbnNhY3Rpb25zKSkge1xuICAgICAgaWYgKHR4LnR5cGUgPT09IFNFTlRfRVRIRVIpIHtcbiAgICAgICAgdHgudHlwZSA9IFRSQU5TQUNUSU9OX1RZUEVTLlNJTVBMRV9TRU5EO1xuICAgICAgfVxuICAgICAgaWYgKHR4Lmhpc3RvcnkpIHtcbiAgICAgICAgdHguaGlzdG9yeS5tYXAoKHR4RXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAodHhFdmVudC50eXBlICYmIHR4RXZlbnQudHlwZSA9PT0gU0VOVF9FVEhFUikge1xuICAgICAgICAgICAgdHhFdmVudC50eXBlID0gVFJBTlNBQ1RJT05fVFlQRVMuU0lNUExFX1NFTkQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eEV2ZW50O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDY1O1xuXG4vKipcbiAqIFJlbW92ZXMgbWV0YU1ldHJpY3NTZW5kQ291bnQgZnJvbSBNZXRhTWV0cmljcyBjb250cm9sbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbXBsZXRlZE9uYm9hcmRpbmcsXG4gICAgICBmaXJzdFRpbWVGbG93VHlwZSxcbiAgICB9ID0gc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyO1xuICAgIHN0YXRlLk9uYm9hcmRpbmdDb250cm9sbGVyID0gc3RhdGUuT25ib2FyZGluZ0NvbnRyb2xsZXIgPz8ge307XG5cbiAgICBpZiAoY29tcGxldGVkT25ib2FyZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGF0ZS5PbmJvYXJkaW5nQ29udHJvbGxlci5jb21wbGV0ZWRPbmJvYXJkaW5nID0gY29tcGxldGVkT25ib2FyZGluZztcbiAgICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuY29tcGxldGVkT25ib2FyZGluZztcbiAgICB9XG4gICAgaWYgKGZpcnN0VGltZUZsb3dUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXRlLk9uYm9hcmRpbmdDb250cm9sbGVyLmZpcnN0VGltZUZsb3dUeXBlID0gZmlyc3RUaW1lRmxvd1R5cGU7XG4gICAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmZpcnN0VGltZUZsb3dUeXBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBTVUJKRUNUX1RZUEVTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hcHAnO1xuXG5jb25zdCB2ZXJzaW9uID0gNjk7XG5cbi8qKlxuICogQWRkcyB0aGUgYHN1YmplY3RUeXBlYCBwcm9wZXJ0eSB0byBhbGwgc3ViamVjdCBtZXRhZGF0YS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBpZiAodHlwZW9mIHN0YXRlPy5TdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyPy5zdWJqZWN0TWV0YWRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3Qge1xuICAgICAgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjogeyBzdWJqZWN0TWV0YWRhdGEgfSxcbiAgICB9ID0gc3RhdGU7XG5cbiAgICAvLyBtdXRhdGUgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlci5zdWJqZWN0TWV0YWRhdGEgaW4gcGxhY2VcbiAgICBPYmplY3QudmFsdWVzKHN1YmplY3RNZXRhZGF0YSkuZm9yRWFjaCgobWV0YWRhdGEpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgbWV0YWRhdGEgJiZcbiAgICAgICAgdHlwZW9mIG1ldGFkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAhQXJyYXkuaXNBcnJheShtZXRhZGF0YSlcbiAgICAgICkge1xuICAgICAgICBtZXRhZGF0YS5zdWJqZWN0VHlwZSA9IG1ldGFkYXRhLmV4dGVuc2lvbklkXG4gICAgICAgICAgPyBTVUJKRUNUX1RZUEVTLkVYVEVOU0lPTlxuICAgICAgICAgIDogU1VCSkVDVF9UWVBFUy5XRUJTSVRFO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyB1dGlsIH0gZnJvbSAnQG1ldGFtYXNrL2NvbnRyb2xsZXJzJztcblxuY29uc3QgdmVyc2lvbiA9IDM3O1xuXG4vKipcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWlncmF0aW9uIGlzIHRvIHVwZGF0ZSB0aGUgYWRkcmVzcyBib29rIHN0YXRlXG4gKiB0byB0aGUgbmV3IHNjaGVtYSB3aXRoIGNoYWluSWQgYXMgYSBrZXkuXG4gKiBhbmQgdG8gYWRkIHRoZSBpc0VucyBmbGFnIHRvIGFsbCBlbnRyaWVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5BZGRyZXNzQm9va0NvbnRyb2xsZXIpIHtcbiAgICBjb25zdCBhYiA9IHN0YXRlLkFkZHJlc3NCb29rQ29udHJvbGxlci5hZGRyZXNzQm9vaztcblxuICAgIGNvbnN0IGNoYWluSWRzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG5ld0FkZHJlc3NCb29rID0ge307XG5cbiAgICAvLyBhZGQgYWxsIG9mIHRoZSBjaGFpbklkcyB0byBhIHNldFxuICAgIE9iamVjdC52YWx1ZXMoYWIpLmZvckVhY2goKHYpID0+IHtcbiAgICAgIGNoYWluSWRzLmFkZCh2LmNoYWluSWQpO1xuICAgIH0pO1xuXG4gICAgLy8gZmlsbCB0aGUgY2hhaW5JZCBvYmplY3Qgd2l0aCB0aGUgZW50cmllcyB3aXRoIHRoZSBtYXRjaGluZyBjaGFpbklkXG4gICAgZm9yIChjb25zdCBpZCBvZiBjaGFpbklkcy52YWx1ZXMoKSkge1xuICAgICAgLy8gbWFrZSBhbiBlbXB0eSBvYmplY3QgZW50cnkgZm9yIGVhY2ggY2hhaW5JZFxuICAgICAgbmV3QWRkcmVzc0Jvb2tbaWRdID0ge307XG4gICAgICBmb3IgKGNvbnN0IGFkZHJlc3MgaW4gYWIpIHtcbiAgICAgICAgaWYgKGFiW2FkZHJlc3NdLmNoYWluSWQgPT09IGlkKSB7XG4gICAgICAgICAgYWJbYWRkcmVzc10uaXNFbnMgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodXRpbC5ub3JtYWxpemVFbnNOYW1lKGFiW2FkZHJlc3NdLm5hbWUpKSB7XG4gICAgICAgICAgICBhYlthZGRyZXNzXS5pc0VucyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ld0FkZHJlc3NCb29rW2lkXVthZGRyZXNzXSA9IGFiW2FkZHJlc3NdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUuQWRkcmVzc0Jvb2tDb250cm9sbGVyLmFkZHJlc3NCb29rID0gbmV3QWRkcmVzc0Jvb2s7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiBtb3ZlcyBzdGF0ZSBmcm9tIHRoZSBmbGF0IHN0YXRlIHRyaWUgaW50byBLZXlyaW5nQ29udHJvbGxlciBzdWJzdGF0ZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHNlbGVjdFN1YnN0YXRlRm9yS2V5cmluZ0NvbnRyb2xsZXIoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjNSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gc2VsZWN0U3Vic3RhdGVGb3JLZXlyaW5nQ29udHJvbGxlcihzdGF0ZSkge1xuICBjb25zdCB7IGNvbmZpZyB9ID0gc3RhdGU7XG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIEtleXJpbmdDb250cm9sbGVyOiB7XG4gICAgICB2YXVsdDogc3RhdGUudmF1bHQsXG4gICAgICBzZWxlY3RlZEFjY291bnQ6IGNvbmZpZy5zZWxlY3RlZEFjY291bnQsXG4gICAgICB3YWxsZXROaWNrbmFtZXM6IHN0YXRlLndhbGxldE5pY2tuYW1lcyxcbiAgICB9LFxuICB9O1xuICBkZWxldGUgbmV3U3RhdGUudmF1bHQ7XG4gIGRlbGV0ZSBuZXdTdGF0ZS53YWxsZXROaWNrbmFtZXM7XG4gIGRlbGV0ZSBuZXdTdGF0ZS5jb25maWcuc2VsZWN0ZWRBY2NvdW50O1xuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIGJyZWFrcyBvdXQgdGhlIFRyYW5zYWN0aW9uTWFuYWdlciBzdWJzdGF0ZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIFRyYW5zYWN0aW9uTWFuYWdlcjoge1xuICAgICAgdHJhbnNhY3Rpb25zOiBzdGF0ZS50cmFuc2FjdGlvbnMgfHwgW10sXG4gICAgICBnYXNNdWx0aXBsaWVyOiBzdGF0ZS5nYXNNdWx0aXBsaWVyIHx8IDEsXG4gICAgfSxcbiAgfTtcbiAgZGVsZXRlIG5ld1N0YXRlLnRyYW5zYWN0aW9ucztcbiAgZGVsZXRlIG5ld1N0YXRlLmdhc011bHRpcGxpZXI7XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gbW92ZXMgS2V5cmluZ0NvbnRyb2xsZXIuc2VsZWN0ZWRBZGRyZXNzIHRvIFByZWZlcmVuY2VzQ29udHJvbGxlci5zZWxlY3RlZEFkZHJlc3NcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDY7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSBtaWdyYXRlU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gbWlncmF0ZVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IGtleXJpbmdTdWJzdGF0ZSA9IHN0YXRlLktleXJpbmdDb250cm9sbGVyO1xuXG4gIC8vIGFkZCBuZXcgc3RhdGVcbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XG4gICAgICBzZWxlY3RlZEFkZHJlc3M6IGtleXJpbmdTdWJzdGF0ZS5zZWxlY3RlZEFjY291bnQsXG4gICAgfSxcbiAgfTtcblxuICAvLyBybSBvbGQgc3RhdGVcbiAgZGVsZXRlIG5ld1N0YXRlLktleXJpbmdDb250cm9sbGVyLnNlbGVjdGVkQWNjb3VudDtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiBicmVha3Mgb3V0IHRoZSBOb3RpY2VDb250cm9sbGVyIHN1YnN0YXRlXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA4O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgTm90aWNlQ29udHJvbGxlcjoge1xuICAgICAgbm90aWNlc0xpc3Q6IHN0YXRlLm5vdGljZXNMaXN0IHx8IFtdLFxuICAgIH0sXG4gIH07XG4gIGRlbGV0ZSBuZXdTdGF0ZS5ub3RpY2VzTGlzdDtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvLyBuZXh0IHZlcnNpb24gbnVtYmVyXG5pbXBvcnQgeyBUUkFOU0FDVElPTl9TVEFUVVNFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuaW1wb3J0IGZhaWxUeHNUaGF0IGZyb20gJy4vZmFpbC10eCc7XG5cbmNvbnN0IHZlcnNpb24gPSAyOTtcblxuLy8gdGltZVxuY29uc3Qgc2Vjb25kcyA9IDEwMDA7XG5jb25zdCBtaW51dGVzID0gNjAgKiBzZWNvbmRzO1xuY29uc3QgaG91cnMgPSA2MCAqIG1pbnV0ZXM7XG5jb25zdCB1bmFjY2VwdGFibGVEZWxheSA9IDEyICogaG91cnM7XG5cbi8qXG5cbm5vcm1hbGl6ZXMgdHhQYXJhbXMgb24gdW5jb25maXJtZWQgdHhzXG5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlOiBmYWlsVHhzVGhhdChcbiAgICB2ZXJzaW9uLFxuICAgICdTdHVjayBpbiBhcHByb3ZlZCBzdGF0ZSBmb3IgdG9vIGxvbmcuJyxcbiAgICAodHhNZXRhKSA9PiB7XG4gICAgICBjb25zdCBpc0FwcHJvdmVkID0gdHhNZXRhLnN0YXR1cyA9PT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuQVBQUk9WRUQ7XG4gICAgICBjb25zdCBjcmVhdGVkVGltZSA9IHR4TWV0YS5zdWJtaXR0ZWRUaW1lO1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIHJldHVybiBpc0FwcHJvdmVkICYmIG5vdyAtIGNyZWF0ZWRUaW1lID4gdW5hY2NlcHRhYmxlRGVsYXk7XG4gICAgfSxcbiAgKSxcbn07XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMzg7XG5cbi8qKlxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gYXNzaWduIGFsbCB1c2VycyB0byBhIHRlc3QgZ3JvdXAgZm9yIHRoZSBmdWxsU2NyZWVuVnNQb3B1cCBhL2IgdGVzdFxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCB7IEFCVGVzdENvbnRyb2xsZXI6IEFCVGVzdENvbnRyb2xsZXJTdGF0ZSA9IHt9IH0gPSBzdGF0ZTtcbiAgY29uc3QgeyBhYlRlc3RzID0ge30gfSA9IEFCVGVzdENvbnRyb2xsZXJTdGF0ZTtcblxuICBpZiAoYWJUZXN0cy5mdWxsU2NyZWVuVnNQb3B1cCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgQUJUZXN0Q29udHJvbGxlcjoge1xuICAgICAgLi4uQUJUZXN0Q29udHJvbGxlclN0YXRlLFxuICAgICAgYWJUZXN0czoge1xuICAgICAgICAuLi5hYlRlc3RzLFxuICAgICAgICBmdWxsU2NyZWVuVnNQb3B1cDogJ2NvbnRyb2wnLFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDQ4O1xuXG4vKipcbiAqIDEuICBEZWxldGUgTmV0d29ya0NvbnRyb2xsZXIuc2V0dGluZ3NcbiAqIDJhLiBNaWdyYXRlIE5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyIHRvIFJpbmtlYnkgaWYgc2V0IHRvIHR5cGUgJ3JwYycgb3JcbiAqICAgICAnbG9jYWxob3N0Jy5cbiAqIDJiLiBSZS1rZXkgcHJvdmlkZXIucnBjVGFyZ2V0IHRvIHByb3ZpZGVyLnJwY1VybFxuICogMy4gIEFkZCBsb2NhbGhvc3QgbmV0d29yayB0byBmcmVxdWVudFJwY0xpc3REZXRhaWwuXG4gKiA0LiAgRGVsZXRlIENhY2hlZEJhbGFuY2VzQ29udHJvbGxlci5jYWNoZWRCYWxhbmNlc1xuICogNS4gIENvbnZlcnQgdHJhbnNhY3Rpb25zIG1ldGFtYXNrTmV0d29ya0lkIHRvIGRlY2ltYWwgaWYgdGhleSBhcmUgaGV4XG4gKiA2LiAgQ29udmVydCBhZGRyZXNzIGJvb2sga2V5cyBmcm9tIGRlY2ltYWwgdG8gaGV4XG4gKiA3LiAgRGVsZXRlIGxvY2FsaG9zdCBrZXkgaW4gSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXG4gKiA4LiAgTWVyZ2UgJ2xvY2FsaG9zdCcgdG9rZW5zIGludG8gJ3JwYycgdG9rZW5zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmNvbnN0IGhleFJlZ0V4ID0gL14weFswLTlhLWZdKyQvaXU7XG5jb25zdCBjaGFpbklkUmVnRXggPSAvXjB4WzEtOWEtZl0rWzAtOWEtZl0qJC9pdTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUgPSB7fSkge1xuICAvLyAxLiBEZWxldGUgTmV0d29ya0NvbnRyb2xsZXIuc2V0dGluZ3NcbiAgZGVsZXRlIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyPy5zZXR0aW5ncztcblxuICAvLyAyLiBNaWdyYXRlIE5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyIHRvIFJpbmtlYnkgb3IgcmVuYW1lIHJwY1RhcmdldCBrZXlcbiAgY29uc3QgcHJvdmlkZXIgPSBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXIgfHwge307XG4gIGNvbnN0IGlzQ3VzdG9tUnBjV2l0aEludmFsaWRDaGFpbklkID1cbiAgICBwcm92aWRlci50eXBlID09PSAncnBjJyAmJlxuICAgICh0eXBlb2YgcHJvdmlkZXIuY2hhaW5JZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICFjaGFpbklkUmVnRXgudGVzdChwcm92aWRlci5jaGFpbklkKSk7XG4gIGlmIChpc0N1c3RvbVJwY1dpdGhJbnZhbGlkQ2hhaW5JZCB8fCBwcm92aWRlci50eXBlID09PSAnbG9jYWxob3N0Jykge1xuICAgIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyID0ge1xuICAgICAgdHlwZTogJ3JpbmtlYnknLFxuICAgICAgcnBjVXJsOiAnJyxcbiAgICAgIGNoYWluSWQ6ICcweDQnLFxuICAgICAgbmlja25hbWU6ICcnLFxuICAgICAgcnBjUHJlZnM6IHt9LFxuICAgICAgdGlja2VyOiAnRVRIJyxcbiAgICB9O1xuICB9IGVsc2UgaWYgKHN0YXRlLk5ldHdvcmtDb250cm9sbGVyPy5wcm92aWRlcikge1xuICAgIGlmICgncnBjVGFyZ2V0JyBpbiBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlcikge1xuICAgICAgY29uc3QgcnBjVXJsID0gc3RhdGUuTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIucnBjVGFyZ2V0O1xuICAgICAgc3RhdGUuTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIucnBjVXJsID0gcnBjVXJsO1xuICAgIH1cbiAgICBkZWxldGUgc3RhdGUuTmV0d29ya0NvbnRyb2xsZXI/LnByb3ZpZGVyPy5ycGNUYXJnZXQ7XG4gIH1cblxuICAvLyAzLiAgQWRkIGxvY2FsaG9zdCBuZXR3b3JrIHRvIGZyZXF1ZW50UnBjTGlzdERldGFpbC5cbiAgaWYgKCFzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcbiAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSB7fTtcbiAgfVxuICBpZiAoIXN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5mcmVxdWVudFJwY0xpc3REZXRhaWwpIHtcbiAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsID0gW107XG4gIH1cbiAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmZyZXF1ZW50UnBjTGlzdERldGFpbC51bnNoaWZ0KHtcbiAgICBycGNVcmw6ICdodHRwOi8vbG9jYWxob3N0Ojg1NDUnLFxuICAgIGNoYWluSWQ6ICcweDUzOScsXG4gICAgdGlja2VyOiAnRVRIJyxcbiAgICBuaWNrbmFtZTogJ0xvY2FsaG9zdCA4NTQ1JyxcbiAgICBycGNQcmVmczoge30sXG4gIH0pO1xuXG4gIC8vIDQuICBEZWxldGUgQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyLmNhY2hlZEJhbGFuY2VzXG4gIGRlbGV0ZSBzdGF0ZS5DYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXI/LmNhY2hlZEJhbGFuY2VzO1xuXG4gIC8vIDUuICBDb252ZXJ0IHRyYW5zYWN0aW9ucyBtZXRhbWFza05ldHdvcmtJZCB0byBkZWNpbWFsIGlmIHRoZXkgYXJlIGhleFxuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBzdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI/LnRyYW5zYWN0aW9ucztcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNhY3Rpb25zKSkge1xuICAgIHRyYW5zYWN0aW9ucy5mb3JFYWNoKCh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgY29uc3QgbWV0YW1hc2tOZXR3b3JrSWQgPSB0cmFuc2FjdGlvbj8ubWV0YW1hc2tOZXR3b3JrSWQ7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBtZXRhbWFza05ldHdvcmtJZCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgaGV4UmVnRXgudGVzdChtZXRhbWFza05ldHdvcmtJZClcbiAgICAgICkge1xuICAgICAgICB0cmFuc2FjdGlvbi5tZXRhbWFza05ldHdvcmtJZCA9IHBhcnNlSW50KFxuICAgICAgICAgIG1ldGFtYXNrTmV0d29ya0lkLFxuICAgICAgICAgIDE2LFxuICAgICAgICApLnRvU3RyaW5nKDEwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIDYuICBDb252ZXJ0IGFkZHJlc3MgYm9vayBrZXlzIGZyb20gZGVjaW1hbCB0byBoZXhcbiAgY29uc3QgYWRkcmVzc0Jvb2sgPSBzdGF0ZS5BZGRyZXNzQm9va0NvbnRyb2xsZXI/LmFkZHJlc3NCb29rIHx8IHt9O1xuICBPYmplY3Qua2V5cyhhZGRyZXNzQm9vaykuZm9yRWFjaCgobmV0d29ya0tleSkgPT4ge1xuICAgIGlmICgvXlxcZCskL2l1LnRlc3QobmV0d29ya0tleSkpIHtcbiAgICAgIGNvbnN0IGNoYWluSWQgPSBgMHgke3BhcnNlSW50KG5ldHdvcmtLZXksIDEwKS50b1N0cmluZygxNil9YDtcbiAgICAgIHVwZGF0ZUNoYWluSWRzKGFkZHJlc3NCb29rW25ldHdvcmtLZXldLCBjaGFpbklkKTtcblxuICAgICAgaWYgKGFkZHJlc3NCb29rW2NoYWluSWRdKSB7XG4gICAgICAgIG1lcmdlQWRkcmVzc0Jvb2tLZXlzKGFkZHJlc3NCb29rLCBuZXR3b3JrS2V5LCBjaGFpbklkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZHJlc3NCb29rW2NoYWluSWRdID0gYWRkcmVzc0Jvb2tbbmV0d29ya0tleV07XG4gICAgICB9XG4gICAgICBkZWxldGUgYWRkcmVzc0Jvb2tbbmV0d29ya0tleV07XG4gICAgfVxuICB9KTtcblxuICAvLyA3LiAgRGVsZXRlIGxvY2FsaG9zdCBrZXkgaW4gSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXG4gIGRlbGV0ZSBzdGF0ZS5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXJcbiAgICA/LmluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2Nrc0J5TmV0d29yaz8ubG9jYWxob3N0O1xuXG4gIC8vIDguICBNZXJnZSAnbG9jYWxob3N0JyB0b2tlbnMgaW50byAncnBjJyB0b2tlbnNcbiAgY29uc3QgYWNjb3VudFRva2VucyA9IHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcj8uYWNjb3VudFRva2VucztcbiAgaWYgKGFjY291bnRUb2tlbnMpIHtcbiAgICBPYmplY3Qua2V5cyhhY2NvdW50VG9rZW5zKS5mb3JFYWNoKChhY2NvdW50KSA9PiB7XG4gICAgICBjb25zdCBsb2NhbGhvc3RUb2tlbnMgPSBhY2NvdW50VG9rZW5zW2FjY291bnRdPy5sb2NhbGhvc3QgfHwgW107XG5cbiAgICAgIGlmIChsb2NhbGhvc3RUb2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBycGNUb2tlbnMgPSBhY2NvdW50VG9rZW5zW2FjY291bnRdLnJwYyB8fCBbXTtcblxuICAgICAgICBpZiAocnBjVG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhY2NvdW50VG9rZW5zW2FjY291bnRdLnJwYyA9IG1lcmdlVG9rZW5BcnJheXMoXG4gICAgICAgICAgICBsb2NhbGhvc3RUb2tlbnMsXG4gICAgICAgICAgICBycGNUb2tlbnMsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2NvdW50VG9rZW5zW2FjY291bnRdLnJwYyA9IGxvY2FsaG9zdFRva2VucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVsZXRlIGFjY291bnRUb2tlbnNbYWNjb3VudF0/LmxvY2FsaG9zdDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBNZXJnZXMgdGhlIHR3byBnaXZlbiBrZXlzIGZvciB0aGUgZ2l2ZW4gYWRkcmVzcyBib29rIGluIHBsYWNlLlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBtZXJnZUFkZHJlc3NCb29rS2V5cyhhZGRyZXNzQm9vaywgbmV0d29ya0tleSwgY2hhaW5JZEtleSkge1xuICBjb25zdCBuZXR3b3JrS2V5RW50cmllcyA9IGFkZHJlc3NCb29rW25ldHdvcmtLZXldIHx8IHt9O1xuICAvLyBGb3IgdGhlIG5ldyBlbnRyaWVzLCBzdGFydCBieSBjb3B5aW5nIHRoZSBleGlzdGluZyBlbnRyaWVzIGZvciB0aGUgY2hhaW5JZFxuICBjb25zdCBuZXdFbnRyaWVzID0geyAuLi5hZGRyZXNzQm9va1tjaGFpbklkS2V5XSB9O1xuXG4gIC8vIEZvciBlYWNoIGFkZHJlc3Mgb2YgdGhlIG9sZC9uZXR3b3JrSWQga2V5IGVudHJpZXNcbiAgT2JqZWN0LmtleXMobmV0d29ya0tleUVudHJpZXMpLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICBpZiAobmV3RW50cmllc1thZGRyZXNzXSAmJiB0eXBlb2YgbmV3RW50cmllc1thZGRyZXNzXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IG1lcmdlZEVudHJ5ID0ge307XG5cbiAgICAgIC8vIENvbGxlY3QgYWxsIGtleXMgZnJvbSBib3RoIGVudHJpZXMgYW5kIG1lcmdlIHRoZSBjb3JyZXNwb25kaW5nIGNoYWluSWRcbiAgICAgIC8vIGVudHJ5IHdpdGggdGhlIG5ldHdvcmtJZCBlbnRyeVxuICAgICAgbmV3IFNldChbXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKG5ld0VudHJpZXNbYWRkcmVzc10pLFxuICAgICAgICAuLi5PYmplY3Qua2V5cyhuZXR3b3JrS2V5RW50cmllc1thZGRyZXNzXSB8fCB7fSksXG4gICAgICBdKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgLy8gVXNlIG5vbi1lbXB0eSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQga2V5LCBpZiBhbnlcbiAgICAgICAgbWVyZ2VkRW50cnlba2V5XSA9XG4gICAgICAgICAgbmV3RW50cmllc1thZGRyZXNzXVtrZXldIHx8IG5ldHdvcmtLZXlFbnRyaWVzW2FkZHJlc3NdPy5ba2V5XSB8fCAnJztcbiAgICAgIH0pO1xuXG4gICAgICBuZXdFbnRyaWVzW2FkZHJlc3NdID0gbWVyZ2VkRW50cnk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG5ldHdvcmtLZXlFbnRyaWVzW2FkZHJlc3NdICYmXG4gICAgICB0eXBlb2YgbmV0d29ya0tleUVudHJpZXNbYWRkcmVzc10gPT09ICdvYmplY3QnXG4gICAgKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBjb3JyZXNwb25kaW5nIGNoYWluSWQgZW50cnksIGp1c3QgdXNlIHRoZSBuZXR3b3JrSWQgZW50cnlcbiAgICAgIC8vIGRpcmVjdGx5XG4gICAgICBuZXdFbnRyaWVzW2FkZHJlc3NdID0gbmV0d29ya0tleUVudHJpZXNbYWRkcmVzc107XG4gICAgfVxuICB9KTtcblxuICBhZGRyZXNzQm9va1tjaGFpbklkS2V5XSA9IG5ld0VudHJpZXM7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgY2hhaW5JZCBrZXkgdmFsdWVzIHRvIHRoZSBnaXZlbiBjaGFpbklkIGluIHBsYWNlIGZvciBhbGwgdmFsdWVzXG4gKiBvZiB0aGUgZ2l2ZW4gbmV0d29ya0VudHJpZXMgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1cGRhdGVDaGFpbklkcyhuZXR3b3JrRW50cmllcywgY2hhaW5JZCkge1xuICBPYmplY3QudmFsdWVzKG5ldHdvcmtFbnRyaWVzKS5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgIGlmIChlbnRyeSAmJiB0eXBlb2YgZW50cnkgPT09ICdvYmplY3QnKSB7XG4gICAgICBlbnRyeS5jaGFpbklkID0gY2hhaW5JZDtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE1lcmdlcyB0aGUgdHdvIGdpdmVuLCBub24tZW1wdHkgYXJyYXlzIG9mIHRva2VuIG9iamVjdHMgYW5kIHJldHVybnMgYSBuZXdcbiAqIGFycmF5LlxuICpcbiAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fVxuICovXG5mdW5jdGlvbiBtZXJnZVRva2VuQXJyYXlzKGxvY2FsaG9zdFRva2VucywgcnBjVG9rZW5zKSB7XG4gIGNvbnN0IGxvY2FsaG9zdFRva2Vuc01hcCA9IHRva2VuQXJyYXlUb01hcChsb2NhbGhvc3RUb2tlbnMpO1xuICBjb25zdCBycGNUb2tlbnNNYXAgPSB0b2tlbkFycmF5VG9NYXAocnBjVG9rZW5zKTtcblxuICBjb25zdCBtZXJnZWRUb2tlbnMgPSBbXTtcbiAgbmV3IFNldChbXG4gICAgLi4uT2JqZWN0LmtleXMobG9jYWxob3N0VG9rZW5zTWFwKSxcbiAgICAuLi5PYmplY3Qua2V5cyhycGNUb2tlbnNNYXApLFxuICBdKS5mb3JFYWNoKCh0b2tlbkFkZHJlc3MpID0+IHtcbiAgICBtZXJnZWRUb2tlbnMucHVzaCh7XG4gICAgICAuLi5sb2NhbGhvc3RUb2tlbnNNYXBbdG9rZW5BZGRyZXNzXSxcbiAgICAgIC4uLnJwY1Rva2Vuc01hcFt0b2tlbkFkZHJlc3NdLFxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gbWVyZ2VkVG9rZW5zO1xuXG4gIGZ1bmN0aW9uIHRva2VuQXJyYXlUb01hcChhcnJheSkge1xuICAgIHJldHVybiBhcnJheS5yZWR1Y2UoKG1hcCwgdG9rZW4pID0+IHtcbiAgICAgIGlmICh0b2tlbj8uYWRkcmVzcyAmJiB0eXBlb2YgdG9rZW4/LmFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcFt0b2tlbi5hZGRyZXNzXSA9IHRva2VuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCB7fSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuXG5jb25zdCB2ZXJzaW9uID0gNTM7XG5cbi8qKlxuICogRGVwcmVjYXRlIHRyYW5zYWN0aW9uQ2F0ZWdvcnkgYW5kIGNvbnNvbGlkYXRlIG9uICd0eXBlJ1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBzdGF0ZT8uVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnM7XG4gIGNvbnN0IGluY29taW5nVHJhbnNhY3Rpb25zID1cbiAgICBzdGF0ZT8uSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyPy5pbmNvbWluZ1RyYW5zYWN0aW9ucztcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNhY3Rpb25zKSkge1xuICAgIHRyYW5zYWN0aW9ucy5mb3JFYWNoKCh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgaWYgKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0cmFuc2FjdGlvbi50eXBlICE9PSBUUkFOU0FDVElPTl9UWVBFUy5SRVRSWSAmJlxuICAgICAgICAgIHRyYW5zYWN0aW9uLnR5cGUgIT09IFRSQU5TQUNUSU9OX1RZUEVTLkNBTkNFTFxuICAgICAgICApIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi50eXBlID0gdHJhbnNhY3Rpb24udHJhbnNhY3Rpb25DYXRlZ29yeTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdHJhbnNhY3Rpb24udHJhbnNhY3Rpb25DYXRlZ29yeTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAoaW5jb21pbmdUcmFuc2FjdGlvbnMpIHtcbiAgICBjb25zdCBpbmNvbWluZ1RyYW5zYWN0aW9uc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhpbmNvbWluZ1RyYW5zYWN0aW9ucyk7XG4gICAgaW5jb21pbmdUcmFuc2FjdGlvbnNFbnRyaWVzLmZvckVhY2goKFtrZXksIHRyYW5zYWN0aW9uXSkgPT4ge1xuICAgICAgaWYgKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbkNhdGVnb3J5O1xuICAgICAgICBzdGF0ZS5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIuaW5jb21pbmdUcmFuc2FjdGlvbnNba2V5XSA9IHtcbiAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICB0eXBlOiBUUkFOU0FDVElPTl9UWVBFUy5JTkNPTUlORyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIGtleUJ5IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBjcmVhdGVJZCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9yYW5kb20taWQnO1xuXG5jb25zdCB2ZXJzaW9uID0gNTc7XG5cbi8qKlxuICogcmVwbGFjZSAnaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tzQnlOZXR3b3JrJyB3aXRoICdpbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja0J5Q2hhaW5JZCdcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKFxuICAgIHN0YXRlPy5UcmFuc2FjdGlvbkNvbnRyb2xsZXI/LnRyYW5zYWN0aW9ucyAmJlxuICAgIEFycmF5LmlzQXJyYXkoc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykgJiZcbiAgICAhc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucy5zb21lKFxuICAgICAgKGl0ZW0pID0+XG4gICAgICAgIHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgaXRlbS50eFBhcmFtcyA9PT0gJ3VuZGVmaW5lZCcsXG4gICAgKVxuICApIHtcbiAgICBzdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0ga2V5QnkoXG4gICAgICBzdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zLFxuICAgICAgLy8gSW4gY2FzZSBmb3Igc29tZSByZWFzb24gYW55IG9mIGEgdXNlcidzIHRyYW5zYWN0aW9ucyBkbyBub3QgaGF2ZSBhbiBpZFxuICAgICAgLy8gZ2VuZXJhdGUgYSBuZXcgb25lIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAodHgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eC5pZCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHguaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGlzIG11dGF0ZXMgdGhlIGl0ZW0gaW4gdGhlIGFycmF5LCBzbyB3aWxsIHJlc3VsdCBpbiBhIGNoYW5nZSB0b1xuICAgICAgICAgIC8vIHRoZSBzdGF0ZS5cbiAgICAgICAgICB0eC5pZCA9IGNyZWF0ZUlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR4LmlkO1xuICAgICAgfSxcbiAgICApO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA2MztcblxuLyoqXG4gKiBNb3ZlcyB0b2tlbiBzdGF0ZSBmcm9tIHByZWZlcmVuY2VzIGNvbnRyb2xsZXIgdG8gVG9rZW5zQ29udHJvbGxlclxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IGFjY291bnRUb2tlbnMgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hY2NvdW50VG9rZW5zO1xuICBjb25zdCBhY2NvdW50SGlkZGVuVG9rZW5zID0gc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uYWNjb3VudEhpZGRlblRva2VucztcblxuICBjb25zdCBuZXdBbGxUb2tlbnMgPSB7fTtcbiAgaWYgKGFjY291bnRUb2tlbnMpIHtcbiAgICBPYmplY3Qua2V5cyhhY2NvdW50VG9rZW5zKS5mb3JFYWNoKChhY2NvdW50QWRkcmVzcykgPT4ge1xuICAgICAgT2JqZWN0LmtleXMoYWNjb3VudFRva2Vuc1thY2NvdW50QWRkcmVzc10pLmZvckVhY2goKGNoYWluSWQpID0+IHtcbiAgICAgICAgY29uc3QgdG9rZW5zQXJyYXkgPSBhY2NvdW50VG9rZW5zW2FjY291bnRBZGRyZXNzXVtjaGFpbklkXTtcbiAgICAgICAgaWYgKG5ld0FsbFRva2Vuc1tjaGFpbklkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3QWxsVG9rZW5zW2NoYWluSWRdID0geyBbYWNjb3VudEFkZHJlc3NdOiB0b2tlbnNBcnJheSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0FsbFRva2Vuc1tjaGFpbklkXSA9IHtcbiAgICAgICAgICAgIC4uLm5ld0FsbFRva2Vuc1tjaGFpbklkXSxcbiAgICAgICAgICAgIFthY2NvdW50QWRkcmVzc106IHRva2Vuc0FycmF5LFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgbmV3QWxsSWdub3JlZFRva2VucyA9IHt9O1xuICBpZiAoYWNjb3VudEhpZGRlblRva2Vucykge1xuICAgIE9iamVjdC5rZXlzKGFjY291bnRIaWRkZW5Ub2tlbnMpLmZvckVhY2goKGFjY291bnRBZGRyZXNzKSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhhY2NvdW50SGlkZGVuVG9rZW5zW2FjY291bnRBZGRyZXNzXSkuZm9yRWFjaCgoY2hhaW5JZCkgPT4ge1xuICAgICAgICBjb25zdCBpZ25vcmVkVG9rZW5zQXJyYXkgPSBhY2NvdW50SGlkZGVuVG9rZW5zW2FjY291bnRBZGRyZXNzXVtjaGFpbklkXTtcbiAgICAgICAgaWYgKG5ld0FsbElnbm9yZWRUb2tlbnNbY2hhaW5JZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld0FsbElnbm9yZWRUb2tlbnNbY2hhaW5JZF0gPSB7XG4gICAgICAgICAgICBbYWNjb3VudEFkZHJlc3NdOiBpZ25vcmVkVG9rZW5zQXJyYXksXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdBbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdID0ge1xuICAgICAgICAgICAgLi4ubmV3QWxsSWdub3JlZFRva2Vuc1tjaGFpbklkXSxcbiAgICAgICAgICAgIFthY2NvdW50QWRkcmVzc106IGlnbm9yZWRUb2tlbnNBcnJheSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5Ub2tlbnNDb250cm9sbGVyKSB7XG4gICAgc3RhdGUuVG9rZW5zQ29udHJvbGxlci5hbGxUb2tlbnMgPSBuZXdBbGxUb2tlbnM7XG4gICAgc3RhdGUuVG9rZW5zQ29udHJvbGxlci5hbGxJZ25vcmVkVG9rZW5zID0gbmV3QWxsSWdub3JlZFRva2VucztcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5Ub2tlbnNDb250cm9sbGVyID0ge1xuICAgICAgYWxsVG9rZW5zOiBuZXdBbGxUb2tlbnMsXG4gICAgICBhbGxJZ25vcmVkVG9rZW5zOiBuZXdBbGxJZ25vcmVkVG9rZW5zLFxuICAgIH07XG4gIH1cblxuICBkZWxldGUgc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uYWNjb3VudEhpZGRlblRva2VucztcbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmFjY291bnRUb2tlbnM7XG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hc3NldEltYWdlcztcbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmhpZGRlblRva2VucztcbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LnRva2VucztcbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LnN1Z2dlc3RlZFRva2VucztcblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgVEVTVF9DSEFJTlMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuXG5jb25zdCBoZXhOdW1iZXJJc0dyZWF0ZXJUaGFuWmVybyA9IChoZXhOdW1iZXIpID0+XG4gIG5ldyBCaWdOdW1iZXIoaGV4TnVtYmVyIHx8ICcweDAnLCAxNikuZ3QoMCk7XG5cbmNvbnN0IHZlcnNpb24gPSA2NztcblxuLyoqXG4gKiBTZXRzIHRoZSBzaG93VGVzdE5ldHdvcmtzIHByb3BlcnR5IHRvIHRydWUgaWYgaXQgd2FzIGZhbHNlIG9yIHVuZGVmaW5lZCwgYW5kIHRoZXJlIGlzIGV2aWRlbmNlXG4gKiB0aGF0IHRoZSB1c2VyIGhhcyB1c2VkIGEgdGVzdCBuZXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyIHx8IHt9O1xuICBjb25zdCBwcmVmZXJlbmNlcyA9IFByZWZlcmVuY2VzQ29udHJvbGxlci5wcmVmZXJlbmNlcyB8fCB7fTtcblxuICBpZiAocHJlZmVyZW5jZXMuc2hvd1Rlc3ROZXR3b3Jrcykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHRyYW5zYWN0aW9ucyA9IHN0YXRlPy5UcmFuc2FjdGlvbkNvbnRyb2xsZXI/LnRyYW5zYWN0aW9ucyB8fCB7fTtcbiAgY29uc3QgcHJvdmlkZXIgPSBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXIgfHwge307XG4gIGNvbnN0IGNhY2hlZEJhbGFuY2VzID0gc3RhdGUuQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyPy5jYWNoZWRCYWxhbmNlcyB8fCB7fTtcblxuICBjb25zdCB1c2VySXNDdXJyZW50bHlPbkFUZXN0TmV0ID0gVEVTVF9DSEFJTlMuaW5jbHVkZXMocHJvdmlkZXI/LmNoYWluSWQpO1xuICBjb25zdCB1c2VySGFzTWFkZUFUZXN0TmV0VHJhbnNhY3Rpb24gPSBPYmplY3QudmFsdWVzKFxuICAgIHRyYW5zYWN0aW9ucyxcbiAgKS5zb21lKCh7IGNoYWluSWQgfSkgPT4gVEVTVF9DSEFJTlMuaW5jbHVkZXMoY2hhaW5JZCkpO1xuICBjb25zdCB1c2VySGFzQUNhY2hlZEJhbGFuY2VPbkFUZXN0bmV0ID0gVEVTVF9DSEFJTlMuc29tZSgoY2hhaW5JZCkgPT4ge1xuICAgIGNvbnN0IGNhY2hlZEJhbGFuY2VzRm9yQ2hhaW4gPSBPYmplY3QudmFsdWVzKGNhY2hlZEJhbGFuY2VzW2NoYWluSWRdIHx8IHt9KTtcbiAgICBjb25zdCB1c2VySGFzQUJhbGFuY2VHcmVhdGVyVGhhblplcm9PblRoaXNDaGFpbiA9IGNhY2hlZEJhbGFuY2VzRm9yQ2hhaW4uc29tZShcbiAgICAgIGhleE51bWJlcklzR3JlYXRlclRoYW5aZXJvLFxuICAgICk7XG4gICAgcmV0dXJuIHVzZXJIYXNBQmFsYW5jZUdyZWF0ZXJUaGFuWmVyb09uVGhpc0NoYWluO1xuICB9KTtcbiAgY29uc3QgdXNlckhhc1VzZWRBVGVzdG5ldCA9XG4gICAgdXNlcklzQ3VycmVudGx5T25BVGVzdE5ldCB8fFxuICAgIHVzZXJIYXNNYWRlQVRlc3ROZXRUcmFuc2FjdGlvbiB8fFxuICAgIHVzZXJIYXNBQ2FjaGVkQmFsYW5jZU9uQVRlc3RuZXQ7XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XG4gICAgICAuLi5QcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICBwcmVmZXJlbmNlczoge1xuICAgICAgICAuLi5wcmVmZXJlbmNlcyxcbiAgICAgICAgc2hvd1Rlc3ROZXR3b3JrczogdXNlckhhc1VzZWRBVGVzdG5ldCxcbiAgICAgIH0sXG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgTEVER0VSX1RSQU5TUE9SVF9UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvaGFyZHdhcmUtd2FsbGV0cyc7XG5cbmNvbnN0IHZlcnNpb24gPSA2NjtcblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSB1c2VMZWRnZXJMaXZlIGJvb2xlYW4gcHJvcGVydHkgdG8gdGhlIGxlZGdlclRyYW5zcG9ydFR5cGUgZW51bVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IGRlZmF1bHRUcmFuc3BvcnRUeXBlID0gd2luZG93Lm5hdmlnYXRvci5oaWRcbiAgICA/IExFREdFUl9UUkFOU1BPUlRfVFlQRVMuV0VCSElEXG4gICAgOiBMRURHRVJfVFJBTlNQT1JUX1RZUEVTLlUyRjtcbiAgY29uc3QgdXNlTGVkZ2VyTGl2ZSA9IEJvb2xlYW4oc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyPy51c2VMZWRnZXJMaXZlKTtcbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XG4gICAgICAuLi5zdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgbGVkZ2VyVHJhbnNwb3J0VHlwZTogdXNlTGVkZ2VyTGl2ZVxuICAgICAgICA/IExFREdFUl9UUkFOU1BPUlRfVFlQRVMuTElWRVxuICAgICAgICA6IGRlZmF1bHRUcmFuc3BvcnRUeXBlLFxuICAgIH0sXG4gIH07XG4gIGRlbGV0ZSBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudXNlTGVkZ2VyTGl2ZTtcbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDY4O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIFBlcm1pc3Npb25zQ29udHJvbGxlciBhbmQgUGVybWlzc2lvbnNNZXRhZGF0YSBzdWJzdGF0ZXNcbiAqIHRvIG1hdGNoIHRoZSBuZXcgcGVybWlzc2lvbiBzeXN0ZW0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3Qge1xuICAgIFBlcm1pc3Npb25zQ29udHJvbGxlciA9IHt9LFxuICAgIFBlcm1pc3Npb25zTWV0YWRhdGEgPSB7fSxcbiAgICAuLi5yZW1haW5pbmdTdGF0ZVxuICB9ID0gc3RhdGU7XG5cbiAgY29uc3Qge1xuICAgIGRvbWFpbk1ldGFkYXRhID0ge30sXG4gICAgcGVybWlzc2lvbnNIaXN0b3J5ID0ge30sXG4gICAgcGVybWlzc2lvbnNMb2cgPSBbXSxcbiAgfSA9IFBlcm1pc3Npb25zTWV0YWRhdGE7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5yZW1haW5pbmdTdGF0ZSxcbiAgICBQZXJtaXNzaW9uQ29udHJvbGxlcjogZ2V0UGVybWlzc2lvbkNvbnRyb2xsZXJTdGF0ZShQZXJtaXNzaW9uc0NvbnRyb2xsZXIpLFxuICAgIFBlcm1pc3Npb25Mb2dDb250cm9sbGVyOiB7XG4gICAgICBwZXJtaXNzaW9uQWN0aXZpdHlMb2c6IHBlcm1pc3Npb25zTG9nLFxuICAgICAgcGVybWlzc2lvbkhpc3Rvcnk6IHBlcm1pc3Npb25zSGlzdG9yeSxcbiAgICB9LFxuICAgIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXI6IGdldFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXJTdGF0ZShcbiAgICAgIGRvbWFpbk1ldGFkYXRhLFxuICAgICksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFBlcm1pc3Npb25Db250cm9sbGVyU3RhdGUoUGVybWlzc2lvbnNDb250cm9sbGVyKSB7XG4gIGNvbnN0IHsgZG9tYWlucyA9IHt9IH0gPSBQZXJtaXNzaW9uc0NvbnRyb2xsZXI7XG5cbiAgLyoqXG4gICAqIEV4YW1wbGUgZXhpc3RpbmcgZG9tYWluIGVudHJ5LiBFdmVyeSBleGlzdGluZyBkb21haW4gd2lsbCBoYXZlIGEgc2luZ2xlXG4gICAqIGV0aF9hY2NvdW50cyBwZXJtaXNzaW9uLCB3aGljaCBzaW1wbGlmaWVzIHRoZSB0cmFuc2Zvcm0uXG4gICAqXG4gICAqICdodHRwczovL21ldGFtYXNrLmdpdGh1Yi5pbyc6IHtcbiAgICogICBwZXJtaXNzaW9uczogW1xuICAgKiAgICAge1xuICAgKiAgICAgICAnQGNvbnRleHQnOiBbJ2h0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9ycGMtY2FwJ10sXG4gICAqICAgICAgICdjYXZlYXRzJzogW1xuICAgKiAgICAgICAgIHtcbiAgICogICAgICAgICAgIG5hbWU6ICdwcmltYXJ5QWNjb3VudE9ubHknLFxuICAgKiAgICAgICAgICAgdHlwZTogJ2xpbWl0UmVzcG9uc2VMZW5ndGgnLFxuICAgKiAgICAgICAgICAgdmFsdWU6IDEsXG4gICAqICAgICAgICAgfSxcbiAgICogICAgICAgICB7XG4gICAqICAgICAgICAgICBuYW1lOiAnZXhwb3NlZEFjY291bnRzJyxcbiAgICogICAgICAgICAgIHR5cGU6ICdmaWx0ZXJSZXNwb25zZScsXG4gICAqICAgICAgICAgICB2YWx1ZTogWycweDBjOTdhNWM4MWU1MGEwMmZmOGJlNzNjYzNmMGEwNTY5ZTYxZjRlZDgnXSxcbiAgICogICAgICAgICB9LFxuICAgKiAgICAgICBdLFxuICAgKiAgICAgICAnZGF0ZSc6IDE2MTYwMDYzNjk0OTgsXG4gICAqICAgICAgICdpZCc6ICczZDBiZGMyNy1lOGU0LTRmYjAtYTI0Yi0zNDBkNjFmNmEzZmEnLFxuICAgKiAgICAgICAnaW52b2tlcic6ICdodHRwczovL21ldGFtYXNrLmdpdGh1Yi5pbycsXG4gICAqICAgICAgICdwYXJlbnRDYXBhYmlsaXR5JzogJ2V0aF9hY2NvdW50cycsXG4gICAqICAgICB9LFxuICAgKiAgIF0sXG4gICAqIH0sXG4gICAqL1xuXG4gIGNvbnN0IEVUSF9BQ0NPVU5UUyA9ICdldGhfYWNjb3VudHMnO1xuICBjb25zdCBORVdfQ0FWRUFUX1RZUEUgPSAncmVzdHJpY3RSZXR1cm5lZEFjY291bnRzJztcbiAgY29uc3QgT0xEX0NBVkVBVF9OQU1FID0gJ2V4cG9zZWRBY2NvdW50cyc7XG5cbiAgY29uc3Qgc3ViamVjdHMgPSBPYmplY3QuZW50cmllcyhkb21haW5zKS5yZWR1Y2UoXG4gICAgKHRyYW5zZm9ybWVkLCBbb3JpZ2luLCBkb21haW5FbnRyeV0pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGVybWlzc2lvbnM6IFtldGhBY2NvdW50c1Blcm1pc3Npb25dLFxuICAgICAgfSA9IGRvbWFpbkVudHJ5O1xuXG4gICAgICAvLyBUaGVyZSBhcmUgdHdvIGNhdmVhdHMgZm9yIGVhY2ggZXRoX2FjY291bnRzIHBlcm1pc3Npb24sIGJ1dCB3ZSBvbmx5XG4gICAgICAvLyBuZWVkIHRoZSB2YWx1ZSBvZiBvbmUgb2YgdGhlbSBpbiB0aGUgbmV3IHBlcm1pc3Npb24gc3lzdGVtLlxuICAgICAgY29uc3Qgb2xkQ2F2ZWF0ID0gZXRoQWNjb3VudHNQZXJtaXNzaW9uLmNhdmVhdHMuZmluZChcbiAgICAgICAgKGNhdmVhdCkgPT4gY2F2ZWF0Lm5hbWUgPT09IE9MRF9DQVZFQVRfTkFNRSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG5ld1Blcm1pc3Npb24gPSB7XG4gICAgICAgIC4uLmV0aEFjY291bnRzUGVybWlzc2lvbixcbiAgICAgICAgY2F2ZWF0czogW3sgdHlwZTogTkVXX0NBVkVBVF9UWVBFLCB2YWx1ZTogb2xkQ2F2ZWF0LnZhbHVlIH1dLFxuICAgICAgfTtcblxuICAgICAgLy8gV2UgbmV2ZXIgdXNlZCB0aGlzLCBhbmQganVzdCBvbWl0IGl0IGluIHRoZSBuZXcgc3lzdGVtLlxuICAgICAgZGVsZXRlIG5ld1Blcm1pc3Npb25bJ0Bjb250ZXh0J107XG5cbiAgICAgIHRyYW5zZm9ybWVkW29yaWdpbl0gPSB7XG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgcGVybWlzc2lvbnM6IHtcbiAgICAgICAgICBbRVRIX0FDQ09VTlRTXTogbmV3UGVybWlzc2lvbixcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgfSxcbiAgICB7fSxcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHN1YmplY3RzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyU3RhdGUoZG9tYWluTWV0YWRhdGEpIHtcbiAgLyoqXG4gICAqIEV4YW1wbGUgZXhpc3RpbmcgZG9tYWluTWV0YWRhdGEgZW50cnkuXG4gICAqXG4gICAqIFwiaHR0cHM6Ly93d3cueW91dHViZS5jb21cIjoge1xuICAgKiAgIFwiaG9zdFwiOiBcInd3dy55b3V0dWJlLmNvbVwiLFxuICAgKiAgIFwiaWNvblwiOiBudWxsLFxuICAgKiAgIFwibGFzdFVwZGF0ZWRcIjogMTYzNzY5NzkxNDkwOCxcbiAgICogICBcIm5hbWVcIjogXCJZb3VUdWJlXCJcbiAgICogfVxuICAgKi9cblxuICBjb25zdCBzdWJqZWN0TWV0YWRhdGEgPSBPYmplY3QuZW50cmllcyhkb21haW5NZXRhZGF0YSkucmVkdWNlKFxuICAgICh0cmFuc2Zvcm1lZCwgW29yaWdpbiwgbWV0YWRhdGFdKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUgPSBudWxsLFxuICAgICAgICBpY29uID0gbnVsbCxcbiAgICAgICAgZXh0ZW5zaW9uSWQgPSBudWxsLFxuICAgICAgICAuLi5vdGhlclxuICAgICAgfSA9IG1ldGFkYXRhO1xuXG4gICAgICAvLyBXZSdyZSBnZXR0aW5nIHJpZCBvZiB0aGVzZS5cbiAgICAgIGRlbGV0ZSBvdGhlci5sYXN0VXBkYXRlZDtcbiAgICAgIGRlbGV0ZSBvdGhlci5ob3N0O1xuXG4gICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgIHRyYW5zZm9ybWVkW29yaWdpbl0gPSB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBpY29uVXJsOiBpY29uLFxuICAgICAgICAgIGV4dGVuc2lvbklkLFxuICAgICAgICAgIC4uLm90aGVyLFxuICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgICB9LFxuICAgIHt9LFxuICApO1xuXG4gIHJldHVybiB7XG4gICAgc3ViamVjdE1ldGFkYXRhLFxuICB9O1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gdXBkYXRlcyBcInRyYW5zYWN0aW9uIHN0YXRlIGhpc3RvcnlcIiB0byBkaWZmcyBzdHlsZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHtcbiAgc25hcHNob3RGcm9tVHhNZXRhLFxuICBtaWdyYXRlRnJvbVNuYXBzaG90c1RvRGlmZnMsXG59IGZyb20gJy4uL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucy9saWIvdHgtc3RhdGUtaGlzdG9yeS1oZWxwZXJzJztcblxuY29uc3QgdmVyc2lvbiA9IDE4O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcbiAgICAgIC8vIG5vIGhpc3Rvcnk6IGluaXRpYWxpemVcbiAgICAgIGlmICghdHhNZXRhLmhpc3RvcnkgfHwgdHhNZXRhLmhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gc25hcHNob3RGcm9tVHhNZXRhKHR4TWV0YSk7XG4gICAgICAgIHR4TWV0YS5oaXN0b3J5ID0gW3NuYXBzaG90XTtcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICAgIH1cbiAgICAgIC8vIGhhcyBoaXN0b3J5OiBtaWdyYXRlXG4gICAgICBjb25zdCBuZXdIaXN0b3J5ID0gbWlncmF0ZUZyb21TbmFwc2hvdHNUb0RpZmZzKHR4TWV0YS5oaXN0b3J5KVxuICAgICAgICAvLyByZW1vdmUgZW1wdHkgZGlmZnNcbiAgICAgICAgLmZpbHRlcigoZW50cnkpID0+IHtcbiAgICAgICAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkoZW50cnkpIHx8IGVudHJ5Lmxlbmd0aCA+IDA7XG4gICAgICAgIH0pO1xuICAgICAgdHhNZXRhLmhpc3RvcnkgPSBuZXdIaXN0b3J5O1xuICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCJ2YXIgdG9EYXRhVmlldyA9IHJlcXVpcmUoJ3RvLWRhdGEtdmlldycpXG5cbnZhciBSRkM0NjQ4ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3J1xudmFyIFJGQzQ2NDhfSEVYID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJ1xudmFyIENST0NLRk9SRCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWidcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYXNlMzJFbmNvZGUgKGRhdGEsIHZhcmlhbnQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGFscGhhYmV0LCBkZWZhdWx0UGFkZGluZ1xuXG4gIHN3aXRjaCAodmFyaWFudCkge1xuICAgIGNhc2UgJ1JGQzM1NDgnOlxuICAgIGNhc2UgJ1JGQzQ2NDgnOlxuICAgICAgYWxwaGFiZXQgPSBSRkM0NjQ4XG4gICAgICBkZWZhdWx0UGFkZGluZyA9IHRydWVcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnUkZDNDY0OC1IRVgnOlxuICAgICAgYWxwaGFiZXQgPSBSRkM0NjQ4X0hFWFxuICAgICAgZGVmYXVsdFBhZGRpbmcgPSB0cnVlXG4gICAgICBicmVha1xuICAgIGNhc2UgJ0Nyb2NrZm9yZCc6XG4gICAgICBhbHBoYWJldCA9IENST0NLRk9SRFxuICAgICAgZGVmYXVsdFBhZGRpbmcgPSBmYWxzZVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGJhc2UzMiB2YXJpYW50OiAnICsgdmFyaWFudClcbiAgfVxuXG4gIHZhciBwYWRkaW5nID0gKG9wdGlvbnMucGFkZGluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5wYWRkaW5nIDogZGVmYXVsdFBhZGRpbmcpXG4gIHZhciB2aWV3ID0gdG9EYXRhVmlldyhkYXRhKVxuXG4gIHZhciBiaXRzID0gMFxuICB2YXIgdmFsdWUgPSAwXG4gIHZhciBvdXRwdXQgPSAnJ1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA8PCA4KSB8IHZpZXcuZ2V0VWludDgoaSlcbiAgICBiaXRzICs9IDhcblxuICAgIHdoaWxlIChiaXRzID49IDUpIHtcbiAgICAgIG91dHB1dCArPSBhbHBoYWJldFsodmFsdWUgPj4+IChiaXRzIC0gNSkpICYgMzFdXG4gICAgICBiaXRzIC09IDVcbiAgICB9XG4gIH1cblxuICBpZiAoYml0cyA+IDApIHtcbiAgICBvdXRwdXQgKz0gYWxwaGFiZXRbKHZhbHVlIDw8ICg1IC0gYml0cykpICYgMzFdXG4gIH1cblxuICBpZiAocGFkZGluZykge1xuICAgIHdoaWxlICgob3V0cHV0Lmxlbmd0aCAlIDgpICE9PSAwKSB7XG4gICAgICBvdXRwdXQgKz0gJz0nXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuIiwiaW1wb3J0IG5hbWVoYXNoIGZyb20gJ2V0aC1lbnMtbmFtZWhhc2gnO1xuaW1wb3J0IEV0aCBmcm9tICdldGhqcy1xdWVyeSc7XG5pbXBvcnQgRXRoQ29udHJhY3QgZnJvbSAnZXRoanMtY29udHJhY3QnO1xuaW1wb3J0IGNvbnRlbnRIYXNoIGZyb20gJ0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaCc7XG5pbXBvcnQgcmVnaXN0cnlBYmkgZnJvbSAnLi9jb250cmFjdHMvcmVnaXN0cnknO1xuaW1wb3J0IHJlc29sdmVyQWJpIGZyb20gJy4vY29udHJhY3RzL3Jlc29sdmVyJztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUVuc1RvSXBmc0NvbnRlbnRJZCh7IHByb3ZpZGVyLCBuYW1lIH0pIHtcbiAgY29uc3QgZXRoID0gbmV3IEV0aChwcm92aWRlcik7XG4gIGNvbnN0IGhhc2ggPSBuYW1laGFzaC5oYXNoKG5hbWUpO1xuICBjb25zdCBjb250cmFjdCA9IG5ldyBFdGhDb250cmFjdChldGgpO1xuICAvLyBsb29rdXAgcmVnaXN0cnlcbiAgY29uc3QgY2hhaW5JZCA9IE51bWJlci5wYXJzZUludChhd2FpdCBldGgubmV0X3ZlcnNpb24oKSwgMTApO1xuICBjb25zdCByZWdpc3RyeUFkZHJlc3MgPSBnZXRSZWdpc3RyeUZvckNoYWluSWQoY2hhaW5JZCk7XG4gIGlmICghcmVnaXN0cnlBZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEVuc0lwZnNSZXNvbHZlciAtIG5vIGtub3duIGVucy1pcGZzIHJlZ2lzdHJ5IGZvciBjaGFpbklkIFwiJHtjaGFpbklkfVwiYCxcbiAgICApO1xuICB9XG4gIGNvbnN0IFJlZ2lzdHJ5ID0gY29udHJhY3QocmVnaXN0cnlBYmkpLmF0KHJlZ2lzdHJ5QWRkcmVzcyk7XG4gIC8vIGxvb2t1cCByZXNvbHZlclxuICBjb25zdCByZXNvbHZlckxvb2t1cFJlc3VsdCA9IGF3YWl0IFJlZ2lzdHJ5LnJlc29sdmVyKGhhc2gpO1xuICBjb25zdCByZXNvbHZlckFkZHJlc3MgPSByZXNvbHZlckxvb2t1cFJlc3VsdFswXTtcbiAgaWYgKGhleFZhbHVlSXNFbXB0eShyZXNvbHZlckFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFbnNJcGZzUmVzb2x2ZXIgLSBubyByZXNvbHZlciBmb3VuZCBmb3IgbmFtZSBcIiR7bmFtZX1cImApO1xuICB9XG4gIGNvbnN0IFJlc29sdmVyID0gY29udHJhY3QocmVzb2x2ZXJBYmkpLmF0KHJlc29sdmVyQWRkcmVzcyk7XG5cbiAgY29uc3QgaXNFSVAxNTc3Q29tcGxpYW50ID0gYXdhaXQgUmVzb2x2ZXIuc3VwcG9ydHNJbnRlcmZhY2UoJzB4YmMxYzU4ZDEnKTtcbiAgY29uc3QgaXNMZWdhY3lSZXNvbHZlciA9IGF3YWl0IFJlc29sdmVyLnN1cHBvcnRzSW50ZXJmYWNlKCcweGQ4Mzg5ZGM1Jyk7XG4gIGlmIChpc0VJUDE1NzdDb21wbGlhbnRbMF0pIHtcbiAgICBjb25zdCBjb250ZW50TG9va3VwUmVzdWx0ID0gYXdhaXQgUmVzb2x2ZXIuY29udGVudGhhc2goaGFzaCk7XG4gICAgY29uc3QgcmF3Q29udGVudEhhc2ggPSBjb250ZW50TG9va3VwUmVzdWx0WzBdO1xuICAgIGxldCBkZWNvZGVkQ29udGVudEhhc2ggPSBjb250ZW50SGFzaC5kZWNvZGUocmF3Q29udGVudEhhc2gpO1xuICAgIGNvbnN0IHR5cGUgPSBjb250ZW50SGFzaC5nZXRDb2RlYyhyYXdDb250ZW50SGFzaCk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2lwZnMtbnMnIHx8IHR5cGUgPT09ICdpcG5zLW5zJykge1xuICAgICAgZGVjb2RlZENvbnRlbnRIYXNoID0gY29udGVudEhhc2guaGVscGVycy5jaWRWMFRvVjFCYXNlMzIoXG4gICAgICAgIGRlY29kZWRDb250ZW50SGFzaCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHlwZSwgaGFzaDogZGVjb2RlZENvbnRlbnRIYXNoIH07XG4gIH1cbiAgaWYgKGlzTGVnYWN5UmVzb2x2ZXJbMF0pIHtcbiAgICAvLyBsb29rdXAgY29udGVudCBpZFxuICAgIGNvbnN0IGNvbnRlbnRMb29rdXBSZXN1bHQgPSBhd2FpdCBSZXNvbHZlci5jb250ZW50KGhhc2gpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBjb250ZW50TG9va3VwUmVzdWx0WzBdO1xuICAgIGlmIChoZXhWYWx1ZUlzRW1wdHkoY29udGVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEVuc0lwZnNSZXNvbHZlciAtIG5vIGNvbnRlbnQgSUQgZm91bmQgZm9yIG5hbWUgXCIke25hbWV9XCJgLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ3N3YXJtLW5zJywgaGFzaDogY29udGVudC5zbGljZSgyKSB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgRW5zSXBmc1Jlc29sdmVyIC0gdGhlIHJlc29sdmVyIGZvciBuYW1lIFwiJHtuYW1lfVwiIGlzIG5vdCBzdGFuZGFyZCwgaXQgc2hvdWxkIGVpdGhlciBzdXBwb3J0cyBjb250ZW50aGFzaCgpIG9yIGNvbnRlbnQoKWAsXG4gICk7XG59XG5cbmZ1bmN0aW9uIGhleFZhbHVlSXNFbXB0eSh2YWx1ZSkge1xuICByZXR1cm4gW1xuICAgIHVuZGVmaW5lZCxcbiAgICBudWxsLFxuICAgICcweCcsXG4gICAgJzB4MCcsXG4gICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gIF0uaW5jbHVkZXModmFsdWUpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlZ2lzdHJ5IGFkZHJlc3MgZm9yIHRoZSBnaXZlbiBjaGFpbiBJRFxuICogQHBhcmFtIHtudW1iZXJ9IGNoYWluSWQgLSB0aGUgY2hhaW4gSURcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gdGhlIHJlZ2lzdHJ5IGFkZHJlc3MgaWYga25vd24sIG51bGwgb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGdldFJlZ2lzdHJ5Rm9yQ2hhaW5JZChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgMTpcbiAgICBjYXNlIDM6XG4gICAgY2FzZSA0OlxuICAgIGNhc2UgNTpcbiAgICAgIC8vIE1haW5uZXQsIFJvcHN0ZW4sIFJpbmtlYnksIGFuZCBHb2VybGksIHJlc3BlY3RpdmVseSwgdXNlIHRoZSBzYW1lIGFkZHJlc3NcbiAgICAgIHJldHVybiAnMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbiIsIi8qKlxuICogUmV0dXJucyBhIG1pZGRsZXdhcmUgdGhhdCBhcHBlbmRzIHRoZSBEQXBwIG9yaWdpbiB0byByZXF1ZXN0XG4gKiBAcGFyYW0ge3sgb3JpZ2luOiBzdHJpbmcgfX0gb3B0cyAtIFRoZSBtaWRkbGV3YXJlIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlT3JpZ2luTWlkZGxld2FyZShvcHRzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvcmlnaW5NaWRkbGV3YXJlKFxuICAgIC8qKiBAdHlwZSB7YW55fSAqLyByZXEsXG4gICAgLyoqIEB0eXBlIHthbnl9ICovIF8sXG4gICAgLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi8gbmV4dCxcbiAgKSB7XG4gICAgcmVxLm9yaWdpbiA9IG9wdHMub3JpZ2luO1xuICAgIG5leHQoKTtcbiAgfTtcbn1cbiIsIi8qKlxuICogUmV0dXJucyBhIG1pZGRsZXdhcmUgdGhhdCBhcHBlbmRzIHRoZSBEQXBwIFRhYklkIHRvIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0ge3sgdGFiSWQ6IG51bWJlciB9fSBvcHRzIC0gVGhlIG1pZGRsZXdhcmUgb3B0aW9uc1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVUYWJJZE1pZGRsZXdhcmUob3B0cykge1xuICByZXR1cm4gZnVuY3Rpb24gdGFiSWRNaWRkbGV3YXJlKFxuICAgIC8qKiBAdHlwZSB7YW55fSAqLyByZXEsXG4gICAgLyoqIEB0eXBlIHthbnl9ICovIF8sXG4gICAgLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi8gbmV4dCxcbiAgKSB7XG4gICAgcmVxLnRhYklkID0gb3B0cy50YWJJZDtcbiAgICBuZXh0KCk7XG4gIH07XG59XG4iLCIvLyBUaGlzIGZpbGUgcmVwbGFjZXMgYGluZGV4LmpzYCBpbiBidW5kbGVycyBsaWtlIHdlYnBhY2sgb3IgUm9sbHVwLFxuLy8gYWNjb3JkaW5nIHRvIGBicm93c2VyYCBjb25maWcgaW4gYHBhY2thZ2UuanNvbmAuXG5cbmlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBBbGwgYnVuZGxlcnMgd2lsbCByZW1vdmUgdGhpcyBibG9jayBpbiBwcm9kdWN0aW9uIGJ1bmRsZVxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnUmVhY3QgTmF0aXZlIGRvZXMgbm90IGhhdmUgYSBidWlsdC1pbiBzZWN1cmUgcmFuZG9tIGdlbmVyYXRvci4gJyArXG4gICAgICAnSWYgeW91IGRvbuKAmXQgbmVlZCB1bnByZWRpY3RhYmxlIElEcywgeW91IGNhbiB1c2UgYG5hbm9pZC9ub24tc2VjdXJlYC4gJyArXG4gICAgICAnRm9yIHNlY3VyZSBJRCBpbnN0YWxsIGBleHBvLXJhbmRvbWAgbG9jYWxseSBhbmQgdXNlIGBuYW5vaWQvYXN5bmNgLidcbiAgICApXG4gIH1cbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyB8fCAoIXNlbGYuY3J5cHRvICYmICFzZWxmLm1zQ3J5cHRvKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdZb3VyIGJyb3dzZXIgZG9lcyBub3QgaGF2ZSBzZWN1cmUgcmFuZG9tIGdlbmVyYXRvci4gJyArXG4gICAgICAnSWYgeW91IGRvbuKAmXQgbmVlZCB1bnByZWRpY3RhYmxlIElEcywgeW91IGNhbiB1c2UgbmFub2lkL25vbi1zZWN1cmUuJ1xuICAgIClcbiAgfVxufVxuXG52YXIgY3J5cHRvID0gc2VsZi5jcnlwdG8gfHwgc2VsZi5tc0NyeXB0b1xuXG4vLyBUaGlzIGFscGhhYmV0IHVzZXMgYS16IEEtWiAwLTkgXy0gc3ltYm9scy5cbi8vIFN5bWJvbHMgYXJlIGdlbmVyYXRlZCBmb3Igc21hbGxlciBzaXplLlxuLy8gLV96eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYTk4NzY1NDMyMTBaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQVxudmFyIHVybCA9ICctXydcbi8vIExvb3AgZnJvbSAzNiB0byAwIChmcm9tIHogdG8gYSBhbmQgOSB0byAwIGluIEJhc2UzNikuXG52YXIgaSA9IDM2XG53aGlsZSAoaS0tKSB7XG4gIC8vIDM2IGlzIHJhZGl4LiBOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nKDM2KSByZXR1cm5zIG51bWJlclxuICAvLyBpbiBCYXNlMzYgcmVwcmVzZW50YXRpb24uIEJhc2UzNiBpcyBsaWtlIGhleCwgYnV0IGl0IHVzZXMgMOKAkzkgYW5kIGEtei5cbiAgdXJsICs9IGkudG9TdHJpbmcoMzYpXG59XG4vLyBMb29wIGZyb20gMzYgdG8gMTAgKGZyb20gWiB0byBBIGluIEJhc2UzNikuXG5pID0gMzZcbndoaWxlIChpLS0gLSAxMCkge1xuICB1cmwgKz0gaS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHZhciBpZCA9ICcnXG4gIHZhciBieXRlcyA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSB8fCAyMSkpXG4gIGkgPSBzaXplIHx8IDIxXG5cbiAgLy8gQ29tcGFjdCBhbHRlcm5hdGl2ZSBmb3IgYGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKWBcbiAgd2hpbGUgKGktLSkge1xuICAgIC8vIFdlIGNhbuKAmXQgdXNlIGJ5dGVzIGJpZ2dlciB0aGFuIHRoZSBhbHBoYWJldC4gNjMgaXMgMDAxMTExMTEgYml0bWFzay5cbiAgICAvLyBUaGlzIG1hc2sgcmVkdWNlcyByYW5kb20gYnl0ZSAwLTI1NSB0byAwLTYzIHZhbHVlcy5cbiAgICAvLyBUaGVyZSBpcyBubyBuZWVkIGluIGB8fCAnJ2AgYW5kIGAqIDEuNmAgaGFja3MgaW4gaGVyZSxcbiAgICAvLyBiZWNhdXNlIGJpdG1hc2sgdHJpbSBieXRlcyBleGFjdCB0byBhbHBoYWJldCBzaXplLlxuICAgIGlkICs9IHVybFtieXRlc1tpXSAmIDYzXVxuICB9XG4gIHJldHVybiBpZFxufVxuIiwiaW1wb3J0IHsgZXRoRXJyb3JzLCBzZXJpYWxpemVFcnJvciB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcblxuY29uc3QgY3JlYXRlTWV0YVJQQ0hhbmRsZXIgPSAoYXBpLCBvdXRTdHJlYW0pID0+IHtcbiAgcmV0dXJuIGFzeW5jIChkYXRhKSA9PiB7XG4gICAgaWYgKG91dFN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWFwaVtkYXRhLm1ldGhvZF0pIHtcbiAgICAgIG91dFN0cmVhbS53cml0ZSh7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBlcnJvcjogZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RGb3VuZCh7XG4gICAgICAgICAgbWVzc2FnZTogYCR7ZGF0YS5tZXRob2R9IG5vdCBmb3VuZGAsXG4gICAgICAgIH0pLFxuICAgICAgICBpZDogZGF0YS5pZCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGVycm9yO1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBhcGlbZGF0YS5tZXRob2RdKC4uLmRhdGEucGFyYW1zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9yID0gZXJyO1xuICAgIH1cblxuICAgIGlmIChvdXRTdHJlYW0uX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIG91dFN0cmVhbS53cml0ZSh7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBlcnJvcjogc2VyaWFsaXplRXJyb3IoZXJyb3IsIHsgc2hvdWxkSW5jbHVkZVN0YWNrOiB0cnVlIH0pLFxuICAgICAgICBpZDogZGF0YS5pZCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRTdHJlYW0ud3JpdGUoe1xuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBpZDogZGF0YS5pZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZU1ldGFSUENIYW5kbGVyO1xuIiwiY29uc3QgRHVwbGV4U3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuRHVwbGV4XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRW5naW5lU3RyZWFtXG5cbmZ1bmN0aW9uIGNyZWF0ZUVuZ2luZVN0cmVhbSh7IGVuZ2luZSB9KSB7XG4gIGlmICghZW5naW5lKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZW5naW5lIHBhcmFtZXRlciEnKVxuICBjb25zdCBzdHJlYW0gPSBuZXcgRHVwbGV4U3RyZWFtKHsgb2JqZWN0TW9kZTogdHJ1ZSwgcmVhZCwgd3JpdGUgfSlcbiAgLy8gZm9yd2FyZCBub3RpZmljYXRpb25zXG4gIGlmIChlbmdpbmUub24pIHtcbiAgICBlbmdpbmUub24oJ25vdGlmaWNhdGlvbicsIChtZXNzYWdlKSA9PiB7XG4gICAgICBzdHJlYW0ucHVzaChtZXNzYWdlKVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIHN0cmVhbVxuXG4gIGZ1bmN0aW9uIHJlYWQgKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGZ1bmN0aW9uIHdyaXRlIChyZXEsIGVuY29kaW5nLCBjYikge1xuICAgIGVuZ2luZS5oYW5kbGUocmVxLCAoZXJyLCByZXMpID0+IHtcbiAgICAgIHRoaXMucHVzaChyZXMpXG4gICAgfSlcbiAgICBjYigpXG4gIH1cbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IHsgZ2V0UGVyc2lzdGVudFN0YXRlIH0gZnJvbSAnQG1ldGFtYXNrL2NvbnRyb2xsZXJzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdAbWV0YW1hc2svY29udHJvbGxlcnMnKS5Db250cm9sbGVyTWVzc2VuZ2VyfSBDb250cm9sbGVyTWVzc2VuZ2VyXG4gKi9cblxuLyoqXG4gKiBBbiBPYnNlcnZhYmxlU3RvcmUgdGhhdCBjYW4gY29tcG9zZXMgYSBmbGF0XG4gKiBzdHJ1Y3R1cmUgb2YgY2hpbGQgc3RvcmVzIGJhc2VkIG9uIGNvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9zYWJsZU9ic2VydmFibGVTdG9yZSBleHRlbmRzIE9ic2VydmFibGVTdG9yZSB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgd2hpY2ggc3RvcmVzIGFyZSBiZWluZyBjb21wb3NlZC4gVGhlIGtleSBpcyB0aGUgbmFtZSBvZiB0aGVcbiAgICogc3RvcmUsIGFuZCB0aGUgdmFsdWUgaXMgZWl0aGVyIGFuIE9ic2VyYWJsZVN0b3JlLCBvciBhIGNvbnRyb2xsZXIgdGhhdFxuICAgKiBleHRlbmRzIG9uZSBvZiB0aGUgdHdvIGJhc2UgY29udHJvbGxlcnMgaW4gdGhlIGBAbWV0YW1hc2svY29udHJvbGxlcnNgXG4gICAqIHBhY2thZ2UuXG4gICAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBPYmplY3Q+fVxuICAgKi9cbiAgY29uZmlnID0ge307XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzdG9yZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY29uZmlnXSAtIE1hcCBvZiBpbnRlcm5hbCBzdGF0ZSBrZXlzIHRvIGNoaWxkIHN0b3Jlc1xuICAgKiBAcGFyYW0ge0NvbnRyb2xsZXJNZXNzZW5nZXJ9IG9wdGlvbnMuY29udHJvbGxlck1lc3NlbmdlciAtIFRoZSBjb250cm9sbGVyXG4gICAqICAgbWVzc2VuZ2VyLCB1c2VkIGZvciBzdWJzY3JpYmluZyB0byBldmVudHMgZnJvbSBCYXNlQ29udHJvbGxlclYyLWJhc2VkXG4gICAqICAgY29udHJvbGxlcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zdGF0ZV0gLSBUaGUgaW5pdGlhbCBzdG9yZSBzdGF0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBlcnNpc3RdIC0gV2V0aGVyIG9yIG5vdCB0byBhcHBseSB0aGUgcGVyc2lzdGVuY2UgZm9yIHYyIGNvbnRyb2xsZXJzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGNvbmZpZywgY29udHJvbGxlck1lc3Nlbmdlciwgc3RhdGUsIHBlcnNpc3QgfSkge1xuICAgIHN1cGVyKHN0YXRlKTtcbiAgICB0aGlzLnBlcnNpc3QgPSBwZXJzaXN0O1xuICAgIHRoaXMuY29udHJvbGxlck1lc3NlbmdlciA9IGNvbnRyb2xsZXJNZXNzZW5nZXI7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdGhpcy51cGRhdGVTdHJ1Y3R1cmUoY29uZmlnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29tcG9zZXMgYSBuZXcgaW50ZXJuYWwgc3RvcmUgc3Vic2NyaXB0aW9uIHN0cnVjdHVyZVxuICAgKlxuICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIE9iamVjdD59IGNvbmZpZyAtIERlc2NyaWJlcyB3aGljaCBzdG9yZXMgYXJlIGJlaW5nXG4gICAqICAgY29tcG9zZWQuIFRoZSBrZXkgaXMgdGhlIG5hbWUgb2YgdGhlIHN0b3JlLCBhbmQgdGhlIHZhbHVlIGlzIGVpdGhlciBhblxuICAgKiAgIE9ic2VyYWJsZVN0b3JlLCBvciBhIGNvbnRyb2xsZXIgdGhhdCBleHRlbmRzIG9uZSBvZiB0aGUgdHdvIGJhc2VcbiAgICogICBjb250cm9sbGVycyBpbiB0aGUgYEBtZXRhbWFzay9jb250cm9sbGVyc2AgcGFja2FnZS5cbiAgICovXG4gIHVwZGF0ZVN0cnVjdHVyZShjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvbmZpZykpIHtcbiAgICAgIGlmICghY29uZmlnW2tleV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmRlZmluZWQgJyR7a2V5fSdgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JlID0gY29uZmlnW2tleV07XG4gICAgICBpZiAoc3RvcmUuc3Vic2NyaWJlKSB7XG4gICAgICAgIGNvbmZpZ1trZXldLnN1YnNjcmliZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHsgW2tleV06IHN0YXRlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUoXG4gICAgICAgICAgYCR7c3RvcmUubmFtZX06c3RhdGVDaGFuZ2VgLFxuICAgICAgICAgIChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZWRTdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVyc2lzdCkge1xuICAgICAgICAgICAgICB1cGRhdGVkU3RhdGUgPSBnZXRQZXJzaXN0ZW50U3RhdGUoc3RhdGUsIGNvbmZpZ1trZXldLm1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoeyBba2V5XTogdXBkYXRlZFN0YXRlIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlcyBhbGwgY2hpbGQgc3RvcmUgc3RhdGUgaW50byBhIHNpbmdsZSBvYmplY3QgcmF0aGVyIHRoYW5cbiAgICogcmV0dXJuaW5nIGFuIG9iamVjdCBrZXllZCBieSBjaGlsZCBzdG9yZSBjbGFzcyBuYW1lXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIG1lcmdlZCBjaGlsZCBzdG9yZSBzdGF0ZVxuICAgKi9cbiAgZ2V0RmxhdFN0YXRlKCkge1xuICAgIGlmICghdGhpcy5jb25maWcpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgbGV0IGZsYXRTdGF0ZSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuY29uZmlnKSkge1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY29uZmlnW2tleV07XG4gICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuZ2V0U3RhdGVcbiAgICAgICAgPyBjb250cm9sbGVyLmdldFN0YXRlKClcbiAgICAgICAgOiBjb250cm9sbGVyLnN0YXRlO1xuICAgICAgZmxhdFN0YXRlID0geyAuLi5mbGF0U3RhdGUsIC4uLnN0YXRlIH07XG4gICAgfVxuICAgIHJldHVybiBmbGF0U3RhdGU7XG4gIH1cbn1cbiIsImltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG4vKipcbiAqIFJldHVybnMgYSBtaWRkbGV3YXJlIHRoYXQgbG9ncyBSUEMgYWN0aXZpdHlcbiAqIEBwYXJhbSB7eyBvcmlnaW46IHN0cmluZyB9fSBvcHRzIC0gVGhlIG1pZGRsZXdhcmUgb3B0aW9uc1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVMb2dnZXJNaWRkbGV3YXJlKG9wdHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxvZ2dlck1pZGRsZXdhcmUoXG4gICAgLyoqIEB0eXBlIHthbnl9ICovIHJlcSxcbiAgICAvKiogQHR5cGUge2FueX0gKi8gcmVzLFxuICAgIC8qKiBAdHlwZSB7RnVuY3Rpb259ICovIG5leHQsXG4gICkge1xuICAgIG5leHQoKC8qKiBAdHlwZSB7RnVuY3Rpb259ICovIGNiKSA9PiB7XG4gICAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICAgIGxvZy5lcnJvcignRXJyb3IgaW4gUlBDIHJlc3BvbnNlOlxcbicsIHJlcyk7XG4gICAgICB9XG4gICAgICBpZiAocmVxLmlzTWV0YW1hc2tJbnRlcm5hbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2cuaW5mbyhgUlBDICgke29wdHMub3JpZ2lufSk6YCwgcmVxLCAnLT4nLCByZXMpO1xuICAgICAgY2IoKTtcbiAgICB9KTtcbiAgfTtcbn1cbiIsImltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IGV4dGVuc2lvbiBmcm9tICdleHRlbnNpb25pemVyJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbWlkZGxld2FyZSB0aGF0IGludGVyY2VwdHMgYHdhbGxldF9yZWdpc3Rlck9uYm9hcmRpbmdgIG1lc3NhZ2VzXG4gKiBAcGFyYW0ge3sgbG9jYXRpb246IHN0cmluZywgcmVnaXN0ZXJPbmJvYXJkaW5nOiBGdW5jdGlvbiB9fSBvcHRzIC0gVGhlIG1pZGRsZXdhcmUgb3B0aW9uc1xuICogQHJldHVybnMgeyhyZXE6IGFueSwgcmVzOiBhbnksIG5leHQ6IEZ1bmN0aW9uLCBlbmQ6IEZ1bmN0aW9uKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVPbmJvYXJkaW5nTWlkZGxld2FyZSh7XG4gIGxvY2F0aW9uLFxuICByZWdpc3Rlck9uYm9hcmRpbmcsXG59KSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBvcmlnaW5NaWRkbGV3YXJlKHJlcSwgcmVzLCBuZXh0LCBlbmQpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHJlcS5tZXRob2QgIT09ICd3YWxsZXRfcmVnaXN0ZXJPbmJvYXJkaW5nJykge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXEudGFiSWQgJiYgcmVxLnRhYklkICE9PSBleHRlbnNpb24udGFicy5UQUJfSURfTk9ORSkge1xuICAgICAgICBhd2FpdCByZWdpc3Rlck9uYm9hcmRpbmcobG9jYXRpb24sIHJlcS50YWJJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cuZGVidWcoXG4gICAgICAgICAgYCd3YWxsZXRfcmVnaXN0ZXJPbmJvYXJkaW5nJyBtZXNzYWdlIGZyb20gJHtsb2NhdGlvbn0gaWdub3JlZCBkdWUgdG8gbWlzc2luZyB0YWJJZGAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXMucmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGVuZCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlbmQoZXJyb3IpO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IHsgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMgfSBmcm9tICcuLi9tZXRhbWFzay1jb250cm9sbGVyJztcbmltcG9ydCB7IE1JTlVURSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdGltZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFwcFN0YXRlQ29udHJvbGxlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZFVubG9ja0xpc3RlbmVyLFxuICAgICAgaXNVbmxvY2tlZCxcbiAgICAgIGluaXRTdGF0ZSxcbiAgICAgIG9uSW5hY3RpdmVUaW1lb3V0LFxuICAgICAgc2hvd1VubG9ja1JlcXVlc3QsXG4gICAgICBwcmVmZXJlbmNlc1N0b3JlLFxuICAgICAgcXJIYXJkd2FyZVN0b3JlLFxuICAgIH0gPSBvcHRzO1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9uSW5hY3RpdmVUaW1lb3V0ID0gb25JbmFjdGl2ZVRpbWVvdXQgfHwgKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgdGltZW91dE1pbnV0ZXM6IDAsXG4gICAgICBjb25uZWN0ZWRTdGF0dXNQb3BvdmVySGFzQmVlblNob3duOiB0cnVlLFxuICAgICAgZGVmYXVsdEhvbWVBY3RpdmVUYWJOYW1lOiBudWxsLFxuICAgICAgYnJvd3NlckVudmlyb25tZW50OiB7fSxcbiAgICAgIHBvcHVwR2FzUG9sbFRva2VuczogW10sXG4gICAgICBub3RpZmljYXRpb25HYXNQb2xsVG9rZW5zOiBbXSxcbiAgICAgIGZ1bGxTY3JlZW5HYXNQb2xsVG9rZW5zOiBbXSxcbiAgICAgIHJlY292ZXJ5UGhyYXNlUmVtaW5kZXJIYXNCZWVuU2hvd246IGZhbHNlLFxuICAgICAgcmVjb3ZlcnlQaHJhc2VSZW1pbmRlckxhc3RTaG93bjogbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICBjb2xsZWN0aWJsZXNEZXRlY3Rpb25Ob3RpY2VEaXNtaXNzZWQ6IGZhbHNlLFxuICAgICAgc2hvd1Rlc3RuZXRNZXNzYWdlSW5Ecm9wZG93bjogdHJ1ZSxcbiAgICAgIHRyZXpvck1vZGVsOiBudWxsLFxuICAgICAgLi4uaW5pdFN0YXRlLFxuICAgICAgcXJIYXJkd2FyZToge30sXG4gICAgfSk7XG4gICAgdGhpcy50aW1lciA9IG51bGw7XG5cbiAgICB0aGlzLmlzVW5sb2NrZWQgPSBpc1VubG9ja2VkO1xuICAgIHRoaXMud2FpdGluZ0ZvclVubG9jayA9IFtdO1xuICAgIGFkZFVubG9ja0xpc3RlbmVyKHRoaXMuaGFuZGxlVW5sb2NrLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5fc2hvd1VubG9ja1JlcXVlc3QgPSBzaG93VW5sb2NrUmVxdWVzdDtcblxuICAgIHByZWZlcmVuY2VzU3RvcmUuc3Vic2NyaWJlKCh7IHByZWZlcmVuY2VzIH0pID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChjdXJyZW50U3RhdGUudGltZW91dE1pbnV0ZXMgIT09IHByZWZlcmVuY2VzLmF1dG9Mb2NrVGltZUxpbWl0KSB7XG4gICAgICAgIHRoaXMuX3NldEluYWN0aXZlVGltZW91dChwcmVmZXJlbmNlcy5hdXRvTG9ja1RpbWVMaW1pdCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBxckhhcmR3YXJlU3RvcmUuc3Vic2NyaWJlKChzdGF0ZSkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHFySGFyZHdhcmU6IHN0YXRlIH0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgeyBwcmVmZXJlbmNlcyB9ID0gcHJlZmVyZW5jZXNTdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuX3NldEluYWN0aXZlVGltZW91dChwcmVmZXJlbmNlcy5hdXRvTG9ja1RpbWVMaW1pdCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGV4dGVuc2lvbiBpcyB1bmxvY2tlZC5cbiAgICogVGhpcyBQcm9taXNlIHdpbGwgbmV2ZXIgcmVqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFNob3dVbmxvY2tSZXF1ZXN0IC0gV2hldGhlciB0aGUgZXh0ZW5zaW9uIG5vdGlmaWNhdGlvblxuICAgKiBwb3B1cCBzaG91bGQgYmUgb3BlbmVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgZXh0ZW5zaW9uIGlzXG4gICAqIHVubG9ja2VkLCBvciBpbW1lZGlhdGVseSBpZiB0aGUgZXh0ZW5zaW9uIGlzIGFscmVhZHkgdW5sb2NrZWQuXG4gICAqL1xuICBnZXRVbmxvY2tQcm9taXNlKHNob3VsZFNob3dVbmxvY2tSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1VubG9ja2VkKCkpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53YWl0Rm9yVW5sb2NrKHJlc29sdmUsIHNob3VsZFNob3dVbmxvY2tSZXF1ZXN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgUHJvbWlzZSdzIHJlc29sdmUgZnVuY3Rpb24gdG8gdGhlIHdhaXRpbmdGb3JVbmxvY2sgcXVldWUuXG4gICAqIEFsc28gb3BlbnMgdGhlIGV4dGVuc2lvbiBwb3B1cCBpZiBzcGVjaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UHJvbWlzZS5yZXNvbHZlfSByZXNvbHZlIC0gQSBQcm9taXNlJ3MgcmVzb2x2ZSBmdW5jdGlvbiB0aGF0IHdpbGxcbiAgICogYmUgY2FsbGVkIHdoZW4gdGhlIGV4dGVuc2lvbiBpcyB1bmxvY2tlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRTaG93VW5sb2NrUmVxdWVzdCAtIFdoZXRoZXIgdGhlIGV4dGVuc2lvbiBub3RpZmljYXRpb25cbiAgICogcG9wdXAgc2hvdWxkIGJlIG9wZW5lZC5cbiAgICovXG4gIHdhaXRGb3JVbmxvY2socmVzb2x2ZSwgc2hvdWxkU2hvd1VubG9ja1JlcXVlc3QpIHtcbiAgICB0aGlzLndhaXRpbmdGb3JVbmxvY2sucHVzaCh7IHJlc29sdmUgfSk7XG4gICAgdGhpcy5lbWl0KE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSk7XG4gICAgaWYgKHNob3VsZFNob3dVbmxvY2tSZXF1ZXN0KSB7XG4gICAgICB0aGlzLl9zaG93VW5sb2NrUmVxdWVzdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFpbnMgdGhlIHdhaXRpbmdGb3JVbmxvY2sgcXVldWUsIHJlc29sdmluZyBhbGwgdGhlIHJlbGF0ZWQgUHJvbWlzZXMuXG4gICAqL1xuICBoYW5kbGVVbmxvY2soKSB7XG4gICAgaWYgKHRoaXMud2FpdGluZ0ZvclVubG9jay5sZW5ndGggPiAwKSB7XG4gICAgICB3aGlsZSAodGhpcy53YWl0aW5nRm9yVW5sb2NrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy53YWl0aW5nRm9yVW5sb2NrLnNoaWZ0KCkucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlZmF1bHQgaG9tZSB0YWJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0SG9tZUFjdGl2ZVRhYk5hbWVdIC0gdGhlIHRhYiBuYW1lXG4gICAqL1xuICBzZXREZWZhdWx0SG9tZUFjdGl2ZVRhYk5hbWUoZGVmYXVsdEhvbWVBY3RpdmVUYWJOYW1lKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBkZWZhdWx0SG9tZUFjdGl2ZVRhYk5hbWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVjb3JkIHRoYXQgdGhlIHVzZXIgaGFzIHNlZW4gdGhlIGNvbm5lY3RlZCBzdGF0dXMgaW5mbyBwb3BvdmVyXG4gICAqL1xuICBzZXRDb25uZWN0ZWRTdGF0dXNQb3BvdmVySGFzQmVlblNob3duKCkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgY29ubmVjdGVkU3RhdHVzUG9wb3Zlckhhc0JlZW5TaG93bjogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvcmQgdGhhdCB0aGUgdXNlciBoYXMgYmVlbiBzaG93biB0aGUgcmVjb3ZlcnkgcGhyYXNlIHJlbWluZGVyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc2V0UmVjb3ZlcnlQaHJhc2VSZW1pbmRlckhhc0JlZW5TaG93bigpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHJlY292ZXJ5UGhyYXNlUmVtaW5kZXJIYXNCZWVuU2hvd246IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVjb3JkIHRoZSB0aW1lc3RhbXAgb2YgdGhlIGxhc3QgdGltZSB0aGUgdXNlciBoYXMgc2VlbiB0aGUgcmVjb3ZlcnkgcGhyYXNlIHJlbWluZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0U2hvd24gLSB0aW1lc3RhbXAgd2hlbiB1c2VyIHdhcyBsYXN0IHNob3duIHRoZSByZW1pbmRlclxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHNldFJlY292ZXJ5UGhyYXNlUmVtaW5kZXJMYXN0U2hvd24obGFzdFNob3duKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICByZWNvdmVyeVBocmFzZVJlbWluZGVyTGFzdFNob3duOiBsYXN0U2hvd24sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGFzdCBhY3RpdmUgdGltZSB0byB0aGUgY3VycmVudCB0aW1lXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc2V0TGFzdEFjdGl2ZVRpbWUoKSB7XG4gICAgdGhpcy5fcmVzZXRUaW1lcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGluYWN0aXZlIHRpbWVvdXQgZm9yIHRoZSBhcHBcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNaW51dGVzIC0gdGhlIGluYWN0aXZlIHRpbWVvdXQgaW4gbWludXRlc1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRJbmFjdGl2ZVRpbWVvdXQodGltZW91dE1pbnV0ZXMpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHRpbWVvdXRNaW51dGVzLFxuICAgIH0pO1xuXG4gICAgdGhpcy5fcmVzZXRUaW1lcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgaW5hY3RpdmUgdGltZXJcbiAgICpcbiAgICogSWYgdGhlIHtAY29kZSB0aW1lb3V0TWludXRlc30gc3RhdGUgaXMgZmFsc3kgKGkuZS4sIHplcm8pIHRoZW4gYSBuZXdcbiAgICogdGltZXIgd2lsbCBub3QgYmUgY3JlYXRlZC5cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRUaW1lcigpIHtcbiAgICBjb25zdCB7IHRpbWVvdXRNaW51dGVzIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgIH1cblxuICAgIGlmICghdGltZW91dE1pbnV0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChcbiAgICAgICgpID0+IHRoaXMub25JbmFjdGl2ZVRpbWVvdXQoKSxcbiAgICAgIHRpbWVvdXRNaW51dGVzICogTUlOVVRFLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBicm93c2VyIGFuZCBPUyBlbnZpcm9ubWVudFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHNldEJyb3dzZXJFbnZpcm9ubWVudChvcywgYnJvd3Nlcikge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBicm93c2VyRW52aXJvbm1lbnQ6IHsgb3MsIGJyb3dzZXIgfSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcG9sbGluZ1Rva2VuIGZvciBhIGdpdmVuIGVudmlyb25tZW50VHlwZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGFkZFBvbGxpbmdUb2tlbihwb2xsaW5nVG9rZW4sIHBvbGxpbmdUb2tlblR5cGUpIHtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLnN0b3JlLmdldFN0YXRlKClbcG9sbGluZ1Rva2VuVHlwZV07XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBbcG9sbGluZ1Rva2VuVHlwZV06IFsuLi5wcmV2U3RhdGUsIHBvbGxpbmdUb2tlbl0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlcyBhIHBvbGxpbmdUb2tlbiBmb3IgYSBnaXZlbiBlbnZpcm9ubWVudFR5cGVcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICByZW1vdmVQb2xsaW5nVG9rZW4ocG9sbGluZ1Rva2VuLCBwb2xsaW5nVG9rZW5UeXBlKSB7XG4gICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpW3BvbGxpbmdUb2tlblR5cGVdO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgW3BvbGxpbmdUb2tlblR5cGVdOiBwcmV2U3RhdGUuZmlsdGVyKCh0b2tlbikgPT4gdG9rZW4gIT09IHBvbGxpbmdUb2tlbiksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogY2xlYXJzIGFsbCBwb2xsaW5nVG9rZW5zXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgY2xlYXJQb2xsaW5nVG9rZW5zKCkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgcG9wdXBHYXNQb2xsVG9rZW5zOiBbXSxcbiAgICAgIG5vdGlmaWNhdGlvbkdhc1BvbGxUb2tlbnM6IFtdLFxuICAgICAgZnVsbFNjcmVlbkdhc1BvbGxUb2tlbnM6IFtdLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0aGUgdGVzdG5ldCBkaXNtaXNzYWwgbGluayBzaG91bGQgYmUgc2hvd24gaW4gdGhlIG5ldHdvcmsgZHJvcGRvd25cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzZXRTaG93VGVzdG5ldE1lc3NhZ2VJbkRyb3Bkb3duKHNob3dUZXN0bmV0TWVzc2FnZUluRHJvcGRvd24pIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgc2hvd1Rlc3RuZXRNZXNzYWdlSW5Ecm9wZG93biB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgcHJvcGVydHkgaW5kaWNhdGluZyB0aGUgbW9kZWwgb2YgdGhlIHVzZXIncyBUcmV6b3IgaGFyZHdhcmUgd2FsbGV0XG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc2V0VHJlem9yTW9kZWwodHJlem9yTW9kZWwpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgdHJlem9yTW9kZWwgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBzZXR0ZXIgZm9yIHRoZSBgY29sbGVjdGlibGVzRGV0ZWN0aW9uTm90aWNlRGlzbWlzc2VkYCBwcm9wZXJ0eVxuICAgKi9cbiAgc2V0Q29sbGVjdGlibGVzRGV0ZWN0aW9uTm90aWNlRGlzbWlzc2VkKFxuICAgIGNvbGxlY3RpYmxlc0RldGVjdGlvbk5vdGljZURpc21pc3NlZCxcbiAgKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBjb2xsZWN0aWJsZXNEZXRlY3Rpb25Ob3RpY2VEaXNtaXNzZWQsXG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhY2hlZEJhbGFuY2VzT3B0aW9uc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGFjY291bnRUcmFja2VyIEFuIHtAY29kZSBBY2NvdW50VHJhY2tlcn0gcmVmZXJlbmNlXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBnZXRDdXJyZW50Q2hhaW5JZCBBIGZ1bmN0aW9uIHRvIGdldCB0aGUgY3VycmVudCBjaGFpbiBpZFxuICogQHByb3BlcnR5IHtPYmplY3R9IGluaXRTdGF0ZSBUaGUgaW5pdGlhbCBjb250cm9sbGVyIHN0YXRlXG4gKi9cblxuLyoqXG4gKiBCYWNrZ3JvdW5kIGNvbnRyb2xsZXIgcmVzcG9uc2libGUgZm9yIG1haW50YWluaW5nXG4gKiBhIGNhY2hlIG9mIGFjY291bnQgYmFsYW5jZXMgaW4gbG9jYWwgc3RvcmFnZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjb250cm9sbGVyIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FjaGVkQmFsYW5jZXNPcHRpb25zfSBbb3B0c10gLSBDb250cm9sbGVyIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBhY2NvdW50VHJhY2tlciwgZ2V0Q3VycmVudENoYWluSWQgfSA9IG9wdHM7XG5cbiAgICB0aGlzLmFjY291bnRUcmFja2VyID0gYWNjb3VudFRyYWNrZXI7XG4gICAgdGhpcy5nZXRDdXJyZW50Q2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkO1xuXG4gICAgY29uc3QgaW5pdFN0YXRlID0geyBjYWNoZWRCYWxhbmNlczoge30sIC4uLm9wdHMuaW5pdFN0YXRlIH07XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoaW5pdFN0YXRlKTtcblxuICAgIHRoaXMuX3JlZ2lzdGVyVXBkYXRlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNhY2hlZEJhbGFuY2VzIHByb3BlcnR5IGZvciB0aGUgY3VycmVudCBjaGFpbi4gQ2FjaGVkIGJhbGFuY2VzIHdpbGwgYmUgdXBkYXRlZCB0byB0aG9zZSBpbiB0aGUgcGFzc2VkIGFjY291bnRzXG4gICAqIGlmIGJhbGFuY2VzIGluIHRoZSBwYXNzZWQgYWNjb3VudHMgYXJlIHRydXRoeS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSB0aGUgcmVjZW50bHkgdXBkYXRlZCBhY2NvdW50cyBvYmplY3QgZm9yIHRoZSBjdXJyZW50IGNoYWluXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlQ2FjaGVkQmFsYW5jZXMoeyBhY2NvdW50cyB9KSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IHRoaXMuZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICBjb25zdCBiYWxhbmNlc1RvQ2FjaGUgPSBhd2FpdCB0aGlzLl9nZW5lcmF0ZUJhbGFuY2VzVG9DYWNoZShcbiAgICAgIGFjY291bnRzLFxuICAgICAgY2hhaW5JZCxcbiAgICApO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgY2FjaGVkQmFsYW5jZXM6IGJhbGFuY2VzVG9DYWNoZSxcbiAgICB9KTtcbiAgfVxuXG4gIF9nZW5lcmF0ZUJhbGFuY2VzVG9DYWNoZShuZXdBY2NvdW50cywgY2hhaW5JZCkge1xuICAgIGNvbnN0IHsgY2FjaGVkQmFsYW5jZXMgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBjdXJyZW50Q2hhaW5CYWxhbmNlc1RvQ2FjaGUgPSB7IC4uLmNhY2hlZEJhbGFuY2VzW2NoYWluSWRdIH07XG5cbiAgICBPYmplY3Qua2V5cyhuZXdBY2NvdW50cykuZm9yRWFjaCgoYWNjb3VudElEKSA9PiB7XG4gICAgICBjb25zdCBhY2NvdW50ID0gbmV3QWNjb3VudHNbYWNjb3VudElEXTtcblxuICAgICAgaWYgKGFjY291bnQuYmFsYW5jZSkge1xuICAgICAgICBjdXJyZW50Q2hhaW5CYWxhbmNlc1RvQ2FjaGVbYWNjb3VudElEXSA9IGFjY291bnQuYmFsYW5jZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBiYWxhbmNlc1RvQ2FjaGUgPSB7XG4gICAgICAuLi5jYWNoZWRCYWxhbmNlcyxcbiAgICAgIFtjaGFpbklkXTogY3VycmVudENoYWluQmFsYW5jZXNUb0NhY2hlLFxuICAgIH07XG5cbiAgICByZXR1cm4gYmFsYW5jZXNUb0NhY2hlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgY2FjaGVkQmFsYW5jZXNcbiAgICovXG5cbiAgY2xlYXJDYWNoZWRCYWxhbmNlcygpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgY2FjaGVkQmFsYW5jZXM6IHt9IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgbGlzdGVuZXJzIGFuZCBzdWJzY3JpcHRpb25zIHdoaWNoIHNob3VsZCB0cmlnZ2VyIGFuIHVwZGF0ZSBvZiBjYWNoZWQgYmFsYW5jZXMuIFRoZXNlIHVwZGF0ZXMgd2lsbFxuICAgKiBoYXBwZW4gd2hlbiB0aGUgY3VycmVudCBhY2NvdW50IGNoYW5nZXMuIFdoaWNoIGhhcHBlbnMgb24gYmxvY2sgdXBkYXRlcywgYXMgd2VsbCBhcyBvbiBuZXR3b3JrIGFuZCBhY2NvdW50XG4gICAqIHNlbGVjdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqL1xuICBfcmVnaXN0ZXJVcGRhdGVzKCkge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHRoaXMudXBkYXRlQ2FjaGVkQmFsYW5jZXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFjY291bnRUcmFja2VyLnN0b3JlLnN1YnNjcmliZSh1cGRhdGUpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7XG4gIFRPR0dMRUFCTEVfQUxFUlRfVFlQRVMsXG4gIFdFQjNfU0hJTV9VU0FHRV9BTEVSVF9TVEFURVMsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYWxlcnRzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBbGVydENvbnRyb2xsZXJJbml0U3RhdGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhbGVydEVuYWJsZWRuZXNzIC0gQSBtYXAgb2YgYWxlcnRzIElEcyB0byBib29sZWFucywgd2hlcmVcbiAqIGB0cnVlYCBpbmRpY2F0ZXMgdGhhdCB0aGUgYWxlcnQgaXMgZW5hYmxlZCBhbmQgc2hvd24sIGFuZCBgZmFsc2VgIHRoZSBvcHBvc2l0ZS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB1bmNvbm5lY3RlZEFjY291bnRBbGVydFNob3duT3JpZ2lucyAtIEEgbWFwIG9mIG9yaWdpblxuICogc3RyaW5ncyB0byBib29sZWFucyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFwic3dpdGNoIHRvIGNvbm5lY3RlZFwiIGFsZXJ0IGhhc1xuICogYmVlbiBzaG93biAoYHRydWVgKSBvciBvdGhlcndpc2UgKGBmYWxzZWApLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQWxlcnRDb250cm9sbGVyT3B0aW9uc1xuICogQHByb3BlcnR5IHtBbGVydENvbnRyb2xsZXJJbml0U3RhdGV9IGluaXRTdGF0ZSAtIFRoZSBpbml0aWFsIGNvbnRyb2xsZXIgc3RhdGVcbiAqL1xuXG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gIGFsZXJ0RW5hYmxlZG5lc3M6IFRPR0dMRUFCTEVfQUxFUlRfVFlQRVMucmVkdWNlKFxuICAgIChhbGVydEVuYWJsZWRuZXNzLCBhbGVydFR5cGUpID0+IHtcbiAgICAgIGFsZXJ0RW5hYmxlZG5lc3NbYWxlcnRUeXBlXSA9IHRydWU7XG4gICAgICByZXR1cm4gYWxlcnRFbmFibGVkbmVzcztcbiAgICB9LFxuICAgIHt9LFxuICApLFxuICB1bmNvbm5lY3RlZEFjY291bnRBbGVydFNob3duT3JpZ2luczoge30sXG4gIHdlYjNTaGltVXNhZ2VPcmlnaW5zOiB7fSxcbn07XG5cbi8qKlxuICogQ29udHJvbGxlciByZXNwb25zaWJsZSBmb3IgbWFpbnRhaW5pbmcgYWxlcnQtcmVsYXRlZCBzdGF0ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWxlcnRDb250cm9sbGVyIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0FsZXJ0Q29udHJvbGxlck9wdGlvbnN9IFtvcHRzXSAtIENvbnRyb2xsZXIgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IGluaXRTdGF0ZSA9IHt9LCBwcmVmZXJlbmNlc1N0b3JlIH0gPSBvcHRzO1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgLi4uZGVmYXVsdFN0YXRlLFxuICAgICAgYWxlcnRFbmFibGVkbmVzczoge1xuICAgICAgICAuLi5kZWZhdWx0U3RhdGUuYWxlcnRFbmFibGVkbmVzcyxcbiAgICAgICAgLi4uaW5pdFN0YXRlLmFsZXJ0RW5hYmxlZG5lc3MsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICB0aGlzLnN0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZShzdGF0ZSk7XG5cbiAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyA9IHByZWZlcmVuY2VzU3RvcmUuZ2V0U3RhdGUoKS5zZWxlY3RlZEFkZHJlc3M7XG5cbiAgICBwcmVmZXJlbmNlc1N0b3JlLnN1YnNjcmliZSgoeyBzZWxlY3RlZEFkZHJlc3MgfSkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKFxuICAgICAgICBjdXJyZW50U3RhdGUudW5jb25uZWN0ZWRBY2NvdW50QWxlcnRTaG93bk9yaWdpbnMgJiZcbiAgICAgICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgIT09IHNlbGVjdGVkQWRkcmVzc1xuICAgICAgKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gc2VsZWN0ZWRBZGRyZXNzO1xuICAgICAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgdW5jb25uZWN0ZWRBY2NvdW50QWxlcnRTaG93bk9yaWdpbnM6IHt9IH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0QWxlcnRFbmFibGVkbmVzcyhhbGVydElkLCBlbmFibGVkbmVzcykge1xuICAgIGxldCB7IGFsZXJ0RW5hYmxlZG5lc3MgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBhbGVydEVuYWJsZWRuZXNzID0geyAuLi5hbGVydEVuYWJsZWRuZXNzIH07XG4gICAgYWxlcnRFbmFibGVkbmVzc1thbGVydElkXSA9IGVuYWJsZWRuZXNzO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBhbGVydEVuYWJsZWRuZXNzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIFwic3dpdGNoIHRvIGNvbm5lY3RlZFwiIGFsZXJ0IGFzIHNob3duIGZvciB0aGUgZ2l2ZW4gb3JpZ2luXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gLSBUaGUgb3JpZ2luIHRoZSBhbGVydCBoYXMgYmVlbiBzaG93biBmb3JcbiAgICovXG4gIHNldFVuY29ubmVjdGVkQWNjb3VudEFsZXJ0U2hvd24ob3JpZ2luKSB7XG4gICAgbGV0IHsgdW5jb25uZWN0ZWRBY2NvdW50QWxlcnRTaG93bk9yaWdpbnMgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB1bmNvbm5lY3RlZEFjY291bnRBbGVydFNob3duT3JpZ2lucyA9IHtcbiAgICAgIC4uLnVuY29ubmVjdGVkQWNjb3VudEFsZXJ0U2hvd25PcmlnaW5zLFxuICAgIH07XG4gICAgdW5jb25uZWN0ZWRBY2NvdW50QWxlcnRTaG93bk9yaWdpbnNbb3JpZ2luXSA9IHRydWU7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHVuY29ubmVjdGVkQWNjb3VudEFsZXJ0U2hvd25PcmlnaW5zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHdlYjMgc2hpbSB1c2FnZSBzdGF0ZSBmb3IgdGhlIGdpdmVuIG9yaWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gdG8gZ2V0IHRoZSB3ZWIzIHNoaW0gdXNhZ2Ugc3RhdGUgZm9yLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkIHwgMSB8IDJ9IFRoZSB3ZWIzIHNoaW0gdXNhZ2Ugc3RhdGUgZm9yIHRoZSBnaXZlblxuICAgKiBvcmlnaW4sIG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldFdlYjNTaGltVXNhZ2VTdGF0ZShvcmlnaW4pIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLndlYjNTaGltVXNhZ2VPcmlnaW5zW29yaWdpbl07XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgd2ViMyBzaGltIHVzYWdlIHN0YXRlIGZvciB0aGUgZ2l2ZW4gb3JpZ2luIHRvIFJFQ09SREVELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIG9yaWdpbiB0aGUgdGhhdCB1c2VkIHRoZSB3ZWIzIHNoaW0uXG4gICAqL1xuICBzZXRXZWIzU2hpbVVzYWdlUmVjb3JkZWQob3JpZ2luKSB7XG4gICAgdGhpcy5fc2V0V2ViM1NoaW1Vc2FnZVN0YXRlKG9yaWdpbiwgV0VCM19TSElNX1VTQUdFX0FMRVJUX1NUQVRFUy5SRUNPUkRFRCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgd2ViMyBzaGltIHVzYWdlIHN0YXRlIGZvciB0aGUgZ2l2ZW4gb3JpZ2luIHRvIERJU01JU1NFRC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gdGhhdCB0aGUgd2ViMyBzaGltIG5vdGlmaWNhdGlvbiB3YXNcbiAgICogZGlzbWlzc2VkIGZvci5cbiAgICovXG4gIHNldFdlYjNTaGltVXNhZ2VBbGVydERpc21pc3NlZChvcmlnaW4pIHtcbiAgICB0aGlzLl9zZXRXZWIzU2hpbVVzYWdlU3RhdGUob3JpZ2luLCBXRUIzX1NISU1fVVNBR0VfQUxFUlRfU1RBVEVTLkRJU01JU1NFRCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gdG8gc2V0IHRoZSBzdGF0ZSBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBzdGF0ZSB2YWx1ZSB0byBzZXQuXG4gICAqL1xuICBfc2V0V2ViM1NoaW1Vc2FnZVN0YXRlKG9yaWdpbiwgdmFsdWUpIHtcbiAgICBsZXQgeyB3ZWIzU2hpbVVzYWdlT3JpZ2lucyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHdlYjNTaGltVXNhZ2VPcmlnaW5zID0ge1xuICAgICAgLi4ud2ViM1NoaW1Vc2FnZU9yaWdpbnMsXG4gICAgfTtcbiAgICB3ZWIzU2hpbVVzYWdlT3JpZ2luc1tvcmlnaW5dID0gdmFsdWU7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHdlYjNTaGltVXNhZ2VPcmlnaW5zIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEluaXRTdGF0ZVxuICogQHByb3BlcnR5IHtCb29sZWFufSBzZWVkUGhyYXNlQmFja2VkVXAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaGFzIGNvbXBsZXRlZCB0aGUgc2VlZCBwaHJhc2UgYmFja3VwIGNoYWxsZW5nZVxuICogQHByb3BlcnR5IHtCb29sZWFufSBjb21wbGV0ZWRPbmJvYXJkaW5nIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIGhhcyBjb21wbGV0ZWQgdGhlIG9uYm9hcmRpbmcgZmxvd1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT25ib2FyZGluZ09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7SW5pdFN0YXRlfSBpbml0U3RhdGUgVGhlIGluaXRpYWwgY29udHJvbGxlciBzdGF0ZVxuICovXG5cbi8qKlxuICogQ29udHJvbGxlciByZXNwb25zaWJsZSBmb3IgbWFpbnRhaW5pbmdcbiAqIHN0YXRlIHJlbGF0ZWQgdG8gb25ib2FyZGluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPbmJvYXJkaW5nQ29udHJvbGxlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtPbmJvYXJkaW5nT3B0aW9uc30gW29wdHNdIENvbnRyb2xsZXIgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBjb25zdCBpbml0aWFsVHJhbnNpZW50U3RhdGUgPSB7XG4gICAgICBvbmJvYXJkaW5nVGFiczoge30sXG4gICAgfTtcbiAgICBjb25zdCBpbml0U3RhdGUgPSB7XG4gICAgICBzZWVkUGhyYXNlQmFja2VkVXA6IG51bGwsXG4gICAgICBmaXJzdFRpbWVGbG93VHlwZTogbnVsbCxcbiAgICAgIGNvbXBsZXRlZE9uYm9hcmRpbmc6IGZhbHNlLFxuICAgICAgLi4ub3B0cy5pbml0U3RhdGUsXG4gICAgICAuLi5pbml0aWFsVHJhbnNpZW50U3RhdGUsXG4gICAgfTtcbiAgICB0aGlzLnN0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZShpbml0U3RhdGUpO1xuICB9XG5cbiAgc2V0U2VlZFBocmFzZUJhY2tlZFVwKG5ld1NlZWRQaHJhc2VCYWNrVXBTdGF0ZSkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgc2VlZFBocmFzZUJhY2tlZFVwOiBuZXdTZWVkUGhyYXNlQmFja1VwU3RhdGUsXG4gICAgfSk7XG4gIH1cblxuICAvLyAvKipcbiAgLy8gICogU2V0cyB0aGUgY29tcGxldGVkT25ib2FyZGluZyBzdGF0ZSB0byB0cnVlLCBpbmRpY2F0aW5nIHRoYXQgdGhlIHVzZXIgaGFzIGNvbXBsZXRlZCB0aGVcbiAgLy8gICogb25ib2FyZGluZyBwcm9jZXNzLlxuICAvLyAgKi9cbiAgY29tcGxldGVPbmJvYXJkaW5nKCkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgY29tcGxldGVkT25ib2FyZGluZzogdHJ1ZSxcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGBmaXJzdFRpbWVGbG93VHlwZWAgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBJbmRpY2F0ZXMgdGhlIHR5cGUgb2YgZmlyc3QgdGltZSBmbG93IC0gY3JlYXRlIG9yIGltcG9ydCAtIHRoZSB1c2VyIHdpc2hlcyB0byBmb2xsb3dcbiAgICpcbiAgICovXG4gIHNldEZpcnN0VGltZUZsb3dUeXBlKHR5cGUpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgZmlyc3RUaW1lRmxvd1R5cGU6IHR5cGUgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJpbmcgYSBzaXRlIGFzIGhhdmluZyBpbml0aWF0ZWQgb25ib2FyZGluZ1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gb2YgdGhlIHNpdGUgcmVnaXN0ZXJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYklkIC0gVGhlIGlkIG9mIHRoZSB0YWIgcmVnaXN0ZXJpbmdcbiAgICovXG4gIHJlZ2lzdGVyT25ib2FyZGluZyA9IGFzeW5jIChsb2NhdGlvbiwgdGFiSWQpID0+IHtcbiAgICBpZiAodGhpcy5jb21wbGV0ZWRPbmJvYXJkaW5nKSB7XG4gICAgICBsb2cuZGVidWcoJ0lnbm9yaW5nIHJlZ2lzdGVyT25ib2FyZGluZzsgdXNlciBhbHJlYWR5IG9uYm9hcmRlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbmJvYXJkaW5nVGFicyA9IHsgLi4udGhpcy5zdG9yZS5nZXRTdGF0ZSgpLm9uYm9hcmRpbmdUYWJzIH07XG4gICAgaWYgKCFvbmJvYXJkaW5nVGFic1tsb2NhdGlvbl0gfHwgb25ib2FyZGluZ1RhYnNbbG9jYXRpb25dICE9PSB0YWJJZCkge1xuICAgICAgbG9nLmRlYnVnKFxuICAgICAgICBgUmVnaXN0ZXJpbmcgb25ib2FyZGluZyB0YWIgYXQgbG9jYXRpb24gJyR7bG9jYXRpb259JyB3aXRoIHRhYklkICcke3RhYklkfSdgLFxuICAgICAgKTtcbiAgICAgIG9uYm9hcmRpbmdUYWJzW2xvY2F0aW9uXSA9IHRhYklkO1xuICAgICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IG9uYm9hcmRpbmdUYWJzIH0pO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgQk4gZnJvbSAnYm4uanMnO1xuaW1wb3J0IGNyZWF0ZUlkIGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3JhbmRvbS1pZCc7XG5pbXBvcnQgeyBiblRvSGV4IH0gZnJvbSAnLi4vbGliL3V0aWwnO1xuaW1wb3J0IGdldEZldGNoV2l0aFRpbWVvdXQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvZmV0Y2gtd2l0aC10aW1lb3V0JztcblxuaW1wb3J0IHtcbiAgVFJBTlNBQ1RJT05fVFlQRVMsXG4gIFRSQU5TQUNUSU9OX1NUQVRVU0VTLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7XG4gIENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQLFxuICBDSEFJTl9JRF9UT19UWVBFX01BUCxcbiAgR09FUkxJX0NIQUlOX0lELFxuICBLT1ZBTl9DSEFJTl9JRCxcbiAgTUFJTk5FVF9DSEFJTl9JRCxcbiAgUklOS0VCWV9DSEFJTl9JRCxcbiAgUk9QU1RFTl9DSEFJTl9JRCxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7IFNFQ09ORCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdGltZSc7XG5cbmNvbnN0IGZldGNoV2l0aFRpbWVvdXQgPSBnZXRGZXRjaFdpdGhUaW1lb3V0KFNFQ09ORCAqIDMwKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJykuVHJhbnNhY3Rpb25NZXRhfSBUcmFuc2FjdGlvbk1ldGFcbiAqL1xuXG4vKipcbiAqIEEgdHJhbnNhY3Rpb24gb2JqZWN0IGluIHRoZSBmb3JtYXQgcmV0dXJuZWQgYnkgdGhlIEV0aGVyc2NhbiBBUEkuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgaXMgbm90IGFuIGV4aGF1c3RpdmUgdHlwZSBkZWZpbml0b247IG9ubHkgdGhlIHByb3BlcnRpZXMgd2UgdXNlIGFyZSBkZWZpbmVkXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRXRoZXJzY2FuVHJhbnNhY3Rpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBibG9ja051bWJlciAtIFRoZSBudW1iZXIgb2YgdGhlIGJsb2NrIHRoaXMgdHJhbnNhY3Rpb24gd2FzIGZvdW5kIGluLCBpbiBkZWNpbWFsXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZnJvbSAtIFRoZSBoZXgtcHJlZml4ZWQgYWRkcmVzcyBvZiB0aGUgc2VuZGVyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZ2FzIC0gVGhlIGdhcyBsaW1pdCwgaW4gZGVjaW1hbCBHV0VJXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2dhc1ByaWNlXSAtIFRoZSBnYXMgcHJpY2UsIGluIGRlY2ltYWwgV0VJXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21heEZlZVBlckdhc10gLSBUaGUgbWF4aW11bSBmZWUgcGVyIGdhcywgaW5jbHVzaXZlIG9mIHRpcCwgaW4gZGVjaW1hbCBXRUlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbWF4UHJpb3JpdHlGZWVQZXJHYXNdIC0gVGhlIG1heGltdW0gdGlwIHBlciBnYXMgaW4gZGVjaW1hbCBXRUlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoYXNoIC0gVGhlIGhleC1wcmVmaXhlZCB0cmFuc2FjdGlvbiBoYXNoXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaXNFcnJvciAtIFdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIHdhcyBjb25maXJtZWQgb3IgZmFpbGVkICgwIGZvciBjb25maXJtZWQsIDEgZm9yIGZhaWxlZClcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBub25jZSAtIFRoZSB0cmFuc2FjdGlvbiBub25jZSwgaW4gZGVjaW1hbFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRpbWVTdGFtcCAtIFRoZSB0aW1lc3RhbXAgZm9yIHRoZSB0cmFuc2FjdGlvbiwgaW4gc2Vjb25kc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHRvIC0gVGhlIGhleC1wcmVmaXhlZCBhZGRyZXNzIG9mIHRoZSByZWNpcGllbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBhbW91bnQgb2YgRVRIIHNlbnQgaW4gdGhpcyB0cmFuc2FjdGlvbiwgaW4gZGVjaW1hbCBXRUlcbiAqL1xuXG4vKipcbiAqIFRoaXMgY29udHJvbGxlciBpcyByZXNwb25zaWJsZSBmb3IgcmV0cmlldmluZyBpbmNvbWluZyB0cmFuc2FjdGlvbnMuIEV0aGVyc2NhbiBpcyBwb2xsZWQgb25jZSBldmVyeSBibG9jayB0byBjaGVja1xuICogZm9yIG5ldyBpbmNvbWluZyB0cmFuc2FjdGlvbnMgZm9yIHRoZSBjdXJyZW50IHNlbGVjdGVkIGFjY291bnQgb24gdGhlIGN1cnJlbnQgbmV0d29ya1xuICpcbiAqIE5vdGUgdGhhdCBvbmx5IHRoZSBidWlsdC1pbiBJbmZ1cmEgbmV0d29ya3MgYXJlIHN1cHBvcnRlZCAoaS5lLiBhbnl0aGluZyBpbiBgSU5GVVJBX1BST1ZJREVSX1RZUEVTYCkuIFdlIHdpbGwgbm90XG4gKiBhdHRlbXB0IHRvIHJldHJpZXZlIGluY29taW5nIHRyYW5zYWN0aW9ucyBvbiBhbnkgY3VzdG9tIFJQQyBlbmRwb2ludHMuXG4gKi9cbmNvbnN0IGV0aGVyc2NhblN1cHBvcnRlZE5ldHdvcmtzID0gW1xuICBHT0VSTElfQ0hBSU5fSUQsXG4gIEtPVkFOX0NIQUlOX0lELFxuICBNQUlOTkVUX0NIQUlOX0lELFxuICBSSU5LRUJZX0NIQUlOX0lELFxuICBST1BTVEVOX0NIQUlOX0lELFxuXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYmxvY2tUcmFja2VyLFxuICAgICAgb25OZXR3b3JrRGlkQ2hhbmdlLFxuICAgICAgZ2V0Q3VycmVudENoYWluSWQsXG4gICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgfSA9IG9wdHM7XG4gICAgdGhpcy5ibG9ja1RyYWNrZXIgPSBibG9ja1RyYWNrZXI7XG4gICAgdGhpcy5nZXRDdXJyZW50Q2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkO1xuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyID0gcHJlZmVyZW5jZXNDb250cm9sbGVyO1xuXG4gICAgdGhpcy5fb25MYXRlc3RCbG9jayA9IGFzeW5jIChuZXdCbG9ja051bWJlckhleCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRBZGRyZXNzID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0U2VsZWN0ZWRBZGRyZXNzKCk7XG4gICAgICBjb25zdCBuZXdCbG9ja051bWJlckRlYyA9IHBhcnNlSW50KG5ld0Jsb2NrTnVtYmVySGV4LCAxNik7XG4gICAgICBhd2FpdCB0aGlzLl91cGRhdGUoc2VsZWN0ZWRBZGRyZXNzLCBuZXdCbG9ja051bWJlckRlYyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGluaXRTdGF0ZSA9IHtcbiAgICAgIGluY29taW5nVHJhbnNhY3Rpb25zOiB7fSxcbiAgICAgIGluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2NrQnlDaGFpbklkOiB7XG4gICAgICAgIFtHT0VSTElfQ0hBSU5fSURdOiBudWxsLFxuICAgICAgICBbS09WQU5fQ0hBSU5fSURdOiBudWxsLFxuICAgICAgICBbTUFJTk5FVF9DSEFJTl9JRF06IG51bGwsXG4gICAgICAgIFtSSU5LRUJZX0NIQUlOX0lEXTogbnVsbCxcbiAgICAgICAgW1JPUFNURU5fQ0hBSU5fSURdOiBudWxsLFxuICAgICAgfSxcbiAgICAgIC4uLm9wdHMuaW5pdFN0YXRlLFxuICAgIH07XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoaW5pdFN0YXRlKTtcblxuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZShcbiAgICAgIHByZXZpb3VzVmFsdWVDb21wYXJhdG9yKChwcmV2U3RhdGUsIGN1cnJTdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZmVhdHVyZUZsYWdzOiB7XG4gICAgICAgICAgICBzaG93SW5jb21pbmdUcmFuc2FjdGlvbnM6IHByZXZTaG93SW5jb21pbmdUcmFuc2FjdGlvbnMsXG4gICAgICAgICAgfSA9IHt9LFxuICAgICAgICB9ID0gcHJldlN0YXRlO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZmVhdHVyZUZsYWdzOiB7XG4gICAgICAgICAgICBzaG93SW5jb21pbmdUcmFuc2FjdGlvbnM6IGN1cnJTaG93SW5jb21pbmdUcmFuc2FjdGlvbnMsXG4gICAgICAgICAgfSA9IHt9LFxuICAgICAgICB9ID0gY3VyclN0YXRlO1xuXG4gICAgICAgIGlmIChjdXJyU2hvd0luY29taW5nVHJhbnNhY3Rpb25zID09PSBwcmV2U2hvd0luY29taW5nVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZTaG93SW5jb21pbmdUcmFuc2FjdGlvbnMgJiYgIWN1cnJTaG93SW5jb21pbmdUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICB9LCB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpKSxcbiAgICApO1xuXG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlKFxuICAgICAgcHJldmlvdXNWYWx1ZUNvbXBhcmF0b3IoYXN5bmMgKHByZXZTdGF0ZSwgY3VyclN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRBZGRyZXNzOiBwcmV2U2VsZWN0ZWRBZGRyZXNzIH0gPSBwcmV2U3RhdGU7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRBZGRyZXNzOiBjdXJyU2VsZWN0ZWRBZGRyZXNzIH0gPSBjdXJyU3RhdGU7XG5cbiAgICAgICAgaWYgKGN1cnJTZWxlY3RlZEFkZHJlc3MgPT09IHByZXZTZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlKGN1cnJTZWxlY3RlZEFkZHJlc3MpO1xuICAgICAgfSwgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKSksXG4gICAgKTtcblxuICAgIG9uTmV0d29ya0RpZENoYW5nZShhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0U2VsZWN0ZWRBZGRyZXNzKCk7XG4gICAgICBhd2FpdCB0aGlzLl91cGRhdGUoYWRkcmVzcyk7XG4gICAgfSk7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBjb25zdCB7IGZlYXR1cmVGbGFncyA9IHt9IH0gPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHsgc2hvd0luY29taW5nVHJhbnNhY3Rpb25zIH0gPSBmZWF0dXJlRmxhZ3M7XG5cbiAgICBpZiAoIXNob3dJbmNvbWluZ1RyYW5zYWN0aW9ucykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYmxvY2tUcmFja2VyLnJlbW92ZUxpc3RlbmVyKCdsYXRlc3QnLCB0aGlzLl9vbkxhdGVzdEJsb2NrKTtcbiAgICB0aGlzLmJsb2NrVHJhY2tlci5hZGRMaXN0ZW5lcignbGF0ZXN0JywgdGhpcy5fb25MYXRlc3RCbG9jayk7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIHRoaXMuYmxvY2tUcmFja2VyLnJlbW92ZUxpc3RlbmVyKCdsYXRlc3QnLCB0aGlzLl9vbkxhdGVzdEJsb2NrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBjb3JyZWN0IGJsb2NrIG51bWJlciB0byBiZWdpbiBsb29raW5nIGZvciBuZXcgdHJhbnNhY3Rpb25zXG4gICAqIGZyb20sIGZldGNoZXMgdGhlIHRyYW5zYWN0aW9ucyBhbmQgdGhlbiBzYXZlcyB0aGVtIGFuZCB0aGUgbmV4dCBibG9ja1xuICAgKiBudW1iZXIgdG8gYmVnaW4gZmV0Y2hpbmcgZnJvbSBpbiBzdGF0ZS4gQmxvY2sgbnVtYmVycyBhbmQgdHJhbnNhY3Rpb25zIGFyZVxuICAgKiBzdG9yZWQgcGVyIGNoYWluSWQuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gYWRkcmVzcyB0byBsb29rdXAgdHJhbnNhY3Rpb25zIGZvclxuICAgKiBAcGFyYW0ge251bWJlcn0gW25ld0Jsb2NrTnVtYmVyRGVjXSAtIGJsb2NrIG51bWJlciB0byBiZWdpbiBmZXRjaGluZyBmcm9tXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgYXN5bmMgX3VwZGF0ZShhZGRyZXNzLCBuZXdCbG9ja051bWJlckRlYykge1xuICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLmdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgaWYgKCFldGhlcnNjYW5TdXBwb3J0ZWROZXR3b3Jrcy5pbmNsdWRlcyhjaGFpbklkKSB8fCAhYWRkcmVzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3QgY3VycmVudEJsb2NrID0gcGFyc2VJbnQodGhpcy5ibG9ja1RyYWNrZXIuZ2V0Q3VycmVudEJsb2NrKCksIDE2KTtcblxuICAgICAgY29uc3QgbW9zdFJlY2VudGx5RmV0Y2hlZEJsb2NrID1cbiAgICAgICAgY3VycmVudFN0YXRlLmluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2NrQnlDaGFpbklkW2NoYWluSWRdO1xuICAgICAgY29uc3QgYmxvY2tUb0ZldGNoRnJvbSA9XG4gICAgICAgIG1vc3RSZWNlbnRseUZldGNoZWRCbG9jayA/PyBuZXdCbG9ja051bWJlckRlYyA/PyBjdXJyZW50QmxvY2s7XG5cbiAgICAgIGNvbnN0IG5ld0luY29taW5nVHhzID0gYXdhaXQgdGhpcy5fZ2V0TmV3SW5jb21pbmdUcmFuc2FjdGlvbnMoXG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGJsb2NrVG9GZXRjaEZyb20sXG4gICAgICAgIGNoYWluSWQsXG4gICAgICApO1xuXG4gICAgICBsZXQgbmV3TW9zdFJlY2VudGx5RmV0Y2hlZEJsb2NrID0gYmxvY2tUb0ZldGNoRnJvbTtcblxuICAgICAgbmV3SW5jb21pbmdUeHMuZm9yRWFjaCgodHgpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR4LmJsb2NrTnVtYmVyICYmXG4gICAgICAgICAgcGFyc2VJbnQobmV3TW9zdFJlY2VudGx5RmV0Y2hlZEJsb2NrLCAxMCkgPFxuICAgICAgICAgICAgcGFyc2VJbnQodHguYmxvY2tOdW1iZXIsIDEwKVxuICAgICAgICApIHtcbiAgICAgICAgICBuZXdNb3N0UmVjZW50bHlGZXRjaGVkQmxvY2sgPSBwYXJzZUludCh0eC5ibG9ja051bWJlciwgMTApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICAgIGluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2NrQnlDaGFpbklkOiB7XG4gICAgICAgICAgLi4uY3VycmVudFN0YXRlLmluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2NrQnlDaGFpbklkLFxuICAgICAgICAgIFtjaGFpbklkXTogbmV3TW9zdFJlY2VudGx5RmV0Y2hlZEJsb2NrICsgMSxcbiAgICAgICAgfSxcbiAgICAgICAgaW5jb21pbmdUcmFuc2FjdGlvbnM6IG5ld0luY29taW5nVHhzLnJlZHVjZShcbiAgICAgICAgICAodHJhbnNhY3Rpb25zLCB0eCkgPT4ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25zW3R4Lmhhc2hdID0gdHg7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25zO1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uY3VycmVudFN0YXRlLmluY29taW5nVHJhbnNhY3Rpb25zLFxuICAgICAgICAgIH0sXG4gICAgICAgICksXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBmZXRjaGVzIHRyYW5zYWN0aW9ucyBmb3IgdGhlIGdpdmVuIGFkZHJlc3MgYW5kIGNoYWluLCB2aWEgZXRoZXJzY2FuLCB0aGVuXG4gICAqIHByb2Nlc3NlcyB0aGUgZGF0YSBpbnRvIHRoZSBuZWNlc3Nhcnkgc2hhcGUgZm9yIHVzYWdlIGluIHRoaXMgY29udHJvbGxlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFthZGRyZXNzXSAtIEFkZHJlc3MgdG8gZmV0Y2ggdHJhbnNhY3Rpb25zIGZvclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21CbG9ja10gLSBCbG9jayB0byBsb29rIGZvciB0cmFuc2FjdGlvbnMgYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFpbklkXSAtIFRoZSBjaGFpbklkIGZvciB0aGUgY3VycmVudCBuZXR3b3JrXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbk1ldGFbXX1cbiAgICovXG4gIGFzeW5jIF9nZXROZXdJbmNvbWluZ1RyYW5zYWN0aW9ucyhhZGRyZXNzLCBmcm9tQmxvY2ssIGNoYWluSWQpIHtcbiAgICBjb25zdCBldGhlcnNjYW5TdWJkb21haW4gPVxuICAgICAgY2hhaW5JZCA9PT0gTUFJTk5FVF9DSEFJTl9JRFxuICAgICAgICA/ICdhcGknXG4gICAgICAgIDogYGFwaS0ke0NIQUlOX0lEX1RPX1RZUEVfTUFQW2NoYWluSWRdfWA7XG5cbiAgICBjb25zdCBhcGlVcmwgPSBgaHR0cHM6Ly8ke2V0aGVyc2NhblN1YmRvbWFpbn0uZXRoZXJzY2FuLmlvYDtcbiAgICBsZXQgdXJsID0gYCR7YXBpVXJsfS9hcGk/bW9kdWxlPWFjY291bnQmYWN0aW9uPXR4bGlzdCZhZGRyZXNzPSR7YWRkcmVzc30mdGFnPWxhdGVzdCZwYWdlPTFgO1xuXG4gICAgaWYgKGZyb21CbG9jaykge1xuICAgICAgdXJsICs9IGAmc3RhcnRCbG9jaz0ke3BhcnNlSW50KGZyb21CbG9jaywgMTApfWA7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoVGltZW91dCh1cmwpO1xuICAgIGNvbnN0IHsgc3RhdHVzLCByZXN1bHQgfSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBsZXQgbmV3SW5jb21pbmdUeHMgPSBbXTtcbiAgICBpZiAoc3RhdHVzID09PSAnMScgJiYgQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZW1vdGVUeExpc3QgPSB7fTtcbiAgICAgIGNvbnN0IHJlbW90ZVR4cyA9IFtdO1xuICAgICAgcmVzdWx0LmZvckVhY2goKHR4KSA9PiB7XG4gICAgICAgIGlmICghcmVtb3RlVHhMaXN0W3R4Lmhhc2hdKSB7XG4gICAgICAgICAgcmVtb3RlVHhzLnB1c2godGhpcy5fbm9ybWFsaXplVHhGcm9tRXRoZXJzY2FuKHR4LCBjaGFpbklkKSk7XG4gICAgICAgICAgcmVtb3RlVHhMaXN0W3R4Lmhhc2hdID0gMTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG5ld0luY29taW5nVHhzID0gcmVtb3RlVHhzLmZpbHRlcihcbiAgICAgICAgKHR4KSA9PiB0eC50eFBhcmFtcz8udG8/LnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgICk7XG4gICAgICBuZXdJbmNvbWluZ1R4cy5zb3J0KChhLCBiKSA9PiAoYS50aW1lIDwgYi50aW1lID8gLTEgOiAxKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdJbmNvbWluZ1R4cztcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc211dGVzIGEgRXRoZXJzY2FuVHJhbnNhY3Rpb24gaW50byBhIFRyYW5zYWN0aW9uTWV0YVxuICAgKiBAcGFyYW0ge0V0aGVyc2NhblRyYW5zYWN0aW9ufSBldGhlcnNjYW5UcmFuc2FjdGlvbiAtIHRoZSB0cmFuc2FjdGlvbiB0byBub3JtYWxpemVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYWluSWQgLSBUaGUgY2hhaW5JZCBvZiB0aGUgY3VycmVudCBuZXR3b3JrXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbk1ldGF9XG4gICAqL1xuICBfbm9ybWFsaXplVHhGcm9tRXRoZXJzY2FuKGV0aGVyc2NhblRyYW5zYWN0aW9uLCBjaGFpbklkKSB7XG4gICAgY29uc3QgdGltZSA9IHBhcnNlSW50KGV0aGVyc2NhblRyYW5zYWN0aW9uLnRpbWVTdGFtcCwgMTApICogMTAwMDtcbiAgICBjb25zdCBzdGF0dXMgPVxuICAgICAgZXRoZXJzY2FuVHJhbnNhY3Rpb24uaXNFcnJvciA9PT0gJzAnXG4gICAgICAgID8gVFJBTlNBQ1RJT05fU1RBVFVTRVMuQ09ORklSTUVEXG4gICAgICAgIDogVFJBTlNBQ1RJT05fU1RBVFVTRVMuRkFJTEVEO1xuICAgIGNvbnN0IHR4UGFyYW1zID0ge1xuICAgICAgZnJvbTogZXRoZXJzY2FuVHJhbnNhY3Rpb24uZnJvbSxcbiAgICAgIGdhczogYm5Ub0hleChuZXcgQk4oZXRoZXJzY2FuVHJhbnNhY3Rpb24uZ2FzKSksXG4gICAgICBub25jZTogYm5Ub0hleChuZXcgQk4oZXRoZXJzY2FuVHJhbnNhY3Rpb24ubm9uY2UpKSxcbiAgICAgIHRvOiBldGhlcnNjYW5UcmFuc2FjdGlvbi50byxcbiAgICAgIHZhbHVlOiBiblRvSGV4KG5ldyBCTihldGhlcnNjYW5UcmFuc2FjdGlvbi52YWx1ZSkpLFxuICAgIH07XG5cbiAgICBpZiAoZXRoZXJzY2FuVHJhbnNhY3Rpb24uZ2FzUHJpY2UpIHtcbiAgICAgIHR4UGFyYW1zLmdhc1ByaWNlID0gYm5Ub0hleChuZXcgQk4oZXRoZXJzY2FuVHJhbnNhY3Rpb24uZ2FzUHJpY2UpKTtcbiAgICB9IGVsc2UgaWYgKGV0aGVyc2NhblRyYW5zYWN0aW9uLm1heEZlZVBlckdhcykge1xuICAgICAgdHhQYXJhbXMubWF4RmVlUGVyR2FzID0gYm5Ub0hleChcbiAgICAgICAgbmV3IEJOKGV0aGVyc2NhblRyYW5zYWN0aW9uLm1heEZlZVBlckdhcyksXG4gICAgICApO1xuICAgICAgdHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBiblRvSGV4KFxuICAgICAgICBuZXcgQk4oZXRoZXJzY2FuVHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2tOdW1iZXI6IGV0aGVyc2NhblRyYW5zYWN0aW9uLmJsb2NrTnVtYmVyLFxuICAgICAgaWQ6IGNyZWF0ZUlkKCksXG4gICAgICBjaGFpbklkLFxuICAgICAgbWV0YW1hc2tOZXR3b3JrSWQ6IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQW2NoYWluSWRdLFxuICAgICAgc3RhdHVzLFxuICAgICAgdGltZSxcbiAgICAgIHR4UGFyYW1zLFxuICAgICAgaGFzaDogZXRoZXJzY2FuVHJhbnNhY3Rpb24uaGFzaCxcbiAgICAgIHR5cGU6IFRSQU5TQUNUSU9OX1RZUEVTLklOQ09NSU5HLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gd2l0aCBhcml0eSAxIHRoYXQgY2FjaGVzIHRoZSBhcmd1bWVudCB0aGF0IHRoZSBmdW5jdGlvblxuICogaXMgY2FsbGVkIHdpdGggYW5kIGludm9rZXMgdGhlIGNvbXBhcmF0b3Igd2l0aCBib3RoIHRoZSBjYWNoZWQsIHByZXZpb3VzLFxuICogdmFsdWUgYW5kIHRoZSBjdXJyZW50IHZhbHVlLiBJZiBzcGVjaWZpZWQsIHRoZSBpbml0aWFsVmFsdWUgd2lsbCBiZSBwYXNzZWRcbiAqIGluIGFzIHRoZSBwcmV2aW91cyB2YWx1ZSBvbiB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiB0aGUgcmV0dXJuZWQgbWV0aG9kLlxuICogQHRlbXBsYXRlIEFcbiAqIEBwYXJhbXMge0E9fSB0eXBlIG9mIGNvbXBhcmVkIHZhbHVlXG4gKiBAcGFyYW0geyhwcmV2VmFsdWU6IEEsIG5leHRWYWx1ZTogQSkgPT4gdm9pZH0gY29tcGFyYXRvciAtIG1ldGhvZCB0byBjb21wYXJlXG4gKiAgcHJldmlvdXMgYW5kIG5leHQgdmFsdWVzLlxuICogQHBhcmFtIHtBfSBbaW5pdGlhbFZhbHVlXSAtIGluaXRpYWwgdmFsdWUgdG8gc3VwcGx5IHRvIHByZXZWYWx1ZVxuICogIG9uIGZpcnN0IGNhbGwgb2YgdGhlIG1ldGhvZC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBwcmV2aW91c1ZhbHVlQ29tcGFyYXRvcihjb21wYXJhdG9yLCBpbml0aWFsVmFsdWUpIHtcbiAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgbGV0IGNhY2hlO1xuICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvcihpbml0aWFsVmFsdWUgPz8gdmFsdWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wYXJhdG9yKGNhY2hlLCB2YWx1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNhY2hlID0gdmFsdWU7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVN0b3JlIH0gZnJvbSAnQG1ldGFtYXNrL29icy1zdG9yZSc7XG5pbXBvcnQgeyBidWZmZXJUb0hleCwgc3RyaXBIZXhQcmVmaXggfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuaW1wb3J0IHsgZXRoRXJyb3JzIH0gZnJvbSAnZXRoLXJwYy1lcnJvcnMnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgeyBNRVNTQUdFX1RZUEUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XG5pbXBvcnQgeyBNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUyB9IGZyb20gJy4uL21ldGFtYXNrLWNvbnRyb2xsZXInO1xuaW1wb3J0IGNyZWF0ZUlkIGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3JhbmRvbS1pZCc7XG5pbXBvcnQgeyBhZGRIZXhQcmVmaXggfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBoZXhSZSA9IC9eWzAtOUEtRmEtZl0rJC9ndTtcblxuLyoqXG4gKiBSZXByZXNlbnRzLCBhbmQgY29udGFpbnMgZGF0YSBhYm91dCwgYW4gJ2V0aF9kZWNyeXB0JyB0eXBlIGRlY3J5cHRpb24gcmVxdWVzdC4gVGhlc2UgYXJlIGNyZWF0ZWQgd2hlbiBhXG4gKiBkZWNyeXB0aW9uIGZvciBhbiBldGhfZGVjcnlwdCBjYWxsIGlzIHJlcXVlc3RlZC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWNyeXB0TWVzc2FnZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlkIEFuIGlkIHRvIHRyYWNrIGFuZCBpZGVudGlmeSB0aGUgbWVzc2FnZSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtc2dQYXJhbXMgVGhlIHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgZGVjcnlwdE1lc3NhZ2UgbWV0aG9kIG9uY2UgdGhlIGRlY3J5cHRpb24gcmVxdWVzdCBpc1xuICogYXBwcm92ZWQuXG4gKiBAcHJvcGVydHkge09iamVjdH0gbXNnUGFyYW1zLm1ldGFtYXNrSWQgQWRkZWQgdG8gbXNnUGFyYW1zIGZvciB0cmFja2luZyBhbmQgaWRlbnRpZmljYXRpb24gd2l0aGluIE1ldGFNYXNrLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1zZ1BhcmFtcy5kYXRhIEEgaGV4IHN0cmluZyBjb252ZXJzaW9uIG9mIHRoZSByYXcgYnVmZmVyIGRhdGEgb2YgdGhlIGRlY3J5cHRpb24gcmVxdWVzdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWUgVGhlIGVwb2NoIHRpbWUgYXQgd2hpY2ggdGhlIHRoaXMgbWVzc2FnZSB3YXMgY3JlYXRlZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXR1cyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVjcnlwdGlvbiByZXF1ZXN0IGlzICd1bmFwcHJvdmVkJywgJ2FwcHJvdmVkJywgJ2RlY3J5cHRlZCcgb3IgJ3JlamVjdGVkJ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgVGhlIGpzb24tcHJjIGRlY3J5cHRpb24gbWV0aG9kIGZvciB3aGljaCBhIGRlY3J5cHRpb24gcmVxdWVzdCBoYXMgYmVlbiBtYWRlLiBBICdNZXNzYWdlJyB3aWxsXG4gKiBhbHdheXMgaGF2ZSBhICdldGhfZGVjcnlwdCcgdHlwZS5cbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVjcnlwdE1lc3NhZ2VNYW5hZ2VyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENvbnRyb2xsZXIgaW4gY2hhcmdlIG9mIG1hbmFnaW5nIC0gc3RvcmluZywgYWRkaW5nLCByZW1vdmluZywgdXBkYXRpbmcgLSBEZWNyeXB0TWVzc2FnZS5cbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gRGVjcnlwdE1lc3NhZ2VNYW5hZ2VyXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtZW1TdG9yZSBUaGUgb2JzZXJ2YWJsZSBzdG9yZSB3aGVyZSBEZWNyeXB0TWVzc2FnZSBhcmUgc2F2ZWQuXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtZW1TdG9yZS51bmFwcHJvdmVkRGVjcnlwdE1zZ3MgQSBjb2xsZWN0aW9uIG9mIGFsbCBEZWNyeXB0TWVzc2FnZXMgaW4gdGhlICd1bmFwcHJvdmVkJyBzdGF0ZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gbWVtU3RvcmUudW5hcHByb3ZlZERlY3J5cHRNc2dDb3VudCBUaGUgY291bnQgb2YgYWxsIERlY3J5cHRNZXNzYWdlcyBpbiB0aGlzLm1lbVN0b3JlLnVuYXBwcm92ZWREZWNyeXB0TXNnc1xuICAgKiBAcHJvcGVydHkge0FycmF5fSBtZXNzYWdlcyBIb2xkcyBhbGwgbWVzc2FnZXMgdGhhdCBoYXZlIGJlZW4gY3JlYXRlZCBieSB0aGlzIERlY3J5cHRNZXNzYWdlTWFuYWdlclxuICAgKlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tZW1TdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgdW5hcHByb3ZlZERlY3J5cHRNc2dzOiB7fSxcbiAgICAgIHVuYXBwcm92ZWREZWNyeXB0TXNnQ291bnQ6IDAsXG4gICAgfSk7XG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMubWV0cmljc0V2ZW50ID0gb3B0cy5tZXRyaWNzRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSBudW1iZXIgb2YgJ3VuYXBwcm92ZWQnIERlY3J5cHRNZXNzYWdlcyBpbiB0aGlzLm1lc3NhZ2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgJ3VuYXBwcm92ZWQnIERlY3J5cHRNZXNzYWdlcyBpbiB0aGlzLm1lc3NhZ2VzXG4gICAqXG4gICAqL1xuICBnZXQgdW5hcHByb3ZlZERlY3J5cHRNc2dDb3VudCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRVbmFwcHJvdmVkTXNncygpKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSAndW5hcHByb3ZlZCcgRGVjcnlwdE1lc3NhZ2VzIGluIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gQW4gaW5kZXggb2YgRGVjcnlwdE1lc3NhZ2UgaWRzIHRvIERlY3J5cHRNZXNzYWdlcywgZm9yIGFsbCAndW5hcHByb3ZlZCcgRGVjcnlwdE1lc3NhZ2VzIGluXG4gICAqIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICovXG4gIGdldFVuYXBwcm92ZWRNc2dzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzXG4gICAgICAuZmlsdGVyKChtc2cpID0+IG1zZy5zdGF0dXMgPT09ICd1bmFwcHJvdmVkJylcbiAgICAgIC5yZWR1Y2UoKHJlc3VsdCwgbXNnKSA9PiB7XG4gICAgICAgIHJlc3VsdFttc2cuaWRdID0gbXNnO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRGVjcnlwdE1lc3NhZ2Ugd2l0aCBhbiAndW5hcHByb3ZlZCcgc3RhdHVzIHVzaW5nIHRoZSBwYXNzZWQgbXNnUGFyYW1zLiB0aGlzLmFkZE1zZyBpcyBjYWxsZWQgdG8gYWRkXG4gICAqIHRoZSBuZXcgRGVjcnlwdE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlIHVuYXBwcm92ZWQgRGVjcnlwdE1lc3NhZ2VzIGZyb20gdGhhdCBsaXN0IHRvXG4gICAqIHRoaXMubWVtU3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgZXRoX2RlY3J5cHQgY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3JlcV0gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59IFRoZSByYXcgZGVjcnlwdGVkIG1lc3NhZ2UgY29udGVudHNcbiAgICpcbiAgICovXG4gIGFkZFVuYXBwcm92ZWRNZXNzYWdlQXN5bmMobXNnUGFyYW1zLCByZXEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCFtc2dQYXJhbXMuZnJvbSkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdNZXRhTWFzayBEZWNyeXB0aW9uOiBmcm9tIGZpZWxkIGlzIHJlcXVpcmVkLicpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbXNnSWQgPSB0aGlzLmFkZFVuYXBwcm92ZWRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxKTtcbiAgICAgIHRoaXMub25jZShgJHttc2dJZH06ZmluaXNoZWRgLCAoZGF0YSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSAnZGVjcnlwdGVkJzpcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YS5yYXdEYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIGV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KFxuICAgICAgICAgICAgICAgICdNZXRhTWFzayBEZWNyeXB0aW9uOiBVc2VyIGRlbmllZCBtZXNzYWdlIGRlY3J5cHRpb24uJyxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSAnZXJyb3JlZCc6XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGlzIG1lc3NhZ2UgY2Fubm90IGJlIGRlY3J5cHRlZCcpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYE1ldGFNYXNrIERlY3J5cHRpb246IFVua25vd24gcHJvYmxlbTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgIG1zZ1BhcmFtcyxcbiAgICAgICAgICAgICAgICApfWAsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IERlY3J5cHRNZXNzYWdlIHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1zZ1BhcmFtcy4gdGhpcy5hZGRNc2cgaXMgY2FsbGVkIHRvIGFkZFxuICAgKiB0aGUgbmV3IERlY3J5cHRNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZSB1bmFwcHJvdmVkIERlY3J5cHRNZXNzYWdlcyBmcm9tIHRoYXQgbGlzdCB0b1xuICAgKiB0aGlzLm1lbVN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIGV0aF9kZWNyeXB0TXNnIGNhbGwgdG8gYmUgbWFkZSBhZnRlciB0aGUgbWVzc2FnZSBpcyBhcHByb3ZlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtyZXFdIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpblxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaWQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgRGVjcnlwdE1lc3NhZ2UuXG4gICAqXG4gICAqL1xuICBhZGRVbmFwcHJvdmVkTWVzc2FnZShtc2dQYXJhbXMsIHJlcSkge1xuICAgIGxvZy5kZWJ1ZyhcbiAgICAgIGBEZWNyeXB0TWVzc2FnZU1hbmFnZXIgYWRkVW5hcHByb3ZlZE1lc3NhZ2U6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIG1zZ1BhcmFtcyxcbiAgICAgICl9YCxcbiAgICApO1xuICAgIC8vIGFkZCBvcmlnaW4gZnJvbSByZXF1ZXN0XG4gICAgaWYgKHJlcSkge1xuICAgICAgbXNnUGFyYW1zLm9yaWdpbiA9IHJlcS5vcmlnaW47XG4gICAgfVxuICAgIG1zZ1BhcmFtcy5kYXRhID0gdGhpcy5ub3JtYWxpemVNc2dEYXRhKG1zZ1BhcmFtcy5kYXRhKTtcbiAgICAvLyBjcmVhdGUgdHhEYXRhIG9iaiB3aXRoIHBhcmFtZXRlcnMgYW5kIG1ldGEgZGF0YVxuICAgIGNvbnN0IHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCBtc2dJZCA9IGNyZWF0ZUlkKCk7XG4gICAgY29uc3QgbXNnRGF0YSA9IHtcbiAgICAgIGlkOiBtc2dJZCxcbiAgICAgIG1zZ1BhcmFtcyxcbiAgICAgIHRpbWUsXG4gICAgICBzdGF0dXM6ICd1bmFwcHJvdmVkJyxcbiAgICAgIHR5cGU6IE1FU1NBR0VfVFlQRS5FVEhfREVDUllQVCxcbiAgICB9O1xuICAgIHRoaXMuYWRkTXNnKG1zZ0RhdGEpO1xuXG4gICAgLy8gc2lnbmFsIHVwZGF0ZVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJyk7XG4gICAgcmV0dXJuIG1zZ0lkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBwYXNzZWQgRGVjcnlwdE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIGNhbGxzIHRoaXMuX3NhdmVNc2dMaXN0KCkgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBEZWNyeXB0TWVzc2FnZXMgZnJvbSB0aGF0XG4gICAqIGxpc3QgdG8gdGhpcy5tZW1TdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtc2cgVGhlIERlY3J5cHRNZXNzYWdlIHRvIGFkZCB0byB0aGlzLm1lc3NhZ2VzXG4gICAqXG4gICAqL1xuICBhZGRNc2cobXNnKSB7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1zZyk7XG4gICAgdGhpcy5fc2F2ZU1zZ0xpc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIERlY3J5cHRNZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgVGhlIGlkIG9mIHRoZSBEZWNyeXB0TWVzc2FnZSB0byBnZXRcbiAgICogQHJldHVybnMge0RlY3J5cHRNZXNzYWdlfHVuZGVmaW5lZH0gVGhlIERlY3J5cHRNZXNzYWdlIHdpdGggdGhlIGlkIHRoYXQgbWF0Y2hlcyB0aGUgcGFzc2VkIG1zZ0lkLCBvciB1bmRlZmluZWRcbiAgICogaWYgbm8gRGVjcnlwdE1lc3NhZ2UgaGFzIHRoYXQgaWQuXG4gICAqXG4gICAqL1xuICBnZXRNc2cobXNnSWQpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5maW5kKChtc2cpID0+IG1zZy5pZCA9PT0gbXNnSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcHJvdmVzIGEgRGVjcnlwdE1lc3NhZ2UuIFNldHMgdGhlIG1lc3NhZ2Ugc3RhdHVzIHZpYSBhIGNhbGwgdG8gdGhpcy5zZXRNc2dTdGF0dXNBcHByb3ZlZCwgYW5kIHJldHVybnMgYSBwcm9taXNlXG4gICAqIHdpdGggdGhlIG1lc3NhZ2UgcGFyYW1zIG1vZGlmaWVkIGZvciBwcm9wZXIgZGVjcnlwdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyBUaGUgbXNnUGFyYW1zIHRvIGJlIHVzZWQgd2hlbiBldGhfZGVjcnlwdE1zZyBpcyBjYWxsZWQsIHBsdXMgZGF0YSBhZGRlZCBieSBNZXRhTWFzay5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcy5tZXRhbWFza0lkIEFkZGVkIHRvIG1zZ1BhcmFtcyBmb3IgdHJhY2tpbmcgYW5kIGlkZW50aWZpY2F0aW9uIHdpdGhpbiBNZXRhTWFzay5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gUHJvbWlzZXMgdGhlIG1zZ1BhcmFtcyBvYmplY3Qgd2l0aCBtZXRhbWFza0lkIHJlbW92ZWQuXG4gICAqXG4gICAqL1xuICBhcHByb3ZlTWVzc2FnZShtc2dQYXJhbXMpIHtcbiAgICB0aGlzLnNldE1zZ1N0YXR1c0FwcHJvdmVkKG1zZ1BhcmFtcy5tZXRhbWFza0lkKTtcbiAgICByZXR1cm4gdGhpcy5wcmVwTXNnRm9yRGVjcnlwdGlvbihtc2dQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBEZWNyeXB0TWVzc2FnZSBzdGF0dXMgdG8gJ2FwcHJvdmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIFRoZSBpZCBvZiB0aGUgRGVjcnlwdE1lc3NhZ2UgdG8gYXBwcm92ZS5cbiAgICpcbiAgICovXG4gIHNldE1zZ1N0YXR1c0FwcHJvdmVkKG1zZ0lkKSB7XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAnYXBwcm92ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgRGVjcnlwdE1lc3NhZ2Ugc3RhdHVzIHRvICdkZWNyeXB0ZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzIGFuZCB1cGRhdGVzIHRoYXQgRGVjcnlwdE1lc3NhZ2UgaW5cbiAgICogdGhpcy5tZXNzYWdlcyBieSBhZGRpbmcgdGhlIHJhdyBkZWNyeXB0aW9uIGRhdGEgb2YgdGhlIGRlY3J5cHRpb24gcmVxdWVzdCB0byB0aGUgRGVjcnlwdE1lc3NhZ2VcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIFRoZSBpZCBvZiB0aGUgRGVjcnlwdE1lc3NhZ2UgdG8gZGVjcnlwdC5cbiAgICogQHBhcmFtIHtidWZmZXJ9IHJhd0RhdGEgVGhlIHJhdyBkYXRhIG9mIHRoZSBtZXNzYWdlIHJlcXVlc3RcbiAgICpcbiAgICovXG4gIHNldE1zZ1N0YXR1c0RlY3J5cHRlZChtc2dJZCwgcmF3RGF0YSkge1xuICAgIGNvbnN0IG1zZyA9IHRoaXMuZ2V0TXNnKG1zZ0lkKTtcbiAgICBtc2cucmF3RGF0YSA9IHJhd0RhdGE7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAnZGVjcnlwdGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSBmcm9tIHBhc3NlZCBtc2dQYXJhbXMgYW5kIHJldHVybnMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRoZSB1cGRhdGVkIG1zZ1BhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIFRoZSBtc2dQYXJhbXMgdG8gbW9kaWZ5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFByb21pc2VzIHRoZSBtc2dQYXJhbXMgd2l0aCB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSByZW1vdmVkXG4gICAqXG4gICAqL1xuICBwcmVwTXNnRm9yRGVjcnlwdGlvbihtc2dQYXJhbXMpIHtcbiAgICBkZWxldGUgbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2dQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBEZWNyeXB0TWVzc2FnZSBzdGF0dXMgdG8gJ3JlamVjdGVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIFRoZSBpZCBvZiB0aGUgRGVjcnlwdE1lc3NhZ2UgdG8gcmVqZWN0LlxuICAgKlxuICAgKi9cbiAgcmVqZWN0TXNnKG1zZ0lkLCByZWFzb24gPSB1bmRlZmluZWQpIHtcbiAgICBpZiAocmVhc29uKSB7XG4gICAgICB0aGlzLm1ldHJpY3NFdmVudCh7XG4gICAgICAgIGV2ZW50OiByZWFzb24sXG4gICAgICAgIGNhdGVnb3J5OiAnTWVzc2FnZXMnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgYWN0aW9uOiAnRGVjcnlwdCBNZXNzYWdlIFJlcXVlc3QnLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3NldE1zZ1N0YXR1cyhtc2dJZCwgJ3JlamVjdGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIFR5cGVkTWVzc2FnZSBzdGF0dXMgdG8gJ2Vycm9yZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgVGhlIGlkIG9mIHRoZSBUeXBlZE1lc3NhZ2UgdG8gZXJyb3JcbiAgICpcbiAgICovXG4gIGVycm9yTWVzc2FnZShtc2dJZCwgZXJyb3IpIHtcbiAgICBjb25zdCBtc2cgPSB0aGlzLmdldE1zZyhtc2dJZCk7XG4gICAgbXNnLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAnZXJyb3JlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgdW5hcHByb3ZlZCBtZXNzYWdlcyBmcm9tIG1lbW9yeS5cbiAgICovXG4gIGNsZWFyVW5hcHByb3ZlZCgpIHtcbiAgICB0aGlzLm1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcy5maWx0ZXIoKG1zZykgPT4gbXNnLnN0YXR1cyAhPT0gJ3VuYXBwcm92ZWQnKTtcbiAgICB0aGlzLl9zYXZlTXNnTGlzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YXR1cyBvZiBhIERlY3J5cHRNZXNzYWdlIGluIHRoaXMubWVzc2FnZXMgdmlhIGEgY2FsbCB0byB0aGlzLl91cGRhdGVNc2dcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIFRoZSBpZCBvZiB0aGUgRGVjcnlwdE1lc3NhZ2UgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdHVzIFRoZSBuZXcgc3RhdHVzIG9mIHRoZSBEZWNyeXB0TWVzc2FnZS5cbiAgICogQHRocm93cyBBICdEZWNyeXB0TWVzc2FnZU1hbmFnZXIgLSBEZWNyeXB0TWVzc2FnZSBub3QgZm91bmQgZm9yIGlkOiBcIiR7bXNnSWR9XCIuJyBpZiB0aGVyZSBpcyBubyBEZWNyeXB0TWVzc2FnZVxuICAgKiBpbiB0aGlzLm1lc3NhZ2VzIHdpdGggYW4gaWQgZXF1YWwgdG8gdGhlIHBhc3NlZCBtc2dJZFxuICAgKiBAZmlyZXMgQW4gZXZlbnQgd2l0aCBhIG5hbWUgZXF1YWwgdG8gYCR7bXNnSWR9OiR7c3RhdHVzfWAuIFRoZSBEZWNyeXB0TWVzc2FnZSBpcyBhbHNvIGZpcmVkLlxuICAgKiBAZmlyZXMgSWYgc3RhdHVzIGlzICdyZWplY3RlZCcgb3IgJ2RlY3J5cHRlZCcsIGFuIGV2ZW50IHdpdGggYSBuYW1lIGVxdWFsIHRvIGAke21zZ0lkfTpmaW5pc2hlZGAgaXMgZmlyZWQgYWxvbmdcbiAgICogd2l0aCB0aGUgRGVjcnlwdE1lc3NhZ2VcbiAgICpcbiAgICovXG4gIF9zZXRNc2dTdGF0dXMobXNnSWQsIHN0YXR1cykge1xuICAgIGNvbnN0IG1zZyA9IHRoaXMuZ2V0TXNnKG1zZ0lkKTtcbiAgICBpZiAoIW1zZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRGVjcnlwdE1lc3NhZ2VNYW5hZ2VyIC0gTWVzc2FnZSBub3QgZm91bmQgZm9yIGlkOiBcIiR7bXNnSWR9XCIuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIG1zZy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5lbWl0KGAke21zZ0lkfToke3N0YXR1c31gLCBtc2cpO1xuICAgIGlmIChcbiAgICAgIHN0YXR1cyA9PT0gJ3JlamVjdGVkJyB8fFxuICAgICAgc3RhdHVzID09PSAnZGVjcnlwdGVkJyB8fFxuICAgICAgc3RhdHVzID09PSAnZXJyb3JlZCdcbiAgICApIHtcbiAgICAgIHRoaXMuZW1pdChgJHttc2dJZH06ZmluaXNoZWRgLCBtc2cpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgRGVjcnlwdE1lc3NhZ2UgaW4gdGhpcy5tZXNzYWdlcyB0byB0aGUgcGFzc2VkIERlY3J5cHRNZXNzYWdlIGlmIHRoZSBpZHMgYXJlIGVxdWFsLiBUaGVuIHNhdmVzIHRoZVxuICAgKiB1bmFwcHJvdmVkRGVjcnlwdE1zZ3MgaW5kZXggdG8gc3RvcmFnZSB2aWEgdGhpcy5fc2F2ZU1zZ0xpc3RcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtEZWNyeXB0TWVzc2FnZX0gbXNnIC0gQSBEZWNyeXB0TWVzc2FnZSB0aGF0IHdpbGwgcmVwbGFjZSBhbiBleGlzdGluZyBEZWNyeXB0TWVzc2FnZSAod2l0aCB0aGUgc2FtZVxuICAgKiBpZCkgaW4gdGhpcy5tZXNzYWdlc1xuICAgKlxuICAgKi9cbiAgX3VwZGF0ZU1zZyhtc2cpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMubWVzc2FnZXMuZmluZEluZGV4KChtZXNzYWdlKSA9PiBtZXNzYWdlLmlkID09PSBtc2cuaWQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMubWVzc2FnZXNbaW5kZXhdID0gbXNnO1xuICAgIH1cbiAgICB0aGlzLl9zYXZlTXNnTGlzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIHRoZSB1bmFwcHJvdmVkIERlY3J5cHRNZXNzYWdlcywgYW5kIHRoZWlyIGNvdW50LCB0byB0aGlzLm1lbVN0b3JlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmaXJlcyAndXBkYXRlQmFkZ2UnXG4gICAqXG4gICAqL1xuICBfc2F2ZU1zZ0xpc3QoKSB7XG4gICAgY29uc3QgdW5hcHByb3ZlZERlY3J5cHRNc2dzID0gdGhpcy5nZXRVbmFwcHJvdmVkTXNncygpO1xuICAgIGNvbnN0IHVuYXBwcm92ZWREZWNyeXB0TXNnQ291bnQgPSBPYmplY3Qua2V5cyh1bmFwcHJvdmVkRGVjcnlwdE1zZ3MpLmxlbmd0aDtcbiAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHVuYXBwcm92ZWREZWNyeXB0TXNncyxcbiAgICAgIHVuYXBwcm92ZWREZWNyeXB0TXNnQ291bnQsXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSk7XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyByYXcgYnVmZmVyIGRhdGEgdG8gYSBoZXgsIG9yIGp1c3QgcmV0dXJucyB0aGUgZGF0YSBpZiBpdCBpcyBhbHJlYWR5IGZvcm1hdHRlZCBhcyBhIGhleC5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGRhdGEgVGhlIGJ1ZmZlciBkYXRhIHRvIGNvbnZlcnQgdG8gYSBoZXhcbiAgICogQHJldHVybnMge3N0cmluZ30gQSBoZXggc3RyaW5nIGNvbnZlcnNpb24gb2YgdGhlIGJ1ZmZlciBkYXRhXG4gICAqXG4gICAqL1xuICBub3JtYWxpemVNc2dEYXRhKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RyaXBwZWQgPSBzdHJpcEhleFByZWZpeChkYXRhKTtcbiAgICAgIGlmIChzdHJpcHBlZC5tYXRjaChoZXhSZSkpIHtcbiAgICAgICAgcmV0dXJuIGFkZEhleFByZWZpeChzdHJpcHBlZCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLmRlYnVnKGBNZXNzYWdlIHdhcyBub3QgaGV4IGVuY29kZWQsIGludGVycHJldGluZyBhcyB1dGY4LmApO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXJUb0hleChCdWZmZXIuZnJvbShkYXRhLCAndXRmOCcpKTtcbiAgfVxufVxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVN0b3JlIH0gZnJvbSAnQG1ldGFtYXNrL29icy1zdG9yZSc7XG5pbXBvcnQgeyBidWZmZXJUb0hleCB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5pbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgeyBNRVNTQUdFX1RZUEUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XG5pbXBvcnQgeyBNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUyB9IGZyb20gJy4uL21ldGFtYXNrLWNvbnRyb2xsZXInO1xuaW1wb3J0IGNyZWF0ZUlkIGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3JhbmRvbS1pZCc7XG5cbi8qKlxuICogUmVwcmVzZW50cywgYW5kIGNvbnRhaW5zIGRhdGEgYWJvdXQsIGFuICdldGhfc2lnbicgdHlwZSBzaWduYXR1cmUgcmVxdWVzdC4gVGhlc2UgYXJlIGNyZWF0ZWQgd2hlbiBhIHNpZ25hdHVyZSBmb3JcbiAqIGFuIGV0aF9zaWduIGNhbGwgaXMgcmVxdWVzdGVkLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjZXRoX3NpZ259XG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gTWVzc2FnZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlkIEFuIGlkIHRvIHRyYWNrIGFuZCBpZGVudGlmeSB0aGUgbWVzc2FnZSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtc2dQYXJhbXMgVGhlIHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgZXRoX3NpZ24gbWV0aG9kIG9uY2UgdGhlIHNpZ25hdHVyZSByZXF1ZXN0IGlzIGFwcHJvdmVkLlxuICogQHByb3BlcnR5IHtPYmplY3R9IG1zZ1BhcmFtcy5tZXRhbWFza0lkIEFkZGVkIHRvIG1zZ1BhcmFtcyBmb3IgdHJhY2tpbmcgYW5kIGlkZW50aWZpY2F0aW9uIHdpdGhpbiBNZXRhTWFzay5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtc2dQYXJhbXMuZGF0YSBBIGhleCBzdHJpbmcgY29udmVyc2lvbiBvZiB0aGUgcmF3IGJ1ZmZlciBkYXRhIG9mIHRoZSBzaWduYXR1cmUgcmVxdWVzdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWUgVGhlIGVwb2NoIHRpbWUgYXQgd2hpY2ggdGhlIHRoaXMgbWVzc2FnZSB3YXMgY3JlYXRlZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXR1cyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc2lnbmF0dXJlIHJlcXVlc3QgaXMgJ3VuYXBwcm92ZWQnLCAnYXBwcm92ZWQnLCAnc2lnbmVkJyBvciAncmVqZWN0ZWQnXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBUaGUganNvbi1wcmMgc2lnbmluZyBtZXRob2QgZm9yIHdoaWNoIGEgc2lnbmF0dXJlIHJlcXVlc3QgaGFzIGJlZW4gbWFkZS4gQSAnTWVzc2FnZScgd2l0aFxuICogYWx3YXlzIGhhdmUgYSAnZXRoX3NpZ24nIHR5cGUuXG4gKlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lc3NhZ2VNYW5hZ2VyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENvbnRyb2xsZXIgaW4gY2hhcmdlIG9mIG1hbmFnaW5nIC0gc3RvcmluZywgYWRkaW5nLCByZW1vdmluZywgdXBkYXRpbmcgLSBNZXNzYWdlcy5cbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWVzc2FnZU1hbmFnZXJcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IG1lbVN0b3JlIFRoZSBvYnNlcnZhYmxlIHN0b3JlIHdoZXJlIE1lc3NhZ2VzIGFyZSBzYXZlZC5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IG1lbVN0b3JlLnVuYXBwcm92ZWRNc2dzIEEgY29sbGVjdGlvbiBvZiBhbGwgTWVzc2FnZXMgaW4gdGhlICd1bmFwcHJvdmVkJyBzdGF0ZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gbWVtU3RvcmUudW5hcHByb3ZlZE1zZ0NvdW50IFRoZSBjb3VudCBvZiBhbGwgTWVzc2FnZXMgaW4gdGhpcy5tZW1TdG9yZS51bmFwcHJvdmVkTXNnc1xuICAgKiBAcHJvcGVydHkge0FycmF5fSBtZXNzYWdlcyBIb2xkcyBhbGwgbWVzc2FnZXMgdGhhdCBoYXZlIGJlZW4gY3JlYXRlZCBieSB0aGlzIE1lc3NhZ2VNYW5hZ2VyXG4gICAqXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IG1ldHJpY3NFdmVudCB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1lbVN0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZSh7XG4gICAgICB1bmFwcHJvdmVkTXNnczoge30sXG4gICAgICB1bmFwcHJvdmVkTXNnQ291bnQ6IDAsXG4gICAgfSk7XG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMubWV0cmljc0V2ZW50ID0gbWV0cmljc0V2ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIGZvciB0aGUgbnVtYmVyIG9mICd1bmFwcHJvdmVkJyBNZXNzYWdlcyBpbiB0aGlzLm1lc3NhZ2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgJ3VuYXBwcm92ZWQnIE1lc3NhZ2VzIGluIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICovXG4gIGdldCB1bmFwcHJvdmVkTXNnQ291bnQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0VW5hcHByb3ZlZE1zZ3MoKSkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIGZvciB0aGUgJ3VuYXBwcm92ZWQnIE1lc3NhZ2VzIGluIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gQW4gaW5kZXggb2YgTWVzc2FnZSBpZHMgdG8gTWVzc2FnZXMsIGZvciBhbGwgJ3VuYXBwcm92ZWQnIE1lc3NhZ2VzIGluIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICovXG4gIGdldFVuYXBwcm92ZWRNc2dzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzXG4gICAgICAuZmlsdGVyKChtc2cpID0+IG1zZy5zdGF0dXMgPT09ICd1bmFwcHJvdmVkJylcbiAgICAgIC5yZWR1Y2UoKHJlc3VsdCwgbXNnKSA9PiB7XG4gICAgICAgIHJlc3VsdFttc2cuaWRdID0gbXNnO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtc2dQYXJhbXMuIHRoaXMuYWRkTXNnIGlzIGNhbGxlZCB0byBhZGQgdGhlXG4gICAqIG5ldyBNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZSB1bmFwcHJvdmVkIE1lc3NhZ2VzIGZyb20gdGhhdCBsaXN0IHRvIHRoaXMubWVtU3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgZXRoX3NpZ24gY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3JlcV0gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luXG4gICAqIEByZXR1cm5zIHtwcm9taXNlfSBhZnRlciBzaWduYXR1cmUgaGFzIGJlZW5cbiAgICpcbiAgICovXG4gIGFzeW5jIGFkZFVuYXBwcm92ZWRNZXNzYWdlQXN5bmMobXNnUGFyYW1zLCByZXEpIHtcbiAgICBjb25zdCBtc2dJZCA9IHRoaXMuYWRkVW5hcHByb3ZlZE1lc3NhZ2UobXNnUGFyYW1zLCByZXEpO1xuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBhd2FpdCBmaW5pc2hlZFxuICAgICAgdGhpcy5vbmNlKGAke21zZ0lkfTpmaW5pc2hlZGAsIChkYXRhKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoZGF0YS5zdGF0dXMpIHtcbiAgICAgICAgICBjYXNlICdzaWduZWQnOlxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGF0YS5yYXdTaWcpO1xuICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgICAgICAgIGV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KFxuICAgICAgICAgICAgICAgICdNZXRhTWFzayBNZXNzYWdlIFNpZ25hdHVyZTogVXNlciBkZW5pZWQgbWVzc2FnZSBzaWduYXR1cmUuJyxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSAnZXJyb3JlZCc6XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoYE1ldGFNYXNrIE1lc3NhZ2UgU2lnbmF0dXJlOiAke2RhdGEuZXJyb3J9YCksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYE1ldGFNYXNrIE1lc3NhZ2UgU2lnbmF0dXJlOiBVbmtub3duIHByb2JsZW06ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICBtc2dQYXJhbXMsXG4gICAgICAgICAgICAgICAgKX1gLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBNZXNzYWdlIHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1zZ1BhcmFtcy4gdGhpcy5hZGRNc2cgaXMgY2FsbGVkIHRvIGFkZCB0aGVcbiAgICogbmV3IE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlIHVuYXBwcm92ZWQgTWVzc2FnZXMgZnJvbSB0aGF0IGxpc3QgdG8gdGhpcy5tZW1TdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBwYXJhbXMgZm9yIHRoZSBldGhfc2lnbiBjYWxsIHRvIGJlIG1hZGUgYWZ0ZXIgdGhlIG1lc3NhZ2UgaXMgYXBwcm92ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxXSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdCB3aGVyZSB0aGUgb3JpZ2luIG1heSBiZSBzcGVjaWZpZWRcbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIGlkIG9mIHRoZSBuZXdseSBjcmVhdGVkIG1lc3NhZ2UuXG4gICAqXG4gICAqL1xuICBhZGRVbmFwcHJvdmVkTWVzc2FnZShtc2dQYXJhbXMsIHJlcSkge1xuICAgIC8vIGFkZCBvcmlnaW4gZnJvbSByZXF1ZXN0XG4gICAgaWYgKHJlcSkge1xuICAgICAgbXNnUGFyYW1zLm9yaWdpbiA9IHJlcS5vcmlnaW47XG4gICAgfVxuICAgIG1zZ1BhcmFtcy5kYXRhID0gbm9ybWFsaXplTXNnRGF0YShtc2dQYXJhbXMuZGF0YSk7XG4gICAgLy8gY3JlYXRlIHR4RGF0YSBvYmogd2l0aCBwYXJhbWV0ZXJzIGFuZCBtZXRhIGRhdGFcbiAgICBjb25zdCB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgbXNnSWQgPSBjcmVhdGVJZCgpO1xuICAgIGNvbnN0IG1zZ0RhdGEgPSB7XG4gICAgICBpZDogbXNnSWQsXG4gICAgICBtc2dQYXJhbXMsXG4gICAgICB0aW1lLFxuICAgICAgc3RhdHVzOiAndW5hcHByb3ZlZCcsXG4gICAgICB0eXBlOiBNRVNTQUdFX1RZUEUuRVRIX1NJR04sXG4gICAgfTtcbiAgICB0aGlzLmFkZE1zZyhtc2dEYXRhKTtcblxuICAgIC8vIHNpZ25hbCB1cGRhdGVcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuICAgIHJldHVybiBtc2dJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcGFzc2VkIE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIGNhbGxzIHRoaXMuX3NhdmVNc2dMaXN0KCkgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBNZXNzYWdlcyBmcm9tIHRoYXRcbiAgICogbGlzdCB0byB0aGlzLm1lbVN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1zZyAtIFRoZSBNZXNzYWdlIHRvIGFkZCB0byB0aGlzLm1lc3NhZ2VzXG4gICAqXG4gICAqL1xuICBhZGRNc2cobXNnKSB7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1zZyk7XG4gICAgdGhpcy5fc2F2ZU1zZ0xpc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIE1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgTWVzc2FnZSB0byBnZXRcbiAgICogQHJldHVybnMge01lc3NhZ2V8dW5kZWZpbmVkfSBUaGUgTWVzc2FnZSB3aXRoIHRoZSBpZCB0aGF0IG1hdGNoZXMgdGhlIHBhc3NlZCBtc2dJZCwgb3IgdW5kZWZpbmVkIGlmIG5vIE1lc3NhZ2UgaGFzIHRoYXQgaWQuXG4gICAqXG4gICAqL1xuICBnZXRNc2cobXNnSWQpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5maW5kKChtc2cpID0+IG1zZy5pZCA9PT0gbXNnSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcHJvdmVzIGEgTWVzc2FnZS4gU2V0cyB0aGUgbWVzc2FnZSBzdGF0dXMgdmlhIGEgY2FsbCB0byB0aGlzLnNldE1zZ1N0YXR1c0FwcHJvdmVkLCBhbmQgcmV0dXJucyBhIHByb21pc2Ugd2l0aFxuICAgKiBhbnkgdGhlIG1lc3NhZ2UgcGFyYW1zIG1vZGlmaWVkIGZvciBwcm9wZXIgc2lnbmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBtc2dQYXJhbXMgdG8gYmUgdXNlZCB3aGVuIGV0aF9zaWduIGlzIGNhbGxlZCwgcGx1cyBkYXRhIGFkZGVkIGJ5IE1ldGFNYXNrLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zLm1ldGFtYXNrSWQgQWRkZWQgdG8gbXNnUGFyYW1zIGZvciB0cmFja2luZyBhbmQgaWRlbnRpZmljYXRpb24gd2l0aGluIE1ldGFNYXNrLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBQcm9taXNlcyB0aGUgbXNnUGFyYW1zIG9iamVjdCB3aXRoIG1ldGFtYXNrSWQgcmVtb3ZlZC5cbiAgICpcbiAgICovXG4gIGFwcHJvdmVNZXNzYWdlKG1zZ1BhcmFtcykge1xuICAgIHRoaXMuc2V0TXNnU3RhdHVzQXBwcm92ZWQobXNnUGFyYW1zLm1ldGFtYXNrSWQpO1xuICAgIHJldHVybiB0aGlzLnByZXBNc2dGb3JTaWduaW5nKG1zZ1BhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIE1lc3NhZ2Ugc3RhdHVzIHRvICdhcHByb3ZlZCcgdmlhIGEgY2FsbCB0byB0aGlzLl9zZXRNc2dTdGF0dXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgTWVzc2FnZSB0byBhcHByb3ZlLlxuICAgKlxuICAgKi9cbiAgc2V0TXNnU3RhdHVzQXBwcm92ZWQobXNnSWQpIHtcbiAgICB0aGlzLl9zZXRNc2dTdGF0dXMobXNnSWQsICdhcHByb3ZlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBNZXNzYWdlIHN0YXR1cyB0byAnc2lnbmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cyBhbmQgdXBkYXRlcyB0aGF0IE1lc3NhZ2UgaW4gdGhpcy5tZXNzYWdlcyBieVxuICAgKiBhZGRpbmcgdGhlIHJhdyBzaWduYXR1cmUgZGF0YSBvZiB0aGUgc2lnbmF0dXJlIHJlcXVlc3QgdG8gdGhlIE1lc3NhZ2VcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBNZXNzYWdlIHRvIHNpZ24uXG4gICAqIEBwYXJhbSB7YnVmZmVyfSByYXdTaWcgLSBUaGUgcmF3IGRhdGEgb2YgdGhlIHNpZ25hdHVyZSByZXF1ZXN0XG4gICAqXG4gICAqL1xuICBzZXRNc2dTdGF0dXNTaWduZWQobXNnSWQsIHJhd1NpZykge1xuICAgIGNvbnN0IG1zZyA9IHRoaXMuZ2V0TXNnKG1zZ0lkKTtcbiAgICBtc2cucmF3U2lnID0gcmF3U2lnO1xuICAgIHRoaXMuX3VwZGF0ZU1zZyhtc2cpO1xuICAgIHRoaXMuX3NldE1zZ1N0YXR1cyhtc2dJZCwgJ3NpZ25lZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIG1ldGFtYXNrSWQgcHJvcGVydHkgZnJvbSBwYXNzZWQgbXNnUGFyYW1zIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0aGUgdXBkYXRlZCBtc2dQYXJhbXNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBtc2dQYXJhbXMgdG8gbW9kaWZ5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFByb21pc2VzIHRoZSBtc2dQYXJhbXMgd2l0aCB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSByZW1vdmVkXG4gICAqXG4gICAqL1xuICBwcmVwTXNnRm9yU2lnbmluZyhtc2dQYXJhbXMpIHtcbiAgICBkZWxldGUgbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2dQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBNZXNzYWdlIHN0YXR1cyB0byAncmVqZWN0ZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIE1lc3NhZ2UgdG8gcmVqZWN0LlxuICAgKlxuICAgKi9cbiAgcmVqZWN0TXNnKG1zZ0lkLCByZWFzb24gPSB1bmRlZmluZWQpIHtcbiAgICBpZiAocmVhc29uKSB7XG4gICAgICBjb25zdCBtc2cgPSB0aGlzLmdldE1zZyhtc2dJZCk7XG4gICAgICB0aGlzLm1ldHJpY3NFdmVudCh7XG4gICAgICAgIGV2ZW50OiByZWFzb24sXG4gICAgICAgIGNhdGVnb3J5OiAnVHJhbnNhY3Rpb25zJyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGFjdGlvbjogJ1NpZ24gUmVxdWVzdCcsXG4gICAgICAgICAgdHlwZTogbXNnLnR5cGUsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAncmVqZWN0ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgTWVzc2FnZSBzdGF0dXMgdG8gJ2Vycm9yZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIE1lc3NhZ2UgdG8gZXJyb3JcbiAgICpcbiAgICovXG4gIGVycm9yTWVzc2FnZShtc2dJZCwgZXJyb3IpIHtcbiAgICBjb25zdCBtc2cgPSB0aGlzLmdldE1zZyhtc2dJZCk7XG4gICAgbXNnLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAnZXJyb3JlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgdW5hcHByb3ZlZCBtZXNzYWdlcyBmcm9tIG1lbW9yeS5cbiAgICovXG4gIGNsZWFyVW5hcHByb3ZlZCgpIHtcbiAgICB0aGlzLm1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcy5maWx0ZXIoKG1zZykgPT4gbXNnLnN0YXR1cyAhPT0gJ3VuYXBwcm92ZWQnKTtcbiAgICB0aGlzLl9zYXZlTXNnTGlzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YXR1cyBvZiBhIE1lc3NhZ2UgaW4gdGhpcy5tZXNzYWdlcyB2aWEgYSBjYWxsIHRvIHRoaXMuX3VwZGF0ZU1zZ1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIE1lc3NhZ2UgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdHVzIC0gVGhlIG5ldyBzdGF0dXMgb2YgdGhlIE1lc3NhZ2UuXG4gICAqIEB0aHJvd3MgQSAnTWVzc2FnZU1hbmFnZXIgLSBNZXNzYWdlIG5vdCBmb3VuZCBmb3IgaWQ6IFwiJHttc2dJZH1cIi4nIGlmIHRoZXJlIGlzIG5vIE1lc3NhZ2UgaW4gdGhpcy5tZXNzYWdlcyB3aXRoIGFuXG4gICAqIGlkIGVxdWFsIHRvIHRoZSBwYXNzZWQgbXNnSWRcbiAgICogQGZpcmVzIEFuIGV2ZW50IHdpdGggYSBuYW1lIGVxdWFsIHRvIGAke21zZ0lkfToke3N0YXR1c31gLiBUaGUgTWVzc2FnZSBpcyBhbHNvIGZpcmVkLlxuICAgKiBAZmlyZXMgSWYgc3RhdHVzIGlzICdyZWplY3RlZCcgb3IgJ3NpZ25lZCcsIGFuIGV2ZW50IHdpdGggYSBuYW1lIGVxdWFsIHRvIGAke21zZ0lkfTpmaW5pc2hlZGAgaXMgZmlyZWQgYWxvbmcgd2l0aCB0aGUgbWVzc2FnZVxuICAgKlxuICAgKi9cbiAgX3NldE1zZ1N0YXR1cyhtc2dJZCwgc3RhdHVzKSB7XG4gICAgY29uc3QgbXNnID0gdGhpcy5nZXRNc2cobXNnSWQpO1xuICAgIGlmICghbXNnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2VNYW5hZ2VyIC0gTWVzc2FnZSBub3QgZm91bmQgZm9yIGlkOiBcIiR7bXNnSWR9XCIuYCk7XG4gICAgfVxuICAgIG1zZy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5lbWl0KGAke21zZ0lkfToke3N0YXR1c31gLCBtc2cpO1xuICAgIGlmIChzdGF0dXMgPT09ICdyZWplY3RlZCcgfHwgc3RhdHVzID09PSAnc2lnbmVkJykge1xuICAgICAgdGhpcy5lbWl0KGAke21zZ0lkfTpmaW5pc2hlZGAsIG1zZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBNZXNzYWdlIGluIHRoaXMubWVzc2FnZXMgdG8gdGhlIHBhc3NlZCBNZXNzYWdlIGlmIHRoZSBpZHMgYXJlIGVxdWFsLiBUaGVuIHNhdmVzIHRoZSB1bmFwcHJvdmVkTXNnIGxpc3QgdG9cbiAgICogc3RvcmFnZSB2aWEgdGhpcy5fc2F2ZU1zZ0xpc3RcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHttc2d9IE1lc3NhZ2UgLSBBIE1lc3NhZ2UgdGhhdCB3aWxsIHJlcGxhY2UgYW4gZXhpc3RpbmcgTWVzc2FnZSAod2l0aCB0aGUgc2FtZSBpZCkgaW4gdGhpcy5tZXNzYWdlc1xuICAgKlxuICAgKi9cbiAgX3VwZGF0ZU1zZyhtc2cpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMubWVzc2FnZXMuZmluZEluZGV4KChtZXNzYWdlKSA9PiBtZXNzYWdlLmlkID09PSBtc2cuaWQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMubWVzc2FnZXNbaW5kZXhdID0gbXNnO1xuICAgIH1cbiAgICB0aGlzLl9zYXZlTXNnTGlzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIHRoZSB1bmFwcHJvdmVkIG1lc3NhZ2VzLCBhbmQgdGhlaXIgY291bnQsIHRvIHRoaXMubWVtU3RvcmVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzICd1cGRhdGVCYWRnZSdcbiAgICpcbiAgICovXG4gIF9zYXZlTXNnTGlzdCgpIHtcbiAgICBjb25zdCB1bmFwcHJvdmVkTXNncyA9IHRoaXMuZ2V0VW5hcHByb3ZlZE1zZ3MoKTtcbiAgICBjb25zdCB1bmFwcHJvdmVkTXNnQ291bnQgPSBPYmplY3Qua2V5cyh1bmFwcHJvdmVkTXNncykubGVuZ3RoO1xuICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoeyB1bmFwcHJvdmVkTXNncywgdW5hcHByb3ZlZE1zZ0NvdW50IH0pO1xuICAgIHRoaXMuZW1pdChNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUy5VUERBVEVfQkFER0UpO1xuICB9XG59XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyByYXcgYnVmZmVyIGRhdGEgdG8gYSBoZXgsIG9yIGp1c3QgcmV0dXJucyB0aGUgZGF0YSBpZiBpdCBpcyBhbHJlYWR5IGZvcm1hdHRlZCBhcyBhIGhleC5cbiAqXG4gKiBAcGFyYW0ge2FueX0gZGF0YSAtIFRoZSBidWZmZXIgZGF0YSB0byBjb252ZXJ0IHRvIGEgaGV4XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIGhleCBzdHJpbmcgY29udmVyc2lvbiBvZiB0aGUgYnVmZmVyIGRhdGFcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVNc2dEYXRhKGRhdGEpIHtcbiAgaWYgKGRhdGEuc2xpY2UoMCwgMikgPT09ICcweCcpIHtcbiAgICAvLyBkYXRhIGlzIGFscmVhZHkgaGV4XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgLy8gZGF0YSBpcyB1bmljb2RlLCBjb252ZXJ0IHRvIGhleFxuICByZXR1cm4gYnVmZmVyVG9IZXgoQnVmZmVyLmZyb20oZGF0YSwgJ3V0ZjgnKSk7XG59XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7IGJ1ZmZlclRvSGV4LCBzdHJpcEhleFByZWZpeCB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5pbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7IE1FU1NBR0VfVFlQRSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcbmltcG9ydCB7IE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTIH0gZnJvbSAnLi4vbWV0YW1hc2stY29udHJvbGxlcic7XG5pbXBvcnQgY3JlYXRlSWQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvcmFuZG9tLWlkJztcbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IGhleFJlID0gL15bMC05QS1GYS1mXSskL2d1O1xuXG4vKipcbiAqIFJlcHJlc2VudHMsIGFuZCBjb250YWlucyBkYXRhIGFib3V0LCBhbiAncGVyc29uYWxfc2lnbicgdHlwZSBzaWduYXR1cmUgcmVxdWVzdC4gVGhlc2UgYXJlIGNyZWF0ZWQgd2hlbiBhXG4gKiBzaWduYXR1cmUgZm9yIGFuIHBlcnNvbmFsX3NpZ24gY2FsbCBpcyByZXF1ZXN0ZWQuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93ZWIzanMucmVhZHRoZWRvY3MuaW8vZW4vMS4wL3dlYjMtZXRoLXBlcnNvbmFsLmh0bWwjc2lnbn1cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQZXJzb25hbE1lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZCBBbiBpZCB0byB0cmFjayBhbmQgaWRlbnRpZnkgdGhlIG1lc3NhZ2Ugb2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gbXNnUGFyYW1zIFRoZSBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHBlcnNvbmFsX3NpZ24gbWV0aG9kIG9uY2UgdGhlIHNpZ25hdHVyZSByZXF1ZXN0IGlzXG4gKiBhcHByb3ZlZC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtc2dQYXJhbXMubWV0YW1hc2tJZCBBZGRlZCB0byBtc2dQYXJhbXMgZm9yIHRyYWNraW5nIGFuZCBpZGVudGlmaWNhdGlvbiB3aXRoaW4gTWV0YU1hc2suXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbXNnUGFyYW1zLmRhdGEgQSBoZXggc3RyaW5nIGNvbnZlcnNpb24gb2YgdGhlIHJhdyBidWZmZXIgZGF0YSBvZiB0aGUgc2lnbmF0dXJlIHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lIFRoZSBlcG9jaCB0aW1lIGF0IHdoaWNoIHRoZSB0aGlzIG1lc3NhZ2Ugd2FzIGNyZWF0ZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0dXMgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNpZ25hdHVyZSByZXF1ZXN0IGlzICd1bmFwcHJvdmVkJywgJ2FwcHJvdmVkJywgJ3NpZ25lZCcgb3IgJ3JlamVjdGVkJ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgVGhlIGpzb24tcHJjIHNpZ25pbmcgbWV0aG9kIGZvciB3aGljaCBhIHNpZ25hdHVyZSByZXF1ZXN0IGhhcyBiZWVuIG1hZGUuIEEgJ01lc3NhZ2UnIHdpbGxcbiAqIGFsd2F5cyBoYXZlIGEgJ3BlcnNvbmFsX3NpZ24nIHR5cGUuXG4gKlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBlcnNvbmFsTWVzc2FnZU1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ29udHJvbGxlciBpbiBjaGFyZ2Ugb2YgbWFuYWdpbmcgLSBzdG9yaW5nLCBhZGRpbmcsIHJlbW92aW5nLCB1cGRhdGluZyAtIFBlcnNvbmFsTWVzc2FnZS5cbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gUGVyc29uYWxNZXNzYWdlTWFuYWdlclxuICAgKiBAcHJvcGVydHkge09iamVjdH0gbWVtU3RvcmUgVGhlIG9ic2VydmFibGUgc3RvcmUgd2hlcmUgUGVyc29uYWxNZXNzYWdlIGFyZSBzYXZlZC5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IG1lbVN0b3JlLnVuYXBwcm92ZWRQZXJzb25hbE1zZ3MgQSBjb2xsZWN0aW9uIG9mIGFsbCBQZXJzb25hbE1lc3NhZ2VzIGluIHRoZSAndW5hcHByb3ZlZCcgc3RhdGVcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1lbVN0b3JlLnVuYXBwcm92ZWRQZXJzb25hbE1zZ0NvdW50IFRoZSBjb3VudCBvZiBhbGwgUGVyc29uYWxNZXNzYWdlcyBpbiB0aGlzLm1lbVN0b3JlLnVuYXBwcm9iZWRNc2dzXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG1lc3NhZ2VzIEhvbGRzIGFsbCBtZXNzYWdlcyB0aGF0IGhhdmUgYmVlbiBjcmVhdGVkIGJ5IHRoaXMgUGVyc29uYWxNZXNzYWdlTWFuYWdlclxuICAgKlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBtZXRyaWNzRXZlbnQgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tZW1TdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgdW5hcHByb3ZlZFBlcnNvbmFsTXNnczoge30sXG4gICAgICB1bmFwcHJvdmVkUGVyc29uYWxNc2dDb3VudDogMCxcbiAgICB9KTtcbiAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgdGhpcy5tZXRyaWNzRXZlbnQgPSBtZXRyaWNzRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSBudW1iZXIgb2YgJ3VuYXBwcm92ZWQnIFBlcnNvbmFsTWVzc2FnZXMgaW4gdGhpcy5tZXNzYWdlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mICd1bmFwcHJvdmVkJyBQZXJzb25hbE1lc3NhZ2VzIGluIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICovXG4gIGdldCB1bmFwcHJvdmVkUGVyc29uYWxNc2dDb3VudCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRVbmFwcHJvdmVkTXNncygpKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSAndW5hcHByb3ZlZCcgUGVyc29uYWxNZXNzYWdlcyBpbiB0aGlzLm1lc3NhZ2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIGluZGV4IG9mIFBlcnNvbmFsTWVzc2FnZSBpZHMgdG8gUGVyc29uYWxNZXNzYWdlcywgZm9yIGFsbCAndW5hcHByb3ZlZCcgUGVyc29uYWxNZXNzYWdlcyBpblxuICAgKiB0aGlzLm1lc3NhZ2VzXG4gICAqXG4gICAqL1xuICBnZXRVbmFwcHJvdmVkTXNncygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlc1xuICAgICAgLmZpbHRlcigobXNnKSA9PiBtc2cuc3RhdHVzID09PSAndW5hcHByb3ZlZCcpXG4gICAgICAucmVkdWNlKChyZXN1bHQsIG1zZykgPT4ge1xuICAgICAgICByZXN1bHRbbXNnLmlkXSA9IG1zZztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFBlcnNvbmFsTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtc2dQYXJhbXMuIHRoaXMuYWRkTXNnIGlzIGNhbGxlZCB0byBhZGRcbiAgICogdGhlIG5ldyBQZXJzb25hbE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlIHVuYXBwcm92ZWQgUGVyc29uYWxNZXNzYWdlcyBmcm9tIHRoYXQgbGlzdCB0b1xuICAgKiB0aGlzLm1lbVN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIGV0aF9zaWduIGNhbGwgdG8gYmUgbWFkZSBhZnRlciB0aGUgbWVzc2FnZSBpcyBhcHByb3ZlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtyZXFdIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpblxuICAgKiBAcmV0dXJucyB7cHJvbWlzZX0gV2hlbiB0aGUgbWVzc2FnZSBoYXMgYmVlbiBzaWduZWQgb3IgcmVqZWN0ZWRcbiAgICpcbiAgICovXG4gIGFkZFVuYXBwcm92ZWRNZXNzYWdlQXN5bmMobXNnUGFyYW1zLCByZXEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCFtc2dQYXJhbXMuZnJvbSkge1xuICAgICAgICByZWplY3QoXG4gICAgICAgICAgbmV3IEVycm9yKCdNZXRhTWFzayBNZXNzYWdlIFNpZ25hdHVyZTogZnJvbSBmaWVsZCBpcyByZXF1aXJlZC4nKSxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbXNnSWQgPSB0aGlzLmFkZFVuYXBwcm92ZWRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxKTtcbiAgICAgIHRoaXMub25jZShgJHttc2dJZH06ZmluaXNoZWRgLCAoZGF0YSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSAnc2lnbmVkJzpcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YS5yYXdTaWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgZXRoRXJyb3JzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QoXG4gICAgICAgICAgICAgICAgJ01ldGFNYXNrIE1lc3NhZ2UgU2lnbmF0dXJlOiBVc2VyIGRlbmllZCBtZXNzYWdlIHNpZ25hdHVyZS4nLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlICdlcnJvcmVkJzpcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYE1ldGFNYXNrIE1lc3NhZ2UgU2lnbmF0dXJlOiAke2RhdGEuZXJyb3J9YCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgTWV0YU1hc2sgTWVzc2FnZSBTaWduYXR1cmU6IFVua25vd24gcHJvYmxlbTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgIG1zZ1BhcmFtcyxcbiAgICAgICAgICAgICAgICApfWAsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFBlcnNvbmFsTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtc2dQYXJhbXMuIHRoaXMuYWRkTXNnIGlzIGNhbGxlZCB0byBhZGRcbiAgICogdGhlIG5ldyBQZXJzb25hbE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlIHVuYXBwcm92ZWQgUGVyc29uYWxNZXNzYWdlcyBmcm9tIHRoYXQgbGlzdCB0b1xuICAgKiB0aGlzLm1lbVN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIGV0aF9zaWduIGNhbGwgdG8gYmUgbWFkZSBhZnRlciB0aGUgbWVzc2FnZSBpcyBhcHByb3ZlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtyZXFdIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpblxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaWQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgUGVyc29uYWxNZXNzYWdlLlxuICAgKlxuICAgKi9cbiAgYWRkVW5hcHByb3ZlZE1lc3NhZ2UobXNnUGFyYW1zLCByZXEpIHtcbiAgICBsb2cuZGVidWcoXG4gICAgICBgUGVyc29uYWxNZXNzYWdlTWFuYWdlciBhZGRVbmFwcHJvdmVkTWVzc2FnZTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgbXNnUGFyYW1zLFxuICAgICAgKX1gLFxuICAgICk7XG4gICAgLy8gYWRkIG9yaWdpbiBmcm9tIHJlcXVlc3RcbiAgICBpZiAocmVxKSB7XG4gICAgICBtc2dQYXJhbXMub3JpZ2luID0gcmVxLm9yaWdpbjtcbiAgICB9XG4gICAgbXNnUGFyYW1zLmRhdGEgPSB0aGlzLm5vcm1hbGl6ZU1zZ0RhdGEobXNnUGFyYW1zLmRhdGEpO1xuICAgIC8vIGNyZWF0ZSB0eERhdGEgb2JqIHdpdGggcGFyYW1ldGVycyBhbmQgbWV0YSBkYXRhXG4gICAgY29uc3QgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGNvbnN0IG1zZ0lkID0gY3JlYXRlSWQoKTtcbiAgICBjb25zdCBtc2dEYXRhID0ge1xuICAgICAgaWQ6IG1zZ0lkLFxuICAgICAgbXNnUGFyYW1zLFxuICAgICAgdGltZSxcbiAgICAgIHN0YXR1czogJ3VuYXBwcm92ZWQnLFxuICAgICAgdHlwZTogTUVTU0FHRV9UWVBFLlBFUlNPTkFMX1NJR04sXG4gICAgfTtcbiAgICB0aGlzLmFkZE1zZyhtc2dEYXRhKTtcblxuICAgIC8vIHNpZ25hbCB1cGRhdGVcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuICAgIHJldHVybiBtc2dJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcGFzc2VkIFBlcnNvbmFsTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgY2FsbHMgdGhpcy5fc2F2ZU1zZ0xpc3QoKSB0byBzYXZlIHRoZSB1bmFwcHJvdmVkIFBlcnNvbmFsTWVzc2FnZXMgZnJvbSB0aGF0XG4gICAqIGxpc3QgdG8gdGhpcy5tZW1TdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtc2cgLSBUaGUgUGVyc29uYWxNZXNzYWdlIHRvIGFkZCB0byB0aGlzLm1lc3NhZ2VzXG4gICAqXG4gICAqL1xuICBhZGRNc2cobXNnKSB7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1zZyk7XG4gICAgdGhpcy5fc2F2ZU1zZ0xpc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIFBlcnNvbmFsTWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBQZXJzb25hbE1lc3NhZ2UgdG8gZ2V0XG4gICAqIEByZXR1cm5zIHtQZXJzb25hbE1lc3NhZ2V8dW5kZWZpbmVkfSBUaGUgUGVyc29uYWxNZXNzYWdlIHdpdGggdGhlIGlkIHRoYXQgbWF0Y2hlcyB0aGUgcGFzc2VkIG1zZ0lkLCBvciB1bmRlZmluZWRcbiAgICogaWYgbm8gUGVyc29uYWxNZXNzYWdlIGhhcyB0aGF0IGlkLlxuICAgKlxuICAgKi9cbiAgZ2V0TXNnKG1zZ0lkKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuZmluZCgobXNnKSA9PiBtc2cuaWQgPT09IG1zZ0lkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHByb3ZlcyBhIFBlcnNvbmFsTWVzc2FnZS4gU2V0cyB0aGUgbWVzc2FnZSBzdGF0dXMgdmlhIGEgY2FsbCB0byB0aGlzLnNldE1zZ1N0YXR1c0FwcHJvdmVkLCBhbmQgcmV0dXJucyBhIHByb21pc2VcbiAgICogd2l0aCBhbnkgdGhlIG1lc3NhZ2UgcGFyYW1zIG1vZGlmaWVkIGZvciBwcm9wZXIgc2lnbmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBtc2dQYXJhbXMgdG8gYmUgdXNlZCB3aGVuIGV0aF9zaWduIGlzIGNhbGxlZCwgcGx1cyBkYXRhIGFkZGVkIGJ5IE1ldGFNYXNrLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zLm1ldGFtYXNrSWQgQWRkZWQgdG8gbXNnUGFyYW1zIGZvciB0cmFja2luZyBhbmQgaWRlbnRpZmljYXRpb24gd2l0aGluIE1ldGFNYXNrLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBQcm9taXNlcyB0aGUgbXNnUGFyYW1zIG9iamVjdCB3aXRoIG1ldGFtYXNrSWQgcmVtb3ZlZC5cbiAgICpcbiAgICovXG4gIGFwcHJvdmVNZXNzYWdlKG1zZ1BhcmFtcykge1xuICAgIHRoaXMuc2V0TXNnU3RhdHVzQXBwcm92ZWQobXNnUGFyYW1zLm1ldGFtYXNrSWQpO1xuICAgIHJldHVybiB0aGlzLnByZXBNc2dGb3JTaWduaW5nKG1zZ1BhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIFBlcnNvbmFsTWVzc2FnZSBzdGF0dXMgdG8gJ2FwcHJvdmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBQZXJzb25hbE1lc3NhZ2UgdG8gYXBwcm92ZS5cbiAgICpcbiAgICovXG4gIHNldE1zZ1N0YXR1c0FwcHJvdmVkKG1zZ0lkKSB7XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAnYXBwcm92ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgUGVyc29uYWxNZXNzYWdlIHN0YXR1cyB0byAnc2lnbmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cyBhbmQgdXBkYXRlcyB0aGF0IFBlcnNvbmFsTWVzc2FnZSBpblxuICAgKiB0aGlzLm1lc3NhZ2VzIGJ5IGFkZGluZyB0aGUgcmF3IHNpZ25hdHVyZSBkYXRhIG9mIHRoZSBzaWduYXR1cmUgcmVxdWVzdCB0byB0aGUgUGVyc29uYWxNZXNzYWdlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgUGVyc29uYWxNZXNzYWdlIHRvIHNpZ24uXG4gICAqIEBwYXJhbSB7YnVmZmVyfSByYXdTaWcgLSBUaGUgcmF3IGRhdGEgb2YgdGhlIHNpZ25hdHVyZSByZXF1ZXN0XG4gICAqXG4gICAqL1xuICBzZXRNc2dTdGF0dXNTaWduZWQobXNnSWQsIHJhd1NpZykge1xuICAgIGNvbnN0IG1zZyA9IHRoaXMuZ2V0TXNnKG1zZ0lkKTtcbiAgICBtc2cucmF3U2lnID0gcmF3U2lnO1xuICAgIHRoaXMuX3VwZGF0ZU1zZyhtc2cpO1xuICAgIHRoaXMuX3NldE1zZ1N0YXR1cyhtc2dJZCwgJ3NpZ25lZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIG1ldGFtYXNrSWQgcHJvcGVydHkgZnJvbSBwYXNzZWQgbXNnUGFyYW1zIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0aGUgdXBkYXRlZCBtc2dQYXJhbXNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBtc2dQYXJhbXMgdG8gbW9kaWZ5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFByb21pc2VzIHRoZSBtc2dQYXJhbXMgd2l0aCB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSByZW1vdmVkXG4gICAqXG4gICAqL1xuICBwcmVwTXNnRm9yU2lnbmluZyhtc2dQYXJhbXMpIHtcbiAgICBkZWxldGUgbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2dQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBQZXJzb25hbE1lc3NhZ2Ugc3RhdHVzIHRvICdyZWplY3RlZCcgdmlhIGEgY2FsbCB0byB0aGlzLl9zZXRNc2dTdGF0dXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgUGVyc29uYWxNZXNzYWdlIHRvIHJlamVjdC5cbiAgICpcbiAgICovXG4gIHJlamVjdE1zZyhtc2dJZCwgcmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHJlYXNvbikge1xuICAgICAgY29uc3QgbXNnID0gdGhpcy5nZXRNc2cobXNnSWQpO1xuICAgICAgdGhpcy5tZXRyaWNzRXZlbnQoe1xuICAgICAgICBldmVudDogcmVhc29uLFxuICAgICAgICBjYXRlZ29yeTogJ1RyYW5zYWN0aW9ucycsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBhY3Rpb246ICdTaWduIFJlcXVlc3QnLFxuICAgICAgICAgIHR5cGU6IG1zZy50eXBlLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3NldE1zZ1N0YXR1cyhtc2dJZCwgJ3JlamVjdGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIE1lc3NhZ2Ugc3RhdHVzIHRvICdlcnJvcmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBNZXNzYWdlIHRvIGVycm9yXG4gICAqXG4gICAqL1xuICBlcnJvck1lc3NhZ2UobXNnSWQsIGVycm9yKSB7XG4gICAgY29uc3QgbXNnID0gdGhpcy5nZXRNc2cobXNnSWQpO1xuICAgIG1zZy5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMuX3VwZGF0ZU1zZyhtc2cpO1xuICAgIHRoaXMuX3NldE1zZ1N0YXR1cyhtc2dJZCwgJ2Vycm9yZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIHVuYXBwcm92ZWQgbWVzc2FnZXMgZnJvbSBtZW1vcnkuXG4gICAqL1xuICBjbGVhclVuYXBwcm92ZWQoKSB7XG4gICAgdGhpcy5tZXNzYWdlcyA9IHRoaXMubWVzc2FnZXMuZmlsdGVyKChtc2cpID0+IG1zZy5zdGF0dXMgIT09ICd1bmFwcHJvdmVkJyk7XG4gICAgdGhpcy5fc2F2ZU1zZ0xpc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzdGF0dXMgb2YgYSBQZXJzb25hbE1lc3NhZ2UgaW4gdGhpcy5tZXNzYWdlcyB2aWEgYSBjYWxsIHRvIHRoaXMuX3VwZGF0ZU1zZ1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIFBlcnNvbmFsTWVzc2FnZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXMgLSBUaGUgbmV3IHN0YXR1cyBvZiB0aGUgUGVyc29uYWxNZXNzYWdlLlxuICAgKiBAdGhyb3dzIEEgJ1BlcnNvbmFsTWVzc2FnZU1hbmFnZXIgLSBQZXJzb25hbE1lc3NhZ2Ugbm90IGZvdW5kIGZvciBpZDogXCIke21zZ0lkfVwiLicgaWYgdGhlcmUgaXMgbm8gUGVyc29uYWxNZXNzYWdlXG4gICAqIGluIHRoaXMubWVzc2FnZXMgd2l0aCBhbiBpZCBlcXVhbCB0byB0aGUgcGFzc2VkIG1zZ0lkXG4gICAqIEBmaXJlcyBBbiBldmVudCB3aXRoIGEgbmFtZSBlcXVhbCB0byBgJHttc2dJZH06JHtzdGF0dXN9YC4gVGhlIFBlcnNvbmFsTWVzc2FnZSBpcyBhbHNvIGZpcmVkLlxuICAgKiBAZmlyZXMgSWYgc3RhdHVzIGlzICdyZWplY3RlZCcgb3IgJ3NpZ25lZCcsIGFuIGV2ZW50IHdpdGggYSBuYW1lIGVxdWFsIHRvIGAke21zZ0lkfTpmaW5pc2hlZGAgaXMgZmlyZWQgYWxvbmdcbiAgICogd2l0aCB0aGUgUGVyc29uYWxNZXNzYWdlXG4gICAqXG4gICAqL1xuICBfc2V0TXNnU3RhdHVzKG1zZ0lkLCBzdGF0dXMpIHtcbiAgICBjb25zdCBtc2cgPSB0aGlzLmdldE1zZyhtc2dJZCk7XG4gICAgaWYgKCFtc2cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFBlcnNvbmFsTWVzc2FnZU1hbmFnZXIgLSBNZXNzYWdlIG5vdCBmb3VuZCBmb3IgaWQ6IFwiJHttc2dJZH1cIi5gLFxuICAgICAgKTtcbiAgICB9XG4gICAgbXNnLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLl91cGRhdGVNc2cobXNnKTtcbiAgICB0aGlzLmVtaXQoYCR7bXNnSWR9OiR7c3RhdHVzfWAsIG1zZyk7XG4gICAgaWYgKHN0YXR1cyA9PT0gJ3JlamVjdGVkJyB8fCBzdGF0dXMgPT09ICdzaWduZWQnKSB7XG4gICAgICB0aGlzLmVtaXQoYCR7bXNnSWR9OmZpbmlzaGVkYCwgbXNnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIFBlcnNvbmFsTWVzc2FnZSBpbiB0aGlzLm1lc3NhZ2VzIHRvIHRoZSBwYXNzZWQgUGVyc29uYWxNZXNzYWdlIGlmIHRoZSBpZHMgYXJlIGVxdWFsLiBUaGVuIHNhdmVzIHRoZVxuICAgKiB1bmFwcHJvdmVkUGVyc29uYWxNc2dzIGluZGV4IHRvIHN0b3JhZ2UgdmlhIHRoaXMuX3NhdmVNc2dMaXN0XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bXNnfSBQZXJzb25hbE1lc3NhZ2UgLSBBIFBlcnNvbmFsTWVzc2FnZSB0aGF0IHdpbGwgcmVwbGFjZSBhbiBleGlzdGluZyBQZXJzb25hbE1lc3NhZ2UgKHdpdGggdGhlIHNhbWVcbiAgICogaWQpIGluIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICovXG4gIF91cGRhdGVNc2cobXNnKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm1lc3NhZ2VzLmZpbmRJbmRleCgobWVzc2FnZSkgPT4gbWVzc2FnZS5pZCA9PT0gbXNnLmlkKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VzW2luZGV4XSA9IG1zZztcbiAgICB9XG4gICAgdGhpcy5fc2F2ZU1zZ0xpc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgdW5hcHByb3ZlZCBQZXJzb25hbE1lc3NhZ2VzLCBhbmQgdGhlaXIgY291bnQsIHRvIHRoaXMubWVtU3RvcmVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzICd1cGRhdGVCYWRnZSdcbiAgICpcbiAgICovXG4gIF9zYXZlTXNnTGlzdCgpIHtcbiAgICBjb25zdCB1bmFwcHJvdmVkUGVyc29uYWxNc2dzID0gdGhpcy5nZXRVbmFwcHJvdmVkTXNncygpO1xuICAgIGNvbnN0IHVuYXBwcm92ZWRQZXJzb25hbE1zZ0NvdW50ID0gT2JqZWN0LmtleXModW5hcHByb3ZlZFBlcnNvbmFsTXNncylcbiAgICAgIC5sZW5ndGg7XG4gICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICB1bmFwcHJvdmVkUGVyc29uYWxNc2dzLFxuICAgICAgdW5hcHByb3ZlZFBlcnNvbmFsTXNnQ291bnQsXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSk7XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyByYXcgYnVmZmVyIGRhdGEgdG8gYSBoZXgsIG9yIGp1c3QgcmV0dXJucyB0aGUgZGF0YSBpZiBpdCBpcyBhbHJlYWR5IGZvcm1hdHRlZCBhcyBhIGhleC5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGRhdGEgLSBUaGUgYnVmZmVyIGRhdGEgdG8gY29udmVydCB0byBhIGhleFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIGhleCBzdHJpbmcgY29udmVyc2lvbiBvZiB0aGUgYnVmZmVyIGRhdGFcbiAgICpcbiAgICovXG4gIG5vcm1hbGl6ZU1zZ0RhdGEoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJpcHBlZCA9IHN0cmlwSGV4UHJlZml4KGRhdGEpO1xuICAgICAgaWYgKHN0cmlwcGVkLm1hdGNoKGhleFJlKSkge1xuICAgICAgICByZXR1cm4gYWRkSGV4UHJlZml4KHN0cmlwcGVkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2cuZGVidWcoYE1lc3NhZ2Ugd2FzIG5vdCBoZXggZW5jb2RlZCwgaW50ZXJwcmV0aW5nIGFzIHV0ZjguYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlclRvSGV4KEJ1ZmZlci5mcm9tKGRhdGEsICd1dGY4JykpO1xuICB9XG59XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7IGV0aEVycm9ycyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsgTUVTU0FHRV9UWVBFIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hcHAnO1xuaW1wb3J0IHsgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMgfSBmcm9tICcuLi9tZXRhbWFzay1jb250cm9sbGVyJztcbmltcG9ydCBjcmVhdGVJZCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9yYW5kb20taWQnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMsIGFuZCBjb250YWlucyBkYXRhIGFib3V0LCBhbiAnZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXknIHR5cGUgcmVxdWVzdC4gVGhlc2UgYXJlIGNyZWF0ZWQgd2hlblxuICogYW4gZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkgY2FsbCBpcyByZXF1ZXN0ZWQuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRW5jcnlwdGlvblB1YmxpY0tleVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlkIEFuIGlkIHRvIHRyYWNrIGFuZCBpZGVudGlmeSB0aGUgbWVzc2FnZSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtc2dQYXJhbXMgVGhlIHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgZW5jcnlwdGlvblB1YmxpY0tleSBtZXRob2Qgb25jZSB0aGUgcmVxdWVzdCBpc1xuICogYXBwcm92ZWQuXG4gKiBAcHJvcGVydHkge09iamVjdH0gbXNnUGFyYW1zLm1ldGFtYXNrSWQgQWRkZWQgdG8gbXNnUGFyYW1zIGZvciB0cmFja2luZyBhbmQgaWRlbnRpZmljYXRpb24gd2l0aGluIE1ldGFNYXNrLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1zZ1BhcmFtcy5kYXRhIEEgaGV4IHN0cmluZyBjb252ZXJzaW9uIG9mIHRoZSByYXcgYnVmZmVyIGRhdGEgb2YgdGhlIHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lIFRoZSBlcG9jaCB0aW1lIGF0IHdoaWNoIHRoZSB0aGlzIG1lc3NhZ2Ugd2FzIGNyZWF0ZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0dXMgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgJ3VuYXBwcm92ZWQnLCAnYXBwcm92ZWQnLCAncmVjZWl2ZWQnIG9yICdyZWplY3RlZCdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIFRoZSBqc29uLXByYyBtZXRob2QgZm9yIHdoaWNoIGEgcmVxdWVzdCBoYXMgYmVlbiBtYWRlLiBBICdNZXNzYWdlJyB3aWxsXG4gKiBhbHdheXMgaGF2ZSBhICdldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleScgdHlwZS5cbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5jcnlwdGlvblB1YmxpY0tleU1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ29udHJvbGxlciBpbiBjaGFyZ2Ugb2YgbWFuYWdpbmcgLSBzdG9yaW5nLCBhZGRpbmcsIHJlbW92aW5nLCB1cGRhdGluZyAtIEVuY3J5cHRpb25QdWJsaWNLZXkuXG4gICAqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtZW1TdG9yZSBUaGUgb2JzZXJ2YWJsZSBzdG9yZSB3aGVyZSBFbmNyeXB0aW9uUHVibGljS2V5IGFyZSBzYXZlZCB3aXRoIHBlcnNpc3RhbmNlLlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gbWVtU3RvcmUudW5hcHByb3ZlZEVuY3J5cHRpb25QdWJsaWNLZXlNc2dzIEEgY29sbGVjdGlvbiBvZiBhbGwgRW5jcnlwdGlvblB1YmxpY0tleXMgaW4gdGhlICd1bmFwcHJvdmVkJyBzdGF0ZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gbWVtU3RvcmUudW5hcHByb3ZlZEVuY3J5cHRpb25QdWJsaWNLZXlNc2dDb3VudCBUaGUgY291bnQgb2YgYWxsIEVuY3J5cHRpb25QdWJsaWNLZXlzIGluIHRoaXMubWVtU3RvcmUudW5hcHByb2JlZE1zZ3NcbiAgICogQHByb3BlcnR5IHtBcnJheX0gbWVzc2FnZXMgSG9sZHMgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBiZWVuIGNyZWF0ZWQgYnkgdGhpcyBFbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlclxuICAgKlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tZW1TdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgdW5hcHByb3ZlZEVuY3J5cHRpb25QdWJsaWNLZXlNc2dzOiB7fSxcbiAgICAgIHVuYXBwcm92ZWRFbmNyeXB0aW9uUHVibGljS2V5TXNnQ291bnQ6IDAsXG4gICAgfSk7XG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMubWV0cmljc0V2ZW50ID0gb3B0cy5tZXRyaWNzRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSBudW1iZXIgb2YgJ3VuYXBwcm92ZWQnIEVuY3J5cHRpb25QdWJsaWNLZXlzIGluIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiAndW5hcHByb3ZlZCcgRW5jcnlwdGlvblB1YmxpY0tleXMgaW4gdGhpcy5tZXNzYWdlc1xuICAgKlxuICAgKi9cbiAgZ2V0IHVuYXBwcm92ZWRFbmNyeXB0aW9uUHVibGljS2V5TXNnQ291bnQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0VW5hcHByb3ZlZE1zZ3MoKSkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIGZvciB0aGUgJ3VuYXBwcm92ZWQnIEVuY3J5cHRpb25QdWJsaWNLZXlzIGluIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gQW4gaW5kZXggb2YgRW5jcnlwdGlvblB1YmxpY0tleSBpZHMgdG8gRW5jcnlwdGlvblB1YmxpY0tleXMsIGZvciBhbGwgJ3VuYXBwcm92ZWQnIEVuY3J5cHRpb25QdWJsaWNLZXlzIGluXG4gICAqIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICovXG4gIGdldFVuYXBwcm92ZWRNc2dzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzXG4gICAgICAuZmlsdGVyKChtc2cpID0+IG1zZy5zdGF0dXMgPT09ICd1bmFwcHJvdmVkJylcbiAgICAgIC5yZWR1Y2UoKHJlc3VsdCwgbXNnKSA9PiB7XG4gICAgICAgIHJlc3VsdFttc2cuaWRdID0gbXNnO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRW5jcnlwdGlvblB1YmxpY0tleSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtc2dQYXJhbXMuIHRoaXMuYWRkTXNnIGlzIGNhbGxlZCB0byBhZGRcbiAgICogdGhlIG5ldyBFbmNyeXB0aW9uUHVibGljS2V5IHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZSB1bmFwcHJvdmVkIEVuY3J5cHRpb25QdWJsaWNLZXlzIGZyb20gdGhhdCBsaXN0IHRvXG4gICAqIHRoaXMubWVtU3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhZGRyZXNzIC0gVGhlIHBhcmFtIGZvciB0aGUgZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkgY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3JlcV0gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59IFRoZSByYXcgcHVibGljIGtleSBjb250ZW50c1xuICAgKlxuICAgKi9cbiAgYWRkVW5hcHByb3ZlZE1lc3NhZ2VBc3luYyhhZGRyZXNzLCByZXEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ01ldGFNYXNrIE1lc3NhZ2U6IGFkZHJlc3MgZmllbGQgaXMgcmVxdWlyZWQuJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBtc2dJZCA9IHRoaXMuYWRkVW5hcHByb3ZlZE1lc3NhZ2UoYWRkcmVzcywgcmVxKTtcbiAgICAgIHRoaXMub25jZShgJHttc2dJZH06ZmluaXNoZWRgLCAoZGF0YSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSAncmVjZWl2ZWQnOlxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhLnJhd0RhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgZXRoRXJyb3JzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QoXG4gICAgICAgICAgICAgICAgJ01ldGFNYXNrIEVuY3J5cHRpb25QdWJsaWNLZXk6IFVzZXIgZGVuaWVkIG1lc3NhZ2UgRW5jcnlwdGlvblB1YmxpY0tleS4nLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYE1ldGFNYXNrIEVuY3J5cHRpb25QdWJsaWNLZXk6IFVua25vd24gcHJvYmxlbTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgKX1gLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBFbmNyeXB0aW9uUHVibGljS2V5IHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1zZ1BhcmFtcy4gdGhpcy5hZGRNc2cgaXMgY2FsbGVkIHRvIGFkZFxuICAgKiB0aGUgbmV3IEVuY3J5cHRpb25QdWJsaWNLZXkgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlIHVuYXBwcm92ZWQgRW5jcnlwdGlvblB1YmxpY0tleXMgZnJvbSB0aGF0IGxpc3QgdG9cbiAgICogdGhpcy5tZW1TdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFkZHJlc3MgLSBUaGUgcGFyYW0gZm9yIHRoZSBldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleSBjYWxsIHRvIGJlIG1hZGUgYWZ0ZXIgdGhlIG1lc3NhZ2UgaXMgYXBwcm92ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxXSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdCBwb3NzaWJseSBjb250YWluaW5nIHRoZSBvcmlnaW5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIGlkIG9mIHRoZSBuZXdseSBjcmVhdGVkIEVuY3J5cHRpb25QdWJsaWNLZXkuXG4gICAqXG4gICAqL1xuICBhZGRVbmFwcHJvdmVkTWVzc2FnZShhZGRyZXNzLCByZXEpIHtcbiAgICBsb2cuZGVidWcoYEVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyIGFkZFVuYXBwcm92ZWRNZXNzYWdlOiBhZGRyZXNzYCk7XG4gICAgLy8gY3JlYXRlIHR4RGF0YSBvYmogd2l0aCBwYXJhbWV0ZXJzIGFuZCBtZXRhIGRhdGFcbiAgICBjb25zdCB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgbXNnSWQgPSBjcmVhdGVJZCgpO1xuICAgIGNvbnN0IG1zZ0RhdGEgPSB7XG4gICAgICBpZDogbXNnSWQsXG4gICAgICBtc2dQYXJhbXM6IGFkZHJlc3MsXG4gICAgICB0aW1lLFxuICAgICAgc3RhdHVzOiAndW5hcHByb3ZlZCcsXG4gICAgICB0eXBlOiBNRVNTQUdFX1RZUEUuRVRIX0dFVF9FTkNSWVBUSU9OX1BVQkxJQ19LRVksXG4gICAgfTtcblxuICAgIGlmIChyZXEpIHtcbiAgICAgIG1zZ0RhdGEub3JpZ2luID0gcmVxLm9yaWdpbjtcbiAgICB9XG5cbiAgICB0aGlzLmFkZE1zZyhtc2dEYXRhKTtcblxuICAgIC8vIHNpZ25hbCB1cGRhdGVcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuICAgIHJldHVybiBtc2dJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcGFzc2VkIEVuY3J5cHRpb25QdWJsaWNLZXkgdG8gdGhpcy5tZXNzYWdlcywgYW5kIGNhbGxzIHRoaXMuX3NhdmVNc2dMaXN0KCkgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBFbmNyeXB0aW9uUHVibGljS2V5cyBmcm9tIHRoYXRcbiAgICogbGlzdCB0byB0aGlzLm1lbVN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1zZyBUaGUgRW5jcnlwdGlvblB1YmxpY0tleSB0byBhZGQgdG8gdGhpcy5tZXNzYWdlc1xuICAgKlxuICAgKi9cbiAgYWRkTXNnKG1zZykge1xuICAgIHRoaXMubWVzc2FnZXMucHVzaChtc2cpO1xuICAgIHRoaXMuX3NhdmVNc2dMaXN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBFbmNyeXB0aW9uUHVibGljS2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgVGhlIGlkIG9mIHRoZSBFbmNyeXB0aW9uUHVibGljS2V5IHRvIGdldFxuICAgKiBAcmV0dXJucyB7RW5jcnlwdGlvblB1YmxpY0tleXx1bmRlZmluZWR9IFRoZSBFbmNyeXB0aW9uUHVibGljS2V5IHdpdGggdGhlIGlkIHRoYXQgbWF0Y2hlcyB0aGUgcGFzc2VkIG1zZ0lkLCBvciB1bmRlZmluZWRcbiAgICogaWYgbm8gRW5jcnlwdGlvblB1YmxpY0tleSBoYXMgdGhhdCBpZC5cbiAgICpcbiAgICovXG4gIGdldE1zZyhtc2dJZCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLmZpbmQoKG1zZykgPT4gbXNnLmlkID09PSBtc2dJZCk7XG4gIH1cblxuICAvKipcbiAgICogQXBwcm92ZXMgYSBFbmNyeXB0aW9uUHVibGljS2V5LiBTZXRzIHRoZSBtZXNzYWdlIHN0YXR1cyB2aWEgYSBjYWxsIHRvIHRoaXMuc2V0TXNnU3RhdHVzQXBwcm92ZWQsIGFuZCByZXR1cm5zIGEgcHJvbWlzZVxuICAgKiB3aXRoIGFueSB0aGUgbWVzc2FnZSBwYXJhbXMgbW9kaWZpZWQgZm9yIHByb3BlciBwcm92aWRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgVGhlIG1zZ1BhcmFtcyB0byBiZSB1c2VkIHdoZW4gZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkgaXMgY2FsbGVkLCBwbHVzIGRhdGEgYWRkZWQgYnkgTWV0YU1hc2suXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMubWV0YW1hc2tJZCBBZGRlZCB0byBtc2dQYXJhbXMgZm9yIHRyYWNraW5nIGFuZCBpZGVudGlmaWNhdGlvbiB3aXRoaW4gTWV0YU1hc2suXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFByb21pc2VzIHRoZSBtc2dQYXJhbXMgb2JqZWN0IHdpdGggbWV0YW1hc2tJZCByZW1vdmVkLlxuICAgKlxuICAgKi9cbiAgYXBwcm92ZU1lc3NhZ2UobXNnUGFyYW1zKSB7XG4gICAgdGhpcy5zZXRNc2dTdGF0dXNBcHByb3ZlZChtc2dQYXJhbXMubWV0YW1hc2tJZCk7XG4gICAgcmV0dXJuIHRoaXMucHJlcE1zZ0ZvckVuY3J5cHRpb25QdWJsaWNLZXkobXNnUGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgRW5jcnlwdGlvblB1YmxpY0tleSBzdGF0dXMgdG8gJ2FwcHJvdmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIFRoZSBpZCBvZiB0aGUgRW5jcnlwdGlvblB1YmxpY0tleSB0byBhcHByb3ZlLlxuICAgKlxuICAgKi9cbiAgc2V0TXNnU3RhdHVzQXBwcm92ZWQobXNnSWQpIHtcbiAgICB0aGlzLl9zZXRNc2dTdGF0dXMobXNnSWQsICdhcHByb3ZlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBFbmNyeXB0aW9uUHVibGljS2V5IHN0YXR1cyB0byAncmVjZWl2ZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzIGFuZCB1cGRhdGVzIHRoYXQgRW5jcnlwdGlvblB1YmxpY0tleSBpblxuICAgKiB0aGlzLm1lc3NhZ2VzIGJ5IGFkZGluZyB0aGUgcmF3IGRhdGEgb2YgcmVxdWVzdCB0byB0aGUgRW5jcnlwdGlvblB1YmxpY0tleVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgVGhlIGlkIG9mIHRoZSBFbmNyeXB0aW9uUHVibGljS2V5LlxuICAgKiBAcGFyYW0ge2J1ZmZlcn0gcmF3RGF0YSBUaGUgcmF3IGRhdGEgb2YgdGhlIG1lc3NhZ2UgcmVxdWVzdFxuICAgKlxuICAgKi9cbiAgc2V0TXNnU3RhdHVzUmVjZWl2ZWQobXNnSWQsIHJhd0RhdGEpIHtcbiAgICBjb25zdCBtc2cgPSB0aGlzLmdldE1zZyhtc2dJZCk7XG4gICAgbXNnLnJhd0RhdGEgPSByYXdEYXRhO1xuICAgIHRoaXMuX3VwZGF0ZU1zZyhtc2cpO1xuICAgIHRoaXMuX3NldE1zZ1N0YXR1cyhtc2dJZCwgJ3JlY2VpdmVkJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSBmcm9tIHBhc3NlZCBtc2dQYXJhbXMgYW5kIHJldHVybnMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRoZSB1cGRhdGVkIG1zZ1BhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIFRoZSBtc2dQYXJhbXMgdG8gbW9kaWZ5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFByb21pc2VzIHRoZSBtc2dQYXJhbXMgd2l0aCB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSByZW1vdmVkXG4gICAqXG4gICAqL1xuICBwcmVwTXNnRm9yRW5jcnlwdGlvblB1YmxpY0tleShtc2dQYXJhbXMpIHtcbiAgICBkZWxldGUgbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2dQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBFbmNyeXB0aW9uUHVibGljS2V5IHN0YXR1cyB0byAncmVqZWN0ZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgVGhlIGlkIG9mIHRoZSBFbmNyeXB0aW9uUHVibGljS2V5IHRvIHJlamVjdC5cbiAgICpcbiAgICovXG4gIHJlamVjdE1zZyhtc2dJZCwgcmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHJlYXNvbikge1xuICAgICAgdGhpcy5tZXRyaWNzRXZlbnQoe1xuICAgICAgICBldmVudDogcmVhc29uLFxuICAgICAgICBjYXRlZ29yeTogJ01lc3NhZ2VzJyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGFjdGlvbjogJ0VuY3J5cHRpb24gcHVibGljIGtleSBSZXF1ZXN0JyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9zZXRNc2dTdGF0dXMobXNnSWQsICdyZWplY3RlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBUeXBlZE1lc3NhZ2Ugc3RhdHVzIHRvICdlcnJvcmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIFRoZSBpZCBvZiB0aGUgVHlwZWRNZXNzYWdlIHRvIGVycm9yXG4gICAqXG4gICAqL1xuICBlcnJvck1lc3NhZ2UobXNnSWQsIGVycm9yKSB7XG4gICAgY29uc3QgbXNnID0gdGhpcy5nZXRNc2cobXNnSWQpO1xuICAgIG1zZy5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMuX3VwZGF0ZU1zZyhtc2cpO1xuICAgIHRoaXMuX3NldE1zZ1N0YXR1cyhtc2dJZCwgJ2Vycm9yZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIHVuYXBwcm92ZWQgbWVzc2FnZXMgZnJvbSBtZW1vcnkuXG4gICAqL1xuICBjbGVhclVuYXBwcm92ZWQoKSB7XG4gICAgdGhpcy5tZXNzYWdlcyA9IHRoaXMubWVzc2FnZXMuZmlsdGVyKChtc2cpID0+IG1zZy5zdGF0dXMgIT09ICd1bmFwcHJvdmVkJyk7XG4gICAgdGhpcy5fc2F2ZU1zZ0xpc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzdGF0dXMgb2YgYSBFbmNyeXB0aW9uUHVibGljS2V5IGluIHRoaXMubWVzc2FnZXMgdmlhIGEgY2FsbCB0byB0aGlzLl91cGRhdGVNc2dcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIFRoZSBpZCBvZiB0aGUgRW5jcnlwdGlvblB1YmxpY0tleSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXMgVGhlIG5ldyBzdGF0dXMgb2YgdGhlIEVuY3J5cHRpb25QdWJsaWNLZXkuXG4gICAqIEB0aHJvd3MgQSAnRW5jcnlwdGlvblB1YmxpY0tleU1hbmFnZXIgLSBFbmNyeXB0aW9uUHVibGljS2V5IG5vdCBmb3VuZCBmb3IgaWQ6IFwiJHttc2dJZH1cIi4nIGlmIHRoZXJlIGlzIG5vIEVuY3J5cHRpb25QdWJsaWNLZXlcbiAgICogaW4gdGhpcy5tZXNzYWdlcyB3aXRoIGFuIGlkIGVxdWFsIHRvIHRoZSBwYXNzZWQgbXNnSWRcbiAgICogQGZpcmVzIEFuIGV2ZW50IHdpdGggYSBuYW1lIGVxdWFsIHRvIGAke21zZ0lkfToke3N0YXR1c31gLiBUaGUgRW5jcnlwdGlvblB1YmxpY0tleSBpcyBhbHNvIGZpcmVkLlxuICAgKiBAZmlyZXMgSWYgc3RhdHVzIGlzICdyZWplY3RlZCcgb3IgJ3JlY2VpdmVkJywgYW4gZXZlbnQgd2l0aCBhIG5hbWUgZXF1YWwgdG8gYCR7bXNnSWR9OmZpbmlzaGVkYCBpcyBmaXJlZCBhbG9uZ1xuICAgKiB3aXRoIHRoZSBFbmNyeXB0aW9uUHVibGljS2V5XG4gICAqXG4gICAqL1xuICBfc2V0TXNnU3RhdHVzKG1zZ0lkLCBzdGF0dXMpIHtcbiAgICBjb25zdCBtc2cgPSB0aGlzLmdldE1zZyhtc2dJZCk7XG4gICAgaWYgKCFtc2cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyIC0gTWVzc2FnZSBub3QgZm91bmQgZm9yIGlkOiBcIiR7bXNnSWR9XCIuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIG1zZy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5lbWl0KGAke21zZ0lkfToke3N0YXR1c31gLCBtc2cpO1xuICAgIGlmIChzdGF0dXMgPT09ICdyZWplY3RlZCcgfHwgc3RhdHVzID09PSAncmVjZWl2ZWQnKSB7XG4gICAgICB0aGlzLmVtaXQoYCR7bXNnSWR9OmZpbmlzaGVkYCwgbXNnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIEVuY3J5cHRpb25QdWJsaWNLZXkgaW4gdGhpcy5tZXNzYWdlcyB0byB0aGUgcGFzc2VkIEVuY3J5cHRpb25QdWJsaWNLZXkgaWYgdGhlIGlkcyBhcmUgZXF1YWwuIFRoZW4gc2F2ZXMgdGhlXG4gICAqIHVuYXBwcm92ZWRFbmNyeXB0aW9uUHVibGljS2V5TXNncyBpbmRleCB0byBzdG9yYWdlIHZpYSB0aGlzLl9zYXZlTXNnTGlzdFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0VuY3J5cHRpb25QdWJsaWNLZXl9IG1zZyAtIEEgRW5jcnlwdGlvblB1YmxpY0tleSB0aGF0IHdpbGwgcmVwbGFjZSBhbiBleGlzdGluZyBFbmNyeXB0aW9uUHVibGljS2V5ICh3aXRoIHRoZSBzYW1lXG4gICAqIGlkKSBpbiB0aGlzLm1lc3NhZ2VzXG4gICAqXG4gICAqL1xuICBfdXBkYXRlTXNnKG1zZykge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tZXNzYWdlcy5maW5kSW5kZXgoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuaWQgPT09IG1zZy5pZCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5tZXNzYWdlc1tpbmRleF0gPSBtc2c7XG4gICAgfVxuICAgIHRoaXMuX3NhdmVNc2dMaXN0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgdGhlIHVuYXBwcm92ZWQgRW5jcnlwdGlvblB1YmxpY0tleXMsIGFuZCB0aGVpciBjb3VudCwgdG8gdGhpcy5tZW1TdG9yZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZmlyZXMgJ3VwZGF0ZUJhZGdlJ1xuICAgKlxuICAgKi9cbiAgX3NhdmVNc2dMaXN0KCkge1xuICAgIGNvbnN0IHVuYXBwcm92ZWRFbmNyeXB0aW9uUHVibGljS2V5TXNncyA9IHRoaXMuZ2V0VW5hcHByb3ZlZE1zZ3MoKTtcbiAgICBjb25zdCB1bmFwcHJvdmVkRW5jcnlwdGlvblB1YmxpY0tleU1zZ0NvdW50ID0gT2JqZWN0LmtleXMoXG4gICAgICB1bmFwcHJvdmVkRW5jcnlwdGlvblB1YmxpY0tleU1zZ3MsXG4gICAgKS5sZW5ndGg7XG4gICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICB1bmFwcHJvdmVkRW5jcnlwdGlvblB1YmxpY0tleU1zZ3MsXG4gICAgICB1bmFwcHJvdmVkRW5jcnlwdGlvblB1YmxpY0tleU1zZ0NvdW50LFxuICAgIH0pO1xuICAgIHRoaXMuZW1pdChNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUy5VUERBVEVfQkFER0UpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBtZXJnZSwgb21pdCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7IGJ1ZmZlclRvSGV4LCBrZWNjYWsgfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuaW1wb3J0IHsgRU5WSVJPTk1FTlRfVFlQRV9CQUNLR1JPVU5EIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hcHAnO1xuaW1wb3J0IHtcbiAgTUVUQU1FVFJJQ1NfQU5PTllNT1VTX0lELFxuICBNRVRBTUVUUklDU19CQUNLR1JPVU5EX1BBR0VfT0JKRUNULFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL21ldGFtZXRyaWNzJztcblxuY29uc3QgZGVmYXVsdENhcHR1cmVFeGNlcHRpb24gPSAoZXJyKSA9PiB7XG4gIC8vIHRocm93IGVycm9yIG9uIGNsZWFuIHN0YWNrIHNvIGl0cyBjYXB0dXJlZCBieSBwbGF0Zm9ybSBpbnRlZ3JhdGlvbnMgKGVnIHNlbnRyeSlcbiAgLy8gYnV0IGRvZXMgbm90IGludGVydXB0IHRoZSBjYWxsIHN0YWNrXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRocm93IGVycjtcbiAgfSk7XG59O1xuXG5jb25zdCBleGNlcHRpb25zVG9GaWx0ZXIgPSB7XG4gIFtgWW91IG11c3QgcGFzcyBlaXRoZXIgYW4gXCJhbm9ueW1vdXNJZFwiIG9yIGEgXCJ1c2VySWRcIi5gXTogdHJ1ZSxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9tZXRhbWV0cmljcycpLk1ldGFNZXRyaWNzQ29udGV4dH0gTWV0YU1ldHJpY3NDb250ZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL21ldGFtZXRyaWNzJykuTWV0YU1ldHJpY3NFdmVudFBheWxvYWR9IE1ldGFNZXRyaWNzRXZlbnRQYXlsb2FkXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL21ldGFtZXRyaWNzJykuTWV0YU1ldHJpY3NFdmVudE9wdGlvbnN9IE1ldGFNZXRyaWNzRXZlbnRPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL21ldGFtZXRyaWNzJykuU2VnbWVudEV2ZW50UGF5bG9hZH0gU2VnbWVudEV2ZW50UGF5bG9hZFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9tZXRhbWV0cmljcycpLlNlZ21lbnRJbnRlcmZhY2V9IFNlZ21lbnRJbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbWV0YW1ldHJpY3MnKS5NZXRhTWV0cmljc1BhZ2VQYXlsb2FkfSBNZXRhTWV0cmljc1BhZ2VQYXlsb2FkXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL21ldGFtZXRyaWNzJykuTWV0YU1ldHJpY3NQYWdlT3B0aW9uc30gTWV0YU1ldHJpY3NQYWdlT3B0aW9uc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YU1ldHJpY3NDb250cm9sbGVyU3RhdGVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gbWV0YU1ldHJpY3NJZCAtIFRoZSB1c2VyJ3MgbWV0YU1ldHJpY3NJZCB0aGF0IHdpbGwgYmVcbiAqICBhdHRhY2hlZCB0byBhbGwgbm9uLWFub255bWl6ZWQgZXZlbnQgcGF5bG9hZHNcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IHBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcyAtIFRoZSB1c2VyJ3MgcHJlZmVyZW5jZSBmb3JcbiAqICBwYXJ0aWNpcGF0aW5nIGluIHRoZSBNZXRhTWV0cmljcyBhbmFseXRpY3MgcHJvZ3JhbS4gVGhpcyBzZXR0aW5nIGNvbnRyb2xzXG4gKiAgd2hldGhlciBvciBub3QgZXZlbnRzIGFyZSB0cmFja2VkXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWV0YU1ldHJpY3NDb250cm9sbGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZWdtZW50IC0gYW4gaW5zdGFuY2Ugb2YgYW5hbHl0aWNzLW5vZGUgZm9yIHRyYWNraW5nXG4gICAqICBldmVudHMgdGhhdCBjb25mb3JtIHRvIHRoZSBuZXcgTWV0YU1ldHJpY3MgdHJhY2tpbmcgcGxhbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IHByZWZlcmVuY2VzU3RvcmUgLSBUaGUgcHJlZmVyZW5jZXMgY29udHJvbGxlciBzdG9yZSwgdXNlZFxuICAgKiAgdG8gYWNjZXNzIGFuZCBzdWJzY3JpYmUgdG8gcHJlZmVyZW5jZXMgdGhhdCB3aWxsIGJlIGF0dGFjaGVkIHRvIGV2ZW50c1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbk5ldHdvcmtEaWRDaGFuZ2UgLSBVc2VkIHRvIGF0dGFjaCBhIGxpc3RlbmVyIHRvIHRoZVxuICAgKiAgbmV0d29ya0RpZENoYW5nZSBldmVudCBlbWl0dGVkIGJ5IHRoZSBuZXR3b3JrQ29udHJvbGxlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRDdXJyZW50Q2hhaW5JZCAtIEdldHMgdGhlIGN1cnJlbnQgY2hhaW4gaWQgZnJvbSB0aGVcbiAgICogIG5ldHdvcmsgY29udHJvbGxlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXROZXR3b3JrSWRlbnRpZmllciAtIEdldHMgdGhlIGN1cnJlbnQgbmV0d29ya1xuICAgKiAgaWRlbnRpZmllciBmcm9tIHRoZSBuZXR3b3JrIGNvbnRyb2xsZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gLSBUaGUgdmVyc2lvbiBvZiB0aGUgZXh0ZW5zaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnZpcm9ubWVudCAtIFRoZSBlbnZpcm9ubWVudCB0aGUgZXh0ZW5zaW9uIGlzIHJ1bm5pbmcgaW5cbiAgICogQHBhcmFtIHtNZXRhTWV0cmljc0NvbnRyb2xsZXJTdGF0ZX0gaW5pdFN0YXRlIC0gU3RhdGUgdG8gaW5pdGlhbGl6ZWQgd2l0aFxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHNlZ21lbnQsXG4gICAgcHJlZmVyZW5jZXNTdG9yZSxcbiAgICBvbk5ldHdvcmtEaWRDaGFuZ2UsXG4gICAgZ2V0Q3VycmVudENoYWluSWQsXG4gICAgZ2V0TmV0d29ya0lkZW50aWZpZXIsXG4gICAgdmVyc2lvbixcbiAgICBlbnZpcm9ubWVudCxcbiAgICBpbml0U3RhdGUsXG4gICAgY2FwdHVyZUV4Y2VwdGlvbiA9IGRlZmF1bHRDYXB0dXJlRXhjZXB0aW9uLFxuICB9KSB7XG4gICAgdGhpcy5fY2FwdHVyZUV4Y2VwdGlvbiA9IChlcnIpID0+IHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0ZW1wb3JhcnkgbWVhc3VyZS4gQ3VycmVudGx5IHRoZXJlIGFyZSBlcnJvcnMgZmxvb2Rpbmcgc2VudHJ5IGR1ZSB0byBhIHByb2JsZW0gaW4gaG93IHdlIGFyZSB0cmFja2luZyBhbm9ueW1vdXNJZFxuICAgICAgLy8gV2UgaW50ZW5kIG9uIHJlbW92aW5nIHRoaXMgYXMgc29vbiBhcyB3ZSB1bmRlcnN0YW5kIGhvdyB0byBjb3JyZWN0bHkgc29sdmUgdGhhdCBwcm9ibGVtLlxuICAgICAgaWYgKCFleGNlcHRpb25zVG9GaWx0ZXJbZXJyLm1lc3NhZ2VdKSB7XG4gICAgICAgIGNhcHR1cmVFeGNlcHRpb24oZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHByZWZTdGF0ZSA9IHByZWZlcmVuY2VzU3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLmNoYWluSWQgPSBnZXRDdXJyZW50Q2hhaW5JZCgpO1xuICAgIHRoaXMubmV0d29yayA9IGdldE5ldHdvcmtJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5sb2NhbGUgPSBwcmVmU3RhdGUuY3VycmVudExvY2FsZS5yZXBsYWNlKCdfJywgJy0nKTtcbiAgICB0aGlzLnZlcnNpb24gPVxuICAgICAgZW52aXJvbm1lbnQgPT09ICdwcm9kdWN0aW9uJyA/IHZlcnNpb24gOiBgJHt2ZXJzaW9ufS0ke2Vudmlyb25tZW50fWA7XG5cbiAgICB0aGlzLnN0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZSh7XG4gICAgICBwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3M6IG51bGwsXG4gICAgICBtZXRhTWV0cmljc0lkOiBudWxsLFxuICAgICAgLi4uaW5pdFN0YXRlLFxuICAgIH0pO1xuXG4gICAgcHJlZmVyZW5jZXNTdG9yZS5zdWJzY3JpYmUoKHsgY3VycmVudExvY2FsZSB9KSA9PiB7XG4gICAgICB0aGlzLmxvY2FsZSA9IGN1cnJlbnRMb2NhbGUucmVwbGFjZSgnXycsICctJyk7XG4gICAgfSk7XG5cbiAgICBvbk5ldHdvcmtEaWRDaGFuZ2UoKCkgPT4ge1xuICAgICAgdGhpcy5jaGFpbklkID0gZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICAgIHRoaXMubmV0d29yayA9IGdldE5ldHdvcmtJZGVudGlmaWVyKCk7XG4gICAgfSk7XG4gICAgdGhpcy5zZWdtZW50ID0gc2VnbWVudDtcbiAgfVxuXG4gIGdlbmVyYXRlTWV0YU1ldHJpY3NJZCgpIHtcbiAgICByZXR1cm4gYnVmZmVyVG9IZXgoXG4gICAgICBrZWNjYWsoXG4gICAgICAgIEJ1ZmZlci5mcm9tKFxuICAgICAgICAgIFN0cmluZyhEYXRlLm5vdygpKSArXG4gICAgICAgICAgICBTdHJpbmcoTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKSxcbiAgICAgICAgKSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBgcGFydGljaXBhdGVJbk1ldGFNZXRyaWNzYCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcyAtIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIHdhbnRzXG4gICAqICB0byBwYXJ0aWNpcGF0ZSBpbiBNZXRhTWV0cmljc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IHRoZSBzdHJpbmcgb2YgdGhlIG5ldyBtZXRhbWV0cmljcyBpZCwgb3IgbnVsbFxuICAgKiAgaWYgbm90IHNldFxuICAgKi9cbiAgc2V0UGFydGljaXBhdGVJbk1ldGFNZXRyaWNzKHBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcykge1xuICAgIGxldCB7IG1ldGFNZXRyaWNzSWQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcyAmJiAhbWV0YU1ldHJpY3NJZCkge1xuICAgICAgbWV0YU1ldHJpY3NJZCA9IHRoaXMuZ2VuZXJhdGVNZXRhTWV0cmljc0lkKCk7XG4gICAgfSBlbHNlIGlmIChwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhTWV0cmljc0lkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcywgbWV0YU1ldHJpY3NJZCB9KTtcbiAgICByZXR1cm4gbWV0YU1ldHJpY3NJZDtcbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIHRoZSBjb250ZXh0IG9iamVjdCB0byBhdHRhY2ggdG8gcGFnZSBhbmQgdHJhY2sgZXZlbnRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1BpY2s8TWV0YU1ldHJpY3NDb250ZXh0LCAncmVmZXJyZXInPn0gW3JlZmVycmVyXSAtIGRhcHAgb3JpZ2luIHRoYXQgaW5pdGlhbGl6ZWRcbiAgICogIHRoZSBub3RpZmljYXRpb24gd2luZG93LlxuICAgKiBAcGFyYW0ge1BpY2s8TWV0YU1ldHJpY3NDb250ZXh0LCAncGFnZSc+fSBbcGFnZV0gLSBwYWdlIG9iamVjdCBkZXNjcmliaW5nIHRoZSBjdXJyZW50XG4gICAqICB2aWV3IG9mIHRoZSBleHRlbnNpb24uIERlZmF1bHRzIHRvIHRoZSBiYWNrZ3JvdW5kLXByb2Nlc3Mgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7TWV0YU1ldHJpY3NDb250ZXh0fVxuICAgKi9cbiAgX2J1aWxkQ29udGV4dChyZWZlcnJlciwgcGFnZSA9IE1FVEFNRVRSSUNTX0JBQ0tHUk9VTkRfUEFHRV9PQkpFQ1QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXBwOiB7XG4gICAgICAgIG5hbWU6ICdNZXRhTWFzayBFeHRlbnNpb24nLFxuICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICB9LFxuICAgICAgdXNlckFnZW50OiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIHBhZ2UsXG4gICAgICByZWZlcnJlcixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkJ3MgdGhlIGV2ZW50IHBheWxvYWQsIHByb2Nlc3NpbmcgYWxsIGZpZWxkcyBpbnRvIGEgZm9ybWF0IHRoYXQgY2FuIGJlXG4gICAqIGZlZCB0byBTZWdtZW50J3MgdHJhY2sgbWV0aG9kXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7XG4gICAqICBPbWl0PE1ldGFNZXRyaWNzRXZlbnRQYXlsb2FkLCAnc2Vuc2l0aXZlUHJvcGVydGllcyc+XG4gICAqIH0gcmF3UGF5bG9hZCAtIHJhdyBwYXlsb2FkIHByb3ZpZGVkIHRvIHRyYWNrRXZlbnRcbiAgICogQHJldHVybnMge1NlZ21lbnRFdmVudFBheWxvYWR9IC0gZm9ybWF0dGVkIGV2ZW50IHBheWxvYWQgZm9yIHNlZ21lbnRcbiAgICovXG4gIF9idWlsZEV2ZW50UGF5bG9hZChyYXdQYXlsb2FkKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXZlbnQsXG4gICAgICBwcm9wZXJ0aWVzLFxuICAgICAgcmV2ZW51ZSxcbiAgICAgIHZhbHVlLFxuICAgICAgY3VycmVuY3ksXG4gICAgICBjYXRlZ29yeSxcbiAgICAgIHBhZ2UsXG4gICAgICByZWZlcnJlcixcbiAgICAgIGVudmlyb25tZW50VHlwZSA9IEVOVklST05NRU5UX1RZUEVfQkFDS0dST1VORCxcbiAgICB9ID0gcmF3UGF5bG9hZDtcbiAgICByZXR1cm4ge1xuICAgICAgZXZlbnQsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8vIFRoZXNlIHZhbHVlcyBhcmUgb21pdHRlZCBmcm9tIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGhhdmUgc3BlY2lhbCBtZWFuaW5nXG4gICAgICAgIC8vIGluIHNlZ21lbnQuIGh0dHBzOi8vc2VnbWVudC5jb20vZG9jcy9jb25uZWN0aW9ucy9zcGVjL3RyYWNrLyNwcm9wZXJ0aWVzLlxuICAgICAgICAvLyB0byBhdm9pZCBhY2NpZGVudGFsbHkgdXNpbmcgdGhlc2UgaW5hcHByb3ByaWF0ZWx5LCB5b3UgbXVzdCBhZGQgdGhlbSBhcyB0b3BcbiAgICAgICAgLy8gbGV2ZWwgcHJvcGVydGllcyBvbiB0aGUgZXZlbnQgcGF5bG9hZC4gV2UgYWxzbyBleGNsdWRlIGxvY2FsZSB0byBwcmV2ZW50IGNvbnN1bWVyc1xuICAgICAgICAvLyBmcm9tIG92ZXJ3cml0aW5nIHRoaXMgY29udGV4dCBsZXZlbCBwcm9wZXJ0eS4gV2UgdHJhY2sgaXQgYXMgYSBwcm9wZXJ0eVxuICAgICAgICAvLyBiZWNhdXNlIG5vdCBhbGwgZGVzdGluYXRpb25zIG1hcCBsb2NhbGUgZnJvbSBjb250ZXh0LlxuICAgICAgICAuLi5vbWl0KHByb3BlcnRpZXMsIFsncmV2ZW51ZScsICdsb2NhbGUnLCAnY3VycmVuY3knLCAndmFsdWUnXSksXG4gICAgICAgIHJldmVudWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjdXJyZW5jeSxcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIG5ldHdvcms6IHByb3BlcnRpZXM/Lm5ldHdvcmsgPz8gdGhpcy5uZXR3b3JrLFxuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgICBjaGFpbl9pZDogcHJvcGVydGllcz8uY2hhaW5faWQgPz8gdGhpcy5jaGFpbklkLFxuICAgICAgICBlbnZpcm9ubWVudF90eXBlOiBlbnZpcm9ubWVudFR5cGUsXG4gICAgICB9LFxuICAgICAgY29udGV4dDogdGhpcy5fYnVpbGRDb250ZXh0KHJlZmVycmVyLCBwYWdlKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdmFsaWRhdGlvbiBvbiB0aGUgcGF5bG9hZCBhbmQgdXBkYXRlIHRoZSBpZCB0eXBlIHRvIHVzZSBiZWZvcmVcbiAgICogc2VuZGluZyB0byBTZWdtZW50LiBBbHNvIGV4YW1pbmVzIHRoZSBvcHRpb25zIHRvIHJvdXRlIGFuZCBoYW5kbGUgdGhlXG4gICAqIGV2ZW50IGFwcHJvcHJpYXRlbHkuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U2VnbWVudEV2ZW50UGF5bG9hZH0gcGF5bG9hZCAtIHByb3BlcnRpZXMgdG8gYXR0YWNoIHRvIGV2ZW50XG4gICAqIEBwYXJhbSB7TWV0YU1ldHJpY3NFdmVudE9wdGlvbnN9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIHJvdXRpbmcgYW5kXG4gICAqICBoYW5kbGluZyB0aGUgZXZlbnRcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBfdHJhY2socGF5bG9hZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzT3B0SW4sXG4gICAgICBtZXRhTWV0cmljc0lkOiBtZXRhTWV0cmljc0lkT3ZlcnJpZGUsXG4gICAgICBtYXRvbW9FdmVudCxcbiAgICAgIGZsdXNoSW1tZWRpYXRlbHksXG4gICAgfSA9IG9wdGlvbnMgfHwge307XG4gICAgbGV0IGlkVHlwZSA9ICd1c2VySWQnO1xuICAgIGxldCBpZFZhbHVlID0gdGhpcy5zdGF0ZS5tZXRhTWV0cmljc0lkO1xuICAgIGxldCBleGNsdWRlTWV0YU1ldHJpY3NJZCA9IG9wdGlvbnM/LmV4Y2x1ZGVNZXRhTWV0cmljc0lkID8/IGZhbHNlO1xuICAgIC8vIFRoaXMgaXMgY2FycmllZCBvdmVyIGZyb20gdGhlIG9sZCBpbXBsZW1lbnRhdGlvbiwgYW5kIHdpbGwgbGlrZWx5IG5lZWRcbiAgICAvLyB0byBiZSB1cGRhdGVkIHRvIHdvcmsgd2l0aCB0aGUgbmV3IHRyYWNraW5nIHBsYW4uIEkgdGhpbmsgd2Ugc2hvdWxkIHVzZVxuICAgIC8vIGEgY29uZmlnIHNldHRpbmcgZm9yIHRoaXMgaW5zdGVhZCBvZiB0cnlpbmcgdG8gbWF0Y2ggdGhlIGV2ZW50IG5hbWVcbiAgICBjb25zdCBpc1NlbmRGbG93ID0gQm9vbGVhbihwYXlsb2FkLmV2ZW50Lm1hdGNoKC9ec2VuZHxeY29uZmlybS9pdSkpO1xuICAgIGlmIChpc1NlbmRGbG93KSB7XG4gICAgICBleGNsdWRlTWV0YU1ldHJpY3NJZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIElmIHdlIGFyZSB0cmFja2luZyBzZW5zaXRpdmUgZGF0YSB3ZSB3aWxsIGFsd2F5cyB1c2UgdGhlIGFub255bW91c0lkXG4gICAgLy8gcHJvcGVydHkgYXMgd2VsbCBhcyBvdXIgTUVUQU1FVFJJQ1NfQU5PTllNT1VTX0lELiBUaGlzIHByZXZlbnRzIHVzIGZyb21cbiAgICAvLyBhc3NvY2lhdGluZyBwb3RlbnRpYWxseSBpZGVudGlmaWFibGUgaW5mb3JtYXRpb24gd2l0aCBhIHNwZWNpZmljIGlkLlxuICAgIC8vIER1cmluZyB0aGUgb3B0IGluIGZsb3cgd2Ugd2lsbCB0cmFjayBhbGwgZXZlbnRzLCBidXQgZG8gc28gd2l0aCB0aGVcbiAgICAvLyBhbm9ueW1vdXMgaWQuIFRoZSBvbmUgZXhjZXB0aW9uIHRvIHRoYXQgcnVsZSBpcyBhZnRlciB0aGUgdXNlciBvcHRzIGluXG4gICAgLy8gdG8gTWV0YU1ldHJpY3MuIFdoZW4gdGhhdCBoYXBwZW5zIHdlIHJlY2VpdmUgYmFjayB0aGUgdXNlcidzIG5ld1xuICAgIC8vIE1ldGFNZXRyaWNzIGlkIGJlZm9yZSBpdCBpcyBmdWxseSBwZXJzaXN0ZWQgdG8gc3RhdGUuIFRvIGF2b2lkIGEgcmFjZVxuICAgIC8vIGNvbmRpdGlvbiB3ZSBleHBsaWNpdGx5IHBhc3MgdGhlIG5ldyBpZCB0byB0aGUgdHJhY2sgbWV0aG9kLiBJbiB0aGF0XG4gICAgLy8gY2FzZSB3ZSB3aWxsIHRyYWNrIHRoZSBvcHQgaW4gZXZlbnQgdG8gdGhlIHVzZXIncyBpZC4gSW4gYWxsIG90aGVyIGNhc2VzXG4gICAgLy8gd2UgdXNlIHRoZSBtZXRhTWV0cmljc0lkIGZyb20gc3RhdGUuXG4gICAgaWYgKGV4Y2x1ZGVNZXRhTWV0cmljc0lkIHx8IChpc09wdEluICYmICFtZXRhTWV0cmljc0lkT3ZlcnJpZGUpKSB7XG4gICAgICBpZFR5cGUgPSAnYW5vbnltb3VzSWQnO1xuICAgICAgaWRWYWx1ZSA9IE1FVEFNRVRSSUNTX0FOT05ZTU9VU19JRDtcbiAgICB9IGVsc2UgaWYgKGlzT3B0SW4gJiYgbWV0YU1ldHJpY3NJZE92ZXJyaWRlKSB7XG4gICAgICBpZFZhbHVlID0gbWV0YU1ldHJpY3NJZE92ZXJyaWRlO1xuICAgIH1cbiAgICBwYXlsb2FkW2lkVHlwZV0gPSBpZFZhbHVlO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBldmVudCBvbiB0aGUgb2xkIG1hdG9tbyBzY2hlbWEsIGFkZCBhIGtleSB0byB0aGUgcGF5bG9hZFxuICAgIC8vIHRvIGRlc2lnbmF0ZSBpdCBhcyBzdWNoXG4gICAgaWYgKG1hdG9tb0V2ZW50ID09PSB0cnVlKSB7XG4gICAgICBwYXlsb2FkLnByb3BlcnRpZXMubGVnYWN5X2V2ZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBQcm9taXNlcyB3aWxsIG9ubHkgcmVzb2x2ZSB3aGVuIHRoZSBldmVudCBpcyBzZW50IHRvIHNlZ21lbnQuIEZvciBhbnlcbiAgICAvLyBldmVudCB0aGF0IHJlbGllcyBvbiB0aGlzIHByb21pc2UgYmVpbmcgZnVsZmlsbGVkIGJlZm9yZSBwZXJmb3JtaW5nIFVJXG4gICAgLy8gdXBkYXRlcywgb3Igb3RoZXJ3aXNlIGRlbGF5aW5nIHVzZXIgaW50ZXJhY3Rpb24sIHN1cHBseSB0aGVcbiAgICAvLyAnZmx1c2hJbW1lZGlhdGVseScgZmxhZyB0byB0aGUgdHJhY2tFdmVudCBtZXRob2QuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gVGhlIGVycm9yIHRoYXQgc2VnbWVudCBnaXZlcyB1cyBoYXMgc29tZSBtYW5pcHVsYXRpb24gZG9uZSB0byBpdFxuICAgICAgICAgIC8vIHRoYXQgc2VlbWluZ2x5IGJyZWFrcyB3aXRoIGxvY2tkb3duIGVuYWJsZWQuIENyZWF0aW5nIGEgbmV3IGVycm9yXG4gICAgICAgICAgLy8gaGVyZSBwcmV2ZW50cyB0aGUgc3lzdGVtIGZyb20gZnJlZXppbmcgd2hlbiB0aGUgbmV0d29yayByZXF1ZXN0IHRvXG4gICAgICAgICAgLy8gc2VnbWVudCBmYWlscyBmb3IgYW55IHJlYXNvbi5cbiAgICAgICAgICBjb25zdCBzYWZlRXJyb3IgPSBuZXcgRXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgIHNhZmVFcnJvci5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KHNhZmVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuc2VnbWVudC50cmFjayhwYXlsb2FkLCBjYWxsYmFjayk7XG4gICAgICBpZiAoZmx1c2hJbW1lZGlhdGVseSkge1xuICAgICAgICB0aGlzLnNlZ21lbnQuZmx1c2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0cmFjayBhIHBhZ2UgdmlldyB3aXRoIFNlZ21lbnRcbiAgICogQHBhcmFtIHtNZXRhTWV0cmljc1BhZ2VQYXlsb2FkfSBwYXlsb2FkIC0gZGV0YWlscyBvZiB0aGUgcGFnZSB2aWV3ZWRcbiAgICogQHBhcmFtIHtNZXRhTWV0cmljc1BhZ2VPcHRpb25zfSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciBoYW5kbGluZyB0aGUgcGFnZVxuICAgKiAgdmlld1xuICAgKi9cbiAgdHJhY2tQYWdlKHsgbmFtZSwgcGFyYW1zLCBlbnZpcm9ubWVudFR5cGUsIHBhZ2UsIHJlZmVycmVyIH0sIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUucGFydGljaXBhdGVJbk1ldGFNZXRyaWNzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5zdGF0ZS5wYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MgPT09IG51bGwgJiZcbiAgICAgICAgIW9wdGlvbnM/LmlzT3B0SW5QYXRoXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBtZXRhTWV0cmljc0lkIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgaWRUcmFpdCA9IG1ldGFNZXRyaWNzSWQgPyAndXNlcklkJyA6ICdhbm9ueW1vdXNJZCc7XG4gICAgICBjb25zdCBpZFZhbHVlID0gbWV0YU1ldHJpY3NJZCA/PyBNRVRBTUVUUklDU19BTk9OWU1PVVNfSUQ7XG4gICAgICB0aGlzLnNlZ21lbnQucGFnZSh7XG4gICAgICAgIFtpZFRyYWl0XTogaWRWYWx1ZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgICAgIG5ldHdvcms6IHRoaXMubmV0d29yayxcbiAgICAgICAgICBjaGFpbl9pZDogdGhpcy5jaGFpbklkLFxuICAgICAgICAgIGVudmlyb25tZW50X3R5cGU6IGVudmlyb25tZW50VHlwZSxcbiAgICAgICAgfSxcbiAgICAgICAgY29udGV4dDogdGhpcy5fYnVpbGRDb250ZXh0KHJlZmVycmVyLCBwYWdlKSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fY2FwdHVyZUV4Y2VwdGlvbihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzdWJtaXRzIGEgbWV0YW1ldHJpY3MgZXZlbnQsIG5vdCB3YWl0aW5nIGZvciBpdCB0byBjb21wbGV0ZSBvciBhbGxvd2luZyBpdHMgZXJyb3IgdG8gYnViYmxlIHVwXG4gICAqIEBwYXJhbSB7TWV0YU1ldHJpY3NFdmVudFBheWxvYWR9IHBheWxvYWQgLSBkZXRhaWxzIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge01ldGFNZXRyaWNzRXZlbnRPcHRpb25zfSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciBoYW5kbGluZy9yb3V0aW5nIHRoZSBldmVudFxuICAgKi9cbiAgdHJhY2tFdmVudChwYXlsb2FkLCBvcHRpb25zKSB7XG4gICAgLy8gdmFsaWRhdGlvbiBpcyBub3QgY2F1Z2h0IGFuZCBoYW5kbGVkXG4gICAgdGhpcy52YWxpZGF0ZVBheWxvYWQocGF5bG9hZCk7XG4gICAgdGhpcy5zdWJtaXRFdmVudChwYXlsb2FkLCBvcHRpb25zKS5jYXRjaCgoZXJyKSA9PlxuICAgICAgdGhpcy5fY2FwdHVyZUV4Y2VwdGlvbihlcnIpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogc3VibWl0cyAob3IgcXVldWVzIGZvciBzdWJtaXNzaW9uKSBhIG1ldGFtZXRyaWNzIGV2ZW50LCBwZXJmb3JtaW5nIG5lY2Vzc2FyeSBwYXlsb2FkIG1hbmlwdWxhdGlvbiBhbmRcbiAgICogcm91dGluZyB0aGUgZXZlbnQgdG8gdGhlIGFwcHJvcHJpYXRlIHNlZ21lbnQgc291cmNlLiBXaWxsIHNwbGl0IGV2ZW50c1xuICAgKiB3aXRoIHNlbnNpdGl2ZVByb3BlcnRpZXMgaW50byB0d28gZXZlbnRzLCB0cmFja2luZyB0aGUgc2Vuc2l0aXZlUHJvcGVydGllc1xuICAgKiB3aXRoIHRoZSBhbm9ueW1vdXNJZCBvbmx5LlxuICAgKiBAcGFyYW0ge01ldGFNZXRyaWNzRXZlbnRQYXlsb2FkfSBwYXlsb2FkIC0gZGV0YWlscyBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtNZXRhTWV0cmljc0V2ZW50T3B0aW9uc30gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgaGFuZGxpbmcvcm91dGluZyB0aGUgZXZlbnRcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBzdWJtaXRFdmVudChwYXlsb2FkLCBvcHRpb25zKSB7XG4gICAgdGhpcy52YWxpZGF0ZVBheWxvYWQocGF5bG9hZCk7XG5cbiAgICBpZiAoIXRoaXMuc3RhdGUucGFydGljaXBhdGVJbk1ldGFNZXRyaWNzICYmICFvcHRpb25zPy5pc09wdEluKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2UgbWlnaHQgdHJhY2sgbXVsdGlwbGUgZXZlbnRzIGlmIHNlbnNpdGl2ZVByb3BlcnRpZXMgaXMgaW5jbHVkZWQsIHRoaXMgYXJyYXkgd2lsbCBob2xkXG4gICAgLy8gdGhlIHByb21pc2VzIHJldHVybmVkIGZyb20gdGhpcy5fdHJhY2suXG4gICAgY29uc3QgZXZlbnRzID0gW107XG5cbiAgICBpZiAocGF5bG9hZC5zZW5zaXRpdmVQcm9wZXJ0aWVzKSB7XG4gICAgICAvLyBzZW5zaXRpdmVQcm9wZXJ0aWVzIHdpbGwgb25seSBiZSB0cmFja2VkIHVzaW5nIHRoZSBhbm9ueW1vdXNJZCBwcm9wZXJ0eSBhbmQgZ2VuZXJpYyBpZFxuICAgICAgLy8gSWYgdGhlIGV2ZW50IG9wdGlvbnMgYWxyZWFkeSBzcGVjaWZ5IHRvIGV4Y2x1ZGUgdGhlIG1ldGFNZXRyaWNzSWQgd2UgdGhyb3cgYW4gZXJyb3IgYXNcbiAgICAgIC8vIGEgc2lnbmFsIHRvIHRoZSBkZXZlbG9wZXIgdGhhdCB0aGUgZXZlbnQgd2FzIGltcGxlbWVudGVkIGluY29ycmVjdGx5XG4gICAgICBpZiAob3B0aW9ucz8uZXhjbHVkZU1ldGFNZXRyaWNzSWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdzZW5zaXRpdmVQcm9wZXJ0aWVzIHdhcyBzcGVjaWZpZWQgaW4gYW4gZXZlbnQgcGF5bG9hZCB0aGF0IGFsc28gc2V0IHRoZSBleGNsdWRlTWV0YU1ldHJpY3NJZCBmbGFnJyxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29tYmluZWRQcm9wZXJ0aWVzID0gbWVyZ2UoXG4gICAgICAgIHBheWxvYWQuc2Vuc2l0aXZlUHJvcGVydGllcyxcbiAgICAgICAgcGF5bG9hZC5wcm9wZXJ0aWVzLFxuICAgICAgKTtcblxuICAgICAgZXZlbnRzLnB1c2goXG4gICAgICAgIHRoaXMuX3RyYWNrKFxuICAgICAgICAgIHRoaXMuX2J1aWxkRXZlbnRQYXlsb2FkKHtcbiAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBjb21iaW5lZFByb3BlcnRpZXMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgeyAuLi5vcHRpb25zLCBleGNsdWRlTWV0YU1ldHJpY3NJZDogdHJ1ZSB9LFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBldmVudHMucHVzaCh0aGlzLl90cmFjayh0aGlzLl9idWlsZEV2ZW50UGF5bG9hZChwYXlsb2FkKSwgb3B0aW9ucykpO1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoZXZlbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB2YWxpZGF0ZXMgYSBtZXRhbWV0cmljcyBldmVudFxuICAgKiBAcGFyYW0ge01ldGFNZXRyaWNzRXZlbnRQYXlsb2FkfSBwYXlsb2FkIC0gZGV0YWlscyBvZiB0aGUgZXZlbnRcbiAgICovXG4gIHZhbGlkYXRlUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgLy8gZXZlbnQgYW5kIGNhdGVnb3J5IGFyZSByZXF1aXJlZCBmaWVsZHMgZm9yIGFsbCBwYXlsb2Fkc1xuICAgIGlmICghcGF5bG9hZC5ldmVudCB8fCAhcGF5bG9hZC5jYXRlZ29yeSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTXVzdCBzcGVjaWZ5IGV2ZW50IGFuZCBjYXRlZ29yeS4gRXZlbnQgd2FzOiAke1xuICAgICAgICAgIHBheWxvYWQuZXZlbnRcbiAgICAgICAgfS4gQ2F0ZWdvcnkgd2FzOiAke3BheWxvYWQuY2F0ZWdvcnl9LiBQYXlsb2FkIGtleXMgd2VyZTogJHtPYmplY3Qua2V5cyhcbiAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICApfS4gJHtcbiAgICAgICAgICB0eXBlb2YgcGF5bG9hZC5wcm9wZXJ0aWVzID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBgUGF5bG9hZCBwcm9wZXJ0eSBrZXlzIHdlcmU6ICR7T2JqZWN0LmtleXMocGF5bG9hZC5wcm9wZXJ0aWVzKX1gXG4gICAgICAgICAgICA6ICcnXG4gICAgICAgIH1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBXZWIzIGZyb20gJ3dlYjMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBTSU5HTEVfQ0FMTF9CQUxBTkNFU19BQkkgZnJvbSAnc2luZ2xlLWNhbGwtYmFsYW5jZS1jaGVja2VyLWFiaSc7XG5pbXBvcnQgeyBTSU5HTEVfQ0FMTF9CQUxBTkNFU19BRERSRVNTIH0gZnJvbSAnLi4vY29uc3RhbnRzL2NvbnRyYWN0cyc7XG5pbXBvcnQgeyBNSU5VVEUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RpbWUnO1xuaW1wb3J0IHsgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZSB9IGZyb20gJy4uLy4uLy4uL3VpL2hlbHBlcnMvdXRpbHMvdXRpbCc7XG5pbXBvcnQgeyBNQUlOTkVUX0NIQUlOX0lEIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcblxuLy8gQnkgZGVmYXVsdCwgcG9sbCBldmVyeSAzIG1pbnV0ZXNcbmNvbnN0IERFRkFVTFRfSU5URVJWQUwgPSBNSU5VVEUgKiAzO1xuXG4vKipcbiAqIEEgY29udHJvbGxlciB0aGF0IHBvbGxzIGZvciB0b2tlbiBleGNoYW5nZVxuICogcmF0ZXMgYmFzZWQgb24gYSB1c2VyJ3MgY3VycmVudCB0b2tlbiBsaXN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERldGVjdFRva2Vuc0NvbnRyb2xsZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIERldGVjdFRva2Vuc0NvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIC0gT3B0aW9ucyB0byBjb25maWd1cmUgY29udHJvbGxlclxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGludGVydmFsID0gREVGQVVMVF9JTlRFUlZBTCxcbiAgICBwcmVmZXJlbmNlcyxcbiAgICBuZXR3b3JrLFxuICAgIGtleXJpbmdNZW1TdG9yZSxcbiAgICB0b2tlbkxpc3QsXG4gICAgdG9rZW5zQ29udHJvbGxlcixcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy50b2tlbnNDb250cm9sbGVyID0gdG9rZW5zQ29udHJvbGxlcjtcbiAgICB0aGlzLnByZWZlcmVuY2VzID0gcHJlZmVyZW5jZXM7XG4gICAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsO1xuICAgIHRoaXMubmV0d29yayA9IG5ldHdvcms7XG4gICAgdGhpcy5rZXlyaW5nTWVtU3RvcmUgPSBrZXlyaW5nTWVtU3RvcmU7XG4gICAgdGhpcy50b2tlbkxpc3QgPSB0b2tlbkxpc3Q7XG4gICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgPSB0aGlzLnByZWZlcmVuY2VzPy5zdG9yZS5nZXRTdGF0ZSgpLnNlbGVjdGVkQWRkcmVzcztcbiAgICB0aGlzLnRva2VuQWRkcmVzc2VzID0gdGhpcy50b2tlbnNDb250cm9sbGVyPy5zdGF0ZS50b2tlbnMubWFwKCh0b2tlbikgPT4ge1xuICAgICAgcmV0dXJuIHRva2VuLmFkZHJlc3M7XG4gICAgfSk7XG4gICAgdGhpcy5oaWRkZW5Ub2tlbnMgPSB0aGlzLnRva2Vuc0NvbnRyb2xsZXI/LnN0YXRlLmlnbm9yZWRUb2tlbnM7XG5cbiAgICBwcmVmZXJlbmNlcz8uc3RvcmUuc3Vic2NyaWJlKCh7IHNlbGVjdGVkQWRkcmVzcywgdXNlVG9rZW5EZXRlY3Rpb24gfSkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyAhPT0gc2VsZWN0ZWRBZGRyZXNzIHx8XG4gICAgICAgIHRoaXMudXNlVG9rZW5EZXRlY3Rpb24gIT09IHVzZVRva2VuRGV0ZWN0aW9uXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgPSBzZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgIHRoaXMudXNlVG9rZW5EZXRlY3Rpb24gPSB1c2VUb2tlbkRldGVjdGlvbjtcbiAgICAgICAgdGhpcy5yZXN0YXJ0VG9rZW5EZXRlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2tlbnNDb250cm9sbGVyPy5zdWJzY3JpYmUoKHsgdG9rZW5zID0gW10sIGlnbm9yZWRUb2tlbnMgPSBbXSB9KSA9PiB7XG4gICAgICB0aGlzLnRva2VuQWRkcmVzc2VzID0gdG9rZW5zLm1hcCgodG9rZW4pID0+IHtcbiAgICAgICAgcmV0dXJuIHRva2VuLmFkZHJlc3M7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGlkZGVuVG9rZW5zID0gaWdub3JlZFRva2VucztcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIF9nZXRUb2tlbkJhbGFuY2VzKHRva2Vucykge1xuICAgIGNvbnN0IGV0aENvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aFxuICAgICAgLmNvbnRyYWN0KFNJTkdMRV9DQUxMX0JBTEFOQ0VTX0FCSSlcbiAgICAgIC5hdChTSU5HTEVfQ0FMTF9CQUxBTkNFU19BRERSRVNTKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZXRoQ29udHJhY3QuYmFsYW5jZXMoW3RoaXMuc2VsZWN0ZWRBZGRyZXNzXSwgdG9rZW5zLCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGVhY2ggdG9rZW4gaW4gdGhlIHRva2VubGlzdCBwcm92aWRlZCBieSB0aGUgVG9rZW5MaXN0Q29udHJvbGxlciwgY2hlY2sgc2VsZWN0ZWRBZGRyZXNzIGJhbGFuY2UuXG4gICAqL1xuICBhc3luYyBkZXRlY3ROZXdUb2tlbnMoKSB7XG4gICAgaWYgKCF0aGlzLmlzQWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyB0b2tlbkxpc3QgfSA9IHRoaXMuX3Rva2VuTGlzdC5zdGF0ZTtcbiAgICAvLyBzaW5jZSB0aGUgdG9rZW4gZGV0ZWN0aW9uIGlzIGN1cnJlbnRseSBlbmFibGVkIG9ubHkgb24gTWFpbm5ldFxuICAgIC8vIHdlIGNhbiB1c2UgdGhlIGNoYWluSWQgY2hlY2sgdG8gZW5zdXJlIHRva2VuIGRldGVjdGlvbiBpcyBub3QgdHJpZ2dlcmVkIGZvciBhbnkgb3RoZXIgbmV0d29ya1xuICAgIC8vIGJ1dCBvbmNlIHRoZSBiYWxhbmNlIGNoZWNrIGNvbnRyYWN0IGZvciBvdGhlciBuZXR3b3JrcyBhcmUgZGVwbG9heWVkIGFuZCByZWFkeSB0byB1c2UsIHdlIG5lZWQgdG8gdXBkYXRlIHRoaXMgY2hlY2suXG4gICAgaWYgKFxuICAgICAgdGhpcy5fbmV0d29yay5zdG9yZS5nZXRTdGF0ZSgpLnByb3ZpZGVyLmNoYWluSWQgIT09IE1BSU5ORVRfQ0hBSU5fSUQgfHxcbiAgICAgIE9iamVjdC5rZXlzKHRva2VuTGlzdCkubGVuZ3RoID09PSAwXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW5zVG9EZXRlY3QgPSBbXTtcbiAgICB0aGlzLndlYjMuc2V0UHJvdmlkZXIodGhpcy5fbmV0d29yay5fcHJvdmlkZXIpO1xuICAgIGZvciAoY29uc3QgdG9rZW5BZGRyZXNzIGluIHRva2VuTGlzdCkge1xuICAgICAgaWYgKFxuICAgICAgICAhdGhpcy50b2tlbkFkZHJlc3Nlcy5maW5kKChhZGRyZXNzKSA9PlxuICAgICAgICAgIGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUoYWRkcmVzcywgdG9rZW5BZGRyZXNzKSxcbiAgICAgICAgKSAmJlxuICAgICAgICAhdGhpcy5oaWRkZW5Ub2tlbnMuZmluZCgoYWRkcmVzcykgPT5cbiAgICAgICAgICBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKGFkZHJlc3MsIHRva2VuQWRkcmVzcyksXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICB0b2tlbnNUb0RldGVjdC5wdXNoKHRva2VuQWRkcmVzcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNsaWNlT2ZUb2tlbnNUb0RldGVjdCA9IFtcbiAgICAgIHRva2Vuc1RvRGV0ZWN0LnNsaWNlKDAsIDEwMDApLFxuICAgICAgdG9rZW5zVG9EZXRlY3Quc2xpY2UoMTAwMCwgdG9rZW5zVG9EZXRlY3QubGVuZ3RoIC0gMSksXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IHRva2Vuc1NsaWNlIG9mIHNsaWNlT2ZUb2tlbnNUb0RldGVjdCkge1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuX2dldFRva2VuQmFsYW5jZXModG9rZW5zU2xpY2UpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgTWV0YU1hc2sgLSBEZXRlY3RUb2tlbnNDb250cm9sbGVyIHNpbmdsZSBjYWxsIGJhbGFuY2UgZmV0Y2ggZmFpbGVkYCxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b2tlbnNXaXRoQmFsYW5jZSA9IHRva2Vuc1NsaWNlLmZpbHRlcigoXywgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgYmFsYW5jZSA9IHJlc3VsdFtpbmRleF07XG4gICAgICAgIHJldHVybiBiYWxhbmNlICYmICFiYWxhbmNlLmlzWmVybygpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICB0b2tlbnNXaXRoQmFsYW5jZS5tYXAoKHRva2VuQWRkcmVzcykgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRva2Vuc0NvbnRyb2xsZXIuYWRkVG9rZW4oXG4gICAgICAgICAgICB0b2tlbkFkZHJlc3MsXG4gICAgICAgICAgICB0b2tlbkxpc3RbdG9rZW5BZGRyZXNzXS5zeW1ib2wsXG4gICAgICAgICAgICB0b2tlbkxpc3RbdG9rZW5BZGRyZXNzXS5kZWNpbWFscyxcbiAgICAgICAgICApO1xuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RhcnQgdG9rZW4gZGV0ZWN0aW9uIHBvbGxpbmcgcGVyaW9kIGFuZCBjYWxsIGRldGVjdE5ld1Rva2Vuc1xuICAgKiBpbiBjYXNlIG9mIGFkZHJlc3MgY2hhbmdlIG9yIHVzZXIgc2Vzc2lvbiBpbml0aWFsaXphdGlvbi5cbiAgICpcbiAgICovXG4gIHJlc3RhcnRUb2tlbkRldGVjdGlvbigpIHtcbiAgICBpZiAoISh0aGlzLmlzQWN0aXZlICYmIHRoaXMuc2VsZWN0ZWRBZGRyZXNzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRldGVjdE5ld1Rva2VucygpO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSBERUZBVUxUX0lOVEVSVkFMO1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgYWNjZXNzb3ItcGFpcnMgKi9cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgaW50ZXJ2YWwoaW50ZXJ2YWwpIHtcbiAgICB0aGlzLl9oYW5kbGUgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLl9oYW5kbGUpO1xuICAgIGlmICghaW50ZXJ2YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faGFuZGxlID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5kZXRlY3ROZXdUb2tlbnMoKTtcbiAgICB9LCBpbnRlcnZhbCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHNldCBuZXR3b3JrKG5ldHdvcmspIHtcbiAgICBpZiAoIW5ldHdvcmspIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbmV0d29yayA9IG5ldHdvcms7XG4gICAgdGhpcy53ZWIzID0gbmV3IFdlYjMobmV0d29yay5fcHJvdmlkZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluIHNldHRlciB3aGVuIGlzVW5sb2NrZWQgaXMgdXBkYXRlZCB0byB0cnVlLCBkZXRlY3ROZXdUb2tlbnMgYW5kIHJlc3RhcnQgcG9sbGluZ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc2V0IGtleXJpbmdNZW1TdG9yZShrZXlyaW5nTWVtU3RvcmUpIHtcbiAgICBpZiAoIWtleXJpbmdNZW1TdG9yZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9rZXlyaW5nTWVtU3RvcmUgPSBrZXlyaW5nTWVtU3RvcmU7XG4gICAgdGhpcy5fa2V5cmluZ01lbVN0b3JlLnN1YnNjcmliZSgoeyBpc1VubG9ja2VkIH0pID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVW5sb2NrZWQgIT09IGlzVW5sb2NrZWQpIHtcbiAgICAgICAgdGhpcy5pc1VubG9ja2VkID0gaXNVbmxvY2tlZDtcbiAgICAgICAgaWYgKGlzVW5sb2NrZWQpIHtcbiAgICAgICAgICB0aGlzLnJlc3RhcnRUb2tlbkRldGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHNldCB0b2tlbkxpc3QodG9rZW5MaXN0KSB7XG4gICAgaWYgKCF0b2tlbkxpc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdG9rZW5MaXN0ID0gdG9rZW5MaXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGlzQWN0aXZlIHN0YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNPcGVuICYmIHRoaXMuaXNVbmxvY2tlZDtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGFjY2Vzc29yLXBhaXJzICovXG59XG4iLCJpbXBvcnQgS2V5cmluZ0NvbnRyb2xsZXIgZnJvbSAnZXRoLWtleXJpbmctY29udHJvbGxlcic7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuY29uc3Qgc2VlZFBocmFzZVZlcmlmaWVyID0ge1xuICAvKipcbiAgICogVmVyaWZpZXMgaWYgdGhlIHNlZWQgd29yZHMgY2FuIHJlc3RvcmUgdGhlIGFjY291bnRzLlxuICAgKlxuICAgKiBLZXkgbm90ZXM6XG4gICAqIC0gVGhlIHNlZWQgd29yZHMgY2FuIHJlY3JlYXRlIHRoZSBwcmltYXJ5IGtleXJpbmcgYW5kIHRoZSBhY2NvdW50cyBiZWxvbmdpbmcgdG8gaXQuXG4gICAqIC0gVGhlIGNyZWF0ZWQgYWNjb3VudHMgaW4gdGhlIHByaW1hcnkga2V5cmluZyBhcmUgYWx3YXlzIHRoZSBzYW1lLlxuICAgKiAtIFRoZSBrZXlyaW5nIGFsd2F5cyBjcmVhdGVzIHRoZSBhY2NvdW50cyBpbiB0aGUgc2FtZSBzZXF1ZW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY3JlYXRlZEFjY291bnRzIC0gVGhlIGFjY291bnRzIHRvIHJlc3RvcmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlZWRXb3JkcyAtIFRoZSBzZWVkIHdvcmRzIHRvIHZlcmlmeVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUHJvbWlzZXMgdW5kZWZpbmVkXG4gICAqXG4gICAqL1xuICBhc3luYyB2ZXJpZnlBY2NvdW50cyhjcmVhdGVkQWNjb3VudHMsIHNlZWRXb3Jkcykge1xuICAgIGlmICghY3JlYXRlZEFjY291bnRzIHx8IGNyZWF0ZWRBY2NvdW50cy5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNyZWF0ZWQgYWNjb3VudHMgZGVmaW5lZC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlyaW5nQ29udHJvbGxlciA9IG5ldyBLZXlyaW5nQ29udHJvbGxlcih7fSk7XG4gICAgY29uc3QgS2V5cmluZyA9IGtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdDbGFzc0ZvclR5cGUoJ0hEIEtleSBUcmVlJyk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIG1uZW1vbmljOiBzZWVkV29yZHMsXG4gICAgICBudW1iZXJPZkFjY291bnRzOiBjcmVhdGVkQWNjb3VudHMubGVuZ3RoLFxuICAgIH07XG5cbiAgICBjb25zdCBrZXlyaW5nID0gbmV3IEtleXJpbmcob3B0cyk7XG4gICAgY29uc3QgcmVzdG9yZWRBY2NvdW50cyA9IGF3YWl0IGtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICBsb2cuZGVidWcoYENyZWF0ZWQgYWNjb3VudHM6ICR7SlNPTi5zdHJpbmdpZnkoY3JlYXRlZEFjY291bnRzKX1gKTtcbiAgICBsb2cuZGVidWcoYFJlc3RvcmVkIGFjY291bnRzOiAke0pTT04uc3RyaW5naWZ5KHJlc3RvcmVkQWNjb3VudHMpfWApO1xuXG4gICAgaWYgKHJlc3RvcmVkQWNjb3VudHMubGVuZ3RoICE9PSBjcmVhdGVkQWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAvLyB0aGlzIHNob3VsZCBub3QgaGFwcGVuLi4uXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIG51bWJlciBvZiBhY2NvdW50cycpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdG9yZWRBY2NvdW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICByZXN0b3JlZEFjY291bnRzW2ldLnRvTG93ZXJDYXNlKCkgIT09IGNyZWF0ZWRBY2NvdW50c1tpXS50b0xvd2VyQ2FzZSgpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBOb3QgaWRlbnRpY2FsIGFjY291bnRzISBPcmlnaW5hbDogJHtjcmVhdGVkQWNjb3VudHNbaV19LCBSZXN0b3JlZDogJHtyZXN0b3JlZEFjY291bnRzW2ldfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgc2VlZFBocmFzZVZlcmlmaWVyO1xuIiwiaW1wb3J0IHsgc3RyaWN0IGFzIGFzc2VydCB9IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7IG5vcm1hbGl6ZSBhcyBub3JtYWxpemVBZGRyZXNzIH0gZnJvbSAnZXRoLXNpZy11dGlsJztcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7XG4gIElQRlNfREVGQVVMVF9HQVRFV0FZX1VSTCxcbiAgTkVUV09SS19UWVBFX1RPX0lEX01BUCxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7IGlzUHJlZml4ZWRGb3JtYXR0ZWRIZXhTdHJpbmcgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9uZXR3b3JrLnV0aWxzJztcbmltcG9ydCB7IExFREdFUl9UUkFOU1BPUlRfVFlQRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2hhcmR3YXJlLXdhbGxldHMnO1xuaW1wb3J0IHsgTkVUV09SS19FVkVOVFMgfSBmcm9tICcuL25ldHdvcmsnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIge1xuICAvKipcbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gUHJlZmVyZW5jZXNDb250cm9sbGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3ZlcnJpZGVzIHRoZSBkZWZhdWx0cyBmb3IgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhpcy5zdG9yZVxuICAgKiBAcHJvcGVydHkge09iamVjdH0gc3RvcmUgVGhlIHN0b3JlZCBvYmplY3QgY29udGFpbmluZyBhIHVzZXJzIHByZWZlcmVuY2VzLCBzdG9yZWQgaW4gbG9jYWwgc3RvcmFnZVxuICAgKiBAcHJvcGVydHkge0FycmF5fSBzdG9yZS5mcmVxdWVudFJwY0xpc3QgQSBsaXN0IG9mIGN1c3RvbSBycGNzIHRvIHByb3ZpZGUgdGhlIHVzZXJcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBzdG9yZS51c2VCbG9ja2llIFRoZSB1c2VycyBwcmVmZXJlbmNlIGZvciBibG9ja2llIGlkZW50aWNvbnMgd2l0aGluIHRoZSBVSVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0b3JlLnVzZU5vbmNlRmllbGQgVGhlIHVzZXJzIHByZWZlcmVuY2UgZm9yIG5vbmNlIGZpZWxkIHdpdGhpbiB0aGUgVUlcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IHN0b3JlLmZlYXR1cmVGbGFncyBBIGtleS1ib29sZWFuIG1hcCwgd2hlcmUga2V5cyByZWZlciB0byBmZWF0dXJlcyBhbmQgYm9vbGVhbnMgdG8gd2hldGhlciB0aGVcbiAgICogdXNlciB3aXNoZXMgdG8gc2VlIHRoYXQgZmVhdHVyZS5cbiAgICpcbiAgICogRmVhdHVyZSBmbGFncyBjYW4gYmUgc2V0IGJ5IHRoZSBnbG9iYWwgZnVuY3Rpb24gYHNldFByZWZlcmVuY2UoZmVhdHVyZSwgZW5hYmxlZClgLCBhbmQgc28gc2hvdWxkIG5vdCBleHBvc2UgYW55IHNlbnNpdGl2ZSBiZWhhdmlvci5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IHN0b3JlLmtub3duTWV0aG9kRGF0YSBDb250YWlucyBhbGwgZGF0YSBtZXRob2RzIGtub3duIGJ5IHRoZSB1c2VyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdG9yZS5jdXJyZW50TG9jYWxlIFRoZSBwcmVmZXJyZWQgbGFuZ3VhZ2UgbG9jYWxlIGtleVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3RvcmUuc2VsZWN0ZWRBZGRyZXNzIEEgaGV4IHN0cmluZyB0aGF0IG1hdGNoZXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBhZGRyZXNzIGluIHRoZSBhcHBcbiAgICpcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGluaXRTdGF0ZSA9IHtcbiAgICAgIGZyZXF1ZW50UnBjTGlzdERldGFpbDogW10sXG4gICAgICB1c2VCbG9ja2llOiBmYWxzZSxcbiAgICAgIHVzZU5vbmNlRmllbGQ6IGZhbHNlLFxuICAgICAgdXNlUGhpc2hEZXRlY3Q6IHRydWUsXG4gICAgICBkaXNtaXNzU2VlZEJhY2tVcFJlbWluZGVyOiBmYWxzZSxcblxuICAgICAgLy8gc2V0IHRvIHRydWUgbWVhbnMgdGhlIGR5bmFtaWMgbGlzdCBmcm9tIHRoZSBBUEkgaXMgYmVpbmcgdXNlZFxuICAgICAgLy8gc2V0IHRvIGZhbHNlIHdpbGwgYmUgdXNpbmcgdGhlIHN0YXRpYyBsaXN0IGZyb20gY29udHJhY3QtbWV0YWRhdGFcbiAgICAgIHVzZVRva2VuRGV0ZWN0aW9uOiBmYWxzZSxcbiAgICAgIHVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uOiBmYWxzZSxcbiAgICAgIG9wZW5TZWFFbmFibGVkOiBmYWxzZSxcbiAgICAgIGFkdmFuY2VkR2FzRmVlOiBudWxsLFxuXG4gICAgICAvLyBXQVJOSU5HOiBEbyBub3QgdXNlIGZlYXR1cmUgZmxhZ3MgZm9yIHNlY3VyaXR5LXNlbnNpdGl2ZSB0aGluZ3MuXG4gICAgICAvLyBGZWF0dXJlIGZsYWcgdG9nZ2xpbmcgaXMgYXZhaWxhYmxlIGluIHRoZSBnbG9iYWwgbmFtZXNwYWNlXG4gICAgICAvLyBmb3IgY29udmVuaWVudCB0ZXN0aW5nIG9mIHByZS1yZWxlYXNlIGZlYXR1cmVzLCBhbmQgc2hvdWxkIG5ldmVyXG4gICAgICAvLyBwZXJmb3JtIHNlbnNpdGl2ZSBvcGVyYXRpb25zLlxuICAgICAgZmVhdHVyZUZsYWdzOiB7XG4gICAgICAgIHNob3dJbmNvbWluZ1RyYW5zYWN0aW9uczogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICBrbm93bk1ldGhvZERhdGE6IHt9LFxuICAgICAgY3VycmVudExvY2FsZTogb3B0cy5pbml0TGFuZ0NvZGUsXG4gICAgICBpZGVudGl0aWVzOiB7fSxcbiAgICAgIGxvc3RJZGVudGl0aWVzOiB7fSxcbiAgICAgIGZvcmdvdHRlblBhc3N3b3JkOiBmYWxzZSxcbiAgICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICAgIGF1dG9Mb2NrVGltZUxpbWl0OiB1bmRlZmluZWQsXG4gICAgICAgIHNob3dGaWF0SW5UZXN0bmV0czogZmFsc2UsXG4gICAgICAgIHNob3dUZXN0TmV0d29ya3M6IGZhbHNlLFxuICAgICAgICB1c2VOYXRpdmVDdXJyZW5jeUFzUHJpbWFyeUN1cnJlbmN5OiB0cnVlLFxuICAgICAgICBoaWRlWmVyb0JhbGFuY2VUb2tlbnM6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIC8vIEVOUyBkZWNlbnRyYWxpemVkIHdlYnNpdGUgcmVzb2x1dGlvblxuICAgICAgaXBmc0dhdGV3YXk6IElQRlNfREVGQVVMVF9HQVRFV0FZX1VSTCxcbiAgICAgIGluZnVyYUJsb2NrZWQ6IG51bGwsXG4gICAgICBsZWRnZXJUcmFuc3BvcnRUeXBlOiB3aW5kb3cubmF2aWdhdG9yLmhpZFxuICAgICAgICA/IExFREdFUl9UUkFOU1BPUlRfVFlQRVMuV0VCSElEXG4gICAgICAgIDogTEVER0VSX1RSQU5TUE9SVF9UWVBFUy5VMkYsXG4gICAgICAuLi5vcHRzLmluaXRTdGF0ZSxcbiAgICB9O1xuXG4gICAgdGhpcy5uZXR3b3JrID0gb3B0cy5uZXR3b3JrO1xuICAgIHRoaXMuZXRoZXJzUHJvdmlkZXIgPSBuZXcgZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIob3B0cy5wcm92aWRlcik7XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoaW5pdFN0YXRlKTtcbiAgICB0aGlzLnN0b3JlLnNldE1heExpc3RlbmVycygxMik7XG4gICAgdGhpcy5vcGVuUG9wdXAgPSBvcHRzLm9wZW5Qb3B1cDtcbiAgICB0aGlzLm1pZ3JhdGVBZGRyZXNzQm9va1N0YXRlID0gb3B0cy5taWdyYXRlQWRkcmVzc0Jvb2tTdGF0ZTtcblxuICAgIHRoaXMuX3N1YnNjcmliZVRvSW5mdXJhQXZhaWxhYmlsaXR5KCk7XG5cbiAgICBnbG9iYWwuc2V0UHJlZmVyZW5jZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRGZWF0dXJlRmxhZyhrZXksIHZhbHVlKTtcbiAgICB9O1xuICB9XG4gIC8vIFBVQkxJQyBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHtAY29kZSBmb3Jnb3R0ZW5QYXNzd29yZH0gc3RhdGUgcHJvcGVydHlcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3Jnb3R0ZW5QYXNzd29yZCAtIHdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIGhhcyBmb3Jnb3R0ZW4gdGhlaXIgcGFzc3dvcmRcbiAgICovXG4gIHNldFBhc3N3b3JkRm9yZ290dGVuKGZvcmdvdHRlblBhc3N3b3JkKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGZvcmdvdHRlblBhc3N3b3JkIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGB1c2VCbG9ja2llYCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbCAtIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIHByZWZlcnMgYmxvY2tpZSBpbmRpY2F0b3JzXG4gICAqXG4gICAqL1xuICBzZXRVc2VCbG9ja2llKHZhbCkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyB1c2VCbG9ja2llOiB2YWwgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYHVzZU5vbmNlRmllbGRgIHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsIC0gV2hldGhlciBvciBub3QgdGhlIHVzZXIgcHJlZmVycyB0byBzZXQgbm9uY2VcbiAgICpcbiAgICovXG4gIHNldFVzZU5vbmNlRmllbGQodmFsKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHVzZU5vbmNlRmllbGQ6IHZhbCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBgdXNlUGhpc2hEZXRlY3RgIHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsIC0gV2hldGhlciBvciBub3QgdGhlIHVzZXIgcHJlZmVycyBwaGlzaGluZyBkb21haW4gcHJvdGVjdGlvblxuICAgKlxuICAgKi9cbiAgc2V0VXNlUGhpc2hEZXRlY3QodmFsKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHVzZVBoaXNoRGV0ZWN0OiB2YWwgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYHVzZVRva2VuRGV0ZWN0aW9uYCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbCAtIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIHByZWZlcnMgdG8gdXNlIHRoZSBzdGF0aWMgdG9rZW4gbGlzdCBvciBkeW5hbWljIHRva2VuIGxpc3QgZnJvbSB0aGUgQVBJXG4gICAqXG4gICAqL1xuICBzZXRVc2VUb2tlbkRldGVjdGlvbih2YWwpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgdXNlVG9rZW5EZXRlY3Rpb246IHZhbCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBgdXNlQ29sbGVjdGlibGVEZXRlY3Rpb25gIHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsIC0gV2hldGhlciBvciBub3QgdGhlIHVzZXIgcHJlZmVycyB0byBhdXRvZGV0ZWN0IGNvbGxlY3RpYmxlcy5cbiAgICpcbiAgICovXG4gIHNldFVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uKHZhbCkge1xuICAgIGNvbnN0IHsgb3BlblNlYUVuYWJsZWQgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBpZiAodmFsICYmICFvcGVuU2VhRW5hYmxlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAndXNlQ29sbGVjdGlibGVEZXRlY3Rpb24gY2Fubm90IGJlIGVuYWJsZWQgaWYgb3BlblNlYUVuYWJsZWQgaXMgZmFsc2UnLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uOiB2YWwgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYG9wZW5TZWFFbmFibGVkYCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbCAtIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIHByZWZlcnMgdG8gdXNlIHRoZSBPcGVuU2VhIEFQSSBmb3IgY29sbGVjdGlibGVzIGRhdGEuXG4gICAqXG4gICAqL1xuICBzZXRPcGVuU2VhRW5hYmxlZCh2YWwpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgb3BlblNlYUVuYWJsZWQ6IHZhbCB9KTtcbiAgICBpZiAoIXZhbCkge1xuICAgICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uOiBmYWxzZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYGFkdmFuY2VkR2FzRmVlYCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsIC0gaG9sZHMgdGhlIG1heEJhc2VGZWUgYW5kIFByaW9yaXR5RmVlIHRoYXQgdGhlIHVzZXIgc2V0IGFzIGRlZmF1bHQgYWR2YW5jZWQgc2V0dGluZ3MuXG4gICAqXG4gICAqL1xuICBzZXRBZHZhbmNlZEdhc0ZlZSh2YWwpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgYWR2YW5jZWRHYXNGZWU6IHZhbCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbmV3IG1ldGhvZERhdGEgdG8gc3RhdGUsIHRvIGF2b2lkIHJlcXVlc3RpbmcgdGhpcyBpbmZvcm1hdGlvbiBhZ2FpbiB0aHJvdWdoIEluZnVyYVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm91ckJ5dGVQcmVmaXggLSBGb3VyLWJ5dGUgbWV0aG9kIHNpZ25hdHVyZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kRGF0YSAtIENvcnJlc3BvbmRpbmcgZGF0YSBtZXRob2RcbiAgICovXG4gIGFkZEtub3duTWV0aG9kRGF0YShmb3VyQnl0ZVByZWZpeCwgbWV0aG9kRGF0YSkge1xuICAgIGNvbnN0IHsga25vd25NZXRob2REYXRhIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAga25vd25NZXRob2REYXRhW2ZvdXJCeXRlUHJlZml4XSA9IG1ldGhvZERhdGE7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGtub3duTWV0aG9kRGF0YSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBgY3VycmVudExvY2FsZWAgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIGhlIHByZWZlcnJlZCBsYW5ndWFnZSBsb2NhbGUga2V5XG4gICAqXG4gICAqL1xuICBzZXRDdXJyZW50TG9jYWxlKGtleSkge1xuICAgIGNvbnN0IHRleHREaXJlY3Rpb24gPSBbJ2FyJywgJ2R2JywgJ2ZhJywgJ2hlJywgJ2t1J10uaW5jbHVkZXMoa2V5KVxuICAgICAgPyAncnRsJ1xuICAgICAgOiAnYXV0byc7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBjdXJyZW50TG9jYWxlOiBrZXksXG4gICAgICB0ZXh0RGlyZWN0aW9uLFxuICAgIH0pO1xuICAgIHJldHVybiB0ZXh0RGlyZWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgaWRlbnRpdGllcyB0byBvbmx5IGluY2x1ZGUgc3BlY2lmaWVkIGFkZHJlc3Nlcy4gUmVtb3ZlcyBpZGVudGl0aWVzXG4gICAqIG5vdCBpbmNsdWRlZCBpbiBhZGRyZXNzZXMgYXJyYXlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gYWRkcmVzc2VzIC0gQW4gYXJyYXkgb2YgaGV4IGFkZHJlc3Nlc1xuICAgKlxuICAgKi9cbiAgc2V0QWRkcmVzc2VzKGFkZHJlc3Nlcykge1xuICAgIGNvbnN0IG9sZElkZW50aXRpZXMgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCkuaWRlbnRpdGllcztcblxuICAgIGNvbnN0IGlkZW50aXRpZXMgPSBhZGRyZXNzZXMucmVkdWNlKChpZHMsIGFkZHJlc3MsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBvbGRJZCA9IG9sZElkZW50aXRpZXNbYWRkcmVzc10gfHwge307XG4gICAgICBpZHNbYWRkcmVzc10gPSB7IG5hbWU6IGBBY2NvdW50ICR7aW5kZXggKyAxfWAsIGFkZHJlc3MsIC4uLm9sZElkIH07XG4gICAgICByZXR1cm4gaWRzO1xuICAgIH0sIHt9KTtcblxuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBpZGVudGl0aWVzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYWRkcmVzcyBmcm9tIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gQSBoZXggYWRkcmVzc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYWRkcmVzcyB0aGF0IHdhcyByZW1vdmVkXG4gICAqL1xuICByZW1vdmVBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBjb25zdCB7IGlkZW50aXRpZXMgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIGlmICghaWRlbnRpdGllc1thZGRyZXNzXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2FkZHJlc3N9IGNhbid0IGJlIGRlbGV0ZWQgY2F1c2UgaXQgd2FzIG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBkZWxldGUgaWRlbnRpdGllc1thZGRyZXNzXTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgaWRlbnRpdGllcyB9KTtcblxuICAgIC8vIElmIHRoZSBzZWxlY3RlZCBhY2NvdW50IGlzIG5vIGxvbmdlciB2YWxpZCxcbiAgICAvLyBzZWxlY3QgYW4gYXJiaXRyYXJ5IG90aGVyIGFjY291bnQ6XG4gICAgaWYgKGFkZHJlc3MgPT09IHRoaXMuZ2V0U2VsZWN0ZWRBZGRyZXNzKCkpIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkID0gT2JqZWN0LmtleXMoaWRlbnRpdGllcylbMF07XG4gICAgICB0aGlzLnNldFNlbGVjdGVkQWRkcmVzcyhzZWxlY3RlZCk7XG4gICAgfVxuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYWRkcmVzc2VzIHRvIHRoZSBpZGVudGl0aWVzIG9iamVjdCB3aXRob3V0IHJlbW92aW5nIGlkZW50aXRpZXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gYWRkcmVzc2VzIC0gQW4gYXJyYXkgb2YgaGV4IGFkZHJlc3Nlc1xuICAgKlxuICAgKi9cbiAgYWRkQWRkcmVzc2VzKGFkZHJlc3Nlcykge1xuICAgIGNvbnN0IHsgaWRlbnRpdGllcyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGFkZHJlc3Nlcy5mb3JFYWNoKChhZGRyZXNzKSA9PiB7XG4gICAgICAvLyBza2lwIGlmIGFscmVhZHkgZXhpc3RzXG4gICAgICBpZiAoaWRlbnRpdGllc1thZGRyZXNzXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBhZGQgbWlzc2luZyBpZGVudGl0eVxuICAgICAgY29uc3QgaWRlbnRpdHlDb3VudCA9IE9iamVjdC5rZXlzKGlkZW50aXRpZXMpLmxlbmd0aDtcblxuICAgICAgaWRlbnRpdGllc1thZGRyZXNzXSA9IHsgbmFtZTogYEFjY291bnQgJHtpZGVudGl0eUNvdW50ICsgMX1gLCBhZGRyZXNzIH07XG4gICAgfSk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGlkZW50aXRpZXMgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25pemVzIGlkZW50aXR5IGVudHJpZXMgd2l0aCBrbm93biBhY2NvdW50cy5cbiAgICogUmVtb3ZlcyBhbnkgdW5rbm93biBpZGVudGl0aWVzLCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIHNlbGVjdGVkIGFkZHJlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYWRkcmVzc2VzIC0ga25vd24gdG8gdGhlIHZhdWx0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBzZWxlY3RlZEFkZHJlc3MgdGhlIHNlbGVjdGVkIGFkZHJlc3MuXG4gICAqL1xuICBzeW5jQWRkcmVzc2VzKGFkZHJlc3Nlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhZGRyZXNzZXMpIHx8IGFkZHJlc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbm9uLWVtcHR5IGFycmF5IG9mIGFkZHJlc3Nlcy4gRXJyb3IgIzExMjAxJyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBpZGVudGl0aWVzLCBsb3N0SWRlbnRpdGllcyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgY29uc3QgbmV3bHlMb3N0ID0ge307XG4gICAgT2JqZWN0LmtleXMoaWRlbnRpdGllcykuZm9yRWFjaCgoaWRlbnRpdHkpID0+IHtcbiAgICAgIGlmICghYWRkcmVzc2VzLmluY2x1ZGVzKGlkZW50aXR5KSkge1xuICAgICAgICBuZXdseUxvc3RbaWRlbnRpdHldID0gaWRlbnRpdGllc1tpZGVudGl0eV07XG4gICAgICAgIGRlbGV0ZSBpZGVudGl0aWVzW2lkZW50aXR5XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIElkZW50aXRpZXMgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgIGlmIChPYmplY3Qua2V5cyhuZXdseUxvc3QpLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHN0b3JlIGxvc3QgYWNjb3VudHNcbiAgICAgIE9iamVjdC5rZXlzKG5ld2x5TG9zdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxvc3RJZGVudGl0aWVzW2tleV0gPSBuZXdseUxvc3Rba2V5XTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBpZGVudGl0aWVzLCBsb3N0SWRlbnRpdGllcyB9KTtcbiAgICB0aGlzLmFkZEFkZHJlc3NlcyhhZGRyZXNzZXMpO1xuXG4gICAgLy8gSWYgdGhlIHNlbGVjdGVkIGFjY291bnQgaXMgbm8gbG9uZ2VyIHZhbGlkLFxuICAgIC8vIHNlbGVjdCBhbiBhcmJpdHJhcnkgb3RoZXIgYWNjb3VudDpcbiAgICBsZXQgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkQWRkcmVzcygpO1xuICAgIGlmICghYWRkcmVzc2VzLmluY2x1ZGVzKHNlbGVjdGVkKSkge1xuICAgICAgc2VsZWN0ZWQgPSBhZGRyZXNzZXNbMF07XG4gICAgICB0aGlzLnNldFNlbGVjdGVkQWRkcmVzcyhzZWxlY3RlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGBzZWxlY3RlZEFkZHJlc3NgIHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfYWRkcmVzcyAtIEEgbmV3IGhleCBhZGRyZXNzIGZvciBhbiBhY2NvdW50XG4gICAqXG4gICAqL1xuICBzZXRTZWxlY3RlZEFkZHJlc3MoX2FkZHJlc3MpIHtcbiAgICBjb25zdCBhZGRyZXNzID0gbm9ybWFsaXplQWRkcmVzcyhfYWRkcmVzcyk7XG5cbiAgICBjb25zdCB7IGlkZW50aXRpZXMgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBzZWxlY3RlZElkZW50aXR5ID0gaWRlbnRpdGllc1thZGRyZXNzXTtcbiAgICBpZiAoIXNlbGVjdGVkSWRlbnRpdHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSWRlbnRpdHkgZm9yICcke2FkZHJlc3N9IG5vdCBmb3VuZGApO1xuICAgIH1cblxuICAgIHNlbGVjdGVkSWRlbnRpdHkubGFzdFNlbGVjdGVkID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgaWRlbnRpdGllcywgc2VsZWN0ZWRBZGRyZXNzOiBhZGRyZXNzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGBzZWxlY3RlZEFkZHJlc3NgIHByb3BlcnR5XG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBoZXggYWRkcmVzcyBmb3IgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBhY2NvdW50XG4gICAqXG4gICAqL1xuICBnZXRTZWxlY3RlZEFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5zZWxlY3RlZEFkZHJlc3M7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIGN1c3RvbSBsYWJlbCBmb3IgYW4gYWNjb3VudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudCAtIHRoZSBhY2NvdW50IHRvIHNldCBhIGxhYmVsIGZvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgLSB0aGUgY3VzdG9tIGxhYmVsIGZvciB0aGUgYWNjb3VudFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICAgKi9cbiAgc2V0QWNjb3VudExhYmVsKGFjY291bnQsIGxhYmVsKSB7XG4gICAgaWYgKCFhY2NvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBzZXRBY2NvdW50TGFiZWwgcmVxdWlyZXMgYSB2YWxpZCBhZGRyZXNzLCBnb3QgJHtTdHJpbmcoYWNjb3VudCl9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGFkZHJlc3MgPSBub3JtYWxpemVBZGRyZXNzKGFjY291bnQpO1xuICAgIGNvbnN0IHsgaWRlbnRpdGllcyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGlkZW50aXRpZXNbYWRkcmVzc10gPSBpZGVudGl0aWVzW2FkZHJlc3NdIHx8IHt9O1xuICAgIGlkZW50aXRpZXNbYWRkcmVzc10ubmFtZSA9IGxhYmVsO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBpZGVudGl0aWVzIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobGFiZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZXMgY3VzdG9tIFJQQyBkZXRhaWxzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdScGNEZXRhaWxzIC0gT3B0aW9ucyBiYWcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdScGNEZXRhaWxzLnJwY1VybCAtIFRoZSBSUEMgdXJsIHRvIGFkZCB0byBmcmVxdWVudFJwY0xpc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdScGNEZXRhaWxzLmNoYWluSWQgLSBUaGUgY2hhaW5JZCBvZiB0aGUgc2VsZWN0ZWQgbmV0d29yay5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuZXdScGNEZXRhaWxzLnRpY2tlcl0gLSBPcHRpb25hbCB0aWNrZXIgc3ltYm9sIG9mIHRoZSBzZWxlY3RlZCBuZXR3b3JrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25ld1JwY0RldGFpbHMubmlja25hbWVdIC0gT3B0aW9uYWwgbmlja25hbWUgb2YgdGhlIHNlbGVjdGVkIG5ldHdvcmsuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbbmV3UnBjRGV0YWlscy5ycGNQcmVmc10gLSBPcHRpb25hbCBSUEMgcHJlZmVyZW5jZXMsIHN1Y2ggYXMgdGhlIGJsb2NrIGV4cGxvcmVyIFVSTFxuICAgKlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlUnBjKG5ld1JwY0RldGFpbHMpIHtcbiAgICBjb25zdCBycGNMaXN0ID0gdGhpcy5nZXRGcmVxdWVudFJwY0xpc3REZXRhaWwoKTtcbiAgICBjb25zdCBpbmRleCA9IHJwY0xpc3QuZmluZEluZGV4KChlbGVtZW50KSA9PiB7XG4gICAgICByZXR1cm4gZWxlbWVudC5ycGNVcmwgPT09IG5ld1JwY0RldGFpbHMucnBjVXJsO1xuICAgIH0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICBjb25zdCBycGNEZXRhaWwgPSBycGNMaXN0W2luZGV4XTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRScGMgPSB7IC4uLnJwY0RldGFpbCwgLi4ubmV3UnBjRGV0YWlscyB9O1xuICAgICAgaWYgKHJwY0RldGFpbC5jaGFpbklkICE9PSB1cGRhdGVkUnBjLmNoYWluSWQpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgY2hhaW5JZCBpcyBjaGFuZ2VkLCBhc3NvY2lhdGVkIGFkZHJlc3MgYm9vayBlbnRyaWVzIHNob3VsZFxuICAgICAgICAvLyBhbHNvIGJlIG1pZ3JhdGVkLiBUaGUgYWRkcmVzcyBib29rIGVudHJpZXMgYXJlIGtleWVkIGJ5IHRoZSBgbmV0d29ya2Agc3RhdGUsXG4gICAgICAgIC8vIHdoaWNoIGZvciBjdXN0b20gbmV0d29ya3MgaXMgdGhlIGNoYWluSWQgd2l0aCBhIGZhbGxiYWNrIHRvIHRoZSBuZXR3b3JrSWRcbiAgICAgICAgLy8gaWYgdGhlIGNoYWluSWQgaXMgbm90IHNldC5cblxuICAgICAgICBsZXQgYWRkcmVzc0Jvb2tLZXkgPSBycGNEZXRhaWwuY2hhaW5JZDtcbiAgICAgICAgaWYgKCFhZGRyZXNzQm9va0tleSkge1xuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZmluZCB0aGUgbmV0d29ya0lkIHRvIGRldGVybWluZSB3aGF0IHRoZXNlIGFkZHJlc3NlcyB3ZXJlIGtleWVkIGJ5XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFkZHJlc3NCb29rS2V5ID0gYXdhaXQgdGhpcy5ldGhlcnNQcm92aWRlci5zZW5kKCduZXRfdmVyc2lvbicpO1xuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiBhZGRyZXNzQm9va0tleSA9PT0gJ3N0cmluZycpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoZXJyb3IpO1xuICAgICAgICAgICAgbG9nLndhcm4oXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gZ2V0IG5ldHdvcmtJZCBmcm9tICR7cnBjRGV0YWlsLnJwY1VybH07IHNraXBwaW5nIGFkZHJlc3MgYm9vayBtaWdyYXRpb25gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVyZSBpcyBhbiBlZGdlIGNhc2Ugd2hlcmUgdHdvIHNlcGFyYXRlIFJQQyBlbmRwb2ludHMgYXJlIGtleWVkIGJ5IHRoZSBzYW1lXG4gICAgICAgIC8vIHZhbHVlLiBJbiB0aGlzIGNhc2UsIHRoZSBjb250YWN0IGJvb2sgZW50cmllcyBhcmUgZHVwbGljYXRlZCBzbyB0aGF0IHRoZXkgcmVtYWluXG4gICAgICAgIC8vIG9uIGJvdGggbmV0d29ya3MsIHNpbmNlIHdlIGRvbid0IGtub3cgd2hpY2ggbmV0d29yayBlYWNoIGNvbnRhY3QgaXMgaW50ZW5kZWQgZm9yLlxuXG4gICAgICAgIGxldCBkdXBsaWNhdGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgYnVpbHRJblByb3ZpZGVyTmV0d29ya0lkcyA9IE9iamVjdC52YWx1ZXMoXG4gICAgICAgICAgTkVUV09SS19UWVBFX1RPX0lEX01BUCxcbiAgICAgICAgKS5tYXAoKGlkcykgPT4gaWRzLm5ldHdvcmtJZCk7XG4gICAgICAgIGNvbnN0IG90aGVyUnBjRW50cmllcyA9IHJwY0xpc3QuZmlsdGVyKFxuICAgICAgICAgIChlbnRyeSkgPT4gZW50cnkucnBjVXJsICE9PSBuZXdScGNEZXRhaWxzLnJwY1VybCxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGJ1aWx0SW5Qcm92aWRlck5ldHdvcmtJZHMuaW5jbHVkZXMoYWRkcmVzc0Jvb2tLZXkpIHx8XG4gICAgICAgICAgb3RoZXJScGNFbnRyaWVzLnNvbWUoKGVudHJ5KSA9PiBlbnRyeS5jaGFpbklkID09PSBhZGRyZXNzQm9va0tleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWlncmF0ZUFkZHJlc3NCb29rU3RhdGUoXG4gICAgICAgICAgYWRkcmVzc0Jvb2tLZXksXG4gICAgICAgICAgdXBkYXRlZFJwYy5jaGFpbklkLFxuICAgICAgICAgIGR1cGxpY2F0ZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJwY0xpc3RbaW5kZXhdID0gdXBkYXRlZFJwYztcbiAgICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBmcmVxdWVudFJwY0xpc3REZXRhaWw6IHJwY0xpc3QgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcnBjVXJsLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB0aWNrZXIsXG4gICAgICAgIG5pY2tuYW1lLFxuICAgICAgICBycGNQcmVmcyA9IHt9LFxuICAgICAgfSA9IG5ld1JwY0RldGFpbHM7XG4gICAgICB0aGlzLmFkZFRvRnJlcXVlbnRScGNMaXN0KHJwY1VybCwgY2hhaW5JZCwgdGlja2VyLCBuaWNrbmFtZSwgcnBjUHJlZnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGN1c3RvbSBSUEMgdXJsIHRvIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcnBjVXJsIC0gVGhlIFJQQyB1cmwgdG8gYWRkIHRvIGZyZXF1ZW50UnBjTGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYWluSWQgLSBUaGUgY2hhaW5JZCBvZiB0aGUgc2VsZWN0ZWQgbmV0d29yay5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0aWNrZXJdIC0gVGlja2VyIHN5bWJvbCBvZiB0aGUgc2VsZWN0ZWQgbmV0d29yay5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuaWNrbmFtZV0gLSBOaWNrbmFtZSBvZiB0aGUgc2VsZWN0ZWQgbmV0d29yay5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtycGNQcmVmc10gLSBPcHRpb25hbCBSUEMgcHJlZmVyZW5jZXMsIHN1Y2ggYXMgdGhlIGJsb2NrIGV4cGxvcmVyIFVSTFxuICAgKlxuICAgKi9cbiAgYWRkVG9GcmVxdWVudFJwY0xpc3QoXG4gICAgcnBjVXJsLFxuICAgIGNoYWluSWQsXG4gICAgdGlja2VyID0gJ0VUSCcsXG4gICAgbmlja25hbWUgPSAnJyxcbiAgICBycGNQcmVmcyA9IHt9LFxuICApIHtcbiAgICBjb25zdCBycGNMaXN0ID0gdGhpcy5nZXRGcmVxdWVudFJwY0xpc3REZXRhaWwoKTtcblxuICAgIGNvbnN0IGluZGV4ID0gcnBjTGlzdC5maW5kSW5kZXgoKGVsZW1lbnQpID0+IHtcbiAgICAgIHJldHVybiBlbGVtZW50LnJwY1VybCA9PT0gcnBjVXJsO1xuICAgIH0pO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHJwY0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUHJlZml4ZWRGb3JtYXR0ZWRIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGFpbklkOiBcIiR7Y2hhaW5JZH1cImApO1xuICAgIH1cblxuICAgIHJwY0xpc3QucHVzaCh7IHJwY1VybCwgY2hhaW5JZCwgdGlja2VyLCBuaWNrbmFtZSwgcnBjUHJlZnMgfSk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGZyZXF1ZW50UnBjTGlzdERldGFpbDogcnBjTGlzdCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGN1c3RvbSBSUEMgdXJsIGZyb20gc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgUlBDIHVybCB0byByZW1vdmUgZnJvbSBmcmVxdWVudFJwY0xpc3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFycmF5Pn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdXBkYXRlZCBmcmVxdWVudFJwY0xpc3QuXG4gICAqXG4gICAqL1xuICByZW1vdmVGcm9tRnJlcXVlbnRScGNMaXN0KHVybCkge1xuICAgIGNvbnN0IHJwY0xpc3QgPSB0aGlzLmdldEZyZXF1ZW50UnBjTGlzdERldGFpbCgpO1xuICAgIGNvbnN0IGluZGV4ID0gcnBjTGlzdC5maW5kSW5kZXgoKGVsZW1lbnQpID0+IHtcbiAgICAgIHJldHVybiBlbGVtZW50LnJwY1VybCA9PT0gdXJsO1xuICAgIH0pO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHJwY0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGZyZXF1ZW50UnBjTGlzdERldGFpbDogcnBjTGlzdCB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJwY0xpc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGBmcmVxdWVudFJwY0xpc3REZXRhaWxgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7YXJyYXk8YXJyYXk+fSBBbiBhcnJheSBvZiBycGMgdXJscy5cbiAgICpcbiAgICovXG4gIGdldEZyZXF1ZW50UnBjTGlzdERldGFpbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmZyZXF1ZW50UnBjTGlzdERldGFpbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBgZmVhdHVyZUZsYWdzYCBwcm9wZXJ0eSwgd2hpY2ggaXMgYW4gb2JqZWN0LiBPbmUgcHJvcGVydHkgd2l0aGluIHRoYXQgb2JqZWN0IHdpbGwgYmUgc2V0IHRvIGEgYm9vbGVhbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSBBIGtleSB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgVUkgZmVhdHVyZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBhY3RpdmF0ZWQgLSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIFVJIGZlYXR1cmUgc2hvdWxkIGJlIGRpc3BsYXllZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBQcm9taXNlcyBhIG5ldyBvYmplY3Q7IHRoZSB1cGRhdGVkIGZlYXR1cmVGbGFncyBvYmplY3QuXG4gICAqXG4gICAqL1xuICBzZXRGZWF0dXJlRmxhZyhmZWF0dXJlLCBhY3RpdmF0ZWQpIHtcbiAgICBjb25zdCBjdXJyZW50RmVhdHVyZUZsYWdzID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmZlYXR1cmVGbGFncztcbiAgICBjb25zdCB1cGRhdGVkRmVhdHVyZUZsYWdzID0ge1xuICAgICAgLi4uY3VycmVudEZlYXR1cmVGbGFncyxcbiAgICAgIFtmZWF0dXJlXTogYWN0aXZhdGVkLFxuICAgIH07XG5cbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgZmVhdHVyZUZsYWdzOiB1cGRhdGVkRmVhdHVyZUZsYWdzIH0pO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1cGRhdGVkRmVhdHVyZUZsYWdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBgcHJlZmVyZW5jZXNgIHByb3BlcnR5LCB3aGljaCBpcyBhbiBvYmplY3QuIFRoZXNlIGFyZSB1c2VyLWNvbnRyb2xsZWQgZmVhdHVyZXNcbiAgICogZm91bmQgaW4gdGhlIHNldHRpbmdzIHBhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmZXJlbmNlIC0gVGhlIHByZWZlcmVuY2UgdG8gZW5hYmxlIG9yIGRpc2FibGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIHByZWZlcmVuY2Ugc2hvdWxkIGJlIGVuYWJsZWQgb3IgZGlzYWJsZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFByb21pc2VzIGEgbmV3IG9iamVjdDsgdGhlIHVwZGF0ZWQgcHJlZmVyZW5jZXMgb2JqZWN0LlxuICAgKi9cbiAgc2V0UHJlZmVyZW5jZShwcmVmZXJlbmNlLCB2YWx1ZSkge1xuICAgIGNvbnN0IGN1cnJlbnRQcmVmZXJlbmNlcyA9IHRoaXMuZ2V0UHJlZmVyZW5jZXMoKTtcbiAgICBjb25zdCB1cGRhdGVkUHJlZmVyZW5jZXMgPSB7XG4gICAgICAuLi5jdXJyZW50UHJlZmVyZW5jZXMsXG4gICAgICBbcHJlZmVyZW5jZV06IHZhbHVlLFxuICAgIH07XG5cbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgcHJlZmVyZW5jZXM6IHVwZGF0ZWRQcmVmZXJlbmNlcyB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVwZGF0ZWRQcmVmZXJlbmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSBgcHJlZmVyZW5jZXNgIHByb3BlcnR5XG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEga2V5LWJvb2xlYW4gbWFwIG9mIHVzZXItc2VsZWN0ZWQgcHJlZmVyZW5jZXMuXG4gICAqL1xuICBnZXRQcmVmZXJlbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLnByZWZlcmVuY2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIGZvciB0aGUgYGlwZnNHYXRld2F5YCBwcm9wZXJ0eVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY3VycmVudCBJUEZTIGdhdGV3YXkgZG9tYWluXG4gICAqL1xuICBnZXRJcGZzR2F0ZXdheSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmlwZnNHYXRld2F5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2V0dGVyIGZvciB0aGUgYGlwZnNHYXRld2F5YCBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluIC0gVGhlIG5ldyBJUEZTIGdhdGV3YXkgZG9tYWluXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSBvZiB0aGUgdXBkYXRlIElQRlMgZ2F0ZXdheSBkb21haW5cbiAgICovXG4gIHNldElwZnNHYXRld2F5KGRvbWFpbikge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBpcGZzR2F0ZXdheTogZG9tYWluIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZG9tYWluKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNldHRlciBmb3IgdGhlIGB1c2VXZWJIaWRgIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZWRnZXJUcmFuc3BvcnRUeXBlIC0gRWl0aGVyICdsZWRnZXJMaXZlJywgJ3dlYmhpZCcgb3IgJ3UyZidcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRyYW5zcG9ydCB0eXBlIHRoYXQgd2FzIHNldC5cbiAgICovXG4gIHNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UobGVkZ2VyVHJhbnNwb3J0VHlwZSkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBsZWRnZXJUcmFuc3BvcnRUeXBlIH0pO1xuICAgIHJldHVybiBsZWRnZXJUcmFuc3BvcnRUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIGZvciB0aGUgYGxlZGdlclRyYW5zcG9ydFR5cGVgIHByb3BlcnR5XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBVc2VyIHByZWZlcmVuY2Ugb2YgdXNpbmcgV2ViSGlkIHRvIGNvbm5lY3QgTGVkZ2VyXG4gICAqL1xuICBnZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkubGVkZ2VyVHJhbnNwb3J0VHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNldHRlciBmb3IgdGhlIHVzZXIgcHJlZmVyZW5jZSB0byBkaXNtaXNzIHRoZSBzZWVkIHBocmFzZSBiYWNrdXAgcmVtaW5kZXJcbiAgICogQHBhcmFtIHtib29sfSBkaXNtaXNzQmFja3VwUmVtaW5kZXItIFVzZXIgcHJlZmVyZW5jZSBmb3IgZGlzbWlzc2luZyB0aGUgYmFjayB1cCByZW1pbmRlclxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGFzeW5jIHNldERpc21pc3NTZWVkQmFja1VwUmVtaW5kZXIoZGlzbWlzc1NlZWRCYWNrVXBSZW1pbmRlcikge1xuICAgIGF3YWl0IHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgZGlzbWlzc1NlZWRCYWNrVXBSZW1pbmRlcixcbiAgICB9KTtcbiAgfVxuXG4gIC8vXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuICAvL1xuXG4gIF9zdWJzY3JpYmVUb0luZnVyYUF2YWlsYWJpbGl0eSgpIHtcbiAgICB0aGlzLm5ldHdvcmsub24oTkVUV09SS19FVkVOVFMuSU5GVVJBX0lTX0JMT0NLRUQsICgpID0+IHtcbiAgICAgIHRoaXMuX3NldEluZnVyYUJsb2NrZWQodHJ1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5uZXR3b3JrLm9uKE5FVFdPUktfRVZFTlRTLklORlVSQV9JU19VTkJMT0NLRUQsICgpID0+IHtcbiAgICAgIHRoaXMuX3NldEluZnVyYUJsb2NrZWQoZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEEgc2V0dGVyIGZvciB0aGUgYGluZnVyYUJsb2NrZWRgIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNCbG9ja2VkIC0gQm9vbCBpbmRpY2F0aW5nIHdoZXRoZXIgSW5mdXJhIGlzIGJsb2NrZWRcbiAgICpcbiAgICovXG4gIF9zZXRJbmZ1cmFCbG9ja2VkKGlzQmxvY2tlZCkge1xuICAgIGNvbnN0IHsgaW5mdXJhQmxvY2tlZCB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgaWYgKGluZnVyYUJsb2NrZWQgPT09IGlzQmxvY2tlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBpbmZ1cmFCbG9ja2VkOiBpc0Jsb2NrZWQgfSk7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaWRSZW1hcE1pZGRsZXdhcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NyZWF0ZUFzeW5jTWlkZGxld2FyZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9nZXRVbmlxdWVJZFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vSnNvblJwY0VuZ2luZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWVyZ2VNaWRkbGV3YXJlXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNWtaWGd1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTl6Y21NdmFXNWtaWGd1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN08wRkJRVUVzYzBSQlFXOURPMEZCUTNCRExEQkVRVUYzUXp0QlFVTjRReXcyUkVGQk1rTTdRVUZETTBNc1owUkJRVGhDTzBGQlF6bENMR3RFUVVGblF6dEJRVU5vUXl4dlJFRkJhME1pZlE9PSIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IHN0cmljdCBhcyBhc3NlcnQgfSBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVN0b3JlIH0gZnJvbSAnQG1ldGFtYXNrL29icy1zdG9yZSc7XG5pbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgeyB0eXBlZFNpZ25hdHVyZUhhc2gsIFRZUEVEX01FU1NBR0VfU0NIRU1BIH0gZnJvbSAnZXRoLXNpZy11dGlsJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IGpzb25zY2hlbWEgZnJvbSAnanNvbnNjaGVtYSc7XG5pbXBvcnQgeyBNRVNTQUdFX1RZUEUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XG5pbXBvcnQgeyBNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUyB9IGZyb20gJy4uL21ldGFtYXNrLWNvbnRyb2xsZXInO1xuaW1wb3J0IGNyZWF0ZUlkIGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3JhbmRvbS1pZCc7XG5pbXBvcnQgeyBpc1ZhbGlkSGV4QWRkcmVzcyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2hleHN0cmluZy11dGlscyc7XG5cbi8qKlxuICogUmVwcmVzZW50cywgYW5kIGNvbnRhaW5zIGRhdGEgYWJvdXQsIGFuICdldGhfc2lnblR5cGVkRGF0YScgdHlwZSBzaWduYXR1cmUgcmVxdWVzdC4gVGhlc2UgYXJlIGNyZWF0ZWQgd2hlbiBhXG4gKiBzaWduYXR1cmUgZm9yIGFuIGV0aF9zaWduVHlwZWREYXRhIGNhbGwgaXMgcmVxdWVzdGVkLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFR5cGVkTWVzc2FnZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlkIEFuIGlkIHRvIHRyYWNrIGFuZCBpZGVudGlmeSB0aGUgbWVzc2FnZSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtc2dQYXJhbXMgVGhlIHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgZXRoX3NpZ25UeXBlZERhdGEgbWV0aG9kIG9uY2UgdGhlIHNpZ25hdHVyZSByZXF1ZXN0IGlzXG4gKiBhcHByb3ZlZC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtc2dQYXJhbXMubWV0YW1hc2tJZCBBZGRlZCB0byBtc2dQYXJhbXMgZm9yIHRyYWNraW5nIGFuZCBpZGVudGlmaWNhdGlvbiB3aXRoaW4gTWV0YU1hc2suXG4gKiBAcHJvcGVydHkge09iamVjdH0gbXNnUGFyYW1zLmZyb20gVGhlIGFkZHJlc3MgdGhhdCBpcyBtYWtpbmcgdGhlIHNpZ25hdHVyZSByZXF1ZXN0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1zZ1BhcmFtcy5kYXRhIEEgaGV4IHN0cmluZyBjb252ZXJzaW9uIG9mIHRoZSByYXcgYnVmZmVyIGRhdGEgb2YgdGhlIHNpZ25hdHVyZSByZXF1ZXN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZSBUaGUgZXBvY2ggdGltZSBhdCB3aGljaCB0aGUgdGhpcyBtZXNzYWdlIHdhcyBjcmVhdGVkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdHVzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzaWduYXR1cmUgcmVxdWVzdCBpcyAndW5hcHByb3ZlZCcsICdhcHByb3ZlZCcsICdzaWduZWQnLCAncmVqZWN0ZWQnLCBvciAnZXJyb3JlZCdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIFRoZSBqc29uLXByYyBzaWduaW5nIG1ldGhvZCBmb3Igd2hpY2ggYSBzaWduYXR1cmUgcmVxdWVzdCBoYXMgYmVlbiBtYWRlLiBBICdNZXNzYWdlJyB3aWxsXG4gKiBhbHdheXMgaGF2ZSBhICdldGhfc2lnblR5cGVkRGF0YScgdHlwZS5cbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHlwZWRNZXNzYWdlTWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDb250cm9sbGVyIGluIGNoYXJnZSBvZiBtYW5hZ2luZyAtIHN0b3JpbmcsIGFkZGluZywgcmVtb3ZpbmcsIHVwZGF0aW5nIC0gVHlwZWRNZXNzYWdlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBnZXRDdXJyZW50Q2hhaW5JZCwgbWV0cmljRXZlbnRzIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2dldEN1cnJlbnRDaGFpbklkID0gZ2V0Q3VycmVudENoYWluSWQ7XG4gICAgdGhpcy5tZW1TdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgdW5hcHByb3ZlZFR5cGVkTWVzc2FnZXM6IHt9LFxuICAgICAgdW5hcHByb3ZlZFR5cGVkTWVzc2FnZXNDb3VudDogMCxcbiAgICB9KTtcbiAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgdGhpcy5tZXRyaWNFdmVudHMgPSBtZXRyaWNFdmVudHM7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSBudW1iZXIgb2YgJ3VuYXBwcm92ZWQnIFR5cGVkTWVzc2FnZXMgaW4gdGhpcy5tZXNzYWdlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mICd1bmFwcHJvdmVkJyBUeXBlZE1lc3NhZ2VzIGluIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICovXG4gIGdldCB1bmFwcHJvdmVkVHlwZWRNZXNzYWdlc0NvdW50KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldFVuYXBwcm92ZWRNc2dzKCkpLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGdldHRlciBmb3IgdGhlICd1bmFwcHJvdmVkJyBUeXBlZE1lc3NhZ2VzIGluIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gQW4gaW5kZXggb2YgVHlwZWRNZXNzYWdlIGlkcyB0byBUeXBlZE1lc3NhZ2VzLCBmb3IgYWxsICd1bmFwcHJvdmVkJyBUeXBlZE1lc3NhZ2VzIGluXG4gICAqIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICovXG4gIGdldFVuYXBwcm92ZWRNc2dzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzXG4gICAgICAuZmlsdGVyKChtc2cpID0+IG1zZy5zdGF0dXMgPT09ICd1bmFwcHJvdmVkJylcbiAgICAgIC5yZWR1Y2UoKHJlc3VsdCwgbXNnKSA9PiB7XG4gICAgICAgIHJlc3VsdFttc2cuaWRdID0gbXNnO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVHlwZWRNZXNzYWdlIHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1zZ1BhcmFtcy4gdGhpcy5hZGRNc2cgaXMgY2FsbGVkIHRvIGFkZFxuICAgKiB0aGUgbmV3IFR5cGVkTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBUeXBlZE1lc3NhZ2VzIGZyb20gdGhhdCBsaXN0IHRvXG4gICAqIHRoaXMubWVtU3RvcmUuIEJlZm9yZSBhbnkgb2YgdGhpcyBpcyBkb25lLCBtc2dQYXJhbXMgYXJlIHZhbGlkYXRlZFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIGV0aF9zaWduIGNhbGwgdG8gYmUgbWFkZSBhZnRlciB0aGUgbWVzc2FnZSBpcyBhcHByb3ZlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtyZXFdIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpblxuICAgKiBAcmV0dXJucyB7cHJvbWlzZX0gV2hlbiB0aGUgbWVzc2FnZSBoYXMgYmVlbiBzaWduZWQgb3IgcmVqZWN0ZWRcbiAgICpcbiAgICovXG4gIGFkZFVuYXBwcm92ZWRNZXNzYWdlQXN5bmMobXNnUGFyYW1zLCByZXEsIHZlcnNpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbXNnSWQgPSB0aGlzLmFkZFVuYXBwcm92ZWRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxLCB2ZXJzaW9uKTtcbiAgICAgIHRoaXMub25jZShgJHttc2dJZH06ZmluaXNoZWRgLCAoZGF0YSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSAnc2lnbmVkJzpcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRhdGEucmF3U2lnKTtcbiAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgICAgICAgICBldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdChcbiAgICAgICAgICAgICAgICAnTWV0YU1hc2sgTWVzc2FnZSBTaWduYXR1cmU6IFVzZXIgZGVuaWVkIG1lc3NhZ2Ugc2lnbmF0dXJlLicsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgJ2Vycm9yZWQnOlxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKGBNZXRhTWFzayBNZXNzYWdlIFNpZ25hdHVyZTogJHtkYXRhLmVycm9yfWApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBNZXRhTWFzayBNZXNzYWdlIFNpZ25hdHVyZTogVW5rbm93biBwcm9ibGVtOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgbXNnUGFyYW1zLFxuICAgICAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVHlwZWRNZXNzYWdlIHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1zZ1BhcmFtcy4gdGhpcy5hZGRNc2cgaXMgY2FsbGVkIHRvIGFkZFxuICAgKiB0aGUgbmV3IFR5cGVkTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBUeXBlZE1lc3NhZ2VzIGZyb20gdGhhdCBsaXN0IHRvXG4gICAqIHRoaXMubWVtU3RvcmUuIEJlZm9yZSBhbnkgb2YgdGhpcyBpcyBkb25lLCBtc2dQYXJhbXMgYXJlIHZhbGlkYXRlZFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIGV0aF9zaWduIGNhbGwgdG8gYmUgbWFkZSBhZnRlciB0aGUgbWVzc2FnZSBpcyBhcHByb3ZlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtyZXFdIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpblxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaWQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgVHlwZWRNZXNzYWdlLlxuICAgKlxuICAgKi9cbiAgYWRkVW5hcHByb3ZlZE1lc3NhZ2UobXNnUGFyYW1zLCByZXEsIHZlcnNpb24pIHtcbiAgICBtc2dQYXJhbXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgaWYgKHJlcSkge1xuICAgICAgbXNnUGFyYW1zLm9yaWdpbiA9IHJlcS5vcmlnaW47XG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGVQYXJhbXMobXNnUGFyYW1zKTtcblxuICAgIGxvZy5kZWJ1ZyhcbiAgICAgIGBUeXBlZE1lc3NhZ2VNYW5hZ2VyIGFkZFVuYXBwcm92ZWRNZXNzYWdlOiAke0pTT04uc3RyaW5naWZ5KG1zZ1BhcmFtcyl9YCxcbiAgICApO1xuXG4gICAgLy8gY3JlYXRlIHR4RGF0YSBvYmogd2l0aCBwYXJhbWV0ZXJzIGFuZCBtZXRhIGRhdGFcbiAgICBjb25zdCB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgbXNnSWQgPSBjcmVhdGVJZCgpO1xuICAgIGNvbnN0IG1zZ0RhdGEgPSB7XG4gICAgICBpZDogbXNnSWQsXG4gICAgICBtc2dQYXJhbXMsXG4gICAgICB0aW1lLFxuICAgICAgc3RhdHVzOiAndW5hcHByb3ZlZCcsXG4gICAgICB0eXBlOiBNRVNTQUdFX1RZUEUuRVRIX1NJR05fVFlQRURfREFUQSxcbiAgICB9O1xuICAgIHRoaXMuYWRkTXNnKG1zZ0RhdGEpO1xuXG4gICAgLy8gc2lnbmFsIHVwZGF0ZVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJyk7XG4gICAgcmV0dXJuIG1zZ0lkO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgZm9yIHRoaXMuYWRkVW5hcHByb3ZlZE1lc3NhZ2UuIFZhbGlkYXRlcyB0aGF0IHRoZSBwYXNzZWQgcGFyYW1zIGhhdmUgdGhlIHJlcXVpcmVkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1zIHRvIHZhbGlkYXRlXG4gICAqXG4gICAqL1xuICB2YWxpZGF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICBhc3NlcnQub2soXG4gICAgICBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcsXG4gICAgICAnUGFyYW1zIG11c3QgYmUgYW4gb2JqZWN0LicsXG4gICAgKTtcbiAgICBhc3NlcnQub2soJ2RhdGEnIGluIHBhcmFtcywgJ1BhcmFtcyBtdXN0IGluY2x1ZGUgYSBcImRhdGFcIiBmaWVsZC4nKTtcbiAgICBhc3NlcnQub2soJ2Zyb20nIGluIHBhcmFtcywgJ1BhcmFtcyBtdXN0IGluY2x1ZGUgYSBcImZyb21cIiBmaWVsZC4nKTtcbiAgICBhc3NlcnQub2soXG4gICAgICB0eXBlb2YgcGFyYW1zLmZyb20gPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGlzVmFsaWRIZXhBZGRyZXNzKHBhcmFtcy5mcm9tLCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pLFxuICAgICAgJ1wiZnJvbVwiIGZpZWxkIG11c3QgYmUgYSB2YWxpZCwgbG93ZXJjYXNlLCBoZXhhZGVjaW1hbCBFdGhlcmV1bSBhZGRyZXNzIHN0cmluZy4nLFxuICAgICk7XG5cbiAgICBzd2l0Y2ggKHBhcmFtcy52ZXJzaW9uKSB7XG4gICAgICBjYXNlICdWMSc6XG4gICAgICAgIGFzc2VydC5vayhcbiAgICAgICAgICBBcnJheS5pc0FycmF5KHBhcmFtcy5kYXRhKSxcbiAgICAgICAgICAnXCJwYXJhbXMuZGF0YVwiIG11c3QgYmUgYW4gYXJyYXkuJyxcbiAgICAgICAgKTtcbiAgICAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdygoKSA9PiB7XG4gICAgICAgICAgdHlwZWRTaWduYXR1cmVIYXNoKHBhcmFtcy5kYXRhKTtcbiAgICAgICAgfSwgJ1NpZ25pbmcgZGF0YSBtdXN0IGJlIHZhbGlkIEVJUC03MTIgdHlwZWQgZGF0YS4nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdWMyc6XG4gICAgICBjYXNlICdWNCc6IHtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKFxuICAgICAgICAgIHR5cGVvZiBwYXJhbXMuZGF0YSxcbiAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAnXCJwYXJhbXMuZGF0YVwiIG11c3QgYmUgYSBzdHJpbmcuJyxcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGFzc2VydC5kb2VzTm90VGhyb3coKCkgPT4ge1xuICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHBhcmFtcy5kYXRhKTtcbiAgICAgICAgfSwgJ1wiZGF0YVwiIG11c3QgYmUgYSB2YWxpZCBKU09OIHN0cmluZy4nKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGpzb25zY2hlbWEudmFsaWRhdGUoZGF0YSwgVFlQRURfTUVTU0FHRV9TQ0hFTUEpO1xuICAgICAgICBhc3NlcnQub2soXG4gICAgICAgICAgZGF0YS5wcmltYXJ5VHlwZSBpbiBkYXRhLnR5cGVzLFxuICAgICAgICAgIGBQcmltYXJ5IHR5cGUgb2YgXCIke2RhdGEucHJpbWFyeVR5cGV9XCIgaGFzIG5vIHR5cGUgZGVmaW5pdGlvbi5gLFxuICAgICAgICApO1xuICAgICAgICBhc3NlcnQuZXF1YWwoXG4gICAgICAgICAgdmFsaWRhdGlvbi5lcnJvcnMubGVuZ3RoLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgJ1NpZ25pbmcgZGF0YSBtdXN0IGNvbmZvcm0gdG8gRUlQLTcxMiBzY2hlbWEuIFNlZSBodHRwczovL2dpdC5pby9mTnRjeC4nLFxuICAgICAgICApO1xuICAgICAgICBsZXQgeyBjaGFpbklkIH0gPSBkYXRhLmRvbWFpbjtcbiAgICAgICAgaWYgKGNoYWluSWQpIHtcbiAgICAgICAgICBjb25zdCBhY3RpdmVDaGFpbklkID0gcGFyc2VJbnQodGhpcy5fZ2V0Q3VycmVudENoYWluSWQoKSwgMTYpO1xuICAgICAgICAgIGFzc2VydC5vayhcbiAgICAgICAgICAgICFOdW1iZXIuaXNOYU4oYWN0aXZlQ2hhaW5JZCksXG4gICAgICAgICAgICBgQ2Fubm90IHNpZ24gbWVzc2FnZXMgZm9yIGNoYWluSWQgXCIke2NoYWluSWR9XCIsIGJlY2F1c2UgTWV0YU1hc2sgaXMgc3dpdGNoaW5nIG5ldHdvcmtzLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNoYWluSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCwgY2hhaW5JZC5zdGFydHNXaXRoKCcweCcpID8gMTYgOiAxMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2VydC5lcXVhbChcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICBhY3RpdmVDaGFpbklkLFxuICAgICAgICAgICAgYFByb3ZpZGVkIGNoYWluSWQgXCIke2NoYWluSWR9XCIgbXVzdCBtYXRjaCB0aGUgYWN0aXZlIGNoYWluSWQgXCIke2FjdGl2ZUNoYWluSWR9XCJgLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhc3NlcnQuZmFpbChgVW5rbm93biB0eXBlZCBkYXRhIHZlcnNpb24gXCIke3BhcmFtcy52ZXJzaW9ufVwiYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBwYXNzZWQgVHlwZWRNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCBjYWxscyB0aGlzLl9zYXZlTXNnTGlzdCgpIHRvIHNhdmUgdGhlIHVuYXBwcm92ZWQgVHlwZWRNZXNzYWdlcyBmcm9tIHRoYXRcbiAgICogbGlzdCB0byB0aGlzLm1lbVN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1zZyAtIFRoZSBUeXBlZE1lc3NhZ2UgdG8gYWRkIHRvIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICovXG4gIGFkZE1zZyhtc2cpIHtcbiAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobXNnKTtcbiAgICB0aGlzLl9zYXZlTXNnTGlzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgVHlwZWRNZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIFR5cGVkTWVzc2FnZSB0byBnZXRcbiAgICogQHJldHVybnMge1R5cGVkTWVzc2FnZXx1bmRlZmluZWR9IFRoZSBUeXBlZE1lc3NhZ2Ugd2l0aCB0aGUgaWQgdGhhdCBtYXRjaGVzIHRoZSBwYXNzZWQgbXNnSWQsIG9yIHVuZGVmaW5lZFxuICAgKiBpZiBubyBUeXBlZE1lc3NhZ2UgaGFzIHRoYXQgaWQuXG4gICAqXG4gICAqL1xuICBnZXRNc2cobXNnSWQpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5maW5kKChtc2cpID0+IG1zZy5pZCA9PT0gbXNnSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcHJvdmVzIGEgVHlwZWRNZXNzYWdlLiBTZXRzIHRoZSBtZXNzYWdlIHN0YXR1cyB2aWEgYSBjYWxsIHRvIHRoaXMuc2V0TXNnU3RhdHVzQXBwcm92ZWQsIGFuZCByZXR1cm5zIGEgcHJvbWlzZVxuICAgKiB3aXRoIGFueSB0aGUgbWVzc2FnZSBwYXJhbXMgbW9kaWZpZWQgZm9yIHByb3BlciBzaWduaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIG1zZ1BhcmFtcyB0byBiZSB1c2VkIHdoZW4gZXRoX3NpZ24gaXMgY2FsbGVkLCBwbHVzIGRhdGEgYWRkZWQgYnkgTWV0YU1hc2suXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMubWV0YW1hc2tJZCBBZGRlZCB0byBtc2dQYXJhbXMgZm9yIHRyYWNraW5nIGFuZCBpZGVudGlmaWNhdGlvbiB3aXRoaW4gTWV0YU1hc2suXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFByb21pc2VzIHRoZSBtc2dQYXJhbXMgb2JqZWN0IHdpdGggbWV0YW1hc2tJZCByZW1vdmVkLlxuICAgKlxuICAgKi9cbiAgYXBwcm92ZU1lc3NhZ2UobXNnUGFyYW1zKSB7XG4gICAgdGhpcy5zZXRNc2dTdGF0dXNBcHByb3ZlZChtc2dQYXJhbXMubWV0YW1hc2tJZCk7XG4gICAgcmV0dXJuIHRoaXMucHJlcE1zZ0ZvclNpZ25pbmcobXNnUGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgVHlwZWRNZXNzYWdlIHN0YXR1cyB0byAnYXBwcm92ZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIFR5cGVkTWVzc2FnZSB0byBhcHByb3ZlLlxuICAgKlxuICAgKi9cbiAgc2V0TXNnU3RhdHVzQXBwcm92ZWQobXNnSWQpIHtcbiAgICB0aGlzLl9zZXRNc2dTdGF0dXMobXNnSWQsICdhcHByb3ZlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBUeXBlZE1lc3NhZ2Ugc3RhdHVzIHRvICdzaWduZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzIGFuZCB1cGRhdGVzIHRoYXQgVHlwZWRNZXNzYWdlIGluXG4gICAqIHRoaXMubWVzc2FnZXMgYnkgYWRkaW5nIHRoZSByYXcgc2lnbmF0dXJlIGRhdGEgb2YgdGhlIHNpZ25hdHVyZSByZXF1ZXN0IHRvIHRoZSBUeXBlZE1lc3NhZ2VcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBUeXBlZE1lc3NhZ2UgdG8gc2lnbi5cbiAgICogQHBhcmFtIHtidWZmZXJ9IHJhd1NpZyAtIFRoZSByYXcgZGF0YSBvZiB0aGUgc2lnbmF0dXJlIHJlcXVlc3RcbiAgICpcbiAgICovXG4gIHNldE1zZ1N0YXR1c1NpZ25lZChtc2dJZCwgcmF3U2lnKSB7XG4gICAgY29uc3QgbXNnID0gdGhpcy5nZXRNc2cobXNnSWQpO1xuICAgIG1zZy5yYXdTaWcgPSByYXdTaWc7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAnc2lnbmVkJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSBmcm9tIHBhc3NlZCBtc2dQYXJhbXMgYW5kIHJldHVybnMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRoZSB1cGRhdGVkIG1zZ1BhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIG1zZ1BhcmFtcyB0byBtb2RpZnlcbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gUHJvbWlzZXMgdGhlIG1zZ1BhcmFtcyB3aXRoIHRoZSBtZXRhbWFza0lkIHByb3BlcnR5IHJlbW92ZWRcbiAgICpcbiAgICovXG4gIHByZXBNc2dGb3JTaWduaW5nKG1zZ1BhcmFtcykge1xuICAgIGRlbGV0ZSBtc2dQYXJhbXMubWV0YW1hc2tJZDtcbiAgICBkZWxldGUgbXNnUGFyYW1zLnZlcnNpb247XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2dQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBUeXBlZE1lc3NhZ2Ugc3RhdHVzIHRvICdyZWplY3RlZCcgdmlhIGEgY2FsbCB0byB0aGlzLl9zZXRNc2dTdGF0dXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgVHlwZWRNZXNzYWdlIHRvIHJlamVjdC5cbiAgICpcbiAgICovXG4gIHJlamVjdE1zZyhtc2dJZCwgcmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHJlYXNvbikge1xuICAgICAgY29uc3QgbXNnID0gdGhpcy5nZXRNc2cobXNnSWQpO1xuICAgICAgdGhpcy5tZXRyaWNzRXZlbnQoe1xuICAgICAgICBldmVudDogcmVhc29uLFxuICAgICAgICBjYXRlZ29yeTogJ1RyYW5zYWN0aW9ucycsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBhY3Rpb246ICdTaWduIFJlcXVlc3QnLFxuICAgICAgICAgIHZlcnNpb246IG1zZy5tc2dQYXJhbXMudmVyc2lvbixcbiAgICAgICAgICB0eXBlOiBtc2cudHlwZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9zZXRNc2dTdGF0dXMobXNnSWQsICdyZWplY3RlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBUeXBlZE1lc3NhZ2Ugc3RhdHVzIHRvICdlcnJvcmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBUeXBlZE1lc3NhZ2UgdG8gZXJyb3JcbiAgICpcbiAgICovXG4gIGVycm9yTWVzc2FnZShtc2dJZCwgZXJyb3IpIHtcbiAgICBjb25zdCBtc2cgPSB0aGlzLmdldE1zZyhtc2dJZCk7XG4gICAgbXNnLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAnZXJyb3JlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgdW5hcHByb3ZlZCBtZXNzYWdlcyBmcm9tIG1lbW9yeS5cbiAgICovXG4gIGNsZWFyVW5hcHByb3ZlZCgpIHtcbiAgICB0aGlzLm1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcy5maWx0ZXIoKG1zZykgPT4gbXNnLnN0YXR1cyAhPT0gJ3VuYXBwcm92ZWQnKTtcbiAgICB0aGlzLl9zYXZlTXNnTGlzdCgpO1xuICB9XG5cbiAgLy9cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG4gIC8vXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YXR1cyBvZiBhIFR5cGVkTWVzc2FnZSBpbiB0aGlzLm1lc3NhZ2VzIHZpYSBhIGNhbGwgdG8gdGhpcy5fdXBkYXRlTXNnXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgVHlwZWRNZXNzYWdlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1cyAtIFRoZSBuZXcgc3RhdHVzIG9mIHRoZSBUeXBlZE1lc3NhZ2UuXG4gICAqIEB0aHJvd3MgQSAnVHlwZWRNZXNzYWdlTWFuYWdlciAtIFR5cGVkTWVzc2FnZSBub3QgZm91bmQgZm9yIGlkOiBcIiR7bXNnSWR9XCIuJyBpZiB0aGVyZSBpcyBubyBUeXBlZE1lc3NhZ2VcbiAgICogaW4gdGhpcy5tZXNzYWdlcyB3aXRoIGFuIGlkIGVxdWFsIHRvIHRoZSBwYXNzZWQgbXNnSWRcbiAgICogQGZpcmVzIEFuIGV2ZW50IHdpdGggYSBuYW1lIGVxdWFsIHRvIGAke21zZ0lkfToke3N0YXR1c31gLiBUaGUgVHlwZWRNZXNzYWdlIGlzIGFsc28gZmlyZWQuXG4gICAqIEBmaXJlcyBJZiBzdGF0dXMgaXMgJ3JlamVjdGVkJyBvciAnc2lnbmVkJywgYW4gZXZlbnQgd2l0aCBhIG5hbWUgZXF1YWwgdG8gYCR7bXNnSWR9OmZpbmlzaGVkYCBpcyBmaXJlZCBhbG9uZ1xuICAgKiB3aXRoIHRoZSBUeXBlZE1lc3NhZ2VcbiAgICpcbiAgICovXG4gIF9zZXRNc2dTdGF0dXMobXNnSWQsIHN0YXR1cykge1xuICAgIGNvbnN0IG1zZyA9IHRoaXMuZ2V0TXNnKG1zZ0lkKTtcbiAgICBpZiAoIW1zZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVHlwZWRNZXNzYWdlTWFuYWdlciAtIE1lc3NhZ2Ugbm90IGZvdW5kIGZvciBpZDogXCIke21zZ0lkfVwiLmAsXG4gICAgICApO1xuICAgIH1cbiAgICBtc2cuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuX3VwZGF0ZU1zZyhtc2cpO1xuICAgIHRoaXMuZW1pdChgJHttc2dJZH06JHtzdGF0dXN9YCwgbXNnKTtcbiAgICBpZiAoc3RhdHVzID09PSAncmVqZWN0ZWQnIHx8IHN0YXR1cyA9PT0gJ3NpZ25lZCcgfHwgc3RhdHVzID09PSAnZXJyb3JlZCcpIHtcbiAgICAgIHRoaXMuZW1pdChgJHttc2dJZH06ZmluaXNoZWRgLCBtc2cpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgVHlwZWRNZXNzYWdlIGluIHRoaXMubWVzc2FnZXMgdG8gdGhlIHBhc3NlZCBUeXBlZE1lc3NhZ2UgaWYgdGhlIGlkcyBhcmUgZXF1YWwuIFRoZW4gc2F2ZXMgdGhlXG4gICAqIHVuYXBwcm92ZWRUeXBlZE1zZ3MgaW5kZXggdG8gc3RvcmFnZSB2aWEgdGhpcy5fc2F2ZU1zZ0xpc3RcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHttc2d9IFR5cGVkTWVzc2FnZSAtIEEgVHlwZWRNZXNzYWdlIHRoYXQgd2lsbCByZXBsYWNlIGFuIGV4aXN0aW5nIFR5cGVkTWVzc2FnZSAod2l0aCB0aGUgc2FtZVxuICAgKiBpZCkgaW4gdGhpcy5tZXNzYWdlc1xuICAgKlxuICAgKi9cbiAgX3VwZGF0ZU1zZyhtc2cpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMubWVzc2FnZXMuZmluZEluZGV4KChtZXNzYWdlKSA9PiBtZXNzYWdlLmlkID09PSBtc2cuaWQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMubWVzc2FnZXNbaW5kZXhdID0gbXNnO1xuICAgIH1cbiAgICB0aGlzLl9zYXZlTXNnTGlzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIHRoZSB1bmFwcHJvdmVkIFR5cGVkTWVzc2FnZXMsIGFuZCB0aGVpciBjb3VudCwgdG8gdGhpcy5tZW1TdG9yZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZmlyZXMgJ3VwZGF0ZUJhZGdlJ1xuICAgKlxuICAgKi9cbiAgX3NhdmVNc2dMaXN0KCkge1xuICAgIGNvbnN0IHVuYXBwcm92ZWRUeXBlZE1lc3NhZ2VzID0gdGhpcy5nZXRVbmFwcHJvdmVkTXNncygpO1xuICAgIGNvbnN0IHVuYXBwcm92ZWRUeXBlZE1lc3NhZ2VzQ291bnQgPSBPYmplY3Qua2V5cyh1bmFwcHJvdmVkVHlwZWRNZXNzYWdlcylcbiAgICAgIC5sZW5ndGg7XG4gICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICB1bmFwcHJvdmVkVHlwZWRNZXNzYWdlcyxcbiAgICAgIHVuYXBwcm92ZWRUeXBlZE1lc3NhZ2VzQ291bnQsXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSk7XG4gIH1cbn1cbiIsImltcG9ydCBwdW55Y29kZSBmcm9tICdwdW55Y29kZS9wdW55Y29kZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsgQ0hBSU5fSURfVE9fTkVUV09SS19JRF9NQVAgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuaW1wb3J0IHsgdG9DaGVja3N1bUhleEFkZHJlc3MgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9oZXhzdHJpbmctdXRpbHMnO1xuaW1wb3J0IEVucyBmcm9tICcuL2Vucyc7XG5cbmNvbnN0IFpFUk9fQUREUkVTUyA9ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnO1xuY29uc3QgWkVST19YX0VSUk9SX0FERFJFU1MgPSAnMHgnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnNDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoeyBlbnMsIHByb3ZpZGVyLCBvbk5ldHdvcmtEaWRDaGFuZ2UsIGdldEN1cnJlbnRDaGFpbklkIH0gPSB7fSkge1xuICAgIGNvbnN0IGluaXRTdGF0ZSA9IHtcbiAgICAgIGVuc1Jlc29sdXRpb25zQnlBZGRyZXNzOiB7fSxcbiAgICB9O1xuXG4gICAgdGhpcy5fZW5zID0gZW5zO1xuICAgIGlmICghdGhpcy5fZW5zKSB7XG4gICAgICBjb25zdCBjaGFpbklkID0gZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBDSEFJTl9JRF9UT19ORVRXT1JLX0lEX01BUFtjaGFpbklkXTtcbiAgICAgIGlmIChFbnMuZ2V0TmV0d29ya0Vuc1N1cHBvcnQobmV0d29yaykpIHtcbiAgICAgICAgdGhpcy5fZW5zID0gbmV3IEVucyh7XG4gICAgICAgICAgbmV0d29yayxcbiAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoaW5pdFN0YXRlKTtcbiAgICBvbk5ldHdvcmtEaWRDaGFuZ2UoKCkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5wdXRTdGF0ZShpbml0U3RhdGUpO1xuICAgICAgY29uc3QgY2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgICBjb25zdCBuZXR3b3JrID0gQ0hBSU5fSURfVE9fTkVUV09SS19JRF9NQVBbY2hhaW5JZF07XG4gICAgICBpZiAoRW5zLmdldE5ldHdvcmtFbnNTdXBwb3J0KG5ldHdvcmspKSB7XG4gICAgICAgIHRoaXMuX2VucyA9IG5ldyBFbnMoe1xuICAgICAgICAgIG5ldHdvcmssXG4gICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2VucztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldmVyc2VSZXNvbHZlQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VSZXNvbHZlQWRkcmVzcyh0b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKSk7XG4gIH1cblxuICBhc3luYyBfcmV2ZXJzZVJlc29sdmVBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBpZiAoIXRoaXMuX2Vucykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUuZW5zUmVzb2x1dGlvbnNCeUFkZHJlc3NbYWRkcmVzc10pIHtcbiAgICAgIHJldHVybiBzdGF0ZS5lbnNSZXNvbHV0aW9uc0J5QWRkcmVzc1thZGRyZXNzXTtcbiAgICB9XG5cbiAgICBsZXQgZG9tYWluO1xuICAgIHRyeSB7XG4gICAgICBkb21haW4gPSBhd2FpdCB0aGlzLl9lbnMucmV2ZXJzZShhZGRyZXNzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmRlYnVnKGVycm9yKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgbGV0IHJlZ2lzdGVyZWRBZGRyZXNzO1xuICAgIHRyeSB7XG4gICAgICByZWdpc3RlcmVkQWRkcmVzcyA9IGF3YWl0IHRoaXMuX2Vucy5sb29rdXAoZG9tYWluKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmRlYnVnKGVycm9yKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcmVnaXN0ZXJlZEFkZHJlc3MgPT09IFpFUk9fQUREUkVTUyB8fFxuICAgICAgcmVnaXN0ZXJlZEFkZHJlc3MgPT09IFpFUk9fWF9FUlJPUl9BRERSRVNTXG4gICAgKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0b0NoZWNrc3VtSGV4QWRkcmVzcyhyZWdpc3RlcmVkQWRkcmVzcykgIT09IGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlUmVzb2x1dGlvbnNCeUFkZHJlc3MoYWRkcmVzcywgcHVueWNvZGUudG9BU0NJSShkb21haW4pKTtcbiAgICByZXR1cm4gZG9tYWluO1xuICB9XG5cbiAgX3VwZGF0ZVJlc29sdXRpb25zQnlBZGRyZXNzKGFkZHJlc3MsIGRvbWFpbikge1xuICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuc3RvcmUucHV0U3RhdGUoe1xuICAgICAgZW5zUmVzb2x1dGlvbnNCeUFkZHJlc3M6IHtcbiAgICAgICAgLi4ub2xkU3RhdGUuZW5zUmVzb2x1dGlvbnNCeUFkZHJlc3MsXG4gICAgICAgIFthZGRyZXNzXTogZG9tYWluLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdzYWZlLWV2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVN0b3JlIH0gZnJvbSAnQG1ldGFtYXNrL29icy1zdG9yZSc7XG5pbXBvcnQgeyBidWZmZXJUb0hleCwga2VjY2FrLCB0b0J1ZmZlciwgaXNIZXhTdHJpbmcgfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuaW1wb3J0IEV0aFF1ZXJ5IGZyb20gJ2V0aGpzLXF1ZXJ5JztcbmltcG9ydCB7IGV0aEVycm9ycyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcbmltcG9ydCBhYmkgZnJvbSAnaHVtYW4tc3RhbmRhcmQtdG9rZW4tYWJpJztcbmltcG9ydCBDb21tb24gZnJvbSAnQGV0aGVyZXVtanMvY29tbW9uJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uRmFjdG9yeSB9IGZyb20gJ0BldGhlcmV1bWpzL3R4JztcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgTm9uY2VUcmFja2VyIGZyb20gJ25vbmNlLXRyYWNrZXInO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgY2xlYW5FcnJvclN0YWNrIGZyb20gJy4uLy4uL2xpYi9jbGVhbkVycm9yU3RhY2snO1xuaW1wb3J0IHtcbiAgaGV4VG9CbixcbiAgYm5Ub0hleCxcbiAgQm5NdWx0aXBseUJ5RnJhY3Rpb24sXG4gIGFkZEhleFByZWZpeCxcbiAgZ2V0Q2hhaW5UeXBlLFxufSBmcm9tICcuLi8uLi9saWIvdXRpbCc7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9OT19DT05UUkFDVF9FUlJPUl9LRVkgfSBmcm9tICcuLi8uLi8uLi8uLi91aS9oZWxwZXJzL2NvbnN0YW50cy9lcnJvci1rZXlzJztcbmltcG9ydCB7IGdldFN3YXBzVG9rZW5zUmVjZWl2ZWRGcm9tVHhNZXRhIH0gZnJvbSAnLi4vLi4vLi4vLi4vdWkvcGFnZXMvc3dhcHMvc3dhcHMudXRpbCc7XG5pbXBvcnQgeyBoZXhXRUlUb0RlY0dXRUkgfSBmcm9tICcuLi8uLi8uLi8uLi91aS9oZWxwZXJzL3V0aWxzL2NvbnZlcnNpb25zLnV0aWwnO1xuaW1wb3J0IHtcbiAgVFJBTlNBQ1RJT05fU1RBVFVTRVMsXG4gIFRSQU5TQUNUSU9OX1RZUEVTLFxuICBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUyxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFX05BTUVTIH0gZnJvbSAnLi4vLi4vLi4vLi4vdWkvaGVscGVycy9jb25zdGFudHMvdHJhbnNhY3Rpb25zJztcbmltcG9ydCB7IE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTIH0gZnJvbSAnLi4vLi4vbWV0YW1hc2stY29udHJvbGxlcic7XG5pbXBvcnQge1xuICBHQVNfTElNSVRTLFxuICBHQVNfRVNUSU1BVEVfVFlQRVMsXG4gIEdBU19SRUNPTU1FTkRBVElPTlMsXG4gIENVU1RPTV9HQVNfRVNUSU1BVEUsXG4gIFBSSU9SSVRZX0xFVkVMUyxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9nYXMnO1xuaW1wb3J0IHsgZGVjR1dFSVRvSGV4V0VJIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5pbXBvcnQge1xuICBIQVJERk9SS1MsXG4gIE1BSU5ORVQsXG4gIE5FVFdPUktfVFlQRV9SUEMsXG4gIENIQUlOX0lEX1RPX0dBU19MSU1JVF9CVUZGRVJfTUFQLFxufSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuaW1wb3J0IHsgaXNFSVAxNTU5VHJhbnNhY3Rpb24gfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy90cmFuc2FjdGlvbi51dGlscyc7XG5pbXBvcnQgeyByZWFkQWRkcmVzc0FzQ29udHJhY3QgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9jb250cmFjdC11dGlscyc7XG5pbXBvcnQgVHJhbnNhY3Rpb25TdGF0ZU1hbmFnZXIgZnJvbSAnLi90eC1zdGF0ZS1tYW5hZ2VyJztcbmltcG9ydCBUeEdhc1V0aWwgZnJvbSAnLi90eC1nYXMtdXRpbHMnO1xuaW1wb3J0IFBlbmRpbmdUcmFuc2FjdGlvblRyYWNrZXIgZnJvbSAnLi9wZW5kaW5nLXR4LXRyYWNrZXInO1xuaW1wb3J0ICogYXMgdHhVdGlscyBmcm9tICcuL2xpYi91dGlsJztcblxuY29uc3QgaHN0SW50ZXJmYWNlID0gbmV3IGV0aGVycy51dGlscy5JbnRlcmZhY2UoYWJpKTtcblxuY29uc3QgTUFYX01FTVNUT1JFX1RYX0xJU1RfU0laRSA9IDEwMDsgLy8gTnVtYmVyIG9mIHRyYW5zYWN0aW9ucyAoYnkgdW5pcXVlIG5vbmNlcykgdG8ga2VlcCBpbiBtZW1vcnlcblxuZXhwb3J0IGNvbnN0IFRSQU5TQUNUSU9OX0VWRU5UUyA9IHtcbiAgQURERUQ6ICdUcmFuc2FjdGlvbiBBZGRlZCcsXG4gIEFQUFJPVkVEOiAnVHJhbnNhY3Rpb24gQXBwcm92ZWQnLFxuICBGSU5BTElaRUQ6ICdUcmFuc2FjdGlvbiBGaW5hbGl6ZWQnLFxuICBSRUpFQ1RFRDogJ1RyYW5zYWN0aW9uIFJlamVjdGVkJyxcbiAgU1VCTUlUVEVEOiAnVHJhbnNhY3Rpb24gU3VibWl0dGVkJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ3VzdG9tR2FzU2V0dGluZ3NcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ2FzXSAtIFRoZSBnYXMgbGltaXQgdG8gdXNlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ2FzUHJpY2VdIC0gVGhlIGdhc1ByaWNlIHRvIHVzZSBmb3IgYSBsZWdhY3kgdHJhbnNhY3Rpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbWF4RmVlUGVyR2FzXSAtIFRoZSBtYXhpbXVtIGFtb3VudCB0byBwYXkgcGVyIGdhcyBvbiBhXG4gKiAgRUlQLTE1NTkgdHJhbnNhY3Rpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbWF4UHJpb3JpdHlGZWVQZXJHYXNdIC0gVGhlIG1heGltdW0gYW1vdW50IG9mIHBhaWQgZmVlXG4gKiAgdG8gYmUgZGlzdHJpYnV0ZWQgdG8gbWluZXIgaW4gYW4gRUlQLTE1NTkgdHJhbnNhY3Rpb25cbiAqL1xuXG4vKipcbiAgVHJhbnNhY3Rpb24gQ29udHJvbGxlciBpcyBhbiBhZ2dyZWdhdGUgb2Ygc3ViLWNvbnRyb2xsZXJzIGFuZCB0cmFja2Vyc1xuICBjb21wb3NpbmcgdGhlbSBpbiBhIHdheSB0byBiZSBleHBvc2VkIHRvIHRoZSBtZXRhbWFzayBjb250cm9sbGVyXG4gICAgPGJyPi0gdHhTdGF0ZU1hbmFnZXJcbiAgICAgIHJlc3BvbnNpYmxlIGZvciB0aGUgc3RhdGUgb2YgYSB0cmFuc2FjdGlvbiBhbmRcbiAgICAgIHN0b3JpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAgPGJyPi0gcGVuZGluZ1R4VHJhY2tlclxuICAgICAgd2F0Y2hpbmcgYmxvY2tzIGZvciB0cmFuc2FjdGlvbnMgdG8gYmUgaW5jbHVkZVxuICAgICAgYW5kIGVtaXR0aW5nIGNvbmZpcm1lZCBldmVudHNcbiAgICA8YnI+LSB0eEdhc1V0aWxcbiAgICAgIGdhcyBjYWxjdWxhdGlvbnMgYW5kIHNhZmV0eSBidWZmZXJpbmdcbiAgICA8YnI+LSBub25jZVRyYWNrZXJcbiAgICAgIGNhbGN1bGF0aW5nIG5vbmNlc1xuXG4gIEBjbGFzc1xuICBAcGFyYW0ge09iamVjdH0gb3B0c1xuICBAcGFyYW0ge09iamVjdH0gb3B0cy5pbml0U3RhdGUgLSBpbml0aWFsIHRyYW5zYWN0aW9uIGxpc3QgZGVmYXVsdCBpcyBhbiBlbXB0eSBhcnJheVxuICBAcGFyYW0ge09iamVjdH0gb3B0cy5uZXR3b3JrU3RvcmUgLSBhbiBvYnNlcnZhYmxlIHN0b3JlIGZvciBuZXR3b3JrIG51bWJlclxuICBAcGFyYW0ge09iamVjdH0gb3B0cy5ibG9ja1RyYWNrZXIgLSBBbiBpbnN0YW5jZSBvZiBldGgtYmxvY2t0cmFja2VyXG4gIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnByb3ZpZGVyIC0gQSBuZXR3b3JrIHByb3ZpZGVyLlxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRzLnNpZ25UcmFuc2FjdGlvbiAtIGZ1bmN0aW9uIHRoZSBzaWducyBhbiBAZXRoZXJldW1qcy90eFxuICBAcGFyYW0ge09iamVjdH0gb3B0cy5nZXRQZXJtaXR0ZWRBY2NvdW50cyAtIGdldCBhY2NvdW50cyB0aGF0IGFuIG9yaWdpbiBoYXMgcGVybWlzc2lvbnMgZm9yXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9wdHMuc2lnblRyYW5zYWN0aW9uIC0gZXRoVHggc2lnbmVyIHRoYXQgcmV0dXJucyBhIHJhd1R4XG4gIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50eEhpc3RvcnlMaW1pdF0gLSBudW1iZXIgKm9wdGlvbmFsKiBmb3IgbGltaXRpbmcgaG93IG1hbnkgdHJhbnNhY3Rpb25zIGFyZSBpbiBzdGF0ZVxuICBAcGFyYW0ge09iamVjdH0gb3B0cy5wcmVmZXJlbmNlc1N0b3JlXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5ldHdvcmtTdG9yZSA9IG9wdHMubmV0d29ya1N0b3JlIHx8IG5ldyBPYnNlcnZhYmxlU3RvcmUoe30pO1xuICAgIHRoaXMuX2dldEN1cnJlbnRDaGFpbklkID0gb3B0cy5nZXRDdXJyZW50Q2hhaW5JZDtcbiAgICB0aGlzLmdldFByb3ZpZGVyQ29uZmlnID0gb3B0cy5nZXRQcm92aWRlckNvbmZpZztcbiAgICB0aGlzLl9nZXRDdXJyZW50TmV0d29ya0VJUDE1NTlDb21wYXRpYmlsaXR5ID1cbiAgICAgIG9wdHMuZ2V0Q3VycmVudE5ldHdvcmtFSVAxNTU5Q29tcGF0aWJpbGl0eTtcbiAgICB0aGlzLl9nZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5ID1cbiAgICAgIG9wdHMuZ2V0Q3VycmVudEFjY291bnRFSVAxNTU5Q29tcGF0aWJpbGl0eTtcbiAgICB0aGlzLnByZWZlcmVuY2VzU3RvcmUgPSBvcHRzLnByZWZlcmVuY2VzU3RvcmUgfHwgbmV3IE9ic2VydmFibGVTdG9yZSh7fSk7XG4gICAgdGhpcy5wcm92aWRlciA9IG9wdHMucHJvdmlkZXI7XG4gICAgdGhpcy5nZXRQZXJtaXR0ZWRBY2NvdW50cyA9IG9wdHMuZ2V0UGVybWl0dGVkQWNjb3VudHM7XG4gICAgdGhpcy5ibG9ja1RyYWNrZXIgPSBvcHRzLmJsb2NrVHJhY2tlcjtcbiAgICB0aGlzLnNpZ25FdGhUeCA9IG9wdHMuc2lnblRyYW5zYWN0aW9uO1xuICAgIHRoaXMuaW5Qcm9jZXNzT2ZTaWduaW5nID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX3RyYWNrTWV0YU1ldHJpY3NFdmVudCA9IG9wdHMudHJhY2tNZXRhTWV0cmljc0V2ZW50O1xuICAgIHRoaXMuX2dldFBhcnRpY2lwYXRlSW5NZXRyaWNzID0gb3B0cy5nZXRQYXJ0aWNpcGF0ZUluTWV0cmljcztcbiAgICB0aGlzLl9nZXRFSVAxNTU5R2FzRmVlRXN0aW1hdGVzID0gb3B0cy5nZXRFSVAxNTU5R2FzRmVlRXN0aW1hdGVzO1xuXG4gICAgdGhpcy5tZW1TdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoe30pO1xuICAgIHRoaXMucXVlcnkgPSBuZXcgRXRoUXVlcnkodGhpcy5wcm92aWRlcik7XG5cbiAgICB0aGlzLnR4R2FzVXRpbCA9IG5ldyBUeEdhc1V0aWwodGhpcy5wcm92aWRlcik7XG4gICAgdGhpcy5fbWFwTWV0aG9kcygpO1xuICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIgPSBuZXcgVHJhbnNhY3Rpb25TdGF0ZU1hbmFnZXIoe1xuICAgICAgaW5pdFN0YXRlOiBvcHRzLmluaXRTdGF0ZSxcbiAgICAgIHR4SGlzdG9yeUxpbWl0OiBvcHRzLnR4SGlzdG9yeUxpbWl0LFxuICAgICAgZ2V0TmV0d29yazogdGhpcy5nZXROZXR3b3JrLmJpbmQodGhpcyksXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogb3B0cy5nZXRDdXJyZW50Q2hhaW5JZCxcbiAgICB9KTtcbiAgICB0aGlzLl9vbkJvb3RDbGVhblVwKCk7XG5cbiAgICB0aGlzLnN0b3JlID0gdGhpcy50eFN0YXRlTWFuYWdlci5zdG9yZTtcbiAgICB0aGlzLm5vbmNlVHJhY2tlciA9IG5ldyBOb25jZVRyYWNrZXIoe1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICBibG9ja1RyYWNrZXI6IHRoaXMuYmxvY2tUcmFja2VyLFxuICAgICAgZ2V0UGVuZGluZ1RyYW5zYWN0aW9uczogdGhpcy50eFN0YXRlTWFuYWdlci5nZXRQZW5kaW5nVHJhbnNhY3Rpb25zLmJpbmQoXG4gICAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIsXG4gICAgICApLFxuICAgICAgZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb25zOiB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdldENvbmZpcm1lZFRyYW5zYWN0aW9ucy5iaW5kKFxuICAgICAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLFxuICAgICAgKSxcbiAgICB9KTtcblxuICAgIHRoaXMucGVuZGluZ1R4VHJhY2tlciA9IG5ldyBQZW5kaW5nVHJhbnNhY3Rpb25UcmFja2VyKHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgbm9uY2VUcmFja2VyOiB0aGlzLm5vbmNlVHJhY2tlcixcbiAgICAgIHB1Ymxpc2hUcmFuc2FjdGlvbjogKHJhd1R4KSA9PiB0aGlzLnF1ZXJ5LnNlbmRSYXdUcmFuc2FjdGlvbihyYXdUeCksXG4gICAgICBnZXRQZW5kaW5nVHJhbnNhY3Rpb25zOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdldFBlbmRpbmdUcmFuc2FjdGlvbnMoKTtcbiAgICAgICAgY29uc3QgYXBwcm92ZWQgPSB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdldEFwcHJvdmVkVHJhbnNhY3Rpb25zKCk7XG4gICAgICAgIHJldHVybiBbLi4ucGVuZGluZywgLi4uYXBwcm92ZWRdO1xuICAgICAgfSxcbiAgICAgIGFwcHJvdmVUcmFuc2FjdGlvbjogdGhpcy5hcHByb3ZlVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgIGdldENvbXBsZXRlZFRyYW5zYWN0aW9uczogdGhpcy50eFN0YXRlTWFuYWdlci5nZXRDb25maXJtZWRUcmFuc2FjdGlvbnMuYmluZChcbiAgICAgICAgdGhpcy50eFN0YXRlTWFuYWdlcixcbiAgICAgICksXG4gICAgfSk7XG5cbiAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLnN0b3JlLnN1YnNjcmliZSgoKSA9PlxuICAgICAgdGhpcy5lbWl0KE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSksXG4gICAgKTtcbiAgICB0aGlzLl9zZXR1cExpc3RlbmVycygpO1xuICAgIC8vIG1lbXN0b3JlIGlzIGNvbXB1dGVkIGZyb20gYSBmZXcgZGlmZmVyZW50IHN0b3Jlc1xuICAgIHRoaXMuX3VwZGF0ZU1lbXN0b3JlKCk7XG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci5zdG9yZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fdXBkYXRlTWVtc3RvcmUoKSk7XG4gICAgdGhpcy5uZXR3b3JrU3RvcmUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuX29uQm9vdENsZWFuVXAoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU1lbXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICAvLyByZXF1ZXN0IHN0YXRlIHVwZGF0ZSB0byBmaW5hbGl6ZSBpbml0aWFsaXphdGlvblxuICAgIHRoaXMuX3VwZGF0ZVBlbmRpbmdUeHNBZnRlckZpcnN0QmxvY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGNoYWluSWQgaW4gdGhlIG5ldHdvcmsgc3RvcmUgYXMgYSBudW1iZXIsIHJldHVybmluZyAwIGlmXG4gICAqIHRoZSBjaGFpbklkIHBhcnNlcyB0byBOYU4uXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1lcmljYWwgY2hhaW5JZC5cbiAgICovXG4gIGdldENoYWluSWQoKSB7XG4gICAgY29uc3QgbmV0d29ya1N0YXRlID0gdGhpcy5uZXR3b3JrU3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBjaGFpbklkID0gdGhpcy5fZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICBjb25zdCBpbnRlZ2VyQ2hhaW5JZCA9IHBhcnNlSW50KGNoYWluSWQsIDE2KTtcbiAgICBpZiAobmV0d29ya1N0YXRlID09PSAnbG9hZGluZycgfHwgTnVtYmVyLmlzTmFOKGludGVnZXJDaGFpbklkKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBpbnRlZ2VyQ2hhaW5JZDtcbiAgfVxuXG4gIGFzeW5jIGdldEVJUDE1NTlDb21wYXRpYmlsaXR5KGZyb21BZGRyZXNzKSB7XG4gICAgY29uc3QgY3VycmVudE5ldHdvcmtJc0NvbXBhdGlibGUgPSBhd2FpdCB0aGlzLl9nZXRDdXJyZW50TmV0d29ya0VJUDE1NTlDb21wYXRpYmlsaXR5KCk7XG4gICAgY29uc3QgZnJvbUFjY291bnRJc0NvbXBhdGlibGUgPSBhd2FpdCB0aGlzLl9nZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5KFxuICAgICAgZnJvbUFkZHJlc3MsXG4gICAgKTtcbiAgICByZXR1cm4gY3VycmVudE5ldHdvcmtJc0NvbXBhdGlibGUgJiYgZnJvbUFjY291bnRJc0NvbXBhdGlibGU7XG4gIH1cblxuICAvKipcbiAgICogQGV0aGVyZXVtanMvdHggdXNlcyBAZXRoZXJldW1qcy9jb21tb24gYXMgYSBjb25maWd1cmF0aW9uIHRvb2wgZm9yXG4gICAqIHNwZWNpZnlpbmcgd2hpY2ggY2hhaW4sIG5ldHdvcmssIGhhcmRmb3JrIGFuZCBFSVBzIHRvIHN1cHBvcnQgZm9yXG4gICAqIGEgdHJhbnNhY3Rpb24uIEJ5IHJlZmVyZW5jaW5nIHRoaXMgY29uZmlndXJhdGlvbiwgYW5kIGFuYWx5emluZyB0aGUgZmllbGRzXG4gICAqIHNwZWNpZmllZCBpbiB0eFBhcmFtcywgQGV0aGVyZXVtanMvdHggaXMgYWJsZSB0byBkZXRlcm1pbmUgd2hpY2ggRUlQLTI3MThcbiAgICogdHJhbnNhY3Rpb24gdHlwZSB0byB1c2UuXG4gICAqIEByZXR1cm5zIHtDb21tb259IGNvbW1vbiBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgYXN5bmMgZ2V0Q29tbW9uQ29uZmlndXJhdGlvbihmcm9tQWRkcmVzcykge1xuICAgIGNvbnN0IHsgdHlwZSwgbmlja25hbWU6IG5hbWUgfSA9IHRoaXMuZ2V0UHJvdmlkZXJDb25maWcoKTtcbiAgICBjb25zdCBzdXBwb3J0c0VJUDE1NTkgPSBhd2FpdCB0aGlzLmdldEVJUDE1NTlDb21wYXRpYmlsaXR5KGZyb21BZGRyZXNzKTtcblxuICAgIC8vIFRoaXMgbG9naWMgYmVsb3cgd2lsbCBoYXZlIHRvIGJlIHVwZGF0ZWQgZWFjaCB0aW1lIGEgaGFyZGZvcmsgaGFwcGVuc1xuICAgIC8vIHRoYXQgY2FycmllcyB3aXRoIGl0IGEgbmV3IFRyYW5zYWN0aW9uIHR5cGUuIEl0IGlzIGluY29uc2VxdWVudGlhbCBmb3JcbiAgICAvLyBoYXJkZm9ya3MgdGhhdCBkbyBub3QgaW5jbHVkZSBuZXcgdHlwZXMuXG4gICAgY29uc3QgaGFyZGZvcmsgPSBzdXBwb3J0c0VJUDE1NTkgPyBIQVJERk9SS1MuTE9ORE9OIDogSEFSREZPUktTLkJFUkxJTjtcblxuICAgIC8vIHR5cGUgd2lsbCBiZSBvbmUgb2Ygb3VyIGRlZmF1bHQgbmV0d29yayBuYW1lcyBvciAncnBjJy4gdGhlIGRlZmF1bHRcbiAgICAvLyBuZXR3b3JrIG5hbWVzIGFyZSBzdWZmaWNpZW50IGNvbmZpZ3VyYXRpb24sIHNpbXBseSBwYXNzIHRoZSBuYW1lIGFzIHRoZVxuICAgIC8vIGNoYWluIGFyZ3VtZW50IGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICBpZiAodHlwZSAhPT0gTkVUV09SS19UWVBFX1JQQykge1xuICAgICAgcmV0dXJuIG5ldyBDb21tb24oe1xuICAgICAgICBjaGFpbjogdHlwZSxcbiAgICAgICAgaGFyZGZvcmssXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGb3IgJ3JwYycgd2UgbmVlZCB0byB1c2UgdGhlIHNhbWUgYmFzaWMgY29uZmlndXJhdGlvbiBhcyBtYWlubmV0LFxuICAgIC8vIHNpbmNlIHdlIG9ubHkgc3VwcG9ydCBFVk0gY29tcGF0aWJsZSBjaGFpbnMsIGFuZCB0aGVuIG92ZXJyaWRlIHRoZVxuICAgIC8vIG5hbWUsIGNoYWluSWQgYW5kIG5ldHdvcmtJZCBwcm9wZXJ0aWVzLiBUaGlzIGlzIGRvbmUgdXNpbmcgdGhlXG4gICAgLy8gYGZvckN1c3RvbUNoYWluYCBzdGF0aWMgbWV0aG9kIG9uIHRoZSBDb21tb24gY2xhc3MuXG4gICAgY29uc3QgY2hhaW5JZCA9IHBhcnNlSW50KHRoaXMuX2dldEN1cnJlbnRDaGFpbklkKCksIDE2KTtcbiAgICBjb25zdCBuZXR3b3JrSWQgPSB0aGlzLm5ldHdvcmtTdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgY29uc3QgY3VzdG9tQ2hhaW5QYXJhbXMgPSB7XG4gICAgICBuYW1lLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIC8vIEl0IGlzIGltcHJvYmFibGUgZm9yIGEgdHJhbnNhY3Rpb24gdG8gYmUgc2lnbmVkIHdoaWxlIHRoZSBuZXR3b3JrXG4gICAgICAvLyBpcyBsb2FkaW5nIGZvciB0d28gcmVhc29ucy5cbiAgICAgIC8vIDEuIFBlbmRpbmcsIHVuY29uZmlybWVkIHRyYW5zYWN0aW9ucyBhcmUgd2lwZWQgb24gbmV0d29yayBjaGFuZ2VcbiAgICAgIC8vIDIuIFRoZSBVSSBpcyB1bnVzYWJsZSAobG9hZGluZyBpbmRpY2F0b3IpIHdoZW4gbmV0d29yayBpcyBsb2FkaW5nLlxuICAgICAgLy8gc2V0dGluZyB0aGUgbmV0d29ya0lkIHRvIDAgaXMgZm9yIHR5cGUgc2FmZXR5IGFuZCB0byBleHBsaWNpdHkgbGVhZFxuICAgICAgLy8gdGhlIHRyYW5zYWN0aW9uIHRvIGZhaWxpbmcgaWYgYSB1c2VyIGlzIGFibGUgdG8gZ2V0IHRvIHRoaXMgYnJhbmNoXG4gICAgICAvLyBvbiBhIGN1c3RvbSBuZXR3b3JrIHRoYXQgcmVxdWlyZXMgdmFsaWQgbmV0d29yayBpZC4gSSBoYXZlIG5vdCByYW5cbiAgICAgIC8vIGludG8gdGhpcyBsaW1pdGF0aW9uIG9uIGFueSBuZXR3b3JrIEkgaGF2ZSBhdHRlbXB0ZWQsIGV2ZW4gd2hlblxuICAgICAgLy8gaGFyZGNvZGluZyBuZXR3b3JrSWQgdG8gJ2xvYWRpbmcnLlxuICAgICAgbmV0d29ya0lkOiBuZXR3b3JrSWQgPT09ICdsb2FkaW5nJyA/IDAgOiBwYXJzZUludChuZXR3b3JrSWQsIDEwKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbW1vbi5mb3JDdXN0b21DaGFpbihNQUlOTkVULCBjdXN0b21DaGFpblBhcmFtcywgaGFyZGZvcmspO1xuICB9XG5cbiAgLyoqXG4gIEFkZHMgYSB0eCB0byB0aGUgdHhsaXN0XG4gIEBlbWl0cyAke3R4TWV0YS5pZH06dW5hcHByb3ZlZFxuICAqL1xuICBhZGRUcmFuc2FjdGlvbih0eE1ldGEpIHtcbiAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLmFkZFRyYW5zYWN0aW9uKHR4TWV0YSk7XG4gICAgdGhpcy5lbWl0KGAke3R4TWV0YS5pZH06dW5hcHByb3ZlZGAsIHR4TWV0YSk7XG4gICAgdGhpcy5fdHJhY2tUcmFuc2FjdGlvbk1ldHJpY3NFdmVudCh0eE1ldGEsIFRSQU5TQUNUSU9OX0VWRU5UUy5BRERFRCk7XG4gIH1cblxuICAvKipcbiAgV2lwZXMgdGhlIHRyYW5zYWN0aW9ucyBmb3IgYSBnaXZlbiBhY2NvdW50XG4gIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gaGV4IHN0cmluZyBvZiB0aGUgZnJvbSBhZGRyZXNzIGZvciB0eHMgYmVpbmcgcmVtb3ZlZFxuICAqL1xuICB3aXBlVHJhbnNhY3Rpb25zKGFkZHJlc3MpIHtcbiAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLndpcGVUcmFuc2FjdGlvbnMoYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IHVuYXBwcm92ZWQgdHJhbnNhY3Rpb24gdG8gdGhlIHBpcGVsaW5lXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IHRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBhZnRlciBiZWluZyBzdWJtaXR0ZWQgdG8gdGhlIG5ldHdvcmtcbiAgICogQHBhcmFtIHtPYmplY3R9IHR4UGFyYW1zIC0gdHhQYXJhbXMgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIHdpdGggdGhlIGtleSBvcmlnaW4gdG8gcHV0IHRoZSBvcmlnaW4gb24gdGhlIHR4TWV0YVxuICAgKi9cbiAgYXN5bmMgbmV3VW5hcHByb3ZlZFRyYW5zYWN0aW9uKHR4UGFyYW1zLCBvcHRzID0ge30pIHtcbiAgICBsb2cuZGVidWcoXG4gICAgICBgTWV0YU1hc2tDb250cm9sbGVyIG5ld1VuYXBwcm92ZWRUcmFuc2FjdGlvbiAke0pTT04uc3RyaW5naWZ5KHR4UGFyYW1zKX1gLFxuICAgICk7XG5cbiAgICBjb25zdCBpbml0aWFsVHhNZXRhID0gYXdhaXQgdGhpcy5hZGRVbmFwcHJvdmVkVHJhbnNhY3Rpb24oXG4gICAgICB0eFBhcmFtcyxcbiAgICAgIG9wdHMub3JpZ2luLFxuICAgICk7XG5cbiAgICAvLyBsaXN0ZW4gZm9yIHR4IGNvbXBsZXRpb24gKHN1Y2Nlc3MsIGZhaWwpXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIub25jZShcbiAgICAgICAgYCR7aW5pdGlhbFR4TWV0YS5pZH06ZmluaXNoZWRgLFxuICAgICAgICAoZmluaXNoZWRUeE1ldGEpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkVHhNZXRhLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBUUkFOU0FDVElPTl9TVEFUVVNFUy5TVUJNSVRURUQ6XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZpbmlzaGVkVHhNZXRhLmhhc2gpO1xuICAgICAgICAgICAgY2FzZSBUUkFOU0FDVElPTl9TVEFUVVNFUy5SRUpFQ1RFRDpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgICBjbGVhbkVycm9yU3RhY2soXG4gICAgICAgICAgICAgICAgICBldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdChcbiAgICAgICAgICAgICAgICAgICAgJ01ldGFNYXNrIFR4IFNpZ25hdHVyZTogVXNlciBkZW5pZWQgdHJhbnNhY3Rpb24gc2lnbmF0dXJlLicsXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFRSQU5TQUNUSU9OX1NUQVRVU0VTLkZBSUxFRDpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgICBjbGVhbkVycm9yU3RhY2soXG4gICAgICAgICAgICAgICAgICBldGhFcnJvcnMucnBjLmludGVybmFsKGZpbmlzaGVkVHhNZXRhLmVyci5tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgICBjbGVhbkVycm9yU3RhY2soXG4gICAgICAgICAgICAgICAgICBldGhFcnJvcnMucnBjLmludGVybmFsKFxuICAgICAgICAgICAgICAgICAgICBgTWV0YU1hc2sgVHggU2lnbmF0dXJlOiBVbmtub3duIHByb2JsZW06ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRUeE1ldGEudHhQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhbmQgZ2VuZXJhdGVzIGEgdHhNZXRhIHdpdGggZGVmYXVsdHMgYW5kIHB1dHMgaXQgaW4gdHhTdGF0ZU1hbmFnZXJcbiAgICogc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHt0eE1ldGF9XG4gICAqL1xuICBhc3luYyBhZGRVbmFwcHJvdmVkVHJhbnNhY3Rpb24odHhQYXJhbXMsIG9yaWdpbikge1xuICAgIC8vIHZhbGlkYXRlXG4gICAgY29uc3Qgbm9ybWFsaXplZFR4UGFyYW1zID0gdHhVdGlscy5ub3JtYWxpemVUeFBhcmFtcyh0eFBhcmFtcyk7XG4gICAgY29uc3QgZWlwMTU1OUNvbXBhdGliaWxpdHkgPSBhd2FpdCB0aGlzLmdldEVJUDE1NTlDb21wYXRpYmlsaXR5KCk7XG5cbiAgICB0eFV0aWxzLnZhbGlkYXRlVHhQYXJhbXMobm9ybWFsaXplZFR4UGFyYW1zLCBlaXAxNTU5Q29tcGF0aWJpbGl0eSk7XG5cbiAgICAvKipcbiAgICBgZ2VuZXJhdGVUeE1ldGFgIGFkZHMgdGhlIGRlZmF1bHQgdHhNZXRhIHByb3BlcnRpZXMgdG8gdGhlIHBhc3NlZCBvYmplY3QuXG4gICAgVGhlc2UgaW5jbHVkZSB0aGUgdHgncyBgaWRgLiBBcyB3ZSB1c2UgdGhlIGlkIGZvciBkZXRlcm1pbmluZyBvcmRlciBvZlxuICAgIHR4ZXMgaW4gdGhlIHR4LXN0YXRlLW1hbmFnZXIsIGl0IGlzIG5lY2Vzc2FyeSB0byBjYWxsIHRoZSBhc3luY2hyb25vdXNcbiAgICBtZXRob2QgYHRoaXMuX2RldGVybWluZVRyYW5zYWN0aW9uVHlwZWAgYWZ0ZXIgYGdlbmVyYXRlVHhNZXRhYC5cbiAgICAqL1xuICAgIGxldCB0eE1ldGEgPSB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdlbmVyYXRlVHhNZXRhKHtcbiAgICAgIHR4UGFyYW1zOiBub3JtYWxpemVkVHhQYXJhbXMsXG4gICAgICBvcmlnaW4sXG4gICAgfSk7XG5cbiAgICBpZiAob3JpZ2luID09PSAnbWV0YW1hc2snKSB7XG4gICAgICAvLyBBc3NlcnQgdGhlIGZyb20gYWRkcmVzcyBpcyB0aGUgc2VsZWN0ZWQgYWRkcmVzc1xuICAgICAgaWYgKG5vcm1hbGl6ZWRUeFBhcmFtcy5mcm9tICE9PSB0aGlzLmdldFNlbGVjdGVkQWRkcmVzcygpKSB7XG4gICAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW50ZXJuYWwoe1xuICAgICAgICAgIG1lc3NhZ2U6IGBJbnRlcm5hbGx5IGluaXRpYXRlZCB0cmFuc2FjdGlvbiBpcyB1c2luZyBpbnZhbGlkIGFjY291bnQuYCxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBmcm9tQWRkcmVzczogbm9ybWFsaXplZFR4UGFyYW1zLmZyb20sXG4gICAgICAgICAgICBzZWxlY3RlZEFkZHJlc3M6IHRoaXMuZ2V0U2VsZWN0ZWRBZGRyZXNzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFzc2VydCB0aGF0IHRoZSBvcmlnaW4gaGFzIHBlcm1pc3Npb25zIHRvIGluaXRpYXRlIHRyYW5zYWN0aW9ucyBmcm9tXG4gICAgICAvLyB0aGUgc3BlY2lmaWVkIGFkZHJlc3NcbiAgICAgIGNvbnN0IHBlcm1pdHRlZEFkZHJlc3NlcyA9IGF3YWl0IHRoaXMuZ2V0UGVybWl0dGVkQWNjb3VudHMob3JpZ2luKTtcbiAgICAgIGlmICghcGVybWl0dGVkQWRkcmVzc2VzLmluY2x1ZGVzKG5vcm1hbGl6ZWRUeFBhcmFtcy5mcm9tKSkge1xuICAgICAgICB0aHJvdyBldGhFcnJvcnMucHJvdmlkZXIudW5hdXRob3JpemVkKHsgZGF0YTogeyBvcmlnaW4gfSB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IHR5cGUsIGdldENvZGVSZXNwb25zZSB9ID0gYXdhaXQgdGhpcy5fZGV0ZXJtaW5lVHJhbnNhY3Rpb25UeXBlKFxuICAgICAgdHhQYXJhbXMsXG4gICAgKTtcbiAgICB0eE1ldGEudHlwZSA9IHR5cGU7XG5cbiAgICAvLyBlbnN1cmUgdmFsdWVcbiAgICB0eE1ldGEudHhQYXJhbXMudmFsdWUgPSB0eE1ldGEudHhQYXJhbXMudmFsdWVcbiAgICAgID8gYWRkSGV4UHJlZml4KHR4TWV0YS50eFBhcmFtcy52YWx1ZSlcbiAgICAgIDogJzB4MCc7XG5cbiAgICB0aGlzLmFkZFRyYW5zYWN0aW9uKHR4TWV0YSk7XG4gICAgdGhpcy5lbWl0KCduZXdVbmFwcHJvdmVkVHgnLCB0eE1ldGEpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHR4TWV0YSA9IGF3YWl0IHRoaXMuYWRkVHhHYXNEZWZhdWx0cyh0eE1ldGEsIGdldENvZGVSZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy53YXJuKGVycm9yKTtcbiAgICAgIHR4TWV0YSA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24odHhNZXRhLmlkKTtcbiAgICAgIHR4TWV0YS5sb2FkaW5nRGVmYXVsdHMgPSBmYWxzZTtcbiAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIudXBkYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgIHR4TWV0YSxcbiAgICAgICAgJ0ZhaWxlZCB0byBjYWxjdWxhdGUgZ2FzIGRlZmF1bHRzLicsXG4gICAgICApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgdHhNZXRhLmxvYWRpbmdEZWZhdWx0cyA9IGZhbHNlO1xuICAgIC8vIHNhdmUgdHhNZXRhXG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgIHR4TWV0YSxcbiAgICAgICdBZGRlZCBuZXcgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbi4nLFxuICAgICk7XG5cbiAgICByZXR1cm4gdHhNZXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIHR4IGdhcyBkZWZhdWx0czogZ2FzICYmIGdhc1ByaWNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eE1ldGEgLSB0aGUgdHhNZXRhIG9iamVjdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSByZXNvbHZlcyB3aXRoIHR4TWV0YVxuICAgKi9cbiAgYXN5bmMgYWRkVHhHYXNEZWZhdWx0cyh0eE1ldGEsIGdldENvZGVSZXNwb25zZSkge1xuICAgIGNvbnN0IGVpcDE1NTlDb21wYXRpYmlsaXR5ID1cbiAgICAgIHR4TWV0YS50eFBhcmFtcy50eXBlICE9PSBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5MRUdBQ1kgJiZcbiAgICAgIChhd2FpdCB0aGlzLmdldEVJUDE1NTlDb21wYXRpYmlsaXR5KCkpO1xuICAgIGNvbnN0IHtcbiAgICAgIGdhc1ByaWNlOiBkZWZhdWx0R2FzUHJpY2UsXG4gICAgICBtYXhGZWVQZXJHYXM6IGRlZmF1bHRNYXhGZWVQZXJHYXMsXG4gICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogZGVmYXVsdE1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgIH0gPSBhd2FpdCB0aGlzLl9nZXREZWZhdWx0R2FzRmVlcyh0eE1ldGEsIGVpcDE1NTlDb21wYXRpYmlsaXR5KTtcbiAgICBjb25zdCB7XG4gICAgICBnYXNMaW1pdDogZGVmYXVsdEdhc0xpbWl0LFxuICAgICAgc2ltdWxhdGlvbkZhaWxzLFxuICAgIH0gPSBhd2FpdCB0aGlzLl9nZXREZWZhdWx0R2FzTGltaXQodHhNZXRhLCBnZXRDb2RlUmVzcG9uc2UpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbih0eE1ldGEuaWQpO1xuICAgIGlmIChzaW11bGF0aW9uRmFpbHMpIHtcbiAgICAgIHR4TWV0YS5zaW11bGF0aW9uRmFpbHMgPSBzaW11bGF0aW9uRmFpbHM7XG4gICAgfVxuXG4gICAgaWYgKGVpcDE1NTlDb21wYXRpYmlsaXR5KSB7XG4gICAgICAvLyBJZiB0aGUgZGFwcCBoYXMgc3VnZ2VzdGVkIGEgZ2FzIHByaWNlLCBidXQgbm8gbWF4RmVlUGVyR2FzIG9yIG1heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgICAvLyAgdGhlbiB3ZSBzZXQgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhcyB0byB0aGUgc3VnZ2VzdGVkIGdhc1ByaWNlLlxuICAgICAgaWYgKFxuICAgICAgICB0eE1ldGEudHhQYXJhbXMuZ2FzUHJpY2UgJiZcbiAgICAgICAgIXR4TWV0YS50eFBhcmFtcy5tYXhGZWVQZXJHYXMgJiZcbiAgICAgICAgIXR4TWV0YS50eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhc1xuICAgICAgKSB7XG4gICAgICAgIHR4TWV0YS50eFBhcmFtcy5tYXhGZWVQZXJHYXMgPSB0eE1ldGEudHhQYXJhbXMuZ2FzUHJpY2U7XG4gICAgICAgIHR4TWV0YS50eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4TWV0YS50eFBhcmFtcy5nYXNQcmljZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LkVJUF8xNTU5X1YyKSB7XG4gICAgICAgICAgdHhNZXRhLnVzZXJGZWVMZXZlbCA9IFBSSU9SSVRZX0xFVkVMUy5EQVBQX1NVR0dFU1RFRDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eE1ldGEudXNlckZlZUxldmVsID0gQ1VTVE9NX0dBU19FU1RJTUFURTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChkZWZhdWx0TWF4RmVlUGVyR2FzICYmXG4gICAgICAgICAgICBkZWZhdWx0TWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcbiAgICAgICAgICAgICF0eE1ldGEudHhQYXJhbXMubWF4RmVlUGVyR2FzICYmXG4gICAgICAgICAgICAhdHhNZXRhLnR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzKSB8fFxuICAgICAgICAgIHR4TWV0YS5vcmlnaW4gPT09ICdtZXRhbWFzaydcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHhNZXRhLnVzZXJGZWVMZXZlbCA9IEdBU19SRUNPTU1FTkRBVElPTlMuTUVESVVNO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52LkVJUF8xNTU5X1YyKSB7XG4gICAgICAgICAgdHhNZXRhLnVzZXJGZWVMZXZlbCA9IFBSSU9SSVRZX0xFVkVMUy5EQVBQX1NVR0dFU1RFRDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eE1ldGEudXNlckZlZUxldmVsID0gQ1VTVE9NX0dBU19FU1RJTUFURTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZhdWx0TWF4RmVlUGVyR2FzICYmICF0eE1ldGEudHhQYXJhbXMubWF4RmVlUGVyR2FzKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRhcHAgaGFzIG5vdCBzZXQgdGhlIGdhc1ByaWNlIG9yIHRoZSBtYXhGZWVQZXJHYXMsIHRoZW4gd2Ugc2V0IG1heEZlZVBlckdhc1xuICAgICAgICAgIC8vIHdpdGggdGhlIG9uZSByZXR1cm5lZCBieSB0aGUgZ2FzRmVlQ29udHJvbGxlciwgaWYgdGhhdCBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgdHhNZXRhLnR4UGFyYW1zLm1heEZlZVBlckdhcyA9IGRlZmF1bHRNYXhGZWVQZXJHYXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgZGVmYXVsdE1heFByaW9yaXR5RmVlUGVyR2FzICYmXG4gICAgICAgICAgIXR4TWV0YS50eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhc1xuICAgICAgICApIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGFwcCBoYXMgbm90IHNldCB0aGUgZ2FzUHJpY2Ugb3IgdGhlIG1heFByaW9yaXR5RmVlUGVyR2FzLCB0aGVuIHdlIHNldCBtYXhQcmlvcml0eUZlZVBlckdhc1xuICAgICAgICAgIC8vIHdpdGggdGhlIG9uZSByZXR1cm5lZCBieSB0aGUgZ2FzRmVlQ29udHJvbGxlciwgaWYgdGhhdCBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgdHhNZXRhLnR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZGVmYXVsdE1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmF1bHRHYXNQcmljZSAmJiAhdHhNZXRhLnR4UGFyYW1zLm1heEZlZVBlckdhcykge1xuICAgICAgICAgIC8vIElmIHRoZSBkYXBwIGhhcyBub3Qgc2V0IHRoZSBnYXNQcmljZSBvciB0aGUgbWF4RmVlUGVyR2FzLCBhbmQgbm8gbWF4RmVlUGVyR2FzIGlzIGF2YWlsYWJsZVxuICAgICAgICAgIC8vIGZyb20gdGhlIGdhc0ZlZUNvbnRyb2xsZXIsIHRoZW4gd2Ugc2V0IG1heEZlZVBlckdhcyB0byB0aGUgZGVmYXVsdEdhc1ByaWNlLCBhc3N1bWluZyBpdCBpc1xuICAgICAgICAgIC8vIGF2YWlsYWJsZS5cbiAgICAgICAgICB0eE1ldGEudHhQYXJhbXMubWF4RmVlUGVyR2FzID0gZGVmYXVsdEdhc1ByaWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR4TWV0YS50eFBhcmFtcy5tYXhGZWVQZXJHYXMgJiZcbiAgICAgICAgICAhdHhNZXRhLnR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIElmIHRoZSBkYXBwIGhhcyBub3Qgc2V0IHRoZSBnYXNQcmljZSBvciB0aGUgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIGFuZCBubyBtYXhQcmlvcml0eUZlZVBlckdhcyBpc1xuICAgICAgICAgIC8vIGF2YWlsYWJsZSBmcm9tIHRoZSBnYXNGZWVDb250cm9sbGVyLCB0aGVuIHdlIHNldCBtYXhQcmlvcml0eUZlZVBlckdhcyB0b1xuICAgICAgICAgIC8vIHR4TWV0YS50eFBhcmFtcy5tYXhGZWVQZXJHYXMsIHdoaWNoIHdpbGwgZWl0aGVyIGJlIHRoZSBnYXNQcmljZSBmcm9tIHRoZSBjb250cm9sbGVyLCB0aGUgbWF4RmVlUGVyR2FzXG4gICAgICAgICAgLy8gc2V0IGJ5IHRoZSBkYXBwLCBvciB0aGUgbWF4RmVlUGVyR2FzIGZyb20gdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAgdHhNZXRhLnR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzID0gdHhNZXRhLnR4UGFyYW1zLm1heEZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBXZSByZW1vdmUgdGhlIGdhc1ByaWNlIHBhcmFtIGVudGlyZWx5IHdoZW4gb24gYW4gZWlwMTU1OSBjb21wYXRpYmxlIG5ldHdvcmtcblxuICAgICAgZGVsZXRlIHR4TWV0YS50eFBhcmFtcy5nYXNQcmljZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgZW5zdXJlIHRoYXQgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhcyBhcmUgbm90IGluIHRoZSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAgICAgIC8vIHdoZW4gbm90IG9uIGEgRUlQMTU1OSBjb21wYXRpYmxlIG5ldHdvcmtcblxuICAgICAgZGVsZXRlIHR4TWV0YS50eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgIGRlbGV0ZSB0eE1ldGEudHhQYXJhbXMubWF4RmVlUGVyR2FzO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgZ290dGVuIHRvIHRoaXMgcG9pbnQsIGFuZCBub25lIG9mIGdhc1ByaWNlLCBtYXhQcmlvcml0eUZlZVBlckdhcyBvciBtYXhGZWVQZXJHYXMgYXJlXG4gICAgLy8gc2V0IG9uIHR4UGFyYW1zLCBpdCBtZWFucyB0aGF0IGVpdGhlciB3ZSBhcmUgb24gYSBub24tRUlQMTU1OSBuZXR3b3JrIGFuZCB0aGUgZGFwcCBkaWRuJ3Qgc3VnZ2VzdFxuICAgIC8vIGEgZ2FzIHByaWNlLCBvciB3ZSBhcmUgb24gYW4gRUlQMTU1OSBuZXR3b3JrLCBhbmQgbm9uZSBvZiBnYXNQcmljZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXMgb3IgbWF4RmVlUGVyR2FzXG4gICAgLy8gd2VyZSBhdmFpbGFibGUgZnJvbSBlaXRoZXIgdGhlIGRhcHAgb3IgdGhlIG5ldHdvcmsuXG4gICAgaWYgKFxuICAgICAgZGVmYXVsdEdhc1ByaWNlICYmXG4gICAgICAhdHhNZXRhLnR4UGFyYW1zLmdhc1ByaWNlICYmXG4gICAgICAhdHhNZXRhLnR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzICYmXG4gICAgICAhdHhNZXRhLnR4UGFyYW1zLm1heEZlZVBlckdhc1xuICAgICkge1xuICAgICAgdHhNZXRhLnR4UGFyYW1zLmdhc1ByaWNlID0gZGVmYXVsdEdhc1ByaWNlO1xuICAgIH1cblxuICAgIGlmIChkZWZhdWx0R2FzTGltaXQgJiYgIXR4TWV0YS50eFBhcmFtcy5nYXMpIHtcbiAgICAgIHR4TWV0YS50eFBhcmFtcy5nYXMgPSBkZWZhdWx0R2FzTGltaXQ7XG4gICAgfVxuICAgIHJldHVybiB0eE1ldGE7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBkZWZhdWx0IGdhcyBmZWVzLCBvciByZXR1cm5zIGB1bmRlZmluZWRgIGlmIGdhcyBmZWVzIGFyZSBhbHJlYWR5IHNldFxuICAgKiBAcGFyYW0ge09iamVjdH0gdHhNZXRhIC0gVGhlIHR4TWV0YSBvYmplY3RcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nfHVuZGVmaW5lZD59IFRoZSBkZWZhdWx0IGdhcyBwcmljZVxuICAgKi9cbiAgYXN5bmMgX2dldERlZmF1bHRHYXNGZWVzKHR4TWV0YSwgZWlwMTU1OUNvbXBhdGliaWxpdHkpIHtcbiAgICBpZiAoXG4gICAgICAoIWVpcDE1NTlDb21wYXRpYmlsaXR5ICYmIHR4TWV0YS50eFBhcmFtcy5nYXNQcmljZSkgfHxcbiAgICAgIChlaXAxNTU5Q29tcGF0aWJpbGl0eSAmJlxuICAgICAgICB0eE1ldGEudHhQYXJhbXMubWF4RmVlUGVyR2FzICYmXG4gICAgICAgIHR4TWV0YS50eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcylcbiAgICApIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBnYXNGZWVFc3RpbWF0ZXMsXG4gICAgICAgIGdhc0VzdGltYXRlVHlwZSxcbiAgICAgIH0gPSBhd2FpdCB0aGlzLl9nZXRFSVAxNTU5R2FzRmVlRXN0aW1hdGVzKCk7XG4gICAgICBpZiAoXG4gICAgICAgIGVpcDE1NTlDb21wYXRpYmlsaXR5ICYmXG4gICAgICAgIGdhc0VzdGltYXRlVHlwZSA9PT0gR0FTX0VTVElNQVRFX1RZUEVTLkZFRV9NQVJLRVRcbiAgICAgICkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbWVkaXVtOiB7IHN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzLCBzdWdnZXN0ZWRNYXhGZWVQZXJHYXMgfSA9IHt9LFxuICAgICAgICB9ID0gZ2FzRmVlRXN0aW1hdGVzO1xuXG4gICAgICAgIGlmIChzdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhcyAmJiBzdWdnZXN0ZWRNYXhGZWVQZXJHYXMpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBkZWNHV0VJVG9IZXhXRUkoc3VnZ2VzdGVkTWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBkZWNHV0VJVG9IZXhXRUkoXG4gICAgICAgICAgICAgIHN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGdhc0VzdGltYXRlVHlwZSA9PT0gR0FTX0VTVElNQVRFX1RZUEVTLkxFR0FDWSkge1xuICAgICAgICAvLyBUaGUgTEVHQUNZIHR5cGUgaW5jbHVkZXMgbG93LCBtZWRpdW0gYW5kIGhpZ2ggZXN0aW1hdGVzIG9mXG4gICAgICAgIC8vIGdhcyBwcmljZSB2YWx1ZXMuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZ2FzUHJpY2U6IGRlY0dXRUlUb0hleFdFSShnYXNGZWVFc3RpbWF0ZXMubWVkaXVtKSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoZ2FzRXN0aW1hdGVUeXBlID09PSBHQVNfRVNUSU1BVEVfVFlQRVMuRVRIX0dBU1BSSUNFKSB7XG4gICAgICAgIC8vIFRoZSBFVEhfR0FTUFJJQ0UgdHlwZSBqdXN0IGluY2x1ZGVzIGEgc2luZ2xlIGdhcyBwcmljZSBwcm9wZXJ0eSxcbiAgICAgICAgLy8gd2hpY2ggd2UgY2FuIGFzc3VtZSB3YXMgcmV0cmlldmVkIGZyb20gZXRoX2dhc1ByaWNlXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZ2FzUHJpY2U6IGRlY0dXRUlUb0hleFdFSShnYXNGZWVFc3RpbWF0ZXMuZ2FzUHJpY2UpLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ2FzUHJpY2UgPSBhd2FpdCB0aGlzLnF1ZXJ5Lmdhc1ByaWNlKCk7XG5cbiAgICByZXR1cm4geyBnYXNQcmljZTogZ2FzUHJpY2UgJiYgYWRkSGV4UHJlZml4KGdhc1ByaWNlLnRvU3RyaW5nKDE2KSkgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGRlZmF1bHQgZ2FzIGxpbWl0LCBvciBkZWJ1ZyBpbmZvcm1hdGlvbiBhYm91dCB3aHkgZ2FzIGVzdGltYXRlIGZhaWxlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHR4TWV0YSAtIFRoZSB0eE1ldGEgb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBnZXRDb2RlUmVzcG9uc2UgLSBUaGUgdHJhbnNhY3Rpb24gY2F0ZWdvcnkgY29kZSByZXNwb25zZSwgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IE9iamVjdCBjb250YWluaW5nIHRoZSBkZWZhdWx0IGdhcyBsaW1pdCwgb3IgdGhlIHNpbXVsYXRpb24gZmFpbHVyZSBvYmplY3RcbiAgICovXG4gIGFzeW5jIF9nZXREZWZhdWx0R2FzTGltaXQodHhNZXRhLCBnZXRDb2RlUmVzcG9uc2UpIHtcbiAgICBjb25zdCBjaGFpbklkID0gdGhpcy5fZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICBjb25zdCBjdXN0b21OZXR3b3JrR2FzQnVmZmVyID0gQ0hBSU5fSURfVE9fR0FTX0xJTUlUX0JVRkZFUl9NQVBbY2hhaW5JZF07XG4gICAgY29uc3QgY2hhaW5UeXBlID0gZ2V0Q2hhaW5UeXBlKGNoYWluSWQpO1xuXG4gICAgaWYgKHR4TWV0YS50eFBhcmFtcy5nYXMpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdHhNZXRhLnR4UGFyYW1zLnRvICYmXG4gICAgICB0eE1ldGEudHlwZSA9PT0gVFJBTlNBQ1RJT05fVFlQRVMuU0lNUExFX1NFTkQgJiZcbiAgICAgIGNoYWluVHlwZSAhPT0gJ2N1c3RvbSdcbiAgICApIHtcbiAgICAgIC8vIGlmIHRoZXJlJ3MgZGF0YSBpbiB0aGUgcGFyYW1zLCBidXQgdGhlcmUncyBubyBjb250cmFjdCBjb2RlLCBpdCdzIG5vdCBhIHZhbGlkIHRyYW5zYWN0aW9uXG4gICAgICBpZiAodHhNZXRhLnR4UGFyYW1zLmRhdGEpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICdUeEdhc1V0aWwgLSBUcnlpbmcgdG8gY2FsbCBhIGZ1bmN0aW9uIG9uIGEgbm9uLWNvbnRyYWN0IGFkZHJlc3MnLFxuICAgICAgICApO1xuICAgICAgICAvLyBzZXQgZXJyb3Iga2V5IHNvIHVpIGNhbiBkaXNwbGF5IGxvY2FsaXplZCBlcnJvciBtZXNzYWdlXG4gICAgICAgIGVyci5lcnJvcktleSA9IFRSQU5TQUNUSU9OX05PX0NPTlRSQUNUX0VSUk9SX0tFWTtcblxuICAgICAgICAvLyBzZXQgdGhlIHJlc3BvbnNlIG9uIHRoZSBlcnJvciBzbyB0aGF0IHdlIGNhbiBzZWUgaW4gbG9ncyB3aGF0IHRoZSBhY3R1YWwgcmVzcG9uc2Ugd2FzXG4gICAgICAgIGVyci5nZXRDb2RlUmVzcG9uc2UgPSBnZXRDb2RlUmVzcG9uc2U7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBpcyBhIHN0YW5kYXJkIGV0aGVyIHNpbXBsZSBzZW5kLCBnYXMgcmVxdWlyZW1lbnQgaXMgZXhhY3RseSAyMWtcbiAgICAgIHJldHVybiB7IGdhc0xpbWl0OiBHQVNfTElNSVRTLlNJTVBMRSB9O1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGJsb2NrR2FzTGltaXQsXG4gICAgICBlc3RpbWF0ZWRHYXNIZXgsXG4gICAgICBzaW11bGF0aW9uRmFpbHMsXG4gICAgfSA9IGF3YWl0IHRoaXMudHhHYXNVdGlsLmFuYWx5emVHYXNVc2FnZSh0eE1ldGEpO1xuXG4gICAgLy8gYWRkIGFkZGl0aW9uYWwgZ2FzIGJ1ZmZlciB0byBvdXIgZXN0aW1hdGlvbiBmb3Igc2FmZXR5XG4gICAgY29uc3QgZ2FzTGltaXQgPSB0aGlzLnR4R2FzVXRpbC5hZGRHYXNCdWZmZXIoXG4gICAgICBhZGRIZXhQcmVmaXgoZXN0aW1hdGVkR2FzSGV4KSxcbiAgICAgIGJsb2NrR2FzTGltaXQsXG4gICAgICBjdXN0b21OZXR3b3JrR2FzQnVmZmVyLFxuICAgICk7XG4gICAgcmV0dXJuIHsgZ2FzTGltaXQsIHNpbXVsYXRpb25GYWlscyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgVHJhbnNhY3Rpb25NZXRhIG9iamVjdCwgZ2VuZXJhdGUgbmV3IGdhcyBwYXJhbXMgc3VjaCB0aGF0IGlmIHRoZVxuICAgKiB0cmFuc2FjdGlvbiB3YXMgYW4gRUlQMTU1OSB0cmFuc2FjdGlvbiwgaXQgb25seSBoYXMgRUlQMTU1OSBnYXMgZmllbGRzLFxuICAgKiBvdGhlcndpc2UgaXQgb25seSBoYXMgZ2FzUHJpY2UuIFdpbGwgdXNlIHdoYXRldmVyIGN1c3RvbSB2YWx1ZXMgYXJlXG4gICAqIHNwZWNpZmllZCBpbiBjdXN0b21HYXNTZXR0aW5ncywgb3IgZmFsbHMgYmFjayB0byBpbmNyZW1lbnRpbmcgYnkgYSBwZXJjZW50XG4gICAqIHdoaWNoIGlzIGRlZmluZWQgYnkgc3BlY2lmeWluZyBhIG51bWVyYXRvci4gMTEgaXMgYSAxMCUgYnVtcCwgMTIgd291bGQgYmVcbiAgICogYSAyMCUgYnVtcCwgYW5kIHNvIG9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcbiAgICogICcuLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJ1xuICAgKiApLlRyYW5zYWN0aW9uTWV0YX0gb3JpZ2luYWxUeE1ldGEgLSBPcmlnaW5hbCB0cmFuc2FjdGlvbiB0byB1c2UgYXMgYmFzZVxuICAgKiBAcGFyYW0ge0N1c3RvbUdhc1NldHRpbmdzfSBbY3VzdG9tR2FzU2V0dGluZ3NdIC0gb3ZlcnJpZGVzIGZvciB0aGUgZ2FzXG4gICAqICBmaWVsZHMgdG8gdXNlIGluc3RlYWQgb2YgdGhlIG11bHRpcGxpZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmNyZW1lbnROdW1lcmF0b3JdIC0gTnVtZXJhdG9yIGZyb20gd2hpY2ggdG8gZ2VuZXJhdGUgYVxuICAgKiAgcGVyY2VudGFnZSBidW1wIG9mIGdhcyBwcmljZS4gRS5nIDExIHdvdWxkIGJlIGEgMTAlIGJ1bXAgb3ZlciBiYXNlLlxuICAgKiBAcmV0dXJucyB7eyBuZXdHYXNQYXJhbXM6IEN1c3RvbUdhc1NldHRpbmdzLCBwcmV2aW91c0dhc1BhcmFtczogQ3VzdG9tR2FzU2V0dGluZ3MgfX1cbiAgICovXG4gIGdlbmVyYXRlTmV3R2FzUGFyYW1zKFxuICAgIG9yaWdpbmFsVHhNZXRhLFxuICAgIGN1c3RvbUdhc1NldHRpbmdzID0ge30sXG4gICAgaW5jcmVtZW50TnVtZXJhdG9yID0gMTEsXG4gICkge1xuICAgIGNvbnN0IHsgdHhQYXJhbXMgfSA9IG9yaWdpbmFsVHhNZXRhO1xuICAgIGNvbnN0IHByZXZpb3VzR2FzUGFyYW1zID0ge307XG4gICAgY29uc3QgbmV3R2FzUGFyYW1zID0ge307XG4gICAgaWYgKGN1c3RvbUdhc1NldHRpbmdzLmdhc0xpbWl0KSB7XG4gICAgICBuZXdHYXNQYXJhbXMuZ2FzID0gY3VzdG9tR2FzU2V0dGluZ3M/LmdhcyA/PyBHQVNfTElNSVRTLlNJTVBMRTtcbiAgICB9XG5cbiAgICBpZiAoY3VzdG9tR2FzU2V0dGluZ3MuZXN0aW1hdGVTdWdnZXN0ZWQpIHtcbiAgICAgIG5ld0dhc1BhcmFtcy5lc3RpbWF0ZVN1Z2dlc3RlZCA9IGN1c3RvbUdhc1NldHRpbmdzLmVzdGltYXRlU3VnZ2VzdGVkO1xuICAgIH1cblxuICAgIGlmIChjdXN0b21HYXNTZXR0aW5ncy5lc3RpbWF0ZVVzZWQpIHtcbiAgICAgIG5ld0dhc1BhcmFtcy5lc3RpbWF0ZVVzZWQgPSBjdXN0b21HYXNTZXR0aW5ncy5lc3RpbWF0ZVVzZWQ7XG4gICAgfVxuXG4gICAgaWYgKGlzRUlQMTU1OVRyYW5zYWN0aW9uKG9yaWdpbmFsVHhNZXRhKSkge1xuICAgICAgcHJldmlvdXNHYXNQYXJhbXMubWF4RmVlUGVyR2FzID0gdHhQYXJhbXMubWF4RmVlUGVyR2FzO1xuICAgICAgcHJldmlvdXNHYXNQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSB0eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgIG5ld0dhc1BhcmFtcy5tYXhGZWVQZXJHYXMgPVxuICAgICAgICBjdXN0b21HYXNTZXR0aW5ncz8ubWF4RmVlUGVyR2FzIHx8XG4gICAgICAgIGJuVG9IZXgoXG4gICAgICAgICAgQm5NdWx0aXBseUJ5RnJhY3Rpb24oXG4gICAgICAgICAgICBoZXhUb0JuKHR4UGFyYW1zLm1heEZlZVBlckdhcyksXG4gICAgICAgICAgICBpbmNyZW1lbnROdW1lcmF0b3IsXG4gICAgICAgICAgICAxMCxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgbmV3R2FzUGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzID1cbiAgICAgICAgY3VzdG9tR2FzU2V0dGluZ3M/Lm1heFByaW9yaXR5RmVlUGVyR2FzIHx8XG4gICAgICAgIGJuVG9IZXgoXG4gICAgICAgICAgQm5NdWx0aXBseUJ5RnJhY3Rpb24oXG4gICAgICAgICAgICBoZXhUb0JuKHR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIGluY3JlbWVudE51bWVyYXRvcixcbiAgICAgICAgICAgIDEwLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZpb3VzR2FzUGFyYW1zLmdhc1ByaWNlID0gdHhQYXJhbXMuZ2FzUHJpY2U7XG4gICAgICBuZXdHYXNQYXJhbXMuZ2FzUHJpY2UgPVxuICAgICAgICBjdXN0b21HYXNTZXR0aW5ncz8uZ2FzUHJpY2UgfHxcbiAgICAgICAgYm5Ub0hleChcbiAgICAgICAgICBCbk11bHRpcGx5QnlGcmFjdGlvbihcbiAgICAgICAgICAgIGhleFRvQm4odHhQYXJhbXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgaW5jcmVtZW50TnVtZXJhdG9yLFxuICAgICAgICAgICAgMTAsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBwcmV2aW91c0dhc1BhcmFtcywgbmV3R2FzUGFyYW1zIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBhcHByb3ZlZCB0cmFuc2FjdGlvbiB0byBhdHRlbXB0IHRvIGNhbmNlbCBhIHByZXZpb3VzbHkgc3VibWl0dGVkIHRyYW5zYWN0aW9uLiBUaGVcbiAgICogbmV3IHRyYW5zYWN0aW9uIGNvbnRhaW5zIHRoZSBzYW1lIG5vbmNlIGFzIHRoZSBwcmV2aW91cywgaXMgYSBiYXNpYyBFVEggdHJhbnNmZXIgb2YgMHggdmFsdWUgdG9cbiAgICogdGhlIHNlbmRlcidzIGFkZHJlc3MsIGFuZCBoYXMgYSBoaWdoZXIgZ2FzUHJpY2UgdGhhbiB0aGF0IG9mIHRoZSBwcmV2aW91cyB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpbmFsVHhJZCAtIHRoZSBpZCBvZiB0aGUgdHhNZXRhIHRoYXQgeW91IHdhbnQgdG8gYXR0ZW1wdCB0byBjYW5jZWxcbiAgICogQHBhcmFtIHtDdXN0b21HYXNTZXR0aW5nc30gW2N1c3RvbUdhc1NldHRpbmdzXSAtIG92ZXJyaWRlcyB0byB1c2UgZm9yIGdhc1xuICAgKiAgcGFyYW1zIGluc3RlYWQgb2YgYWxsb3dpbmcgdGhpcyBtZXRob2QgdG8gZ2VuZXJhdGUgdGhlbVxuICAgKiBAcmV0dXJucyB7dHhNZXRhfVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQ2FuY2VsVHJhbnNhY3Rpb24oXG4gICAgb3JpZ2luYWxUeElkLFxuICAgIGN1c3RvbUdhc1NldHRpbmdzLFxuICAgIHsgZXN0aW1hdGVkQmFzZUZlZSB9ID0ge30sXG4gICkge1xuICAgIGNvbnN0IG9yaWdpbmFsVHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbihvcmlnaW5hbFR4SWQpO1xuICAgIGNvbnN0IHsgdHhQYXJhbXMgfSA9IG9yaWdpbmFsVHhNZXRhO1xuICAgIGNvbnN0IHsgZnJvbSwgbm9uY2UgfSA9IHR4UGFyYW1zO1xuXG4gICAgY29uc3QgeyBwcmV2aW91c0dhc1BhcmFtcywgbmV3R2FzUGFyYW1zIH0gPSB0aGlzLmdlbmVyYXRlTmV3R2FzUGFyYW1zKFxuICAgICAgb3JpZ2luYWxUeE1ldGEsXG4gICAgICB7XG4gICAgICAgIC4uLmN1c3RvbUdhc1NldHRpbmdzLFxuICAgICAgICAvLyBXZSB3YW50IHRvIG92ZXJyaWRlIHRoZSBwcmV2aW91cyB0cmFuc2FjdGlvbnMgZ2FzTGltaXQgYmVjYXVzZSBpdFxuICAgICAgICAvLyB3aWxsIG5vdyBiZSBhIHNpbXBsZSBzZW5kIGluc3RlYWQgb2Ygd2hhdGV2ZXIgaXQgd2FzIGJlZm9yZSBzdWNoXG4gICAgICAgIC8vIGFzIGEgdG9rZW4gdHJhbnNmZXIgb3IgY29udHJhY3QgY2FsbC5cbiAgICAgICAgZ2FzTGltaXQ6IGN1c3RvbUdhc1NldHRpbmdzLmdhc0xpbWl0IHx8IEdBU19MSU1JVFMuU0lNUExFLFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgY29uc3QgbmV3VHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZW5lcmF0ZVR4TWV0YSh7XG4gICAgICB0eFBhcmFtczoge1xuICAgICAgICBmcm9tLFxuICAgICAgICB0bzogZnJvbSxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIHZhbHVlOiAnMHgwJyxcbiAgICAgICAgLi4ubmV3R2FzUGFyYW1zLFxuICAgICAgfSxcbiAgICAgIHByZXZpb3VzR2FzUGFyYW1zLFxuICAgICAgbG9hZGluZ0RlZmF1bHRzOiBmYWxzZSxcbiAgICAgIHN0YXR1czogVFJBTlNBQ1RJT05fU1RBVFVTRVMuQVBQUk9WRUQsXG4gICAgICB0eXBlOiBUUkFOU0FDVElPTl9UWVBFUy5DQU5DRUwsXG4gICAgfSk7XG5cbiAgICBpZiAoZXN0aW1hdGVkQmFzZUZlZSkge1xuICAgICAgbmV3VHhNZXRhLmVzdGltYXRlZEJhc2VGZWUgPSBlc3RpbWF0ZWRCYXNlRmVlO1xuICAgIH1cblxuICAgIHRoaXMuYWRkVHJhbnNhY3Rpb24obmV3VHhNZXRhKTtcbiAgICBhd2FpdCB0aGlzLmFwcHJvdmVUcmFuc2FjdGlvbihuZXdUeE1ldGEuaWQpO1xuICAgIHJldHVybiBuZXdUeE1ldGE7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBhcHByb3ZlZCB0cmFuc2FjdGlvbiB0byBhdHRlbXB0IHRvIHNwZWVkIHVwIGEgcHJldmlvdXNseSBzdWJtaXR0ZWQgdHJhbnNhY3Rpb24uIFRoZVxuICAgKiBuZXcgdHJhbnNhY3Rpb24gY29udGFpbnMgdGhlIHNhbWUgbm9uY2UgYXMgdGhlIHByZXZpb3VzLiBCeSBkZWZhdWx0LCB0aGUgbmV3IHRyYW5zYWN0aW9uIHdpbGwgdXNlXG4gICAqIHRoZSBzYW1lIGdhcyBsaW1pdCBhbmQgYSAxMCUgaGlnaGVyIGdhcyBwcmljZSwgdGhvdWdoIGl0IGlzIHBvc3NpYmxlIHRvIHNldCBhIGN1c3RvbSB2YWx1ZSBmb3JcbiAgICogZWFjaCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luYWxUeElkIC0gdGhlIGlkIG9mIHRoZSB0eE1ldGEgdGhhdCB5b3Ugd2FudCB0byBzcGVlZCB1cFxuICAgKiBAcGFyYW0ge0N1c3RvbUdhc1NldHRpbmdzfSBbY3VzdG9tR2FzU2V0dGluZ3NdIC0gb3ZlcnJpZGVzIHRvIHVzZSBmb3IgZ2FzXG4gICAqICBwYXJhbXMgaW5zdGVhZCBvZiBhbGxvd2luZyB0aGlzIG1ldGhvZCB0byBnZW5lcmF0ZSB0aGVtXG4gICAqIEByZXR1cm5zIHt0eE1ldGF9XG4gICAqL1xuICBhc3luYyBjcmVhdGVTcGVlZFVwVHJhbnNhY3Rpb24oXG4gICAgb3JpZ2luYWxUeElkLFxuICAgIGN1c3RvbUdhc1NldHRpbmdzLFxuICAgIHsgZXN0aW1hdGVkQmFzZUZlZSB9ID0ge30sXG4gICkge1xuICAgIGNvbnN0IG9yaWdpbmFsVHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbihvcmlnaW5hbFR4SWQpO1xuICAgIGNvbnN0IHsgdHhQYXJhbXMgfSA9IG9yaWdpbmFsVHhNZXRhO1xuXG4gICAgY29uc3QgeyBwcmV2aW91c0dhc1BhcmFtcywgbmV3R2FzUGFyYW1zIH0gPSB0aGlzLmdlbmVyYXRlTmV3R2FzUGFyYW1zKFxuICAgICAgb3JpZ2luYWxUeE1ldGEsXG4gICAgICBjdXN0b21HYXNTZXR0aW5ncyxcbiAgICApO1xuXG4gICAgY29uc3QgbmV3VHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZW5lcmF0ZVR4TWV0YSh7XG4gICAgICB0eFBhcmFtczoge1xuICAgICAgICAuLi50eFBhcmFtcyxcbiAgICAgICAgLi4ubmV3R2FzUGFyYW1zLFxuICAgICAgfSxcbiAgICAgIHByZXZpb3VzR2FzUGFyYW1zLFxuICAgICAgbG9hZGluZ0RlZmF1bHRzOiBmYWxzZSxcbiAgICAgIHN0YXR1czogVFJBTlNBQ1RJT05fU1RBVFVTRVMuQVBQUk9WRUQsXG4gICAgICB0eXBlOiBUUkFOU0FDVElPTl9UWVBFUy5SRVRSWSxcbiAgICB9KTtcblxuICAgIGlmIChlc3RpbWF0ZWRCYXNlRmVlKSB7XG4gICAgICBuZXdUeE1ldGEuZXN0aW1hdGVkQmFzZUZlZSA9IGVzdGltYXRlZEJhc2VGZWU7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRUcmFuc2FjdGlvbihuZXdUeE1ldGEpO1xuICAgIGF3YWl0IHRoaXMuYXBwcm92ZVRyYW5zYWN0aW9uKG5ld1R4TWV0YS5pZCk7XG4gICAgcmV0dXJuIG5ld1R4TWV0YTtcbiAgfVxuXG4gIC8qKlxuICB1cGRhdGVzIHRoZSB0eE1ldGEgaW4gdGhlIHR4U3RhdGVNYW5hZ2VyXG4gIEBwYXJhbSB7T2JqZWN0fSB0eE1ldGEgLSB0aGUgdXBkYXRlZCB0eE1ldGFcbiAgKi9cbiAgYXN5bmMgdXBkYXRlVHJhbnNhY3Rpb24odHhNZXRhKSB7XG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgIHR4TWV0YSxcbiAgICAgICdjb25mVHg6IHVzZXIgdXBkYXRlZCB0cmFuc2FjdGlvbicsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICB1cGRhdGVzIGFuZCBhcHByb3ZlcyB0aGUgdHJhbnNhY3Rpb25cbiAgQHBhcmFtIHtPYmplY3R9IHR4TWV0YVxuICAqL1xuICBhc3luYyB1cGRhdGVBbmRBcHByb3ZlVHJhbnNhY3Rpb24odHhNZXRhKSB7XG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgIHR4TWV0YSxcbiAgICAgICdjb25mVHg6IHVzZXIgYXBwcm92ZWQgdHJhbnNhY3Rpb24nLFxuICAgICk7XG4gICAgYXdhaXQgdGhpcy5hcHByb3ZlVHJhbnNhY3Rpb24odHhNZXRhLmlkKTtcbiAgfVxuXG4gIC8qKlxuICBzZXRzIHRoZSB0eCBzdGF0dXMgdG8gYXBwcm92ZWRcbiAgYXV0byBmaWxscyB0aGUgbm9uY2VcbiAgc2lnbnMgdGhlIHRyYW5zYWN0aW9uXG4gIHB1Ymxpc2hlcyB0aGUgdHJhbnNhY3Rpb25cbiAgaWYgYW55IG9mIHRoZXNlIHN0ZXBzIGZhaWxzIHRoZSB0eCBzdGF0dXMgd2lsbCBiZSBzZXQgdG8gZmFpbGVkXG4gICAgQHBhcmFtIHtudW1iZXJ9IHR4SWQgLSB0aGUgdHgncyBJZFxuICAqL1xuICBhc3luYyBhcHByb3ZlVHJhbnNhY3Rpb24odHhJZCkge1xuICAgIC8vIFRPRE86IE1vdmUgdGhpcyBzYWZldHkgb3V0IG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgLy8gU2luY2UgdGhpcyB0cmFuc2FjdGlvbiBpcyBhc3luYyxcbiAgICAvLyB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCBpcyBjdXJyZW50bHkgYmVpbmcgc2lnbmVkLFxuICAgIC8vIFNvIHRoYXQgd2UgZG8gbm90IGluY3JlbWVudCBub25jZSArIHJlc3VibWl0IHNvbWV0aGluZ1xuICAgIC8vIHRoYXQgaXMgYWxyZWFkeSBiZWluZyBpbmNyZW1lbnRlZCAmIHNpZ25lZC5cbiAgICBpZiAodGhpcy5pblByb2Nlc3NPZlNpZ25pbmcuaGFzKHR4SWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaW5Qcm9jZXNzT2ZTaWduaW5nLmFkZCh0eElkKTtcbiAgICBsZXQgbm9uY2VMb2NrO1xuICAgIHRyeSB7XG4gICAgICAvLyBhcHByb3ZlXG4gICAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLnNldFR4U3RhdHVzQXBwcm92ZWQodHhJZCk7XG4gICAgICAvLyBnZXQgbmV4dCBub25jZVxuICAgICAgY29uc3QgdHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbih0eElkKTtcblxuICAgICAgY29uc3QgZnJvbUFkZHJlc3MgPSB0eE1ldGEudHhQYXJhbXMuZnJvbTtcbiAgICAgIC8vIHdhaXQgZm9yIGEgbm9uY2VcbiAgICAgIGxldCB7IGN1c3RvbU5vbmNlVmFsdWUgfSA9IHR4TWV0YTtcbiAgICAgIGN1c3RvbU5vbmNlVmFsdWUgPSBOdW1iZXIoY3VzdG9tTm9uY2VWYWx1ZSk7XG4gICAgICBub25jZUxvY2sgPSBhd2FpdCB0aGlzLm5vbmNlVHJhY2tlci5nZXROb25jZUxvY2soZnJvbUFkZHJlc3MpO1xuICAgICAgLy8gYWRkIG5vbmNlIHRvIHR4UGFyYW1zXG4gICAgICAvLyBpZiB0eE1ldGEgaGFzIHByZXZpb3VzR2FzUGFyYW1zIHRoZW4gaXQgaXMgYSByZXRyeSBhdCBzYW1lIG5vbmNlIHdpdGhcbiAgICAgIC8vIGhpZ2hlciBnYXMgc2V0dGluZ3MgYW5kIHRoZXJlZm9yIHRoZSBub25jZSBzaG91bGQgbm90IGJlIHJlY2FsY3VsYXRlZFxuICAgICAgY29uc3Qgbm9uY2UgPSB0eE1ldGEucHJldmlvdXNHYXNQYXJhbXNcbiAgICAgICAgPyB0eE1ldGEudHhQYXJhbXMubm9uY2VcbiAgICAgICAgOiBub25jZUxvY2submV4dE5vbmNlO1xuICAgICAgY29uc3QgY3VzdG9tT3JOb25jZSA9XG4gICAgICAgIGN1c3RvbU5vbmNlVmFsdWUgPT09IDAgPyBjdXN0b21Ob25jZVZhbHVlIDogY3VzdG9tTm9uY2VWYWx1ZSB8fCBub25jZTtcblxuICAgICAgdHhNZXRhLnR4UGFyYW1zLm5vbmNlID0gYWRkSGV4UHJlZml4KGN1c3RvbU9yTm9uY2UudG9TdHJpbmcoMTYpKTtcbiAgICAgIC8vIGFkZCBub25jZSBkZWJ1Z2dpbmcgaW5mb3JtYXRpb24gdG8gdHhNZXRhXG4gICAgICB0eE1ldGEubm9uY2VEZXRhaWxzID0gbm9uY2VMb2NrLm5vbmNlRGV0YWlscztcbiAgICAgIGlmIChjdXN0b21Ob25jZVZhbHVlKSB7XG4gICAgICAgIHR4TWV0YS5ub25jZURldGFpbHMuY3VzdG9tTm9uY2VWYWx1ZSA9IGN1c3RvbU5vbmNlVmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLnVwZGF0ZVRyYW5zYWN0aW9uKFxuICAgICAgICB0eE1ldGEsXG4gICAgICAgICd0cmFuc2FjdGlvbnMjYXBwcm92ZVRyYW5zYWN0aW9uJyxcbiAgICAgICk7XG4gICAgICAvLyBzaWduIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCByYXdUeCA9IGF3YWl0IHRoaXMuc2lnblRyYW5zYWN0aW9uKHR4SWQpO1xuICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoVHJhbnNhY3Rpb24odHhJZCwgcmF3VHgpO1xuICAgICAgdGhpcy5fdHJhY2tUcmFuc2FjdGlvbk1ldHJpY3NFdmVudCh0eE1ldGEsIFRSQU5TQUNUSU9OX0VWRU5UUy5BUFBST1ZFRCk7XG4gICAgICAvLyBtdXN0IHNldCB0cmFuc2FjdGlvbiB0byBzdWJtaXR0ZWQvZmFpbGVkIGJlZm9yZSByZWxlYXNpbmcgbG9ja1xuICAgICAgbm9uY2VMb2NrLnJlbGVhc2VMb2NrKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyB0aGlzIGlzIHRyeS1jYXRjaCB3cmFwcGVkIHNvIHRoYXQgd2UgY2FuIGd1YXJhbnRlZSB0aGF0IHRoZSBub25jZUxvY2sgaXMgcmVsZWFzZWRcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2ZhaWxUcmFuc2FjdGlvbih0eElkLCBlcnIpO1xuICAgICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgICBsb2cuZXJyb3IoZXJyMik7XG4gICAgICB9XG4gICAgICAvLyBtdXN0IHNldCB0cmFuc2FjdGlvbiB0byBzdWJtaXR0ZWQvZmFpbGVkIGJlZm9yZSByZWxlYXNpbmcgbG9ja1xuICAgICAgaWYgKG5vbmNlTG9jaykge1xuICAgICAgICBub25jZUxvY2sucmVsZWFzZUxvY2soKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbnRpbnVlIHdpdGggZXJyb3IgY2hhaW5cbiAgICAgIHRocm93IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5pblByb2Nlc3NPZlNpZ25pbmcuZGVsZXRlKHR4SWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgIGFkZHMgdGhlIGNoYWluIGlkIGFuZCBzaWducyB0aGUgdHJhbnNhY3Rpb24gYW5kIHNldCB0aGUgc3RhdHVzIHRvIHNpZ25lZFxuICAgIEBwYXJhbSB7bnVtYmVyfSB0eElkIC0gdGhlIHR4J3MgSWRcbiAgICBAcmV0dXJucyB7c3RyaW5nfSByYXdUeFxuICAqL1xuICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHhJZCkge1xuICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG4gICAgLy8gYWRkIG5ldHdvcmsvY2hhaW4gaWRcbiAgICBjb25zdCBjaGFpbklkID0gdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgdHlwZSA9IGlzRUlQMTU1OVRyYW5zYWN0aW9uKHR4TWV0YSlcbiAgICAgID8gVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMuRkVFX01BUktFVFxuICAgICAgOiBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5MRUdBQ1k7XG4gICAgY29uc3QgdHhQYXJhbXMgPSB7XG4gICAgICAuLi50eE1ldGEudHhQYXJhbXMsXG4gICAgICB0eXBlLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIGdhc0xpbWl0OiB0eE1ldGEudHhQYXJhbXMuZ2FzLFxuICAgIH07XG4gICAgLy8gc2lnbiB0eFxuICAgIGNvbnN0IGZyb21BZGRyZXNzID0gdHhQYXJhbXMuZnJvbTtcbiAgICBjb25zdCBjb21tb24gPSBhd2FpdCB0aGlzLmdldENvbW1vbkNvbmZpZ3VyYXRpb24odHhQYXJhbXMuZnJvbSk7XG4gICAgY29uc3QgdW5zaWduZWRFdGhUeCA9IFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4UGFyYW1zLCB7IGNvbW1vbiB9KTtcbiAgICBjb25zdCBzaWduZWRFdGhUeCA9IGF3YWl0IHRoaXMuc2lnbkV0aFR4KHVuc2lnbmVkRXRoVHgsIGZyb21BZGRyZXNzKTtcblxuICAgIC8vIGFkZCByLHMsdiB2YWx1ZXMgZm9yIHByb3ZpZGVyIHJlcXVlc3QgcHVycG9zZXMgc2VlIGNyZWF0ZU1ldGFtYXNrTWlkZGxld2FyZVxuICAgIC8vIGFuZCBKU09OIHJwYyBzdGFuZGFyZCBmb3IgZnVydGhlciBleHBsYW5hdGlvblxuICAgIHR4TWV0YS5yID0gYnVmZmVyVG9IZXgoc2lnbmVkRXRoVHgucik7XG4gICAgdHhNZXRhLnMgPSBidWZmZXJUb0hleChzaWduZWRFdGhUeC5zKTtcbiAgICB0eE1ldGEudiA9IGJ1ZmZlclRvSGV4KHNpZ25lZEV0aFR4LnYpO1xuXG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgIHR4TWV0YSxcbiAgICAgICd0cmFuc2FjdGlvbnMjc2lnblRyYW5zYWN0aW9uOiBhZGQgciwgcywgdiB2YWx1ZXMnLFxuICAgICk7XG5cbiAgICAvLyBzZXQgc3RhdGUgdG8gc2lnbmVkXG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci5zZXRUeFN0YXR1c1NpZ25lZCh0eE1ldGEuaWQpO1xuICAgIGNvbnN0IHJhd1R4ID0gYnVmZmVyVG9IZXgoc2lnbmVkRXRoVHguc2VyaWFsaXplKCkpO1xuICAgIHJldHVybiByYXdUeDtcbiAgfVxuXG4gIC8qKlxuICAgIHB1Ymxpc2hlcyB0aGUgcmF3IHR4IGFuZCBzZXRzIHRoZSB0eE1ldGEgdG8gc3VibWl0dGVkXG4gICAgQHBhcmFtIHtudW1iZXJ9IHR4SWQgLSB0aGUgdHgncyBJZFxuICAgIEBwYXJhbSB7c3RyaW5nfSByYXdUeCAtIHRoZSBoZXggc3RyaW5nIG9mIHRoZSBzZXJpYWxpemVkIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAqL1xuICBhc3luYyBwdWJsaXNoVHJhbnNhY3Rpb24odHhJZCwgcmF3VHgpIHtcbiAgICBjb25zdCB0eE1ldGEgPSB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdldFRyYW5zYWN0aW9uKHR4SWQpO1xuICAgIHR4TWV0YS5yYXdUeCA9IHJhd1R4O1xuICAgIGlmICh0eE1ldGEudHlwZSA9PT0gVFJBTlNBQ1RJT05fVFlQRVMuU1dBUCkge1xuICAgICAgY29uc3QgcHJlVHhCYWxhbmNlID0gYXdhaXQgdGhpcy5xdWVyeS5nZXRCYWxhbmNlKHR4TWV0YS50eFBhcmFtcy5mcm9tKTtcbiAgICAgIHR4TWV0YS5wcmVUeEJhbGFuY2UgPSBwcmVUeEJhbGFuY2UudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLnVwZGF0ZVRyYW5zYWN0aW9uKFxuICAgICAgdHhNZXRhLFxuICAgICAgJ3RyYW5zYWN0aW9ucyNwdWJsaXNoVHJhbnNhY3Rpb24nLFxuICAgICk7XG4gICAgbGV0IHR4SGFzaDtcbiAgICB0cnkge1xuICAgICAgdHhIYXNoID0gYXdhaXQgdGhpcy5xdWVyeS5zZW5kUmF3VHJhbnNhY3Rpb24ocmF3VHgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdrbm93biB0cmFuc2FjdGlvbicpKSB7XG4gICAgICAgIHR4SGFzaCA9IGtlY2Nhayh0b0J1ZmZlcihhZGRIZXhQcmVmaXgocmF3VHgpLCAnaGV4JykpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgdHhIYXNoID0gYWRkSGV4UHJlZml4KHR4SGFzaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXRUeEhhc2godHhJZCwgdHhIYXNoKTtcblxuICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIuc2V0VHhTdGF0dXNTdWJtaXR0ZWQodHhJZCk7XG5cbiAgICB0aGlzLl90cmFja1RyYW5zYWN0aW9uTWV0cmljc0V2ZW50KHR4TWV0YSwgVFJBTlNBQ1RJT05fRVZFTlRTLlNVQk1JVFRFRCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhdHVzIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBjb25maXJtZWQgYW5kIHNldHMgdGhlIHN0YXR1cyBvZiBub25jZSBkdXBsaWNhdGVzIGFzXG4gICAqIGRyb3BwZWQgaWYgdGhlIHR4UGFyYW1zIGhhdmUgZGF0YSBpdCB3aWxsIGZldGNoIHRoZSB0eFJlY2VpcHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR4SWQgLSBUaGUgdHgncyBJRFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvbih0eElkLCB0eFJlY2VpcHQsIGJhc2VGZWVQZXJHYXMsIGJsb2NrVGltZXN0YW1wKSB7XG4gICAgLy8gZ2V0IHRoZSB0eFJlY2VpcHQgYmVmb3JlIG1hcmtpbmcgdGhlIHRyYW5zYWN0aW9uIGNvbmZpcm1lZFxuICAgIC8vIHRvIGVuc3VyZSB0aGUgcmVjZWlwdCBpcyBnb3R0ZW4gYmVmb3JlIHRoZSB1aSByZXZpdmVzIHRoZSB0eFxuICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG5cbiAgICBpZiAoIXR4TWV0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBJdCBzZWVtcyB0aGF0IHNvbWV0aW1lcyB0aGUgbnVtZXJpY2FsIHZhbHVlcyBiZWluZyByZXR1cm5lZCBmcm9tXG4gICAgICAvLyB0aGlzLnF1ZXJ5LmdldFRyYW5zYWN0aW9uUmVjZWlwdCBhcmUgQk4gaW5zdGFuY2VzIGFuZCBub3Qgc3RyaW5ncy5cbiAgICAgIGNvbnN0IGdhc1VzZWQgPVxuICAgICAgICB0eXBlb2YgdHhSZWNlaXB0Lmdhc1VzZWQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgPyB0eFJlY2VpcHQuZ2FzVXNlZFxuICAgICAgICAgIDogdHhSZWNlaXB0Lmdhc1VzZWQudG9TdHJpbmcoMTYpO1xuXG4gICAgICB0eE1ldGEudHhSZWNlaXB0ID0ge1xuICAgICAgICAuLi50eFJlY2VpcHQsXG4gICAgICAgIGdhc1VzZWQsXG4gICAgICB9O1xuXG4gICAgICBpZiAoYmFzZUZlZVBlckdhcykge1xuICAgICAgICB0eE1ldGEuYmFzZUZlZVBlckdhcyA9IGJhc2VGZWVQZXJHYXM7XG4gICAgICB9XG4gICAgICBpZiAoYmxvY2tUaW1lc3RhbXApIHtcbiAgICAgICAgdHhNZXRhLmJsb2NrVGltZXN0YW1wID0gYmxvY2tUaW1lc3RhbXA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIuc2V0VHhTdGF0dXNDb25maXJtZWQodHhJZCk7XG4gICAgICB0aGlzLl9tYXJrTm9uY2VEdXBsaWNhdGVzRHJvcHBlZCh0eElkKTtcblxuICAgICAgY29uc3QgeyBzdWJtaXR0ZWRUaW1lIH0gPSB0eE1ldGE7XG4gICAgICBjb25zdCBtZXRyaWNzUGFyYW1zID0geyBnYXNfdXNlZDogZ2FzVXNlZCB9O1xuXG4gICAgICBpZiAoc3VibWl0dGVkVGltZSkge1xuICAgICAgICBtZXRyaWNzUGFyYW1zLmNvbXBsZXRpb25fdGltZSA9IHRoaXMuX2dldFRyYW5zYWN0aW9uQ29tcGxldGlvblRpbWUoXG4gICAgICAgICAgc3VibWl0dGVkVGltZSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR4UmVjZWlwdC5zdGF0dXMgPT09ICcweDAnKSB7XG4gICAgICAgIG1ldHJpY3NQYXJhbXMuc3RhdHVzID0gJ2ZhaWxlZCBvbi1jaGFpbic7XG4gICAgICAgIC8vIG1ldHJpY3NQYXJhbXMuZXJyb3IgPSBUT0RPOiBmaWd1cmUgb3V0IGEgd2F5IHRvIGdldCB0aGUgb24tY2hhaW4gZmFpbHVyZSByZWFzb25cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdHJhY2tUcmFuc2FjdGlvbk1ldHJpY3NFdmVudChcbiAgICAgICAgdHhNZXRhLFxuICAgICAgICBUUkFOU0FDVElPTl9FVkVOVFMuRklOQUxJWkVELFxuICAgICAgICBtZXRyaWNzUGFyYW1zLFxuICAgICAgKTtcblxuICAgICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgICAgdHhNZXRhLFxuICAgICAgICAndHJhbnNhY3Rpb25zI2NvbmZpcm1UcmFuc2FjdGlvbiAtIGFkZCB0eFJlY2VpcHQnLFxuICAgICAgKTtcblxuICAgICAgaWYgKHR4TWV0YS50eXBlID09PSBUUkFOU0FDVElPTl9UWVBFUy5TV0FQKSB7XG4gICAgICAgIGNvbnN0IHBvc3RUeEJhbGFuY2UgPSBhd2FpdCB0aGlzLnF1ZXJ5LmdldEJhbGFuY2UodHhNZXRhLnR4UGFyYW1zLmZyb20pO1xuICAgICAgICBjb25zdCBsYXRlc3RUeE1ldGEgPSB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdldFRyYW5zYWN0aW9uKHR4SWQpO1xuXG4gICAgICAgIGNvbnN0IGFwcHJvdmFsVHhNZXRhID0gbGF0ZXN0VHhNZXRhLmFwcHJvdmFsVHhJZFxuICAgICAgICAgID8gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbihsYXRlc3RUeE1ldGEuYXBwcm92YWxUeElkKVxuICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICBsYXRlc3RUeE1ldGEucG9zdFR4QmFsYW5jZSA9IHBvc3RUeEJhbGFuY2UudG9TdHJpbmcoMTYpO1xuXG4gICAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIudXBkYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgICAgbGF0ZXN0VHhNZXRhLFxuICAgICAgICAgICd0cmFuc2FjdGlvbnMjY29uZmlybVRyYW5zYWN0aW9uIC0gYWRkIHBvc3RUeEJhbGFuY2UnLFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX3RyYWNrU3dhcHNNZXRyaWNzKGxhdGVzdFR4TWV0YSwgYXBwcm92YWxUeE1ldGEpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLmVycm9yKGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAgQ29udmVuaWVuY2UgbWV0aG9kIGZvciB0aGUgdWkgdGhhdHMgc2V0cyB0aGUgdHJhbnNhY3Rpb24gdG8gcmVqZWN0ZWRcbiAgICBAcGFyYW0ge251bWJlcn0gdHhJZCAtIHRoZSB0eCdzIElkXG4gICAgQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICovXG4gIGFzeW5jIGNhbmNlbFRyYW5zYWN0aW9uKHR4SWQpIHtcbiAgICBjb25zdCB0eE1ldGEgPSB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdldFRyYW5zYWN0aW9uKHR4SWQpO1xuICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIuc2V0VHhTdGF0dXNSZWplY3RlZCh0eElkKTtcbiAgICB0aGlzLl90cmFja1RyYW5zYWN0aW9uTWV0cmljc0V2ZW50KHR4TWV0YSwgVFJBTlNBQ1RJT05fRVZFTlRTLlJFSkVDVEVEKTtcbiAgfVxuXG4gIC8qKlxuICAgIFNldHMgdGhlIHR4SGFzIG9uIHRoZSB0eE1ldGFcbiAgICBAcGFyYW0ge251bWJlcn0gdHhJZCAtIHRoZSB0eCdzIElkXG4gICAgQHBhcmFtIHtzdHJpbmd9IHR4SGFzaCAtIHRoZSBoYXNoIGZvciB0aGUgdHhNZXRhXG4gICovXG4gIHNldFR4SGFzaCh0eElkLCB0eEhhc2gpIHtcbiAgICAvLyBBZGQgdGhlIHR4IGhhc2ggdG8gdGhlIHBlcnNpc3RlZCBtZXRhLXR4IG9iamVjdFxuICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG4gICAgdHhNZXRhLmhhc2ggPSB0eEhhc2g7XG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbih0eE1ldGEsICd0cmFuc2FjdGlvbnMjc2V0VHhIYXNoJyk7XG4gIH1cblxuICAvL1xuICAvLyAgICAgICAgICAgUFJJVkFURSBNRVRIT0RTXG4gIC8vXG4gIC8qKiBtYXBzIG1ldGhvZHMgZm9yIGNvbnZlbmllbmNlKi9cbiAgX21hcE1ldGhvZHMoKSB7XG4gICAgLyoqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBzdGF0ZSBpbiB0cmFuc2FjdGlvbiBjb250cm9sbGVyICovXG4gICAgdGhpcy5nZXRTdGF0ZSA9ICgpID0+IHRoaXMubWVtU3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIC8qKiBAcmV0dXJucyB7c3RyaW5nfG51bWJlcn0gdGhlIG5ldHdvcmsgbnVtYmVyIHN0b3JlZCBpbiBuZXR3b3JrU3RvcmUgKi9cbiAgICB0aGlzLmdldE5ldHdvcmsgPSAoKSA9PiB0aGlzLm5ldHdvcmtTdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgLyoqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB1c2VyIHNlbGVjdGVkIGFkZHJlc3MgKi9cbiAgICB0aGlzLmdldFNlbGVjdGVkQWRkcmVzcyA9ICgpID0+XG4gICAgICB0aGlzLnByZWZlcmVuY2VzU3RvcmUuZ2V0U3RhdGUoKS5zZWxlY3RlZEFkZHJlc3M7XG5cbiAgICAvKiogQHJldHVybnMge0FycmF5fSB0cmFuc2FjdGlvbnMgd2hvcyBzdGF0dXMgaXMgdW5hcHByb3ZlZCAqL1xuICAgIHRoaXMuZ2V0VW5hcHByb3ZlZFR4Q291bnQgPSAoKSA9PlxuICAgICAgT2JqZWN0LmtleXModGhpcy50eFN0YXRlTWFuYWdlci5nZXRVbmFwcHJvdmVkVHhMaXN0KCkpLmxlbmd0aDtcblxuICAgIC8qKlxuICAgICAgQHJldHVybnMge251bWJlcn0gbnVtYmVyIG9mIHRyYW5zYWN0aW9ucyB0aGF0IGhhdmUgdGhlIHN0YXR1cyBzdWJtaXR0ZWRcbiAgICAgIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50IC0gaGV4IHByZWZpeGVkIGFjY291bnRcbiAgICAqL1xuICAgIHRoaXMuZ2V0UGVuZGluZ1R4Q291bnQgPSAoYWNjb3VudCkgPT5cbiAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0UGVuZGluZ1RyYW5zYWN0aW9ucyhhY2NvdW50KS5sZW5ndGg7XG5cbiAgICAvKiogc2VlIHR4U3RhdGVNYW5hZ2VyICovXG4gICAgdGhpcy5nZXRUcmFuc2FjdGlvbnMgPSAob3B0cykgPT4gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbnMob3B0cyk7XG4gIH1cblxuICAvLyBjYWxsZWQgb25jZSBvbiBzdGFydHVwXG4gIGFzeW5jIF91cGRhdGVQZW5kaW5nVHhzQWZ0ZXJGaXJzdEJsb2NrKCkge1xuICAgIC8vIHdhaXQgZm9yIGZpcnN0IGJsb2NrIHNvIHdlIGtub3cgd2UncmUgcmVhZHlcbiAgICBhd2FpdCB0aGlzLmJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgIC8vIGdldCBzdGF0dXMgdXBkYXRlIGZvciBhbGwgcGVuZGluZyB0cmFuc2FjdGlvbnMgKGZvciB0aGUgY3VycmVudCBuZXR3b3JrKVxuICAgIGF3YWl0IHRoaXMucGVuZGluZ1R4VHJhY2tlci51cGRhdGVQZW5kaW5nVHhzKCk7XG4gIH1cblxuICAvKipcbiAgICBJZiB0cmFuc2FjdGlvbiBjb250cm9sbGVyIHdhcyByZWJvb3RlZCB3aXRoIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSB1bmNvbXBsZXRlZFxuICAgIGluIHN0ZXBzIG9mIHRoZSB0cmFuc2FjdGlvbiBzaWduaW5nIG9yIHVzZXIgY29uZmlybWF0aW9uIHByb2Nlc3MgaXQgd2lsbCBlaXRoZXJcbiAgICB0cmFuc2l0aW9uIHR4TWV0YXMgdG8gYSBmYWlsZWQgc3RhdGUgb3IgdHJ5IHRvIHJlZG8gdGhvc2UgdGFza3MuXG4gICovXG5cbiAgX29uQm9vdENsZWFuVXAoKSB7XG4gICAgdGhpcy50eFN0YXRlTWFuYWdlclxuICAgICAgLmdldFRyYW5zYWN0aW9ucyh7XG4gICAgICAgIHNlYXJjaENyaXRlcmlhOiB7XG4gICAgICAgICAgc3RhdHVzOiBUUkFOU0FDVElPTl9TVEFUVVNFUy5VTkFQUFJPVkVELFxuICAgICAgICAgIGxvYWRpbmdEZWZhdWx0czogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICAuZm9yRWFjaCgodHgpID0+IHtcbiAgICAgICAgdGhpcy5hZGRUeEdhc0RlZmF1bHRzKHR4KVxuICAgICAgICAgIC50aGVuKCh0eE1ldGEpID0+IHtcbiAgICAgICAgICAgIHR4TWV0YS5sb2FkaW5nRGVmYXVsdHMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIudXBkYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgICAgICAgIHR4TWV0YSxcbiAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9uczogZ2FzIGVzdGltYXRpb24gZm9yIHR4IG9uIGJvb3QnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24odHguaWQpO1xuICAgICAgICAgICAgdHhNZXRhLmxvYWRpbmdEZWZhdWx0cyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgICAgICAgICAgdHhNZXRhLFxuICAgICAgICAgICAgICAnZmFpbGVkIHRvIGVzdGltYXRlIGdhcyBkdXJpbmcgYm9vdCBjbGVhbnVwLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fZmFpbFRyYW5zYWN0aW9uKHR4TWV0YS5pZCwgZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyXG4gICAgICAuZ2V0VHJhbnNhY3Rpb25zKHtcbiAgICAgICAgc2VhcmNoQ3JpdGVyaWE6IHtcbiAgICAgICAgICBzdGF0dXM6IFRSQU5TQUNUSU9OX1NUQVRVU0VTLkFQUFJPVkVELFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIC5mb3JFYWNoKCh0eE1ldGEpID0+IHtcbiAgICAgICAgY29uc3QgdHhTaWduRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1RyYW5zYWN0aW9uIGZvdW5kIGFzIFwiYXBwcm92ZWRcIiBkdXJpbmcgYm9vdCAtIHBvc3NpYmx5IHN0dWNrIGR1cmluZyBzaWduaW5nJyxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fZmFpbFRyYW5zYWN0aW9uKHR4TWV0YS5pZCwgdHhTaWduRXJyb3IpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICBpcyBjYWxsZWQgaW4gY29uc3RydWN0b3IgYXBwbGllcyB0aGUgbGlzdGVuZXJzIGZvciBwZW5kaW5nVHhUcmFja2VyIHR4U3RhdGVNYW5hZ2VyXG4gICAgYW5kIGJsb2NrVHJhY2tlclxuICAqL1xuICBfc2V0dXBMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci5vbihcbiAgICAgICd0eDpzdGF0dXMtdXBkYXRlJyxcbiAgICAgIHRoaXMuZW1pdC5iaW5kKHRoaXMsICd0eDpzdGF0dXMtdXBkYXRlJyksXG4gICAgKTtcbiAgICB0aGlzLl9zZXR1cEJsb2NrVHJhY2tlckxpc3RlbmVyKCk7XG4gICAgdGhpcy5wZW5kaW5nVHhUcmFja2VyLm9uKCd0eDp3YXJuaW5nJywgKHR4TWV0YSkgPT4ge1xuICAgICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgICAgdHhNZXRhLFxuICAgICAgICAndHJhbnNhY3Rpb25zL3BlbmRpbmctdHgtdHJhY2tlciNldmVudDogdHg6d2FybmluZycsXG4gICAgICApO1xuICAgIH0pO1xuICAgIHRoaXMucGVuZGluZ1R4VHJhY2tlci5vbigndHg6ZmFpbGVkJywgKHR4SWQsIGVycm9yKSA9PiB7XG4gICAgICB0aGlzLl9mYWlsVHJhbnNhY3Rpb24odHhJZCwgZXJyb3IpO1xuICAgIH0pO1xuICAgIHRoaXMucGVuZGluZ1R4VHJhY2tlci5vbihcbiAgICAgICd0eDpjb25maXJtZWQnLFxuICAgICAgKHR4SWQsIHRyYW5zYWN0aW9uUmVjZWlwdCwgYmFzZUZlZVBlckdhcywgYmxvY2tUaW1lc3RhbXApID0+XG4gICAgICAgIHRoaXMuY29uZmlybVRyYW5zYWN0aW9uKFxuICAgICAgICAgIHR4SWQsXG4gICAgICAgICAgdHJhbnNhY3Rpb25SZWNlaXB0LFxuICAgICAgICAgIGJhc2VGZWVQZXJHYXMsXG4gICAgICAgICAgYmxvY2tUaW1lc3RhbXAsXG4gICAgICAgICksXG4gICAgKTtcbiAgICB0aGlzLnBlbmRpbmdUeFRyYWNrZXIub24oJ3R4OmRyb3BwZWQnLCAodHhJZCkgPT4ge1xuICAgICAgdGhpcy5fZHJvcFRyYW5zYWN0aW9uKHR4SWQpO1xuICAgIH0pO1xuICAgIHRoaXMucGVuZGluZ1R4VHJhY2tlci5vbigndHg6YmxvY2stdXBkYXRlJywgKHR4TWV0YSwgbGF0ZXN0QmxvY2tOdW1iZXIpID0+IHtcbiAgICAgIGlmICghdHhNZXRhLmZpcnN0UmV0cnlCbG9ja051bWJlcikge1xuICAgICAgICB0eE1ldGEuZmlyc3RSZXRyeUJsb2NrTnVtYmVyID0gbGF0ZXN0QmxvY2tOdW1iZXI7XG4gICAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIudXBkYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgICAgdHhNZXRhLFxuICAgICAgICAgICd0cmFuc2FjdGlvbnMvcGVuZGluZy10eC10cmFja2VyI2V2ZW50OiB0eDpibG9jay11cGRhdGUnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucGVuZGluZ1R4VHJhY2tlci5vbigndHg6cmV0cnknLCAodHhNZXRhKSA9PiB7XG4gICAgICBpZiAoISgncmV0cnlDb3VudCcgaW4gdHhNZXRhKSkge1xuICAgICAgICB0eE1ldGEucmV0cnlDb3VudCA9IDA7XG4gICAgICB9XG4gICAgICB0eE1ldGEucmV0cnlDb3VudCArPSAxO1xuICAgICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgICAgdHhNZXRhLFxuICAgICAgICAndHJhbnNhY3Rpb25zL3BlbmRpbmctdHgtdHJhY2tlciNldmVudDogdHg6cmV0cnknLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7ICd0cmFuc2ZlcicgfCAnYXBwcm92ZScgfCAndHJhbnNmZXJmcm9tJyB8ICdjb250cmFjdEludGVyYWN0aW9uJ3wgJ3NpbXBsZVNlbmQnIH0gSW5mZXJyYWJsZVRyYW5zYWN0aW9uVHlwZXNcbiAgICovXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEluZmVyVHJhbnNhY3Rpb25UeXBlUmVzdWx0XG4gICAqIEBwcm9wZXJ0eSB7SW5mZXJyYWJsZVRyYW5zYWN0aW9uVHlwZXN9IHR5cGUgLSBUaGUgdHlwZSBvZiB0cmFuc2FjdGlvblxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gZ2V0Q29kZVJlc3BvbnNlIC0gVGhlIGNvbnRyYWN0IGNvZGUsIGluIGhleCBmb3JtYXQgaWZcbiAgICogIGl0IGV4aXN0cy4gJzB4MCcgb3IgJzB4JyBhcmUgYWxzbyBpbmRpY2F0b3JzIG9mIG5vbi1leGlzdGVudCBjb250cmFjdFxuICAgKiAgY29kZVxuICAgKi9cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgdHlwZSBvZiB0aGUgdHJhbnNhY3Rpb24gYnkgYW5hbHl6aW5nIHRoZSB0eFBhcmFtcy5cbiAgICogVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gb25lIG9mIHRoZSB0eXBlcyBkZWZpbmVkIGluIHNoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb25zXG4gICAqIEl0IHdpbGwgbmV2ZXIgcmV0dXJuIFRSQU5TQUNUSU9OX1RZUEVfQ0FOQ0VMIG9yIFRSQU5TQUNUSU9OX1RZUEVfUkVUUlkgYXMgdGhlc2VcbiAgICogcmVwcmVzZW50IHNwZWNpZmljIGV2ZW50cyB0aGF0IHdlIGNvbnRyb2wgZnJvbSB0aGUgZXh0ZW5zaW9uIGFuZCBhcmUgYWRkZWQgbWFudWFsbHlcbiAgICogYXQgdHJhbnNhY3Rpb24gY3JlYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eFBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyB7SW5mZXJUcmFuc2FjdGlvblR5cGVSZXN1bHR9XG4gICAqL1xuICBhc3luYyBfZGV0ZXJtaW5lVHJhbnNhY3Rpb25UeXBlKHR4UGFyYW1zKSB7XG4gICAgY29uc3QgeyBkYXRhLCB0byB9ID0gdHhQYXJhbXM7XG4gICAgbGV0IG5hbWU7XG4gICAgdHJ5IHtcbiAgICAgIG5hbWUgPSBkYXRhICYmIGhzdEludGVyZmFjZS5wYXJzZVRyYW5zYWN0aW9uKHsgZGF0YSB9KS5uYW1lO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZGVidWcoJ0ZhaWxlZCB0byBwYXJzZSB0cmFuc2FjdGlvbiBkYXRhLicsIGVycm9yLCBkYXRhKTtcbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbk1ldGhvZE5hbWUgPSBbXG4gICAgICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfQVBQUk9WRSxcbiAgICAgIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9UUkFOU0ZFUixcbiAgICAgIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9UUkFOU0ZFUl9GUk9NLFxuICAgIF0uZmluZCgobWV0aG9kTmFtZSkgPT4gbWV0aG9kTmFtZSA9PT0gbmFtZSAmJiBuYW1lLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoZGF0YSAmJiB0b2tlbk1ldGhvZE5hbWUpIHtcbiAgICAgIHJlc3VsdCA9IHRva2VuTWV0aG9kTmFtZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgJiYgIXRvKSB7XG4gICAgICByZXN1bHQgPSBUUkFOU0FDVElPTl9UWVBFUy5ERVBMT1lfQ09OVFJBQ1Q7XG4gICAgfVxuXG4gICAgbGV0IGNvbnRyYWN0Q29kZTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRyYWN0Q29kZTogcmVzdWx0Q29kZSxcbiAgICAgICAgaXNDb250cmFjdEFkZHJlc3MsXG4gICAgICB9ID0gYXdhaXQgcmVhZEFkZHJlc3NBc0NvbnRyYWN0KHRoaXMucXVlcnksIHRvKTtcblxuICAgICAgY29udHJhY3RDb2RlID0gcmVzdWx0Q29kZTtcbiAgICAgIHJlc3VsdCA9IGlzQ29udHJhY3RBZGRyZXNzXG4gICAgICAgID8gVFJBTlNBQ1RJT05fVFlQRVMuQ09OVFJBQ1RfSU5URVJBQ1RJT05cbiAgICAgICAgOiBUUkFOU0FDVElPTl9UWVBFUy5TSU1QTEVfU0VORDtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0eXBlOiByZXN1bHQsIGdldENvZGVSZXNwb25zZTogY29udHJhY3RDb2RlIH07XG4gIH1cblxuICAvKipcbiAgICBTZXRzIG90aGVyIHR4TWV0YSBzdGF0dXNlcyB0byBkcm9wcGVkIGlmIHRoZSB0eE1ldGEgdGhhdCBoYXMgYmVlbiBjb25maXJtZWQgaGFzIG90aGVyIHRyYW5zYWN0aW9uc1xuICAgIGluIHRoZSBsaXN0IGhhdmUgdGhlIHNhbWUgbm9uY2VcblxuICAgIEBwYXJhbSB7bnVtYmVyfSB0eElkIC0gdGhlIHR4SWQgb2YgdGhlIHRyYW5zYWN0aW9uIHRoYXQgaGFzIGJlZW4gY29uZmlybWVkIGluIGEgYmxvY2tcbiAgKi9cbiAgX21hcmtOb25jZUR1cGxpY2F0ZXNEcm9wcGVkKHR4SWQpIHtcbiAgICAvLyBnZXQgdGhlIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMgbm9uY2UgYW5kIGZyb20gYWRkcmVzc1xuICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG4gICAgY29uc3QgeyBub25jZSwgZnJvbSB9ID0gdHhNZXRhLnR4UGFyYW1zO1xuICAgIGNvbnN0IHNhbWVOb25jZVR4cyA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb25zKHtcbiAgICAgIHNlYXJjaENyaXRlcmlhOiB7IG5vbmNlLCBmcm9tIH0sXG4gICAgfSk7XG4gICAgaWYgKCFzYW1lTm9uY2VUeHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG1hcmsgYWxsIHNhbWUgbm9uY2UgdHJhbnNhY3Rpb25zIGFzIGRyb3BwZWQgYW5kIGdpdmUgaSBhIHJlcGxhY2VkQnkgaGFzaFxuICAgIHNhbWVOb25jZVR4cy5mb3JFYWNoKChvdGhlclR4TWV0YSkgPT4ge1xuICAgICAgaWYgKG90aGVyVHhNZXRhLmlkID09PSB0eElkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG90aGVyVHhNZXRhLnJlcGxhY2VkQnkgPSB0eE1ldGEuaGFzaDtcbiAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIudXBkYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgIHR4TWV0YSxcbiAgICAgICAgJ3RyYW5zYWN0aW9ucy9wZW5kaW5nLXR4LXRyYWNrZXIjZXZlbnQ6IHR4OmNvbmZpcm1lZCByZWZlcmVuY2UgdG8gY29uZmlybWVkIHR4SGFzaCB3aXRoIHNhbWUgbm9uY2UnLFxuICAgICAgKTtcbiAgICAgIHRoaXMuX2Ryb3BUcmFuc2FjdGlvbihvdGhlclR4TWV0YS5pZCk7XG4gICAgfSk7XG4gIH1cblxuICBfc2V0dXBCbG9ja1RyYWNrZXJMaXN0ZW5lcigpIHtcbiAgICBsZXQgbGlzdGVuZXJzQXJlQWN0aXZlID0gZmFsc2U7XG4gICAgY29uc3QgbGF0ZXN0QmxvY2tIYW5kbGVyID0gdGhpcy5fb25MYXRlc3RCbG9jay5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHsgYmxvY2tUcmFja2VyLCB0eFN0YXRlTWFuYWdlciB9ID0gdGhpcztcblxuICAgIHR4U3RhdGVNYW5hZ2VyLm9uKCd0eDpzdGF0dXMtdXBkYXRlJywgdXBkYXRlU3Vic2NyaXB0aW9uKTtcbiAgICB1cGRhdGVTdWJzY3JpcHRpb24oKTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN1YnNjcmlwdGlvbigpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdUeHMgPSB0eFN0YXRlTWFuYWdlci5nZXRQZW5kaW5nVHJhbnNhY3Rpb25zKCk7XG4gICAgICBpZiAoIWxpc3RlbmVyc0FyZUFjdGl2ZSAmJiBwZW5kaW5nVHhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYmxvY2tUcmFja2VyLm9uKCdsYXRlc3QnLCBsYXRlc3RCbG9ja0hhbmRsZXIpO1xuICAgICAgICBsaXN0ZW5lcnNBcmVBY3RpdmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnNBcmVBY3RpdmUgJiYgIXBlbmRpbmdUeHMubGVuZ3RoKSB7XG4gICAgICAgIGJsb2NrVHJhY2tlci5yZW1vdmVMaXN0ZW5lcignbGF0ZXN0JywgbGF0ZXN0QmxvY2tIYW5kbGVyKTtcbiAgICAgICAgbGlzdGVuZXJzQXJlQWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX29uTGF0ZXN0QmxvY2soYmxvY2tOdW1iZXIpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5wZW5kaW5nVHhUcmFja2VyLnVwZGF0ZVBlbmRpbmdUeHMoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5lcnJvcihlcnIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5wZW5kaW5nVHhUcmFja2VyLnJlc3VibWl0UGVuZGluZ1R4cyhibG9ja051bWJlcik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICBVcGRhdGVzIHRoZSBtZW1TdG9yZSBpbiB0cmFuc2FjdGlvbiBjb250cm9sbGVyXG4gICovXG4gIF91cGRhdGVNZW1zdG9yZSgpIHtcbiAgICBjb25zdCB1bmFwcHJvdmVkVHhzID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRVbmFwcHJvdmVkVHhMaXN0KCk7XG4gICAgY29uc3QgY3VycmVudE5ldHdvcmtUeExpc3QgPSB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdldFRyYW5zYWN0aW9ucyh7XG4gICAgICBsaW1pdDogTUFYX01FTVNUT1JFX1RYX0xJU1RfU0laRSxcbiAgICB9KTtcbiAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHsgdW5hcHByb3ZlZFR4cywgY3VycmVudE5ldHdvcmtUeExpc3QgfSk7XG4gIH1cblxuICBfdHJhY2tTd2Fwc01ldHJpY3ModHhNZXRhLCBhcHByb3ZhbFR4TWV0YSkge1xuICAgIGlmICh0aGlzLl9nZXRQYXJ0aWNpcGF0ZUluTWV0cmljcygpICYmIHR4TWV0YS5zd2FwTWV0YURhdGEpIHtcbiAgICAgIGlmICh0eE1ldGEudHhSZWNlaXB0LnN0YXR1cyA9PT0gJzB4MCcpIHtcbiAgICAgICAgdGhpcy5fdHJhY2tNZXRhTWV0cmljc0V2ZW50KHtcbiAgICAgICAgICBldmVudDogJ1N3YXAgRmFpbGVkJyxcbiAgICAgICAgICBzZW5zaXRpdmVQcm9wZXJ0aWVzOiB7IC4uLnR4TWV0YS5zd2FwTWV0YURhdGEgfSxcbiAgICAgICAgICBjYXRlZ29yeTogJ3N3YXBzJyxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0b2tlbnNSZWNlaXZlZCA9IGdldFN3YXBzVG9rZW5zUmVjZWl2ZWRGcm9tVHhNZXRhKFxuICAgICAgICAgIHR4TWV0YS5kZXN0aW5hdGlvblRva2VuU3ltYm9sLFxuICAgICAgICAgIHR4TWV0YSxcbiAgICAgICAgICB0eE1ldGEuZGVzdGluYXRpb25Ub2tlbkFkZHJlc3MsXG4gICAgICAgICAgdHhNZXRhLnR4UGFyYW1zLmZyb20sXG4gICAgICAgICAgdHhNZXRhLmRlc3RpbmF0aW9uVG9rZW5EZWNpbWFscyxcbiAgICAgICAgICBhcHByb3ZhbFR4TWV0YSxcbiAgICAgICAgICB0eE1ldGEuY2hhaW5JZCxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBxdW90ZVZzRXhlY3V0aW9uUmF0aW8gPSB0b2tlbnNSZWNlaXZlZFxuICAgICAgICAgID8gYCR7bmV3IEJpZ051bWJlcih0b2tlbnNSZWNlaXZlZCwgMTApXG4gICAgICAgICAgICAgIC5kaXYodHhNZXRhLnN3YXBNZXRhRGF0YS50b2tlbl90b19hbW91bnQsIDEwKVxuICAgICAgICAgICAgICAudGltZXMoMTAwKVxuICAgICAgICAgICAgICAucm91bmQoMil9JWBcbiAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgY29uc3QgZXN0aW1hdGVkVnNVc2VkR2FzUmF0aW8gPSBgJHtuZXcgQmlnTnVtYmVyKFxuICAgICAgICAgIHR4TWV0YS50eFJlY2VpcHQuZ2FzVXNlZCxcbiAgICAgICAgICAxNixcbiAgICAgICAgKVxuICAgICAgICAgIC5kaXYodHhNZXRhLnN3YXBNZXRhRGF0YS5lc3RpbWF0ZWRfZ2FzLCAxMClcbiAgICAgICAgICAudGltZXMoMTAwKVxuICAgICAgICAgIC5yb3VuZCgyKX0lYDtcblxuICAgICAgICB0aGlzLl90cmFja01ldGFNZXRyaWNzRXZlbnQoe1xuICAgICAgICAgIGV2ZW50OiAnU3dhcCBDb21wbGV0ZWQnLFxuICAgICAgICAgIGNhdGVnb3J5OiAnc3dhcHMnLFxuICAgICAgICAgIHNlbnNpdGl2ZVByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIC4uLnR4TWV0YS5zd2FwTWV0YURhdGEsXG4gICAgICAgICAgICB0b2tlbl90b19hbW91bnRfcmVjZWl2ZWQ6IHRva2Vuc1JlY2VpdmVkLFxuICAgICAgICAgICAgcXVvdGVfdnNfZXhlY3V0aW9uUmF0aW86IHF1b3RlVnNFeGVjdXRpb25SYXRpbyxcbiAgICAgICAgICAgIGVzdGltYXRlZF92c191c2VkX2dhc1JhdGlvOiBlc3RpbWF0ZWRWc1VzZWRHYXNSYXRpbyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgcmVsZXZhbnQgcHJvcGVydGllcyBmcm9tIGEgdHJhbnNhY3Rpb24gbWV0YVxuICAgKiBvYmplY3QgYW5kIHVzZXMgdGhlbSB0byBjcmVhdGUgYW5kIHNlbmQgbWV0cmljcyBmb3IgdmFyaW91cyB0cmFuc2FjdGlvblxuICAgKiBldmVudHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eE1ldGEgLSB0aGUgdHhNZXRhIG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSB0aGUgbmFtZSBvZiB0aGUgdHJhbnNhY3Rpb24gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhUGFyYW1zIC0gb3B0aW9uYWwgcHJvcHMgYW5kIHZhbHVlcyB0byBpbmNsdWRlIGluIHNlbnNpdGl2ZVByb3BlcnRpZXNcbiAgICovXG4gIF90cmFja1RyYW5zYWN0aW9uTWV0cmljc0V2ZW50KHR4TWV0YSwgZXZlbnQsIGV4dHJhUGFyYW1zID0ge30pIHtcbiAgICBpZiAoIXR4TWV0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICB0aW1lLFxuICAgICAgc3RhdHVzLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIG9yaWdpbjogcmVmZXJyZXIsXG4gICAgICB0eFBhcmFtczoge1xuICAgICAgICBnYXNQcmljZSxcbiAgICAgICAgZ2FzOiBnYXNMaW1pdCxcbiAgICAgICAgbWF4RmVlUGVyR2FzLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgZXN0aW1hdGVTdWdnZXN0ZWQsXG4gICAgICAgIGVzdGltYXRlVXNlZCxcbiAgICAgIH0sXG4gICAgICBtZXRhbWFza05ldHdvcmtJZDogbmV0d29yayxcbiAgICB9ID0gdHhNZXRhO1xuICAgIGNvbnN0IHNvdXJjZSA9IHJlZmVycmVyID09PSAnbWV0YW1hc2snID8gJ3VzZXInIDogJ2RhcHAnO1xuXG4gICAgY29uc3QgZ2FzUGFyYW1zID0ge307XG5cbiAgICBpZiAoaXNFSVAxNTU5VHJhbnNhY3Rpb24odHhNZXRhKSkge1xuICAgICAgZ2FzUGFyYW1zLm1heF9mZWVfcGVyX2dhcyA9IG1heEZlZVBlckdhcztcbiAgICAgIGdhc1BhcmFtcy5tYXhfcHJpb3JpdHlfZmVlX3Blcl9nYXMgPSBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICB9IGVsc2Uge1xuICAgICAgZ2FzUGFyYW1zLmdhc19wcmljZSA9IGdhc1ByaWNlO1xuICAgIH1cblxuICAgIGlmIChlc3RpbWF0ZVN1Z2dlc3RlZCkge1xuICAgICAgZ2FzUGFyYW1zLmVzdGltYXRlX3N1Z2dlc3RlZCA9IGVzdGltYXRlU3VnZ2VzdGVkO1xuICAgIH1cblxuICAgIGlmIChlc3RpbWF0ZVVzZWQpIHtcbiAgICAgIGdhc1BhcmFtcy5lc3RpbWF0ZV91c2VkID0gZXN0aW1hdGVVc2VkO1xuICAgIH1cblxuICAgIGNvbnN0IGdhc1BhcmFtc0luR3dlaSA9IHRoaXMuX2dldEdhc1ZhbHVlc0luR1dFSShnYXNQYXJhbXMpO1xuXG4gICAgdGhpcy5fdHJhY2tNZXRhTWV0cmljc0V2ZW50KHtcbiAgICAgIGV2ZW50LFxuICAgICAgY2F0ZWdvcnk6ICdUcmFuc2FjdGlvbnMnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBjaGFpbl9pZDogY2hhaW5JZCxcbiAgICAgICAgcmVmZXJyZXIsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgbmV0d29yayxcbiAgICAgICAgdHlwZSxcbiAgICAgIH0sXG4gICAgICBzZW5zaXRpdmVQcm9wZXJ0aWVzOiB7XG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgdHJhbnNhY3Rpb25fZW52ZWxvcGVfdHlwZTogaXNFSVAxNTU5VHJhbnNhY3Rpb24odHhNZXRhKVxuICAgICAgICAgID8gVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRV9OQU1FUy5GRUVfTUFSS0VUXG4gICAgICAgICAgOiBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFX05BTUVTLkxFR0FDWSxcbiAgICAgICAgZmlyc3Rfc2VlbjogdGltZSxcbiAgICAgICAgZ2FzX2xpbWl0OiBnYXNMaW1pdCxcbiAgICAgICAgLi4uZ2FzUGFyYW1zSW5Hd2VpLFxuICAgICAgICAuLi5leHRyYVBhcmFtcyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBfZ2V0VHJhbnNhY3Rpb25Db21wbGV0aW9uVGltZShzdWJtaXR0ZWRUaW1lKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKERhdGUubm93KCkgLSBzdWJtaXR0ZWRUaW1lKSAvIDEwMDApLnRvU3RyaW5nKCk7XG4gIH1cblxuICBfZ2V0R2FzVmFsdWVzSW5HV0VJKGdhc1BhcmFtcykge1xuICAgIGNvbnN0IGdhc1ZhbHVlc0luR3dlaSA9IHt9O1xuICAgIGZvciAoY29uc3QgcGFyYW0gaW4gZ2FzUGFyYW1zKSB7XG4gICAgICBpZiAoaXNIZXhTdHJpbmcoZ2FzUGFyYW1zW3BhcmFtXSkpIHtcbiAgICAgICAgZ2FzVmFsdWVzSW5Hd2VpW3BhcmFtXSA9IGhleFdFSVRvRGVjR1dFSShnYXNQYXJhbXNbcGFyYW1dKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdhc1ZhbHVlc0luR3dlaVtwYXJhbV0gPSBnYXNQYXJhbXNbcGFyYW1dO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2FzVmFsdWVzSW5Hd2VpO1xuICB9XG5cbiAgX2ZhaWxUcmFuc2FjdGlvbih0eElkLCBlcnJvcikge1xuICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIuc2V0VHhTdGF0dXNGYWlsZWQodHhJZCwgZXJyb3IpO1xuICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG4gICAgdGhpcy5fdHJhY2tUcmFuc2FjdGlvbk1ldHJpY3NFdmVudCh0eE1ldGEsIFRSQU5TQUNUSU9OX0VWRU5UUy5GSU5BTElaRUQsIHtcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgIH0pO1xuICB9XG5cbiAgX2Ryb3BUcmFuc2FjdGlvbih0eElkKSB7XG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci5zZXRUeFN0YXR1c0Ryb3BwZWQodHhJZCk7XG4gICAgY29uc3QgdHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbih0eElkKTtcbiAgICB0aGlzLl90cmFja1RyYW5zYWN0aW9uTWV0cmljc0V2ZW50KHR4TWV0YSwgVFJBTlNBQ1RJT05fRVZFTlRTLkZJTkFMSVpFRCk7XG4gIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vY2F2ZWF0LW11dGF0b3JzJztcbmV4cG9ydCAqIGZyb20gJy4vYmFja2dyb3VuZC1hcGknO1xuZXhwb3J0ICogZnJvbSAnLi9lbnVtcyc7XG5leHBvcnQgKiBmcm9tICcuL3Blcm1pc3Npb24tbG9nJztcbmV4cG9ydCAqIGZyb20gJy4vc3BlY2lmaWNhdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi9zZWxlY3RvcnMnO1xuIiwiaW1wb3J0IEFuYWx5dGljcyBmcm9tICdhbmFseXRpY3Mtbm9kZSc7XG5pbXBvcnQgeyBTRUNPTkQgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RpbWUnO1xuXG5jb25zdCBpc0Rldk9yVGVzdEVudmlyb25tZW50ID0gQm9vbGVhbihcbiAgcHJvY2Vzcy5lbnYuTUVUQU1BU0tfREVCVUcgfHwgcHJvY2Vzcy5lbnYuSU5fVEVTVCxcbik7XG5jb25zdCBTRUdNRU5UX1dSSVRFX0tFWSA9IHByb2Nlc3MuZW52LlNFR01FTlRfV1JJVEVfS0VZID8/IG51bGw7XG5jb25zdCBTRUdNRU5UX0hPU1QgPSBwcm9jZXNzLmVudi5TRUdNRU5UX0hPU1QgPz8gbnVsbDtcblxuLy8gZmx1c2hBdCBjb250cm9scyBob3cgbWFueSBldmVudHMgYXJlIHNlbnQgdG8gc2VnbWVudCBhdCBvbmNlLiBTZWdtZW50IHdpbGxcbi8vIGhvbGQgb250byBhIHF1ZXVlIG9mIGV2ZW50cyB1bnRpbCBpdCBoaXRzIHRoaXMgbnVtYmVyLCB0aGVuIGl0IHNlbmRzIHRoZW0gYXNcbi8vIGEgYmF0Y2guIFRoaXMgc2V0dGluZyBkZWZhdWx0cyB0byAyMCwgYnV0IGluIGRldmVsb3BtZW50IHdlIGxpa2VseSB3YW50IHRvXG4vLyBzZWUgZXZlbnRzIGluIHJlYWwgdGltZSBmb3IgZGVidWdnaW5nLCBzbyB0aGlzIGlzIHNldCB0byAxIHRvIGRpc2FibGUgdGhlXG4vLyBxdWV1ZWluZyBtZWNoYW5pc20uXG5jb25zdCBTRUdNRU5UX0ZMVVNIX0FUID1cbiAgcHJvY2Vzcy5lbnYuTUVUQU1BU0tfRU5WSVJPTk1FTlQgPT09ICdwcm9kdWN0aW9uJyA/IHVuZGVmaW5lZCA6IDE7XG5cbi8vIGZsdXNoSW50ZXJ2YWwgY29udHJvbHMgaG93IGZyZXF1ZW50bHkgdGhlIHF1ZXVlIGlzIGZsdXNoZWQgdG8gc2VnbWVudC5cbi8vIFRoaXMgaGFwcGVucyByZWdhcmRsZXNzIG9mIHRoZSBzaXplIG9mIHRoZSBxdWV1ZS4gVGhlIGRlZmF1bHQgc2V0dGluZyBpc1xuLy8gMTAsMDAwbXMgKDEwIHNlY29uZHMpLiBUaGlzIGRlZmF1bHQgaXMgcmF0aGVyIGhpZ2gsIHRob3VnaCB0aGFua2Z1bGx5XG4vLyB1c2luZyB0aGUgYmFja2dyb3VuZCBwcm9jZXNzIGFzIG91ciBldmVudCBoYW5kbGVyIG1lYW5zIHdlIGRvbid0IGhhdmUgdG9cbi8vIGRlYWwgd2l0aCBzaG9ydCBsaXZlZCBzZXNzaW9ucyB0aGF0IGhhcHBlbiBmYXN0ZXIgdGhhbiB0aGUgaW50ZXJ2YWxcbi8vIGUuZyBjb25maXJtYXRpb25zLiBUaGlzIGlzIHNldCB0byA1LDAwMG1zICg1IHNlY29uZHMpIGFyYml0cmFyaWx5IHdpdGggdGhlXG4vLyBpbnRlbnQgb2YgaGF2aW5nIGEgdmFsdWUgbGVzcyB0aGFuIDEwIHNlY29uZHMuXG5jb25zdCBTRUdNRU5UX0ZMVVNIX0lOVEVSVkFMID0gU0VDT05EICogNTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbW9jayBzZWdtZW50IG1vZHVsZSBmb3IgdXNhZ2UgaW4gdGVzdCBlbnZpcm9ubWVudHMuIFRoaXMgaXMgdXNlZFxuICogd2hlbiBidWlsZGluZyB0aGUgYXBwbGljYXRpb24gaW4gdGVzdCBtb2RlIHRvIGNhdGNoIGV2ZW50IGNhbGxzIGFuZCBwcmV2ZW50XG4gKiB0aGVtIGZyb20gYmVpbmcgc2VudCB0byBzZWdtZW50LiBJdCBpcyBhbHNvIHVzZWQgaW4gdW5pdCB0ZXN0cyB0byBtb2NrIGFuZFxuICogc3B5IG9uIHRoZSBtZXRob2RzIHRvIGVuc3VyZSBwcm9wZXIgYmVoYXZpb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbHVzaEF0IC0gbnVtYmVyIG9mIGV2ZW50cyB0byBxdWV1ZSBiZWZvcmUgc2VuZGluZyB0byBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gZmx1c2hJbnRlcnZhbCAtIG1zIGludGVydmFsIHRvIGZsdXNoIHF1ZXVlIGFuZCBzZW5kIHRvIHNlZ21lbnRcbiAqIEByZXR1cm5zIHtTZWdtZW50SW50ZXJmYWNlfVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlU2VnbWVudE1vY2sgPSAoZmx1c2hBdCA9IFNFR01FTlRfRkxVU0hfQVQpID0+IHtcbiAgY29uc3Qgc2VnbWVudE1vY2sgPSB7XG4gICAgLy8gSW50ZXJuYWwgcXVldWUgdG8ga2VlcCB0cmFjayBvZiBldmVudHMgYW5kIHByb3Blcmx5IG1pbWljIHNlZ21lbnQnc1xuICAgIC8vIHF1ZXVlaW5nIGJlaGF2aW9yLlxuICAgIHF1ZXVlOiBbXSxcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gaW1tZWRpYXRlbHkgc2VuZCBhbGwgcXVldWVkIGV2ZW50cyBhbmQgcmVzZXQgdGhlIHF1ZXVlIHRvIHplcm8uXG4gICAgICogRm9yIG91ciBwdXJwb3NlcyB0aGlzIHNpbXBseSB0cmlnZ2VycyB0aGUgY2FsbGJhY2sgbWV0aG9kIHJlZ2lzdGVyZWQgd2l0aFxuICAgICAqIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBmbHVzaCgpIHtcbiAgICAgIHNlZ21lbnRNb2NrLnF1ZXVlLmZvckVhY2goKFtfLCBjYWxsYmFja10pID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgc2VnbWVudE1vY2sucXVldWUgPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhY2sgYW4gZXZlbnQgYW5kIGFkZCBpdCB0byB0aGUgcXVldWUuIElmIHRoZSBxdWV1ZSBzaXplIHJlYWNoZXMgdGhlXG4gICAgICogZmx1c2hBdCB0aHJlc2hvbGQsIGZsdXNoIHRoZSBxdWV1ZS5cbiAgICAgKi9cbiAgICB0cmFjayhwYXlsb2FkLCBjYWxsYmFjayA9ICgpID0+IHVuZGVmaW5lZCkge1xuICAgICAgc2VnbWVudE1vY2sucXVldWUucHVzaChbcGF5bG9hZCwgY2FsbGJhY2tdKTtcblxuICAgICAgaWYgKHNlZ21lbnRNb2NrLnF1ZXVlLmxlbmd0aCA+PSBmbHVzaEF0KSB7XG4gICAgICAgIHNlZ21lbnRNb2NrLmZsdXNoKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJ1ZSBOT09QLCB0aGVzZSBtZXRob2RzIGFyZSBlaXRoZXIgbm90IHVzZWQgb3IgZG8gbm90IGF3YWl0IGNhbGxiYWNrXG4gICAgICogYW5kIHRoZXJlZm9yZSByZXF1aXJlIG5vIGZ1bmN0aW9uYWxpdHkuXG4gICAgICovXG4gICAgcGFnZSgpIHtcbiAgICAgIC8vIG5vb3BcbiAgICB9LFxuICAgIGlkZW50aWZ5KCkge1xuICAgICAgLy8gbm9vcFxuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIHNlZ21lbnRNb2NrO1xufTtcblxuZXhwb3J0IGNvbnN0IHNlZ21lbnQgPVxuICAhU0VHTUVOVF9XUklURV9LRVkgfHwgKGlzRGV2T3JUZXN0RW52aXJvbm1lbnQgJiYgIVNFR01FTlRfSE9TVClcbiAgICA/IGNyZWF0ZVNlZ21lbnRNb2NrKFNFR01FTlRfRkxVU0hfQVQsIFNFR01FTlRfRkxVU0hfSU5URVJWQUwpXG4gICAgOiBuZXcgQW5hbHl0aWNzKFNFR01FTlRfV1JJVEVfS0VZLCB7XG4gICAgICAgIGhvc3Q6IFNFR01FTlRfSE9TVCxcbiAgICAgICAgZmx1c2hBdDogU0VHTUVOVF9GTFVTSF9BVCxcbiAgICAgICAgZmx1c2hJbnRlcnZhbDogU0VHTUVOVF9GTFVTSF9JTlRFUlZBTCxcbiAgICAgIH0pO1xuIiwiaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgV2FsbGV0IGZyb20gJ2V0aGVyZXVtanMtd2FsbGV0JztcbmltcG9ydCBpbXBvcnRlcnMgZnJvbSAnZXRoZXJldW1qcy13YWxsZXQvdGhpcmRwYXJ0eSc7XG5pbXBvcnQge1xuICB0b0J1ZmZlcixcbiAgaXNWYWxpZFByaXZhdGUsXG4gIGJ1ZmZlclRvSGV4LFxuICBzdHJpcEhleFByZWZpeCxcbn0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJy4uL2xpYi91dGlsJztcblxuY29uc3QgYWNjb3VudEltcG9ydGVyID0ge1xuICBpbXBvcnRBY2NvdW50KHN0cmF0ZWd5LCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGltcG9ydGVyID0gdGhpcy5zdHJhdGVnaWVzW3N0cmF0ZWd5XTtcbiAgICAgIGNvbnN0IHByaXZhdGVLZXlIZXggPSBpbXBvcnRlciguLi5hcmdzKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJpdmF0ZUtleUhleCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfSxcblxuICBzdHJhdGVnaWVzOiB7XG4gICAgJ1ByaXZhdGUgS2V5JzogKHByaXZhdGVLZXkpID0+IHtcbiAgICAgIGlmICghcHJpdmF0ZUtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbXBvcnQgYW4gZW1wdHkga2V5LicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcmVmaXhlZCA9IGFkZEhleFByZWZpeChwcml2YXRlS2V5KTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHRvQnVmZmVyKHByZWZpeGVkKTtcblxuICAgICAgaWYgKCFpc1ZhbGlkUHJpdmF0ZShidWZmZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGltcG9ydCBpbnZhbGlkIHByaXZhdGUga2V5LicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdHJpcHBlZCA9IHN0cmlwSGV4UHJlZml4KHByZWZpeGVkKTtcbiAgICAgIHJldHVybiBzdHJpcHBlZDtcbiAgICB9LFxuICAgICdKU09OIEZpbGUnOiAoaW5wdXQsIHBhc3N3b3JkKSA9PiB7XG4gICAgICBsZXQgd2FsbGV0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2FsbGV0ID0gaW1wb3J0ZXJzLmZyb21FdGhlcldhbGxldChpbnB1dCwgcGFzc3dvcmQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cuZGVidWcoJ0F0dGVtcHQgdG8gaW1wb3J0IGFzIEV0aGVyV2FsbGV0IGZvcm1hdCBmYWlsZWQsIHRyeWluZyBWMycpO1xuICAgICAgICB3YWxsZXQgPSBXYWxsZXQuZnJvbVYzKGlucHV0LCBwYXNzd29yZCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3YWxsZXRUb1ByaXZhdGVLZXkod2FsbGV0KTtcbiAgICB9LFxuICB9LFxufTtcblxuZnVuY3Rpb24gd2FsbGV0VG9Qcml2YXRlS2V5KHdhbGxldCkge1xuICBjb25zdCBwcml2YXRlS2V5QnVmZmVyID0gd2FsbGV0LmdldFByaXZhdGVLZXkoKTtcbiAgcmV0dXJuIGJ1ZmZlclRvSGV4KHByaXZhdGVLZXlCdWZmZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhY2NvdW50SW1wb3J0ZXI7XG4iLCJleHBvcnQgeyBkZWZhdWx0LCBORVRXT1JLX0VWRU5UUyB9IGZyb20gJy4vbmV0d29yayc7XG4iLCJjb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBldGhVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJyk7XG5jb25zdCBIREtleSA9IHJlcXVpcmUoJ2hka2V5Jyk7XG5jb25zdCBUcmV6b3JDb25uZWN0ID0gcmVxdWlyZSgndHJlem9yLWNvbm5lY3QnKS5kZWZhdWx0O1xuY29uc3QgeyBUcmFuc2FjdGlvbkZhY3RvcnkgfSA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3R4Jyk7XG5cbmNvbnN0IGhkUGF0aFN0cmluZyA9IGBtLzQ0Jy82MCcvMCcvMGA7XG5jb25zdCBTTElQMDA0NFRlc3RuZXRQYXRoID0gYG0vNDQnLzEnLzAnLzBgO1xuXG5jb25zdCBBTExPV0VEX0hEX1BBVEhTID0ge1xuICBbaGRQYXRoU3RyaW5nXTogdHJ1ZSxcbiAgW1NMSVAwMDQ0VGVzdG5ldFBhdGhdOiB0cnVlLFxufTtcblxuY29uc3Qga2V5cmluZ1R5cGUgPSAnVHJlem9yIEhhcmR3YXJlJztcbmNvbnN0IHBhdGhCYXNlID0gJ20nO1xuY29uc3QgTUFYX0lOREVYID0gMTAwMDtcbmNvbnN0IERFTEFZX0JFVFdFRU5fUE9QVVBTID0gMTAwMDtcbmNvbnN0IFRSRVpPUl9DT05ORUNUX01BTklGRVNUID0ge1xuICBlbWFpbDogJ3N1cHBvcnRAbWV0YW1hc2suaW8nLFxuICBhcHBVcmw6ICdodHRwczovL21ldGFtYXNrLmlvJyxcbn07XG5cbmZ1bmN0aW9uIHdhaXQobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge19faW1wb3J0X18oJ0BldGhlcmV1bWpzL3R4JykuVHlwZWRUcmFuc2FjdGlvbn0gVHlwZWRUcmFuc2FjdGlvblxuICogQHR5cGVkZWYge0luc3RhbmNlVHlwZTxfX2ltcG9ydF9fKFwiZXRoZXJldW1qcy10eFwiKT59IE9sZEV0aEpzVHJhbnNhY3Rpb25cbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB0cmFuc2FjdGlvbiBpcyBtYWRlIHdpdGggZXRoZXJldW1qcy10eCBvciBAZXRoZXJldW1qcy90eFxuICpcbiAqIFRyYW5zYWN0aW9ucyBidWlsdCB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIGV0aGVyZXVtanMtdHggaGF2ZSBhXG4gKiBnZXRDaGFpbklkIG1ldGhvZCB0aGF0IG5ld2VyIHZlcnNpb25zIGRvIG5vdC5cbiAqIE9sZGVyIHZlcnNpb25zIGFyZSBtdXRhYmxlXG4gKiB3aGlsZSBuZXdlciB2ZXJzaW9ucyBkZWZhdWx0IHRvIGJlaW5nIGltbXV0YWJsZS5cbiAqIEV4cGVjdGVkIHNoYXBlIGFuZCB0eXBlXG4gKiBvZiBkYXRhIGZvciB2LCByIGFuZCBzIGRpZmZlciAoQnVmZmVyIChvbGQpIHZzIEJOIChuZXcpKS5cbiAqXG4gKiBAcGFyYW0ge1R5cGVkVHJhbnNhY3Rpb24gfCBPbGRFdGhKc1RyYW5zYWN0aW9ufSB0eFxuICogQHJldHVybnMge3R4IGlzIE9sZEV0aEpzVHJhbnNhY3Rpb259IFJldHVybnMgYHRydWVgIGlmIHR4IGlzIGFuIG9sZC1zdHlsZSBldGhlcmV1bWpzLXR4IHRyYW5zYWN0aW9uLlxuICovXG5mdW5jdGlvbiBpc09sZFN0eWxlRXRoZXJldW1qc1R4KHR4KSB7XG4gIHJldHVybiB0eXBlb2YgdHguZ2V0Q2hhaW5JZCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuY2xhc3MgVHJlem9yS2V5cmluZyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50eXBlID0ga2V5cmluZ1R5cGU7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgIHRoaXMuaGRrID0gbmV3IEhES2V5KCk7XG4gICAgdGhpcy5wYWdlID0gMDtcbiAgICB0aGlzLnBlclBhZ2UgPSA1O1xuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gMDtcbiAgICB0aGlzLnBhdGhzID0ge307XG4gICAgdGhpcy5kZXNlcmlhbGl6ZShvcHRzKTtcblxuICAgIFRyZXpvckNvbm5lY3Qub24oJ0RFVklDRV9FVkVOVCcsIChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnBheWxvYWQgJiYgZXZlbnQucGF5bG9hZC5mZWF0dXJlcykge1xuICAgICAgICB0aGlzLm1vZGVsID0gZXZlbnQucGF5bG9hZC5mZWF0dXJlcy5tb2RlbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBUcmV6b3JDb25uZWN0LmluaXQoeyBtYW5pZmVzdDogVFJFWk9SX0NPTk5FQ1RfTUFOSUZFU1QgfSk7XG4gIH1cblxuICBnZXRNb2RlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbDtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgLy8gVGhpcyByZW1vdmVzIHRoZSBUcmV6b3IgQ29ubmVjdCBpZnJhbWUgZnJvbSB0aGUgRE9NXG4gICAgLy8gVGhpcyBtZXRob2QgaXMgbm90IHdlbGwgZG9jdW1lbnRlZCwgYnV0IHRoZSBjb2RlIGl0IGNhbGxzIGNhbiBiZSBzZWVuXG4gICAgLy8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3RyZXpvci9jb25uZWN0L2Jsb2IvZGVjNGE1NmFmOGE2NWE2MDU5ZmI1ZjYzZmEzYzY2OTBkMmMzN2UwMC9zcmMvanMvaWZyYW1lL2J1aWxkZXIuanMjTDE4MVxuICAgIFRyZXpvckNvbm5lY3QuZGlzcG9zZSgpO1xuICB9XG5cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgaGRQYXRoOiB0aGlzLmhkUGF0aCxcbiAgICAgIGFjY291bnRzOiB0aGlzLmFjY291bnRzLFxuICAgICAgcGFnZTogdGhpcy5wYWdlLFxuICAgICAgcGF0aHM6IHRoaXMucGF0aHMsXG4gICAgICBwZXJQYWdlOiB0aGlzLnBlclBhZ2UsXG4gICAgICB1bmxvY2tlZEFjY291bnQ6IHRoaXMudW5sb2NrZWRBY2NvdW50LFxuICAgIH0pO1xuICB9XG5cbiAgZGVzZXJpYWxpemUob3B0cyA9IHt9KSB7XG4gICAgdGhpcy5oZFBhdGggPSBvcHRzLmhkUGF0aCB8fCBoZFBhdGhTdHJpbmc7XG4gICAgdGhpcy5hY2NvdW50cyA9IG9wdHMuYWNjb3VudHMgfHwgW107XG4gICAgdGhpcy5wYWdlID0gb3B0cy5wYWdlIHx8IDA7XG4gICAgdGhpcy5wZXJQYWdlID0gb3B0cy5wZXJQYWdlIHx8IDU7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgaXNVbmxvY2tlZCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmhkayAmJiB0aGlzLmhkay5wdWJsaWNLZXkpO1xuICB9XG5cbiAgdW5sb2NrKCkge1xuICAgIGlmICh0aGlzLmlzVW5sb2NrZWQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnYWxyZWFkeSB1bmxvY2tlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgVHJlem9yQ29ubmVjdC5nZXRQdWJsaWNLZXkoe1xuICAgICAgICBwYXRoOiB0aGlzLmhkUGF0aCxcbiAgICAgICAgY29pbjogJ0VUSCcsXG4gICAgICB9KVxuICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5oZGsucHVibGljS2V5ID0gQnVmZmVyLmZyb20ocmVzcG9uc2UucGF5bG9hZC5wdWJsaWNLZXksICdoZXgnKTtcbiAgICAgICAgICAgIHRoaXMuaGRrLmNoYWluQ29kZSA9IEJ1ZmZlci5mcm9tKHJlc3BvbnNlLnBheWxvYWQuY2hhaW5Db2RlLCAnaGV4Jyk7XG4gICAgICAgICAgICByZXNvbHZlKCdqdXN0IHVubG9ja2VkJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIChyZXNwb25zZS5wYXlsb2FkICYmIHJlc3BvbnNlLnBheWxvYWQuZXJyb3IpIHx8ICdVbmtub3duIGVycm9yJyxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKChlICYmIGUudG9TdHJpbmcoKSkgfHwgJ1Vua25vd24gZXJyb3InKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgc2V0QWNjb3VudFRvVW5sb2NrKGluZGV4KSB7XG4gICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSBwYXJzZUludChpbmRleCwgMTApO1xuICB9XG5cbiAgYWRkQWNjb3VudHMobiA9IDEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy51bmxvY2soKVxuICAgICAgICAudGhlbigoXykgPT4ge1xuICAgICAgICAgIGNvbnN0IGZyb20gPSB0aGlzLnVubG9ja2VkQWNjb3VudDtcbiAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyBuO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWNjb3VudHMuaW5jbHVkZXMoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5hY2NvdW50cy5wdXNoKGFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYWdlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLmFjY291bnRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEZpcnN0UGFnZSgpIHtcbiAgICB0aGlzLnBhZ2UgPSAwO1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgxKTtcbiAgfVxuXG4gIGdldE5leHRQYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgxKTtcbiAgfVxuXG4gIGdldFByZXZpb3VzUGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2dldFBhZ2UoLTEpO1xuICB9XG5cbiAgX19nZXRQYWdlKGluY3JlbWVudCkge1xuICAgIHRoaXMucGFnZSArPSBpbmNyZW1lbnQ7XG5cbiAgICBpZiAodGhpcy5wYWdlIDw9IDApIHtcbiAgICAgIHRoaXMucGFnZSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrKClcbiAgICAgICAgLnRoZW4oKF8pID0+IHtcbiAgICAgICAgICBjb25zdCBmcm9tID0gKHRoaXMucGFnZSAtIDEpICogdGhpcy5wZXJQYWdlO1xuICAgICAgICAgIGNvbnN0IHRvID0gZnJvbSArIHRoaXMucGVyUGFnZTtcblxuICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gW107XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLl9hZGRyZXNzRnJvbUluZGV4KHBhdGhCYXNlLCBpKTtcbiAgICAgICAgICAgIGFjY291bnRzLnB1c2goe1xuICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICBiYWxhbmNlOiBudWxsLFxuICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYXRoc1tldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoYWNjb3VudHMpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0QWNjb3VudHMoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFjY291bnRzLnNsaWNlKCkpO1xuICB9XG5cbiAgcmVtb3ZlQWNjb3VudChhZGRyZXNzKSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMuYWNjb3VudHMubWFwKChhKSA9PiBhLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTtcbiAgICB9XG5cbiAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5maWx0ZXIoXG4gICAgICAoYSkgPT4gYS50b0xvd2VyQ2FzZSgpICE9PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBhIHRyYW5zYWN0aW9uIHVzaW5nIFRyZXpvci5cbiAgICpcbiAgICogQWNjZXB0cyBlaXRoZXIgYW4gZXRoZXJldW1qcy10eCBvciBAZXRoZXJldW1qcy90eCB0cmFuc2FjdGlvbiwgYW5kIHJldHVybnNcbiAgICogdGhlIHNhbWUgdHlwZS5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtUeXBlZFRyYW5zYWN0aW9uIHwgT2xkRXRoSnNUcmFuc2FjdGlvbn0gVHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBIZXggc3RyaW5nIGFkZHJlc3MuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHR4IC0gSW5zdGFuY2Ugb2YgZWl0aGVyIG5ldy1zdHlsZSBvciBvbGQtc3R5bGUgZXRoZXJldW1qcyB0cmFuc2FjdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24+fSBUaGUgc2lnbmVkIHRyYW5zYWN0aW9uLCBhbiBpbnN0YW5jZSBvZiBlaXRoZXIgbmV3LXN0eWxlIG9yIG9sZC1zdHlsZVxuICAgKiBldGhlcmV1bWpzIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgc2lnblRyYW5zYWN0aW9uKGFkZHJlc3MsIHR4KSB7XG4gICAgaWYgKGlzT2xkU3R5bGVFdGhlcmV1bWpzVHgodHgpKSB7XG4gICAgICAvLyBJbiB0aGlzIHZlcnNpb24gb2YgZXRoZXJldW1qcy10eCB3ZSBtdXN0IGFkZCB0aGUgY2hhaW5JZCBpbiBoZXggZm9ybWF0XG4gICAgICAvLyB0byB0aGUgaW5pdGlhbCB2IHZhbHVlLiBUaGUgY2hhaW5JZCBtdXN0IGJlIGluY2x1ZGVkIGluIHRoZSBzZXJpYWxpemVkXG4gICAgICAvLyB0cmFuc2FjdGlvbiB3aGljaCBpcyBvbmx5IGNvbW11bmljYXRlZCB0byBldGhlcmV1bWpzLXR4IGluIHRoaXNcbiAgICAgIC8vIHZhbHVlLiBJbiBuZXdlciB2ZXJzaW9ucyB0aGUgY2hhaW5JZCBpcyBjb21tdW5pY2F0ZWQgdmlhIHRoZSAnQ29tbW9uJ1xuICAgICAgLy8gb2JqZWN0LlxuICAgICAgcmV0dXJuIHRoaXMuX3NpZ25UcmFuc2FjdGlvbihhZGRyZXNzLCB0eC5nZXRDaGFpbklkKCksIHR4LCAocGF5bG9hZCkgPT4ge1xuICAgICAgICB0eC52ID0gQnVmZmVyLmZyb20ocGF5bG9hZC52LCAnaGV4Jyk7XG4gICAgICAgIHR4LnIgPSBCdWZmZXIuZnJvbShwYXlsb2FkLnIsICdoZXgnKTtcbiAgICAgICAgdHgucyA9IEJ1ZmZlci5mcm9tKHBheWxvYWQucywgJ2hleCcpO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NpZ25UcmFuc2FjdGlvbihcbiAgICAgIGFkZHJlc3MsXG4gICAgICB0eC5jb21tb24uY2hhaW5JZEJOKCkudG9OdW1iZXIoKSxcbiAgICAgIHR4LFxuICAgICAgKHBheWxvYWQpID0+IHtcbiAgICAgICAgLy8gQmVjYXVzZSB0eCB3aWxsIGJlIGltbXV0YWJsZSwgZmlyc3QgZ2V0IGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgdGhhdFxuICAgICAgICAvLyByZXByZXNlbnRzIHRoZSB0cmFuc2FjdGlvbi4gVXNpbmcgdHhEYXRhIGhlcmUgYXMgaXQgYWxpZ25zIHdpdGggdGhlXG4gICAgICAgIC8vIG5vbWVuY2xhdHVyZSBvZiBldGhlcmV1bWpzL3R4LlxuICAgICAgICBjb25zdCB0eERhdGEgPSB0eC50b0pTT04oKTtcbiAgICAgICAgLy8gVGhlIGZyb21UeERhdGEgdXRpbGl0eSBleHBlY3RzIGEgdHlwZSB0byBzdXBwb3J0IHRyYW5zYWN0aW9ucyB3aXRoIGEgdHlwZSBvdGhlciB0aGFuIDBcbiAgICAgICAgdHhEYXRhLnR5cGUgPSB0eC50eXBlO1xuICAgICAgICAvLyBUaGUgZnJvbVR4RGF0YSB1dGlsaXR5IGV4cGVjdHMgdixyIGFuZCBzIHRvIGJlIGhleCBwcmVmaXhlZFxuICAgICAgICB0eERhdGEudiA9IGV0aFV0aWwuYWRkSGV4UHJlZml4KHBheWxvYWQudik7XG4gICAgICAgIHR4RGF0YS5yID0gZXRoVXRpbC5hZGRIZXhQcmVmaXgocGF5bG9hZC5yKTtcbiAgICAgICAgdHhEYXRhLnMgPSBldGhVdGlsLmFkZEhleFByZWZpeChwYXlsb2FkLnMpO1xuICAgICAgICAvLyBBZG9wdCB0aGUgJ2NvbW1vbicgb3B0aW9uIGZyb20gdGhlIG9yaWdpbmFsIHRyYW5zYWN0aW9uIGFuZCBzZXQgdGhlXG4gICAgICAgIC8vIHJldHVybmVkIG9iamVjdCB0byBiZSBmcm96ZW4gaWYgdGhlIG9yaWdpbmFsIGlzIGZyb3plbi5cbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4RGF0YSwge1xuICAgICAgICAgIGNvbW1vbjogdHguY29tbW9uLFxuICAgICAgICAgIGZyZWV6ZTogT2JqZWN0LmlzRnJvemVuKHR4KSxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHRlbXBsYXRlIHtUeXBlZFRyYW5zYWN0aW9uIHwgT2xkRXRoSnNUcmFuc2FjdGlvbn0gVHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBIZXggc3RyaW5nIGFkZHJlc3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFpbklkIC0gQ2hhaW4gSURcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHggLSBJbnN0YW5jZSBvZiBlaXRoZXIgbmV3LXN0eWxlIG9yIG9sZC1zdHlsZSBldGhlcmV1bWpzIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0geyhfX2ltcG9ydF9fKCd0cmV6b3ItY29ubmVjdCcpLkV0aGVyZXVtU2lnbmVkVHgpID0+IFRyYW5zYWN0aW9ufSBoYW5kbGVTaWduaW5nIC0gQ29udmVydHMgc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqIHRvIHRoZSBzYW1lIG5ldy1zdHlsZSBvciBvbGQtc3R5bGUgZXRoZXJldW1qcy10eC5cbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24+fSBUaGUgc2lnbmVkIHRyYW5zYWN0aW9uLCBhbiBpbnN0YW5jZSBvZiBlaXRoZXIgbmV3LXN0eWxlIG9yIG9sZC1zdHlsZVxuICAgKiBldGhlcmV1bWpzIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgX3NpZ25UcmFuc2FjdGlvbihhZGRyZXNzLCBjaGFpbklkLCB0eCwgaGFuZGxlU2lnbmluZykge1xuICAgIGxldCB0cmFuc2FjdGlvbjtcbiAgICBpZiAoaXNPbGRTdHlsZUV0aGVyZXVtanNUeCh0eCkpIHtcbiAgICAgIC8vIGxlZ2FjeSB0cmFuc2FjdGlvbiBmcm9tIGV0aGVyZXVtanMtdHggcGFja2FnZSBoYXMgbm8gLnRvSlNPTigpIGZ1bmN0aW9uLFxuICAgICAgLy8gc28gd2UgbmVlZCB0byBjb252ZXJ0IHRvIGhleC1zdHJpbmdzIG1hbnVhbGx5IG1hbnVhbGx5XG4gICAgICB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgdG86IHRoaXMuX25vcm1hbGl6ZSh0eC50byksXG4gICAgICAgIHZhbHVlOiB0aGlzLl9ub3JtYWxpemUodHgudmFsdWUpLFxuICAgICAgICBkYXRhOiB0aGlzLl9ub3JtYWxpemUodHguZGF0YSksXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIG5vbmNlOiB0aGlzLl9ub3JtYWxpemUodHgubm9uY2UpLFxuICAgICAgICBnYXNMaW1pdDogdGhpcy5fbm9ybWFsaXplKHR4Lmdhc0xpbWl0KSxcbiAgICAgICAgZ2FzUHJpY2U6IHRoaXMuX25vcm1hbGl6ZSh0eC5nYXNQcmljZSksXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZXctc3R5bGUgdHJhbnNhY3Rpb24gZnJvbSBAZXRoZXJldW1qcy90eCBwYWNrYWdlXG4gICAgICAvLyB3ZSBjYW4ganVzdCBjb3B5IHR4LnRvSlNPTigpIGZvciBldmVyeXRoaW5nIGV4Y2VwdCBjaGFpbklkLCB3aGljaCBtdXN0IGJlIGEgbnVtYmVyXG4gICAgICB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgLi4udHgudG9KU09OKCksXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHRvOiB0aGlzLl9ub3JtYWxpemUodHgudG8pLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy51bmxvY2soKTtcbiAgICAgIGF3YWl0IHdhaXQoc3RhdHVzID09PSAnanVzdCB1bmxvY2tlZCcgPyBERUxBWV9CRVRXRUVOX1BPUFVQUyA6IDApO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBUcmV6b3JDb25uZWN0LmV0aGVyZXVtU2lnblRyYW5zYWN0aW9uKHtcbiAgICAgICAgcGF0aDogdGhpcy5fcGF0aEZyb21BZGRyZXNzKGFkZHJlc3MpLFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc3QgbmV3T3JNdXRhdGVkVHggPSBoYW5kbGVTaWduaW5nKHJlc3BvbnNlLnBheWxvYWQpO1xuXG4gICAgICAgIGNvbnN0IGFkZHJlc3NTaWduZWRXaXRoID0gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhcbiAgICAgICAgICBldGhVdGlsLmFkZEhleFByZWZpeChcbiAgICAgICAgICAgIG5ld09yTXV0YXRlZFR4LmdldFNlbmRlckFkZHJlc3MoKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY29ycmVjdEFkZHJlc3MgPSBldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBpZiAoYWRkcmVzc1NpZ25lZFdpdGggIT09IGNvcnJlY3RBZGRyZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2lnbmF0dXJlIGRvZXNuJ3QgbWF0Y2ggdGhlIHJpZ2h0IGFkZHJlc3NcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3T3JNdXRhdGVkVHg7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChyZXNwb25zZS5wYXlsb2FkICYmIHJlc3BvbnNlLnBheWxvYWQuZXJyb3IpIHx8ICdVbmtub3duIGVycm9yJyxcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKChlICYmIGUudG9TdHJpbmcoKSkgfHwgJ1Vua25vd24gZXJyb3InKTtcbiAgICB9XG4gIH1cblxuICBzaWduTWVzc2FnZSh3aXRoQWNjb3VudCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2Uod2l0aEFjY291bnQsIGRhdGEpO1xuICB9XG5cbiAgLy8gRm9yIHBlcnNvbmFsX3NpZ24sIHdlIG5lZWQgdG8gcHJlZml4IHRoZSBtZXNzYWdlOlxuICBzaWduUGVyc29uYWxNZXNzYWdlKHdpdGhBY2NvdW50LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrKClcbiAgICAgICAgLnRoZW4oKHN0YXR1cykgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAoXykgPT4ge1xuICAgICAgICAgICAgICBUcmV6b3JDb25uZWN0LmV0aGVyZXVtU2lnbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyh3aXRoQWNjb3VudCksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXRoVXRpbC5zdHJpcEhleFByZWZpeChtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICBoZXg6IHRydWUsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGF5bG9hZC5hZGRyZXNzICE9PVxuICAgICAgICAgICAgICAgICAgICAgIGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3Mod2l0aEFjY291bnQpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcignc2lnbmF0dXJlIGRvZXNudCBtYXRjaCB0aGUgcmlnaHQgYWRkcmVzcycpLFxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYDB4JHtyZXNwb25zZS5wYXlsb2FkLnNpZ25hdHVyZX1gO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlLnBheWxvYWQgJiYgcmVzcG9uc2UucGF5bG9hZC5lcnJvcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1Vua25vd24gZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoKGUgJiYgZS50b1N0cmluZygpKSB8fCAnVW5rbm93biBlcnJvcicpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gYXZvaWQgcG9wdXAgY29sbGlzaW9uXG4gICAgICAgICAgICAgIC8vIGJldHdlZW4gdGhlIHVubG9jayAmIHNpZ24gdHJlem9yIHBvcHVwc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXR1cyA9PT0gJ2p1c3QgdW5sb2NrZWQnID8gREVMQVlfQkVUV0VFTl9QT1BVUFMgOiAwLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoKGUgJiYgZS50b1N0cmluZygpKSB8fCAnVW5rbm93biBlcnJvcicpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBzaWduVHlwZWREYXRhKCkge1xuICAgIC8vIFdhaXRpbmcgb24gdHJlem9yIHRvIGVuYWJsZSB0aGlzXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpKTtcbiAgfVxuXG4gIGV4cG9ydEFjY291bnQoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpKTtcbiAgfVxuXG4gIGZvcmdldERldmljZSgpIHtcbiAgICB0aGlzLmFjY291bnRzID0gW107XG4gICAgdGhpcy5oZGsgPSBuZXcgSERLZXkoKTtcbiAgICB0aGlzLnBhZ2UgPSAwO1xuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gMDtcbiAgICB0aGlzLnBhdGhzID0ge307XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBIRCBwYXRoIHRvIGJlIHVzZWQgYnkgdGhlIGtleXJpbmcuIE9ubHkga25vd24gc3VwcG9ydGVkIEhEIHBhdGhzIGFyZSBhbGxvd2VkLlxuICAgKlxuICAgKiBJZiB0aGUgZ2l2ZW4gSEQgcGF0aCBpcyBhbHJlYWR5IHRoZSBjdXJyZW50IEhEIHBhdGgsIG5vdGhpbmcgaGFwcGVucy4gT3RoZXJ3aXNlIHRoZSBuZXcgSERcbiAgICogcGF0aCBpcyBzZXQsIGFuZCB0aGUgd2FsbGV0IHN0YXRlIGlzIGNvbXBsZXRlbHkgcmVzZXQuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yXSBUaHJvd3MgaWYgdGhlIEhEIHBhdGggaXMgbm90IHN1cHBvcnRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhkUGF0aCAtIFRoZSBIRCBwYXRoIHRvIHNldC5cbiAgICovXG4gIHNldEhkUGF0aChoZFBhdGgpIHtcbiAgICBpZiAoIUFMTE9XRURfSERfUEFUSFNbaGRQYXRoXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIHNldEhkUGF0aCBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBzZXR0aW5nIEhEIFBhdGggdG8gJHtoZFBhdGh9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgSERLZXkgaWYgdGhlIHBhdGggY2hhbmdlc1xuICAgIGlmICh0aGlzLmhkUGF0aCAhPT0gaGRQYXRoKSB7XG4gICAgICB0aGlzLmhkayA9IG5ldyBIREtleSgpO1xuICAgICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgICAgdGhpcy5wYWdlID0gMDtcbiAgICAgIHRoaXMucGVyUGFnZSA9IDU7XG4gICAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IDA7XG4gICAgICB0aGlzLnBhdGhzID0ge307XG4gICAgfVxuICAgIHRoaXMuaGRQYXRoID0gaGRQYXRoO1xuICB9XG5cbiAgLyogUFJJVkFURSBNRVRIT0RTICovXG5cbiAgX25vcm1hbGl6ZShidWYpIHtcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleChidWYpLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG4gIF9hZGRyZXNzRnJvbUluZGV4KHBhdGhCYXNlLCBpKSB7XG4gICAgY29uc3QgZGtleSA9IHRoaXMuaGRrLmRlcml2ZShgJHtwYXRoQmFzZX0vJHtpfWApO1xuICAgIGNvbnN0IGFkZHJlc3MgPSBldGhVdGlsXG4gICAgICAucHVibGljVG9BZGRyZXNzKGRrZXkucHVibGljS2V5LCB0cnVlKVxuICAgICAgLnRvU3RyaW5nKCdoZXgnKTtcbiAgICByZXR1cm4gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhgMHgke2FkZHJlc3N9YCk7XG4gIH1cblxuICBfcGF0aEZyb21BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBjb25zdCBjaGVja3N1bW1lZEFkZHJlc3MgPSBldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgIGxldCBpbmRleCA9IHRoaXMucGF0aHNbY2hlY2tzdW1tZWRBZGRyZXNzXTtcbiAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfSU5ERVg7IGkrKykge1xuICAgICAgICBpZiAoY2hlY2tzdW1tZWRBZGRyZXNzID09PSB0aGlzLl9hZGRyZXNzRnJvbUluZGV4KHBhdGhCYXNlLCBpKSkge1xuICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYWRkcmVzcycpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dGhpcy5oZFBhdGh9LyR7aW5kZXh9YDtcbiAgfVxufVxuXG5UcmV6b3JLZXlyaW5nLnR5cGUgPSBrZXlyaW5nVHlwZTtcbm1vZHVsZS5leHBvcnRzID0gVHJlem9yS2V5cmluZztcbiIsImNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgSERLZXkgPSByZXF1aXJlKCdoZGtleScpXG5jb25zdCBldGhVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJylcbmNvbnN0IHNpZ1V0aWwgPSByZXF1aXJlKCdldGgtc2lnLXV0aWwnKVxuY29uc3QgeyBUcmFuc2FjdGlvbkZhY3RvcnkgfSA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3R4JylcblxuY29uc3QgcGF0aEJhc2UgPSAnbSdcbmNvbnN0IGhkUGF0aFN0cmluZyA9IGAke3BhdGhCYXNlfS80NCcvNjAnLzAnYFxuY29uc3QgdHlwZSA9ICdMZWRnZXIgSGFyZHdhcmUnXG5cbmNvbnN0IEJSSURHRV9VUkwgPSAnaHR0cHM6Ly9tZXRhbWFzay5naXRodWIuaW8vZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZydcblxuY29uc3QgTUFYX0lOREVYID0gMTAwMFxuY29uc3QgTkVUV09SS19BUElfVVJMUyA9IHtcbiAgcm9wc3RlbjogJ2h0dHA6Ly9hcGktcm9wc3Rlbi5ldGhlcnNjYW4uaW8nLFxuICBrb3ZhbjogJ2h0dHA6Ly9hcGkta292YW4uZXRoZXJzY2FuLmlvJyxcbiAgcmlua2VieTogJ2h0dHBzOi8vYXBpLXJpbmtlYnkuZXRoZXJzY2FuLmlvJyxcbiAgbWFpbm5ldDogJ2h0dHBzOi8vYXBpLmV0aGVyc2Nhbi5pbycsXG59XG5cbmNsYXNzIExlZGdlckJyaWRnZUtleXJpbmcgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuYWNjb3VudERldGFpbHMgPSB7fVxuICAgIHRoaXMuYnJpZGdlVXJsID0gbnVsbFxuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICB0aGlzLnBhZ2UgPSAwXG4gICAgdGhpcy5wZXJQYWdlID0gNVxuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gMFxuICAgIHRoaXMuaGRrID0gbmV3IEhES2V5KClcbiAgICB0aGlzLnBhdGhzID0ge31cbiAgICB0aGlzLmlmcmFtZSA9IG51bGxcbiAgICB0aGlzLm5ldHdvcmsgPSAnbWFpbm5ldCdcbiAgICB0aGlzLmltcGxlbWVudEZ1bGxCSVA0NCA9IGZhbHNlXG4gICAgdGhpcy5kZXNlcmlhbGl6ZShvcHRzKVxuXG4gICAgdGhpcy5pZnJhbWVMb2FkZWQgPSBmYWxzZVxuICAgIHRoaXMuX3NldHVwSWZyYW1lKClcbiAgfVxuXG4gIHNlcmlhbGl6ZSAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBoZFBhdGg6IHRoaXMuaGRQYXRoLFxuICAgICAgYWNjb3VudHM6IHRoaXMuYWNjb3VudHMsXG4gICAgICBhY2NvdW50RGV0YWlsczogdGhpcy5hY2NvdW50RGV0YWlscyxcbiAgICAgIGJyaWRnZVVybDogdGhpcy5icmlkZ2VVcmwsXG4gICAgICBpbXBsZW1lbnRGdWxsQklQNDQ6IGZhbHNlLFxuICAgIH0pXG4gIH1cblxuICBkZXNlcmlhbGl6ZSAob3B0cyA9IHt9KSB7XG4gICAgdGhpcy5oZFBhdGggPSBvcHRzLmhkUGF0aCB8fCBoZFBhdGhTdHJpbmdcbiAgICB0aGlzLmJyaWRnZVVybCA9IG9wdHMuYnJpZGdlVXJsIHx8IEJSSURHRV9VUkxcbiAgICB0aGlzLmFjY291bnRzID0gb3B0cy5hY2NvdW50cyB8fCBbXVxuICAgIHRoaXMuYWNjb3VudERldGFpbHMgPSBvcHRzLmFjY291bnREZXRhaWxzIHx8IHt9XG4gICAgaWYgKCFvcHRzLmFjY291bnREZXRhaWxzKSB7XG4gICAgICB0aGlzLl9taWdyYXRlQWNjb3VudERldGFpbHMob3B0cylcbiAgICB9XG5cbiAgICB0aGlzLmltcGxlbWVudEZ1bGxCSVA0NCA9IG9wdHMuaW1wbGVtZW50RnVsbEJJUDQ0IHx8IGZhbHNlXG5cbiAgICAvLyBSZW1vdmUgYWNjb3VudHMgdGhhdCBkb24ndCBoYXZlIGNvcnJlc3BvbmRpbmcgYWNjb3VudCBkZXRhaWxzXG4gICAgdGhpcy5hY2NvdW50cyA9IHRoaXMuYWNjb3VudHNcbiAgICAgIC5maWx0ZXIoKGFjY291bnQpID0+IE9iamVjdC5rZXlzKHRoaXMuYWNjb3VudERldGFpbHMpLmluY2x1ZGVzKGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWNjb3VudCkpKVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICBfbWlncmF0ZUFjY291bnREZXRhaWxzIChvcHRzKSB7XG4gICAgaWYgKHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpICYmIG9wdHMuYWNjb3VudEluZGV4ZXMpIHtcbiAgICAgIGZvciAoY29uc3QgYWNjb3VudCBvZiBPYmplY3Qua2V5cyhvcHRzLmFjY291bnRJbmRleGVzKSkge1xuICAgICAgICB0aGlzLmFjY291bnREZXRhaWxzW2FjY291bnRdID0ge1xuICAgICAgICAgIGJpcDQ0OiB0cnVlLFxuICAgICAgICAgIGhkUGF0aDogdGhpcy5fZ2V0UGF0aEZvckluZGV4KG9wdHMuYWNjb3VudEluZGV4ZXNbYWNjb3VudF0pLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHJ5IHRvIG1pZ3JhdGUgbm9uLUxlZGdlckxpdmUgYWNjb3VudHMgdG9vXG4gICAgaWYgKCF0aGlzLl9pc0xlZGdlckxpdmVIZFBhdGgoKSkge1xuICAgICAgdGhpcy5hY2NvdW50c1xuICAgICAgICAuZmlsdGVyKChhY2NvdW50KSA9PiAhT2JqZWN0LmtleXModGhpcy5hY2NvdW50RGV0YWlscykuaW5jbHVkZXMoZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhY2NvdW50KSkpXG4gICAgICAgIC5mb3JFYWNoKChhY2NvdW50KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYWNjb3VudERldGFpbHNbZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhY2NvdW50KV0gPSB7XG4gICAgICAgICAgICAgIGJpcDQ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgaGRQYXRoOiB0aGlzLl9wYXRoRnJvbUFkZHJlc3MoYWNjb3VudCksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYGZhaWxlZCB0byBtaWdyYXRlIGFjY291bnQgJHthY2NvdW50fWApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlzVW5sb2NrZWQgKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuaGRrICYmIHRoaXMuaGRrLnB1YmxpY0tleSlcbiAgfVxuXG4gIHNldEFjY291bnRUb1VubG9jayAoaW5kZXgpIHtcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IHBhcnNlSW50KGluZGV4LCAxMClcbiAgfVxuXG4gIHNldEhkUGF0aCAoaGRQYXRoKSB7XG4gICAgLy8gUmVzZXQgSERLZXkgaWYgdGhlIHBhdGggY2hhbmdlc1xuICAgIGlmICh0aGlzLmhkUGF0aCAhPT0gaGRQYXRoKSB7XG4gICAgICB0aGlzLmhkayA9IG5ldyBIREtleSgpXG4gICAgfVxuICAgIHRoaXMuaGRQYXRoID0gaGRQYXRoXG4gIH1cblxuICB1bmxvY2sgKGhkUGF0aCkge1xuICAgIGlmICh0aGlzLmlzVW5sb2NrZWQoKSAmJiAhaGRQYXRoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdhbHJlYWR5IHVubG9ja2VkJylcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGhkUGF0aCA/IHRoaXMuX3RvTGVkZ2VyUGF0aChoZFBhdGgpIDogdGhpcy5oZFBhdGhcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBhY3Rpb246ICdsZWRnZXItdW5sb2NrJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgaGRQYXRoOiBwYXRoLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgICh7IHN1Y2Nlc3MsIHBheWxvYWQgfSkgPT4ge1xuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIHRoaXMuaGRrLnB1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKHBheWxvYWQucHVibGljS2V5LCAnaGV4JylcbiAgICAgICAgICB0aGlzLmhkay5jaGFpbkNvZGUgPSBCdWZmZXIuZnJvbShwYXlsb2FkLmNoYWluQ29kZSwgJ2hleCcpXG4gICAgICAgICAgcmVzb2x2ZShwYXlsb2FkLmFkZHJlc3MpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdVbmtub3duIGVycm9yJykpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGFkZEFjY291bnRzIChuID0gMSkge1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrKClcbiAgICAgICAgLnRoZW4oYXN5bmMgKF8pID0+IHtcbiAgICAgICAgICBjb25zdCBmcm9tID0gdGhpcy51bmxvY2tlZEFjY291bnRcbiAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyBuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5fZ2V0UGF0aEZvckluZGV4KGkpXG4gICAgICAgICAgICBsZXQgYWRkcmVzc1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpKSB7XG4gICAgICAgICAgICAgIGFkZHJlc3MgPSBhd2FpdCB0aGlzLnVubG9jayhwYXRoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFjY291bnREZXRhaWxzW2V0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldID0ge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBjb25zaWRlciByZW5hbWluZyB0aGlzIHByb3BlcnR5LCBhcyB0aGUgY3VycmVudCBuYW1lIGlzIG1pc2xlYWRpbmdcbiAgICAgICAgICAgICAgLy8gSXQncyBjdXJyZW50bHkgdXNlZCB0byByZXByZXNlbnQgd2hldGhlciBhbiBhY2NvdW50IHVzZXMgdGhlIExlZGdlciBMaXZlIHBhdGguXG4gICAgICAgICAgICAgIGJpcDQ0OiB0aGlzLl9pc0xlZGdlckxpdmVIZFBhdGgoKSxcbiAgICAgICAgICAgICAgaGRQYXRoOiBwYXRoLFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWNjb3VudHMuaW5jbHVkZXMoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5hY2NvdW50cy5wdXNoKGFkZHJlc3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhZ2UgPSAwXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUodGhpcy5hY2NvdW50cylcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICB9KVxuICB9XG5cbiAgZ2V0Rmlyc3RQYWdlICgpIHtcbiAgICB0aGlzLnBhZ2UgPSAwXG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpXG4gIH1cblxuICBnZXROZXh0UGFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpXG4gIH1cblxuICBnZXRQcmV2aW91c1BhZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgtMSlcbiAgfVxuXG4gIGdldEFjY291bnRzICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWNjb3VudHMuc2xpY2UoKSlcbiAgfVxuXG4gIHJlbW92ZUFjY291bnQgKGFkZHJlc3MpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudHMubWFwKChhKSA9PiBhLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKVxuICAgIH1cbiAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5maWx0ZXIoKGEpID0+IGEudG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKVxuICAgIGRlbGV0ZSB0aGlzLmFjY291bnREZXRhaWxzW2V0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldXG4gIH1cblxuICBhdHRlbXB0TWFrZUFwcCAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgYWN0aW9uOiAnbGVkZ2VyLW1ha2UtYXBwJyxcbiAgICAgIH0sICh7IHN1Y2Nlc3MsIGVycm9yIH0pID0+IHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB1cGRhdGVUcmFuc3BvcnRNZXRob2QgKHRyYW5zcG9ydFR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gSWYgdGhlIGlmcmFtZSBpc24ndCBsb2FkZWQgeWV0LCBsZXQncyBzdG9yZSB0aGUgZGVzaXJlZCB0cmFuc3BvcnRUeXBlIHZhbHVlIGFuZFxuICAgICAgLy8gb3B0aW1pc3RpY2FsbHkgcmV0dXJuIGEgc3VjY2Vzc2Z1bCBwcm9taXNlXG4gICAgICBpZiAoIXRoaXMuaWZyYW1lTG9hZGVkKSB7XG4gICAgICAgIHRoaXMuZGVsYXllZFByb21pc2UgPSB7XG4gICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgdHJhbnNwb3J0VHlwZSxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBhY3Rpb246ICdsZWRnZXItdXBkYXRlLXRyYW5zcG9ydCcsXG4gICAgICAgIHBhcmFtczogeyB0cmFuc3BvcnRUeXBlIH0sXG4gICAgICB9LCAoeyBzdWNjZXNzIH0pID0+IHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTGVkZ2VyIHRyYW5zcG9ydCBjb3VsZCBub3QgYmUgdXBkYXRlZCcpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyB0eCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgZXRoZXJldW1qcy10cmFuc2FjdGlvbiBjbGFzcy5cbiAgc2lnblRyYW5zYWN0aW9uIChhZGRyZXNzLCB0eCkge1xuICAgIGxldCByYXdUeEhleFxuICAgIC8vIHRyYW5zYWN0aW9ucyBidWlsdCB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIGV0aGVyZXVtanMtdHggaGF2ZSBhXG4gICAgLy8gZ2V0Q2hhaW5JZCBtZXRob2QgdGhhdCBuZXdlciB2ZXJzaW9ucyBkbyBub3QuIE9sZGVyIHZlcnNpb25zIGFyZSBtdXRhYmxlXG4gICAgLy8gd2hpbGUgbmV3ZXIgdmVyc2lvbnMgZGVmYXVsdCB0byBiZWluZyBpbW11dGFibGUuIEV4cGVjdGVkIHNoYXBlIGFuZCB0eXBlXG4gICAgLy8gb2YgZGF0YSBmb3IgdiwgciBhbmQgcyBkaWZmZXIgKEJ1ZmZlciAob2xkKSB2cyBCTiAobmV3KSlcbiAgICBpZiAodHlwZW9mIHR4LmdldENoYWluSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEluIHRoaXMgdmVyc2lvbiBvZiBldGhlcmV1bWpzLXR4IHdlIG11c3QgYWRkIHRoZSBjaGFpbklkIGluIGhleCBmb3JtYXRcbiAgICAgIC8vIHRvIHRoZSBpbml0aWFsIHYgdmFsdWUuIFRoZSBjaGFpbklkIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIHNlcmlhbGl6ZWRcbiAgICAgIC8vIHRyYW5zYWN0aW9uIHdoaWNoIGlzIG9ubHkgY29tbXVuaWNhdGVkIHRvIGV0aGVyZXVtanMtdHggaW4gdGhpc1xuICAgICAgLy8gdmFsdWUuIEluIG5ld2VyIHZlcnNpb25zIHRoZSBjaGFpbklkIGlzIGNvbW11bmljYXRlZCB2aWEgdGhlICdDb21tb24nXG4gICAgICAvLyBvYmplY3QuXG4gICAgICB0eC52ID0gZXRoVXRpbC5idWZmZXJUb0hleCh0eC5nZXRDaGFpbklkKCkpXG4gICAgICB0eC5yID0gJzB4MDAnXG4gICAgICB0eC5zID0gJzB4MDAnXG5cbiAgICAgIHJhd1R4SGV4ID0gdHguc2VyaWFsaXplKCkudG9TdHJpbmcoJ2hleCcpXG5cbiAgICAgIHJldHVybiB0aGlzLl9zaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgcmF3VHhIZXgsIChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHR4LnYgPSBCdWZmZXIuZnJvbShwYXlsb2FkLnYsICdoZXgnKVxuICAgICAgICB0eC5yID0gQnVmZmVyLmZyb20ocGF5bG9hZC5yLCAnaGV4JylcbiAgICAgICAgdHgucyA9IEJ1ZmZlci5mcm9tKHBheWxvYWQucywgJ2hleCcpXG4gICAgICAgIHJldHVybiB0eFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBUaGUgYmVsb3cgYGVuY29kZWAgY2FsbCBpcyBvbmx5IG5lY2Vzc2FyeSBmb3IgbGVnYWN5IHRyYW5zYWN0aW9ucywgYXMgYGdldE1lc3NhZ2VUb1NpZ25gXG4gICAgLy8gY2FsbHMgYHJscC5lbmNvZGVgIGludGVybmFsbHkgZm9yIG5vbi1sZWdhY3kgdHJhbnNhY3Rpb25zLiBBcyBwZXIgdGhlIFwiVHJhbnNhY3Rpb24gRXhlY3V0aW9uXCJcbiAgICAvLyBzZWN0aW9uIG9mIHRoZSBldGhlcmV1bSB5ZWxsb3cgcGFwZXIsIHRyYW5zYWN0aW9ucyBuZWVkIHRvIGJlIFwid2VsbC1mb3JtZWQgUkxQLCB3aXRoIG5vIGFkZGl0aW9uYWxcbiAgICAvLyB0cmFpbGluZyBieXRlc1wiLlxuXG4gICAgLy8gTm90ZSBhbHNvIHRoYXQgYGdldE1lc3NhZ2VUb1NpZ25gIHdpbGwgcmV0dXJuIHZhbGlkIFJMUCBmb3IgYWxsIHRyYW5zYWN0aW9uIHR5cGVzLCB3aGVyZWFzIHRoZVxuICAgIC8vIGBzZXJpYWxpemVgIG1ldGhvZCB3aWxsIG5vdCBmb3IgYW55IHRyYW5zYWN0aW9uIHR5cGUgZXhjZXB0IGxlZ2FjeS4gVGhpcyBpcyBiZWNhdXNlIGBzZXJpYWxpemVgIGluY2x1ZGVzXG4gICAgLy8gZW1wdHkgciwgcyBhbmQgdiB2YWx1ZXMgaW4gdGhlIGVuY29kZWQgcmxwLiBUaGlzIGlzIHdoeSB3ZSB1c2UgYGdldE1lc3NhZ2VUb1NpZ25gIGhlcmUgaW5zdGVhZCBvZiBgc2VyaWFsaXplYC5cbiAgICBjb25zdCBtZXNzYWdlVG9TaWduID0gdHguZ2V0TWVzc2FnZVRvU2lnbihmYWxzZSlcblxuICAgIHJhd1R4SGV4ID0gQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2VUb1NpZ24pXG4gICAgICA/IG1lc3NhZ2VUb1NpZ24udG9TdHJpbmcoJ2hleCcpXG4gICAgICA6IGV0aFV0aWwucmxwLmVuY29kZShtZXNzYWdlVG9TaWduKS50b1N0cmluZygnaGV4JylcblxuICAgIHJldHVybiB0aGlzLl9zaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgcmF3VHhIZXgsIChwYXlsb2FkKSA9PiB7XG4gICAgICAvLyBCZWNhdXNlIHR4IHdpbGwgYmUgaW1tdXRhYmxlLCBmaXJzdCBnZXQgYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCB0aGF0XG4gICAgICAvLyByZXByZXNlbnRzIHRoZSB0cmFuc2FjdGlvbi4gVXNpbmcgdHhEYXRhIGhlcmUgYXMgaXQgYWxpZ25zIHdpdGggdGhlXG4gICAgICAvLyBub21lbmNsYXR1cmUgb2YgZXRoZXJldW1qcy90eC5cbiAgICAgIGNvbnN0IHR4RGF0YSA9IHR4LnRvSlNPTigpXG4gICAgICAvLyBUaGUgZnJvbVR4RGF0YSB1dGlsaXR5IGV4cGVjdHMgYSB0eXBlIHRvIHN1cHBvcnQgdHJhbnNhY3Rpb25zIHdpdGggYSB0eXBlIG90aGVyIHRoYW4gMFxuICAgICAgdHhEYXRhLnR5cGUgPSB0eC50eXBlXG4gICAgICAvLyBUaGUgZnJvbVR4RGF0YSB1dGlsaXR5IGV4cGVjdHMgdixyIGFuZCBzIHRvIGJlIGhleCBwcmVmaXhlZFxuICAgICAgdHhEYXRhLnYgPSBldGhVdGlsLmFkZEhleFByZWZpeChwYXlsb2FkLnYpXG4gICAgICB0eERhdGEuciA9IGV0aFV0aWwuYWRkSGV4UHJlZml4KHBheWxvYWQucilcbiAgICAgIHR4RGF0YS5zID0gZXRoVXRpbC5hZGRIZXhQcmVmaXgocGF5bG9hZC5zKVxuICAgICAgLy8gQWRvcHQgdGhlICdjb21tb24nIG9wdGlvbiBmcm9tIHRoZSBvcmlnaW5hbCB0cmFuc2FjdGlvbiBhbmQgc2V0IHRoZVxuICAgICAgLy8gcmV0dXJuZWQgb2JqZWN0IHRvIGJlIGZyb3plbiBpZiB0aGUgb3JpZ2luYWwgaXMgZnJvemVuLlxuICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4RGF0YSwgeyBjb21tb246IHR4LmNvbW1vbiwgZnJlZXplOiBPYmplY3QuaXNGcm96ZW4odHgpIH0pXG4gICAgfSlcbiAgfVxuXG4gIF9zaWduVHJhbnNhY3Rpb24gKGFkZHJlc3MsIHJhd1R4SGV4LCBoYW5kbGVTaWduaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrQWNjb3VudEJ5QWRkcmVzcyhhZGRyZXNzKVxuICAgICAgICAudGhlbigoaGRQYXRoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWN0aW9uOiAnbGVkZ2VyLXNpZ24tdHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIHR4OiByYXdUeEhleCxcbiAgICAgICAgICAgICAgaGRQYXRoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgICh7IHN1Y2Nlc3MsIHBheWxvYWQgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcblxuICAgICAgICAgICAgICBjb25zdCBuZXdPck11dGF0ZWRUeCA9IGhhbmRsZVNpZ25pbmcocGF5bG9hZClcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBuZXdPck11dGF0ZWRUeC52ZXJpZnlTaWduYXR1cmUoKVxuICAgICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ld09yTXV0YXRlZFR4KVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0xlZGdlcjogVGhlIHRyYW5zYWN0aW9uIHNpZ25hdHVyZSBpcyBub3QgdmFsaWQnKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdMZWRnZXI6IFVua25vd24gZXJyb3Igd2hpbGUgc2lnbmluZyB0cmFuc2FjdGlvbicpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgfSlcbiAgfVxuXG4gIHNpZ25NZXNzYWdlICh3aXRoQWNjb3VudCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2Uod2l0aEFjY291bnQsIGRhdGEpXG4gIH1cblxuICAvLyBGb3IgcGVyc29uYWxfc2lnbiwgd2UgbmVlZCB0byBwcmVmaXggdGhlIG1lc3NhZ2U6XG4gIHNpZ25QZXJzb25hbE1lc3NhZ2UgKHdpdGhBY2NvdW50LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrQWNjb3VudEJ5QWRkcmVzcyh3aXRoQWNjb3VudClcbiAgICAgICAgLnRoZW4oKGhkUGF0aCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIGFjdGlvbjogJ2xlZGdlci1zaWduLXBlcnNvbmFsLW1lc3NhZ2UnLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIGhkUGF0aCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogZXRoVXRpbC5zdHJpcEhleFByZWZpeChtZXNzYWdlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICAoeyBzdWNjZXNzLCBwYXlsb2FkIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgIGxldCB2ID0gcGF5bG9hZC52IC0gMjdcbiAgICAgICAgICAgICAgdiA9IHYudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgIGlmICh2Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICB2ID0gYDAke3Z9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGAweCR7cGF5bG9hZC5yfSR7cGF5bG9hZC5zfSR7dn1gXG4gICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NTaWduZWRXaXRoID0gc2lnVXRpbC5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUoeyBkYXRhOiBtZXNzYWdlLCBzaWc6IHNpZ25hdHVyZSB9KVxuICAgICAgICAgICAgICBpZiAoZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzU2lnbmVkV2l0aCkgIT09IGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3Mod2l0aEFjY291bnQpKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTGVkZ2VyOiBUaGUgc2lnbmF0dXJlIGRvZXNudCBtYXRjaCB0aGUgcmlnaHQgYWRkcmVzcycpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUoc2lnbmF0dXJlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdMZWRnZXI6IFVua25vd24gZXJyb3Igd2hpbGUgc2lnbmluZyBtZXNzYWdlJykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgdW5sb2NrQWNjb3VudEJ5QWRkcmVzcyAoYWRkcmVzcykge1xuICAgIGNvbnN0IGNoZWNrc3VtbWVkQWRkcmVzcyA9IGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcylcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuYWNjb3VudERldGFpbHMpLmluY2x1ZGVzKGNoZWNrc3VtbWVkQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGVkZ2VyOiBBY2NvdW50IGZvciBhZGRyZXNzICcke2NoZWNrc3VtbWVkQWRkcmVzc30nIG5vdCBmb3VuZGApXG4gICAgfVxuICAgIGNvbnN0IHsgaGRQYXRoIH0gPSB0aGlzLmFjY291bnREZXRhaWxzW2NoZWNrc3VtbWVkQWRkcmVzc11cbiAgICBjb25zdCB1bmxvY2tlZEFkZHJlc3MgPSBhd2FpdCB0aGlzLnVubG9jayhoZFBhdGgpXG5cbiAgICAvLyB1bmxvY2sgcmVzb2x2ZXMgdG8gdGhlIGFkZHJlc3MgZm9yIHRoZSBnaXZlbiBoZFBhdGggYXMgcmVwb3J0ZWQgYnkgdGhlIGxlZGdlciBkZXZpY2VcbiAgICAvLyBpZiB0aGF0IGFkZHJlc3MgaXMgbm90IHRoZSByZXF1ZXN0ZWQgYWRkcmVzcywgdGhlbiB0aGlzIGFjY291bnQgYmVsb25ncyB0byBhIGRpZmZlcmVudCBkZXZpY2Ugb3Igc2VlZFxuICAgIGlmICh1bmxvY2tlZEFkZHJlc3MudG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExlZGdlcjogQWNjb3VudCAke2FkZHJlc3N9IGRvZXMgbm90IGJlbG9uZyB0byB0aGUgY29ubmVjdGVkIGRldmljZWApXG4gICAgfVxuICAgIHJldHVybiBoZFBhdGhcbiAgfVxuXG4gIGFzeW5jIHNpZ25UeXBlZERhdGEgKHdpdGhBY2NvdW50LCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBpc1Y0ID0gb3B0aW9ucy52ZXJzaW9uID09PSAnVjQnXG4gICAgaWYgKCFpc1Y0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlZGdlcjogT25seSB2ZXJzaW9uIDQgb2YgdHlwZWQgZGF0YSBzaWduaW5nIGlzIHN1cHBvcnRlZCcpXG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgZG9tYWluLFxuICAgICAgdHlwZXMsXG4gICAgICBwcmltYXJ5VHlwZSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgfSA9IHNpZ1V0aWwuVHlwZWREYXRhVXRpbHMuc2FuaXRpemVEYXRhKGRhdGEpXG4gICAgY29uc3QgZG9tYWluU2VwYXJhdG9ySGV4ID0gc2lnVXRpbC5UeXBlZERhdGFVdGlscy5oYXNoU3RydWN0KCdFSVA3MTJEb21haW4nLCBkb21haW4sIHR5cGVzLCBpc1Y0KS50b1N0cmluZygnaGV4JylcbiAgICBjb25zdCBoYXNoU3RydWN0TWVzc2FnZUhleCA9IHNpZ1V0aWwuVHlwZWREYXRhVXRpbHMuaGFzaFN0cnVjdChwcmltYXJ5VHlwZSwgbWVzc2FnZSwgdHlwZXMsIGlzVjQpLnRvU3RyaW5nKCdoZXgnKVxuXG4gICAgY29uc3QgaGRQYXRoID0gYXdhaXQgdGhpcy51bmxvY2tBY2NvdW50QnlBZGRyZXNzKHdpdGhBY2NvdW50KVxuICAgIGNvbnN0IHsgc3VjY2VzcywgcGF5bG9hZCB9ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgYWN0aW9uOiAnbGVkZ2VyLXNpZ24tdHlwZWQtZGF0YScsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGhkUGF0aCxcbiAgICAgICAgICBkb21haW5TZXBhcmF0b3JIZXgsXG4gICAgICAgICAgaGFzaFN0cnVjdE1lc3NhZ2VIZXgsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgKHJlc3VsdCkgPT4gcmVzb2x2ZShyZXN1bHQpKVxuICAgIH0pXG5cbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgbGV0IHYgPSBwYXlsb2FkLnYgLSAyN1xuICAgICAgdiA9IHYudG9TdHJpbmcoMTYpXG4gICAgICBpZiAodi5sZW5ndGggPCAyKSB7XG4gICAgICAgIHYgPSBgMCR7dn1gXG4gICAgICB9XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBgMHgke3BheWxvYWQucn0ke3BheWxvYWQuc30ke3Z9YFxuICAgICAgY29uc3QgYWRkcmVzc1NpZ25lZFdpdGggPSBzaWdVdGlsLnJlY292ZXJUeXBlZFNpZ25hdHVyZV92NCh7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNpZzogc2lnbmF0dXJlLFxuICAgICAgfSlcbiAgICAgIGlmIChldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3NTaWduZWRXaXRoKSAhPT0gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyh3aXRoQWNjb3VudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWRnZXI6IFRoZSBzaWduYXR1cmUgZG9lc250IG1hdGNoIHRoZSByaWdodCBhZGRyZXNzJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaWduYXR1cmVcbiAgICB9XG4gICAgdGhyb3cgcGF5bG9hZC5lcnJvciB8fCBuZXcgRXJyb3IoJ0xlZGdlcjogVW5rbm93biBlcnJvciB3aGlsZSBzaWduaW5nIG1lc3NhZ2UnKVxuICB9XG5cbiAgZXhwb3J0QWNjb3VudCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlJylcbiAgfVxuXG4gIGZvcmdldERldmljZSAoKSB7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdXG4gICAgdGhpcy5wYWdlID0gMFxuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gMFxuICAgIHRoaXMucGF0aHMgPSB7fVxuICAgIHRoaXMuYWNjb3VudERldGFpbHMgPSB7fVxuICAgIHRoaXMuaGRrID0gbmV3IEhES2V5KClcbiAgfVxuXG4gIC8qIFBSSVZBVEUgTUVUSE9EUyAqL1xuXG4gIF9zZXR1cElmcmFtZSAoKSB7XG4gICAgdGhpcy5pZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKVxuICAgIHRoaXMuaWZyYW1lLnNyYyA9IHRoaXMuYnJpZGdlVXJsXG4gICAgdGhpcy5pZnJhbWUuYWxsb3cgPSBgaGlkICdzcmMnYFxuICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIC8vIElmIHRoZSBsZWRnZXIgbGl2ZSBwcmVmZXJlbmNlIHdhcyBzZXQgYmVmb3JlIHRoZSBpZnJhbWUgaXMgbG9hZGVkLFxuICAgICAgLy8gc2V0IGl0IGFmdGVyIHRoZSBpZnJhbWUgaGFzIGxvYWRlZFxuICAgICAgdGhpcy5pZnJhbWVMb2FkZWQgPSB0cnVlXG4gICAgICBpZiAodGhpcy5kZWxheWVkUHJvbWlzZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudXBkYXRlVHJhbnNwb3J0TWV0aG9kKFxuICAgICAgICAgICAgdGhpcy5kZWxheWVkUHJvbWlzZS50cmFuc3BvcnRUeXBlLFxuICAgICAgICAgIClcbiAgICAgICAgICB0aGlzLmRlbGF5ZWRQcm9taXNlLnJlc29sdmUocmVzdWx0KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5kZWxheWVkUHJvbWlzZS5yZWplY3QoZSlcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5kZWxheWVkUHJvbWlzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy5pZnJhbWUpXG4gIH1cblxuICBfZ2V0T3JpZ2luICgpIHtcbiAgICBjb25zdCB0bXAgPSB0aGlzLmJyaWRnZVVybC5zcGxpdCgnLycpXG4gICAgdG1wLnNwbGljZSgtMSwgMSlcbiAgICByZXR1cm4gdG1wLmpvaW4oJy8nKVxuICB9XG5cbiAgX3NlbmRNZXNzYWdlIChtc2csIGNiKSB7XG4gICAgbXNnLnRhcmdldCA9ICdMRURHRVItSUZSQU1FJ1xuICAgIHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCAnKicpXG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9ICh7IG9yaWdpbiwgZGF0YSB9KSA9PiB7XG4gICAgICBpZiAob3JpZ2luICE9PSB0aGlzLl9nZXRPcmlnaW4oKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5hY3Rpb24gJiYgZGF0YS5hY3Rpb24gPT09IGAke21zZy5hY3Rpb259LXJlcGx5YCAmJiBjYikge1xuICAgICAgICBjYihkYXRhKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnRMaXN0ZW5lcilcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudExpc3RlbmVyKVxuICB9XG5cbiAgYXN5bmMgX19nZXRQYWdlIChpbmNyZW1lbnQpIHtcblxuICAgIHRoaXMucGFnZSArPSBpbmNyZW1lbnRcblxuICAgIGlmICh0aGlzLnBhZ2UgPD0gMCkge1xuICAgICAgdGhpcy5wYWdlID0gMVxuICAgIH1cbiAgICBjb25zdCBmcm9tID0gKHRoaXMucGFnZSAtIDEpICogdGhpcy5wZXJQYWdlXG4gICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5wZXJQYWdlXG5cbiAgICBhd2FpdCB0aGlzLnVubG9jaygpXG4gICAgbGV0IGFjY291bnRzXG4gICAgaWYgKHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpKSB7XG4gICAgICBhY2NvdW50cyA9IGF3YWl0IHRoaXMuX2dldEFjY291bnRzQklQNDQoZnJvbSwgdG8pXG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY291bnRzID0gdGhpcy5fZ2V0QWNjb3VudHNMZWdhY3koZnJvbSwgdG8pXG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50c1xuICB9XG5cbiAgYXN5bmMgX2dldEFjY291bnRzQklQNDQgKGZyb20sIHRvKSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBbXVxuXG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy5fZ2V0UGF0aEZvckluZGV4KGkpXG4gICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy51bmxvY2socGF0aClcbiAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5pbXBsZW1lbnRGdWxsQklQNDQgPyBhd2FpdCB0aGlzLl9oYXNQcmV2aW91c1RyYW5zYWN0aW9ucyhhZGRyZXNzKSA6IHRydWVcbiAgICAgIGFjY291bnRzLnB1c2goe1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBiYWxhbmNlOiBudWxsLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgIH0pXG4gICAgICAvLyBQRVIgQklQNDRcbiAgICAgIC8vIFwiU29mdHdhcmUgc2hvdWxkIHByZXZlbnQgYSBjcmVhdGlvbiBvZiBhbiBhY2NvdW50IGlmXG4gICAgICAvLyBhIHByZXZpb3VzIGFjY291bnQgZG9lcyBub3QgaGF2ZSBhIHRyYW5zYWN0aW9uIGhpc3RvcnlcbiAgICAgIC8vIChtZWFuaW5nIG5vbmUgb2YgaXRzIGFkZHJlc3NlcyBoYXZlIGJlZW4gdXNlZCBiZWZvcmUpLlwiXG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50c1xuICB9XG5cbiAgX2dldEFjY291bnRzTGVnYWN5IChmcm9tLCB0bykge1xuICAgIGNvbnN0IGFjY291bnRzID0gW11cblxuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpXG4gICAgICBhY2NvdW50cy5wdXNoKHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgYmFsYW5jZTogbnVsbCxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICB9KVxuICAgICAgdGhpcy5wYXRoc1tldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXSA9IGlcbiAgICB9XG4gICAgcmV0dXJuIGFjY291bnRzXG4gIH1cblxuICBfcGFkTGVmdEV2ZW4gKGhleCkge1xuICAgIHJldHVybiBoZXgubGVuZ3RoICUgMiA9PT0gMCA/IGhleCA6IGAwJHtoZXh9YFxuICB9XG5cbiAgX25vcm1hbGl6ZSAoYnVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZExlZnRFdmVuKGV0aFV0aWwuYnVmZmVyVG9IZXgoYnVmKS50b0xvd2VyQ2FzZSgpKVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICBfYWRkcmVzc0Zyb21JbmRleCAocGF0aEJhc2UsIGkpIHtcbiAgICBjb25zdCBka2V5ID0gdGhpcy5oZGsuZGVyaXZlKGAke3BhdGhCYXNlfS8ke2l9YClcbiAgICBjb25zdCBhZGRyZXNzID0gZXRoVXRpbFxuICAgICAgLnB1YmxpY1RvQWRkcmVzcyhka2V5LnB1YmxpY0tleSwgdHJ1ZSlcbiAgICAgIC50b1N0cmluZygnaGV4JylcbiAgICByZXR1cm4gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhgMHgke2FkZHJlc3N9YClcbiAgfVxuXG4gIF9wYXRoRnJvbUFkZHJlc3MgKGFkZHJlc3MpIHtcbiAgICBjb25zdCBjaGVja3N1bW1lZEFkZHJlc3MgPSBldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXG4gICAgbGV0IGluZGV4ID0gdGhpcy5wYXRoc1tjaGVja3N1bW1lZEFkZHJlc3NdXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0lOREVYOyBpKyspIHtcbiAgICAgICAgaWYgKGNoZWNrc3VtbWVkQWRkcmVzcyA9PT0gdGhpcy5fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSkpIHtcbiAgICAgICAgICBpbmRleCA9IGlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhZGRyZXNzJylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhdGhGb3JJbmRleChpbmRleClcbiAgfVxuXG4gIF90b0FzY2lpIChoZXgpIHtcbiAgICBsZXQgc3RyID0gJydcbiAgICBsZXQgaSA9IDBcbiAgICBjb25zdCBsID0gaGV4Lmxlbmd0aFxuICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICBpID0gMlxuICAgIH1cbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgY29uc3QgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KVxuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICBfZ2V0UGF0aEZvckluZGV4IChpbmRleCkge1xuICAgIC8vIENoZWNrIGlmIHRoZSBwYXRoIGlzIEJJUCA0NCAoTGVkZ2VyIExpdmUpXG4gICAgcmV0dXJuIHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpID8gYG0vNDQnLzYwJy8ke2luZGV4fScvMC8wYCA6IGAke3RoaXMuaGRQYXRofS8ke2luZGV4fWBcbiAgfVxuXG4gIF9pc0xlZGdlckxpdmVIZFBhdGggKCkge1xuICAgIHJldHVybiB0aGlzLmhkUGF0aCA9PT0gYG0vNDQnLzYwJy8wJy8wLzBgXG4gIH1cblxuICBfdG9MZWRnZXJQYXRoIChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKS5yZXBsYWNlKCdtLycsICcnKVxuICB9XG5cbiAgYXN5bmMgX2hhc1ByZXZpb3VzVHJhbnNhY3Rpb25zIChhZGRyZXNzKSB7XG4gICAgY29uc3QgYXBpVXJsID0gdGhpcy5fZ2V0QXBpVXJsKClcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5mZXRjaChgJHthcGlVcmx9L2FwaT9tb2R1bGU9YWNjb3VudCZhY3Rpb249dHhsaXN0JmFkZHJlc3M9JHthZGRyZXNzfSZ0YWc9bGF0ZXN0JnBhZ2U9MSZvZmZzZXQ9MWApXG4gICAgY29uc3QgcGFyc2VkUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICBpZiAocGFyc2VkUmVzcG9uc2Uuc3RhdHVzICE9PSAnMCcgJiYgcGFyc2VkUmVzcG9uc2UucmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgX2dldEFwaVVybCAoKSB7XG4gICAgcmV0dXJuIE5FVFdPUktfQVBJX1VSTFNbdGhpcy5uZXR3b3JrXSB8fCBORVRXT1JLX0FQSV9VUkxTLm1haW5uZXRcbiAgfVxuXG59XG5cbkxlZGdlckJyaWRnZUtleXJpbmcudHlwZSA9IHR5cGVcbm1vZHVsZS5leHBvcnRzID0gTGVkZ2VyQnJpZGdlS2V5cmluZ1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ibG9jay1jYWNoZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmxvY2stcmVmLXJld3JpdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jsb2NrLXJlZlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmxvY2stdHJhY2tlci1pbnNwZWN0b3JcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ZldGNoXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbmZsaWdodC1jYWNoZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvdmlkZXJBc01pZGRsZXdhcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Byb3ZpZGVyRnJvbUVuZ2luZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvdmlkZXJGcm9tTWlkZGxld2FyZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmV0cnlPbkVtcHR5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi93YWxsZXRcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBCTiA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpO1xuY29uc3QgU0RLID0gcmVxdWlyZSgnZ3JpZHBsdXMtc2RrJyk7XG5jb25zdCBFdGhUeCA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3R4Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCdAZXRoZXJldW1qcy9jb21tb24nKS5kZWZhdWx0O1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpO1xuY29uc3Qga2V5cmluZ1R5cGUgPSAnTGF0dGljZSBIYXJkd2FyZSc7XG5jb25zdCBIQVJERU5FRF9PRkZTRVQgPSAweDgwMDAwMDAwO1xuY29uc3QgUEVSX1BBR0UgPSA1O1xuY29uc3QgQ0xPU0VfQ09ERSA9IC0xMDAwO1xuY29uc3QgU1RBTkRBUkRfSERfUEFUSCA9IGBtLzQ0Jy82MCcvMCcvMC94YFxuXG5jbGFzcyBMYXR0aWNlS2V5cmluZyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzPXt9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMudHlwZSA9IGtleXJpbmdUeXBlO1xuICAgIHRoaXMuX3Jlc2V0RGVmYXVsdHMoKTtcbiAgICB0aGlzLmRlc2VyaWFsaXplKG9wdHMpO1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEtleXJpbmcgQVBJIChwZXIgYGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9ldGgtc2ltcGxlLWtleXJpbmdgKVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZGVzZXJpYWxpemUgKG9wdHMgPSB7fSkge1xuICAgIGlmIChvcHRzLmhkUGF0aClcbiAgICAgIHRoaXMuaGRQYXRoID0gb3B0cy5oZFBhdGg7XG4gICAgaWYgKG9wdHMuY3JlZHMpXG4gICAgICB0aGlzLmNyZWRzID0gb3B0cy5jcmVkcztcbiAgICBpZiAob3B0cy5hY2NvdW50cylcbiAgICAgIHRoaXMuYWNjb3VudHMgPSBvcHRzLmFjY291bnRzO1xuICAgIGlmIChvcHRzLmFjY291bnRJbmRpY2VzKVxuICAgICAgdGhpcy5hY2NvdW50SW5kaWNlcyA9IG9wdHMuYWNjb3VudEluZGljZXM7XG4gICAgaWYgKG9wdHMuYWNjb3VudE9wdHMpXG4gICAgICB0aGlzLmFjY291bnRPcHRzID0gb3B0cy5hY2NvdW50T3B0cztcbiAgICBpZiAob3B0cy53YWxsZXRVSUQpXG4gICAgICB0aGlzLndhbGxldFVJRCA9IG9wdHMud2FsbGV0VUlEO1xuICAgIGlmIChvcHRzLm5hbWUpICAvLyBMZWdhY3k7IHVzZSBpcyBkZXByZWNhdGVkIGFuZCBhcHBOYW1lIGlzIG1vcmUgZGVzY3JpcHRpdmVcbiAgICAgIHRoaXMuYXBwTmFtZSA9IG9wdHMubmFtZTtcbiAgICBpZiAob3B0cy5hcHBOYW1lKVxuICAgICAgdGhpcy5hcHBOYW1lID0gb3B0cy5hcHBOYW1lO1xuICAgIGlmIChvcHRzLm5ldHdvcmspXG4gICAgICB0aGlzLm5ldHdvcmsgPSBvcHRzLm5ldHdvcms7XG4gICAgaWYgKG9wdHMucGFnZSlcbiAgICAgIHRoaXMucGFnZSA9IG9wdHMucGFnZTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIHNldEhkUGF0aChoZFBhdGgpIHtcbiAgICB0aGlzLmhkUGF0aCA9IGhkUGF0aDtcbiAgfVxuXG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGNyZWRzOiB0aGlzLmNyZWRzLFxuICAgICAgYWNjb3VudHM6IHRoaXMuYWNjb3VudHMsXG4gICAgICBhY2NvdW50SW5kaWNlczogdGhpcy5hY2NvdW50SW5kaWNlcyxcbiAgICAgIGFjY291bnRPcHRzOiB0aGlzLmFjY291bnRPcHRzLFxuICAgICAgd2FsbGV0VUlEOiB0aGlzLndhbGxldFVJRCxcbiAgICAgIGFwcE5hbWU6IHRoaXMuYXBwTmFtZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSwgIC8vIExlZ2FjeTsgdXNlIGlzIGRlcHJlY2F0ZWRcbiAgICAgIG5ldHdvcms6IHRoaXMubmV0d29yayxcbiAgICAgIHBhZ2U6IHRoaXMucGFnZSxcbiAgICAgIGhkUGF0aDogdGhpcy5oZFBhdGgsXG4gICAgfSlcbiAgfVxuXG4gIGlzVW5sb2NrZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9oYXNDcmVkcygpICYmIHRoaXMuX2hhc1Nlc3Npb24oKVxuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBhIHNlc3Npb24gd2l0aCB0aGUgTGF0dGljZTEgZGV2aWNlIHVzaW5nIHRoZSBHcmlkUGx1cyBTREtcbiAgdW5sb2NrKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBGb3JjZSBjb21wYXRhYmlsaXR5LiBgdGhpcy5hY2NvdW50T3B0c2Agd2VyZSBhZGRlZCBhZnRlciBvdGhlclxuICAgICAgLy8gc3RhdGUgcGFyYW1zIGFuZCBtdXN0IGJlIHN5bmNlZCBpbiBvcmRlciBmb3IgdGhpcyBrZXlyaW5nIHRvIGZ1bmN0aW9uLlxuICAgICAgaWYgKCghdGhpcy5hY2NvdW50T3B0cykgfHwgXG4gICAgICAgICAgKHRoaXMuYWNjb3VudHMubGVuZ3RoID4gMCAmJiB0aGlzLmFjY291bnRPcHRzLmxlbmd0aCAhPSB0aGlzLmFjY291bnRzLmxlbmd0aCkpIFxuICAgICAge1xuICAgICAgICB0aGlzLmZvcmdldERldmljZSgpO1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcbiAgICAgICAgICAnWW91IGNhbiBub3cgYWRkIG11bHRpcGxlIExhdHRpY2UgYW5kIFNhZmVDYXJkIGFjY291bnRzIGF0IHRoZSBzYW1lIHRpbWUhICcgK1xuICAgICAgICAgICdZb3VyIGFjY291bnRzIGhhdmUgYmVlbiBjbGVhcmVkLiBQbGVhc2UgcHJlc3MgQ29udGludWUgdG8gYWRkIHRoZW0gYmFjayBpbi4nXG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9nZXRDcmVkcygpXG4gICAgICAudGhlbigoY3JlZHMpID0+IHtcbiAgICAgICAgaWYgKGNyZWRzKSB7XG4gICAgICAgICAgdGhpcy5jcmVkcy5kZXZpY2VJRCA9IGNyZWRzLmRldmljZUlEO1xuICAgICAgICAgIHRoaXMuY3JlZHMucGFzc3dvcmQgPSBjcmVkcy5wYXNzd29yZDtcbiAgICAgICAgICB0aGlzLmNyZWRzLmVuZHBvaW50ID0gY3JlZHMuZW5kcG9pbnQgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW5pdFNlc3Npb24oKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0KCk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSgnVW5sb2NrZWQnKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8vIEFkZCBhZGRyZXNzZXMgdG8gdGhlIGxvY2FsIHN0b3JlIGFuZCByZXR1cm4gdGhlIGZ1bGwgcmVzdWx0XG4gIGFkZEFjY291bnRzKG49MSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAobiA9PT0gQ0xPU0VfQ09ERSkge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IHVzZSBhIGNvZGUgdG8gZm9yZ2V0IHRoZSBkZXZpY2UuIFxuICAgICAgICAvLyAoVGhpcyBmdW5jdGlvbiBpcyBvdmVybG9hZGVkIGR1ZSB0byBjb25zdHJhaW50cyB1cHN0cmVhbSlcbiAgICAgICAgdGhpcy5mb3JnZXREZXZpY2UoKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgICAgfSBlbHNlIGlmIChuIDw9IDApIHtcbiAgICAgICAgLy8gQXZvaWQgbm9uLXBvc2l0aXZlIG51bWJlcnMuXG4gICAgICAgIHJldHVybiByZWplY3QoJ051bWJlciBvZiBhY2NvdW50cyB0byBhZGQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlci4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vcm1hbCBiZWhhdmlvcjogZXN0YWJsaXNoIHRoZSBjb25uZWN0aW9uIGFuZCBmZXRjaCBhZGRyZXNzZXMuXG4gICAgICAgIHRoaXMudW5sb2NrKClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9mZXRjaEFkZHJlc3NlcyhuLCB0aGlzLnVubG9ja2VkQWNjb3VudClcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKGFkZHJzKSA9PiB7XG4gICAgICAgICAgY29uc3Qgd2FsbGV0VUlEID0gdGhpcy5fZ2V0Q3VycmVudFdhbGxldFVJRCgpO1xuICAgICAgICAgIC8vIEFkZCB0aGVzZSBpbmRpY2VzXG4gICAgICAgICAgYWRkcnMuZm9yRWFjaCgoYWRkciwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IGFscmVhZHlTYXZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmFjY291bnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmICgodGhpcy5hY2NvdW50c1tqXSA9PT0gYWRkcikgJiYgXG4gICAgICAgICAgICAgICAgICAodGhpcy5hY2NvdW50T3B0c1tqXS53YWxsZXRVSUQgPT09IHdhbGxldFVJRCkgJiZcbiAgICAgICAgICAgICAgICAgICh0aGlzLmFjY291bnRPcHRzW2pdLmhkUGF0aCA9PT0gdGhpcy5oZFBhdGgpKVxuICAgICAgICAgICAgICAgIGFscmVhZHlTYXZlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFscmVhZHlTYXZlZCkge1xuICAgICAgICAgICAgICB0aGlzLmFjY291bnRzLnB1c2goYWRkcik7XG4gICAgICAgICAgICAgIHRoaXMuYWNjb3VudEluZGljZXMucHVzaCh0aGlzLnVubG9ja2VkQWNjb3VudCtpKTtcbiAgICAgICAgICAgICAgdGhpcy5hY2NvdW50T3B0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB3YWxsZXRVSUQsXG4gICAgICAgICAgICAgICAgaGRQYXRoOiB0aGlzLmhkUGF0aCxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMuYWNjb3VudHMpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGVycikpO1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIGxvY2FsIHN0b3JlIG9mIGFkZHJlc3Nlc1xuICBnZXRBY2NvdW50cygpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWNjb3VudHMgPyB0aGlzLmFjY291bnRzLnNsaWNlKCkgOiBbXS5zbGljZSgpKTtcbiAgfVxuXG4gIHNpZ25UcmFuc2FjdGlvbiAoYWRkcmVzcywgdHgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fdW5sb2NrQW5kRmluZEFjY291bnQoYWRkcmVzcylcbiAgICAgIC50aGVuKChhY2NvdW50SWR4KSA9PiB7XG4gICAgICAgIGlmICghdHgudG8pIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KCdDb250cmFjdCBkZXBsb3ltZW50IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIExhdHRpY2UgYXQgdGhpcyB0aW1lLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdgdG9gIGZpZWxkIG11c3QgYmUgaW5jbHVkZWQuJylcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgTGF0dGljZSByZXF1ZXN0IGRhdGEgYW5kIG1ha2UgcmVxdWVzdFxuICAgICAgICAvLyBXZSBleHBlY3QgYHR4YCB0byBiZSBhbiBgZXRoZXJldW1qcy10eGAgb2JqZWN0LCBtZWFuaW5nIGFsbCBmaWVsZHMgYXJlIGJ1ZmZlcml6ZWRcbiAgICAgICAgLy8gVG8gZW5zdXJlIGV2ZXJ5dGhpbmcgcGxheXMgbmljZWx5IHdpdGggZ3JpZHBsdXMtc2RrLCB3ZSBjb252ZXJ0IGV2ZXJ5dGhpbmcgdG8gaGV4IHN0cmluZ3NcbiAgICAgICAgY29uc3QgYWRkcmVzc0lkeCA9IHRoaXMuYWNjb3VudEluZGljZXNbYWNjb3VudElkeF07XG4gICAgICAgIGNvbnN0IGFkZHJlc3NQYXJlbnRQYXRoID0gdGhpcy5hY2NvdW50T3B0c1thY2NvdW50SWR4XS5oZFBhdGg7XG4gICAgICAgIGNvbnN0IHR4RGF0YSA9IHtcbiAgICAgICAgICBjaGFpbklkOiBgMHgke3RoaXMuX2dldEV0aGVyZXVtSnNDaGFpbklkKHR4KS50b1N0cmluZygnaGV4Jyl9YCB8fCAxLFxuICAgICAgICAgIG5vbmNlOiBgMHgke3R4Lm5vbmNlLnRvU3RyaW5nKCdoZXgnKX1gIHx8IDAsXG4gICAgICAgICAgZ2FzTGltaXQ6IGAweCR7dHguZ2FzTGltaXQudG9TdHJpbmcoJ2hleCcpfWAsXG4gICAgICAgICAgdG86IHR4LnRvLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICB2YWx1ZTogYDB4JHt0eC52YWx1ZS50b1N0cmluZygnaGV4Jyl9YCxcbiAgICAgICAgICBkYXRhOiB0eC5kYXRhLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBgMHgke3R4LmRhdGEudG9TdHJpbmcoJ2hleCcpfWAsXG4gICAgICAgICAgc2lnbmVyUGF0aDogdGhpcy5fZ2V0SERQYXRoSW5kaWNlcyhhZGRyZXNzUGFyZW50UGF0aCwgYWRkcmVzc0lkeCksXG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eC5fdHlwZSkge1xuICAgICAgICAgIGNhc2UgMjogLy8gZWlwMTU1OVxuICAgICAgICAgICAgaWYgKCh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PT0gbnVsbCB8fCB0eC5tYXhGZWVQZXJHYXMgPT09IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09PSB1bmRlZmluZWQgfHwgdHgubWF4RmVlUGVyR2FzID09PSB1bmRlZmluZWQpKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BtYXhQcmlvcml0eUZlZVBlckdhc2AgYW5kIGBtYXhGZWVQZXJHYXNgIG11c3QgYmUgaW5jbHVkZWQgZm9yIEVJUDE1NTkgdHJhbnNhY3Rpb25zLicpO1xuICAgICAgICAgICAgdHhEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID0gYDB4JHt0eC5tYXhQcmlvcml0eUZlZVBlckdhcy50b1N0cmluZygnaGV4Jyl9YDtcbiAgICAgICAgICAgIHR4RGF0YS5tYXhGZWVQZXJHYXMgPSBgMHgke3R4Lm1heEZlZVBlckdhcy50b1N0cmluZygnaGV4Jyl9YDtcbiAgICAgICAgICAgIHR4RGF0YS5hY2Nlc3NMaXN0ID0gdHguYWNjZXNzTGlzdCB8fCBbXTtcbiAgICAgICAgICAgIHR4RGF0YS50eXBlID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogLy8gZWlwMjkzMFxuICAgICAgICAgICAgdHhEYXRhLmFjY2Vzc0xpc3QgPSB0eC5hY2Nlc3NMaXN0IHx8IFtdO1xuICAgICAgICAgICAgdHhEYXRhLmdhc1ByaWNlID0gYDB4JHt0eC5nYXNQcmljZS50b1N0cmluZygnaGV4Jyl9YDtcbiAgICAgICAgICAgIHR4RGF0YS50eXBlID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IC8vIGxlZ2FjeVxuICAgICAgICAgICAgdHhEYXRhLmdhc1ByaWNlID0gYDB4JHt0eC5nYXNQcmljZS50b1N0cmluZygnaGV4Jyl9YDtcbiAgICAgICAgICAgIHR4RGF0YS50eXBlID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIExhdHRpY2UgZmlybXdhcmUgdjAuMTEuMCBpbXBsZW1lbnRlZCBFSVAxNTU5IGFuZCBFSVAyOTMwIHNvIGZvciBwcmV2aW91cyB2ZXJpc29uc1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIG92ZXJ3cml0ZSByZWxldmFudCBwYXJhbXMgYW5kIHJldmVydCB0byBsZWdhY3kgdHlwZS5cbiAgICAgICAgLy8gTm90ZTogYHRoaXMuc2RrU2Vzc2lvbi5md1ZlcnNpb24gaXMgb2YgZm9ybWF0IFtmaXgsIG1pbm9yLCBtYWpvciwgcmVzZXJ2ZWRdXG4gICAgICAgIGNvbnN0IGZvcmNlTGVnYWN5VHggPSB0aGlzLnNka1Nlc3Npb24uZndWZXJzaW9uWzJdIDwgMSAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2RrU2Vzc2lvbi5md1ZlcnNpb25bMV0gPCAxMTtcbiAgICAgICAgaWYgKGZvcmNlTGVnYWN5VHggJiYgdHhEYXRhLnR5cGUgPT09IDIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0xhdHRpY2UgZmlybXdhcmUgbXVzdCBiZSA+PTAuMTEuMCB0byBzdXBwb3J0IEVJUDE1NTkgdHJhbnNhY3Rpb25zLiBSZXZlcmluZyB0byBsZWdhY3kuJyk7XG4gICAgICAgICAgdHhEYXRhLmdhc1ByaWNlID0gdHhEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICB0eERhdGEucmV2ZXJ0VG9MZWdhY3kgPSB0cnVlO1xuICAgICAgICAgIGRlbGV0ZSB0eERhdGEudHlwZTtcbiAgICAgICAgICBkZWxldGUgdHhEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICBkZWxldGUgdHhEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgIGRlbGV0ZSB0eERhdGEuYWNjZXNzTGlzdDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JjZUxlZ2FjeVR4ICYmIHR4RGF0YS50eXBlID09PSAxKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdMYXR0aWNlIGZpcm13YXJlIG11c3QgYmUgPj0wLjExLjAgdG8gc3VwcG9ydCBFSVAyOTMwIHRyYW5zYWN0aW9ucy4gUmV2ZXJ0aW5nIHRvIGxlZ2FjeS4nKTtcbiAgICAgICAgICB0eERhdGEucmV2ZXJ0VG9MZWdhY3kgPSB0cnVlO1xuICAgICAgICAgIGRlbGV0ZSB0eERhdGEudHlwZTtcbiAgICAgICAgICBkZWxldGUgdHhEYXRhLmFjY2Vzc0xpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBzaWduYXR1cmVcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25UeERhdGEodHhEYXRhKVxuICAgICAgfSlcbiAgICAgIC50aGVuKChzaWduZWRUeCkgPT4ge1xuICAgICAgICAvLyBBZGQgdGhlIHNpZyBwYXJhbXMuIGBzaWduZWRUeCA9IHsgc2lnOiB7IHYsIHIsIHMgfSwgdHgsIHR4SGFzaH1gXG4gICAgICAgIGlmICghc2lnbmVkVHguc2lnIHx8ICFzaWduZWRUeC5zaWcudiB8fCAhc2lnbmVkVHguc2lnLnIgfHwgIXNpZ25lZFR4LnNpZy5zKVxuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdObyBzaWduYXR1cmUgcmV0dXJuZWQuJykpO1xuICAgICAgICBjb25zdCB0eFRvUmV0dXJuID0gdHgudG9KU09OKCk7XG4gICAgICAgIGNvbnN0IHYgPSBzaWduZWRUeC5zaWcudi5sZW5ndGggPT09IDAgPyAnMCcgOiBzaWduZWRUeC5zaWcudi50b1N0cmluZygnaGV4JylcbiAgICAgICAgdHhUb1JldHVybi5yID0gVXRpbC5hZGRIZXhQcmVmaXgoc2lnbmVkVHguc2lnLnIudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgdHhUb1JldHVybi5zID0gVXRpbC5hZGRIZXhQcmVmaXgoc2lnbmVkVHguc2lnLnMudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgdHhUb1JldHVybi52ID0gVXRpbC5hZGRIZXhQcmVmaXgodik7XG5cbiAgICAgICAgaWYgKHNpZ25lZFR4LnJldmVydFRvTGVnYWN5ID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gSWYgZmlybXdhcmUgZG9lcyBub3Qgc3VwcG9ydCBhbiBFSVAxNTU5LzI5MzAgdHJhbnNhY3Rpb24gd2UgcmV2ZXJ0IHRvIGxlZ2FjeVxuICAgICAgICAgIHR4VG9SZXR1cm4udHlwZSA9IDA7XG4gICAgICAgICAgdHhUb1JldHVybi5nYXNQcmljZSA9IHNpZ25lZFR4Lmdhc1ByaWNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSByZWxheSB0aGUgdHggdHlwZVxuICAgICAgICAgIHR4VG9SZXR1cm4udHlwZSA9IHNpZ25lZFR4LnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCdWlsZCB0aGUgdHggZm9yIGV4cG9ydFxuICAgICAgICBsZXQgdmFsaWRhdGluZ1R4O1xuICAgICAgICBjb25zdCBfY2hhaW5JZCA9IGAweCR7dGhpcy5fZ2V0RXRoZXJldW1Kc0NoYWluSWQodHgpLnRvU3RyaW5nKCdoZXgnKX1gO1xuICAgICAgICBjb25zdCBjaGFpbklkID0gbmV3IEJOKF9jaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICBjb25zdCBjdXN0b21OZXR3b3JrID0gQ29tbW9uLmZvckN1c3RvbUNoYWluKCdtYWlubmV0Jywge1xuICAgICAgICAgIG5hbWU6ICdub3RNYWlubmV0JyxcbiAgICAgICAgICBuZXR3b3JrSWQ6IGNoYWluSWQsXG4gICAgICAgICAgY2hhaW5JZDogY2hhaW5JZCxcbiAgICAgICAgfSwgJ2xvbmRvbicpXG5cbiAgICAgICAgdmFsaWRhdGluZ1R4ID0gRXRoVHguVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEodHhUb1JldHVybiwge1xuICAgICAgICAgIGNvbW1vbjogY3VzdG9tTmV0d29yaywgZnJlZXplOiBPYmplY3QuaXNGcm96ZW4odHgpXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiByZXNvbHZlKHZhbGlkYXRpbmdUeClcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHNpZ25QZXJzb25hbE1lc3NhZ2UoYWRkcmVzcywgbXNnKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbk1lc3NhZ2UoYWRkcmVzcywgeyBwYXlsb2FkOiBtc2csIHByb3RvY29sOiAnc2lnblBlcnNvbmFsJyB9KTtcbiAgfVxuXG4gIHNpZ25UeXBlZERhdGEoYWRkcmVzcywgbXNnLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMudmVyc2lvbiAmJiAob3B0cy52ZXJzaW9uICE9PSAnVjQnICYmIG9wdHMudmVyc2lvbiAhPT0gJ1YzJykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgc2lnblR5cGVkRGF0YSBWMyBhbmQgVjQgbWVzc2FnZXMgKEVJUDcxMikgYXJlIHN1cHBvcnRlZC4gR290IHZlcnNpb24gJHtvcHRzLnZlcnNpb259YCk7XG4gICAgcmV0dXJuIHRoaXMuc2lnbk1lc3NhZ2UoYWRkcmVzcywgeyBwYXlsb2FkOiBtc2csIHByb3RvY29sOiAnZWlwNzEyJyB9KVxuICB9XG5cbiAgc2lnbk1lc3NhZ2UoYWRkcmVzcywgbXNnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3VubG9ja0FuZEZpbmRBY2NvdW50KGFkZHJlc3MpXG4gICAgICAudGhlbigoYWNjb3VudElkeCkgPT4ge1xuICAgICAgICBsZXQgeyBwYXlsb2FkLCBwcm90b2NvbCB9ID0gbXNnO1xuICAgICAgICAvLyBJZiB0aGUgbWVzc2FnZSBpcyBub3QgYW4gb2JqZWN0IHdlIGFzc3VtZSBpdCBpcyBhIGxlZ2FjeSBzaWduUGVyc29uYWwgcmVxdWVzdFxuICAgICAgICBpZiAoIXBheWxvYWQgfHwgIXByb3RvY29sKSB7XG4gICAgICAgICAgcGF5bG9hZCA9IG1zZztcbiAgICAgICAgICBwcm90b2NvbCA9ICdzaWduUGVyc29uYWwnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3NJZHggPSB0aGlzLmFjY291bnRJbmRpY2VzW2FjY291bnRJZHhdO1xuICAgICAgICBjb25zdCBhZGRyZXNzUGFyZW50UGF0aCA9IHRoaXMuYWNjb3VudE9wdHNbYWNjb3VudElkeF0uaGRQYXRoO1xuICAgICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgICAgY3VycmVuY3k6ICdFVEhfTVNHJyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICBzaWduZXJQYXRoOiB0aGlzLl9nZXRIRFBhdGhJbmRpY2VzKGFkZHJlc3NQYXJlbnRQYXRoLCBhZGRyZXNzSWR4KSxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNTZXNzaW9uKCkpXG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vIFNESyBzZXNzaW9uIHN0YXJ0ZWQuIENhbm5vdCBzaWduIHRyYW5zYWN0aW9uLicpKTtcbiAgICAgICAgdGhpcy5zZGtTZXNzaW9uLnNpZ24ocmVxLCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoZXJyKSk7XG4gICAgICAgICAgaWYgKCFyZXMuc2lnKVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZSByZXR1cm5lZCcpKTtcbiAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgdmAgdG8gYSBudW1iZXIuIEl0IHNob3VsZCBjb252ZXJ0IHRvIDAgb3IgMVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgdiA9IHJlcy5zaWcudi50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgICAgICBpZiAodi5sZW5ndGggPCAyKVxuICAgICAgICAgICAgICB2ID0gYDAke3Z9YDtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGAweCR7cmVzLnNpZy5yfSR7cmVzLnNpZy5zfSR7dn1gKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBmb3JtYXQgcmV0dXJuZWQuJykpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGVycikpO1xuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgZXhwb3J0QWNjb3VudChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEVycm9yKCdleHBvcnRBY2NvdW50IG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBkZXZpY2UnKSlcbiAgfVxuXG4gIHJlbW92ZUFjY291bnQoYWRkcmVzcykge1xuICAgIHRoaXMuYWNjb3VudHMuZm9yRWFjaCgoYWNjb3VudCwgaSkgPT4ge1xuICAgICAgaWYgKGFjY291bnQudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHRoaXMuYWNjb3VudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLmFjY291bnRJbmRpY2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5hY2NvdW50T3B0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZ2V0Rmlyc3RQYWdlKCkge1xuICAgIHRoaXMucGFnZSA9IDA7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhZ2UoMCk7XG4gIH1cblxuICBnZXROZXh0UGFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhZ2UoMSk7XG4gIH1cblxuICBnZXRQcmV2aW91c1BhZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQYWdlKC0xKTtcbiAgfVxuXG4gIHNldEFjY291bnRUb1VubG9jayAoaW5kZXgpIHtcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IHBhcnNlSW50KGluZGV4LCAxMClcbiAgfVxuXG4gIGZvcmdldERldmljZSAoKSB7XG4gICAgdGhpcy5fcmVzZXREZWZhdWx0cygpO1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEludGVybmFsIG1ldGhvZHMgYW5kIGludGVyZmFjZSB0byBTREtcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEZpbmQgdGhlIGFjY291bnQgaW5kZXggb2YgdGhlIHJlcXVlc3RlZCBhZGRyZXNzLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBpcyB0aGUgQklQMzkgcGF0aCBpbmRleCwgbm90IHRoZSBpbmRleCBpbiB0aGUgYWRkcmVzcyBjYWNoZS5cbiAgX3VubG9ja0FuZEZpbmRBY2NvdW50KGFkZHJlc3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy51bmxvY2soKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBY2NvdW50cygpXG4gICAgICB9KVxuICAgICAgLnRoZW4oKGFkZHJzKSA9PiB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHNpZ25lciBpbiBvdXIgY3VycmVudCBzZXQgb2YgYWNjb3VudHNcbiAgICAgICAgLy8gSWYgd2UgY2FuJ3QgZmluZCBpdCwgcmV0dXJuIGFuIGVycm9yXG4gICAgICAgIGxldCBhY2NvdW50SWR4ID0gbnVsbDtcbiAgICAgICAgYWRkcnMuZm9yRWFjaCgoYWRkciwgaSkgPT4ge1xuICAgICAgICAgIGlmIChhZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHIudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgIGFjY291bnRJZHggPSBpO1xuICAgICAgICB9KVxuICAgICAgICBpZiAoYWNjb3VudElkeCA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KCdTaWduZXIgbm90IHByZXNlbnQnKTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBhY2NvdW50IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCB3YWxsZXRcbiAgICAgICAgaWYgKHRoaXMuYWNjb3VudE9wdHNbYWNjb3VudElkeF0ud2FsbGV0VUlEICE9PSB0aGlzLl9nZXRDdXJyZW50V2FsbGV0VUlEKCkpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignQWNjb3VudCBvbiBhIGRpZmZlcmVudCB3YWxsZXQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdQbGVhc2Ugc3dpdGNoIHRvIHRoZSBjb3JyZWN0IHdhbGxldCBvbiB5b3VyIExhdHRpY2UuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKGFjY291bnRJZHgpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRIRFBhdGhJbmRpY2VzKGhkUGF0aCwgaW5zZXJ0SWR4PTApIHtcbiAgICBjb25zdCBwYXRoID0gaGRQYXRoLnNwbGl0KCcvJykuc2xpY2UoMSk7XG4gICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgIGxldCB1c2VkWCA9IGZhbHNlO1xuICAgIHBhdGguZm9yRWFjaCgoX2lkeCkgPT4ge1xuICAgICAgY29uc3QgaXNIYXJkZW5lZCA9IChfaWR4W19pZHgubGVuZ3RoIC0gMV0gPT09IFwiJ1wiKTtcbiAgICAgIGxldCBpZHggPSBpc0hhcmRlbmVkID8gSEFSREVORURfT0ZGU0VUIDogMDtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGB4YCBpbiB0aGUgcGF0aCBzdHJpbmcsIHdlIHdpbGwgdXNlIGl0IHRvIGluc2VydCBvdXJcbiAgICAgIC8vIGluZGV4LiBUaGlzIGlzIHVzZWZ1bCBmb3IgZS5nLiBMZWRnZXIgTGl2ZSBwYXRoLiBNb3N0IHBhdGhzIGhhdmUgdGhlXG4gICAgICAvLyBjaGFuZ2luZyBpbmRleCBhcyB0aGUgbGFzdCBvbmUsIHNvIGhhdmluZyBhbiBgeGAgaW4gdGhlIHBhdGggaXNuJ3RcbiAgICAgIC8vIHVzdWFsbHkgbmVjZXNzYXJ5LlxuICAgICAgaWYgKF9pZHguaW5kZXhPZigneCcpID4gLTEpIHtcbiAgICAgICAgaWR4ICs9IGluc2VydElkeDtcbiAgICAgICAgdXNlZFggPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpc0hhcmRlbmVkKSB7XG4gICAgICAgIGlkeCArPSBOdW1iZXIoX2lkeC5zbGljZSgwLCBfaWR4Lmxlbmd0aCAtIDEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeCArPSBOdW1iZXIoX2lkeCk7XG4gICAgICB9XG4gICAgICBpbmRpY2VzLnB1c2goaWR4KTtcbiAgICB9KVxuICAgIC8vIElmIHRoaXMgcGF0aCBzdHJpbmcgZG9lcyBub3QgaW5jbHVkZSBhbiBgeGAsIHdlIGp1c3QgYXBwZW5kIHRoZSBpbmRleFxuICAgIC8vIHRvIHRoZSBlbmQgb2YgdGhlIGV4dHJhY3RlZCBzZXRcbiAgICBpZiAodXNlZFggPT09IGZhbHNlKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaW5zZXJ0SWR4KTtcbiAgICB9XG4gICAgLy8gU2FuaXR5IGNoZWNrIC0tIExhdHRpY2UgZmlybXdhcmUgd2lsbCB0aHJvdyBhbiBlcnJvciBmb3IgbGFyZ2UgcGF0aHNcbiAgICBpZiAoaW5kaWNlcy5sZW5ndGggPiA1KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IEhEIHBhdGhzIHdpdGggdXAgdG8gNSBpbmRpY2VzIGFyZSBhbGxvd2VkLicpXG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1cblxuICBfcmVzZXREZWZhdWx0cygpIHtcbiAgICB0aGlzLmFjY291bnRzID0gW107XG4gICAgdGhpcy5hY2NvdW50SW5kaWNlcyA9IFtdO1xuICAgIHRoaXMuYWNjb3VudE9wdHMgPSBbXTtcbiAgICB0aGlzLmlzTG9ja2VkID0gdHJ1ZTtcbiAgICB0aGlzLmNyZWRzID0ge1xuICAgICAgZGV2aWNlSUQ6IG51bGwsXG4gICAgICBwYXNzd29yZDogbnVsbCxcbiAgICAgIGVuZHBvaW50OiBudWxsLFxuICAgIH07XG4gICAgdGhpcy53YWxsZXRVSUQgPSBudWxsO1xuICAgIHRoaXMuc2RrU2Vzc2lvbiA9IG51bGw7XG4gICAgdGhpcy5wYWdlID0gMDtcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IDA7XG4gICAgdGhpcy5uZXR3b3JrID0gbnVsbDtcbiAgICB0aGlzLmhkUGF0aCA9IFNUQU5EQVJEX0hEX1BBVEg7XG4gIH1cblxuICBfb3BlbkNvbm5lY3RvclRhYih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgYnJvd3NlclRhYiA9IHdpbmRvdy5vcGVuKHVybCk7XG4gICAgICAvLyBQcmVmZXJyZWQgb3B0aW9uIGZvciBDaHJvbWl1bSBicm93c2Vycy4gVGhpcyBleHRlbnNpb24gcnVucyBpbiBhIHdpbmRvd1xuICAgICAgLy8gZm9yIENocm9taXVtIHNvIHdlIGNhbiBkbyB3aW5kb3ctYmFzZWQgY29tbXVuaWNhdGlvbiB2ZXJ5IGVhc2lseS5cbiAgICAgIGlmIChicm93c2VyVGFiKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHsgY2hyb21pdW06IGJyb3dzZXJUYWIgfSk7XG4gICAgICB9IGVsc2UgaWYgKGJyb3dzZXIgJiYgYnJvd3Nlci50YWJzICYmIGJyb3dzZXIudGFicy5jcmVhdGUpIHtcbiAgICAgICAgLy8gRmlyZUZveCBleHRlbnNpb25zIGRvIG5vdCBydW4gaW4gd2luZG93cywgc28gaXQgd2lsbCByZXR1cm4gYG51bGxgIGZyb21cbiAgICAgICAgLy8gYHdpbmRvdy5vcGVuYC4gSW5zdGVhZCwgd2UgbmVlZCB0byB1c2UgdGhlIGBicm93c2VyYCBBUEkgdG8gb3BlbiBhIHRhYi4gXG4gICAgICAgIC8vIFdlIHdpbGwgc3VydmVpbGxlIHRoaXMgdGFiIHRvIHNlZSBpZiBpdHMgVVJMIHBhcmFtZXRlcnMgY2hhbmdlLCB3aGljaCBcbiAgICAgICAgLy8gd2lsbCBpbmRpY2F0ZSB0aGF0IHRoZSB1c2VyIGhhcyBsb2dnZWQgaW4uXG4gICAgICAgIGJyb3dzZXIudGFicy5jcmVhdGUoe3VybH0pXG4gICAgICAgIC50aGVuKCh0YWIpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IGZpcmVmb3g6IHRhYiB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIG9wZW4gTGF0dGljZSBjb25uZWN0b3IuJykpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignVW5rbm93biBicm93c2VyIGNvbnRleHQuIENhbm5vdCBvcGVuIExhdHRpY2UgY29ubmVjdG9yLicpKVxuICAgICAgfVxuXG4gICAgfSlcbiAgfVxuXG4gIF9maW5kVGFiQnlJZChpZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBicm93c2VyLnRhYnMucXVlcnkoe30pXG4gICAgICAudGhlbigodGFicykgPT4ge1xuICAgICAgICB0YWJzLmZvckVhY2goKHRhYikgPT4ge1xuICAgICAgICAgIGlmICh0YWIuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0YWIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfSlcbiAgICB9KVxuICB9XG4gIFxuICBfZ2V0Q3JlZHMoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBzZXR1cCBpZiB3ZSBkb24ndCBoYXZlIGEgZGV2aWNlSURcbiAgICAgIGlmICh0aGlzLl9oYXNDcmVkcygpKVxuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuXG4gICAgICAvLyBJZiB3ZSBhcmUgbm90IGF3YXJlIG9mIHdoYXQgTGF0dGljZSB3ZSBzaG91bGQgYmUgdGFsa2luZyB0byxcbiAgICAgIC8vIHdlIG5lZWQgdG8gb3BlbiBhIHdpbmRvdyB0aGF0IGxldHMgdGhlIHVzZXIgZ28gdGhyb3VnaCB0aGVcbiAgICAgIC8vIHBhaXJpbmcgb3IgY29ubmVjdGlvbiBwcm9jZXNzLlxuICAgICAgY29uc3QgbmFtZSA9IHRoaXMuYXBwTmFtZSA/IHRoaXMuYXBwTmFtZSA6ICdVbmtub3duJ1xuICAgICAgY29uc3QgYmFzZSA9ICdodHRwczovL3dhbGxldC5ncmlkcGx1cy5pbyc7XG4gICAgICBjb25zdCB1cmwgPSBgJHtiYXNlfT9rZXlyaW5nPSR7bmFtZX0mZm9yY2VMb2dpbj10cnVlYDtcbiAgICAgIGxldCBsaXN0ZW5JbnRlcnZhbDtcblxuICAgICAgLy8gUG9zdE1lc3NhZ2UgaGFuZGxlclxuICAgICAgZnVuY3Rpb24gcmVjZWl2ZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgLy8gRW5zdXJlIG9yaWdpblxuICAgICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSBiYXNlKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gU3RvcCB0aGUgbGlzdGVuZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGxpc3RlbkludGVydmFsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gY2xvc2UgaW50ZXJ2YWwnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIGFuZCByZXR1cm4gY3JlZHNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjcmVkcyA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgaWYgKCFjcmVkcy5kZXZpY2VJRCB8fCAhY3JlZHMucGFzc3dvcmQpXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBjcmVkZW50aWFscyByZXR1cm5lZCBmcm9tIExhdHRpY2UuJykpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGNyZWRzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9wZW4gdGhlIHRhYlxuICAgICAgdGhpcy5fb3BlbkNvbm5lY3RvclRhYih1cmwpXG4gICAgICAudGhlbigoY29ubikgPT4ge1xuICAgICAgICBpZiAoY29ubi5jaHJvbWl1bSkge1xuICAgICAgICAgIC8vIE9uIGEgQ2hyb21pdW0gYnJvd3NlciB3ZSBjYW4ganVzdCBsaXN0ZW4gZm9yIGEgd2luZG93IG1lc3NhZ2VcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgcmVjZWl2ZU1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgICAvLyBXYXRjaCBmb3IgdGhlIG9wZW4gd2luZG93IGNsb3NpbmcgYmVmb3JlIGNyZWRzIGFyZSBzZW50IGJhY2tcbiAgICAgICAgICBsaXN0ZW5JbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb25uLmNocm9taXVtLmNsb3NlZCkge1xuICAgICAgICAgICAgICBjbGVhckludGVydmFsKGxpc3RlbkludGVydmFsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ0xhdHRpY2UgY29ubmVjdG9yIGNsb3NlZC4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25uLmZpcmVmb3gpIHtcbiAgICAgICAgICAvLyBGb3IgRmlyZWZveCB3ZSBjYW5ub3QgdXNlIGB3aW5kb3dgIGluIHRoZSBleHRlbnNpb24gYW5kIGNhbid0XG4gICAgICAgICAgLy8gZGlyZWN0bHkgY29tbXVuaWNhdGUgd2l0aCB0aGUgdGFicyB2ZXJ5IGVhc2lseSBzbyB3ZSB1c2UgYVxuICAgICAgICAgIC8vIHdvcmthcm91bmQ6IGxpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGUgVVJMLCB3aGljaCB3aWxsIGNvbnRhaW5cbiAgICAgICAgICAvLyB0aGUgbG9naW4gaW5mby5cbiAgICAgICAgICAvLyBOT1RFOiBUaGlzIHdpbGwgb25seSB3b3JrIGlmIGhhdmUgYGh0dHBzOi8vd2FsbGV0LmdyaWRwbHVzLmlvLypgXG4gICAgICAgICAgLy8gaG9zdCBwZXJtaXNzaW9ucyBpbiB5b3VyIG1hbmlmZXN0IGZpbGUgKGFuZCBhbHNvIGBhY3RpdmVUYWJgIHBlcm1pc3Npb24pXG4gICAgICAgICAgY29uc3QgbG9naW5VcmxQYXJhbSA9ICcmbG9naW5DYWNoZT0nO1xuICAgICAgICAgIGxpc3RlbkludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZmluZFRhYkJ5SWQoY29ubi5maXJlZm94LmlkKVxuICAgICAgICAgICAgLnRoZW4oKHRhYikgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXRhYiB8fCAhdGFiLnVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdMYXR0aWNlIGNvbm5lY3RvciBjbG9zZWQuJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIElmIHRoZSB0YWIgd2Ugb3BlbmVkIGNvbnRhaW5zIGEgbmV3IFVSTCBwYXJhbVxuICAgICAgICAgICAgICBjb25zdCBwYXJhbUxvYyA9IHRhYi51cmwuaW5kZXhPZihsb2dpblVybFBhcmFtKTtcbiAgICAgICAgICAgICAgaWYgKHBhcmFtTG9jIDwgMCkgXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBjb25zdCBkYXRhTG9jID0gcGFyYW1Mb2MgKyBsb2dpblVybFBhcmFtLmxlbmd0aDtcbiAgICAgICAgICAgICAgLy8gU3RvcCB0aGlzIGludGVydmFsXG4gICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwobGlzdGVuSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBsb2dpbiBkYXRhLiBJdCBpcyBhIHN0cmluZ2lmaWVkIEpTT04gb2JqZWN0IFxuICAgICAgICAgICAgICAgIC8vIGVuY29kZWQgYXMgYSBiYXNlNjQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGNvbnN0IF9jcmVkcyA9IEJ1ZmZlci5mcm9tKHRhYi51cmwuc2xpY2UoZGF0YUxvYyksICdiYXNlNjQnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIC8vIENsb3NlIHRoZSB0YWIgYW5kIHJldHVybiB0aGUgY3JlZGVudGlhbHNcbiAgICAgICAgICAgICAgICBicm93c2VyLnRhYnMucmVtb3ZlKHRhYi5pZClcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjcmVkcyA9IEpTT04ucGFyc2UoX2NyZWRzKTtcbiAgICAgICAgICAgICAgICAgIGlmICghY3JlZHMuZGV2aWNlSUQgfHwgIWNyZWRzLnBhc3N3b3JkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBjcmVkZW50aWFscyByZXR1cm5lZCBmcm9tIExhdHRpY2UuJykpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoY3JlZHMpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoJ0ZhaWxlZCB0byBnZXQgbG9naW4gZGF0YSBmcm9tIExhdHRpY2UuIFBsZWFzZSB0cnkgYWdhaW4uJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBbcmVdY29ubmVjdCB0byB0aGUgTGF0dGljZS4gVGhpcyBzaG91bGQgYmUgZG9uZSBmcmVxdWVudGx5IHRvIGVuc3VyZVxuICAvLyB0aGUgZXhwZWN0ZWQgd2FsbGV0IFVJRCBpcyBzdGlsbCB0aGUgb25lIGFjdGl2ZSBpbiB0aGUgTGF0dGljZS5cbiAgLy8gVGhpcyB3aWxsIGhhbmRsZSBTYWZlQ2FyZCBpbnNlcnRpb24vcmVtb3ZhbCBldmVudHMuXG4gIF9jb25uZWN0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnNka1Nlc3Npb24uY29ubmVjdCh0aGlzLmNyZWRzLmRldmljZUlELCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHdhbGxldCBVSURcbiAgICAgICAgY29uc3QgYWN0aXZlV2FsbGV0ID0gdGhpcy5zZGtTZXNzaW9uLmdldEFjdGl2ZVdhbGxldCgpO1xuICAgICAgICBpZiAoIWFjdGl2ZVdhbGxldCB8fCAhYWN0aXZlV2FsbGV0LnVpZClcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTm8gYWN0aXZlIHdhbGxldCcpKTtcbiAgICAgICAgY29uc3QgbmV3VUlEID0gYWN0aXZlV2FsbGV0LnVpZC50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIC8vIElmIHdlIGZldGNoZWQgYSB3YWxsZXRVSUQgdGhhdCBkb2VzIG5vdCBtYXRjaCBvdXIgY3VycmVudCBvbmUsXG4gICAgICAgIC8vIHJlc2V0IGFjY291bnRzIGFuZCB1cGRhdGUgdGhlIGtub3duIFVJRFxuICAgICAgICBpZiAobmV3VUlEICE9IHRoaXMud2FsbGV0VUlEKSB7XG4gICAgICAgICAgdGhpcy53YWxsZXRVSUQgPSBuZXdVSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pXG4gIH1cblxuICBfaW5pdFNlc3Npb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLl9oYXNTZXNzaW9uKCkpXG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgdXJsID0gJ2h0dHBzOi8vc2lnbmluZy5ncmlkcGwudXMnO1xuICAgICAgICBpZiAodGhpcy5jcmVkcy5lbmRwb2ludClcbiAgICAgICAgICB1cmwgPSB0aGlzLmNyZWRzLmVuZHBvaW50XG4gICAgICAgIGNvbnN0IHNldHVwRGF0YSA9IHtcbiAgICAgICAgICBuYW1lOiB0aGlzLmFwcE5hbWUsXG4gICAgICAgICAgYmFzZVVybDogdXJsLFxuICAgICAgICAgIGNyeXB0byxcbiAgICAgICAgICB0aW1lb3V0OiAxMjAwMDAsXG4gICAgICAgICAgcHJpdktleTogdGhpcy5fZ2VuU2Vzc2lvbktleSgpLFxuICAgICAgICAgIG5ldHdvcms6IHRoaXMubmV0d29ya1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2RrU2Vzc2lvbiA9IG5ldyBTREsuQ2xpZW50KHNldHVwRGF0YSk7XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBfZmV0Y2hBZGRyZXNzZXMobj0xLCBpPTAsIHJlY3Vyc2VkQWRkcnM9W10pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9oYXNTZXNzaW9uKCkpXG4gICAgICAgIHJldHVybiByZWplY3QoJ05vIFNESyBzZXNzaW9uIHN0YXJ0ZWQuIENhbm5vdCBmZXRjaCBhZGRyZXNzZXMuJylcblxuICAgICAgdGhpcy5fX2ZldGNoQWRkcmVzc2VzKG4sIGksIChlcnIsIGFkZHJzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoYWRkcnMpO1xuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgX19mZXRjaEFkZHJlc3NlcyhuPTEsIGk9MCwgY2IsIHJlY3Vyc2VkQWRkcnM9W10pIHtcbiAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gZG8gYSByZWN1cnNpdmUgY2FsbCBoZXJlLiBXZSBwcmVmZXIgbm90IHRvXG4gICAgICAvLyBiZWNhdXNlIHRoZXkgd2lsbCBiZSBtdWNoIHNsb3dlciwgYnV0IExlZGdlciBwYXRocyByZXF1aXJlIGl0IHNpbmNlXG4gICAgICAvLyB0aGV5IGFyZSBub24tc3RhbmRhcmQuXG4gICAgICBpZiAobiA9PT0gMClcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHJlY3Vyc2VkQWRkcnMpO1xuICAgICAgY29uc3Qgc2hvdWxkUmVjdXJzZSA9IHRoaXMuX2hkUGF0aEhhc0ludGVybmFsVmFySWR4KCk7XG5cbiAgICAgIC8vIE1ha2UgdGhlIHJlcXVlc3QgdG8gZ2V0IHRoZSByZXF1ZXN0ZWQgYWRkcmVzc1xuICAgICAgY29uc3QgYWRkckRhdGEgPSB7IFxuICAgICAgICBjdXJyZW5jeTogJ0VUSCcsIFxuICAgICAgICBzdGFydFBhdGg6IHRoaXMuX2dldEhEUGF0aEluZGljZXModGhpcy5oZFBhdGgsIGkpLCBcbiAgICAgICAgbjogc2hvdWxkUmVjdXJzZSA/IDEgOiBuLFxuICAgICAgICBza2lwQ2FjaGU6IHRydWUsXG4gICAgICB9O1xuICAgICAgdGhpcy5zZGtTZXNzaW9uLmdldEFkZHJlc3NlcyhhZGRyRGF0YSwgKGVyciwgYWRkcnMpID0+IHtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrIC0tIGlmIHRoaXMgcmV0dXJuZWQgMCBhZGRyZXNzZXMsIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgICAgaWYgKGFkZHJzLmxlbmd0aCA8IDEpXG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignTm8gYWRkcmVzc2VzIHJldHVybmVkJykpO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGFkZHJlc3NlcyB3ZSBmZXRjaGVkICp3aXRob3V0KiB1cGRhdGluZyBzdGF0ZVxuICAgICAgICBpZiAoc2hvdWxkUmVjdXJzZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9fZmV0Y2hBZGRyZXNzZXMobi0xLCBpKzEsIGNiLCByZWN1cnNlZEFkZHJzLmNvbmNhdChhZGRycykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCBhZGRycyk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICBfc2lnblR4RGF0YSh0eERhdGEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9oYXNTZXNzaW9uKCkpXG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdObyBTREsgc2Vzc2lvbiBzdGFydGVkLiBDYW5ub3Qgc2lnbiB0cmFuc2FjdGlvbi4nKSk7XG4gICAgICB0aGlzLnNka1Nlc3Npb24uc2lnbih7IGN1cnJlbmN5OiAnRVRIJywgZGF0YTogdHhEYXRhIH0sIChlcnIsIHJlcykgPT4ge1xuICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgaWYgKCFyZXMudHgpXG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vIHRyYW5zYWN0aW9uIHBheWxvYWQgcmV0dXJuZWQuJykpO1xuICAgICAgICAvLyBIZXJlIHdlIGNhdGNoIGFuIGVkZ2UgY2FzZSB3aGVyZSB0aGUgcmVxdWVzdGVyIGlzIGFza2luZyBmb3IgYW4gRUlQMTU1OVxuICAgICAgICAvLyB0cmFuc2FjdGlvbiBidXQgZmlybXdhcmUgaXMgbm90IHVwZGF0ZWQgdG8gc3VwcG9ydCBpdC4gV2UgZmFsbGJhY2sgdG8gbGVnYWN5LlxuICAgICAgICByZXMudHlwZSA9IHR4RGF0YS50eXBlO1xuICAgICAgICBpZiAodHhEYXRhLnJldmVydFRvTGVnYWN5KSB7XG4gICAgICAgICAgcmVzLnJldmVydFRvTGVnYWN5ID0gdHJ1ZTtcbiAgICAgICAgICByZXMuZ2FzUHJpY2UgPSB0eERhdGEuZ2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBzaWduZWQgdHhcbiAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgX2dldFBhZ2UoaW5jcmVtZW50PTApIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5wYWdlICs9IGluY3JlbWVudDtcbiAgICAgIGlmICh0aGlzLnBhZ2UgPCAwKVxuICAgICAgICB0aGlzLnBhZ2UgPSAwO1xuICAgICAgY29uc3Qgc3RhcnQgPSBQRVJfUEFHRSAqIHRoaXMucGFnZTtcbiAgICAgIC8vIE90aGVyd2lzZSB1bmxvY2sgdGhlIGRldmljZSBhbmQgZmV0Y2ggbW9yZSBhZGRyZXNzZXNcbiAgICAgIHRoaXMudW5sb2NrKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoQWRkcmVzc2VzKFBFUl9QQUdFLCBzdGFydClcbiAgICAgIH0pXG4gICAgICAudGhlbigoYWRkcnMpID0+IHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBbXVxuICAgICAgICBhZGRycy5mb3JFYWNoKChhZGRyZXNzLCBpKSA9PiB7XG4gICAgICAgICAgYWNjb3VudHMucHVzaCh7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgYmFsYW5jZTogbnVsbCxcbiAgICAgICAgICAgIGluZGV4OiBzdGFydCArIGksXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoYWNjb3VudHMpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgX2hhc0NyZWRzKCkge1xuICAgIHJldHVybiB0aGlzLmNyZWRzLmRldmljZUlEICE9PSBudWxsICYmIHRoaXMuY3JlZHMucGFzc3dvcmQgIT09IG51bGwgJiYgdGhpcy5hcHBOYW1lO1xuICB9XG5cbiAgX2hhc1Nlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrU2Vzc2lvbiAmJiB0aGlzLndhbGxldFVJRDtcbiAgfVxuXG4gIF9nZW5TZXNzaW9uS2V5KCkge1xuICAgIGlmICh0aGlzLm5hbWUgJiYgIXRoaXMuYXBwTmFtZSkgLy8gTWlncmF0ZSBmcm9tIGxlZ2FjeSBwYXJhbSBpZiBuZWVkZWRcbiAgICAgIHRoaXMuYXBwTmFtZSA9IHRoaXMubmFtZTtcbiAgICBpZiAoIXRoaXMuX2hhc0NyZWRzKCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNyZWRlbnRpYWxzIC0tIGNhbm5vdCBjcmVhdGUgc2Vzc2lvbiBrZXkhJyk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBCdWZmZXIuZnJvbSh0aGlzLmNyZWRzLnBhc3N3b3JkKSwgXG4gICAgICBCdWZmZXIuZnJvbSh0aGlzLmNyZWRzLmRldmljZUlEKSwgXG4gICAgICBCdWZmZXIuZnJvbSh0aGlzLmFwcE5hbWUpXG4gICAgXSlcbiAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShidWYpLmRpZ2VzdCgpO1xuICB9XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGFuIEhEIHBhdGggaGFzIGEgdmFyaWFibGUgaW5kZXggaW50ZXJuYWwgdG8gaXQuXG4gIC8vIGUuZy4gbS80NCcvNjAnL3gnLzAvMCAtPiB0cnVlLCB3aGlsZSBtLzQ0Jy82MCcvMCcvMC94IC0+IGZhbHNlXG4gIC8vIFRoaXMgaXMganVzdCBhIGhhY2t5IGhlbHBlciB0byBhdm9pZCBoYXZpbmcgdG8gcmVjdXJzaXZlbHkgY2FsbCBmb3Igbm9uLWxlZGdlclxuICAvLyBkZXJpdmF0aW9uIHBhdGhzLiBMZWRnZXIgaXMgU08gQU5OT1lJTkcgVE8gU1VQUE9SVC5cbiAgX2hkUGF0aEhhc0ludGVybmFsVmFySWR4KCkge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLmhkUGF0aC5zcGxpdCgnLycpLnNsaWNlKDEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLTE7IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0uaW5kZXhPZigneCcpID4gLTEpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBHZXQgdGhlIGNoYWluSWQgZm9yIHdoYXRldmVyIG9iamVjdCB0aGlzIGlzLlxuICAvLyBSZXR1cm5zIGEgaGV4IHN0cmluZyB3aXRob3V0IHRoZSAweCBwcmVmaXhcbiAgX2dldEV0aGVyZXVtSnNDaGFpbklkKHR4KSB7XG4gICAgaWYgKHR5cGVvZiB0eC5nZXRDaGFpbklkID09PSAnZnVuY3Rpb24nKVxuICAgICAgcmV0dXJuIHR4LmdldENoYWluSWQoKTtcbiAgICBlbHNlIGlmICh0eC5jb21tb24gJiYgdHlwZW9mIHR4LmNvbW1vbi5jaGFpbklkQk4gPT09ICdmdW5jdGlvbicpXG4gICAgICByZXR1cm4gdHguY29tbW9uLmNoYWluSWRCTigpLnRvU3RyaW5nKDE2KTtcbiAgICBlbHNlIGlmICh0eXBlb2YgdHguY2hhaW5JZCA9PT0gJ251bWJlcicpXG4gICAgICByZXR1cm4gdHguY2hhaW5JZC50b1N0cmluZygxNik7XG4gICAgZWxzZSBpZiAodHlwZW9mIHR4LmNoYWluSWQgPT09ICdzdHJpbmcnKVxuICAgICAgcmV0dXJuIHR4LmNoYWluSWQ7XG4gICAgcmV0dXJuICcxJztcbiAgfVxuXG4gIF9nZXRDdXJyZW50V2FsbGV0VUlEKCkge1xuICAgIGlmICghdGhpcy5zZGtTZXNzaW9uKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuc2RrU2Vzc2lvbi5nZXRBY3RpdmVXYWxsZXQoKS51aWQudG9TdHJpbmcoJ2hleCcpO1xuICB9XG5cbn1cblxuTGF0dGljZUtleXJpbmcudHlwZSA9IGtleXJpbmdUeXBlXG5tb2R1bGUuZXhwb3J0cyA9IExhdHRpY2VLZXlyaW5nOyIsImltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IHsgbWFwVmFsdWVzLCBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGFiaSBmcm9tICdodW1hbi1zdGFuZGFyZC10b2tlbi1hYmknO1xuaW1wb3J0IHsgY2FsY1Rva2VuQW1vdW50IH0gZnJvbSAnLi4vLi4vLi4vdWkvaGVscGVycy91dGlscy90b2tlbi11dGlsJztcbmltcG9ydCB7IGNhbGNHYXNUb3RhbCB9IGZyb20gJy4uLy4uLy4uL3VpL3BhZ2VzL3NlbmQvc2VuZC51dGlscyc7XG5pbXBvcnQge1xuICBjb252ZXJzaW9uVXRpbCxcbiAgZGVjR1dFSVRvSGV4V0VJLFxuICBhZGRDdXJyZW5jaWVzLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9jb252ZXJzaW9uLnV0aWxzJztcbmltcG9ydCB7XG4gIERFRkFVTFRfRVJDMjBfQVBQUk9WRV9HQVMsXG4gIFFVT1RFU19FWFBJUkVEX0VSUk9SLFxuICBRVU9URVNfTk9UX0FWQUlMQUJMRV9FUlJPUixcbiAgU1dBUFNfRkVUQ0hfT1JERVJfQ09ORkxJQ1QsXG4gIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVAsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvc3dhcHMnO1xuaW1wb3J0IHsgR0FTX0VTVElNQVRFX1RZUEVTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9nYXMnO1xuXG5pbXBvcnQgeyBpc1N3YXBzRGVmYXVsdFRva2VuQWRkcmVzcyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3N3YXBzLnV0aWxzJztcblxuaW1wb3J0IHtcbiAgZmV0Y2hUcmFkZXNJbmZvIGFzIGRlZmF1bHRGZXRjaFRyYWRlc0luZm8sXG4gIGdldEJhc2VBcGksXG59IGZyb20gJy4uLy4uLy4uL3VpL3BhZ2VzL3N3YXBzL3N3YXBzLnV0aWwnO1xuaW1wb3J0IGZldGNoV2l0aENhY2hlIGZyb20gJy4uLy4uLy4uL3VpL2hlbHBlcnMvdXRpbHMvZmV0Y2gtd2l0aC1jYWNoZSc7XG5pbXBvcnQgeyBNSU5VVEUsIFNFQ09ORCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdGltZSc7XG5pbXBvcnQgeyBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlIH0gZnJvbSAnLi4vLi4vLi4vdWkvaGVscGVycy91dGlscy91dGlsJztcbmltcG9ydCB7IE5FVFdPUktfRVZFTlRTIH0gZnJvbSAnLi9uZXR3b3JrJztcblxuLy8gVGhlIE1BWF9HQVNfTElNSVQgaXMgYSBudW1iZXIgdGhhdCBpcyBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBnYXMgY29zdHMgd2UgaGF2ZSBvYnNlcnZlZCBvbiBhbnkgYWdncmVnYXRvclxuY29uc3QgTUFYX0dBU19MSU1JVCA9IDI1MDAwMDA7XG5cbi8vIFRvIGVuc3VyZSB0aGF0IG91ciBzZXJ2ZXMgYXJlIG5vdCBzcGFtbWVkIGlmIE1ldGFNYXNrIGlzIGxlZnQgaWRsZSwgd2UgbGltaXQgdGhlIG51bWJlciBvZiBmZXRjaGVzIGZvciBxdW90ZXMgdGhhdCBhcmUgbWFkZSBvbiB0aW1lZCBpbnRlcnZhbHMuXG4vLyAzIHNlZW1zIHRvIGJlIGFuIGFwcHJvcHJpYXRlIGJhbGFuY2Ugb2YgZ2l2aW5nIHVzZXJzIHRoZSB0aW1lIHRoZXkgbmVlZCB3aGVuIE1ldGFNYXNrIGlzIG5vdCBsZWZ0IGlkbGUsIGFuZCB0dXJuaW5nIHBvbGxpbmcgb2ZmIHdoZW4gaXQgaXMuXG5jb25zdCBQT0xMX0NPVU5UX0xJTUlUID0gMztcblxuLy8gSWYgZm9yIGFueSByZWFzb24gdGhlIE1ldGFTd2FwIEFQSSBmYWlscyB0byBwcm92aWRlIGEgcmVmcmVzaCB0aW1lLFxuLy8gcHJvdmlkZSBhIHJlYXNvbmFibGUgZmFsbGJhY2sgdG8gYXZvaWQgZnVydGhlciBlcnJvcnNcbmNvbnN0IEZBTExCQUNLX1FVT1RFX1JFRlJFU0hfVElNRSA9IE1JTlVURTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlR2FzRXN0aW1hdGVXaXRoUmVmdW5kKFxuICBtYXhHYXMgPSBNQVhfR0FTX0xJTUlULFxuICBlc3RpbWF0ZWRSZWZ1bmQgPSAwLFxuICBlc3RpbWF0ZWRHYXMgPSAwLFxuKSB7XG4gIGNvbnN0IG1heEdhc01pbnVzUmVmdW5kID0gbmV3IEJpZ051bWJlcihtYXhHYXMsIDEwKS5taW51cyhcbiAgICBlc3RpbWF0ZWRSZWZ1bmQsXG4gICAgMTAsXG4gICk7XG5cbiAgY29uc3QgZ2FzRXN0aW1hdGVXaXRoUmVmdW5kID0gbWF4R2FzTWludXNSZWZ1bmQubHQoZXN0aW1hdGVkR2FzLCAxNilcbiAgICA/IG1heEdhc01pbnVzUmVmdW5kLnRvU3RyaW5nKDE2KVxuICAgIDogZXN0aW1hdGVkR2FzO1xuXG4gIHJldHVybiBnYXNFc3RpbWF0ZVdpdGhSZWZ1bmQ7XG59XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgc3dhcHNTdGF0ZToge1xuICAgIHF1b3Rlczoge30sXG4gICAgcXVvdGVzUG9sbGluZ0xpbWl0RW5hYmxlZDogZmFsc2UsXG4gICAgZmV0Y2hQYXJhbXM6IG51bGwsXG4gICAgdG9rZW5zOiBudWxsLFxuICAgIHRyYWRlVHhJZDogbnVsbCxcbiAgICBhcHByb3ZlVHhJZDogbnVsbCxcbiAgICBxdW90ZXNMYXN0RmV0Y2hlZDogbnVsbCxcbiAgICBjdXN0b21NYXhHYXM6ICcnLFxuICAgIGN1c3RvbUdhc1ByaWNlOiBudWxsLFxuICAgIGN1c3RvbU1heEZlZVBlckdhczogbnVsbCxcbiAgICBjdXN0b21NYXhQcmlvcml0eUZlZVBlckdhczogbnVsbCxcbiAgICBzd2Fwc1VzZXJGZWVMZXZlbDogJycsXG4gICAgc2VsZWN0ZWRBZ2dJZDogbnVsbCxcbiAgICBjdXN0b21BcHByb3ZlVHhEYXRhOiAnJyxcbiAgICBlcnJvcktleTogJycsXG4gICAgdG9wQWdnSWQ6IG51bGwsXG4gICAgcm91dGVTdGF0ZTogJycsXG4gICAgc3dhcHNGZWF0dXJlSXNMaXZlOiB0cnVlLFxuICAgIHNhdmVGZXRjaGVkUXVvdGVzOiBmYWxzZSxcbiAgICBzd2Fwc1F1b3RlUmVmcmVzaFRpbWU6IEZBTExCQUNLX1FVT1RFX1JFRlJFU0hfVElNRSxcbiAgICBzd2Fwc1F1b3RlUHJlZmV0Y2hpbmdSZWZyZXNoVGltZTogRkFMTEJBQ0tfUVVPVEVfUkVGUkVTSF9USU1FLFxuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3dhcHNDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGdldEJ1ZmZlcmVkR2FzTGltaXQsXG4gICAgbmV0d29ya0NvbnRyb2xsZXIsXG4gICAgcHJvdmlkZXIsXG4gICAgZ2V0UHJvdmlkZXJDb25maWcsXG4gICAgZ2V0VG9rZW5SYXRlc1N0YXRlLFxuICAgIGZldGNoVHJhZGVzSW5mbyA9IGRlZmF1bHRGZXRjaFRyYWRlc0luZm8sXG4gICAgZ2V0Q3VycmVudENoYWluSWQsXG4gICAgZ2V0RUlQMTU1OUdhc0ZlZUVzdGltYXRlcyxcbiAgfSkge1xuICAgIHRoaXMuc3RvcmUgPSBuZXcgT2JzZXJ2YWJsZVN0b3JlKHtcbiAgICAgIHN3YXBzU3RhdGU6IHsgLi4uaW5pdGlhbFN0YXRlLnN3YXBzU3RhdGUgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuX2ZldGNoVHJhZGVzSW5mbyA9IGZldGNoVHJhZGVzSW5mbztcbiAgICB0aGlzLl9nZXRDdXJyZW50Q2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkO1xuICAgIHRoaXMuX2dldEVJUDE1NTlHYXNGZWVFc3RpbWF0ZXMgPSBnZXRFSVAxNTU5R2FzRmVlRXN0aW1hdGVzO1xuXG4gICAgdGhpcy5nZXRCdWZmZXJlZEdhc0xpbWl0ID0gZ2V0QnVmZmVyZWRHYXNMaW1pdDtcbiAgICB0aGlzLmdldFRva2VuUmF0ZXNTdGF0ZSA9IGdldFRva2VuUmF0ZXNTdGF0ZTtcblxuICAgIHRoaXMucG9sbENvdW50ID0gMDtcbiAgICB0aGlzLmdldFByb3ZpZGVyQ29uZmlnID0gZ2V0UHJvdmlkZXJDb25maWc7XG5cbiAgICB0aGlzLmluZGV4T2ZOZXdlc3RDYWxsSW5GbGlnaHQgPSAwO1xuXG4gICAgdGhpcy5ldGhlcnNQcm92aWRlciA9IG5ldyBldGhlcnMucHJvdmlkZXJzLldlYjNQcm92aWRlcihwcm92aWRlcik7XG4gICAgdGhpcy5fY3VycmVudE5ldHdvcmsgPSBuZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLm5ldHdvcms7XG4gICAgbmV0d29ya0NvbnRyb2xsZXIub24oTkVUV09SS19FVkVOVFMuTkVUV09SS19ESURfQ0hBTkdFLCAobmV0d29yaykgPT4ge1xuICAgICAgaWYgKG5ldHdvcmsgIT09ICdsb2FkaW5nJyAmJiBuZXR3b3JrICE9PSB0aGlzLl9jdXJyZW50TmV0d29yaykge1xuICAgICAgICB0aGlzLl9jdXJyZW50TmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgIHRoaXMuZXRoZXJzUHJvdmlkZXIgPSBuZXcgZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZmV0Y2hTd2Fwc1JlZnJlc2hSYXRlcyhjaGFpbklkKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhDYWNoZShcbiAgICAgIGdldEJhc2VBcGkoJ25ldHdvcmsnLCBjaGFpbklkKSxcbiAgICAgIHsgbWV0aG9kOiAnR0VUJyB9LFxuICAgICAgeyBjYWNoZVJlZnJlc2hUaW1lOiA2MDAwMDAgfSxcbiAgICApO1xuICAgIGNvbnN0IHsgcmVmcmVzaFJhdGVzIH0gPSByZXNwb25zZSB8fCB7fTtcbiAgICBpZiAoXG4gICAgICAhcmVmcmVzaFJhdGVzIHx8XG4gICAgICB0eXBlb2YgcmVmcmVzaFJhdGVzLnF1b3RlcyAhPT0gJ251bWJlcicgfHxcbiAgICAgIHR5cGVvZiByZWZyZXNoUmF0ZXMucXVvdGVzUHJlZmV0Y2hpbmcgIT09ICdudW1iZXInXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBNZXRhTWFzayAtIGludmFsaWQgcmVzcG9uc2UgZm9yIHJlZnJlc2hSYXRlczogJHtyZXNwb25zZX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gV2UgcHJlc2VudGx5IHVzZSBtaWxsaXNlY29uZHMgaW4gdGhlIFVJLlxuICAgIHJldHVybiB7XG4gICAgICBxdW90ZXM6IHJlZnJlc2hSYXRlcy5xdW90ZXMgKiAxMDAwLFxuICAgICAgcXVvdGVzUHJlZmV0Y2hpbmc6IHJlZnJlc2hSYXRlcy5xdW90ZXNQcmVmZXRjaGluZyAqIDEwMDAsXG4gICAgfTtcbiAgfVxuXG4gIC8vIFNldHMgdGhlIHJlZnJlc2ggcmF0ZSBmb3IgcXVvdGUgdXBkYXRlcyBmcm9tIHRoZSBNZXRhU3dhcCBBUElcbiAgYXN5bmMgX3NldFN3YXBzUmVmcmVzaFJhdGVzKCkge1xuICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLl9nZXRDdXJyZW50Q2hhaW5JZCgpO1xuICAgIGxldCBzd2Fwc1JlZnJlc2hSYXRlcztcbiAgICB0cnkge1xuICAgICAgc3dhcHNSZWZyZXNoUmF0ZXMgPSBhd2FpdCB0aGlzLmZldGNoU3dhcHNSZWZyZXNoUmF0ZXMoY2hhaW5JZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignUmVxdWVzdCBmb3Igc3dhcHMgcXVvdGUgcmVmcmVzaCB0aW1lIGZhaWxlZDogJywgZSk7XG4gICAgfVxuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZTogbGF0ZXN0U3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgc3dhcHNTdGF0ZToge1xuICAgICAgICAuLi5sYXRlc3RTd2Fwc1N0YXRlLFxuICAgICAgICBzd2Fwc1F1b3RlUmVmcmVzaFRpbWU6XG4gICAgICAgICAgc3dhcHNSZWZyZXNoUmF0ZXM/LnF1b3RlcyB8fCBGQUxMQkFDS19RVU9URV9SRUZSRVNIX1RJTUUsXG4gICAgICAgIHN3YXBzUXVvdGVQcmVmZXRjaGluZ1JlZnJlc2hUaW1lOlxuICAgICAgICAgIHN3YXBzUmVmcmVzaFJhdGVzPy5xdW90ZXNQcmVmZXRjaGluZyB8fCBGQUxMQkFDS19RVU9URV9SRUZSRVNIX1RJTUUsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLy8gT25jZSBxdW90ZXMgYXJlIGZldGNoZWQsIHdlIHBvbGwgZm9yIG5ldyBvbmVzIHRvIGtlZXAgdGhlIHF1b3RlcyB1cCB0byBkYXRlLiBNYXJrZXQgYW5kIGFnZ3JlZ2F0b3IgY29udHJhY3QgY29uZGl0aW9ucyBjYW4gY2hhbmdlIGZhc3QgZW5vdWdoXG4gIC8vIHRoYXQgcXVvdGVzIHdpbGwgbm8gbG9uZ2VyIGJlIGF2YWlsYWJsZSBhZnRlciAxIG9yIDIgbWludXRlcy4gV2hlbiBmZXRjaEFuZFNldFF1b3RlcyBpcyBmaXJzdCBjYWxsZWQsIGl0IHJlY2VpdmVzIGZldGNoIHBhcmFtZXRlcnMgdGhhdCBhcmUgc3RvcmVkIGluXG4gIC8vIHN0YXRlLiBUaGVzZSBzdG9yZWQgcGFyYW1ldGVycyBhcmUgdXNlZCBvbiBzdWJzZXF1ZW50IGNhbGxzIG1hZGUgZHVyaW5nIHBvbGxpbmcuXG4gIC8vIE5vdGU6IHdlIHN0b3AgcG9sbGluZyBhZnRlciAzIHJlcXVlc3RzLCB1bnRpbCBuZXcgcXVvdGVzIGFyZSBleHBsaWNpdGx5IGFza2VkIGZvci4gVGhlIGxvZ2ljIHRoYXQgZW5mb3JjZXMgdGhhdCBtYXhpbXVtIGlzIGluIHRoZSBib2R5IG9mIGZldGNoQW5kU2V0UXVvdGVzXG4gIHBvbGxGb3JOZXdRdW90ZXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3dhcHNTdGF0ZToge1xuICAgICAgICBzd2Fwc1F1b3RlUmVmcmVzaFRpbWUsXG4gICAgICAgIHN3YXBzUXVvdGVQcmVmZXRjaGluZ1JlZnJlc2hUaW1lLFxuICAgICAgICBxdW90ZXNQb2xsaW5nTGltaXRFbmFibGVkLFxuICAgICAgfSxcbiAgICB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIC8vIHN3YXBzUXVvdGVSZWZyZXNoVGltZSBpcyB1c2VkIG9uIHRoZSBWaWV3IFF1b3RlIHBhZ2UsIHN3YXBzUXVvdGVQcmVmZXRjaGluZ1JlZnJlc2hUaW1lIGlzIHVzZWQgb24gdGhlIEJ1aWxkIFF1b3RlIHBhZ2UuXG4gICAgY29uc3QgcXVvdGVzUmVmcmVzaFJhdGVJbk1zID0gcXVvdGVzUG9sbGluZ0xpbWl0RW5hYmxlZFxuICAgICAgPyBzd2Fwc1F1b3RlUmVmcmVzaFRpbWVcbiAgICAgIDogc3dhcHNRdW90ZVByZWZldGNoaW5nUmVmcmVzaFRpbWU7XG4gICAgdGhpcy5wb2xsaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICB0aGlzLmZldGNoQW5kU2V0UXVvdGVzKFxuICAgICAgICBzd2Fwc1N0YXRlLmZldGNoUGFyYW1zLFxuICAgICAgICBzd2Fwc1N0YXRlLmZldGNoUGFyYW1zPy5tZXRhRGF0YSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICk7XG4gICAgfSwgcXVvdGVzUmVmcmVzaFJhdGVJbk1zKTtcbiAgfVxuXG4gIHN0b3BQb2xsaW5nRm9yUXVvdGVzKCkge1xuICAgIGlmICh0aGlzLnBvbGxpbmdUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5wb2xsaW5nVGltZW91dCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hBbmRTZXRRdW90ZXMoXG4gICAgZmV0Y2hQYXJhbXMsXG4gICAgZmV0Y2hQYXJhbXNNZXRhRGF0YSA9IHt9LFxuICAgIGlzUG9sbGVkUmVxdWVzdCxcbiAgKSB7XG4gICAgY29uc3QgeyBjaGFpbklkIH0gPSBmZXRjaFBhcmFtc01ldGFEYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHN3YXBzU3RhdGU6IHsgcXVvdGVzUG9sbGluZ0xpbWl0RW5hYmxlZCwgc2F2ZUZldGNoZWRRdW90ZXMgfSxcbiAgICB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgaWYgKCFmZXRjaFBhcmFtcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEV2ZXJ5IHRpbWUgd2UgZ2V0IGEgbmV3IHJlcXVlc3QgdGhhdCBpcyBub3QgZnJvbSB0aGUgcG9sbGluZywgd2UgcmVzZXQgdGhlIHBvbGwgY291bnQgc28gd2UgY2FuIHBvbGwgZm9yIHVwIHRvIHRocmVlIG1vcmUgc2V0cyBvZiBxdW90ZXMgd2l0aCB0aGVzZSBuZXcgcGFyYW1zLlxuICAgIGlmICghaXNQb2xsZWRSZXF1ZXN0KSB7XG4gICAgICB0aGlzLnBvbGxDb3VudCA9IDA7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgYXJlIGFueSBwZW5kaW5nIHBvbGwgcmVxdWVzdHMsIGNsZWFyIHRoZW0gc28gdGhhdCB0aGV5IGRvbid0IGdldCBjYWxsIHdoaWxlIHRoaXMgbmV3IGZldGNoIGlzIGluIHByb2Nlc3NcbiAgICBjbGVhclRpbWVvdXQodGhpcy5wb2xsaW5nVGltZW91dCk7XG5cbiAgICBpZiAoIWlzUG9sbGVkUmVxdWVzdCkge1xuICAgICAgdGhpcy5zZXRTd2Fwc0Vycm9yS2V5KCcnKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleE9mQ3VycmVudENhbGwgPSB0aGlzLmluZGV4T2ZOZXdlc3RDYWxsSW5GbGlnaHQgKyAxO1xuICAgIHRoaXMuaW5kZXhPZk5ld2VzdENhbGxJbkZsaWdodCA9IGluZGV4T2ZDdXJyZW50Q2FsbDtcblxuICAgIGlmICghc2F2ZUZldGNoZWRRdW90ZXMpIHtcbiAgICAgIHRoaXMuc2V0U2F2ZUZldGNoZWRRdW90ZXModHJ1ZSk7XG4gICAgfVxuXG4gICAgbGV0IFtuZXdRdW90ZXNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5fZmV0Y2hUcmFkZXNJbmZvKGZldGNoUGFyYW1zLCB7XG4gICAgICAgIC4uLmZldGNoUGFyYW1zTWV0YURhdGEsXG4gICAgICB9KSxcbiAgICAgIHRoaXMuX3NldFN3YXBzUmVmcmVzaFJhdGVzKCksXG4gICAgXSk7XG5cbiAgICBjb25zdCB7XG4gICAgICBzd2Fwc1N0YXRlOiB7IHNhdmVGZXRjaGVkUXVvdGVzOiBzYXZlRmV0Y2hlZFF1b3Rlc0FmdGVyUmVzcG9uc2UgfSxcbiAgICB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgLy8gSWYgc2F2ZUZldGNoZWRRdW90ZXNBZnRlclJlc3BvbnNlIGlzIGZhbHNlLCBpdCBtZWFucyBhIHVzZXIgbGVmdCBTd2FwcyAod2UgY2xlYW5lZCB0aGUgc3RhdGUpXG4gICAgLy8gYW5kIHdlIGRvbid0IHdhbnQgdG8gc2V0IGFueSBBUEkgcmVzcG9uc2Ugd2l0aCBxdW90ZXMgaW50byBzdGF0ZS5cbiAgICBpZiAoIXNhdmVGZXRjaGVkUXVvdGVzQWZ0ZXJSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge30sIC8vIHF1b3Rlc1xuICAgICAgICBudWxsLCAvLyBzZWxlY3RlZEFnZ0lkXG4gICAgICBdO1xuICAgIH1cblxuICAgIG5ld1F1b3RlcyA9IG1hcFZhbHVlcyhuZXdRdW90ZXMsIChxdW90ZSkgPT4gKHtcbiAgICAgIC4uLnF1b3RlLFxuICAgICAgc291cmNlVG9rZW5JbmZvOiBmZXRjaFBhcmFtc01ldGFEYXRhLnNvdXJjZVRva2VuSW5mbyxcbiAgICAgIGRlc3RpbmF0aW9uVG9rZW5JbmZvOiBmZXRjaFBhcmFtc01ldGFEYXRhLmRlc3RpbmF0aW9uVG9rZW5JbmZvLFxuICAgIH0pKTtcblxuICAgIGNvbnN0IHF1b3Rlc0xhc3RGZXRjaGVkID0gRGF0ZS5ub3coKTtcblxuICAgIGxldCBhcHByb3ZhbFJlcXVpcmVkID0gZmFsc2U7XG4gICAgaWYgKFxuICAgICAgIWlzU3dhcHNEZWZhdWx0VG9rZW5BZGRyZXNzKGZldGNoUGFyYW1zLnNvdXJjZVRva2VuLCBjaGFpbklkKSAmJlxuICAgICAgT2JqZWN0LnZhbHVlcyhuZXdRdW90ZXMpLmxlbmd0aFxuICAgICkge1xuICAgICAgY29uc3QgYWxsb3dhbmNlID0gYXdhaXQgdGhpcy5fZ2V0RVJDMjBBbGxvd2FuY2UoXG4gICAgICAgIGZldGNoUGFyYW1zLnNvdXJjZVRva2VuLFxuICAgICAgICBmZXRjaFBhcmFtcy5mcm9tQWRkcmVzcyxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICk7XG5cbiAgICAgIC8vIEZvciBhIHVzZXIgdG8gYmUgYWJsZSB0byBzd2FwIGEgdG9rZW4sIHRoZXkgbmVlZCB0byBoYXZlIGFwcHJvdmVkIHRoZSBNZXRhU3dhcCBjb250cmFjdCB0byB3aXRoZHJhdyB0aGF0IHRva2VuLlxuICAgICAgLy8gX2dldEVSQzIwQWxsb3dhbmNlKCkgcmV0dXJucyB0aGUgYW1vdW50IG9mIHRoZSB0b2tlbiB0aGV5IGhhdmUgYXBwcm92ZWQgZm9yIHdpdGhkcmF3YWwuIElmIHRoYXQgYW1vdW50IGlzIGdyZWF0ZXJcbiAgICAgIC8vIHRoYW4gMCwgaXQgbWVhbnMgdGhhdCBhcHByb3ZhbCBoYXMgYWxyZWFkeSBvY2N1cnJlZCBhbmQgaXMgbm90IG5lZWRlZC4gT3RoZXJ3aXNlLCBmb3IgdG9rZW5zIHRvIGJlIHN3YXBwZWQsIGEgbmV3XG4gICAgICAvLyBjYWxsIG9mIHRoZSBFUkMtMjAgYXBwcm92ZSBtZXRob2QgaXMgcmVxdWlyZWQuXG4gICAgICBhcHByb3ZhbFJlcXVpcmVkID1cbiAgICAgICAgYWxsb3dhbmNlLmVxKDApICYmXG4gICAgICAgIE9iamVjdC52YWx1ZXMobmV3UXVvdGVzKVswXS5hZ2dyZWdhdG9yICE9PSAnd3JhcHBlZE5hdGl2ZSc7XG4gICAgICBpZiAoIWFwcHJvdmFsUmVxdWlyZWQpIHtcbiAgICAgICAgbmV3UXVvdGVzID0gbWFwVmFsdWVzKG5ld1F1b3RlcywgKHF1b3RlKSA9PiAoe1xuICAgICAgICAgIC4uLnF1b3RlLFxuICAgICAgICAgIGFwcHJvdmFsTmVlZGVkOiBudWxsLFxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc1BvbGxlZFJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgeyBnYXNMaW1pdDogYXBwcm92YWxHYXMgfSA9IGF3YWl0IHRoaXMudGltZWRvdXRHYXNSZXR1cm4oXG4gICAgICAgICAgT2JqZWN0LnZhbHVlcyhuZXdRdW90ZXMpWzBdLmFwcHJvdmFsTmVlZGVkLFxuICAgICAgICApO1xuXG4gICAgICAgIG5ld1F1b3RlcyA9IG1hcFZhbHVlcyhuZXdRdW90ZXMsIChxdW90ZSkgPT4gKHtcbiAgICAgICAgICAuLi5xdW90ZSxcbiAgICAgICAgICBhcHByb3ZhbE5lZWRlZDoge1xuICAgICAgICAgICAgLi4ucXVvdGUuYXBwcm92YWxOZWVkZWQsXG4gICAgICAgICAgICBnYXM6IGFwcHJvdmFsR2FzIHx8IERFRkFVTFRfRVJDMjBfQVBQUk9WRV9HQVMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0b3BBZ2dJZCA9IG51bGw7XG5cbiAgICAvLyBXZSBjYW4gcmVkdWNlIHRpbWUgb24gdGhlIGxvYWRpbmcgc2NyZWVuIGJ5IG9ubHkgZG9pbmcgdGhpcyBhZnRlciB0aGVcbiAgICAvLyBsb2FkaW5nIHNjcmVlbiBhbmQgYmVzdCBxdW90ZSBoYXZlIHJlbmRlcmVkLlxuICAgIGlmICghYXBwcm92YWxSZXF1aXJlZCAmJiAhZmV0Y2hQYXJhbXM/LmJhbGFuY2VFcnJvcikge1xuICAgICAgbmV3UXVvdGVzID0gYXdhaXQgdGhpcy5nZXRBbGxRdW90ZXNXaXRoR2FzRXN0aW1hdGVzKG5ld1F1b3Rlcyk7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC52YWx1ZXMobmV3UXVvdGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc2V0U3dhcHNFcnJvcktleShRVU9URVNfTk9UX0FWQUlMQUJMRV9FUlJPUik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtcbiAgICAgICAgX3RvcEFnZ0lkLFxuICAgICAgICBxdW90ZXNXaXRoU2F2aW5nc0FuZEZlZURhdGEsXG4gICAgICBdID0gYXdhaXQgdGhpcy5fZmluZFRvcFF1b3RlQW5kQ2FsY3VsYXRlU2F2aW5ncyhuZXdRdW90ZXMpO1xuICAgICAgdG9wQWdnSWQgPSBfdG9wQWdnSWQ7XG4gICAgICBuZXdRdW90ZXMgPSBxdW90ZXNXaXRoU2F2aW5nc0FuZEZlZURhdGE7XG4gICAgfVxuXG4gICAgLy8gSWYgYSBuZXdlciBjYWxsIGhhcyBiZWVuIG1hZGUsIGRvbid0IHVwZGF0ZSBzdGF0ZSB3aXRoIG9sZCBpbmZvcm1hdGlvblxuICAgIC8vIFByZXZlbnRzIHRpbWluZyBjb25mbGljdHMgYmV0d2VlbiBmZXRjaGVzXG4gICAgaWYgKHRoaXMuaW5kZXhPZk5ld2VzdENhbGxJbkZsaWdodCAhPT0gaW5kZXhPZkN1cnJlbnRDYWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoU1dBUFNfRkVUQ0hfT1JERVJfQ09ORkxJQ1QpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGxldCB7IHNlbGVjdGVkQWdnSWQgfSA9IHN3YXBzU3RhdGU7XG4gICAgaWYgKCFuZXdRdW90ZXNbc2VsZWN0ZWRBZ2dJZF0pIHtcbiAgICAgIHNlbGVjdGVkQWdnSWQgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgc3dhcHNTdGF0ZToge1xuICAgICAgICAuLi5zd2Fwc1N0YXRlLFxuICAgICAgICBxdW90ZXM6IG5ld1F1b3RlcyxcbiAgICAgICAgZmV0Y2hQYXJhbXM6IHsgLi4uZmV0Y2hQYXJhbXMsIG1ldGFEYXRhOiBmZXRjaFBhcmFtc01ldGFEYXRhIH0sXG4gICAgICAgIHF1b3Rlc0xhc3RGZXRjaGVkLFxuICAgICAgICBzZWxlY3RlZEFnZ0lkLFxuICAgICAgICB0b3BBZ2dJZCxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBpZiAocXVvdGVzUG9sbGluZ0xpbWl0RW5hYmxlZCkge1xuICAgICAgLy8gV2Ugb25seSB3YW50IHRvIGRvIHVwIHRvIGEgbWF4aW11bSBvZiB0aHJlZSByZXF1ZXN0cyBmcm9tIHBvbGxpbmcgaWYgcG9sbGluZyBsaW1pdCBpcyBlbmFibGVkLlxuICAgICAgLy8gT3RoZXJ3aXNlIHdlIHdvbid0IGluY3JlYXNlIHBvbGxDb3VudCwgc28gcG9sbGluZyB3aWxsIHJ1biB3aXRob3V0IGEgbGltaXQuXG4gICAgICB0aGlzLnBvbGxDb3VudCArPSAxO1xuICAgIH1cblxuICAgIGlmICghcXVvdGVzUG9sbGluZ0xpbWl0RW5hYmxlZCB8fCB0aGlzLnBvbGxDb3VudCA8IFBPTExfQ09VTlRfTElNSVQgKyAxKSB7XG4gICAgICB0aGlzLnBvbGxGb3JOZXdRdW90ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXNldFBvc3RGZXRjaFN0YXRlKCk7XG4gICAgICB0aGlzLnNldFN3YXBzRXJyb3JLZXkoUVVPVEVTX0VYUElSRURfRVJST1IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuZXdRdW90ZXMsIHRvcEFnZ0lkXTtcbiAgfVxuXG4gIHNhZmVSZWZldGNoUXVvdGVzKCkge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGlmICghdGhpcy5wb2xsaW5nVGltZW91dCAmJiBzd2Fwc1N0YXRlLmZldGNoUGFyYW1zKSB7XG4gICAgICB0aGlzLmZldGNoQW5kU2V0UXVvdGVzKHN3YXBzU3RhdGUuZmV0Y2hQYXJhbXMpO1xuICAgIH1cbiAgfVxuXG4gIHNldFNlbGVjdGVkUXVvdGVBZ2dJZChzZWxlY3RlZEFnZ0lkKSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHN3YXBzU3RhdGU6IHsgLi4uc3dhcHNTdGF0ZSwgc2VsZWN0ZWRBZ2dJZCB9IH0pO1xuICB9XG5cbiAgc2V0U3dhcHNUb2tlbnModG9rZW5zKSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHN3YXBzU3RhdGU6IHsgLi4uc3dhcHNTdGF0ZSwgdG9rZW5zIH0gfSk7XG4gIH1cblxuICBjbGVhclN3YXBzUXVvdGVzKCkge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBzd2Fwc1N0YXRlOiB7IC4uLnN3YXBzU3RhdGUsIHF1b3Rlczoge30gfSB9KTtcbiAgfVxuXG4gIHNldFN3YXBzRXJyb3JLZXkoZXJyb3JLZXkpIHtcbiAgICBjb25zdCB7IHN3YXBzU3RhdGUgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgc3dhcHNTdGF0ZTogeyAuLi5zd2Fwc1N0YXRlLCBlcnJvcktleSB9IH0pO1xuICB9XG5cbiAgYXN5bmMgZ2V0QWxsUXVvdGVzV2l0aEdhc0VzdGltYXRlcyhxdW90ZXMpIHtcbiAgICBjb25zdCBxdW90ZUdhc0RhdGEgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIE9iamVjdC52YWx1ZXMocXVvdGVzKS5tYXAoYXN5bmMgKHF1b3RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZ2FzTGltaXQsIHNpbXVsYXRpb25GYWlscyB9ID0gYXdhaXQgdGhpcy50aW1lZG91dEdhc1JldHVybihcbiAgICAgICAgICBxdW90ZS50cmFkZSxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIFtnYXNMaW1pdCwgc2ltdWxhdGlvbkZhaWxzLCBxdW90ZS5hZ2dyZWdhdG9yXTtcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICBjb25zdCBuZXdRdW90ZXMgPSB7fTtcbiAgICBxdW90ZUdhc0RhdGEuZm9yRWFjaCgoW2dhc0xpbWl0LCBzaW11bGF0aW9uRmFpbHMsIGFnZ0lkXSkgPT4ge1xuICAgICAgaWYgKGdhc0xpbWl0ICYmICFzaW11bGF0aW9uRmFpbHMpIHtcbiAgICAgICAgY29uc3QgZ2FzRXN0aW1hdGVXaXRoUmVmdW5kID0gY2FsY3VsYXRlR2FzRXN0aW1hdGVXaXRoUmVmdW5kKFxuICAgICAgICAgIHF1b3Rlc1thZ2dJZF0ubWF4R2FzLFxuICAgICAgICAgIHF1b3Rlc1thZ2dJZF0uZXN0aW1hdGVkUmVmdW5kLFxuICAgICAgICAgIGdhc0xpbWl0LFxuICAgICAgICApO1xuXG4gICAgICAgIG5ld1F1b3Rlc1thZ2dJZF0gPSB7XG4gICAgICAgICAgLi4ucXVvdGVzW2FnZ0lkXSxcbiAgICAgICAgICBnYXNFc3RpbWF0ZTogZ2FzTGltaXQsXG4gICAgICAgICAgZ2FzRXN0aW1hdGVXaXRoUmVmdW5kLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChxdW90ZXNbYWdnSWRdLmFwcHJvdmFsTmVlZGVkKSB7XG4gICAgICAgIC8vIElmIGdhcyBlc3RpbWF0aW9uIGZhaWxzLCBidXQgYW4gRVJDLTIwIGFwcHJvdmUgaXMgbmVlZGVkLCB0aGVuIHdlIGRvIG5vdCBhZGQgYW55IGVzdGltYXRlIHByb3BlcnR5IHRvIHRoZSBxdW90ZSBvYmplY3RcbiAgICAgICAgLy8gU3VjaCBxdW90ZXMgd2lsbCByZWx5IG9uIHRoZSBtYXhHYXMgYW5kIGF2ZXJhZ2VHYXMgcHJvcGVydGllcyBmcm9tIHRoZSBhcGlcbiAgICAgICAgbmV3UXVvdGVzW2FnZ0lkXSA9IHF1b3Rlc1thZ2dJZF07XG4gICAgICB9XG4gICAgICAvLyBJZiBnYXMgZXN0aW1hdGlvbiBmYWlscyBhbmQgbm8gYXBwcm92YWwgaXMgbmVlZGVkLCB0aGVuIHdlIGZpbHRlciB0aGF0IHF1b3RlIG91dCwgc28gdGhhdCBpdCBpcyBub3Qgc2hvd24gdG8gdGhlIHVzZXJcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3UXVvdGVzO1xuICB9XG5cbiAgdGltZWRvdXRHYXNSZXR1cm4odHJhZGVUeFBhcmFtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgbGV0IGdhc1RpbWVkT3V0ID0gZmFsc2U7XG5cbiAgICAgIGNvbnN0IGdhc1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZ2FzVGltZWRPdXQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKHsgZ2FzTGltaXQ6IG51bGwsIHNpbXVsYXRpb25GYWlsczogdHJ1ZSB9KTtcbiAgICAgIH0sIFNFQ09ORCAqIDUpO1xuXG4gICAgICAvLyBSZW1vdmUgZ2FzIGZyb20gcGFyYW1zIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGBlc3RpbWF0ZUdhc2AgY2FsbFxuICAgICAgLy8gSW5jbHVkaW5nIGl0IGNhbiBjYXVzZSB0aGUgZXN0aW1hdGUgdG8gZmFpbCBpZiB0aGUgYWN0dWFsIGdhcyBuZWVkZWRcbiAgICAgIC8vIGV4Y2VlZHMgdGhlIHBhc3NlZCBnYXNcbiAgICAgIGNvbnN0IHRyYWRlVHhQYXJhbXNGb3JHYXNFc3RpbWF0ZSA9IHtcbiAgICAgICAgZGF0YTogdHJhZGVUeFBhcmFtcy5kYXRhLFxuICAgICAgICBmcm9tOiB0cmFkZVR4UGFyYW1zLmZyb20sXG4gICAgICAgIHRvOiB0cmFkZVR4UGFyYW1zLnRvLFxuICAgICAgICB2YWx1ZTogdHJhZGVUeFBhcmFtcy52YWx1ZSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZ2V0QnVmZmVyZWRHYXNMaW1pdCh7IHR4UGFyYW1zOiB0cmFkZVR4UGFyYW1zRm9yR2FzRXN0aW1hdGUgfSwgMSlcbiAgICAgICAgLnRoZW4oKHsgZ2FzTGltaXQsIHNpbXVsYXRpb25GYWlscyB9KSA9PiB7XG4gICAgICAgICAgaWYgKCFnYXNUaW1lZE91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGdhc1RpbWVvdXQpO1xuICAgICAgICAgICAgcmVzb2x2ZSh7IGdhc0xpbWl0LCBzaW11bGF0aW9uRmFpbHMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBsb2cuZXJyb3IoZSk7XG4gICAgICAgICAgaWYgKCFnYXNUaW1lZE91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGdhc1RpbWVvdXQpO1xuICAgICAgICAgICAgcmVzb2x2ZSh7IGdhc0xpbWl0OiBudWxsLCBzaW11bGF0aW9uRmFpbHM6IHRydWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHNldEluaXRpYWxHYXNFc3RpbWF0ZShpbml0aWFsQWdnSWQpIHtcbiAgICBjb25zdCB7IHN3YXBzU3RhdGUgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIGNvbnN0IHF1b3RlVG9VcGRhdGUgPSB7IC4uLnN3YXBzU3RhdGUucXVvdGVzW2luaXRpYWxBZ2dJZF0gfTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGdhc0xpbWl0OiBuZXdHYXNFc3RpbWF0ZSxcbiAgICAgIHNpbXVsYXRpb25GYWlscyxcbiAgICB9ID0gYXdhaXQgdGhpcy50aW1lZG91dEdhc1JldHVybihxdW90ZVRvVXBkYXRlLnRyYWRlKTtcblxuICAgIGlmIChuZXdHYXNFc3RpbWF0ZSAmJiAhc2ltdWxhdGlvbkZhaWxzKSB7XG4gICAgICBjb25zdCBnYXNFc3RpbWF0ZVdpdGhSZWZ1bmQgPSBjYWxjdWxhdGVHYXNFc3RpbWF0ZVdpdGhSZWZ1bmQoXG4gICAgICAgIHF1b3RlVG9VcGRhdGUubWF4R2FzLFxuICAgICAgICBxdW90ZVRvVXBkYXRlLmVzdGltYXRlZFJlZnVuZCxcbiAgICAgICAgbmV3R2FzRXN0aW1hdGUsXG4gICAgICApO1xuXG4gICAgICBxdW90ZVRvVXBkYXRlLmdhc0VzdGltYXRlID0gbmV3R2FzRXN0aW1hdGU7XG4gICAgICBxdW90ZVRvVXBkYXRlLmdhc0VzdGltYXRlV2l0aFJlZnVuZCA9IGdhc0VzdGltYXRlV2l0aFJlZnVuZDtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHN3YXBzU3RhdGU6IHtcbiAgICAgICAgLi4uc3dhcHNTdGF0ZSxcbiAgICAgICAgcXVvdGVzOiB7IC4uLnN3YXBzU3RhdGUucXVvdGVzLCBbaW5pdGlhbEFnZ0lkXTogcXVvdGVUb1VwZGF0ZSB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHNldEFwcHJvdmVUeElkKGFwcHJvdmVUeElkKSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHN3YXBzU3RhdGU6IHsgLi4uc3dhcHNTdGF0ZSwgYXBwcm92ZVR4SWQgfSB9KTtcbiAgfVxuXG4gIHNldFRyYWRlVHhJZCh0cmFkZVR4SWQpIHtcbiAgICBjb25zdCB7IHN3YXBzU3RhdGUgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgc3dhcHNTdGF0ZTogeyAuLi5zd2Fwc1N0YXRlLCB0cmFkZVR4SWQgfSB9KTtcbiAgfVxuXG4gIHNldFF1b3Rlc0xhc3RGZXRjaGVkKHF1b3Rlc0xhc3RGZXRjaGVkKSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBzd2Fwc1N0YXRlOiB7IC4uLnN3YXBzU3RhdGUsIHF1b3Rlc0xhc3RGZXRjaGVkIH0sXG4gICAgfSk7XG4gIH1cblxuICBzZXRTd2Fwc1R4R2FzUHJpY2UoZ2FzUHJpY2UpIHtcbiAgICBjb25zdCB7IHN3YXBzU3RhdGUgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHN3YXBzU3RhdGU6IHsgLi4uc3dhcHNTdGF0ZSwgY3VzdG9tR2FzUHJpY2U6IGdhc1ByaWNlIH0sXG4gICAgfSk7XG4gIH1cblxuICBzZXRTd2Fwc1R4TWF4RmVlUGVyR2FzKG1heEZlZVBlckdhcykge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgc3dhcHNTdGF0ZTogeyAuLi5zd2Fwc1N0YXRlLCBjdXN0b21NYXhGZWVQZXJHYXM6IG1heEZlZVBlckdhcyB9LFxuICAgIH0pO1xuICB9XG5cbiAgc2V0U3dhcHNVc2VyRmVlTGV2ZWwoc3dhcHNVc2VyRmVlTGV2ZWwpIHtcbiAgICBjb25zdCB7IHN3YXBzU3RhdGUgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHN3YXBzU3RhdGU6IHsgLi4uc3dhcHNTdGF0ZSwgc3dhcHNVc2VyRmVlTGV2ZWwgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHNldFN3YXBzUXVvdGVzUG9sbGluZ0xpbWl0RW5hYmxlZChxdW90ZXNQb2xsaW5nTGltaXRFbmFibGVkKSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBzd2Fwc1N0YXRlOiB7IC4uLnN3YXBzU3RhdGUsIHF1b3Rlc1BvbGxpbmdMaW1pdEVuYWJsZWQgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHNldFN3YXBzVHhNYXhGZWVQcmlvcml0eVBlckdhcyhtYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgc3dhcHNTdGF0ZToge1xuICAgICAgICAuLi5zd2Fwc1N0YXRlLFxuICAgICAgICBjdXN0b21NYXhQcmlvcml0eUZlZVBlckdhczogbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgc2V0U3dhcHNUeEdhc0xpbWl0KGdhc0xpbWl0KSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBzd2Fwc1N0YXRlOiB7IC4uLnN3YXBzU3RhdGUsIGN1c3RvbU1heEdhczogZ2FzTGltaXQgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHNldEN1c3RvbUFwcHJvdmVUeERhdGEoZGF0YSkge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgc3dhcHNTdGF0ZTogeyAuLi5zd2Fwc1N0YXRlLCBjdXN0b21BcHByb3ZlVHhEYXRhOiBkYXRhIH0sXG4gICAgfSk7XG4gIH1cblxuICBzZXRCYWNrZ3JvdW5kU3dhcFJvdXRlU3RhdGUocm91dGVTdGF0ZSkge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBzd2Fwc1N0YXRlOiB7IC4uLnN3YXBzU3RhdGUsIHJvdXRlU3RhdGUgfSB9KTtcbiAgfVxuXG4gIHNldFNhdmVGZXRjaGVkUXVvdGVzKHN0YXR1cykge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgc3dhcHNTdGF0ZTogeyAuLi5zd2Fwc1N0YXRlLCBzYXZlRmV0Y2hlZFF1b3Rlczogc3RhdHVzIH0sXG4gICAgfSk7XG4gIH1cblxuICBzZXRTd2Fwc0xpdmVuZXNzKHN3YXBzTGl2ZW5lc3MpIHtcbiAgICBjb25zdCB7IHN3YXBzU3RhdGUgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB7IHN3YXBzRmVhdHVyZUlzTGl2ZSB9ID0gc3dhcHNMaXZlbmVzcztcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHN3YXBzU3RhdGU6IHsgLi4uc3dhcHNTdGF0ZSwgc3dhcHNGZWF0dXJlSXNMaXZlIH0sXG4gICAgfSk7XG4gIH1cblxuICByZXNldFBvc3RGZXRjaFN0YXRlKCkge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgc3dhcHNTdGF0ZToge1xuICAgICAgICAuLi5pbml0aWFsU3RhdGUuc3dhcHNTdGF0ZSxcbiAgICAgICAgdG9rZW5zOiBzd2Fwc1N0YXRlLnRva2VucyxcbiAgICAgICAgZmV0Y2hQYXJhbXM6IHN3YXBzU3RhdGUuZmV0Y2hQYXJhbXMsXG4gICAgICAgIHN3YXBzRmVhdHVyZUlzTGl2ZTogc3dhcHNTdGF0ZS5zd2Fwc0ZlYXR1cmVJc0xpdmUsXG4gICAgICAgIHN3YXBzUXVvdGVSZWZyZXNoVGltZTogc3dhcHNTdGF0ZS5zd2Fwc1F1b3RlUmVmcmVzaFRpbWUsXG4gICAgICAgIHN3YXBzUXVvdGVQcmVmZXRjaGluZ1JlZnJlc2hUaW1lOlxuICAgICAgICAgIHN3YXBzU3RhdGUuc3dhcHNRdW90ZVByZWZldGNoaW5nUmVmcmVzaFRpbWUsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBvbGxpbmdUaW1lb3V0KTtcbiAgfVxuXG4gIHJlc2V0U3dhcHNTdGF0ZSgpIHtcbiAgICBjb25zdCB7IHN3YXBzU3RhdGUgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHN3YXBzU3RhdGU6IHtcbiAgICAgICAgLi4uaW5pdGlhbFN0YXRlLnN3YXBzU3RhdGUsXG4gICAgICAgIHN3YXBzUXVvdGVSZWZyZXNoVGltZTogc3dhcHNTdGF0ZS5zd2Fwc1F1b3RlUmVmcmVzaFRpbWUsXG4gICAgICAgIHN3YXBzUXVvdGVQcmVmZXRjaGluZ1JlZnJlc2hUaW1lOlxuICAgICAgICAgIHN3YXBzU3RhdGUuc3dhcHNRdW90ZVByZWZldGNoaW5nUmVmcmVzaFRpbWUsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBvbGxpbmdUaW1lb3V0KTtcbiAgfVxuXG4gIGFzeW5jIF9maW5kVG9wUXVvdGVBbmRDYWxjdWxhdGVTYXZpbmdzKHF1b3RlcyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udHJhY3RFeGNoYW5nZVJhdGVzOiB0b2tlbkNvbnZlcnNpb25SYXRlcyxcbiAgICB9ID0gdGhpcy5nZXRUb2tlblJhdGVzU3RhdGUoKTtcbiAgICBjb25zdCB7XG4gICAgICBzd2Fwc1N0YXRlOiB7IGN1c3RvbUdhc1ByaWNlLCBjdXN0b21NYXhQcmlvcml0eUZlZVBlckdhcyB9LFxuICAgIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgY2hhaW5JZCA9IHRoaXMuX2dldEN1cnJlbnRDaGFpbklkKCk7XG5cbiAgICBjb25zdCBudW1RdW90ZXMgPSBPYmplY3Qua2V5cyhxdW90ZXMpLmxlbmd0aDtcbiAgICBpZiAoIW51bVF1b3Rlcykge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1F1b3RlcyA9IGNsb25lRGVlcChxdW90ZXMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgZ2FzRmVlRXN0aW1hdGVzLFxuICAgICAgZ2FzRXN0aW1hdGVUeXBlLFxuICAgIH0gPSBhd2FpdCB0aGlzLl9nZXRFSVAxNTU5R2FzRmVlRXN0aW1hdGVzKCk7XG5cbiAgICBsZXQgdXNlZEdhc1ByaWNlID0gJzB4MCc7XG5cbiAgICBpZiAoZ2FzRXN0aW1hdGVUeXBlID09PSBHQVNfRVNUSU1BVEVfVFlQRVMuRkVFX01BUktFVCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBoaWdoOiB7IHN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzIH0sXG4gICAgICAgIGVzdGltYXRlZEJhc2VGZWUsXG4gICAgICB9ID0gZ2FzRmVlRXN0aW1hdGVzO1xuXG4gICAgICB1c2VkR2FzUHJpY2UgPSBhZGRDdXJyZW5jaWVzKFxuICAgICAgICBjdXN0b21NYXhQcmlvcml0eUZlZVBlckdhcyB8fCAvLyBJcyBhbHJlYWR5IGluIGhleCBXRUkuXG4gICAgICAgICAgZGVjR1dFSVRvSGV4V0VJKHN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgZGVjR1dFSVRvSGV4V0VJKGVzdGltYXRlZEJhc2VGZWUpLFxuICAgICAgICB7XG4gICAgICAgICAgYUJhc2U6IDE2LFxuICAgICAgICAgIGJCYXNlOiAxNixcbiAgICAgICAgICB0b051bWVyaWNCYXNlOiAnaGV4JyxcbiAgICAgICAgICBudW1iZXJPZkRlY2ltYWxzOiA2LFxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGdhc0VzdGltYXRlVHlwZSA9PT0gR0FTX0VTVElNQVRFX1RZUEVTLkxFR0FDWSkge1xuICAgICAgdXNlZEdhc1ByaWNlID0gY3VzdG9tR2FzUHJpY2UgfHwgZGVjR1dFSVRvSGV4V0VJKGdhc0ZlZUVzdGltYXRlcy5oaWdoKTtcbiAgICB9IGVsc2UgaWYgKGdhc0VzdGltYXRlVHlwZSA9PT0gR0FTX0VTVElNQVRFX1RZUEVTLkVUSF9HQVNQUklDRSkge1xuICAgICAgdXNlZEdhc1ByaWNlID1cbiAgICAgICAgY3VzdG9tR2FzUHJpY2UgfHwgZGVjR1dFSVRvSGV4V0VJKGdhc0ZlZUVzdGltYXRlcy5nYXNQcmljZSk7XG4gICAgfVxuXG4gICAgbGV0IHRvcEFnZ0lkID0gbnVsbDtcbiAgICBsZXQgb3ZlcmFsbFZhbHVlT2ZCZXN0UXVvdGVGb3JTb3J0aW5nID0gbnVsbDtcblxuICAgIE9iamVjdC52YWx1ZXMobmV3UXVvdGVzKS5mb3JFYWNoKChxdW90ZSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhZ2dyZWdhdG9yLFxuICAgICAgICBhcHByb3ZhbE5lZWRlZCxcbiAgICAgICAgYXZlcmFnZUdhcyxcbiAgICAgICAgZGVzdGluYXRpb25BbW91bnQgPSAwLFxuICAgICAgICBkZXN0aW5hdGlvblRva2VuLFxuICAgICAgICBkZXN0aW5hdGlvblRva2VuSW5mbyxcbiAgICAgICAgZ2FzRXN0aW1hdGUsXG4gICAgICAgIHNvdXJjZUFtb3VudCxcbiAgICAgICAgc291cmNlVG9rZW4sXG4gICAgICAgIHRyYWRlLFxuICAgICAgICBmZWU6IG1ldGFNYXNrRmVlLFxuICAgICAgfSA9IHF1b3RlO1xuXG4gICAgICBjb25zdCB0cmFkZUdhc0xpbWl0Rm9yQ2FsY3VsYXRpb24gPSBnYXNFc3RpbWF0ZVxuICAgICAgICA/IG5ldyBCaWdOdW1iZXIoZ2FzRXN0aW1hdGUsIDE2KVxuICAgICAgICA6IG5ldyBCaWdOdW1iZXIoYXZlcmFnZUdhcyB8fCBNQVhfR0FTX0xJTUlULCAxMCk7XG5cbiAgICAgIGNvbnN0IHRvdGFsR2FzTGltaXRGb3JDYWxjdWxhdGlvbiA9IHRyYWRlR2FzTGltaXRGb3JDYWxjdWxhdGlvblxuICAgICAgICAucGx1cyhhcHByb3ZhbE5lZWRlZD8uZ2FzIHx8ICcweDAnLCAxNilcbiAgICAgICAgLnRvU3RyaW5nKDE2KTtcblxuICAgICAgY29uc3QgZ2FzVG90YWxJbldlaUhleCA9IGNhbGNHYXNUb3RhbChcbiAgICAgICAgdG90YWxHYXNMaW1pdEZvckNhbGN1bGF0aW9uLFxuICAgICAgICB1c2VkR2FzUHJpY2UsXG4gICAgICApO1xuXG4gICAgICAvLyB0cmFkZS52YWx1ZSBpcyBhIHN1bSBvZiBkaWZmZXJlbnQgdmFsdWVzIGRlcGVuZGluZyBvbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAvLyBJdCBhbHdheXMgaW5jbHVkZXMgYW55IGV4dGVybmFsIGZlZXMgY2hhcmdlZCBieSB0aGUgcXVvdGUgc291cmNlLiBJblxuICAgICAgLy8gYWRkaXRpb24sIGlmIHRoZSBzb3VyY2UgYXNzZXQgaXMgdGhlIHNlbGVjdGVkIGNoYWluJ3MgZGVmYXVsdCB0b2tlbiwgdHJhZGUudmFsdWVcbiAgICAgIC8vIGluY2x1ZGVzIHRoZSBhbW91bnQgb2YgdGhhdCB0b2tlbi5cbiAgICAgIGNvbnN0IHRvdGFsV2VpQ29zdCA9IG5ldyBCaWdOdW1iZXIoZ2FzVG90YWxJbldlaUhleCwgMTYpLnBsdXMoXG4gICAgICAgIHRyYWRlLnZhbHVlLFxuICAgICAgICAxNixcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRvdGFsRXRoQ29zdCA9IGNvbnZlcnNpb25VdGlsKHRvdGFsV2VpQ29zdCwge1xuICAgICAgICBmcm9tQ3VycmVuY3k6ICdFVEgnLFxuICAgICAgICBmcm9tRGVub21pbmF0aW9uOiAnV0VJJyxcbiAgICAgICAgdG9EZW5vbWluYXRpb246ICdFVEgnLFxuICAgICAgICBmcm9tTnVtZXJpY0Jhc2U6ICdCTicsXG4gICAgICAgIG51bWJlck9mRGVjaW1hbHM6IDYsXG4gICAgICB9KTtcblxuICAgICAgLy8gVGhlIHRvdGFsIGZlZSBpcyBhZ2dyZWdhdG9yL2V4Y2hhbmdlIGZlZXMgcGx1cyBnYXMgZmVlcy5cbiAgICAgIC8vIElmIHRoZSBzd2FwIGlzIGZyb20gdGhlIHNlbGVjdGVkIGNoYWluJ3MgZGVmYXVsdCB0b2tlbiwgc3VidHJhY3RcbiAgICAgIC8vIHRoZSBzb3VyY2VBbW91bnQgZnJvbSB0aGUgdG90YWwgY29zdC4gT3RoZXJ3aXNlLCB0aGUgdG90YWwgZmVlXG4gICAgICAvLyBpcyBzaW1wbHkgdHJhZGUudmFsdWUgcGx1cyBnYXMgZmVlcy5cbiAgICAgIGNvbnN0IGV0aEZlZSA9IGlzU3dhcHNEZWZhdWx0VG9rZW5BZGRyZXNzKHNvdXJjZVRva2VuLCBjaGFpbklkKVxuICAgICAgICA/IGNvbnZlcnNpb25VdGlsKFxuICAgICAgICAgICAgdG90YWxXZWlDb3N0Lm1pbnVzKHNvdXJjZUFtb3VudCwgMTApLCAvLyBzb3VyY2VBbW91bnQgaXMgaW4gd2VpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZyb21DdXJyZW5jeTogJ0VUSCcsXG4gICAgICAgICAgICAgIGZyb21EZW5vbWluYXRpb246ICdXRUknLFxuICAgICAgICAgICAgICB0b0Rlbm9taW5hdGlvbjogJ0VUSCcsXG4gICAgICAgICAgICAgIGZyb21OdW1lcmljQmFzZTogJ0JOJyxcbiAgICAgICAgICAgICAgbnVtYmVyT2ZEZWNpbWFsczogNixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKVxuICAgICAgICA6IHRvdGFsRXRoQ29zdDtcblxuICAgICAgY29uc3QgZGVjaW1hbEFkanVzdGVkRGVzdGluYXRpb25BbW91bnQgPSBjYWxjVG9rZW5BbW91bnQoXG4gICAgICAgIGRlc3RpbmF0aW9uQW1vdW50LFxuICAgICAgICBkZXN0aW5hdGlvblRva2VuSW5mby5kZWNpbWFscyxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRva2VuUGVyY2VudGFnZU9mUHJlRmVlRGVzdEFtb3VudCA9IG5ldyBCaWdOdW1iZXIoMTAwLCAxMClcbiAgICAgICAgLm1pbnVzKG1ldGFNYXNrRmVlLCAxMClcbiAgICAgICAgLmRpdigxMDApO1xuICAgICAgY29uc3QgZGVzdGluYXRpb25BbW91bnRCZWZvcmVNZXRhTWFza0ZlZSA9IGRlY2ltYWxBZGp1c3RlZERlc3RpbmF0aW9uQW1vdW50LmRpdihcbiAgICAgICAgdG9rZW5QZXJjZW50YWdlT2ZQcmVGZWVEZXN0QW1vdW50LFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG1ldGFNYXNrRmVlSW5Ub2tlbnMgPSBkZXN0aW5hdGlvbkFtb3VudEJlZm9yZU1ldGFNYXNrRmVlLm1pbnVzKFxuICAgICAgICBkZWNpbWFsQWRqdXN0ZWREZXN0aW5hdGlvbkFtb3VudCxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRva2VuQ29udmVyc2lvblJhdGUgPVxuICAgICAgICB0b2tlbkNvbnZlcnNpb25SYXRlc1tcbiAgICAgICAgICBPYmplY3Qua2V5cyh0b2tlbkNvbnZlcnNpb25SYXRlcykuZmluZCgodG9rZW5BZGRyZXNzKSA9PlxuICAgICAgICAgICAgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZSh0b2tlbkFkZHJlc3MsIGRlc3RpbmF0aW9uVG9rZW4pLFxuICAgICAgICAgIClcbiAgICAgICAgXTtcbiAgICAgIGNvbnN0IGNvbnZlcnNpb25SYXRlRm9yU29ydGluZyA9IHRva2VuQ29udmVyc2lvblJhdGUgfHwgMTtcblxuICAgICAgY29uc3QgZXRoVmFsdWVPZlRva2VucyA9IGRlY2ltYWxBZGp1c3RlZERlc3RpbmF0aW9uQW1vdW50LnRpbWVzKFxuICAgICAgICBjb252ZXJzaW9uUmF0ZUZvclNvcnRpbmcudG9TdHJpbmcoMTApLFxuICAgICAgICAxMCxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGNvbnZlcnNpb25SYXRlRm9yQ2FsY3VsYXRpb25zID0gaXNTd2Fwc0RlZmF1bHRUb2tlbkFkZHJlc3MoXG4gICAgICAgIGRlc3RpbmF0aW9uVG9rZW4sXG4gICAgICAgIGNoYWluSWQsXG4gICAgICApXG4gICAgICAgID8gMVxuICAgICAgICA6IHRva2VuQ29udmVyc2lvblJhdGU7XG5cbiAgICAgIGNvbnN0IG92ZXJhbGxWYWx1ZU9mUXVvdGVGb3JTb3J0aW5nID1cbiAgICAgICAgY29udmVyc2lvblJhdGVGb3JDYWxjdWxhdGlvbnMgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gZXRoVmFsdWVPZlRva2Vuc1xuICAgICAgICAgIDogZXRoVmFsdWVPZlRva2Vucy5taW51cyhldGhGZWUsIDEwKTtcblxuICAgICAgcXVvdGUuZXRoRmVlID0gZXRoRmVlLnRvU3RyaW5nKDEwKTtcblxuICAgICAgaWYgKGNvbnZlcnNpb25SYXRlRm9yQ2FsY3VsYXRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcXVvdGUuZXRoVmFsdWVPZlRva2VucyA9IGV0aFZhbHVlT2ZUb2tlbnMudG9TdHJpbmcoMTApO1xuICAgICAgICBxdW90ZS5vdmVyYWxsVmFsdWVPZlF1b3RlID0gb3ZlcmFsbFZhbHVlT2ZRdW90ZUZvclNvcnRpbmcudG9TdHJpbmcoMTApO1xuICAgICAgICBxdW90ZS5tZXRhTWFza0ZlZUluRXRoID0gbWV0YU1hc2tGZWVJblRva2Vuc1xuICAgICAgICAgIC50aW1lcyhjb252ZXJzaW9uUmF0ZUZvckNhbGN1bGF0aW9ucy50b1N0cmluZygxMCkpXG4gICAgICAgICAgLnRvU3RyaW5nKDEwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBvdmVyYWxsVmFsdWVPZkJlc3RRdW90ZUZvclNvcnRpbmcgPT09IG51bGwgfHxcbiAgICAgICAgb3ZlcmFsbFZhbHVlT2ZRdW90ZUZvclNvcnRpbmcuZ3Qob3ZlcmFsbFZhbHVlT2ZCZXN0UXVvdGVGb3JTb3J0aW5nKVxuICAgICAgKSB7XG4gICAgICAgIHRvcEFnZ0lkID0gYWdncmVnYXRvcjtcbiAgICAgICAgb3ZlcmFsbFZhbHVlT2ZCZXN0UXVvdGVGb3JTb3J0aW5nID0gb3ZlcmFsbFZhbHVlT2ZRdW90ZUZvclNvcnRpbmc7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBpc0Jlc3QgPVxuICAgICAgaXNTd2Fwc0RlZmF1bHRUb2tlbkFkZHJlc3MoXG4gICAgICAgIG5ld1F1b3Rlc1t0b3BBZ2dJZF0uZGVzdGluYXRpb25Ub2tlbixcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICkgfHxcbiAgICAgIEJvb2xlYW4oXG4gICAgICAgIHRva2VuQ29udmVyc2lvblJhdGVzW1xuICAgICAgICAgIE9iamVjdC5rZXlzKHRva2VuQ29udmVyc2lvblJhdGVzKS5maW5kKCh0b2tlbkFkZHJlc3MpID0+XG4gICAgICAgICAgICBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKFxuICAgICAgICAgICAgICB0b2tlbkFkZHJlc3MsXG4gICAgICAgICAgICAgIG5ld1F1b3Rlc1t0b3BBZ2dJZF0/LmRlc3RpbmF0aW9uVG9rZW4sXG4gICAgICAgICAgICApLFxuICAgICAgICAgIClcbiAgICAgICAgXSxcbiAgICAgICk7XG5cbiAgICBsZXQgc2F2aW5ncyA9IG51bGw7XG5cbiAgICBpZiAoaXNCZXN0KSB7XG4gICAgICBjb25zdCBiZXN0UXVvdGUgPSBuZXdRdW90ZXNbdG9wQWdnSWRdO1xuXG4gICAgICBzYXZpbmdzID0ge307XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXRoRmVlOiBtZWRpYW5FdGhGZWUsXG4gICAgICAgIG1ldGFNYXNrRmVlSW5FdGg6IG1lZGlhbk1ldGFNYXNrRmVlLFxuICAgICAgICBldGhWYWx1ZU9mVG9rZW5zOiBtZWRpYW5FdGhWYWx1ZU9mVG9rZW5zLFxuICAgICAgfSA9IGdldE1lZGlhbkV0aFZhbHVlUXVvdGUoT2JqZWN0LnZhbHVlcyhuZXdRdW90ZXMpKTtcblxuICAgICAgLy8gUGVyZm9ybWFuY2Ugc2F2aW5ncyBhcmUgY2FsY3VsYXRlZCBhczpcbiAgICAgIC8vICAgKGV0aFZhbHVlT2ZUb2tlbnMgZm9yIHRoZSBiZXN0IHRyYWRlKSAtIChldGhWYWx1ZU9mVG9rZW5zIGZvciB0aGUgbWVkaWEgdHJhZGUpXG4gICAgICBzYXZpbmdzLnBlcmZvcm1hbmNlID0gbmV3IEJpZ051bWJlcihiZXN0UXVvdGUuZXRoVmFsdWVPZlRva2VucywgMTApLm1pbnVzKFxuICAgICAgICBtZWRpYW5FdGhWYWx1ZU9mVG9rZW5zLFxuICAgICAgICAxMCxcbiAgICAgICk7XG5cbiAgICAgIC8vIEZlZSBzYXZpbmdzIGFyZSBjYWxjdWxhdGVkIGFzOlxuICAgICAgLy8gICAoZmVlIGZvciB0aGUgbWVkaWFuIHRyYWRlKSAtIChmZWUgZm9yIHRoZSBiZXN0IHRyYWRlKVxuICAgICAgc2F2aW5ncy5mZWUgPSBuZXcgQmlnTnVtYmVyKG1lZGlhbkV0aEZlZSkubWludXMoYmVzdFF1b3RlLmV0aEZlZSwgMTApO1xuXG4gICAgICBzYXZpbmdzLm1ldGFNYXNrRmVlID0gYmVzdFF1b3RlLm1ldGFNYXNrRmVlSW5FdGg7XG5cbiAgICAgIC8vIFRvdGFsIHNhdmluZ3MgYXJlIGNhbGN1bGF0ZWQgYXM6XG4gICAgICAvLyAgIHBlcmZvcm1hbmNlIHNhdmluZ3MgKyBmZWUgc2F2aW5ncyAtIG1ldGFtYXNrIGZlZVxuICAgICAgc2F2aW5ncy50b3RhbCA9IHNhdmluZ3MucGVyZm9ybWFuY2VcbiAgICAgICAgLnBsdXMoc2F2aW5ncy5mZWUpXG4gICAgICAgIC5taW51cyhzYXZpbmdzLm1ldGFNYXNrRmVlKVxuICAgICAgICAudG9TdHJpbmcoMTApO1xuICAgICAgc2F2aW5ncy5wZXJmb3JtYW5jZSA9IHNhdmluZ3MucGVyZm9ybWFuY2UudG9TdHJpbmcoMTApO1xuICAgICAgc2F2aW5ncy5mZWUgPSBzYXZpbmdzLmZlZS50b1N0cmluZygxMCk7XG4gICAgICBzYXZpbmdzLm1lZGlhbk1ldGFNYXNrRmVlID0gbWVkaWFuTWV0YU1hc2tGZWU7XG5cbiAgICAgIG5ld1F1b3Rlc1t0b3BBZ2dJZF0uaXNCZXN0UXVvdGUgPSB0cnVlO1xuICAgICAgbmV3UXVvdGVzW3RvcEFnZ0lkXS5zYXZpbmdzID0gc2F2aW5ncztcbiAgICB9XG5cbiAgICByZXR1cm4gW3RvcEFnZ0lkLCBuZXdRdW90ZXNdO1xuICB9XG5cbiAgYXN5bmMgX2dldEVSQzIwQWxsb3dhbmNlKGNvbnRyYWN0QWRkcmVzcywgd2FsbGV0QWRkcmVzcywgY2hhaW5JZCkge1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGFiaSxcbiAgICAgIHRoaXMuZXRoZXJzUHJvdmlkZXIsXG4gICAgKTtcbiAgICByZXR1cm4gYXdhaXQgY29udHJhY3QuYWxsb3dhbmNlKFxuICAgICAgd2FsbGV0QWRkcmVzcyxcbiAgICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbY2hhaW5JZF0sXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG1lZGlhbiBvdmVyYWxsVmFsdWVPZlF1b3RlIG9mIGEgc2FtcGxlIG9mIHF1b3Rlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBxdW90ZXMgLSBBIHNhbXBsZSBvZiBxdW90ZSBvYmplY3RzIHdpdGggb3ZlcmFsbFZhbHVlT2ZRdW90ZSwgZXRoRmVlLCBtZXRhTWFza0ZlZUluRXRoLCBhbmQgZXRoVmFsdWVPZlRva2VucyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgZXRoVmFsdWVPZlRva2VucywgZXRoRmVlLCBhbmQgbWV0YU1hc2tGZWVJbkV0aCBvZiB0aGUgcXVvdGUgd2l0aCB0aGUgbWVkaWFuIG92ZXJhbGxWYWx1ZU9mUXVvdGVcbiAqL1xuZnVuY3Rpb24gZ2V0TWVkaWFuRXRoVmFsdWVRdW90ZShfcXVvdGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShfcXVvdGVzKSB8fCBfcXVvdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbm9uLWVtcHR5IGFycmF5IHBhcmFtLicpO1xuICB9XG5cbiAgY29uc3QgcXVvdGVzID0gWy4uLl9xdW90ZXNdO1xuXG4gIHF1b3Rlcy5zb3J0KChxdW90ZUEsIHF1b3RlQikgPT4ge1xuICAgIGNvbnN0IG92ZXJhbGxWYWx1ZU9mUXVvdGVBID0gbmV3IEJpZ051bWJlcihxdW90ZUEub3ZlcmFsbFZhbHVlT2ZRdW90ZSwgMTApO1xuICAgIGNvbnN0IG92ZXJhbGxWYWx1ZU9mUXVvdGVCID0gbmV3IEJpZ051bWJlcihxdW90ZUIub3ZlcmFsbFZhbHVlT2ZRdW90ZSwgMTApO1xuICAgIGlmIChvdmVyYWxsVmFsdWVPZlF1b3RlQS5lcXVhbHMob3ZlcmFsbFZhbHVlT2ZRdW90ZUIpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIG92ZXJhbGxWYWx1ZU9mUXVvdGVBLmxlc3NUaGFuKG92ZXJhbGxWYWx1ZU9mUXVvdGVCKSA/IC0xIDogMTtcbiAgfSk7XG5cbiAgaWYgKHF1b3Rlcy5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgLy8gcmV0dXJuIG1pZGRsZSB2YWx1ZXNcbiAgICBjb25zdCBtZWRpYW5PdmVyYWxsVmFsdWUgPVxuICAgICAgcXVvdGVzWyhxdW90ZXMubGVuZ3RoIC0gMSkgLyAyXS5vdmVyYWxsVmFsdWVPZlF1b3RlO1xuICAgIGNvbnN0IHF1b3Rlc01hdGNoaW5nTWVkaWFuUXVvdGVWYWx1ZSA9IHF1b3Rlcy5maWx0ZXIoXG4gICAgICAocXVvdGUpID0+IG1lZGlhbk92ZXJhbGxWYWx1ZSA9PT0gcXVvdGUub3ZlcmFsbFZhbHVlT2ZRdW90ZSxcbiAgICApO1xuICAgIHJldHVybiBtZWFuc09mUXVvdGVzRmVlc0FuZFZhbHVlKHF1b3Rlc01hdGNoaW5nTWVkaWFuUXVvdGVWYWx1ZSk7XG4gIH1cblxuICAvLyByZXR1cm4gbWVhbiBvZiBtaWRkbGUgdHdvIHZhbHVlc1xuICBjb25zdCB1cHBlckluZGV4ID0gcXVvdGVzLmxlbmd0aCAvIDI7XG4gIGNvbnN0IGxvd2VySW5kZXggPSB1cHBlckluZGV4IC0gMTtcblxuICBjb25zdCBvdmVyYWxsVmFsdWVBdFVwcGVySW5kZXggPSBxdW90ZXNbdXBwZXJJbmRleF0ub3ZlcmFsbFZhbHVlT2ZRdW90ZTtcbiAgY29uc3Qgb3ZlcmFsbFZhbHVlQXRMb3dlckluZGV4ID0gcXVvdGVzW2xvd2VySW5kZXhdLm92ZXJhbGxWYWx1ZU9mUXVvdGU7XG5cbiAgY29uc3QgcXVvdGVzTWF0Y2hpbmdVcHBlckluZGV4VmFsdWUgPSBxdW90ZXMuZmlsdGVyKFxuICAgIChxdW90ZSkgPT4gb3ZlcmFsbFZhbHVlQXRVcHBlckluZGV4ID09PSBxdW90ZS5vdmVyYWxsVmFsdWVPZlF1b3RlLFxuICApO1xuICBjb25zdCBxdW90ZXNNYXRjaGluZ0xvd2VySW5kZXhWYWx1ZSA9IHF1b3Rlcy5maWx0ZXIoXG4gICAgKHF1b3RlKSA9PiBvdmVyYWxsVmFsdWVBdExvd2VySW5kZXggPT09IHF1b3RlLm92ZXJhbGxWYWx1ZU9mUXVvdGUsXG4gICk7XG5cbiAgY29uc3QgZmVlc0FuZFZhbHVlQXRVcHBlckluZGV4ID0gbWVhbnNPZlF1b3Rlc0ZlZXNBbmRWYWx1ZShcbiAgICBxdW90ZXNNYXRjaGluZ1VwcGVySW5kZXhWYWx1ZSxcbiAgKTtcbiAgY29uc3QgZmVlc0FuZFZhbHVlQXRMb3dlckluZGV4ID0gbWVhbnNPZlF1b3Rlc0ZlZXNBbmRWYWx1ZShcbiAgICBxdW90ZXNNYXRjaGluZ0xvd2VySW5kZXhWYWx1ZSxcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIGV0aEZlZTogbmV3IEJpZ051bWJlcihmZWVzQW5kVmFsdWVBdFVwcGVySW5kZXguZXRoRmVlLCAxMClcbiAgICAgIC5wbHVzKGZlZXNBbmRWYWx1ZUF0TG93ZXJJbmRleC5ldGhGZWUsIDEwKVxuICAgICAgLmRpdmlkZWRCeSgyKVxuICAgICAgLnRvU3RyaW5nKDEwKSxcbiAgICBtZXRhTWFza0ZlZUluRXRoOiBuZXcgQmlnTnVtYmVyKFxuICAgICAgZmVlc0FuZFZhbHVlQXRVcHBlckluZGV4Lm1ldGFNYXNrRmVlSW5FdGgsXG4gICAgICAxMCxcbiAgICApXG4gICAgICAucGx1cyhmZWVzQW5kVmFsdWVBdExvd2VySW5kZXgubWV0YU1hc2tGZWVJbkV0aCwgMTApXG4gICAgICAuZGl2aWRlZEJ5KDIpXG4gICAgICAudG9TdHJpbmcoMTApLFxuICAgIGV0aFZhbHVlT2ZUb2tlbnM6IG5ldyBCaWdOdW1iZXIoXG4gICAgICBmZWVzQW5kVmFsdWVBdFVwcGVySW5kZXguZXRoVmFsdWVPZlRva2VucyxcbiAgICAgIDEwLFxuICAgIClcbiAgICAgIC5wbHVzKGZlZXNBbmRWYWx1ZUF0TG93ZXJJbmRleC5ldGhWYWx1ZU9mVG9rZW5zLCAxMClcbiAgICAgIC5kaXZpZGVkQnkoMilcbiAgICAgIC50b1N0cmluZygxMCksXG4gIH07XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYXJpdGhtZXRpYyBtZWFuIGZvciBlYWNoIG9mIHRocmVlIHByb3BlcnRpZXMgLSBldGhGZWUsIG1ldGFNYXNrRmVlSW5FdGggYW5kIGV0aFZhbHVlT2ZUb2tlbnMgLSBhY3Jvc3NcbiAqIGFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aG9zZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHF1b3RlcyAtIEEgc2FtcGxlIG9mIHF1b3RlIG9iamVjdHMgd2l0aCBvdmVyYWxsVmFsdWVPZlF1b3RlLCBldGhGZWUsIG1ldGFNYXNrRmVlSW5FdGggYW5kXG4gKiBldGhWYWx1ZU9mVG9rZW5zIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBhcml0aG1ldGljIG1lYW4gZWFjaCBvZiB0aGUgZXRoRmVlLCBtZXRhTWFza0ZlZUluRXRoIGFuZCBldGhWYWx1ZU9mVG9rZW5zIG9mXG4gKiB0aGUgcGFzc2VkIHF1b3RlIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gbWVhbnNPZlF1b3Rlc0ZlZXNBbmRWYWx1ZShxdW90ZXMpIHtcbiAgY29uc3QgZmVlQW5kVmFsdWVTdW1zQXNCaWdOdW1iZXJzID0gcXVvdGVzLnJlZHVjZShcbiAgICAoZmVlQW5kVmFsdWVTdW1zLCBxdW90ZSkgPT4gKHtcbiAgICAgIGV0aEZlZTogZmVlQW5kVmFsdWVTdW1zLmV0aEZlZS5wbHVzKHF1b3RlLmV0aEZlZSwgMTApLFxuICAgICAgbWV0YU1hc2tGZWVJbkV0aDogZmVlQW5kVmFsdWVTdW1zLm1ldGFNYXNrRmVlSW5FdGgucGx1cyhcbiAgICAgICAgcXVvdGUubWV0YU1hc2tGZWVJbkV0aCxcbiAgICAgICAgMTAsXG4gICAgICApLFxuICAgICAgZXRoVmFsdWVPZlRva2VuczogZmVlQW5kVmFsdWVTdW1zLmV0aFZhbHVlT2ZUb2tlbnMucGx1cyhcbiAgICAgICAgcXVvdGUuZXRoVmFsdWVPZlRva2VucyxcbiAgICAgICAgMTAsXG4gICAgICApLFxuICAgIH0pLFxuICAgIHtcbiAgICAgIGV0aEZlZTogbmV3IEJpZ051bWJlcigwLCAxMCksXG4gICAgICBtZXRhTWFza0ZlZUluRXRoOiBuZXcgQmlnTnVtYmVyKDAsIDEwKSxcbiAgICAgIGV0aFZhbHVlT2ZUb2tlbnM6IG5ldyBCaWdOdW1iZXIoMCwgMTApLFxuICAgIH0sXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBldGhGZWU6IGZlZUFuZFZhbHVlU3Vtc0FzQmlnTnVtYmVycy5ldGhGZWVcbiAgICAgIC5kaXYocXVvdGVzLmxlbmd0aCwgMTApXG4gICAgICAudG9TdHJpbmcoMTApLFxuICAgIG1ldGFNYXNrRmVlSW5FdGg6IGZlZUFuZFZhbHVlU3Vtc0FzQmlnTnVtYmVycy5tZXRhTWFza0ZlZUluRXRoXG4gICAgICAuZGl2KHF1b3Rlcy5sZW5ndGgsIDEwKVxuICAgICAgLnRvU3RyaW5nKDEwKSxcbiAgICBldGhWYWx1ZU9mVG9rZW5zOiBmZWVBbmRWYWx1ZVN1bXNBc0JpZ051bWJlcnMuZXRoVmFsdWVPZlRva2Vuc1xuICAgICAgLmRpdihxdW90ZXMubGVuZ3RoLCAxMClcbiAgICAgIC50b1N0cmluZygxMCksXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCB1dGlscyA9IHtcbiAgZ2V0TWVkaWFuRXRoVmFsdWVRdW90ZSxcbiAgbWVhbnNPZlF1b3Rlc0ZlZXNBbmRWYWx1ZSxcbn07XG4iLCIvKiBBY2NvdW50IFRyYWNrZXJcbiAqXG4gKiBUaGlzIG1vZHVsZSBpcyByZXNwb25zaWJsZSBmb3IgdHJhY2tpbmcgYW55IG51bWJlciBvZiBhY2NvdW50c1xuICogYW5kIGNhY2hpbmcgdGhlaXIgY3VycmVudCBiYWxhbmNlcyAmIHRyYW5zYWN0aW9uIGNvdW50cy5cbiAqXG4gKiBJdCBhbHNvIHRyYWNrcyB0cmFuc2FjdGlvbiBoYXNoZXMsIGFuZCBjaGVja3MgdGhlaXIgaW5jbHVzaW9uIHN0YXR1c1xuICogb24gZWFjaCBuZXcgYmxvY2suXG4gKi9cblxuaW1wb3J0IEV0aFF1ZXJ5IGZyb20gJ2V0aC1xdWVyeSc7XG5cbmltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgcGlmeSBmcm9tICdwaWZ5JztcbmltcG9ydCBXZWIzIGZyb20gJ3dlYjMnO1xuaW1wb3J0IFNJTkdMRV9DQUxMX0JBTEFOQ0VTX0FCSSBmcm9tICdzaW5nbGUtY2FsbC1iYWxhbmNlLWNoZWNrZXItYWJpJztcbmltcG9ydCB7XG4gIE1BSU5ORVRfQ0hBSU5fSUQsXG4gIFJJTktFQllfQ0hBSU5fSUQsXG4gIFJPUFNURU5fQ0hBSU5fSUQsXG4gIEtPVkFOX0NIQUlOX0lELFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuXG5pbXBvcnQge1xuICBTSU5HTEVfQ0FMTF9CQUxBTkNFU19BRERSRVNTLFxuICBTSU5HTEVfQ0FMTF9CQUxBTkNFU19BRERSRVNTX1JJTktFQlksXG4gIFNJTkdMRV9DQUxMX0JBTEFOQ0VTX0FERFJFU1NfUk9QU1RFTixcbiAgU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTU19LT1ZBTixcbn0gZnJvbSAnLi4vY29uc3RhbnRzL2NvbnRyYWN0cyc7XG5pbXBvcnQgeyBiblRvSGV4IH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBpcyByZXNwb25zaWJsZSBmb3IgdHJhY2tpbmcgYW55IG51bWJlciBvZiBhY2NvdW50cyBhbmQgY2FjaGluZyB0aGVpciBjdXJyZW50IGJhbGFuY2VzICYgdHJhbnNhY3Rpb25cbiAqIGNvdW50cy5cbiAqXG4gKiBJdCBhbHNvIHRyYWNrcyB0cmFuc2FjdGlvbiBoYXNoZXMsIGFuZCBjaGVja3MgdGhlaXIgaW5jbHVzaW9uIHN0YXR1cyBvbiBlYWNoIG5ldyBibG9jay5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBY2NvdW50VHJhY2tlclxuICogQHByb3BlcnR5IHtPYmplY3R9IHN0b3JlIFRoZSBzdG9yZWQgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGFjY291bnRzIHRvIHRyYWNrLCBhcyB3ZWxsIGFzIHRoZSBjdXJyZW50IGJsb2NrJ3MgZ2FzIGxpbWl0LlxuICogQHByb3BlcnR5IHtPYmplY3R9IHN0b3JlLmFjY291bnRzIFRoZSBhY2NvdW50cyBjdXJyZW50bHkgc3RvcmVkIGluIHRoaXMgQWNjb3VudFRyYWNrZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdG9yZS5jdXJyZW50QmxvY2tHYXNMaW1pdCBBIGhleCBzdHJpbmcgaW5kaWNhdGluZyB0aGUgZ2FzIGxpbWl0IG9mIHRoZSBjdXJyZW50IGJsb2NrXG4gKiBAcHJvcGVydHkge09iamVjdH0gX3Byb3ZpZGVyIEEgcHJvdmlkZXIgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgRXRoUXVlcnkgaW5zdGFuY2UgdXNlZCB3aXRoaW4gdGhpcyBBY2NvdW50VHJhY2tlci5cbiAqIEBwcm9wZXJ0eSB7RXRoUXVlcnl9IF9xdWVyeSBBbiBFdGhRdWVyeSBpbnN0YW5jZSB1c2VkIHRvIGFjY2VzcyBhY2NvdW50IGluZm9ybWF0aW9uIGZyb20gdGhlIGJsb2NrY2hhaW5cbiAqIEBwcm9wZXJ0eSB7QmxvY2tUcmFja2VyfSBfYmxvY2tUcmFja2VyIEEgQmxvY2tUcmFja2VyIGluc3RhbmNlLiBOZWVkZWQgdG8gZW5zdXJlIHRoYXQgYWNjb3VudHMgYW5kIHRoZWlyIGluZm8gdXBkYXRlc1xuICogd2hlbiBhIG5ldyBibG9jayBpcyBjcmVhdGVkLlxuICogQHByb3BlcnR5IHtPYmplY3R9IF9jdXJyZW50QmxvY2tOdW1iZXIgUmVmZXJlbmNlIHRvIGEgcHJvcGVydHkgb24gdGhlIF9ibG9ja1RyYWNrZXI6IHRoZSBudW1iZXIgKGkuZS4gYW4gaWQpIG9mIHRoZSB0aGUgY3VycmVudCBibG9ja1xuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWNjb3VudFRyYWNrZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIGZvciBpbml0aWFsaXppbmcgdGhlIGNvbnRyb2xsZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucHJvdmlkZXIgLSBBbiBFSVAtMTE5MyBwcm92aWRlciBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIGN1cnJlbnQgZ2xvYmFsIG5ldHdvcmtcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuYmxvY2tUcmFja2VyIC0gQSBibG9jayB0cmFja2VyLCB3aGljaCBlbWl0cyBldmVudHMgZm9yIGVhY2ggbmV3IGJsb2NrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdHMuZ2V0Q3VycmVudENoYWluSWQgLSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYGNoYWluSWRgIGZvciB0aGUgY3VycmVudCBnbG9iYWwgbmV0d29ya1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgY29uc3QgaW5pdFN0YXRlID0ge1xuICAgICAgYWNjb3VudHM6IHt9LFxuICAgICAgY3VycmVudEJsb2NrR2FzTGltaXQ6ICcnLFxuICAgIH07XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoaW5pdFN0YXRlKTtcblxuICAgIHRoaXMuX3Byb3ZpZGVyID0gb3B0cy5wcm92aWRlcjtcbiAgICB0aGlzLl9xdWVyeSA9IHBpZnkobmV3IEV0aFF1ZXJ5KHRoaXMuX3Byb3ZpZGVyKSk7XG4gICAgdGhpcy5fYmxvY2tUcmFja2VyID0gb3B0cy5ibG9ja1RyYWNrZXI7XG4gICAgLy8gYmxvY2tUcmFja2VyLmN1cnJlbnRCbG9jayBtYXkgYmUgbnVsbFxuICAgIHRoaXMuX2N1cnJlbnRCbG9ja051bWJlciA9IHRoaXMuX2Jsb2NrVHJhY2tlci5nZXRDdXJyZW50QmxvY2soKTtcbiAgICB0aGlzLl9ibG9ja1RyYWNrZXIub25jZSgnbGF0ZXN0JywgKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICB0aGlzLl9jdXJyZW50QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICB9KTtcbiAgICAvLyBiaW5kIGZ1bmN0aW9uIGZvciBlYXNpZXIgbGlzdGVuZXIgc3ludGF4XG4gICAgdGhpcy5fdXBkYXRlRm9yQmxvY2sgPSB0aGlzLl91cGRhdGVGb3JCbG9jay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0Q3VycmVudENoYWluSWQgPSBvcHRzLmdldEN1cnJlbnRDaGFpbklkO1xuXG4gICAgdGhpcy53ZWIzID0gbmV3IFdlYjModGhpcy5fcHJvdmlkZXIpO1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgLy8gcmVtb3ZlIGZpcnN0IHRvIGF2b2lkIGRvdWJsZSBhZGRcbiAgICB0aGlzLl9ibG9ja1RyYWNrZXIucmVtb3ZlTGlzdGVuZXIoJ2xhdGVzdCcsIHRoaXMuX3VwZGF0ZUZvckJsb2NrKTtcbiAgICAvLyBhZGQgbGlzdGVuZXJcbiAgICB0aGlzLl9ibG9ja1RyYWNrZXIuYWRkTGlzdGVuZXIoJ2xhdGVzdCcsIHRoaXMuX3VwZGF0ZUZvckJsb2NrKTtcbiAgICAvLyBmZXRjaCBhY2NvdW50IGJhbGFuY2VzXG4gICAgdGhpcy5fdXBkYXRlQWNjb3VudHMoKTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgLy8gcmVtb3ZlIGxpc3RlbmVyXG4gICAgdGhpcy5fYmxvY2tUcmFja2VyLnJlbW92ZUxpc3RlbmVyKCdsYXRlc3QnLCB0aGlzLl91cGRhdGVGb3JCbG9jayk7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IHRoZSBsb2NhbGx5IHN0b3JlZCBhY2NvdW50cyBhcmUgaW4gc3luYyB3aXRoIGEgc2V0IG9mIGFjY291bnRzIHN0b3JlZCBleHRlcm5hbGx5IHRvIHRoaXNcbiAgICogQWNjb3VudFRyYWNrZXIuXG4gICAqXG4gICAqIE9uY2UgdGhpcyBBY2NvdW50VHJhY2tlcidzIGFjY291bnRzIGFyZSB1cCB0byBkYXRlIHdpdGggdGhvc2UgcmVmZXJlbmNlZCBieSB0aGUgcGFzc2VkIGFkZHJlc3NlcywgZWFjaFxuICAgKiBvZiB0aGVzZSBhY2NvdW50cyBhcmUgZ2l2ZW4gYW4gdXBkYXRlZCBiYWxhbmNlIHZpYSBFdGhRdWVyeS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYWRkcmVzcyAtIFRoZSBhcnJheSBvZiBoZXggYWRkcmVzc2VzIGZvciBhY2NvdW50cyB3aXRoIHdoaWNoIHRoaXMgQWNjb3VudFRyYWNrZXIncyBhY2NvdW50cyBzaG91bGQgYmVcbiAgICogaW4gc3luY1xuICAgKlxuICAgKi9cbiAgc3luY1dpdGhBZGRyZXNzZXMoYWRkcmVzc2VzKSB7XG4gICAgY29uc3QgeyBhY2NvdW50cyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGxvY2FscyA9IE9iamVjdC5rZXlzKGFjY291bnRzKTtcblxuICAgIGNvbnN0IGFjY291bnRzVG9BZGQgPSBbXTtcbiAgICBhZGRyZXNzZXMuZm9yRWFjaCgodXBzdHJlYW0pID0+IHtcbiAgICAgIGlmICghbG9jYWxzLmluY2x1ZGVzKHVwc3RyZWFtKSkge1xuICAgICAgICBhY2NvdW50c1RvQWRkLnB1c2godXBzdHJlYW0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgYWNjb3VudHNUb1JlbW92ZSA9IFtdO1xuICAgIGxvY2Fscy5mb3JFYWNoKChsb2NhbCkgPT4ge1xuICAgICAgaWYgKCFhZGRyZXNzZXMuaW5jbHVkZXMobG9jYWwpKSB7XG4gICAgICAgIGFjY291bnRzVG9SZW1vdmUucHVzaChsb2NhbCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZEFjY291bnRzKGFjY291bnRzVG9BZGQpO1xuICAgIHRoaXMucmVtb3ZlQWNjb3VudChhY2NvdW50c1RvUmVtb3ZlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG5ldyBhZGRyZXNzZXMgdG8gdHJhY2sgdGhlIGJhbGFuY2VzIG9mXG4gICAqIGdpdmVuIGEgYmFsYW5jZSBhcyBsb25nIHRoaXMuX2N1cnJlbnRCbG9ja051bWJlciBpcyBkZWZpbmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhZGRyZXNzZXMgLSBBbiBhcnJheSBvZiBoZXggYWRkcmVzc2VzIG9mIG5ldyBhY2NvdW50cyB0byB0cmFja1xuICAgKlxuICAgKi9cbiAgYWRkQWNjb3VudHMoYWRkcmVzc2VzKSB7XG4gICAgY29uc3QgeyBhY2NvdW50cyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIC8vIGFkZCBpbml0aWFsIHN0YXRlIGZvciBhZGRyZXNzZXNcbiAgICBhZGRyZXNzZXMuZm9yRWFjaCgoYWRkcmVzcykgPT4ge1xuICAgICAgYWNjb3VudHNbYWRkcmVzc10gPSB7fTtcbiAgICB9KTtcbiAgICAvLyBzYXZlIGFjY291bnRzIHN0YXRlXG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGFjY291bnRzIH0pO1xuICAgIC8vIGZldGNoIGJhbGFuY2VzIGZvciB0aGUgYWNjb3VudHMgaWYgdGhlcmUgaXMgYmxvY2sgbnVtYmVyIHJlYWR5XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50QmxvY2tOdW1iZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlQWNjb3VudHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFjY291bnRzIGZyb20gYmVpbmcgdHJhY2tlZFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhbiAtIGFycmF5IG9mIGhleCBhZGRyZXNzZXMgdG8gc3RvcCB0cmFja2luZ1xuICAgKlxuICAgKi9cbiAgcmVtb3ZlQWNjb3VudChhZGRyZXNzZXMpIHtcbiAgICBjb25zdCB7IGFjY291bnRzIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgLy8gcmVtb3ZlIGVhY2ggc3RhdGUgb2JqZWN0XG4gICAgYWRkcmVzc2VzLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICAgIGRlbGV0ZSBhY2NvdW50c1thZGRyZXNzXTtcbiAgICB9KTtcbiAgICAvLyBzYXZlIGFjY291bnRzIHN0YXRlXG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGFjY291bnRzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGFkZHJlc3NlcyBhbmQgYXNzb2NpYXRlZCBiYWxhbmNlc1xuICAgKi9cblxuICBjbGVhckFjY291bnRzKCkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBhY2NvdW50czoge30gfSk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBibG9jaywgdXBkYXRlcyB0aGlzIEFjY291bnRUcmFja2VyJ3MgY3VycmVudEJsb2NrR2FzTGltaXQsIGFuZCB0aGVuIHVwZGF0ZXMgZWFjaCBsb2NhbCBhY2NvdW50J3MgYmFsYW5jZVxuICAgKiB2aWEgRXRoUXVlcnlcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrTnVtYmVyIC0gdGhlIGJsb2NrIG51bWJlciB0byB1cGRhdGUgdG8uXG4gICAqIEBmaXJlcyAnYmxvY2snIFRoZSB1cGRhdGVkIHN0YXRlLCBpZiBhbGwgYWNjb3VudCB1cGRhdGVzIGFyZSBzdWNjZXNzZnVsXG4gICAqXG4gICAqL1xuICBhc3luYyBfdXBkYXRlRm9yQmxvY2soYmxvY2tOdW1iZXIpIHtcbiAgICB0aGlzLl9jdXJyZW50QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcblxuICAgIC8vIGJsb2NrIGdhc0xpbWl0IHBvbGxpbmcgc2hvdWxkbid0IGJlIGluIGFjY291bnQtdHJhY2tlciBzaG91bGRuJ3QgYmUgaGVyZS4uLlxuICAgIGNvbnN0IGN1cnJlbnRCbG9jayA9IGF3YWl0IHRoaXMuX3F1ZXJ5LmdldEJsb2NrQnlOdW1iZXIoYmxvY2tOdW1iZXIsIGZhbHNlKTtcbiAgICBpZiAoIWN1cnJlbnRCbG9jaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50QmxvY2tHYXNMaW1pdCA9IGN1cnJlbnRCbG9jay5nYXNMaW1pdDtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgY3VycmVudEJsb2NrR2FzTGltaXQgfSk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlQWNjb3VudHMoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBiYWxhbmNlQ2hlY2tlciBpcyBkZXBsb3llZCBvbiBtYWluIGV0aCAodGVzdCluZXRzIGFuZCByZXF1aXJlcyBhIHNpbmdsZSBjYWxsXG4gICAqIGZvciBhbGwgb3RoZXIgbmV0d29ya3MsIGNhbGxzIHRoaXMuX3VwZGF0ZUFjY291bnQgZm9yIGVhY2ggYWNjb3VudCBpbiB0aGlzLnN0b3JlXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBhZnRlciBhbGwgYWNjb3VudCBiYWxhbmNlcyB1cGRhdGVkXG4gICAqXG4gICAqL1xuICBhc3luYyBfdXBkYXRlQWNjb3VudHMoKSB7XG4gICAgY29uc3QgeyBhY2NvdW50cyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IE9iamVjdC5rZXlzKGFjY291bnRzKTtcbiAgICBjb25zdCBjaGFpbklkID0gdGhpcy5nZXRDdXJyZW50Q2hhaW5JZCgpO1xuXG4gICAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgICBjYXNlIE1BSU5ORVRfQ0hBSU5fSUQ6XG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZUFjY291bnRzVmlhQmFsYW5jZUNoZWNrZXIoXG4gICAgICAgICAgYWRkcmVzc2VzLFxuICAgICAgICAgIFNJTkdMRV9DQUxMX0JBTEFOQ0VTX0FERFJFU1MsXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFJJTktFQllfQ0hBSU5fSUQ6XG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZUFjY291bnRzVmlhQmFsYW5jZUNoZWNrZXIoXG4gICAgICAgICAgYWRkcmVzc2VzLFxuICAgICAgICAgIFNJTkdMRV9DQUxMX0JBTEFOQ0VTX0FERFJFU1NfUklOS0VCWSxcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUk9QU1RFTl9DSEFJTl9JRDpcbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlQWNjb3VudHNWaWFCYWxhbmNlQ2hlY2tlcihcbiAgICAgICAgICBhZGRyZXNzZXMsXG4gICAgICAgICAgU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTU19ST1BTVEVOLFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBLT1ZBTl9DSEFJTl9JRDpcbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlQWNjb3VudHNWaWFCYWxhbmNlQ2hlY2tlcihcbiAgICAgICAgICBhZGRyZXNzZXMsXG4gICAgICAgICAgU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTU19LT1ZBTixcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGFkZHJlc3Nlcy5tYXAodGhpcy5fdXBkYXRlQWNjb3VudC5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgYmFsYW5jZSBvZiBhbiBhY2NvdW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEEgaGV4IGFkZHJlc3Mgb2YgYSB0aGUgYWNjb3VudCB0byBiZSB1cGRhdGVkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBhZnRlciB0aGUgYWNjb3VudCBiYWxhbmNlIGlzIHVwZGF0ZWRcbiAgICpcbiAgICovXG4gIGFzeW5jIF91cGRhdGVBY2NvdW50KGFkZHJlc3MpIHtcbiAgICAvLyBxdWVyeSBiYWxhbmNlXG4gICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IHRoaXMuX3F1ZXJ5LmdldEJhbGFuY2UoYWRkcmVzcyk7XG4gICAgY29uc3QgcmVzdWx0ID0geyBhZGRyZXNzLCBiYWxhbmNlIH07XG4gICAgLy8gdXBkYXRlIGFjY291bnRzIHN0YXRlXG4gICAgY29uc3QgeyBhY2NvdW50cyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIC8vIG9ubHkgcG9wdWxhdGUgaWYgdGhlIGVudHJ5IGlzIHN0aWxsIHByZXNlbnRcbiAgICBpZiAoIWFjY291bnRzW2FkZHJlc3NdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjY291bnRzW2FkZHJlc3NdID0gcmVzdWx0O1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBhY2NvdW50cyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGN1cnJlbnQgYWRkcmVzcyBiYWxhbmNlcyBmcm9tIGJhbGFuY2VDaGVja2VyIGRlcGxveWVkIGNvbnRyYWN0IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7Kn0gYWRkcmVzc2VzXG4gICAqIEBwYXJhbSB7Kn0gZGVwbG95ZWRDb250cmFjdEFkZHJlc3NcbiAgICovXG4gIGFzeW5jIF91cGRhdGVBY2NvdW50c1ZpYUJhbGFuY2VDaGVja2VyKGFkZHJlc3NlcywgZGVwbG95ZWRDb250cmFjdEFkZHJlc3MpIHtcbiAgICBjb25zdCB7IGFjY291bnRzIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy53ZWIzLnNldFByb3ZpZGVyKHRoaXMuX3Byb3ZpZGVyKTtcbiAgICBjb25zdCBldGhDb250cmFjdCA9IHRoaXMud2ViMy5ldGhcbiAgICAgIC5jb250cmFjdChTSU5HTEVfQ0FMTF9CQUxBTkNFU19BQkkpXG4gICAgICAuYXQoZGVwbG95ZWRDb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGV0aEJhbGFuY2UgPSBbJzB4MCddO1xuXG4gICAgZXRoQ29udHJhY3QuYmFsYW5jZXMoYWRkcmVzc2VzLCBldGhCYWxhbmNlLCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGxvZy53YXJuKFxuICAgICAgICAgIGBNZXRhTWFzayAtIEFjY291bnQgVHJhY2tlciBzaW5nbGUgY2FsbCBiYWxhbmNlIGZldGNoIGZhaWxlZGAsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICk7XG4gICAgICAgIFByb21pc2UuYWxsKGFkZHJlc3Nlcy5tYXAodGhpcy5fdXBkYXRlQWNjb3VudC5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFkZHJlc3Nlcy5mb3JFYWNoKChhZGRyZXNzLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBiYWxhbmNlID0gcmVzdWx0W2luZGV4XSA/IGJuVG9IZXgocmVzdWx0W2luZGV4XSkgOiAnMHgwJztcbiAgICAgICAgYWNjb3VudHNbYWRkcmVzc10gPSB7IGFkZHJlc3MsIGJhbGFuY2UgfTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGFjY291bnRzIH0pO1xuICAgIH0pO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Blcm1pc3Npb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZXNvdXJjZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2VydmljZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NuYXBzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdWJqZWN0LW1ldGFkYXRhXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlxuJ3VzZSBzdHJpY3QnXG5cbmlmIChcImRldmVsb3BtZW50XCIgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy5janMuZGV2ZWxvcG1lbnQuanMnKVxufVxuIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZVN0b3JlIH0gZnJvbSAnQG1ldGFtYXNrL29icy1zdG9yZSc7XG5cbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9maXJzdCxpbXBvcnQvb3JkZXIgKi9cbmNvbnN0IEJveCA9IHByb2Nlc3MuZW52LklOX1RFU1RcbiAgPyByZXF1aXJlKCcuLi8uLi8uLi9kZXZlbG9wbWVudC9tb2NrLTNib3gnKVxuICA6IHJlcXVpcmUoJzNib3gnKTtcbi8qIGVzbGludC1lbmFibGUgaW1wb3J0L29yZGVyICovXG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsgSnNvblJwY0VuZ2luZSB9IGZyb20gJ2pzb24tcnBjLWVuZ2luZSc7XG5pbXBvcnQgeyBwcm92aWRlckZyb21FbmdpbmUgfSBmcm9tICdldGgtanNvbi1ycGMtbWlkZGxld2FyZSc7XG5pbXBvcnQgTWlncmF0b3IgZnJvbSAnLi4vbGliL21pZ3JhdG9yJztcbmltcG9ydCBtaWdyYXRpb25zIGZyb20gJy4uL21pZ3JhdGlvbnMnO1xuaW1wb3J0IGNyZWF0ZU9yaWdpbk1pZGRsZXdhcmUgZnJvbSAnLi4vbGliL2NyZWF0ZU9yaWdpbk1pZGRsZXdhcmUnO1xuaW1wb3J0IGNyZWF0ZU1ldGFtYXNrTWlkZGxld2FyZSBmcm9tICcuL25ldHdvcmsvY3JlYXRlTWV0YW1hc2tNaWRkbGV3YXJlJztcbi8qIGVzbGludC1lbmFibGUgaW1wb3J0L2ZpcnN0ICovXG5cbmNvbnN0IFNZTkNfVElNRU9VVCA9IDYwICogMTAwMDsgLy8gb25lIG1pbnV0ZVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaHJlZUJveENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICBrZXlyaW5nQ29udHJvbGxlcixcbiAgICAgIGFkZHJlc3NCb29rQ29udHJvbGxlcixcbiAgICAgIHZlcnNpb24sXG4gICAgICBnZXRLZXlyaW5nQ29udHJvbGxlclN0YXRlLFxuICAgICAgdHJhY2tNZXRhTWV0cmljc0V2ZW50LFxuICAgIH0gPSBvcHRzO1xuXG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSBwcmVmZXJlbmNlc0NvbnRyb2xsZXI7XG4gICAgdGhpcy5hZGRyZXNzQm9va0NvbnRyb2xsZXIgPSBhZGRyZXNzQm9va0NvbnRyb2xsZXI7XG4gICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlciA9IGtleXJpbmdDb250cm9sbGVyO1xuICAgIHRoaXMucHJvdmlkZXIgPSB0aGlzLl9jcmVhdGVQcm92aWRlcih7XG4gICAgICB2ZXJzaW9uLFxuICAgICAgZ2V0QWNjb3VudHM6IGFzeW5jICh7IG9yaWdpbiB9KSA9PiB7XG4gICAgICAgIGlmIChvcmlnaW4gIT09ICczQm94Jykge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlzVW5sb2NrZWQgfSA9IGdldEtleXJpbmdDb250cm9sbGVyU3RhdGUoKTtcblxuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcblxuICAgICAgICBpZiAoaXNVbmxvY2tlZCAmJiBhY2NvdW50c1swXSkge1xuICAgICAgICAgIGNvbnN0IGFwcEtleUFkZHJlc3MgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFwcEtleUFkZHJlc3MoXG4gICAgICAgICAgICBhY2NvdW50c1swXSxcbiAgICAgICAgICAgICd3YWxsZXQ6Ly8zYm94Lm1ldGFtYXNrLmlvJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBbYXBwS2V5QWRkcmVzc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSxcbiAgICAgIHByb2Nlc3NQZXJzb25hbE1lc3NhZ2U6IGFzeW5jIChtc2dQYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG4gICAgICAgIHJldHVybiBrZXlyaW5nQ29udHJvbGxlci5zaWduUGVyc29uYWxNZXNzYWdlKFxuICAgICAgICAgIHsgLi4ubXNnUGFyYW1zLCBmcm9tOiBhY2NvdW50c1swXSB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdpdGhBcHBLZXlPcmlnaW46ICd3YWxsZXQ6Ly8zYm94Lm1ldGFtYXNrLmlvJyxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICB9KTtcbiAgICB0aGlzLl90cmFja01ldGFNZXRyaWNzRXZlbnQgPSB0cmFja01ldGFNZXRyaWNzRXZlbnQ7XG5cbiAgICBjb25zdCBpbml0U3RhdGUgPSB7XG4gICAgICB0aHJlZUJveFN5bmNpbmdBbGxvd2VkOiBmYWxzZSxcbiAgICAgIHNob3dSZXN0b3JlUHJvbXB0OiB0cnVlLFxuICAgICAgdGhyZWVCb3hMYXN0VXBkYXRlZDogMCxcbiAgICAgIC4uLm9wdHMuaW5pdFN0YXRlLFxuICAgICAgdGhyZWVCb3hBZGRyZXNzOiBudWxsLFxuICAgICAgdGhyZWVCb3hTeW5jZWQ6IGZhbHNlLFxuICAgICAgdGhyZWVCb3hEaXNhYmxlZDogZmFsc2UsXG4gICAgfTtcbiAgICB0aGlzLnN0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZShpbml0U3RhdGUpO1xuICAgIHRoaXMucmVnaXN0ZXJpbmdVcGRhdGVzID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0TWlncmF0aW9uID0gbWlncmF0aW9uc1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGEudmVyc2lvbiAtIGIudmVyc2lvbilcbiAgICAgIC5zbGljZSgtMSlbMF07XG5cbiAgICBpZiAoaW5pdFN0YXRlLnRocmVlQm94U3luY2luZ0FsbG93ZWQpIHtcbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGluaXQoKSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG4gICAgdGhpcy5hZGRyZXNzID0gYWNjb3VudHNbMF07XG5cbiAgICB0aGlzLl90cmFja01ldGFNZXRyaWNzRXZlbnQoe1xuICAgICAgZXZlbnQ6ICczQm94IEluaXRpYXRlZCcsXG4gICAgICBjYXRlZ29yeTogJzNCb3gnLFxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuYWRkcmVzcyAmJiAhKHRoaXMuYm94ICYmIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS50aHJlZUJveFN5bmNlZCkpIHtcbiAgICAgIGF3YWl0IHRoaXMubmV3M0JveCgpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF91cGRhdGUzQm94KCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHRocmVlQm94U3luY2luZ0FsbG93ZWQsIHRocmVlQm94U3luY2VkIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAodGhyZWVCb3hTeW5jaW5nQWxsb3dlZCAmJiB0aHJlZUJveFN5bmNlZCkge1xuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICBwcmVmZXJlbmNlczogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKSxcbiAgICAgICAgICBhZGRyZXNzQm9vazogdGhpcy5hZGRyZXNzQm9va0NvbnRyb2xsZXIuc3RhdGUsXG4gICAgICAgICAgbGFzdFVwZGF0ZWQ6IERhdGUubm93KCksXG4gICAgICAgICAgbGFzdE1pZ3JhdGlvbjogdGhpcy5sYXN0TWlncmF0aW9uLFxuICAgICAgICB9O1xuXG4gICAgICAgIGF3YWl0IHRoaXMuc3BhY2UucHJpdmF0ZS5zZXQoXG4gICAgICAgICAgJ21ldGFtYXNrQmFja3VwJyxcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXdTdGF0ZSksXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2V0U2hvd1Jlc3RvcmVQcm9tcHRUb0ZhbHNlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVQcm92aWRlcihwcm92aWRlck9wdHMpIHtcbiAgICBjb25zdCBtZXRhbWFza01pZGRsZXdhcmUgPSBjcmVhdGVNZXRhbWFza01pZGRsZXdhcmUocHJvdmlkZXJPcHRzKTtcbiAgICBjb25zdCBlbmdpbmUgPSBuZXcgSnNvblJwY0VuZ2luZSgpO1xuICAgIGVuZ2luZS5wdXNoKGNyZWF0ZU9yaWdpbk1pZGRsZXdhcmUoeyBvcmlnaW46ICczQm94JyB9KSk7XG4gICAgZW5naW5lLnB1c2gobWV0YW1hc2tNaWRkbGV3YXJlKTtcbiAgICBjb25zdCBwcm92aWRlciA9IHByb3ZpZGVyRnJvbUVuZ2luZShlbmdpbmUpO1xuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfVxuXG4gIF93YWl0Rm9yT25TeW5jRG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuYm94Lm9uU3luY0RvbmUoKCkgPT4ge1xuICAgICAgICBsb2cuZGVidWcoJzNCb3ggYm94IHN5bmMgZG9uZScpO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBuZXczQm94KCkge1xuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgIHRoaXMuYWRkcmVzcyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QXBwS2V5QWRkcmVzcyhcbiAgICAgIGFjY291bnRzWzBdLFxuICAgICAgJ3dhbGxldDovLzNib3gubWV0YW1hc2suaW8nLFxuICAgICk7XG4gICAgbGV0IGJhY2t1cEV4aXN0cztcbiAgICB0cnkge1xuICAgICAgY29uc3QgdGhyZWVCb3hDb25maWcgPSBhd2FpdCBCb3guZ2V0Q29uZmlnKHRoaXMuYWRkcmVzcyk7XG4gICAgICBiYWNrdXBFeGlzdHMgPSB0aHJlZUJveENvbmZpZy5zcGFjZXMgJiYgdGhyZWVCb3hDb25maWcuc3BhY2VzLm1ldGFtYXNrO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm1lc3NhZ2UubWF0Y2goL15FcnJvcjogSW52YWxpZCByZXNwb25zZSBcXCg0MDRcXCkvdSkpIHtcbiAgICAgICAgdGhpcy5fdHJhY2tNZXRhTWV0cmljc0V2ZW50KHtcbiAgICAgICAgICBldmVudDogJzNCb3ggQmFja3VwIGRvZXMgbm90IGV4aXN0JyxcbiAgICAgICAgICBjYXRlZ29yeTogJzNCb3gnLFxuICAgICAgICB9KTtcblxuICAgICAgICBiYWNrdXBFeGlzdHMgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RyYWNrTWV0YU1ldHJpY3NFdmVudCh7XG4gICAgICAgICAgZXZlbnQ6ICczQm94IENvbmZpZyBFcnJvcicsXG4gICAgICAgICAgY2F0ZWdvcnk6ICczQm94JyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0VGhyZWVCb3hTeW5jaW5nU3RhdGUoKSB8fCBiYWNrdXBFeGlzdHMpIHtcbiAgICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyB0aHJlZUJveFN5bmNlZDogZmFsc2UgfSk7XG5cbiAgICAgIGxldCB0aW1lZE91dCA9IGZhbHNlO1xuICAgICAgY29uc3Qgc3luY1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbG9nLmVycm9yKGAzQm94IHN5bmMgdGltZWQgb3V0IGFmdGVyICR7U1lOQ19USU1FT1VUfSBtc2ApO1xuICAgICAgICB0aW1lZE91dCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgICAgIHRocmVlQm94RGlzYWJsZWQ6IHRydWUsXG4gICAgICAgICAgdGhyZWVCb3hTeW5jaW5nQWxsb3dlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgfSwgU1lOQ19USU1FT1VUKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuYm94ID0gYXdhaXQgQm94Lm9wZW5Cb3godGhpcy5hZGRyZXNzLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fd2FpdEZvck9uU3luY0RvbmUoKTtcbiAgICAgICAgdGhpcy5zcGFjZSA9IGF3YWl0IHRoaXMuYm94Lm9wZW5TcGFjZSgnbWV0YW1hc2snLCB7XG4gICAgICAgICAgb25TeW5jRG9uZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVVcGRhdGUgPSB7XG4gICAgICAgICAgICAgIHRocmVlQm94U3luY2VkOiB0cnVlLFxuICAgICAgICAgICAgICB0aHJlZUJveEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGltZWRPdXQpIHtcbiAgICAgICAgICAgICAgbG9nLmluZm8oYDNCb3ggc3luYyBjb21wbGV0ZWQgYWZ0ZXIgdGltZW91dDsgbm8gbG9uZ2VyIGRpc2FibGVkYCk7XG4gICAgICAgICAgICAgIHN0YXRlVXBkYXRlLnRocmVlQm94RGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN5bmNUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoc3RhdGVVcGRhdGUpO1xuXG4gICAgICAgICAgICBsb2cuZGVidWcoJzNCb3ggc3BhY2Ugc3luYyBkb25lJyk7XG5cbiAgICAgICAgICAgIHRoaXMuX3RyYWNrTWV0YU1ldHJpY3NFdmVudCh7XG4gICAgICAgICAgICAgIGV2ZW50OiAnM0JveCBTeW5jZWQnLFxuICAgICAgICAgICAgICBjYXRlZ29yeTogJzNCb3gnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrTWV0YU1ldHJpY3NFdmVudCh7XG4gICAgICAgICAgZXZlbnQ6ICczQm94IEluaXRpYXRpb24gRXJyb3InLFxuICAgICAgICAgIGNhdGVnb3J5OiAnM0JveCcsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0TGFzdFVwZGF0ZWQoKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5zcGFjZS5wcml2YXRlLmdldCgnbWV0YW1hc2tCYWNrdXAnKTtcbiAgICBjb25zdCBwYXJzZWRSZXMgPSBKU09OLnBhcnNlKHJlcyB8fCAne30nKTtcbiAgICByZXR1cm4gcGFyc2VkUmVzLmxhc3RVcGRhdGVkO1xuICB9XG5cbiAgYXN5bmMgbWlncmF0ZUJhY2tlZFVwU3RhdGUoYmFja2VkVXBTdGF0ZSkge1xuICAgIGNvbnN0IG1pZ3JhdG9yID0gbmV3IE1pZ3JhdG9yKHsgbWlncmF0aW9ucyB9KTtcbiAgICBjb25zdCB7IHByZWZlcmVuY2VzLCBhZGRyZXNzQm9vayB9ID0gSlNPTi5wYXJzZShiYWNrZWRVcFN0YXRlKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRTdGF0ZUJhY2t1cCA9IHtcbiAgICAgIFByZWZlcmVuY2VzQ29udHJvbGxlcjogcHJlZmVyZW5jZXMsXG4gICAgICBBZGRyZXNzQm9va0NvbnRyb2xsZXI6IGFkZHJlc3NCb29rLFxuICAgIH07XG4gICAgY29uc3QgaW5pdGlhbE1pZ3JhdGlvblN0YXRlID0gbWlncmF0b3IuZ2VuZXJhdGVJbml0aWFsU3RhdGUoXG4gICAgICBmb3JtYXR0ZWRTdGF0ZUJhY2t1cCxcbiAgICApO1xuICAgIGNvbnN0IG1pZ3JhdGVkU3RhdGUgPSBhd2FpdCBtaWdyYXRvci5taWdyYXRlRGF0YShpbml0aWFsTWlncmF0aW9uU3RhdGUpO1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmZXJlbmNlczogbWlncmF0ZWRTdGF0ZS5kYXRhLlByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgIGFkZHJlc3NCb29rOiBtaWdyYXRlZFN0YXRlLmRhdGEuQWRkcmVzc0Jvb2tDb250cm9sbGVyLFxuICAgIH07XG4gIH1cblxuICBhc3luYyByZXN0b3JlRnJvbVRocmVlQm94KCkge1xuICAgIGNvbnN0IGJhY2tlZFVwU3RhdGUgPSBhd2FpdCB0aGlzLnNwYWNlLnByaXZhdGUuZ2V0KCdtZXRhbWFza0JhY2t1cCcpO1xuICAgIGNvbnN0IHsgcHJlZmVyZW5jZXMsIGFkZHJlc3NCb29rIH0gPSBhd2FpdCB0aGlzLm1pZ3JhdGVCYWNrZWRVcFN0YXRlKFxuICAgICAgYmFja2VkVXBTdGF0ZSxcbiAgICApO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyB0aHJlZUJveExhc3RVcGRhdGVkOiBiYWNrZWRVcFN0YXRlLmxhc3RVcGRhdGVkIH0pO1xuICAgIHByZWZlcmVuY2VzICYmIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnVwZGF0ZVN0YXRlKHByZWZlcmVuY2VzKTtcbiAgICBhZGRyZXNzQm9vayAmJiB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlci51cGRhdGUoYWRkcmVzc0Jvb2ssIHRydWUpO1xuICAgIHRoaXMuc2V0U2hvd1Jlc3RvcmVQcm9tcHRUb0ZhbHNlKCk7XG5cbiAgICB0aGlzLl90cmFja01ldGFNZXRyaWNzRXZlbnQoe1xuICAgICAgZXZlbnQ6ICczQm94IFJlc3RvcmVkIERhdGEnLFxuICAgICAgY2F0ZWdvcnk6ICczQm94JyxcbiAgICB9KTtcbiAgfVxuXG4gIHR1cm5UaHJlZUJveFN5bmNpbmdPbigpIHtcbiAgICB0aGlzLl90cmFja01ldGFNZXRyaWNzRXZlbnQoe1xuICAgICAgZXZlbnQ6ICczQm94IFN5bmMgVHVybmVkIE9uJyxcbiAgICAgIGNhdGVnb3J5OiAnM0JveCcsXG4gICAgfSk7XG5cbiAgICB0aGlzLl9yZWdpc3RlclVwZGF0ZXMoKTtcbiAgfVxuXG4gIHR1cm5UaHJlZUJveFN5bmNpbmdPZmYoKSB7XG4gICAgdGhpcy5fdHJhY2tNZXRhTWV0cmljc0V2ZW50KHtcbiAgICAgIGV2ZW50OiAnM0JveCBTeW5jIFR1cm5lZCBPZmYnLFxuICAgICAgY2F0ZWdvcnk6ICczQm94JyxcbiAgICB9KTtcblxuICAgIHRoaXMuYm94LmxvZ291dCgpO1xuICB9XG5cbiAgc2V0U2hvd1Jlc3RvcmVQcm9tcHRUb0ZhbHNlKCkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBzaG93UmVzdG9yZVByb21wdDogZmFsc2UgfSk7XG4gIH1cblxuICBzZXRUaHJlZUJveFN5bmNpbmdQZXJtaXNzaW9uKG5ld1RocmVlYm94U3luY2luZ1N0YXRlKSB7XG4gICAgaWYgKHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS50aHJlZUJveERpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgdGhyZWVCb3hTeW5jaW5nQWxsb3dlZDogbmV3VGhyZWVib3hTeW5jaW5nU3RhdGUsXG4gICAgfSk7XG5cbiAgICBpZiAobmV3VGhyZWVib3hTeW5jaW5nU3RhdGUgJiYgdGhpcy5ib3gpIHtcbiAgICAgIHRoaXMudHVyblRocmVlQm94U3luY2luZ09uKCk7XG4gICAgfVxuXG4gICAgaWYgKCFuZXdUaHJlZWJveFN5bmNpbmdTdGF0ZSAmJiB0aGlzLmJveCkge1xuICAgICAgdGhpcy50dXJuVGhyZWVCb3hTeW5jaW5nT2ZmKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0VGhyZWVCb3hTeW5jaW5nU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS50aHJlZUJveFN5bmNpbmdBbGxvd2VkO1xuICB9XG5cbiAgX3JlZ2lzdGVyVXBkYXRlcygpIHtcbiAgICBpZiAoIXRoaXMucmVnaXN0ZXJpbmdVcGRhdGVzKSB7XG4gICAgICBjb25zdCB1cGRhdGVQcmVmZXJlbmNlcyA9IHRoaXMuX3VwZGF0ZTNCb3guYmluZCh0aGlzKTtcbiAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZSh1cGRhdGVQcmVmZXJlbmNlcyk7XG4gICAgICBjb25zdCB1cGRhdGVBZGRyZXNzQm9vayA9IHRoaXMuX3VwZGF0ZTNCb3guYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYWRkcmVzc0Jvb2tDb250cm9sbGVyLnN1YnNjcmliZSh1cGRhdGVBZGRyZXNzQm9vayk7XG4gICAgICB0aGlzLnJlZ2lzdGVyaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgfVxuICB9XG59XG4iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9jcmVhdGVNZXRob2RNaWRkbGV3YXJlJztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuZnVuY3Rpb24gc2FmZUFwcGx5KGhhbmRsZXIsIGNvbnRleHQsIGFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgICBSZWZsZWN0LmFwcGx5KGhhbmRsZXIsIGNvbnRleHQsIGFyZ3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIFRocm93IGVycm9yIGFmdGVyIHRpbWVvdXQgc28gYXMgbm90IHRvIGludGVycnVwdCB0aGUgc3RhY2tcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyKSB7XG4gICAgY29uc3QgbiA9IGFyci5sZW5ndGg7XG4gICAgY29uc3QgY29weSA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkgKz0gMSkge1xuICAgICAgICBjb3B5W2ldID0gYXJyW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cbmNsYXNzIFNhZmVFdmVudEVtaXR0ZXIgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGVtaXQodHlwZSwgLi4uYXJncykge1xuICAgICAgICBsZXQgZG9FcnJvciA9IHR5cGUgPT09ICdlcnJvcic7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgICAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkb0Vycm9yID0gZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZG9FcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgICAgICAgaWYgKGRvRXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBlcjtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBbZXJdID0gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAgICAgICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgVW5oYW5kbGVkIGVycm9yLiR7ZXIgPyBgICgke2VyLm1lc3NhZ2V9KWAgOiAnJ31gKTtcbiAgICAgICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgICAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZUFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHNhZmVBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNhZmVFdmVudEVtaXR0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtXG4gICwgaW5oZXJpdHMgID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG4gICwgeHRlbmQgICAgID0gcmVxdWlyZSgneHRlbmQnKVxuXG5mdW5jdGlvbiBEZXN0cm95YWJsZVRyYW5zZm9ybShvcHRzKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKERlc3Ryb3lhYmxlVHJhbnNmb3JtLCBUcmFuc2Zvcm0pXG5cbkRlc3Ryb3lhYmxlVHJhbnNmb3JtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG4gIFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBpZiAoZXJyKVxuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgfSlcbn1cblxuLy8gYSBub29wIF90cmFuc2Zvcm0gZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AgKGNodW5rLCBlbmMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKG51bGwsIGNodW5rKVxufVxuXG5cbi8vIGNyZWF0ZSBhIG5ldyBleHBvcnQgZnVuY3Rpb24sIHVzZWQgYnkgYm90aCB0aGUgbWFpbiBleHBvcnQgYW5kXG4vLyB0aGUgLmN0b3IgZXhwb3J0LCBjb250YWlucyBjb21tb24gbG9naWMgZm9yIGRlYWxpbmcgd2l0aCBhcmd1bWVudHNcbmZ1bmN0aW9uIHRocm91Z2gyIChjb25zdHJ1Y3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZsdXNoICAgICA9IHRyYW5zZm9ybVxuICAgICAgdHJhbnNmb3JtID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyAgID0ge31cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSAhPSAnZnVuY3Rpb24nKVxuICAgICAgdHJhbnNmb3JtID0gbm9vcFxuXG4gICAgaWYgKHR5cGVvZiBmbHVzaCAhPSAnZnVuY3Rpb24nKVxuICAgICAgZmx1c2ggPSBudWxsXG5cbiAgICByZXR1cm4gY29uc3RydWN0KG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpXG4gIH1cbn1cblxuXG4vLyBtYWluIGV4cG9ydCwganVzdCBtYWtlIG1lIGEgdHJhbnNmb3JtIHN0cmVhbSFcbm1vZHVsZS5leHBvcnRzID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgdmFyIHQyID0gbmV3IERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdGlvbnMpXG5cbiAgdDIuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICB0Mi5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiB0MlxufSlcblxuXG4vLyBtYWtlIG1lIGEgcmV1c2FibGUgcHJvdG90eXBlIHRoYXQgSSBjYW4gYG5ld2AsIG9yIGltcGxpY2l0bHkgYG5ld2Bcbi8vIHdpdGggYSBjb25zdHJ1Y3RvciBjYWxsXG5tb2R1bGUuZXhwb3J0cy5jdG9yID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgZnVuY3Rpb24gVGhyb3VnaDIgKG92ZXJyaWRlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRocm91Z2gyKSlcbiAgICAgIHJldHVybiBuZXcgVGhyb3VnaDIob3ZlcnJpZGUpXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB4dGVuZChvcHRpb25zLCBvdmVycmlkZSlcblxuICAgIERlc3Ryb3lhYmxlVHJhbnNmb3JtLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW5oZXJpdHMoVGhyb3VnaDIsIERlc3Ryb3lhYmxlVHJhbnNmb3JtKVxuXG4gIFRocm91Z2gyLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIFRocm91Z2gyLnByb3RvdHlwZS5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiBUaHJvdWdoMlxufSlcblxuXG5tb2R1bGUuZXhwb3J0cy5vYmogPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0oeHRlbmQoeyBvYmplY3RNb2RlOiB0cnVlLCBoaWdoV2F0ZXJNYXJrOiAxNiB9LCBvcHRpb25zKSlcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZhaWxUeHNUaGF0KHZlcnNpb24sIHJlYXNvbiwgY29uZGl0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlLCBjb25kaXRpb24sIHJlYXNvbik7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlLCBjb25kaXRpb24sIHJlYXNvbikge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XG4gIGlmIChUcmFuc2FjdGlvbkNvbnRyb2xsZXIgJiYgVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBUcmFuc2FjdGlvbkNvbnRyb2xsZXI7XG5cbiAgICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcCgodHhNZXRhKSA9PiB7XG4gICAgICBpZiAoIWNvbmRpdGlvbih0eE1ldGEpKSB7XG4gICAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgICB9XG5cbiAgICAgIHR4TWV0YS5zdGF0dXMgPSBUUkFOU0FDVElPTl9TVEFUVVNFUy5GQUlMRUQ7XG4gICAgICB0eE1ldGEuZXJyID0ge1xuICAgICAgICBtZXNzYWdlOiByZWFzb24sXG4gICAgICAgIG5vdGU6IGBUeCBhdXRvbWF0aWNhbGx5IGZhaWxlZCBieSBtaWdyYXRpb24gYmVjYXVzZSAke3JlYXNvbn1gLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCJpbXBvcnQganNvbkRpZmZlciBmcm9tICdmYXN0LWpzb24tcGF0Y2gnO1xuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuLyoqXG4gIGNvbnZlcnRzIG5vbi1pbml0aWFsIGhpc3RvcnkgZW50cmllcyBpbnRvIGRpZmZzXG4gIEBwYXJhbSB7QXJyYXl9IGxvbmdIaXN0b3J5XG4gIEByZXR1cm5zIHtBcnJheX1cbiovXG5leHBvcnQgZnVuY3Rpb24gbWlncmF0ZUZyb21TbmFwc2hvdHNUb0RpZmZzKGxvbmdIaXN0b3J5KSB7XG4gIHJldHVybiAoXG4gICAgbG9uZ0hpc3RvcnlcbiAgICAgIC8vIGNvbnZlcnQgbm9uLWluaXRpYWwgaGlzdG9yeSBlbnRyaWVzIGludG8gZGlmZnNcbiAgICAgIC5tYXAoKGVudHJ5LCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlSGlzdG9yeUVudHJ5KGxvbmdIaXN0b3J5W2luZGV4IC0gMV0sIGVudHJ5KTtcbiAgICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICBHZW5lcmF0ZXMgYW4gYXJyYXkgb2YgaGlzdG9yeSBvYmplY3RzIHNlbnNlIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgVGhlIG9iamVjdCBoYXMgdGhlIGtleXNcbiAgICBvcCAodGhlIG9wZXJhdGlvbiBwZXJmb3JtZWQpLFxuICAgIHBhdGggKHRoZSBrZXkgYW5kIGlmIGEgbmVzdGVkIG9iamVjdCB0aGVuIGVhY2gga2V5IHdpbGwgYmUgc2VwYXJhdGVkIHdpdGggYSBgL2ApXG4gICAgdmFsdWVcbiAgd2l0aCB0aGUgZmlyc3QgZW50cnkgaGF2aW5nIHRoZSBub3RlIGFuZCBhIHRpbWVzdGFtcCB3aGVuIHRoZSBjaGFuZ2UgdG9vayBwbGFjZVxuICBAcGFyYW0ge09iamVjdH0gcHJldmlvdXNTdGF0ZSAtIHRoZSBwcmV2aW91cyBzdGF0ZSBvZiB0aGUgb2JqZWN0XG4gIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZSAtIHRoZSB1cGRhdGUgb2JqZWN0XG4gIEBwYXJhbSB7c3RyaW5nfSBbbm90ZV0gLSBhIG9wdGlvbmFsIG5vdGUgZm9yIHRoZSBzdGF0ZSBjaGFuZ2VcbiAgQHJldHVybnMge0FycmF5fVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUhpc3RvcnlFbnRyeShwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwgbm90ZSkge1xuICBjb25zdCBlbnRyeSA9IGpzb25EaWZmZXIuY29tcGFyZShwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSk7XG4gIC8vIEFkZCBhIG5vdGUgdG8gdGhlIGZpcnN0IG9wLCBzaW5jZSBpdCBicmVha3MgaWYgd2UgYXBwZW5kIGl0IHRvIHRoZSBlbnRyeVxuICBpZiAoZW50cnlbMF0pIHtcbiAgICBpZiAobm90ZSkge1xuICAgICAgZW50cnlbMF0ubm90ZSA9IG5vdGU7XG4gICAgfVxuICAgIGVudHJ5WzBdLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gIH1cbiAgcmV0dXJuIGVudHJ5O1xufVxuXG4vKipcbiAgUmVjb3ZlcnMgcHJldmlvdXMgdHhNZXRhIHN0YXRlIG9ialxuICBAcmV0dXJucyB7T2JqZWN0fVxuKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYXlIaXN0b3J5KF9zaG9ydEhpc3RvcnkpIHtcbiAgY29uc3Qgc2hvcnRIaXN0b3J5ID0gY2xvbmVEZWVwKF9zaG9ydEhpc3RvcnkpO1xuICByZXR1cm4gc2hvcnRIaXN0b3J5LnJlZHVjZShcbiAgICAodmFsLCBlbnRyeSkgPT4ganNvbkRpZmZlci5hcHBseVBhdGNoKHZhbCwgZW50cnkpLm5ld0RvY3VtZW50LFxuICApO1xufVxuXG4vKipcbiAqIFNuYXBzaG90IHtAY29kZSB0eE1ldGF9XG4gKiBAcGFyYW0ge09iamVjdH0gdHhNZXRhIC0gdGhlIHR4IG1ldGFkYXRhIG9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gYSBkZWVwIGNsb25lIHdpdGhvdXQgaGlzdG9yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gc25hcHNob3RGcm9tVHhNZXRhKHR4TWV0YSkge1xuICBjb25zdCBzaGFsbG93ID0geyAuLi50eE1ldGEgfTtcbiAgZGVsZXRlIHNoYWxsb3cuaGlzdG9yeTtcbiAgcmV0dXJuIGNsb25lRGVlcChzaGFsbG93KTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9EYXRhVmlldyAoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEludDhBcnJheSB8fCBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBkYXRhIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aClcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGRhdGEpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgZGF0YWAgdG8gYmUgYW4gQXJyYXlCdWZmZXIsIEJ1ZmZlciwgSW50OEFycmF5LCBVaW50OEFycmF5IG9yIFVpbnQ4Q2xhbXBlZEFycmF5Jylcbn1cbiIsImNvbnN0IGFiaSA9IFtcbiAge1xuICAgIGNvbnN0YW50OiB0cnVlLFxuICAgIGlucHV0czogW3sgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfV0sXG4gICAgbmFtZTogJ3Jlc29sdmVyJyxcbiAgICBvdXRwdXRzOiBbeyBuYW1lOiAnJywgdHlwZTogJ2FkZHJlc3MnIH1dLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gIH0sXG4gIHtcbiAgICBjb25zdGFudDogdHJ1ZSxcbiAgICBpbnB1dHM6IFt7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH1dLFxuICAgIG5hbWU6ICdvd25lcicsXG4gICAgb3V0cHV0czogW3sgbmFtZTogJycsIHR5cGU6ICdhZGRyZXNzJyB9XSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICB9LFxuICB7XG4gICAgY29uc3RhbnQ6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBuYW1lOiAnbGFiZWwnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgbmFtZTogJ293bmVyJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnc2V0U3Vibm9kZU93bmVyJyxcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICB9LFxuICB7XG4gICAgY29uc3RhbnQ6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBuYW1lOiAndHRsJywgdHlwZTogJ3VpbnQ2NCcgfSxcbiAgICBdLFxuICAgIG5hbWU6ICdzZXRUVEwnLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gIH0sXG4gIHtcbiAgICBjb25zdGFudDogdHJ1ZSxcbiAgICBpbnB1dHM6IFt7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH1dLFxuICAgIG5hbWU6ICd0dGwnLFxuICAgIG91dHB1dHM6IFt7IG5hbWU6ICcnLCB0eXBlOiAndWludDY0JyB9XSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICB9LFxuICB7XG4gICAgY29uc3RhbnQ6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBuYW1lOiAncmVzb2x2ZXInLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICBdLFxuICAgIG5hbWU6ICdzZXRSZXNvbHZlcicsXG4gICAgb3V0cHV0czogW10sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgbmFtZTogJ293bmVyJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnc2V0T3duZXInLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBpbmRleGVkOiB0cnVlLCBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBpbmRleGVkOiBmYWxzZSwgbmFtZTogJ293bmVyJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnVHJhbnNmZXInLFxuICAgIHR5cGU6ICdldmVudCcsXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBpbmRleGVkOiB0cnVlLCBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBpbmRleGVkOiB0cnVlLCBuYW1lOiAnbGFiZWwnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgaW5kZXhlZDogZmFsc2UsIG5hbWU6ICdvd25lcicsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ05ld093bmVyJyxcbiAgICB0eXBlOiAnZXZlbnQnLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgaW5kZXhlZDogZmFsc2UsIG5hbWU6ICdyZXNvbHZlcicsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ05ld1Jlc29sdmVyJyxcbiAgICB0eXBlOiAnZXZlbnQnLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgaW5kZXhlZDogZmFsc2UsIG5hbWU6ICd0dGwnLCB0eXBlOiAndWludDY0JyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ05ld1RUTCcsXG4gICAgdHlwZTogJ2V2ZW50JyxcbiAgfSxcbl07XG5leHBvcnQgZGVmYXVsdCBhYmk7XG4iLCJjb25zdCBhYmkgPSBbXG4gIHtcbiAgICBjb25zdGFudDogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICB7IG5hbWU6ICdoYXNoJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnc2V0Q29udGVudCcsXG4gICAgb3V0cHV0czogW10sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiB0cnVlLFxuICAgIGlucHV0czogW3sgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfV0sXG4gICAgbmFtZTogJ2NvbnRlbnQnLFxuICAgIG91dHB1dHM6IFt7IG5hbWU6ICcnLCB0eXBlOiAnYnl0ZXMzMicgfV0sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiB0cnVlLFxuICAgIGlucHV0czogW3sgbmFtZTogJ2ludGVyZmFjZUlEJywgdHlwZTogJ2J5dGVzNCcgfV0sXG4gICAgbmFtZTogJ3N1cHBvcnRzSW50ZXJmYWNlJyxcbiAgICBvdXRwdXRzOiBbeyBuYW1lOiAnJywgdHlwZTogJ2Jvb2wnIH1dLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ3B1cmUnLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gIH0sXG4gIHtcbiAgICBjb25zdGFudDogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICB7IG5hbWU6ICdrZXknLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgeyBuYW1lOiAndmFsdWUnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ3NldFRleHQnLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gIH0sXG4gIHtcbiAgICBjb25zdGFudDogdHJ1ZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgbmFtZTogJ2NvbnRlbnRUeXBlcycsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ0FCSScsXG4gICAgb3V0cHV0czogW1xuICAgICAgeyBuYW1lOiAnY29udGVudFR5cGUnLCB0eXBlOiAndWludDI1NicgfSxcbiAgICAgIHsgbmFtZTogJ2RhdGEnLCB0eXBlOiAnYnl0ZXMnIH0sXG4gICAgXSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICB9LFxuICB7XG4gICAgY29uc3RhbnQ6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBuYW1lOiAneCcsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBuYW1lOiAneScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ3NldFB1YmtleScsXG4gICAgb3V0cHV0czogW10sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgbmFtZTogJ2hhc2gnLCB0eXBlOiAnYnl0ZXMnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnc2V0Q29udGVudGhhc2gnLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gIH0sXG4gIHtcbiAgICBjb25zdGFudDogdHJ1ZSxcbiAgICBpbnB1dHM6IFt7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH1dLFxuICAgIG5hbWU6ICdhZGRyJyxcbiAgICBvdXRwdXRzOiBbeyBuYW1lOiAnJywgdHlwZTogJ2FkZHJlc3MnIH1dLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gIH0sXG4gIHtcbiAgICBjb25zdGFudDogdHJ1ZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgbmFtZTogJ2tleScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAndGV4dCcsXG4gICAgb3V0cHV0czogW3sgbmFtZTogJycsIHR5cGU6ICdzdHJpbmcnIH1dLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gIH0sXG4gIHtcbiAgICBjb25zdGFudDogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICB7IG5hbWU6ICdjb250ZW50VHlwZScsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgICAgeyBuYW1lOiAnZGF0YScsIHR5cGU6ICdieXRlcycgfSxcbiAgICBdLFxuICAgIG5hbWU6ICdzZXRBQkknLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gIH0sXG4gIHtcbiAgICBjb25zdGFudDogdHJ1ZSxcbiAgICBpbnB1dHM6IFt7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH1dLFxuICAgIG5hbWU6ICduYW1lJyxcbiAgICBvdXRwdXRzOiBbeyBuYW1lOiAnJywgdHlwZTogJ3N0cmluZycgfV0sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgbmFtZTogJ25hbWUnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ3NldE5hbWUnLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gIH0sXG4gIHtcbiAgICBjb25zdGFudDogdHJ1ZSxcbiAgICBpbnB1dHM6IFt7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH1dLFxuICAgIG5hbWU6ICdjb250ZW50aGFzaCcsXG4gICAgb3V0cHV0czogW3sgbmFtZTogJycsIHR5cGU6ICdieXRlcycgfV0sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiB0cnVlLFxuICAgIGlucHV0czogW3sgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfV0sXG4gICAgbmFtZTogJ3B1YmtleScsXG4gICAgb3V0cHV0czogW1xuICAgICAgeyBuYW1lOiAneCcsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBuYW1lOiAneScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgIF0sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgbmFtZTogJ2FkZHInLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICBdLFxuICAgIG5hbWU6ICdzZXRBZGRyJyxcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbeyBuYW1lOiAnZW5zQWRkcicsIHR5cGU6ICdhZGRyZXNzJyB9XSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICB0eXBlOiAnY29uc3RydWN0b3InLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgaW5kZXhlZDogZmFsc2UsIG5hbWU6ICdhJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnQWRkckNoYW5nZWQnLFxuICAgIHR5cGU6ICdldmVudCcsXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBpbmRleGVkOiB0cnVlLCBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBpbmRleGVkOiBmYWxzZSwgbmFtZTogJ25hbWUnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ05hbWVDaGFuZ2VkJyxcbiAgICB0eXBlOiAnZXZlbnQnLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgbmFtZTogJ2NvbnRlbnRUeXBlJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnQUJJQ2hhbmdlZCcsXG4gICAgdHlwZTogJ2V2ZW50JyxcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7IGluZGV4ZWQ6IHRydWUsIG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBuYW1lOiAneCcsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBpbmRleGVkOiBmYWxzZSwgbmFtZTogJ3knLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICBdLFxuICAgIG5hbWU6ICdQdWJrZXlDaGFuZ2VkJyxcbiAgICB0eXBlOiAnZXZlbnQnLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgaW5kZXhlZDogZmFsc2UsIG5hbWU6ICdpbmRleGVkS2V5JywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgIHsgaW5kZXhlZDogZmFsc2UsIG5hbWU6ICdrZXknLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ1RleHRDaGFuZ2VkJyxcbiAgICB0eXBlOiAnZXZlbnQnLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgaW5kZXhlZDogZmFsc2UsIG5hbWU6ICdoYXNoJywgdHlwZTogJ2J5dGVzJyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ0NvbnRlbnRoYXNoQ2hhbmdlZCcsXG4gICAgdHlwZTogJ2V2ZW50JyxcbiAgfSxcbl07XG5leHBvcnQgZGVmYXVsdCBhYmk7XG4iLCIvKlxuXHRJU0MgTGljZW5zZVxuXG5cdENvcHlyaWdodCAoYykgMjAxOSwgUGllcnJlLUxvdWlzIERlc3BhaWduZVxuXG5cdFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuXHRwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG5cdGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcblx0V0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuXHRNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuXHRBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG5cdFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuXHRBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuXHRPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKi9cblxuY29uc3QgbXVsdGlDID0gcmVxdWlyZSgnbXVsdGljb2RlYycpO1xuY29uc3QgbXVsdGlIID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKTtcblxuY29uc3QgeyBoZXhTdHJpbmdUb0J1ZmZlciwgcHJvZmlsZXMgfSA9IHJlcXVpcmUoJy4vcHJvZmlsZXMnKTtcbmNvbnN0IHsgY2lkRm9yV2ViLCBjaWRWMFRvVjFCYXNlMzIgfSA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHQvL2V4cG9ydCBzb21lIGhlbHBlcnMgZnVuY3Rpb25zXG5cdGhlbHBlcnM6IHtcblx0XHRjaWRGb3JXZWIsXG5cdFx0Y2lkVjBUb1YxQmFzZTMyLFxuXHR9LFxuXG5cdC8qKlxuXHQqIERlY29kZSBhIENvbnRlbnQgSGFzaC5cblx0KiBAcGFyYW0ge3N0cmluZ30gaGFzaCBhbiBoZXggc3RyaW5nIGNvbnRhaW5pbmcgYSBjb250ZW50IGhhc2hcblx0KiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBkZWNvZGVkIGNvbnRlbnRcblx0Ki9cblx0ZGVjb2RlOiBmdW5jdGlvbiAoY29udGVudEhhc2gpIHtcblx0XHRjb25zdCBidWZmZXIgPSBoZXhTdHJpbmdUb0J1ZmZlcihjb250ZW50SGFzaCk7XG5cdFx0Y29uc3QgY29kZWMgPSBtdWx0aUMuZ2V0Q29kZWMoYnVmZmVyKTtcblx0XHRjb25zdCB2YWx1ZSA9IG11bHRpQy5ybVByZWZpeChidWZmZXIpO1xuXHRcdGxldCBwcm9maWxlID0gcHJvZmlsZXNbY29kZWNdO1xuXHRcdGlmICghcHJvZmlsZSkgcHJvZmlsZSA9IHByb2ZpbGVzWydkZWZhdWx0J107XG5cdFx0cmV0dXJuIHByb2ZpbGUuZGVjb2RlKHZhbHVlKTtcblx0fSxcblxuXHQvKipcblx0KiBFbmNvZGUgYW4gSVBGUyBhZGRyZXNzIGludG8gYSBjb250ZW50IGhhc2hcblx0KiBAcGFyYW0ge3N0cmluZ30gaXBmc0hhc2ggc3RyaW5nIGNvbnRhaW5pbmcgYW4gSVBGUyBhZGRyZXNzXG5cdCogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVzdWx0aW5nIGNvbnRlbnQgaGFzaFxuXHQqL1xuXHRmcm9tSXBmczogZnVuY3Rpb24gKGlwZnNIYXNoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZW5jb2RlKCdpcGZzLW5zJywgaXBmc0hhc2gpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEVuY29kZSBhIFNreWxpbmsgaW50byBhIGNvbnRlbnQgaGFzaFxuXHQqIEBwYXJhbSB7c3RyaW5nfSBza3lsaW5rIHN0cmluZyBjb250YWluaW5nIGEgU2t5bGlua1xuXHQqIEByZXR1cm4ge3N0cmluZ30gdGhlIHJlc3VsdGluZyBjb250ZW50IGhhc2hcblx0Ki9cblx0ZnJvbVNreWxpbms6IGZ1bmN0aW9uIChza3lsaW5rKSB7XG5cdFx0cmV0dXJuIHRoaXMuZW5jb2RlKCdza3luZXQtbnMnLCBza3lsaW5rKTtcblx0fSxcblxuXHQvKipcblx0KiBFbmNvZGUgYSBTd2FybSBhZGRyZXNzIGludG8gYSBjb250ZW50IGhhc2hcblx0KiBAcGFyYW0ge3N0cmluZ30gc3dhcm1IYXNoIHN0cmluZyBjb250YWluaW5nIGEgU3dhcm0gYWRkcmVzc1xuXHQqIEByZXR1cm4ge3N0cmluZ30gdGhlIHJlc3VsdGluZyBjb250ZW50IGhhc2hcblx0Ki9cblx0ZnJvbVN3YXJtOiBmdW5jdGlvbiAoc3dhcm1IYXNoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZW5jb2RlKCdzd2FybS1ucycsIHN3YXJtSGFzaCk7XG5cdH0sXG5cblx0LyoqXG5cdCogR2VuZXJhbCBwdXJwb3NlIGVuY29kaW5nIGZ1bmN0aW9uXG4gICogQHBhcmFtIHtzdHJpbmd9IGNvZGVjIFxuICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBcbiAgKi9cblx0ZW5jb2RlOiBmdW5jdGlvbiAoY29kZWMsIHZhbHVlKSB7XG5cdFx0bGV0IHByb2ZpbGUgPSBwcm9maWxlc1tjb2RlY107XG5cdFx0aWYgKCFwcm9maWxlKSBwcm9maWxlID0gcHJvZmlsZXNbJ2RlZmF1bHQnXTtcblx0XHRjb25zdCBlbmNvZGVkVmFsdWUgPSBwcm9maWxlLmVuY29kZSh2YWx1ZSk7XG5cdFx0cmV0dXJuIG11bHRpSC50b0hleFN0cmluZyhtdWx0aUMuYWRkUHJlZml4KGNvZGVjLCBlbmNvZGVkVmFsdWUpKVxuXHR9LFxuXG5cdC8qKlxuXHQqIEV4dHJhY3QgdGhlIGNvZGVjIG9mIGEgY29udGVudCBoYXNoXG5cdCogQHBhcmFtIHtzdHJpbmd9IGhhc2ggaGV4IHN0cmluZyBjb250YWluaW5nIGEgY29udGVudCBoYXNoXG5cdCogQHJldHVybiB7c3RyaW5nfSB0aGUgZXh0cmFjdGVkIGNvZGVjXG5cdCovXG5cdGdldENvZGVjOiBmdW5jdGlvbiAoaGFzaCkge1xuXHRcdGxldCBidWZmZXIgPSBoZXhTdHJpbmdUb0J1ZmZlcihoYXNoKTtcblx0XHRyZXR1cm4gbXVsdGlDLmdldENvZGVjKGJ1ZmZlcik7XG5cdH0sXG59XG4iLCJleHBvcnQgY29uc3QgU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTUyA9XG4gICcweGIxZjhlNTVjN2Y2NGQyMDNjMTQwMGI5ZDg1NTVkMDUwZjk0YWRmMzknO1xuZXhwb3J0IGNvbnN0IFNJTkdMRV9DQUxMX0JBTEFOQ0VTX0FERFJFU1NfUklOS0VCWSA9XG4gICcweDlmNTEwYjE5ZjFhZDY2ZjBkY2Y2ZTQ1NTU5ZmFiMGQ2NzUyYzFkYjcnO1xuZXhwb3J0IGNvbnN0IFNJTkdMRV9DQUxMX0JBTEFOQ0VTX0FERFJFU1NfUk9QU1RFTiA9XG4gICcweGI4ZTY3MTczNGNlNWM4ZDdkZmJiZWE1NTc0ZmE0Y2YzOWY3YTU0YTQnO1xuZXhwb3J0IGNvbnN0IFNJTkdMRV9DQUxMX0JBTEFOQ0VTX0FERFJFU1NfS09WQU4gPVxuICAnMHhiMWQzZmJiMmY4M2FlY2QxOTZmNDc0YzE2Y2E1ZDljZmZhMGQwZmZjJztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVBc3luY01pZGRsZXdhcmUgPSB2b2lkIDA7XG4vKipcbiAqIEpzb25ScGNFbmdpbmUgb25seSBhY2NlcHRzIGNhbGxiYWNrLWJhc2VkIG1pZGRsZXdhcmUgZGlyZWN0bHkuXG4gKiBjcmVhdGVBc3luY01pZGRsZXdhcmUgZXhpc3RzIHRvIGVuYWJsZSBjb25zdW1lcnMgdG8gcGFzcyBpbiBhc3luYyBtaWRkbGV3YXJlXG4gKiBmdW5jdGlvbnMuXG4gKlxuICogQXN5bmMgbWlkZGxld2FyZSBoYXZlIG5vIFwiZW5kXCIgZnVuY3Rpb24uIEluc3RlYWQsIHRoZXkgXCJlbmRcIiBpZiB0aGV5IHJldHVyblxuICogd2l0aG91dCBjYWxsaW5nIFwibmV4dFwiLiBSYXRoZXIgdGhhbiBwYXNzaW5nIGluIGV4cGxpY2l0IHJldHVybiBoYW5kbGVycyxcbiAqIGFzeW5jIG1pZGRsZXdhcmUgY2FuIHNpbXBseSBhd2FpdCBcIm5leHRcIiwgYW5kIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiB0aGVcbiAqIHJlc3BvbnNlIG9iamVjdCB3aGVuIGV4ZWN1dGlvbiByZXN1bWVzLlxuICpcbiAqIFRvIGFjY29tcGxpc2ggdGhpcywgY3JlYXRlQXN5bmNNaWRkbGV3YXJlIHBhc3NlcyB0aGUgYXN5bmMgbWlkZGxld2FyZSBhXG4gKiB3cmFwcGVkIFwibmV4dFwiIGZ1bmN0aW9uLiBUaGF0IGZ1bmN0aW9uIGNhbGxzIHRoZSBpbnRlcm5hbCBKc29uUnBjRW5naW5lXG4gKiBcIm5leHRcIiBmdW5jdGlvbiB3aXRoIGEgcmV0dXJuIGhhbmRsZXIgdGhhdCByZXNvbHZlcyBhIHByb21pc2Ugd2hlbiBjYWxsZWQuXG4gKlxuICogVGhlIHJldHVybiBoYW5kbGVyIHdpbGwgYWx3YXlzIGJlIGNhbGxlZC4gSXRzIHJlc29sdXRpb24gb2YgdGhlIHByb21pc2VcbiAqIGVuYWJsZXMgdGhlIGNvbnRyb2wgZmxvdyBkZXNjcmliZWQgYWJvdmUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luY01pZGRsZXdhcmUpIHtcbiAgICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcbiAgICAgICAgLy8gbmV4dFByb21pc2UgaXMgdGhlIGtleSB0byB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgICAgLy8gaXQgaXMgcmVzb2x2ZWQgYnkgdGhlIHJldHVybiBoYW5kbGVyIHBhc3NlZCB0byB0aGVcbiAgICAgICAgLy8gXCJuZXh0XCIgZnVuY3Rpb25cbiAgICAgICAgbGV0IHJlc29sdmVOZXh0UHJvbWlzZTtcbiAgICAgICAgY29uc3QgbmV4dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZU5leHRQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXR1cm5IYW5kbGVyQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBsZXQgbmV4dFdhc0NhbGxlZCA9IGZhbHNlO1xuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBjb25zdW1lcidzIGFzeW5jIG1pZGRsZXdhcmUuXG4gICAgICAgIGNvbnN0IGFzeW5jTmV4dCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIG5leHRXYXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gV2UgcGFzcyBhIHJldHVybiBoYW5kbGVyIHRvIG5leHQoKS4gV2hlbiBpdCBpcyBjYWxsZWQgYnkgdGhlIGVuZ2luZSxcbiAgICAgICAgICAgIC8vIHRoZSBjb25zdW1lcidzIGFzeW5jIG1pZGRsZXdhcmUgd2lsbCByZXN1bWUgZXhlY3V0aW5nLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvY2FsbGJhY2stcmV0dXJuXG4gICAgICAgICAgICBuZXh0KChydW5SZXR1cm5IYW5kbGVyc0NhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjYWxsYmFjayBjb21lcyBmcm9tIEpzb25ScGNFbmdpbmUuX3J1blJldHVybkhhbmRsZXJzXG4gICAgICAgICAgICAgICAgcmV0dXJuSGFuZGxlckNhbGxiYWNrID0gcnVuUmV0dXJuSGFuZGxlcnNDYWxsYmFjaztcbiAgICAgICAgICAgICAgICByZXNvbHZlTmV4dFByb21pc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgbmV4dFByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBhc3luY01pZGRsZXdhcmUocmVxLCByZXMsIGFzeW5jTmV4dCk7XG4gICAgICAgICAgICBpZiAobmV4dFdhc0NhbGxlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5leHRQcm9taXNlOyAvLyB3ZSBtdXN0IHdhaXQgdW50aWwgdGhlIHJldHVybiBoYW5kbGVyIGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgIHJldHVybkhhbmRsZXJDYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5IYW5kbGVyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm5IYW5kbGVyQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSA9IGNyZWF0ZUFzeW5jTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkzSmxZWFJsUVhONWJtTk5hV1JrYkdWM1lYSmxMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZjM0pqTDJOeVpXRjBaVUZ6ZVc1alRXbGtaR3hsZDJGeVpTNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGblFrRTdPenM3T3pzN096czdPenM3T3pzN1IwRm5Ra2M3UVVGRFNDeFRRVUZuUWl4eFFrRkJjVUlzUTBGRGJrTXNaVUZCTmtNN1NVRkZOME1zVDBGQlR5eExRVUZMTEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hKUVVGSkxFVkJRVVVzUjBGQlJ5eEZRVUZGTEVWQlFVVTdVVUZEYmtNc0swTkJRU3RETzFGQlF5OURMSEZFUVVGeFJEdFJRVU55UkN4clFrRkJhMEk3VVVGRGJFSXNTVUZCU1N4clFrRkJPRUlzUTBGQlF6dFJRVU51UXl4TlFVRk5MRmRCUVZjc1IwRkJSeXhKUVVGSkxFOUJRVThzUTBGQlF5eERRVUZETEU5QlFVOHNSVUZCUlN4RlFVRkZPMWxCUXpGRExHdENRVUZyUWl4SFFVRkhMRTlCUVU4c1EwRkJRenRSUVVNdlFpeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVklMRWxCUVVrc2NVSkJRWEZDTEVkQlFWa3NTVUZCU1N4RFFVRkRPMUZCUXpGRExFbEJRVWtzWVVGQllTeEhRVUZITEV0QlFVc3NRMEZCUXp0UlFVVXhRaXd3UkVGQk1FUTdVVUZETVVRc1RVRkJUU3hUUVVGVExFZEJRVWNzUzBGQlN5eEpRVUZKTEVWQlFVVTdXVUZETTBJc1lVRkJZU3hIUVVGSExFbEJRVWtzUTBGQlF6dFpRVVZ5UWl4MVJVRkJkVVU3V1VGRGRrVXNlVVJCUVhsRU8xbEJRM3BFTEdkRVFVRm5SRHRaUVVOb1JDeEpRVUZKTEVOQlFVTXNRMEZCUXl4NVFrRkJlVUlzUlVGQlJTeEZRVUZGTzJkQ1FVTnFReXcwUkVGQk5FUTdaMEpCUXpWRUxIRkNRVUZ4UWl4SFFVRkhMSGxDUVVGNVFpeERRVUZETzJkQ1FVTnNSQ3hyUWtGQmEwSXNSVUZCUlN4RFFVRkRPMWxCUTNaQ0xFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEwZ3NUVUZCVFN4WFFVRlhMRU5CUVVNN1VVRkRjRUlzUTBGQlF5eERRVUZETzFGQlJVWXNTVUZCU1R0WlFVTkdMRTFCUVUwc1pVRkJaU3hEUVVGRExFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1dVRkZNME1zU1VGQlNTeGhRVUZoTEVWQlFVVTdaMEpCUTJwQ0xFMUJRVTBzVjBGQlZ5eERRVUZETEVOQlFVTXNhMFJCUVd0RU8yZENRVU53UlN4eFFrRkJLME1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0aFFVTjRSRHRwUWtGQlRUdG5Ra0ZEVEN4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03WVVGRFdEdFRRVU5HTzFGQlFVTXNUMEZCVHl4TFFVRkxMRVZCUVVVN1dVRkRaQ3hKUVVGSkxIRkNRVUZ4UWl4RlFVRkZPMmRDUVVONFFpeHhRa0ZCSzBNc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dGhRVU42UkR0cFFrRkJUVHRuUWtGRFRDeEhRVUZITEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1lVRkRXanRUUVVOR08wbEJRMGdzUTBGQlF5eERRVUZETzBGQlEwb3NRMEZCUXp0QlFTOURSQ3h6UkVFclEwTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZShoYW5kbGVycykge1xuICAgIHJldHVybiAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbcmVxLm1ldGhvZF07XG4gICAgICAgIC8vIGlmIG5vIGhhbmRsZXIsIHJldHVyblxuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGhhbmRsZXIgaXMgZm4sIGNhbGwgYXMgbWlkZGxld2FyZVxuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKHJlcSwgcmVzLCBuZXh0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGhhbmRsZXIgaXMgc29tZSBvdGhlciB2YWx1ZSwgdXNlIGFzIHJlc3VsdFxuICAgICAgICByZXMucmVzdWx0ID0gaGFuZGxlcjtcbiAgICAgICAgcmV0dXJuIGVuZCgpO1xuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSA9IGNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkzSmxZWFJsVTJOaFptWnZiR1JOYVdSa2JHVjNZWEpsTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2YzNKakwyTnlaV0YwWlZOallXWm1iMnhrVFdsa1pHeGxkMkZ5WlM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdRVUZKUVN4VFFVRm5RaXgzUWtGQmQwSXNRMEZCUXl4UlFVVjRRenRKUVVORExFOUJRVThzUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWxCUVVrc1JVRkJSU3hIUVVGSExFVkJRVVVzUlVGQlJUdFJRVU0zUWl4TlFVRk5MRTlCUVU4c1IwRkJSeXhSUVVGUkxFTkJRVU1zUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUTNKRExIZENRVUYzUWp0UlFVTjRRaXhKUVVGSkxFOUJRVThzUzBGQlN5eFRRVUZUTEVWQlFVVTdXVUZEZWtJc1QwRkJUeXhKUVVGSkxFVkJRVVVzUTBGQlF6dFRRVU5tTzFGQlEwUXNkVU5CUVhWRE8xRkJRM1pETEVsQlFVa3NUMEZCVHl4UFFVRlBMRXRCUVVzc1ZVRkJWU3hGUVVGRk8xbEJRMnBETEU5QlFVOHNUMEZCVHl4RFFVRkRMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzU1VGQlNTeEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRPMU5CUTNKRE8xRkJRMFFzWjBSQlFXZEVPMUZCUXk5RExFZEJRU3RDTEVOQlFVTXNUVUZCVFN4SFFVRkhMRTlCUVU4c1EwRkJRenRSUVVOc1JDeFBRVUZQTEVkQlFVY3NSVUZCUlN4RFFVRkRPMGxCUTJZc1EwRkJReXhEUVVGRE8wRkJRMG9zUTBGQlF6dEJRV3BDUkN3MFJFRnBRa01pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRVbmlxdWVJZCA9IHZvaWQgMDtcbi8vIHVpbnQzMiAodHdvJ3MgY29tcGxlbWVudCkgbWF4XG4vLyBtb3JlIGNvbnNlcnZhdGl2ZSB0aGFuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG5jb25zdCBNQVggPSA0Mjk0OTY3Mjk1O1xubGV0IGlkQ291bnRlciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1BWCk7XG5mdW5jdGlvbiBnZXRVbmlxdWVJZCgpIHtcbiAgICBpZENvdW50ZXIgPSAoaWRDb3VudGVyICsgMSkgJSBNQVg7XG4gICAgcmV0dXJuIGlkQ291bnRlcjtcbn1cbmV4cG9ydHMuZ2V0VW5pcXVlSWQgPSBnZXRVbmlxdWVJZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVoyVjBWVzVwY1hWbFNXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOXpjbU12WjJWMFZXNXBjWFZsU1dRdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdPMEZCUVVFc1owTkJRV2RETzBGQlEyaERMR2xFUVVGcFJEdEJRVU5xUkN4TlFVRk5MRWRCUVVjc1IwRkJSeXhWUVVGVkxFTkJRVU03UVVGRGRrSXNTVUZCU1N4VFFVRlRMRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RlFVRkZMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03UVVGRmFFUXNVMEZCWjBJc1YwRkJWenRKUVVONlFpeFRRVUZUTEVkQlFVY3NRMEZCUXl4VFFVRlRMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eERRVUZETzBsQlEyeERMRTlCUVU4c1UwRkJVeXhEUVVGRE8wRkJRMjVDTEVOQlFVTTdRVUZJUkN4clEwRkhReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QgZ2V0VW5pcXVlSWRfMSA9IHJlcXVpcmUoXCIuL2dldFVuaXF1ZUlkXCIpO1xuZnVuY3Rpb24gY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUoKSB7XG4gICAgcmV0dXJuIChyZXEsIHJlcywgbmV4dCwgX2VuZCkgPT4ge1xuICAgICAgICBjb25zdCBvcmlnaW5hbElkID0gcmVxLmlkO1xuICAgICAgICBjb25zdCBuZXdJZCA9IGdldFVuaXF1ZUlkXzEuZ2V0VW5pcXVlSWQoKTtcbiAgICAgICAgcmVxLmlkID0gbmV3SWQ7XG4gICAgICAgIHJlcy5pZCA9IG5ld0lkO1xuICAgICAgICBuZXh0KChkb25lKSA9PiB7XG4gICAgICAgICAgICByZXEuaWQgPSBvcmlnaW5hbElkO1xuICAgICAgICAgICAgcmVzLmlkID0gb3JpZ2luYWxJZDtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUgPSBjcmVhdGVJZFJlbWFwTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXUlNaVzFoY0UxcFpHUnNaWGRoY21VdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk5emNtTXZhV1JTWlcxaGNFMXBaR1JzWlhkaGNtVXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3TzBGQlFVRXNLME5CUVRSRE8wRkJSelZETEZOQlFXZENMSFZDUVVGMVFqdEpRVU55UXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhGUVVGRkxFZEJRVWNzUlVGQlJTeEpRVUZKTEVWQlFVVXNTVUZCU1N4RlFVRkZMRVZCUVVVN1VVRkRPVUlzVFVGQlRTeFZRVUZWTEVkQlFVY3NSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJRenRSUVVNeFFpeE5RVUZOTEV0QlFVc3NSMEZCUnl4NVFrRkJWeXhGUVVGRkxFTkJRVU03VVVGRE5VSXNSMEZCUnl4RFFVRkRMRVZCUVVVc1IwRkJSeXhMUVVGTExFTkJRVU03VVVGRFppeEhRVUZITEVOQlFVTXNSVUZCUlN4SFFVRkhMRXRCUVVzc1EwRkJRenRSUVVObUxFbEJRVWtzUTBGQlF5eERRVUZETEVsQlFVa3NSVUZCUlN4RlFVRkZPMWxCUTFvc1IwRkJSeXhEUVVGRExFVkJRVVVzUjBGQlJ5eFZRVUZWTEVOQlFVTTdXVUZEY0VJc1IwRkJSeXhEUVVGRExFVkJRVVVzUjBGQlJ5eFZRVUZWTEVOQlFVTTdXVUZEY0VJc1NVRkJTU3hGUVVGRkxFTkJRVU03VVVGRFZDeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTk1MRU5CUVVNc1EwRkJRenRCUVVOS0xFTkJRVU03UVVGYVJDd3dSRUZaUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tZXJnZU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBKc29uUnBjRW5naW5lXzEgPSByZXF1aXJlKFwiLi9Kc29uUnBjRW5naW5lXCIpO1xuZnVuY3Rpb24gbWVyZ2VNaWRkbGV3YXJlKG1pZGRsZXdhcmVTdGFjaykge1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBKc29uUnBjRW5naW5lXzEuSnNvblJwY0VuZ2luZSgpO1xuICAgIG1pZGRsZXdhcmVTdGFjay5mb3JFYWNoKChtaWRkbGV3YXJlKSA9PiBlbmdpbmUucHVzaChtaWRkbGV3YXJlKSk7XG4gICAgcmV0dXJuIGVuZ2luZS5hc01pZGRsZXdhcmUoKTtcbn1cbmV4cG9ydHMubWVyZ2VNaWRkbGV3YXJlID0gbWVyZ2VNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYldWeVoyVk5hV1JrYkdWM1lYSmxMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZjM0pqTDIxbGNtZGxUV2xrWkd4bGQyRnlaUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN1FVRkJRU3h0UkVGQmJVVTdRVUZGYmtVc1UwRkJaMElzWlVGQlpTeERRVUZETEdWQlFYTkVPMGxCUTNCR0xFMUJRVTBzVFVGQlRTeEhRVUZITEVsQlFVa3NOa0pCUVdFc1JVRkJSU3hEUVVGRE8wbEJRMjVETEdWQlFXVXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhWUVVGVkxFVkJRVVVzUlVGQlJTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU5xUlN4UFFVRlBMRTFCUVUwc1EwRkJReXhaUVVGWkxFVkJRVVVzUTBGQlF6dEJRVU12UWl4RFFVRkRPMEZCU2tRc01FTkJTVU1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Kc29uUnBjRW5naW5lID0gdm9pZCAwO1xuY29uc3Qgc2FmZV9ldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9zYWZlLWV2ZW50LWVtaXR0ZXJcIikpO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbi8qKlxuICogQSBKU09OLVJQQyByZXF1ZXN0IGFuZCByZXNwb25zZSBwcm9jZXNzb3IuXG4gKiBHaXZlIGl0IGEgc3RhY2sgb2YgbWlkZGxld2FyZSwgcGFzcyBpdCByZXF1ZXN0cywgYW5kIGdldCBiYWNrIHJlc3BvbnNlcy5cbiAqL1xuY2xhc3MgSnNvblJwY0VuZ2luZSBleHRlbmRzIHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9taWRkbGV3YXJlID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG1pZGRsZXdhcmUgZnVuY3Rpb24gdG8gdGhlIGVuZ2luZSdzIG1pZGRsZXdhcmUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWlkZGxld2FyZSAtIFRoZSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIGFkZC5cbiAgICAgKi9cbiAgICBwdXNoKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgdGhpcy5fbWlkZGxld2FyZS5wdXNoKG1pZGRsZXdhcmUpO1xuICAgIH1cbiAgICBoYW5kbGUocmVxLCBjYikge1xuICAgICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY2FsbGJhY2tcIiBtdXN0IGJlIGEgZnVuY3Rpb24gaWYgcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxKSkge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUJhdGNoKHJlcSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUJhdGNoKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlKHJlcSwgY2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlSGFuZGxlKHJlcSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBlbmdpbmUgYXMgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHB1c2hlZCB0byBvdGhlclxuICAgICAqIGVuZ2luZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGlzIGVuZ2luZSBhcyBhIG1pZGRsZXdhcmUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXNNaWRkbGV3YXJlKCkge1xuICAgICAgICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW21pZGRsZXdhcmVFcnJvciwgaXNDb21wbGV0ZSwgcmV0dXJuSGFuZGxlcnMsXSA9IGF3YWl0IEpzb25ScGNFbmdpbmUuX3J1bkFsbE1pZGRsZXdhcmUocmVxLCByZXMsIHRoaXMuX21pZGRsZXdhcmUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IEpzb25ScGNFbmdpbmUuX3J1blJldHVybkhhbmRsZXJzKHJldHVybkhhbmRsZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuZChtaWRkbGV3YXJlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChhc3luYyAoaGFuZGxlckNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBKc29uUnBjRW5naW5lLl9ydW5SZXR1cm5IYW5kbGVycyhyZXR1cm5IYW5kbGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlckNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlckNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZUJhdGNoKHJlcXMsIGNiKSB7XG4gICAgICAgIC8vIFRoZSBvcmRlciBoZXJlIGlzIGltcG9ydGFudFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gMi4gV2FpdCBmb3IgYWxsIHJlcXVlc3RzIHRvIGZpbmlzaCwgb3IgdGhyb3cgb24gc29tZSBraW5kIG9mIGZhdGFsXG4gICAgICAgICAgICAvLyBlcnJvclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAvLyAxLiBCZWdpbiBleGVjdXRpbmcgZWFjaCByZXF1ZXN0IGluIHRoZSBvcmRlciByZWNlaXZlZFxuICAgICAgICAgICAgcmVxcy5tYXAodGhpcy5fcHJvbWlzZUhhbmRsZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgICAgICAvLyAzLiBSZXR1cm4gYmF0Y2ggcmVzcG9uc2VcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihudWxsLCByZXNwb25zZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHByb21pc2Utd3JhcHBlZCBfaGFuZGxlLlxuICAgICAqL1xuICAgIF9wcm9taXNlSGFuZGxlKHJlcSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZShyZXEsIChfZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhIHJlc3BvbnNlLCBhbmQgaXQgd2lsbCBhbHdheXMgaGF2ZSBhbnkgZXJyb3JcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGlzIGNhdWdodCBhbmQgcHJvcGFnYXRlZC5cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgcmVxdWVzdCBvYmplY3QgaXMgdmFsaWQsIHByb2Nlc3NlcyBpdCwgYW5kIHBhc3NlcyBhbnlcbiAgICAgKiBlcnJvciBhbmQgdGhlIHJlc3BvbnNlIG9iamVjdCB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBEb2VzIG5vdCByZWplY3QuXG4gICAgICovXG4gICAgYXN5bmMgX2hhbmRsZShjYWxsZXJSZXEsIGNiKSB7XG4gICAgICAgIGlmICghY2FsbGVyUmVxIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGNhbGxlclJlcSkgfHxcbiAgICAgICAgICAgIHR5cGVvZiBjYWxsZXJSZXEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBldGhfcnBjX2Vycm9yc18xLkV0aGVyZXVtUnBjRXJyb3IoZXRoX3JwY19lcnJvcnNfMS5lcnJvckNvZGVzLnJwYy5pbnZhbGlkUmVxdWVzdCwgYFJlcXVlc3RzIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gUmVjZWl2ZWQ6ICR7dHlwZW9mIGNhbGxlclJlcX1gLCB7IHJlcXVlc3Q6IGNhbGxlclJlcSB9KTtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnJvciwgeyBpZDogdW5kZWZpbmVkLCBqc29ucnBjOiAnMi4wJywgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsZXJSZXEubWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgZXRoX3JwY19lcnJvcnNfMS5FdGhlcmV1bVJwY0Vycm9yKGV0aF9ycGNfZXJyb3JzXzEuZXJyb3JDb2Rlcy5ycGMuaW52YWxpZFJlcXVlc3QsIGBNdXN0IHNwZWNpZnkgYSBzdHJpbmcgbWV0aG9kLiBSZWNlaXZlZDogJHt0eXBlb2YgY2FsbGVyUmVxLm1ldGhvZH1gLCB7IHJlcXVlc3Q6IGNhbGxlclJlcSB9KTtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnJvciwgeyBpZDogY2FsbGVyUmVxLmlkLCBqc29ucnBjOiAnMi4wJywgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxID0gT2JqZWN0LmFzc2lnbih7fSwgY2FsbGVyUmVxKTtcbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgaWQ6IHJlcS5pZCxcbiAgICAgICAgICAgIGpzb25ycGM6IHJlcS5qc29ucnBjLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc1JlcXVlc3QocmVxLCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEEgcmVxdWVzdCBoYW5kbGVyIGVycm9yLCBhIHJlLXRocm93biBtaWRkbGV3YXJlIGVycm9yLCBvciBzb21ldGhpbmdcbiAgICAgICAgICAgIC8vIHVuZXhwZWN0ZWQuXG4gICAgICAgICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBubyByZXN1bHQgaXMgcHJlc2VudCBvbiBhbiBlcnJvcmVkIHJlc3BvbnNlXG4gICAgICAgICAgICBkZWxldGUgcmVzLnJlc3VsdDtcbiAgICAgICAgICAgIGlmICghcmVzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVzLmVycm9yID0gZXRoX3JwY19lcnJvcnNfMS5zZXJpYWxpemVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNiKGVycm9yLCByZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIGdpdmVuIHJlcXVlc3QgYW5kIHJlc3BvbnNlLCBydW5zIGFsbCBtaWRkbGV3YXJlIGFuZCB0aGVpciByZXR1cm5cbiAgICAgKiBoYW5kbGVycywgaWYgYW55LCBhbmQgZW5zdXJlcyB0aGF0IGludGVybmFsIHJlcXVlc3QgcHJvY2Vzc2luZyBzZW1hbnRpY3NcbiAgICAgKiBhcmUgc2F0aXNmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIF9wcm9jZXNzUmVxdWVzdChyZXEsIHJlcykge1xuICAgICAgICBjb25zdCBbZXJyb3IsIGlzQ29tcGxldGUsIHJldHVybkhhbmRsZXJzLF0gPSBhd2FpdCBKc29uUnBjRW5naW5lLl9ydW5BbGxNaWRkbGV3YXJlKHJlcSwgcmVzLCB0aGlzLl9taWRkbGV3YXJlKTtcbiAgICAgICAgLy8gVGhyb3cgaWYgXCJlbmRcIiB3YXMgbm90IGNhbGxlZCwgb3IgaWYgdGhlIHJlc3BvbnNlIGhhcyBuZWl0aGVyIGEgcmVzdWx0XG4gICAgICAgIC8vIG5vciBhbiBlcnJvci5cbiAgICAgICAgSnNvblJwY0VuZ2luZS5fY2hlY2tGb3JDb21wbGV0aW9uKHJlcSwgcmVzLCBpc0NvbXBsZXRlKTtcbiAgICAgICAgLy8gVGhlIHJldHVybiBoYW5kbGVycyBzaG91bGQgcnVuIGV2ZW4gaWYgYW4gZXJyb3Igd2FzIGVuY291bnRlcmVkIGR1cmluZ1xuICAgICAgICAvLyBtaWRkbGV3YXJlIHByb2Nlc3NpbmcuXG4gICAgICAgIGF3YWl0IEpzb25ScGNFbmdpbmUuX3J1blJldHVybkhhbmRsZXJzKHJldHVybkhhbmRsZXJzKTtcbiAgICAgICAgLy8gTm93IHdlIHJlLXRocm93IHRoZSBtaWRkbGV3YXJlIHByb2Nlc3NpbmcgZXJyb3IsIGlmIGFueSwgdG8gY2F0Y2ggaXRcbiAgICAgICAgLy8gZnVydGhlciB1cCB0aGUgY2FsbCBjaGFpbi5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxseSBleGVjdXRlcyB0aGUgZ2l2ZW4gc3RhY2sgb2YgbWlkZGxld2FyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFueSBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgbWlkZGxld2FyZSBleGVjdXRpb24sXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcmVxdWVzdCB3YXMgY29tcGxldGVkLCBhbmQgYW4gYXJyYXkgb2ZcbiAgICAgKiBtaWRkbGV3YXJlLWRlZmluZWQgcmV0dXJuIGhhbmRsZXJzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBfcnVuQWxsTWlkZGxld2FyZShyZXEsIHJlcywgbWlkZGxld2FyZVN0YWNrKSB7XG4gICAgICAgIGNvbnN0IHJldHVybkhhbmRsZXJzID0gW107XG4gICAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICAgIGxldCBpc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIC8vIEdvIGRvd24gc3RhY2sgb2YgbWlkZGxld2FyZSwgY2FsbCBhbmQgY29sbGVjdCBvcHRpb25hbCByZXR1cm5IYW5kbGVyc1xuICAgICAgICBmb3IgKGNvbnN0IG1pZGRsZXdhcmUgb2YgbWlkZGxld2FyZVN0YWNrKSB7XG4gICAgICAgICAgICBbZXJyb3IsIGlzQ29tcGxldGVdID0gYXdhaXQgSnNvblJwY0VuZ2luZS5fcnVuTWlkZGxld2FyZShyZXEsIHJlcywgbWlkZGxld2FyZSwgcmV0dXJuSGFuZGxlcnMpO1xuICAgICAgICAgICAgaWYgKGlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2Vycm9yLCBpc0NvbXBsZXRlLCByZXR1cm5IYW5kbGVycy5yZXZlcnNlKCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIGFuIGluZGl2aWR1YWwgbWlkZGxld2FyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFueSBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgbWlkZGxld2FyZSBleGVjdGlvbixcbiAgICAgKiBhbmQgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcmVxdWVzdCBzaG91bGQgZW5kLlxuICAgICAqL1xuICAgIHN0YXRpYyBfcnVuTWlkZGxld2FyZShyZXEsIHJlcywgbWlkZGxld2FyZSwgcmV0dXJuSGFuZGxlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnIgfHwgcmVzLmVycm9yO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXMuZXJyb3IgPSBldGhfcnBjX2Vycm9yc18xLnNlcmlhbGl6ZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgcmVxdWVzdCBzaG91bGQgZW5kXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShbZXJyb3IsIHRydWVdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gKHJldHVybkhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZChyZXMuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVybkhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0dXJuSGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZChuZXcgZXRoX3JwY19lcnJvcnNfMS5FdGhlcmV1bVJwY0Vycm9yKGV0aF9ycGNfZXJyb3JzXzEuZXJyb3JDb2Rlcy5ycGMuaW50ZXJuYWwsIGBKc29uUnBjRW5naW5lOiBcIm5leHRcIiByZXR1cm4gaGFuZGxlcnMgbXVzdCBiZSBmdW5jdGlvbnMuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgUmVjZWl2ZWQgXCIke3R5cGVvZiByZXR1cm5IYW5kbGVyfVwiIGZvciByZXF1ZXN0OlxcbiR7anNvbmlmeShyZXEpfWAsIHsgcmVxdWVzdDogcmVxIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkhhbmRsZXJzLnB1c2gocmV0dXJuSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIHJlcXVlc3Qgc2hvdWxkIG5vdCBlbmRcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbbnVsbCwgZmFsc2VdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBtaWRkbGV3YXJlKHJlcSwgcmVzLCBuZXh0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZW5kKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGx5IGV4ZWN1dGVzIGFycmF5IG9mIHJldHVybiBoYW5kbGVycy4gVGhlIHJlcXVlc3QgYW5kIHJlc3BvbnNlIGFyZVxuICAgICAqIGFzc3VtZWQgdG8gYmUgaW4gdGhlaXIgc2NvcGUuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIF9ydW5SZXR1cm5IYW5kbGVycyhoYW5kbGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKChlcnIpID0+IChlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSByZXNwb25zZSBoYXMgbmVpdGhlciBhIHJlc3VsdCBub3IgYW4gZXJyb3IsIG9yIGlmXG4gICAgICogdGhlIFwiaXNDb21wbGV0ZVwiIGZsYWcgaXMgZmFsc3kuXG4gICAgICovXG4gICAgc3RhdGljIF9jaGVja0ZvckNvbXBsZXRpb24ocmVxLCByZXMsIGlzQ29tcGxldGUpIHtcbiAgICAgICAgaWYgKCEoJ3Jlc3VsdCcgaW4gcmVzKSAmJiAhKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV0aF9ycGNfZXJyb3JzXzEuRXRoZXJldW1ScGNFcnJvcihldGhfcnBjX2Vycm9yc18xLmVycm9yQ29kZXMucnBjLmludGVybmFsLCBgSnNvblJwY0VuZ2luZTogUmVzcG9uc2UgaGFzIG5vIGVycm9yIG9yIHJlc3VsdCBmb3IgcmVxdWVzdDpcXG4ke2pzb25pZnkocmVxKX1gLCB7IHJlcXVlc3Q6IHJlcSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBldGhfcnBjX2Vycm9yc18xLkV0aGVyZXVtUnBjRXJyb3IoZXRoX3JwY19lcnJvcnNfMS5lcnJvckNvZGVzLnJwYy5pbnRlcm5hbCwgYEpzb25ScGNFbmdpbmU6IE5vdGhpbmcgZW5kZWQgcmVxdWVzdDpcXG4ke2pzb25pZnkocmVxKX1gLCB7IHJlcXVlc3Q6IHJlcSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSnNvblJwY0VuZ2luZSA9IEpzb25ScGNFbmdpbmU7XG5mdW5jdGlvbiBqc29uaWZ5KHJlcXVlc3QpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVxdWVzdCwgbnVsbCwgMik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lTbk52YmxKd1kwVnVaMmx1WlM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1TDNOeVl5OUtjMjl1VW5CalJXNW5hVzVsTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN096czdPenRCUVVGQkxITkdRVUUwUkR0QlFVTTFSQ3h0UkVGQk9FVTdRVUYxUmpsRk96czdSMEZIUnp0QlFVTklMRTFCUVdFc1lVRkJZeXhUUVVGUkxEUkNRVUZuUWp0SlFVZHFSRHRSUVVORkxFdEJRVXNzUlVGQlJTeERRVUZETzFGQlExSXNTVUZCU1N4RFFVRkRMRmRCUVZjc1IwRkJSeXhGUVVGRkxFTkJRVU03U1VGRGVFSXNRMEZCUXp0SlFVVkVPenM3TzA5QlNVYzdTVUZEU0N4SlFVRkpMRU5CUVU4c1ZVRkJiVU03VVVGRE5VTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhKUVVGSkxFTkJRVU1zVlVGQmFVUXNRMEZCUXl4RFFVRkRPMGxCUXpORkxFTkJRVU03U1VFeVEwUXNUVUZCVFN4RFFVRkRMRWRCUVZrc1JVRkJSU3hGUVVGUk8xRkJRek5DTEVsQlFVa3NSVUZCUlN4SlFVRkpMRTlCUVU4c1JVRkJSU3hMUVVGTExGVkJRVlVzUlVGQlJUdFpRVU5zUXl4TlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExEUkRRVUUwUXl4RFFVRkRMRU5CUVVNN1UwRkRMMFE3VVVGRlJDeEpRVUZKTEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVU3V1VGRGRFSXNTVUZCU1N4RlFVRkZMRVZCUVVVN1owSkJRMDRzVDBGQlR5eEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRWRCUVVjc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dGhRVU51UXp0WlFVTkVMRTlCUVU4c1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0VFFVTXZRanRSUVVWRUxFbEJRVWtzUlVGQlJTeEZRVUZGTzFsQlEwNHNUMEZCVHl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFZEJRVGhDTEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1UwRkRla1E3VVVGRFJDeFBRVUZQTEVsQlFVa3NRMEZCUXl4alFVRmpMRU5CUVVNc1IwRkJPRUlzUTBGQlF5eERRVUZETzBsQlF6ZEVMRU5CUVVNN1NVRkZSRHM3T3pzN1QwRkxSenRKUVVOSUxGbEJRVms3VVVGRFZpeFBRVUZQTEV0QlFVc3NSVUZCUlN4SFFVRkhMRVZCUVVVc1IwRkJSeXhGUVVGRkxFbEJRVWtzUlVGQlJTeEhRVUZITEVWQlFVVXNSVUZCUlR0WlFVTnVReXhKUVVGSk8yZENRVU5HTEUxQlFVMHNRMEZEU2l4bFFVRmxMRVZCUTJZc1ZVRkJWU3hGUVVOV0xHTkJRV01zUlVGRFppeEhRVUZITEUxQlFVMHNZVUZCWVN4RFFVRkRMR2xDUVVGcFFpeERRVUZETEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUVVVc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eERRVUZETzJkQ1FVVjBSU3hKUVVGSkxGVkJRVlVzUlVGQlJUdHZRa0ZEWkN4TlFVRk5MR0ZCUVdFc1EwRkJReXhyUWtGQmEwSXNRMEZCUXl4alFVRmpMRU5CUVVNc1EwRkJRenR2UWtGRGRrUXNUMEZCVHl4SFFVRkhMRU5CUVVNc1pVRkJOa01zUTBGQlF5eERRVUZETzJsQ1FVTXpSRHRuUWtGRlJDeFBRVUZQTEVsQlFVa3NRMEZCUXl4TFFVRkxMRVZCUVVVc1pVRkJaU3hGUVVGRkxFVkJRVVU3YjBKQlEzQkRMRWxCUVVrN2QwSkJRMFlzVFVGQlRTeGhRVUZoTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zWTBGQll5eERRVUZETEVOQlFVTTdjVUpCUTNoRU8yOUNRVUZETEU5QlFVOHNTMEZCU3l4RlFVRkZPM2RDUVVOa0xFOUJRVThzWlVGQlpTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPM0ZDUVVNdlFqdHZRa0ZEUkN4UFFVRlBMR1ZCUVdVc1JVRkJSU3hEUVVGRE8yZENRVU16UWl4RFFVRkRMRU5CUVVNc1EwRkJRenRoUVVOS08xbEJRVU1zVDBGQlR5eExRVUZMTEVWQlFVVTdaMEpCUTJRc1QwRkJUeXhIUVVGSExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdZVUZEYmtJN1VVRkRTQ3hEUVVGRExFTkJRVU03U1VGRFNpeERRVUZETzBsQmFVSlBMRXRCUVVzc1EwRkJReXhaUVVGWkxFTkJRM2hDTEVsQlFTdENMRVZCUXk5Q0xFVkJRWEZGTzFGQlJYSkZMRGhDUVVFNFFqdFJRVU01UWl4SlFVRkpPMWxCUTBZc2NVVkJRWEZGTzFsQlEzSkZMRkZCUVZFN1dVRkRVaXhOUVVGTkxGTkJRVk1zUjBGQlJ5eE5RVUZOTEU5QlFVOHNRMEZCUXl4SFFVRkhPMWxCUTJwRExIZEVRVUYzUkR0WlFVTjRSQ3hKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4alFVRmpMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlEzcERMRU5CUVVNN1dVRkZSaXd5UWtGQk1rSTdXVUZETTBJc1NVRkJTU3hGUVVGRkxFVkJRVVU3WjBKQlEwNHNUMEZCVHl4RlFVRkZMRU5CUVVNc1NVRkJTU3hGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzJGQlF6VkNPMWxCUTBRc1QwRkJUeXhUUVVGVExFTkJRVU03VTBGRGJFSTdVVUZCUXl4UFFVRlBMRXRCUVVzc1JVRkJSVHRaUVVOa0xFbEJRVWtzUlVGQlJTeEZRVUZGTzJkQ1FVTk9MRTlCUVU4c1JVRkJSU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzJGQlEyeENPMWxCUlVRc1RVRkJUU3hMUVVGTExFTkJRVU03VTBGRFlqdEpRVU5JTEVOQlFVTTdTVUZGUkRzN1QwRkZSenRKUVVOTExHTkJRV01zUTBGRGNFSXNSMEZCTkVJN1VVRkZOVUlzVDBGQlR5eEpRVUZKTEU5QlFVOHNRMEZCUXl4RFFVRkRMRTlCUVU4c1JVRkJSU3hGUVVGRk8xbEJRemRDTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhGUVVGRkxFTkJRVU1zU1VGQlNTeEZRVUZGTEVkQlFVY3NSVUZCUlN4RlFVRkZPMmRDUVVNNVFpeHhSVUZCY1VVN1owSkJRM0pGTEdsRFFVRnBRenRuUWtGRGFrTXNUMEZCVHl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRMllzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEVEN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOTUxFTkJRVU03U1VGRlJEczdPenM3VDBGTFJ6dEpRVU5MTEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUTI1Q0xGTkJRV3RETEVWQlEyeERMRVZCUVdkRk8xRkJSV2hGTEVsQlEwVXNRMEZCUXl4VFFVRlRPMWxCUTFZc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eFRRVUZUTEVOQlFVTTdXVUZEZUVJc1QwRkJUeXhUUVVGVExFdEJRVXNzVVVGQlVTeEZRVU0zUWp0WlFVTkJMRTFCUVUwc1MwRkJTeXhIUVVGSExFbEJRVWtzYVVOQlFXZENMRU5CUTJoRExESkNRVUZWTEVOQlFVTXNSMEZCUnl4RFFVRkRMR05CUVdNc1JVRkROMElzTmtOQlFUWkRMRTlCUVU4c1UwRkJVeXhGUVVGRkxFVkJReTlFTEVWQlFVVXNUMEZCVHl4RlFVRkZMRk5CUVZNc1JVRkJSU3hEUVVOMlFpeERRVUZETzFsQlEwWXNUMEZCVHl4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEZOQlFWTXNSVUZCUlN4UFFVRlBMRVZCUVVVc1MwRkJTeXhGUVVGRkxFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdVMEZETlVRN1VVRkZSQ3hKUVVGSkxFOUJRVThzVTBGQlV5eERRVUZETEUxQlFVMHNTMEZCU3l4UlFVRlJMRVZCUVVVN1dVRkRlRU1zVFVGQlRTeExRVUZMTEVkQlFVY3NTVUZCU1N4cFEwRkJaMElzUTBGRGFFTXNNa0pCUVZVc1EwRkJReXhIUVVGSExFTkJRVU1zWTBGQll5eEZRVU0zUWl3eVEwRkJNa01zVDBGQlR5eFRRVUZUTEVOQlFVTXNUVUZCVFN4RlFVRkZMRVZCUTNCRkxFVkJRVVVzVDBGQlR5eEZRVUZGTEZOQlFWTXNSVUZCUlN4RFFVTjJRaXhEUVVGRE8xbEJRMFlzVDBGQlR5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxGTkJRVk1zUTBGQlF5eEZRVUZGTEVWQlFVVXNUMEZCVHl4RlFVRkZMRXRCUVVzc1JVRkJSU3hMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETzFOQlF5OUVPMUZCUlVRc1RVRkJUU3hIUVVGSExIRkNRVUZwUXl4VFFVRlRMRU5CUVVVc1EwRkJRenRSUVVOMFJDeE5RVUZOTEVkQlFVY3NSMEZCYjBNN1dVRkRNME1zUlVGQlJTeEZRVUZGTEVkQlFVY3NRMEZCUXl4RlFVRkZPMWxCUTFZc1QwRkJUeXhGUVVGRkxFZEJRVWNzUTBGQlF5eFBRVUZQTzFOQlEzSkNMRU5CUVVNN1VVRkRSaXhKUVVGSkxFdEJRVXNzUjBGQkswSXNTVUZCU1N4RFFVRkRPMUZCUlRkRExFbEJRVWs3V1VGRFJpeE5RVUZOTEVsQlFVa3NRMEZCUXl4bFFVRmxMRU5CUVVNc1IwRkJSeXhGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETzFOQlEzUkRPMUZCUVVNc1QwRkJUeXhOUVVGTkxFVkJRVVU3V1VGRFppeHpSVUZCYzBVN1dVRkRkRVVzWTBGQll6dFpRVU5rTEV0QlFVc3NSMEZCUnl4TlFVRk5MRU5CUVVNN1UwRkRhRUk3VVVGRlJDeEpRVUZKTEV0QlFVc3NSVUZCUlR0WlFVTlVMSEZFUVVGeFJEdFpRVU55UkN4UFFVRlBMRWRCUVVjc1EwRkJReXhOUVVGTkxFTkJRVU03V1VGRGJFSXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhMUVVGTExFVkJRVVU3WjBKQlEyUXNSMEZCUnl4RFFVRkRMRXRCUVVzc1IwRkJSeXdyUWtGQll5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMkZCUTI1RE8xTkJRMFk3VVVGRlJDeFBRVUZQTEVWQlFVVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1IwRkJLMElzUTBGQlF5eERRVUZETzBsQlEzQkVMRU5CUVVNN1NVRkZSRHM3T3p0UFFVbEhPMGxCUTBzc1MwRkJTeXhEUVVGRExHVkJRV1VzUTBGRE0wSXNSMEZCTkVJc1JVRkROVUlzUjBGQmIwTTdVVUZGY0VNc1RVRkJUU3hEUVVOS0xFdEJRVXNzUlVGRFRDeFZRVUZWTEVWQlExWXNZMEZCWXl4RlFVTm1MRWRCUVVjc1RVRkJUU3hoUVVGaExFTkJRVU1zYVVKQlFXbENMRU5CUVVNc1IwRkJSeXhGUVVGRkxFZEJRVWNzUlVGQlJTeEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNN1VVRkZkRVVzZVVWQlFYbEZPMUZCUTNwRkxHZENRVUZuUWp0UlFVTm9RaXhoUVVGaExFTkJRVU1zYlVKQlFXMUNMRU5CUVVNc1IwRkJSeXhGUVVGRkxFZEJRVWNzUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXp0UlFVVjRSQ3g1UlVGQmVVVTdVVUZEZWtVc2VVSkJRWGxDTzFGQlEzcENMRTFCUVUwc1lVRkJZU3hEUVVGRExHdENRVUZyUWl4RFFVRkRMR05CUVdNc1EwRkJReXhEUVVGRE8xRkJSWFpFTEhWRlFVRjFSVHRSUVVOMlJTdzJRa0ZCTmtJN1VVRkROMElzU1VGQlNTeExRVUZMTEVWQlFVVTdXVUZEVkN4TlFVRk5MRXRCUVVzc1EwRkJRenRUUVVOaU8wbEJRMGdzUTBGQlF6dEpRVVZFT3pzN096czdUMEZOUnp0SlFVTkxMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zYVVKQlFXbENMRU5CUTNCRExFZEJRVFJDTEVWQlF6VkNMRWRCUVc5RExFVkJRM0JETEdWQlFYTkVPMUZCVVhSRUxFMUJRVTBzWTBGQll5eEhRVUZwUXl4RlFVRkZMRU5CUVVNN1VVRkRlRVFzU1VGQlNTeExRVUZMTEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUTJwQ0xFbEJRVWtzVlVGQlZTeEhRVUZITEV0QlFVc3NRMEZCUXp0UlFVVjJRaXgzUlVGQmQwVTdVVUZEZUVVc1MwRkJTeXhOUVVGTkxGVkJRVlVzU1VGQlNTeGxRVUZsTEVWQlFVVTdXVUZEZUVNc1EwRkJReXhMUVVGTExFVkJRVVVzVlVGQlZTeERRVUZETEVkQlFVY3NUVUZCVFN4aFFVRmhMRU5CUVVNc1kwRkJZeXhEUVVOMFJDeEhRVUZITEVWQlEwZ3NSMEZCUnl4RlFVTklMRlZCUVZVc1JVRkRWaXhqUVVGakxFTkJRMllzUTBGQlF6dFpRVU5HTEVsQlFVa3NWVUZCVlN4RlFVRkZPMmRDUVVOa0xFMUJRVTA3WVVGRFVEdFRRVU5HTzFGQlEwUXNUMEZCVHl4RFFVRkRMRXRCUVVzc1JVRkJSU3hWUVVGVkxFVkJRVVVzWTBGQll5eERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRMRU5CUVVNN1NVRkRka1FzUTBGQlF6dEpRVVZFT3pzN096dFBRVXRITzBsQlEwc3NUVUZCVFN4RFFVRkRMR05CUVdNc1EwRkRNMElzUjBGQk5FSXNSVUZETlVJc1IwRkJiME1zUlVGRGNFTXNWVUZCSzBNc1JVRkRMME1zWTBGQk5FTTdVVUZGTlVNc1QwRkJUeXhKUVVGSkxFOUJRVThzUTBGQlF5eERRVUZETEU5QlFVOHNSVUZCUlN4RlFVRkZPMWxCUXpkQ0xFMUJRVTBzUjBGQlJ5eEhRVUUyUWl4RFFVRkRMRWRCUVdFc1JVRkJSU3hGUVVGRk8yZENRVU4wUkN4TlFVRk5MRXRCUVVzc1IwRkJSeXhIUVVGSExFbEJRVWtzUjBGQlJ5eERRVUZETEV0QlFVc3NRMEZCUXp0blFrRkRMMElzU1VGQlNTeExRVUZMTEVWQlFVVTdiMEpCUTFRc1IwRkJSeXhEUVVGRExFdEJRVXNzUjBGQlJ5d3JRa0ZCWXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8ybENRVU51UXp0blFrRkRSQ3cyUTBGQk5rTTdaMEpCUXpkRExFOUJRVThzUTBGQlF5eERRVUZETEV0QlFVc3NSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM3BDTEVOQlFVTXNRMEZCUXp0WlFVVkdMRTFCUVUwc1NVRkJTU3hIUVVFNFFpeERRVU4wUXl4aFFVRXdReXhGUVVNeFF5eEZRVUZGTzJkQ1FVTkdMRWxCUVVrc1IwRkJSeXhEUVVGRExFdEJRVXNzUlVGQlJUdHZRa0ZEWWl4SFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzJsQ1FVTm9RanR4UWtGQlRUdHZRa0ZEVEN4SlFVRkpMR0ZCUVdFc1JVRkJSVHQzUWtGRGFrSXNTVUZCU1N4UFFVRlBMR0ZCUVdFc1MwRkJTeXhWUVVGVkxFVkJRVVU3TkVKQlEzWkRMRWRCUVVjc1EwRkRSQ3hKUVVGSkxHbERRVUZuUWl4RFFVTnNRaXd5UWtGQlZTeERRVUZETEVkQlFVY3NRMEZCUXl4UlFVRlJMRVZCUTNaQ0xESkVRVUV5UkR0blEwRkRla1FzWVVGQllTeFBRVUZQTEdGQlFXRXNiVUpCUVcxQ0xFOUJRVThzUTBGRGVrUXNSMEZCUnl4RFFVTktMRVZCUVVVc1JVRkRUQ3hGUVVGRkxFOUJRVThzUlVGQlJTeEhRVUZITEVWQlFVVXNRMEZEYWtJc1EwRkRSaXhEUVVGRE8zbENRVU5JTzNkQ1FVTkVMR05CUVdNc1EwRkJReXhKUVVGSkxFTkJRVU1zWVVGQllTeERRVUZETEVOQlFVTTdjVUpCUTNCRE8yOUNRVVZFTEd0RVFVRnJSRHR2UWtGRGJFUXNUMEZCVHl4RFFVRkRMRU5CUVVNc1NVRkJTU3hGUVVGRkxFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdhVUpCUTNoQ08xbEJRMGdzUTBGQlF5eERRVUZETzFsQlJVWXNTVUZCU1R0blFrRkRSaXhWUVVGVkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4SlFVRkpMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU03WVVGRGFrTTdXVUZCUXl4UFFVRlBMRXRCUVVzc1JVRkJSVHRuUWtGRFpDeEhRVUZITEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1lVRkRXanRSUVVOSUxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEwd3NRMEZCUXp0SlFVVkVPenM3VDBGSFJ6dEpRVU5MTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc2EwSkJRV3RDTEVOQlEzSkRMRkZCUVhORE8xRkJSWFJETEV0QlFVc3NUVUZCVFN4UFFVRlBMRWxCUVVrc1VVRkJVU3hGUVVGRk8xbEJRemxDTEUxQlFVMHNTVUZCU1N4UFFVRlBMRU5CUVVNc1EwRkJReXhQUVVGUExFVkJRVVVzVFVGQlRTeEZRVUZGTEVWQlFVVTdaMEpCUTNCRExFOUJRVThzUTBGQlF5eERRVUZETEVkQlFVY3NSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNCRUxFTkJRVU1zUTBGQlF5eERRVUZETzFOQlEwbzdTVUZEU0N4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwc3NUVUZCVFN4RFFVRkRMRzFDUVVGdFFpeERRVU5vUXl4SFFVRTBRaXhGUVVNMVFpeEhRVUZ2UXl4RlFVTndReXhWUVVGdFFqdFJRVVZ1UWl4SlFVRkpMRU5CUVVNc1EwRkJReXhSUVVGUkxFbEJRVWtzUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRTlCUVU4c1NVRkJTU3hIUVVGSExFTkJRVU1zUlVGQlJUdFpRVU16UXl4TlFVRk5MRWxCUVVrc2FVTkJRV2RDTEVOQlEzaENMREpDUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEZGQlFWRXNSVUZEZGtJc1owVkJRV2RGTEU5QlFVOHNRMEZEY2tVc1IwRkJSeXhEUVVOS0xFVkJRVVVzUlVGRFNDeEZRVUZGTEU5QlFVOHNSVUZCUlN4SFFVRkhMRVZCUVVVc1EwRkRha0lzUTBGQlF6dFRRVU5JTzFGQlEwUXNTVUZCU1N4RFFVRkRMRlZCUVZVc1JVRkJSVHRaUVVObUxFMUJRVTBzU1VGQlNTeHBRMEZCWjBJc1EwRkRlRUlzTWtKQlFWVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1VVRkJVU3hGUVVOMlFpd3dRMEZCTUVNc1QwRkJUeXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVWQlEzaEVMRVZCUVVVc1QwRkJUeXhGUVVGRkxFZEJRVWNzUlVGQlJTeERRVU5xUWl4RFFVRkRPMU5CUTBnN1NVRkRTQ3hEUVVGRE8wTkJRMFk3UVVGeVdVUXNjME5CY1ZsRE8wRkJSVVFzVTBGQlV5eFBRVUZQTEVOQlFVTXNUMEZCWjBNN1NVRkRMME1zVDBGQlR5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTlCUVU4c1JVRkJSU3hKUVVGSkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdRVUZETVVNc1EwRkJReUo5IiwiaW1wb3J0IEV0aEpzRW5zIGZyb20gJ2V0aGpzLWVucyc7XG5pbXBvcnQgZW5zTmV0d29ya01hcCBmcm9tICdldGhlcmV1bS1lbnMtbmV0d29yay1tYXAnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnMge1xuICBzdGF0aWMgZ2V0TmV0d29ya0Vuc1N1cHBvcnQobmV0d29yaykge1xuICAgIHJldHVybiBCb29sZWFuKGVuc05ldHdvcmtNYXBbbmV0d29ya10pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoeyBuZXR3b3JrLCBwcm92aWRlciB9ID0ge30pIHtcbiAgICB0aGlzLl9ldGhKc0VucyA9IG5ldyBFdGhKc0Vucyh7XG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJvdmlkZXIsXG4gICAgfSk7XG4gIH1cblxuICBsb29rdXAoZW5zTmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9ldGhKc0Vucy5sb29rdXAoZW5zTmFtZSk7XG4gIH1cblxuICByZXZlcnNlKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gdGhpcy5fZXRoSnNFbnMucmV2ZXJzZShhZGRyZXNzKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBSZXR1cm5zIGVycm9yIHdpdGhvdXQgc3RhY2sgdHJhY2UgZm9yIGJldHRlciBVSSBkaXNwbGF5XG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBlcnJvclxuICogQHJldHVybnMge0Vycm9yfSBFcnJvciB3aXRoIGNsZWFuIHN0YWNrIHRyYWNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjbGVhbkVycm9yU3RhY2soZXJyKSB7XG4gIGxldCB7IG5hbWUgfSA9IGVycjtcbiAgbmFtZSA9IG5hbWUgPT09IHVuZGVmaW5lZCA/ICdFcnJvcicgOiBTdHJpbmcobmFtZSk7XG5cbiAgbGV0IG1zZyA9IGVyci5tZXNzYWdlO1xuICBtc2cgPSBtc2cgPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKG1zZyk7XG5cbiAgaWYgKG5hbWUgPT09ICcnKSB7XG4gICAgZXJyLnN0YWNrID0gZXJyLm1lc3NhZ2U7XG4gIH0gZWxzZSBpZiAobXNnID09PSAnJykge1xuICAgIGVyci5zdGFjayA9IGVyci5uYW1lO1xuICB9IGVsc2UgaWYgKCFlcnIuc3RhY2spIHtcbiAgICBlcnIuc3RhY2sgPSBgJHtlcnIubmFtZX06ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgfVxuXG4gIHJldHVybiBlcnI7XG59XG4iLCJjb25zdCBFdGhRdWVyeSA9IHJlcXVpcmUoJ2V0aGpzLXF1ZXJ5JylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBNdXRleCA9IHJlcXVpcmUoJ2F3YWl0LXNlbWFwaG9yZScpLk11dGV4XG4vKipcbiAgQHBhcmFtIG9wdHMge09iamVjdH1cbiAgICBAcGFyYW0ge09iamVjdH0gb3B0cy5wcm92aWRlciBhIGV0aGVyZXVtIHByb3ZpZGVyXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5nZXRQZW5kaW5nVHJhbnNhY3Rpb25zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFycmF5IG9mIHR4TWV0YVxuICAgIHdob3NlZSBzdGF0dXMgaXMgYHN1Ym1pdHRlZGBcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRzLmdldENvbmZpcm1lZFRyYW5zYWN0aW9ucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheSBvZiB0eE1ldGFcbiAgICB3aG9zZSBzdGF0dXMgaXMgYGNvbmZpcm1lZGBcbiAgQGNsYXNzXG4qL1xuY2xhc3MgTm9uY2VUcmFja2VyIHtcblxuICBjb25zdHJ1Y3RvciAoeyBwcm92aWRlciwgYmxvY2tUcmFja2VyLCBnZXRQZW5kaW5nVHJhbnNhY3Rpb25zLCBnZXRDb25maXJtZWRUcmFuc2FjdGlvbnMgfSkge1xuICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlclxuICAgIHRoaXMuYmxvY2tUcmFja2VyID0gYmxvY2tUcmFja2VyXG4gICAgdGhpcy5ldGhRdWVyeSA9IG5ldyBFdGhRdWVyeShwcm92aWRlcilcbiAgICB0aGlzLmdldFBlbmRpbmdUcmFuc2FjdGlvbnMgPSBnZXRQZW5kaW5nVHJhbnNhY3Rpb25zXG4gICAgdGhpcy5nZXRDb25maXJtZWRUcmFuc2FjdGlvbnMgPSBnZXRDb25maXJtZWRUcmFuc2FjdGlvbnNcbiAgICB0aGlzLmxvY2tNYXAgPSB7fVxuICB9XG5cbiAgLyoqXG4gICAgQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gd2l0aCB0aGUga2V5IHJlbGVhc2VMb2NrICh0aGUgZ2xvYWJsIG11dGV4KVxuICAqL1xuICBhc3luYyBnZXRHbG9iYWxMb2NrICgpIHtcbiAgICBjb25zdCBnbG9iYWxNdXRleCA9IHRoaXMuX2xvb2t1cE11dGV4KCdnbG9iYWwnKVxuICAgIC8vIGF3YWl0IGdsb2JhbCBtdXRleCBmcmVlXG4gICAgY29uc3QgcmVsZWFzZUxvY2sgPSBhd2FpdCBnbG9iYWxNdXRleC5hY3F1aXJlKClcbiAgICByZXR1cm4geyByZWxlYXNlTG9jayB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYgTm9uY2VEZXRhaWxzXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoZXN0TG9jYWxseUNvbmZpcm1lZCAtIEEgaGV4IHN0cmluZyBvZiB0aGUgaGlnaGVzdCBub25jZSBvbiBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvbi5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5leHROZXR3b3JrTm9uY2UgLSBUaGUgbmV4dCBub25jZSBzdWdnZXN0ZWQgYnkgdGhlIGV0aF9nZXRUcmFuc2FjdGlvbkNvdW50IG1ldGhvZC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhpZ2hlc3RTdWdnZXN0ZWQgLSBUaGUgbWF4aW11bSBiZXR3ZWVuIHRoZSBvdGhlciB0d28sIHRoZSBudW1iZXIgcmV0dXJuZWQuXG4gICAqL1xuXG4gIC8qKlxuICB0aGlzIHdpbGwgcmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBgbmV4dE5vbmNlYCBgbm9uY2VEZXRhaWxzYCwgYW5kIHRoZSByZWxlYXNlTG9ja1xuICBOb3RlOiByZWxlYXNlTG9jayBtdXN0IGJlIGNhbGxlZCBhZnRlciBhZGRpbmcgYSBzaWduZWQgdHggdG8gcGVuZGluZyB0cmFuc2FjdGlvbnMgKG9yIGRpc2NhcmRpbmcpLlxuXG4gIEBwYXJhbSBhZGRyZXNzIHtzdHJpbmd9IHRoZSBoZXggc3RyaW5nIGZvciB0aGUgYWRkcmVzcyB3aG9zZSBub25jZSB3ZSBhcmUgY2FsY3VsYXRpbmdcbiAgQHJldHVybnMge1Byb21pc2U8Tm9uY2VEZXRhaWxzPn1cbiAgKi9cbiAgYXN5bmMgZ2V0Tm9uY2VMb2NrIChhZGRyZXNzKSB7XG4gICAgLy8gYXdhaXQgZ2xvYmFsIG11dGV4IGZyZWVcbiAgICBhd2FpdCB0aGlzLl9nbG9iYWxNdXRleEZyZWUoKVxuICAgIC8vIGF3YWl0IGxvY2sgZnJlZSwgdGhlbiB0YWtlIGxvY2tcbiAgICBjb25zdCByZWxlYXNlTG9jayA9IGF3YWl0IHRoaXMuX3Rha2VNdXRleChhZGRyZXNzKVxuICAgIHRyeSB7XG4gICAgICAvLyBldmFsdWF0ZSBtdWx0aXBsZSBuZXh0Tm9uY2Ugc3RyYXRlZ2llc1xuICAgICAgY29uc3Qgbm9uY2VEZXRhaWxzID0ge31cbiAgICAgIGNvbnN0IG5ldHdvcmtOb25jZVJlc3VsdCA9IGF3YWl0IHRoaXMuX2dldE5ldHdvcmtOZXh0Tm9uY2UoYWRkcmVzcylcbiAgICAgIGNvbnN0IGhpZ2hlc3RMb2NhbGx5Q29uZmlybWVkID0gdGhpcy5fZ2V0SGlnaGVzdExvY2FsbHlDb25maXJtZWQoYWRkcmVzcylcbiAgICAgIGNvbnN0IG5leHROZXR3b3JrTm9uY2UgPSBuZXR3b3JrTm9uY2VSZXN1bHQubm9uY2VcbiAgICAgIGNvbnN0IGhpZ2hlc3RTdWdnZXN0ZWQgPSBNYXRoLm1heChuZXh0TmV0d29ya05vbmNlLCBoaWdoZXN0TG9jYWxseUNvbmZpcm1lZClcblxuICAgICAgY29uc3QgcGVuZGluZ1R4cyA9IHRoaXMuZ2V0UGVuZGluZ1RyYW5zYWN0aW9ucyhhZGRyZXNzKVxuICAgICAgY29uc3QgbG9jYWxOb25jZVJlc3VsdCA9IHRoaXMuX2dldEhpZ2hlc3RDb250aW51b3VzRnJvbShwZW5kaW5nVHhzLCBoaWdoZXN0U3VnZ2VzdGVkKSB8fCAwXG5cbiAgICAgIG5vbmNlRGV0YWlscy5wYXJhbXMgPSB7XG4gICAgICAgIGhpZ2hlc3RMb2NhbGx5Q29uZmlybWVkLFxuICAgICAgICBoaWdoZXN0U3VnZ2VzdGVkLFxuICAgICAgICBuZXh0TmV0d29ya05vbmNlLFxuICAgICAgfVxuICAgICAgbm9uY2VEZXRhaWxzLmxvY2FsID0gbG9jYWxOb25jZVJlc3VsdFxuICAgICAgbm9uY2VEZXRhaWxzLm5ldHdvcmsgPSBuZXR3b3JrTm9uY2VSZXN1bHRcblxuICAgICAgY29uc3QgbmV4dE5vbmNlID0gTWF0aC5tYXgobmV0d29ya05vbmNlUmVzdWx0Lm5vbmNlLCBsb2NhbE5vbmNlUmVzdWx0Lm5vbmNlKVxuICAgICAgYXNzZXJ0KE51bWJlci5pc0ludGVnZXIobmV4dE5vbmNlKSwgYG5vbmNlLXRyYWNrZXIgLSBuZXh0Tm9uY2UgaXMgbm90IGFuIGludGVnZXIgLSBnb3Q6ICgke3R5cGVvZiBuZXh0Tm9uY2V9KSBcIiR7bmV4dE5vbmNlfVwiYClcblxuICAgICAgLy8gcmV0dXJuIG5vbmNlIGFuZCByZWxlYXNlIGNiXG4gICAgICByZXR1cm4geyBuZXh0Tm9uY2UsIG5vbmNlRGV0YWlscywgcmVsZWFzZUxvY2sgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gcmVsZWFzZSBsb2NrIGlmIHdlIGVuY291bnRlciBhbiBlcnJvclxuICAgICAgcmVsZWFzZUxvY2soKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2dsb2JhbE11dGV4RnJlZSAoKSB7XG4gICAgY29uc3QgZ2xvYmFsTXV0ZXggPSB0aGlzLl9sb29rdXBNdXRleCgnZ2xvYmFsJylcbiAgICBjb25zdCByZWxlYXNlTG9jayA9IGF3YWl0IGdsb2JhbE11dGV4LmFjcXVpcmUoKVxuICAgIHJlbGVhc2VMb2NrKClcbiAgfVxuXG4gIGFzeW5jIF90YWtlTXV0ZXggKGxvY2tJZCkge1xuICAgIGNvbnN0IG11dGV4ID0gdGhpcy5fbG9va3VwTXV0ZXgobG9ja0lkKVxuICAgIGNvbnN0IHJlbGVhc2VMb2NrID0gYXdhaXQgbXV0ZXguYWNxdWlyZSgpXG4gICAgcmV0dXJuIHJlbGVhc2VMb2NrXG4gIH1cblxuICBfbG9va3VwTXV0ZXggKGxvY2tJZCkge1xuICAgIGxldCBtdXRleCA9IHRoaXMubG9ja01hcFtsb2NrSWRdXG4gICAgaWYgKCFtdXRleCkge1xuICAgICAgbXV0ZXggPSBuZXcgTXV0ZXgoKVxuICAgICAgdGhpcy5sb2NrTWFwW2xvY2tJZF0gPSBtdXRleFxuICAgIH1cbiAgICByZXR1cm4gbXV0ZXhcbiAgfVxuXG4gIGFzeW5jIF9nZXROZXR3b3JrTmV4dE5vbmNlIChhZGRyZXNzKSB7XG4gICAgLy8gY2FsY3VsYXRlIG5leHQgbm9uY2VcbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBvdXIgYmFzZSBjb3VudFxuICAgIC8vIGFuZCBwZW5kaW5nIGNvdW50IGFyZSBmcm9tIHRoZSBzYW1lIGJsb2NrXG4gICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLmJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpXG4gICAgY29uc3QgYmFzZUNvdW50Qk4gPSBhd2FpdCB0aGlzLmV0aFF1ZXJ5LmdldFRyYW5zYWN0aW9uQ291bnQoYWRkcmVzcywgYmxvY2tOdW1iZXIpXG4gICAgY29uc3QgYmFzZUNvdW50ID0gYmFzZUNvdW50Qk4udG9OdW1iZXIoKVxuICAgIGFzc2VydChOdW1iZXIuaXNJbnRlZ2VyKGJhc2VDb3VudCksIGBub25jZS10cmFja2VyIC0gYmFzZUNvdW50IGlzIG5vdCBhbiBpbnRlZ2VyIC0gZ290OiAoJHt0eXBlb2YgYmFzZUNvdW50fSkgXCIke2Jhc2VDb3VudH1cImApXG4gICAgY29uc3Qgbm9uY2VEZXRhaWxzID0geyBibG9ja051bWJlciwgYmFzZUNvdW50IH1cbiAgICByZXR1cm4geyBuYW1lOiAnbmV0d29yaycsIG5vbmNlOiBiYXNlQ291bnQsIGRldGFpbHM6IG5vbmNlRGV0YWlscyB9XG4gIH1cblxuICBfZ2V0SGlnaGVzdExvY2FsbHlDb25maXJtZWQgKGFkZHJlc3MpIHtcbiAgICBjb25zdCBjb25maXJtZWRUcmFuc2FjdGlvbnMgPSB0aGlzLmdldENvbmZpcm1lZFRyYW5zYWN0aW9ucyhhZGRyZXNzKVxuICAgIGNvbnN0IGhpZ2hlc3QgPSB0aGlzLl9nZXRIaWdoZXN0Tm9uY2UoY29uZmlybWVkVHJhbnNhY3Rpb25zKVxuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGhpZ2hlc3QpID8gaGlnaGVzdCArIDEgOiAwXG4gIH1cblxuICBfZ2V0SGlnaGVzdE5vbmNlICh0eExpc3QpIHtcbiAgICBjb25zdCBub25jZXMgPSB0eExpc3QubWFwKCh0eE1ldGEpID0+IHtcbiAgICAgIGNvbnN0IG5vbmNlID0gdHhNZXRhLnR4UGFyYW1zLm5vbmNlXG4gICAgICBhc3NlcnQodHlwZW9mIG5vbmNlLCAnc3RyaW5nJywgJ25vbmNlcyBzaG91bGQgYmUgaGV4IHN0cmluZ3MnKVxuICAgICAgcmV0dXJuIHBhcnNlSW50KG5vbmNlLCAxNilcbiAgICB9KVxuICAgIGNvbnN0IGhpZ2hlc3ROb25jZSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIG5vbmNlcylcbiAgICByZXR1cm4gaGlnaGVzdE5vbmNlXG4gIH1cblxuICAvKipcbiAgICBAdHlwZWRlZiB7b2JqZWN0fSBoaWdoZXN0Q29udGludW91c0Zyb21cbiAgICBAcHJvcGVydHkge3N0cmluZ30gLSBuYW1lIHRoZSBuYW1lIGZvciBob3cgdGhlIG5vbmNlIHdhcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBkYXRhIHVzZWRcbiAgICBAcHJvcGVydHkge251bWJlcn0gLSBub25jZSB0aGUgbmV4dCBzdWdnZXN0ZWQgbm9uY2VcbiAgICBAcHJvcGVydHkge29iamVjdH0gLSBkZXRhaWxzIHRoZSBwcm92aWRlZCBzdGFydGluZyBub25jZSB0aGF0IHdhcyB1c2VkIChmb3IgZGVidWdnaW5nKVxuICAqL1xuICAvKipcbiAgICBAcGFyYW0gdHhMaXN0IHthcnJheX0gLSBsaXN0IG9mIHR4TWV0YSdzXG4gICAgQHBhcmFtIHN0YXJ0UG9pbnQge251bWJlcn0gLSB0aGUgaGlnaGVzdCBrbm93biBsb2NhbGx5IGNvbmZpcm1lZCBub25jZVxuICAgIEByZXR1cm5zIHtoaWdoZXN0Q29udGludW91c0Zyb219XG4gICovXG4gIF9nZXRIaWdoZXN0Q29udGludW91c0Zyb20gKHR4TGlzdCwgc3RhcnRQb2ludCkge1xuICAgIGNvbnN0IG5vbmNlcyA9IHR4TGlzdC5tYXAoKHR4TWV0YSkgPT4ge1xuICAgICAgY29uc3Qgbm9uY2UgPSB0eE1ldGEudHhQYXJhbXMubm9uY2VcbiAgICAgIGFzc2VydCh0eXBlb2Ygbm9uY2UsICdzdHJpbmcnLCAnbm9uY2VzIHNob3VsZCBiZSBoZXggc3RyaW5ncycpXG4gICAgICByZXR1cm4gcGFyc2VJbnQobm9uY2UsIDE2KVxuICAgIH0pXG5cbiAgICBsZXQgaGlnaGVzdCA9IHN0YXJ0UG9pbnRcbiAgICB3aGlsZSAobm9uY2VzLmluY2x1ZGVzKGhpZ2hlc3QpKSB7XG4gICAgICBoaWdoZXN0KytcbiAgICB9XG5cbiAgICByZXR1cm4geyBuYW1lOiAnbG9jYWwnLCBub25jZTogaGlnaGVzdCwgZGV0YWlsczogeyBzdGFydFBvaW50LCBoaWdoZXN0IH0gfVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOb25jZVRyYWNrZXJcbiIsImltcG9ydCB7IGV0aEVycm9ycyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlsJztcbmltcG9ydCB7XG4gIFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTLFxuICBUUkFOU0FDVElPTl9TVEFUVVNFUyxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBpc0VJUDE1NTlUcmFuc2FjdGlvbiB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3RyYW5zYWN0aW9uLnV0aWxzJztcbmltcG9ydCB7IGlzVmFsaWRIZXhBZGRyZXNzIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcblxuY29uc3Qgbm9ybWFsaXplcnMgPSB7XG4gIGZyb206IGFkZEhleFByZWZpeCxcbiAgdG86ICh0bywgbG93ZXJDYXNlKSA9PlxuICAgIGxvd2VyQ2FzZSA/IGFkZEhleFByZWZpeCh0bykudG9Mb3dlckNhc2UoKSA6IGFkZEhleFByZWZpeCh0byksXG4gIG5vbmNlOiBhZGRIZXhQcmVmaXgsXG4gIHZhbHVlOiBhZGRIZXhQcmVmaXgsXG4gIGRhdGE6IGFkZEhleFByZWZpeCxcbiAgZ2FzOiBhZGRIZXhQcmVmaXgsXG4gIGdhc1ByaWNlOiBhZGRIZXhQcmVmaXgsXG4gIG1heEZlZVBlckdhczogYWRkSGV4UHJlZml4LFxuICBtYXhQcmlvcml0eUZlZVBlckdhczogYWRkSGV4UHJlZml4LFxuICB0eXBlOiBhZGRIZXhQcmVmaXgsXG4gIGVzdGltYXRlU3VnZ2VzdGVkOiAoZXN0aW1hdGUpID0+IGVzdGltYXRlLFxuICBlc3RpbWF0ZVVzZWQ6IChlc3RpbWF0ZSkgPT4gZXN0aW1hdGUsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQW5kVmFsaWRhdGVUeFBhcmFtcyh0eFBhcmFtcywgbG93ZXJDYXNlID0gdHJ1ZSkge1xuICBjb25zdCBub3JtYWxpemVkVHhQYXJhbXMgPSBub3JtYWxpemVUeFBhcmFtcyh0eFBhcmFtcywgbG93ZXJDYXNlKTtcbiAgdmFsaWRhdGVUeFBhcmFtcyhub3JtYWxpemVkVHhQYXJhbXMpO1xuICByZXR1cm4gbm9ybWFsaXplZFR4UGFyYW1zO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIHR4UGFyYW1zXG4gKiBAcGFyYW0ge09iamVjdH0gdHhQYXJhbXMgLSBUaGUgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtsb3dlckNhc2VdIC0gV2hldGhlciB0byBsb3dlcmNhc2UgdGhlICd0bycgYWRkcmVzcy5cbiAqIERlZmF1bHQ6IHRydWVcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBub3JtYWxpemVkIHR4IHBhcmFtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplVHhQYXJhbXModHhQYXJhbXMsIGxvd2VyQ2FzZSA9IHRydWUpIHtcbiAgLy8gYXBwbHkgb25seSBrZXlzIGluIHRoZSBub3JtYWxpemVyc1xuICBjb25zdCBub3JtYWxpemVkVHhQYXJhbXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplcnMpIHtcbiAgICBpZiAodHhQYXJhbXNba2V5XSkge1xuICAgICAgbm9ybWFsaXplZFR4UGFyYW1zW2tleV0gPSBub3JtYWxpemVyc1trZXldKHR4UGFyYW1zW2tleV0sIGxvd2VyQ2FzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemVkVHhQYXJhbXM7XG59XG5cbi8qKlxuICogR2l2ZW4gdHdvIGZpZWxkcywgZW5zdXJlIHRoYXQgdGhlIHNlY29uZCBmaWVsZCBpcyBub3QgaW5jbHVkZWQgaW4gdHhQYXJhbXMsXG4gKiBhbmQgaWYgaXQgaXMgdGhyb3cgYW4gaW52YWxpZFBhcmFtcyBlcnJvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0eFBhcmFtcyAtIHRoZSB0cmFuc2FjdGlvbiBwYXJhbWV0ZXJzIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkQmVpbmdWYWxpZGF0ZWQgLSB0aGUgY3VycmVudCBmaWVsZCBiZWluZyB2YWxpZGF0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtdXR1YWxseUV4Y2x1c2l2ZUZpZWxkIC0gdGhlIGZpZWxkIHRvIGVuc3VyZSBpcyBub3QgcHJvdmlkZWRcbiAqIEB0aHJvd3Mge2V0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtc30gLSB0aHJvd3MgaWYgbXV0dWFsbHlFeGNsdXNpdmVGaWVsZCBpc1xuICogIHByZXNlbnQgaW4gdHhQYXJhbXMuXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZU11dHVhbGx5RXhjbHVzaXZlRmllbGRzTm90UHJvdmlkZWQoXG4gIHR4UGFyYW1zLFxuICBmaWVsZEJlaW5nVmFsaWRhdGVkLFxuICBtdXR1YWxseUV4Y2x1c2l2ZUZpZWxkLFxuKSB7XG4gIGlmICh0eXBlb2YgdHhQYXJhbXNbbXV0dWFsbHlFeGNsdXNpdmVGaWVsZF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKFxuICAgICAgYEludmFsaWQgdHJhbnNhY3Rpb24gcGFyYW1zOiBzcGVjaWZpZWQgJHtmaWVsZEJlaW5nVmFsaWRhdGVkfSBidXQgYWxzbyBpbmNsdWRlZCAke211dHVhbGx5RXhjbHVzaXZlRmllbGR9LCB0aGVzZSBjYW5ub3QgYmUgbWl4ZWRgLFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQgdGhlIHByb3ZpZGVkIHZhbHVlIGZvciBmaWVsZCBpcyBhIHN0cmluZywgdGhyb3dzIGFuXG4gKiBpbnZhbGlkUGFyYW1zIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0eFBhcmFtcyAtIHRoZSB0cmFuc2FjdGlvbiBwYXJhbWV0ZXJzIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIC0gdGhlIGN1cnJlbnQgZmllbGQgYmVpbmcgdmFsaWRhdGVkXG4gKiBAdGhyb3dzIHtldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXN9IC0gdGhyb3dzIGlmIGZpZWxkIGlzIG5vdCBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiBlbnN1cmVGaWVsZElzU3RyaW5nKHR4UGFyYW1zLCBmaWVsZCkge1xuICBpZiAodHlwZW9mIHR4UGFyYW1zW2ZpZWxkXSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoXG4gICAgICBgSW52YWxpZCB0cmFuc2FjdGlvbiBwYXJhbXM6ICR7ZmllbGR9IGlzIG5vdCBhIHN0cmluZy4gZ290OiAoJHt0eFBhcmFtc1tmaWVsZF19KWAsXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCB0aGUgcHJvdmlkZWQgdHhQYXJhbXMgaGFzIHRoZSBwcm9wZXIgJ3R5cGUnIHNwZWNpZmllZCBmb3IgdGhlXG4gKiBnaXZlbiBmaWVsZCwgaWYgaXQgaXMgcHJvdmlkZWQuIElmIHR5cGVzIGRvIG5vdCBtYXRjaCB0aHJvd3MgYW5cbiAqIGludmFsaWRQYXJhbXMgZXJyb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gdHhQYXJhbXMgLSB0aGUgdHJhbnNhY3Rpb24gcGFyYW1ldGVycyBvYmplY3RcbiAqIEBwYXJhbSB7J2dhc1ByaWNlJyB8ICdtYXhGZWVQZXJHYXMnIHwgJ21heFByaW9yaXR5RmVlUGVyR2FzJ30gZmllbGQgLSB0aGVcbiAqICBjdXJyZW50IGZpZWxkIGJlaW5nIHZhbGlkYXRlZFxuICogQHRocm93cyB7ZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zfSAtIHRocm93cyBpZiB0eXBlIGRvZXMgbm90IG1hdGNoIHRoZVxuICogIGV4cGVjdGF0aW9ucyBmb3IgcHJvdmlkZWQgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZVByb3BlclRyYW5zYWN0aW9uRW52ZWxvcGVUeXBlUHJvdmlkZWQodHhQYXJhbXMsIGZpZWxkKSB7XG4gIHN3aXRjaCAoZmllbGQpIHtcbiAgICBjYXNlICdtYXhGZWVQZXJHYXMnOlxuICAgIGNhc2UgJ21heFByaW9yaXR5RmVlUGVyR2FzJzpcbiAgICAgIGlmIChcbiAgICAgICAgdHhQYXJhbXMudHlwZSAmJlxuICAgICAgICB0eFBhcmFtcy50eXBlICE9PSBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5GRUVfTUFSS0VUXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKFxuICAgICAgICAgIGBJbnZhbGlkIHRyYW5zYWN0aW9uIGVudmVsb3BlIHR5cGU6IHNwZWNpZmllZCB0eXBlIFwiJHt0eFBhcmFtcy50eXBlfVwiIGJ1dCBpbmNsdWRpbmcgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhcyByZXF1aXJlcyB0eXBlOiBcIiR7VFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMuRkVFX01BUktFVH1cImAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdnYXNQcmljZSc6XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChcbiAgICAgICAgdHhQYXJhbXMudHlwZSAmJlxuICAgICAgICB0eFBhcmFtcy50eXBlID09PSBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5GRUVfTUFSS0VUXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKFxuICAgICAgICAgIGBJbnZhbGlkIHRyYW5zYWN0aW9uIGVudmVsb3BlIHR5cGU6IHNwZWNpZmllZCB0eXBlIFwiJHt0eFBhcmFtcy50eXBlfVwiIGJ1dCBpbmNsdWRlZCBhIGdhc1ByaWNlIGluc3RlYWQgb2YgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhc2AsXG4gICAgICAgICk7XG4gICAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGdpdmVuIHR4IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eFBhcmFtcyAtIHRoZSB0eCBwYXJhbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZWlwMTU1OUNvbXBhdGliaWxpdHkgLSB3aGV0aGVyIG9yIG5vdCB0aGUgY3VycmVudCBuZXR3b3JrIHN1cHBvcnRzIEVJUC0xNTU5IHRyYW5zYWN0aW9uc1xuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSB0eCBwYXJhbXMgY29udGFpbnMgaW52YWxpZCBmaWVsZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVHhQYXJhbXModHhQYXJhbXMsIGVpcDE1NTlDb21wYXRpYmlsaXR5ID0gdHJ1ZSkge1xuICBpZiAoIXR4UGFyYW1zIHx8IHR5cGVvZiB0eFBhcmFtcyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheSh0eFBhcmFtcykpIHtcbiAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoXG4gICAgICAnSW52YWxpZCB0cmFuc2FjdGlvbiBwYXJhbXM6IG11c3QgYmUgYW4gb2JqZWN0LicsXG4gICAgKTtcbiAgfVxuICBpZiAoIXR4UGFyYW1zLnRvICYmICF0eFBhcmFtcy5kYXRhKSB7XG4gICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKFxuICAgICAgJ0ludmFsaWQgdHJhbnNhY3Rpb24gcGFyYW1zOiBtdXN0IHNwZWNpZnkgXCJkYXRhXCIgZm9yIGNvbnRyYWN0IGRlcGxveW1lbnRzLCBvciBcInRvXCIgKGFuZCBvcHRpb25hbGx5IFwiZGF0YVwiKSBmb3IgYWxsIG90aGVyIHR5cGVzIG9mIHRyYW5zYWN0aW9ucy4nLFxuICAgICk7XG4gIH1cbiAgaWYgKGlzRUlQMTU1OVRyYW5zYWN0aW9uKHsgdHhQYXJhbXMgfSkgJiYgIWVpcDE1NTlDb21wYXRpYmlsaXR5KSB7XG4gICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKFxuICAgICAgJ0ludmFsaWQgdHJhbnNhY3Rpb24gcGFyYW1zOiBwYXJhbXMgc3BlY2lmeSBhbiBFSVAtMTU1OSB0cmFuc2FjdGlvbiBidXQgdGhlIGN1cnJlbnQgbmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVJUC0xNTU5JyxcbiAgICApO1xuICB9XG5cbiAgT2JqZWN0LmVudHJpZXModHhQYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIC8vIHZhbGlkYXRlIHR5cGVzXG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ2Zyb20nOlxuICAgICAgICB2YWxpZGF0ZUZyb20odHhQYXJhbXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvJzpcbiAgICAgICAgdmFsaWRhdGVSZWNpcGllbnQodHhQYXJhbXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2dhc1ByaWNlJzpcbiAgICAgICAgZW5zdXJlUHJvcGVyVHJhbnNhY3Rpb25FbnZlbG9wZVR5cGVQcm92aWRlZCh0eFBhcmFtcywgJ2dhc1ByaWNlJyk7XG4gICAgICAgIGVuc3VyZU11dHVhbGx5RXhjbHVzaXZlRmllbGRzTm90UHJvdmlkZWQoXG4gICAgICAgICAgdHhQYXJhbXMsXG4gICAgICAgICAgJ2dhc1ByaWNlJyxcbiAgICAgICAgICAnbWF4RmVlUGVyR2FzJyxcbiAgICAgICAgKTtcbiAgICAgICAgZW5zdXJlTXV0dWFsbHlFeGNsdXNpdmVGaWVsZHNOb3RQcm92aWRlZChcbiAgICAgICAgICB0eFBhcmFtcyxcbiAgICAgICAgICAnZ2FzUHJpY2UnLFxuICAgICAgICAgICdtYXhQcmlvcml0eUZlZVBlckdhcycsXG4gICAgICAgICk7XG4gICAgICAgIGVuc3VyZUZpZWxkSXNTdHJpbmcodHhQYXJhbXMsICdnYXNQcmljZScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21heEZlZVBlckdhcyc6XG4gICAgICAgIGVuc3VyZVByb3BlclRyYW5zYWN0aW9uRW52ZWxvcGVUeXBlUHJvdmlkZWQodHhQYXJhbXMsICdtYXhGZWVQZXJHYXMnKTtcbiAgICAgICAgZW5zdXJlTXV0dWFsbHlFeGNsdXNpdmVGaWVsZHNOb3RQcm92aWRlZChcbiAgICAgICAgICB0eFBhcmFtcyxcbiAgICAgICAgICAnbWF4RmVlUGVyR2FzJyxcbiAgICAgICAgICAnZ2FzUHJpY2UnLFxuICAgICAgICApO1xuICAgICAgICBlbnN1cmVGaWVsZElzU3RyaW5nKHR4UGFyYW1zLCAnbWF4RmVlUGVyR2FzJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWF4UHJpb3JpdHlGZWVQZXJHYXMnOlxuICAgICAgICBlbnN1cmVQcm9wZXJUcmFuc2FjdGlvbkVudmVsb3BlVHlwZVByb3ZpZGVkKFxuICAgICAgICAgIHR4UGFyYW1zLFxuICAgICAgICAgICdtYXhQcmlvcml0eUZlZVBlckdhcycsXG4gICAgICAgICk7XG4gICAgICAgIGVuc3VyZU11dHVhbGx5RXhjbHVzaXZlRmllbGRzTm90UHJvdmlkZWQoXG4gICAgICAgICAgdHhQYXJhbXMsXG4gICAgICAgICAgJ21heFByaW9yaXR5RmVlUGVyR2FzJyxcbiAgICAgICAgICAnZ2FzUHJpY2UnLFxuICAgICAgICApO1xuICAgICAgICBlbnN1cmVGaWVsZElzU3RyaW5nKHR4UGFyYW1zLCAnbWF4UHJpb3JpdHlGZWVQZXJHYXMnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgIGVuc3VyZUZpZWxkSXNTdHJpbmcodHhQYXJhbXMsICd2YWx1ZScpO1xuICAgICAgICBpZiAodmFsdWUudG9TdHJpbmcoKS5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKFxuICAgICAgICAgICAgYEludmFsaWQgdHJhbnNhY3Rpb24gdmFsdWUgXCIke3ZhbHVlfVwiOiBub3QgYSBwb3NpdGl2ZSBudW1iZXIuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLnRvU3RyaW5nKCkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhcbiAgICAgICAgICAgIGBJbnZhbGlkIHRyYW5zYWN0aW9uIHZhbHVlIG9mIFwiJHt2YWx1ZX1cIjogbnVtYmVyIG11c3QgYmUgaW4gd2VpLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdmFsdWUubWF0Y2goL14weFthLWZBLUYwLTldKyQvdSkpIHtcbiAgICAgICAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoXG4gICAgICAgICAgICBgSW52YWxpZCB0cmFuc2FjdGlvbiB2YWx1ZSBvZiBcIiR7dmFsdWV9XCI6IG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2hhaW5JZCc6XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoXG4gICAgICAgICAgICBgSW52YWxpZCB0cmFuc2FjdGlvbiBwYXJhbXM6ICR7a2V5fSBpcyBub3QgYSBOdW1iZXIgb3IgaGV4IHN0cmluZy4gZ290OiAoJHt2YWx1ZX0pYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZW5zdXJlRmllbGRJc1N0cmluZyh0eFBhcmFtcywga2V5KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGUge0Bjb2RlIGZyb219IGZpZWxkIGluIHRoZSBnaXZlbiB0eCBwYXJhbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eFBhcmFtc1xuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBmcm9tIGFkZHJlc3MgaXNuJ3QgdmFsaWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRnJvbSh0eFBhcmFtcykge1xuICBpZiAoISh0eXBlb2YgdHhQYXJhbXMuZnJvbSA9PT0gJ3N0cmluZycpKSB7XG4gICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKFxuICAgICAgYEludmFsaWQgXCJmcm9tXCIgYWRkcmVzcyBcIiR7dHhQYXJhbXMuZnJvbX1cIjogbm90IGEgc3RyaW5nLmAsXG4gICAgKTtcbiAgfVxuICBpZiAoIWlzVmFsaWRIZXhBZGRyZXNzKHR4UGFyYW1zLmZyb20sIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSkpIHtcbiAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoJ0ludmFsaWQgXCJmcm9tXCIgYWRkcmVzcy4nKTtcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGUge0Bjb2RlIHRvfSBmaWVsZCBpbiB0aGUgZ2l2ZW4gdHggcGFyYW1zXG4gKiBAcGFyYW0ge09iamVjdH0gdHhQYXJhbXMgLSB0aGUgdHggcGFyYW1zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgdHggcGFyYW1zXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIHJlY2lwaWVudCBpcyBpbnZhbGlkIE9SIHRoZXJlIGlzbid0IHR4IGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmVjaXBpZW50KHR4UGFyYW1zKSB7XG4gIGlmICh0eFBhcmFtcy50byA9PT0gJzB4JyB8fCB0eFBhcmFtcy50byA9PT0gbnVsbCkge1xuICAgIGlmICh0eFBhcmFtcy5kYXRhKSB7XG4gICAgICBkZWxldGUgdHhQYXJhbXMudG87XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcygnSW52YWxpZCBcInRvXCIgYWRkcmVzcy4nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgdHhQYXJhbXMudG8gIT09IHVuZGVmaW5lZCAmJlxuICAgICFpc1ZhbGlkSGV4QWRkcmVzcyh0eFBhcmFtcy50bywgeyBhbGxvd05vblByZWZpeGVkOiBmYWxzZSB9KVxuICApIHtcbiAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoJ0ludmFsaWQgXCJ0b1wiIGFkZHJlc3MuJyk7XG4gIH1cbiAgcmV0dXJuIHR4UGFyYW1zO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGZpbmFsIHN0YXRlc1xuICogQHJldHVybnMge3N0cmluZ1tdfSB0aGUgc3RhdGVzIHRoYXQgY2FuIGJlIGNvbnNpZGVyZWQgZmluYWwgc3RhdGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaW5hbFN0YXRlcygpIHtcbiAgcmV0dXJuIFtcbiAgICBUUkFOU0FDVElPTl9TVEFUVVNFUy5SRUpFQ1RFRCwgLy8gdGhlIHVzZXIgaGFzIHJlc3BvbmRlZCBubyFcbiAgICBUUkFOU0FDVElPTl9TVEFUVVNFUy5DT05GSVJNRUQsIC8vIHRoZSB0eCBoYXMgYmVlbiBpbmNsdWRlZCBpbiBhIGJsb2NrLlxuICAgIFRSQU5TQUNUSU9OX1NUQVRVU0VTLkZBSUxFRCwgLy8gdGhlIHR4IGZhaWxlZCBmb3Igc29tZSByZWFzb24sIGluY2x1ZGVkIG9uIHR4IGRhdGEuXG4gICAgVFJBTlNBQ1RJT05fU1RBVFVTRVMuRFJPUFBFRCwgLy8gdGhlIHR4IG5vbmNlIHdhcyBhbHJlYWR5IHVzZWRcbiAgXTtcbn1cbiIsImltcG9ydCBFdGhRdWVyeSBmcm9tICdldGhqcy1xdWVyeSc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaGV4VG9CbiwgQm5NdWx0aXBseUJ5RnJhY3Rpb24sIGJuVG9IZXggfSBmcm9tICcuLi8uLi9saWIvdXRpbCc7XG5cbi8qKlxuICogUmVzdWx0IG9mIGdhcyBhbmFseXNpcywgaW5jbHVkaW5nIGVpdGhlciBhIGdhcyBlc3RpbWF0ZSBmb3IgYSBzdWNjZXNzZnVsIGFuYWx5c2lzLCBvclxuICogZGVidWcgaW5mb3JtYXRpb24gZm9yIGEgZmFpbGVkIGFuYWx5c2lzLlxuICogQHR5cGVkZWYge09iamVjdH0gR2FzQW5hbHlzaXNSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBibG9ja0dhc0xpbWl0IC0gVGhlIGdhcyBsaW1pdCBvZiB0aGUgYmxvY2sgdXNlZCBmb3IgdGhlIGFuYWx5c2lzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXN0aW1hdGVkR2FzSGV4IC0gVGhlIGVzdGltYXRlZCBnYXMsIGluIGhleGFkZWNpbWFsXG4gKiBAcHJvcGVydHkge09iamVjdH0gc2ltdWxhdGlvbkZhaWxzIC0gRGVidWcgaW5mb3JtYXRpb24gYWJvdXQgd2h5IGFuIGFuYWx5c2lzIGZhaWxlZFxuICovXG5cbi8qKlxudHgtZ2FzLXV0aWxzIGFyZSBnYXMgdXRpbGl0eSBtZXRob2RzIGZvciBUcmFuc2FjdGlvbiBtYW5hZ2VyXG5pdHMgcGFzc2VkIGV0aHF1ZXJ5XG5hbmQgdXNlZCB0byBkbyB0aGluZ3MgbGlrZSBjYWxjdWxhdGUgZ2FzIG9mIGEgdHguXG5AcGFyYW0ge09iamVjdH0gcHJvdmlkZXIgLSBBIG5ldHdvcmsgcHJvdmlkZXIuXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUeEdhc1V0aWwge1xuICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgIHRoaXMucXVlcnkgPSBuZXcgRXRoUXVlcnkocHJvdmlkZXIpO1xuICB9XG5cbiAgLyoqXG4gICAgQHBhcmFtIHtPYmplY3R9IHR4TWV0YSAtIHRoZSB0eE1ldGEgb2JqZWN0XG4gICAgQHJldHVybnMge0dhc0FuYWx5c2lzUmVzdWx0fSBUaGUgcmVzdWx0IG9mIHRoZSBnYXMgYW5hbHlzaXNcbiAgKi9cbiAgYXN5bmMgYW5hbHl6ZUdhc1VzYWdlKHR4TWV0YSkge1xuICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5xdWVyeS5nZXRCbG9ja0J5TnVtYmVyKCdsYXRlc3QnLCBmYWxzZSk7XG5cbiAgICAvLyBmYWxsYmFjayB0byBibG9jayBnYXNMaW1pdFxuICAgIGNvbnN0IGJsb2NrR2FzTGltaXRCTiA9IGhleFRvQm4oYmxvY2suZ2FzTGltaXQpO1xuICAgIGNvbnN0IHNhZmVyR2FzTGltaXRCTiA9IEJuTXVsdGlwbHlCeUZyYWN0aW9uKGJsb2NrR2FzTGltaXRCTiwgMTksIDIwKTtcbiAgICBsZXQgZXN0aW1hdGVkR2FzSGV4ID0gYm5Ub0hleChzYWZlckdhc0xpbWl0Qk4pO1xuICAgIGxldCBzaW11bGF0aW9uRmFpbHM7XG4gICAgdHJ5IHtcbiAgICAgIGVzdGltYXRlZEdhc0hleCA9IGF3YWl0IHRoaXMuZXN0aW1hdGVUeEdhcyh0eE1ldGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cud2FybihlcnJvcik7XG4gICAgICBzaW11bGF0aW9uRmFpbHMgPSB7XG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgZXJyb3JLZXk6IGVycm9yLmVycm9yS2V5LFxuICAgICAgICBkZWJ1ZzogeyBibG9ja051bWJlcjogYmxvY2subnVtYmVyLCBibG9ja0dhc0xpbWl0OiBibG9jay5nYXNMaW1pdCB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBibG9ja0dhc0xpbWl0OiBibG9jay5nYXNMaW1pdCwgZXN0aW1hdGVkR2FzSGV4LCBzaW11bGF0aW9uRmFpbHMgfTtcbiAgfVxuXG4gIC8qKlxuICAgIEVzdGltYXRlcyB0aGUgdHgncyBnYXMgdXNhZ2VcbiAgICBAcGFyYW0ge09iamVjdH0gdHhNZXRhIC0gdGhlIHR4TWV0YSBvYmplY3RcbiAgICBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZXN0aW1hdGVkIGdhcyBsaW1pdCBhcyBhIGhleCBzdHJpbmdcbiAgKi9cbiAgYXN5bmMgZXN0aW1hdGVUeEdhcyh0eE1ldGEpIHtcbiAgICBjb25zdCB0eFBhcmFtcyA9IGNsb25lRGVlcCh0eE1ldGEudHhQYXJhbXMpO1xuXG4gICAgLy8gYGV0aF9lc3RpbWF0ZUdhc2AgY2FuIGZhaWwgaWYgdGhlIHVzZXIgaGFzIGluc3VmZmljaWVudCBiYWxhbmNlIGZvciB0aGVcbiAgICAvLyB2YWx1ZSBiZWluZyBzZW50LCBvciBmb3IgdGhlIGdhcyBjb3N0LiBXZSBkb24ndCB3YW50IHRvIGNoZWNrIHRoZWlyXG4gICAgLy8gYmFsYW5jZSBoZXJlLCB3ZSBqdXN0IHdhbnQgdGhlIGdhcyBlc3RpbWF0ZS4gVGhlIGdhcyBwcmljZSBpcyByZW1vdmVkXG4gICAgLy8gdG8gc2tpcCB0aG9zZSBiYWxhbmNlIGNoZWNrcy4gV2UgY2hlY2sgYmFsYW5jZSBlbHNld2hlcmUuIFdlIGFsc28gZGVsZXRlXG4gICAgLy8gbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhcyB0byBzdXBwb3J0IEVJUC0xNTU5IHR4cy5cbiAgICBkZWxldGUgdHhQYXJhbXMuZ2FzUHJpY2U7XG4gICAgZGVsZXRlIHR4UGFyYW1zLm1heEZlZVBlckdhcztcbiAgICBkZWxldGUgdHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG5cbiAgICAvLyBlc3RpbWF0ZSB0eCBnYXMgcmVxdWlyZW1lbnRzXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucXVlcnkuZXN0aW1hdGVHYXModHhQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAgQWRkcyBhIGdhcyBidWZmZXIgd2l0aCBvdXQgZXhjZWVkaW5nIHRoZSBibG9jayBnYXMgbGltaXRcblxuICAgIEBwYXJhbSB7c3RyaW5nfSBpbml0aWFsR2FzTGltaXRIZXggLSB0aGUgaW5pdGlhbCBnYXMgbGltaXQgdG8gYWRkIHRoZSBidWZmZXIgdG9vXG4gICAgQHBhcmFtIHtzdHJpbmd9IGJsb2NrR2FzTGltaXRIZXggLSB0aGUgYmxvY2sgZ2FzIGxpbWl0XG4gICAgQHJldHVybnMge3N0cmluZ30gdGhlIGJ1ZmZlcmVkIGdhcyBsaW1pdCBhcyBhIGhleCBzdHJpbmdcbiAgKi9cbiAgYWRkR2FzQnVmZmVyKGluaXRpYWxHYXNMaW1pdEhleCwgYmxvY2tHYXNMaW1pdEhleCwgbXVsdGlwbGllciA9IDEuNSkge1xuICAgIGNvbnN0IGluaXRpYWxHYXNMaW1pdEJuID0gaGV4VG9Cbihpbml0aWFsR2FzTGltaXRIZXgpO1xuICAgIGNvbnN0IGJsb2NrR2FzTGltaXRCbiA9IGhleFRvQm4oYmxvY2tHYXNMaW1pdEhleCk7XG4gICAgY29uc3QgdXBwZXJHYXNMaW1pdEJuID0gYmxvY2tHYXNMaW1pdEJuLm11bG4oMC45KTtcbiAgICBjb25zdCBidWZmZXJlZEdhc0xpbWl0Qm4gPSBpbml0aWFsR2FzTGltaXRCbi5tdWxuKG11bHRpcGxpZXIpO1xuXG4gICAgLy8gaWYgaW5pdGlhbEdhc0xpbWl0IGlzIGFib3ZlIGJsb2NrR2FzTGltaXQsIGRvbnQgbW9kaWZ5IGl0XG4gICAgaWYgKGluaXRpYWxHYXNMaW1pdEJuLmd0KHVwcGVyR2FzTGltaXRCbikpIHtcbiAgICAgIHJldHVybiBiblRvSGV4KGluaXRpYWxHYXNMaW1pdEJuKTtcbiAgICB9XG4gICAgLy8gaWYgYnVmZmVyZWRHYXNMaW1pdCBpcyBiZWxvdyBibG9ja0dhc0xpbWl0LCB1c2UgYnVmZmVyZWRHYXNMaW1pdFxuICAgIGlmIChidWZmZXJlZEdhc0xpbWl0Qm4ubHQodXBwZXJHYXNMaW1pdEJuKSkge1xuICAgICAgcmV0dXJuIGJuVG9IZXgoYnVmZmVyZWRHYXNMaW1pdEJuKTtcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIHVzZSBibG9ja0dhc0xpbWl0XG4gICAgcmV0dXJuIGJuVG9IZXgodXBwZXJHYXNMaW1pdEJuKTtcbiAgfVxuXG4gIGFzeW5jIGdldEJ1ZmZlcmVkR2FzTGltaXQodHhNZXRhLCBtdWx0aXBsaWVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgYmxvY2tHYXNMaW1pdCxcbiAgICAgIGVzdGltYXRlZEdhc0hleCxcbiAgICAgIHNpbXVsYXRpb25GYWlscyxcbiAgICB9ID0gYXdhaXQgdGhpcy5hbmFseXplR2FzVXNhZ2UodHhNZXRhKTtcblxuICAgIC8vIGFkZCBhZGRpdGlvbmFsIGdhcyBidWZmZXIgdG8gb3VyIGVzdGltYXRpb24gZm9yIHNhZmV0eVxuICAgIGNvbnN0IGdhc0xpbWl0ID0gdGhpcy5hZGRHYXNCdWZmZXIoXG4gICAgICBhZGRIZXhQcmVmaXgoZXN0aW1hdGVkR2FzSGV4KSxcbiAgICAgIGJsb2NrR2FzTGltaXQsXG4gICAgICBtdWx0aXBsaWVyLFxuICAgICk7XG4gICAgcmV0dXJuIHsgZ2FzTGltaXQsIHNpbXVsYXRpb25GYWlscyB9O1xuICB9XG59XG4iXSwicHJlRXhpc3RpbmdDb21tZW50IjoiLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIn0=
