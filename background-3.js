LavaPack.loadBundle([
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/dist/index.js", {"./hdkey":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/dist/hdkey.js","./thirdparty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/dist/thirdparty.js","bs58check":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bs58check/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crypto-browserify/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","randombytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/randombytes/browser.js","scrypt-js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/scrypt-js/scrypt.js","uuid/v4":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/node_modules/uuid/v4.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/dist/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var crypto = require("crypto");
var ethereumjs_util_1 = require("ethereumjs-util");
var scrypt_js_1 = require("scrypt-js");
var hdkey_1 = require("./hdkey");
Object.defineProperty(exports, "hdkey", { enumerable: true, get: function () { return hdkey_1.default; } });
var thirdparty_1 = require("./thirdparty");
Object.defineProperty(exports, "thirdparty", { enumerable: true, get: function () { return thirdparty_1.default; } });
var bs58check = require('bs58check');
var randomBytes = require('randombytes');
var uuidv4 = require('uuid/v4');
function validateHexString(paramName, str, length) {
    if (str.toLowerCase().startsWith('0x')) {
        str = str.slice(2);
    }
    if (!str && !length) {
        return str;
    }
    if (length % 2) {
        throw new Error("Invalid length argument, must be an even number");
    }
    if (typeof length === 'number' && str.length !== length) {
        throw new Error("Invalid " + paramName + ", string must be " + length + " hex characters");
    }
    if (!/^([0-9a-f]{2})+$/i.test(str)) {
        var howMany = typeof length === 'number' ? length : 'empty or a non-zero even number of';
        throw new Error("Invalid " + paramName + ", string must be " + howMany + " hex characters");
    }
    return str;
}
function validateBuffer(paramName, buff, length) {
    if (!Buffer.isBuffer(buff)) {
        var howManyHex = typeof length === 'number' ? "" + length * 2 : 'empty or a non-zero even number of';
        var howManyBytes = typeof length === 'number' ? " (" + length + " bytes)" : '';
        throw new Error("Invalid " + paramName + ", must be a string (" + howManyHex + " hex characters) or buffer" + howManyBytes);
    }
    if (typeof length === 'number' && buff.length !== length) {
        throw new Error("Invalid " + paramName + ", buffer must be " + length + " bytes");
    }
    return buff;
}
function mergeToV3ParamsWithDefaults(params) {
    var v3Defaults = {
        cipher: 'aes-128-ctr',
        kdf: 'scrypt',
        salt: randomBytes(32),
        iv: randomBytes(16),
        uuid: randomBytes(16),
        dklen: 32,
        c: 262144,
        n: 262144,
        r: 8,
        p: 1,
    };
    if (!params) {
        return v3Defaults;
    }
    if (typeof params.salt === 'string') {
        params.salt = Buffer.from(validateHexString('salt', params.salt), 'hex');
    }
    if (typeof params.iv === 'string') {
        params.iv = Buffer.from(validateHexString('iv', params.iv, 32), 'hex');
    }
    if (typeof params.uuid === 'string') {
        params.uuid = Buffer.from(validateHexString('uuid', params.uuid, 32), 'hex');
    }
    if (params.salt) {
        validateBuffer('salt', params.salt);
    }
    if (params.iv) {
        validateBuffer('iv', params.iv, 16);
    }
    if (params.uuid) {
        validateBuffer('uuid', params.uuid, 16);
    }
    return __assign(__assign({}, v3Defaults), params);
}
function kdfParamsForPBKDF(opts) {
    return {
        dklen: opts.dklen,
        salt: opts.salt,
        c: opts.c,
        prf: 'hmac-sha256',
    };
}
function kdfParamsForScrypt(opts) {
    return {
        dklen: opts.dklen,
        salt: opts.salt,
        n: opts.n,
        r: opts.r,
        p: opts.p,
    };
}
// wallet implementation
var Wallet = /** @class */ (function () {
    function Wallet(privateKey, publicKey) {
        if (publicKey === void 0) { publicKey = undefined; }
        this.privateKey = privateKey;
        this.publicKey = publicKey;
        if (privateKey && publicKey) {
            throw new Error('Cannot supply both a private and a public key to the constructor');
        }
        if (privateKey && !ethereumjs_util_1.isValidPrivate(privateKey)) {
            throw new Error('Private key does not satisfy the curve requirements (ie. it is invalid)');
        }
        if (publicKey && !ethereumjs_util_1.isValidPublic(publicKey)) {
            throw new Error('Invalid public key');
        }
    }
    // static methods
    /**
     * Create an instance based on a new random key.
     *
     * @param icapDirect setting this to `true` will generate an address suitable for the `ICAP Direct mode`
     */
    Wallet.generate = function (icapDirect) {
        if (icapDirect === void 0) { icapDirect = false; }
        if (icapDirect) {
            var max = new ethereumjs_util_1.BN('088f924eeceeda7fe92e1f5b0fffffffffffffff', 16);
            while (true) {
                var privateKey = randomBytes(32);
                if (new ethereumjs_util_1.BN(ethereumjs_util_1.privateToAddress(privateKey)).lte(max)) {
                    return new Wallet(privateKey);
                }
            }
        }
        else {
            return new Wallet(randomBytes(32));
        }
    };
    /**
     * Create an instance where the address is valid against the supplied pattern (**this will be very slow**)
     */
    Wallet.generateVanityAddress = function (pattern) {
        if (!(pattern instanceof RegExp)) {
            pattern = new RegExp(pattern);
        }
        while (true) {
            var privateKey = randomBytes(32);
            var address = ethereumjs_util_1.privateToAddress(privateKey);
            if (pattern.test(address.toString('hex'))) {
                return new Wallet(privateKey);
            }
        }
    };
    /**
     * Create an instance based on a public key (certain methods will not be available)
     *
     * This method only accepts uncompressed Ethereum-style public keys, unless
     * the `nonStrict` flag is set to true.
     */
    Wallet.fromPublicKey = function (publicKey, nonStrict) {
        if (nonStrict === void 0) { nonStrict = false; }
        if (nonStrict) {
            publicKey = ethereumjs_util_1.importPublic(publicKey);
        }
        return new Wallet(undefined, publicKey);
    };
    /**
     * Create an instance based on a BIP32 extended public key (xpub)
     */
    Wallet.fromExtendedPublicKey = function (extendedPublicKey) {
        if (extendedPublicKey.slice(0, 4) !== 'xpub') {
            throw new Error('Not an extended public key');
        }
        var publicKey = bs58check.decode(extendedPublicKey).slice(45);
        // Convert to an Ethereum public key
        return Wallet.fromPublicKey(publicKey, true);
    };
    /**
     * Create an instance based on a raw private key
     */
    Wallet.fromPrivateKey = function (privateKey) {
        return new Wallet(privateKey);
    };
    /**
     * Create an instance based on a BIP32 extended private key (xprv)
     */
    Wallet.fromExtendedPrivateKey = function (extendedPrivateKey) {
        if (extendedPrivateKey.slice(0, 4) !== 'xprv') {
            throw new Error('Not an extended private key');
        }
        var tmp = bs58check.decode(extendedPrivateKey);
        if (tmp[45] !== 0) {
            throw new Error('Invalid extended private key');
        }
        return Wallet.fromPrivateKey(tmp.slice(46));
    };
    /**
     * Import a wallet (Version 1 of the Ethereum wallet format).
     *
     * @param input A JSON serialized string, or an object representing V1 Keystore.
     * @param password The keystore password.
     */
    Wallet.fromV1 = function (input, password) {
        return __awaiter(this, void 0, void 0, function () {
            var json, kdfparams, derivedKey, ciphertext, mac, decipher, seed;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        json = typeof input === 'object' ? input : JSON.parse(input);
                        if (json.Version !== '1') {
                            throw new Error('Not a V1 Wallet');
                        }
                        if (json.Crypto.KeyHeader.Kdf !== 'scrypt') {
                            throw new Error('Unsupported key derivation scheme');
                        }
                        kdfparams = json.Crypto.KeyHeader.KdfParams;
                        return [4 /*yield*/, scrypt_js_1.scrypt(Buffer.from(password), Buffer.from(json.Crypto.Salt, 'hex'), kdfparams.N, kdfparams.R, kdfparams.P, kdfparams.DkLen)];
                    case 1:
                        derivedKey = _a.sent();
                        ciphertext = Buffer.from(json.Crypto.CipherText, 'hex');
                        mac = ethereumjs_util_1.keccak256(Buffer.concat([derivedKey.slice(16, 32), ciphertext]));
                        if (mac.toString('hex') !== json.Crypto.MAC) {
                            throw new Error('Key derivation failed - possibly wrong passphrase');
                        }
                        decipher = crypto.createDecipheriv('aes-128-cbc', ethereumjs_util_1.keccak256(derivedKey.slice(0, 16)).slice(0, 16), Buffer.from(json.Crypto.IV, 'hex'));
                        seed = runCipherBuffer(decipher, ciphertext);
                        return [2 /*return*/, new Wallet(seed)];
                }
            });
        });
    };
    /**
     * Import a wallet (Version 3 of the Ethereum wallet format). Set `nonStrict` true to accept files with mixed-caps.
     *
     * @param input A JSON serialized string, or an object representing V3 Keystore.
     * @param password The keystore password.
     */
    Wallet.fromV3 = function (input, password, nonStrict) {
        if (nonStrict === void 0) { nonStrict = false; }
        return __awaiter(this, void 0, void 0, function () {
            var json, derivedKey, kdfparams, ciphertext, mac, decipher, seed;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        json = typeof input === 'object' ? input : JSON.parse(nonStrict ? input.toLowerCase() : input);
                        if (json.version !== 3) {
                            throw new Error('Not a V3 wallet');
                        }
                        if (!(json.crypto.kdf === 'scrypt')) return [3 /*break*/, 2];
                        kdfparams = json.crypto.kdfparams;
                        return [4 /*yield*/, scrypt_js_1.scrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen)];
                    case 1:
                        // FIXME: support progress reporting callback
                        derivedKey = _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        if (json.crypto.kdf === 'pbkdf2') {
                            kdfparams = json.crypto.kdfparams;
                            if (kdfparams.prf !== 'hmac-sha256') {
                                throw new Error('Unsupported parameters to PBKDF2');
                            }
                            derivedKey = crypto.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');
                        }
                        else {
                            throw new Error('Unsupported key derivation scheme');
                        }
                        _a.label = 3;
                    case 3:
                        ciphertext = Buffer.from(json.crypto.ciphertext, 'hex');
                        mac = ethereumjs_util_1.keccak256(Buffer.concat([Buffer.from(derivedKey.slice(16, 32)), ciphertext]));
                        if (mac.toString('hex') !== json.crypto.mac) {
                            throw new Error('Key derivation failed - possibly wrong passphrase');
                        }
                        decipher = crypto.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(json.crypto.cipherparams.iv, 'hex'));
                        seed = runCipherBuffer(decipher, ciphertext);
                        return [2 /*return*/, new Wallet(seed)];
                }
            });
        });
    };
    /*
     * Import an Ethereum Pre Sale wallet.
     * Based on https://github.com/ethereum/pyethsaletool/blob/master/pyethsaletool.py
     * JSON fields: encseed, ethaddr, btcaddr, email
     *
     * @param input A JSON serialized string, or an object representing EthSale Keystore.
     * @param password The keystore password.
     */
    Wallet.fromEthSale = function (input, password) {
        var json = typeof input === 'object' ? input : JSON.parse(input);
        var encseed = Buffer.from(json.encseed, 'hex');
        // key derivation
        var derivedKey = crypto.pbkdf2Sync(password, password, 2000, 32, 'sha256').slice(0, 16);
        // seed decoding (IV is first 16 bytes)
        // NOTE: crypto (derived from openssl) when used with aes-*-cbc will handle PKCS#7 padding internally
        //       see also http://stackoverflow.com/a/31614770/4964819
        var decipher = crypto.createDecipheriv('aes-128-cbc', derivedKey, encseed.slice(0, 16));
        var seed = runCipherBuffer(decipher, encseed.slice(16));
        var wallet = new Wallet(ethereumjs_util_1.keccak256(seed));
        if (wallet.getAddress().toString('hex') !== json.ethaddr) {
            throw new Error('Decoded key mismatch - possibly wrong passphrase');
        }
        return wallet;
    };
    Object.defineProperty(Wallet.prototype, "pubKey", {
        // private getters
        /**
         * Returns the wallet's public key.
         */
        get: function () {
            if (!keyExists(this.publicKey)) {
                this.publicKey = ethereumjs_util_1.privateToPublic(this.privateKey);
            }
            return this.publicKey;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Wallet.prototype, "privKey", {
        /**
         * Returns the wallet's private key.
         */
        get: function () {
            if (!keyExists(this.privateKey)) {
                throw new Error('This is a public key only wallet');
            }
            return this.privateKey;
        },
        enumerable: false,
        configurable: true
    });
    // public instance methods
    /**
     * Returns the wallet's private key.
     *
     */
    // tslint:disable-next-line
    Wallet.prototype.getPrivateKey = function () {
        return this.privKey;
    };
    Wallet.prototype.getPrivateKeyString = function () {
        return ethereumjs_util_1.bufferToHex(this.privKey);
    };
    /**
     * Returns the wallet's public key.
     */
    // tslint:disable-next-line
    Wallet.prototype.getPublicKey = function () {
        return this.pubKey;
    };
    /**
     * Returns the wallet's public key as a "0x" prefixed hex string
     */
    Wallet.prototype.getPublicKeyString = function () {
        return ethereumjs_util_1.bufferToHex(this.getPublicKey());
    };
    /**
     * Returns the wallet's address.
     */
    Wallet.prototype.getAddress = function () {
        return ethereumjs_util_1.publicToAddress(this.pubKey);
    };
    /**
     * Returns the wallet's address as a "0x" prefixed hex string
     */
    Wallet.prototype.getAddressString = function () {
        return ethereumjs_util_1.bufferToHex(this.getAddress());
    };
    /**
     * Returns the wallet's private key as a "0x" prefixed hex string checksummed
     * according to [EIP 55](https://github.com/ethereum/EIPs/issues/55).
     */
    Wallet.prototype.getChecksumAddressString = function () {
        return ethereumjs_util_1.toChecksumAddress(this.getAddressString());
    };
    /**
     * Returns an Etherem Version 3 Keystore Format object representing the wallet
     *
     * @param password The password used to encrypt the Keystore.
     * @param opts The options for the keystore. See [its spec](https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition) for more info.
     */
    Wallet.prototype.toV3 = function (password, opts) {
        return __awaiter(this, void 0, void 0, function () {
            var v3Params, kdfParams, derivedKey, _a, cipher, ciphertext, mac;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!keyExists(this.privateKey)) {
                            throw new Error('This is a public key only wallet');
                        }
                        v3Params = mergeToV3ParamsWithDefaults(opts);
                        _a = v3Params.kdf;
                        switch (_a) {
                            case "pbkdf2" /* PBKDF */: return [3 /*break*/, 1];
                            case "scrypt" /* Scrypt */: return [3 /*break*/, 2];
                        }
                        return [3 /*break*/, 4];
                    case 1:
                        kdfParams = kdfParamsForPBKDF(v3Params);
                        derivedKey = crypto.pbkdf2Sync(Buffer.from(password), kdfParams.salt, kdfParams.c, kdfParams.dklen, 'sha256');
                        return [3 /*break*/, 5];
                    case 2:
                        kdfParams = kdfParamsForScrypt(v3Params);
                        return [4 /*yield*/, scrypt_js_1.scrypt(Buffer.from(password), kdfParams.salt, kdfParams.n, kdfParams.r, kdfParams.p, kdfParams.dklen)];
                    case 3:
                        // FIXME: support progress reporting callback
                        derivedKey = _b.sent();
                        return [3 /*break*/, 5];
                    case 4: throw new Error('Unsupported kdf');
                    case 5:
                        cipher = crypto.createCipheriv(v3Params.cipher, derivedKey.slice(0, 16), v3Params.iv);
                        if (!cipher) {
                            throw new Error('Unsupported cipher');
                        }
                        ciphertext = runCipherBuffer(cipher, this.privKey);
                        mac = ethereumjs_util_1.keccak256(Buffer.concat([Buffer.from(derivedKey.slice(16, 32)), Buffer.from(ciphertext)]));
                        return [2 /*return*/, {
                                version: 3,
                                id: uuidv4({ random: v3Params.uuid }),
                                // @ts-ignore - the official V3 keystore spec omits the address key
                                address: this.getAddress().toString('hex'),
                                crypto: {
                                    ciphertext: ciphertext.toString('hex'),
                                    cipherparams: { iv: v3Params.iv.toString('hex') },
                                    cipher: v3Params.cipher,
                                    kdf: v3Params.kdf,
                                    kdfparams: __assign(__assign({}, kdfParams), { salt: kdfParams.salt.toString('hex') }),
                                    mac: mac.toString('hex'),
                                },
                            }];
                }
            });
        });
    };
    /**
     * Return the suggested filename for V3 keystores.
     */
    Wallet.prototype.getV3Filename = function (timestamp) {
        /*
         * We want a timestamp like 2016-03-15T17-11-33.007598288Z. Date formatting
         * is a pain in Javascript, everbody knows that. We could use moment.js,
         * but decide to do it manually in order to save space.
         *
         * toJSON() returns a pretty close version, so let's use it. It is not UTC though,
         * but does it really matter?
         *
         * Alternative manual way with padding and Date fields: http://stackoverflow.com/a/7244288/4964819
         *
         */
        var ts = timestamp ? new Date(timestamp) : new Date();
        return ['UTC--', ts.toJSON().replace(/:/g, '-'), '--', this.getAddress().toString('hex')].join('');
    };
    Wallet.prototype.toV3String = function (password, opts) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = JSON).stringify;
                        return [4 /*yield*/, this.toV3(password, opts)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    return Wallet;
}());
exports.default = Wallet;
// helpers
function runCipherBuffer(cipher, data) {
    return Buffer.concat([cipher.update(data), cipher.final()]);
}
function keyExists(k) {
    return k !== undefined && k !== null;
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-wallet",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/eth-method-registry/index.js", {"./abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/eth-method-registry/abi.json","./registry-map.json":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/eth-method-registry/registry-map.json","ethjs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/eth-method-registry/index.js
      return function (require, module, exports) {
const Eth = require('ethjs')
const registryMap = require('./registry-map.json')
const abi = require('./abi')

class MethodRegistry {

  constructor (opts = {}) {
    this.provider = opts.provider ||
      new Eth.HttpProvider('https://mainnet.infura.io/eth-contract-registry')
    this.eth = new Eth(this.provider)
    const address = registryMap[opts.network || '1']

    if (!address) {
      throw new Error('No method registry found on the requested network.')
    }

    this.registry = this.eth.contract(abi).at(address)
  }

  async lookup (bytes) {
    const result = await this.registry.entries(bytes)
    return result[0]
  }

  parse (signature) {
    let name = signature.match(/^.+(?=\()/)
    
    if (name) {
      name = name[0].charAt(0).toUpperCase() + name[0].slice(1).split(/(?=[A-Z])/).join(' ')
    } else {
      name = ''
    }

    const match = signature.match(/\(.+\)/)
    let args = [];
    if (match) {
      args = match[0].slice(1, -1).split(',').map((arg) => { return {type: arg}})
    }
  
    return {
      name,
      args
    }
  }

}

module.exports = MethodRegistry

      };
    };
  }
}, {package:"eth-method-registry",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/eth-method-registry/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/through2/through2.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/readable-stream/readable-browser.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/util/util.js","xtend":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xtend/immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/through2/through2.js
      return function (require, module, exports) {
(function (process){(function (){
var Transform = require('readable-stream').Transform
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"through2",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/through2/through2.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/object-multiplex/dist/Substream.js", {"readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/object-multiplex/dist/Substream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Substream = void 0;
const readable_stream_1 = require("readable-stream");
class Substream extends readable_stream_1.Duplex {
    constructor({ parent, name }) {
        super({ objectMode: true });
        this._parent = parent;
        this._name = name;
    }
    /**
     * Explicitly sets read operations to a no-op.
     */
    _read() {
        return undefined;
    }
    /**
     * Called when data should be written to this writable stream.
     *
     * @param chunk - Arbitrary object to write
     * @param encoding - Encoding to use when writing payload
     * @param callback - Called when writing is complete or an error occurs
     */
    _write(chunk, _encoding, callback) {
        this._parent.push({
            name: this._name,
            data: chunk,
        });
        callback();
    }
}
exports.Substream = Substream;
//# sourceMappingURL=Substream.js.map
      };
    };
  }
}, {package:"@metamask/object-multiplex",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/object-multiplex/dist/Substream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/BasePostMessageStream.js", {"readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/BasePostMessageStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePostMessageStream = void 0;
const readable_stream_1 = require("readable-stream");
function noop() {
    return undefined;
}
const SYN = 'SYN';
const ACK = 'ACK';
/**
 * Abstract base class for postMessage streams.
 */
class BasePostMessageStream extends readable_stream_1.Duplex {
    constructor() {
        super({
            objectMode: true,
        });
        // Initialization flags
        this._init = false;
        this._haveSyn = false;
    }
    /**
     * Must be called at end of child constructor to initiate
     * communication with other end.
     */
    _handshake() {
        // Send synchronization message
        this._write(SYN, null, noop);
        this.cork();
    }
    _onData(data) {
        if (this._init) {
            // Forward message
            try {
                this.push(data);
            }
            catch (err) {
                this.emit('error', err);
            }
        }
        else if (data === SYN) {
            // Listen for handshake
            this._haveSyn = true;
            this._write(ACK, null, noop);
        }
        else if (data === ACK) {
            this._init = true;
            if (!this._haveSyn) {
                this._write(ACK, null, noop);
            }
            this.uncork();
        }
    }
    _read() {
        return undefined;
    }
    _write(data, _encoding, cb) {
        this._postMessage(data);
        cb();
    }
}
exports.BasePostMessageStream = BasePostMessageStream;
//# sourceMappingURL=BasePostMessageStream.js.map
      };
    };
  }
}, {package:"@metamask/post-message-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/BasePostMessageStream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/enums.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/enums.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEDICATED_WORKER_NAME = void 0;
exports.DEDICATED_WORKER_NAME = 'dedicatedWorker';
//# sourceMappingURL=enums.js.map
      };
    };
  }
}, {package:"@metamask/post-message-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/enums.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@ethereumjs/tx/dist.browser/types.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@ethereumjs/tx/dist.browser/types.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map
      };
    };
  }
}, {package:"@ethereumjs/tx",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@ethereumjs/tx/dist.browser/types.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@ethereumjs/tx/dist.browser/transaction.js", {"@ethereumjs/common":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ethereumjs/common/dist.browser/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@ethereumjs/tx/dist.browser/transaction.js
      return function (require, module, exports) {
"use strict";
/* eslint-disable no-dupe-class-members */
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var buffer_1 = require("buffer");
var ethereumjs_util_1 = require("ethereumjs-util");
var common_1 = __importDefault(require("@ethereumjs/common"));
// secp256k1n/2
var N_DIV_2 = new ethereumjs_util_1.BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
/**
 * An Ethereum transaction.
 */
var Transaction = /** @class */ (function () {
    /**
     * This constructor takes the values, validates them, assigns them and freezes the object.
     * Use the static factory methods to assist in creating a Transaction object from varying data types.
     * @note Transaction objects implement EIP155 by default. To disable it, pass in an `@ethereumjs/common` object set before EIP155 activation (i.e. before Spurious Dragon).
     */
    function Transaction(txData, opts) {
        var e_1, _a;
        var _b;
        var nonce = txData.nonce, gasPrice = txData.gasPrice, gasLimit = txData.gasLimit, to = txData.to, value = txData.value, data = txData.data, v = txData.v, r = txData.r, s = txData.s;
        this.nonce = new ethereumjs_util_1.BN(ethereumjs_util_1.toBuffer(nonce));
        this.gasPrice = new ethereumjs_util_1.BN(ethereumjs_util_1.toBuffer(gasPrice));
        this.gasLimit = new ethereumjs_util_1.BN(ethereumjs_util_1.toBuffer(gasLimit));
        this.to = to ? new ethereumjs_util_1.Address(ethereumjs_util_1.toBuffer(to)) : undefined;
        this.value = new ethereumjs_util_1.BN(ethereumjs_util_1.toBuffer(value));
        this.data = ethereumjs_util_1.toBuffer(data);
        this.v = new ethereumjs_util_1.BN(ethereumjs_util_1.toBuffer(v));
        this.r = new ethereumjs_util_1.BN(ethereumjs_util_1.toBuffer(r));
        this.s = new ethereumjs_util_1.BN(ethereumjs_util_1.toBuffer(s));
        var validateCannotExceedMaxInteger = {
            nonce: this.nonce,
            gasPrice: this.gasPrice,
            gasLimit: this.gasLimit,
            value: this.value,
            r: this.r,
            s: this.s,
        };
        try {
            for (var _c = __values(Object.entries(validateCannotExceedMaxInteger)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = __read(_d.value, 2), key = _e[0], value_1 = _e[1];
                if (value_1 && value_1.gt(ethereumjs_util_1.MAX_INTEGER)) {
                    throw new Error(key + " cannot exceed MAX_INTEGER, given " + value_1);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (opts === null || opts === void 0 ? void 0 : opts.common) {
            this.common = opts.common;
        }
        else {
            var DEFAULT_CHAIN = 'mainnet';
            this.common = new common_1.default({ chain: DEFAULT_CHAIN });
        }
        this._validateTxV(this.v);
        var freeze = (_b = opts === null || opts === void 0 ? void 0 : opts.freeze) !== null && _b !== void 0 ? _b : true;
        if (freeze) {
            Object.freeze(this);
        }
    }
    Transaction.fromTxData = function (txData, opts) {
        return new Transaction(txData, opts);
    };
    Transaction.fromRlpSerializedTx = function (serialized, opts) {
        var values = ethereumjs_util_1.rlp.decode(serialized);
        if (!Array.isArray(values)) {
            throw new Error('Invalid serialized tx input. Must be array');
        }
        return this.fromValuesArray(values, opts);
    };
    Transaction.fromValuesArray = function (values, opts) {
        if (values.length !== 6 && values.length !== 9) {
            throw new Error('Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).');
        }
        var _a = __read(values, 9), nonce = _a[0], gasPrice = _a[1], gasLimit = _a[2], to = _a[3], value = _a[4], data = _a[5], v = _a[6], r = _a[7], s = _a[8];
        return new Transaction({
            nonce: new ethereumjs_util_1.BN(nonce),
            gasPrice: new ethereumjs_util_1.BN(gasPrice),
            gasLimit: new ethereumjs_util_1.BN(gasLimit),
            to: to && to.length > 0 ? new ethereumjs_util_1.Address(to) : undefined,
            value: new ethereumjs_util_1.BN(value),
            data: data || buffer_1.Buffer.from([]),
            v: v ? new ethereumjs_util_1.BN(v) : undefined,
            r: r ? new ethereumjs_util_1.BN(r) : undefined,
            s: s ? new ethereumjs_util_1.BN(s) : undefined,
        }, opts);
    };
    /**
     * If the tx's `to` is to the creation address
     */
    Transaction.prototype.toCreationAddress = function () {
        return this.to === undefined || this.to.buf.length === 0;
    };
    /**
     * Computes a sha3-256 hash of the serialized tx
     */
    Transaction.prototype.hash = function () {
        var values = [
            ethereumjs_util_1.bnToRlp(this.nonce),
            ethereumjs_util_1.bnToRlp(this.gasPrice),
            ethereumjs_util_1.bnToRlp(this.gasLimit),
            this.to !== undefined ? this.to.buf : buffer_1.Buffer.from([]),
            ethereumjs_util_1.bnToRlp(this.value),
            this.data,
            this.v ? ethereumjs_util_1.bnToRlp(this.v) : buffer_1.Buffer.from([]),
            this.r ? ethereumjs_util_1.bnToRlp(this.r) : buffer_1.Buffer.from([]),
            this.s ? ethereumjs_util_1.bnToRlp(this.s) : buffer_1.Buffer.from([]),
        ];
        return ethereumjs_util_1.rlphash(values);
    };
    Transaction.prototype.getMessageToSign = function () {
        return this._getMessageToSign(this._unsignedTxImplementsEIP155());
    };
    Transaction.prototype.getMessageToVerifySignature = function () {
        return this._getMessageToSign(this._signedTxImplementsEIP155());
    };
    /**
     * Returns chain ID
     */
    Transaction.prototype.getChainId = function () {
        return this.common.chainId();
    };
    /**
     * Returns the sender's address
     */
    Transaction.prototype.getSenderAddress = function () {
        return new ethereumjs_util_1.Address(ethereumjs_util_1.publicToAddress(this.getSenderPublicKey()));
    };
    /**
     * Returns the public key of the sender
     */
    Transaction.prototype.getSenderPublicKey = function () {
        var msgHash = this.getMessageToVerifySignature();
        // All transaction signatures whose s-value is greater than secp256k1n/2 are considered invalid.
        if (this.common.gteHardfork('homestead') && this.s && this.s.gt(N_DIV_2)) {
            throw new Error('Invalid Signature: s-values greater than secp256k1n/2 are considered invalid');
        }
        var _a = this, v = _a.v, r = _a.r, s = _a.s;
        if (!v || !r || !s) {
            throw new Error('Missing values to derive sender public key from signed tx');
        }
        try {
            return ethereumjs_util_1.ecrecover(msgHash, v.toNumber(), ethereumjs_util_1.bnToRlp(r), ethereumjs_util_1.bnToRlp(s), this._signedTxImplementsEIP155() ? this.getChainId() : undefined);
        }
        catch (e) {
            throw new Error('Invalid Signature');
        }
    };
    /**
     * Determines if the signature is valid
     */
    Transaction.prototype.verifySignature = function () {
        try {
            // Main signature verification is done in `getSenderPublicKey()`
            var publicKey = this.getSenderPublicKey();
            return ethereumjs_util_1.unpadBuffer(publicKey).length !== 0;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Sign a transaction with a given private key.
     * Returns a new Transaction object (the original tx will not be modified).
     * Example:
     * ```typescript
     * const unsignedTx = Transaction.fromTxData(txData)
     * const signedTx = unsignedTx.sign(privKey)
     * ```
     * @param privateKey Must be 32 bytes in length.
     */
    Transaction.prototype.sign = function (privateKey) {
        if (privateKey.length !== 32) {
            throw new Error('Private key must be 32 bytes in length.');
        }
        var msgHash = this.getMessageToSign();
        // Only `v` is reassigned.
        /* eslint-disable-next-line prefer-const */
        var _a = ethereumjs_util_1.ecsign(msgHash, privateKey), v = _a.v, r = _a.r, s = _a.s;
        if (this._unsignedTxImplementsEIP155()) {
            v += this.getChainId() * 2 + 8;
        }
        var opts = {
            common: this.common,
        };
        return new Transaction({
            nonce: this.nonce,
            gasPrice: this.gasPrice,
            gasLimit: this.gasLimit,
            to: this.to,
            value: this.value,
            data: this.data,
            v: new ethereumjs_util_1.BN(v),
            r: new ethereumjs_util_1.BN(r),
            s: new ethereumjs_util_1.BN(s),
        }, opts);
    };
    /**
     * The amount of gas paid for the data in this tx
     */
    Transaction.prototype.getDataFee = function () {
        var txDataZero = this.common.param('gasPrices', 'txDataZero');
        var txDataNonZero = this.common.param('gasPrices', 'txDataNonZero');
        var cost = 0;
        for (var i = 0; i < this.data.length; i++) {
            this.data[i] === 0 ? (cost += txDataZero) : (cost += txDataNonZero);
        }
        return new ethereumjs_util_1.BN(cost);
    };
    /**
     * The minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)
     */
    Transaction.prototype.getBaseFee = function () {
        var fee = this.getDataFee().addn(this.common.param('gasPrices', 'tx'));
        if (this.common.gteHardfork('homestead') && this.toCreationAddress()) {
            fee.iaddn(this.common.param('gasPrices', 'txCreation'));
        }
        return fee;
    };
    /**
     * The up front amount that an account must have for this transaction to be valid
     */
    Transaction.prototype.getUpfrontCost = function () {
        return this.gasLimit.mul(this.gasPrice).add(this.value);
    };
    Transaction.prototype.validate = function (stringError) {
        if (stringError === void 0) { stringError = false; }
        var errors = [];
        if (!this.verifySignature()) {
            errors.push('Invalid Signature');
        }
        if (this.getBaseFee().gt(this.gasLimit)) {
            errors.push("gasLimit is too low. given " + this.gasLimit + ", need at least " + this.getBaseFee());
        }
        return stringError ? errors : errors.length === 0;
    };
    /**
     * Returns a Buffer Array of the raw Buffers of this transaction, in order.
     */
    Transaction.prototype.raw = function () {
        return [
            ethereumjs_util_1.bnToRlp(this.nonce),
            ethereumjs_util_1.bnToRlp(this.gasPrice),
            ethereumjs_util_1.bnToRlp(this.gasLimit),
            this.to !== undefined ? this.to.buf : buffer_1.Buffer.from([]),
            ethereumjs_util_1.bnToRlp(this.value),
            this.data,
            this.v !== undefined ? ethereumjs_util_1.bnToRlp(this.v) : buffer_1.Buffer.from([]),
            this.r !== undefined ? ethereumjs_util_1.bnToRlp(this.r) : buffer_1.Buffer.from([]),
            this.s !== undefined ? ethereumjs_util_1.bnToRlp(this.s) : buffer_1.Buffer.from([]),
        ];
    };
    /**
     * Returns the rlp encoding of the transaction.
     */
    Transaction.prototype.serialize = function () {
        return ethereumjs_util_1.rlp.encode(this.raw());
    };
    /**
     * Returns an object with the JSON representation of the transaction
     */
    Transaction.prototype.toJSON = function () {
        return {
            nonce: ethereumjs_util_1.bnToHex(this.nonce),
            gasPrice: ethereumjs_util_1.bnToHex(this.gasPrice),
            gasLimit: ethereumjs_util_1.bnToHex(this.gasLimit),
            to: this.to !== undefined ? this.to.toString() : undefined,
            value: ethereumjs_util_1.bnToHex(this.value),
            data: '0x' + this.data.toString('hex'),
            v: this.v !== undefined ? ethereumjs_util_1.bnToHex(this.v) : undefined,
            r: this.r !== undefined ? ethereumjs_util_1.bnToHex(this.r) : undefined,
            s: this.s !== undefined ? ethereumjs_util_1.bnToHex(this.s) : undefined,
        };
    };
    Transaction.prototype.isSigned = function () {
        var _a = this, v = _a.v, r = _a.r, s = _a.s;
        return !!v && !!r && !!s;
    };
    Transaction.prototype._unsignedTxImplementsEIP155 = function () {
        return this.common.gteHardfork('spuriousDragon');
    };
    Transaction.prototype._signedTxImplementsEIP155 = function () {
        var _a;
        if (!this.isSigned()) {
            throw Error('This transaction is not signed');
        }
        var onEIP155BlockOrLater = this.common.gteHardfork('spuriousDragon');
        // EIP155 spec:
        // If block.number >= 2,675,000 and v = CHAIN_ID * 2 + 35 or v = CHAIN_ID * 2 + 36, then when computing the hash of a transaction for purposes of signing or recovering, instead of hashing only the first six elements (i.e. nonce, gasprice, startgas, to, value, data), hash nine elements, with v replaced by CHAIN_ID, r = 0 and s = 0.
        var v = (_a = this.v) === null || _a === void 0 ? void 0 : _a.toNumber();
        var vAndChainIdMeetEIP155Conditions = v === this.getChainId() * 2 + 35 || v === this.getChainId() * 2 + 36;
        return vAndChainIdMeetEIP155Conditions && onEIP155BlockOrLater;
    };
    Transaction.prototype._getMessageToSign = function (withEIP155) {
        var values = [
            ethereumjs_util_1.bnToRlp(this.nonce),
            ethereumjs_util_1.bnToRlp(this.gasPrice),
            ethereumjs_util_1.bnToRlp(this.gasLimit),
            this.to !== undefined ? this.to.buf : buffer_1.Buffer.from([]),
            ethereumjs_util_1.bnToRlp(this.value),
            this.data,
        ];
        if (withEIP155) {
            values.push(ethereumjs_util_1.toBuffer(this.getChainId()));
            values.push(ethereumjs_util_1.unpadBuffer(ethereumjs_util_1.toBuffer(0)));
            values.push(ethereumjs_util_1.unpadBuffer(ethereumjs_util_1.toBuffer(0)));
        }
        return ethereumjs_util_1.rlphash(values);
    };
    /**
     * Validates tx's `v` value
     */
    Transaction.prototype._validateTxV = function (v) {
        if (v === undefined || v.toNumber() === 0) {
            return;
        }
        if (!this.common.gteHardfork('spuriousDragon')) {
            return;
        }
        var vInt = v.toNumber();
        if (vInt === 27 || vInt === 28) {
            return;
        }
        var isValidEIP155V = vInt === this.getChainId() * 2 + 35 || vInt === this.getChainId() * 2 + 36;
        if (!isValidEIP155V) {
            throw new Error("Incompatible EIP155-based V " + vInt + " and chain id " + this.getChainId() + ". See the Common parameter of the Transaction constructor to set the chain id.");
        }
    };
    return Transaction;
}());
exports.default = Transaction;
//# sourceMappingURL=transaction.js.map
      };
    };
  }
}, {package:"@ethereumjs/tx",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@ethereumjs/tx/dist.browser/transaction.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.production.min.js", {"@keystonehq/bc-ur-registry":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/bc-ur-registry/dist/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","hdkey":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/hdkey/lib/hdkey.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,e=require("@keystonehq/bc-ur-registry"),s=require("uuid"),a=(t=require("hdkey"))&&"object"==typeof t&&"default"in t?t.default:t,i=require("ethereumjs-util");const{RegistryType:r}=e.extend,n={ETH_SIGN_REQUEST:new r("eth-sign-request",401),ETH_SIGNATAURE:new r("eth-signature",402)},{decodeToDataItem:d,RegistryTypes:o}=e.extend;var h,u;!function(t){t[t.requestId=1]="requestId",t[t.signData=2]="signData",t[t.dataType=3]="dataType",t[t.chainId=4]="chainId",t[t.derivationPath=5]="derivationPath",t[t.address=6]="address",t[t.origin=7]="origin"}(h||(h={})),(u=exports.DataType||(exports.DataType={}))[u.transaction=1]="transaction",u[u.typedData=2]="typedData",u[u.personalMessage=3]="personalMessage",u[u.typedTransaction=4]="typedTransaction";class g extends e.RegistryItem{constructor(t){super(),this.getRegistryType=()=>n.ETH_SIGN_REQUEST,this.setupData=t=>{this.requestId=t.requestId,this.signData=t.signData,this.dataType=t.dataType,this.chainId=t.chainId,this.derivationPath=t.derivationPath,this.address=t.address,this.origin=t.origin},this.getRequestId=()=>this.requestId,this.getSignData=()=>this.signData,this.getDataType=()=>this.dataType,this.getChainId=()=>this.chainId,this.getDerivationPath=()=>this.derivationPath.getPath(),this.getSignRequestAddress=()=>this.address,this.getOrigin=()=>this.origin,this.toDataItem=()=>{const t={};this.requestId&&(t[h.requestId]=new e.DataItem(this.requestId,o.UUID.getTag())),this.address&&(t[h.address]=this.address),this.chainId&&(t[h.chainId]=this.chainId),this.origin&&(t[h.origin]=this.origin),t[h.signData]=this.signData,t[h.dataType]=this.dataType;const s=this.derivationPath.toDataItem();return s.setTag(this.derivationPath.getRegistryType().getTag()),t[h.derivationPath]=s,new e.DataItem(t)},this.setupData(t)}static constructETHRequest(t,a,i,r,n,d,o,h){const u=i.replace(/[m|M]\//,"").split("/"),c=new e.CryptoKeypath(u.map(t=>{const s=parseInt(t.replace("'",""));let a=!1;return t.endsWith("'")&&(a=!0),new e.PathComponent({index:s,hardened:a})}),Buffer.from(r,"hex"));return new g({requestId:n?Buffer.from(s.parse(n)):void 0,signData:t,dataType:a,derivationPath:c,chainId:d,address:o?Buffer.from(o.replace("0x",""),"hex"):void 0,origin:h||void 0})}}g.fromDataItem=t=>{const s=t.getData(),a=s[h.signData],i=s[h.dataType],r=e.CryptoKeypath.fromDataItem(s[h.derivationPath]),n=s[h.chainId]?s[h.chainId]:void 0,d=s[h.address]?s[h.address]:void 0,o=s[h.requestId]?s[h.requestId].getData():void 0;return new g({requestId:o,signData:a,dataType:i,chainId:n,derivationPath:r,address:d,origin:s[h.origin]?s[h.origin]:void 0})},g.fromCBOR=t=>{const e=d(t);return g.fromDataItem(e)};const{RegistryTypes:c,decodeToDataItem:I}=e.extend;var p;!function(t){t[t.requestId=1]="requestId",t[t.signature=2]="signature"}(p||(p={}));class y extends e.RegistryItem{constructor(t,s){super(),this.getRegistryType=()=>n.ETH_SIGNATAURE,this.getRequestId=()=>this.requestId,this.getSignature=()=>this.signature,this.toDataItem=()=>{const t={};return this.requestId&&(t[p.requestId]=new e.DataItem(this.requestId,c.UUID.getTag())),t[p.signature]=this.signature,new e.DataItem(t)},this.signature=t,this.requestId=s}}y.fromDataItem=t=>{const e=t.getData(),s=e[p.signature],a=e[p.requestId]?e[p.requestId].getData():void 0;return new y(s,a)},y.fromCBOR=t=>{const e=I(t);return y.fromDataItem(e)};const T=(t,e)=>{const s=a.fromExtendedKey(t).derive(e),r="0x"+i.publicToAddress(s.publicKey,!0).toString("hex");return i.toChecksumAddress(r)},{cbor:D}=e.extend;D.patchTags(Object.values(n).filter(t=>!!t.getTag()).map(t=>t.getTag())),Object.keys(e).forEach((function(t){"default"!==t&&Object.defineProperty(exports,t,{enumerable:!0,get:function(){return e[t]}})})),exports.ETHSignature=y,exports.EthSignRequest=g,exports.findHDpatfromAddress=(t,e,s,a)=>{for(let i=0;i<s;i++){const s=T(e,"M/0/"+i);if(t.toLowerCase()==s.toLowerCase())return`${a}/0/${i}`}return null},exports.generateAddressfromXpub=T;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq/bc-ur-registry-eth",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.production.min.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.development.js", {"@keystonehq/bc-ur-registry":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/bc-ur-registry/dist/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","hdkey":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/hdkey/lib/hdkey.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var bcUrRegistry = require('@keystonehq/bc-ur-registry');
var uuid = require('uuid');
var HDKey = _interopDefault(require('hdkey'));
var ethereumjsUtil = require('ethereumjs-util');

const {
  RegistryType
} = bcUrRegistry.extend;
const ExtendedRegistryTypes = {
  ETH_SIGN_REQUEST: /*#__PURE__*/new RegistryType('eth-sign-request', 401),
  ETH_SIGNATAURE: /*#__PURE__*/new RegistryType('eth-signature', 402)
};

const {
  decodeToDataItem,
  RegistryTypes
} = bcUrRegistry.extend;
var Keys;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signData"] = 2] = "signData";
  Keys[Keys["dataType"] = 3] = "dataType";
  Keys[Keys["chainId"] = 4] = "chainId";
  Keys[Keys["derivationPath"] = 5] = "derivationPath";
  Keys[Keys["address"] = 6] = "address";
  Keys[Keys["origin"] = 7] = "origin";
})(Keys || (Keys = {}));

(function (DataType) {
  DataType[DataType["transaction"] = 1] = "transaction";
  DataType[DataType["typedData"] = 2] = "typedData";
  DataType[DataType["personalMessage"] = 3] = "personalMessage";
  DataType[DataType["typedTransaction"] = 4] = "typedTransaction";
})(exports.DataType || (exports.DataType = {}));

class EthSignRequest extends bcUrRegistry.RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;

    this.setupData = args => {
      this.requestId = args.requestId;
      this.signData = args.signData;
      this.dataType = args.dataType;
      this.chainId = args.chainId;
      this.derivationPath = args.derivationPath;
      this.address = args.address;
      this.origin = args.origin;
    };

    this.getRequestId = () => this.requestId;

    this.getSignData = () => this.signData;

    this.getDataType = () => this.dataType;

    this.getChainId = () => this.chainId;

    this.getDerivationPath = () => this.derivationPath.getPath();

    this.getSignRequestAddress = () => this.address;

    this.getOrigin = () => this.origin;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes.UUID.getTag());
      }

      if (this.address) {
        map[Keys.address] = this.address;
      }

      if (this.chainId) {
        map[Keys.chainId] = this.chainId;
      }

      if (this.origin) {
        map[Keys.origin] = this.origin;
      }

      map[Keys.signData] = this.signData;
      map[Keys.dataType] = this.dataType;
      const keyPath = this.derivationPath.toDataItem();
      keyPath.setTag(this.derivationPath.getRegistryType().getTag());
      map[Keys.derivationPath] = keyPath;
      return new bcUrRegistry.DataItem(map);
    };

    this.setupData(args);
  }

  static constructETHRequest(signData, signDataType, hdPath, xfp, uuidString, chainId, address, origin) {
    const paths = hdPath.replace(/[m|M]\//, '').split('/');
    const hdpathObject = new bcUrRegistry.CryptoKeypath(paths.map(path => {
      const index = parseInt(path.replace("'", ''));
      let isHardened = false;

      if (path.endsWith("'")) {
        isHardened = true;
      }

      return new bcUrRegistry.PathComponent({
        index,
        hardened: isHardened
      });
    }), Buffer.from(xfp, 'hex'));
    return new EthSignRequest({
      requestId: uuidString ? Buffer.from(uuid.parse(uuidString)) : undefined,
      signData,
      dataType: signDataType,
      derivationPath: hdpathObject,
      chainId,
      address: address ? Buffer.from(address.replace('0x', ''), 'hex') : undefined,
      origin: origin || undefined
    });
  }

}

EthSignRequest.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signData = map[Keys.signData];
  const dataType = map[Keys.dataType];
  const derivationPath = bcUrRegistry.CryptoKeypath.fromDataItem(map[Keys.derivationPath]);
  const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;
  const address = map[Keys.address] ? map[Keys.address] : undefined;
  const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;
  const origin = map[Keys.origin] ? map[Keys.origin] : undefined;
  return new EthSignRequest({
    requestId,
    signData,
    dataType,
    chainId,
    derivationPath,
    address,
    origin
  });
};

EthSignRequest.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem(_cborPayload);
  return EthSignRequest.fromDataItem(dataItem);
};

const {
  RegistryTypes: RegistryTypes$1,
  decodeToDataItem: decodeToDataItem$1
} = bcUrRegistry.extend;
var Keys$1;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signature"] = 2] = "signature";
})(Keys$1 || (Keys$1 = {}));

class ETHSignature extends bcUrRegistry.RegistryItem {
  constructor(signature, requestId) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATAURE;

    this.getRequestId = () => this.requestId;

    this.getSignature = () => this.signature;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys$1.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes$1.UUID.getTag());
      }

      map[Keys$1.signature] = this.signature;
      return new bcUrRegistry.DataItem(map);
    };

    this.signature = signature;
    this.requestId = requestId;
  }

}

ETHSignature.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signature = map[Keys$1.signature];
  const requestId = map[Keys$1.requestId] ? map[Keys$1.requestId].getData() : undefined;
  return new ETHSignature(signature, requestId);
};

ETHSignature.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$1(_cborPayload);
  return ETHSignature.fromDataItem(dataItem);
};

// @ts-ignore
const generateAddressfromXpub = (xpub, derivePath) => {
  // @ts-ignore
  const node = HDKey.fromExtendedKey(xpub);
  const publicKey = node.derive(derivePath);
  const address = '0x' + ethereumjsUtil.publicToAddress(publicKey.publicKey, true).toString('hex');
  return ethereumjsUtil.toChecksumAddress(address);
};
const findHDpatfromAddress = (address, xpub, numberLimit, rootPath) => {
  for (let i = 0; i < numberLimit; i++) {
    const path = `M/0/${i}`;
    const caculateAddress = generateAddressfromXpub(xpub, path);

    if (address.toLowerCase() == caculateAddress.toLowerCase()) {
      return `${rootPath}/0/${i}`;
    }
  }

  return null;
};

const {
  cbor
} = bcUrRegistry.extend;
cbor.patchTags(Object.values(ExtendedRegistryTypes).filter(rt => !!rt.getTag()).map(rt => rt.getTag()));

Object.keys(bcUrRegistry).forEach(function (k) {
    if (k !== 'default') Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
            return bcUrRegistry[k];
        }
    });
});
exports.ETHSignature = ETHSignature;
exports.EthSignRequest = EthSignRequest;
exports.findHDpatfromAddress = findHDpatfromAddress;
exports.generateAddressfromXpub = generateAddressfromXpub;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq/bc-ur-registry-eth",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.development.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-peer-monitor/src/utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-peer-monitor/src/utils.js
      return function (require, module, exports) {
'use strict'

// Set utils
const difference = (set1, set2) => new Set([...set1].filter(x => !set2.has(x)))

// Poll utils
const sleep = (time) => new Promise(resolve => setTimeout(resolve, time))

const runWithDelay = async (func, topic, interval) => {
  const peers = await func(topic)
  await sleep(interval)
  return peers
}

module.exports.runWithDelay = runWithDelay
module.exports.difference = difference

      };
    };
  }
}, {package:"ipfs-pubsub-peer-monitor",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-peer-monitor/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-reduce/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/p-reduce/index.js
      return function (require, module, exports) {
'use strict';
module.exports = (iterable, reducer, initVal) => new Promise((resolve, reject) => {
	const iterator = iterable[Symbol.iterator]();
	let i = 0;

	const next = total => {
		const el = iterator.next();

		if (el.done) {
			resolve(total);
			return;
		}

		Promise.all([total, el.value])
			.then(value => {
				next(reducer(value[0], value[1], i++));
			})
			.catch(reject);
	};

	next(initVal);
});

      };
    };
  }
}, {package:"p-reduce",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-reduce/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-series/node_modules/@sindresorhus/is/dist/index.js", {"../../../../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/util/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/p-series/node_modules/@sindresorhus/is/dist/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util = require("util");
const toString = Object.prototype.toString;
const isOfType = (type) => (value) => typeof value === type; // tslint:disable-line:strict-type-predicates
const getObjectType = (value) => {
    const objectName = toString.call(value).slice(8, -1);
    if (objectName) {
        return objectName;
    }
    return null;
};
const isObjectOfType = (typeName) => (value) => {
    return getObjectType(value) === typeName;
};
function is(value) {
    if (value === null) {
        return "null" /* null */;
    }
    if (value === true || value === false) {
        return "boolean" /* boolean */;
    }
    const type = typeof value;
    if (type === 'undefined') {
        return "undefined" /* undefined */;
    }
    if (type === 'string') {
        return "string" /* string */;
    }
    if (type === 'number') {
        return "number" /* number */;
    }
    if (type === 'symbol') {
        return "symbol" /* symbol */;
    }
    if (is.function_(value)) {
        return "Function" /* Function */;
    }
    if (Array.isArray(value)) {
        return "Array" /* Array */;
    }
    if (Buffer.isBuffer(value)) {
        return "Buffer" /* Buffer */;
    }
    const tagType = getObjectType(value);
    if (tagType) {
        return tagType;
    }
    if (value instanceof String || value instanceof Boolean || value instanceof Number) {
        throw new TypeError('Please don\'t use object wrappers for primitive types');
    }
    return "Object" /* Object */;
}
(function (is) {
    const isObject = (value) => typeof value === 'object';
    // tslint:disable:variable-name
    is.undefined = isOfType('undefined');
    is.string = isOfType('string');
    is.number = isOfType('number');
    is.function_ = isOfType('function');
    is.null_ = (value) => value === null;
    is.class_ = (value) => is.function_(value) && value.toString().startsWith('class ');
    is.boolean = (value) => value === true || value === false;
    // tslint:enable:variable-name
    is.symbol = isOfType('symbol');
    is.array = Array.isArray;
    is.buffer = Buffer.isBuffer;
    is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
    is.object = (value) => !is.nullOrUndefined(value) && (is.function_(value) || isObject(value));
    is.iterable = (value) => !is.nullOrUndefined(value) && is.function_(value[Symbol.iterator]);
    is.generator = (value) => is.iterable(value) && is.function_(value.next) && is.function_(value.throw);
    is.nativePromise = isObjectOfType("Promise" /* Promise */);
    const hasPromiseAPI = (value) => !is.null_(value) &&
        isObject(value) &&
        is.function_(value.then) &&
        is.function_(value.catch);
    is.promise = (value) => is.nativePromise(value) || hasPromiseAPI(value);
    // TODO: Change to use `isObjectOfType` once Node.js 6 or higher is targeted
    const isFunctionOfType = (type) => (value) => is.function_(value) && is.function_(value.constructor) && value.constructor.name === type;
    is.generatorFunction = isFunctionOfType('GeneratorFunction');
    is.asyncFunction = isFunctionOfType('AsyncFunction');
    is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty('prototype');
    is.regExp = isObjectOfType("RegExp" /* RegExp */);
    is.date = isObjectOfType("Date" /* Date */);
    is.error = isObjectOfType("Error" /* Error */);
    is.map = isObjectOfType("Map" /* Map */);
    is.set = isObjectOfType("Set" /* Set */);
    is.weakMap = isObjectOfType("WeakMap" /* WeakMap */);
    is.weakSet = isObjectOfType("WeakSet" /* WeakSet */);
    is.int8Array = isObjectOfType("Int8Array" /* Int8Array */);
    is.uint8Array = isObjectOfType("Uint8Array" /* Uint8Array */);
    is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray" /* Uint8ClampedArray */);
    is.int16Array = isObjectOfType("Int16Array" /* Int16Array */);
    is.uint16Array = isObjectOfType("Uint16Array" /* Uint16Array */);
    is.int32Array = isObjectOfType("Int32Array" /* Int32Array */);
    is.uint32Array = isObjectOfType("Uint32Array" /* Uint32Array */);
    is.float32Array = isObjectOfType("Float32Array" /* Float32Array */);
    is.float64Array = isObjectOfType("Float64Array" /* Float64Array */);
    is.arrayBuffer = isObjectOfType("ArrayBuffer" /* ArrayBuffer */);
    is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer" /* SharedArrayBuffer */);
    is.dataView = isObjectOfType("DataView" /* DataView */);
    // TODO: Remove `object` checks when targeting ES2015 or higher
    // See `Notes`: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf
    is.directInstanceOf = (instance, klass) => is.object(instance) && is.object(klass) && Object.getPrototypeOf(instance) === klass.prototype;
    is.truthy = (value) => Boolean(value);
    is.falsy = (value) => !value;
    is.nan = (value) => Number.isNaN(value);
    const primitiveTypes = new Set([
        'undefined',
        'string',
        'number',
        'boolean',
        'symbol'
    ]);
    is.primitive = (value) => is.null_(value) || primitiveTypes.has(typeof value);
    is.integer = (value) => Number.isInteger(value);
    is.safeInteger = (value) => Number.isSafeInteger(value);
    is.plainObject = (value) => {
        // From: https://github.com/sindresorhus/is-plain-obj/blob/master/index.js
        let prototype;
        return getObjectType(value) === "Object" /* Object */ &&
            (prototype = Object.getPrototypeOf(value), prototype === null || // tslint:disable-line:ban-comma-operator
                prototype === Object.getPrototypeOf({}));
    };
    const typedArrayTypes = new Set([
        "Int8Array" /* Int8Array */,
        "Uint8Array" /* Uint8Array */,
        "Uint8ClampedArray" /* Uint8ClampedArray */,
        "Int16Array" /* Int16Array */,
        "Uint16Array" /* Uint16Array */,
        "Int32Array" /* Int32Array */,
        "Uint32Array" /* Uint32Array */,
        "Float32Array" /* Float32Array */,
        "Float64Array" /* Float64Array */
    ]);
    is.typedArray = (value) => {
        const objectType = getObjectType(value);
        if (objectType === null) {
            return false;
        }
        return typedArrayTypes.has(objectType);
    };
    const isValidLength = (value) => is.safeInteger(value) && value > -1;
    is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
    is.inRange = (value, range) => {
        if (is.number(range)) {
            return value >= Math.min(0, range) && value <= Math.max(range, 0);
        }
        if (is.array(range) && range.length === 2) {
            // TODO: Use spread operator here when targeting Node.js 6 or higher
            return value >= Math.min.apply(null, range) && value <= Math.max.apply(null, range);
        }
        throw new TypeError(`Invalid range: ${util.inspect(range)}`);
    };
    const NODE_TYPE_ELEMENT = 1;
    const DOM_PROPERTIES_TO_CHECK = [
        'innerHTML',
        'ownerDocument',
        'style',
        'attributes',
        'nodeValue'
    ];
    is.domElement = (value) => is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) &&
        !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every(property => property in value);
    is.nodeStream = (value) => !is.nullOrUndefined(value) && isObject(value) && is.function_(value.pipe);
    is.infinite = (value) => value === Infinity || value === -Infinity;
    const isAbsoluteMod2 = (value) => (rem) => is.integer(rem) && Math.abs(rem % 2) === value;
    is.even = isAbsoluteMod2(0);
    is.odd = isAbsoluteMod2(1);
    const isWhiteSpaceString = (value) => is.string(value) && /\S/.test(value) === false;
    const isEmptyStringOrArray = (value) => (is.string(value) || is.array(value)) && value.length === 0;
    const isEmptyObject = (value) => !is.map(value) && !is.set(value) && is.object(value) && Object.keys(value).length === 0;
    const isEmptyMapOrSet = (value) => (is.map(value) || is.set(value)) && value.size === 0;
    is.empty = (value) => is.falsy(value) || isEmptyStringOrArray(value) || isEmptyObject(value) || isEmptyMapOrSet(value);
    is.emptyOrWhitespace = (value) => is.empty(value) || isWhiteSpaceString(value);
    const predicateOnArray = (method, predicate, args) => {
        // `args` is the calling function's "arguments object".
        // We have to do it this way to keep node v4 support.
        // So here we convert it to an array and slice off the first item.
        const values = Array.prototype.slice.call(args, 1);
        if (is.function_(predicate) === false) {
            throw new TypeError(`Invalid predicate: ${util.inspect(predicate)}`);
        }
        if (values.length === 0) {
            throw new TypeError('Invalid number of values');
        }
        return method.call(values, predicate);
    };
    function any(predicate) {
        return predicateOnArray(Array.prototype.some, predicate, arguments);
    }
    is.any = any;
    function all(predicate) {
        return predicateOnArray(Array.prototype.every, predicate, arguments);
    }
    is.all = all;
    // tslint:enable:only-arrow-functions no-function-expression
})(is || (is = {}));
// Some few keywords are reserved, but we'll populate them for Node.js users
// See https://github.com/Microsoft/TypeScript/issues/2536
Object.defineProperties(is, {
    class: {
        value: is.class_
    },
    function: {
        value: is.function_
    },
    null: {
        value: is.null_
    }
});
exports.default = is;
// For CommonJS default export support
module.exports = is;
module.exports.default = is;

}).call(this)}).call(this,{"isBuffer":require("../../../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"@sindresorhus/is",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-series/node_modules/@sindresorhus/is/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/difference.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/difference.js
      return function (require, module, exports) {
'use strict'

function difference (a, b, key) {
  // Indices for quick lookups
  var processed = {}
  var existing = {}

  // Create an index of the first collection
  var addToIndex = e => (existing[key ? e[key] : e] = true)
  a.forEach(addToIndex)

  // Reduce to entries that are not in the first collection
  var reducer = (res, entry) => {
    var isInFirst = existing[key ? entry[key] : entry] !== undefined
    var hasBeenProcessed = processed[key ? entry[key] : entry] !== undefined
    if (!isInFirst && !hasBeenProcessed) {
      res.push(entry)
      processed[key ? entry[key] : entry] = true
    }
    return res
  }

  return b.reduce(reducer, [])
}

module.exports = difference

      };
    };
  }
}, {package:"ipfs-log",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/difference.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/find-uniques.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/find-uniques.js
      return function (require, module, exports) {
'use strict'

function findUniques (value, key) {
  // Create an index of the collection
  let uniques = {}
  var get = e => uniques[e]
  var addToIndex = e => (uniques[key ? e[key] : e] = e)
  value.forEach(addToIndex)
  return Object.keys(uniques).map(get)
}

module.exports = findUniques

      };
    };
  }
}, {package:"ipfs-log",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/find-uniques.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/is-defined.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/is-defined.js
      return function (require, module, exports) {
'use strict'

const isDefined = (arg) => arg !== undefined && arg !== null

module.exports = isDefined

      };
    };
  }
}, {package:"ipfs-log",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/is-defined.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry-io.js", {"./entry":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry.js","p-map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/node_modules/p-map/index.js","p-whilst":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-whilst/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry-io.js
      return function (require, module, exports) {
'use strict'

const pWhilst = require('p-whilst')
const pMap = require('p-map')
const Entry = require('./entry')

class EntryIO {
  /**
   * Fetch log entries in parallel.
   * @param {IPFS} ipfs An IPFS instance
   * @param {string|Array<string>} hashes hashes of the entries to fetch
   * @param {Object} options
   * @param {number} options.length How many entries to fetch
   * @param {Array<Entry>} options.exclude Entries to not fetch
   * @param {number} options.concurrency Max concurrent fetch operations
   * @param {number} options.timeout Maximum time to wait for each fetch operation, in ms
   * @param {function(hash, entry, parent, depth)} options.onProgressCallback
   * @returns {Promise<Array<Entry>>}
   */
  static async fetchParallel (ipfs, hashes,
    { length = -1, exclude = [], concurrency = null, timeout, onProgressCallback } = {}) {
    const fetchOne = (hash) => EntryIO.fetchAll(ipfs, hash,
      { length, exclude, timeout, onProgressCallback })
    const getHashes = e => e.hash
    const uniquelyConcatArrays = (arr1, arr2) => {
      // Add any new entries to arr1
      const entryHashes = arr1.map(getHashes)
      arr2.forEach(entry => {
        if (entryHashes.indexOf(entry.hash) === -1) arr1.push(entry)
      })
      return arr1
    }
    const flatten = (arr) => arr.reduce(uniquelyConcatArrays, [])
    const hashesToFetch = Array.isArray(hashes) ? hashes.slice() : [hashes]
    concurrency = Math.max(concurrency || hashesToFetch.length, 1)

    const entries = await pMap(hashesToFetch, fetchOne, { concurrency: concurrency })
    // Flatten the results and get unique vals
    return flatten(entries)
  }

  /**
   * Fetch log entries sequentially.
   * @param {IPFS} ipfs An IPFS instance
   * @param {string|Array<string>} hashes hashes of the entries to fetch
   * @param {Object} options
   * @param {number} options.length How many entries to fetch
   * @param {Array<Entry>} options.exclude Entries to not fetch
   * @param {number} options.concurrency Max concurrent fetch operations
   * @param {number} options.timeout Maximum time to wait for each fetch operation, in ms
   * @param {function(hash, entry, parent, depth)} options.onProgressCallback
   * @returns {Promise<Array<Entry>>}
   */
  static async fetchAll (ipfs, hashes,
    { length = -1, exclude = [], timeout = null, onProgressCallback }) {
    let result = []
    let cache = {}
    let loadingQueue = Array.isArray(hashes)
      ? hashes.slice()
      : [hashes]

    // Add a hash to the loading queue
    const addToLoadingQueue = e => loadingQueue.push(e)

    // Add entries that we don't need to fetch to the "cache"
    exclude = exclude && Array.isArray(exclude) ? exclude : []
    var addToExcludeCache = e => {
      if (Entry.isEntry(e)) {
        result.push(e)
        cache[e.hash] = e
      }
    }
    exclude.forEach(addToExcludeCache)

    const shouldFetchMore = () => {
      return loadingQueue.length > 0 &&
          (result.length < length || length < 0)
    }

    const fetchEntry = () => {
      const hash = loadingQueue.shift()

      if (cache[hash]) {
        return Promise.resolve()
      }

      return new Promise(async (resolve, reject) => {
        // Resolve the promise after a timeout (if given) in order to
        // not get stuck loading a block that is unreachable
        const timer = timeout
          ? setTimeout(() => {
            console.warn(`Warning: Couldn't fetch entry '${hash}', request timed out (${timeout}ms)`)
            resolve()
          }, timeout)
          : null

        const addToResults = (entry) => {
          if (Entry.isEntry(entry)) {
            entry.next.forEach(addToLoadingQueue)
            result.push(entry)
            cache[hash] = entry
            if (onProgressCallback) {
              onProgressCallback(hash, entry, result.length)
            }
          }
        }

        // Load the entry
        try {
          const entry = await Entry.fromMultihash(ipfs, hash)
          addToResults(entry)
          resolve()
        } catch (e) {
          reject(e)
        } finally {
          clearTimeout(timer)
        }
      })
    }

    await pWhilst(shouldFetchMore, fetchEntry)
    return result
  }
}

module.exports = EntryIO

      };
    };
  }
}, {package:"ipfs-log",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry-io.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-stringify-deterministic/lib/index.js", {"./defaults":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-stringify-deterministic/lib/defaults.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-stringify-deterministic/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/json-stringify-deterministic/lib/index.js
      return function (require, module, exports) {
'use strict'

const DEFAULTS = require('./defaults')
const isFunction = require('./util').isFunction
const isBoolean = require('./util').isBoolean
const isObject = require('./util').isObject
const isArray = require('./util').isArray
const isRegex = require('./util').isRegex
const assign = require('./util').assign
const keys = require('./util').keys

function serialize (obj) {
  if (obj === null || obj === undefined) return obj
  if (isRegex(obj)) return obj.toString()
  return obj.toJSON ? obj.toJSON() : obj
}

function stringifyDeterministic (obj, opts) {
  opts = opts || assign({}, DEFAULTS)

  if (isFunction(opts)) opts = { compare: opts }

  const space = opts.space || DEFAULTS.space
  const cycles = isBoolean(opts.cycles) ? opts.cycles : DEFAULTS.cycles
  const replacer = opts.replacer || DEFAULTS.replacer
  const stringify = opts.stringify || DEFAULTS.stringify

  const compare = opts.compare && (function (f) {
    return function (node) {
      return function (a, b) {
        const aobj = {key: a, value: node[a]}
        const bobj = {key: b, value: node[b]}
        return f(aobj, bobj)
      }
    }
  })(opts.compare)

  // Detect circular structure in obj and raise error efficiently.
  if (!cycles) stringify(obj)

  const seen = []

  return (function _deterministic (parent, key, node, level) {
    const indent = space ? ('\n' + new Array(level + 1).join(space)) : ''
    const colonSeparator = space ? ': ' : ':'

    node = serialize(node)
    node = replacer.call(parent, key, node)

    if (node === undefined) return

    if (!isObject(node) || node === null) return stringify(node)

    if (isArray(node)) {
      const out = []
      for (let i = 0; i < node.length; i++) {
        const item = _deterministic(node, i, node[i], level + 1) || stringify(null)
        out.push(indent + space + item)
      }
      return '[' + out.join(',') + indent + ']'
    } else {
      if (cycles) {
        if (seen.indexOf(node) !== -1) {
          return stringify('[Circular]')
        } else {
          seen.push(node)
        }
      }

      const nodeKeys = keys(node).sort(compare && compare(node))
      const out = []
      for (let i = 0; i < nodeKeys.length; i++) {
        const key = nodeKeys[i]
        const value = _deterministic(node, key, node[key], level + 1)

        if (!value) continue

        const keyValue = stringify(key) + colonSeparator + value
        out.push(indent + space + keyValue)
      }
      seen.splice(seen.indexOf(node), 1)
      return '{' + out.join(',') + indent + '}'
    }
  })({ '': obj }, '', obj, 0)
}

module.exports = stringifyDeterministic

      };
    };
  }
}, {package:"json-stringify-deterministic",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-stringify-deterministic/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/uport-base64url/dist/base64url.js", {"./pad-string":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uport-base64url/dist/pad-string.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/uport-base64url/dist/base64url.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var buffer_1 = require("buffer");
var pad_string_1 = require("./pad-string");
function encode(input, encoding) {
    if (encoding === void 0) { encoding = "utf8"; }
    if (buffer_1.Buffer.isBuffer(input)) {
        return fromBase64(input.toString("base64"));
    }
    return fromBase64(buffer_1.Buffer.from(input, encoding).toString("base64"));
}
;
function decode(base64url, encoding) {
    if (encoding === void 0) { encoding = "utf8"; }
    return buffer_1.Buffer.from(toBase64(base64url), "base64").toString(encoding);
}
function toBase64(base64url) {
    base64url = base64url.toString();
    return pad_string_1.default(base64url)
        .replace(/\-/g, "+")
        .replace(/_/g, "/");
}
function fromBase64(base64) {
    return base64
        .replace(/=/g, "")
        .replace(/\+/g, "-")
        .replace(/\//g, "_");
}
function toBuffer(base64url) {
    return buffer_1.Buffer.from(toBase64(base64url), "base64");
}
var base64url = encode;
base64url.encode = encode;
base64url.decode = decode;
base64url.toBase64 = toBase64;
base64url.fromBase64 = fromBase64;
base64url.toBuffer = toBuffer;
exports.default = base64url;

      };
    };
  }
}, {package:"uport-base64url",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uport-base64url/dist/base64url.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/identity.js", {"./is-defined":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/is-defined.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/identity.js
      return function (require, module, exports) {
'use strict'
const isDefined = require('./is-defined')

class Identity {
  constructor (id, publicKey, idSignature, pubKeyIdSignature, type, provider) {
    if (!isDefined(id)) {
      throw new Error('Identity id is required')
    }

    if (!isDefined(publicKey)) {
      throw new Error('Invalid public key')
    }

    if (!isDefined(idSignature)) {
      throw new Error('Signature of the id (idSignature) is required')
    }

    if (!isDefined(pubKeyIdSignature)) {
      throw new Error('Signature of (publicKey + idSignature) is required')
    }

    if (!isDefined(type)) {
      throw new Error('Identity type is required')
    }

    if (!isDefined(provider)) {
      throw new Error('Identity provider is required')
    }

    this._id = id
    this._publicKey = publicKey
    this._signatures = Object.assign({}, { id: idSignature }, { publicKey: pubKeyIdSignature })
    this._type = type
    this._provider = provider
  }

  /**
  * This is only used as a fallback to the clock id when necessary
  * @return {string} public key hex encoded
  */
  get id () {
    return this._id
  }

  get publicKey () {
    return this._publicKey
  }

  get signatures () {
    return this._signatures
  }

  get type () {
    return this._type
  }

  get provider () {
    return this._provider
  }

  toJSON () {
    return {
      id: this._id,
      publicKey: this._publicKey,
      signatures: this._signatures,
      type: this._type
    }
  }
}

module.exports = Identity

      };
    };
  }
}, {package:"orbit-db-identity-provider",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/identity.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/orbit-db-identity-provider.js", {"./identity-provider-interface":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/identity-provider-interface.js","orbit-db-keystore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/index-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/orbit-db-identity-provider.js
      return function (require, module, exports) {
'use strict'
const IdentityProvider = require('./identity-provider-interface')
const Keystore = require('orbit-db-keystore')
const signingKeysPath = './orbitdb/identity/signingkeys'
const type = 'orbitdb'

class OrbitDBIdentityProvider extends IdentityProvider {
  constructor (options = {}) {
    super()
    this._keystore = options.keystore || Keystore.create(options.signingKeysPath || signingKeysPath)
  }

  // Returns the type of the identity provider
  static get type () { return type }

  async getId (options = {}) {
    const id = options.id
    if (!id) {
      throw new Error('id is required')
    }

    const keystore = this._keystore
    const key = await keystore.getKey(id) || await keystore.createKey(id)
    return key.public.marshal().toString('hex')
  }

  async signIdentity (data, options = {}) {
    const id = options.id
    if (!id) {
      throw new Error('id is required')
    }
    const keystore = this._keystore
    const key = await keystore.getKey(id)
    if (!key) {
      throw new Error(`Signing key for '${id}' not found`)
    }

    return keystore.sign(key, data)
  }

  static async verifyIdentity (identity) {
    // Verify that identity was signed by the ID
    return Keystore.verify(
      identity.signatures.publicKey,
      identity.id,
      identity.publicKey + identity.signatures.id
    )
  }
}

module.exports = OrbitDBIdentityProvider

      };
    };
  }
}, {package:"orbit-db-identity-provider",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/orbit-db-identity-provider.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/dist/base64url.js", {"./pad-string":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/dist/pad-string.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/dist/base64url.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var pad_string_1 = require("./pad-string");
function encode(input, encoding) {
    if (encoding === void 0) { encoding = "utf8"; }
    if (Buffer.isBuffer(input)) {
        return fromBase64(input.toString("base64"));
    }
    return fromBase64(Buffer.from(input, encoding).toString("base64"));
}
;
function decode(base64url, encoding) {
    if (encoding === void 0) { encoding = "utf8"; }
    return Buffer.from(toBase64(base64url), "base64").toString(encoding);
}
function toBase64(base64url) {
    base64url = base64url.toString();
    return pad_string_1.default(base64url)
        .replace(/\-/g, "+")
        .replace(/_/g, "/");
}
function fromBase64(base64) {
    return base64
        .replace(/=/g, "")
        .replace(/\+/g, "-")
        .replace(/\//g, "_");
}
function toBuffer(base64url) {
    return Buffer.from(toBase64(base64url), "base64");
}
var base64url = encode;
base64url.encode = encode;
base64url.decode = decode;
base64url.toBase64 = toBase64;
base64url.fromBase64 = fromBase64;
base64url.toBuffer = toBuffer;
exports.default = base64url;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"base64url",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/dist/base64url.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/SimpleSigner.js", {"./Digest":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/Digest.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","elliptic":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/elliptic/lib/elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/SimpleSigner.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _elliptic = require("elliptic");

var _Digest = require("./Digest");

var secp256k1 = new _elliptic.ec('secp256k1');

function leftpad(data) {
  var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;
  if (data.length === size) return data;
  return '0'.repeat(size - data.length) + data;
}
/**
*  The SimpleSigner returns a configured function for signing data. It also defines
*  an interface that you can also implement yourself and use in our other modules.
*
*  @example
*  const signer = SimpleSigner(process.env.PRIVATE_KEY)
*  signer(data, (err, signature) => {
*    ...
*  })
*
*  @param    {String}         hexPrivateKey    a hex encoded private key
*  @return   {Function}                     a configured signer function
*/


function SimpleSigner(hexPrivateKey) {
  var privateKey = secp256k1.keyFromPrivate(hexPrivateKey);
  return (
    /*#__PURE__*/
    function () {
      var _ref = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(data) {
        var _privateKey$sign, r, s, recoveryParam;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _privateKey$sign = privateKey.sign((0, _Digest.sha256)(data)), r = _privateKey$sign.r, s = _privateKey$sign.s, recoveryParam = _privateKey$sign.recoveryParam;
                return _context.abrupt("return", {
                  r: leftpad(r.toString('hex')),
                  s: leftpad(s.toString('hex')),
                  recoveryParam: recoveryParam
                });

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }()
  );
}

module.exports = SimpleSigner;
      };
    };
  }
}, {package:"did-jwt",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/SimpleSigner.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/NaclSigner.js", {"@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","tweetnacl":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/tweetnacl/nacl-fast.js","tweetnacl-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/tweetnacl-util/nacl-util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/NaclSigner.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _tweetnacl = _interopRequireDefault(require("tweetnacl"));

var _tweetnaclUtil = _interopRequireDefault(require("tweetnacl-util"));

function encodeBase64Url(data) {
  return _tweetnaclUtil.default.encodeBase64(data).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}
/**
*  The NaclSigner returns a configured function for signing data using the Ed25519 algorithm. It also defines
*  an interface that you can also implement yourself and use in our other modules.
*
*  The signing function itself takes the data as a string parameter and returls a base64Url encoded signature
*
*  @example
*  const signer = NaclSigner(process.env.PRIVATE_KEY)
*  signer(data, (err, signature) => {
*    ...
*  })
*
*  @param    {String}         base64PrivateKey    a 64 byte base64 encoded private key
*  @return   {Function}                     a configured signer function
*/


function NaclSigner(base64PrivateKey) {
  var privateKey = _tweetnaclUtil.default.decodeBase64(base64PrivateKey);

  return (
    /*#__PURE__*/
    function () {
      var _ref = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(data) {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", encodeBase64Url(_tweetnacl.default.sign.detached(_tweetnaclUtil.default.decodeUTF8(data), privateKey)));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }()
  );
}

module.exports = NaclSigner;
      };
    };
  }
}, {package:"did-jwt",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/NaclSigner.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/JWT.js", {"./SignerAlgorithm":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/SignerAlgorithm.js","./VerifierAlgorithm":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/VerifierAlgorithm.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/helpers/objectSpread":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/objectSpread.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","base64url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/index.js","did-resolver":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-resolver/lib/resolver.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/JWT.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeDID = normalizeDID;
exports.decodeJWT = decodeJWT;
exports.createJWT = createJWT;
exports.verifyJWT = verifyJWT;
exports.resolveAuthenticator = resolveAuthenticator;
exports.default = exports.IAT_SKEW = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _VerifierAlgorithm = _interopRequireDefault(require("./VerifierAlgorithm"));

var _SignerAlgorithm = _interopRequireDefault(require("./SignerAlgorithm"));

var _base64url = _interopRequireDefault(require("base64url"));

var _didResolver = _interopRequireDefault(require("did-resolver"));

var SUPPORTED_PUBLIC_KEY_TYPES = {
  ES256K: ['Secp256k1VerificationKey2018', 'Secp256k1SignatureVerificationKey2018', 'EcdsaPublicKeySecp256k1'],
  'ES256K-R': ['Secp256k1VerificationKey2018', 'Secp256k1SignatureVerificationKey2018', 'EcdsaPublicKeySecp256k1'],
  'Ed25519': ['ED25519SignatureVerification']
};
var JOSE_HEADER = {
  typ: 'JWT'
};
var defaultAlg = 'ES256K';

function encodeSection(data) {
  return _base64url.default.encode(JSON.stringify(data));
}

var IAT_SKEW = 300;
/**  @module did-jwt/JWT */

exports.IAT_SKEW = IAT_SKEW;

function isMNID(id) {
  return id.match(/^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/);
}

function isDIDOrMNID(mnidOrDid) {
  return mnidOrDid && (mnidOrDid.match(/^did:/) || isMNID(mnidOrDid));
}

function normalizeDID(mnidOrDid) {
  if (mnidOrDid.match(/^did:/)) return mnidOrDid; // Backwards compatibility

  if (isMNID(mnidOrDid)) return "did:uport:".concat(mnidOrDid);
  throw new Error("Not a valid DID '".concat(mnidOrDid, "'"));
}
/**
*  Decodes a JWT and returns an object representing the payload
*
*  @example
*  decodeJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpYXQiOjE1MjU5Mjc1MTcsImF1ZCI6ImRpZDp1cG9ydDoyb3NuZko0V3k3TEJBbTJuUEJYaXJlMVdmUW43NVJyVjZUcyIsImV4cCI6MTU1NzQ2MzQyMSwibmFtZSI6InVQb3J0IERldmVsb3BlciIsImlzcyI6ImRpZDp1cG9ydDoyb3NuZko0V3k3TEJBbTJuUEJYaXJlMVdmUW43NVJyVjZUcyJ9.R7owbvNZoL4ti5ec-Kpktb0datw9Y-FshHsF5R7cXuKaiGlQz1dcOOXbXTOb-wg7-30CDfchFERR6Yc8F61ymw')
*
*  @param    {String}            jwt                a JSON Web Token to verify
*  @return   {Object}                               a JS object representing the decoded JWT
*/


function decodeJWT(jwt) {
  if (!jwt) throw new Error('no JWT passed into decodeJWT');
  var parts = jwt.match(/^([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);

  if (parts) {
    return {
      header: JSON.parse(_base64url.default.decode(parts[1])),
      payload: JSON.parse(_base64url.default.decode(parts[2])),
      signature: parts[3],
      data: "".concat(parts[1], ".").concat(parts[2])
    };
  }

  throw new Error('Incorrect format JWT');
}
/**
*  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is over.
*
*  @example
*  const signer = SimpleSigner(process.env.PRIVATE_KEY)
*  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {
*      ...
*  })
*
*  @param    {Object}            payload            payload object
*  @param    {Object}            [options]           an unsigned credential object
*  @param    {String}            options.issuer      The DID of the issuer (signer) of JWT
*  @param    {String}            options.alg         The JWT signing algorithm to use. Supports: [ES256K, ES256K-R, Ed25519], Defaults to: ES256K
*  @param    {SimpleSigner}      options.signer      a signer, reference our SimpleSigner.js
*  @return   {Promise<Object, Error>}               a promise which resolves with a signed JSON Web Token or rejects with an error
*/


function createJWT(_x, _x2) {
  return _createJWT.apply(this, arguments);
}
/**
*  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,
*  and the did doc of the issuer of the JWT.
*
*  @example
*  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}).then(obj => {
*      const did = obj.did // DID of signer
*      const payload = obj.payload
*      const doc = obj.doc // DID Document of signer
*      const jwt = obj.jwt
*      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT
*      ...
*  })
*
*  @param    {String}            jwt                a JSON Web Token to verify
*  @param    {Object}            [options]           an unsigned credential object
*  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)
*  @param    {String}            options.audience    DID of the recipient of the JWT
*  @param    {String}            options.callbackUrl callback url in JWT
*  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error
*/


function _createJWT() {
  _createJWT = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(payload, _ref) {
    var issuer, signer, alg, expiresIn, header, timestamps, signingInput, jwtSigner, signature;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            issuer = _ref.issuer, signer = _ref.signer, alg = _ref.alg, expiresIn = _ref.expiresIn;

            if (signer) {
              _context.next = 3;
              break;
            }

            throw new Error('No Signer functionality has been configured');

          case 3:
            if (issuer) {
              _context.next = 5;
              break;
            }

            throw new Error('No issuing DID has been configured');

          case 5:
            header = (0, _objectSpread2.default)({}, JOSE_HEADER, {
              alg: alg || defaultAlg
            });
            timestamps = {
              iat: Math.floor(Date.now() / 1000)
            };

            if (!expiresIn) {
              _context.next = 13;
              break;
            }

            if (!(typeof expiresIn === 'number')) {
              _context.next = 12;
              break;
            }

            timestamps.exp = timestamps.iat + Math.floor(expiresIn);
            _context.next = 13;
            break;

          case 12:
            throw new Error('JWT expiresIn is not a number');

          case 13:
            signingInput = [encodeSection(header), encodeSection((0, _objectSpread2.default)({}, timestamps, payload, {
              iss: issuer
            }))].join('.');
            jwtSigner = (0, _SignerAlgorithm.default)(header.alg);
            _context.next = 17;
            return jwtSigner(signingInput, signer);

          case 17:
            signature = _context.sent;
            return _context.abrupt("return", [signingInput, signature].join('.'));

          case 19:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _createJWT.apply(this, arguments);
}

function verifyJWT(_x3) {
  return _verifyJWT.apply(this, arguments);
}
/**
* Resolves relevant public keys or other authenticating material used to verify signature from the DID document of provided DID
*
*  @example
*  resolveAuthenticator('ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {
*      const payload = obj.payload
*      const profile = obj.profile
*      const jwt = obj.jwt
*      ...
*  })
*
*  @param    {String}            alg                a JWT algorithm
*  @param    {String}            did                a Decentralized IDentifier (DID) to lookup
*  @param    {Boolean}           auth               Restrict public keys to ones specifically listed in the 'authentication' section of DID document
*  @return   {Promise<Object, Error>}               a promise which resolves with a response object containing an array of authenticators or if non exist rejects with an error
*/


function _verifyJWT() {
  _verifyJWT = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2(jwt) {
    var options,
        aud,
        _decodeJWT,
        payload,
        header,
        signature,
        data,
        _ref2,
        doc,
        authenticators,
        issuer,
        signer,
        now,
        _args2 = arguments;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
            aud = options.audience ? normalizeDID(options.audience) : undefined;
            _decodeJWT = decodeJWT(jwt), payload = _decodeJWT.payload, header = _decodeJWT.header, signature = _decodeJWT.signature, data = _decodeJWT.data;
            _context2.next = 5;
            return resolveAuthenticator(header.alg, payload.iss, options.auth);

          case 5:
            _ref2 = _context2.sent;
            doc = _ref2.doc;
            authenticators = _ref2.authenticators;
            issuer = _ref2.issuer;
            signer = (0, _VerifierAlgorithm.default)(header.alg)(data, signature, authenticators);
            now = Math.floor(Date.now() / 1000);

            if (!signer) {
              _context2.next = 31;
              break;
            }

            if (!(payload.iat && payload.iat > now + IAT_SKEW)) {
              _context2.next = 14;
              break;
            }

            throw new Error("JWT not valid yet (issued in the future): iat: ".concat(payload.iat, " > now: ").concat(now));

          case 14:
            if (!(payload.exp && payload.exp <= now - IAT_SKEW)) {
              _context2.next = 16;
              break;
            }

            throw new Error("JWT has expired: exp: ".concat(payload.exp, " < now: ").concat(now));

          case 16:
            if (!payload.aud) {
              _context2.next = 28;
              break;
            }

            if (!isDIDOrMNID(payload.aud)) {
              _context2.next = 24;
              break;
            }

            if (aud) {
              _context2.next = 20;
              break;
            }

            throw new Error('JWT audience is required but your app address has not been configured');

          case 20:
            if (!(aud !== normalizeDID(payload.aud))) {
              _context2.next = 22;
              break;
            }

            throw new Error("JWT audience does not match your DID: aud: ".concat(payload.aud, " !== yours: ").concat(aud));

          case 22:
            _context2.next = 28;
            break;

          case 24:
            if (options.callbackUrl) {
              _context2.next = 26;
              break;
            }

            throw new Error('JWT audience matching your callback url is required but one wasn\'t passed in');

          case 26:
            if (!(payload.aud !== options.callbackUrl)) {
              _context2.next = 28;
              break;
            }

            throw new Error("JWT audience does not match the callback url: aud: ".concat(payload.aud, " !== url: ").concat(options.callbackUrl));

          case 28:
            return _context2.abrupt("return", {
              payload: payload,
              doc: doc,
              issuer: issuer,
              signer: signer,
              jwt: jwt
            });

          case 31:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _verifyJWT.apply(this, arguments);
}

function resolveAuthenticator(_x4, _x5, _x6) {
  return _resolveAuthenticator.apply(this, arguments);
}

function _resolveAuthenticator() {
  _resolveAuthenticator = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee3(alg, mnidOrDid, auth) {
    var types, issuer, doc, authenticationKeys, authenticators;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            types = SUPPORTED_PUBLIC_KEY_TYPES[alg];

            if (!(!types || types.length === 0)) {
              _context3.next = 3;
              break;
            }

            throw new Error("No supported signature types for algorithm ".concat(alg));

          case 3:
            issuer = normalizeDID(mnidOrDid);
            _context3.next = 6;
            return (0, _didResolver.default)(issuer);

          case 6:
            doc = _context3.sent;

            if (doc) {
              _context3.next = 9;
              break;
            }

            throw new Error("Unable to resolve DID document for ".concat(issuer));

          case 9:
            authenticationKeys = auth ? (doc.authentication || []).map(function (_ref3) {
              var publicKey = _ref3.publicKey;
              return publicKey;
            }) : true;
            authenticators = (doc.publicKey || []).filter(function (_ref4) {
              var type = _ref4.type,
                  id = _ref4.id;
              return types.find(function (supported) {
                return supported === type && (!auth || authenticationKeys.indexOf(id) >= 0);
              });
            });

            if (!(auth && (!authenticators || authenticators.length === 0))) {
              _context3.next = 13;
              break;
            }

            throw new Error("DID document for ".concat(issuer, " does not have public keys suitable for authenticationg user"));

          case 13:
            if (!(!authenticators || authenticators.length === 0)) {
              _context3.next = 15;
              break;
            }

            throw new Error("DID document for ".concat(issuer, " does not have public keys for ").concat(alg));

          case 15:
            return _context3.abrupt("return", {
              authenticators: authenticators,
              issuer: issuer,
              doc: doc
            });

          case 16:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _resolveAuthenticator.apply(this, arguments);
}

var _default = {
  decodeJWT: decodeJWT,
  createJWT: createJWT,
  verifyJWT: verifyJWT,
  resolveAuthenticator: resolveAuthenticator
};
exports.default = _default;
      };
    };
  }
}, {package:"did-jwt",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/JWT.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/access-controller-interface.js", {"events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/access-controller-interface.js
      return function (require, module, exports) {
'use strict'

const EventEmitter = require('events').EventEmitter

/**
 * Interface for OrbitDB Access Controllers
 *
 * Any OrbitDB access controller needs to define and implement
 * the methods defined by the interface here.
 */
class AccessController extends EventEmitter {
  /*
    Every AC needs to have a 'Factory' method
    that creates an instance of the AccessController
  */
  static async create (orbitdb, options) {}

  /* Return the type for this controller */
  static get type () {
    throw new Error(`'static get type ()' needs to be defined in the inheriting class`)
  }

  /*
    Return the type for this controller
    NOTE! This is the only property of the interface that
    shouldn't be overridden in the inherited Access Controller
  */
  get type () {
    return this.constructor.type
  }

  /* Each Access Controller has some address to anchor to */
  get address () {}

  /*
    Called by the databases (the log) to see if entry should
    be allowed in the database. Return true if the entry is allowed,
    false is not allowed
  */
  async canAppend (entry, identityProvider) {}

  /* Add and remove access */
  async grant (access, identity) {}
  async revoke (access, identity) {}

  /* AC creation and loading */
  async load (address) {}
  /* Returns AC manifest parameters object */
  async save () {}
  /* Called when the database for this AC gets closed */
  async close () {}
}

module.exports = AccessController

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/access-controller-interface.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-map-series/index.js", {"p-reduce":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-reduce/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/p-map-series/index.js
      return function (require, module, exports) {
'use strict';
const pReduce = require('p-reduce');

module.exports = (iterable, iterator) => {
	const ret = [];

	return pReduce(iterable, (a, b, i) => {
		return Promise.resolve(iterator(b, i)).then(val => {
			ret.push(val);
		});
	}).then(() => ret);
};

      };
    };
  }
}, {package:"p-map-series",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-map-series/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/index.js", {"./io.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/io.js","./is-valid-eth-address":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/is-valid-eth-address.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/index.js
      return function (require, module, exports) {
'use strict'

const isValidEthAddress = require('./is-valid-eth-address')
const io = require('./io.js')

module.exports = {
  io,
  isValidEthAddress,
}

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Index.js
      return function (require, module, exports) {
'use strict'

/*
  Index

  Index contains the state of a datastore, ie. what data we currently have.

  Index receives a call from a Store when the operations log for the Store
  was updated, ie. new operations were added. In updateIndex, the Index
  implements its CRDT logic: add, remove or update items in the data
  structure. Each new operation received from the operations log is applied
  in order onto the current state, ie. each new operation changes the data
  and the state changes.

  Implementing each CRDT as an Index, we can implement both operation-based
  and state-based CRDTs with the same higher level abstractions.

  To read the current state of the database, Index provides a single public
  function: `get()`. It is up to the Store to decide what kind of query
  capabilities it provides to the consumer.

  Usage:
  ```javascript
  const Index = new Index(userId)
  ```
*/

class Index {
  /*
    @param id - unique identifier of this index, eg. a user id or a hash
  */
  constructor (id) {
    this.id = id
    this._index = []
  }

  /*
    Returns the state of the datastore, ie. most up-to-date data
    @return - current state
  */
  get () {
    return this._index
  }

  /*
    Applies operations to the Index and updates the state
    @param oplog - the source operations log that called updateIndex
    @param entries - operations that were added to the log
  */
  async updateIndex (oplog, entries) {
    this._index = oplog.values
  }
}

module.exports = Index

      };
    };
  }
}, {package:"orbit-db-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/replication-info.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/replication-info.js
      return function (require, module, exports) {
class ReplicationInfo {
  constructor () {
    this.reset()
  }

  reset () {
    this.progress = 0
    this.max = 0
    this.buffered = 0
    this.queued = 0
  }
}

module.exports = ReplicationInfo

      };
    };
  }
}, {package:"orbit-db-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/replication-info.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Replicator.js", {"events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","ipfs-log":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log.js","logplease":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/logplease/src/index.js","p-map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-map/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Replicator.js
      return function (require, module, exports) {
const EventEmitter = require('events').EventEmitter
const pMap = require('p-map')
const Log = require('ipfs-log')

const Logger = require('logplease')
const logger = Logger.create('replicator', { color: Logger.Colors.Cyan })
Logger.setLogLevel('ERROR')

const getNext = e => e.next
const flatMap = (res, val) => res.concat(val)
const notNull = entry => entry !== null && entry !== undefined
const uniqueValues = (res, val) => {
  res[val] = val
  return res
}

const batchSize = 1

class Replicator extends EventEmitter {
  constructor (store, concurrency) {
    super()
    this._store = store
    this._fetching = {}
    this._stats = {
      tasksRequested: 0,
      tasksStarted: 0,
      tasksProcessed: 0
    }
    this._buffer = []

    this._concurrency = concurrency || 128
    this._queue = {}
    this._q = new Set()

    // Flush the queue as an emergency switch
    this._flushTimer = setInterval(() => {
      if (this.tasksRunning === 0 && Object.keys(this._queue).length > 0) {
        logger.warn('Had to flush the queue!', Object.keys(this._queue).length, 'items in the queue, ', this.tasksRequested, this.tasksFinished, ' tasks requested/finished')
        setTimeout(() => this._processQueue(), 0)
      }
    }, 3000)
  }

  /**
   * Returns the number of tasks started during the life time
   * @return {[Integer]} [Number of tasks started]
   */
  get tasksRequested () {
    return this._stats.tasksRequested
  }

  /**
   * Returns the number of tasks started during the life time
   * @return {[Integer]} [Number of tasks running]
   */
  get tasksStarted () {
    return this._stats.tasksStarted
  }

  /**
   * Returns the number of tasks running currently
   * @return {[Integer]} [Number of tasks running]
   */
  get tasksRunning () {
    return this._stats.tasksStarted - this._stats.tasksProcessed
  }

  /**
   * Returns the number of tasks currently queued
   * @return {[Integer]} [Number of tasks queued]
   */
  get tasksQueued () {
    return Math.max(Object.keys(this._queue).length - this.tasksRunning, 0)
  }

  /**
   * Returns the number of tasks finished during the life time
   * @return {[Integer]} [Number of tasks finished]
   */
  get tasksFinished () {
    return this._stats.tasksProcessed
  }

  /**
   * Returns the hashes currently queued
   * @return {[Array<String>]} [Queued hashes]
   */
  getQueue () {
    return Object.values(this._queue)
  }

  /*
    Process new heads.
   */
  load (entries) {
    const notKnown = entry => {
      const hash = entry.hash || entry
      return !this._store._oplog.has(hash) && !this._fetching[hash] && !this._queue[hash]
    }

    try {
      entries
        .filter(notNull)
        .filter(notKnown)
        .forEach(this._addToQueue.bind(this))

      setTimeout(() => this._processQueue(), 0)
    } catch (e) {
      console.error(e)
    }
  }

  stop () {
    // Clears the queue flusher
    clearInterval(this._flushTimer)
  }

  _addToQueue (entry) {
    const hash = entry.hash || entry
    this._stats.tasksRequested += 1
    this._queue[hash] = entry
  }

  async _processQueue () {
    if (this.tasksRunning < this._concurrency) {
      const capacity = this._concurrency - this.tasksRunning
      const items = Object.values(this._queue).slice(0, capacity).filter(notNull)
      items.forEach(entry => delete this._queue[entry.hash || entry])

      const flattenAndGetUniques = (nexts) => nexts.reduce(flatMap, []).reduce(uniqueValues, {})
      const processValues = (nexts) => {
        const values = Object.values(nexts).filter(notNull)

        if ((items.length > 0 && this._buffer.length > 0) ||
        (this.tasksRunning === 0 && this._buffer.length > 0)) {
          const logs = this._buffer.slice()
          this._buffer = []
          this.emit('load.end', logs)
        }

        if (values.length > 0) {
          this.load(values)
        }
      }

      return pMap(items, e => this._processOne(e))
        .then(flattenAndGetUniques)
        .then(processValues)
    }
  }

  async _processOne (entry) {
    const hash = entry.hash || entry

    if (this._store._oplog.has(hash) || this._fetching[hash]) {
      return
    }

    this._fetching[hash] = hash
    this.emit('load.added', entry)
    this._stats.tasksStarted += 1

    const exclude = []
    const log = await Log.fromEntryHash(this._store._ipfs, this._store.identity, hash, { logId: this._store._oplog.id, access: this._store.access, length: batchSize, exclude })
    this._buffer.push(log)

    const latest = log.values[0]
    delete this._queue[hash]

    // Mark this task as processed
    this._stats.tasksProcessed += 1

    // Notify subscribers that we made progress
    this.emit('load.progress', this._id, hash, latest, null, this._buffer.length)

    // Return all next pointers
    return log.values.map(getNext).reduce(flatMap, [])
  }
}

module.exports = Replicator

      };
    };
  }
}, {package:"orbit-db-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Replicator.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/node_modules/p-each-series/index.js", {"p-reduce":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-reduce/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/node_modules/p-each-series/index.js
      return function (require, module, exports) {
'use strict';
const pReduce = require('p-reduce');

module.exports = (iterable, iterator) => pReduce(iterable, (a, b, i) => iterator(b, i)).then(() => iterable);

      };
    };
  }
}, {package:"p-each-series",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/node_modules/p-each-series/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/crdts/src/utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/crdts/src/utils.js
      return function (require, module, exports) {
'use strict'

exports.deepEqual = (a, b) => {
  const propsA = Object.getOwnPropertyNames(a)
  const propsB = Object.getOwnPropertyNames(b)

  if(propsA.length !== propsB.length)
    return false

  for(let i = 0; i < propsA.length; i ++) {
    const prop = propsA[i]
    if(a[prop] !== b[prop])
      return false
  }

  return true
}

class OperationTuple3 {
  constructor (value, added, removed) {
    this.value = value
    this.added = new Set(added)
    this.removed = new Set(removed)
  }

  static create (value, added, removed) {
    return new OperationTuple3(value, added, removed)
  }

  static from (json) {
    return OperationTuple3.create(json.value, json.added, json.removed)
  }
}

exports.OperationTuple3 = OperationTuple3

      };
    };
  }
}, {package:"crdts",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crdts/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/protocol.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/protocol.js
      return function (require, module, exports) {
'use strict'

module.exports = 'ipfs-pubsub-direct-channel/v1'

      };
    };
  }
}, {package:"ipfs-pubsub-1on1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/protocol.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/wait-for-peers.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/wait-for-peers.js
      return function (require, module, exports) {
'use strict'

const waitForPeers = async (ipfs, peersToWait, topic) => {
  const checkPeers = async () => {
    const peers = await ipfs.pubsub.peers(topic)
    const hasAllPeers = peersToWait.map((e) => peers.includes(e)).filter((e) => e === false).length === 0
    return hasAllPeers
  }

  if (await checkPeers()) {
    return Promise.resolve()
  }

  return new Promise(async (resolve, reject) => {
    const interval = setInterval(async () => {
      try {
        if (await checkPeers()) {
          clearInterval(interval)
          resolve()
        }
      } catch (e) {
        reject(e)
      }
    }, 100)
  })
}

module.exports = waitForPeers

      };
    };
  }
}, {package:"ipfs-pubsub-1on1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/wait-for-peers.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/get-peer-id.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/get-peer-id.js
      return function (require, module, exports) {
'use strict'

const getPeerID = async (ipfs) => {
  const peerInfo = await ipfs.id()
  return peerInfo.id
}

module.exports = getPeerID

      };
    };
  }
}, {package:"ipfs-pubsub-1on1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/get-peer-id.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/encoding.js", {"safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/node_modules/safe-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/encoding.js
      return function (require, module, exports) {
'use strict'

const Buffer = require('safe-buffer').Buffer

module.exports = (_message) => {
  let message = _message
  if (!Buffer.isBuffer(message)) {
    message = Buffer.from(message)
  }
  return message
}

      };
    };
  }
}, {package:"ipfs-pubsub-1on1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/encoding.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/util/support.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/util/support.js
      return function (require, module, exports) {
'use strict'

exports.test = function (key) {
  return function test (impl) {
    try {
      impl.cmp(key, 0)
      return true
    } catch (err) {
      return false
    }
  }
}

exports.binaryKeys = exports.test(new Uint8Array(0))
exports.arrayKeys = exports.test([1])

      };
    };
  }
}, {package:"level-js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/util/support.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/iterator.js", {"./util/immediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/util/immediate-browser.js","./util/mixed-to-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/util/mixed-to-buffer.js","abstract-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","ltgt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ltgt/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/iterator.js
      return function (require, module, exports) {
/* global IDBKeyRange */

'use strict'

var inherits = require('inherits')
var AbstractIterator = require('abstract-leveldown').AbstractIterator
var ltgt = require('ltgt')
var mixedToBuffer = require('./util/mixed-to-buffer')
var setImmediate = require('./util/immediate')
var noop = function () {}

module.exports = Iterator

function Iterator (db, location, options) {
  AbstractIterator.call(this, db)

  this._limit = options.limit
  this._count = 0
  this._callback = null
  this._cache = []
  this._completed = false
  this._aborted = false
  this._error = null
  this._transaction = null

  this._keyAsBuffer = options.keyAsBuffer
  this._valueAsBuffer = options.valueAsBuffer

  if (this._limit === 0) {
    this._completed = true
    return
  }

  try {
    var keyRange = this.createKeyRange(options)
  } catch (e) {
    // The lower key is greater than the upper key.
    // IndexedDB throws an error, but we'll just return 0 results.
    this._completed = true
    return
  }

  this.createIterator(location, keyRange, options.reverse)
}

inherits(Iterator, AbstractIterator)

Iterator.prototype.createKeyRange = function (options) {
  var lower = ltgt.lowerBound(options)
  var upper = ltgt.upperBound(options)
  var lowerOpen = ltgt.lowerBoundExclusive(options)
  var upperOpen = ltgt.upperBoundExclusive(options)

  if (lower !== undefined && upper !== undefined) {
    return IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen)
  } else if (lower !== undefined) {
    return IDBKeyRange.lowerBound(lower, lowerOpen)
  } else if (upper !== undefined) {
    return IDBKeyRange.upperBound(upper, upperOpen)
  } else {
    return null
  }
}

Iterator.prototype.createIterator = function (location, keyRange, reverse) {
  var self = this
  var transaction = this.db.db.transaction([location], 'readonly')
  var store = transaction.objectStore(location)
  var req = store.openCursor(keyRange, reverse ? 'prev' : 'next')

  req.onsuccess = function (ev) {
    var cursor = ev.target.result
    if (cursor) self.onItem(cursor)
  }

  this._transaction = transaction

  // If an error occurs (on the request), the transaction will abort.
  transaction.onabort = function () {
    self.onAbort(self._transaction.error || new Error('aborted by user'))
  }

  transaction.oncomplete = function () {
    self.onComplete()
  }
}

Iterator.prototype.onItem = function (cursor) {
  this._cache.push(cursor.key, cursor.value)

  if (this._limit <= 0 || ++this._count < this._limit) {
    cursor['continue']()
  }

  this.maybeNext()
}

Iterator.prototype.onAbort = function (err) {
  this._aborted = true
  this._error = err
  this.maybeNext()
}

Iterator.prototype.onComplete = function () {
  this._completed = true
  this.maybeNext()
}

Iterator.prototype.maybeNext = function () {
  if (this._callback) {
    this._next(this._callback)
    this._callback = null
  }
}

Iterator.prototype._next = function (callback) {
  if (this._aborted) {
    // The error should be picked up by either next() or end().
    var err = this._error
    this._error = null

    setImmediate(function () {
      callback(err)
    })
  } else if (this._cache.length > 0) {
    var key = this._cache.shift()
    var value = this._cache.shift()

    if (this._keyAsBuffer) key = mixedToBuffer(key)
    if (this._valueAsBuffer) value = mixedToBuffer(value)

    setImmediate(function () {
      callback(null, key, value)
    })
  } else if (this._completed) {
    setImmediate(callback)
  } else {
    this._callback = callback
  }
}

Iterator.prototype._end = function (callback) {
  if (this._aborted || this._completed) {
    var err = this._error

    setImmediate(function () {
      callback(err)
    })

    return
  }

  // Don't advance the cursor anymore, and the transaction will complete
  // on its own in the next tick. This approach is much cleaner than calling
  // transaction.abort() with its unpredictable event order.
  this.onItem = noop
  this.onAbort = callback
  this.onComplete = callback
}

      };
    };
  }
}, {package:"level-js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/iterator.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/index.js", {"./abstract-chained-batch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/abstract-chained-batch.js","./abstract-iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/abstract-iterator.js","./abstract-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/abstract-leveldown.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/index.js
      return function (require, module, exports) {
exports.AbstractLevelDOWN = require('./abstract-leveldown')
exports.AbstractIterator = require('./abstract-iterator')
exports.AbstractChainedBatch = require('./abstract-chained-batch')

      };
    };
  }
}, {package:"abstract-leveldown",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/util/mixed-to-buffer.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","typedarray-to-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/typedarray-to-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/util/mixed-to-buffer.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

var toBuffer = require('typedarray-to-buffer')

module.exports = function (value) {
  if (value instanceof Uint8Array) return toBuffer(value)
  else if (value instanceof ArrayBuffer) return Buffer.from(value)
  else return Buffer.from(String(value))
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"level-js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/util/mixed-to-buffer.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/util/immediate-browser.js", {"immediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/util/immediate-browser.js
      return function (require, module, exports) {
module.exports = require('immediate')

      };
    };
  }
}, {package:"level-js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/util/immediate-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/lru/index.js", {"events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/lru/index.js
      return function (require, module, exports) {
var events = require('events')
var inherits = require('inherits')

module.exports = LRU

function LRU (opts) {
  if (!(this instanceof LRU)) return new LRU(opts)
  if (typeof opts === 'number') opts = {max: opts}
  if (!opts) opts = {}
  events.EventEmitter.call(this)
  this.cache = {}
  this.head = this.tail = null
  this.length = 0
  this.max = opts.max || 1000
  this.maxAge = opts.maxAge || 0
}

inherits(LRU, events.EventEmitter)

Object.defineProperty(LRU.prototype, 'keys', {
  get: function () { return Object.keys(this.cache) }
})

LRU.prototype.clear = function () {
  this.cache = {}
  this.head = this.tail = null
  this.length = 0
}

LRU.prototype.remove = function (key) {
  if (typeof key !== 'string') key = '' + key
  if (!this.cache.hasOwnProperty(key)) return

  var element = this.cache[key]
  delete this.cache[key]
  this._unlink(key, element.prev, element.next)
  return element.value
}

LRU.prototype._unlink = function (key, prev, next) {
  this.length--

  if (this.length === 0) {
    this.head = this.tail = null
  } else {
    if (this.head === key) {
      this.head = prev
      this.cache[this.head].next = null
    } else if (this.tail === key) {
      this.tail = next
      this.cache[this.tail].prev = null
    } else {
      this.cache[prev].next = next
      this.cache[next].prev = prev
    }
  }
}

LRU.prototype.peek = function (key) {
  if (!this.cache.hasOwnProperty(key)) return

  var element = this.cache[key]

  if (!this._checkAge(key, element)) return
  return element.value
}

LRU.prototype.set = function (key, value) {
  if (typeof key !== 'string') key = '' + key

  var element

  if (this.cache.hasOwnProperty(key)) {
    element = this.cache[key]
    element.value = value
    if (this.maxAge) element.modified = Date.now()

    // If it's already the head, there's nothing more to do:
    if (key === this.head) return value
    this._unlink(key, element.prev, element.next)
  } else {
    element = {value: value, modified: 0, next: null, prev: null}
    if (this.maxAge) element.modified = Date.now()
    this.cache[key] = element

    // Eviction is only possible if the key didn't already exist:
    if (this.length === this.max) this.evict()
  }

  this.length++
  element.next = null
  element.prev = this.head

  if (this.head) this.cache[this.head].next = key
  this.head = key

  if (!this.tail) this.tail = key
  return value
}

LRU.prototype._checkAge = function (key, element) {
  if (this.maxAge && (Date.now() - element.modified) > this.maxAge) {
    this.remove(key)
    this.emit('evict', {key: key, value: element.value})
    return false
  }
  return true
}

LRU.prototype.get = function (key) {
  if (typeof key !== 'string') key = '' + key
  if (!this.cache.hasOwnProperty(key)) return

  var element = this.cache[key]

  if (!this._checkAge(key, element)) return

  if (this.head !== key) {
    if (key === this.tail) {
      this.tail = element.next
      this.cache[this.tail].prev = null
    } else {
      // Set prev.next -> element.next:
      this.cache[element.prev].next = element.next
    }

    // Set element.next.prev -> element.prev:
    this.cache[element.next].prev = element.prev

    // Element is the new head
    this.cache[this.head].next = key
    element.prev = this.head
    element.next = null
    this.head = key
  }

  return element.value
}

LRU.prototype.evict = function () {
  if (!this.tail) return
  var key = this.tail
  var value = this.remove(this.tail)
  this.emit('evict', {key: key, value: value})
}

      };
    };
  }
}, {package:"lru",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lru/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/verifiers/index.js", {"./verifierv0":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/verifiers/verifierv0.js","./verifierv1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/verifiers/verifierv1.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/verifiers/index.js
      return function (require, module, exports) {
'use strict'

const verifiers = {
  'v0': require('./verifierv0'),
  'v1': require('./verifierv1')
}

module.exports = {
  verifier: (v) => {
    return verifiers[v]
  }
}

      };
    };
  }
}, {package:"orbit-db-keystore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/verifiers/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/levelup.js", {"./batch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/batch.js","./common":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/common.js","./promisify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/promisify.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","deferred-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/deferred-leveldown/deferred-leveldown.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","level-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-errors/errors.js","level-iterator-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/level-iterator-stream/index.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/util/util.js","xtend":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xtend/immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/levelup.js
      return function (require, module, exports) {
(function (process){(function (){
var EventEmitter = require('events').EventEmitter
var inherits = require('util').inherits
var extend = require('xtend')
var DeferredLevelDOWN = require('deferred-leveldown')
var IteratorStream = require('level-iterator-stream')
var Batch = require('./batch')
var errors = require('level-errors')
var assert = require('assert')
var promisify = require('./promisify')
var getCallback = require('./common').getCallback
var getOptions = require('./common').getOptions

var WriteError = errors.WriteError
var ReadError = errors.ReadError
var NotFoundError = errors.NotFoundError
var OpenError = errors.OpenError
var InitializationError = errors.InitializationError

// Possible AbstractLevelDOWN#status values:
//  - 'new'     - newly created, not opened or closed
//  - 'opening' - waiting for the database to be opened, post open()
//  - 'open'    - successfully opened the database, available for use
//  - 'closing' - waiting for the database to be closed, post close()
//  - 'closed'  - database has been successfully closed, should not be
//                 used except for another open() operation

function LevelUP (db, options, callback) {
  if (!(this instanceof LevelUP)) {
    return new LevelUP(db, options, callback)
  }

  var error

  EventEmitter.call(this)
  this.setMaxListeners(Infinity)

  if (typeof options === 'function') {
    callback = options
    options = {}
  }

  options = options || {}

  if (!db || typeof db !== 'object') {
    error = new InitializationError('First argument must be an abstract-leveldown compliant store')
    if (typeof callback === 'function') {
      return process.nextTick(callback, error)
    }
    throw error
  }

  assert.strictEqual(typeof db.status, 'string', '.status required, old abstract-leveldown')

  this.options = getOptions(options)
  this._db = db
  this.db = new DeferredLevelDOWN(db)
  this.open(callback)
}

LevelUP.prototype.emit = EventEmitter.prototype.emit
LevelUP.prototype.once = EventEmitter.prototype.once
inherits(LevelUP, EventEmitter)

LevelUP.prototype.open = function (opts, callback) {
  var self = this
  var promise

  if (typeof opts === 'function') {
    callback = opts
    opts = null
  }

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (!opts) {
    opts = this.options
  }

  if (this.isOpen()) {
    process.nextTick(callback, null, self)
    return promise
  }

  if (this._isOpening()) {
    this.once('open', function () { callback(null, self) })
    return promise
  }

  this.emit('opening')

  this.db.open(opts, function (err) {
    if (err) {
      return callback(new OpenError(err))
    }
    self.db = self._db
    callback(null, self)
    self.emit('open')
    self.emit('ready')
  })

  return promise
}

LevelUP.prototype.close = function (callback) {
  var self = this
  var promise

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (this.isOpen()) {
    this.db.close(function () {
      self.emit('closed')
      callback.apply(null, arguments)
    })
    this.emit('closing')
    this.db = new DeferredLevelDOWN(this._db)
  } else if (this.isClosed()) {
    process.nextTick(callback)
  } else if (this.db.status === 'closing') {
    this.once('closed', callback)
  } else if (this._isOpening()) {
    this.once('open', function () {
      self.close(callback)
    })
  }

  return promise
}

LevelUP.prototype.isOpen = function () {
  return this.db.status === 'open'
}

LevelUP.prototype._isOpening = function () {
  return this.db.status === 'opening'
}

LevelUP.prototype.isClosed = function () {
  return (/^clos|new/).test(this.db.status)
}

LevelUP.prototype.get = function (key, options, callback) {
  if (key === null || key === undefined) {
    throw new ReadError('get() requires a key argument')
  }

  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (maybeError(this, callback)) { return promise }

  options = getOptions(options)

  this.db.get(key, options, function (err, value) {
    if (err) {
      if ((/notfound/i).test(err) || err.notFound) {
        err = new NotFoundError('Key not found in database [' + key + ']', err)
      } else {
        err = new ReadError(err)
      }
      return callback(err)
    }
    callback(null, value)
  })

  return promise
}

LevelUP.prototype.put = function (key, value, options, callback) {
  if (key === null || key === undefined) {
    throw new WriteError('put() requires a key argument')
  }

  var self = this
  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (maybeError(this, callback)) { return promise }

  options = getOptions(options)

  this.db.put(key, value, options, function (err) {
    if (err) {
      return callback(new WriteError(err))
    }
    self.emit('put', key, value)
    callback()
  })

  return promise
}

LevelUP.prototype.del = function (key, options, callback) {
  if (key === null || key === undefined) {
    throw new WriteError('del() requires a key argument')
  }

  var self = this
  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (maybeError(this, callback)) { return promise }

  options = getOptions(options)

  this.db.del(key, options, function (err) {
    if (err) {
      return callback(new WriteError(err))
    }
    self.emit('del', key)
    callback()
  })

  return promise
}

LevelUP.prototype.batch = function (arr, options, callback) {
  if (!arguments.length) {
    return new Batch(this)
  }

  if (!Array.isArray(arr)) {
    throw new WriteError('batch() requires an array argument')
  }

  var self = this
  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (maybeError(this, callback)) { return promise }

  options = getOptions(options)

  this.db.batch(arr, options, function (err) {
    if (err) {
      return callback(new WriteError(err))
    }
    self.emit('batch', arr)
    callback()
  })

  return promise
}

LevelUP.prototype.iterator = function (options) {
  return this.db.iterator(options)
}

LevelUP.prototype.readStream =
LevelUP.prototype.createReadStream = function (options) {
  options = extend({ keys: true, values: true }, options)
  if (typeof options.limit !== 'number') { options.limit = -1 }
  return new IteratorStream(this.db.iterator(options), options)
}

LevelUP.prototype.keyStream =
LevelUP.prototype.createKeyStream = function (options) {
  return this.createReadStream(extend(options, { keys: true, values: false }))
}

LevelUP.prototype.valueStream =
LevelUP.prototype.createValueStream = function (options) {
  return this.createReadStream(extend(options, { keys: false, values: true }))
}

LevelUP.prototype.toString = function () {
  return 'LevelUP'
}

function maybeError (db, callback) {
  if (!db._isOpening() && !db.isOpen()) {
    process.nextTick(callback, new ReadError('Database is not open'))
    return true
  }
}

LevelUP.errors = errors
module.exports = LevelUP.default = LevelUP

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"levelup",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/levelup.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/lock-memory.js", {"async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/lock-memory.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')
const setImmediate = require('async/setImmediate')

const log = debug('repo:lock')

const lockFile = 'repo.lock'

const LOCKS = {}

/**
 * Lock the repo in the given dir.
 *
 * @param {string} dir
 * @param {function(Error, lock)} callback
 * @returns {void}
 */
exports.lock = (dir, callback) => {
  const file = dir + '/' + lockFile
  log('locking %s', file)
  LOCKS[file] = true
  const closer = {
    close (cb) {
      if (LOCKS[file]) {
        delete LOCKS[file]
      }
      setImmediate(cb)
    }
  }
  setImmediate(() => {
    callback(null, closer)
  })
}

/**
 * Check if the repo in the given directory is locked.
 *
 * @param {string} dir
 * @param {function(Error, bool)} callback
 * @returns {void}
 */
exports.locked = (dir, callback) => {
  const file = dir + '/' + lockFile
  log('checking lock: %s')

  const locked = LOCKS[file]
  setImmediate(() => {
    callback(null, locked)
  })
}

      };
    };
  }
}, {package:"ipfs-repo",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/lock-memory.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/backends.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/backends.js
      return function (require, module, exports) {
'use strict'

exports.create = function createBackend (name, path, options) {
  const Ctor = options.storageBackends[name]
  const backendOptions = Object.assign({}, options.storageBackendOptions[name] || {})
  return new Ctor(path, backendOptions)
}

      };
    };
  }
}, {package:"ipfs-repo",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/backends.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/default-datastore.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/default-datastore.js
      return function (require, module, exports) {
'use strict'

// Default configuration for the datastore spec in node.js
module.exports = {
  Spec: {
    type: 'mount',
    mounts: [
      {
        mountpoint: '/blocks',
        type: 'measure',
        prefix: 'flatfs.datastore',
        child: {
          type: 'flatfs',
          path: 'blocks',
          sync: true,
          shardFunc: '/repo/flatfs/shard/v1/next-to-last/2'
        }
      },
      {
        mountpoint: '/',
        type: 'measure',
        prefix: 'leveldb.datastore',
        child: {
          type: 'levelds',
          path: 'datastore',
          compression: 'none'
        }
      }
    ]
  }
}

      };
    };
  }
}, {package:"ipfs-repo",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/default-datastore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/constants.js
      return function (require, module, exports) {
'use strict'

module.exports = {
  repoVersion: 7
}

      };
    };
  }
}, {package:"ipfs-repo",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/errors/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/errors/index.js
      return function (require, module, exports) {
'use strict'

exports.ERR_REPO_NOT_INITIALIZED = 'ERR_REPO_NOT_INITIALIZED'

      };
    };
  }
}, {package:"ipfs-repo",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/errors/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/node_modules/bignumber.js/bignumber.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/node_modules/bignumber.js/bignumber.js
      return function (require, module, exports) {
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v8.1.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2019 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    hasSymbol = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol',

    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                    // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',      // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if only one character,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.$|[+-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return 0, else return Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, Infinity or 0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return Infinity if either is Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return 0 if either is 0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return Infinity if either Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '1e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (hasSymbol) {
      P[Symbol.toStringTag] = 'BigNumber';

      // Node.js v10.12.0+
      P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;
    }

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

      };
    };
  }
}, {package:"bignumber.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/node_modules/bignumber.js/bignumber.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/dlv/dist/dlv.umd.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/dlv/dist/dlv.umd.js
      return function (require, module, exports) {
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=function(t,n,e,i,o){for(n=n.split?n.split("."):n,i=0;i<n.length;i++)t=t?t[n[i]]:o;return t===o?e:t}:"function"==typeof define&&define.amd?define(function(){return function(t,n,e,i,o){for(n=n.split?n.split("."):n,i=0;i<n.length;i++)t=t?t[n[i]]:o;return t===o?e:t}}):t.dlv=function(t,n,e,i,o){for(n=n.split?n.split("."):n,i=0;i<n.length;i++)t=t?t[n[i]]:o;return t===o?e:t}}(this);
//# sourceMappingURL=dlv.umd.js.map

      };
    };
  }
}, {package:"dlv",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/dlv/dist/dlv.umd.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js
      return function (require, module, exports) {
'use strict'

module.exports = function pull (a) {
  var length = arguments.length
  if (typeof a === 'function' && a.length === 1) {
    var args = new Array(length)
    for(var i = 0; i < length; i++)
      args[i] = arguments[i]
    return function (read) {
      if (args == null) {
        throw new TypeError("partial sink should only be called once!")
      }

      // Grab the reference after the check, because it's always an array now
      // (engines like that kind of consistency).
      var ref = args
      args = null

      // Prioritize common case of small number of pulls.
      switch (length) {
      case 1: return pull(read, ref[0])
      case 2: return pull(read, ref[0], ref[1])
      case 3: return pull(read, ref[0], ref[1], ref[2])
      case 4: return pull(read, ref[0], ref[1], ref[2], ref[3])
      default:
        ref.unshift(read)
        return pull.apply(null, ref)
      }
    }
  }

  var read = a

  if (read && typeof read.source === 'function') {
    read = read.source
  }

  for (var i = 1; i < length; i++) {
    var s = arguments[i]
    if (typeof s === 'function') {
      read = s(read)
    } else if (s && typeof s === 'object') {
      s.sink(read)
      read = s.source
    }
  }

  return read
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/version.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/version.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const Key = require('interface-datastore').Key
const debug = require('debug')
const log = debug('repo:version')

const versionKey = new Key('version')

module.exports = (store) => {
  return {
    /**
     * Check if a version file exists.
     *
     * @param {function(Error, bool)} callback
     * @returns {void}
     */
    exists (callback) {
      store.has(versionKey, callback)
    },
    /**
     * Get the current version.
     *
     * @param {function(Error, number)} callback
     * @returns {void}
     */
    get (callback) {
      store.get(versionKey, (err, buf) => {
        if (err) {
          return callback(err)
        }
        callback(null, parseInt(buf.toString().trim(), 10))
      })
    },
    /**
     * Set the version of the repo, writing it to the underlying store.
     *
     * @param {number} version
     * @param {function(Error)} callback
     * @returns {void}
     */
    set (version, callback) {
      store.put(versionKey, Buffer.from(String(version)), callback)
    },
    /**
     * Check the current version, and return an error on missmatch
     * @param {number} expected
     * @param {function(Error)} callback
     * @returns {void}
     */
    check (expected, callback) {
      this.get((err, version) => {
        if (err) {
          return callback(err)
        }
        log('comparing version: %s and %s', version, expected)

        // Version 6 and 7 are the same
        // TODO: Clean up the compatibility logic. Repo feature detection would be ideal, or a better version schema
        const compatibleVersion = (version === 6 && expected === 7) || (expected === 6 && version === 7)

        if (version !== expected && !compatibleVersion) {
          return callback(new Error(`ipfs repo needs migration: expected version v${expected}, found version v${version}`))
        }
        callback()
      })
    }
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-repo",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/version.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/api-addr.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/api-addr.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const Key = require('interface-datastore').Key

const apiFile = new Key('api')

module.exports = (store) => {
  return {
    /**
     * Get the current configuration from the repo.
     *
     * @param {function(Error, Object)} callback
     * @returns {void}
     */
    get (callback) {
      store.get(apiFile, (err, value) => callback(err, value && value.toString()))
    },
    /**
     * Set the current configuration for this repo.
     *
     * @param {Object} value - the api address to be written
     * @param {function(Error)} callback
     * @returns {void}
     */
    set (value, callback) {
      store.put(apiFile, Buffer.from(value.toString()), callback)
    },
    /**
     * Deletes api file
     *
     * @param {function(Error, bool)} callback
     * @returns {void}
     */
    delete (callback) {
      store.delete(apiFile, callback)
    }
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-repo",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/api-addr.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js", {"./eachOf":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/eachOf.js","./internal/withoutIndex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/withoutIndex.js","./internal/wrapAsync":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/wrapAsync.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = eachLimit;

var _eachOf = require('./eachOf');

var _eachOf2 = _interopRequireDefault(_eachOf);

var _withoutIndex = require('./internal/withoutIndex');

var _withoutIndex2 = _interopRequireDefault(_withoutIndex);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Applies the function `iteratee` to each item in `coll`, in parallel.
 * The `iteratee` is called with an item from the list, and a callback for when
 * it has finished. If the `iteratee` passes an error to its `callback`, the
 * main `callback` (for the `each` function) is immediately called with the
 * error.
 *
 * Note, that since this function applies `iteratee` to each item in parallel,
 * there is no guarantee that the iteratee functions will complete in order.
 *
 * @name each
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEach
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to
 * each item in `coll`. Invoked with (item, callback).
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOf`.
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * // assuming openFiles is an array of file names and saveFile is a function
 * // to save the modified contents of that file:
 *
 * async.each(openFiles, saveFile, function(err){
 *   // if any of the saves produced an error, err would equal that error
 * });
 *
 * // assuming openFiles is an array of file names
 * async.each(openFiles, function(file, callback) {
 *
 *     // Perform operation on file here.
 *     console.log('Processing file ' + file);
 *
 *     if( file.length > 32 ) {
 *       console.log('This file name is too long');
 *       callback('File name too long');
 *     } else {
 *       // Do work to process file here
 *       console.log('File processed');
 *       callback();
 *     }
 * }, function(err) {
 *     // if any of the file processing produced an error, err would equal that error
 *     if( err ) {
 *       // One of the iterations produced an error.
 *       // All processing will now stop.
 *       console.log('A file failed to process');
 *     } else {
 *       console.log('All files have been processed successfully');
 *     }
 * });
 */
function eachLimit(coll, iteratee, callback) {
  (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
}
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/reduce.js", {"./drain":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/drain.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/reduce.js
      return function (require, module, exports) {
'use strict'

var drain = require('./drain')

module.exports = function reduce (reducer, acc, cb ) {
  if(!cb) cb = acc, acc = null
  var sink = drain(function (data) {
    acc = reducer(acc, data)
  }, function (err) {
    cb(err, acc)
  })
  if (arguments.length === 2)
    return function (source) {
      source(null, function (end, data) {
        //if ended immediately, and no initial...
        if(end) return cb(end === true ? null : end)
        acc = data; sink(source)
      })
    }
  else
    return sink
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/reduce.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/series.js", {"./eachOfSeries":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/eachOfSeries.js","./internal/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/parallel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/series.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = series;

var _parallel = require('./internal/parallel');

var _parallel2 = _interopRequireDefault(_parallel);

var _eachOfSeries = require('./eachOfSeries');

var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Run the functions in the `tasks` collection in series, each one running once
 * the previous function has completed. If any functions in the series pass an
 * error to its callback, no more functions are run, and `callback` is
 * immediately called with the value of the error. Otherwise, `callback`
 * receives an array of results when `tasks` have completed.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function, and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 *  results from {@link async.series}.
 *
 * **Note** that while many implementations preserve the order of object
 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
 * explicitly states that
 *
 * > The mechanics and order of enumerating the properties is not specified.
 *
 * So if you rely on the order in which your series of functions are executed,
 * and want this to work on all platforms, consider using an array.
 *
 * @name series
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection containing
 * [async functions]{@link AsyncFunction} to run in series.
 * Each function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This function gets a results array (or object)
 * containing all the result arguments passed to the `task` callbacks. Invoked
 * with (err, result).
 * @example
 * async.series([
 *     function(callback) {
 *         // do some stuff ...
 *         callback(null, 'one');
 *     },
 *     function(callback) {
 *         // do some more stuff ...
 *         callback(null, 'two');
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // results is now equal to ['one', 'two']
 * });
 *
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback){
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equal to: {one: 1, two: 2}
 * });
 */
function series(tasks, callback) {
  (0, _parallel2.default)(_eachOfSeries2.default, tasks, callback);
}
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/series.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/spec.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js","sort-keys":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/sort-keys/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/spec.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const Key = require('interface-datastore').Key
const sortKeys = require('sort-keys')

const specKey = new Key('datastore_spec')

module.exports = (store) => {
  return {
    /**
     * Check if a datastore spec file exists.
     *
     * @param {function(Error, bool)} callback
     * @returns {void}
     */
    exists (callback) {
      store.has(specKey, callback)
    },
    /**
     * Get the current datastore spec.
     *
     * @param {function(Error, number)} callback
     * @returns {void}
     */
    get (callback) {
      store.get(specKey, (err, buf) => {
        if (err) {
          return callback(err)
        }
        callback(null, JSON.parse(buf.toString()))
      })
    },
    /**
     * Set the datastore spec of the repo, writing it to the underlying store.
     *
     * @param {number} spec
     * @param {function(Error)} callback
     * @returns {void}
     */
    set (spec, callback) {
      store.put(specKey, Buffer.from(JSON.stringify(sortKeys(spec, { deep: true }))), callback)
    }
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-repo",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/spec.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/config.js", {"async/queue":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/queue.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","dlv":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/dlv/dist/dlv.umd.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js","just-safe-set":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/just-safe-set/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/config.js
      return function (require, module, exports) {
'use strict'

const Key = require('interface-datastore').Key
const queue = require('async/queue')
const waterfall = require('async/waterfall')
const _get = require('dlv')
const _set = require('just-safe-set')
const Buffer = require('buffer').Buffer

const configKey = new Key('config')

module.exports = (store) => {
  const setQueue = queue(_doSet, 1)

  const configStore = {
    /**
     * Get the current configuration from the repo.
     *
     * @param {String} key - the config key to get
     * @param {function(Error, Object)} callback
     * @returns {void}
     */
    get (key, callback) {
      if (typeof key === 'function') {
        callback = key
        key = undefined
      }
      if (!key) {
        key = undefined
      }
      store.get(configKey, (err, encodedValue) => {
        if (err) { return callback(err) }

        let config
        try {
          config = JSON.parse(encodedValue.toString())
        } catch (err) {
          return callback(err)
        }

        if (typeof key === 'undefined') {
          return callback(null, config)
        }

        if (typeof key !== 'string') {
          return callback(new Error('Key ' + key + ' must be a string.'))
        }

        const value = _get(config, key, null)

        if (value === null) {
          return callback(new Error('Key ' + key + ' does not exist in config.'))
        }

        callback(null, value)
      })
    },
    /**
     * Set the current configuration for this repo.
     *
     * @param {String} key - the config key to be written
     * @param {Object} value - the config value to be written
     * @param {function(Error)} callback
     * @returns {void}
     */
    set (key, value, callback) {
      if (typeof value === 'function') {
        callback = value
        value = key
        key = undefined
      } else if (!key || typeof key !== 'string') {
        return callback(new Error('Invalid key type'))
      }

      if (value === undefined || Buffer.isBuffer(value)) {
        return callback(new Error('Invalid value type'))
      }

      setQueue.push({
        key: key,
        value: value
      }, callback)
    },

    /**
     * Check if a config file exists.
     *
     * @param {function(Error, bool)} callback
     * @returns {void}
     */
    exists (callback) {
      store.has(configKey, callback)
    }
  }

  return configStore

  function _doSet (m, callback) {
    const key = m.key
    const value = m.value
    if (key) {
      waterfall(
        [
          (cb) => configStore.get(cb),
          (config, cb) => {
            _set(config, key, value)
            cb(null, config)
          },
          _saveAll
        ],
        callback)
    } else {
      _saveAll(value, callback)
    }
  }

  function _saveAll (config, callback) {
    const buf = Buffer.from(JSON.stringify(config, null, 2))
    store.put(configKey, buf, callback)
  }
}

      };
    };
  }
}, {package:"ipfs-repo",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/config.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/blockstore.js", {"async/reject":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/reject.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","base32.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base32.js/base32.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","datastore-core":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/index.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js","ipfs-block":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-block/src/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js","pull-stream/sinks/collect":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/collect.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/blockstore.js
      return function (require, module, exports) {
'use strict'

const core = require('datastore-core')
const ShardingStore = core.ShardingDatastore
const Key = require('interface-datastore').Key
const base32 = require('base32.js')
const Block = require('ipfs-block')
const setImmediate = require('async/setImmediate')
const reject = require('async/reject')
const CID = require('cids')
const pull = require('pull-stream/pull')
const collect = require('pull-stream/sinks/collect')

/**
 * Transform a raw buffer to a base32 encoded key.
 *
 * @param {Buffer} rawKey
 * @returns {Key}
 */
const keyFromBuffer = (rawKey) => {
  const enc = new base32.Encoder()
  return new Key('/' + enc.write(rawKey).finalize(), false)
}

/**
 * Transform a cid to the appropriate datastore key.
 *
 * @param {CID} cid
 * @returns {Key}
 */
const cidToDsKey = (cid) => {
  return keyFromBuffer(cid.buffer)
}

module.exports = (filestore, options, callback) => {
  maybeWithSharding(filestore, options, (err, store) => {
    if (err) { return callback(err) }

    callback(null, createBaseStore(store))
  })
}

function maybeWithSharding (filestore, options, callback) {
  if (options.sharding) {
    const shard = new core.shard.NextToLast(2)
    ShardingStore.createOrOpen(filestore, shard, callback)
  } else {
    setImmediate(() => callback(null, filestore))
  }
}

function createBaseStore (store) {
  return {
    /**
     * Query the store.
     *
     * @param {object} query
     * @param {function(Error, Array)} callback
     * @return {void}
     */
    query (query, callback) {
      pull(
        store.query(query),
        collect(callback)
      )
    },
    /**
     * Get a single block by CID.
     *
     * @param {CID} cid
     * @param {function(Error, Block)} callback
     * @returns {void}
     */
    get (cid, callback) {
      if (!CID.isCID(cid)) {
        return setImmediate(() => {
          callback(new Error('Not a valid cid'))
        })
      }

      const key = cidToDsKey(cid)
      store.get(key, (err, blockData) => {
        if (err) {
          // If not found, we try with the other CID version.
          // If exists, then store that block under the CID that was requested.
          // Some duplication occurs.
          if (err.code === 'ERR_NOT_FOUND') {
            const otherCid = cidToOtherVersion(cid)
            if (!otherCid) return callback(err)

            const otherKey = cidToDsKey(otherCid)
            return store.get(otherKey, (err, blockData) => {
              if (err) return callback(err)

              store.put(key, blockData, (err) => {
                if (err) return callback(err)
                callback(null, new Block(blockData, cid))
              })
            })
          }

          return callback(err)
        }

        callback(null, new Block(blockData, cid))
      })
    },
    put (block, callback) {
      if (!Block.isBlock(block)) {
        return setImmediate(() => {
          callback(new Error('invalid block'))
        })
      }

      const k = cidToDsKey(block.cid)

      store.has(k, (err, exists) => {
        if (err) { return callback(err) }
        if (exists) { return callback() }

        store.put(k, block.data, callback)
      })
    },
    /**
     * Like put, but for more.
     *
     * @param {Array<Block>} blocks
     * @param {function(Error)} callback
     * @returns {void}
     */
    putMany (blocks, callback) {
      const keys = blocks.map((b) => ({
        key: cidToDsKey(b.cid),
        block: b
      }))

      const batch = store.batch()
      reject(keys, (k, cb) => store.has(k.key, cb), (err, newKeys) => {
        if (err) {
          return callback(err)
        }

        newKeys.forEach((k) => {
          batch.put(k.key, k.block.data)
        })

        batch.commit(callback)
      })
    },
    /**
     * Does the store contain block with this cid?
     *
     * @param {CID} cid
     * @param {function(Error, bool)} callback
     * @returns {void}
     */
    has (cid, callback) {
      if (!CID.isCID(cid)) {
        return setImmediate(() => {
          callback(new Error('Not a valid cid'))
        })
      }

      store.has(cidToDsKey(cid), (err, exists) => {
        if (err) return callback(err)
        if (exists) return callback(null, true)

        // If not found, we try with the other CID version.
        const otherCid = cidToOtherVersion(cid)
        if (!otherCid) return callback(null, false)

        store.has(cidToDsKey(otherCid), callback)
      })
    },
    /**
     * Delete a block from the store
     *
     * @param {CID} cid
     * @param {function(Error)} callback
     * @returns {void}
     */
    delete (cid, callback) {
      if (!CID.isCID(cid)) {
        return setImmediate(() => {
          callback(new Error('Not a valid cid'))
        })
      }

      store.delete(cidToDsKey(cid), callback)
    },

    close (callback) {
      store.close(callback)
    }
  }
}

function cidToOtherVersion (cid) {
  try {
    return cid.version === 0 ? cid.toV1() : cid.toV0()
  } catch (err) {
    return null
  }
}

      };
    };
  }
}, {package:"ipfs-repo",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/blockstore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/default-options-browser.js", {"datastore-level":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/default-options-browser.js
      return function (require, module, exports) {
'use strict'

// Default configuration for a repo in the browser
module.exports = {
  lock: 'memory',
  storageBackends: {
    root: require('datastore-level'),
    blocks: require('datastore-level'),
    keys: require('datastore-level'),
    datastore: require('datastore-level')
  },
  storageBackendOptions: {
    root: {
      extension: ''
    },
    blocks: {
      sharding: false
    },
    keys: {
      sharding: false
    }
  }
}

      };
    };
  }
}, {package:"ipfs-repo",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/default-options-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/fsm/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/fsm/index.js
      return function (require, module, exports) {
function each(obj, iter) {
  for(var key in obj) {
    var value = obj[key]
    iter(value, key, obj)
  }
}

function keys (obj) {
  return Object.keys(obj).sort()
}

function contains (a, v) {
  return ~a.indexOf(v)
}
function union (a, b) {
  return a.filter(function (v) {
    return contains(b, v)
  })
}

function disunion1(a, b) {
  return a.filter(function (v) {
    return !contains(b, v)
  })
}

function disunion(a, b) {
  return a.filter(function (v) {
    return !contains(b, v)
  }).concat(b.filter(function (v) {
    return !contains(a, v)
  })).sort()
}

function equal (a, b) {
  if(a.length != b.length) return false
  for(var i in a)
    if(b[i] !== a[i]) return false
}

function empty (v) {
  for(var k in v)
    return false
  return true
}

//check that all transitions are to valid states.
var validate = exports.validate = function (fsm) {
  var states = Object.keys(fsm)
  each(fsm, function (state, name) {
    each(state, function (_state, event) {
      if(!fsm[_state])
        throw new Error(
            'invalid transition from state:' + name
          + ' to state:' + _state
          + ' on event:' + event
        )
    })
  })
  return true
}

//get a list of all states that are reachable from any given state.
//(with the shortest paths?)
// returns object: {STATES: {REACHABLE_STATE: path}}

var reachable = exports.reachable = function (fsm) {
  var reachable = {}
  var added = false
  do {
    added = false
    each(fsm, function (state, name) {
      var reach = reachable[name] = reachable[name] || {}
      //add any state that can be reached directly.
      each(state, function (_name, event) {
        if(!reach[_name]) reach[_name] = [event], added = true
      })
      //add any state that can be reached from a state you can reach directly.
      each(state, function (_name, event) {
        var _state = reachable[_name]
        each(_state, function (path, _name) {
          if(!reach[_name])
            reach[_name] = [event].concat(path), added = true
        })
      })
    })
  } while(added);
  return reachable
}

// deadlock: are there any dead ends that cannot reach another state?

exports.terminal =
exports.deadlock = function (fsm) {
  var dead = []
  each(fsm, function (state, name) {
    if(empty(state)) dead.push(name)
  })
  return dead
}

// livelock; are there any cycles that cannot reach a terminal state?
// return any states that cannot reach the given terminal states,
// unless they are themselves terminal states.

var livelock = exports.livelock = function (fsm, terminals) {
  var reach = reachable(fsm), locked = []
  each(reach, function (reaches, name) {
    if(contains(terminals, name)) return
    each(terminals, function (_name) {
      if(!reaches[_name] && !contains(locked, name))
        locked.push(name)
    })
  })
  return locked.sort()
}


function events (fsm) {
  var events = []
  each(fsm, function (state, name) {
    each(state, function (_state, event) {
      if(!contains(events, event)) events.push(event)
    })
  })
  return events.sort()
}

var combine = exports.combine = function (fsm1, fsm2, start1, start2) {
  var combined = {}
  var events1 = events(fsm1)
  var events2 = events(fsm2)
  var independent = disunion(events1, events2)

  function expand(name1, name2) {
    var cName = name1 + '-' + name2, state
    if(!combined[cName]) combined[cName] = {}
    state = combined[cName]

    //Q: what are the events which are allowed to occur from this state?
    //A: independent events (used in only one fsm) or events that occur in both fsms in current state.

    var trans1 = keys(fsm1[name1]), trans2 = keys(fsm2[name2])
    var allowed = union(trans1, trans2)

    //expand to a new state
    allowed.forEach(function (event) {
      state[event] = fsm1[name1][event] + '-' + fsm2[name2][event]
      if(!combined[state[event]])
        expand(fsm1[name1][event], fsm2[name2][event])
    })

    //only transition fsm1
    union(independent, trans1).forEach(function (event) {
      state[event] = fsm1[name1][event] + '-' + name2
      if(!combined[state[event]])
        expand(fsm1[name1][event], name2)
    })

    union(independent, trans2).forEach(function (event) {
      state[event] =  name1 + '-' + fsm2[name2][event]
      if(!combined[state[event]])
        expand(name1, fsm2[name2][event])
    })

    return combined[cName]
  }

  expand(start1, start2)
  return combined
}


      };
    };
  }
}, {package:"fsm",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fsm/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/unique-by/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/unique-by/index.js
      return function (require, module, exports) {
'use strict';

module.exports = uniqueBy;

function uniqueBy(arr, getValue) {
  var unique = [];
  var found = {};

  if (typeof getValue !== 'function') {
    var key = getValue;
    getValue = function defaultGetValue(obj) {
      return obj[key];
    };
  }

  arr.forEach(function addUniques(obj) {
    var value = getValue(obj);
    if (!found[value]) {
      found[value] = true;
      unique.push(obj);
    }
  });

  return unique;
}

      };
    };
  }
}, {package:"unique-by",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/unique-by/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/keys.proto.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/keys.proto.js
      return function (require, module, exports) {
'use strict'

module.exports = `enum KeyType {
  RSA = 0;
  Ed25519 = 1;
  Secp256k1 = 2;
}
message PublicKey {
  required KeyType Type = 1;
  required bytes Data = 2;
}
message PrivateKey {
  required KeyType Type = 1;
  required bytes Data = 2;
}`
      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/keys.proto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js
      return function (require, module, exports) {
/**
 * Node.js module for Forge.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2016 Digital Bazaar, Inc.
 */
module.exports = {
  // default options
  options: {
    usePureJavaScript: false
  }
};

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ed25519-class.js", {"./ed25519":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ed25519.js","./keys.proto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/keys.proto.js","bs58":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bs58/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/index.js","protons":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ed25519-class.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const multihashing = require('multihashing-async')
const protobuf = require('protons')
const bs58 = require('bs58')

const crypto = require('./ed25519')
const pbm = protobuf(require('./keys.proto'))

class Ed25519PublicKey {
  constructor (key) {
    this._key = ensureKey(key, crypto.publicKeyLength)
  }

  verify (data, sig, callback) {
    ensure(callback)
    crypto.hashAndVerify(this._key, sig, data, callback)
  }

  marshal () {
    return Buffer.from(this._key)
  }

  get bytes () {
    return pbm.PublicKey.encode({
      Type: pbm.KeyType.Ed25519,
      Data: this.marshal()
    })
  }

  equals (key) {
    return this.bytes.equals(key.bytes)
  }

  hash (callback) {
    ensure(callback)
    multihashing(this.bytes, 'sha2-256', callback)
  }
}

class Ed25519PrivateKey {
  // key       - 64 byte Uint8Array or Buffer containing private key
  // publicKey - 32 byte Uint8Array or Buffer containing public key
  constructor (key, publicKey) {
    this._key = ensureKey(key, crypto.privateKeyLength)
    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength)
  }

  sign (message, callback) {
    ensure(callback)
    crypto.hashAndSign(this._key, message, callback)
  }

  get public () {
    if (!this._publicKey) {
      throw new Error('public key not provided')
    }

    return new Ed25519PublicKey(this._publicKey)
  }

  marshal () {
    return Buffer.concat([Buffer.from(this._key), Buffer.from(this._publicKey)])
  }

  get bytes () {
    return pbm.PrivateKey.encode({
      Type: pbm.KeyType.Ed25519,
      Data: this.marshal()
    })
  }

  equals (key) {
    return this.bytes.equals(key.bytes)
  }

  hash (callback) {
    ensure(callback)
    multihashing(this.bytes, 'sha2-256', callback)
  }

  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   *
   * @param {function(Error, id)} callback
   * @returns {undefined}
   */
  id (callback) {
    this.public.hash((err, hash) => {
      if (err) {
        return callback(err)
      }
      callback(null, bs58.encode(hash))
    })
  }
}

function unmarshalEd25519PrivateKey (bytes, callback) {
  try {
    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength)
  } catch (err) {
    return callback(err)
  }
  const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength)
  const publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length)
  callback(null, new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes))
}

function unmarshalEd25519PublicKey (bytes) {
  bytes = ensureKey(bytes, crypto.publicKeyLength)
  return new Ed25519PublicKey(bytes)
}

function generateKeyPair (_bits, cb) {
  if (cb === undefined && typeof _bits === 'function') {
    cb = _bits
  }

  crypto.generateKey((err, keys) => {
    if (err) {
      return cb(err)
    }
    let privkey
    try {
      privkey = new Ed25519PrivateKey(keys.secretKey, keys.publicKey)
    } catch (err) {
      cb(err)
      return
    }

    cb(null, privkey)
  })
}

function generateKeyPairFromSeed (seed, _bits, cb) {
  if (cb === undefined && typeof _bits === 'function') {
    cb = _bits
  }

  crypto.generateKeyFromSeed(seed, (err, keys) => {
    if (err) {
      return cb(err)
    }
    let privkey
    try {
      privkey = new Ed25519PrivateKey(keys.secretKey, keys.publicKey)
    } catch (err) {
      cb(err)
      return
    }

    cb(null, privkey)
  })
}

function ensure (cb) {
  if (typeof cb !== 'function') {
    throw new Error('callback is required')
  }
}

function ensureKey (key, length) {
  if (Buffer.isBuffer(key)) {
    key = new Uint8Array(key)
  }
  if (!(key instanceof Uint8Array) || key.length !== length) {
    throw new Error('Key must be a Uint8Array or Buffer of length ' + length)
  }
  return key
}

module.exports = {
  Ed25519PublicKey,
  Ed25519PrivateKey,
  unmarshalEd25519PrivateKey,
  unmarshalEd25519PublicKey,
  generateKeyPair,
  generateKeyPairFromSeed
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ed25519-class.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/key-stretcher.js", {"../hmac":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/hmac/index-browser.js","async/whilst":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/whilst.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/key-stretcher.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const whilst = require('async/whilst')
const hmac = require('../hmac')

const cipherMap = {
  'AES-128': {
    ivSize: 16,
    keySize: 16
  },
  'AES-256': {
    ivSize: 16,
    keySize: 32
  },
  Blowfish: {
    ivSize: 8,
    cipherKeySize: 32
  }
}

// Generates a set of keys for each party by stretching the shared key.
// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)
module.exports = (cipherType, hash, secret, callback) => {
  const cipher = cipherMap[cipherType]

  if (!cipher) {
    return callback(new Error('unkown cipherType passed'))
  }

  if (!hash) {
    return callback(new Error('unkown hashType passed'))
  }

  const cipherKeySize = cipher.keySize
  const ivSize = cipher.ivSize
  const hmacKeySize = 20
  const seed = Buffer.from('key expansion')
  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize)

  hmac.create(hash, secret, (err, m) => {
    if (err) {
      return callback(err)
    }

    m.digest(seed, (err, a) => {
      if (err) {
        return callback(err)
      }

      let result = []
      let j = 0

      whilst(
        () => j < resultLength,
        stretch,
        finish
      )

      function stretch (cb) {
        m.digest(Buffer.concat([a, seed]), (err, b) => {
          if (err) {
            return cb(err)
          }

          let todo = b.length

          if (j + todo > resultLength) {
            todo = resultLength - j
          }

          result.push(b)

          j += todo

          m.digest(a, (err, _a) => {
            if (err) {
              return cb(err)
            }
            a = _a
            cb()
          })
        })
      }

      function finish (err) {
        if (err) {
          return callback(err)
        }

        const half = resultLength / 2
        const resultBuffer = Buffer.concat(result)
        const r1 = resultBuffer.slice(0, half)
        const r2 = resultBuffer.slice(half, resultLength)

        const createKey = (res) => ({
          iv: res.slice(0, ivSize),
          cipherKey: res.slice(ivSize, ivSize + cipherKeySize),
          macKey: res.slice(ivSize + cipherKeySize)
        })

        callback(null, {
          k1: createKey(r1),
          k2: createKey(r2)
        })
      }
    })
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/key-stretcher.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/asn1.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./oids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/oids.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/asn1.js
      return function (require, module, exports) {
/**
 * Javascript implementation of Abstract Syntax Notation Number One.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 *
 * An API for storing data using the Abstract Syntax Notation Number One
 * format using DER (Distinguished Encoding Rules) encoding. This encoding is
 * commonly used to store data for PKI, i.e. X.509 Certificates, and this
 * implementation exists for that purpose.
 *
 * Abstract Syntax Notation Number One (ASN.1) is used to define the abstract
 * syntax of information without restricting the way the information is encoded
 * for transmission. It provides a standard that allows for open systems
 * communication. ASN.1 defines the syntax of information data and a number of
 * simple data types as well as a notation for describing them and specifying
 * values for them.
 *
 * The RSA algorithm creates public and private keys that are often stored in
 * X.509 or PKCS#X formats -- which use ASN.1 (encoded in DER format). This
 * class provides the most basic functionality required to store and load DSA
 * keys that are encoded according to ASN.1.
 *
 * The most common binary encodings for ASN.1 are BER (Basic Encoding Rules)
 * and DER (Distinguished Encoding Rules). DER is just a subset of BER that
 * has stricter requirements for how data must be encoded.
 *
 * Each ASN.1 structure has a tag (a byte identifying the ASN.1 structure type)
 * and a byte array for the value of this ASN1 structure which may be data or a
 * list of ASN.1 structures.
 *
 * Each ASN.1 structure using BER is (Tag-Length-Value):
 *
 * | byte 0 | bytes X | bytes Y |
 * |--------|---------|----------
 * |  tag   | length  |  value  |
 *
 * ASN.1 allows for tags to be of "High-tag-number form" which allows a tag to
 * be two or more octets, but that is not supported by this class. A tag is
 * only 1 byte. Bits 1-5 give the tag number (ie the data type within a
 * particular 'class'), 6 indicates whether or not the ASN.1 value is
 * constructed from other ASN.1 values, and bits 7 and 8 give the 'class'. If
 * bits 7 and 8 are both zero, the class is UNIVERSAL. If only bit 7 is set,
 * then the class is APPLICATION. If only bit 8 is set, then the class is
 * CONTEXT_SPECIFIC. If both bits 7 and 8 are set, then the class is PRIVATE.
 * The tag numbers for the data types for the class UNIVERSAL are listed below:
 *
 * UNIVERSAL 0 Reserved for use by the encoding rules
 * UNIVERSAL 1 Boolean type
 * UNIVERSAL 2 Integer type
 * UNIVERSAL 3 Bitstring type
 * UNIVERSAL 4 Octetstring type
 * UNIVERSAL 5 Null type
 * UNIVERSAL 6 Object identifier type
 * UNIVERSAL 7 Object descriptor type
 * UNIVERSAL 8 External type and Instance-of type
 * UNIVERSAL 9 Real type
 * UNIVERSAL 10 Enumerated type
 * UNIVERSAL 11 Embedded-pdv type
 * UNIVERSAL 12 UTF8String type
 * UNIVERSAL 13 Relative object identifier type
 * UNIVERSAL 14-15 Reserved for future editions
 * UNIVERSAL 16 Sequence and Sequence-of types
 * UNIVERSAL 17 Set and Set-of types
 * UNIVERSAL 18-22, 25-30 Character string types
 * UNIVERSAL 23-24 Time types
 *
 * The length of an ASN.1 structure is specified after the tag identifier.
 * There is a definite form and an indefinite form. The indefinite form may
 * be used if the encoding is constructed and not all immediately available.
 * The indefinite form is encoded using a length byte with only the 8th bit
 * set. The end of the constructed object is marked using end-of-contents
 * octets (two zero bytes).
 *
 * The definite form looks like this:
 *
 * The length may take up 1 or more bytes, it depends on the length of the
 * value of the ASN.1 structure. DER encoding requires that if the ASN.1
 * structure has a value that has a length greater than 127, more than 1 byte
 * will be used to store its length, otherwise just one byte will be used.
 * This is strict.
 *
 * In the case that the length of the ASN.1 value is less than 127, 1 octet
 * (byte) is used to store the "short form" length. The 8th bit has a value of
 * 0 indicating the length is "short form" and not "long form" and bits 7-1
 * give the length of the data. (The 8th bit is the left-most, most significant
 * bit: also known as big endian or network format).
 *
 * In the case that the length of the ASN.1 value is greater than 127, 2 to
 * 127 octets (bytes) are used to store the "long form" length. The first
 * byte's 8th bit is set to 1 to indicate the length is "long form." Bits 7-1
 * give the number of additional octets. All following octets are in base 256
 * with the most significant digit first (typical big-endian binary unsigned
 * integer storage). So, for instance, if the length of a value was 257, the
 * first byte would be set to:
 *
 * 10000010 = 130 = 0x82.
 *
 * This indicates there are 2 octets (base 256) for the length. The second and
 * third bytes (the octets just mentioned) would store the length in base 256:
 *
 * octet 2: 00000001 = 1 * 256^1 = 256
 * octet 3: 00000001 = 1 * 256^0 = 1
 * total = 257
 *
 * The algorithm for converting a js integer value of 257 to base-256 is:
 *
 * var value = 257;
 * var bytes = [];
 * bytes[0] = (value >>> 8) & 0xFF; // most significant byte first
 * bytes[1] = value & 0xFF;        // least significant byte last
 *
 * On the ASN.1 UNIVERSAL Object Identifier (OID) type:
 *
 * An OID can be written like: "value1.value2.value3...valueN"
 *
 * The DER encoding rules:
 *
 * The first byte has the value 40 * value1 + value2.
 * The following bytes, if any, encode the remaining values. Each value is
 * encoded in base 128, most significant digit first (big endian), with as
 * few digits as possible, and the most significant bit of each byte set
 * to 1 except the last in each value's encoding. For example: Given the
 * OID "1.2.840.113549", its DER encoding is (remember each byte except the
 * last one in each encoding is OR'd with 0x80):
 *
 * byte 1: 40 * 1 + 2 = 42 = 0x2A.
 * bytes 2-3: 128 * 6 + 72 = 840 = 6 72 = 6 72 = 0x0648 = 0x8648
 * bytes 4-6: 16384 * 6 + 128 * 119 + 13 = 6 119 13 = 0x06770D = 0x86F70D
 *
 * The final value is: 0x2A864886F70D.
 * The full OID (including ASN.1 tag and length of 6 bytes) is:
 * 0x06062A864886F70D
 */
var forge = require('./forge');
require('./util');
require('./oids');

/* ASN.1 API */
var asn1 = module.exports = forge.asn1 = forge.asn1 || {};

/**
 * ASN.1 classes.
 */
asn1.Class = {
  UNIVERSAL:        0x00,
  APPLICATION:      0x40,
  CONTEXT_SPECIFIC: 0x80,
  PRIVATE:          0xC0
};

/**
 * ASN.1 types. Not all types are supported by this implementation, only
 * those necessary to implement a simple PKI are implemented.
 */
asn1.Type = {
  NONE:             0,
  BOOLEAN:          1,
  INTEGER:          2,
  BITSTRING:        3,
  OCTETSTRING:      4,
  NULL:             5,
  OID:              6,
  ODESC:            7,
  EXTERNAL:         8,
  REAL:             9,
  ENUMERATED:      10,
  EMBEDDED:        11,
  UTF8:            12,
  ROID:            13,
  SEQUENCE:        16,
  SET:             17,
  PRINTABLESTRING: 19,
  IA5STRING:       22,
  UTCTIME:         23,
  GENERALIZEDTIME: 24,
  BMPSTRING:       30
};

/**
 * Creates a new asn1 object.
 *
 * @param tagClass the tag class for the object.
 * @param type the data type (tag number) for the object.
 * @param constructed true if the asn1 object is in constructed form.
 * @param value the value for the object, if it is not constructed.
 * @param [options] the options to use:
 *          [bitStringContents] the plain BIT STRING content including padding
 *            byte.
 *
 * @return the asn1 object.
 */
asn1.create = function(tagClass, type, constructed, value, options) {
  /* An asn1 object has a tagClass, a type, a constructed flag, and a
    value. The value's type depends on the constructed flag. If
    constructed, it will contain a list of other asn1 objects. If not,
    it will contain the ASN.1 value as an array of bytes formatted
    according to the ASN.1 data type. */

  // remove undefined values
  if(forge.util.isArray(value)) {
    var tmp = [];
    for(var i = 0; i < value.length; ++i) {
      if(value[i] !== undefined) {
        tmp.push(value[i]);
      }
    }
    value = tmp;
  }

  var obj = {
    tagClass: tagClass,
    type: type,
    constructed: constructed,
    composed: constructed || forge.util.isArray(value),
    value: value
  };
  if(options && 'bitStringContents' in options) {
    // TODO: copy byte buffer if it's a buffer not a string
    obj.bitStringContents = options.bitStringContents;
    // TODO: add readonly flag to avoid this overhead
    // save copy to detect changes
    obj.original = asn1.copy(obj);
  }
  return obj;
};

/**
 * Copies an asn1 object.
 *
 * @param obj the asn1 object.
 * @param [options] copy options:
 *          [excludeBitStringContents] true to not copy bitStringContents
 *
 * @return the a copy of the asn1 object.
 */
asn1.copy = function(obj, options) {
  var copy;

  if(forge.util.isArray(obj)) {
    copy = [];
    for(var i = 0; i < obj.length; ++i) {
      copy.push(asn1.copy(obj[i], options));
    }
    return copy;
  }

  if(typeof obj === 'string') {
    // TODO: copy byte buffer if it's a buffer not a string
    return obj;
  }

  copy = {
    tagClass: obj.tagClass,
    type: obj.type,
    constructed: obj.constructed,
    composed: obj.composed,
    value: asn1.copy(obj.value, options)
  };
  if(options && !options.excludeBitStringContents) {
    // TODO: copy byte buffer if it's a buffer not a string
    copy.bitStringContents = obj.bitStringContents;
  }
  return copy;
};

/**
 * Compares asn1 objects for equality.
 *
 * Note this function does not run in constant time.
 *
 * @param obj1 the first asn1 object.
 * @param obj2 the second asn1 object.
 * @param [options] compare options:
 *          [includeBitStringContents] true to compare bitStringContents
 *
 * @return true if the asn1 objects are equal.
 */
asn1.equals = function(obj1, obj2, options) {
  if(forge.util.isArray(obj1)) {
    if(!forge.util.isArray(obj2)) {
      return false;
    }
    if(obj1.length !== obj2.length) {
      return false;
    }
    for(var i = 0; i < obj1.length; ++i) {
      if(!asn1.equals(obj1[i], obj2[i])) {
        return false;
      }
    }
    return true;
  }

  if(typeof obj1 !== typeof obj2) {
    return false;
  }

  if(typeof obj1 === 'string') {
    return obj1 === obj2;
  }

  var equal = obj1.tagClass === obj2.tagClass &&
    obj1.type === obj2.type &&
    obj1.constructed === obj2.constructed &&
    obj1.composed === obj2.composed &&
    asn1.equals(obj1.value, obj2.value);
  if(options && options.includeBitStringContents) {
    equal = equal && (obj1.bitStringContents === obj2.bitStringContents);
  }

  return equal;
};

/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param b the BER-encoded ASN.1 byte buffer, starting with the first
 *          length byte.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */
asn1.getBerValueLength = function(b) {
  // TODO: move this function and related DER/BER functions to a der.js
  // file; better abstract ASN.1 away from der/ber.
  var b2 = b.getByte();
  if(b2 === 0x80) {
    return undefined;
  }

  // see if the length is "short form" or "long form" (bit 8 set)
  var length;
  var longForm = b2 & 0x80;
  if(!longForm) {
    // length is just the first byte
    length = b2;
  } else {
    // the number of bytes the length is specified in bits 7 through 1
    // and each length byte is in big-endian base-256
    length = b.getInt((b2 & 0x7F) << 3);
  }
  return length;
};

/**
 * Check if the byte buffer has enough bytes. Throws an Error if not.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 * @param n the number of bytes the buffer must have.
 */
function _checkBufferLength(bytes, remaining, n) {
  if(n > remaining) {
    var error = new Error('Too few bytes to parse DER.');
    error.available = bytes.length();
    error.remaining = remaining;
    error.requested = n;
    throw error;
  }
}

/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */
var _getValueLength = function(bytes, remaining) {
  // TODO: move this function and related DER/BER functions to a der.js
  // file; better abstract ASN.1 away from der/ber.
  // fromDer already checked that this byte exists
  var b2 = bytes.getByte();
  remaining--;
  if(b2 === 0x80) {
    return undefined;
  }

  // see if the length is "short form" or "long form" (bit 8 set)
  var length;
  var longForm = b2 & 0x80;
  if(!longForm) {
    // length is just the first byte
    length = b2;
  } else {
    // the number of bytes the length is specified in bits 7 through 1
    // and each length byte is in big-endian base-256
    var longFormBytes = b2 & 0x7F;
    _checkBufferLength(bytes, remaining, longFormBytes);
    length = bytes.getInt(longFormBytes << 3);
  }
  // FIXME: this will only happen for 32 bit getInt with high bit set
  if(length < 0) {
    throw new Error('Negative length: ' + length);
  }
  return length;
};

/**
 * Parses an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param [strict] true to be strict when checking value lengths, false to
 *          allow truncated values (default: true).
 * @param [options] object with options or boolean strict flag
 *          [strict] true to be strict when checking value lengths, false to
 *            allow truncated values (default: true).
 *          [decodeBitStrings] true to attempt to decode the content of
 *            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that
 *            without schema support to understand the data context this can
 *            erroneously decode values that happen to be valid ASN.1. This
 *            flag will be deprecated or removed as soon as schema support is
 *            available. (default: true)
 *
 * @return the parsed asn1 object.
 */
asn1.fromDer = function(bytes, options) {
  if(options === undefined) {
    options = {
      strict: true,
      decodeBitStrings: true
    };
  }
  if(typeof options === 'boolean') {
    options = {
      strict: options,
      decodeBitStrings: true
    };
  }
  if(!('strict' in options)) {
    options.strict = true;
  }
  if(!('decodeBitStrings' in options)) {
    options.decodeBitStrings = true;
  }

  // wrap in buffer if needed
  if(typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  return _fromDer(bytes, bytes.length(), 0, options);
};

/**
 * Internal function to parse an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the number of bytes remaining for this chunk.
 * @param depth the current parsing depth.
 * @param options object with same options as fromDer().
 *
 * @return the parsed asn1 object.
 */
function _fromDer(bytes, remaining, depth, options) {
  // temporary storage for consumption calculations
  var start;

  // minimum length for ASN.1 DER structure is 2
  _checkBufferLength(bytes, remaining, 2);

  // get the first byte
  var b1 = bytes.getByte();
  // consumed one byte
  remaining--;

  // get the tag class
  var tagClass = (b1 & 0xC0);

  // get the type (bits 1-5)
  var type = b1 & 0x1F;

  // get the variable value length and adjust remaining bytes
  start = bytes.length();
  var length = _getValueLength(bytes, remaining);
  remaining -= start - bytes.length();

  // ensure there are enough bytes to get the value
  if(length !== undefined && length > remaining) {
    if(options.strict) {
      var error = new Error('Too few bytes to read ASN.1 value.');
      error.available = bytes.length();
      error.remaining = remaining;
      error.requested = length;
      throw error;
    }
    // Note: be lenient with truncated values and use remaining state bytes
    length = remaining;
  }

  // value storage
  var value;
  // possible BIT STRING contents storage
  var bitStringContents;

  // constructed flag is bit 6 (32 = 0x20) of the first byte
  var constructed = ((b1 & 0x20) === 0x20);
  if(constructed) {
    // parse child asn1 objects from the value
    value = [];
    if(length === undefined) {
      // asn1 object of indefinite length, read until end tag
      for(;;) {
        _checkBufferLength(bytes, remaining, 2);
        if(bytes.bytes(2) === String.fromCharCode(0, 0)) {
          bytes.getBytes(2);
          remaining -= 2;
          break;
        }
        start = bytes.length();
        value.push(_fromDer(bytes, remaining, depth + 1, options));
        remaining -= start - bytes.length();
      }
    } else {
      // parsing asn1 object of definite length
      while(length > 0) {
        start = bytes.length();
        value.push(_fromDer(bytes, length, depth + 1, options));
        remaining -= start - bytes.length();
        length -= start - bytes.length();
      }
    }
  }

  // if a BIT STRING, save the contents including padding
  if(value === undefined && tagClass === asn1.Class.UNIVERSAL &&
    type === asn1.Type.BITSTRING) {
    bitStringContents = bytes.bytes(length);
  }

  // determine if a non-constructed value should be decoded as a composed
  // value that contains other ASN.1 objects. BIT STRINGs (and OCTET STRINGs)
  // can be used this way.
  if(value === undefined && options.decodeBitStrings &&
    tagClass === asn1.Class.UNIVERSAL &&
    // FIXME: OCTET STRINGs not yet supported here
    // .. other parts of forge expect to decode OCTET STRINGs manually
    (type === asn1.Type.BITSTRING /*|| type === asn1.Type.OCTETSTRING*/) &&
    length > 1) {
    // save read position
    var savedRead = bytes.read;
    var savedRemaining = remaining;
    var unused = 0;
    if(type === asn1.Type.BITSTRING) {
      /* The first octet gives the number of bits by which the length of the
        bit string is less than the next multiple of eight (this is called
        the "number of unused bits").

        The second and following octets give the value of the bit string
        converted to an octet string. */
      _checkBufferLength(bytes, remaining, 1);
      unused = bytes.getByte();
      remaining--;
    }
    // if all bits are used, maybe the BIT/OCTET STRING holds ASN.1 objs
    if(unused === 0) {
      try {
        // attempt to parse child asn1 object from the value
        // (stored in array to signal composed value)
        start = bytes.length();
        var subOptions = {
          // enforce strict mode to avoid parsing ASN.1 from plain data
          verbose: options.verbose,
          strict: true,
          decodeBitStrings: true
        };
        var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
        var used = start - bytes.length();
        remaining -= used;
        if(type == asn1.Type.BITSTRING) {
          used++;
        }

        // if the data all decoded and the class indicates UNIVERSAL or
        // CONTEXT_SPECIFIC then assume we've got an encapsulated ASN.1 object
        var tc = composed.tagClass;
        if(used === length &&
          (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
          value = [composed];
        }
      } catch(ex) {
      }
    }
    if(value === undefined) {
      // restore read position
      bytes.read = savedRead;
      remaining = savedRemaining;
    }
  }

  if(value === undefined) {
    // asn1 not constructed or composed, get raw value
    // TODO: do DER to OID conversion and vice-versa in .toDer?

    if(length === undefined) {
      if(options.strict) {
        throw new Error('Non-constructed ASN.1 object of indefinite length.');
      }
      // be lenient and use remaining state bytes
      length = remaining;
    }

    if(type === asn1.Type.BMPSTRING) {
      value = '';
      for(; length > 0; length -= 2) {
        _checkBufferLength(bytes, remaining, 2);
        value += String.fromCharCode(bytes.getInt16());
        remaining -= 2;
      }
    } else {
      value = bytes.getBytes(length);
    }
  }

  // add BIT STRING contents if available
  var asn1Options = bitStringContents === undefined ? null : {
    bitStringContents: bitStringContents
  };

  // create and return asn1 object
  return asn1.create(tagClass, type, constructed, value, asn1Options);
}

/**
 * Converts the given asn1 object to a buffer of bytes in DER format.
 *
 * @param asn1 the asn1 object to convert to bytes.
 *
 * @return the buffer of bytes.
 */
asn1.toDer = function(obj) {
  var bytes = forge.util.createBuffer();

  // build the first byte
  var b1 = obj.tagClass | obj.type;

  // for storing the ASN.1 value
  var value = forge.util.createBuffer();

  // use BIT STRING contents if available and data not changed
  var useBitStringContents = false;
  if('bitStringContents' in obj) {
    useBitStringContents = true;
    if(obj.original) {
      useBitStringContents = asn1.equals(obj, obj.original);
    }
  }

  if(useBitStringContents) {
    value.putBytes(obj.bitStringContents);
  } else if(obj.composed) {
    // if composed, use each child asn1 object's DER bytes as value
    // turn on 6th bit (0x20 = 32) to indicate asn1 is constructed
    // from other asn1 objects
    if(obj.constructed) {
      b1 |= 0x20;
    } else {
      // type is a bit string, add unused bits of 0x00
      value.putByte(0x00);
    }

    // add all of the child DER bytes together
    for(var i = 0; i < obj.value.length; ++i) {
      if(obj.value[i] !== undefined) {
        value.putBuffer(asn1.toDer(obj.value[i]));
      }
    }
  } else {
    // use asn1.value directly
    if(obj.type === asn1.Type.BMPSTRING) {
      for(var i = 0; i < obj.value.length; ++i) {
        value.putInt16(obj.value.charCodeAt(i));
      }
    } else {
      // ensure integer is minimally-encoded
      // TODO: should all leading bytes be stripped vs just one?
      // .. ex '00 00 01' => '01'?
      if(obj.type === asn1.Type.INTEGER &&
        obj.value.length > 1 &&
        // leading 0x00 for positive integer
        ((obj.value.charCodeAt(0) === 0 &&
        (obj.value.charCodeAt(1) & 0x80) === 0) ||
        // leading 0xFF for negative integer
        (obj.value.charCodeAt(0) === 0xFF &&
        (obj.value.charCodeAt(1) & 0x80) === 0x80))) {
        value.putBytes(obj.value.substr(1));
      } else {
        value.putBytes(obj.value);
      }
    }
  }

  // add tag byte
  bytes.putByte(b1);

  // use "short form" encoding
  if(value.length() <= 127) {
    // one byte describes the length
    // bit 8 = 0 and bits 7-1 = length
    bytes.putByte(value.length() & 0x7F);
  } else {
    // use "long form" encoding
    // 2 to 127 bytes describe the length
    // first byte: bit 8 = 1 and bits 7-1 = # of additional bytes
    // other bytes: length in base 256, big-endian
    var len = value.length();
    var lenBytes = '';
    do {
      lenBytes += String.fromCharCode(len & 0xFF);
      len = len >>> 8;
    } while(len > 0);

    // set first byte to # bytes used to store the length and turn on
    // bit 8 to indicate long-form length is used
    bytes.putByte(lenBytes.length | 0x80);

    // concatenate length bytes in reverse since they were generated
    // little endian and we need big endian
    for(var i = lenBytes.length - 1; i >= 0; --i) {
      bytes.putByte(lenBytes.charCodeAt(i));
    }
  }

  // concatenate value bytes
  bytes.putBuffer(value);
  return bytes;
};

/**
 * Converts an OID dot-separated string to a byte buffer. The byte buffer
 * contains only the DER-encoded value, not any tag or length bytes.
 *
 * @param oid the OID dot-separated string.
 *
 * @return the byte buffer.
 */
asn1.oidToDer = function(oid) {
  // split OID into individual values
  var values = oid.split('.');
  var bytes = forge.util.createBuffer();

  // first byte is 40 * value1 + value2
  bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
  // other bytes are each value in base 128 with 8th bit set except for
  // the last byte for each value
  var last, valueBytes, value, b;
  for(var i = 2; i < values.length; ++i) {
    // produce value bytes in reverse because we don't know how many
    // bytes it will take to store the value
    last = true;
    valueBytes = [];
    value = parseInt(values[i], 10);
    do {
      b = value & 0x7F;
      value = value >>> 7;
      // if value is not last, then turn on 8th bit
      if(!last) {
        b |= 0x80;
      }
      valueBytes.push(b);
      last = false;
    } while(value > 0);

    // add value bytes in reverse (needs to be in big endian)
    for(var n = valueBytes.length - 1; n >= 0; --n) {
      bytes.putByte(valueBytes[n]);
    }
  }

  return bytes;
};

/**
 * Converts a DER-encoded byte buffer to an OID dot-separated string. The
 * byte buffer should contain only the DER-encoded value, not any tag or
 * length bytes.
 *
 * @param bytes the byte buffer.
 *
 * @return the OID dot-separated string.
 */
asn1.derToOid = function(bytes) {
  var oid;

  // wrap in buffer if needed
  if(typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  // first byte is 40 * value1 + value2
  var b = bytes.getByte();
  oid = Math.floor(b / 40) + '.' + (b % 40);

  // other bytes are each value in base 128 with 8th bit set except for
  // the last byte for each value
  var value = 0;
  while(bytes.length() > 0) {
    b = bytes.getByte();
    value = value << 7;
    // not the last byte for the value
    if(b & 0x80) {
      value += b & 0x7F;
    } else {
      // last byte
      oid += '.' + (value + b);
      value = 0;
    }
  }

  return oid;
};

/**
 * Converts a UTCTime value to a date.
 *
 * Note: GeneralizedTime has 4 digits for the year and is used for X.509
 * dates past 2049. Parsing that structure hasn't been implemented yet.
 *
 * @param utc the UTCTime value to convert.
 *
 * @return the date.
 */
asn1.utcTimeToDate = function(utc) {
  /* The following formats can be used:

    YYMMDDhhmmZ
    YYMMDDhhmm+hh'mm'
    YYMMDDhhmm-hh'mm'
    YYMMDDhhmmssZ
    YYMMDDhhmmss+hh'mm'
    YYMMDDhhmmss-hh'mm'

    Where:

    YY is the least significant two digits of the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */
  var date = new Date();

  // if YY >= 50 use 19xx, if YY < 50 use 20xx
  var year = parseInt(utc.substr(0, 2), 10);
  year = (year >= 50) ? 1900 + year : 2000 + year;
  var MM = parseInt(utc.substr(2, 2), 10) - 1; // use 0-11 for month
  var DD = parseInt(utc.substr(4, 2), 10);
  var hh = parseInt(utc.substr(6, 2), 10);
  var mm = parseInt(utc.substr(8, 2), 10);
  var ss = 0;

  // not just YYMMDDhhmmZ
  if(utc.length > 11) {
    // get character after minutes
    var c = utc.charAt(10);
    var end = 10;

    // see if seconds are present
    if(c !== '+' && c !== '-') {
      // get seconds
      ss = parseInt(utc.substr(10, 2), 10);
      end += 2;
    }
  }

  // update date
  date.setUTCFullYear(year, MM, DD);
  date.setUTCHours(hh, mm, ss, 0);

  if(end) {
    // get +/- after end of time
    c = utc.charAt(end);
    if(c === '+' || c === '-') {
      // get hours+minutes offset
      var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
      var mmoffset = parseInt(utc.substr(end + 4, 2), 10);

      // calculate offset in milliseconds
      var offset = hhoffset * 60 + mmoffset;
      offset *= 60000;

      // apply offset
      if(c === '+') {
        date.setTime(+date - offset);
      } else {
        date.setTime(+date + offset);
      }
    }
  }

  return date;
};

/**
 * Converts a GeneralizedTime value to a date.
 *
 * @param gentime the GeneralizedTime value to convert.
 *
 * @return the date.
 */
asn1.generalizedTimeToDate = function(gentime) {
  /* The following formats can be used:

    YYYYMMDDHHMMSS
    YYYYMMDDHHMMSS.fff
    YYYYMMDDHHMMSSZ
    YYYYMMDDHHMMSS.fffZ
    YYYYMMDDHHMMSS+hh'mm'
    YYYYMMDDHHMMSS.fff+hh'mm'
    YYYYMMDDHHMMSS-hh'mm'
    YYYYMMDDHHMMSS.fff-hh'mm'

    Where:

    YYYY is the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    .fff is the second fraction, accurate to three decimal places
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */
  var date = new Date();

  var YYYY = parseInt(gentime.substr(0, 4), 10);
  var MM = parseInt(gentime.substr(4, 2), 10) - 1; // use 0-11 for month
  var DD = parseInt(gentime.substr(6, 2), 10);
  var hh = parseInt(gentime.substr(8, 2), 10);
  var mm = parseInt(gentime.substr(10, 2), 10);
  var ss = parseInt(gentime.substr(12, 2), 10);
  var fff = 0;
  var offset = 0;
  var isUTC = false;

  if(gentime.charAt(gentime.length - 1) === 'Z') {
    isUTC = true;
  }

  var end = gentime.length - 5, c = gentime.charAt(end);
  if(c === '+' || c === '-') {
    // get hours+minutes offset
    var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
    var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);

    // calculate offset in milliseconds
    offset = hhoffset * 60 + mmoffset;
    offset *= 60000;

    // apply offset
    if(c === '+') {
      offset *= -1;
    }

    isUTC = true;
  }

  // check for second fraction
  if(gentime.charAt(14) === '.') {
    fff = parseFloat(gentime.substr(14), 10) * 1000;
  }

  if(isUTC) {
    date.setUTCFullYear(YYYY, MM, DD);
    date.setUTCHours(hh, mm, ss, fff);

    // apply offset
    date.setTime(+date + offset);
  } else {
    date.setFullYear(YYYY, MM, DD);
    date.setHours(hh, mm, ss, fff);
  }

  return date;
};

/**
 * Converts a date to a UTCTime value.
 *
 * Note: GeneralizedTime has 4 digits for the year and is used for X.509
 * dates past 2049. Converting to a GeneralizedTime hasn't been
 * implemented yet.
 *
 * @param date the date to convert.
 *
 * @return the UTCTime value.
 */
asn1.dateToUtcTime = function(date) {
  // TODO: validate; currently assumes proper format
  if(typeof date === 'string') {
    return date;
  }

  var rval = '';

  // create format YYMMDDhhmmssZ
  var format = [];
  format.push(('' + date.getUTCFullYear()).substr(2));
  format.push('' + (date.getUTCMonth() + 1));
  format.push('' + date.getUTCDate());
  format.push('' + date.getUTCHours());
  format.push('' + date.getUTCMinutes());
  format.push('' + date.getUTCSeconds());

  // ensure 2 digits are used for each format entry
  for(var i = 0; i < format.length; ++i) {
    if(format[i].length < 2) {
      rval += '0';
    }
    rval += format[i];
  }
  rval += 'Z';

  return rval;
};

/**
 * Converts a date to a GeneralizedTime value.
 *
 * @param date the date to convert.
 *
 * @return the GeneralizedTime value as a string.
 */
asn1.dateToGeneralizedTime = function(date) {
  // TODO: validate; currently assumes proper format
  if(typeof date === 'string') {
    return date;
  }

  var rval = '';

  // create format YYYYMMDDHHMMSSZ
  var format = [];
  format.push('' + date.getUTCFullYear());
  format.push('' + (date.getUTCMonth() + 1));
  format.push('' + date.getUTCDate());
  format.push('' + date.getUTCHours());
  format.push('' + date.getUTCMinutes());
  format.push('' + date.getUTCSeconds());

  // ensure 2 digits are used for each format entry
  for(var i = 0; i < format.length; ++i) {
    if(format[i].length < 2) {
      rval += '0';
    }
    rval += format[i];
  }
  rval += 'Z';

  return rval;
};

/**
 * Converts a javascript integer to a DER-encoded byte buffer to be used
 * as the value for an INTEGER type.
 *
 * @param x the integer.
 *
 * @return the byte buffer.
 */
asn1.integerToDer = function(x) {
  var rval = forge.util.createBuffer();
  if(x >= -0x80 && x < 0x80) {
    return rval.putSignedInt(x, 8);
  }
  if(x >= -0x8000 && x < 0x8000) {
    return rval.putSignedInt(x, 16);
  }
  if(x >= -0x800000 && x < 0x800000) {
    return rval.putSignedInt(x, 24);
  }
  if(x >= -0x80000000 && x < 0x80000000) {
    return rval.putSignedInt(x, 32);
  }
  var error = new Error('Integer too large; max is 32-bits.');
  error.integer = x;
  throw error;
};

/**
 * Converts a DER-encoded byte buffer to a javascript integer. This is
 * typically used to decode the value of an INTEGER type.
 *
 * @param bytes the byte buffer.
 *
 * @return the integer.
 */
asn1.derToInteger = function(bytes) {
  // wrap in buffer if needed
  if(typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  var n = bytes.length() * 8;
  if(n > 32) {
    throw new Error('Integer too large; max is 32-bits.');
  }
  return bytes.getSignedInt(n);
};

/**
 * Validates that the given ASN.1 object is at least a super set of the
 * given ASN.1 structure. Only tag classes and types are checked. An
 * optional map may also be provided to capture ASN.1 values while the
 * structure is checked.
 *
 * To capture an ASN.1 value, set an object in the validator's 'capture'
 * parameter to the key to use in the capture map. To capture the full
 * ASN.1 object, specify 'captureAsn1'. To capture BIT STRING bytes, including
 * the leading unused bits counter byte, specify 'captureBitStringContents'.
 * To capture BIT STRING bytes, without the leading unused bits counter byte,
 * specify 'captureBitStringValue'.
 *
 * Objects in the validator may set a field 'optional' to true to indicate
 * that it isn't necessary to pass validation.
 *
 * @param obj the ASN.1 object to validate.
 * @param v the ASN.1 structure validator.
 * @param capture an optional map to capture values in.
 * @param errors an optional array for storing validation errors.
 *
 * @return true on success, false on failure.
 */
asn1.validate = function(obj, v, capture, errors) {
  var rval = false;

  // ensure tag class and type are the same if specified
  if((obj.tagClass === v.tagClass || typeof(v.tagClass) === 'undefined') &&
    (obj.type === v.type || typeof(v.type) === 'undefined')) {
    // ensure constructed flag is the same if specified
    if(obj.constructed === v.constructed ||
      typeof(v.constructed) === 'undefined') {
      rval = true;

      // handle sub values
      if(v.value && forge.util.isArray(v.value)) {
        var j = 0;
        for(var i = 0; rval && i < v.value.length; ++i) {
          rval = v.value[i].optional || false;
          if(obj.value[j]) {
            rval = asn1.validate(obj.value[j], v.value[i], capture, errors);
            if(rval) {
              ++j;
            } else if(v.value[i].optional) {
              rval = true;
            }
          }
          if(!rval && errors) {
            errors.push(
              '[' + v.name + '] ' +
              'Tag class "' + v.tagClass + '", type "' +
              v.type + '" expected value length "' +
              v.value.length + '", got "' +
              obj.value.length + '"');
          }
        }
      }

      if(rval && capture) {
        if(v.capture) {
          capture[v.capture] = obj.value;
        }
        if(v.captureAsn1) {
          capture[v.captureAsn1] = obj;
        }
        if(v.captureBitStringContents && 'bitStringContents' in obj) {
          capture[v.captureBitStringContents] = obj.bitStringContents;
        }
        if(v.captureBitStringValue && 'bitStringContents' in obj) {
          var value;
          if(obj.bitStringContents.length < 2) {
            capture[v.captureBitStringValue] = '';
          } else {
            // FIXME: support unused bits with data shifting
            var unused = obj.bitStringContents.charCodeAt(0);
            if(unused !== 0) {
              throw new Error(
                'captureBitStringValue only supported for zero unused bits');
            }
            capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
          }
        }
      }
    } else if(errors) {
      errors.push(
        '[' + v.name + '] ' +
        'Expected constructed "' + v.constructed + '", got "' +
        obj.constructed + '"');
    }
  } else if(errors) {
    if(obj.tagClass !== v.tagClass) {
      errors.push(
        '[' + v.name + '] ' +
        'Expected tag class "' + v.tagClass + '", got "' +
        obj.tagClass + '"');
    }
    if(obj.type !== v.type) {
      errors.push(
        '[' + v.name + '] ' +
        'Expected type "' + v.type + '", got "' + obj.type + '"');
    }
  }
  return rval;
};

// regex for testing for non-latin characters
var _nonLatinRegex = /[^\\u0000-\\u00ff]/;

/**
 * Pretty prints an ASN.1 object to a string.
 *
 * @param obj the object to write out.
 * @param level the level in the tree.
 * @param indentation the indentation to use.
 *
 * @return the string.
 */
asn1.prettyPrint = function(obj, level, indentation) {
  var rval = '';

  // set default level and indentation
  level = level || 0;
  indentation = indentation || 2;

  // start new line for deep levels
  if(level > 0) {
    rval += '\n';
  }

  // create indent
  var indent = '';
  for(var i = 0; i < level * indentation; ++i) {
    indent += ' ';
  }

  // print class:type
  rval += indent + 'Tag: ';
  switch(obj.tagClass) {
  case asn1.Class.UNIVERSAL:
    rval += 'Universal:';
    break;
  case asn1.Class.APPLICATION:
    rval += 'Application:';
    break;
  case asn1.Class.CONTEXT_SPECIFIC:
    rval += 'Context-Specific:';
    break;
  case asn1.Class.PRIVATE:
    rval += 'Private:';
    break;
  }

  if(obj.tagClass === asn1.Class.UNIVERSAL) {
    rval += obj.type;

    // known types
    switch(obj.type) {
    case asn1.Type.NONE:
      rval += ' (None)';
      break;
    case asn1.Type.BOOLEAN:
      rval += ' (Boolean)';
      break;
    case asn1.Type.INTEGER:
      rval += ' (Integer)';
      break;
    case asn1.Type.BITSTRING:
      rval += ' (Bit string)';
      break;
    case asn1.Type.OCTETSTRING:
      rval += ' (Octet string)';
      break;
    case asn1.Type.NULL:
      rval += ' (Null)';
      break;
    case asn1.Type.OID:
      rval += ' (Object Identifier)';
      break;
    case asn1.Type.ODESC:
      rval += ' (Object Descriptor)';
      break;
    case asn1.Type.EXTERNAL:
      rval += ' (External or Instance of)';
      break;
    case asn1.Type.REAL:
      rval += ' (Real)';
      break;
    case asn1.Type.ENUMERATED:
      rval += ' (Enumerated)';
      break;
    case asn1.Type.EMBEDDED:
      rval += ' (Embedded PDV)';
      break;
    case asn1.Type.UTF8:
      rval += ' (UTF8)';
      break;
    case asn1.Type.ROID:
      rval += ' (Relative Object Identifier)';
      break;
    case asn1.Type.SEQUENCE:
      rval += ' (Sequence)';
      break;
    case asn1.Type.SET:
      rval += ' (Set)';
      break;
    case asn1.Type.PRINTABLESTRING:
      rval += ' (Printable String)';
      break;
    case asn1.Type.IA5String:
      rval += ' (IA5String (ASCII))';
      break;
    case asn1.Type.UTCTIME:
      rval += ' (UTC time)';
      break;
    case asn1.Type.GENERALIZEDTIME:
      rval += ' (Generalized time)';
      break;
    case asn1.Type.BMPSTRING:
      rval += ' (BMP String)';
      break;
    }
  } else {
    rval += obj.type;
  }

  rval += '\n';
  rval += indent + 'Constructed: ' + obj.constructed + '\n';

  if(obj.composed) {
    var subvalues = 0;
    var sub = '';
    for(var i = 0; i < obj.value.length; ++i) {
      if(obj.value[i] !== undefined) {
        subvalues += 1;
        sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
        if((i + 1) < obj.value.length) {
          sub += ',';
        }
      }
    }
    rval += indent + 'Sub values: ' + subvalues + sub;
  } else {
    rval += indent + 'Value: ';
    if(obj.type === asn1.Type.OID) {
      var oid = asn1.derToOid(obj.value);
      rval += oid;
      if(forge.pki && forge.pki.oids) {
        if(oid in forge.pki.oids) {
          rval += ' (' + forge.pki.oids[oid] + ') ';
        }
      }
    }
    if(obj.type === asn1.Type.INTEGER) {
      try {
        rval += asn1.derToInteger(obj.value);
      } catch(ex) {
        rval += '0x' + forge.util.bytesToHex(obj.value);
      }
    } else if(obj.type === asn1.Type.BITSTRING) {
      // TODO: shift bits as needed to display without padding
      if(obj.value.length > 1) {
        // remove unused bits field
        rval += '0x' + forge.util.bytesToHex(obj.value.slice(1));
      } else {
        rval += '(none)';
      }
      // show unused bit count
      if(obj.value.length > 0) {
        var unused = obj.value.charCodeAt(0);
        if(unused == 1) {
          rval += ' (1 unused bit shown)';
        } else if(unused > 1) {
          rval += ' (' + unused + ' unused bits shown)';
        }
      }
    } else if(obj.type === asn1.Type.OCTETSTRING) {
      if(!_nonLatinRegex.test(obj.value)) {
        rval += '(' + obj.value + ') ';
      }
      rval += '0x' + forge.util.bytesToHex(obj.value);
    } else if(obj.type === asn1.Type.UTF8) {
      rval += forge.util.decodeUtf8(obj.value);
    } else if(obj.type === asn1.Type.PRINTABLESTRING ||
      obj.type === asn1.Type.IA5String) {
      rval += obj.value;
    } else if(_nonLatinRegex.test(obj.value)) {
      rval += '0x' + forge.util.bytesToHex(obj.value);
    } else if(obj.value.length === 0) {
      rval += '[null]';
    } else {
      rval += obj.value;
    }
  }

  return rval;
};

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/asn1.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pbe.js", {"./aes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/aes.js","./asn1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/asn1.js","./des":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/des.js","./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./md":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/md.js","./oids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/oids.js","./pbkdf2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pbkdf2.js","./pem":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pem.js","./random":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/random.js","./rc2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/rc2.js","./rsa":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/rsa.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pbe.js
      return function (require, module, exports) {
/**
 * Password-based encryption functions.
 *
 * @author Dave Longley
 * @author Stefan Siegl <stesie@brokenpipe.de>
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * An EncryptedPrivateKeyInfo:
 *
 * EncryptedPrivateKeyInfo ::= SEQUENCE {
 *   encryptionAlgorithm  EncryptionAlgorithmIdentifier,
 *   encryptedData        EncryptedData }
 *
 * EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedData ::= OCTET STRING
 */
var forge = require('./forge');
require('./aes');
require('./asn1');
require('./des');
require('./md');
require('./oids');
require('./pbkdf2');
require('./pem');
require('./random');
require('./rc2');
require('./rsa');
require('./util');

if(typeof BigInteger === 'undefined') {
  var BigInteger = forge.jsbn.BigInteger;
}

// shortcut for asn.1 API
var asn1 = forge.asn1;

/* Password-based encryption implementation. */
var pki = forge.pki = forge.pki || {};
module.exports = pki.pbe = forge.pbe = forge.pbe || {};
var oids = pki.oids;

// validator for an EncryptedPrivateKeyInfo structure
// Note: Currently only works w/algorithm params
var encryptedPrivateKeyValidator = {
  name: 'EncryptedPrivateKeyInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EncryptedPrivateKeyInfo.encryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'AlgorithmIdentifier.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'encryptionOid'
    }, {
      name: 'AlgorithmIdentifier.parameters',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'encryptionParams'
    }]
  }, {
    // encryptedData
    name: 'EncryptedPrivateKeyInfo.encryptedData',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'encryptedData'
  }]
};

// validator for a PBES2Algorithms structure
// Note: Currently only works w/PBKDF2 + AES encryption schemes
var PBES2AlgorithmsValidator = {
  name: 'PBES2Algorithms',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'PBES2Algorithms.keyDerivationFunc',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'PBES2Algorithms.keyDerivationFunc.oid',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'kdfOid'
    }, {
      name: 'PBES2Algorithms.params',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'PBES2Algorithms.params.salt',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: 'kdfSalt'
      }, {
        name: 'PBES2Algorithms.params.iterationCount',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'kdfIterationCount'
      }, {
        name: 'PBES2Algorithms.params.keyLength',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        optional: true,
        capture: 'keyLength'
      }, {
        // prf
        name: 'PBES2Algorithms.params.prf',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        value: [{
          name: 'PBES2Algorithms.params.prf.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'prfOid'
        }]
      }]
    }]
  }, {
    name: 'PBES2Algorithms.encryptionScheme',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'PBES2Algorithms.encryptionScheme.oid',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'encOid'
    }, {
      name: 'PBES2Algorithms.encryptionScheme.iv',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: 'encIv'
    }]
  }]
};

var pkcs12PbeParamsValidator = {
  name: 'pkcs-12PbeParams',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'pkcs-12PbeParams.salt',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'salt'
  }, {
    name: 'pkcs-12PbeParams.iterations',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'iterations'
  }]
};

/**
 * Encrypts a ASN.1 PrivateKeyInfo object, producing an EncryptedPrivateKeyInfo.
 *
 * PBES2Algorithms ALGORITHM-IDENTIFIER ::=
 *   { {PBES2-params IDENTIFIED BY id-PBES2}, ...}
 *
 * id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}
 *
 * PBES2-params ::= SEQUENCE {
 *   keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
 *   encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}
 * }
 *
 * PBES2-KDFs ALGORITHM-IDENTIFIER ::=
 *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }
 *
 * PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }
 *
 * PBKDF2-params ::= SEQUENCE {
 *   salt CHOICE {
 *     specified OCTET STRING,
 *     otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}
 *   },
 *   iterationCount INTEGER (1..MAX),
 *   keyLength INTEGER (1..MAX) OPTIONAL,
 *   prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1
 * }
 *
 * @param obj the ASN.1 PrivateKeyInfo object.
 * @param password the password to encrypt with.
 * @param options:
 *          algorithm the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
 *          count the iteration count to use.
 *          saltSize the salt size to use.
 *          prfAlgorithm the PRF message digest algorithm to use
 *            ('sha1', 'sha224', 'sha256', 'sha384', 'sha512')
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */
pki.encryptPrivateKeyInfo = function(obj, password, options) {
  // set default options
  options = options || {};
  options.saltSize = options.saltSize || 8;
  options.count = options.count || 2048;
  options.algorithm = options.algorithm || 'aes128';
  options.prfAlgorithm = options.prfAlgorithm || 'sha1';

  // generate PBE params
  var salt = forge.random.getBytesSync(options.saltSize);
  var count = options.count;
  var countBytes = asn1.integerToDer(count);
  var dkLen;
  var encryptionAlgorithm;
  var encryptedData;
  if(options.algorithm.indexOf('aes') === 0 || options.algorithm === 'des') {
    // do PBES2
    var ivLen, encOid, cipherFn;
    switch(options.algorithm) {
    case 'aes128':
      dkLen = 16;
      ivLen = 16;
      encOid = oids['aes128-CBC'];
      cipherFn = forge.aes.createEncryptionCipher;
      break;
    case 'aes192':
      dkLen = 24;
      ivLen = 16;
      encOid = oids['aes192-CBC'];
      cipherFn = forge.aes.createEncryptionCipher;
      break;
    case 'aes256':
      dkLen = 32;
      ivLen = 16;
      encOid = oids['aes256-CBC'];
      cipherFn = forge.aes.createEncryptionCipher;
      break;
    case 'des':
      dkLen = 8;
      ivLen = 8;
      encOid = oids['desCBC'];
      cipherFn = forge.des.createEncryptionCipher;
      break;
    default:
      var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');
      error.algorithm = options.algorithm;
      throw error;
    }

    // get PRF message digest
    var prfAlgorithm = 'hmacWith' + options.prfAlgorithm.toUpperCase();
    var md = prfAlgorithmToMessageDigest(prfAlgorithm);

    // encrypt private key using pbe SHA-1 and AES/DES
    var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
    var iv = forge.random.getBytesSync(ivLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(asn1.toDer(obj));
    cipher.finish();
    encryptedData = cipher.output.getBytes();

    // get PBKDF2-params
    var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);

    encryptionAlgorithm = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(oids['pkcs5PBES2']).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // keyDerivationFunc
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
            asn1.oidToDer(oids['pkcs5PBKDF2']).getBytes()),
          // PBKDF2-params
          params
        ]),
        // encryptionScheme
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
            asn1.oidToDer(encOid).getBytes()),
          // iv
          asn1.create(
            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)
        ])
      ])
    ]);
  } else if(options.algorithm === '3des') {
    // Do PKCS12 PBE
    dkLen = 24;

    var saltBytes = new forge.util.ByteBuffer(salt);
    var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
    var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
    var cipher = forge.des.createEncryptionCipher(dk);
    cipher.start(iv);
    cipher.update(asn1.toDer(obj));
    cipher.finish();
    encryptedData = cipher.output.getBytes();

    encryptionAlgorithm = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(oids['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()),
      // pkcs-12PbeParams
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // salt
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
        // iteration count
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
          countBytes.getBytes())
      ])
    ]);
  } else {
    var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');
    error.algorithm = options.algorithm;
    throw error;
  }

  // EncryptedPrivateKeyInfo
  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // encryptionAlgorithm
    encryptionAlgorithm,
    // encryptedData
    asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)
  ]);
  return rval;
};

/**
 * Decrypts a ASN.1 PrivateKeyInfo object.
 *
 * @param obj the ASN.1 EncryptedPrivateKeyInfo object.
 * @param password the password to decrypt with.
 *
 * @return the ASN.1 PrivateKeyInfo on success, null on failure.
 */
pki.decryptPrivateKeyInfo = function(obj, password) {
  var rval = null;

  // get PBE params
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
    var error = new Error('Cannot read encrypted private key. ' +
      'ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
    error.errors = errors;
    throw error;
  }

  // get cipher
  var oid = asn1.derToOid(capture.encryptionOid);
  var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);

  // get encrypted data
  var encrypted = forge.util.createBuffer(capture.encryptedData);

  cipher.update(encrypted);
  if(cipher.finish()) {
    rval = asn1.fromDer(cipher.output);
  }

  return rval;
};

/**
 * Converts a EncryptedPrivateKeyInfo to PEM format.
 *
 * @param epki the EncryptedPrivateKeyInfo.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted encrypted private key.
 */
pki.encryptedPrivateKeyToPem = function(epki, maxline) {
  // convert to DER, then PEM-encode
  var msg = {
    type: 'ENCRYPTED PRIVATE KEY',
    body: asn1.toDer(epki).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption
 * is not performed.
 *
 * @param pem the EncryptedPrivateKeyInfo in PEM-format.
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */
pki.encryptedPrivateKeyFromPem = function(pem) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'ENCRYPTED PRIVATE KEY') {
    var error = new Error('Could not convert encrypted private key from PEM; ' +
      'PEM header type is "ENCRYPTED PRIVATE KEY".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert encrypted private key from PEM; ' +
      'PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  return asn1.fromDer(msg.body);
};

/**
 * Encrypts an RSA private key. By default, the key will be wrapped in
 * a PrivateKeyInfo and encrypted to produce a PKCS#8 EncryptedPrivateKeyInfo.
 * This is the standard, preferred way to encrypt a private key.
 *
 * To produce a non-standard PEM-encrypted private key that uses encapsulated
 * headers to indicate the encryption algorithm (old-style non-PKCS#8 OpenSSL
 * private key encryption), set the 'legacy' option to true. Note: Using this
 * option will cause the iteration count to be forced to 1.
 *
 * Note: The 'des' algorithm is supported, but it is not considered to be
 * secure because it only uses a single 56-bit key. If possible, it is highly
 * recommended that a different algorithm be used.
 *
 * @param rsaKey the RSA key to encrypt.
 * @param password the password to use.
 * @param options:
 *          algorithm: the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des', 'des').
 *          count: the iteration count to use.
 *          saltSize: the salt size to use.
 *          legacy: output an old non-PKCS#8 PEM-encrypted+encapsulated
 *            headers (DEK-Info) private key.
 *
 * @return the PEM-encoded ASN.1 EncryptedPrivateKeyInfo.
 */
pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
  // standard PKCS#8
  options = options || {};
  if(!options.legacy) {
    // encrypt PrivateKeyInfo
    var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
    rval = pki.encryptPrivateKeyInfo(rval, password, options);
    return pki.encryptedPrivateKeyToPem(rval);
  }

  // legacy non-PKCS#8
  var algorithm;
  var iv;
  var dkLen;
  var cipherFn;
  switch(options.algorithm) {
  case 'aes128':
    algorithm = 'AES-128-CBC';
    dkLen = 16;
    iv = forge.random.getBytesSync(16);
    cipherFn = forge.aes.createEncryptionCipher;
    break;
  case 'aes192':
    algorithm = 'AES-192-CBC';
    dkLen = 24;
    iv = forge.random.getBytesSync(16);
    cipherFn = forge.aes.createEncryptionCipher;
    break;
  case 'aes256':
    algorithm = 'AES-256-CBC';
    dkLen = 32;
    iv = forge.random.getBytesSync(16);
    cipherFn = forge.aes.createEncryptionCipher;
    break;
  case '3des':
    algorithm = 'DES-EDE3-CBC';
    dkLen = 24;
    iv = forge.random.getBytesSync(8);
    cipherFn = forge.des.createEncryptionCipher;
    break;
  case 'des':
    algorithm = 'DES-CBC';
    dkLen = 8;
    iv = forge.random.getBytesSync(8);
    cipherFn = forge.des.createEncryptionCipher;
    break;
  default:
    var error = new Error('Could not encrypt RSA private key; unsupported ' +
      'encryption algorithm "' + options.algorithm + '".');
    error.algorithm = options.algorithm;
    throw error;
  }

  // encrypt private key using OpenSSL legacy key derivation
  var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
  var cipher = cipherFn(dk);
  cipher.start(iv);
  cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
  cipher.finish();

  var msg = {
    type: 'RSA PRIVATE KEY',
    procType: {
      version: '4',
      type: 'ENCRYPTED'
    },
    dekInfo: {
      algorithm: algorithm,
      parameters: forge.util.bytesToHex(iv).toUpperCase()
    },
    body: cipher.output.getBytes()
  };
  return forge.pem.encode(msg);
};

/**
 * Decrypts an RSA private key.
 *
 * @param pem the PEM-formatted EncryptedPrivateKeyInfo to decrypt.
 * @param password the password to use.
 *
 * @return the RSA key on success, null on failure.
 */
pki.decryptRsaPrivateKey = function(pem, password) {
  var rval = null;

  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'ENCRYPTED PRIVATE KEY' &&
    msg.type !== 'PRIVATE KEY' &&
    msg.type !== 'RSA PRIVATE KEY') {
    var error = new Error('Could not convert private key from PEM; PEM header type ' +
      'is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
    error.headerType = error;
    throw error;
  }

  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    var dkLen;
    var cipherFn;
    switch(msg.dekInfo.algorithm) {
    case 'DES-CBC':
      dkLen = 8;
      cipherFn = forge.des.createDecryptionCipher;
      break;
    case 'DES-EDE3-CBC':
      dkLen = 24;
      cipherFn = forge.des.createDecryptionCipher;
      break;
    case 'AES-128-CBC':
      dkLen = 16;
      cipherFn = forge.aes.createDecryptionCipher;
      break;
    case 'AES-192-CBC':
      dkLen = 24;
      cipherFn = forge.aes.createDecryptionCipher;
      break;
    case 'AES-256-CBC':
      dkLen = 32;
      cipherFn = forge.aes.createDecryptionCipher;
      break;
    case 'RC2-40-CBC':
      dkLen = 5;
      cipherFn = function(key) {
        return forge.rc2.createDecryptionCipher(key, 40);
      };
      break;
    case 'RC2-64-CBC':
      dkLen = 8;
      cipherFn = function(key) {
        return forge.rc2.createDecryptionCipher(key, 64);
      };
      break;
    case 'RC2-128-CBC':
      dkLen = 16;
      cipherFn = function(key) {
        return forge.rc2.createDecryptionCipher(key, 128);
      };
      break;
    default:
      var error = new Error('Could not decrypt private key; unsupported ' +
        'encryption algorithm "' + msg.dekInfo.algorithm + '".');
      error.algorithm = msg.dekInfo.algorithm;
      throw error;
    }

    // use OpenSSL legacy key derivation
    var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
    var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(forge.util.createBuffer(msg.body));
    if(cipher.finish()) {
      rval = cipher.output.getBytes();
    } else {
      return rval;
    }
  } else {
    rval = msg.body;
  }

  if(msg.type === 'ENCRYPTED PRIVATE KEY') {
    rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
  } else {
    // decryption already performed above
    rval = asn1.fromDer(rval);
  }

  if(rval !== null) {
    rval = pki.privateKeyFromAsn1(rval);
  }

  return rval;
};

/**
 * Derives a PKCS#12 key.
 *
 * @param password the password to derive the key material from, null or
 *          undefined for none.
 * @param salt the salt, as a ByteBuffer, to use.
 * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
 * @param iter the iteration count.
 * @param n the number of bytes to derive from the password.
 * @param md the message digest to use, defaults to SHA-1.
 *
 * @return a ByteBuffer with the bytes derived from the password.
 */
pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
  var j, l;

  if(typeof md === 'undefined' || md === null) {
    if(!('sha1' in forge.md)) {
      throw new Error('"sha1" hash algorithm unavailable.');
    }
    md = forge.md.sha1.create();
  }

  var u = md.digestLength;
  var v = md.blockLength;
  var result = new forge.util.ByteBuffer();

  /* Convert password to Unicode byte buffer + trailing 0-byte. */
  var passBuf = new forge.util.ByteBuffer();
  if(password !== null && password !== undefined) {
    for(l = 0; l < password.length; l++) {
      passBuf.putInt16(password.charCodeAt(l));
    }
    passBuf.putInt16(0);
  }

  /* Length of salt and password in BYTES. */
  var p = passBuf.length();
  var s = salt.length();

  /* 1. Construct a string, D (the "diversifier"), by concatenating
        v copies of ID. */
  var D = new forge.util.ByteBuffer();
  D.fillWithByte(id, v);

  /* 2. Concatenate copies of the salt together to create a string S of length
        v * ceil(s / v) bytes (the final copy of the salt may be trunacted
        to create S).
        Note that if the salt is the empty string, then so is S. */
  var Slen = v * Math.ceil(s / v);
  var S = new forge.util.ByteBuffer();
  for(l = 0; l < Slen; l++) {
    S.putByte(salt.at(l % s));
  }

  /* 3. Concatenate copies of the password together to create a string P of
        length v * ceil(p / v) bytes (the final copy of the password may be
        truncated to create P).
        Note that if the password is the empty string, then so is P. */
  var Plen = v * Math.ceil(p / v);
  var P = new forge.util.ByteBuffer();
  for(l = 0; l < Plen; l++) {
    P.putByte(passBuf.at(l % p));
  }

  /* 4. Set I=S||P to be the concatenation of S and P. */
  var I = S;
  I.putBuffer(P);

  /* 5. Set c=ceil(n / u). */
  var c = Math.ceil(n / u);

  /* 6. For i=1, 2, ..., c, do the following: */
  for(var i = 1; i <= c; i++) {
    /* a) Set Ai=H^r(D||I). (l.e. the rth hash of D||I, H(H(H(...H(D||I)))) */
    var buf = new forge.util.ByteBuffer();
    buf.putBytes(D.bytes());
    buf.putBytes(I.bytes());
    for(var round = 0; round < iter; round++) {
      md.start();
      md.update(buf.getBytes());
      buf = md.digest();
    }

    /* b) Concatenate copies of Ai to create a string B of length v bytes (the
          final copy of Ai may be truncated to create B). */
    var B = new forge.util.ByteBuffer();
    for(l = 0; l < v; l++) {
      B.putByte(buf.at(l % u));
    }

    /* c) Treating I as a concatenation I0, I1, ..., Ik-1 of v-byte blocks,
          where k=ceil(s / v) + ceil(p / v), modify I by setting
          Ij=(Ij+B+1) mod 2v for each j.  */
    var k = Math.ceil(s / v) + Math.ceil(p / v);
    var Inew = new forge.util.ByteBuffer();
    for(j = 0; j < k; j++) {
      var chunk = new forge.util.ByteBuffer(I.getBytes(v));
      var x = 0x1ff;
      for(l = B.length() - 1; l >= 0; l--) {
        x = x >> 8;
        x += B.at(l) + chunk.at(l);
        chunk.setAt(l, x & 0xff);
      }
      Inew.putBuffer(chunk);
    }
    I = Inew;

    /* Add Ai to A. */
    result.putBuffer(buf);
  }

  result.truncate(result.length() - n);
  return result;
};

/**
 * Get new Forge cipher object instance.
 *
 * @param oid the OID (in string notation).
 * @param params the ASN.1 params object.
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */
pki.pbe.getCipher = function(oid, params, password) {
  switch(oid) {
  case pki.oids['pkcs5PBES2']:
    return pki.pbe.getCipherForPBES2(oid, params, password);

  case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
  case pki.oids['pbewithSHAAnd40BitRC2-CBC']:
    return pki.pbe.getCipherForPKCS12PBE(oid, params, password);

  default:
    var error = new Error('Cannot read encrypted PBE data block. Unsupported OID.');
    error.oid = oid;
    error.supportedOids = [
      'pkcs5PBES2',
      'pbeWithSHAAnd3-KeyTripleDES-CBC',
      'pbewithSHAAnd40BitRC2-CBC'
    ];
    throw error;
  }
};

/**
 * Get new Forge cipher object instance according to PBES2 params block.
 *
 * The returned cipher instance is already started using the IV
 * from PBES2 parameter block.
 *
 * @param oid the PKCS#5 PBKDF2 OID (in string notation).
 * @param params the ASN.1 PBES2-params object.
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */
pki.pbe.getCipherForPBES2 = function(oid, params, password) {
  // get PBE params
  var capture = {};
  var errors = [];
  if(!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
    var error = new Error('Cannot read password-based-encryption algorithm ' +
      'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
    error.errors = errors;
    throw error;
  }

  // check oids
  oid = asn1.derToOid(capture.kdfOid);
  if(oid !== pki.oids['pkcs5PBKDF2']) {
    var error = new Error('Cannot read encrypted private key. ' +
      'Unsupported key derivation function OID.');
    error.oid = oid;
    error.supportedOids = ['pkcs5PBKDF2'];
    throw error;
  }
  oid = asn1.derToOid(capture.encOid);
  if(oid !== pki.oids['aes128-CBC'] &&
    oid !== pki.oids['aes192-CBC'] &&
    oid !== pki.oids['aes256-CBC'] &&
    oid !== pki.oids['des-EDE3-CBC'] &&
    oid !== pki.oids['desCBC']) {
    var error = new Error('Cannot read encrypted private key. ' +
      'Unsupported encryption scheme OID.');
    error.oid = oid;
    error.supportedOids = [
      'aes128-CBC', 'aes192-CBC', 'aes256-CBC', 'des-EDE3-CBC', 'desCBC'];
    throw error;
  }

  // set PBE params
  var salt = capture.kdfSalt;
  var count = forge.util.createBuffer(capture.kdfIterationCount);
  count = count.getInt(count.length() << 3);
  var dkLen;
  var cipherFn;
  switch(pki.oids[oid]) {
  case 'aes128-CBC':
    dkLen = 16;
    cipherFn = forge.aes.createDecryptionCipher;
    break;
  case 'aes192-CBC':
    dkLen = 24;
    cipherFn = forge.aes.createDecryptionCipher;
    break;
  case 'aes256-CBC':
    dkLen = 32;
    cipherFn = forge.aes.createDecryptionCipher;
    break;
  case 'des-EDE3-CBC':
    dkLen = 24;
    cipherFn = forge.des.createDecryptionCipher;
    break;
  case 'desCBC':
    dkLen = 8;
    cipherFn = forge.des.createDecryptionCipher;
    break;
  }

  // get PRF message digest
  var md = prfOidToMessageDigest(capture.prfOid);

  // decrypt private key using pbe with chosen PRF and AES/DES
  var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
  var iv = capture.encIv;
  var cipher = cipherFn(dk);
  cipher.start(iv);

  return cipher;
};

/**
 * Get new Forge cipher object instance for PKCS#12 PBE.
 *
 * The returned cipher instance is already started using the key & IV
 * derived from the provided password and PKCS#12 PBE salt.
 *
 * @param oid The PKCS#12 PBE OID (in string notation).
 * @param params The ASN.1 PKCS#12 PBE-params object.
 * @param password The password to decrypt with.
 *
 * @return the new cipher object instance.
 */
pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
  // get PBE params
  var capture = {};
  var errors = [];
  if(!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
    var error = new Error('Cannot read password-based-encryption algorithm ' +
      'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
    error.errors = errors;
    throw error;
  }

  var salt = forge.util.createBuffer(capture.salt);
  var count = forge.util.createBuffer(capture.iterations);
  count = count.getInt(count.length() << 3);

  var dkLen, dIvLen, cipherFn;
  switch(oid) {
    case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
      dkLen = 24;
      dIvLen = 8;
      cipherFn = forge.des.startDecrypting;
      break;

    case pki.oids['pbewithSHAAnd40BitRC2-CBC']:
      dkLen = 5;
      dIvLen = 8;
      cipherFn = function(key, iv) {
        var cipher = forge.rc2.createDecryptionCipher(key, 40);
        cipher.start(iv, null);
        return cipher;
      };
      break;

    default:
      var error = new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.');
      error.oid = oid;
      throw error;
  }

  // get PRF message digest
  var md = prfOidToMessageDigest(capture.prfOid);
  var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
  md.start();
  var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);

  return cipherFn(key, iv);
};

/**
 * OpenSSL's legacy key derivation function.
 *
 * See: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html
 *
 * @param password the password to derive the key from.
 * @param salt the salt to use, null for none.
 * @param dkLen the number of bytes needed for the derived key.
 * @param [options] the options to use:
 *          [md] an optional message digest object to use.
 */
pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
  if(typeof md === 'undefined' || md === null) {
    if(!('md5' in forge.md)) {
      throw new Error('"md5" hash algorithm unavailable.');
    }
    md = forge.md.md5.create();
  }
  if(salt === null) {
    salt = '';
  }
  var digests = [hash(md, password + salt)];
  for(var length = 16, i = 1; length < dkLen; ++i, length += 16) {
    digests.push(hash(md, digests[i - 1] + password + salt));
  }
  return digests.join('').substr(0, dkLen);
};

function hash(md, bytes) {
  return md.start().update(bytes).digest().getBytes();
}

function prfOidToMessageDigest(prfOid) {
  // get PRF algorithm, default to SHA-1
  var prfAlgorithm;
  if(!prfOid) {
    prfAlgorithm = 'hmacWithSHA1';
  } else {
    prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
    if(!prfAlgorithm) {
      var error = new Error('Unsupported PRF OID.');
      error.oid = prfOid;
      error.supported = [
        'hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384',
        'hmacWithSHA512'];
      throw error;
    }
  }
  return prfAlgorithmToMessageDigest(prfAlgorithm);
}

function prfAlgorithmToMessageDigest(prfAlgorithm) {
  var factory = forge.md;
  switch(prfAlgorithm) {
  case 'hmacWithSHA224':
    factory = forge.md.sha512;
  case 'hmacWithSHA1':
  case 'hmacWithSHA256':
  case 'hmacWithSHA384':
  case 'hmacWithSHA512':
    prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
    break;
  default:
    var error = new Error('Unsupported PRF algorithm.');
    error.algorithm = prfAlgorithm;
    error.supported = [
      'hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384',
      'hmacWithSHA512'];
    throw error;
  }
  if(!factory || !(prfAlgorithm in factory)) {
    throw new Error('Unknown hash algorithm: ' + prfAlgorithm);
  }
  return factory[prfAlgorithm].create();
}

function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
  var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // salt
    asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
    // iteration count
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      countBytes.getBytes())
  ]);
  // when PRF algorithm is not SHA-1 default, add key length and PRF algorithm
  if(prfAlgorithm !== 'hmacWithSHA1') {
    params.value.push(
      // key length
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
        forge.util.hexToBytes(dkLen.toString(16))),
      // AlgorithmIdentifier
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // algorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),
        // parameters (null)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
      ]));
  }
  return params;
}

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pbe.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/rsa.js", {"./asn1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/asn1.js","./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./jsbn":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/jsbn.js","./oids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/oids.js","./pkcs1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pkcs1.js","./prime":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/prime.js","./random":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/random.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js","crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/rsa.js
      return function (require, module, exports) {
/**
 * Javascript implementation of basic RSA algorithms.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The only algorithm currently supported for PKI is RSA.
 *
 * An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo
 * ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier
 * and a subjectPublicKey of type bit string.
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of RSA, there aren't any.
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm AlgorithmIdentifier,
 *   subjectPublicKey BIT STRING
 * }
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * For an RSA public key, the subjectPublicKey is:
 *
 * RSAPublicKey ::= SEQUENCE {
 *   modulus            INTEGER,    -- n
 *   publicExponent     INTEGER     -- e
 * }
 *
 * PrivateKeyInfo ::= SEQUENCE {
 *   version                   Version,
 *   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
 *   privateKey                PrivateKey,
 *   attributes           [0]  IMPLICIT Attributes OPTIONAL
 * }
 *
 * Version ::= INTEGER
 * PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
 * PrivateKey ::= OCTET STRING
 * Attributes ::= SET OF Attribute
 *
 * An RSA private key as the following structure:
 *
 * RSAPrivateKey ::= SEQUENCE {
 *   version Version,
 *   modulus INTEGER, -- n
 *   publicExponent INTEGER, -- e
 *   privateExponent INTEGER, -- d
 *   prime1 INTEGER, -- p
 *   prime2 INTEGER, -- q
 *   exponent1 INTEGER, -- d mod (p-1)
 *   exponent2 INTEGER, -- d mod (q-1)
 *   coefficient INTEGER -- (inverse of q) mod p
 * }
 *
 * Version ::= INTEGER
 *
 * The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1
 */
var forge = require('./forge');
require('./asn1');
require('./jsbn');
require('./oids');
require('./pkcs1');
require('./prime');
require('./random');
require('./util');

if(typeof BigInteger === 'undefined') {
  var BigInteger = forge.jsbn.BigInteger;
}

var _crypto = forge.util.isNodejs ? require('crypto') : null;

// shortcut for asn.1 API
var asn1 = forge.asn1;

// shortcut for util API
var util = forge.util;

/*
 * RSA encryption and decryption, see RFC 2313.
 */
forge.pki = forge.pki || {};
module.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
var pki = forge.pki;

// for finding primes, which are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29
var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];

// validator for a PrivateKeyInfo structure
var privateKeyValidator = {
  // PrivateKeyInfo
  name: 'PrivateKeyInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: 'PrivateKeyInfo.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyVersion'
  }, {
    // privateKeyAlgorithm
    name: 'PrivateKeyInfo.privateKeyAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'AlgorithmIdentifier.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'privateKeyOid'
    }]
  }, {
    // PrivateKey
    name: 'PrivateKeyInfo',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'privateKey'
  }]
};

// validator for an RSA private key
var rsaPrivateKeyValidator = {
  // RSAPrivateKey
  name: 'RSAPrivateKey',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: 'RSAPrivateKey.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyVersion'
  }, {
    // modulus (n)
    name: 'RSAPrivateKey.modulus',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyModulus'
  }, {
    // publicExponent (e)
    name: 'RSAPrivateKey.publicExponent',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyPublicExponent'
  }, {
    // privateExponent (d)
    name: 'RSAPrivateKey.privateExponent',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyPrivateExponent'
  }, {
    // prime1 (p)
    name: 'RSAPrivateKey.prime1',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyPrime1'
  }, {
    // prime2 (q)
    name: 'RSAPrivateKey.prime2',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyPrime2'
  }, {
    // exponent1 (d mod (p-1))
    name: 'RSAPrivateKey.exponent1',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyExponent1'
  }, {
    // exponent2 (d mod (q-1))
    name: 'RSAPrivateKey.exponent2',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyExponent2'
  }, {
    // coefficient ((inverse of q) mod p)
    name: 'RSAPrivateKey.coefficient',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyCoefficient'
  }]
};

// validator for an RSA public key
var rsaPublicKeyValidator = {
  // RSAPublicKey
  name: 'RSAPublicKey',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    // modulus (n)
    name: 'RSAPublicKey.modulus',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'publicKeyModulus'
  }, {
    // publicExponent (e)
    name: 'RSAPublicKey.exponent',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'publicKeyExponent'
  }]
};

// validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key
var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
  name: 'SubjectPublicKeyInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: 'subjectPublicKeyInfo',
  value: [{
    name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'AlgorithmIdentifier.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'publicKeyOid'
    }]
  }, {
    // subjectPublicKey
    name: 'SubjectPublicKeyInfo.subjectPublicKey',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.BITSTRING,
    constructed: false,
    value: [{
      // RSAPublicKey
      name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      optional: true,
      captureAsn1: 'rsaPublicKey'
    }]
  }]
};

/**
 * Wrap digest in DigestInfo object.
 *
 * This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.
 *
 * DigestInfo ::= SEQUENCE {
 *   digestAlgorithm DigestAlgorithmIdentifier,
 *   digest Digest
 * }
 *
 * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
 * Digest ::= OCTET STRING
 *
 * @param md the message digest object with the hash to sign.
 *
 * @return the encoded message (ready for RSA encrytion)
 */
var emsaPkcs1v15encode = function(md) {
  // get the oid for the algorithm
  var oid;
  if(md.algorithm in pki.oids) {
    oid = pki.oids[md.algorithm];
  } else {
    var error = new Error('Unknown message digest algorithm.');
    error.algorithm = md.algorithm;
    throw error;
  }
  var oidBytes = asn1.oidToDer(oid).getBytes();

  // create the digest info
  var digestInfo = asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
  var digestAlgorithm = asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
  digestAlgorithm.value.push(asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));
  digestAlgorithm.value.push(asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ''));
  var digest = asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING,
    false, md.digest().getBytes());
  digestInfo.value.push(digestAlgorithm);
  digestInfo.value.push(digest);

  // encode digest info
  return asn1.toDer(digestInfo).getBytes();
};

/**
 * Performs x^c mod n (RSA encryption or decryption operation).
 *
 * @param x the number to raise and mod.
 * @param key the key to use.
 * @param pub true if the key is public, false if private.
 *
 * @return the result of x^c mod n.
 */
var _modPow = function(x, key, pub) {
  if(pub) {
    return x.modPow(key.e, key.n);
  }

  if(!key.p || !key.q) {
    // allow calculation without CRT params (slow)
    return x.modPow(key.d, key.n);
  }

  // pre-compute dP, dQ, and qInv if necessary
  if(!key.dP) {
    key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
  }
  if(!key.dQ) {
    key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
  }
  if(!key.qInv) {
    key.qInv = key.q.modInverse(key.p);
  }

  /* Chinese remainder theorem (CRT) states:

    Suppose n1, n2, ..., nk are positive integers which are pairwise
    coprime (n1 and n2 have no common factors other than 1). For any
    integers x1, x2, ..., xk there exists an integer x solving the
    system of simultaneous congruences (where ~= means modularly
    congruent so a ~= b mod n means a mod n = b mod n):

    x ~= x1 mod n1
    x ~= x2 mod n2
    ...
    x ~= xk mod nk

    This system of congruences has a single simultaneous solution x
    between 0 and n - 1. Furthermore, each xk solution and x itself
    is congruent modulo the product n = n1*n2*...*nk.
    So x1 mod n = x2 mod n = xk mod n = x mod n.

    The single simultaneous solution x can be solved with the following
    equation:

    x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.

    Where x is less than n, xi = x mod ni.

    For RSA we are only concerned with k = 2. The modulus n = pq, where
    p and q are coprime. The RSA decryption algorithm is:

    y = x^d mod n

    Given the above:

    x1 = x^d mod p
    r1 = n/p = q
    s1 = q^-1 mod p
    x2 = x^d mod q
    r2 = n/q = p
    s2 = p^-1 mod q

    So y = (x1r1s1 + x2r2s2) mod n
         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n

    According to Fermat's Little Theorem, if the modulus P is prime,
    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.
    Since A is not divisible by P it follows that if:
    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:

    A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort
    to calculate). In order to calculate x^d mod p more quickly the
    exponent d mod (p - 1) is stored in the RSA private key (the same
    is done for x^d mod q). These values are referred to as dP and dQ
    respectively. Therefore we now have:

    y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n

    Since we'll be reducing x^dP by modulo p (same for q) we can also
    reduce x by p (and q respectively) before hand. Therefore, let

    xp = ((x mod p)^dP mod p), and
    xq = ((x mod q)^dQ mod q), yielding:

    y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n

    This can be further reduced to a simple algorithm that only
    requires 1 inverse (the q inverse is used) to be used and stored.
    The algorithm is called Garner's algorithm. If qInv is the
    inverse of q, we simply calculate:

    y = (qInv*(xp - xq) mod p) * q + xq

    However, there are two further complications. First, we need to
    ensure that xp > xq to prevent signed BigIntegers from being used
    so we add p until this is true (since we will be mod'ing with
    p anyway). Then, there is a known timing attack on algorithms
    using the CRT. To mitigate this risk, "cryptographic blinding"
    should be used. This requires simply generating a random number r
    between 0 and n-1 and its inverse and multiplying x by r^e before
    calculating y and then multiplying y by r^-1 afterwards. Note that
    r must be coprime with n (gcd(r, n) === 1) in order to have an
    inverse.
  */

  // cryptographic blinding
  var r;
  do {
    r = new BigInteger(
      forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)),
      16);
  } while(r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
  x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);

  // calculate xp and xq
  var xp = x.mod(key.p).modPow(key.dP, key.p);
  var xq = x.mod(key.q).modPow(key.dQ, key.q);

  // xp must be larger than xq to avoid signed bit usage
  while(xp.compareTo(xq) < 0) {
    xp = xp.add(key.p);
  }

  // do last step
  var y = xp.subtract(xq)
    .multiply(key.qInv).mod(key.p)
    .multiply(key.q).add(xq);

  // remove effect of random for cryptographic blinding
  y = y.multiply(r.modInverse(key.n)).mod(key.n);

  return y;
};

/**
 * NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or
 * 'encrypt' on a public key object instead.
 *
 * Performs RSA encryption.
 *
 * The parameter bt controls whether to put padding bytes before the
 * message passed in. Set bt to either true or false to disable padding
 * completely (in order to handle e.g. EMSA-PSS encoding seperately before),
 * signaling whether the encryption operation is a public key operation
 * (i.e. encrypting data) or not, i.e. private key operation (data signing).
 *
 * For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01
 * (for signing) or 0x02 (for encryption). The key operation mode (private
 * or public) is derived from this flag in that case).
 *
 * @param m the message to encrypt as a byte string.
 * @param key the RSA key to use.
 * @param bt for PKCS#1 v1.5 padding, the block type to use
 *   (0x01 for private key, 0x02 for public),
 *   to disable padding: true = public key, false = private key.
 *
 * @return the encrypted bytes as a string.
 */
pki.rsa.encrypt = function(m, key, bt) {
  var pub = bt;
  var eb;

  // get the length of the modulus in bytes
  var k = Math.ceil(key.n.bitLength() / 8);

  if(bt !== false && bt !== true) {
    // legacy, default to PKCS#1 v1.5 padding
    pub = (bt === 0x02);
    eb = _encodePkcs1_v1_5(m, key, bt);
  } else {
    eb = forge.util.createBuffer();
    eb.putBytes(m);
  }

  // load encryption block as big integer 'x'
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings
  var x = new BigInteger(eb.toHex(), 16);

  // do RSA encryption
  var y = _modPow(x, key, pub);

  // convert y into the encrypted data byte string, if y is shorter in
  // bytes than k, then prepend zero bytes to fill up ed
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings
  var yhex = y.toString(16);
  var ed = forge.util.createBuffer();
  var zeros = k - Math.ceil(yhex.length / 2);
  while(zeros > 0) {
    ed.putByte(0x00);
    --zeros;
  }
  ed.putBytes(forge.util.hexToBytes(yhex));
  return ed.getBytes();
};

/**
 * NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or
 * 'verify' on a public key object instead.
 *
 * Performs RSA decryption.
 *
 * The parameter ml controls whether to apply PKCS#1 v1.5 padding
 * or not.  Set ml = false to disable padding removal completely
 * (in order to handle e.g. EMSA-PSS later on) and simply pass back
 * the RSA encryption block.
 *
 * @param ed the encrypted data to decrypt in as a byte string.
 * @param key the RSA key to use.
 * @param pub true for a public key operation, false for private.
 * @param ml the message length, if known, false to disable padding.
 *
 * @return the decrypted message as a byte string.
 */
pki.rsa.decrypt = function(ed, key, pub, ml) {
  // get the length of the modulus in bytes
  var k = Math.ceil(key.n.bitLength() / 8);

  // error if the length of the encrypted data ED is not k
  if(ed.length !== k) {
    var error = new Error('Encrypted message length is invalid.');
    error.length = ed.length;
    error.expected = k;
    throw error;
  }

  // convert encrypted data into a big integer
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings
  var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);

  // y must be less than the modulus or it wasn't the result of
  // a previous mod operation (encryption) using that modulus
  if(y.compareTo(key.n) >= 0) {
    throw new Error('Encrypted message is invalid.');
  }

  // do RSA decryption
  var x = _modPow(y, key, pub);

  // create the encryption block, if x is shorter in bytes than k, then
  // prepend zero bytes to fill up eb
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings
  var xhex = x.toString(16);
  var eb = forge.util.createBuffer();
  var zeros = k - Math.ceil(xhex.length / 2);
  while(zeros > 0) {
    eb.putByte(0x00);
    --zeros;
  }
  eb.putBytes(forge.util.hexToBytes(xhex));

  if(ml !== false) {
    // legacy, default to PKCS#1 v1.5 padding
    return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
  }

  // return message
  return eb.getBytes();
};

/**
 * Creates an RSA key-pair generation state object. It is used to allow
 * key-generation to be performed in steps. It also allows for a UI to
 * display progress updates.
 *
 * @param bits the size for the private key in bits, defaults to 2048.
 * @param e the public exponent to use, defaults to 65537 (0x10001).
 * @param [options] the options to use.
 *          prng a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *          algorithm the algorithm to use (default: 'PRIMEINC').
 *
 * @return the state object to use to generate the key-pair.
 */
pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
  // TODO: migrate step-based prime generation code to forge.prime

  // set default bits
  if(typeof(bits) === 'string') {
    bits = parseInt(bits, 10);
  }
  bits = bits || 2048;

  // create prng with api that matches BigInteger secure random
  options = options || {};
  var prng = options.prng || forge.random;
  var rng = {
    // x is an array to fill with bytes
    nextBytes: function(x) {
      var b = prng.getBytesSync(x.length);
      for(var i = 0; i < x.length; ++i) {
        x[i] = b.charCodeAt(i);
      }
    }
  };

  var algorithm = options.algorithm || 'PRIMEINC';

  // create PRIMEINC algorithm state
  var rval;
  if(algorithm === 'PRIMEINC') {
    rval = {
      algorithm: algorithm,
      state: 0,
      bits: bits,
      rng: rng,
      eInt: e || 65537,
      e: new BigInteger(null),
      p: null,
      q: null,
      qBits: bits >> 1,
      pBits: bits - (bits >> 1),
      pqState: 0,
      num: null,
      keys: null
    };
    rval.e.fromInt(rval.eInt);
  } else {
    throw new Error('Invalid key generation algorithm: ' + algorithm);
  }

  return rval;
};

/**
 * Attempts to runs the key-generation algorithm for at most n seconds
 * (approximately) using the given state. When key-generation has completed,
 * the keys will be stored in state.keys.
 *
 * To use this function to update a UI while generating a key or to prevent
 * causing browser lockups/warnings, set "n" to a value other than 0. A
 * simple pattern for generating a key and showing a progress indicator is:
 *
 * var state = pki.rsa.createKeyPairGenerationState(2048);
 * var step = function() {
 *   // step key-generation, run algorithm for 100 ms, repeat
 *   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {
 *     setTimeout(step, 1);
 *   } else {
 *     // key-generation complete
 *     // TODO: turn off progress indicator here
 *     // TODO: use the generated key-pair in "state.keys"
 *   }
 * };
 * // TODO: turn on progress indicator here
 * setTimeout(step, 0);
 *
 * @param state the state to use.
 * @param n the maximum number of milliseconds to run the algorithm for, 0
 *          to run the algorithm to completion.
 *
 * @return true if the key-generation completed, false if not.
 */
pki.rsa.stepKeyPairGenerationState = function(state, n) {
  // set default algorithm if not set
  if(!('algorithm' in state)) {
    state.algorithm = 'PRIMEINC';
  }

  // TODO: migrate step-based prime generation code to forge.prime
  // TODO: abstract as PRIMEINC algorithm

  // do key generation (based on Tom Wu's rsa.js, see jsbn.js license)
  // with some minor optimizations and designed to run in steps

  // local state vars
  var THIRTY = new BigInteger(null);
  THIRTY.fromInt(30);
  var deltaIdx = 0;
  var op_or = function(x, y) {return x | y;};

  // keep stepping until time limit is reached or done
  var t1 = +new Date();
  var t2;
  var total = 0;
  while(state.keys === null && (n <= 0 || total < n)) {
    // generate p or q
    if(state.state === 0) {
      /* Note: All primes are of the form:

        30k+i, for i < 30 and gcd(30, i)=1, where there are 8 values for i

        When we generate a random number, we always align it at 30k + 1. Each
        time the number is determined not to be prime we add to get to the
        next 'i', eg: if the number was at 30k + 1 we add 6. */
      var bits = (state.p === null) ? state.pBits : state.qBits;
      var bits1 = bits - 1;

      // get a random number
      if(state.pqState === 0) {
        state.num = new BigInteger(bits, state.rng);
        // force MSB set
        if(!state.num.testBit(bits1)) {
          state.num.bitwiseTo(
            BigInteger.ONE.shiftLeft(bits1), op_or, state.num);
        }
        // align number on 30k+1 boundary
        state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
        deltaIdx = 0;

        ++state.pqState;
      } else if(state.pqState === 1) {
        // try to make the number a prime
        if(state.num.bitLength() > bits) {
          // overflow, try again
          state.pqState = 0;
          // do primality test
        } else if(state.num.isProbablePrime(
          _getMillerRabinTests(state.num.bitLength()))) {
          ++state.pqState;
        } else {
          // get next potential prime
          state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        }
      } else if(state.pqState === 2) {
        // ensure number is coprime with e
        state.pqState =
          (state.num.subtract(BigInteger.ONE).gcd(state.e)
            .compareTo(BigInteger.ONE) === 0) ? 3 : 0;
      } else if(state.pqState === 3) {
        // store p or q
        state.pqState = 0;
        if(state.p === null) {
          state.p = state.num;
        } else {
          state.q = state.num;
        }

        // advance state if both p and q are ready
        if(state.p !== null && state.q !== null) {
          ++state.state;
        }
        state.num = null;
      }
    } else if(state.state === 1) {
      // ensure p is larger than q (swap them if not)
      if(state.p.compareTo(state.q) < 0) {
        state.num = state.p;
        state.p = state.q;
        state.q = state.num;
      }
      ++state.state;
    } else if(state.state === 2) {
      // compute phi: (p - 1)(q - 1) (Euler's totient function)
      state.p1 = state.p.subtract(BigInteger.ONE);
      state.q1 = state.q.subtract(BigInteger.ONE);
      state.phi = state.p1.multiply(state.q1);
      ++state.state;
    } else if(state.state === 3) {
      // ensure e and phi are coprime
      if(state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
        // phi and e are coprime, advance
        ++state.state;
      } else {
        // phi and e aren't coprime, so generate a new p and q
        state.p = null;
        state.q = null;
        state.state = 0;
      }
    } else if(state.state === 4) {
      // create n, ensure n is has the right number of bits
      state.n = state.p.multiply(state.q);

      // ensure n is right number of bits
      if(state.n.bitLength() === state.bits) {
        // success, advance
        ++state.state;
      } else {
        // failed, get new q
        state.q = null;
        state.state = 0;
      }
    } else if(state.state === 5) {
      // set keys
      var d = state.e.modInverse(state.phi);
      state.keys = {
        privateKey: pki.rsa.setPrivateKey(
          state.n, state.e, d, state.p, state.q,
          d.mod(state.p1), d.mod(state.q1),
          state.q.modInverse(state.p)),
        publicKey: pki.rsa.setPublicKey(state.n, state.e)
      };
    }

    // update timing
    t2 = +new Date();
    total += t2 - t1;
    t1 = t2;
  }

  return state.keys !== null;
};

/**
 * Generates an RSA public-private key pair in a single call.
 *
 * To generate a key-pair in steps (to allow for progress updates and to
 * prevent blocking or warnings in slow browsers) then use the key-pair
 * generation state functions.
 *
 * To generate a key-pair asynchronously (either through web-workers, if
 * available, or by breaking up the work on the main thread), pass a
 * callback function.
 *
 * @param [bits] the size for the private key in bits, defaults to 2048.
 * @param [e] the public exponent to use, defaults to 65537.
 * @param [options] options for key-pair generation, if given then 'bits'
 *            and 'e' must *not* be given:
 *          bits the size for the private key in bits, (default: 2048).
 *          e the public exponent to use, (default: 65537 (0x10001)).
 *          workerScript the worker script URL.
 *          workers the number of web workers (if supported) to use,
 *            (default: 2).
 *          workLoad the size of the work load, ie: number of possible prime
 *            numbers for each web worker to check per work assignment,
 *            (default: 100).
 *          prng a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync". Disables use of native APIs.
 *          algorithm the algorithm to use (default: 'PRIMEINC').
 * @param [callback(err, keypair)] called once the operation completes.
 *
 * @return an object with privateKey and publicKey properties.
 */
pki.rsa.generateKeyPair = function(bits, e, options, callback) {
  // (bits), (options), (callback)
  if(arguments.length === 1) {
    if(typeof bits === 'object') {
      options = bits;
      bits = undefined;
    } else if(typeof bits === 'function') {
      callback = bits;
      bits = undefined;
    }
  } else if(arguments.length === 2) {
    // (bits, e), (bits, options), (bits, callback), (options, callback)
    if(typeof bits === 'number') {
      if(typeof e === 'function') {
        callback = e;
        e = undefined;
      } else if(typeof e !== 'number') {
        options = e;
        e = undefined;
      }
    } else {
      options = bits;
      callback = e;
      bits = undefined;
      e = undefined;
    }
  } else if(arguments.length === 3) {
    // (bits, e, options), (bits, e, callback), (bits, options, callback)
    if(typeof e === 'number') {
      if(typeof options === 'function') {
        callback = options;
        options = undefined;
      }
    } else {
      callback = options;
      options = e;
      e = undefined;
    }
  }
  options = options || {};
  if(bits === undefined) {
    bits = options.bits || 2048;
  }
  if(e === undefined) {
    e = options.e || 0x10001;
  }

  // use native code if permitted, available, and parameters are acceptable
  if(!forge.options.usePureJavaScript && !options.prng &&
    bits >= 256 && bits <= 16384 && (e === 0x10001 || e === 3)) {
    if(callback) {
      // try native async
      if(_detectNodeCrypto('generateKeyPair')) {
        return _crypto.generateKeyPair('rsa', {
          modulusLength: bits,
          publicExponent: e,
          publicKeyEncoding: {
            type: 'spki',
            format: 'pem'
          },
          privateKeyEncoding: {
            type: 'pkcs8',
            format: 'pem'
          }
        }, function(err, pub, priv) {
          if(err) {
            return callback(err);
          }
          callback(null, {
            privateKey: pki.privateKeyFromPem(priv),
            publicKey: pki.publicKeyFromPem(pub)
          });
        });
      }
      if(_detectSubtleCrypto('generateKey') &&
        _detectSubtleCrypto('exportKey')) {
        // use standard native generateKey
        return util.globalScope.crypto.subtle.generateKey({
          name: 'RSASSA-PKCS1-v1_5',
          modulusLength: bits,
          publicExponent: _intToUint8Array(e),
          hash: {name: 'SHA-256'}
        }, true /* key can be exported*/, ['sign', 'verify'])
        .then(function(pair) {
          return util.globalScope.crypto.subtle.exportKey(
            'pkcs8', pair.privateKey);
        // avoiding catch(function(err) {...}) to support IE <= 8
        }).then(undefined, function(err) {
          callback(err);
        }).then(function(pkcs8) {
          if(pkcs8) {
            var privateKey = pki.privateKeyFromAsn1(
              asn1.fromDer(forge.util.createBuffer(pkcs8)));
            callback(null, {
              privateKey: privateKey,
              publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
            });
          }
        });
      }
      if(_detectSubtleMsCrypto('generateKey') &&
        _detectSubtleMsCrypto('exportKey')) {
        var genOp = util.globalScope.msCrypto.subtle.generateKey({
          name: 'RSASSA-PKCS1-v1_5',
          modulusLength: bits,
          publicExponent: _intToUint8Array(e),
          hash: {name: 'SHA-256'}
        }, true /* key can be exported*/, ['sign', 'verify']);
        genOp.oncomplete = function(e) {
          var pair = e.target.result;
          var exportOp = util.globalScope.msCrypto.subtle.exportKey(
            'pkcs8', pair.privateKey);
          exportOp.oncomplete = function(e) {
            var pkcs8 = e.target.result;
            var privateKey = pki.privateKeyFromAsn1(
              asn1.fromDer(forge.util.createBuffer(pkcs8)));
            callback(null, {
              privateKey: privateKey,
              publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
            });
          };
          exportOp.onerror = function(err) {
            callback(err);
          };
        };
        genOp.onerror = function(err) {
          callback(err);
        };
        return;
      }
    } else {
      // try native sync
      if(_detectNodeCrypto('generateKeyPairSync')) {
        var keypair = _crypto.generateKeyPairSync('rsa', {
          modulusLength: bits,
          publicExponent: e,
          publicKeyEncoding: {
            type: 'spki',
            format: 'pem'
          },
          privateKeyEncoding: {
            type: 'pkcs8',
            format: 'pem'
          }
        });
        return {
          privateKey: pki.privateKeyFromPem(keypair.privateKey),
          publicKey: pki.publicKeyFromPem(keypair.publicKey)
        };
      }
    }
  }

  // use JavaScript implementation
  var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
  if(!callback) {
    pki.rsa.stepKeyPairGenerationState(state, 0);
    return state.keys;
  }
  _generateKeyPair(state, options, callback);
};

/**
 * Sets an RSA public key from BigIntegers modulus and exponent.
 *
 * @param n the modulus.
 * @param e the exponent.
 *
 * @return the public key.
 */
pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
  var key = {
    n: n,
    e: e
  };

  /**
   * Encrypts the given data with this public key. Newer applications
   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for
   * legacy applications.
   *
   * @param data the byte string to encrypt.
   * @param scheme the encryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA encryption,
   *          an object with an 'encode' property set to a function
   *          with the signature 'function(data, key)' that returns
   *          a binary-encoded string representing the encoded data.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the encrypted byte string.
   */
  key.encrypt = function(data, scheme, schemeOptions) {
    if(typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    } else if(scheme === undefined) {
      scheme = 'RSAES-PKCS1-V1_5';
    }

    if(scheme === 'RSAES-PKCS1-V1_5') {
      scheme = {
        encode: function(m, key, pub) {
          return _encodePkcs1_v1_5(m, key, 0x02).getBytes();
        }
      };
    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
      scheme = {
        encode: function(m, key) {
          return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);
        }
      };
    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
      scheme = {encode: function(e) {return e;}};
    } else if(typeof scheme === 'string') {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }

    // do scheme-based encoding then rsa encryption
    var e = scheme.encode(data, key, true);
    return pki.rsa.encrypt(e, key, true);
  };

  /**
   * Verifies the given signature against the given digest.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the
   * signature is an OCTET STRING that holds a DigestInfo.
   *
   * DigestInfo ::= SEQUENCE {
   *   digestAlgorithm DigestAlgorithmIdentifier,
   *   digest Digest
   * }
   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
   * Digest ::= OCTET STRING
   *
   * To perform PSS signature verification, provide an instance
   * of Forge PSS object as the scheme parameter.
   *
   * @param digest the message digest hash to compare against the signature,
   *          as a binary-encoded string.
   * @param signature the signature to verify, as a binary-encoded string.
   * @param scheme signature verification scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be expected, but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return true if the signature was verified, false if not.
   */
  key.verify = function(digest, signature, scheme) {
    if(typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    } else if(scheme === undefined) {
      scheme = 'RSASSA-PKCS1-V1_5';
    }

    if(scheme === 'RSASSA-PKCS1-V1_5') {
      scheme = {
        verify: function(digest, d) {
          // remove padding
          d = _decodePkcs1_v1_5(d, key, true);
          // d is ASN.1 BER-encoded DigestInfo
          var obj = asn1.fromDer(d);
          // compare the given digest to the decrypted one
          return digest === obj.value[1].value;
        }
      };
    } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {
      scheme = {
        verify: function(digest, d) {
          // remove padding
          d = _decodePkcs1_v1_5(d, key, true);
          return digest === d;
        }
      };
    }

    // do rsa decryption w/o any decoding, then verify -- which does decoding
    var d = pki.rsa.decrypt(signature, key, true, false);
    return scheme.verify(digest, d, key.n.bitLength());
  };

  return key;
};

/**
 * Sets an RSA private key from BigIntegers modulus, exponent, primes,
 * prime exponents, and modular multiplicative inverse.
 *
 * @param n the modulus.
 * @param e the public exponent.
 * @param d the private exponent ((inverse of e) mod n).
 * @param p the first prime.
 * @param q the second prime.
 * @param dP exponent1 (d mod (p-1)).
 * @param dQ exponent2 (d mod (q-1)).
 * @param qInv ((inverse of q) mod p)
 *
 * @return the private key.
 */
pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(
  n, e, d, p, q, dP, dQ, qInv) {
  var key = {
    n: n,
    e: e,
    d: d,
    p: p,
    q: q,
    dP: dP,
    dQ: dQ,
    qInv: qInv
  };

  /**
   * Decrypts the given data with this private key. The decryption scheme
   * must match the one used to encrypt the data.
   *
   * @param data the byte string to decrypt.
   * @param scheme the decryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA decryption.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the decrypted byte string.
   */
  key.decrypt = function(data, scheme, schemeOptions) {
    if(typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    } else if(scheme === undefined) {
      scheme = 'RSAES-PKCS1-V1_5';
    }

    // do rsa decryption w/o any decoding
    var d = pki.rsa.decrypt(data, key, false, false);

    if(scheme === 'RSAES-PKCS1-V1_5') {
      scheme = {decode: _decodePkcs1_v1_5};
    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
      scheme = {
        decode: function(d, key) {
          return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);
        }
      };
    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
      scheme = {decode: function(d) {return d;}};
    } else {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }

    // decode according to scheme
    return scheme.decode(d, key, false);
  };

  /**
   * Signs the given digest, producing a signature.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide
   * an instance of Forge PSS object as the scheme parameter.
   *
   * @param md the message digest object with the hash to sign.
   * @param scheme the signature scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be used but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return the signature as a byte string.
   */
  key.sign = function(md, scheme) {
    /* Note: The internal implementation of RSA operations is being
      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy
      code like the use of an encoding block identifier 'bt' will eventually
      be removed. */

    // private key operation
    var bt = false;

    if(typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    }

    if(scheme === undefined || scheme === 'RSASSA-PKCS1-V1_5') {
      scheme = {encode: emsaPkcs1v15encode};
      bt = 0x01;
    } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {
      scheme = {encode: function() {return md;}};
      bt = 0x01;
    }

    // encode and then encrypt
    var d = scheme.encode(md, key.n.bitLength());
    return pki.rsa.encrypt(d, key, bt);
  };

  return key;
};

/**
 * Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.
 *
 * @param rsaKey the ASN.1 RSAPrivateKey.
 *
 * @return the ASN.1 PrivateKeyInfo.
 */
pki.wrapRsaPrivateKey = function(rsaKey) {
  // PrivateKeyInfo
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version (0)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      asn1.integerToDer(0).getBytes()),
    // privateKeyAlgorithm
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(
        asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
    ]),
    // PrivateKey
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
      asn1.toDer(rsaKey).getBytes())
  ]);
};

/**
 * Converts a private key from an ASN.1 object.
 *
 * @param obj the ASN.1 representation of a PrivateKeyInfo containing an
 *          RSAPrivateKey or an RSAPrivateKey.
 *
 * @return the private key.
 */
pki.privateKeyFromAsn1 = function(obj) {
  // get PrivateKeyInfo
  var capture = {};
  var errors = [];
  if(asn1.validate(obj, privateKeyValidator, capture, errors)) {
    obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
  }

  // get RSAPrivateKey
  capture = {};
  errors = [];
  if(!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
    var error = new Error('Cannot read private key. ' +
      'ASN.1 object does not contain an RSAPrivateKey.');
    error.errors = errors;
    throw error;
  }

  // Note: Version is currently ignored.
  // capture.privateKeyVersion
  // FIXME: inefficient, get a BigInteger that uses byte strings
  var n, e, d, p, q, dP, dQ, qInv;
  n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
  e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
  d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
  p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
  q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
  dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
  dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
  qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();

  // set private key
  return pki.setRsaPrivateKey(
    new BigInteger(n, 16),
    new BigInteger(e, 16),
    new BigInteger(d, 16),
    new BigInteger(p, 16),
    new BigInteger(q, 16),
    new BigInteger(dP, 16),
    new BigInteger(dQ, 16),
    new BigInteger(qInv, 16));
};

/**
 * Converts a private key to an ASN.1 RSAPrivateKey.
 *
 * @param key the private key.
 *
 * @return the ASN.1 representation of an RSAPrivateKey.
 */
pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
  // RSAPrivateKey
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version (0 = only 2 primes, 1 multiple primes)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      asn1.integerToDer(0).getBytes()),
    // modulus (n)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.n)),
    // publicExponent (e)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.e)),
    // privateExponent (d)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.d)),
    // privateKeyPrime1 (p)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.p)),
    // privateKeyPrime2 (q)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.q)),
    // privateKeyExponent1 (dP)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.dP)),
    // privateKeyExponent2 (dQ)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.dQ)),
    // coefficient (qInv)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.qInv))
  ]);
};

/**
 * Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.
 *
 * @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.
 *
 * @return the public key.
 */
pki.publicKeyFromAsn1 = function(obj) {
  // get SubjectPublicKeyInfo
  var capture = {};
  var errors = [];
  if(asn1.validate(obj, publicKeyValidator, capture, errors)) {
    // get oid
    var oid = asn1.derToOid(capture.publicKeyOid);
    if(oid !== pki.oids.rsaEncryption) {
      var error = new Error('Cannot read public key. Unknown OID.');
      error.oid = oid;
      throw error;
    }
    obj = capture.rsaPublicKey;
  }

  // get RSA params
  errors = [];
  if(!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
    var error = new Error('Cannot read public key. ' +
      'ASN.1 object does not contain an RSAPublicKey.');
    error.errors = errors;
    throw error;
  }

  // FIXME: inefficient, get a BigInteger that uses byte strings
  var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
  var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();

  // set public key
  return pki.setRsaPublicKey(
    new BigInteger(n, 16),
    new BigInteger(e, 16));
};

/**
 * Converts a public key to an ASN.1 SubjectPublicKeyInfo.
 *
 * @param key the public key.
 *
 * @return the asn1 representation of a SubjectPublicKeyInfo.
 */
pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
  // SubjectPublicKeyInfo
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // AlgorithmIdentifier
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
      // parameters (null)
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
    ]),
    // subjectPublicKey
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
      pki.publicKeyToRSAPublicKey(key)
    ])
  ]);
};

/**
 * Converts a public key to an ASN.1 RSAPublicKey.
 *
 * @param key the public key.
 *
 * @return the asn1 representation of a RSAPublicKey.
 */
pki.publicKeyToRSAPublicKey = function(key) {
  // RSAPublicKey
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // modulus (n)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.n)),
    // publicExponent (e)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.e))
  ]);
};

/**
 * Encodes a message using PKCS#1 v1.5 padding.
 *
 * @param m the message to encode.
 * @param key the RSA key to use.
 * @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02
 *          (for encryption).
 *
 * @return the padded byte buffer.
 */
function _encodePkcs1_v1_5(m, key, bt) {
  var eb = forge.util.createBuffer();

  // get the length of the modulus in bytes
  var k = Math.ceil(key.n.bitLength() / 8);

  /* use PKCS#1 v1.5 padding */
  if(m.length > (k - 11)) {
    var error = new Error('Message is too long for PKCS#1 v1.5 padding.');
    error.length = m.length;
    error.max = k - 11;
    throw error;
  }

  /* A block type BT, a padding string PS, and the data D shall be
    formatted into an octet string EB, the encryption block:

    EB = 00 || BT || PS || 00 || D

    The block type BT shall be a single octet indicating the structure of
    the encryption block. For this version of the document it shall have
    value 00, 01, or 02. For a private-key operation, the block type
    shall be 00 or 01. For a public-key operation, it shall be 02.

    The padding string PS shall consist of k-3-||D|| octets. For block
    type 00, the octets shall have value 00; for block type 01, they
    shall have value FF; and for block type 02, they shall be
    pseudorandomly generated and nonzero. This makes the length of the
    encryption block EB equal to k. */

  // build the encryption block
  eb.putByte(0x00);
  eb.putByte(bt);

  // create the padding
  var padNum = k - 3 - m.length;
  var padByte;
  // private key op
  if(bt === 0x00 || bt === 0x01) {
    padByte = (bt === 0x00) ? 0x00 : 0xFF;
    for(var i = 0; i < padNum; ++i) {
      eb.putByte(padByte);
    }
  } else {
    // public key op
    // pad with random non-zero values
    while(padNum > 0) {
      var numZeros = 0;
      var padBytes = forge.random.getBytes(padNum);
      for(var i = 0; i < padNum; ++i) {
        padByte = padBytes.charCodeAt(i);
        if(padByte === 0) {
          ++numZeros;
        } else {
          eb.putByte(padByte);
        }
      }
      padNum = numZeros;
    }
  }

  // zero followed by message
  eb.putByte(0x00);
  eb.putBytes(m);

  return eb;
}

/**
 * Decodes a message using PKCS#1 v1.5 padding.
 *
 * @param em the message to decode.
 * @param key the RSA key to use.
 * @param pub true if the key is a public key, false if it is private.
 * @param ml the message length, if specified.
 *
 * @return the decoded bytes.
 */
function _decodePkcs1_v1_5(em, key, pub, ml) {
  // get the length of the modulus in bytes
  var k = Math.ceil(key.n.bitLength() / 8);

  /* It is an error if any of the following conditions occurs:

    1. The encryption block EB cannot be parsed unambiguously.
    2. The padding string PS consists of fewer than eight octets
      or is inconsisent with the block type BT.
    3. The decryption process is a public-key operation and the block
      type BT is not 00 or 01, or the decryption process is a
      private-key operation and the block type is not 02.
   */

  // parse the encryption block
  var eb = forge.util.createBuffer(em);
  var first = eb.getByte();
  var bt = eb.getByte();
  if(first !== 0x00 ||
    (pub && bt !== 0x00 && bt !== 0x01) ||
    (!pub && bt != 0x02) ||
    (pub && bt === 0x00 && typeof(ml) === 'undefined')) {
    throw new Error('Encryption block is invalid.');
  }

  var padNum = 0;
  if(bt === 0x00) {
    // check all padding bytes for 0x00
    padNum = k - 3 - ml;
    for(var i = 0; i < padNum; ++i) {
      if(eb.getByte() !== 0x00) {
        throw new Error('Encryption block is invalid.');
      }
    }
  } else if(bt === 0x01) {
    // find the first byte that isn't 0xFF, should be after all padding
    padNum = 0;
    while(eb.length() > 1) {
      if(eb.getByte() !== 0xFF) {
        --eb.read;
        break;
      }
      ++padNum;
    }
  } else if(bt === 0x02) {
    // look for 0x00 byte
    padNum = 0;
    while(eb.length() > 1) {
      if(eb.getByte() === 0x00) {
        --eb.read;
        break;
      }
      ++padNum;
    }
  }

  // zero must be 0x00 and padNum must be (k - 3 - message length)
  var zero = eb.getByte();
  if(zero !== 0x00 || padNum !== (k - 3 - eb.length())) {
    throw new Error('Encryption block is invalid.');
  }

  return eb.getBytes();
}

/**
 * Runs the key-generation algorithm asynchronously, either in the background
 * via Web Workers, or using the main thread and setImmediate.
 *
 * @param state the key-pair generation state.
 * @param [options] options for key-pair generation:
 *          workerScript the worker script URL.
 *          workers the number of web workers (if supported) to use,
 *            (default: 2, -1 to use estimated cores minus one).
 *          workLoad the size of the work load, ie: number of possible prime
 *            numbers for each web worker to check per work assignment,
 *            (default: 100).
 * @param callback(err, keypair) called once the operation completes.
 */
function _generateKeyPair(state, options, callback) {
  if(typeof options === 'function') {
    callback = options;
    options = {};
  }
  options = options || {};

  var opts = {
    algorithm: {
      name: options.algorithm || 'PRIMEINC',
      options: {
        workers: options.workers || 2,
        workLoad: options.workLoad || 100,
        workerScript: options.workerScript
      }
    }
  };
  if('prng' in options) {
    opts.prng = options.prng;
  }

  generate();

  function generate() {
    // find p and then q (done in series to simplify)
    getPrime(state.pBits, function(err, num) {
      if(err) {
        return callback(err);
      }
      state.p = num;
      if(state.q !== null) {
        return finish(err, state.q);
      }
      getPrime(state.qBits, finish);
    });
  }

  function getPrime(bits, callback) {
    forge.prime.generateProbablePrime(bits, opts, callback);
  }

  function finish(err, num) {
    if(err) {
      return callback(err);
    }

    // set q
    state.q = num;

    // ensure p is larger than q (swap them if not)
    if(state.p.compareTo(state.q) < 0) {
      var tmp = state.p;
      state.p = state.q;
      state.q = tmp;
    }

    // ensure p is coprime with e
    if(state.p.subtract(BigInteger.ONE).gcd(state.e)
      .compareTo(BigInteger.ONE) !== 0) {
      state.p = null;
      generate();
      return;
    }

    // ensure q is coprime with e
    if(state.q.subtract(BigInteger.ONE).gcd(state.e)
      .compareTo(BigInteger.ONE) !== 0) {
      state.q = null;
      getPrime(state.qBits, finish);
      return;
    }

    // compute phi: (p - 1)(q - 1) (Euler's totient function)
    state.p1 = state.p.subtract(BigInteger.ONE);
    state.q1 = state.q.subtract(BigInteger.ONE);
    state.phi = state.p1.multiply(state.q1);

    // ensure e and phi are coprime
    if(state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
      // phi and e aren't coprime, so generate a new p and q
      state.p = state.q = null;
      generate();
      return;
    }

    // create n, ensure n is has the right number of bits
    state.n = state.p.multiply(state.q);
    if(state.n.bitLength() !== state.bits) {
      // failed, get new q
      state.q = null;
      getPrime(state.qBits, finish);
      return;
    }

    // set keys
    var d = state.e.modInverse(state.phi);
    state.keys = {
      privateKey: pki.rsa.setPrivateKey(
        state.n, state.e, d, state.p, state.q,
        d.mod(state.p1), d.mod(state.q1),
        state.q.modInverse(state.p)),
      publicKey: pki.rsa.setPublicKey(state.n, state.e)
    };

    callback(null, state.keys);
  }
}

/**
 * Converts a positive BigInteger into 2's-complement big-endian bytes.
 *
 * @param b the big integer to convert.
 *
 * @return the bytes.
 */
function _bnToBytes(b) {
  // prepend 0x00 if first byte >= 0x80
  var hex = b.toString(16);
  if(hex[0] >= '8') {
    hex = '00' + hex;
  }
  var bytes = forge.util.hexToBytes(hex);

  // ensure integer is minimally-encoded
  if(bytes.length > 1 &&
    // leading 0x00 for positive integer
    ((bytes.charCodeAt(0) === 0 &&
    (bytes.charCodeAt(1) & 0x80) === 0) ||
    // leading 0xFF for negative integer
    (bytes.charCodeAt(0) === 0xFF &&
    (bytes.charCodeAt(1) & 0x80) === 0x80))) {
    return bytes.substr(1);
  }
  return bytes;
}

/**
 * Returns the required number of Miller-Rabin tests to generate a
 * prime with an error probability of (1/2)^80.
 *
 * See Handbook of Applied Cryptography Chapter 4, Table 4.4.
 *
 * @param bits the bit size.
 *
 * @return the required number of iterations.
 */
function _getMillerRabinTests(bits) {
  if(bits <= 100) return 27;
  if(bits <= 150) return 18;
  if(bits <= 200) return 15;
  if(bits <= 250) return 12;
  if(bits <= 300) return 9;
  if(bits <= 350) return 8;
  if(bits <= 400) return 7;
  if(bits <= 500) return 6;
  if(bits <= 600) return 5;
  if(bits <= 800) return 4;
  if(bits <= 1250) return 3;
  return 2;
}

/**
 * Performs feature detection on the Node crypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */
function _detectNodeCrypto(fn) {
  return forge.util.isNodejs && typeof _crypto[fn] === 'function';
}

/**
 * Performs feature detection on the SubtleCrypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */
function _detectSubtleCrypto(fn) {
  return (typeof util.globalScope !== 'undefined' &&
    typeof util.globalScope.crypto === 'object' &&
    typeof util.globalScope.crypto.subtle === 'object' &&
    typeof util.globalScope.crypto.subtle[fn] === 'function');
}

/**
 * Performs feature detection on the deprecated Microsoft Internet Explorer
 * outdated SubtleCrypto interface. This function should only be used after
 * checking for the modern, standard SubtleCrypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */
function _detectSubtleMsCrypto(fn) {
  return (typeof util.globalScope !== 'undefined' &&
    typeof util.globalScope.msCrypto === 'object' &&
    typeof util.globalScope.msCrypto.subtle === 'object' &&
    typeof util.globalScope.msCrypto.subtle[fn] === 'function');
}

function _intToUint8Array(x) {
  var bytes = forge.util.hexToBytes(x.toString(16));
  var buffer = new Uint8Array(bytes.length);
  for(var i = 0; i < bytes.length; ++i) {
    buffer[i] = bytes.charCodeAt(i);
  }
  return buffer;
}

function _privateKeyFromJwk(jwk) {
  if(jwk.kty !== 'RSA') {
    throw new Error(
      'Unsupported key algorithm "' + jwk.kty + '"; algorithm must be "RSA".');
  }
  return pki.setRsaPrivateKey(
    _base64ToBigInt(jwk.n),
    _base64ToBigInt(jwk.e),
    _base64ToBigInt(jwk.d),
    _base64ToBigInt(jwk.p),
    _base64ToBigInt(jwk.q),
    _base64ToBigInt(jwk.dp),
    _base64ToBigInt(jwk.dq),
    _base64ToBigInt(jwk.qi));
}

function _publicKeyFromJwk(jwk) {
  if(jwk.kty !== 'RSA') {
    throw new Error('Key algorithm must be "RSA".');
  }
  return pki.setRsaPublicKey(
    _base64ToBigInt(jwk.n),
    _base64ToBigInt(jwk.e));
}

function _base64ToBigInt(b64) {
  return new BigInteger(forge.util.bytesToHex(forge.util.decode64(b64)), 16);
}

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/rsa.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/rsa-class.js", {"./keys.proto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/keys.proto.js","./rsa":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/rsa-browser.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","bs58":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bs58/index.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/index.js","node-forge/lib/forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","node-forge/lib/pbe":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pbe.js","node-forge/lib/sha512":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/sha512.js","protons":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/rsa-class.js
      return function (require, module, exports) {
'use strict'

const multihashing = require('multihashing-async')
const protobuf = require('protons')
const bs58 = require('bs58')
const nextTick = require('async/nextTick')

const crypto = require('./rsa')
const pbm = protobuf(require('./keys.proto'))
require('node-forge/lib/sha512')
require('node-forge/lib/pbe')
const forge = require('node-forge/lib/forge')

class RsaPublicKey {
  constructor (key) {
    this._key = key
  }

  verify (data, sig, callback) {
    ensure(callback)
    crypto.hashAndVerify(this._key, sig, data, callback)
  }

  marshal () {
    return crypto.utils.jwkToPkix(this._key)
  }

  get bytes () {
    return pbm.PublicKey.encode({
      Type: pbm.KeyType.RSA,
      Data: this.marshal()
    })
  }

  encrypt (bytes) {
    return this._key.encrypt(bytes, 'RSAES-PKCS1-V1_5')
  }

  equals (key) {
    return this.bytes.equals(key.bytes)
  }

  hash (callback) {
    ensure(callback)
    multihashing(this.bytes, 'sha2-256', callback)
  }
}

class RsaPrivateKey {
  // key       - Object of the jwk format
  // publicKey - Buffer of the spki format
  constructor (key, publicKey) {
    this._key = key
    this._publicKey = publicKey
  }

  genSecret () {
    return crypto.getRandomValues(16)
  }

  sign (message, callback) {
    ensure(callback)
    crypto.hashAndSign(this._key, message, callback)
  }

  get public () {
    if (!this._publicKey) {
      throw new Error('public key not provided')
    }

    return new RsaPublicKey(this._publicKey)
  }

  decrypt (msg, callback) {
    crypto.decrypt(this._key, msg, callback)
  }

  marshal () {
    return crypto.utils.jwkToPkcs1(this._key)
  }

  get bytes () {
    return pbm.PrivateKey.encode({
      Type: pbm.KeyType.RSA,
      Data: this.marshal()
    })
  }

  equals (key) {
    return this.bytes.equals(key.bytes)
  }

  hash (callback) {
    ensure(callback)
    multihashing(this.bytes, 'sha2-256', callback)
  }

  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   *
   * @param {function(Error, id)} callback
   * @returns {undefined}
   */
  id (callback) {
    this.public.hash((err, hash) => {
      if (err) {
        return callback(err)
      }
      callback(null, bs58.encode(hash))
    })
  }

  /**
   * Exports the key into a password protected PEM format
   *
   * @param {string} [format] - Defaults to 'pkcs-8'.
   * @param {string} password - The password to read the encrypted PEM
   * @param {function(Error, KeyInfo)} callback
   * @returns {undefined}
   */
  export (format, password, callback) {
    if (typeof password === 'function') {
      callback = password
      password = format
      format = 'pkcs-8'
    }

    ensure(callback)

    nextTick(() => {
      let err = null
      let pem = null
      try {
        const buffer = new forge.util.ByteBuffer(this.marshal())
        const asn1 = forge.asn1.fromDer(buffer)
        const privateKey = forge.pki.privateKeyFromAsn1(asn1)
        if (format === 'pkcs-8') {
          const options = {
            algorithm: 'aes256',
            count: 10000,
            saltSize: 128 / 8,
            prfAlgorithm: 'sha512'
          }
          pem = forge.pki.encryptRsaPrivateKey(privateKey, password, options)
        } else {
          err = new Error(`Unknown export format '${format}'`)
        }
      } catch (_err) {
        err = _err
      }

      callback(err, pem)
    })
  }
}

function unmarshalRsaPrivateKey (bytes, callback) {
  const jwk = crypto.utils.pkcs1ToJwk(bytes)

  crypto.unmarshalPrivateKey(jwk, (err, keys) => {
    if (err) {
      return callback(err)
    }

    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))
  })
}

function unmarshalRsaPublicKey (bytes) {
  const jwk = crypto.utils.pkixToJwk(bytes)

  return new RsaPublicKey(jwk)
}

function fromJwk (jwk, callback) {
  crypto.unmarshalPrivateKey(jwk, (err, keys) => {
    if (err) {
      return callback(err)
    }

    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))
  })
}

function generateKeyPair (bits, callback) {
  crypto.generateKey(bits, (err, keys) => {
    if (err) {
      return callback(err)
    }

    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))
  })
}

function ensure (callback) {
  if (typeof callback !== 'function') {
    throw new Error('callback is required')
  }
}

module.exports = {
  RsaPublicKey,
  RsaPrivateKey,
  unmarshalRsaPublicKey,
  unmarshalRsaPrivateKey,
  generateKeyPair,
  fromJwk
}

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/rsa-class.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/index.js", {"../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./compile":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/index.js","protocol-buffers-schema":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

var schema = require('protocol-buffers-schema')
var compile = require('./compile')

var flatten = function (values) {
  if (!values) return null
  var result = {}
  Object.keys(values).forEach(function (k) {
    result[k] = values[k].value
  })
  return result
}

module.exports = function (proto, opts) {
  if (!opts) opts = {}
  if (!proto) throw new Error('Pass in a .proto string or a protobuf-schema parsed object')

  var sch = (typeof proto === 'object' && !Buffer.isBuffer(proto)) ? proto : schema.parse(proto)

  // to not make toString,toJSON enumarable we make a fire-and-forget prototype
  var Messages = function () {
    var self = this

    compile(sch, opts.encodings || {}).forEach(function (m) {
      self[m.name] = flatten(m.values) || m
    })
  }

  Messages.prototype.toString = function () {
    return schema.stringify(sch)
  }

  Messages.prototype.toJSON = function () {
    return sch
  }

  return new Messages()
}

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"protons",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ephemeral-keys.js", {"./ecdh":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ecdh-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ephemeral-keys.js
      return function (require, module, exports) {
'use strict'

const ecdh = require('./ecdh')

// Generates an ephemeral public key and returns a function that will compute
// the shared secret key.
//
// Focuses only on ECDH now, but can be made more general in the future.
module.exports = (curve, callback) => {
  ecdh.generateEphmeralKeyPair(curve, callback)
}

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ephemeral-keys.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/src/index.js", {"./crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/src/crypto.js","bs58":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bs58/index.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/src/index.js
      return function (require, module, exports) {
'use strict'

const bs58 = require('bs58')
const multihashing = require('multihashing-async')

module.exports = (keysProtobuf, randomBytes, crypto) => {
  crypto = crypto || require('./crypto')(randomBytes)

  class Secp256k1PublicKey {
    constructor (key) {
      crypto.validatePublicKey(key)
      this._key = key
    }

    verify (data, sig, callback) {
      ensure(callback)
      crypto.hashAndVerify(this._key, sig, data, callback)
    }

    marshal () {
      return crypto.compressPublicKey(this._key)
    }

    get bytes () {
      return keysProtobuf.PublicKey.encode({
        Type: keysProtobuf.KeyType.Secp256k1,
        Data: this.marshal()
      })
    }

    equals (key) {
      return this.bytes.equals(key.bytes)
    }

    hash (callback) {
      ensure(callback)
      multihashing(this.bytes, 'sha2-256', callback)
    }
  }

  class Secp256k1PrivateKey {
    constructor (key, publicKey) {
      this._key = key
      this._publicKey = publicKey || crypto.computePublicKey(key)
      crypto.validatePrivateKey(this._key)
      crypto.validatePublicKey(this._publicKey)
    }

    sign (message, callback) {
      ensure(callback)
      crypto.hashAndSign(this._key, message, callback)
    }

    get public () {
      return new Secp256k1PublicKey(this._publicKey)
    }

    marshal () {
      return this._key
    }

    get bytes () {
      return keysProtobuf.PrivateKey.encode({
        Type: keysProtobuf.KeyType.Secp256k1,
        Data: this.marshal()
      })
    }

    equals (key) {
      return this.bytes.equals(key.bytes)
    }

    hash (callback) {
      ensure(callback)
      multihashing(this.bytes, 'sha2-256', callback)
    }

    /**
     * Gets the ID of the key.
     *
     * The key id is the base58 encoding of the SHA-256 multihash of its public key.
     * The public key is a protobuf encoding containing a type and the DER encoding
     * of the PKCS SubjectPublicKeyInfo.
     *
     * @param {function(Error, id)} callback
     * @returns {undefined}
     */
    id (callback) {
      this.public.hash((err, hash) => {
        if (err) {
          return callback(err)
        }
        callback(null, bs58.encode(hash))
      })
    }
  }

  function unmarshalSecp256k1PrivateKey (bytes, callback) {
    callback(null, new Secp256k1PrivateKey(bytes))
  }

  function unmarshalSecp256k1PublicKey (bytes) {
    return new Secp256k1PublicKey(bytes)
  }

  function generateKeyPair (_bits, callback) {
    if (callback === undefined && typeof _bits === 'function') {
      callback = _bits
    }

    ensure(callback)

    crypto.generateKey((err, privateKeyBytes) => {
      if (err) { return callback(err) }

      let privkey
      try {
        privkey = new Secp256k1PrivateKey(privateKeyBytes)
      } catch (err) { return callback(err) }

      callback(null, privkey)
    })
  }

  function ensure (callback) {
    if (typeof callback !== 'function') {
      throw new Error('callback is required')
    }
  }

  return {
    Secp256k1PublicKey,
    Secp256k1PrivateKey,
    unmarshalSecp256k1PrivateKey,
    unmarshalSecp256k1PublicKey,
    generateKeyPair
  }
}

      };
    };
  }
}, {package:"libp2p-crypto-secp256k1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-cbor/src/resolver.js", {"../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-cbor/src/util.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-cbor/src/resolver.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const CID = require('cids')

const util = require('./util')

/**
 * Resolves a path within a CBOR block.
 *
 * Returns the value or a link and the partial mising path. This way the
 * IPLD Resolver can fetch the link and continue to resolve.
 *
 * @param {Buffer} binaryBlob - Binary representation of a CBOR block
 * @param {string} [path='/'] - Path that should be resolved
 * @returns {Object} result - Result of the path it it was resolved successfully
 * @returns {*} result.value - Value the path resolves to
 * @returns {string} result.remainderPath - If the path resolves half-way to a
 *   link, then the `remainderPath` is the part after the link that can be used
 *   for further resolving
 */
exports.resolve = (binaryBlob, path) => {
  let node = util.deserialize(binaryBlob)

  const parts = path.split('/').filter(Boolean)
  while (parts.length) {
    const key = parts.shift()
    if (node[key] === undefined) {
      throw new Error(`Object has no property '${key}'`)
    }

    node = node[key]
    if (CID.isCID(node)) {
      return {
        value: node,
        remainderPath: parts.join('/')
      }
    }
  }

  return {
    value: node,
    remainderPath: ''
  }
}

const traverse = function * (node, path) {
  // Traverse only objects and arrays
  if (Buffer.isBuffer(node) || CID.isCID(node) || typeof node === 'string' ||
      node === null) {
    return
  }
  for (const item of Object.keys(node)) {
    const nextpath = path === undefined ? item : path + '/' + item
    yield nextpath
    yield * traverse(node[item], nextpath)
  }
}

/**
 * Return all available paths of a block.
 *
 * @generator
 * @param {Buffer} binaryBlob - Binary representation of a CBOR block
 * @yields {string} - A single path
 */
exports.tree = function * (binaryBlob) {
  const node = util.deserialize(binaryBlob)

  yield * traverse(node)
}

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipld-dag-cbor",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-cbor/src/resolver.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-cbor/src/util.js", {"borc":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","is-circular":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-circular/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-cbor/src/util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const cbor = require('borc')
const multicodec = require('multicodec')
const multihashing = require('multihashing-async')
const CID = require('cids')
const isCircular = require('is-circular')

// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692
const CID_CBOR_TAG = 42

function tagCID (cid) {
  if (typeof cid === 'string') {
    cid = new CID(cid).buffer
  } else if (CID.isCID(cid)) {
    cid = cid.buffer
  }

  return new cbor.Tagged(CID_CBOR_TAG, Buffer.concat([
    Buffer.from('00', 'hex'), // thanks jdag
    cid
  ]))
}

function replaceCIDbyTAG (dagNode) {
  let circular
  try {
    circular = isCircular(dagNode)
  } catch (e) {
    circular = false
  }
  if (circular) {
    throw new Error('The object passed has circular references')
  }

  function transform (obj) {
    if (!obj || Buffer.isBuffer(obj) || typeof obj === 'string') {
      return obj
    }

    if (Array.isArray(obj)) {
      return obj.map(transform)
    }

    if (CID.isCID(obj)) {
      return tagCID(obj)
    }

    const keys = Object.keys(obj)

    if (keys.length > 0) {
      // Recursive transform
      const out = {}
      keys.forEach((key) => {
        if (typeof obj[key] === 'object') {
          out[key] = transform(obj[key])
        } else {
          out[key] = obj[key]
        }
      })
      return out
    } else {
      return obj
    }
  }

  return transform(dagNode)
}

exports = module.exports

exports.codec = multicodec.DAG_CBOR
exports.defaultHashAlg = multicodec.SHA2_256

const defaultTags = {
  [CID_CBOR_TAG]: (val) => {
    // remove that 0
    val = val.slice(1)
    return new CID(val)
  }
}
const defaultSize = 64 * 1024 // current decoder heap size, 64 Kb
let currentSize = defaultSize
const defaultMaxSize = 64 * 1024 * 1024 // max heap size when auto-growing, 64 Mb
let maxSize = defaultMaxSize
let decoder = null

/**
 * Configure the underlying CBOR decoder.
 *
 * @param {Object} [options] - The options the decoder takes. The decoder will reset to the defaul values if no options are given.
 * @param {number} [options.size=65536] - The current heap size used in CBOR parsing, this may grow automatically as larger blocks are encountered up to `maxSize`
 * @param {number} [options.maxSize=67108864] - The maximum size the CBOR parsing heap is allowed to grow to before `dagCBOR.util.deserialize()` returns an error
 * @param {Object} [options.tags] - An object whose keys are CBOR tag numbers and values are transform functions that accept a `value` and return a decoded representation of that `value`
 */
exports.configureDecoder = (options) => {
  let tags = defaultTags

  if (options) {
    if (typeof options.size === 'number') {
      currentSize = options.size
    }
    if (typeof options.maxSize === 'number') {
      maxSize = options.maxSize
    }
    if (options.tags) {
      tags = Object.assign({}, defaultTags, options && options.tags)
    }
  } else {
    // no options, reset to defaults
    currentSize = defaultSize
    maxSize = defaultMaxSize
  }

  let decoderOptions = {
    tags: tags,
    size: currentSize
  }

  decoder = new cbor.Decoder(decoderOptions)
  // borc edits opts.size in-place so we can capture _actual_ size
  currentSize = decoderOptions.size
}

exports.configureDecoder() // Setup default cbor.Decoder

/**
 * Serialize internal representation into a binary CBOR block.
 *
 * @param {Object} node - Internal representation of a CBOR block
 * @returns {Buffer} - The encoded binary representation
 */
exports.serialize = (node) => {
  const nodeTagged = replaceCIDbyTAG(node)
  const serialized = cbor.encode(nodeTagged)

  return serialized
}

/**
 * Deserialize CBOR block into the internal representation.
 *
 * @param {Buffer} data - Binary representation of a CBOR block
 * @returns {Object} - An object that conforms to the IPLD Data Model
 */
exports.deserialize = (data) => {
  if (data.length > currentSize && data.length <= maxSize) {
    exports.configureDecoder({ size: data.length })
  }

  if (data.length > currentSize) {
    throw new Error('Data is too large to deserialize with current decoder')
  }

  const deserialized = decoder.decodeFirst(data)

  return deserialized
}

/**
 * Calculate the CID of the binary blob.
 *
 * @param {Object} binaryBlob - Encoded IPLD Node
 * @param {Object} [userOptions] - Options to create the CID
 * @param {number} [userOptions.cidVersion=1] - CID version number
 * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format
 * @returns {Promise.<CID>}
 */
exports.cid = async (binaryBlob, userOptions) => {
  const defaultOptions = { cidVersion: 1, hashAlg: exports.defaultHashAlg }
  const options = Object.assign(defaultOptions, userOptions)

  const multihash = await multihashing(binaryBlob, options.hashAlg)
  const codecName = multicodec.print[exports.codec]
  const cid = new CID(options.cidVersion, codecName, multihash)

  return cid
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipld-dag-cbor",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-cbor/src/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/resolver.js", {"../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/util.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/resolver.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const CID = require('cids')

const util = require('./util')

/**
 * Resolves a path within a PB block.
 *
 * Returns the value or a link and the partial mising path. This way the
 * IPLD Resolver can fetch the link and continue to resolve.
 *
 * @param {Buffer} binaryBlob - Binary representation of a PB block
 * @param {string} [path='/'] - Path that should be resolved
 * @returns {Object} result - Result of the path it it was resolved successfully
 * @returns {*} result.value - Value the path resolves to
 * @returns {string} result.remainderPath - If the path resolves half-way to a
 *   link, then the `remainderPath` is the part after the link that can be used
 *   for further resolving
 */
exports.resolve = (binaryBlob, path) => {
  let node = util.deserialize(binaryBlob)

  const parts = path.split('/').filter(Boolean)
  while (parts.length) {
    const key = parts.shift()
    if (node[key] === undefined) {
      throw new Error(`Object has no property '${key}'`)
    }

    node = node[key]
    if (CID.isCID(node)) {
      return {
        value: node,
        remainderPath: parts.join('/')
      }
    }
  }

  return {
    value: node,
    remainderPath: ''
  }
}

const traverse = function * (node, path) {
  // Traverse only objects and arrays
  if (Buffer.isBuffer(node) || CID.isCID(node) || typeof node === 'string' ||
      node === null) {
    return
  }
  for (const item of Object.keys(node)) {
    const nextpath = path === undefined ? item : path + '/' + item
    yield nextpath
    yield * traverse(node[item], nextpath)
  }
}

/**
 * Return all available paths of a block.
 *
 * @generator
 * @param {Buffer} binaryBlob - Binary representation of a PB block
 * @yields {string} - A single path
 */
exports.tree = function * (binaryBlob) {
  const node = util.deserialize(binaryBlob)

  yield * traverse(node)
}

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipld-dag-pb",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/resolver.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/util.js", {"./dag-link":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-link/index.js","./dag-node":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/index.js","./dag.proto.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag.proto.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/index.js","protons":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const CID = require('cids')
const protons = require('protons')
const proto = protons(require('./dag.proto.js'))
const DAGLink = require('./dag-link')
const DAGNode = require('./dag-node')
const multicodec = require('multicodec')
const multihashing = require('multihashing-async')

exports = module.exports

exports.codec = multicodec.DAG_PB
exports.defaultHashAlg = multicodec.SHA2_256

/**
 * Calculate the CID of the binary blob.
 *
 * @param {Object} binaryBlob - Encoded IPLD Node
 * @param {Object} [userOptions] - Options to create the CID
 * @param {number} [userOptions.cidVersion=1] - CID version number
 * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format
 * @returns {Promise.<CID>}
 */
const cid = async (binaryBlob, userOptions) => {
  const defaultOptions = { cidVersion: 1, hashAlg: exports.defaultHashAlg }
  const options = Object.assign(defaultOptions, userOptions)

  const multihash = await multihashing(binaryBlob, options.hashAlg)
  const codecName = multicodec.print[exports.codec]
  const cid = new CID(options.cidVersion, codecName, multihash)

  return cid
}

/**
 * Serialize internal representation into a binary PB block.
 *
 * @param {Object} node - Internal representation of a CBOR block
 * @returns {Buffer} - The encoded binary representation
 */
const serialize = (node) => {
  let data = node.Data
  let links = node.Links || []

  // If the node is not an instance of a DAGNode, the link.hash might be a Base58 encoded string; decode it
  if (!DAGNode.isDAGNode(node) && links) {
    links = links.map((link) => {
      return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link)
    })
  }

  const serialized = proto.PBNode.encode(toProtoBuf({
    Data: data,
    Links: links
  }))

  return serialized
}

/**
 * Deserialize PB block into the internal representation.
 *
 * @param {Buffer} buffer - Binary representation of a PB block
 * @returns {Object} - An object that conforms to the IPLD Data Model
 */
const deserialize = (buffer) => {
  const pbn = proto.PBNode.decode(buffer)

  const links = pbn.Links.map((link) => {
    return new DAGLink(link.Name, link.Tsize, link.Hash)
  })

  const data = pbn.Data == null ? Buffer.alloc(0) : pbn.Data

  return new DAGNode(data, links, buffer.length)
}

function toProtoBuf (node) {
  const pbn = {}

  if (node.Data && node.Data.length > 0) {
    pbn.Data = node.Data
  } else {
    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`
    pbn.Data = null
  }

  if (node.Links && node.Links.length > 0) {
    pbn.Links = node.Links
      .map((link) => ({
        Hash: link.Hash.buffer,
        Name: link.Name,
        Tsize: link.Tsize
      }))
  } else {
    pbn.Links = null
  }

  return pbn
}

exports.serialize = serialize
exports.deserialize = deserialize
exports.cid = cid

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipld-dag-pb",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-link/index.js", {"../visibility":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/visibility.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-link/util.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","class-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-link/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const CID = require('cids')
const assert = require('assert')
const withIs = require('class-is')
const visibility = require('../visibility')

// Link represents an IPFS Merkle DAG Link between Nodes.
class DAGLink {
  constructor (name, size, cid) {
    assert(cid, 'A link requires a cid to point to')
    // assert(size, 'A link requires a size')
    //  note - links should include size, but this assert is disabled
    //  for now to maintain consistency with go-ipfs pinset

    this._name = name || ''
    this._nameBuf = null
    this._size = size
    this._cid = new CID(cid)

    // Make sure we have a nice public API that can be used by an IPLD resolver
    visibility.hidePrivateFields(this)
    visibility.addEnumerableGetters(this, ['Hash', 'Name', 'Tsize'])
  }

  toString () {
    return `DAGLink <${this._cid.toBaseEncodedString()} - name: "${this.Name}", size: ${this.Tsize}>`
  }

  toJSON () {
    if (!this._json) {
      this._json = Object.freeze({
        name: this.Name,
        size: this.Tsize,
        cid: this.Hash.toBaseEncodedString()
      })
    }

    return Object.assign({}, this._json)
  }

  get Name () {
    return this._name
  }

  // Memoize the Buffer representation of name
  // We need this to sort the links, otherwise
  // we will reallocate new buffers every time
  get nameAsBuffer () {
    if (this._nameBuf !== null) {
      return this._nameBuf
    }

    this._nameBuf = Buffer.from(this._name)
    return this._nameBuf
  }

  set Name (name) {
    throw new Error("Can't set property: 'name' is immutable")
  }

  get Tsize () {
    return this._size
  }

  set Tsize (size) {
    throw new Error("Can't set property: 'size' is immutable")
  }

  get Hash () {
    return this._cid
  }

  set Hash (cid) {
    throw new Error("Can't set property: 'cid' is immutable")
  }
}

exports = module.exports = withIs(DAGLink, { className: 'DAGLink', symbolName: '@ipld/js-ipld-dag-pb/daglink' })
exports.util = require('./util')

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipld-dag-pb",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-link/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/index.js", {"../visibility":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/visibility.js","./addLink":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/addLink.js","./addNamedLink":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/addNamedLink.js","./clone":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/clone.js","./create":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/create.js","./rmLink":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/rmLink.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","class-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const assert = require('assert')
const withIs = require('class-is')
const addNamedLink = require('./addNamedLink')
const visibility = require('../visibility')

class DAGNode {
  constructor (data, links, serializedSize) {
    if (serializedSize !== 0) {
      assert(serializedSize, 'A DAGNode requires it\'s serialized size')
    }

    this._data = data || Buffer.alloc(0)
    this._links = links
    this._serializedSize = serializedSize

    // Make sure we have a nice public API that can be used by an IPLD resolver
    visibility.hidePrivateFields(this)
    visibility.addEnumerableGetters(this, ['Data', 'Links'])

    // Add getters for existing links by the name of the link
    // This is how paths are traversed in IPFS. Links with names won't
    // override existing fields like `data` or `links`.
    links.forEach((link, position) => {
      addNamedLink(this, link.Name, position)
    })
  }

  toJSON () {
    if (!this._json) {
      this._json = Object.freeze({
        data: this.Data,
        links: this._links.map((l) => l.toJSON()),
        size: this.size
      })
    }

    return Object.assign({}, this._json)
  }

  toString () {
    return `DAGNode <data: "${this.Data.toString('base64')}", links: ${this.Links.length}, size: ${this.size}>`
  }

  get size () {
    if (this._size === undefined) {
      this._size = this._links.reduce((sum, l) => sum + l.Tsize, this._serializedSize)
    }

    return this._size
  }

  set size (size) {
    throw new Error("Can't set property: 'size' is immutable")
  }

  // Getters for backwards compatible path resolving
  get Data () {
    return this._data
  }
  set Data (_) {
    throw new Error("Can't set property: 'Data' is immutable")
  }
  get Links () {
    return this._links.map((link) => {
      return {
        Name: link.Name,
        Tsize: link.Tsize,
        Hash: link.Hash
      }
    })
  }
  set Links (_) {
    throw new Error("Can't set property: 'Links' is immutable")
  }
}

exports = module.exports = withIs(DAGNode, { className: 'DAGNode', symbolName: '@ipld/js-ipld-dag-pb/dagnode' })
exports.create = require('./create')
exports.clone = require('./clone')
exports.addLink = require('./addLink')
exports.rmLink = require('./rmLink')

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipld-dag-pb",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/index.js", {"./crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/crypto.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/index.js
      return function (require, module, exports) {
'use strict'

const { Buffer } = require('buffer')
const errcode = require('err-code')
const multihash = require('multihashes')
const crypto = require('./crypto')

/**
 * Hash the given `buf` using the algorithm specified by `alg`.
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} alg - The algorithm to use eg 'sha1'
 * @param {number} [length] - Optionally trim the result to this length.
 * @returns {Promise<Buffer>}
 */
async function Multihashing (buf, alg, length) {
  const digest = await Multihashing.digest(buf, alg, length)
  return multihash.encode(digest, alg, length)
}

/**
 * The `buffer` module for easy use in the browser.
 *
 * @type {Buffer}
 */
Multihashing.Buffer = Buffer // for browser things

/**
 * Expose multihash itself, to avoid silly double requires.
 */
Multihashing.multihash = multihash

/**
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} alg - The algorithm to use eg 'sha1'
 * @param {number} [length] - Optionally trim the result to this length.
 * @returns {Promise<Buffer>}
 */
Multihashing.digest = async (buf, alg, length) => {
  const hash = Multihashing.createHash(alg)
  const digest = await hash(buf)
  return length ? digest.slice(0, length) : digest
}

/**
 * Creates a function that hashes with the given algorithm
 *
 * @param {string|number} alg - The algorithm to use eg 'sha1'
 *
 * @returns {function} - The hash function corresponding to `alg`
 */
Multihashing.createHash = function (alg) {
  if (!alg) {
    throw errcode('hash algorithm must be specified', 'ERR_HASH_ALGORITHM_NOT_SPECIFIED')
  }

  alg = multihash.coerceCode(alg)
  if (!Multihashing.functions[alg]) {
    throw errcode(`multihash function '${alg}' not yet supported`, 'ERR_HASH_ALGORITHM_NOT_SUPPORTED')
  }

  return Multihashing.functions[alg]
}

/**
 * Mapping of multihash codes to their hashing functions.
 * @type {Object}
 */
Multihashing.functions = {
  // sha1
  0x11: crypto.sha1,
  // sha2-256
  0x12: crypto.sha2256,
  // sha2-512
  0x13: crypto.sha2512,
  // sha3-512
  0x14: crypto.sha3512,
  // sha3-384
  0x15: crypto.sha3384,
  // sha3-256
  0x16: crypto.sha3256,
  // sha3-224
  0x17: crypto.sha3224,
  // shake-128
  0x18: crypto.shake128,
  // shake-256
  0x19: crypto.shake256,
  // keccak-224
  0x1A: crypto.keccak224,
  // keccak-256
  0x1B: crypto.keccak256,
  // keccak-384
  0x1C: crypto.keccak384,
  // keccak-512
  0x1D: crypto.keccak512,
  // murmur3-128
  0x22: crypto.murmur3128,
  // murmur3-32
  0x23: crypto.murmur332,
  // dbl-sha2-256
  0x56: crypto.dblSha2256
}

// add blake functions
crypto.addBlake(Multihashing.functions)

Multihashing.validate = async (buf, hash) => {
  const newHash = await Multihashing(buf, multihash.decode(hash).name)

  return Buffer.compare(hash, newHash) === 0
}

module.exports = Multihashing

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base.js
      return function (require, module, exports) {
'use strict'

class Base {
  constructor (name, code, implementation, alphabet) {
    this.name = name
    this.code = code
    this.alphabet = alphabet
    if (implementation && alphabet) {
      this.engine = implementation(alphabet)
    }
  }

  encode (stringOrBuffer) {
    return this.engine.encode(stringOrBuffer)
  }

  decode (stringOrBuffer) {
    return this.engine.decode(stringOrBuffer)
  }

  isImplemented () {
    return this.engine
  }
}

module.exports = Base

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base16.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base16.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

module.exports = function base16 (alphabet) {
  return {
    encode (input) {
      if (typeof input === 'string') {
        return Buffer.from(input).toString('hex')
      }
      return input.toString('hex')
    },
    decode (input) {
      for (let char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base16 character')
        }
      }
      return Buffer.from(input, 'hex')
    }
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base16.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base32.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base32.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

function decode (input, alphabet) {
  input = input.replace(new RegExp('=', 'g'), '')
  let length = input.length

  let bits = 0
  let value = 0

  let index = 0
  let output = new Uint8Array((length * 5 / 8) | 0)

  for (let i = 0; i < length; i++) {
    value = (value << 5) | alphabet.indexOf(input[i])
    bits += 5

    if (bits >= 8) {
      output[index++] = (value >>> (bits - 8)) & 255
      bits -= 8
    }
  }

  return output.buffer
}

function encode (buffer, alphabet) {
  let length = buffer.byteLength
  let view = new Uint8Array(buffer)
  let padding = alphabet.indexOf('=') === alphabet.length - 1

  if (padding) {
    alphabet = alphabet.substring(0, alphabet.length - 2)
  }

  let bits = 0
  let value = 0
  let output = ''

  for (let i = 0; i < length; i++) {
    value = (value << 8) | view[i]
    bits += 8

    while (bits >= 5) {
      output += alphabet[(value >>> (bits - 5)) & 31]
      bits -= 5
    }
  }

  if (bits > 0) {
    output += alphabet[(value << (5 - bits)) & 31]
  }

  if (padding) {
    while ((output.length % 8) !== 0) {
      output += '='
    }
  }

  return output
}

module.exports = function base32 (alphabet) {
  return {
    encode (input) {
      if (typeof input === 'string') {
        return encode(Buffer.from(input), alphabet)
      }

      return encode(input, alphabet)
    },
    decode (input) {
      for (let char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base32 character')
        }
      }

      return decode(input, alphabet)
    }
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base32.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base64.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base64.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

module.exports = function base64 (alphabet) {
  // The alphabet is only used to know:
  //   1. If padding is enabled (must contain '=')
  //   2. If the output must be url-safe (must contain '-' and '_')
  //   3. If the input of the output function is valid
  // The alphabets from RFC 4648 are always used.
  const padding = alphabet.indexOf('=') > -1
  const url = alphabet.indexOf('-') > -1 && alphabet.indexOf('_') > -1

  return {
    encode (input) {
      let output = ''

      if (typeof input === 'string') {
        output = Buffer.from(input).toString('base64')
      } else {
        output = input.toString('base64')
      }

      if (url) {
        output = output.replace(/\+/g, '-').replace(/\//g, '_')
      }

      const pad = output.indexOf('=')
      if (pad > 0 && !padding) {
        output = output.substring(0, pad)
      }

      return output
    },
    decode (input) {
      for (let char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base64 character')
        }
      }

      return Buffer.from(input, 'base64')
    }
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base64.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/node_modules/base-x/index.js", {"safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/node_modules/base-x/index.js
      return function (require, module, exports) {
// base-x encoding
// Forked from https://github.com/cryptocoinjs/bs58
// Originally written by Mike Hearn for BitcoinJ
// Copyright (c) 2011 Google Inc
// Ported to JavaScript by Stefan Thomas
// Merged Buffer refactorings from base58-native by Stephen Pair
// Copyright (c) 2013 BitPay Inc

var Buffer = require('safe-buffer').Buffer

module.exports = function base (ALPHABET) {
  var ALPHABET_MAP = {}
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)

  // pre-compute lookup table
  for (var z = 0; z < ALPHABET.length; z++) {
    var x = ALPHABET.charAt(z)

    if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')
    ALPHABET_MAP[x] = z
  }

  function encode (source) {
    if (source.length === 0) return ''

    var digits = [0]
    for (var i = 0; i < source.length; ++i) {
      for (var j = 0, carry = source[i]; j < digits.length; ++j) {
        carry += digits[j] << 8
        digits[j] = carry % BASE
        carry = (carry / BASE) | 0
      }

      while (carry > 0) {
        digits.push(carry % BASE)
        carry = (carry / BASE) | 0
      }
    }

    var string = ''

    // deal with leading zeros
    for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) string += LEADER
    // convert digits to a string
    for (var q = digits.length - 1; q >= 0; --q) string += ALPHABET[digits[q]]

    return string
  }

  function decodeUnsafe (string) {
    if (typeof string !== 'string') throw new TypeError('Expected String')
    if (string.length === 0) return Buffer.allocUnsafe(0)

    var bytes = [0]
    for (var i = 0; i < string.length; i++) {
      var value = ALPHABET_MAP[string[i]]
      if (value === undefined) return

      for (var j = 0, carry = value; j < bytes.length; ++j) {
        carry += bytes[j] * BASE
        bytes[j] = carry & 0xff
        carry >>= 8
      }

      while (carry > 0) {
        bytes.push(carry & 0xff)
        carry >>= 8
      }
    }

    // deal with leading zeros
    for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
      bytes.push(0)
    }

    return Buffer.from(bytes.reverse())
  }

  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) return buffer

    throw new Error('Non-base' + BASE + ' character')
  }

  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}

      };
    };
  }
}, {package:"base-x",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/node_modules/base-x/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/convert.js", {"./protocols-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/protocols-table.js","bs58":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bs58/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","hi-base32":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/hi-base32/src/base32.js","ip":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ip/lib/ip.js","is-ip":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-ip/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/convert.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const ip = require('ip')
const isIp = require('is-ip')
const protocols = require('./protocols-table')
const bs58 = require('bs58')
const base32 = require('hi-base32')
const varint = require('varint')

module.exports = Convert

// converts (serializes) addresses
function Convert (proto, a) {
  if (a instanceof Buffer) {
    return Convert.toString(proto, a)
  } else {
    return Convert.toBuffer(proto, a)
  }
}

Convert.toString = function convertToString (proto, buf) {
  proto = protocols(proto)
  switch (proto.code) {
    case 4: // ipv4
    case 41: // ipv6
      return buf2ip(buf)

    case 6: // tcp
    case 273: // udp
    case 33: // dccp
    case 132: // sctp
      return buf2port(buf)

    case 53: // dns
    case 54: // dns4
    case 55: // dns6
    case 56: // dnsaddr
    case 400: // unix
      return buf2str(buf)

    case 421: // ipfs
      return buf2mh(buf)
    case 444: // onion
      return buf2onion(buf)
    case 445: // onion3
      return buf2onion(buf)
    default:
      return buf.toString('hex') // no clue. convert to hex
  }
}

Convert.toBuffer = function convertToBuffer (proto, str) {
  proto = protocols(proto)
  switch (proto.code) {
    case 4: // ipv4
      return ip2buf(str)
    case 41: // ipv6
      return ip2buf(str)

    case 6: // tcp
    case 273: // udp
    case 33: // dccp
    case 132: // sctp
      return port2buf(parseInt(str, 10))

    case 53: // dns
    case 54: // dns4
    case 55: // dns6
    case 56: // dnsaddr
    case 400: // unix
      return str2buf(str)

    case 421: // ipfs
      return mh2buf(str)
    case 444: // onion
      return onion2buf(str)
    case 445: // onion3
      return onion32buf(str)
    default:
      return Buffer.from(str, 'hex') // no clue. convert from hex
  }
}

function ip2buf (ipString) {
  if (!isIp(ipString)) {
    throw new Error('invalid ip address')
  }
  return ip.toBuffer(ipString)
}

function buf2ip (ipBuff) {
  const ipString = ip.toString(ipBuff)
  if (!isIp(ipString)) {
    throw new Error('invalid ip address')
  }
  return ipString
}

function port2buf (port) {
  const buf = Buffer.alloc(2)
  buf.writeUInt16BE(port, 0)
  return buf
}

function buf2port (buf) {
  return buf.readUInt16BE(0)
}

function str2buf (str) {
  const buf = Buffer.from(str)
  const size = Buffer.from(varint.encode(buf.length))
  return Buffer.concat([size, buf])
}

function buf2str (buf) {
  const size = varint.decode(buf)
  buf = buf.slice(varint.decode.bytes)

  if (buf.length !== size) {
    throw new Error('inconsistent lengths')
  }

  return buf.toString()
}

function mh2buf (hash) {
  // the address is a varint prefixed multihash string representation
  const mh = Buffer.from(bs58.decode(hash))
  const size = Buffer.from(varint.encode(mh.length))
  return Buffer.concat([size, mh])
}

function buf2mh (buf) {
  const size = varint.decode(buf)
  const address = buf.slice(varint.decode.bytes)

  if (address.length !== size) {
    throw new Error('inconsistent lengths')
  }

  return bs58.encode(address)
}

function onion2buf (str) {
  const addr = str.split(':')
  if (addr.length !== 2) {
    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number')
  }
  if (addr[0].length !== 16) {
    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion address.')
  }
  const buf = Buffer.from(base32.decode.asBytes(addr[0].toUpperCase()))

  // onion port number
  const port = parseInt(addr[1], 10)
  if (port < 1 || port > 65536) {
    throw new Error('Port number is not in range(1, 65536)')
  }
  const portBuf = port2buf(port)
  return Buffer.concat([buf, portBuf])
}

function onion32buf (str) {
  const addr = str.split(':')
  if (addr.length !== 2) {
    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number')
  }
  if (addr[0].length !== 56) {
    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion3 address.')
  }
  const buf = Buffer.from(base32.decode.asBytes(addr[0].toUpperCase()))

  // onion port number
  const port = parseInt(addr[1], 10)
  if (port < 1 || port > 65536) {
    throw new Error('Port number is not in range(1, 65536)')
  }
  const portBuf = port2buf(port)
  return Buffer.concat([buf, portBuf])
}

function buf2onion (buf) {
  const addrBytes = buf.slice(0, buf.length - 2)
  const portBytes = buf.slice(buf.length - 2)
  const addr = base32.encode(addrBytes).toString('ascii').toLowerCase()
  const port = buf2port(portBytes)
  return addr + ':' + port
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multiaddr",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/convert.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/utils.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/utils.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
'use strict'

exports.toCallback = (doWork) => {
  return function (input, callback) {
    let res
    try {
      res = doWork(input)
    } catch (err) {
      process.nextTick(callback, err)
      return
    }

    process.nextTick(callback, null, res)
  }
}

exports.toBuf = (doWork, other) => (input) => {
  let result = doWork(input, other)
  return Buffer.from(result, 'hex')
}

exports.fromString = (doWork, other) => (_input) => {
  const input = Buffer.isBuffer(_input) ? _input.toString() : _input
  return doWork(input, other)
}

exports.fromNumberTo32BitBuf = (doWork, other) => (input) => {
  let number = doWork(input, other)
  const bytes = new Array(4)

  for (let i = 0; i < 4; i++) {
    bytes[i] = number & 0xff
    number = number >> 8
  }

  return Buffer.from(bytes)
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js/index.js", {"./lib/murmurHash3js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js/lib/murmurHash3js.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js/index.js
      return function (require, module, exports) {
module.exports = require('./lib/murmurHash3js');

      };
    };
  }
}, {package:"murmurhash3js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/blake.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/utils.js","blakejs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/blake.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const blake = require('blakejs')

const toCallback = require('./utils').toCallback

const minB = 0xb201
const minS = 0xb241

const blake2b = {
  init: blake.blake2bInit,
  update: blake.blake2bUpdate,
  digest: blake.blake2bFinal
}

const blake2s = {
  init: blake.blake2sInit,
  update: blake.blake2sUpdate,
  digest: blake.blake2sFinal
}

const makeB2Hash = (size, hf) => toCallback((buf) => {
  const ctx = hf.init(size, null)
  hf.update(ctx, buf)
  return Buffer.from(hf.digest(ctx))
})

module.exports = (table) => {
  for (let i = 0; i < 64; i++) {
    table[minB + i] = makeB2Hash(i + 1, blake2b)
  }
  for (let i = 0; i < 32; i++) {
    table[minS + i] = makeB2Hash(i + 1, blake2s)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/blake.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/crypto-sha1-2-browser.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","nodeify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/nodeify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/crypto-sha1-2-browser.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* global self */

'use strict'

const nodeify = require('nodeify')

const webCrypto = getWebCrypto()

function getWebCrypto () {
  if (self.crypto) {
    return self.crypto.subtle || self.crypto.webkitSubtle
  }

  if (self.msCrypto) {
    return self.msCrypto.subtle
  }
}

function webCryptoHash (type) {
  if (!webCrypto) {
    throw new Error('Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context')
  }

  return (data, callback) => {
    const res = webCrypto.digest({ name: type }, data)

    if (typeof res.then !== 'function') { // IE11
      res.onerror = () => {
        callback(new Error(`hashing data using ${type}`))
      }
      res.oncomplete = (e) => {
        callback(null, e.target.result)
      }
      return
    }

    nodeify(
      res.then((raw) => Buffer.from(new Uint8Array(raw))),
      callback
    )
  }
}

function sha1 (buf, callback) {
  webCryptoHash('SHA-1')(buf, callback)
}

function sha2256 (buf, callback) {
  webCryptoHash('SHA-256')(buf, callback)
}

function sha2512 (buf, callback) {
  webCryptoHash('SHA-512')(buf, callback)
}

module.exports = {
  sha1: sha1,
  sha2256: sha2256,
  sha2512: sha2512
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/crypto-sha1-2-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/nodeify.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/nodeify.js
      return function (require, module, exports) {
'use strict'

// Based on npmjs.com/nodeify but without additional `nextTick` calls
// to keep the overhead low
module.exports = function nodeify (promise, cb) {
  return promise.then((res) => {
    cb(null, res)
  }, (err) => {
    cb(err)
  })
}

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/nodeify.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/webcrypto.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/webcrypto.js
      return function (require, module, exports) {
/* global self */

'use strict'

module.exports = self.crypto || self.msCrypto

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/webcrypto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/hmac/lengths.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/hmac/lengths.js
      return function (require, module, exports) {
'use strict'

module.exports = {
  SHA1: 20,
  SHA256: 32,
  SHA512: 64
}

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/hmac/lengths.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-random-stream/src/random.browser.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-random-stream/src/random.browser.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

const crypto = global.crypto || global.msCrypto;

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
const MAX_BYTES = 65536;

function oldBrowser() {
    throw new Error(
        'Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11'
    );
}

if (crypto && crypto.getRandomValues) {
    module.exports = randomBytes;
} else {
    module.exports = oldBrowser;
}

function randomBytes(size) {
    const bytes = new Uint8Array(size);
    let generated = 0;

    if (size > 0) {
        // getRandomValues fails on IE if size == 0
        if (size > MAX_BYTES) {
            while (generated < bytes) {
                if (generated + MAX_BYTES > bytes) {
                    crypto.getRandomValues(
                        bytes.subarray(generated, bytes - generated)
                    );
                } else {
                    crypto.getRandomValues(
                        bytes.subarray(generated, generated + MAX_BYTES)
                    );
                    generated += MAX_BYTES;
                }
            }
        } else {
            crypto.getRandomValues(bytes);
        }
    }

    return Buffer.from(bytes);
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"iso-random-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-random-stream/src/random.browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/aes/ciphers-browser.js", {"browserify-aes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify-aes/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/aes/ciphers-browser.js
      return function (require, module, exports) {
'use strict'

const crypto = require('browserify-aes')

module.exports = {
  createCipheriv: crypto.createCipheriv,
  createDecipheriv: crypto.createDecipheriv
}

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/aes/ciphers-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pbkdf2.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./hmac":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/hmac.js","./md":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/md.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js","crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pbkdf2.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/**
 * Password-Based Key-Derivation Function #2 implementation.
 *
 * See RFC 2898 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./hmac');
require('./md');
require('./util');

var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};

var crypto;
if(forge.util.isNodejs && !forge.options.usePureJavaScript) {
  crypto = require('crypto');
}

/**
 * Derives a key from a password.
 *
 * @param p the password as a binary-encoded string of bytes.
 * @param s the salt as a binary-encoded string of bytes.
 * @param c the iteration count, a positive integer.
 * @param dkLen the intended length, in bytes, of the derived key,
 *          (max: 2^32 - 1) * hash length of the PRF.
 * @param [md] the message digest (or algorithm identifier as a string) to use
 *          in the PRF, defaults to SHA-1.
 * @param [callback(err, key)] presence triggers asynchronous version, called
 *          once the operation completes.
 *
 * @return the derived key, as a binary-encoded string of bytes, for the
 *           synchronous version (if no callback is specified).
 */
module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(
  p, s, c, dkLen, md, callback) {
  if(typeof md === 'function') {
    callback = md;
    md = null;
  }

  // use native implementation if possible and not disabled, note that
  // some node versions only support SHA-1, others allow digest to be changed
  if(forge.util.isNodejs && !forge.options.usePureJavaScript &&
    crypto.pbkdf2 && (md === null || typeof md !== 'object') &&
    (crypto.pbkdf2Sync.length > 4 || (!md || md === 'sha1'))) {
    if(typeof md !== 'string') {
      // default prf to SHA-1
      md = 'sha1';
    }
    p = Buffer.from(p, 'binary');
    s = Buffer.from(s, 'binary');
    if(!callback) {
      if(crypto.pbkdf2Sync.length === 4) {
        return crypto.pbkdf2Sync(p, s, c, dkLen).toString('binary');
      }
      return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString('binary');
    }
    if(crypto.pbkdf2Sync.length === 4) {
      return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {
        if(err) {
          return callback(err);
        }
        callback(null, key.toString('binary'));
      });
    }
    return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {
      if(err) {
        return callback(err);
      }
      callback(null, key.toString('binary'));
    });
  }

  if(typeof md === 'undefined' || md === null) {
    // default prf to SHA-1
    md = 'sha1';
  }
  if(typeof md === 'string') {
    if(!(md in forge.md.algorithms)) {
      throw new Error('Unknown hash algorithm: ' + md);
    }
    md = forge.md[md].create();
  }

  var hLen = md.digestLength;

  /* 1. If dkLen > (2^32 - 1) * hLen, output "derived key too long" and
    stop. */
  if(dkLen > (0xFFFFFFFF * hLen)) {
    var err = new Error('Derived key is too long.');
    if(callback) {
      return callback(err);
    }
    throw err;
  }

  /* 2. Let len be the number of hLen-octet blocks in the derived key,
    rounding up, and let r be the number of octets in the last
    block:

    len = CEIL(dkLen / hLen),
    r = dkLen - (len - 1) * hLen. */
  var len = Math.ceil(dkLen / hLen);
  var r = dkLen - (len - 1) * hLen;

  /* 3. For each block of the derived key apply the function F defined
    below to the password P, the salt S, the iteration count c, and
    the block index to compute the block:

    T_1 = F(P, S, c, 1),
    T_2 = F(P, S, c, 2),
    ...
    T_len = F(P, S, c, len),

    where the function F is defined as the exclusive-or sum of the
    first c iterates of the underlying pseudorandom function PRF
    applied to the password P and the concatenation of the salt S
    and the block index i:

    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c

    where

    u_1 = PRF(P, S || INT(i)),
    u_2 = PRF(P, u_1),
    ...
    u_c = PRF(P, u_{c-1}).

    Here, INT(i) is a four-octet encoding of the integer i, most
    significant octet first. */
  var prf = forge.hmac.create();
  prf.start(md, p);
  var dk = '';
  var xor, u_c, u_c1;

  // sync version
  if(!callback) {
    for(var i = 1; i <= len; ++i) {
      // PRF(P, S || INT(i)) (first iteration)
      prf.start(null, null);
      prf.update(s);
      prf.update(forge.util.int32ToBytes(i));
      xor = u_c1 = prf.digest().getBytes();

      // PRF(P, u_{c-1}) (other iterations)
      for(var j = 2; j <= c; ++j) {
        prf.start(null, null);
        prf.update(u_c1);
        u_c = prf.digest().getBytes();
        // F(p, s, c, i)
        xor = forge.util.xorBytes(xor, u_c, hLen);
        u_c1 = u_c;
      }

      /* 4. Concatenate the blocks and extract the first dkLen octets to
        produce a derived key DK:

        DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */
      dk += (i < len) ? xor : xor.substr(0, r);
    }
    /* 5. Output the derived key DK. */
    return dk;
  }

  // async version
  var i = 1, j;
  function outer() {
    if(i > len) {
      // done
      return callback(null, dk);
    }

    // PRF(P, S || INT(i)) (first iteration)
    prf.start(null, null);
    prf.update(s);
    prf.update(forge.util.int32ToBytes(i));
    xor = u_c1 = prf.digest().getBytes();

    // PRF(P, u_{c-1}) (other iterations)
    j = 2;
    inner();
  }

  function inner() {
    if(j <= c) {
      prf.start(null, null);
      prf.update(u_c1);
      u_c = prf.digest().getBytes();
      // F(p, s, c, i)
      xor = forge.util.xorBytes(xor, u_c, hLen);
      u_c1 = u_c;
      ++j;
      return forge.util.setImmediate(inner);
    }

    /* 4. Concatenate the blocks and extract the first dkLen octets to
      produce a derived key DK:

      DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */
    dk += (i < len) ? xor : xor.substr(0, r);

    ++i;
    outer();
  }

  outer();
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pbkdf2.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js", {"./baseN":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/baseN.js","./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js","timers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/timers-browserify/main.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js
      return function (require, module, exports) {
(function (process,Buffer,setImmediate){(function (){
/**
 * Utility functions for web applications.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2018 Digital Bazaar, Inc.
 */
var forge = require('./forge');
var baseN = require('./baseN');

/* Utilities API */
var util = module.exports = forge.util = forge.util || {};

// define setImmediate and nextTick
(function() {
  // use native nextTick (unless we're in webpack)
  // webpack (or better node-libs-browser polyfill) sets process.browser.
  // this way we can detect webpack properly
  if(typeof process !== 'undefined' && process.nextTick && !process.browser) {
    util.nextTick = process.nextTick;
    if(typeof setImmediate === 'function') {
      util.setImmediate = setImmediate;
    } else {
      // polyfill setImmediate with nextTick, older versions of node
      // (those w/o setImmediate) won't totally starve IO
      util.setImmediate = util.nextTick;
    }
    return;
  }

  // polyfill nextTick with native setImmediate
  if(typeof setImmediate === 'function') {
    util.setImmediate = function() { return setImmediate.apply(undefined, arguments); };
    util.nextTick = function(callback) {
      return setImmediate(callback);
    };
    return;
  }

  /* Note: A polyfill upgrade pattern is used here to allow combining
  polyfills. For example, MutationObserver is fast, but blocks UI updates,
  so it needs to allow UI updates periodically, so it falls back on
  postMessage or setTimeout. */

  // polyfill with setTimeout
  util.setImmediate = function(callback) {
    setTimeout(callback, 0);
  };

  // upgrade polyfill to use postMessage
  if(typeof window !== 'undefined' &&
    typeof window.postMessage === 'function') {
    var msg = 'forge.setImmediate';
    var callbacks = [];
    util.setImmediate = function(callback) {
      callbacks.push(callback);
      // only send message when one hasn't been sent in
      // the current turn of the event loop
      if(callbacks.length === 1) {
        window.postMessage(msg, '*');
      }
    };
    function handler(event) {
      if(event.source === window && event.data === msg) {
        event.stopPropagation();
        var copy = callbacks.slice();
        callbacks.length = 0;
        copy.forEach(function(callback) {
          callback();
        });
      }
    }
    window.addEventListener('message', handler, true);
  }

  // upgrade polyfill to use MutationObserver
  if(typeof MutationObserver !== 'undefined') {
    // polyfill with MutationObserver
    var now = Date.now();
    var attr = true;
    var div = document.createElement('div');
    var callbacks = [];
    new MutationObserver(function() {
      var copy = callbacks.slice();
      callbacks.length = 0;
      copy.forEach(function(callback) {
        callback();
      });
    }).observe(div, {attributes: true});
    var oldSetImmediate = util.setImmediate;
    util.setImmediate = function(callback) {
      if(Date.now() - now > 15) {
        now = Date.now();
        oldSetImmediate(callback);
      } else {
        callbacks.push(callback);
        // only trigger observer when it hasn't been triggered in
        // the current turn of the event loop
        if(callbacks.length === 1) {
          div.setAttribute('a', attr = !attr);
        }
      }
    };
  }

  util.nextTick = util.setImmediate;
})();

// check if running under Node.js
util.isNodejs =
  typeof process !== 'undefined' && process.versions && process.versions.node;


// 'self' will also work in Web Workers (instance of WorkerGlobalScope) while
// it will point to `window` in the main thread.
// To remain compatible with older browsers, we fall back to 'window' if 'self'
// is not available.
util.globalScope = (function() {
  if(util.isNodejs) {
    return global;
  }

  return typeof self === 'undefined' ? window : self;
})();

// define isArray
util.isArray = Array.isArray || function(x) {
  return Object.prototype.toString.call(x) === '[object Array]';
};

// define isArrayBuffer
util.isArrayBuffer = function(x) {
  return typeof ArrayBuffer !== 'undefined' && x instanceof ArrayBuffer;
};

// define isArrayBufferView
util.isArrayBufferView = function(x) {
  return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;
};

/**
 * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for
 * algorithms where bit manipulation, JavaScript limitations, and/or algorithm
 * design only allow for byte operations of a limited size.
 *
 * @param n number of bits.
 *
 * Throw Error if n invalid.
 */
function _checkBitsParam(n) {
  if(!(n === 8 || n === 16 || n === 24 || n === 32)) {
    throw new Error('Only 8, 16, 24, or 32 bits supported: ' + n);
  }
}

// TODO: set ByteBuffer to best available backing
util.ByteBuffer = ByteStringBuffer;

/** Buffer w/BinaryString backing */

/**
 * Constructor for a binary string backed byte buffer.
 *
 * @param [b] the bytes to wrap (either encoded as string, one byte per
 *          character, or as an ArrayBuffer or Typed Array).
 */
function ByteStringBuffer(b) {
  // TODO: update to match DataBuffer API

  // the data in this buffer
  this.data = '';
  // the pointer for reading from this buffer
  this.read = 0;

  if(typeof b === 'string') {
    this.data = b;
  } else if(util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
    if(typeof Buffer !== 'undefined' && b instanceof Buffer) {
      this.data = b.toString('binary');
    } else {
      // convert native buffer to forge buffer
      // FIXME: support native buffers internally instead
      var arr = new Uint8Array(b);
      try {
        this.data = String.fromCharCode.apply(null, arr);
      } catch(e) {
        for(var i = 0; i < arr.length; ++i) {
          this.putByte(arr[i]);
        }
      }
    }
  } else if(b instanceof ByteStringBuffer ||
    (typeof b === 'object' && typeof b.data === 'string' &&
    typeof b.read === 'number')) {
    // copy existing buffer
    this.data = b.data;
    this.read = b.read;
  }

  // used for v8 optimization
  this._constructedStringLength = 0;
}
util.ByteStringBuffer = ByteStringBuffer;

/* Note: This is an optimization for V8-based browsers. When V8 concatenates
  a string, the strings are only joined logically using a "cons string" or
  "constructed/concatenated string". These containers keep references to one
  another and can result in very large memory usage. For example, if a 2MB
  string is constructed by concatenating 4 bytes together at a time, the
  memory usage will be ~44MB; so ~22x increase. The strings are only joined
  together when an operation requiring their joining takes place, such as
  substr(). This function is called when adding data to this buffer to ensure
  these types of strings are periodically joined to reduce the memory
  footprint. */
var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
  this._constructedStringLength += x;
  if(this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
    // this substr() should cause the constructed string to join
    this.data.substr(0, 1);
    this._constructedStringLength = 0;
  }
};

/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */
util.ByteStringBuffer.prototype.length = function() {
  return this.data.length - this.read;
};

/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */
util.ByteStringBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};

/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putByte = function(b) {
  return this.putBytes(String.fromCharCode(b));
};

/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
  b = String.fromCharCode(b);
  var d = this.data;
  while(n > 0) {
    if(n & 1) {
      d += b;
    }
    n >>>= 1;
    if(n > 0) {
      b += b;
    }
  }
  this.data = d;
  this._optimizeConstructedString(n);
  return this;
};

/**
 * Puts bytes in this buffer.
 *
 * @param bytes the bytes (as a binary encoded string) to put.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putBytes = function(bytes) {
  this.data += bytes;
  this._optimizeConstructedString(bytes.length);
  return this;
};

/**
 * Puts a UTF-16 encoded string into this buffer.
 *
 * @param str the string to put.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putString = function(str) {
  return this.putBytes(util.encodeUtf8(str));
};

/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putInt16 = function(i) {
  return this.putBytes(
    String.fromCharCode(i >> 8 & 0xFF) +
    String.fromCharCode(i & 0xFF));
};

/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putInt24 = function(i) {
  return this.putBytes(
    String.fromCharCode(i >> 16 & 0xFF) +
    String.fromCharCode(i >> 8 & 0xFF) +
    String.fromCharCode(i & 0xFF));
};

/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putInt32 = function(i) {
  return this.putBytes(
    String.fromCharCode(i >> 24 & 0xFF) +
    String.fromCharCode(i >> 16 & 0xFF) +
    String.fromCharCode(i >> 8 & 0xFF) +
    String.fromCharCode(i & 0xFF));
};

/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putInt16Le = function(i) {
  return this.putBytes(
    String.fromCharCode(i & 0xFF) +
    String.fromCharCode(i >> 8 & 0xFF));
};

/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putInt24Le = function(i) {
  return this.putBytes(
    String.fromCharCode(i & 0xFF) +
    String.fromCharCode(i >> 8 & 0xFF) +
    String.fromCharCode(i >> 16 & 0xFF));
};

/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putInt32Le = function(i) {
  return this.putBytes(
    String.fromCharCode(i & 0xFF) +
    String.fromCharCode(i >> 8 & 0xFF) +
    String.fromCharCode(i >> 16 & 0xFF) +
    String.fromCharCode(i >> 24 & 0xFF));
};

/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putInt = function(i, n) {
  _checkBitsParam(n);
  var bytes = '';
  do {
    n -= 8;
    bytes += String.fromCharCode((i >> n) & 0xFF);
  } while(n > 0);
  return this.putBytes(bytes);
};

/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
  // putInt checks n
  if(i < 0) {
    i += 2 << (n - 1);
  }
  return this.putInt(i, n);
};

/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
  return this.putBytes(buffer.getBytes());
};

/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */
util.ByteStringBuffer.prototype.getByte = function() {
  return this.data.charCodeAt(this.read++);
};

/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */
util.ByteStringBuffer.prototype.getInt16 = function() {
  var rval = (
    this.data.charCodeAt(this.read) << 8 ^
    this.data.charCodeAt(this.read + 1));
  this.read += 2;
  return rval;
};

/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */
util.ByteStringBuffer.prototype.getInt24 = function() {
  var rval = (
    this.data.charCodeAt(this.read) << 16 ^
    this.data.charCodeAt(this.read + 1) << 8 ^
    this.data.charCodeAt(this.read + 2));
  this.read += 3;
  return rval;
};

/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */
util.ByteStringBuffer.prototype.getInt32 = function() {
  var rval = (
    this.data.charCodeAt(this.read) << 24 ^
    this.data.charCodeAt(this.read + 1) << 16 ^
    this.data.charCodeAt(this.read + 2) << 8 ^
    this.data.charCodeAt(this.read + 3));
  this.read += 4;
  return rval;
};

/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */
util.ByteStringBuffer.prototype.getInt16Le = function() {
  var rval = (
    this.data.charCodeAt(this.read) ^
    this.data.charCodeAt(this.read + 1) << 8);
  this.read += 2;
  return rval;
};

/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */
util.ByteStringBuffer.prototype.getInt24Le = function() {
  var rval = (
    this.data.charCodeAt(this.read) ^
    this.data.charCodeAt(this.read + 1) << 8 ^
    this.data.charCodeAt(this.read + 2) << 16);
  this.read += 3;
  return rval;
};

/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */
util.ByteStringBuffer.prototype.getInt32Le = function() {
  var rval = (
    this.data.charCodeAt(this.read) ^
    this.data.charCodeAt(this.read + 1) << 8 ^
    this.data.charCodeAt(this.read + 2) << 16 ^
    this.data.charCodeAt(this.read + 3) << 24);
  this.read += 4;
  return rval;
};

/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by ceil(n/8).
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */
util.ByteStringBuffer.prototype.getInt = function(n) {
  _checkBitsParam(n);
  var rval = 0;
  do {
    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
    rval = (rval << 8) + this.data.charCodeAt(this.read++);
    n -= 8;
  } while(n > 0);
  return rval;
};

/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */
util.ByteStringBuffer.prototype.getSignedInt = function(n) {
  // getInt checks n
  var x = this.getInt(n);
  var max = 2 << (n - 2);
  if(x >= max) {
    x -= max << 1;
  }
  return x;
};

/**
 * Reads bytes out as a binary encoded string and clears them from the
 * buffer. Note that the resulting string is binary encoded (in node.js this
 * encoding is referred to as `binary`, it is *not* `utf8`).
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a binary encoded string of bytes.
 */
util.ByteStringBuffer.prototype.getBytes = function(count) {
  var rval;
  if(count) {
    // read count bytes
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if(count === 0) {
    rval = '';
  } else {
    // read all bytes, optimize to only copy when needed
    rval = (this.read === 0) ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
};

/**
 * Gets a binary encoded string of the bytes from this buffer without
 * modifying the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of binary encoded characters.
 */
util.ByteStringBuffer.prototype.bytes = function(count) {
  return (typeof(count) === 'undefined' ?
    this.data.slice(this.read) :
    this.data.slice(this.read, this.read + count));
};

/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */
util.ByteStringBuffer.prototype.at = function(i) {
  return this.data.charCodeAt(this.read + i);
};

/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.setAt = function(i, b) {
  this.data = this.data.substr(0, this.read + i) +
    String.fromCharCode(b) +
    this.data.substr(this.read + i + 1);
  return this;
};

/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */
util.ByteStringBuffer.prototype.last = function() {
  return this.data.charCodeAt(this.data.length - 1);
};

/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */
util.ByteStringBuffer.prototype.copy = function() {
  var c = util.createBuffer(this.data);
  c.read = this.read;
  return c;
};

/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.compact = function() {
  if(this.read > 0) {
    this.data = this.data.slice(this.read);
    this.read = 0;
  }
  return this;
};

/**
 * Clears this buffer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.clear = function() {
  this.data = '';
  this.read = 0;
  return this;
};

/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.truncate = function(count) {
  var len = Math.max(0, this.length() - count);
  this.data = this.data.substr(this.read, len);
  this.read = 0;
  return this;
};

/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */
util.ByteStringBuffer.prototype.toHex = function() {
  var rval = '';
  for(var i = this.read; i < this.data.length; ++i) {
    var b = this.data.charCodeAt(i);
    if(b < 16) {
      rval += '0';
    }
    rval += b.toString(16);
  }
  return rval;
};

/**
 * Converts this buffer to a UTF-16 string (standard JavaScript string).
 *
 * @return a UTF-16 string.
 */
util.ByteStringBuffer.prototype.toString = function() {
  return util.decodeUtf8(this.bytes());
};

/** End Buffer w/BinaryString backing */

/** Buffer w/UInt8Array backing */

/**
 * FIXME: Experimental. Do not use yet.
 *
 * Constructor for an ArrayBuffer-backed byte buffer.
 *
 * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a
 * TypedArray.
 *
 * If a string is given, its encoding should be provided as an option,
 * otherwise it will default to 'binary'. A 'binary' string is encoded such
 * that each character is one byte in length and size.
 *
 * If an ArrayBuffer, DataView, or TypedArray is given, it will be used
 * *directly* without any copying. Note that, if a write to the buffer requires
 * more space, the buffer will allocate a new backing ArrayBuffer to
 * accommodate. The starting read and write offsets for the buffer may be
 * given as options.
 *
 * @param [b] the initial bytes for this buffer.
 * @param options the options to use:
 *          [readOffset] the starting read offset to use (default: 0).
 *          [writeOffset] the starting write offset to use (default: the
 *            length of the first parameter).
 *          [growSize] the minimum amount, in bytes, to grow the buffer by to
 *            accommodate writes (default: 1024).
 *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the
 *            first parameter, if it is a string (default: 'binary').
 */
function DataBuffer(b, options) {
  // default options
  options = options || {};

  // pointers for read from/write to buffer
  this.read = options.readOffset || 0;
  this.growSize = options.growSize || 1024;

  var isArrayBuffer = util.isArrayBuffer(b);
  var isArrayBufferView = util.isArrayBufferView(b);
  if(isArrayBuffer || isArrayBufferView) {
    // use ArrayBuffer directly
    if(isArrayBuffer) {
      this.data = new DataView(b);
    } else {
      // TODO: adjust read/write offset based on the type of view
      // or specify that this must be done in the options ... that the
      // offsets are byte-based
      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
    }
    this.write = ('writeOffset' in options ?
      options.writeOffset : this.data.byteLength);
    return;
  }

  // initialize to empty array buffer and add any given bytes using putBytes
  this.data = new DataView(new ArrayBuffer(0));
  this.write = 0;

  if(b !== null && b !== undefined) {
    this.putBytes(b);
  }

  if('writeOffset' in options) {
    this.write = options.writeOffset;
  }
}
util.DataBuffer = DataBuffer;

/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */
util.DataBuffer.prototype.length = function() {
  return this.write - this.read;
};

/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */
util.DataBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};

/**
 * Ensures this buffer has enough empty space to accommodate the given number
 * of bytes. An optional parameter may be given that indicates a minimum
 * amount to grow the buffer if necessary. If the parameter is not given,
 * the buffer will be grown by some previously-specified default amount
 * or heuristic.
 *
 * @param amount the number of bytes to accommodate.
 * @param [growSize] the minimum amount, in bytes, to grow the buffer by if
 *          necessary.
 */
util.DataBuffer.prototype.accommodate = function(amount, growSize) {
  if(this.length() >= amount) {
    return this;
  }
  growSize = Math.max(growSize || this.growSize, amount);

  // grow buffer
  var src = new Uint8Array(
    this.data.buffer, this.data.byteOffset, this.data.byteLength);
  var dst = new Uint8Array(this.length() + growSize);
  dst.set(src);
  this.data = new DataView(dst.buffer);

  return this;
};

/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putByte = function(b) {
  this.accommodate(1);
  this.data.setUint8(this.write++, b);
  return this;
};

/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.fillWithByte = function(b, n) {
  this.accommodate(n);
  for(var i = 0; i < n; ++i) {
    this.data.setUint8(b);
  }
  return this;
};

/**
 * Puts bytes in this buffer. The bytes may be given as a string, an
 * ArrayBuffer, a DataView, or a TypedArray.
 *
 * @param bytes the bytes to put.
 * @param [encoding] the encoding for the first parameter ('binary', 'utf8',
 *          'utf16', 'hex'), if it is a string (default: 'binary').
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
  if(util.isArrayBufferView(bytes)) {
    var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    var len = src.byteLength - src.byteOffset;
    this.accommodate(len);
    var dst = new Uint8Array(this.data.buffer, this.write);
    dst.set(src);
    this.write += len;
    return this;
  }

  if(util.isArrayBuffer(bytes)) {
    var src = new Uint8Array(bytes);
    this.accommodate(src.byteLength);
    var dst = new Uint8Array(this.data.buffer);
    dst.set(src, this.write);
    this.write += src.byteLength;
    return this;
  }

  // bytes is a util.DataBuffer or equivalent
  if(bytes instanceof util.DataBuffer ||
    (typeof bytes === 'object' &&
    typeof bytes.read === 'number' && typeof bytes.write === 'number' &&
    util.isArrayBufferView(bytes.data))) {
    var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
    this.accommodate(src.byteLength);
    var dst = new Uint8Array(bytes.data.byteLength, this.write);
    dst.set(src);
    this.write += src.byteLength;
    return this;
  }

  if(bytes instanceof util.ByteStringBuffer) {
    // copy binary string and process as the same as a string parameter below
    bytes = bytes.data;
    encoding = 'binary';
  }

  // string conversion
  encoding = encoding || 'binary';
  if(typeof bytes === 'string') {
    var view;

    // decode from string
    if(encoding === 'hex') {
      this.accommodate(Math.ceil(bytes.length / 2));
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.hex.decode(bytes, view, this.write);
      return this;
    }
    if(encoding === 'base64') {
      this.accommodate(Math.ceil(bytes.length / 4) * 3);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.base64.decode(bytes, view, this.write);
      return this;
    }

    // encode text as UTF-8 bytes
    if(encoding === 'utf8') {
      // encode as UTF-8 then decode string as raw binary
      bytes = util.encodeUtf8(bytes);
      encoding = 'binary';
    }

    // decode string as raw binary
    if(encoding === 'binary' || encoding === 'raw') {
      // one byte per character
      this.accommodate(bytes.length);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.raw.decode(view);
      return this;
    }

    // encode text as UTF-16 bytes
    if(encoding === 'utf16') {
      // two bytes per character
      this.accommodate(bytes.length * 2);
      view = new Uint16Array(this.data.buffer, this.write);
      this.write += util.text.utf16.encode(view);
      return this;
    }

    throw new Error('Invalid encoding: ' + encoding);
  }

  throw Error('Invalid parameter: ' + bytes);
};

/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putBuffer = function(buffer) {
  this.putBytes(buffer);
  buffer.clear();
  return this;
};

/**
 * Puts a string into this buffer.
 *
 * @param str the string to put.
 * @param [encoding] the encoding for the string (default: 'utf16').
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putString = function(str) {
  return this.putBytes(str, 'utf16');
};

/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putInt16 = function(i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i);
  this.write += 2;
  return this;
};

/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putInt24 = function(i) {
  this.accommodate(3);
  this.data.setInt16(this.write, i >> 8 & 0xFFFF);
  this.data.setInt8(this.write, i >> 16 & 0xFF);
  this.write += 3;
  return this;
};

/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putInt32 = function(i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i);
  this.write += 4;
  return this;
};

/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putInt16Le = function(i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i, true);
  this.write += 2;
  return this;
};

/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putInt24Le = function(i) {
  this.accommodate(3);
  this.data.setInt8(this.write, i >> 16 & 0xFF);
  this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);
  this.write += 3;
  return this;
};

/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putInt32Le = function(i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i, true);
  this.write += 4;
  return this;
};

/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putInt = function(i, n) {
  _checkBitsParam(n);
  this.accommodate(n / 8);
  do {
    n -= 8;
    this.data.setInt8(this.write++, (i >> n) & 0xFF);
  } while(n > 0);
  return this;
};

/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putSignedInt = function(i, n) {
  _checkBitsParam(n);
  this.accommodate(n / 8);
  if(i < 0) {
    i += 2 << (n - 1);
  }
  return this.putInt(i, n);
};

/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */
util.DataBuffer.prototype.getByte = function() {
  return this.data.getInt8(this.read++);
};

/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */
util.DataBuffer.prototype.getInt16 = function() {
  var rval = this.data.getInt16(this.read);
  this.read += 2;
  return rval;
};

/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */
util.DataBuffer.prototype.getInt24 = function() {
  var rval = (
    this.data.getInt16(this.read) << 8 ^
    this.data.getInt8(this.read + 2));
  this.read += 3;
  return rval;
};

/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */
util.DataBuffer.prototype.getInt32 = function() {
  var rval = this.data.getInt32(this.read);
  this.read += 4;
  return rval;
};

/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */
util.DataBuffer.prototype.getInt16Le = function() {
  var rval = this.data.getInt16(this.read, true);
  this.read += 2;
  return rval;
};

/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */
util.DataBuffer.prototype.getInt24Le = function() {
  var rval = (
    this.data.getInt8(this.read) ^
    this.data.getInt16(this.read + 1, true) << 8);
  this.read += 3;
  return rval;
};

/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */
util.DataBuffer.prototype.getInt32Le = function() {
  var rval = this.data.getInt32(this.read, true);
  this.read += 4;
  return rval;
};

/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */
util.DataBuffer.prototype.getInt = function(n) {
  _checkBitsParam(n);
  var rval = 0;
  do {
    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
    rval = (rval << 8) + this.data.getInt8(this.read++);
    n -= 8;
  } while(n > 0);
  return rval;
};

/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */
util.DataBuffer.prototype.getSignedInt = function(n) {
  // getInt checks n
  var x = this.getInt(n);
  var max = 2 << (n - 2);
  if(x >= max) {
    x -= max << 1;
  }
  return x;
};

/**
 * Reads bytes out as a binary encoded string and clears them from the
 * buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a binary encoded string of bytes.
 */
util.DataBuffer.prototype.getBytes = function(count) {
  // TODO: deprecate this method, it is poorly named and
  // this.toString('binary') replaces it
  // add a toTypedArray()/toArrayBuffer() function
  var rval;
  if(count) {
    // read count bytes
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if(count === 0) {
    rval = '';
  } else {
    // read all bytes, optimize to only copy when needed
    rval = (this.read === 0) ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
};

/**
 * Gets a binary encoded string of the bytes from this buffer without
 * modifying the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of binary encoded characters.
 */
util.DataBuffer.prototype.bytes = function(count) {
  // TODO: deprecate this method, it is poorly named, add "getString()"
  return (typeof(count) === 'undefined' ?
    this.data.slice(this.read) :
    this.data.slice(this.read, this.read + count));
};

/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */
util.DataBuffer.prototype.at = function(i) {
  return this.data.getUint8(this.read + i);
};

/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.setAt = function(i, b) {
  this.data.setUint8(i, b);
  return this;
};

/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */
util.DataBuffer.prototype.last = function() {
  return this.data.getUint8(this.write - 1);
};

/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */
util.DataBuffer.prototype.copy = function() {
  return new util.DataBuffer(this);
};

/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.compact = function() {
  if(this.read > 0) {
    var src = new Uint8Array(this.data.buffer, this.read);
    var dst = new Uint8Array(src.byteLength);
    dst.set(src);
    this.data = new DataView(dst);
    this.write -= this.read;
    this.read = 0;
  }
  return this;
};

/**
 * Clears this buffer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.clear = function() {
  this.data = new DataView(new ArrayBuffer(0));
  this.read = this.write = 0;
  return this;
};

/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.truncate = function(count) {
  this.write = Math.max(0, this.length() - count);
  this.read = Math.min(this.read, this.write);
  return this;
};

/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */
util.DataBuffer.prototype.toHex = function() {
  var rval = '';
  for(var i = this.read; i < this.data.byteLength; ++i) {
    var b = this.data.getUint8(i);
    if(b < 16) {
      rval += '0';
    }
    rval += b.toString(16);
  }
  return rval;
};

/**
 * Converts this buffer to a string, using the given encoding. If no
 * encoding is given, 'utf8' (UTF-8) is used.
 *
 * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',
 *          'base64' (default: 'utf8').
 *
 * @return a string representation of the bytes in this buffer.
 */
util.DataBuffer.prototype.toString = function(encoding) {
  var view = new Uint8Array(this.data, this.read, this.length());
  encoding = encoding || 'utf8';

  // encode to string
  if(encoding === 'binary' || encoding === 'raw') {
    return util.binary.raw.encode(view);
  }
  if(encoding === 'hex') {
    return util.binary.hex.encode(view);
  }
  if(encoding === 'base64') {
    return util.binary.base64.encode(view);
  }

  // decode to text
  if(encoding === 'utf8') {
    return util.text.utf8.decode(view);
  }
  if(encoding === 'utf16') {
    return util.text.utf16.decode(view);
  }

  throw new Error('Invalid encoding: ' + encoding);
};

/** End Buffer w/UInt8Array backing */

/**
 * Creates a buffer that stores bytes. A value may be given to populate the
 * buffer with data. This value can either be string of encoded bytes or a
 * regular string of characters. When passing a string of binary encoded
 * bytes, the encoding `raw` should be given. This is also the default. When
 * passing a string of characters, the encoding `utf8` should be given.
 *
 * @param [input] a string with encoded bytes to store in the buffer.
 * @param [encoding] (default: 'raw', other: 'utf8').
 */
util.createBuffer = function(input, encoding) {
  // TODO: deprecate, use new ByteBuffer() instead
  encoding = encoding || 'raw';
  if(input !== undefined && encoding === 'utf8') {
    input = util.encodeUtf8(input);
  }
  return new util.ByteBuffer(input);
};

/**
 * Fills a string with a particular value. If you want the string to be a byte
 * string, pass in String.fromCharCode(theByte).
 *
 * @param c the character to fill the string with, use String.fromCharCode
 *          to fill the string with a byte value.
 * @param n the number of characters of value c to fill with.
 *
 * @return the filled string.
 */
util.fillString = function(c, n) {
  var s = '';
  while(n > 0) {
    if(n & 1) {
      s += c;
    }
    n >>>= 1;
    if(n > 0) {
      c += c;
    }
  }
  return s;
};

/**
 * Performs a per byte XOR between two byte strings and returns the result as a
 * string of bytes.
 *
 * @param s1 first string of bytes.
 * @param s2 second string of bytes.
 * @param n the number of bytes to XOR.
 *
 * @return the XOR'd result.
 */
util.xorBytes = function(s1, s2, n) {
  var s3 = '';
  var b = '';
  var t = '';
  var i = 0;
  var c = 0;
  for(; n > 0; --n, ++i) {
    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
    if(c >= 10) {
      s3 += t;
      t = '';
      c = 0;
    }
    t += String.fromCharCode(b);
    ++c;
  }
  s3 += t;
  return s3;
};

/**
 * Converts a hex string into a 'binary' encoded string of bytes.
 *
 * @param hex the hexadecimal string to convert.
 *
 * @return the binary-encoded string of bytes.
 */
util.hexToBytes = function(hex) {
  // TODO: deprecate: "Deprecated. Use util.binary.hex.decode instead."
  var rval = '';
  var i = 0;
  if(hex.length & 1 == 1) {
    // odd number of characters, convert first character alone
    i = 1;
    rval += String.fromCharCode(parseInt(hex[0], 16));
  }
  // convert 2 characters (1 byte) at a time
  for(; i < hex.length; i += 2) {
    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  }
  return rval;
};

/**
 * Converts a 'binary' encoded string of bytes to hex.
 *
 * @param bytes the byte string to convert.
 *
 * @return the string of hexadecimal characters.
 */
util.bytesToHex = function(bytes) {
  // TODO: deprecate: "Deprecated. Use util.binary.hex.encode instead."
  return util.createBuffer(bytes).toHex();
};

/**
 * Converts an 32-bit integer to 4-big-endian byte string.
 *
 * @param i the integer.
 *
 * @return the byte string.
 */
util.int32ToBytes = function(i) {
  return (
    String.fromCharCode(i >> 24 & 0xFF) +
    String.fromCharCode(i >> 16 & 0xFF) +
    String.fromCharCode(i >> 8 & 0xFF) +
    String.fromCharCode(i & 0xFF));
};

// base64 characters, reverse mapping
var _base64 =
  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var _base64Idx = [
/*43 -43 = 0*/
/*'+',  1,  2,  3,'/' */
   62, -1, -1, -1, 63,

/*'0','1','2','3','4','5','6','7','8','9' */
   52, 53, 54, 55, 56, 57, 58, 59, 60, 61,

/*15, 16, 17,'=', 19, 20, 21 */
  -1, -1, -1, 64, -1, -1, -1,

/*65 - 43 = 22*/
/*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,

/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
   13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,

/*91 - 43 = 48 */
/*48, 49, 50, 51, 52, 53 */
  -1, -1, -1, -1, -1, -1,

/*97 - 43 = 54*/
/*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
   26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,

/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
   39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
];

// base58 characters (Bitcoin alphabet)
var _base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

/**
 * Base64 encodes a 'binary' encoded string of bytes.
 *
 * @param input the binary encoded string of bytes to base64-encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output.
 */
util.encode64 = function(input, maxline) {
  // TODO: deprecate: "Deprecated. Use util.binary.base64.encode instead."
  var line = '';
  var output = '';
  var chr1, chr2, chr3;
  var i = 0;
  while(i < input.length) {
    chr1 = input.charCodeAt(i++);
    chr2 = input.charCodeAt(i++);
    chr3 = input.charCodeAt(i++);

    // encode 4 character group
    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));
    if(isNaN(chr2)) {
      line += '==';
    } else {
      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));
      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
    }

    if(maxline && line.length > maxline) {
      output += line.substr(0, maxline) + '\r\n';
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
};

/**
 * Base64 decodes a string into a 'binary' encoded string of bytes.
 *
 * @param input the base64-encoded input.
 *
 * @return the binary encoded string.
 */
util.decode64 = function(input) {
  // TODO: deprecate: "Deprecated. Use util.binary.base64.decode instead."

  // remove all non-base64 characters
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

  var output = '';
  var enc1, enc2, enc3, enc4;
  var i = 0;

  while(i < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];

    output += String.fromCharCode((enc1 << 2) | (enc2 >> 4));
    if(enc3 !== 64) {
      // decoded at least 2 bytes
      output += String.fromCharCode(((enc2 & 15) << 4) | (enc3 >> 2));
      if(enc4 !== 64) {
        // decoded 3 bytes
        output += String.fromCharCode(((enc3 & 3) << 6) | enc4);
      }
    }
  }

  return output;
};

/**
 * Encodes the given string of characters (a standard JavaScript
 * string) as a binary encoded string where the bytes represent
 * a UTF-8 encoded string of characters. Non-ASCII characters will be
 * encoded as multiple bytes according to UTF-8.
 *
 * @param str a standard string of characters to encode.
 *
 * @return the binary encoded string.
 */
util.encodeUtf8 = function(str) {
  return unescape(encodeURIComponent(str));
};

/**
 * Decodes a binary encoded string that contains bytes that
 * represent a UTF-8 encoded string of characters -- into a
 * string of characters (a standard JavaScript string).
 *
 * @param str the binary encoded string to decode.
 *
 * @return the resulting standard string of characters.
 */
util.decodeUtf8 = function(str) {
  return decodeURIComponent(escape(str));
};

// binary encoding/decoding tools
// FIXME: Experimental. Do not use yet.
util.binary = {
  raw: {},
  hex: {},
  base64: {},
  base58: {},
  baseN : {
    encode: baseN.encode,
    decode: baseN.decode
  }
};

/**
 * Encodes a Uint8Array as a binary-encoded string. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param bytes the Uint8Array to encode.
 *
 * @return the binary-encoded string.
 */
util.binary.raw.encode = function(bytes) {
  return String.fromCharCode.apply(null, bytes);
};

/**
 * Decodes a binary-encoded string to a Uint8Array. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param str the binary-encoded string to decode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */
util.binary.raw.decode = function(str, output, offset) {
  var out = output;
  if(!out) {
    out = new Uint8Array(str.length);
  }
  offset = offset || 0;
  var j = offset;
  for(var i = 0; i < str.length; ++i) {
    out[j++] = str.charCodeAt(i);
  }
  return output ? (j - offset) : out;
};

/**
 * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or
 * ByteBuffer as a string of hexadecimal characters.
 *
 * @param bytes the bytes to convert.
 *
 * @return the string of hexadecimal characters.
 */
util.binary.hex.encode = util.bytesToHex;

/**
 * Decodes a hex-encoded string to a Uint8Array.
 *
 * @param hex the hexadecimal string to convert.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */
util.binary.hex.decode = function(hex, output, offset) {
  var out = output;
  if(!out) {
    out = new Uint8Array(Math.ceil(hex.length / 2));
  }
  offset = offset || 0;
  var i = 0, j = offset;
  if(hex.length & 1) {
    // odd number of characters, convert first character alone
    i = 1;
    out[j++] = parseInt(hex[0], 16);
  }
  // convert 2 characters (1 byte) at a time
  for(; i < hex.length; i += 2) {
    out[j++] = parseInt(hex.substr(i, 2), 16);
  }
  return output ? (j - offset) : out;
};

/**
 * Base64-encodes a Uint8Array.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output string.
 */
util.binary.base64.encode = function(input, maxline) {
  var line = '';
  var output = '';
  var chr1, chr2, chr3;
  var i = 0;
  while(i < input.byteLength) {
    chr1 = input[i++];
    chr2 = input[i++];
    chr3 = input[i++];

    // encode 4 character group
    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));
    if(isNaN(chr2)) {
      line += '==';
    } else {
      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));
      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
    }

    if(maxline && line.length > maxline) {
      output += line.substr(0, maxline) + '\r\n';
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
};

/**
 * Decodes a base64-encoded string to a Uint8Array.
 *
 * @param input the base64-encoded input string.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */
util.binary.base64.decode = function(input, output, offset) {
  var out = output;
  if(!out) {
    out = new Uint8Array(Math.ceil(input.length / 4) * 3);
  }

  // remove all non-base64 characters
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

  offset = offset || 0;
  var enc1, enc2, enc3, enc4;
  var i = 0, j = offset;

  while(i < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];

    out[j++] = (enc1 << 2) | (enc2 >> 4);
    if(enc3 !== 64) {
      // decoded at least 2 bytes
      out[j++] = ((enc2 & 15) << 4) | (enc3 >> 2);
      if(enc4 !== 64) {
        // decoded 3 bytes
        out[j++] = ((enc3 & 3) << 6) | enc4;
      }
    }
  }

  // make sure result is the exact decoded length
  return output ? (j - offset) : out.subarray(0, j);
};

// add support for base58 encoding/decoding with Bitcoin alphabet
util.binary.base58.encode = function(input, maxline) {
  return util.binary.baseN.encode(input, _base58, maxline);
};
util.binary.base58.decode = function(input, maxline) {
  return util.binary.baseN.decode(input, _base58, maxline);
};

// text encoding/decoding tools
// FIXME: Experimental. Do not use yet.
util.text = {
  utf8: {},
  utf16: {}
};

/**
 * Encodes the given string as UTF-8 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */
util.text.utf8.encode = function(str, output, offset) {
  str = util.encodeUtf8(str);
  var out = output;
  if(!out) {
    out = new Uint8Array(str.length);
  }
  offset = offset || 0;
  var j = offset;
  for(var i = 0; i < str.length; ++i) {
    out[j++] = str.charCodeAt(i);
  }
  return output ? (j - offset) : out;
};

/**
 * Decodes the UTF-8 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */
util.text.utf8.decode = function(bytes) {
  return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
};

/**
 * Encodes the given string as UTF-16 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */
util.text.utf16.encode = function(str, output, offset) {
  var out = output;
  if(!out) {
    out = new Uint8Array(str.length * 2);
  }
  var view = new Uint16Array(out.buffer);
  offset = offset || 0;
  var j = offset;
  var k = offset;
  for(var i = 0; i < str.length; ++i) {
    view[k++] = str.charCodeAt(i);
    j += 2;
  }
  return output ? (j - offset) : out;
};

/**
 * Decodes the UTF-16 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */
util.text.utf16.decode = function(bytes) {
  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
};

/**
 * Deflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true to return only raw deflate data, false to include zlib
 *          header and trailer.
 *
 * @return the deflated data as a string.
 */
util.deflate = function(api, bytes, raw) {
  bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);

  // strip zlib header and trailer if necessary
  if(raw) {
    // zlib header is 2 bytes (CMF,FLG) where FLG indicates that
    // there is a 4-byte DICT (alder-32) block before the data if
    // its 5th bit is set
    var start = 2;
    var flg = bytes.charCodeAt(1);
    if(flg & 0x20) {
      start = 6;
    }
    // zlib trailer is 4 bytes of adler-32
    bytes = bytes.substring(start, bytes.length - 4);
  }

  return bytes;
};

/**
 * Inflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true if the incoming data has no zlib header or trailer and is
 *          raw DEFLATE data.
 *
 * @return the inflated data as a string, null on error.
 */
util.inflate = function(api, bytes, raw) {
  // TODO: add zlib header and trailer if necessary/possible
  var rval = api.inflate(util.encode64(bytes)).rval;
  return (rval === null) ? null : util.decode64(rval);
};

/**
 * Sets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param obj the storage object, null to remove.
 */
var _setStorageObject = function(api, id, obj) {
  if(!api) {
    throw new Error('WebStorage not available.');
  }

  var rval;
  if(obj === null) {
    rval = api.removeItem(id);
  } else {
    // json-encode and base64-encode object
    obj = util.encode64(JSON.stringify(obj));
    rval = api.setItem(id, obj);
  }

  // handle potential flash error
  if(typeof(rval) !== 'undefined' && rval.rval !== true) {
    var error = new Error(rval.error.message);
    error.id = rval.error.id;
    error.name = rval.error.name;
    throw error;
  }
};

/**
 * Gets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 *
 * @return the storage object entry or null if none exists.
 */
var _getStorageObject = function(api, id) {
  if(!api) {
    throw new Error('WebStorage not available.');
  }

  // get the existing entry
  var rval = api.getItem(id);

  /* Note: We check api.init because we can't do (api == localStorage)
    on IE because of "Class doesn't support Automation" exception. Only
    the flash api has an init method so this works too, but we need a
    better solution in the future. */

  // flash returns item wrapped in an object, handle special case
  if(api.init) {
    if(rval.rval === null) {
      if(rval.error) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
      // no error, but also no item
      rval = null;
    } else {
      rval = rval.rval;
    }
  }

  // handle decoding
  if(rval !== null) {
    // base64-decode and json-decode data
    rval = JSON.parse(util.decode64(rval));
  }

  return rval;
};

/**
 * Stores an item in local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 */
var _setItem = function(api, id, key, data) {
  // get storage object
  var obj = _getStorageObject(api, id);
  if(obj === null) {
    // create a new storage object
    obj = {};
  }
  // update key
  obj[key] = data;

  // set storage object
  _setStorageObject(api, id, obj);
};

/**
 * Gets an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 *
 * @return the item.
 */
var _getItem = function(api, id, key) {
  // get storage object
  var rval = _getStorageObject(api, id);
  if(rval !== null) {
    // return data at key
    rval = (key in rval) ? rval[key] : null;
  }

  return rval;
};

/**
 * Removes an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 */
var _removeItem = function(api, id, key) {
  // get storage object
  var obj = _getStorageObject(api, id);
  if(obj !== null && key in obj) {
    // remove key
    delete obj[key];

    // see if entry has no keys remaining
    var empty = true;
    for(var prop in obj) {
      empty = false;
      break;
    }
    if(empty) {
      // remove entry entirely if no keys are left
      obj = null;
    }

    // set storage object
    _setStorageObject(api, id, obj);
  }
};

/**
 * Clears the local disk storage identified by the given ID.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 */
var _clearItems = function(api, id) {
  _setStorageObject(api, id, null);
};

/**
 * Calls a storage function.
 *
 * @param func the function to call.
 * @param args the arguments for the function.
 * @param location the location argument.
 *
 * @return the return value from the function.
 */
var _callStorageFunction = function(func, args, location) {
  var rval = null;

  // default storage types
  if(typeof(location) === 'undefined') {
    location = ['web', 'flash'];
  }

  // apply storage types in order of preference
  var type;
  var done = false;
  var exception = null;
  for(var idx in location) {
    type = location[idx];
    try {
      if(type === 'flash' || type === 'both') {
        if(args[0] === null) {
          throw new Error('Flash local storage not available.');
        }
        rval = func.apply(this, args);
        done = (type === 'flash');
      }
      if(type === 'web' || type === 'both') {
        args[0] = localStorage;
        rval = func.apply(this, args);
        done = true;
      }
    } catch(ex) {
      exception = ex;
    }
    if(done) {
      break;
    }
  }

  if(!done) {
    throw exception;
  }

  return rval;
};

/**
 * Stores an item on local disk.
 *
 * The available types of local storage include 'flash', 'web', and 'both'.
 *
 * The type 'flash' refers to flash local storage (SharedObject). In order
 * to use flash local storage, the 'api' parameter must be valid. The type
 * 'web' refers to WebStorage, if supported by the browser. The type 'both'
 * refers to storing using both 'flash' and 'web', not just one or the
 * other.
 *
 * The location array should list the storage types to use in order of
 * preference:
 *
 * ['flash']: flash only storage
 * ['web']: web only storage
 * ['both']: try to store in both
 * ['flash','web']: store in flash first, but if not available, 'web'
 * ['web','flash']: store in web first, but if not available, 'flash'
 *
 * The location array defaults to: ['web', 'flash']
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 * @param location an array with the preferred types of storage to use.
 */
util.setItem = function(api, id, key, data, location) {
  _callStorageFunction(_setItem, arguments, location);
};

/**
 * Gets an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 *
 * @return the item.
 */
util.getItem = function(api, id, key, location) {
  return _callStorageFunction(_getItem, arguments, location);
};

/**
 * Removes an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 */
util.removeItem = function(api, id, key, location) {
  _callStorageFunction(_removeItem, arguments, location);
};

/**
 * Clears the local disk storage identified by the given ID.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface if flash is available.
 * @param id the storage ID to use.
 * @param location an array with the preferred types of storage to use.
 */
util.clearItems = function(api, id, location) {
  _callStorageFunction(_clearItems, arguments, location);
};

/**
 * Parses the scheme, host, and port from an http(s) url.
 *
 * @param str the url string.
 *
 * @return the parsed url object or null if the url is invalid.
 */
util.parseUrl = function(str) {
  // FIXME: this regex looks a bit broken
  var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
  regex.lastIndex = 0;
  var m = regex.exec(str);
  var url = (m === null) ? null : {
    full: str,
    scheme: m[1],
    host: m[2],
    port: m[3],
    path: m[4]
  };
  if(url) {
    url.fullHost = url.host;
    if(url.port) {
      if(url.port !== 80 && url.scheme === 'http') {
        url.fullHost += ':' + url.port;
      } else if(url.port !== 443 && url.scheme === 'https') {
        url.fullHost += ':' + url.port;
      }
    } else if(url.scheme === 'http') {
      url.port = 80;
    } else if(url.scheme === 'https') {
      url.port = 443;
    }
    url.full = url.scheme + '://' + url.fullHost;
  }
  return url;
};

/* Storage for query variables */
var _queryVariables = null;

/**
 * Returns the window location query variables. Query is parsed on the first
 * call and the same object is returned on subsequent calls. The mapping
 * is from keys to an array of values. Parameters without values will have
 * an object key set but no value added to the value array. Values are
 * unescaped.
 *
 * ...?k1=v1&k2=v2:
 * {
 *   "k1": ["v1"],
 *   "k2": ["v2"]
 * }
 *
 * ...?k1=v1&k1=v2:
 * {
 *   "k1": ["v1", "v2"]
 * }
 *
 * ...?k1=v1&k2:
 * {
 *   "k1": ["v1"],
 *   "k2": []
 * }
 *
 * ...?k1=v1&k1:
 * {
 *   "k1": ["v1"]
 * }
 *
 * ...?k1&k1:
 * {
 *   "k1": []
 * }
 *
 * @param query the query string to parse (optional, default to cached
 *          results from parsing window location search query).
 *
 * @return object mapping keys to variables.
 */
util.getQueryVariables = function(query) {
  var parse = function(q) {
    var rval = {};
    var kvpairs = q.split('&');
    for(var i = 0; i < kvpairs.length; i++) {
      var pos = kvpairs[i].indexOf('=');
      var key;
      var val;
      if(pos > 0) {
        key = kvpairs[i].substring(0, pos);
        val = kvpairs[i].substring(pos + 1);
      } else {
        key = kvpairs[i];
        val = null;
      }
      if(!(key in rval)) {
        rval[key] = [];
      }
      // disallow overriding object prototype keys
      if(!(key in Object.prototype) && val !== null) {
        rval[key].push(unescape(val));
      }
    }
    return rval;
  };

   var rval;
   if(typeof(query) === 'undefined') {
     // set cached variables if needed
     if(_queryVariables === null) {
       if(typeof(window) !== 'undefined' && window.location && window.location.search) {
          // parse window search query
          _queryVariables = parse(window.location.search.substring(1));
       } else {
          // no query variables available
          _queryVariables = {};
       }
     }
     rval = _queryVariables;
   } else {
     // parse given query
     rval = parse(query);
   }
   return rval;
};

/**
 * Parses a fragment into a path and query. This method will take a URI
 * fragment and break it up as if it were the main URI. For example:
 *    /bar/baz?a=1&b=2
 * results in:
 *    {
 *       path: ["bar", "baz"],
 *       query: {"k1": ["v1"], "k2": ["v2"]}
 *    }
 *
 * @return object with a path array and query object.
 */
util.parseFragment = function(fragment) {
  // default to whole fragment
  var fp = fragment;
  var fq = '';
  // split into path and query if possible at the first '?'
  var pos = fragment.indexOf('?');
  if(pos > 0) {
    fp = fragment.substring(0, pos);
    fq = fragment.substring(pos + 1);
  }
  // split path based on '/' and ignore first element if empty
  var path = fp.split('/');
  if(path.length > 0 && path[0] === '') {
    path.shift();
  }
  // convert query into object
  var query = (fq === '') ? {} : util.getQueryVariables(fq);

  return {
    pathString: fp,
    queryString: fq,
    path: path,
    query: query
  };
};

/**
 * Makes a request out of a URI-like request string. This is intended to
 * be used where a fragment id (after a URI '#') is parsed as a URI with
 * path and query parts. The string should have a path beginning and
 * delimited by '/' and optional query parameters following a '?'. The
 * query should be a standard URL set of key value pairs delimited by
 * '&'. For backwards compatibility the initial '/' on the path is not
 * required. The request object has the following API, (fully described
 * in the method code):
 *    {
 *       path: <the path string part>.
 *       query: <the query string part>,
 *       getPath(i): get part or all of the split path array,
 *       getQuery(k, i): get part or all of a query key array,
 *       getQueryLast(k, _default): get last element of a query key array.
 *    }
 *
 * @return object with request parameters.
 */
util.makeRequest = function(reqString) {
  var frag = util.parseFragment(reqString);
  var req = {
    // full path string
    path: frag.pathString,
    // full query string
    query: frag.queryString,
    /**
     * Get path or element in path.
     *
     * @param i optional path index.
     *
     * @return path or part of path if i provided.
     */
    getPath: function(i) {
      return (typeof(i) === 'undefined') ? frag.path : frag.path[i];
    },
    /**
     * Get query, values for a key, or value for a key index.
     *
     * @param k optional query key.
     * @param i optional query key index.
     *
     * @return query, values for a key, or value for a key index.
     */
    getQuery: function(k, i) {
      var rval;
      if(typeof(k) === 'undefined') {
        rval = frag.query;
      } else {
        rval = frag.query[k];
        if(rval && typeof(i) !== 'undefined') {
           rval = rval[i];
        }
      }
      return rval;
    },
    getQueryLast: function(k, _default) {
      var rval;
      var vals = req.getQuery(k);
      if(vals) {
        rval = vals[vals.length - 1];
      } else {
        rval = _default;
      }
      return rval;
    }
  };
  return req;
};

/**
 * Makes a URI out of a path, an object with query parameters, and a
 * fragment. Uses jQuery.param() internally for query string creation.
 * If the path is an array, it will be joined with '/'.
 *
 * @param path string path or array of strings.
 * @param query object with query parameters. (optional)
 * @param fragment fragment string. (optional)
 *
 * @return string object with request parameters.
 */
util.makeLink = function(path, query, fragment) {
  // join path parts if needed
  path = jQuery.isArray(path) ? path.join('/') : path;

  var qstr = jQuery.param(query || {});
  fragment = fragment || '';
  return path +
    ((qstr.length > 0) ? ('?' + qstr) : '') +
    ((fragment.length > 0) ? ('#' + fragment) : '');
};

/**
 * Check if an object is empty.
 *
 * Taken from:
 * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937
 *
 * @param object the object to check.
 */
util.isEmpty = function(obj) {
  for(var prop in obj) {
    if(obj.hasOwnProperty(prop)) {
      return false;
    }
  }
  return true;
};

/**
 * Format with simple printf-style interpolation.
 *
 * %%: literal '%'
 * %s,%o: convert next argument into a string.
 *
 * @param format the string to format.
 * @param ... arguments to interpolate into the format string.
 */
util.format = function(format) {
  var re = /%./g;
  // current match
  var match;
  // current part
  var part;
  // current arg index
  var argi = 0;
  // collected parts to recombine later
  var parts = [];
  // last index found
  var last = 0;
  // loop while matches remain
  while((match = re.exec(format))) {
    part = format.substring(last, re.lastIndex - 2);
    // don't add empty strings (ie, parts between %s%s)
    if(part.length > 0) {
      parts.push(part);
    }
    last = re.lastIndex;
    // switch on % code
    var code = match[0][1];
    switch(code) {
    case 's':
    case 'o':
      // check if enough arguments were given
      if(argi < arguments.length) {
        parts.push(arguments[argi++ + 1]);
      } else {
        parts.push('<?>');
      }
      break;
    // FIXME: do proper formating for numbers, etc
    //case 'f':
    //case 'd':
    case '%':
      parts.push('%');
      break;
    default:
      parts.push('<%' + code + '?>');
    }
  }
  // add trailing part of format string
  parts.push(format.substring(last));
  return parts.join('');
};

/**
 * Formats a number.
 *
 * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/
 */
util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
  // http://kevin.vanzonneveld.net
  // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +     bugfix by: Michael White (http://crestidg.com)
  // +     bugfix by: Benjamin Lupton
  // +     bugfix by: Allan Jensen (http://www.winternet.no)
  // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  // *     example 1: number_format(1234.5678, 2, '.', '');
  // *     returns 1: 1234.57

  var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
  var d = dec_point === undefined ? ',' : dec_point;
  var t = thousands_sep === undefined ?
   '.' : thousands_sep, s = n < 0 ? '-' : '';
  var i = parseInt((n = Math.abs(+n || 0).toFixed(c)), 10) + '';
  var j = (i.length > 3) ? i.length % 3 : 0;
  return s + (j ? i.substr(0, j) + t : '') +
    i.substr(j).replace(/(\d{3})(?=\d)/g, '$1' + t) +
    (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');
};

/**
 * Formats a byte size.
 *
 * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/
 */
util.formatSize = function(size) {
  if(size >= 1073741824) {
    size = util.formatNumber(size / 1073741824, 2, '.', '') + ' GiB';
  } else if(size >= 1048576) {
    size = util.formatNumber(size / 1048576, 2, '.', '') + ' MiB';
  } else if(size >= 1024) {
    size = util.formatNumber(size / 1024, 0) + ' KiB';
  } else {
    size = util.formatNumber(size, 0) + ' bytes';
  }
  return size;
};

/**
 * Converts an IPv4 or IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv4 or IPv6 address to convert.
 *
 * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't
 *         be parsed.
 */
util.bytesFromIP = function(ip) {
  if(ip.indexOf('.') !== -1) {
    return util.bytesFromIPv4(ip);
  }
  if(ip.indexOf(':') !== -1) {
    return util.bytesFromIPv6(ip);
  }
  return null;
};

/**
 * Converts an IPv4 string representation into bytes (in network order).
 *
 * @param ip the IPv4 address to convert.
 *
 * @return the 4-byte address or null if the address can't be parsed.
 */
util.bytesFromIPv4 = function(ip) {
  ip = ip.split('.');
  if(ip.length !== 4) {
    return null;
  }
  var b = util.createBuffer();
  for(var i = 0; i < ip.length; ++i) {
    var num = parseInt(ip[i], 10);
    if(isNaN(num)) {
      return null;
    }
    b.putByte(num);
  }
  return b.getBytes();
};

/**
 * Converts an IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv6 address to convert.
 *
 * @return the 16-byte address or null if the address can't be parsed.
 */
util.bytesFromIPv6 = function(ip) {
  var blanks = 0;
  ip = ip.split(':').filter(function(e) {
    if(e.length === 0) ++blanks;
    return true;
  });
  var zeros = (8 - ip.length + blanks) * 2;
  var b = util.createBuffer();
  for(var i = 0; i < 8; ++i) {
    if(!ip[i] || ip[i].length === 0) {
      b.fillWithByte(0, zeros);
      zeros = 0;
      continue;
    }
    var bytes = util.hexToBytes(ip[i]);
    if(bytes.length < 2) {
      b.putByte(0);
    }
    b.putBytes(bytes);
  }
  return b.getBytes();
};

/**
 * Converts 4-bytes into an IPv4 string representation or 16-bytes into
 * an IPv6 string representation. The bytes must be in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,
 *         respectively, are given, otherwise null.
 */
util.bytesToIP = function(bytes) {
  if(bytes.length === 4) {
    return util.bytesToIPv4(bytes);
  }
  if(bytes.length === 16) {
    return util.bytesToIPv6(bytes);
  }
  return null;
};

/**
 * Converts 4-bytes into an IPv4 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 string representation or null for an invalid # of bytes.
 */
util.bytesToIPv4 = function(bytes) {
  if(bytes.length !== 4) {
    return null;
  }
  var ip = [];
  for(var i = 0; i < bytes.length; ++i) {
    ip.push(bytes.charCodeAt(i));
  }
  return ip.join('.');
};

/**
 * Converts 16-bytes into an IPv16 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv16 string representation or null for an invalid # of bytes.
 */
util.bytesToIPv6 = function(bytes) {
  if(bytes.length !== 16) {
    return null;
  }
  var ip = [];
  var zeroGroups = [];
  var zeroMaxGroup = 0;
  for(var i = 0; i < bytes.length; i += 2) {
    var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);
    // canonicalize zero representation
    while(hex[0] === '0' && hex !== '0') {
      hex = hex.substr(1);
    }
    if(hex === '0') {
      var last = zeroGroups[zeroGroups.length - 1];
      var idx = ip.length;
      if(!last || idx !== last.end + 1) {
        zeroGroups.push({start: idx, end: idx});
      } else {
        last.end = idx;
        if((last.end - last.start) >
          (zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start)) {
          zeroMaxGroup = zeroGroups.length - 1;
        }
      }
    }
    ip.push(hex);
  }
  if(zeroGroups.length > 0) {
    var group = zeroGroups[zeroMaxGroup];
    // only shorten group of length > 0
    if(group.end - group.start > 0) {
      ip.splice(group.start, group.end - group.start + 1, '');
      if(group.start === 0) {
        ip.unshift('');
      }
      if(group.end === 7) {
        ip.push('');
      }
    }
  }
  return ip.join(':');
};

/**
 * Estimates the number of processes that can be run concurrently. If
 * creating Web Workers, keep in mind that the main JavaScript process needs
 * its own core.
 *
 * @param options the options to use:
 *          update true to force an update (not use the cached value).
 * @param callback(err, max) called once the operation completes.
 */
util.estimateCores = function(options, callback) {
  if(typeof options === 'function') {
    callback = options;
    options = {};
  }
  options = options || {};
  if('cores' in util && !options.update) {
    return callback(null, util.cores);
  }
  if(typeof navigator !== 'undefined' &&
    'hardwareConcurrency' in navigator &&
    navigator.hardwareConcurrency > 0) {
    util.cores = navigator.hardwareConcurrency;
    return callback(null, util.cores);
  }
  if(typeof Worker === 'undefined') {
    // workers not available
    util.cores = 1;
    return callback(null, util.cores);
  }
  if(typeof Blob === 'undefined') {
    // can't estimate, default to 2
    util.cores = 2;
    return callback(null, util.cores);
  }

  // create worker concurrency estimation code as blob
  var blobUrl = URL.createObjectURL(new Blob(['(',
    function() {
      self.addEventListener('message', function(e) {
        // run worker for 4 ms
        var st = Date.now();
        var et = st + 4;
        while(Date.now() < et);
        self.postMessage({st: st, et: et});
      });
    }.toString(),
  ')()'], {type: 'application/javascript'}));

  // take 5 samples using 16 workers
  sample([], 5, 16);

  function sample(max, samples, numWorkers) {
    if(samples === 0) {
      // get overlap average
      var avg = Math.floor(max.reduce(function(avg, x) {
        return avg + x;
      }, 0) / max.length);
      util.cores = Math.max(1, avg);
      URL.revokeObjectURL(blobUrl);
      return callback(null, util.cores);
    }
    map(numWorkers, function(err, results) {
      max.push(reduce(numWorkers, results));
      sample(max, samples - 1, numWorkers);
    });
  }

  function map(numWorkers, callback) {
    var workers = [];
    var results = [];
    for(var i = 0; i < numWorkers; ++i) {
      var worker = new Worker(blobUrl);
      worker.addEventListener('message', function(e) {
        results.push(e.data);
        if(results.length === numWorkers) {
          for(var i = 0; i < numWorkers; ++i) {
            workers[i].terminate();
          }
          callback(null, results);
        }
      });
      workers.push(worker);
    }
    for(var i = 0; i < numWorkers; ++i) {
      workers[i].postMessage(i);
    }
  }

  function reduce(numWorkers, results) {
    // find overlapping time windows
    var overlaps = [];
    for(var n = 0; n < numWorkers; ++n) {
      var r1 = results[n];
      var overlap = overlaps[n] = [];
      for(var i = 0; i < numWorkers; ++i) {
        if(n === i) {
          continue;
        }
        var r2 = results[i];
        if((r1.st > r2.st && r1.st < r2.et) ||
          (r2.st > r1.st && r2.st < r1.et)) {
          overlap.push(i);
        }
      }
    }
    // get maximum overlaps ... don't include overlapping worker itself
    // as the main JS process was also being scheduled during the work and
    // would have to be subtracted from the estimate anyway
    return overlaps.reduce(function(max, overlap) {
      return Math.max(max, overlap.length);
    }, 0);
  }
};

}).call(this)}).call(this,require('_process'),require("buffer").Buffer,require("timers").setImmediate)

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/package.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/package.json
      return function (require, module, exports) {
module.exports={
  "name": "ipfs",
  "version": "0.36.4",
  "description": "JavaScript implementation of the IPFS specification",
  "keywords": [
    "IPFS"
  ],
  "homepage": "https://js.ipfs.io",
  "bugs": "https://github.com/ipfs/js-ipfs/issues",
  "license": "MIT",
  "leadMaintainer": "Alan Shaw <alan@tableflip.io>",
  "files": [
    "src",
    "dist"
  ],
  "main": "src/core/index.js",
  "browser": {
    "./src/core/components/init-assets.js": false,
    "./src/core/runtime/add-from-fs-nodejs.js": "./src/core/runtime/add-from-fs-browser.js",
    "./src/core/runtime/config-nodejs.js": "./src/core/runtime/config-browser.js",
    "./src/core/runtime/dns-nodejs.js": "./src/core/runtime/dns-browser.js",
    "./src/core/runtime/fetch-nodejs.js": "./src/core/runtime/fetch-browser.js",
    "./src/core/runtime/libp2p-nodejs.js": "./src/core/runtime/libp2p-browser.js",
    "./src/core/runtime/preload-nodejs.js": "./src/core/runtime/preload-browser.js",
    "./src/core/runtime/repo-nodejs.js": "./src/core/runtime/repo-browser.js",
    "./src/core/runtime/ipld-nodejs.js": "./src/core/runtime/ipld-browser.js",
    "./test/utils/create-repo-nodejs.js": "./test/utils/create-repo-browser.js",
    "stream": "readable-stream"
  },
  "browser-all-ipld-formats": {
    "./src/core/runtime/ipld-browser.js": "./src/core/runtime/ipld-browser-all.js"
  },
  "bin": {
    "jsipfs": "src/cli/bin.js"
  },
  "repository": "github:ipfs/js-ipfs",
  "scripts": {
    "lint": "aegir lint",
    "build": "aegir build",
    "test": "aegir test",
    "test:node": "aegir test -t node",
    "test:browser": "aegir test -t browser",
    "test:webworker": "aegir test -t webworker",
    "test:node:core": "aegir test -t node -f test/core/**/*.js",
    "test:node:http": "aegir test -t node -f test/http-api/index.js",
    "test:node:gateway": "aegir test -t node -f test/gateway/index.js",
    "test:node:cli": "aegir test -t node -f test/cli/index.js",
    "test:node:interface": "aegir test -t node -f test/core/interface.spec.js",
    "test:bootstrapers": "IPFS_TEST=bootstrapers aegir test -t browser -f test/bootstrapers.js",
    "benchmark": "echo \"Error: no benchmarks yet\" && exit 1",
    "benchmark:node": "echo \"Error: no benchmarks yet\" && exit 1",
    "benchmark:node:core": "echo \"Error: no benchmarks yet\" && exit 1",
    "benchmark:node:http": "echo \"Error: no benchmarks yet\" && exit 1",
    "benchmark:browser": "echo \"Error: no benchmarks yet\" && exit 1",
    "release": "aegir release -t node -t browser",
    "release-minor": "aegir release --type minor -t node -t browser",
    "release-major": "aegir release --type major -t node -t browser"
  },
  "dependencies": {
    "@hapi/ammo": "^3.1.0",
    "@hapi/hapi": "^18.3.1",
    "@hapi/joi": "^15.0.1",
    "async": "^2.6.1",
    "async-iterator-all": "^1.0.0",
    "async-iterator-to-pull-stream": "^1.1.0",
    "async-iterator-to-stream": "^1.1.0",
    "base32.js": "~0.1.0",
    "bignumber.js": "^9.0.0",
    "binary-querystring": "~0.1.2",
    "bl": "^3.0.0",
    "boom": "^7.2.0",
    "bs58": "^4.0.1",
    "buffer-peek-stream": "^1.0.1",
    "byteman": "^1.3.5",
    "callbackify": "^1.1.0",
    "cid-tool": "~0.3.0",
    "cids": "~0.7.1",
    "class-is": "^1.1.0",
    "datastore-core": "~0.6.0",
    "datastore-pubsub": "~0.1.1",
    "debug": "^4.1.0",
    "dlv": "^1.1.3",
    "err-code": "^1.1.2",
    "file-type": "^11.1.0",
    "fnv1a": "^1.0.1",
    "fsm-event": "^2.1.0",
    "get-folder-size": "^2.0.0",
    "glob": "^7.1.3",
    "hapi-pino": "^6.0.0",
    "human-to-milliseconds": "^1.0.0",
    "interface-datastore": "~0.6.0",
    "ipfs-bitswap": "~0.24.1",
    "ipfs-block": "~0.8.1",
    "ipfs-block-service": "~0.15.1",
    "ipfs-http-client": "^32.0.0",
    "ipfs-http-response": "~0.3.0",
    "ipfs-mfs": "~0.11.4",
    "ipfs-multipart": "~0.1.0",
    "ipfs-repo": "~0.26.6",
    "ipfs-unixfs": "~0.1.16",
    "ipfs-unixfs-exporter": "~0.37.6",
    "ipfs-unixfs-importer": "~0.39.9",
    "ipfs-utils": "~0.0.3",
    "ipld": "~0.24.1",
    "ipld-bitcoin": "~0.3.0",
    "ipld-dag-cbor": "~0.15.0",
    "ipld-dag-pb": "~0.17.4",
    "ipld-ethereum": "^4.0.0",
    "ipld-git": "~0.5.0",
    "ipld-raw": "^4.0.0",
    "ipld-zcash": "~0.3.0",
    "ipns": "~0.5.2",
    "is-ipfs": "~0.6.1",
    "is-pull-stream": "~0.0.0",
    "is-stream": "^2.0.0",
    "iso-url": "~0.4.6",
    "just-flatten-it": "^2.1.0",
    "just-safe-set": "^2.1.0",
    "kind-of": "^6.0.2",
    "libp2p": "~0.25.3",
    "libp2p-bootstrap": "~0.9.3",
    "libp2p-crypto": "~0.16.0",
    "libp2p-kad-dht": "~0.15.1",
    "libp2p-keychain": "~0.4.1",
    "libp2p-mdns": "~0.12.0",
    "libp2p-record": "~0.6.3",
    "libp2p-secio": "~0.11.0",
    "libp2p-tcp": "~0.13.0",
    "libp2p-webrtc-star": "~0.16.0",
    "libp2p-websocket-star-multi": "~0.4.3",
    "libp2p-websockets": "~0.12.2",
    "lodash": "^4.17.11",
    "mafmt": "^6.0.2",
    "merge-options": "^1.0.1",
    "mime-types": "^2.1.21",
    "mkdirp": "~0.5.1",
    "multiaddr": "^6.0.5",
    "multiaddr-to-uri": "^4.0.1",
    "multibase": "~0.6.0",
    "multicodec": "~0.5.1",
    "multihashes": "~0.4.14",
    "multihashing-async": "~0.6.0",
    "node-fetch": "^2.3.0",
    "peer-book": "~0.9.0",
    "peer-id": "~0.12.0",
    "peer-info": "~0.15.0",
    "progress": "^2.0.1",
    "promisify-es6": "^1.0.3",
    "protons": "^1.0.1",
    "pull-abortable": "^4.1.1",
    "pull-cat": "^1.1.11",
    "pull-defer": "~0.2.3",
    "pull-file": "^1.1.0",
    "pull-mplex": "~0.1.1",
    "pull-ndjson": "~0.1.1",
    "pull-pushable": "^2.2.0",
    "pull-sort": "^1.0.1",
    "pull-stream": "^3.6.9",
    "pull-stream-to-async-iterator": "^1.0.1",
    "pull-stream-to-stream": "^1.3.4",
    "pull-traverse": "^1.0.3",
    "readable-stream": "^3.4.0",
    "receptacle": "^1.3.2",
    "semver": "^6.1.1",
    "stream-to-pull-stream": "^1.7.3",
    "superstruct": "~0.6.0",
    "tar-stream": "^2.0.0",
    "temp": "~0.9.0",
    "update-notifier": "^3.0.0",
    "uri-to-multiaddr": "^3.0.1",
    "varint": "^5.0.0",
    "yargs": "^13.2.4",
    "yargs-promise": "^1.1.0"
  },
  "devDependencies": {
    "aegir": "^19.0.3",
    "base64url": "^3.0.1",
    "chai": "^4.2.0",
    "delay": "^4.1.0",
    "detect-node": "^2.0.4",
    "dir-compare": "^1.4.0",
    "dirty-chai": "^2.0.1",
    "execa": "^1.0.0",
    "form-data": "^2.3.3",
    "hat": "0.0.3",
    "interface-ipfs-core": "~0.104.0",
    "ipfsd-ctl": "~0.42.0",
    "libp2p-websocket-star": "~0.10.2",
    "ncp": "^2.0.0",
    "qs": "^6.5.2",
    "rimraf": "^2.6.2",
    "sinon": "^7.3.1",
    "stream-to-promise": "^2.2.0"
  },
  "optionalDependencies": {
    "prom-client": "^11.1.3",
    "prometheus-gc-stats": "~0.6.0"
  },
  "engines": {
    "node": ">=10.0.0",
    "npm": ">=6.0.0"
  },
  "contributors": [
    "0xflotus <0xflotus@gmail.com>",
    "A_A <21040751+Otto-AA@users.noreply.github.com>",
    "Alan Shaw <alan.shaw@protocol.ai>",
    "Alan Shaw <alan@tableflip.io>",
    "Alex North <alex@alexnorth.me>",
    "Alex Potsides <alex@achingbrain.net>",
    "Andrew Nesbitt <andrewnez@gmail.com>",
    "Andrew de Andrade <andrew@deandrade.com.br>",
    "Andr Cruz <andremiguelcruz@msn.com>",
    "Arkadiy Kukarkin <parkan@users.noreply.github.com>",
    "Arpit Agarwal <93arpit@gmail.com>",
    "Arpit Agarwal <atvanguard@users.noreply.github.com>",
    "Bernard Mordan <bernard@tableflip.io>",
    "Brian Vander Schaaf <bvs330@gmail.com>",
    "Bruno Zell <bruno.zzell@gmail.com>",
    "CHEVALAY JOSSELIN <josselin54.chevalay@gmail.com>",
    "Caio Gondim <me@caiogondim.com>",
    "Chance Hudson <jchancehud@gmail.com>",
    "Chirag Shinde <chirag-shinde@users.noreply.github.com>",
    "Christian Couder <chriscool@tuxfamily.org>",
    "Dafeng <dfguo.joe@gmail.com>",
    "Dan Ordille <dordille@gmail.com>",
    "Daniel J. O'Quinn <danieljoquinn@gmail.com>",
    "Daniela Borges Matos de Carvalho <alunassertiva@gmail.com>",
    "David Dias <daviddias.p@gmail.com>",
    "David Gilbertson <gilbertson.david@gmail.com>",
    "David da Silva <dasilvacontin@gmail.com>",
    "Diogo Silva <fsdiogo@gmail.com>",
    "Dmitriy Ryajov <dryajov@gmail.com>",
    "Dzmitry Das <dbachko@gmail.com>",
    "Enrico Marino <enrico.marino@email.com>",
    "Faheel Ahmad <faheel@live.in>",
    "Felix Yan <felixonmars@archlinux.org>",
    "Francisco Baio Dias <xicombd@gmail.com>",
    "Francisco Baio Dias <francisco@typeform.com>",
    "Friedel Ziegelmayer <dignifiedquire@gmail.com>",
    "Gar <gar+gh@danger.computer>",
    "Georgios Rassias <georassias@gmail.com>",
    "Gorka Ludlow <gorka@aquigorka.com>",
    "Grant Herman <grantlouisherman041@gmail.com>",
    "Greenkeeper <support@greenkeeper.io>",
    "Haad <haadcode@users.noreply.github.com>",
    "Haoliang Yu <haoliangyu@users.noreply.github.com>",
    "Harsh Vakharia <harshjv@users.noreply.github.com>",
    "Henrique Dias <hacdias@gmail.com>",
    "Henry Rodrick <moshisushi@gmail.com>",
    "Heo Sangmin <heo@mapiacompany.com>",
    "Hugo Dias <mail@hugodias.me>",
    "Hugo Dias <hugomrdias@gmail.com>",
    "Irakli Gozalishvili <contact@gozala.io>",
    "Jacob Heun <jacobheun@gmail.com>",
    "Jacob Heun <jake@andyet.net>",
    "Jade Meskill <jade.meskill@gmail.com>",
    "Johannes Wikner <johannes.wikner@gmail.com>",
    "Jon Schlinkert <dev@sellside.com>",
    "Jonathan <jkrone@vt.edu>",
    "Jonybang <Jonybange@gmail.com>",
    "Joo Antunes <j.goncalo.antunes@gmail.com>",
    "Joo Santos <joaosantos15@users.noreply.github.com>",
    "Kevin Wang <kevin@fossa.io>",
    "Lars Gierth <larsg@systemli.org>",
    "Lukas Drgon <lukas.drgon@gmail.com>",
    "Maciej Krger <mkg20001@gmail.com>",
    "Marcin Rataj <lidel@lidel.org>",
    "Marius Darila <marius.darila@gmail.com>",
    "Mat Kelly <machawk1@gmail.com>",
    "Michelle Lee <michelle@protocol.ai>",
    "Mikeal Rogers <mikeal.rogers@gmail.com>",
    "Mithgol <getgit@mithgol.ru>",
    "Molly <momack2@users.noreply.github.com>",
    "Mounish Sai <pvsmounish@gmail.com>",
    "My9Bot <34904312+My9Bot@users.noreply.github.com>",
    "Nitin Patel <31539366+niinpatel@users.noreply.github.com>",
    "Nuno Nogueira <nunofmn@gmail.com>",
    "Oli Evans <oli@tableflip.io>",
    "Oskar Nyberg <oskar@oskarnyberg.com>",
    "Pascal Precht <pascal.precht@googlemail.com>",
    "Pau Ramon Revilla <masylum@gmail.com>",
    "Paulo Rodrigues <me@paulogr.com>",
    "Pedro Teixeira <i@pgte.me>",
    "Portia Burton <plburton@gmail.com>",
    "Prabhakar Poudel <yuvrajzohan@gmail.com>",
    "Raoul Millais <raoul@raoulmillais.com>",
    "RasmusErik Voel Jensen <github@solsort.com>",
    "Richard Littauer <richard.littauer@gmail.com>",
    "Richard Schneider <makaretu@gmail.com>",
    "Rob Brackett <rob@robbrackett.com>",
    "Rod Keys <rod@zokos.com>",
    "Sangwon Hong <qpakzk@gmail.com>",
    "Sid Harder <sideharder@gmail.com>",
    "SidHarder <softwarenavigator@gmail.com>",
    "Stephen Whitmore <stephen.whitmore@gmail.com>",
    "Stephen Whitmore <noffle@users.noreply.github.com>",
    "Steven Allen <steven@stebalien.com>",
    "Terence Pae <terencepae@gmail.com>",
    "Uro Jurgli <jurglic@gmail.com>",
    "Vasco Santos <vasco.santos@moxy.studio>",
    "Vasco Santos <vasco.santos@ua.pt>",
    "Volker Mische <volker.mische@gmail.com>",
    "Xiao Liang <yxliang01@users.noreply.github.com>",
    "Yahya <ya7yaz@gmail.com>",
    "Yole <yole@ultiledger.io>",
    "bitspill <bitspill+github@bitspill.net>",
    "datafatmunger <jbg@peerparty.org>",
    "dirkmc <dirkmdev@gmail.com>",
    "dirkmc <dirk@mccormick.cx>",
    "greenkeeper[bot] <greenkeeper[bot]@users.noreply.github.com>",
    "haad <haad@headbanggames.com>",
    "jbenet <juan@benet.ai>",
    "jonahweissman <19804455+jonahweissman@users.noreply.github.com>",
    "kevingzhang <kevin.zhang.canada@gmail.com>",
    "kumavis <kumavis@users.noreply.github.com>",
    "nginnever <ginneversource@gmail.com>",
    "npmcdn-to-unpkg-bot <npmcdn-to-unpkg-bot@users.noreply.github.com>",
    "robbsolter <35879806+robbsolter@users.noreply.github.com>",
    "seungwon-kang <ksw3894@gmail.com>",
    "tcme <hi@this-connect.me>",
    "victorbjelkholm <victorbjelkholm@gmail.com>",
    "ukasz Magiera <magik6k@users.noreply.github.com>",
    "  <negamaxi@gmail.com>"
  ]
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/package.json",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/dns-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/dns-browser.js
      return function (require, module, exports) {
/* global self */
'use strict'

module.exports = (domain, opts, callback) => {
  if (typeof opts === 'function') {
    callback = opts
    opts = {}
  }

  opts = opts || {}

  domain = encodeURIComponent(domain)
  let url = `https://ipfs.io/api/v0/dns?arg=${domain}`

  Object.keys(opts).forEach(prop => {
    url += `&${encodeURIComponent(prop)}=${encodeURIComponent(opts[prop])}`
  })

  self.fetch(url, { mode: 'cors' })
    .then((response) => {
      return response.json()
    })
    .then((response) => {
      if (response.Path) {
        return callback(null, response.Path)
      } else {
        return callback(new Error(response.Message))
      }
    })
    .catch((error) => {
      callback(error)
    })
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/dns-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/config-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/config-browser.js
      return function (require, module, exports) {
'use strict'

module.exports = () => ({
  Addresses: {
    Swarm: [
    ],
    API: '',
    Gateway: ''
  },
  Discovery: {
    MDNS: {
      Enabled: false,
      Interval: 10
    },
    webRTCStar: {
      Enabled: true
    }
  },
  Bootstrap: [
    '/dns4/ams-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLer265NRgSp2LA3dPaeykiS1J6DifTC88f5uVQKNAd',
    '/dns4/lon-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLMeWqB7YGVLJN3pNLQpmmEk35v6wYtsMGLzSr5QBU3',
    '/dns4/sfo-3.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLPppuBtQSGwKDZT2M73ULpjvfd3aZ6ha4oFGL1KrGM',
    '/dns4/sgp-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLSafTMBsPKadTEgaXctDQVcqN88CNLHXMkTNwMKPnu',
    '/dns4/nyc-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLueR4xBeUbY9WZ9xGUUxunbKWcrNFTDAadQJmocnWm',
    '/dns4/nyc-2.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLV4Bbm51jM9C4gDYZQ9Cy3U6aXMJDAbzgu2fzaDs64',
    '/dns4/node0.preload.ipfs.io/tcp/443/wss/ipfs/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic',
    '/dns4/node1.preload.ipfs.io/tcp/443/wss/ipfs/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6'
  ],
  Swarm: {
    ConnMgr: {
      LowWater: 200,
      HighWater: 500
    }
  }
})

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/config-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/utils.js", {"async/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/map.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","is-ipfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-ipfs/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/utils.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')
const map = require('async/map')
const isIpfs = require('is-ipfs')
const CID = require('cids')

const ERR_BAD_PATH = 'ERR_BAD_PATH'
exports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \'ipfs daemon\' first.'

/**
 * Break an ipfs-path down into it's hash and an array of links.
 *
 * examples:
 *  b58Hash -> { hash: 'b58Hash', links: [] }
 *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}
 *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }
 *
 * @param  {String} ipfsPath An ipfs-path
 * @return {Object}            { hash: base58 string, links: [string], ?err: Error }
 * @throws on an invalid @param ipfsPath
 */
function parseIpfsPath (ipfsPath) {
  const invalidPathErr = new Error('invalid ipfs ref path')
  ipfsPath = ipfsPath.replace(/^\/ipfs\//, '')
  const matched = ipfsPath.match(/([^/]+(?:\/[^/]+)*)\/?$/)
  if (!matched) {
    throw invalidPathErr
  }

  const [hash, ...links] = matched[1].split('/')

  // check that a CID can be constructed with the hash
  if (isIpfs.cid(hash)) {
    return { hash, links }
  } else {
    throw invalidPathErr
  }
}

/**
 * Returns a well-formed ipfs Path.
 * The returned path will always be prefixed with /ipfs/ or /ipns/.
 * If the received string is not a valid ipfs path, an error will be returned
 * examples:
 *  b58Hash -> { hash: 'b58Hash', links: [] }
 *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}
 *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }
 *
 * @param  {String} pathStr An ipfs-path, or ipns-path or a cid
 * @return {String} ipfs-path or ipns-path
 * @throws on an invalid @param ipfsPath
 */
const normalizePath = (pathStr) => {
  if (isIpfs.cid(pathStr)) {
    return `/ipfs/${pathStr}`
  } else if (isIpfs.path(pathStr)) {
    return pathStr
  } else {
    throw Object.assign(new Error(`invalid ${pathStr} path`), { code: ERR_BAD_PATH })
  }
}

/**
 * Resolve various styles of an ipfs-path to the hash of the target node.
 * Follows links in the path.
 *
 * Accepts formats:
 *  - <base58 string>
 *  - <base58 string>/link/to/venus
 *  - /ipfs/<base58 string>/link/to/pluto
 *  - multihash Buffer
 *  - Arrays of the above
 *
 * @param  {IPFS}               objectAPI The IPFS object api
 * @param  {Described above}    ipfsPaths A single or collection of ipfs-paths
 * @param  {Function<err, res>} callback res is Array<Buffer(hash)>
 *                              if no callback is passed, returns a Promise
 * @return {Promise|void}
 */
const resolvePath = promisify(function (objectAPI, ipfsPaths, callback) {
  if (!Array.isArray(ipfsPaths)) {
    ipfsPaths = [ipfsPaths]
  }

  map(ipfsPaths, (path, cb) => {
    if (typeof path !== 'string') {
      let cid

      try {
        cid = new CID(path)
      } catch (err) {
        return cb(err)
      }

      return cb(null, cid.buffer)
    }

    let parsedPath
    try {
      parsedPath = exports.parseIpfsPath(path)
    } catch (err) {
      return cb(err)
    }

    const rootHash = new CID(parsedPath.hash)
    const rootLinks = parsedPath.links

    if (!rootLinks.length) {
      return cb(null, rootHash.buffer)
    }

    objectAPI.get(rootHash, follow.bind(null, rootHash, rootLinks))

    // recursively follow named links to the target node
    function follow (cid, links, err, obj) {
      if (err) {
        return cb(err)
      }

      if (!links.length) {
        // done tracing, obj is the target node
        return cb(null, cid.buffer)
      }

      const linkName = links[0]
      const nextObj = obj.Links.find(link => link.Name === linkName)

      if (!nextObj) {
        return cb(new Error(`no link named "${linkName}" under ${cid}`))
      }

      objectAPI.get(nextObj.Hash, follow.bind(null, nextObj.Hash, links.slice(1)))
    }
  }, callback)
})

exports.normalizePath = normalizePath
exports.parseIpfsPath = parseIpfsPath
exports.resolvePath = resolvePath

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js", {"./pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js","./sinks":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/index.js","./sources":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/index.js","./throughs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js
      return function (require, module, exports) {
'use strict'

var sources  = require('./sources')
var sinks    = require('./sinks')
var throughs = require('./throughs')

exports = module.exports = require('./pull')

exports.pull = exports

for(var k in sources)
  exports[k] = sources[k]

for(var k in throughs)
  exports[k] = throughs[k]

for(var k in sinks)
  exports[k] = sinks[k]


      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-pushable/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-pushable/index.js
      return function (require, module, exports) {
module.exports = pullPushable

function pullPushable (separated, onClose) {
  if (typeof separated === 'function') {
    onClose = separated
    separated = false
  }

  // create a buffer for data
  // that have been pushed
  // but not yet pulled.
  var buffer = []

  // a pushable is a source stream
  // (abort, cb) => cb(end, data)
  //
  // when pushable is pulled,
  // keep references to abort and cb
  // so we can call back after
  // .end(end) or .push(data)
  var abort, cb
  function read (_abort, _cb) {
    if (_abort) {
      abort = _abort
      // if there is already a cb waiting, abort it.
      if (cb) callback(abort)
    }
    cb = _cb
    drain()
  }

  var ended
  function end (end) {
    ended = ended || end || true
    // attempt to drain
    drain()
  }

  function push (data) {
    if (ended) return
    // if sink already waiting,
    // we can call back directly.
    if (cb) {
      callback(abort, data)
      return
    }
    // otherwise buffer data
    buffer.push(data)
  }

  // Return functions separated from source { push, end, source }
  if (separated) {
    return { push: push, end: end, source: read, buffer: buffer }
  }

  // Return normal
  read.push = push
  read.end = end
  read.buffer = buffer
  return read

  // `drain` calls back to (if any) waiting
  // sink with abort, end, or next data.
  function drain () {
    if (!cb) return

    if (abort) callback(abort)
    else if (!buffer.length && ended) callback(ended)
    else if (buffer.length) callback(null, buffer.shift())
  }

  // `callback` calls back to waiting sink,
  // and removes references to sink cb.
  function callback (err, val) {
    var _cb = cb
    // if error and pushable passed onClose, call it
    // the first time this stream ends or errors.
    if (err && onClose) {
      var c = onClose
      onClose = null
      c(err === true ? null : err)
    }
    cb = null
    _cb(err, val)
  }
}

      };
    };
  }
}, {package:"pull-pushable",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-pushable/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-stream/index.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-browserify/index.js","timers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/timers-browserify/main.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-stream/index.js
      return function (require, module, exports) {
(function (process,setImmediate){(function (){

var Stream = require('stream')

module.exports = duplex


module.exports.source = function (source) {
  return duplex(null, source)
}

module.exports.sink = function (sink) {
  return duplex(sink, null)
}

var next = (
  'undefined' === typeof setImmediate
  ? process.nextTick
  : setImmediate
)

function duplex (reader, read) {
  if(reader && 'object' === typeof reader) {
    read = reader.source
    reader = reader.sink
  }

  var cbs = [], input = [], ended, needDrain
  var s = new Stream()
  s.writable = s.readable = true
  s.write = function (data) {
    if(cbs.length)
      cbs.shift()(null, data)
    else
      input.push(data)

    if (!cbs.length) {
      needDrain = true
    }
    return !!cbs.length
  }

  s.end = function () {
    if(read) {
      if (input.length)
        drain()
      else
        read(ended = true, cbs.length ? cbs.shift() : function () {})
    } else if(cbs.length) {
      cbs.shift()(true)
    }
  }

  s.source = function (end, cb) {
    if(input.length) {
      cb(null, input.shift())
      if(!input.length)
        s.emit('drain')
    }
    else {
      if(ended = ended || end)
        cb(ended)
      else
        cbs.push(cb)

      if (needDrain) {
        needDrain = false
        s.emit('drain')
      }
    }
  }

  var n
  if(reader) n = reader(s.source)
  if(n && !read) read = n

  var output = [], _cbs = []
  var _ended = false, waiting = false, busy = false

  s.sink = function (_read) {
    read = _read
    next(drain)
  }

  if(read) {
    s.sink(read)

    var pipe = s.pipe.bind(s)
    s.pipe = function (dest, opts) {
      var res = pipe(dest, opts)

      if(s.paused) s.resume()

      return res
    }
  }

  function drain () {
    waiting = false
    if(!read || busy) return
    while(output.length && !s.paused) {
      s.emit('data', output.shift())
    }
    if(s.paused) return
    if(_ended)
      return s.emit('end')

    busy = true
    read(null, function next (end, data) {
      busy = false
      if(s.paused) {
        if(end === true) _ended = end
        else if(end) s.emit('error', end)
        else output.push(data)
        waiting = true
      } else {
        if(end && (ended = end) !== true)
          s.emit('error', end)
        else if(ended = ended || end) s.emit('end')
        else {
          s.emit('data', data)
          busy = true
          read(null, next)
        }
      }
    })
  }

  s.pause = function () {
    s.paused = true
    return s
  }

  s.resume = function () {
    s.paused = false
    drain()
    return s
  }

  s.destroy = function () {
    if(!ended && read)
      read(ended = true, function () {})
    ended = true
    if(cbs.length)
      cbs.shift()(true)

    s.emit('close')
  }

  return s
}

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)

      };
    };
  }
}, {package:"pull-stream-to-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-stream/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js
      return function (require, module, exports) {
'use strict';

function createError(msg, code, props) {
    var err = msg instanceof Error ? msg : new Error(msg);
    var key;

    if (typeof code === 'object') {
        props = code;
    } else if (code != null) {
        err.code = code;
    }

    if (props) {
        for (key in props) {
            err[key] = props[key];
        }
    }

    return err;
}

module.exports = createError;

      };
    };
  }
}, {package:"err-code",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js", {"./unixfs.proto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/unixfs.proto.js","protons":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js
      return function (require, module, exports) {
'use strict'

const protons = require('protons')
const pb = protons(require('./unixfs.proto'))
// encode/decode
const unixfsData = pb.Data
// const unixfsMetadata = pb.MetaData // encode/decode

const types = [
  'raw',
  'directory',
  'file',
  'metadata',
  'symlink',
  'hamt-sharded-directory'
]

const dirTypes = [
  'directory',
  'hamt-sharded-directory'
]

function Data (type, data) {
  if (!(this instanceof Data)) {
    return new Data(type, data)
  }
  if (types.indexOf(type) === -1) {
    throw new Error('Type: ' + type + ' is not valid')
  }

  this.type = type
  this.data = data
  this.blockSizes = []

  this.addBlockSize = (size) => {
    this.blockSizes.push(size)
  }

  this.removeBlockSize = (index) => {
    this.blockSizes.splice(index, 1)
  }

  // data.length + blockSizes
  this.fileSize = () => {
    if (dirTypes.indexOf(this.type) >= 0) {
      // dirs don't have file size
      return undefined
    }

    let sum = 0
    this.blockSizes.forEach((size) => {
      sum += size
    })
    if (data) {
      sum += data.length
    }
    return sum
  }

  // encode to protobuf
  this.marshal = () => {
    let type

    switch (this.type) {
      case 'raw': type = unixfsData.DataType.Raw; break
      case 'directory': type = unixfsData.DataType.Directory; break
      case 'file': type = unixfsData.DataType.File; break
      case 'metadata': type = unixfsData.DataType.Metadata; break
      case 'symlink': type = unixfsData.DataType.Symlink; break
      case 'hamt-sharded-directory': type = unixfsData.DataType.HAMTShard; break
      default:
        throw new Error(`Unkown type: "${this.type}"`)
    }
    let fileSize = this.fileSize()

    let data = this.data

    if (!this.data || !this.data.length) {
      data = undefined
    }

    let blockSizes = this.blockSizes

    if (!this.blockSizes || !this.blockSizes.length) {
      blockSizes = undefined
    }

    return unixfsData.encode({
      Type: type,
      Data: data,
      filesize: fileSize,
      blocksizes: blockSizes,
      hashType: this.hashType,
      fanout: this.fanout
    })
  }
}

// decode from protobuf https://github.com/ipfs/go-ipfs/blob/master/unixfs/format.go#L24
Data.unmarshal = (marsheled) => {
  const decoded = unixfsData.decode(marsheled)
  if (!decoded.Data) {
    decoded.Data = undefined
  }
  const obj = new Data(types[decoded.Type], decoded.Data)
  obj.blockSizes = decoded.blocksizes
  return obj
}

exports = module.exports = Data

      };
    };
  }
}, {package:"ipfs-unixfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/bignumber.js/bignumber.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/bignumber.js/bignumber.js
      return function (require, module, exports) {
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                    // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',      // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return 0, else return Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, Infinity or 0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return Infinity if either is Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return 0 if either is 0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return Infinity if either Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

      };
    };
  }
}, {package:"bignumber.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/bignumber.js/bignumber.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/utils/cid.js", {"cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/utils/cid.js
      return function (require, module, exports) {
'use strict'

const CID = require('cids')

/**
* Stringify a CID encoded in the requested base, upgrading to v1 if necessary.
*
* Setting upgrade to false will disable automatic CID upgrading from v0 to v1
* which is necessary if the multibase is something other than base58btc. Note
* that it will also not apply the encoding (since v0 CIDs can only be encoded
* as base58btc).
*
* @param {CID|Buffer|String} cid The CID to encode
* @param {Object} [options] Optional options
* @param {String} [options.base] Name of multibase codec to encode the CID with
* @param {Boolean} [options.upgrade] Automatically upgrade v0 CIDs to v1 when
* necessary. Default: true.
* @returns {String}
*/
exports.cidToString = (cid, options) => {
  options = options || {}
  options.upgrade = options.upgrade !== false

  if (!CID.isCID(cid)) {
    cid = new CID(cid)
  }

  if (cid.version === 0 && options.base && options.base !== 'base58btc') {
    if (!options.upgrade) return cid.toString()
    cid = cid.toV1()
  }

  return cid.toBaseEncodedString(options.base)
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/utils/cid.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/human-to-milliseconds/src/index.js", {"promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/human-to-milliseconds/src/index.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')

const whole = /^((\d+(\.\d+)*)(ns|ms|us|s|m|s|h))+$/
const pieces = /((\d+(\.\d+)*)(ns|ms|us|s|m|s|h))/g
const measure = /(ns|ms|us|s|m|s|h)/g

const multipliers = {
  ns: 1e-6,
  us: 0.001,
  s: 0.001,
  ms: 1,
  s: 1000,
  m: 60000,
  h: 3.6e+6
}

function analyse (time) {
  let unit = time.match(measure)[0]
  time = time.substring(0, time.length - unit.length)

  return parseFloat(time) * multipliers[unit]
}

module.exports = promisify(function (time, callback) {
  if (typeof time !== 'string') {
    return callback(new Error('the first argument must be a string'))
  }

  if (!whole.test(time)) {
    return callback(new Error('invalid time'))
  }

  callback(null, time.match(pieces).reduce((sum, currentVal) => {
    return sum + analyse(currentVal)
  }, 0))
})

      };
    };
  }
}, {package:"human-to-milliseconds",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/human-to-milliseconds/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js", {"./internal/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/setImmediate.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","timers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/timers-browserify/main.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js
      return function (require, module, exports) {
(function (process,setImmediate){(function (){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _setImmediate = require('./internal/setImmediate');

/**
 * Calls `callback` on a later loop around the event loop. In Node.js this just
 * calls `process.nextTick`.  In the browser it will use `setImmediate` if
 * available, otherwise `setTimeout(callback, 0)`, which means other higher
 * priority events may precede the execution of `callback`.
 *
 * This is used internally for browser-compatibility purposes.
 *
 * @name nextTick
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.setImmediate]{@link module:Utils.setImmediate}
 * @category Util
 * @param {Function} callback - The function to call on a later loop around
 * the event loop. Invoked with (args...).
 * @param {...*} args... - any number of additional arguments to pass to the
 * callback on the next tick.
 * @example
 *
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push('two');
 *     // call_order now equals ['one','two']
 * });
 * call_order.push('one');
 *
 * async.setImmediate(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
var _defer;

if (_setImmediate.hasNextTick) {
    _defer = process.nextTick;
} else if (_setImmediate.hasSetImmediate) {
    _defer = setImmediate;
} else {
    _defer = _setImmediate.fallback;
}

exports.default = (0, _setImmediate.wrap)(_defer);
module.exports = exports['default'];
}).call(this)}).call(this,require('_process'),require("timers").setImmediate)

      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/every.js", {"./internal/createTester":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/createTester.js","./internal/doParallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/doParallel.js","./internal/notId":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/notId.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/every.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createTester = require('./internal/createTester');

var _createTester2 = _interopRequireDefault(_createTester);

var _doParallel = require('./internal/doParallel');

var _doParallel2 = _interopRequireDefault(_doParallel);

var _notId = require('./internal/notId');

var _notId2 = _interopRequireDefault(_notId);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns `true` if every element in `coll` satisfies an async test. If any
 * iteratee call returns `false`, the main `callback` is immediately called.
 *
 * @name every
 * @static
 * @memberOf module:Collections
 * @method
 * @alias all
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in parallel.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 * @example
 *
 * async.every(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // if result is true then every file exists
 * });
 */
exports.default = (0, _doParallel2.default)((0, _createTester2.default)(_notId2.default, _notId2.default));
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/every.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/just-flatten-it/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/just-flatten-it/index.js
      return function (require, module, exports) {
module.exports = flatten;

/*
  flatten([[1, [2, 3]], [[4, 5], 6, 7, [8, 9]]]);
  // [1, 2, 3, 4, 5, 6, 7, 8, 9]
*/

function flatten(arr) {
  if (!Array.isArray(arr)) {
    throw new Error('expected an array');
  }
  var result = [];
  var len = arr.length;
  for (var i = 0; i < len; i++) {
    var elem = arr[i];
    if (Array.isArray(elem)) {
      result.push.apply(result, flatten(elem));
    } else {
      result.push(elem);
    }
  }
  return result;
}

      };
    };
  }
}, {package:"just-flatten-it",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/just-flatten-it/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-pull-stream/index.js", {"get-iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/get-iterator/index.js","pull-stream-to-async-iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-async-iterator/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-pull-stream/index.js
      return function (require, module, exports) {
const getIterator = require('get-iterator')
const toIterable = require('pull-stream-to-async-iterator')

function toPull (source) {
  source = getIterator(source)

  return async (end, cb) => {
    if (end) {
      if (source.return) {
        try {
          await source.return()
        } catch (err) {
          return cb(err)
        }
      }
      return cb(end)
    }

    let next
    try {
      next = await source.next()
    } catch (err) {
      return cb(err)
    }

    if (next.done) return cb(true) // eslint-disable-line
    cb(null, next.value)
  }
}

toPull.source = toPull

toPull.transform = toPull.through = source => read => toPull(source(toIterable(read)))

toPull.duplex = duplex => ({
  sink: toPull.sink(duplex.sink),
  source: toPull(duplex.source)
})

toPull.sink = sink => {
  return read => {
    sink({
      [Symbol.asyncIterator] () {
        return this
      },

      next: () => new Promise((resolve, reject) => {
        read(null, (end, value) => {
          if (end === true) return resolve({ done: true, value })
          if (end) return reject(end)
          resolve({ done: false, value })
        })
      }),

      return: () => new Promise((resolve, reject) => {
        read(true, (end, value) => {
          if (end && end !== true) return reject(end)
          resolve({ done: true, value })
        })
      }),

      throw: err => new Promise((resolve, reject) => {
        read(err, (end, value) => {
          if (end && end !== true) return reject(end)
          resolve({ done: true, value })
        })
      })
    })
  }
}

module.exports = toPull

      };
    };
  }
}, {package:"async-iterator-to-pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-pull-stream/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/mapSeries.js", {"./internal/doLimit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/doLimit.js","./mapLimit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/mapLimit.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/mapSeries.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mapLimit = require('./mapLimit');

var _mapLimit2 = _interopRequireDefault(_mapLimit);

var _doLimit = require('./internal/doLimit');

var _doLimit2 = _interopRequireDefault(_doLimit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
 *
 * @name mapSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 */
exports.default = (0, _doLimit2.default)(_mapLimit2.default, 1);
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/mapSeries.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js", {"./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/errors.js","./key":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/key.js","./memory":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/memory.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js
      return function (require, module, exports) {
/* @flow */
'use strict'

const Key = require('./key')
const MemoryDatastore = require('./memory')
const utils = require('./utils')
const Errors = require('./errors')

exports.Key = Key
exports.MemoryDatastore = MemoryDatastore
exports.utils = utils
exports.Errors = Errors

/* ::
// -- Basics

export type Callback<Value> = (err: ?Error, ?Value) => void

// eslint-disable-next-line
export interface Datastore<Value> {
  // eslint-disable-next-line
  put(Key, Value, Callback<void>): void;
  // eslint-disable-next-line
  get(Key, Callback<Value>): void;
  has(Key, Callback<bool>): void;
  delete(Key, Callback<void>): void;
  // eslint-disable-next-line
  query(Query<Value>): QueryResult<Value>;

  // eslint-disable-next-line
  batch(): Batch<Value>;
  close(Callback<void>): void;
  open(Callback<void>): void;
}

// -- Batch
export type Batch<Value> = {
  put(Key, Value): void,
  delete(Key): void,
  commit(Callback<void>): void
}

// -- Query

export type Query<Value> = {
  prefix?: string,
  filters?: Array<Filter<Value>>,
  orders?: Array<Order<Value>>,
  limit?: number,
  offset?: number,
  keysOnly?: bool
}

export type PullEnd = bool | Error
export type PullSource<Val> = (end: ?PullEnd, (end: ?PullEnd, Val) => void) => void

export type QueryResult<Value> = PullSource<QueryEntry<Value>>

export type QueryEntry<Value> = {
  key: Key,
  value?: Value
}

export type Filter<Value> = (QueryEntry<Value>, Callback<bool>) => void

export type Order<Value> = (QueryResult<Value>, Callback<QueryResult<Value>>) => void

*/

      };
    };
  }
}, {package:"interface-datastore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/detectLimit.js", {"./internal/createTester":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/createTester.js","./internal/doParallelLimit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/doParallelLimit.js","./internal/findGetResult":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/findGetResult.js","lodash/identity":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/identity.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/detectLimit.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _identity = require('lodash/identity');

var _identity2 = _interopRequireDefault(_identity);

var _createTester = require('./internal/createTester');

var _createTester2 = _interopRequireDefault(_createTester);

var _doParallelLimit = require('./internal/doParallelLimit');

var _doParallelLimit2 = _interopRequireDefault(_doParallelLimit);

var _findGetResult = require('./internal/findGetResult');

var _findGetResult2 = _interopRequireDefault(_findGetResult);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name detectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]{@link module:Collections.detect}
 * @alias findLimit
 * @category Collections
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 */
exports.default = (0, _doParallelLimit2.default)((0, _createTester2.default)(_identity2.default, _findGetResult2.default));
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/detectLimit.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pin-set.js", {"./pin.proto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pin.proto.js","async/eachOfSeries":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/eachOfSeries.js","async/someSeries":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/someSeries.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","fnv1a":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fnv1a/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js","protons":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pin-set.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const multihashes = require('multihashes')
const CID = require('cids')
const protobuf = require('protons')
const fnv1a = require('fnv1a')
const varint = require('varint')
const { DAGNode, DAGLink } = require('ipld-dag-pb')
const multicodec = require('multicodec')
const someSeries = require('async/someSeries')
const eachOfSeries = require('async/eachOfSeries')

const pbSchema = require('./pin.proto')

const emptyKeyHash = 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'
const emptyKey = multihashes.fromB58String(emptyKeyHash)
const defaultFanout = 256
const maxItems = 8192
const pb = protobuf(pbSchema)

function toB58String (hash) {
  return new CID(hash).toBaseEncodedString()
}

function readHeader (rootNode) {
  // rootNode.data should be a buffer of the format:
  // < varint(headerLength) | header | itemData... >
  const rootData = rootNode.Data
  const hdrLength = varint.decode(rootData)
  const vBytes = varint.decode.bytes
  if (vBytes <= 0) {
    throw new Error('Invalid Set header length')
  }
  if (vBytes + hdrLength > rootData.length) {
    throw new Error('Impossibly large set header length')
  }
  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes)
  const header = pb.Set.decode(hdrSlice)
  if (header.version !== 1) {
    throw new Error(`Unsupported Set version: ${header.version}`)
  }
  if (header.fanout > rootNode.Links.length) {
    throw new Error('Impossibly large fanout')
  }
  return {
    header: header,
    data: rootData.slice(hdrLength + vBytes)
  }
}

function hash (seed, key) {
  const buf = Buffer.alloc(4)
  buf.writeUInt32LE(seed, 0)
  const data = Buffer.concat([
    buf, Buffer.from(toB58String(key))
  ])
  return fnv1a(data.toString('binary'))
}

exports = module.exports = function (dag) {
  const pinSet = {
    // should this be part of `object` API?
    hasDescendant: (root, childhash, callback) => {
      const seen = {}

      if (CID.isCID(childhash) || Buffer.isBuffer(childhash)) {
        childhash = toB58String(childhash)
      }

      return searchChildren(root, callback)

      function searchChildren (root, cb) {
        someSeries(root.Links, (link, done) => {
          const cid = link.Hash
          const bs58Link = toB58String(cid)

          if (bs58Link === childhash) {
            return done(null, true)
          }

          if (bs58Link in seen) {
            return done(null, false)
          }

          seen[bs58Link] = true

          dag.get(cid, '', { preload: false }, (err, res) => {
            if (err) {
              return done(err)
            }

            searchChildren(res.value, done)
          })
        }, cb)
      }
    },

    storeSet: (keys, callback) => {
      const pins = keys.map(key => {
        if (typeof key === 'string' || Buffer.isBuffer(key)) {
          key = new CID(key)
        }

        return {
          key: key,
          data: null
        }
      })

      pinSet.storeItems(pins, (err, rootNode) => {
        if (err) { return callback(err) }

        dag.put(rootNode, {
          version: 0,
          format: multicodec.DAG_PB,
          hashAlg: multicodec.SHA2_256,
          preload: false
        }, (err, cid) => {
          if (err) { return callback(err, cid) }
          callback(null, { node: rootNode, cid })
        })
      })
    },

    storeItems: (items, callback) => {
      return storePins(items, 0, callback)

      function storePins (pins, depth, storePinsCb) {
        const pbHeader = pb.Set.encode({
          version: 1,
          fanout: defaultFanout,
          seed: depth
        })
        const headerBuf = Buffer.concat([
          Buffer.from(varint.encode(pbHeader.length)), pbHeader
        ])
        const fanoutLinks = []
        for (let i = 0; i < defaultFanout; i++) {
          fanoutLinks.push(new DAGLink('', 1, emptyKey))
        }

        if (pins.length <= maxItems) {
          const nodes = pins
            .map(item => {
              return ({
                link: new DAGLink('', 1, item.key),
                data: item.data || Buffer.alloc(0)
              })
            })
            // sorting makes any ordering of `pins` produce the same DAGNode
            .sort((a, b) => Buffer.compare(a.link.Hash.buffer, b.link.Hash.buffer))

          const rootLinks = fanoutLinks.concat(nodes.map(item => item.link))
          const rootData = Buffer.concat(
            [headerBuf].concat(nodes.map(item => item.data))
          )

          let rootNode

          try {
            rootNode = DAGNode.create(rootData, rootLinks)
          } catch (err) {
            return storePinsCb(err)
          }

          return storePinsCb(null, rootNode)
        } else {
          // If the array of pins is > maxItems, we:
          //  - distribute the pins among `defaultFanout` bins
          //    - create a DAGNode for each bin
          //      - add each pin as a DAGLink to that bin
          //  - create a root DAGNode
          //    - add each bin as a DAGLink
          //  - send that root DAGNode via callback
          // (using go-ipfs' "wasteful but simple" approach for consistency)
          // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57

          const bins = pins.reduce((bins, pin) => {
            const n = hash(depth, pin.key) % defaultFanout
            bins[n] = n in bins ? bins[n].concat([pin]) : [pin]
            return bins
          }, {})

          eachOfSeries(bins, (bin, idx, eachCb) => {
            storePins(
              bin,
              depth + 1,
              (err, child) => storeChild(err, child, idx, eachCb)
            )
          }, err => {
            if (err) { return storePinsCb(err) }

            let rootNode

            try {
              rootNode = DAGNode.create(headerBuf, fanoutLinks)
            } catch (err) {
              return storePinsCb(err)
            }

            return storePinsCb(null, rootNode)
          })
        }

        function storeChild (err, child, binIdx, cb) {
          if (err) { return cb(err) }

          const opts = {
            version: 0,
            format: multicodec.DAG_PB,
            hashAlg: multicodec.SHA2_256,
            preload: false
          }

          dag.put(child, opts, (err, cid) => {
            if (err) { return cb(err) }
            fanoutLinks[binIdx] = new DAGLink('', child.size, cid)
            cb(null)
          })
        }
      }
    },

    loadSet: (rootNode, name, callback) => {
      const link = rootNode.Links.find(l => l.Name === name)
      if (!link) {
        return callback(new Error('No link found with name ' + name))
      }

      dag.get(link.Hash, '', { preload: false }, (err, res) => {
        if (err) { return callback(err) }
        const keys = []
        const step = link => keys.push(link.Hash.buffer)
        pinSet.walkItems(res.value, step, err => {
          if (err) { return callback(err) }
          return callback(null, keys)
        })
      })
    },

    walkItems: (node, step, callback) => {
      let pbh
      try {
        pbh = readHeader(node)
      } catch (err) {
        return callback(err)
      }

      eachOfSeries(node.Links, (link, idx, eachCb) => {
        if (idx < pbh.header.fanout) {
          // the first pbh.header.fanout links are fanout bins
          // if a fanout bin is not 'empty', dig into and walk its DAGLinks
          const linkHash = link.Hash.buffer

          if (!emptyKey.equals(linkHash)) {
            // walk the links of this fanout bin
            return dag.get(linkHash, '', { preload: false }, (err, res) => {
              if (err) { return eachCb(err) }
              pinSet.walkItems(res.value, step, eachCb)
            })
          }
        } else {
          // otherwise, the link is a pin
          step(link, idx, pbh.data)
        }

        eachCb(null)
      }, callback)
    }
  }
  return pinSet
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pin-set.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/path.js", {"debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","is-ipfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-ipfs/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/path.js
      return function (require, module, exports) {
'use strict'

const isIPFS = require('is-ipfs')

const debug = require('debug')
const log = debug('ipfs:ipns:path')
log.error = debug('ipfs:ipns:path:error')

// resolves the given path by parsing out protocol-specific entries
// (e.g. /ipns/<node-key>) and then going through the /ipfs/ entries and returning the final node
const resolvePath = (ipfsNode, name, callback) => {
  // ipns path
  if (isIPFS.ipnsPath(name)) {
    log(`resolve ipns path ${name}`)

    return ipfsNode._ipns.resolve(name, callback)
  }

  // ipfs path
  ipfsNode.dag.get(name.substring('/ipfs/'.length), (err, value) => {
    if (err) {
      return callback(err)
    }

    return callback(null, value)
  })
}

module.exports = {
  resolvePath
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/path.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/name-pubsub.js", {"../ipns/routing/pubsub-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/pubsub-datastore.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/name-pubsub.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')
const errcode = require('err-code')
const promisify = require('promisify-es6')

const IpnsPubsubDatastore = require('../ipns/routing/pubsub-datastore')

const log = debug('ipfs:name-pubsub')
log.error = debug('ipfs:name-pubsub:error')

// Is pubsub enabled
const isNamePubsubEnabled = (node) => {
  try {
    return Boolean(getPubsubRouting(node))
  } catch (err) {
    return false
  }
}

// Get pubsub from IPNS routing
const getPubsubRouting = (node) => {
  if (!node._ipns || !node._options.EXPERIMENTAL.ipnsPubsub) {
    const errMsg = 'IPNS pubsub subsystem is not enabled'

    throw errcode(errMsg, 'ERR_IPNS_PUBSUB_NOT_ENABLED')
  }

  // Only one store and it is pubsub
  if (IpnsPubsubDatastore.isIpnsPubsubDatastore(node._ipns.routing)) {
    return node._ipns.routing
  }

  // Find in tiered
  const pubsub = (node._ipns.routing.stores || []).find(s => IpnsPubsubDatastore.isIpnsPubsubDatastore(s))

  if (!pubsub) {
    const errMsg = 'IPNS pubsub datastore not found'

    throw errcode(errMsg, 'ERR_PUBSUB_DATASTORE_NOT_FOUND')
  }

  return pubsub
}

module.exports = function namePubsub (self) {
  return {
    /**
     * Query the state of IPNS pubsub.
     *
     * @returns {Promise|void}
     */
    state: promisify((callback) => {
      callback(null, {
        enabled: isNamePubsubEnabled(self)
      })
    }),
    /**
     * Cancel a name subscription.
     *
     * @param {String} name subscription name.
     * @param {function(Error)} [callback]
     * @returns {Promise|void}
     */
    cancel: promisify((name, callback) => {
      let pubsub
      try {
        pubsub = getPubsubRouting(self)
      } catch (err) {
        return callback(err)
      }

      pubsub.cancel(name, callback)
    }),
    /**
     * Show current name subscriptions.
     *
     * @param {function(Error)} [callback]
     * @returns {Promise|void}
     */
    subs: promisify((callback) => {
      let pubsub
      try {
        pubsub = getPubsubRouting(self)
      } catch (err) {
        return callback(err)
      }

      pubsub.getSubscriptions(callback)
    })
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/name-pubsub.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/no-keychain.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/no-keychain.js
      return function (require, module, exports) {
'use strict'

function fail () {
  throw new Error('Key management requires \'--pass ...\' option')
}

class NoKeychain {
  static get options () { fail() }
  static generateOptions () { fail() }

  createKey () { fail() }
  listKeys () { fail() }
  findKeyById () { fail() }
  findKeyByName () { fail() }
  renameKey () { fail() }
  removeKey () { fail() }
  exportKey () { fail() }
  importKey () { fail() }
  importPeer () { fail() }

  get cms () { fail() }
}

module.exports = NoKeychain

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/no-keychain.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/index.js", {"./keychain":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/keychain.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/index.js
      return function (require, module, exports) {
'use strict'

module.exports = require('./keychain')

      };
    };
  }
}, {package:"libp2p-keychain",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/config.js", {"./offline-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/offline-datastore.js","./pubsub-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/pubsub-datastore.js","datastore-core":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/index.js","dlv":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/dlv/dist/dlv.umd.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/config.js
      return function (require, module, exports) {
'use strict'

const { TieredDatastore } = require('datastore-core')
const get = require('dlv')

const PubsubDatastore = require('./pubsub-datastore')
const OfflineDatastore = require('./offline-datastore')

module.exports = (ipfs) => {
  // Setup online routing for IPNS with a tiered routing composed by a DHT and a Pubsub router (if properly enabled)
  const ipnsStores = []

  // Add IPNS pubsub if enabled
  let pubsubDs
  if (get(ipfs._options, 'EXPERIMENTAL.ipnsPubsub', false)) {
    const pubsub = ipfs.libp2p.pubsub
    const localDatastore = ipfs._repo.datastore
    const peerId = ipfs._peerInfo.id

    pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId)
    ipnsStores.push(pubsubDs)
  }

  // DHT should not be added as routing if we are offline or it is disabled
  if (get(ipfs._options, 'offline') || !get(ipfs._options, 'libp2p.dht.enabled', false)) {
    const offlineDatastore = new OfflineDatastore(ipfs._repo)
    ipnsStores.push(offlineDatastore)
  } else {
    ipnsStores.push(ipfs.libp2p.dht)
  }

  // Create ipns routing with a set of datastores
  return new TieredDatastore(ipnsStores)
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/config.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/index.js", {"./path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/path.js","./publisher":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/publisher.js","./republisher":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/republisher.js","./resolver":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/resolver.js","async/series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/series.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","receptacle":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/receptacle/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/index.js
      return function (require, module, exports) {
'use strict'

const { createFromPrivKey } = require('peer-id')
const series = require('async/series')
const Receptacle = require('receptacle')

const errcode = require('err-code')
const debug = require('debug')
const log = debug('ipfs:ipns')
log.error = debug('ipfs:ipns:error')

const IpnsPublisher = require('./publisher')
const IpnsRepublisher = require('./republisher')
const IpnsResolver = require('./resolver')
const path = require('./path')

const defaultRecordTtl = 60 * 1000

class IPNS {
  constructor (routing, datastore, peerInfo, keychain, options) {
    this.publisher = new IpnsPublisher(routing, datastore)
    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerInfo, keychain, options)
    this.resolver = new IpnsResolver(routing)
    this.cache = new Receptacle({ max: 1000 }) // Create an LRU cache with max 1000 items
    this.routing = routing
  }

  // Publish
  publish (privKey, value, lifetime, callback) {
    series([
      (cb) => createFromPrivKey(privKey.bytes, cb),
      (cb) => this.publisher.publishWithEOL(privKey, value, lifetime, cb)
    ], (err, results) => {
      if (err) {
        log.error(err)
        return callback(err)
      }

      log(`IPNS value ${value} was published correctly`)

      // Add to cache
      const id = results[0].toB58String()
      const ttEol = parseFloat(lifetime)
      const ttl = (ttEol < defaultRecordTtl) ? ttEol : defaultRecordTtl

      this.cache.set(id, value, { ttl: ttl })

      log(`IPNS value ${value} was cached correctly`)

      callback(null, {
        name: id,
        value: value
      })
    })
  }

  // Resolve
  resolve (name, options, callback) {
    if (typeof name !== 'string') {
      const errMsg = `name received is not valid`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_NAME'))
    }

    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    options = options || {}

    // If recursive, we should not try to get the cached value
    if (!options.nocache && !options.recursive) {
      // Try to get the record from cache
      const id = name.split('/')[2]
      const result = this.cache.get(id)

      if (result) {
        return callback(null, {
          path: result
        })
      }
    }

    this.resolver.resolve(name, options, (err, result) => {
      if (err) {
        log.error(err)
        return callback(err)
      }

      log(`IPNS record from ${name} was resolved correctly`)

      callback(null, {
        path: result
      })
    })
  }

  // Initialize keyspace
  // sets the ipns record for the given key to point to an empty directory
  initializeKeyspace (privKey, value, callback) {
    this.publisher.publish(privKey, value, callback)
  }
}

exports = module.exports = IPNS
exports.path = path

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/index.js", {"./decision-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/decision-engine/index.js","./network":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/network.js","./notifications":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/notifications.js","./stats":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/stats/index.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/utils.js","./want-manager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/want-manager/index.js","async/each":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js","async/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/map.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","async/reject":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/reject.js","async/series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/series.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/index.js
      return function (require, module, exports) {
'use strict'

const waterfall = require('async/waterfall')
const reject = require('async/reject')
const each = require('async/each')
const series = require('async/series')
const map = require('async/map')
const nextTick = require('async/nextTick')

const WantManager = require('./want-manager')
const Network = require('./network')
const DecisionEngine = require('./decision-engine')
const Notifications = require('./notifications')
const logger = require('./utils').logger
const Stats = require('./stats')

const defaultOptions = {
  statsEnabled: false,
  statsComputeThrottleTimeout: 1000,
  statsComputeThrottleMaxQueueSize: 1000
}
const statsKeys = [
  'blocksReceived',
  'dataReceived',
  'dupBlksReceived',
  'dupDataReceived',
  'blocksSent',
  'dataSent',
  'providesBufferLength',
  'wantListLength',
  'peerCount'
]

/**
 * JavaScript implementation of the Bitswap 'data exchange' protocol
 * used by IPFS.
 *
 * @param {Libp2p} libp2p
 * @param {Blockstore} blockstore
 */
class Bitswap {
  constructor (libp2p, blockstore, options) {
    this._libp2p = libp2p
    this._log = logger(this.peerInfo.id)

    this._options = Object.assign({}, defaultOptions, options)

    // stats
    this._stats = new Stats(statsKeys, {
      enabled: this._options.statsEnabled,
      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,
      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize
    })

    // the network delivers messages
    this.network = new Network(libp2p, this, {}, this._stats)

    // local database
    this.blockstore = blockstore

    this.engine = new DecisionEngine(this.peerInfo.id, blockstore, this.network, this._stats)

    // handle message sending
    this.wm = new WantManager(this.peerInfo.id, this.network, this._stats)

    this.notifications = new Notifications(this.peerInfo.id)
  }

  get peerInfo () {
    return this._libp2p.peerInfo
  }

  // handle messages received through the network
  _receiveMessage (peerId, incoming, callback) {
    this.engine.messageReceived(peerId, incoming, (err) => {
      if (err) {
        // Only logging the issue to process as much as possible
        // of the message. Currently `messageReceived` does not
        // return any errors, but this could change in the future.
        this._log('failed to receive message', incoming)
      }

      if (incoming.blocks.size === 0) {
        return callback()
      }

      const blocks = Array.from(incoming.blocks.values())

      // quickly send out cancels, reduces chances of duplicate block receives
      const wanted = blocks
        .filter((b) => this.wm.wantlist.contains(b.cid))
        .map((b) => b.cid)

      this.wm.cancelWants(wanted)

      each(
        blocks,
        (b, cb) => {
          const wasWanted = wanted.includes(b.cid)
          this._handleReceivedBlock(peerId, b, wasWanted, cb)
        },
        callback
      )
    })
  }

  _handleReceivedBlock (peerId, block, wasWanted, callback) {
    this._log('received block')

    waterfall([
      (cb) => this.blockstore.has(block.cid, cb),
      (has, cb) => {
        this._updateReceiveCounters(peerId.toB58String(), block, has)
        if (has || !wasWanted) {
          return nextTick(cb)
        }

        this._putBlock(block, cb)
      }
    ], callback)
  }

  _updateReceiveCounters (peerId, block, exists) {
    this._stats.push(peerId, 'blocksReceived', 1)
    this._stats.push(peerId, 'dataReceived', block.data.length)

    if (exists) {
      this._stats.push(peerId, 'dupBlksReceived', 1)
      this._stats.push(peerId, 'dupDataReceived', block.data.length)
    }
  }

  // handle errors on the receiving channel
  _receiveError (err) {
    this._log.error('ReceiveError: %s', err.message)
  }

  // handle new peers
  _onPeerConnected (peerId) {
    this.wm.connected(peerId)
  }

  // handle peers being disconnected
  _onPeerDisconnected (peerId) {
    this.wm.disconnected(peerId)
    this.engine.peerDisconnected(peerId)
    this._stats.disconnected(peerId)
  }

  _putBlock (block, callback) {
    this.blockstore.put(block, (err) => {
      if (err) {
        return callback(err)
      }

      this.notifications.hasBlock(block)
      this.network.provide(block.cid, (err) => {
        if (err) {
          this._log.error('Failed to provide: %s', err.message)
        }
      })

      this.engine.receivedBlocks([block.cid])
      callback()
    })
  }

  enableStats () {
    this._stats.enable()
  }

  disableStats () {
    this._stats.disable()
  }

  /**
   * Return the current wantlist for a given `peerId`
   *
   * @param {PeerId} peerId
   * @returns {Wantlist}
   */
  wantlistForPeer (peerId) {
    return this.engine.wantlistForPeer(peerId)
  }

  /**
   * Return ledger information for a given `peerId`
   *
   * @param {PeerId} peerId
   * @returns {?Object}
   */
  ledgerForPeer (peerId) {
    return this.engine.ledgerForPeer(peerId)
  }

  /**
   * Fetch a given block by cid. If the block is in the local
   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.
   *
   * @param {CID} cid
   * @param {function(Error, Block)} callback
   * @returns {void}
   */
  get (cid, callback) {
    this.getMany([cid], (err, blocks) => {
      if (err) {
        return callback(err)
      }

      if (blocks && blocks.length > 0) {
        callback(null, blocks[0])
      } else {
        // when a unwant happens
        callback()
      }
    })
  }

  /**
   * Fetch a a list of blocks by cid. If the blocks are in the local
   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.
   *
   * @param {Array<CID>} cids
   * @param {function(Error, Blocks)} callback
   * @returns {void}
   */
  getMany (cids, callback) {
    let pendingStart = cids.length
    const wantList = []
    let promptedNetwork = false

    const getFromOutside = (cid, cb) => {
      wantList.push(cid)

      this.notifications.wantBlock(
        cid,
        // called on block receive
        (block) => {
          this.wm.cancelWants([cid])
          cb(null, block)
        },
        // called on unwant
        () => {
          this.wm.cancelWants([cid])
          cb(null, undefined)
        }
      )

      if (!pendingStart) {
        this.wm.wantBlocks(wantList)
      }
    }

    map(cids, (cid, cb) => {
      waterfall(
        [
          (cb) => this.blockstore.has(cid, cb),
          (has, cb) => {
            pendingStart--
            if (has) {
              if (!pendingStart) {
                this.wm.wantBlocks(wantList)
              }
              return this.blockstore.get(cid, cb)
            }

            if (!promptedNetwork) {
              promptedNetwork = true
              this.network.findAndConnect(cids[0], (err) => {
                if (err) {
                  this._log.error(err)
                }
              })
            }

            // we don't have the block here
            getFromOutside(cid, cb)
          }
        ],
        cb)
    }, callback)
  }

  // removes the given cids from the wantlist independent of any ref counts
  unwant (cids) {
    if (!Array.isArray(cids)) {
      cids = [cids]
    }

    this.wm.unwantBlocks(cids)
    cids.forEach((cid) => this.notifications.unwantBlock(cid))
  }

  // removes the given keys from the want list
  cancelWants (cids) {
    if (!Array.isArray(cids)) {
      cids = [cids]
    }
    this.wm.cancelWants(cids)
  }

  /**
   * Put the given block to the underlying blockstore and
   * send it to nodes that have it in their wantlist.
   *
   * @param {Block} block
   * @param {function(Error)} callback
   * @returns {void}
   */
  put (block, callback) {
    this._log('putting block')

    waterfall([
      (cb) => this.blockstore.has(block.cid, cb),
      (has, cb) => {
        if (has) {
          return nextTick(cb)
        }

        this._putBlock(block, cb)
      }
    ], callback)
  }

  /**
   * Put the given blocks to the underlying blockstore and
   * send it to nodes that have it them their wantlist.
   *
   * @param {Array<Block>} blocks
   * @param {function(Error)} callback
   * @returns {void}
   */
  putMany (blocks, callback) {
    waterfall([
      (cb) => reject(blocks, (b, cb) => {
        this.blockstore.has(b.cid, cb)
      }, cb),
      (newBlocks, cb) => this.blockstore.putMany(newBlocks, (err) => {
        if (err) {
          return cb(err)
        }

        newBlocks.forEach((block) => {
          this.notifications.hasBlock(block)
          this.engine.receivedBlocks([block.cid])
          this.network.provide(block.cid, (err) => {
            if (err) {
              this._log.error('Failed to provide: %s', err.message)
            }
          })
        })
        cb()
      })
    ], callback)
  }

  /**
   * Get the current list of wants.
   *
   * @returns {Iterator<WantlistEntry>}
   */
  getWantlist () {
    return this.wm.wantlist.entries()
  }

  /**
   * Get the current list of partners.
   *
   * @returns {Array<PeerId>}
   */
  peers () {
    return this.engine.peers()
  }

  /**
   * Get stats about the bitswap node.
   *
   * @returns {Object}
   */
  stat () {
    return this._stats
  }

  /**
   * Start the bitswap node.
   *
   * @param {function(Error)} callback
   *
   * @returns {void}
   */
  start (callback) {
    series([
      (cb) => this.wm.start(cb),
      (cb) => this.network.start(cb),
      (cb) => this.engine.start(cb)
    ], callback)
  }

  /**
   * Stop the bitswap node.
   *
   * @param {function(Error)} callback
   *
   * @returns {void}
   */
  stop (callback) {
    this._stats.stop()
    series([
      (cb) => this.wm.stop(cb),
      (cb) => this.network.stop(cb),
      (cb) => this.engine.stop(cb)
    ], callback)
  }
}

module.exports = Bitswap

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/offline-datastore.js", {"../../../../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/utils.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js","libp2p-record":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/offline-datastore.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const { Key } = require('interface-datastore')
const { Record } = require('libp2p-record')
const { encodeBase32 } = require('./utils')

const errcode = require('err-code')
const debug = require('debug')
const log = debug('ipfs:ipns:offline-datastore')
log.error = debug('ipfs:ipns:offline-datastore:error')

// Offline datastore aims to mimic the same encoding as routing when storing records
// to the local datastore
class OfflineDatastore {
  constructor (repo) {
    this._repo = repo
  }

  /**
   * Put a value to the local datastore indexed by the received key properly encoded.
   * @param {Buffer} key identifier of the value.
   * @param {Buffer} value value to be stored.
   * @param {function(Error)} callback
   * @returns {void}
   */
  put (key, value, callback) {
    if (!Buffer.isBuffer(key)) {
      const errMsg = `Offline datastore key must be a buffer`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_KEY'))
    }

    if (!Buffer.isBuffer(value)) {
      const errMsg = `Offline datastore value must be a buffer`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_VALUE'))
    }

    let routingKey

    try {
      routingKey = this._routingKey(key)
    } catch (err) {
      const errMsg = `Not possible to generate the routing key`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_GENERATING_ROUTING_KEY'))
    }

    // Marshal to libp2p record as the DHT does
    const record = new Record(key, value)

    this._repo.datastore.put(routingKey, record.serialize(), callback)
  }

  /**
   * Get a value from the local datastore indexed by the received key properly encoded.
   * @param {Buffer} key identifier of the value to be obtained.
   * @param {function(Error, Buffer)} callback
   * @returns {void}
   */
  get (key, callback) {
    if (!Buffer.isBuffer(key)) {
      const errMsg = `Offline datastore key must be a buffer`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_KEY'))
    }

    let routingKey

    try {
      routingKey = this._routingKey(key)
    } catch (err) {
      const errMsg = `Not possible to generate the routing key`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_GENERATING_ROUTING_KEY'))
    }

    this._repo.datastore.get(routingKey, (err, res) => {
      if (err) {
        return callback(err)
      }

      // Unmarshal libp2p record as the DHT does
      let record
      try {
        record = Record.deserialize(res)
      } catch (err) {
        log.error(err)
        return callback(err)
      }

      callback(null, record.value)
    })
  }

  // encode key properly - base32(/ipns/{cid})
  _routingKey (key) {
    return new Key('/' + encodeBase32(key), false)
  }
}

exports = module.exports = OfflineDatastore

}).call(this)}).call(this,{"isBuffer":require("../../../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/offline-datastore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/utils.js", {"ipns":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/index.js","multibase":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/utils.js
      return function (require, module, exports) {
'use strict'

const multibase = require('multibase')
const ipns = require('ipns')

module.exports = {
  encodeBase32: (buf) => {
    const m = multibase.encode('base32', buf).slice(1) // slice off multibase codec

    return m.toString().toUpperCase() // should be uppercase for interop with go
  },
  validator: {
    func: (key, record, cb) => ipns.validator.validate(record, key, cb)
  },
  selector: (k, records) => ipns.validator.select(records[0], records[1])
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/libp2p-browser.js", {"libp2p":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/index.js","libp2p-bootstrap":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-bootstrap/src/index.js","libp2p-kad-dht":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/index.js","libp2p-secio":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/index.js","libp2p-webrtc-star":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-webrtc-star/src/index.js","libp2p-websocket-star-multi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star-multi/src/index.js","libp2p-websockets":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websockets/src/index.js","merge-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/merge-options/index.js","multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js","pull-mplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/libp2p-browser.js
      return function (require, module, exports) {
'use strict'

const WS = require('libp2p-websockets')
const WebRTCStar = require('libp2p-webrtc-star')
const WebSocketStarMulti = require('libp2p-websocket-star-multi')
const Multiplex = require('pull-mplex')
const SECIO = require('libp2p-secio')
const Bootstrap = require('libp2p-bootstrap')
const KadDHT = require('libp2p-kad-dht')
const libp2p = require('libp2p')
const mergeOptions = require('merge-options')
const multiaddr = require('multiaddr')

class Node extends libp2p {
  constructor (_options) {
    const wrtcstar = new WebRTCStar({ id: _options.peerInfo.id })

    // this can be replaced once optional listening is supported with the below code. ref: https://github.com/libp2p/interface-transport/issues/41
    // const wsstar = new WebSocketStar({ id: _options.peerInfo.id })
    const wsstarServers = _options.peerInfo.multiaddrs.toArray().map(String).filter(addr => addr.includes('p2p-websocket-star'))
    _options.peerInfo.multiaddrs.replace(wsstarServers.map(multiaddr), '/p2p-websocket-star') // the ws-star-multi module will replace this with the chosen ws-star servers
    const wsstar = new WebSocketStarMulti({ servers: wsstarServers, id: _options.peerInfo.id, ignore_no_online: !wsstarServers.length || _options.wsStarIgnoreErrors })

    const defaults = {
      switch: {
        blacklistTTL: 2 * 60 * 1e3, // 2 minute base
        blackListAttempts: 5, // back off 5 times
        maxParallelDials: 100,
        maxColdCalls: 25,
        dialTimeout: 20e3
      },
      modules: {
        transport: [
          WS,
          wrtcstar,
          wsstar
        ],
        streamMuxer: [
          Multiplex
        ],
        connEncryption: [
          SECIO
        ],
        peerDiscovery: [
          wrtcstar.discovery,
          wsstar.discovery,
          Bootstrap
        ],
        dht: KadDHT
      },
      config: {
        peerDiscovery: {
          autoDial: true,
          bootstrap: {
            enabled: true
          },
          webRTCStar: {
            enabled: true
          },
          websocketStar: {
            enabled: true
          }
        },
        dht: {
          enabled: false
        },
        EXPERIMENTAL: {
          pubsub: false
        }
      }
    }

    super(mergeOptions(defaults, _options))
  }
}

module.exports = Node

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/libp2p-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-from-stream.js", {"./add":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-from-stream.js
      return function (require, module, exports) {
'use strict'

module.exports = self => require('./add')(self)

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-from-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-from-url.js", {"../../runtime/fetch-nodejs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/fetch-browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","iso-url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-from-url.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const { URL } = require('iso-url')
const fetch = require('../../runtime/fetch-nodejs')

module.exports = (self) => {
  return async (url, options, callback) => {
    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    let files

    try {
      const parsedUrl = new URL(url)
      const res = await fetch(url)

      if (!res.ok) {
        throw new Error('unexpected status code: ' + res.status)
      }

      // TODO: use res.body when supported
      const content = Buffer.from(await res.arrayBuffer())
      const path = decodeURIComponent(parsedUrl.pathname.split('/').pop())

      files = await self.add({ content, path }, options)
    } catch (err) {
      if (callback) {
        return callback(err)
      }
      throw err
    }

    if (callback) {
      callback(null, files)
    }

    return files
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-from-url.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-readable-stream.js", {"pull-pushable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-pushable/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-readable-stream.js
      return function (require, module, exports) {
'use strict'

const pull = require('pull-stream')
const pushable = require('pull-pushable')
const Duplex = require('readable-stream').Duplex

class AddHelper extends Duplex {
  constructor (pullStream, push, options) {
    super(Object.assign({ objectMode: true }, options))
    this._pullStream = pullStream
    this._pushable = push
    this._waitingPullFlush = []
  }

  _read () {
    this._pullStream(null, (end, data) => {
      while (this._waitingPullFlush.length) {
        const cb = this._waitingPullFlush.shift()
        cb()
      }
      if (end) {
        if (end instanceof Error) {
          this.emit('error', end)
        } else {
          this.push(null)
        }
      } else {
        this.push(data)
      }
    })
  }

  _write (chunk, encoding, callback) {
    this._waitingPullFlush.push(callback)
    this._pushable.push(chunk)
  }
}

module.exports = function (self) {
  return (options) => {
    options = options || {}

    const p = pushable()
    const s = pull(
      p,
      self.addPullStream(options)
    )

    const retStream = new AddHelper(s, p)

    retStream.once('finish', () => p.end())

    return retStream
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-readable-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/cat.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/cat.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const promisify = require('promisify-es6')
const pull = require('pull-stream')

module.exports = function (self) {
  return promisify((ipfsPath, options, callback) => {
    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    pull(
      self.catPullStream(ipfsPath, options),
      pull.collect((err, buffers) => {
        if (err) { return callback(err) }
        callback(null, Buffer.concat(buffers))
      })
    )
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/cat.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/cat-readable-stream.js", {"pull-stream-to-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/cat-readable-stream.js
      return function (require, module, exports) {
'use strict'

const toStream = require('pull-stream-to-stream')

module.exports = function (self) {
  return (ipfsPath, options) => toStream.source(self.catPullStream(ipfsPath, options))
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/cat-readable-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/get.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/get.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const promisify = require('promisify-es6')
const pull = require('pull-stream')

module.exports = function (self) {
  return promisify((ipfsPath, options, callback) => {
    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    options = options || {}

    pull(
      self.getPullStream(ipfsPath, options),
      pull.asyncMap((file, cb) => {
        if (file.content) {
          pull(
            file.content,
            pull.collect((err, buffers) => {
              if (err) { return cb(err) }
              file.content = Buffer.concat(buffers)
              cb(null, file)
            })
          )
        } else {
          cb(null, file)
        }
      }),
      pull.collect(callback)
    )
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/get.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/get-readable-stream.js", {"pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js","pull-stream-to-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/get-readable-stream.js
      return function (require, module, exports) {
'use strict'

const pull = require('pull-stream')
const toStream = require('pull-stream-to-stream')

module.exports = function (self) {
  return (ipfsPath, options) => {
    options = options || {}

    return toStream.source(
      pull(
        self.getPullStream(ipfsPath, options),
        pull.map((file) => {
          if (file.content) {
            file.content = toStream.source(file.content)
            file.content.pause()
          }

          return file
        })
      )
    )
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/get-readable-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/ls.js", {"promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/ls.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')
const pull = require('pull-stream')

module.exports = function (self) {
  return promisify((ipfsPath, options, callback) => {
    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    options = options || {}

    pull(
      self.lsPullStream(ipfsPath, options),
      pull.collect((err, values) => {
        if (err) {
          return callback(err)
        }
        callback(null, values)
      })
    )
  })
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/ls.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/ls-readable-stream.js", {"pull-stream-to-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/ls-readable-stream.js
      return function (require, module, exports) {
'use strict'

const toStream = require('pull-stream-to-stream')

module.exports = function (self) {
  return (ipfsPath, options) => {
    return toStream.source(self.lsPullStream(ipfsPath, options))
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/ls-readable-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs.js", {"promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')
const pull = require('pull-stream')

module.exports = function (self) {
  return promisify((ipfsPath, options, callback) => {
    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    options = options || {}

    pull(
      self.refsPullStream(ipfsPath, options),
      pull.collect((err, values) => {
        if (err) {
          return callback(err)
        }
        callback(null, values)
      })
    )
  })
}

// Preset format strings
module.exports.Format = {
  default: '<dst>',
  edges: '<src> -> <dst>'
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-readable-stream.js", {"pull-stream-to-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-readable-stream.js
      return function (require, module, exports) {
'use strict'

const toStream = require('pull-stream-to-stream')

module.exports = function (self) {
  return (ipfsPath, options) => {
    return toStream.source(self.refsPullStream(ipfsPath, options))
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-readable-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-local.js", {"promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-local.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')
const pull = require('pull-stream')

module.exports = function (self) {
  return promisify((callback) => {
    pull(
      self.refs.localPullStream(),
      pull.collect((err, values) => {
        if (err) {
          return callback(err)
        }
        callback(null, values)
      })
    )
  })
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-local.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-local-readable-stream.js", {"pull-stream-to-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-local-readable-stream.js
      return function (require, module, exports) {
'use strict'

const toStream = require('pull-stream-to-stream')

module.exports = function (self) {
  return (ipfsPath, options) => {
    return toStream.source(self.refs.localPullStream())
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-local-readable-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-local-pull-stream.js", {"base32.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base32.js/base32.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","pull-defer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-local-pull-stream.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const CID = require('cids')
const base32 = require('base32.js')
const pull = require('pull-stream')
const pullDefer = require('pull-defer')

module.exports = function (self) {
  return () => {
    const deferred = pullDefer.source()

    self._repo.blocks.query({ keysOnly: true }, (err, blocks) => {
      if (err) {
        return deferred.resolve(pull.error(err))
      }

      const refs = blocks.map(b => dsKeyToRef(b.key))
      deferred.resolve(pull.values(refs))
    })

    return deferred
  }
}

function dsKeyToRef (key) {
  try {
    // Block key is of the form /<base32 encoded string>
    const decoder = new base32.Decoder()
    const buff = Buffer.from(decoder.write(key.toString().slice(1)).finalize())
    return { ref: new CID(buff).toString() }
  } catch (err) {
    return { err: `Could not convert block with key '${key}' to CID: ${err.message}` }
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-local-pull-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-pull-stream.js", {"./refs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/utils.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js","is-ipfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-ipfs/src/index.js","pull-cat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-cat/index.js","pull-defer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js","pull-traverse":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-traverse/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-pull-stream.js
      return function (require, module, exports) {
'use strict'

const pull = require('pull-stream')
const pullDefer = require('pull-defer')
const pullTraverse = require('pull-traverse')
const pullCat = require('pull-cat')
const isIpfs = require('is-ipfs')
const CID = require('cids')
const { DAGNode } = require('ipld-dag-pb')
const { normalizePath } = require('./utils')
const { Format } = require('./refs')

module.exports = function (self) {
  return function (ipfsPath, options = {}) {
    if (options.maxDepth === 0) {
      return pull.empty()
    }
    if (options.edges && options.format && options.format !== Format.default) {
      return pull.error(new Error('Cannot set edges to true and also specify format'))
    }

    options.format = options.edges ? Format.edges : options.format || Format.default

    if (typeof options.maxDepth !== 'number') {
      options.maxDepth = options.recursive ? Infinity : 1
    }

    let paths
    try {
      const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath]
      paths = rawPaths.map(p => getFullPath(self, p, options))
    } catch (err) {
      return pull.error(err)
    }

    return pullCat(paths.map(p => refsStream(self, p, options)))
  }
}

function getFullPath (ipfs, ipfsPath, options) {
  // normalizePath() strips /ipfs/ off the front of the path so the CID will
  // be at the front of the path
  const path = normalizePath(ipfsPath)
  const pathComponents = path.split('/')
  const cid = pathComponents[0]
  if (!isIpfs.cid(cid)) {
    throw new Error(`Error resolving path '${path}': '${cid}' is not a valid CID`)
  }

  if (options.preload !== false) {
    ipfs._preload(cid)
  }

  return '/ipfs/' + path
}

// Get a stream of refs at the given path
function refsStream (ipfs, path, options) {
  const deferred = pullDefer.source()

  // Resolve to the target CID of the path
  ipfs.resolve(path, (err, resPath) => {
    if (err) {
      return deferred.resolve(pull.error(err))
    }

    // path is /ipfs/<cid>
    const parts = resPath.split('/')
    const cid = parts[2]
    deferred.resolve(pull(
      // Traverse the DAG, converting it into a stream
      objectStream(ipfs, cid, options.maxDepth, options.unique),
      // Root object will not have a parent
      pull.filter(obj => Boolean(obj.parent)),
      // Filter out duplicates (isDuplicate flag is only set if options.unique is set)
      pull.filter(obj => !obj.isDuplicate),
      // Format the links
      pull.map(obj => formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)),
      // Clients expect refs to be in the format { ref: <ref> }
      pull.map(ref => ({ ref }))
    ))
  })

  return deferred
}

// Get formatted link
function formatLink (srcCid, dstCid, linkName, format) {
  let out = format.replace(/<src>/g, srcCid.toString())
  out = out.replace(/<dst>/g, dstCid.toString())
  out = out.replace(/<linkname>/g, linkName)
  return out
}

// Do a depth first search of the DAG, starting from the given root cid
function objectStream (ipfs, rootCid, maxDepth, isUnique) {
  const uniques = new Set()

  const root = { node: { cid: rootCid }, depth: 0 }
  const traverseLevel = (obj) => {
    const { node, depth } = obj

    // Check the depth
    const nextLevelDepth = depth + 1
    if (nextLevelDepth > maxDepth) {
      return pull.empty()
    }

    // If unique option is enabled, check if the CID has been seen before.
    // Note we need to do this here rather than before adding to the stream
    // so that the unique check happens in the order that items are examined
    // in the DAG.
    if (isUnique) {
      if (uniques.has(node.cid.toString())) {
        // Mark this object as a duplicate so we can filter it out later
        obj.isDuplicate = true
        return pull.empty()
      }
      uniques.add(node.cid.toString())
    }

    const deferred = pullDefer.source()

    // Get this object's links
    getLinks(ipfs, node.cid, (err, links) => {
      if (err) {
        if (err.code === 'ERR_NOT_FOUND') {
          err.message = `Could not find object with CID: ${node.cid}`
        }
        return deferred.resolve(pull.error(err))
      }

      // Add to the stream each link, parent and the new depth
      const vals = links.map(link => ({
        parent: node,
        node: link,
        depth: nextLevelDepth
      }))

      deferred.resolve(pull.values(vals))
    })

    return deferred
  }

  return pullTraverse.depthFirst(root, traverseLevel)
}

// Fetch a node from IPLD then get all its links
function getLinks (ipfs, cid, callback) {
  ipfs._ipld.get(new CID(cid))
    .then(node => {
      let links
      if (DAGNode.isDAGNode(node)) {
        links = node.Links.map(({ Name, Hash }) => {
          return { name: Name, cid: new CID(Hash) }
        })
      } else {
        links = getNodeLinks(node)
      }
      callback(null, links)
    })
    .catch(callback)
}

// Recursively search the node for CIDs
function getNodeLinks (node, path = '') {
  let links = []
  for (const [name, value] of Object.entries(node)) {
    if (CID.isCID(value)) {
      links.push({
        name: path + name,
        cid: value
      })
    } else if (typeof value === 'object') {
      links = links.concat(getNodeLinks(value, path + name + '/'))
    }
  }
  return links
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-pull-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-from-fs.js", {"../../runtime/add-from-fs-nodejs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/add-from-fs-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-from-fs.js
      return function (require, module, exports) {
'use strict'

module.exports = (self) => require('../../runtime/add-from-fs-nodejs')(self)

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-from-fs.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/get-pull-stream.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/utils.js","async-iterator-to-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-pull-stream/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipfs-unixfs-exporter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js","pull-stream/throughs/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/map.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/get-pull-stream.js
      return function (require, module, exports) {
'use strict'

const exporter = require('ipfs-unixfs-exporter')
const toPullStream = require('async-iterator-to-pull-stream')
const errCode = require('err-code')
const pull = require('pull-stream/pull')
const map = require('pull-stream/throughs/map')
const { normalizePath, mapFile } = require('./utils')

module.exports = function (self) {
  return (ipfsPath, options) => {
    options = options || {}

    if (options.preload !== false) {
      let pathComponents

      try {
        pathComponents = normalizePath(ipfsPath).split('/')
      } catch (err) {
        return pull.error(errCode(err, 'ERR_INVALID_PATH'))
      }

      self._preload(pathComponents[0])
    }

    return pull(
      toPullStream.source(exporter.recursive(ipfsPath, self._ipld, options)),
      map(mapFile({
        ...options,
        includeContent: true
      }))
    )
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/get-pull-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/ls-pull-stream.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/utils.js","async-iterator-to-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-pull-stream/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipfs-unixfs-exporter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/index.js","pull-defer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js","pull-stream/sources/once":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/once.js","pull-stream/throughs/filter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/filter.js","pull-stream/throughs/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/map.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/ls-pull-stream.js
      return function (require, module, exports) {
'use strict'

const exporter = require('ipfs-unixfs-exporter')
const deferred = require('pull-defer')
const pull = require('pull-stream/pull')
const once = require('pull-stream/sources/once')
const map = require('pull-stream/throughs/map')
const filter = require('pull-stream/throughs/filter')
const errCode = require('err-code')
const toPullStream = require('async-iterator-to-pull-stream')
const { normalizePath, mapFile } = require('./utils')

module.exports = function (self) {
  return function (ipfsPath, options) {
    options = options || {}

    const path = normalizePath(ipfsPath)
    const recursive = options.recursive
    const pathComponents = path.split('/')

    if (options.preload !== false) {
      self._preload(pathComponents[0])
    }

    const d = deferred.source()

    exporter(ipfsPath, self._ipld, options)
      .then(file => {
        if (!file.unixfs) {
          return d.abort(errCode(new Error('dag node was not a UnixFS node'), 'ENOTUNIXFS'))
        }

        if (file.unixfs.type === 'file') {
          return d.resolve(once(mapFile(options)(file)))
        }

        if (file.unixfs.type.includes('dir')) {
          if (recursive) {
            return d.resolve(pull(
              toPullStream.source(exporter.recursive(file.cid, self._ipld, options)),
              filter(child => file.cid.toBaseEncodedString() !== child.cid.toBaseEncodedString()),
              map(mapFile(options))
            ))
          }

          return d.resolve(pull(
            toPullStream.source(file.content()),
            map(mapFile(options)),
            map((file) => {
              file.depth--

              return file
            })
          ))
        }

        d.abort(errCode(new Error(`Unknown UnixFS type ${file.unixfs.type}`), 'EUNKNOWNUNIXFSTYPE'))
      }, err => {
        d.abort(err)
      })

    return d
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/ls-pull-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add.js", {"ipfs-utils/src/files/add-input-validation":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/src/files/add-input-validation.js","is-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-pull-stream/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js","pull-sort":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-sort/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')
const pull = require('pull-stream')
const sort = require('pull-sort')
const isSource = require('is-pull-stream').isSource
const validateAddInput = require('ipfs-utils/src/files/add-input-validation')

module.exports = function (self) {
  const add = promisify((data, options, callback) => {
    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    options = options || {}

    try {
      validateAddInput(data)
    } catch (err) {
      return callback(err)
    }

    pull(
      pull.values([data]),
      self.addPullStream(options),
      sort((a, b) => {
        if (a.path < b.path) return 1
        if (a.path > b.path) return -1
        return 0
      }),
      pull.collect(callback)
    )
  })

  return function () {
    const args = Array.from(arguments)

    // If we .add(<pull stream>), then promisify thinks the pull stream
    // is a callback! Add an empty options object in this case so that a
    // promise is returned.
    if (args.length === 1 && isSource(args[0])) {
      args.push({})
    }

    return add.apply(null, args)
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/cat-pull-stream.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/utils.js","async-iterator-to-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-pull-stream/index.js","ipfs-unixfs-exporter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/index.js","pull-defer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/cat-pull-stream.js
      return function (require, module, exports) {
'use strict'

const exporter = require('ipfs-unixfs-exporter')
const deferred = require('pull-defer')
const toPullStream = require('async-iterator-to-pull-stream')
const { normalizePath } = require('./utils')

module.exports = function (self) {
  return function catPullStream (ipfsPath, options) {
    if (typeof ipfsPath === 'function') {
      throw new Error('You must supply an ipfsPath')
    }

    options = options || {}

    ipfsPath = normalizePath(ipfsPath)
    const pathComponents = ipfsPath.split('/')

    if (options.preload !== false) {
      self._preload(pathComponents[0])
    }

    const d = deferred.source()

    exporter(ipfsPath, self._ipld, options)
      .then(file => {
        // File may not have unixfs prop if small & imported with rawLeaves true
        if (file.unixfs && file.unixfs.type.includes('dir')) {
          return d.abort(new Error('this dag node is a directory'))
        }

        if (!file.content) {
          return d.abort(new Error('this dag node has no content'))
        }

        d.resolve(toPullStream.source(file.content(options)))
      }, err => {
        d.abort(err)
      })

    return d
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/cat-pull-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-pull-stream.js", {"../../../../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/utils.js","async-iterator-to-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-pull-stream/index.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","ipfs-unixfs-importer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/index.js","ipfs-utils/src/streams/stream-from-filereader":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/src/streams/stream-from-filereader.js","ipfs-utils/src/supports":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/src/supports.js","is-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-pull-stream/index.js","is-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/is-stream/index.js","kind-of":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/kind-of/index.js","pull-stream-to-async-iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-async-iterator/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js","pull-stream/sources/values":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/values.js","pull-stream/throughs/async-map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/async-map.js","pull-stream/throughs/flatten":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/flatten.js","pull-stream/throughs/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/map.js","stream-to-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-to-pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-pull-stream.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const importer = require('ipfs-unixfs-importer')
const kindOf = require('kind-of')
const toAsyncIterator = require('pull-stream-to-async-iterator')
const toPullStream = require('async-iterator-to-pull-stream')
const pull = require('pull-stream/pull')
const pullValues = require('pull-stream/sources/values')
const pullMap = require('pull-stream/throughs/map')
const pullAsyncMap = require('pull-stream/throughs/async-map')
const pullFlatten = require('pull-stream/throughs/flatten')
const toPull = require('stream-to-pull-stream')
const waterfall = require('async/waterfall')
const isStream = require('is-stream')
const { isSource } = require('is-pull-stream')
const { parseChunkerString } = require('./utils')
const streamFromFileReader = require('ipfs-utils/src/streams/stream-from-filereader')
const { supportsFileReader } = require('ipfs-utils/src/supports')

function noop () {}

function prepareFile (file, self, opts, callback) {
  opts = opts || {}

  let cid = file.cid

  waterfall([
    (cb) => opts.onlyHash
      ? cb(null, file)
      : self.object.get(file.cid, Object.assign({}, opts, { preload: false }), cb),
    (node, cb) => {
      if (opts.cidVersion === 1) {
        cid = cid.toV1()
      }

      const b58Hash = cid.toBaseEncodedString()
      let size = node.size

      if (Buffer.isBuffer(node)) {
        size = node.length
      }

      cb(null, {
        path: file.path === undefined ? b58Hash : (file.path || ''),
        hash: b58Hash,
        // multihash: b58Hash,
        size
      })
    }
  ], callback)
}

function normalizeContent (content, opts) {
  if (!Array.isArray(content)) {
    content = [content]
  }

  return content.map((data) => {
    if (supportsFileReader && kindOf(data) === 'file') {
      data = { path: '', content: toPull.source(streamFromFileReader(data)) }
    }
    // Buffer input
    if (Buffer.isBuffer(data)) {
      data = { path: '', content: pullValues([data]) }
    }

    // Readable stream input
    if (isStream.readable(data)) {
      data = { path: '', content: toPull.source(data) }
    }

    if (isSource(data)) {
      data = { path: '', content: data }
    }

    if (data && data.content && typeof data.content !== 'function') {
      if (supportsFileReader && kindOf(data.content) === 'file') {
        data = { path: data.path, content: toPull.source(streamFromFileReader(data.content)) }
      }

      if (Buffer.isBuffer(data.content)) {
        data = { path: data.path, content: pullValues([data.content]) }
      }

      if (isStream.readable(data.content)) {
        data = { path: data.path, content: toPull.source(data.content) }
      }
    }

    if (opts.wrapWithDirectory && !data.path) {
      throw new Error('Must provide a path when wrapping with a directory')
    }

    return data
  })
}

function preloadFile (file, self, opts) {
  const isRootFile = !file.path || opts.wrapWithDirectory
    ? file.path === ''
    : !file.path.includes('/')

  const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false

  if (shouldPreload) {
    self._preload(file.hash)
  }

  return file
}

function pinFile (file, self, opts, cb) {
  // Pin a file if it is the root dir of a recursive add or the single file
  // of a direct add.
  const pin = 'pin' in opts ? opts.pin : true
  const isRootDir = !file.path.includes('/')
  const shouldPin = pin && isRootDir && !opts.onlyHash && !opts.hashAlg
  if (shouldPin) {
    return self.pin.add(file.hash, { preload: false }, err => cb(err, file))
  } else {
    cb(null, file)
  }
}

module.exports = function (self) {
  // Internal add func that gets used by all add funcs
  return function addPullStream (options) {
    options = options || {}

    let chunkerOptions
    try {
      chunkerOptions = parseChunkerString(options.chunker)
    } catch (err) {
      return pullMap(() => { throw err })
    }
    const opts = Object.assign({}, {
      shardSplitThreshold: self._options.EXPERIMENTAL.sharding
        ? 1000
        : Infinity
    }, options, {
      chunker: chunkerOptions.chunker,
      chunkerOptions: chunkerOptions.chunkerOptions
    })

    // CID v0 is for multihashes encoded with sha2-256
    if (opts.hashAlg && opts.cidVersion !== 1) {
      opts.cidVersion = 1
    }

    let total = 0

    const prog = opts.progress || noop
    const progress = (bytes) => {
      total += bytes
      prog(total)
    }

    opts.progress = progress
    return pull(
      pullMap(content => normalizeContent(content, opts)),
      pullFlatten(),
      pullMap(file => ({
        path: file.path ? file.path : undefined,
        content: file.content ? toAsyncIterator(file.content) : undefined
      })),
      toPullStream.transform(source => importer(source, self._ipld, opts)),
      pullAsyncMap((file, cb) => prepareFile(file, self, opts, cb)),
      pullMap(file => preloadFile(file, self, opts)),
      pullAsyncMap((file, cb) => pinFile(file, self, opts, cb))
    )
  }
}

}).call(this)}).call(this,{"isBuffer":require("../../../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-pull-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/callbackify/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/callbackify/index.js
      return function (require, module, exports) {
function callbackify(fn) {
  var fnLength = fn.length
  return function () {
    var args = [].slice.call(arguments)
    var ctx = this
    if (args.length === fnLength + 1 &&
        typeof args[fnLength] === 'function') {
      // callback mode
      var cb = args.pop()
      fn.apply(this, args)
        .then(function (val) { cb.call(ctx, null, val) },
          function (err) { cb.call(ctx, err) })
        return
    }
    // promise mode
    return fn.apply(ctx, arguments)
  }
}

function callbackifyVariadic(fn) {
  return function () {
    var args = [].slice.call(arguments)
    var ctx = this
    if (args.length >= 1 &&
        typeof args[args.length - 1] === 'function') {
      // callback mode
      var cb = args.pop()
      fn.apply(this, args)
        .then(function (val) { cb.call(ctx, null, val) },
          function (err) { cb.call(ctx, err) })
        return
    }
    // promise mode
    return fn.apply(ctx, arguments)
  }
}

module.exports = callbackify
module.exports.variadic = callbackifyVariadic;

      };
    };
  }
}, {package:"callbackify",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/callbackify/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-all/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-all/index.js
      return function (require, module, exports) {
'use strict'

const toArray = async (iterator) => {
  const arr = []

  for await (const entry of iterator) {
    arr.push(entry)
  }

  return arr
}

module.exports = toArray

      };
    };
  }
}, {package:"async-iterator-all",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-all/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-pull-stream/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/is-pull-stream/index.js
      return function (require, module, exports) {

function isFunction (f) {
  return 'function' === typeof f
}

function isDuplex (d) {
  return 'object' === typeof d && isSource(d.source) && isSink(d.sink)
}

function isSource (s) {
  return isFunction(s) && s.length === 2
}

function isSink (s) {
  return isFunction(s) && s.length === 1
}

exports.isDuplex = isDuplex
exports.isSource = isSource
exports.isSink = isSink
//can't do is through, it will appear as a sink til you git it a source.


      };
    };
  }
}, {package:"is-pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-pull-stream/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-async-iterator/index.js", {"pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-async-iterator/index.js
      return function (require, module, exports) {
const pull = require('pull-stream/pull')

module.exports = source => {
  return (async function * () {
    let _read

    const sink = read => {
      _read = () => new Promise((resolve, reject) => {
        read(null, (end, data) => {
          if (end === true) return resolve({ end })
          if (end) return reject(end)
          resolve({ data })
        })
      })
    }

    pull(source, sink)

    while (true) {
      const { end, data } = await _read()
      if (end) break
      yield data
    }
  })()
}

      };
    };
  }
}, {package:"pull-stream-to-async-iterator",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-async-iterator/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/map.js", {"../util/prop":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/prop.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/map.js
      return function (require, module, exports) {
'use strict'

function id (e) { return e }
var prop = require('../util/prop')

module.exports = function map (mapper) {
  if(!mapper) return id
  mapper = prop(mapper)
  return function (read) {
    return function (abort, cb) {
      read(abort, function (end, data) {
        try {
        data = !end ? mapper(data) : null
        } catch (err) {
          return read(err, function () {
            return cb(err)
          })
        }
        cb(end, data)
      })
    }
  }
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/map.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/readable-browser.js", {"./lib/_stream_duplex.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_passthrough.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/_stream_readable.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_transform.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_writable.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_writable.js","./lib/internal/streams/end-of-stream.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","./lib/internal/streams/pipeline.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/pipeline.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/readable-browser.js
      return function (require, module, exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/readable-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/dist/index.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/dist/index.js
      return function (require, module, exports) {
(function (process){(function (){
"use strict";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const _require = require("readable-stream"),
      Readable = _require.Readable;

const getSymbol = typeof Symbol === "function" ? name => {
  const symbol = Symbol[name];
  return symbol !== undefined ? symbol : `@@${name}`;
} : name => `@@${name}`;
const $$asyncIterator = asyncIteratorToStream.$$asyncIterator = getSymbol("asyncIterator");
const $$iterator = asyncIteratorToStream.$$iterator = getSymbol("iterator");

const resolveToIterator = value => {
  let tmp;

  if (typeof (tmp = value[$$asyncIterator]) === "function") {
    return tmp.call(value);
  }

  if (typeof (tmp = value[$$iterator]) === "function") {
    return tmp.call(value);
  }

  return value;
};

function asyncIteratorToStream(iterable, options) {
  if (typeof iterable === "function") {
    return function () {
      return asyncIteratorToStream(iterable.apply(this, arguments), options);
    };
  }

  const then = iterable.then;

  if (typeof then === "function") {
    return then.call(iterable, iterable => asyncIteratorToStream(iterable, options));
  }

  const iterator = resolveToIterator(iterable);
  const isGenerator = "return" in iterator;
  const readable = options instanceof Readable ? options : new Readable(options);

  if (isGenerator) {
    readable._destroy = function () {
      var _ref = _asyncToGenerator(function* (error, cb) {
        try {
          yield error != null ? iterator.throw(error) : iterator.return();
        } catch (error) {
          return cb(error);
        }

        cb(error);
      });

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }();
  }

  let running = false;

  readable._read = function () {
    var _ref2 = _asyncToGenerator(function* (size) {
      if (running) {
        return;
      }

      running = true;

      try {
        let value;

        do {
          let cursor = iterator.next(size);

          if (typeof cursor.then === "function") {
            cursor = yield cursor;
          } else {
            while (!cursor.done && (value = cursor.value) != null && typeof value.then === "function") {
              try {
                value = yield value;
              } catch (error) {
                cursor = iterator.throw(error);
                continue;
              }

              cursor = iterator.next(value);
            }
          }

          if (cursor.done) {
            return readable.push(null);
          }

          value = cursor.value;
        } while (value === undefined || readable.push(value));
      } catch (error) {
        process.nextTick(readable.emit.bind(readable, "error", error));
      } finally {
        running = false;
      }
    });

    return function (_x3) {
      return _ref2.apply(this, arguments);
    };
  }();

  return readable;
}

module.exports = asyncIteratorToStream;

asyncIteratorToStream.obj = (iterable, options) => asyncIteratorToStream(iterable, _extends({
  objectMode: true
}, options));

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"async-iterator-to-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/core.js", {"./src/core":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/core.js
      return function (require, module, exports) {
'use strict'

module.exports = require('./src/core')

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/core.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/index.js", {"./permissions":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/index.js","./resource":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/resource/index.js","./services":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/services/index.js","./snaps":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/snaps/index.js","./subject-metadata":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/subject-metadata/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./permissions"), exports);
__exportStar(require("./resource"), exports);
__exportStar(require("./services"), exports);
__exportStar(require("./snaps"), exports);
__exportStar(require("./subject-metadata"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/index.js", {"./BIP44CoinTypeNode":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.js","./BIP44Node":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/BIP44Node.js","./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/constants.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageBuffer = exports.BIP44PurposeNodeToken = exports.MAX_BIP_44_DEPTH = exports.MIN_BIP_44_DEPTH = exports.getBIP44AddressKeyDeriver = exports.deriveBIP44AddressKey = exports.BIP_44_COIN_TYPE_DEPTH = exports.BIP44CoinTypeNode = exports.BIP44Node = void 0;
var BIP44Node_1 = require("./BIP44Node");
Object.defineProperty(exports, "BIP44Node", { enumerable: true, get: function () { return BIP44Node_1.BIP44Node; } });
var BIP44CoinTypeNode_1 = require("./BIP44CoinTypeNode");
Object.defineProperty(exports, "BIP44CoinTypeNode", { enumerable: true, get: function () { return BIP44CoinTypeNode_1.BIP44CoinTypeNode; } });
Object.defineProperty(exports, "BIP_44_COIN_TYPE_DEPTH", { enumerable: true, get: function () { return BIP44CoinTypeNode_1.BIP_44_COIN_TYPE_DEPTH; } });
Object.defineProperty(exports, "deriveBIP44AddressKey", { enumerable: true, get: function () { return BIP44CoinTypeNode_1.deriveBIP44AddressKey; } });
Object.defineProperty(exports, "getBIP44AddressKeyDeriver", { enumerable: true, get: function () { return BIP44CoinTypeNode_1.getBIP44AddressKeyDeriver; } });
var constants_1 = require("./constants");
Object.defineProperty(exports, "MIN_BIP_44_DEPTH", { enumerable: true, get: function () { return constants_1.MIN_BIP_44_DEPTH; } });
Object.defineProperty(exports, "MAX_BIP_44_DEPTH", { enumerable: true, get: function () { return constants_1.MAX_BIP_44_DEPTH; } });
Object.defineProperty(exports, "BIP44PurposeNodeToken", { enumerable: true, get: function () { return constants_1.BIP44PurposeNodeToken; } });
/**
 * The {@link Buffer} accessible to `@metamask/key-tree`, re-exported in case
 * of module resolution issues.
 */
exports.PackageBuffer = Buffer;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/key-tree",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/common/snapInstallation.js", {"../../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/utils.js","@metamask/snap-controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/common/snapInstallation.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleInstallSnaps = exports.preprocessRequestedPermissions = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const snap_controllers_1 = require("@metamask/snap-controllers");
const utils_1 = require("../../utils");
// preprocess requested permissions to support 'wallet_snap' syntactic sugar
function preprocessRequestedPermissions(requestedPermissions) {
    if (!utils_1.isPlainObject(requestedPermissions)) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({ data: { requestedPermissions } });
    }
    // passthrough if 'wallet_snap' is not requested
    if (!requestedPermissions.wallet_snap) {
        return requestedPermissions;
    }
    // rewrite permissions request parameter by destructuring snaps into
    // proper permissions prefixed with 'wallet_snap_'
    return Object.keys(requestedPermissions).reduce((newRequestedPermissions, permName) => {
        if (permName === 'wallet_snap') {
            if (!utils_1.isPlainObject(requestedPermissions[permName])) {
                throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                    message: `Invalid params to 'wallet_requestPermissions'`,
                    data: { requestedPermissions },
                });
            }
            const requestedSnaps = requestedPermissions[permName];
            // destructure 'wallet_snap' object
            Object.keys(requestedSnaps).forEach((snapName) => {
                const snapKey = snap_controllers_1.SNAP_PREFIX + snapName;
                // disallow requesting a snap X under 'wallet_snaps' and
                // directly as 'wallet_snap_X'
                if (requestedPermissions[snapKey]) {
                    throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                        message: `Snap '${snapName}' requested both as direct permission and under 'wallet_snap'. We recommend using 'wallet_snap' only.`,
                        data: { requestedPermissions },
                    });
                }
                newRequestedPermissions[snapKey] = requestedSnaps[snapName];
            });
        }
        else {
            // otherwise, leave things as we found them
            newRequestedPermissions[permName] = requestedPermissions[permName];
        }
        return newRequestedPermissions;
    }, {});
}
exports.preprocessRequestedPermissions = preprocessRequestedPermissions;
/**
 * Typechecks the requested snaps and passes them to the permissions
 * controller for installation.
 */
async function handleInstallSnaps(requestedSnaps, installSnaps) {
    if (!utils_1.isPlainObject(requestedSnaps)) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Invalid snap installation params.`,
            data: { requestedSnaps },
        });
    }
    else if (Object.keys(requestedSnaps).length === 0) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Must specify at least one snap to install.`,
            data: { requestedSnaps },
        });
    }
    // installSnaps is bound to the origin
    return await installSnaps(requestedSnaps);
}
exports.handleInstallSnaps = handleInstallSnaps;
//# sourceMappingURL=snapInstallation.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/common/snapInstallation.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/generated-table.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/generated-table.js
      return function (require, module, exports) {
// DO NOT CHANGE THIS FILE. IT IS GENERATED BY tools/update-table.js
/* eslint quote-props: off */
'use strict'

/**
 * @type {__import__('./generated-types').NameCodeMap}
 */
const baseTable = Object.freeze({
  'identity': 0x00,
  'cidv1': 0x01,
  'cidv2': 0x02,
  'cidv3': 0x03,
  'ip4': 0x04,
  'tcp': 0x06,
  'sha1': 0x11,
  'sha2-256': 0x12,
  'sha2-512': 0x13,
  'sha3-512': 0x14,
  'sha3-384': 0x15,
  'sha3-256': 0x16,
  'sha3-224': 0x17,
  'shake-128': 0x18,
  'shake-256': 0x19,
  'keccak-224': 0x1a,
  'keccak-256': 0x1b,
  'keccak-384': 0x1c,
  'keccak-512': 0x1d,
  'blake3': 0x1e,
  'dccp': 0x21,
  'murmur3-128': 0x22,
  'murmur3-32': 0x23,
  'ip6': 0x29,
  'ip6zone': 0x2a,
  'path': 0x2f,
  'multicodec': 0x30,
  'multihash': 0x31,
  'multiaddr': 0x32,
  'multibase': 0x33,
  'dns': 0x35,
  'dns4': 0x36,
  'dns6': 0x37,
  'dnsaddr': 0x38,
  'protobuf': 0x50,
  'cbor': 0x51,
  'raw': 0x55,
  'dbl-sha2-256': 0x56,
  'rlp': 0x60,
  'bencode': 0x63,
  'dag-pb': 0x70,
  'dag-cbor': 0x71,
  'libp2p-key': 0x72,
  'git-raw': 0x78,
  'torrent-info': 0x7b,
  'torrent-file': 0x7c,
  'leofcoin-block': 0x81,
  'leofcoin-tx': 0x82,
  'leofcoin-pr': 0x83,
  'sctp': 0x84,
  'dag-jose': 0x85,
  'dag-cose': 0x86,
  'eth-block': 0x90,
  'eth-block-list': 0x91,
  'eth-tx-trie': 0x92,
  'eth-tx': 0x93,
  'eth-tx-receipt-trie': 0x94,
  'eth-tx-receipt': 0x95,
  'eth-state-trie': 0x96,
  'eth-account-snapshot': 0x97,
  'eth-storage-trie': 0x98,
  'bitcoin-block': 0xb0,
  'bitcoin-tx': 0xb1,
  'bitcoin-witness-commitment': 0xb2,
  'zcash-block': 0xc0,
  'zcash-tx': 0xc1,
  'docid': 0xce,
  'stellar-block': 0xd0,
  'stellar-tx': 0xd1,
  'md4': 0xd4,
  'md5': 0xd5,
  'bmt': 0xd6,
  'decred-block': 0xe0,
  'decred-tx': 0xe1,
  'ipld-ns': 0xe2,
  'ipfs-ns': 0xe3,
  'swarm-ns': 0xe4,
  'ipns-ns': 0xe5,
  'zeronet': 0xe6,
  'secp256k1-pub': 0xe7,
  'bls12_381-g1-pub': 0xea,
  'bls12_381-g2-pub': 0xeb,
  'x25519-pub': 0xec,
  'ed25519-pub': 0xed,
  'bls12_381-g1g2-pub': 0xee,
  'dash-block': 0xf0,
  'dash-tx': 0xf1,
  'swarm-manifest': 0xfa,
  'swarm-feed': 0xfb,
  'udp': 0x0111,
  'p2p-webrtc-star': 0x0113,
  'p2p-webrtc-direct': 0x0114,
  'p2p-stardust': 0x0115,
  'p2p-circuit': 0x0122,
  'dag-json': 0x0129,
  'udt': 0x012d,
  'utp': 0x012e,
  'unix': 0x0190,
  'thread': 0x0196,
  'p2p': 0x01a5,
  'ipfs': 0x01a5,
  'https': 0x01bb,
  'onion': 0x01bc,
  'onion3': 0x01bd,
  'garlic64': 0x01be,
  'garlic32': 0x01bf,
  'tls': 0x01c0,
  'quic': 0x01cc,
  'ws': 0x01dd,
  'wss': 0x01de,
  'p2p-websocket-star': 0x01df,
  'http': 0x01e0,
  'json': 0x0200,
  'messagepack': 0x0201,
  'libp2p-peer-record': 0x0301,
  'sha2-256-trunc254-padded': 0x1012,
  'ripemd-128': 0x1052,
  'ripemd-160': 0x1053,
  'ripemd-256': 0x1054,
  'ripemd-320': 0x1055,
  'x11': 0x1100,
  'p256-pub': 0x1200,
  'p384-pub': 0x1201,
  'p521-pub': 0x1202,
  'ed448-pub': 0x1203,
  'x448-pub': 0x1204,
  'ed25519-priv': 0x1300,
  'kangarootwelve': 0x1d01,
  'sm3-256': 0x534d,
  'blake2b-8': 0xb201,
  'blake2b-16': 0xb202,
  'blake2b-24': 0xb203,
  'blake2b-32': 0xb204,
  'blake2b-40': 0xb205,
  'blake2b-48': 0xb206,
  'blake2b-56': 0xb207,
  'blake2b-64': 0xb208,
  'blake2b-72': 0xb209,
  'blake2b-80': 0xb20a,
  'blake2b-88': 0xb20b,
  'blake2b-96': 0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8': 0xb241,
  'blake2s-16': 0xb242,
  'blake2s-24': 0xb243,
  'blake2s-32': 0xb244,
  'blake2s-40': 0xb245,
  'blake2s-48': 0xb246,
  'blake2s-56': 0xb247,
  'blake2s-64': 0xb248,
  'blake2s-72': 0xb249,
  'blake2s-80': 0xb24a,
  'blake2s-88': 0xb24b,
  'blake2s-96': 0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'skein256-8': 0xb301,
  'skein256-16': 0xb302,
  'skein256-24': 0xb303,
  'skein256-32': 0xb304,
  'skein256-40': 0xb305,
  'skein256-48': 0xb306,
  'skein256-56': 0xb307,
  'skein256-64': 0xb308,
  'skein256-72': 0xb309,
  'skein256-80': 0xb30a,
  'skein256-88': 0xb30b,
  'skein256-96': 0xb30c,
  'skein256-104': 0xb30d,
  'skein256-112': 0xb30e,
  'skein256-120': 0xb30f,
  'skein256-128': 0xb310,
  'skein256-136': 0xb311,
  'skein256-144': 0xb312,
  'skein256-152': 0xb313,
  'skein256-160': 0xb314,
  'skein256-168': 0xb315,
  'skein256-176': 0xb316,
  'skein256-184': 0xb317,
  'skein256-192': 0xb318,
  'skein256-200': 0xb319,
  'skein256-208': 0xb31a,
  'skein256-216': 0xb31b,
  'skein256-224': 0xb31c,
  'skein256-232': 0xb31d,
  'skein256-240': 0xb31e,
  'skein256-248': 0xb31f,
  'skein256-256': 0xb320,
  'skein512-8': 0xb321,
  'skein512-16': 0xb322,
  'skein512-24': 0xb323,
  'skein512-32': 0xb324,
  'skein512-40': 0xb325,
  'skein512-48': 0xb326,
  'skein512-56': 0xb327,
  'skein512-64': 0xb328,
  'skein512-72': 0xb329,
  'skein512-80': 0xb32a,
  'skein512-88': 0xb32b,
  'skein512-96': 0xb32c,
  'skein512-104': 0xb32d,
  'skein512-112': 0xb32e,
  'skein512-120': 0xb32f,
  'skein512-128': 0xb330,
  'skein512-136': 0xb331,
  'skein512-144': 0xb332,
  'skein512-152': 0xb333,
  'skein512-160': 0xb334,
  'skein512-168': 0xb335,
  'skein512-176': 0xb336,
  'skein512-184': 0xb337,
  'skein512-192': 0xb338,
  'skein512-200': 0xb339,
  'skein512-208': 0xb33a,
  'skein512-216': 0xb33b,
  'skein512-224': 0xb33c,
  'skein512-232': 0xb33d,
  'skein512-240': 0xb33e,
  'skein512-248': 0xb33f,
  'skein512-256': 0xb340,
  'skein512-264': 0xb341,
  'skein512-272': 0xb342,
  'skein512-280': 0xb343,
  'skein512-288': 0xb344,
  'skein512-296': 0xb345,
  'skein512-304': 0xb346,
  'skein512-312': 0xb347,
  'skein512-320': 0xb348,
  'skein512-328': 0xb349,
  'skein512-336': 0xb34a,
  'skein512-344': 0xb34b,
  'skein512-352': 0xb34c,
  'skein512-360': 0xb34d,
  'skein512-368': 0xb34e,
  'skein512-376': 0xb34f,
  'skein512-384': 0xb350,
  'skein512-392': 0xb351,
  'skein512-400': 0xb352,
  'skein512-408': 0xb353,
  'skein512-416': 0xb354,
  'skein512-424': 0xb355,
  'skein512-432': 0xb356,
  'skein512-440': 0xb357,
  'skein512-448': 0xb358,
  'skein512-456': 0xb359,
  'skein512-464': 0xb35a,
  'skein512-472': 0xb35b,
  'skein512-480': 0xb35c,
  'skein512-488': 0xb35d,
  'skein512-496': 0xb35e,
  'skein512-504': 0xb35f,
  'skein512-512': 0xb360,
  'skein1024-8': 0xb361,
  'skein1024-16': 0xb362,
  'skein1024-24': 0xb363,
  'skein1024-32': 0xb364,
  'skein1024-40': 0xb365,
  'skein1024-48': 0xb366,
  'skein1024-56': 0xb367,
  'skein1024-64': 0xb368,
  'skein1024-72': 0xb369,
  'skein1024-80': 0xb36a,
  'skein1024-88': 0xb36b,
  'skein1024-96': 0xb36c,
  'skein1024-104': 0xb36d,
  'skein1024-112': 0xb36e,
  'skein1024-120': 0xb36f,
  'skein1024-128': 0xb370,
  'skein1024-136': 0xb371,
  'skein1024-144': 0xb372,
  'skein1024-152': 0xb373,
  'skein1024-160': 0xb374,
  'skein1024-168': 0xb375,
  'skein1024-176': 0xb376,
  'skein1024-184': 0xb377,
  'skein1024-192': 0xb378,
  'skein1024-200': 0xb379,
  'skein1024-208': 0xb37a,
  'skein1024-216': 0xb37b,
  'skein1024-224': 0xb37c,
  'skein1024-232': 0xb37d,
  'skein1024-240': 0xb37e,
  'skein1024-248': 0xb37f,
  'skein1024-256': 0xb380,
  'skein1024-264': 0xb381,
  'skein1024-272': 0xb382,
  'skein1024-280': 0xb383,
  'skein1024-288': 0xb384,
  'skein1024-296': 0xb385,
  'skein1024-304': 0xb386,
  'skein1024-312': 0xb387,
  'skein1024-320': 0xb388,
  'skein1024-328': 0xb389,
  'skein1024-336': 0xb38a,
  'skein1024-344': 0xb38b,
  'skein1024-352': 0xb38c,
  'skein1024-360': 0xb38d,
  'skein1024-368': 0xb38e,
  'skein1024-376': 0xb38f,
  'skein1024-384': 0xb390,
  'skein1024-392': 0xb391,
  'skein1024-400': 0xb392,
  'skein1024-408': 0xb393,
  'skein1024-416': 0xb394,
  'skein1024-424': 0xb395,
  'skein1024-432': 0xb396,
  'skein1024-440': 0xb397,
  'skein1024-448': 0xb398,
  'skein1024-456': 0xb399,
  'skein1024-464': 0xb39a,
  'skein1024-472': 0xb39b,
  'skein1024-480': 0xb39c,
  'skein1024-488': 0xb39d,
  'skein1024-496': 0xb39e,
  'skein1024-504': 0xb39f,
  'skein1024-512': 0xb3a0,
  'skein1024-520': 0xb3a1,
  'skein1024-528': 0xb3a2,
  'skein1024-536': 0xb3a3,
  'skein1024-544': 0xb3a4,
  'skein1024-552': 0xb3a5,
  'skein1024-560': 0xb3a6,
  'skein1024-568': 0xb3a7,
  'skein1024-576': 0xb3a8,
  'skein1024-584': 0xb3a9,
  'skein1024-592': 0xb3aa,
  'skein1024-600': 0xb3ab,
  'skein1024-608': 0xb3ac,
  'skein1024-616': 0xb3ad,
  'skein1024-624': 0xb3ae,
  'skein1024-632': 0xb3af,
  'skein1024-640': 0xb3b0,
  'skein1024-648': 0xb3b1,
  'skein1024-656': 0xb3b2,
  'skein1024-664': 0xb3b3,
  'skein1024-672': 0xb3b4,
  'skein1024-680': 0xb3b5,
  'skein1024-688': 0xb3b6,
  'skein1024-696': 0xb3b7,
  'skein1024-704': 0xb3b8,
  'skein1024-712': 0xb3b9,
  'skein1024-720': 0xb3ba,
  'skein1024-728': 0xb3bb,
  'skein1024-736': 0xb3bc,
  'skein1024-744': 0xb3bd,
  'skein1024-752': 0xb3be,
  'skein1024-760': 0xb3bf,
  'skein1024-768': 0xb3c0,
  'skein1024-776': 0xb3c1,
  'skein1024-784': 0xb3c2,
  'skein1024-792': 0xb3c3,
  'skein1024-800': 0xb3c4,
  'skein1024-808': 0xb3c5,
  'skein1024-816': 0xb3c6,
  'skein1024-824': 0xb3c7,
  'skein1024-832': 0xb3c8,
  'skein1024-840': 0xb3c9,
  'skein1024-848': 0xb3ca,
  'skein1024-856': 0xb3cb,
  'skein1024-864': 0xb3cc,
  'skein1024-872': 0xb3cd,
  'skein1024-880': 0xb3ce,
  'skein1024-888': 0xb3cf,
  'skein1024-896': 0xb3d0,
  'skein1024-904': 0xb3d1,
  'skein1024-912': 0xb3d2,
  'skein1024-920': 0xb3d3,
  'skein1024-928': 0xb3d4,
  'skein1024-936': 0xb3d5,
  'skein1024-944': 0xb3d6,
  'skein1024-952': 0xb3d7,
  'skein1024-960': 0xb3d8,
  'skein1024-968': 0xb3d9,
  'skein1024-976': 0xb3da,
  'skein1024-984': 0xb3db,
  'skein1024-992': 0xb3dc,
  'skein1024-1000': 0xb3dd,
  'skein1024-1008': 0xb3de,
  'skein1024-1016': 0xb3df,
  'skein1024-1024': 0xb3e0,
  'poseidon-bls12_381-a2-fc1': 0xb401,
  'poseidon-bls12_381-a2-fc1-sc': 0xb402,
  'zeroxcert-imprint-256': 0xce11,
  'fil-commitment-unsealed': 0xf101,
  'fil-commitment-sealed': 0xf102,
  'holochain-adr-v0': 0x807124,
  'holochain-adr-v1': 0x817124,
  'holochain-key-v0': 0x947124,
  'holochain-key-v1': 0x957124,
  'holochain-sig-v0': 0xa27124,
  'holochain-sig-v1': 0xa37124,
  'skynet-ns': 0xb19910
})

module.exports = { baseTable }

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/generated-table.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/decode.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/decode.js
      return function (require, module, exports) {
module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l || shift > 49) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}

      };
    };
  }
}, {package:"varint",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/decode.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/encode.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/encode.js
      return function (require, module, exports) {
module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode.bytes = 0
    throw new RangeError('Could not encode varint')
  }
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}

      };
    };
  }
}, {package:"varint",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/encode.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/length.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/length.js
      return function (require, module, exports) {

var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}

      };
    };
  }
}, {package:"varint",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/length.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/rfc4648.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/rfc4648.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./types').CodecFactory} CodecFactory */

/**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {Uint8Array}
 */
const decode = (string, alphabet, bitsPerChar) => {
  // Build the character lookup table:
  /** @type {Record<string, number>} */
  const codes = {}
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i
  }

  // Count the padding bytes:
  let end = string.length
  while (string[end - 1] === '=') {
    --end
  }

  // Allocate the output:
  const out = new Uint8Array((end * bitsPerChar / 8) | 0)

  // Parse the data:
  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  let written = 0 // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]]
    if (value === undefined) {
      throw new SyntaxError('Invalid character ' + string[i])
    }

    // Append the bits to the buffer:
    buffer = (buffer << bitsPerChar) | value
    bits += bitsPerChar

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8
      out[written++] = 0xff & (buffer >> bits)
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
    throw new SyntaxError('Unexpected end of data')
  }

  return out
}

/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '='
  const mask = (1 << bitsPerChar) - 1
  let out = ''

  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = (buffer << 8) | data[i]
    bits += 8

    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar
      out += alphabet[mask & (buffer >> bits)]
    }
  }

  // Partial character:
  if (bits) {
    out += alphabet[mask & (buffer << (bitsPerChar - bits))]
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar) & 7) {
      out += '='
    }
  }

  return out
}

/**
 * RFC4648 Factory
 *
 * @param {number} bitsPerChar
 * @returns {CodecFactory}
 */
const rfc4648 = (bitsPerChar) => (alphabet) => {
  return {
    /**
     * @param {Uint8Array} input
     * @returns {string}
     */
    encode (input) {
      return encode(input, alphabet, bitsPerChar)
    },
    /**
     * @param {string} input
     * @returns {Uint8Array}
     */
    decode (input) {
      return decode(input, alphabet, bitsPerChar)
    }
  }
}

module.exports = { rfc4648 }

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/rfc4648.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/base.js", {"./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/base.js
      return function (require, module, exports) {
'use strict'

const { encodeText } = require('./util')

/** @typedef {__import__('./types').CodecFactory} CodecFactory */
/** @typedef {__import__("./types").BaseName} BaseName */
/** @typedef {__import__("./types").BaseCode} BaseCode */

/**
 * Class to encode/decode in the supported Bases
 *
 */
class Base {
  /**
   * @param {BaseName} name
   * @param {BaseCode} code
   * @param {CodecFactory} factory
   * @param {string} alphabet
   */
  constructor (name, code, factory, alphabet) {
    this.name = name
    this.code = code
    this.codeBuf = encodeText(this.code)
    this.alphabet = alphabet
    this.codec = factory(alphabet)
  }

  /**
   * @param {Uint8Array} buf
   * @returns {string}
   */
  encode (buf) {
    return this.codec.encode(buf)
  }

  /**
   * @param {string} string
   * @returns {Uint8Array}
   */
  decode (string) {
    for (const char of string) {
      if (this.alphabet && this.alphabet.indexOf(char) < 0) {
        throw new Error(`invalid character '${char}' in '${string}'`)
      }
    }
    return this.codec.decode(string)
  }
}

module.exports = Base

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/base.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@multiformats/base-x/src/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@multiformats/base-x/src/index.js
      return function (require, module, exports) {
'use strict'
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256)
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i)
    var xc = x.charCodeAt(0)
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i
  }
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)
  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
  function encode (source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source)
    }
    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0
    var length = 0
    var pbegin = 0
    var pend = source.length
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++
      zeroes++
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
    var b58 = new Uint8Array(size)
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin]
            // Apply "b58 = b58 * 256 + ch".
      var i = 0
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0
        b58[it1] = (carry % BASE) >>> 0
        carry = (carry / BASE) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      pbegin++
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length
    while (it2 !== size && b58[it2] === 0) {
      it2++
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes)
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return new Uint8Array() }
    var psz = 0
        // Skip leading spaces.
    if (source[psz] === ' ') { return }
        // Skip and count leading '1's.
    var zeroes = 0
    var length = 0
    while (source[psz] === LEADER) {
      zeroes++
      psz++
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size)
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)]
            // Invalid character
      if (carry === 255) { return }
      var i = 0
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0
        b256[it3] = (carry % 256) >>> 0
        carry = (carry / 256) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      psz++
    }
        // Skip trailing spaces.
    if (source[psz] === ' ') { return }
        // Skip leading zeroes in b256.
    var it4 = size - length
    while (it4 !== size && b256[it4] === 0) {
      it4++
    }
    var vch = new Uint8Array(zeroes + (size - it4))
    var j = zeroes
    while (it4 !== size) {
      vch[j++] = b256[it4++]
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
module.exports = base

      };
    };
  }
}, {package:"@multiformats/base-x",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@multiformats/base-x/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/rfc4648.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/rfc4648.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./types').CodecFactory} CodecFactory */

/**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {Uint8Array}
 */
const decode = (string, alphabet, bitsPerChar) => {
  // Build the character lookup table:
  /** @type {Record<string, number>} */
  const codes = {}
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i
  }

  // Count the padding bytes:
  let end = string.length
  while (string[end - 1] === '=') {
    --end
  }

  // Allocate the output:
  const out = new Uint8Array((end * bitsPerChar / 8) | 0)

  // Parse the data:
  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  let written = 0 // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]]
    if (value === undefined) {
      throw new SyntaxError('Invalid character ' + string[i])
    }

    // Append the bits to the buffer:
    buffer = (buffer << bitsPerChar) | value
    bits += bitsPerChar

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8
      out[written++] = 0xff & (buffer >> bits)
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
    throw new SyntaxError('Unexpected end of data')
  }

  return out
}

/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '='
  const mask = (1 << bitsPerChar) - 1
  let out = ''

  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = (buffer << 8) | data[i]
    bits += 8

    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar
      out += alphabet[mask & (buffer >> bits)]
    }
  }

  // Partial character:
  if (bits) {
    out += alphabet[mask & (buffer << (bitsPerChar - bits))]
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar) & 7) {
      out += '='
    }
  }

  return out
}

/**
 * RFC4648 Factory
 *
 * @param {number} bitsPerChar
 * @returns {CodecFactory}
 */
const rfc4648 = (bitsPerChar) => (alphabet) => {
  return {
    /**
     * @param {Uint8Array} input
     * @returns {string}
     */
    encode (input) {
      return encode(input, alphabet, bitsPerChar)
    },
    /**
     * @param {string} input
     * @returns {Uint8Array}
     */
    decode (input) {
      return decode(input, alphabet, bitsPerChar)
    }
  }
}

module.exports = { rfc4648 }

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/rfc4648.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/base.js", {"./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/base.js
      return function (require, module, exports) {
'use strict'

const { encodeText } = require('./util')

/** @typedef {__import__('./types').CodecFactory} CodecFactory */
/** @typedef {__import__("./types").BaseName} BaseName */
/** @typedef {__import__("./types").BaseCode} BaseCode */

/**
 * Class to encode/decode in the supported Bases
 *
 */
class Base {
  /**
   * @param {BaseName} name
   * @param {BaseCode} code
   * @param {CodecFactory} factory
   * @param {string} alphabet
   */
  constructor (name, code, factory, alphabet) {
    this.name = name
    this.code = code
    this.codeBuf = encodeText(this.code)
    this.alphabet = alphabet
    this.codec = factory(alphabet)
  }

  /**
   * @param {Uint8Array} buf
   * @returns {string}
   */
  encode (buf) {
    return this.codec.encode(buf)
  }

  /**
   * @param {string} string
   * @returns {Uint8Array}
   */
  decode (string) {
    for (const char of string) {
      if (this.alphabet && this.alphabet.indexOf(char) < 0) {
        throw new Error(`invalid character '${char}' in '${string}'`)
      }
    }
    return this.codec.decode(string)
  }
}

module.exports = Base

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/base.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/util.js", {"web-encoding":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/web-encoding/src/lib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/util.js
      return function (require, module, exports) {
'use strict'

// @ts-ignore
const { TextEncoder, TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
/**
 * @param {ArrayBufferView|ArrayBuffer} bytes
 * @returns {string}
 */
const decodeText = (bytes) => textDecoder.decode(bytes)

const textEncoder = new TextEncoder()
/**
 * @param {string} text
 * @returns {Uint8Array}
 */
const encodeText = (text) => textEncoder.encode(text)

/**
 * Returns a new Uint8Array created by concatenating the passed Arrays
 *
 * @param {Array<ArrayLike<number>>} arrs
 * @param {number} length
 * @returns {Uint8Array}
 */
function concat (arrs, length) {
  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrs) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = { decodeText, encodeText, concat }

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/package.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/package.json
      return function (require, module, exports) {
module.exports={
  "name": "axios",
  "version": "0.21.4",
  "description": "Promise based HTTP client for the browser and node.js",
  "main": "index.js",
  "scripts": {
    "test": "grunt test",
    "start": "node ./sandbox/server.js",
    "build": "NODE_ENV=production grunt build",
    "preversion": "npm test",
    "version": "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
    "postversion": "git push && git push --tags",
    "examples": "node ./examples/server.js",
    "coveralls": "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
    "fix": "eslint --fix lib/**/*.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/axios/axios.git"
  },
  "keywords": [
    "xhr",
    "http",
    "ajax",
    "promise",
    "node"
  ],
  "author": "Matt Zabriskie",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/axios/axios/issues"
  },
  "homepage": "https://axios-http.com",
  "devDependencies": {
    "coveralls": "^3.0.0",
    "es6-promise": "^4.2.4",
    "grunt": "^1.3.0",
    "grunt-banner": "^0.6.0",
    "grunt-cli": "^1.2.0",
    "grunt-contrib-clean": "^1.1.0",
    "grunt-contrib-watch": "^1.0.0",
    "grunt-eslint": "^23.0.0",
    "grunt-karma": "^4.0.0",
    "grunt-mocha-test": "^0.13.3",
    "grunt-ts": "^6.0.0-beta.19",
    "grunt-webpack": "^4.0.2",
    "istanbul-instrumenter-loader": "^1.0.0",
    "jasmine-core": "^2.4.1",
    "karma": "^6.3.2",
    "karma-chrome-launcher": "^3.1.0",
    "karma-firefox-launcher": "^2.1.0",
    "karma-jasmine": "^1.1.1",
    "karma-jasmine-ajax": "^0.1.13",
    "karma-safari-launcher": "^1.0.0",
    "karma-sauce-launcher": "^4.3.6",
    "karma-sinon": "^1.0.5",
    "karma-sourcemap-loader": "^0.3.8",
    "karma-webpack": "^4.0.2",
    "load-grunt-tasks": "^3.5.2",
    "minimist": "^1.2.0",
    "mocha": "^8.2.1",
    "sinon": "^4.5.0",
    "terser-webpack-plugin": "^4.2.3",
    "typescript": "^4.0.5",
    "url-search-params": "^0.10.0",
    "webpack": "^4.44.2",
    "webpack-dev-server": "^3.11.0"
  },
  "browser": {
    "./lib/adapters/http.js": "./lib/adapters/xhr.js"
  },
  "jsdelivr": "dist/axios.min.js",
  "unpkg": "dist/axios.min.js",
  "typings": "./index.d.ts",
  "dependencies": {
    "follow-redirects": "^1.14.0"
  },
  "bundlesize": [
    {
      "path": "./dist/axios.min.js",
      "threshold": "5kB"
    }
  ]
}

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/package.json",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/transformData.js", {"./../defaults":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/defaults.js","./../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/transformData.js
      return function (require, module, exports) {
'use strict';

var utils = require('./../utils');
var defaults = require('./../defaults');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/transformData.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/cookies.js", {"./../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/cookies.js
      return function (require, module, exports) {
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/cookies.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/parseHeaders.js", {"./../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/parseHeaders.js
      return function (require, module, exports) {
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/parseHeaders.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/isURLSameOrigin.js", {"./../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/isURLSameOrigin.js
      return function (require, module, exports) {
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/isURLSameOrigin.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/settle.js", {"./createError":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/createError.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/settle.js
      return function (require, module, exports) {
'use strict';

var createError = require('./createError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/settle.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/createError.js", {"./enhanceError":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/enhanceError.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/createError.js
      return function (require, module, exports) {
'use strict';

var enhanceError = require('./enhanceError');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/createError.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/buildFullPath.js", {"../helpers/combineURLs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/combineURLs.js","../helpers/isAbsoluteURL":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/isAbsoluteURL.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/buildFullPath.js
      return function (require, module, exports) {
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');
var combineURLs = require('../helpers/combineURLs');

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/buildFullPath.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/keccak-state-unroll.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/keccak-state-unroll.js
      return function (require, module, exports) {
'use strict'
var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]

exports.p1600 = function (s) {
  for (var round = 0; round < 24; ++round) {
    // theta
    var lo0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40]
    var hi0 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41]
    var lo1 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42]
    var hi1 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43]
    var lo2 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44]
    var hi2 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45]
    var lo3 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46]
    var hi3 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47]
    var lo4 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48]
    var hi4 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49]

    var lo = lo4 ^ (lo1 << 1 | hi1 >>> 31)
    var hi = hi4 ^ (hi1 << 1 | lo1 >>> 31)
    var t1slo0 = s[0] ^ lo
    var t1shi0 = s[1] ^ hi
    var t1slo5 = s[10] ^ lo
    var t1shi5 = s[11] ^ hi
    var t1slo10 = s[20] ^ lo
    var t1shi10 = s[21] ^ hi
    var t1slo15 = s[30] ^ lo
    var t1shi15 = s[31] ^ hi
    var t1slo20 = s[40] ^ lo
    var t1shi20 = s[41] ^ hi
    lo = lo0 ^ (lo2 << 1 | hi2 >>> 31)
    hi = hi0 ^ (hi2 << 1 | lo2 >>> 31)
    var t1slo1 = s[2] ^ lo
    var t1shi1 = s[3] ^ hi
    var t1slo6 = s[12] ^ lo
    var t1shi6 = s[13] ^ hi
    var t1slo11 = s[22] ^ lo
    var t1shi11 = s[23] ^ hi
    var t1slo16 = s[32] ^ lo
    var t1shi16 = s[33] ^ hi
    var t1slo21 = s[42] ^ lo
    var t1shi21 = s[43] ^ hi
    lo = lo1 ^ (lo3 << 1 | hi3 >>> 31)
    hi = hi1 ^ (hi3 << 1 | lo3 >>> 31)
    var t1slo2 = s[4] ^ lo
    var t1shi2 = s[5] ^ hi
    var t1slo7 = s[14] ^ lo
    var t1shi7 = s[15] ^ hi
    var t1slo12 = s[24] ^ lo
    var t1shi12 = s[25] ^ hi
    var t1slo17 = s[34] ^ lo
    var t1shi17 = s[35] ^ hi
    var t1slo22 = s[44] ^ lo
    var t1shi22 = s[45] ^ hi
    lo = lo2 ^ (lo4 << 1 | hi4 >>> 31)
    hi = hi2 ^ (hi4 << 1 | lo4 >>> 31)
    var t1slo3 = s[6] ^ lo
    var t1shi3 = s[7] ^ hi
    var t1slo8 = s[16] ^ lo
    var t1shi8 = s[17] ^ hi
    var t1slo13 = s[26] ^ lo
    var t1shi13 = s[27] ^ hi
    var t1slo18 = s[36] ^ lo
    var t1shi18 = s[37] ^ hi
    var t1slo23 = s[46] ^ lo
    var t1shi23 = s[47] ^ hi
    lo = lo3 ^ (lo0 << 1 | hi0 >>> 31)
    hi = hi3 ^ (hi0 << 1 | lo0 >>> 31)
    var t1slo4 = s[8] ^ lo
    var t1shi4 = s[9] ^ hi
    var t1slo9 = s[18] ^ lo
    var t1shi9 = s[19] ^ hi
    var t1slo14 = s[28] ^ lo
    var t1shi14 = s[29] ^ hi
    var t1slo19 = s[38] ^ lo
    var t1shi19 = s[39] ^ hi
    var t1slo24 = s[48] ^ lo
    var t1shi24 = s[49] ^ hi

    // rho & pi
    var t2slo0 = t1slo0
    var t2shi0 = t1shi0
    var t2slo16 = (t1shi5 << 4 | t1slo5 >>> 28)
    var t2shi16 = (t1slo5 << 4 | t1shi5 >>> 28)
    var t2slo7 = (t1slo10 << 3 | t1shi10 >>> 29)
    var t2shi7 = (t1shi10 << 3 | t1slo10 >>> 29)
    var t2slo23 = (t1shi15 << 9 | t1slo15 >>> 23)
    var t2shi23 = (t1slo15 << 9 | t1shi15 >>> 23)
    var t2slo14 = (t1slo20 << 18 | t1shi20 >>> 14)
    var t2shi14 = (t1shi20 << 18 | t1slo20 >>> 14)
    var t2slo10 = (t1slo1 << 1 | t1shi1 >>> 31)
    var t2shi10 = (t1shi1 << 1 | t1slo1 >>> 31)
    var t2slo1 = (t1shi6 << 12 | t1slo6 >>> 20)
    var t2shi1 = (t1slo6 << 12 | t1shi6 >>> 20)
    var t2slo17 = (t1slo11 << 10 | t1shi11 >>> 22)
    var t2shi17 = (t1shi11 << 10 | t1slo11 >>> 22)
    var t2slo8 = (t1shi16 << 13 | t1slo16 >>> 19)
    var t2shi8 = (t1slo16 << 13 | t1shi16 >>> 19)
    var t2slo24 = (t1slo21 << 2 | t1shi21 >>> 30)
    var t2shi24 = (t1shi21 << 2 | t1slo21 >>> 30)
    var t2slo20 = (t1shi2 << 30 | t1slo2 >>> 2)
    var t2shi20 = (t1slo2 << 30 | t1shi2 >>> 2)
    var t2slo11 = (t1slo7 << 6 | t1shi7 >>> 26)
    var t2shi11 = (t1shi7 << 6 | t1slo7 >>> 26)
    var t2slo2 = (t1shi12 << 11 | t1slo12 >>> 21)
    var t2shi2 = (t1slo12 << 11 | t1shi12 >>> 21)
    var t2slo18 = (t1slo17 << 15 | t1shi17 >>> 17)
    var t2shi18 = (t1shi17 << 15 | t1slo17 >>> 17)
    var t2slo9 = (t1shi22 << 29 | t1slo22 >>> 3)
    var t2shi9 = (t1slo22 << 29 | t1shi22 >>> 3)
    var t2slo5 = (t1slo3 << 28 | t1shi3 >>> 4)
    var t2shi5 = (t1shi3 << 28 | t1slo3 >>> 4)
    var t2slo21 = (t1shi8 << 23 | t1slo8 >>> 9)
    var t2shi21 = (t1slo8 << 23 | t1shi8 >>> 9)
    var t2slo12 = (t1slo13 << 25 | t1shi13 >>> 7)
    var t2shi12 = (t1shi13 << 25 | t1slo13 >>> 7)
    var t2slo3 = (t1slo18 << 21 | t1shi18 >>> 11)
    var t2shi3 = (t1shi18 << 21 | t1slo18 >>> 11)
    var t2slo19 = (t1shi23 << 24 | t1slo23 >>> 8)
    var t2shi19 = (t1slo23 << 24 | t1shi23 >>> 8)
    var t2slo15 = (t1slo4 << 27 | t1shi4 >>> 5)
    var t2shi15 = (t1shi4 << 27 | t1slo4 >>> 5)
    var t2slo6 = (t1slo9 << 20 | t1shi9 >>> 12)
    var t2shi6 = (t1shi9 << 20 | t1slo9 >>> 12)
    var t2slo22 = (t1shi14 << 7 | t1slo14 >>> 25)
    var t2shi22 = (t1slo14 << 7 | t1shi14 >>> 25)
    var t2slo13 = (t1slo19 << 8 | t1shi19 >>> 24)
    var t2shi13 = (t1shi19 << 8 | t1slo19 >>> 24)
    var t2slo4 = (t1slo24 << 14 | t1shi24 >>> 18)
    var t2shi4 = (t1shi24 << 14 | t1slo24 >>> 18)

    // chi
    s[0] = t2slo0 ^ (~t2slo1 & t2slo2)
    s[1] = t2shi0 ^ (~t2shi1 & t2shi2)
    s[10] = t2slo5 ^ (~t2slo6 & t2slo7)
    s[11] = t2shi5 ^ (~t2shi6 & t2shi7)
    s[20] = t2slo10 ^ (~t2slo11 & t2slo12)
    s[21] = t2shi10 ^ (~t2shi11 & t2shi12)
    s[30] = t2slo15 ^ (~t2slo16 & t2slo17)
    s[31] = t2shi15 ^ (~t2shi16 & t2shi17)
    s[40] = t2slo20 ^ (~t2slo21 & t2slo22)
    s[41] = t2shi20 ^ (~t2shi21 & t2shi22)
    s[2] = t2slo1 ^ (~t2slo2 & t2slo3)
    s[3] = t2shi1 ^ (~t2shi2 & t2shi3)
    s[12] = t2slo6 ^ (~t2slo7 & t2slo8)
    s[13] = t2shi6 ^ (~t2shi7 & t2shi8)
    s[22] = t2slo11 ^ (~t2slo12 & t2slo13)
    s[23] = t2shi11 ^ (~t2shi12 & t2shi13)
    s[32] = t2slo16 ^ (~t2slo17 & t2slo18)
    s[33] = t2shi16 ^ (~t2shi17 & t2shi18)
    s[42] = t2slo21 ^ (~t2slo22 & t2slo23)
    s[43] = t2shi21 ^ (~t2shi22 & t2shi23)
    s[4] = t2slo2 ^ (~t2slo3 & t2slo4)
    s[5] = t2shi2 ^ (~t2shi3 & t2shi4)
    s[14] = t2slo7 ^ (~t2slo8 & t2slo9)
    s[15] = t2shi7 ^ (~t2shi8 & t2shi9)
    s[24] = t2slo12 ^ (~t2slo13 & t2slo14)
    s[25] = t2shi12 ^ (~t2shi13 & t2shi14)
    s[34] = t2slo17 ^ (~t2slo18 & t2slo19)
    s[35] = t2shi17 ^ (~t2shi18 & t2shi19)
    s[44] = t2slo22 ^ (~t2slo23 & t2slo24)
    s[45] = t2shi22 ^ (~t2shi23 & t2shi24)
    s[6] = t2slo3 ^ (~t2slo4 & t2slo0)
    s[7] = t2shi3 ^ (~t2shi4 & t2shi0)
    s[16] = t2slo8 ^ (~t2slo9 & t2slo5)
    s[17] = t2shi8 ^ (~t2shi9 & t2shi5)
    s[26] = t2slo13 ^ (~t2slo14 & t2slo10)
    s[27] = t2shi13 ^ (~t2shi14 & t2shi10)
    s[36] = t2slo18 ^ (~t2slo19 & t2slo15)
    s[37] = t2shi18 ^ (~t2shi19 & t2shi15)
    s[46] = t2slo23 ^ (~t2slo24 & t2slo20)
    s[47] = t2shi23 ^ (~t2shi24 & t2shi20)
    s[8] = t2slo4 ^ (~t2slo0 & t2slo1)
    s[9] = t2shi4 ^ (~t2shi0 & t2shi1)
    s[18] = t2slo9 ^ (~t2slo5 & t2slo6)
    s[19] = t2shi9 ^ (~t2shi5 & t2shi6)
    s[28] = t2slo14 ^ (~t2slo10 & t2slo11)
    s[29] = t2shi14 ^ (~t2shi10 & t2shi11)
    s[38] = t2slo19 ^ (~t2slo15 & t2slo16)
    s[39] = t2shi19 ^ (~t2shi15 & t2shi16)
    s[48] = t2slo24 ^ (~t2slo20 & t2slo21)
    s[49] = t2shi24 ^ (~t2shi20 & t2shi21)

    // iota
    s[0] ^= P1600_ROUND_CONSTANTS[round * 2]
    s[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1]
  }
}

      };
    };
  }
}, {package:"keccak",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/keccak-state-unroll.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/api/keccak.js", {"inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js","stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/api/keccak.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var inherits = require('inherits')

module.exports = function (KeccakState) {
  function Keccak (rate, capacity, delimitedSuffix, hashBitLength, options) {
    Transform.call(this, options)

    this._rate = rate
    this._capacity = capacity
    this._delimitedSuffix = delimitedSuffix
    this._hashBitLength = hashBitLength
    this._options = options

    this._state = new KeccakState()
    this._state.initialize(rate, capacity)
    this._finalized = false
  }

  inherits(Keccak, Transform)

  Keccak.prototype._transform = function (chunk, encoding, callback) {
    var error = null
    try {
      this.update(chunk, encoding)
    } catch (err) {
      error = err
    }

    callback(error)
  }

  Keccak.prototype._flush = function (callback) {
    var error = null
    try {
      this.push(this.digest())
    } catch (err) {
      error = err
    }

    callback(error)
  }

  Keccak.prototype.update = function (data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
    if (this._finalized) throw new Error('Digest already called')
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

    this._state.absorb(data)

    return this
  }

  Keccak.prototype.digest = function (encoding) {
    if (this._finalized) throw new Error('Digest already called')
    this._finalized = true

    if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix)
    var digest = this._state.squeeze(this._hashBitLength / 8)
    if (encoding !== undefined) digest = digest.toString(encoding)

    this._resetState()

    return digest
  }

  // remove result from memory
  Keccak.prototype._resetState = function () {
    this._state.initialize(this._rate, this._capacity)
    return this
  }

  // because sometimes we need hash right now and little later
  Keccak.prototype._clone = function () {
    var clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options)
    this._state.copy(clone._state)
    clone._finalized = this._finalized

    return clone
  }

  return Keccak
}

      };
    };
  }
}, {package:"keccak",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/api/keccak.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/api/shake.js", {"inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js","stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/api/shake.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var inherits = require('inherits')

module.exports = function (KeccakState) {
  function Shake (rate, capacity, delimitedSuffix, options) {
    Transform.call(this, options)

    this._rate = rate
    this._capacity = capacity
    this._delimitedSuffix = delimitedSuffix
    this._options = options

    this._state = new KeccakState()
    this._state.initialize(rate, capacity)
    this._finalized = false
  }

  inherits(Shake, Transform)

  Shake.prototype._transform = function (chunk, encoding, callback) {
    var error = null
    try {
      this.update(chunk, encoding)
    } catch (err) {
      error = err
    }

    callback(error)
  }

  Shake.prototype._flush = function () {}

  Shake.prototype._read = function (size) {
    this.push(this.squeeze(size))
  }

  Shake.prototype.update = function (data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
    if (this._finalized) throw new Error('Squeeze already called')
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

    this._state.absorb(data)

    return this
  }

  Shake.prototype.squeeze = function (dataByteLength, encoding) {
    if (!this._finalized) {
      this._finalized = true
      this._state.absorbLastFewBits(this._delimitedSuffix)
    }

    var data = this._state.squeeze(dataByteLength)
    if (encoding !== undefined) data = data.toString(encoding)

    return data
  }

  Shake.prototype._resetState = function () {
    this._state.initialize(this._rate, this._capacity)
    return this
  }

  Shake.prototype._clone = function () {
    var clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options)
    this._state.copy(clone._state)
    clone._finalized = this._finalized

    return clone
  }

  return Shake
}

      };
    };
  }
}, {package:"keccak",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/api/shake.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js", {"bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;
var BN = require("bn.js");
/**
 * The max integer that this VM can handle
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);
/**
 * 2^256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);
/**
 * Keccak-256 hash of null
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
/**
 * Keccak-256 hash of null
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
/**
 * Keccak-256 of an RLP of an empty array
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
/**
 * Keccak-256 of an RLP of an empty array
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
/**
 * Keccak-256 hash of the RLP of null
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
/**
 * Keccak-256 hash of the RLP of null
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js", {"./bytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js","./hash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js","./secp256k1v3-adapter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js","bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
var secp256k1 = require('./secp256k1v3-adapter');
var BN = require("bn.js");
var bytes_1 = require("./bytes");
var hash_1 = require("./hash");
/**
 * Returns the ECDSA signature of a message hash.
 */
exports.ecsign = function (msgHash, privateKey, chainId) {
    var sig = secp256k1.sign(msgHash, privateKey);
    var recovery = sig.recovery;
    var ret = {
        r: sig.signature.slice(0, 32),
        s: sig.signature.slice(32, 64),
        v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27,
    };
    return ret;
};
/**
 * ECDSA public key recovery from signature.
 * @returns Recovered public key
 */
exports.ecrecover = function (msgHash, v, r, s, chainId) {
    var signature = Buffer.concat([bytes_1.setLength(r, 32), bytes_1.setLength(s, 32)], 64);
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
    return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};
/**
 * Convert signature parameters into the format of `eth_sign` RPC method.
 * @returns Signature
 */
exports.toRpcSig = function (v, r, s, chainId) {
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
    return bytes_1.bufferToHex(Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32), bytes_1.toBuffer(v)]));
};
/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 */
exports.fromRpcSig = function (sig) {
    var buf = bytes_1.toBuffer(sig);
    // NOTE: with potential introduction of chainId this might need to be updated
    if (buf.length !== 65) {
        throw new Error('Invalid signature length');
    }
    var v = buf[64];
    // support both versions of `eth_sign` responses
    if (v < 27) {
        v += 27;
    }
    return {
        v: v,
        r: buf.slice(0, 32),
        s: buf.slice(32, 64),
    };
};
/**
 * Validate a ECDSA signature.
 * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one
 */
exports.isValidSignature = function (v, r, s, homesteadOrLater, chainId) {
    if (homesteadOrLater === void 0) { homesteadOrLater = true; }
    var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
    var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);
    if (r.length !== 32 || s.length !== 32) {
        return false;
    }
    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
    }
    var rBN = new BN(r);
    var sBN = new BN(s);
    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
        return false;
    }
    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
    }
    return true;
};
/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 */
exports.hashPersonalMessage = function (message) {
    var prefix = Buffer.from("\u0019Ethereum Signed Message:\n" + message.length.toString(), 'utf-8');
    return hash_1.keccak(Buffer.concat([prefix, message]));
};
function calculateSigRecovery(v, chainId) {
    return chainId ? v - (2 * chainId + 35) : v - 27;
}
function isValidSigRecovery(recovery) {
    return recovery === 0 || recovery === 1;
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js", {"./bytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js","./hash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js","./secp256k1v3-adapter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethjs-util/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;
var assert = require('assert');
var ethjsUtil = require('ethjs-util');
var secp256k1 = require('./secp256k1v3-adapter');
var BN = require("bn.js");
var bytes_1 = require("./bytes");
var hash_1 = require("./hash");
/**
 * Returns a zero address.
 */
exports.zeroAddress = function () {
    var addressLength = 20;
    var addr = bytes_1.zeros(addressLength);
    return bytes_1.bufferToHex(addr);
};
/**
 * Checks if the address is a valid. Accepts checksummed addresses too.
 */
exports.isValidAddress = function (address) {
    return /^0x[0-9a-fA-F]{40}$/.test(address);
};
/**
 * Checks if a given address is a zero address.
 */
exports.isZeroAddress = function (address) {
    var zeroAddr = exports.zeroAddress();
    return zeroAddr === bytes_1.addHexPrefix(address);
};
/**
 * Returns a checksummed address.
 *
 * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This
 * has the effect of checksummed addresses for one chain having invalid checksums for others.
 * For more details, consult EIP-1191.
 *
 * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly
 * used variation in Ethereum was without the chainId. This may change in the future.
 */
exports.toChecksumAddress = function (address, eip1191ChainId) {
    address = ethjsUtil.stripHexPrefix(address).toLowerCase();
    var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';
    var hash = hash_1.keccak(prefix + address).toString('hex');
    var ret = '0x';
    for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
            ret += address[i].toUpperCase();
        }
        else {
            ret += address[i];
        }
    }
    return ret;
};
/**
 * Checks if the address is a valid checksummed address.
 *
 * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.
 */
exports.isValidChecksumAddress = function (address, eip1191ChainId) {
    return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;
};
/**
 * Generates an address of a newly created contract.
 * @param from The address which is creating this new address
 * @param nonce The nonce of the from account
 */
exports.generateAddress = function (from, nonce) {
    from = bytes_1.toBuffer(from);
    var nonceBN = new BN(nonce);
    if (nonceBN.isZero()) {
        // in RLP we want to encode null in the case of zero nonce
        // read the RLP documentation for an answer if you dare
        return hash_1.rlphash([from, null]).slice(-20);
    }
    // Only take the lower 160bits of the hash
    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);
};
/**
 * Generates an address for a contract created using CREATE2.
 * @param from The address which is creating this new address
 * @param salt A salt
 * @param initCode The init code of the contract being created
 */
exports.generateAddress2 = function (from, salt, initCode) {
    var fromBuf = bytes_1.toBuffer(from);
    var saltBuf = bytes_1.toBuffer(salt);
    var initCodeBuf = bytes_1.toBuffer(initCode);
    assert(fromBuf.length === 20);
    assert(saltBuf.length === 32);
    var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));
    return address.slice(-20);
};
/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium).
 */
exports.isPrecompiled = function (address) {
    var a = bytes_1.unpad(address);
    return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};
/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 */
exports.isValidPrivate = function (privateKey) {
    return secp256k1.privateKeyVerify(privateKey);
};
/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param sanitize Accept public keys in other formats
 */
exports.isValidPublic = function (publicKey, sanitize) {
    if (sanitize === void 0) { sanitize = false; }
    if (publicKey.length === 64) {
        // Convert to SEC1 for secp256k1
        return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
    }
    if (!sanitize) {
        return false;
    }
    return secp256k1.publicKeyVerify(publicKey);
};
/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param sanitize Accept public keys in other formats
 */
exports.pubToAddress = function (pubKey, sanitize) {
    if (sanitize === void 0) { sanitize = false; }
    pubKey = bytes_1.toBuffer(pubKey);
    if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
    }
    assert(pubKey.length === 64);
    // Only take the lower 160bits of the hash
    return hash_1.keccak(pubKey).slice(-20);
};
exports.publicToAddress = exports.pubToAddress;
/**
 * Returns the ethereum address of a given private key.
 * @param privateKey A private key must be 256 bits wide
 */
exports.privateToAddress = function (privateKey) {
    return exports.publicToAddress(exports.privateToPublic(privateKey));
};
/**
 * Returns the ethereum public key of a given private key.
 * @param privateKey A private key must be 256 bits wide
 */
exports.privateToPublic = function (privateKey) {
    privateKey = bytes_1.toBuffer(privateKey);
    // skip the type flag and use the X, Y points
    return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};
/**
 * Converts a public key to the Ethereum format.
 */
exports.importPublic = function (publicKey) {
    publicKey = bytes_1.toBuffer(publicKey);
    if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
    }
    return publicKey;
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js", {"bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethjs-util/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.stripZeros = exports.unpad = exports.setLengthRight = exports.setLength = exports.setLengthLeft = exports.zeros = void 0;
var ethjsUtil = require('ethjs-util');
var BN = require("bn.js");
/**
 * Returns a buffer filled with 0s.
 * @param bytes the number of bytes the buffer should be
 */
exports.zeros = function (bytes) {
    return Buffer.allocUnsafe(bytes).fill(0);
};
/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param msg the value to pad (Buffer|Array)
 * @param length the number of bytes the output should be
 * @param right whether to start padding form the left or right
 * @return (Buffer|Array)
 */
exports.setLengthLeft = function (msg, length, right) {
    if (right === void 0) { right = false; }
    var buf = exports.zeros(length);
    msg = exports.toBuffer(msg);
    if (right) {
        if (msg.length < length) {
            msg.copy(buf);
            return buf;
        }
        return msg.slice(0, length);
    }
    else {
        if (msg.length < length) {
            msg.copy(buf, length - msg.length);
            return buf;
        }
        return msg.slice(-length);
    }
};
exports.setLength = exports.setLengthLeft;
/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param msg the value to pad (Buffer|Array)
 * @param length the number of bytes the output should be
 * @return (Buffer|Array)
 */
exports.setLengthRight = function (msg, length) {
    return exports.setLength(msg, length, true);
};
/**
 * Trims leading zeros from a `Buffer` or an `Array`.
 * @param a (Buffer|Array|String)
 * @return (Buffer|Array|String)
 */
exports.unpad = function (a) {
    a = ethjsUtil.stripHexPrefix(a);
    var first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
};
exports.stripZeros = exports.unpad;
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param v the value
 */
exports.toBuffer = function (v) {
    if (!Buffer.isBuffer(v)) {
        if (Array.isArray(v)) {
            v = Buffer.from(v);
        }
        else if (typeof v === 'string') {
            if (ethjsUtil.isHexString(v)) {
                v = Buffer.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(v)), 'hex');
            }
            else {
                throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v);
            }
        }
        else if (typeof v === 'number') {
            v = ethjsUtil.intToBuffer(v);
        }
        else if (v === null || v === undefined) {
            v = Buffer.allocUnsafe(0);
        }
        else if (BN.isBN(v)) {
            v = v.toArrayLike(Buffer);
        }
        else if (v.toArray) {
            // converts a BN to a Buffer
            v = Buffer.from(v.toArray());
        }
        else {
            throw new Error('invalid type');
        }
    }
    return v;
};
/**
 * Converts a `Buffer` to a `Number`.
 * @param buf `Buffer` object to convert
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
    return new BN(exports.toBuffer(buf)).toNumber();
};
/**
 * Converts a `Buffer` into a `0x`-prefixed hex `String`.
 * @param buf `Buffer` object to convert
 */
exports.bufferToHex = function (buf) {
    buf = exports.toBuffer(buf);
    return '0x' + buf.toString('hex');
};
/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param num Signed integer value
 */
exports.fromSigned = function (num) {
    return new BN(num).fromTwos(256);
};
/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param num
 */
exports.toUnsigned = function (num) {
    return Buffer.from(num.toTwos(256).toArray());
};
/**
 * Adds "0x" to a given `String` if it does not already start with "0x".
 */
exports.addHexPrefix = function (str) {
    if (typeof str !== 'string') {
        return str;
    }
    return ethjsUtil.isHexPrefixed(str) ? str : '0x' + str;
};
/**
 * Converts a `Buffer` or `Array` to JSON.
 * @param ba (Buffer|Array)
 * @return (Array|String|null)
 */
exports.baToJSON = function (ba) {
    if (Buffer.isBuffer(ba)) {
        return "0x" + ba.toString('hex');
    }
    else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
            array.push(exports.baToJSON(ba[i]));
        }
        return array;
    }
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js", {"./bytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethjs-util/lib/index.js","rlp":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/rlp/dist.browser/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineProperties = void 0;
var assert = require('assert');
var ethjsUtil = require('ethjs-util');
var rlp = require("rlp");
var bytes_1 = require("./bytes");
/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param self the `Object` to define properties on
 * @param fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param data data to be validated against the definitions
 * @deprecated
 */
exports.defineProperties = function (self, fields, data) {
    self.raw = [];
    self._fields = [];
    // attach the `toJSON`
    self.toJSON = function (label) {
        if (label === void 0) { label = false; }
        if (label) {
            var obj_1 = {};
            self._fields.forEach(function (field) {
                obj_1[field] = "0x" + self[field].toString('hex');
            });
            return obj_1;
        }
        return bytes_1.baToJSON(self.raw);
    };
    self.serialize = function serialize() {
        return rlp.encode(self.raw);
    };
    fields.forEach(function (field, i) {
        self._fields.push(field.name);
        function getter() {
            return self.raw[i];
        }
        function setter(v) {
            v = bytes_1.toBuffer(v);
            if (v.toString('hex') === '00' && !field.allowZero) {
                v = Buffer.allocUnsafe(0);
            }
            if (field.allowLess && field.length) {
                v = bytes_1.stripZeros(v);
                assert(field.length >= v.length, "The field " + field.name + " must not have more " + field.length + " bytes");
            }
            else if (!(field.allowZero && v.length === 0) && field.length) {
                assert(field.length === v.length, "The field " + field.name + " must have byte length of " + field.length);
            }
            self.raw[i] = v;
        }
        Object.defineProperty(self, field.name, {
            enumerable: true,
            configurable: true,
            get: getter,
            set: setter,
        });
        if (field.default) {
            self[field.name] = field.default;
        }
        // attach alias
        if (field.alias) {
            Object.defineProperty(self, field.alias, {
                enumerable: false,
                configurable: true,
                set: setter,
                get: getter,
            });
        }
    });
    // if the constuctor is passed data
    if (data) {
        if (typeof data === 'string') {
            data = Buffer.from(ethjsUtil.stripHexPrefix(data), 'hex');
        }
        if (Buffer.isBuffer(data)) {
            data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
            if (data.length > self._fields.length) {
                throw new Error('wrong number of fields in data');
            }
            // make sure all the items are buffers
            data.forEach(function (d, i) {
                self[self._fields[i]] = bytes_1.toBuffer(d);
            });
        }
        else if (typeof data === 'object') {
            var keys_1 = Object.keys(data);
            fields.forEach(function (field) {
                if (keys_1.indexOf(field.name) !== -1)
                    self[field.name] = data[field.name];
                if (keys_1.indexOf(field.alias) !== -1)
                    self[field.alias] = data[field.alias];
            });
        }
        else {
            throw new Error('invalid data');
        }
    }
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js", {"./bytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","create-hash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/create-hash/browser.js","ethereum-cryptography/keccak":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereum-cryptography/keccak.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethjs-util/lib/index.js","rlp":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/rlp/dist.browser/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rlphash = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.keccak = void 0;
var _a = require('ethereum-cryptography/keccak'), keccak224 = _a.keccak224, keccak384 = _a.keccak384, k256 = _a.keccak256, keccak512 = _a.keccak512;
var createHash = require('create-hash');
var ethjsUtil = require('ethjs-util');
var rlp = require("rlp");
var bytes_1 = require("./bytes");
/**
 * Creates Keccak hash of the input
 * @param a The input data (Buffer|Array|String|Number) If the string is a 0x-prefixed hex value
 * it's interpreted as hexadecimal, otherwise as utf8.
 * @param bits The Keccak width
 */
exports.keccak = function (a, bits) {
    if (bits === void 0) { bits = 256; }
    if (typeof a === 'string' && !ethjsUtil.isHexString(a)) {
        a = Buffer.from(a, 'utf8');
    }
    else {
        a = bytes_1.toBuffer(a);
    }
    if (!bits)
        bits = 256;
    switch (bits) {
        case 224: {
            return keccak224(a);
        }
        case 256: {
            return k256(a);
        }
        case 384: {
            return keccak384(a);
        }
        case 512: {
            return keccak512(a);
        }
        default: {
            throw new Error("Invald algorithm: keccak" + bits);
        }
    }
};
/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256).
 * @param a The input data (Buffer|Array|String|Number)
 */
exports.keccak256 = function (a) {
    return exports.keccak(a);
};
/**
 * Creates SHA256 hash of the input.
 * @param a The input data (Buffer|Array|String|Number)
 */
exports.sha256 = function (a) {
    a = bytes_1.toBuffer(a);
    return createHash('sha256')
        .update(a)
        .digest();
};
/**
 * Creates RIPEMD160 hash of the input.
 * @param a The input data (Buffer|Array|String|Number)
 * @param padded Whether it should be padded to 256 bits or not
 */
exports.ripemd160 = function (a, padded) {
    a = bytes_1.toBuffer(a);
    var hash = createHash('rmd160')
        .update(a)
        .digest();
    if (padded === true) {
        return bytes_1.setLength(hash, 32);
    }
    else {
        return hash;
    }
};
/**
 * Creates SHA-3 hash of the RLP encoded version of the input.
 * @param a The input data
 */
exports.rlphash = function (a) {
    return exports.keccak(rlp.encode(a));
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js", {"./secp256k1v3-lib/der":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js","./secp256k1v3-lib/index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethereum-cryptography/secp256k1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereum-cryptography/secp256k1.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;
var secp256k1 = require('ethereum-cryptography/secp256k1');
var secp256k1v3 = require('./secp256k1v3-lib/index');
var der = require('./secp256k1v3-lib/der');
/**
 * Verify an ECDSA privateKey
 * @method privateKeyVerify
 * @param {Buffer} privateKey
 * @return {boolean}
 */
exports.privateKeyVerify = function (privateKey) {
    // secp256k1 v4 version throws when privateKey length is not 32
    if (privateKey.length !== 32) {
        return false;
    }
    return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
};
/**
 * Export a privateKey in DER format
 * @method privateKeyExport
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {boolean}
 */
exports.privateKeyExport = function (privateKey, compressed) {
    // secp256k1 v4 version throws when privateKey length is not 32
    if (privateKey.length !== 32) {
        throw new RangeError('private key length is invalid');
    }
    var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
    return der.privateKeyExport(privateKey, publicKey, compressed);
};
/**
 * Import a privateKey in DER format
 * @method privateKeyImport
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyImport = function (privateKey) {
    // privateKeyImport method is not part of secp256k1 v4 package
    // this implementation is based on v3
    privateKey = der.privateKeyImport(privateKey);
    if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {
        return privateKey;
    }
    throw new Error("couldn't import from DER format");
};
/**
 * Negate a privateKey by subtracting it from the order of the curve's base point
 * @method privateKeyNegate
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyNegate = function (privateKey) {
    return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
};
/**
 * Compute the inverse of a privateKey (modulo the order of the curve's base point).
 * @method privateKeyModInverse
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyModInverse = function (privateKey) {
    if (privateKey.length !== 32) {
        throw new Error('private key length is invalid');
    }
    return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};
/**
 * Tweak a privateKey by adding tweak to it.
 * @method privateKeyTweakAdd
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
exports.privateKeyTweakAdd = function (privateKey, tweak) {
    return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};
/**
 * Tweak a privateKey by multiplying it by a tweak.
 * @method privateKeyTweakMul
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
exports.privateKeyTweakMul = function (privateKey, tweak) {
    return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};
/**
 * Compute the public key for a privateKey.
 * @method publicKeyCreate
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyCreate = function (privateKey, compressed) {
    return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};
/**
 * Convert a publicKey to compressed or uncompressed form.
 * @method publicKeyConvert
 * @param {Buffer} publicKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyConvert = function (publicKey, compressed) {
    return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};
/**
 * Verify an ECDSA publicKey.
 * @method publicKeyVerify
 * @param {Buffer} publicKey
 * @return {boolean}
 */
exports.publicKeyVerify = function (publicKey) {
    // secp256k1 v4 version throws when publicKey length is not 33 or 65
    if (publicKey.length !== 33 && publicKey.length !== 65) {
        return false;
    }
    return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
};
/**
 * Tweak a publicKey by adding tweak times the generator to it.
 * @method publicKeyTweakAdd
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
    return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};
/**
 * Tweak a publicKey by multiplying it by a tweak value
 * @method publicKeyTweakMul
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
    return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};
/**
 * Add a given publicKeys together.
 * @method publicKeyCombine
 * @param {Array<Buffer>} publicKeys
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyCombine = function (publicKeys, compressed) {
    var keys = [];
    publicKeys.forEach(function (publicKey) {
        keys.push(Uint8Array.from(publicKey));
    });
    return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
};
/**
 * Convert a signature to a normalized lower-S form.
 * @method signatureNormalize
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureNormalize = function (signature) {
    return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
};
/**
 * Serialize an ECDSA signature in DER format.
 * @method signatureExport
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureExport = function (signature) {
    return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
};
/**
 * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImport
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureImport = function (signature) {
    return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
};
/**
 * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImportLax
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureImportLax = function (signature) {
    // signatureImportLax method is not part of secp256k1 v4 package
    // this implementation is based on v3
    // ensure that signature is greater than 0
    if (signature.length === 0) {
        throw new RangeError('signature length is invalid');
    }
    var sigObj = der.signatureImportLax(signature);
    if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
    }
    return secp256k1v3.signatureImport(sigObj);
};
/**
 * Create an ECDSA signature. Always return low-S signature.
 * @method sign
 * @param {Buffer} message
 * @param {Buffer} privateKey
 * @param {Object} options
 * @return {Buffer}
 */
exports.sign = function (message, privateKey, options) {
    if (options === null) {
        throw new TypeError('options should be an Object');
    }
    var signOptions = undefined;
    if (options) {
        signOptions = {};
        if (options.data === null) {
            // validate option.data length
            throw new TypeError('options.data should be a Buffer');
        }
        if (options.data) {
            if (options.data.length != 32) {
                throw new RangeError('options.data length is invalid');
            }
            signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
            throw new TypeError('options.noncefn should be a Function');
        }
        if (options.noncefn) {
            // convert option.noncefn function signature
            signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
                var bufferAlgo = algo != null ? Buffer.from(algo) : null;
                var bufferData = data != null ? Buffer.from(data) : null;
                var buffer = Buffer.from('');
                if (options.noncefn) {
                    buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);
                }
                return new Uint8Array(buffer);
            };
        }
    }
    var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
    return {
        signature: Buffer.from(sig.signature),
        recovery: sig.recid,
    };
};
/**
 * Verify an ECDSA signature.
 * @method verify
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Buffer} publicKey
 * @return {boolean}
 */
exports.verify = function (message, signature, publicKey) {
    return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
};
/**
 * Recover an ECDSA public key from a signature.
 * @method recover
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Number} recid
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.recover = function (message, signature, recid, compressed) {
    return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
};
/**
 * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
 * @method ecdh
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.ecdh = function (publicKey, privateKey) {
    // note: secp256k1 v3 doesn't allow optional parameter
    return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};
exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
    // ecdhUnsafe method is not part of secp256k1 v4 package
    // this implementation is based on v3
    // ensure valid publicKey length
    if (publicKey.length !== 33 && publicKey.length !== 65) {
        throw new RangeError('public key length is invalid');
    }
    // ensure valid privateKey length
    if (privateKey.length !== 32) {
        throw new RangeError('private key length is invalid');
    }
    return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/utilities.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/utilities.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.p2 = void 0;
// 32-bit powers of two wouldn't be possible with <<
exports.p2 = [];
for (var i = 0; i < 32; i++)
    exports.p2[i] = Math.pow(2, i);

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/utilities.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/constants.js", {"bignumber.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/node_modules/bignumber.js/bignumber.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/constants.js
      return function (require, module, exports) {
'use strict'

const Bignumber = require('bignumber.js').BigNumber

exports.MT = {
  POS_INT: 0,
  NEG_INT: 1,
  BYTE_STRING: 2,
  UTF8_STRING: 3,
  ARRAY: 4,
  MAP: 5,
  TAG: 6,
  SIMPLE_FLOAT: 7
}

exports.TAG = {
  DATE_STRING: 0,
  DATE_EPOCH: 1,
  POS_BIGINT: 2,
  NEG_BIGINT: 3,
  DECIMAL_FRAC: 4,
  BIGFLOAT: 5,
  BASE64URL_EXPECTED: 21,
  BASE64_EXPECTED: 22,
  BASE16_EXPECTED: 23,
  CBOR: 24,
  URI: 32,
  BASE64URL: 33,
  BASE64: 34,
  REGEXP: 35,
  MIME: 36
}

exports.NUMBYTES = {
  ZERO: 0,
  ONE: 24,
  TWO: 25,
  FOUR: 26,
  EIGHT: 27,
  INDEFINITE: 31
}

exports.SIMPLE = {
  FALSE: 20,
  TRUE: 21,
  NULL: 22,
  UNDEFINED: 23
}

exports.SYMS = {
  NULL: Symbol('null'),
  UNDEFINED: Symbol('undef'),
  PARENT: Symbol('parent'),
  BREAK: Symbol('break'),
  STREAM: Symbol('stream')
}

exports.SHIFT32 = Math.pow(2, 32)
exports.SHIFT16 = Math.pow(2, 16)

exports.MAX_SAFE_HIGH = 0x1fffff
exports.NEG_ONE = new Bignumber(-1)
exports.TEN = new Bignumber(10)
exports.TWO = new Bignumber(2)

exports.PARENT = {
  ARRAY: 0,
  OBJECT: 1,
  MAP: 2,
  TAG: 3,
  BYTE_STRING: 4,
  UTF8_STRING: 5
}

      };
    };
  }
}, {package:"borc",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/utils.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/constants.js","bignumber.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/node_modules/bignumber.js/bignumber.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/utils.js
      return function (require, module, exports) {
'use strict'

const { Buffer } = require('buffer')
const Bignumber = require('bignumber.js').BigNumber

const constants = require('./constants')
const SHIFT32 = constants.SHIFT32
const SHIFT16 = constants.SHIFT16
const MAX_SAFE_HIGH = 0x1fffff

exports.parseHalf = function parseHalf (buf) {
  var exp, mant, sign
  sign = buf[0] & 0x80 ? -1 : 1
  exp = (buf[0] & 0x7C) >> 2
  mant = ((buf[0] & 0x03) << 8) | buf[1]
  if (!exp) {
    return sign * 5.9604644775390625e-8 * mant
  } else if (exp === 0x1f) {
    return sign * (mant ? 0 / 0 : 2e308)
  } else {
    return sign * Math.pow(2, exp - 25) * (1024 + mant)
  }
}

function toHex (n) {
  if (n < 16) {
    return '0' + n.toString(16)
  }

  return n.toString(16)
}

exports.arrayBufferToBignumber = function (buf) {
  const len = buf.byteLength
  let res = ''
  for (let i = 0; i < len; i++) {
    res += toHex(buf[i])
  }

  return new Bignumber(res, 16)
}

// convert an Object into a Map
exports.buildMap = (obj) => {
  const res = new Map()
  const keys = Object.keys(obj)
  const length = keys.length
  for (let i = 0; i < length; i++) {
    res.set(keys[i], obj[keys[i]])
  }
  return res
}

exports.buildInt32 = (f, g) => {
  return f * SHIFT16 + g
}

exports.buildInt64 = (f1, f2, g1, g2) => {
  const f = exports.buildInt32(f1, f2)
  const g = exports.buildInt32(g1, g2)

  if (f > MAX_SAFE_HIGH) {
    return new Bignumber(f).times(SHIFT32).plus(g)
  } else {
    return (f * SHIFT32) + g
  }
}

exports.writeHalf = function writeHalf (buf, half) {
  // assume 0, -0, NaN, Infinity, and -Infinity have already been caught

  // HACK: everyone settle in.  This isn't going to be pretty.
  // Translate cn-cbor's C code (from Carsten Borman):

  // uint32_t be32;
  // uint16_t be16, u16;
  // union {
  //   float f;
  //   uint32_t u;
  // } u32;
  // u32.f = float_val;

  const u32 = Buffer.allocUnsafe(4)
  u32.writeFloatBE(half, 0)
  const u = u32.readUInt32BE(0)

  // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */

  // hildjj: If the lower 13 bits are 0, we won't lose anything in the conversion
  if ((u & 0x1FFF) !== 0) {
    return false
  }

  //   int s16 = (u32.u >> 16) & 0x8000;
  //   int exp = (u32.u >> 23) & 0xff;
  //   int mant = u32.u & 0x7fffff;

  var s16 = (u >> 16) & 0x8000 // top bit is sign
  const exp = (u >> 23) & 0xff // then 5 bits of exponent
  const mant = u & 0x7fffff

  //   if (exp == 0 && mant == 0)
  //     ;              /* 0.0, -0.0 */

  // hildjj: zeros already handled.  Assert if you don't believe me.

  //   else if (exp >= 113 && exp <= 142) /* normalized */
  //     s16 += ((exp - 112) << 10) + (mant >> 13);
  if ((exp >= 113) && (exp <= 142)) {
    s16 += ((exp - 112) << 10) + (mant >> 13)

  //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */
  //     if (mant & ((1 << (126 - exp)) - 1))
  //       goto float32;         /* loss of precision */
  //     s16 += ((mant + 0x800000) >> (126 - exp));
  } else if ((exp >= 103) && (exp < 113)) {
    if (mant & ((1 << (126 - exp)) - 1)) {
      return false
    }
    s16 += ((mant + 0x800000) >> (126 - exp))

    //   } else if (exp == 255 && mant == 0) { /* Inf */
    //     s16 += 0x7c00;

    // hildjj: Infinity already handled

  //   } else
  //     goto float32;           /* loss of range */
  } else {
    return false
  }

  //   ensure_writable(3);
  //   u16 = s16;
  //   be16 = hton16p((const uint8_t*)&u16);
  buf.writeUInt16BE(s16, 0)
  return true
}

exports.keySorter = function (a, b) {
  var lenA = a[0].byteLength
  var lenB = b[0].byteLength

  if (lenA > lenB) {
    return 1
  }

  if (lenB > lenA) {
    return -1
  }

  return a[0].compare(b[0])
}

// Adapted from http://www.2ality.com/2012/03/signedzero.html
exports.isNegativeZero = (x) => {
  return x === 0 && (1 / x < 0)
}

exports.nextPowerOf2 = (n) => {
  let count = 0
  // First n in the below condition is for
  // the case where n is 0
  if (n && !(n & (n - 1))) {
    return n
  }

  while (n !== 0) {
    n >>= 1
    count += 1
  }

  return 1 << count
}

      };
    };
  }
}, {package:"borc",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/decoder.asm.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/decoder.asm.js
      return function (require, module, exports) {
/* eslint-disable */

module.exports = function decodeAsm (stdlib, foreign, buffer) {
  'use asm'

  // -- Imports

  var heap = new stdlib.Uint8Array(buffer)
  // var log = foreign.log
  var pushInt = foreign.pushInt
  var pushInt32 = foreign.pushInt32
  var pushInt32Neg = foreign.pushInt32Neg
  var pushInt64 = foreign.pushInt64
  var pushInt64Neg = foreign.pushInt64Neg
  var pushFloat = foreign.pushFloat
  var pushFloatSingle = foreign.pushFloatSingle
  var pushFloatDouble = foreign.pushFloatDouble
  var pushTrue = foreign.pushTrue
  var pushFalse = foreign.pushFalse
  var pushUndefined = foreign.pushUndefined
  var pushNull = foreign.pushNull
  var pushInfinity = foreign.pushInfinity
  var pushInfinityNeg = foreign.pushInfinityNeg
  var pushNaN = foreign.pushNaN
  var pushNaNNeg = foreign.pushNaNNeg

  var pushArrayStart = foreign.pushArrayStart
  var pushArrayStartFixed = foreign.pushArrayStartFixed
  var pushArrayStartFixed32 = foreign.pushArrayStartFixed32
  var pushArrayStartFixed64 = foreign.pushArrayStartFixed64
  var pushObjectStart = foreign.pushObjectStart
  var pushObjectStartFixed = foreign.pushObjectStartFixed
  var pushObjectStartFixed32 = foreign.pushObjectStartFixed32
  var pushObjectStartFixed64 = foreign.pushObjectStartFixed64

  var pushByteString = foreign.pushByteString
  var pushByteStringStart = foreign.pushByteStringStart
  var pushUtf8String = foreign.pushUtf8String
  var pushUtf8StringStart = foreign.pushUtf8StringStart

  var pushSimpleUnassigned = foreign.pushSimpleUnassigned

  var pushTagStart = foreign.pushTagStart
  var pushTagStart4 = foreign.pushTagStart4
  var pushTagStart8 = foreign.pushTagStart8
  var pushTagUnassigned = foreign.pushTagUnassigned

  var pushBreak = foreign.pushBreak

  var pow = stdlib.Math.pow

  // -- Constants


  // -- Mutable Variables

  var offset = 0
  var inputLength = 0
  var code = 0

  // Decode a cbor string represented as Uint8Array
  // which is allocated on the heap from 0 to inputLength
  //
  // input - Int
  //
  // Returns Code - Int,
  // Success = 0
  // Error > 0
  function parse (input) {
    input = input | 0

    offset = 0
    inputLength = input

    while ((offset | 0) < (inputLength | 0)) {
      code = jumpTable[heap[offset] & 255](heap[offset] | 0) | 0

      if ((code | 0) > 0) {
        break
      }
    }

    return code | 0
  }

  // -- Helper Function

  function checkOffset (n) {
    n = n | 0

    if ((((offset | 0) + (n | 0)) | 0) < (inputLength | 0)) {
      return 0
    }

    return 1
  }

  function readUInt16 (n) {
    n = n | 0

    return (
      (heap[n | 0] << 8) | heap[(n + 1) | 0]
    ) | 0
  }

  function readUInt32 (n) {
    n = n | 0

    return (
      (heap[n | 0] << 24) | (heap[(n + 1) | 0] << 16) | (heap[(n + 2) | 0] << 8) | heap[(n + 3) | 0]
    ) | 0
  }

  // -- Initial Byte Handlers

  function INT_P (octet) {
    octet = octet | 0

    pushInt(octet | 0)

    offset = (offset + 1) | 0

    return 0
  }

  function UINT_P_8 (octet) {
    octet = octet | 0

    if (checkOffset(1) | 0) {
      return 1
    }

    pushInt(heap[(offset + 1) | 0] | 0)

    offset = (offset + 2) | 0

    return 0
  }

  function UINT_P_16 (octet) {
    octet = octet | 0

    if (checkOffset(2) | 0) {
      return 1
    }

    pushInt(
      readUInt16((offset + 1) | 0) | 0
    )

    offset = (offset + 3) | 0

    return 0
  }

  function UINT_P_32 (octet) {
    octet = octet | 0

    if (checkOffset(4) | 0) {
      return 1
    }

    pushInt32(
      readUInt16((offset + 1) | 0) | 0,
      readUInt16((offset + 3) | 0) | 0
    )

    offset = (offset + 5) | 0

    return 0
  }

  function UINT_P_64 (octet) {
    octet = octet | 0

    if (checkOffset(8) | 0) {
      return 1
    }

    pushInt64(
      readUInt16((offset + 1) | 0) | 0,
      readUInt16((offset + 3) | 0) | 0,
      readUInt16((offset + 5) | 0) | 0,
      readUInt16((offset + 7) | 0) | 0
    )

    offset = (offset + 9) | 0

    return 0
  }

  function INT_N (octet) {
    octet = octet | 0

    pushInt((-1 - ((octet - 32) | 0)) | 0)

    offset = (offset + 1) | 0

    return 0
  }

  function UINT_N_8 (octet) {
    octet = octet | 0

    if (checkOffset(1) | 0) {
      return 1
    }

    pushInt(
      (-1 - (heap[(offset + 1) | 0] | 0)) | 0
    )

    offset = (offset + 2) | 0

    return 0
  }

  function UINT_N_16 (octet) {
    octet = octet | 0

    var val = 0

    if (checkOffset(2) | 0) {
      return 1
    }

    val = readUInt16((offset + 1) | 0) | 0
    pushInt((-1 - (val | 0)) | 0)

    offset = (offset + 3) | 0

    return 0
  }

  function UINT_N_32 (octet) {
    octet = octet | 0

    if (checkOffset(4) | 0) {
      return 1
    }

    pushInt32Neg(
      readUInt16((offset + 1) | 0) | 0,
      readUInt16((offset + 3) | 0) | 0
    )

    offset = (offset + 5) | 0

    return 0
  }

  function UINT_N_64 (octet) {
    octet = octet | 0

    if (checkOffset(8) | 0) {
      return 1
    }

    pushInt64Neg(
      readUInt16((offset + 1) | 0) | 0,
      readUInt16((offset + 3) | 0) | 0,
      readUInt16((offset + 5) | 0) | 0,
      readUInt16((offset + 7) | 0) | 0
    )

    offset = (offset + 9) | 0

    return 0
  }

  function BYTE_STRING (octet) {
    octet = octet | 0

    var start = 0
    var end = 0
    var step = 0

    step = (octet - 64) | 0
    if (checkOffset(step | 0) | 0) {
      return 1
    }

    start = (offset + 1) | 0
    end = (((offset + 1) | 0) + (step | 0)) | 0

    pushByteString(start | 0, end | 0)

    offset = end | 0

    return 0
  }

  function BYTE_STRING_8 (octet) {
    octet = octet | 0

    var start = 0
    var end = 0
    var length = 0

    if (checkOffset(1) | 0) {
      return 1
    }

    length = heap[(offset + 1) | 0] | 0
    start = (offset + 2) | 0
    end = (((offset + 2) | 0) + (length | 0)) | 0

    if (checkOffset((length + 1) | 0) | 0) {
      return 1
    }

    pushByteString(start | 0, end | 0)

    offset = end | 0

    return 0
  }

  function BYTE_STRING_16 (octet) {
    octet = octet | 0

    var start = 0
    var end = 0
    var length = 0

    if (checkOffset(2) | 0) {
      return 1
    }

    length = readUInt16((offset + 1) | 0) | 0
    start = (offset + 3) | 0
    end = (((offset + 3) | 0) + (length | 0)) | 0


    if (checkOffset((length + 2) | 0) | 0) {
      return 1
    }

    pushByteString(start | 0, end | 0)

    offset = end | 0

    return 0
  }

  function BYTE_STRING_32 (octet) {
    octet = octet | 0

    var start = 0
    var end = 0
    var length = 0

    if (checkOffset(4) | 0) {
      return 1
    }

    length = readUInt32((offset + 1) | 0) | 0
    start = (offset + 5) | 0
    end = (((offset + 5) | 0) + (length | 0)) | 0


    if (checkOffset((length + 4) | 0) | 0) {
      return 1
    }

    pushByteString(start | 0, end | 0)

    offset = end | 0

    return 0
  }

  function BYTE_STRING_64 (octet) {
    // NOT IMPLEMENTED
    octet = octet | 0

    return 1
  }

  function BYTE_STRING_BREAK (octet) {
    octet = octet | 0

    pushByteStringStart()

    offset = (offset + 1) | 0

    return 0
  }

  function UTF8_STRING (octet) {
    octet = octet | 0

    var start = 0
    var end = 0
    var step = 0

    step = (octet - 96) | 0

    if (checkOffset(step | 0) | 0) {
      return 1
    }

    start = (offset + 1) | 0
    end = (((offset + 1) | 0) + (step | 0)) | 0

    pushUtf8String(start | 0, end | 0)

    offset = end | 0

    return 0
  }

  function UTF8_STRING_8 (octet) {
    octet = octet | 0

    var start = 0
    var end = 0
    var length = 0

    if (checkOffset(1) | 0) {
      return 1
    }

    length = heap[(offset + 1) | 0] | 0
    start = (offset + 2) | 0
    end = (((offset + 2) | 0) + (length | 0)) | 0

    if (checkOffset((length + 1) | 0) | 0) {
      return 1
    }

    pushUtf8String(start | 0, end | 0)

    offset = end | 0

    return 0
  }

  function UTF8_STRING_16 (octet) {
    octet = octet | 0

    var start = 0
    var end = 0
    var length = 0

    if (checkOffset(2) | 0) {
      return 1
    }

    length = readUInt16((offset + 1) | 0) | 0
    start = (offset + 3) | 0
    end = (((offset + 3) | 0) + (length | 0)) | 0

    if (checkOffset((length + 2) | 0) | 0) {
      return 1
    }

    pushUtf8String(start | 0, end | 0)

    offset = end | 0

    return 0
  }

  function UTF8_STRING_32 (octet) {
    octet = octet | 0

    var start = 0
    var end = 0
    var length = 0

    if (checkOffset(4) | 0) {
      return 1
    }

    length = readUInt32((offset + 1) | 0) | 0
    start = (offset + 5) | 0
    end = (((offset + 5) | 0) + (length | 0)) | 0

    if (checkOffset((length + 4) | 0) | 0) {
      return 1
    }

    pushUtf8String(start | 0, end | 0)

    offset = end | 0

    return 0
  }

  function UTF8_STRING_64 (octet) {
    // NOT IMPLEMENTED
    octet = octet | 0

    return 1
  }

  function UTF8_STRING_BREAK (octet) {
    octet = octet | 0

    pushUtf8StringStart()

    offset = (offset + 1) | 0

    return 0
  }

  function ARRAY (octet) {
    octet = octet | 0

    pushArrayStartFixed((octet - 128) | 0)

    offset = (offset + 1) | 0

    return 0
  }

  function ARRAY_8 (octet) {
    octet = octet | 0

    if (checkOffset(1) | 0) {
      return 1
    }

    pushArrayStartFixed(heap[(offset + 1) | 0] | 0)

    offset = (offset + 2) | 0

    return 0
  }

  function ARRAY_16 (octet) {
    octet = octet | 0

    if (checkOffset(2) | 0) {
      return 1
    }

    pushArrayStartFixed(
      readUInt16((offset + 1) | 0) | 0
    )

    offset = (offset + 3) | 0

    return 0
  }

  function ARRAY_32 (octet) {
    octet = octet | 0

    if (checkOffset(4) | 0) {
      return 1
    }

    pushArrayStartFixed32(
      readUInt16((offset + 1) | 0) | 0,
      readUInt16((offset + 3) | 0) | 0
    )

    offset = (offset + 5) | 0

    return 0
  }

  function ARRAY_64 (octet) {
    octet = octet | 0

    if (checkOffset(8) | 0) {
      return 1
    }

    pushArrayStartFixed64(
      readUInt16((offset + 1) | 0) | 0,
      readUInt16((offset + 3) | 0) | 0,
      readUInt16((offset + 5) | 0) | 0,
      readUInt16((offset + 7) | 0) | 0
    )

    offset = (offset + 9) | 0

    return 0
  }

  function ARRAY_BREAK (octet) {
    octet = octet | 0

    pushArrayStart()

    offset = (offset + 1) | 0

    return 0
  }

  function MAP (octet) {
    octet = octet | 0

    var step = 0

    step = (octet - 160) | 0

    if (checkOffset(step | 0) | 0) {
      return 1
    }

    pushObjectStartFixed(step | 0)

    offset = (offset + 1) | 0

    return 0
  }

  function MAP_8 (octet) {
    octet = octet | 0

    if (checkOffset(1) | 0) {
      return 1
    }

    pushObjectStartFixed(heap[(offset + 1) | 0] | 0)

    offset = (offset + 2) | 0

    return 0
  }

  function MAP_16 (octet) {
    octet = octet | 0

    if (checkOffset(2) | 0) {
      return 1
    }

    pushObjectStartFixed(
      readUInt16((offset + 1) | 0) | 0
    )

    offset = (offset + 3) | 0

    return 0
  }

  function MAP_32 (octet) {
    octet = octet | 0

    if (checkOffset(4) | 0) {
      return 1
    }

    pushObjectStartFixed32(
      readUInt16((offset + 1) | 0) | 0,
      readUInt16((offset + 3) | 0) | 0
    )

    offset = (offset + 5) | 0

    return 0
  }

  function MAP_64 (octet) {
    octet = octet | 0

    if (checkOffset(8) | 0) {
      return 1
    }

    pushObjectStartFixed64(
      readUInt16((offset + 1) | 0) | 0,
      readUInt16((offset + 3) | 0) | 0,
      readUInt16((offset + 5) | 0) | 0,
      readUInt16((offset + 7) | 0) | 0
    )

    offset = (offset + 9) | 0

    return 0
  }

  function MAP_BREAK (octet) {
    octet = octet | 0

    pushObjectStart()

    offset = (offset + 1) | 0

    return 0
  }

  function TAG_KNOWN (octet) {
    octet = octet | 0

    pushTagStart((octet - 192| 0) | 0)

    offset = (offset + 1 | 0)

    return 0
  }

  function TAG_BIGNUM_POS (octet) {
    octet = octet | 0

    pushTagStart(octet | 0)

    offset = (offset + 1 | 0)

    return 0
  }

  function TAG_BIGNUM_NEG (octet) {
    octet = octet | 0

    pushTagStart(octet | 0)

    offset = (offset + 1 | 0)

    return 0
  }

  function TAG_FRAC (octet) {
    octet = octet | 0

    pushTagStart(octet | 0)

    offset = (offset + 1 | 0)

    return 0
  }

  function TAG_BIGNUM_FLOAT (octet) {
    octet = octet | 0

    pushTagStart(octet | 0)

    offset = (offset + 1 | 0)

    return 0
  }

  function TAG_UNASSIGNED (octet) {
    octet = octet | 0

    pushTagStart((octet - 192| 0) | 0)

    offset = (offset + 1 | 0)

    return 0
  }

  function TAG_BASE64_URL (octet) {
    octet = octet | 0

    pushTagStart(octet | 0)

    offset = (offset + 1 | 0)

    return 0
  }

  function TAG_BASE64 (octet) {
    octet = octet | 0

    pushTagStart(octet | 0)

    offset = (offset + 1 | 0)

    return 0
  }

  function TAG_BASE16 (octet) {
    octet = octet | 0

    pushTagStart(octet | 0)

    offset = (offset + 1 | 0)

    return 0
  }

  function TAG_MORE_1 (octet) {
    octet = octet | 0

    if (checkOffset(1) | 0) {
      return 1
    }

    pushTagStart(heap[(offset + 1) | 0] | 0)

    offset = (offset + 2 | 0)

    return 0
  }

  function TAG_MORE_2 (octet) {
    octet = octet | 0

    if (checkOffset(2) | 0) {
      return 1
    }

    pushTagStart(
      readUInt16((offset + 1) | 0) | 0
    )

    offset = (offset + 3 | 0)

    return 0
  }

  function TAG_MORE_4 (octet) {
    octet = octet | 0

    if (checkOffset(4) | 0) {
      return 1
    }

    pushTagStart4(
      readUInt16((offset + 1) | 0) | 0,
      readUInt16((offset + 3) | 0) | 0
    )

    offset = (offset + 5 | 0)

    return 0
  }

  function TAG_MORE_8 (octet) {
    octet = octet | 0

    if (checkOffset(8) | 0) {
      return 1
    }

    pushTagStart8(
      readUInt16((offset + 1) | 0) | 0,
      readUInt16((offset + 3) | 0) | 0,
      readUInt16((offset + 5) | 0) | 0,
      readUInt16((offset + 7) | 0) | 0
    )

    offset = (offset + 9 | 0)

    return 0
  }

  function SIMPLE_UNASSIGNED (octet) {
    octet = octet | 0

    pushSimpleUnassigned(((octet | 0) - 224) | 0)

    offset = (offset + 1) | 0

    return 0
  }

  function SIMPLE_FALSE (octet) {
    octet = octet | 0

    pushFalse()

    offset = (offset + 1) | 0

    return 0
  }

  function SIMPLE_TRUE (octet) {
    octet = octet | 0

    pushTrue()

    offset = (offset + 1) | 0

    return 0
  }

  function SIMPLE_NULL (octet) {
    octet = octet | 0

    pushNull()

    offset = (offset + 1) | 0

    return 0
  }

  function SIMPLE_UNDEFINED (octet) {
    octet = octet | 0

    pushUndefined()

    offset = (offset + 1) | 0

    return 0
  }

  function SIMPLE_BYTE (octet) {
    octet = octet | 0

    if (checkOffset(1) | 0) {
      return 1
    }

    pushSimpleUnassigned(heap[(offset + 1) | 0] | 0)

    offset = (offset + 2)  | 0

    return 0
  }

  function SIMPLE_FLOAT_HALF (octet) {
    octet = octet | 0

    var f = 0
    var g = 0
    var sign = 1.0
    var exp = 0.0
    var mant = 0.0
    var r = 0.0
    if (checkOffset(2) | 0) {
      return 1
    }

    f = heap[(offset + 1) | 0] | 0
    g = heap[(offset + 2) | 0] | 0

    if ((f | 0) & 0x80) {
      sign = -1.0
    }

    exp = +(((f | 0) & 0x7C) >> 2)
    mant = +((((f | 0) & 0x03) << 8) | g)

    if (+exp == 0.0) {
      pushFloat(+(
        (+sign) * +5.9604644775390625e-8 * (+mant)
      ))
    } else if (+exp == 31.0) {
      if (+sign == 1.0) {
        if (+mant > 0.0) {
          pushNaN()
        } else {
          pushInfinity()
        }
      } else {
        if (+mant > 0.0) {
          pushNaNNeg()
        } else {
          pushInfinityNeg()
        }
      }
    } else {
      pushFloat(+(
        +sign * pow(+2, +(+exp - 25.0)) * +(1024.0 + mant)
      ))
    }

    offset = (offset + 3) | 0

    return 0
  }

  function SIMPLE_FLOAT_SINGLE (octet) {
    octet = octet | 0

    if (checkOffset(4) | 0) {
      return 1
    }

    pushFloatSingle(
      heap[(offset + 1) | 0] | 0,
      heap[(offset + 2) | 0] | 0,
      heap[(offset + 3) | 0] | 0,
      heap[(offset + 4) | 0] | 0
    )

    offset = (offset + 5) | 0

    return 0
  }

  function SIMPLE_FLOAT_DOUBLE (octet) {
    octet = octet | 0

    if (checkOffset(8) | 0) {
      return 1
    }

    pushFloatDouble(
      heap[(offset + 1) | 0] | 0,
      heap[(offset + 2) | 0] | 0,
      heap[(offset + 3) | 0] | 0,
      heap[(offset + 4) | 0] | 0,
      heap[(offset + 5) | 0] | 0,
      heap[(offset + 6) | 0] | 0,
      heap[(offset + 7) | 0] | 0,
      heap[(offset + 8) | 0] | 0
    )

    offset = (offset + 9) | 0

    return 0
  }

  function ERROR (octet) {
    octet = octet | 0

    return 1
  }

  function BREAK (octet) {
    octet = octet | 0

    pushBreak()

    offset = (offset + 1) | 0

    return 0
  }

  // -- Jump Table

  var jumpTable = [
    // Integer 0x00..0x17 (0..23)
    INT_P, // 0x00
    INT_P, // 0x01
    INT_P, // 0x02
    INT_P, // 0x03
    INT_P, // 0x04
    INT_P, // 0x05
    INT_P, // 0x06
    INT_P, // 0x07
    INT_P, // 0x08
    INT_P, // 0x09
    INT_P, // 0x0A
    INT_P, // 0x0B
    INT_P, // 0x0C
    INT_P, // 0x0D
    INT_P, // 0x0E
    INT_P, // 0x0F
    INT_P, // 0x10
    INT_P, // 0x11
    INT_P, // 0x12
    INT_P, // 0x13
    INT_P, // 0x14
    INT_P, // 0x15
    INT_P, // 0x16
    INT_P, // 0x17
    // Unsigned integer (one-byte uint8_t follows)
    UINT_P_8, // 0x18
    // Unsigned integer (two-byte uint16_t follows)
    UINT_P_16, // 0x19
    // Unsigned integer (four-byte uint32_t follows)
    UINT_P_32, // 0x1a
    // Unsigned integer (eight-byte uint64_t follows)
    UINT_P_64, // 0x1b
    ERROR, // 0x1c
    ERROR, // 0x1d
    ERROR, // 0x1e
    ERROR, // 0x1f
    // Negative integer -1-0x00..-1-0x17 (-1..-24)
    INT_N, // 0x20
    INT_N, // 0x21
    INT_N, // 0x22
    INT_N, // 0x23
    INT_N, // 0x24
    INT_N, // 0x25
    INT_N, // 0x26
    INT_N, // 0x27
    INT_N, // 0x28
    INT_N, // 0x29
    INT_N, // 0x2A
    INT_N, // 0x2B
    INT_N, // 0x2C
    INT_N, // 0x2D
    INT_N, // 0x2E
    INT_N, // 0x2F
    INT_N, // 0x30
    INT_N, // 0x31
    INT_N, // 0x32
    INT_N, // 0x33
    INT_N, // 0x34
    INT_N, // 0x35
    INT_N, // 0x36
    INT_N, // 0x37
    // Negative integer -1-n (one-byte uint8_t for n follows)
    UINT_N_8, // 0x38
    // Negative integer -1-n (two-byte uint16_t for n follows)
    UINT_N_16, // 0x39
    // Negative integer -1-n (four-byte uint32_t for nfollows)
    UINT_N_32, // 0x3a
    // Negative integer -1-n (eight-byte uint64_t for n follows)
    UINT_N_64, // 0x3b
    ERROR, // 0x3c
    ERROR, // 0x3d
    ERROR, // 0x3e
    ERROR, // 0x3f
    // byte string (0x00..0x17 bytes follow)
    BYTE_STRING, // 0x40
    BYTE_STRING, // 0x41
    BYTE_STRING, // 0x42
    BYTE_STRING, // 0x43
    BYTE_STRING, // 0x44
    BYTE_STRING, // 0x45
    BYTE_STRING, // 0x46
    BYTE_STRING, // 0x47
    BYTE_STRING, // 0x48
    BYTE_STRING, // 0x49
    BYTE_STRING, // 0x4A
    BYTE_STRING, // 0x4B
    BYTE_STRING, // 0x4C
    BYTE_STRING, // 0x4D
    BYTE_STRING, // 0x4E
    BYTE_STRING, // 0x4F
    BYTE_STRING, // 0x50
    BYTE_STRING, // 0x51
    BYTE_STRING, // 0x52
    BYTE_STRING, // 0x53
    BYTE_STRING, // 0x54
    BYTE_STRING, // 0x55
    BYTE_STRING, // 0x56
    BYTE_STRING, // 0x57
    // byte string (one-byte uint8_t for n, and then n bytes follow)
    BYTE_STRING_8, // 0x58
    // byte string (two-byte uint16_t for n, and then n bytes follow)
    BYTE_STRING_16, // 0x59
    // byte string (four-byte uint32_t for n, and then n bytes follow)
    BYTE_STRING_32, // 0x5a
    // byte string (eight-byte uint64_t for n, and then n bytes follow)
    BYTE_STRING_64, // 0x5b
    ERROR, // 0x5c
    ERROR, // 0x5d
    ERROR, // 0x5e
    // byte string, byte strings follow, terminated by "break"
    BYTE_STRING_BREAK, // 0x5f
    // UTF-8 string (0x00..0x17 bytes follow)
    UTF8_STRING, // 0x60
    UTF8_STRING, // 0x61
    UTF8_STRING, // 0x62
    UTF8_STRING, // 0x63
    UTF8_STRING, // 0x64
    UTF8_STRING, // 0x65
    UTF8_STRING, // 0x66
    UTF8_STRING, // 0x67
    UTF8_STRING, // 0x68
    UTF8_STRING, // 0x69
    UTF8_STRING, // 0x6A
    UTF8_STRING, // 0x6B
    UTF8_STRING, // 0x6C
    UTF8_STRING, // 0x6D
    UTF8_STRING, // 0x6E
    UTF8_STRING, // 0x6F
    UTF8_STRING, // 0x70
    UTF8_STRING, // 0x71
    UTF8_STRING, // 0x72
    UTF8_STRING, // 0x73
    UTF8_STRING, // 0x74
    UTF8_STRING, // 0x75
    UTF8_STRING, // 0x76
    UTF8_STRING, // 0x77
    // UTF-8 string (one-byte uint8_t for n, and then n bytes follow)
    UTF8_STRING_8, // 0x78
    // UTF-8 string (two-byte uint16_t for n, and then n bytes follow)
    UTF8_STRING_16, // 0x79
    // UTF-8 string (four-byte uint32_t for n, and then n bytes follow)
    UTF8_STRING_32, // 0x7a
    // UTF-8 string (eight-byte uint64_t for n, and then n bytes follow)
    UTF8_STRING_64, // 0x7b
    // UTF-8 string, UTF-8 strings follow, terminated by "break"
    ERROR, // 0x7c
    ERROR, // 0x7d
    ERROR, // 0x7e
    UTF8_STRING_BREAK, // 0x7f
    // array (0x00..0x17 data items follow)
    ARRAY, // 0x80
    ARRAY, // 0x81
    ARRAY, // 0x82
    ARRAY, // 0x83
    ARRAY, // 0x84
    ARRAY, // 0x85
    ARRAY, // 0x86
    ARRAY, // 0x87
    ARRAY, // 0x88
    ARRAY, // 0x89
    ARRAY, // 0x8A
    ARRAY, // 0x8B
    ARRAY, // 0x8C
    ARRAY, // 0x8D
    ARRAY, // 0x8E
    ARRAY, // 0x8F
    ARRAY, // 0x90
    ARRAY, // 0x91
    ARRAY, // 0x92
    ARRAY, // 0x93
    ARRAY, // 0x94
    ARRAY, // 0x95
    ARRAY, // 0x96
    ARRAY, // 0x97
    // array (one-byte uint8_t fo, and then n data items follow)
    ARRAY_8, // 0x98
    // array (two-byte uint16_t for n, and then n data items follow)
    ARRAY_16, // 0x99
    // array (four-byte uint32_t for n, and then n data items follow)
    ARRAY_32, // 0x9a
    // array (eight-byte uint64_t for n, and then n data items follow)
    ARRAY_64, // 0x9b
    // array, data items follow, terminated by "break"
    ERROR, // 0x9c
    ERROR, // 0x9d
    ERROR, // 0x9e
    ARRAY_BREAK, // 0x9f
    // map (0x00..0x17 pairs of data items follow)
    MAP, // 0xa0
    MAP, // 0xa1
    MAP, // 0xa2
    MAP, // 0xa3
    MAP, // 0xa4
    MAP, // 0xa5
    MAP, // 0xa6
    MAP, // 0xa7
    MAP, // 0xa8
    MAP, // 0xa9
    MAP, // 0xaA
    MAP, // 0xaB
    MAP, // 0xaC
    MAP, // 0xaD
    MAP, // 0xaE
    MAP, // 0xaF
    MAP, // 0xb0
    MAP, // 0xb1
    MAP, // 0xb2
    MAP, // 0xb3
    MAP, // 0xb4
    MAP, // 0xb5
    MAP, // 0xb6
    MAP, // 0xb7
    // map (one-byte uint8_t for n, and then n pairs of data items follow)
    MAP_8, // 0xb8
    // map (two-byte uint16_t for n, and then n pairs of data items follow)
    MAP_16, // 0xb9
    // map (four-byte uint32_t for n, and then n pairs of data items follow)
    MAP_32, // 0xba
    // map (eight-byte uint64_t for n, and then n pairs of data items follow)
    MAP_64, // 0xbb
    ERROR, // 0xbc
    ERROR, // 0xbd
    ERROR, // 0xbe
    // map, pairs of data items follow, terminated by "break"
    MAP_BREAK, // 0xbf
    // Text-based date/time (data item follows; see Section 2.4.1)
    TAG_KNOWN, // 0xc0
    // Epoch-based date/time (data item follows; see Section 2.4.1)
    TAG_KNOWN, // 0xc1
    // Positive bignum (data item "byte string" follows)
    TAG_KNOWN, // 0xc2
    // Negative bignum (data item "byte string" follows)
    TAG_KNOWN, // 0xc3
    // Decimal Fraction (data item "array" follows; see Section 2.4.3)
    TAG_KNOWN, // 0xc4
    // Bigfloat (data item "array" follows; see Section 2.4.3)
    TAG_KNOWN, // 0xc5
    // (tagged item)
    TAG_UNASSIGNED, // 0xc6
    TAG_UNASSIGNED, // 0xc7
    TAG_UNASSIGNED, // 0xc8
    TAG_UNASSIGNED, // 0xc9
    TAG_UNASSIGNED, // 0xca
    TAG_UNASSIGNED, // 0xcb
    TAG_UNASSIGNED, // 0xcc
    TAG_UNASSIGNED, // 0xcd
    TAG_UNASSIGNED, // 0xce
    TAG_UNASSIGNED, // 0xcf
    TAG_UNASSIGNED, // 0xd0
    TAG_UNASSIGNED, // 0xd1
    TAG_UNASSIGNED, // 0xd2
    TAG_UNASSIGNED, // 0xd3
    TAG_UNASSIGNED, // 0xd4
    // Expected Conversion (data item follows; see Section 2.4.4.2)
    TAG_UNASSIGNED, // 0xd5
    TAG_UNASSIGNED, // 0xd6
    TAG_UNASSIGNED, // 0xd7
    // (more tagged items, 1/2/4/8 bytes and then a data item follow)
    TAG_MORE_1, // 0xd8
    TAG_MORE_2, // 0xd9
    TAG_MORE_4, // 0xda
    TAG_MORE_8, // 0xdb
    ERROR, // 0xdc
    ERROR, // 0xdd
    ERROR, // 0xde
    ERROR, // 0xdf
    // (simple value)
    SIMPLE_UNASSIGNED, // 0xe0
    SIMPLE_UNASSIGNED, // 0xe1
    SIMPLE_UNASSIGNED, // 0xe2
    SIMPLE_UNASSIGNED, // 0xe3
    SIMPLE_UNASSIGNED, // 0xe4
    SIMPLE_UNASSIGNED, // 0xe5
    SIMPLE_UNASSIGNED, // 0xe6
    SIMPLE_UNASSIGNED, // 0xe7
    SIMPLE_UNASSIGNED, // 0xe8
    SIMPLE_UNASSIGNED, // 0xe9
    SIMPLE_UNASSIGNED, // 0xea
    SIMPLE_UNASSIGNED, // 0xeb
    SIMPLE_UNASSIGNED, // 0xec
    SIMPLE_UNASSIGNED, // 0xed
    SIMPLE_UNASSIGNED, // 0xee
    SIMPLE_UNASSIGNED, // 0xef
    SIMPLE_UNASSIGNED, // 0xf0
    SIMPLE_UNASSIGNED, // 0xf1
    SIMPLE_UNASSIGNED, // 0xf2
    SIMPLE_UNASSIGNED, // 0xf3
    // False
    SIMPLE_FALSE, // 0xf4
    // True
    SIMPLE_TRUE, // 0xf5
    // Null
    SIMPLE_NULL, // 0xf6
    // Undefined
    SIMPLE_UNDEFINED, // 0xf7
    // (simple value, one byte follows)
    SIMPLE_BYTE, // 0xf8
    // Half-Precision Float (two-byte IEEE 754)
    SIMPLE_FLOAT_HALF, // 0xf9
    // Single-Precision Float (four-byte IEEE 754)
    SIMPLE_FLOAT_SINGLE, // 0xfa
    // Double-Precision Float (eight-byte IEEE 754)
    SIMPLE_FLOAT_DOUBLE, // 0xfb
    ERROR, // 0xfc
    ERROR, // 0xfd
    ERROR, // 0xfe
    // "break" stop code
    BREAK // 0xff
  ]

  // --

  return {
    parse: parse
  }
}

      };
    };
  }
}, {package:"borc",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/decoder.asm.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/node_modules/bignumber.js/bignumber.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/node_modules/bignumber.js/bignumber.js
      return function (require, module, exports) {
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                    // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',      // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return 0, else return Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, Infinity or 0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return Infinity if either is Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return 0 if either is 0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return Infinity if either Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

      };
    };
  }
}, {package:"bignumber.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/node_modules/bignumber.js/bignumber.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/index.js", {"./src/relative":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/src/relative.js","./src/url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/src/url-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/index.js
      return function (require, module, exports) {
'use strict';

const {
    URLWithLegacySupport,
    format,
    URLSearchParams,
    defaultBase
} = require('./src/url');
const relative = require('./src/relative');

module.exports = {
    URL: URLWithLegacySupport,
    URLSearchParams,
    format,
    relative,
    defaultBase
};

      };
    };
  }
}, {package:"iso-url",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/node_modules/uuid/v4.js", {"./lib/bytesToUuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/node_modules/uuid/lib/bytesToUuid.js","./lib/rng":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/node_modules/uuid/lib/rng-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/node_modules/uuid/v4.js
      return function (require, module, exports) {
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

      };
    };
  }
}, {package:"uuid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/node_modules/uuid/v4.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/dist/thirdparty.js", {"./index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/dist/index.js","aes-js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/aes-js/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crypto-browserify/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","scrypt-js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/scrypt-js/scrypt.js","utf8":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/utf8/utf8.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/dist/thirdparty.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromQuorumWallet = exports.fromKryptoKit = exports.fromEtherCamp = exports.fromEtherWallet = void 0;
var crypto = require("crypto");
var ethereumjs_util_1 = require("ethereumjs-util");
var scrypt_js_1 = require("scrypt-js");
var index_1 = require("./index");
var utf8 = require('utf8');
var aesjs = require('aes-js');
function runCipherBuffer(cipher, data) {
    return Buffer.concat([cipher.update(data), cipher.final()]);
}
var evpKdfDefaults = {
    count: 1,
    keysize: 16,
    ivsize: 16,
    digest: 'md5',
};
function mergeEvpKdfOptsWithDefaults(opts) {
    if (!opts) {
        return evpKdfDefaults;
    }
    return {
        count: opts.count || evpKdfDefaults.count,
        keysize: opts.keysize || evpKdfDefaults.keysize,
        ivsize: opts.ivsize || evpKdfDefaults.ivsize,
        digest: opts.digest || evpKdfDefaults.digest,
    };
}
/*
 * opts:
 * - digest - digest algorithm, defaults to md5
 * - count - hash iterations
 * - keysize - desired key size
 * - ivsize - desired IV size
 *
 * Algorithm form https://www.openssl.org/docs/manmaster/crypto/EVP_BytesToKey.html
 *
 * FIXME: not optimised at all
 */
function evp_kdf(data, salt, opts) {
    var params = mergeEvpKdfOptsWithDefaults(opts);
    // A single EVP iteration, returns `D_i`, where block equlas to `D_(i-1)`
    function iter(block) {
        var hash = crypto.createHash(params.digest);
        hash.update(block);
        hash.update(data);
        hash.update(salt);
        block = hash.digest();
        for (var i_1 = 1, len = params.count; i_1 < len; i_1++) {
            hash = crypto.createHash(params.digest);
            hash.update(block);
            block = hash.digest();
        }
        return block;
    }
    var ret = [];
    var i = 0;
    while (Buffer.concat(ret).length < params.keysize + params.ivsize) {
        ret[i] = iter(i === 0 ? Buffer.alloc(0) : ret[i - 1]);
        i++;
    }
    var tmp = Buffer.concat(ret);
    return {
        key: tmp.slice(0, params.keysize),
        iv: tmp.slice(params.keysize, params.keysize + params.ivsize),
    };
}
// http://stackoverflow.com/questions/25288311/cryptojs-aes-pattern-always-ends-with
function decodeCryptojsSalt(input) {
    var ciphertext = Buffer.from(input, 'base64');
    if (ciphertext.slice(0, 8).toString() === 'Salted__') {
        return {
            salt: ciphertext.slice(8, 16),
            ciphertext: ciphertext.slice(16),
        };
    }
    return { ciphertext: ciphertext };
}
/*
 * Third Party API: Import a wallet generated by EtherWallet
 * This wallet format is created by https://github.com/SilentCicero/ethereumjs-accounts
 * and used on https://www.myetherwallet.com/
 */
function fromEtherWallet(input, password) {
    var json = typeof input === 'object' ? input : JSON.parse(input);
    var privateKey;
    if (!json.locked) {
        if (json.private.length !== 64) {
            throw new Error('Invalid private key length');
        }
        privateKey = Buffer.from(json.private, 'hex');
    }
    else {
        if (typeof password !== 'string') {
            throw new Error('Password required');
        }
        if (password.length < 7) {
            throw new Error('Password must be at least 7 characters');
        }
        // the "encrypted" version has the low 4 bytes
        // of the hash of the address appended
        var hash = json.encrypted ? json.private.slice(0, 128) : json.private;
        // decode openssl ciphertext + salt encoding
        var cipher = decodeCryptojsSalt(hash);
        if (!cipher.salt) {
            throw new Error('Unsupported EtherWallet key format');
        }
        // derive key/iv using OpenSSL EVP as implemented in CryptoJS
        var evp = evp_kdf(Buffer.from(password), cipher.salt, { keysize: 32, ivsize: 16 });
        var decipher = crypto.createDecipheriv('aes-256-cbc', evp.key, evp.iv);
        privateKey = runCipherBuffer(decipher, Buffer.from(cipher.ciphertext));
        // NOTE: yes, they've run it through UTF8
        privateKey = Buffer.from(utf8.decode(privateKey.toString()), 'hex');
    }
    var wallet = new index_1.default(privateKey);
    if (wallet.getAddressString() !== json.address) {
        throw new Error('Invalid private key or address');
    }
    return wallet;
}
exports.fromEtherWallet = fromEtherWallet;
/**
 * Third Party API: Import a brain wallet used by Ether.Camp
 */
function fromEtherCamp(passphrase) {
    return new index_1.default(ethereumjs_util_1.keccak256(Buffer.from(passphrase)));
}
exports.fromEtherCamp = fromEtherCamp;
/**
 * Third Party API: Import a wallet from a KryptoKit seed
 */
function fromKryptoKit(entropy, password) {
    return __awaiter(this, void 0, void 0, function () {
        function kryptoKitBrokenScryptSeed(buf) {
            // js-scrypt calls `Buffer.from(String(salt), 'utf8')` on the seed even though it is a buffer
            //
            // The `buffer`` implementation used does the below transformation (doesn't matches the current version):
            // https://github.com/feross/buffer/blob/67c61181b938b17d10dbfc0a545f713b8bd59de8/index.js
            function decodeUtf8Char(str) {
                try {
                    return decodeURIComponent(str);
                }
                catch (err) {
                    return String.fromCharCode(0xfffd); // UTF 8 invalid char
                }
            }
            var res = '', tmp = '';
            for (var i = 0; i < buf.length; i++) {
                if (buf[i] <= 0x7f) {
                    res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
                    tmp = '';
                }
                else {
                    tmp += '%' + buf[i].toString(16);
                }
            }
            return Buffer.from(res + decodeUtf8Char(tmp));
        }
        var type, privateKey, encryptedSeed, checksum, salt, aesKey, decipher;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (entropy[0] === '#') {
                        entropy = entropy.slice(1);
                    }
                    type = entropy[0];
                    entropy = entropy.slice(1);
                    if (!(type === 'd')) return [3 /*break*/, 1];
                    privateKey = ethereumjs_util_1.sha256(ethereumjs_util_1.toBuffer(entropy));
                    return [3 /*break*/, 4];
                case 1:
                    if (!(type === 'q')) return [3 /*break*/, 3];
                    if (typeof password !== 'string') {
                        throw new Error('Password required');
                    }
                    encryptedSeed = ethereumjs_util_1.sha256(Buffer.from(entropy.slice(0, 30)));
                    checksum = entropy.slice(30, 46);
                    salt = kryptoKitBrokenScryptSeed(encryptedSeed);
                    return [4 /*yield*/, scrypt_js_1.scrypt(Buffer.from(password, 'utf8'), salt, 16384, 8, 1, 32)
                        /* FIXME: try to use `crypto` instead of `aesjs`
                    
                        // NOTE: ECB doesn't use the IV, so it can be anything
                        var decipher = crypto.createDecipheriv("aes-256-ecb", aesKey, Buffer.from(0))
                    
                        // FIXME: this is a clear abuse, but seems to match how ECB in aesjs works
                        privKey = Buffer.concat([
                          decipher.update(encryptedSeed).slice(0, 16),
                          decipher.update(encryptedSeed).slice(0, 16),
                        ])
                        */
                    ];
                case 2:
                    aesKey = _a.sent();
                    decipher = new aesjs.ModeOfOperation.ecb(aesKey);
                    /* decrypt returns an Uint8Array, perhaps there is a better way to concatenate */
                    privateKey = Buffer.concat([
                        Buffer.from(decipher.decrypt(encryptedSeed.slice(0, 16))),
                        Buffer.from(decipher.decrypt(encryptedSeed.slice(16, 32))),
                    ]);
                    if (checksum.length > 0) {
                        if (checksum !==
                            ethereumjs_util_1.sha256(ethereumjs_util_1.sha256(privateKey))
                                .slice(0, 8)
                                .toString('hex')) {
                            throw new Error('Failed to decrypt input - possibly invalid passphrase');
                        }
                    }
                    return [3 /*break*/, 4];
                case 3: throw new Error('Unsupported or invalid entropy type');
                case 4: return [2 /*return*/, new index_1.default(privateKey)];
            }
        });
    });
}
exports.fromKryptoKit = fromKryptoKit;
/**
 * Third Party API: Import a brain wallet used by Quorum Wallet
 */
function fromQuorumWallet(passphrase, userid) {
    if (passphrase.length < 10) {
        throw new Error('Passphrase must be at least 10 characters');
    }
    if (userid.length < 10) {
        throw new Error('User id must be at least 10 characters');
    }
    var merged = passphrase + userid;
    var seed = crypto.pbkdf2Sync(merged, merged, 2000, 32, 'sha256');
    return new index_1.default(seed);
}
exports.fromQuorumWallet = fromQuorumWallet;
var Thirdparty = {
    fromEtherWallet: fromEtherWallet,
    fromEtherCamp: fromEtherCamp,
    fromKryptoKit: fromKryptoKit,
    fromQuorumWallet: fromQuorumWallet,
};
exports.default = Thirdparty;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-wallet",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/dist/thirdparty.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/dist/hdkey.js", {"./index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/dist/index.js","ethereum-cryptography/hdkey":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereum-cryptography/pure/hdkey.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/dist/hdkey.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("./index");
var hdkey_1 = require("ethereum-cryptography/hdkey");
var EthereumHDKey = /** @class */ (function () {
    function EthereumHDKey(_hdkey) {
        this._hdkey = _hdkey;
    }
    /**
     * Creates an instance based on a seed.
     *
     * For the seed we suggest to use [bip39](https://npmjs.org/package/bip39) to
     * create one from a BIP39 mnemonic.
     */
    EthereumHDKey.fromMasterSeed = function (seedBuffer) {
        return new EthereumHDKey(hdkey_1.HDKey.fromMasterSeed(seedBuffer));
    };
    /**
     * Create an instance based on a BIP32 extended private or public key.
     */
    EthereumHDKey.fromExtendedKey = function (base58Key) {
        return new EthereumHDKey(hdkey_1.HDKey.fromExtendedKey(base58Key));
    };
    /**
     * Returns a BIP32 extended private key (xprv)
     */
    EthereumHDKey.prototype.privateExtendedKey = function () {
        if (!this._hdkey.privateExtendedKey) {
            throw new Error('This is a public key only wallet');
        }
        return this._hdkey.privateExtendedKey;
    };
    /**
     * Return a BIP32 extended public key (xpub)
     */
    EthereumHDKey.prototype.publicExtendedKey = function () {
        return this._hdkey.publicExtendedKey;
    };
    /**
     * Derives a node based on a path (e.g. m/44'/0'/0/1)
     */
    EthereumHDKey.prototype.derivePath = function (path) {
        return new EthereumHDKey(this._hdkey.derive(path));
    };
    /**
     * Derive a node based on a child index
     */
    EthereumHDKey.prototype.deriveChild = function (index) {
        return new EthereumHDKey(this._hdkey.deriveChild(index));
    };
    /**
     * Return a `Wallet` instance as seen above
     */
    EthereumHDKey.prototype.getWallet = function () {
        if (this._hdkey._privateKey) {
            return index_1.default.fromPrivateKey(this._hdkey._privateKey);
        }
        return index_1.default.fromPublicKey(this._hdkey._publicKey, true);
    };
    return EthereumHDKey;
}());
exports.default = EthereumHDKey;
//# sourceMappingURL=hdkey.js.map
      };
    };
  }
}, {package:"ethereumjs-wallet",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/dist/hdkey.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/eth-method-registry/registry-map.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/eth-method-registry/registry-map.json
      return function (require, module, exports) {
module.exports={
  "1": "0x44691B39d1a75dC4E0A0346CBB15E310e6ED1E86"
}

      };
    };
  }
}, {package:"eth-method-registry",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/eth-method-registry/registry-map.json",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/eth-method-registry/abi.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/eth-method-registry/abi.json
      return function (require, module, exports) {
module.exports=[{"constant":false,"inputs":[{"name":"_new","type":"address"}],"name":"setOwner","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"totalSignatures","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"constant":false,"inputs":[],"name":"drain","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"","type":"bytes4"}],"name":"entries","outputs":[{"name":"","type":"string"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_method","type":"string"}],"name":"register","outputs":[{"name":"","type":"bool"}],"payable":false,"type":"function"},{"inputs":[],"type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"creator","type":"address"},{"indexed":true,"name":"signature","type":"bytes4"},{"indexed":false,"name":"method","type":"string"}],"name":"Registered","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"old","type":"address"},{"indexed":true,"name":"current","type":"address"}],"name":"NewOwner","type":"event"}]
      };
    };
  }
}, {package:"eth-method-registry",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/eth-method-registry/abi.json",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs/lib/index.js", {"./lib/getTransactionSuccess.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs/lib/lib/getTransactionSuccess.js","bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/bn.js/lib/bn.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethjs-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-abi/lib/index.js","ethjs-contract":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/lib/index.js","ethjs-filter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-filter/lib/index.js","ethjs-provider-http":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-provider-http/lib/index.js","ethjs-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-query/lib/index.js","ethjs-unit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-unit/lib/index.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs/node_modules/ethjs-util/lib/index.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/js-sha3/src/sha3.js","number-to-bn":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/number-to-bn/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs/lib/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var EthQuery = require('ethjs-query');
var EthFilter = require('ethjs-filter');
var EthContract = require('ethjs-contract');
var HttpProvider = require('ethjs-provider-http');
var abi = require('ethjs-abi');
// const getTxSuccess = require('ethjs-transaction-success'); // eslint-disable-line
var unit = require('ethjs-unit');
var keccak256 = require('js-sha3').keccak_256;
var toBN = require('number-to-bn');
var BN = require('bn.js');
var utils = require('ethjs-util');
var getTransactionSuccess = require('./lib/getTransactionSuccess.js');

module.exports = Eth;

/**
 * Returns the ethjs Eth instance.
 *
 * @method Eth
 * @param {Object} cprovider the web3 standard provider object
 * @param {Object} options the Eth options object
 * @returns {Object} eth Eth object instance
 * @throws if the new flag is not used in construction
 */

function Eth(cprovider, options) {
  if (!(this instanceof Eth)) {
    throw new Error('[ethjs] the Eth object requires you construct it with the "new" flag (i.e. `const eth = new Eth(...);`).');
  }
  var self = this;
  self.options = options || {};
  var query = new EthQuery(cprovider, self.options.query);
  Object.keys(Object.getPrototypeOf(query)).forEach(function (methodName) {
    self[methodName] = function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return query[methodName].apply(query, args);
    };
  });
  self.filter = new EthFilter(query, self.options.query);
  self.contract = new EthContract(query, self.options.query);
  self.currentProvider = query.rpc.currentProvider;
  self.setProvider = query.setProvider;
  self.getTransactionSuccess = getTransactionSuccess(self);
}

Eth.BN = BN;
Eth.isAddress = function (val) {
  return utils.isHexString(val, 20);
};
Eth.keccak256 = function (val) {
  return '0x' + keccak256(val);
};
Eth.Buffer = Buffer;
Eth.isHexString = utils.isHexString;
Eth.fromWei = unit.fromWei;
Eth.toWei = unit.toWei;
Eth.toBN = toBN;
Eth.abi = abi;
Eth.fromAscii = utils.fromAscii;
Eth.toAscii = utils.toAscii;
Eth.fromUtf8 = utils.fromUtf8;
Eth.toUtf8 = utils.toUtf8;
Eth.HttpProvider = HttpProvider;
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/readable-browser.js", {"./lib/_stream_duplex.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_passthrough.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/_stream_readable.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_transform.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_writable.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_writable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/readable-browser.js
      return function (require, module, exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/readable-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/node_modules/p-map/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/node_modules/p-map/index.js
      return function (require, module, exports) {
'use strict';
module.exports = (iterable, mapper, opts) => new Promise((resolve, reject) => {
	opts = Object.assign({
		concurrency: Infinity
	}, opts);

	if (typeof mapper !== 'function') {
		throw new TypeError('Mapper function is required');
	}

	const concurrency = opts.concurrency;

	if (!(typeof concurrency === 'number' && concurrency >= 1)) {
		throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${concurrency}\` (${typeof concurrency})`);
	}

	const ret = [];
	const iterator = iterable[Symbol.iterator]();
	let isRejected = false;
	let iterableDone = false;
	let resolvingCount = 0;
	let currentIdx = 0;

	const next = () => {
		if (isRejected) {
			return;
		}

		const nextItem = iterator.next();
		const i = currentIdx;
		currentIdx++;

		if (nextItem.done) {
			iterableDone = true;

			if (resolvingCount === 0) {
				resolve(ret);
			}

			return;
		}

		resolvingCount++;

		Promise.resolve(nextItem.value)
			.then(el => mapper(el, i))
			.then(
				val => {
					ret[i] = val;
					resolvingCount--;
					next();
				},
				err => {
					isRejected = true;
					reject(err);
				}
			);
	};

	for (let i = 0; i < concurrency; i++) {
		next();

		if (iterableDone) {
			break;
		}
	}
});

      };
    };
  }
}, {package:"p-map",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/node_modules/p-map/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-whilst/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/p-whilst/index.js
      return function (require, module, exports) {
'use strict';

const wrap = fn => new Promise(resolve => {
	resolve(fn());
});

module.exports = (condition, action) => wrap(function loop() {
	if (condition()) {
		return wrap(action).then(loop);
	}
});

      };
    };
  }
}, {package:"p-whilst",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-whilst/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-stringify-deterministic/lib/defaults.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/json-stringify-deterministic/lib/defaults.js
      return function (require, module, exports) {
module.exports = {
  space: '',
  cycles: false,
  replacer: (k, v) => v,
  stringify: JSON.stringify
}

      };
    };
  }
}, {package:"json-stringify-deterministic",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-stringify-deterministic/lib/defaults.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-stringify-deterministic/lib/util.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/json-stringify-deterministic/lib/util.js
      return function (require, module, exports) {
'use strict'

module.exports = {
  isArray: Array.isArray,
  assign: Object.assign,
  isObject: v => typeof v === 'object',
  isFunction: v => typeof v === 'function',
  isBoolean: v => typeof v === 'boolean',
  isRegex: v => v instanceof RegExp,
  keys: Object.keys
}

      };
    };
  }
}, {package:"json-stringify-deterministic",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-stringify-deterministic/lib/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/uport-base64url/dist/pad-string.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/uport-base64url/dist/pad-string.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var buffer_1 = require("buffer");
function padString(input) {
    var segmentLength = 4;
    var stringLength = input.length;
    var diff = stringLength % segmentLength;
    if (!diff) {
        return input;
    }
    var position = stringLength;
    var padLength = segmentLength - diff;
    var paddedStringLength = stringLength + padLength;
    var buffer = buffer_1.Buffer.alloc(paddedStringLength);
    buffer.write(input);
    while (padLength--) {
        buffer.write("=", position++);
    }
    return buffer.toString();
}
exports.default = padString;

      };
    };
  }
}, {package:"uport-base64url",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uport-base64url/dist/pad-string.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/is-defined.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/is-defined.js
      return function (require, module, exports) {
'use strict'
const isDefined = (arg) => arg !== undefined && arg !== null

module.exports = isDefined

      };
    };
  }
}, {package:"orbit-db-identity-provider",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/is-defined.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/identity-provider-interface.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/identity-provider-interface.js
      return function (require, module, exports) {
'use strict'

class IdentityProvider {
  /* Return id of identity (to be signed by orbit-db public key) */
  async getId (options) {}

  /* Return signature of OrbitDB public key signature */
  async signIdentity (data, options) {}

  /* Verify a signature of OrbitDB public key signature */
  static async verifyIdentity (identity) {}

  /* Return the type for this identity provider */
  static get type () {
    throw new Error(`'static get type ()' needs to be defined in the inheriting class`)
  }

  /*
    Return the type for this identity-procider
    NOTE! This is the only property of the interface that
    shouldn't be overridden in the inherited IdentityProvider
  */
  get type () {
    return this.constructor.type
  }
}

module.exports = IdentityProvider

      };
    };
  }
}, {package:"orbit-db-identity-provider",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/identity-provider-interface.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/dist/pad-string.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/dist/pad-string.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function padString(input) {
    var segmentLength = 4;
    var stringLength = input.length;
    var diff = stringLength % segmentLength;
    if (!diff) {
        return input;
    }
    var position = stringLength;
    var padLength = segmentLength - diff;
    var paddedStringLength = stringLength + padLength;
    var buffer = Buffer.alloc(paddedStringLength);
    buffer.write(input);
    while (padLength--) {
        buffer.write("=", position++);
    }
    return buffer.toString();
}
exports.default = padString;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"base64url",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/dist/pad-string.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/Digest.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","js-sha256":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha256/src/sha256.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha3/src/sha3.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/Digest.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sha256 = sha256;
exports.keccak = keccak;
exports.toEthereumAddress = toEthereumAddress;

var _jsSha = require("js-sha256");

var _jsSha2 = require("js-sha3");

var _buffer = require("buffer");

// eslint-disable-line
function sha256(payload) {
  return _buffer.Buffer.from(_jsSha.sha256.arrayBuffer(payload));
}

function keccak(data) {
  return _buffer.Buffer.from(_jsSha2.keccak_256.buffer(data));
}

function toEthereumAddress(hexPublicKey) {
  return "0x".concat(keccak(_buffer.Buffer.from(hexPublicKey.slice(2), 'hex')).slice(-20).toString('hex'));
}
      };
    };
  }
}, {package:"did-jwt",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/Digest.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/VerifierAlgorithm.js", {"./Digest":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/Digest.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","base64url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/index.js","elliptic":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/elliptic/lib/elliptic.js","tweetnacl":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/tweetnacl/nacl-fast.js","tweetnacl-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/tweetnacl-util/nacl-util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/VerifierAlgorithm.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toSignatureObject = toSignatureObject;
exports.verifyES256K = verifyES256K;
exports.verifyRecoverableES256K = verifyRecoverableES256K;
exports.verifyEd25519 = verifyEd25519;

var _elliptic = require("elliptic");

var _Digest = require("./Digest");

var _base64url = _interopRequireDefault(require("base64url"));

var _tweetnacl = _interopRequireDefault(require("tweetnacl"));

var _tweetnaclUtil = _interopRequireDefault(require("tweetnacl-util"));

var secp256k1 = new _elliptic.ec('secp256k1'); // converts a JOSE signature to it's components

function toSignatureObject(signature) {
  var recoverable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var rawsig = _base64url.default.toBuffer(signature);

  if (rawsig.length !== (recoverable ? 65 : 64)) throw new Error('wrong signature length');
  var r = rawsig.slice(0, 32).toString('hex');
  var s = rawsig.slice(32, 64).toString('hex');
  var sigObj = {
    r: r,
    s: s
  };

  if (recoverable) {
    sigObj.recoveryParam = rawsig[64];
  }

  return sigObj;
}

function verifyES256K(data, signature, authenticators) {
  var hash = (0, _Digest.sha256)(data);
  var sigObj = toSignatureObject(signature);
  var signer = authenticators.find(function (_ref) {
    var publicKeyHex = _ref.publicKeyHex;
    return secp256k1.keyFromPublic(publicKeyHex, 'hex').verify(hash, sigObj);
  });
  if (!signer) throw new Error('Signature invalid for JWT');
  return signer;
}

function verifyRecoverableES256K(data, signature, authenticators) {
  var sigObj = toSignatureObject(signature, true);
  var hash = (0, _Digest.sha256)(data);
  var recoveredKey = secp256k1.recoverPubKey(hash, sigObj, sigObj.recoveryParam);
  var recoveredPublicKeyHex = recoveredKey.encode('hex');
  var recoveredCompressedPublicKeyHex = recoveredKey.encode('hex', true);
  var recoveredAddress = (0, _Digest.toEthereumAddress)(recoveredPublicKeyHex);
  var signer = authenticators.find(function (_ref2) {
    var publicKeyHex = _ref2.publicKeyHex,
        ethereumAddress = _ref2.ethereumAddress;
    return publicKeyHex === recoveredPublicKeyHex || publicKeyHex === recoveredCompressedPublicKeyHex || ethereumAddress === recoveredAddress;
  });
  if (!signer) throw new Error('Signature invalid for JWT');
  return signer;
}

function verifyEd25519(data, signature, authenticators) {
  var clear = _tweetnaclUtil.default.decodeUTF8(data);

  var sig = _tweetnaclUtil.default.decodeBase64(_base64url.default.toBase64(signature));

  var signer = authenticators.find(function (_ref3) {
    var publicKeyBase64 = _ref3.publicKeyBase64;
    return _tweetnacl.default.sign.detached.verify(clear, sig, _tweetnaclUtil.default.decodeBase64(publicKeyBase64));
  });
  if (!signer) throw new Error('Signature invalid for JWT');
  return signer;
}

var algorithms = {
  ES256K: verifyES256K,
  'ES256K-R': verifyRecoverableES256K,
  'Ed25519': verifyEd25519
};

function VerifierAlgorithm(alg) {
  var impl = algorithms[alg];
  if (!impl) throw new Error("Unsupported algorithm ".concat(alg));
  return impl;
}

VerifierAlgorithm.toSignatureObject = toSignatureObject;
module.exports = VerifierAlgorithm;
      };
    };
  }
}, {package:"did-jwt",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/VerifierAlgorithm.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/objectSpread.js", {"./defineProperty.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/objectSpread.js
      return function (require, module, exports) {
var defineProperty = require("./defineProperty.js");

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? Object(arguments[i]) : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      defineProperty(target, key, source[key]);
    });
  }

  return target;
}

module.exports = _objectSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;
      };
    };
  }
}, {package:"@babel/runtime",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/objectSpread.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/SignerAlgorithm.js", {"@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","base64url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/SignerAlgorithm.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ES256KSigner = ES256KSigner;
exports.Ed25519Signer = Ed25519Signer;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _base64url = _interopRequireDefault(require("base64url"));

var _buffer = require("buffer");

function ES256KSigner() {
  var recoverable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  function toJose(_ref) {
    var r = _ref.r,
        s = _ref.s,
        recoveryParam = _ref.recoveryParam;

    var jose = _buffer.Buffer.alloc(recoverable ? 65 : 64);

    _buffer.Buffer.from(r, 'hex').copy(jose, 0);

    _buffer.Buffer.from(s, 'hex').copy(jose, 32);

    if (recoverable) {
      if (recoveryParam === undefined) throw new Error('Signer did not return a recoveryParam');
      jose[64] = recoveryParam;
    }

    return _base64url.default.encode(jose);
  }

  return (
    /*#__PURE__*/
    function () {
      var _sign = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(payload, signer) {
        var signature;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return signer(payload);

              case 2:
                signature = _context.sent;
                return _context.abrupt("return", toJose(signature));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function sign(_x, _x2) {
        return _sign.apply(this, arguments);
      }

      return sign;
    }()
  );
}

function Ed25519Signer() {
  return (
    /*#__PURE__*/
    function () {
      var _sign2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(payload, signer) {
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", signer(payload));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function sign(_x3, _x4) {
        return _sign2.apply(this, arguments);
      }

      return sign;
    }()
  );
}

var algorithms = {
  ES256K: ES256KSigner(),
  'ES256K-R': ES256KSigner(true),
  'Ed25519': Ed25519Signer()
};

function SignerAlgorithm(alg) {
  var impl = algorithms[alg];
  if (!impl) throw new Error("Unsupported algorithm ".concat(alg));
  return impl;
}

module.exports = SignerAlgorithm;
      };
    };
  }
}, {package:"did-jwt",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/SignerAlgorithm.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/is-valid-eth-address.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/is-valid-eth-address.js
      return function (require, module, exports) {
'use strict'

const isValidEthAddress = (web3, address) => {
  return web3.utils.isAddress(address)
}
module.exports = isValidEthAddress

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/is-valid-eth-address.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/io.js", {"orbit-db-io":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-io/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/io.js
      return function (require, module, exports) {
'use strict'
const io = require('orbit-db-io')

module.exports = {
  read: async (ipfs, cid, options = {}) => {
    const access = await io.read(ipfs, cid, options)
    return (typeof access.write === 'string') ? JSON.parse(access.write) : access.write //v0 access.write not stringified
  },
  write: io.write
}

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/io.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-map/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/p-map/index.js
      return function (require, module, exports) {
'use strict';

const pMap = (iterable, mapper, options) => new Promise((resolve, reject) => {
	options = Object.assign({
		concurrency: Infinity
	}, options);

	if (typeof mapper !== 'function') {
		throw new TypeError('Mapper function is required');
	}

	const {concurrency} = options;

	if (!(typeof concurrency === 'number' && concurrency >= 1)) {
		throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${concurrency}\` (${typeof concurrency})`);
	}

	const ret = [];
	const iterator = iterable[Symbol.iterator]();
	let isRejected = false;
	let isIterableDone = false;
	let resolvingCount = 0;
	let currentIndex = 0;

	const next = () => {
		if (isRejected) {
			return;
		}

		const nextItem = iterator.next();
		const i = currentIndex;
		currentIndex++;

		if (nextItem.done) {
			isIterableDone = true;

			if (resolvingCount === 0) {
				resolve(ret);
			}

			return;
		}

		resolvingCount++;

		Promise.resolve(nextItem.value)
			.then(element => mapper(element, i))
			.then(
				value => {
					ret[i] = value;
					resolvingCount--;
					next();
				},
				error => {
					isRejected = true;
					reject(error);
				}
			);
	};

	for (let i = 0; i < concurrency; i++) {
		next();

		if (isIterableDone) {
			break;
		}
	}
});

module.exports = pMap;
// TODO: Remove this for the next major release
module.exports.default = pMap;

      };
    };
  }
}, {package:"p-map",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-map/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/node_modules/safe-buffer/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/node_modules/safe-buffer/index.js
      return function (require, module, exports) {
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

      };
    };
  }
}, {package:"safe-buffer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/node_modules/safe-buffer/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ltgt/index.js", {"../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ltgt/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){

exports.compare = function (a, b) {

  if(Buffer.isBuffer(a)) {
    var l = Math.min(a.length, b.length)
    for(var i = 0; i < l; i++) {
      var cmp = a[i] - b[i]
      if(cmp) return cmp
    }
    return a.length - b.length
  }

  return a < b ? -1 : a > b ? 1 : 0
}

// to be compatible with the current abstract-leveldown tests
// nullish or empty strings.
// I could use !!val but I want to permit numbers and booleans,
// if possible.

function isDef (val) {
  return val !== undefined && val !== ''
}

function has (range, name) {
  return Object.hasOwnProperty.call(range, name)
}

function hasKey(range, name) {
  return Object.hasOwnProperty.call(range, name) && name
}

var lowerBoundKey = exports.lowerBoundKey = function (range) {
    return (
       hasKey(range, 'gt')
    || hasKey(range, 'gte')
    || hasKey(range, 'min')
    || (range.reverse ? hasKey(range, 'end') : hasKey(range, 'start'))
    || undefined
    )
}

var lowerBound = exports.lowerBound = function (range, def) {
  var k = lowerBoundKey(range)
  return k ? range[k] : def
}

var lowerBoundInclusive = exports.lowerBoundInclusive = function (range) {
  return has(range, 'gt') ? false : true
}

var upperBoundInclusive = exports.upperBoundInclusive =
  function (range) {
    return (has(range, 'lt') /*&& !range.maxEx*/) ? false : true
  }

var lowerBoundExclusive = exports.lowerBoundExclusive =
  function (range) {
    return !lowerBoundInclusive(range)
  }

var upperBoundExclusive = exports.upperBoundExclusive =
  function (range) {
    return !upperBoundInclusive(range)
  }

var upperBoundKey = exports.upperBoundKey = function (range) {
    return (
       hasKey(range, 'lt')
    || hasKey(range, 'lte')
    || hasKey(range, 'max')
    || (range.reverse ? hasKey(range, 'start') : hasKey(range, 'end'))
    || undefined
    )
}

var upperBound = exports.upperBound = function (range, def) {
  var k = upperBoundKey(range)
  return k ? range[k] : def
}

exports.start = function (range, def) {
  return range.reverse ? upperBound(range, def) : lowerBound(range, def)
}
exports.end = function (range, def) {
  return range.reverse ? lowerBound(range, def) : upperBound(range, def)
}
exports.startInclusive = function (range) {
  return (
    range.reverse
  ? upperBoundInclusive(range)
  : lowerBoundInclusive(range)
  )
}
exports.endInclusive = function (range) {
  return (
    range.reverse
  ? lowerBoundInclusive(range)
  : upperBoundInclusive(range)
  )
}

function id (e) { return e }

exports.toLtgt = function (range, _range, map, lower, upper) {
  _range = _range || {}
  map = map || id
  var defaults = arguments.length > 3
  var lb = exports.lowerBoundKey(range)
  var ub = exports.upperBoundKey(range)
  if(lb) {
    if(lb === 'gt') _range.gt = map(range.gt, false)
    else            _range.gte = map(range[lb], false)
  }
  else if(defaults)
    _range.gte = map(lower, false)

  if(ub) {
    if(ub === 'lt') _range.lt = map(range.lt, true)
    else            _range.lte = map(range[ub], true)
  }
  else if(defaults)
    _range.lte = map(upper, true)

  if(range.reverse != null)
    _range.reverse = !!range.reverse

  //if range was used mutably
  //(in level-sublevel it's part of an options object
  //that has more properties on it.)
  if(has(_range, 'max'))   delete _range.max
  if(has(_range, 'min'))   delete _range.min
  if(has(_range, 'start')) delete _range.start
  if(has(_range, 'end'))   delete _range.end

  return _range
}

exports.contains = function (range, key, compare) {
  compare = compare || exports.compare

  var lb = lowerBound(range)
  if(isDef(lb)) {
    var cmp = compare(key, lb)
    if(cmp < 0 || (cmp === 0 && lowerBoundExclusive(range)))
      return false
  }

  var ub = upperBound(range)
  if(isDef(ub)) {
    var cmp = compare(key, ub)
    if(cmp > 0 || (cmp === 0) && upperBoundExclusive(range))
      return false
  }

  return true
}

exports.filter = function (range, compare) {
  return function (key) {
    return exports.contains(range, key, compare)
  }
}



}).call(this)}).call(this,{"isBuffer":require("../is-buffer/index.js")})

      };
    };
  }
}, {package:"ltgt",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ltgt/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/abstract-chained-batch.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/abstract-chained-batch.js
      return function (require, module, exports) {
function AbstractChainedBatch (db) {
  if (typeof db !== 'object' || db === null) {
    throw new TypeError('First argument must be an abstract-leveldown compliant store')
  }

  this.db = db
  this._operations = []
  this._written = false
}

AbstractChainedBatch.prototype._checkWritten = function () {
  if (this._written) {
    throw new Error('write() already called on this batch')
  }
}

AbstractChainedBatch.prototype.put = function (key, value) {
  this._checkWritten()

  var err = this.db._checkKey(key) || this.db._checkValue(value)
  if (err) throw err

  key = this.db._serializeKey(key)
  value = this.db._serializeValue(value)

  this._put(key, value)

  return this
}

AbstractChainedBatch.prototype._put = function (key, value) {
  this._operations.push({ type: 'put', key: key, value: value })
}

AbstractChainedBatch.prototype.del = function (key) {
  this._checkWritten()

  var err = this.db._checkKey(key)
  if (err) throw err

  key = this.db._serializeKey(key)
  this._del(key)

  return this
}

AbstractChainedBatch.prototype._del = function (key) {
  this._operations.push({ type: 'del', key: key })
}

AbstractChainedBatch.prototype.clear = function () {
  this._checkWritten()
  this._clear()

  return this
}

AbstractChainedBatch.prototype._clear = function () {
  this._operations = []
}

AbstractChainedBatch.prototype.write = function (options, callback) {
  this._checkWritten()

  if (typeof options === 'function') { callback = options }
  if (typeof callback !== 'function') {
    throw new Error('write() requires a callback argument')
  }
  if (typeof options !== 'object' || options === null) {
    options = {}
  }

  this._written = true
  this._write(options, callback)
}

AbstractChainedBatch.prototype._write = function (options, callback) {
  this.db._batch(this._operations, options, callback)
}

module.exports = AbstractChainedBatch

      };
    };
  }
}, {package:"abstract-leveldown",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/abstract-chained-batch.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/abstract-iterator.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/abstract-iterator.js
      return function (require, module, exports) {
(function (process){(function (){
function AbstractIterator (db) {
  if (typeof db !== 'object' || db === null) {
    throw new TypeError('First argument must be an abstract-leveldown compliant store')
  }

  this.db = db
  this._ended = false
  this._nexting = false
}

AbstractIterator.prototype.next = function (callback) {
  var self = this

  if (typeof callback !== 'function') {
    throw new Error('next() requires a callback argument')
  }

  if (self._ended) {
    process.nextTick(callback, new Error('cannot call next() after end()'))
    return self
  }

  if (self._nexting) {
    process.nextTick(callback, new Error('cannot call next() before previous next() has completed'))
    return self
  }

  self._nexting = true
  self._next(function () {
    self._nexting = false
    callback.apply(null, arguments)
  })

  return self
}

AbstractIterator.prototype._next = function (callback) {
  process.nextTick(callback)
}

AbstractIterator.prototype.seek = function (target) {
  if (this._ended) {
    throw new Error('cannot call seek() after end()')
  }
  if (this._nexting) {
    throw new Error('cannot call seek() before next() has completed')
  }

  target = this.db._serializeKey(target)
  this._seek(target)
}

AbstractIterator.prototype._seek = function (target) {}

AbstractIterator.prototype.end = function (callback) {
  if (typeof callback !== 'function') {
    throw new Error('end() requires a callback argument')
  }

  if (this._ended) {
    return process.nextTick(callback, new Error('end() already called on iterator'))
  }

  this._ended = true
  this._end(callback)
}

AbstractIterator.prototype._end = function (callback) {
  process.nextTick(callback)
}

module.exports = AbstractIterator

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"abstract-leveldown",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/abstract-iterator.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/abstract-leveldown.js", {"../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./abstract-chained-batch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/abstract-chained-batch.js","./abstract-iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/abstract-iterator.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","xtend":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xtend/immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/abstract-leveldown.js
      return function (require, module, exports) {
(function (Buffer,process){(function (){
var xtend = require('xtend')
var AbstractIterator = require('./abstract-iterator')
var AbstractChainedBatch = require('./abstract-chained-batch')
var hasOwnProperty = Object.prototype.hasOwnProperty
var rangeOptions = 'start end gt gte lt lte'.split(' ')

function AbstractLevelDOWN () {
  this.status = 'new'
}

AbstractLevelDOWN.prototype.open = function (options, callback) {
  var self = this
  var oldStatus = this.status

  if (typeof options === 'function') callback = options

  if (typeof callback !== 'function') {
    throw new Error('open() requires a callback argument')
  }

  if (typeof options !== 'object' || options === null) options = {}

  options.createIfMissing = options.createIfMissing !== false
  options.errorIfExists = !!options.errorIfExists

  this.status = 'opening'
  this._open(options, function (err) {
    if (err) {
      self.status = oldStatus
      return callback(err)
    }
    self.status = 'open'
    callback()
  })
}

AbstractLevelDOWN.prototype._open = function (options, callback) {
  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.close = function (callback) {
  var self = this
  var oldStatus = this.status

  if (typeof callback !== 'function') {
    throw new Error('close() requires a callback argument')
  }

  this.status = 'closing'
  this._close(function (err) {
    if (err) {
      self.status = oldStatus
      return callback(err)
    }
    self.status = 'closed'
    callback()
  })
}

AbstractLevelDOWN.prototype._close = function (callback) {
  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.get = function (key, options, callback) {
  if (typeof options === 'function') callback = options

  if (typeof callback !== 'function') {
    throw new Error('get() requires a callback argument')
  }

  var err = this._checkKey(key)
  if (err) return process.nextTick(callback, err)

  key = this._serializeKey(key)

  if (typeof options !== 'object' || options === null) options = {}

  options.asBuffer = options.asBuffer !== false

  this._get(key, options, callback)
}

AbstractLevelDOWN.prototype._get = function (key, options, callback) {
  process.nextTick(function () { callback(new Error('NotFound')) })
}

AbstractLevelDOWN.prototype.put = function (key, value, options, callback) {
  if (typeof options === 'function') callback = options

  if (typeof callback !== 'function') {
    throw new Error('put() requires a callback argument')
  }

  var err = this._checkKey(key) || this._checkValue(value)
  if (err) return process.nextTick(callback, err)

  key = this._serializeKey(key)
  value = this._serializeValue(value)

  if (typeof options !== 'object' || options === null) options = {}

  this._put(key, value, options, callback)
}

AbstractLevelDOWN.prototype._put = function (key, value, options, callback) {
  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.del = function (key, options, callback) {
  if (typeof options === 'function') callback = options

  if (typeof callback !== 'function') {
    throw new Error('del() requires a callback argument')
  }

  var err = this._checkKey(key)
  if (err) return process.nextTick(callback, err)

  key = this._serializeKey(key)

  if (typeof options !== 'object' || options === null) options = {}

  this._del(key, options, callback)
}

AbstractLevelDOWN.prototype._del = function (key, options, callback) {
  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.batch = function (array, options, callback) {
  if (!arguments.length) return this._chainedBatch()

  if (typeof options === 'function') callback = options

  if (typeof array === 'function') callback = array

  if (typeof callback !== 'function') {
    throw new Error('batch(array) requires a callback argument')
  }

  if (!Array.isArray(array)) {
    return process.nextTick(callback, new Error('batch(array) requires an array argument'))
  }

  if (array.length === 0) {
    return process.nextTick(callback)
  }

  if (typeof options !== 'object' || options === null) options = {}

  var serialized = new Array(array.length)

  for (var i = 0; i < array.length; i++) {
    if (typeof array[i] !== 'object' || array[i] === null) {
      return process.nextTick(callback, new Error('batch(array) element must be an object and not `null`'))
    }

    var e = xtend(array[i])

    if (e.type !== 'put' && e.type !== 'del') {
      return process.nextTick(callback, new Error("`type` must be 'put' or 'del'"))
    }

    var err = this._checkKey(e.key)
    if (err) return process.nextTick(callback, err)

    e.key = this._serializeKey(e.key)

    if (e.type === 'put') {
      var valueErr = this._checkValue(e.value)
      if (valueErr) return process.nextTick(callback, valueErr)

      e.value = this._serializeValue(e.value)
    }

    serialized[i] = e
  }

  this._batch(serialized, options, callback)
}

AbstractLevelDOWN.prototype._batch = function (array, options, callback) {
  process.nextTick(callback)
}

AbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {
  options = cleanRangeOptions(this, options)

  options.reverse = !!options.reverse
  options.keys = options.keys !== false
  options.values = options.values !== false
  options.limit = 'limit' in options ? options.limit : -1
  options.keyAsBuffer = options.keyAsBuffer !== false
  options.valueAsBuffer = options.valueAsBuffer !== false

  return options
}

function cleanRangeOptions (db, options) {
  var result = {}

  for (var k in options) {
    if (!hasOwnProperty.call(options, k)) continue

    var opt = options[k]

    if (isRangeOption(k)) {
      // Note that we don't reject nullish and empty options here. While
      // those types are invalid as keys, they are valid as range options.
      opt = db._serializeKey(opt)
    }

    result[k] = opt
  }

  return result
}

function isRangeOption (k) {
  return rangeOptions.indexOf(k) !== -1
}

AbstractLevelDOWN.prototype.iterator = function (options) {
  if (typeof options !== 'object' || options === null) options = {}
  options = this._setupIteratorOptions(options)
  return this._iterator(options)
}

AbstractLevelDOWN.prototype._iterator = function (options) {
  return new AbstractIterator(this)
}

AbstractLevelDOWN.prototype._chainedBatch = function () {
  return new AbstractChainedBatch(this)
}

AbstractLevelDOWN.prototype._serializeKey = function (key) {
  return key
}

AbstractLevelDOWN.prototype._serializeValue = function (value) {
  return value
}

AbstractLevelDOWN.prototype._checkKey = function (key) {
  if (key === null || key === undefined) {
    return new Error('key cannot be `null` or `undefined`')
  } else if (Buffer.isBuffer(key) && key.length === 0) {
    return new Error('key cannot be an empty Buffer')
  } else if (key === '') {
    return new Error('key cannot be an empty String')
  } else if (Array.isArray(key) && key.length === 0) {
    return new Error('key cannot be an empty Array')
  }
}

AbstractLevelDOWN.prototype._checkValue = function (value) {
  if (value === null || value === undefined) {
    return new Error('value cannot be `null` or `undefined`')
  }
}

module.exports = AbstractLevelDOWN

}).call(this)}).call(this,{"isBuffer":require("../is-buffer/index.js")},require('_process'))

      };
    };
  }
}, {package:"abstract-leveldown",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/abstract-leveldown.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/typedarray-to-buffer/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","is-typedarray":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-typedarray/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/typedarray-to-buffer/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <https://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = require('is-typedarray').strict

module.exports = function typedarrayToBuffer (arr) {
  if (isTypedArray(arr)) {
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
    var buf = Buffer.from(arr.buffer)
    if (arr.byteLength !== arr.buffer.byteLength) {
      // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)
    }
    return buf
  } else {
    // Pass through all other types to `Buffer.from`
    return Buffer.from(arr)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"typedarray-to-buffer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/typedarray-to-buffer/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/index.js", {"./messageChannel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/messageChannel.js","./mutation.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/mutation.js","./nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/nextTick.js","./stateChange":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/stateChange.js","./timeout":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/timeout.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/index.js
      return function (require, module, exports) {
'use strict';
var types = [
  require('./nextTick'),
  require('./mutation.js'),
  require('./messageChannel'),
  require('./stateChange'),
  require('./timeout')
];
var draining;
var currentQueue;
var queueIndex = -1;
var queue = [];
var scheduled = false;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    nextTick();
  }
}

//named nextTick for less confusing stack traces
function nextTick() {
  if (draining) {
    return;
  }
  scheduled = false;
  draining = true;
  var len = queue.length;
  var timeout = setTimeout(cleanUpNextTick);
  while (len) {
    currentQueue = queue;
    queue = [];
    while (currentQueue && ++queueIndex < len) {
      currentQueue[queueIndex].run();
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  queueIndex = -1;
  draining = false;
  clearTimeout(timeout);
}
var scheduleDrain;
var i = -1;
var len = types.length;
while (++i < len) {
  if (types[i] && types[i].test && types[i].test()) {
    scheduleDrain = types[i].install(nextTick);
    break;
  }
}
// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  var fun = this.fun;
  var array = this.array;
  switch (array.length) {
  case 0:
    return fun();
  case 1:
    return fun(array[0]);
  case 2:
    return fun(array[0], array[1]);
  case 3:
    return fun(array[0], array[1], array[2]);
  default:
    return fun.apply(null, array);
  }

};
module.exports = immediate;
function immediate(task) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(task, args));
  if (!scheduled && !draining) {
    scheduled = true;
    scheduleDrain();
  }
}

      };
    };
  }
}, {package:"immediate",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/verifiers/verifierv0.js", {"elliptic":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/elliptic/lib/elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/verifiers/verifierv0.js
      return function (require, module, exports) {
'use strict'

const EC = require('elliptic').ec
const ec = new EC('secp256k1')

module.exports = {
  verify: async (signature, publicKey, data) => {
    if (!signature) {
      throw new Error('No signature given')
    }
    if (!publicKey) {
      throw new Error('Given publicKey was undefined')
    }
    if (!data) {
      throw new Error('Given input data was undefined')
    }
    let res = false
    const key = ec.keyPair({
      pub: publicKey,
      pubEnc: 'hex'
    })
    try {
      res = ec.verify(data, signature, key)
    } catch (e) {
      // Catches 'Error: Signature without r or s'
    }
    return Promise.resolve(res)
  }
}

      };
    };
  }
}, {package:"orbit-db-keystore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/verifiers/verifierv0.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/verifiers/verifierv1.js", {"libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js","safe-buffer/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/verifiers/verifierv1.js
      return function (require, module, exports) {
'use strict'
const crypto = require('libp2p-crypto')
const Buffer = require('safe-buffer/').Buffer

module.exports = {
  verify: async (signature, publicKey, data) => {
    if (!signature) {
      throw new Error('No signature given')
    }
    if (!publicKey) {
      throw new Error('Given publicKey was undefined')
    }
    if (!data) {
      throw new Error('Given input data was undefined')
    }

    if (!Buffer.isBuffer(data)) {
      data = Buffer.from(data)
    }

    const isValid = (key, msg, sig) => new Promise((resolve, reject) => {
      key.verify(msg, sig, (err, valid) => {
        if (!err) {
          resolve(valid)
        }
        reject(valid)
      })
    })

    let res = false
    try {
      const pubKey = crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(Buffer.from(publicKey, 'hex'))
      res = await isValid(pubKey, data, Buffer.from(signature, 'hex'))
    } catch (e) {
      // Catch error: sig length wrong
    }
    return Promise.resolve(res)
  }
}

      };
    };
  }
}, {package:"orbit-db-keystore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/verifiers/verifierv1.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/common.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/common.js
      return function (require, module, exports) {
exports.getCallback = function (options, callback) {
  return typeof options === 'function' ? options : callback
}

exports.getOptions = function (options) {
  return typeof options === 'object' && options !== null ? options : {}
}

      };
    };
  }
}, {package:"levelup",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/common.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/promisify.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/promisify.js
      return function (require, module, exports) {
function promisify () {
  var callback
  var promise = new Promise(function (resolve, reject) {
    callback = function callback (err, value) {
      if (err) reject(err)
      else resolve(value)
    }
  })
  callback.promise = promise
  return callback
}

module.exports = promisify

      };
    };
  }
}, {package:"levelup",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/promisify.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/batch.js", {"./common":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/common.js","./promisify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/promisify.js","level-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-errors/errors.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/batch.js
      return function (require, module, exports) {
var WriteError = require('level-errors').WriteError
var promisify = require('./promisify')
var getCallback = require('./common').getCallback
var getOptions = require('./common').getOptions

function Batch (levelup) {
  this._levelup = levelup
  this.batch = levelup.db.batch()
  this.ops = []
  this.length = 0
}

Batch.prototype.put = function (key, value) {
  try {
    this.batch.put(key, value)
  } catch (e) {
    throw new WriteError(e)
  }

  this.ops.push({ type: 'put', key: key, value: value })
  this.length++

  return this
}

Batch.prototype.del = function (key) {
  try {
    this.batch.del(key)
  } catch (err) {
    throw new WriteError(err)
  }

  this.ops.push({ type: 'del', key: key })
  this.length++

  return this
}

Batch.prototype.clear = function () {
  try {
    this.batch.clear()
  } catch (err) {
    throw new WriteError(err)
  }

  this.ops = []
  this.length = 0

  return this
}

Batch.prototype.write = function (options, callback) {
  var levelup = this._levelup
  var ops = this.ops
  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  options = getOptions(options)

  try {
    this.batch.write(options, function (err) {
      if (err) { return callback(new WriteError(err)) }
      levelup.emit('batch', ops)
      callback()
    })
  } catch (err) {
    throw new WriteError(err)
  }

  return promise
}

module.exports = Batch

      };
    };
  }
}, {package:"levelup",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/batch.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/deferred-leveldown/deferred-leveldown.js", {"./deferred-iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/deferred-leveldown/deferred-iterator.js","abstract-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/deferred-leveldown/deferred-leveldown.js
      return function (require, module, exports) {
var AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN
var inherits = require('inherits')
var DeferredIterator = require('./deferred-iterator')
var deferrables = 'put get del batch'.split(' ')

function DeferredLevelDOWN (db) {
  AbstractLevelDOWN.call(this, '')
  this._db = db
  this._operations = []
  this._iterators = []
  closed(this)
}

inherits(DeferredLevelDOWN, AbstractLevelDOWN)

DeferredLevelDOWN.prototype._open = function (options, callback) {
  var self = this

  this._db.open(options, function (err) {
    if (err) return callback(err)

    self._operations.forEach(function (op) {
      self._db[op.method].apply(self._db, op.args)
    })
    self._operations = []
    self._iterators.forEach(function (it) {
      it.setDb(self._db)
    })
    self._iterators = []
    open(self)
    callback()
  })
}

DeferredLevelDOWN.prototype._close = function (callback) {
  var self = this

  this._db.close(function (err) {
    if (err) return callback(err)
    closed(self)
    callback()
  })
}

function open (self) {
  deferrables.concat('iterator').forEach(function (m) {
    self['_' + m] = function () {
      return this._db[m].apply(this._db, arguments)
    }
  })
  if (self._db.approximateSize) {
    self.approximateSize = function () {
      return this._db.approximateSize.apply(this._db, arguments)
    }
  }
}

function closed (self) {
  deferrables.forEach(function (m) {
    self['_' + m] = function () {
      this._operations.push({ method: m, args: arguments })
    }
  })
  if (typeof self._db.approximateSize === 'function') {
    self.approximateSize = function () {
      this._operations.push({
        method: 'approximateSize',
        args: arguments
      })
    }
  }
  self._iterator = function (options) {
    var it = new DeferredIterator(options)
    this._iterators.push(it)
    return it
  }
}

DeferredLevelDOWN.prototype._serializeKey = function (key) {
  return key
}

DeferredLevelDOWN.prototype._serializeValue = function (value) {
  return value
}

module.exports = DeferredLevelDOWN
module.exports.DeferredIterator = DeferredIterator

      };
    };
  }
}, {package:"deferred-leveldown",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/deferred-leveldown/deferred-leveldown.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-errors/errors.js", {"errno":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/errno/errno.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/level-errors/errors.js
      return function (require, module, exports) {
/* Copyright (c) 2012-2017 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT License
 * <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>
 */

var createError = require('errno').create
var LevelUPError = createError('LevelUPError')
var NotFoundError = createError('NotFoundError', LevelUPError)

NotFoundError.prototype.notFound = true
NotFoundError.prototype.status = 404

module.exports = {
  LevelUPError: LevelUPError,
  InitializationError: createError('InitializationError', LevelUPError),
  OpenError: createError('OpenError', LevelUPError),
  ReadError: createError('ReadError', LevelUPError),
  WriteError: createError('WriteError', LevelUPError),
  NotFoundError: NotFoundError,
  EncodingError: createError('EncodingError', LevelUPError)
}

      };
    };
  }
}, {package:"level-errors",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-errors/errors.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/level-iterator-stream/index.js", {"inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/readable-browser.js","xtend":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xtend/immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/level-iterator-stream/index.js
      return function (require, module, exports) {
var inherits = require('inherits')
var Readable = require('readable-stream').Readable
var extend = require('xtend')

module.exports = ReadStream
inherits(ReadStream, Readable)

function ReadStream (iterator, options) {
  if (!(this instanceof ReadStream)) return new ReadStream(iterator, options)
  options = options || {}
  Readable.call(this, extend(options, {
    objectMode: true
  }))
  this._iterator = iterator
  this._options = options
  this.on('end', this.destroy.bind(this, null, null))
}

ReadStream.prototype._read = function () {
  var self = this
  var options = this._options
  if (this.destroyed) return

  this._iterator.next(function (err, key, value) {
    if (self.destroyed) return
    if (err) return self.destroy(err)

    if (key === undefined && value === undefined) {
      self.push(null)
    } else if (options.keys !== false && options.values === false) {
      self.push(key)
    } else if (options.keys === false && options.values !== false) {
      self.push(value)
    } else {
      self.push({ key: key, value: value })
    }
  })
}

ReadStream.prototype._destroy = function (err, callback) {
  this._iterator.end(function (err2) {
    callback(err || err2)
  })
}

      };
    };
  }
}, {package:"level-iterator-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/level-iterator-stream/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/drain.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/drain.js
      return function (require, module, exports) {
'use strict'

module.exports = function drain (op, done) {
  var read, abort

  function sink (_read) {
    read = _read
    if(abort) return sink.abort()
    //this function is much simpler to write if you
    //just use recursion, but by using a while loop
    //we do not blow the stack if the stream happens to be sync.
    ;(function next() {
        var loop = true, cbed = false
        while(loop) {
          cbed = false
          read(null, function (end, data) {
            cbed = true
            if(end = end || abort) {
              loop = false
              if(done) done(end === true ? null : end)
              else if(end && end !== true)
                throw end
            }
            else if(op && false === op(data) || abort) {
              loop = false
              read(abort || true, done || function () {})
            }
            else if(!loop){
              next()
            }
          })
          if(!cbed) {
            loop = false
            return
          }
        }
      })()
  }

  sink.abort = function (err, cb) {
    if('function' == typeof err)
      cb = err, err = true
    abort = err || true
    if(read) return read(abort, cb || function () {})
  }

  return sink
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/drain.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/eachOfSeries.js", {"./eachOfLimit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/eachOfLimit.js","./internal/doLimit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/doLimit.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/eachOfSeries.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eachOfLimit = require('./eachOfLimit');

var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

var _doLimit = require('./internal/doLimit');

var _doLimit2 = _interopRequireDefault(_doLimit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
 *
 * @name eachOfSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Invoked with (err).
 */
exports.default = (0, _doLimit2.default)(_eachOfLimit2.default, 1);
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/eachOfSeries.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/sort-keys/index.js", {"is-plain-obj":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-plain-obj/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/sort-keys/index.js
      return function (require, module, exports) {
'use strict';
const isPlainObj = require('is-plain-obj');

module.exports = (obj, opts) => {
	if (!isPlainObj(obj)) {
		throw new TypeError('Expected a plain object');
	}

	opts = opts || {};

	// DEPRECATED
	if (typeof opts === 'function') {
		throw new TypeError('Specify the compare function as an option instead');
	}

	const deep = opts.deep;
	const seenInput = [];
	const seenOutput = [];

	const sortKeys = x => {
		const seenIndex = seenInput.indexOf(x);

		if (seenIndex !== -1) {
			return seenOutput[seenIndex];
		}

		const ret = {};
		const keys = Object.keys(x).sort(opts.compare);

		seenInput.push(x);
		seenOutput.push(ret);

		for (let i = 0; i < keys.length; i++) {
			const key = keys[i];
			const val = x[key];

			if (deep && Array.isArray(val)) {
				const retArr = [];

				for (let j = 0; j < val.length; j++) {
					retArr[j] = isPlainObj(val[j]) ? sortKeys(val[j]) : val[j];
				}

				ret[key] = retArr;
				continue;
			}

			ret[key] = deep && isPlainObj(val) ? sortKeys(val) : val;
		}

		return ret;
	};

	return sortKeys(obj);
};

      };
    };
  }
}, {package:"sort-keys",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/sort-keys/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/just-safe-set/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/just-safe-set/index.js
      return function (require, module, exports) {
module.exports = set;

/*
  var obj1 = {};
  set(obj1, 'a.aa.aaa', 4); // true
  obj1; // {a: {aa: {aaa: 4}}}

  var obj2 = {};
  set(obj2, ['a', 'aa', 'aaa'], 4); // true
  obj2; // {a: {aa: {aaa: 4}}}

  var obj3 = {a: {aa: {aaa: 2}}};
  set(obj3, 'a.aa.aaa', 3); // true
  obj3; // {a: {aa: {aaa: 3}}}

  // don't clobber existing
  var obj4 = {a: {aa: {aaa: 2}}};
  set(obj4, 'a.aa', {bbb: 7}); // false

  const obj5 = {a: {}};
  const sym = Symbol();
  set(obj5.a, sym, 7); // true
  obj5; // {a: {Symbol(): 7}}
*/

function set(obj, propsArg, value) {
  var props, lastProp;
  if (Array.isArray(propsArg)) {
    props = propsArg.slice(0);
  }
  if (typeof propsArg == 'string') {
    props = propsArg.split('.');
  }
  if (typeof propsArg == 'symbol') {
    props = [propsArg];
  }
  if (!Array.isArray(props)) {
    throw new Error('props arg must be an array, a string or a symbol');
  }
  lastProp = props.pop();
  if (!lastProp) {
    return false;
  }
  prototypeCheck(lastProp);
  var thisProp;
  while ((thisProp = props.shift())) {
    prototypeCheck(thisProp);
    if (typeof obj[thisProp] == 'undefined') {
      obj[thisProp] = {};
    }
    obj = obj[thisProp];
    if (!obj || typeof obj != 'object') {
      return false;
    }
  }
  obj[lastProp] = value;
  return true;
}

function prototypeCheck(prop) {
  if (prop === '__proto__' || prop === 'constructor' || prop === 'prototype') {
    throw new Error('setting of prototype values not supported');
  }
}

      };
    };
  }
}, {package:"just-safe-set",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/just-safe-set/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/queue.js", {"./internal/queue":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/queue.js","./internal/wrapAsync":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/wrapAsync.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/queue.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (worker, concurrency) {
  var _worker = (0, _wrapAsync2.default)(worker);
  return (0, _queue2.default)(function (items, cb) {
    _worker(items[0], cb);
  }, concurrency, 1);
};

var _queue = require('./internal/queue');

var _queue2 = _interopRequireDefault(_queue);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];

/**
 * A queue of tasks for the worker function to complete.
 * @typedef {Object} QueueObject
 * @memberOf module:ControlFlow
 * @property {Function} length - a function returning the number of items
 * waiting to be processed. Invoke with `queue.length()`.
 * @property {boolean} started - a boolean indicating whether or not any
 * items have been pushed and processed by the queue.
 * @property {Function} running - a function returning the number of items
 * currently being processed. Invoke with `queue.running()`.
 * @property {Function} workersList - a function returning the array of items
 * currently being processed. Invoke with `queue.workersList()`.
 * @property {Function} idle - a function returning false if there are items
 * waiting or being processed, or true if not. Invoke with `queue.idle()`.
 * @property {number} concurrency - an integer for determining how many `worker`
 * functions should be run in parallel. This property can be changed after a
 * `queue` is created to alter the concurrency on-the-fly.
 * @property {Function} push - add a new task to the `queue`. Calls `callback`
 * once the `worker` has finished processing the task. Instead of a single task,
 * a `tasks` array can be submitted. The respective callback is used for every
 * task in the list. Invoke with `queue.push(task, [callback])`,
 * @property {Function} unshift - add a new task to the front of the `queue`.
 * Invoke with `queue.unshift(task, [callback])`.
 * @property {Function} remove - remove items from the queue that match a test
 * function.  The test function will be passed an object with a `data` property,
 * and a `priority` property, if this is a
 * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
 * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
 * `function ({data, priority}) {}` and returns a Boolean.
 * @property {Function} saturated - a callback that is called when the number of
 * running workers hits the `concurrency` limit, and further tasks will be
 * queued.
 * @property {Function} unsaturated - a callback that is called when the number
 * of running workers is less than the `concurrency` & `buffer` limits, and
 * further tasks will not be queued.
 * @property {number} buffer - A minimum threshold buffer in order to say that
 * the `queue` is `unsaturated`.
 * @property {Function} empty - a callback that is called when the last item
 * from the `queue` is given to a `worker`.
 * @property {Function} drain - a callback that is called when the last item
 * from the `queue` has returned from the `worker`.
 * @property {Function} error - a callback that is called when a task errors.
 * Has the signature `function(error, task)`.
 * @property {boolean} paused - a boolean for determining whether the queue is
 * in a paused state.
 * @property {Function} pause - a function that pauses the processing of tasks
 * until `resume()` is called. Invoke with `queue.pause()`.
 * @property {Function} resume - a function that resumes the processing of
 * queued tasks when the queue is paused. Invoke with `queue.resume()`.
 * @property {Function} kill - a function that removes the `drain` callback and
 * empties remaining tasks from the queue forcing it to go idle. No more tasks
 * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
 */

/**
 * Creates a `queue` object with the specified `concurrency`. Tasks added to the
 * `queue` are processed in parallel (up to the `concurrency` limit). If all
 * `worker`s are in progress, the task is queued until one becomes available.
 * Once a `worker` completes a `task`, that `task`'s callback is called.
 *
 * @name queue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {AsyncFunction} worker - An async function for processing a queued task.
 * If you want to handle errors from an individual task, pass a callback to
 * `q.push()`. Invoked with (task, callback).
 * @param {number} [concurrency=1] - An `integer` for determining how many
 * `worker` functions should be run in parallel.  If omitted, the concurrency
 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
 * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can
 * attached as certain properties to listen for specific events during the
 * lifecycle of the queue.
 * @example
 *
 * // create a queue object with concurrency 2
 * var q = async.queue(function(task, callback) {
 *     console.log('hello ' + task.name);
 *     callback();
 * }, 2);
 *
 * // assign a callback
 * q.drain = function() {
 *     console.log('all items have been processed');
 * };
 *
 * // add some items to the queue
 * q.push({name: 'foo'}, function(err) {
 *     console.log('finished processing foo');
 * });
 * q.push({name: 'bar'}, function (err) {
 *     console.log('finished processing bar');
 * });
 *
 * // add some items to the queue (batch-wise)
 * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
 *     console.log('finished processing item');
 * });
 *
 * // add some items to the front of the queue
 * q.unshift({name: 'bar'}, function (err) {
 *     console.log('finished processing bar');
 * });
 */
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/queue.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/base32.js/base32.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/base32.js/base32.js
      return function (require, module, exports) {
"use strict";

/**
 * Generate a character map.
 * @param {string} alphabet e.g. "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
 * @param {object} mappings map overrides from key to value
 * @method
 */

var charmap = function (alphabet, mappings) {
  mappings || (mappings = {});
  alphabet.split("").forEach(function (c, i) {
    if (!(c in mappings)) mappings[c] = i;
  });
  return mappings;
}

/**
 * The RFC 4648 base 32 alphabet and character map.
 * @see {@link https://tools.ietf.org/html/rfc4648}
 */

var rfc4648 = {
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  charmap: {
    0: 14,
    1: 8
  }
};

rfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);

/**
 * The Crockford base 32 alphabet and character map.
 * @see {@link http://www.crockford.com/wrmg/base32.html}
 */

var crockford = {
  alphabet: "0123456789ABCDEFGHJKMNPQRSTVWXYZ",
  charmap: {
    O: 0,
    I: 1,
    L: 1
  }
};

crockford.charmap = charmap(crockford.alphabet, crockford.charmap);

/**
 * base32hex
 * @see {@link https://en.wikipedia.org/wiki/Base32#base32hex}
 */

var base32hex = {
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  charmap: {}
};

base32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);

/**
 * Create a new `Decoder` with the given options.
 *
 * @param {object} [options]
 *   @param {string} [type] Supported Base-32 variants are "rfc4648" and
 *     "crockford".
 *   @param {object} [charmap] Override the character map used in decoding.
 * @constructor
 */

function Decoder (options) {
  this.buf = [];
  this.shift = 8;
  this.carry = 0;

  if (options) {

    switch (options.type) {
      case "rfc4648":
        this.charmap = exports.rfc4648.charmap;
        break;
      case "crockford":
        this.charmap = exports.crockford.charmap;
        break;
      case "base32hex":
        this.charmap = exports.base32hex.charmap;
        break;
      default:
        throw new Error("invalid type");
    }

    if (options.charmap) this.charmap = options.charmap;
  }
}

/**
 * The default character map coresponds to RFC4648.
 */

Decoder.prototype.charmap = rfc4648.charmap;

/**
 * Decode a string, continuing from the previous state.
 *
 * @param {string} str
 * @return {Decoder} this
 */

Decoder.prototype.write = function (str) {
  var charmap = this.charmap;
  var buf = this.buf;
  var shift = this.shift;
  var carry = this.carry;

  // decode string
  str.toUpperCase().split("").forEach(function (char) {

    // ignore padding
    if (char == "=") return;

    // lookup symbol
    var symbol = charmap[char] & 0xff;

    // 1: 00000 000
    // 2:          00 00000 0
    // 3:                    0000 0000
    // 4:                             0 00000 00
    // 5:                                       000 00000
    // 6:                                                00000 000
    // 7:                                                         00 00000 0

    shift -= 5;
    if (shift > 0) {
      carry |= symbol << shift;
    } else if (shift < 0) {
      buf.push(carry | (symbol >> -shift));
      shift += 8;
      carry = (symbol << shift) & 0xff;
    } else {
      buf.push(carry | symbol);
      shift = 8;
      carry = 0;
    }
  });

  // save state
  this.shift = shift;
  this.carry = carry;

  // for chaining
  return this;
};

/**
 * Finish decoding.
 *
 * @param {string} [str] The final string to decode.
 * @return {Array} Decoded byte array.
 */

Decoder.prototype.finalize = function (str) {
  if (str) {
    this.write(str);
  }
  if (this.shift !== 8 && this.carry !== 0) {
    this.buf.push(this.carry);
    this.shift = 8;
    this.carry = 0;
  }
  return this.buf;
};

/**
 * Create a new `Encoder` with the given options.
 *
 * @param {object} [options]
 *   @param {string} [type] Supported Base-32 variants are "rfc4648" and
 *     "crockford".
 *   @param {object} [alphabet] Override the alphabet used in encoding.
 * @constructor
 */

function Encoder (options) {
  this.buf = "";
  this.shift = 3;
  this.carry = 0;

  if (options) {

    switch (options.type) {
      case "rfc4648":
        this.alphabet = exports.rfc4648.alphabet;
        break;
      case "crockford":
        this.alphabet = exports.crockford.alphabet;
        break;
      case "base32hex":
        this.alphabet = exports.base32hex.alphabet;
        break;
      default:
        throw new Error("invalid type");
    }

    if (options.alphabet) this.alphabet = options.alphabet;
    else if (options.lc) this.alphabet = this.alphabet.toLowerCase();
  }
}

/**
 * The default alphabet coresponds to RFC4648.
 */

Encoder.prototype.alphabet = rfc4648.alphabet;

/**
 * Encode a byte array, continuing from the previous state.
 *
 * @param {byte[]} buf The byte array to encode.
 * @return {Encoder} this
 */

Encoder.prototype.write = function (buf) {
  var shift = this.shift;
  var carry = this.carry;
  var symbol;
  var byte;
  var i;

  // encode each byte in buf
  for (i = 0; i < buf.length; i++) {
    byte = buf[i];

    // 1: 00000 000
    // 2:          00 00000 0
    // 3:                    0000 0000
    // 4:                             0 00000 00
    // 5:                                       000 00000
    // 6:                                                00000 000
    // 7:                                                         00 00000 0

    symbol = carry | (byte >> shift);
    this.buf += this.alphabet[symbol & 0x1f];

    if (shift > 5) {
      shift -= 5;
      symbol = byte >> shift;
      this.buf += this.alphabet[symbol & 0x1f];
    }

    shift = 5 - shift;
    carry = byte << shift;
    shift = 8 - shift;
  }

  // save state
  this.shift = shift;
  this.carry = carry;

  // for chaining
  return this;
};

/**
 * Finish encoding.
 *
 * @param {byte[]} [buf] The final byte array to encode.
 * @return {string} The encoded byte array.
 */

Encoder.prototype.finalize = function (buf) {
  if (buf) {
    this.write(buf);
  }
  if (this.shift !== 3) {
    this.buf += this.alphabet[this.carry & 0x1f];
    this.shift = 3;
    this.carry = 0;
  }
  return this.buf;
};

/**
 * Convenience encoder.
 *
 * @param {byte[]} buf The byte array to encode.
 * @param {object} [options] Options to pass to the encoder.
 * @return {string} The encoded string.
 */

exports.encode = function (buf, options) {
  return new Encoder(options).finalize(buf);
};

/**
 * Convenience decoder.
 *
 * @param {string} str The string to decode.
 * @param {object} [options] Options to pass to the decoder.
 * @return {byte[]} The decoded byte array.
 */

exports.decode = function (str, options) {
  return new Decoder(options).finalize(str);
};

// Exports.
exports.Decoder = Decoder;
exports.Encoder = Encoder;
exports.charmap = charmap;
exports.crockford = crockford;
exports.rfc4648 = rfc4648;
exports.base32hex = base32hex;

      };
    };
  }
}, {package:"base32.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base32.js/base32.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/collect.js", {"./reduce":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/reduce.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/collect.js
      return function (require, module, exports) {
'use strict'

var reduce = require('./reduce')

module.exports = function collect (cb) {
  return reduce(function (arr, item) {
    arr.push(item)
    return arr
  }, [], cb)
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/collect.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/index.js", {"./keytransform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/keytransform.js","./mount":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/mount.js","./namespace":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/namespace.js","./shard":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/shard.js","./sharding":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/sharding.js","./tiered":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/tiered.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/index.js
      return function (require, module, exports) {
/* @flow */
'use strict'

const KeytransformDatastore = require('./keytransform')
const ShardingDatastore = require('./sharding')
const MountDatastore = require('./mount')
const TieredDatastore = require('./tiered')
const NamespaceDatastore = require('./namespace')
const shard = require('./shard')

exports.KeytransformDatastore = KeytransformDatastore
exports.ShardingDatastore = ShardingDatastore
exports.MountDatastore = MountDatastore
exports.TieredDatastore = TieredDatastore
exports.NamespaceDatastore = NamespaceDatastore
exports.shard = shard

      };
    };
  }
}, {package:"datastore-core",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/reject.js", {"./internal/doParallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/doParallel.js","./internal/reject":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/reject.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/reject.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reject = require('./internal/reject');

var _reject2 = _interopRequireDefault(_reject);

var _doParallel = require('./internal/doParallel');

var _doParallel2 = _interopRequireDefault(_doParallel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
 *
 * @name reject
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @example
 *
 * async.reject(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, results) {
 *     // results now equals an array of missing files
 *     createFiles(results);
 * });
 */
exports.default = (0, _doParallel2.default)(_reject2.default);
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/reject.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/src/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","encoding-down":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/encoding-down/index.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js","leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/index.js","levelup":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/levelup.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* @flow */
'use strict'

/* :: import type {Callback, Batch, Query, QueryResult, QueryEntry} from 'interface-datastore' */

const pull = require('pull-stream')
const levelup = require('levelup')

const asyncFilter = require('interface-datastore').utils.asyncFilter
const asyncSort = require('interface-datastore').utils.asyncSort
const Key = require('interface-datastore').Key
const Errors = require('interface-datastore').Errors
const encode = require('encoding-down')

/**
 * A datastore backed by leveldb.
 */
/* :: export type LevelOptions = {
  createIfMissing?: bool,
  errorIfExists?: bool,
  compression?: bool,
  cacheSize?: number,
  db?: Object
} */
class LevelDatastore {
  /* :: db: levelup */

  constructor (path /* : string */, opts /* : ?LevelOptions */) {
    let database

    if (opts && opts.db) {
      database = opts.db
      delete opts.db
    } else {
      // Default to leveldown db
      database = require('leveldown')
    }

    this.db = levelup(
      encode(database(path), { valueEncoding: 'binary' }),
      Object.assign({}, opts, {
        compression: false // same default as go
      }),
      (err) => {
        // Prevent an uncaught exception error on duplicate locks
        if (err) {
          throw err
        }
      }
    )
  }

  open (callback /* : Callback<void> */) /* : void */ {
    this.db.open((err) => {
      if (err) {
        return callback(Errors.dbOpenFailedError(err))
      }
      callback()
    })
  }

  put (key /* : Key */, value /* : Buffer */, callback /* : Callback<void> */) /* : void */ {
    this.db.put(key.toString(), value, (err) => {
      if (err) {
        return callback(Errors.dbWriteFailedError(err))
      }
      callback()
    })
  }

  get (key /* : Key */, callback /* : Callback<Buffer> */) /* : void */ {
    this.db.get(key.toString(), (err, data) => {
      if (err) {
        return callback(Errors.notFoundError(err))
      }
      callback(null, data)
    })
  }

  has (key /* : Key */, callback /* : Callback<bool> */) /* : void */ {
    this.db.get(key.toString(), (err, res) => {
      if (err) {
        if (err.notFound) {
          callback(null, false)
          return
        }
        callback(err)
        return
      }

      callback(null, true)
    })
  }

  delete (key /* : Key */, callback /* : Callback<void> */) /* : void */ {
    this.db.del(key.toString(), (err) => {
      if (err) {
        return callback(Errors.dbDeleteFailedError(err))
      }
      callback()
    })
  }

  close (callback /* : Callback<void> */) /* : void */ {
    this.db.close(callback)
  }

  batch () /* : Batch<Buffer> */ {
    const ops = []
    return {
      put: (key /* : Key */, value /* : Buffer */) /* : void */ => {
        ops.push({
          type: 'put',
          key: key.toString(),
          value: value
        })
      },
      delete: (key /* : Key */) /* : void */ => {
        ops.push({
          type: 'del',
          key: key.toString()
        })
      },
      commit: (callback /* : Callback<void> */) /* : void */ => {
        this.db.batch(ops, callback)
      }
    }
  }

  query (q /* : Query<Buffer> */) /* : QueryResult<Buffer> */ {
    let values = true
    if (q.keysOnly != null) {
      values = !q.keysOnly
    }

    const iter = this.db.db.iterator({
      keys: true,
      values: values,
      keyAsBuffer: true
    })

    const rawStream = (end, cb) => {
      if (end) {
        return iter.end((err) => {
          cb(err || end)
        })
      }

      iter.next((err, key, value) => {
        if (err) {
          return cb(err)
        }

        if (err == null && key == null && value == null) {
          return iter.end((err) => {
            cb(err || true)
          })
        }

        const res /* : QueryEntry<Buffer> */ = {
          key: new Key(key, false)
        }

        if (values) {
          res.value = Buffer.from(value)
        }

        cb(null, res)
      })
    }

    let tasks = [rawStream]
    let filters = []

    if (q.prefix != null) {
      const prefix = q.prefix
      filters.push((e, cb) => cb(null, e.key.toString().startsWith(prefix)))
    }

    if (q.filters != null) {
      filters = filters.concat(q.filters)
    }

    tasks = tasks.concat(filters.map(f => asyncFilter(f)))

    if (q.orders != null) {
      tasks = tasks.concat(q.orders.map(o => asyncSort(o)))
    }

    if (q.offset != null) {
      let i = 0
      tasks.push(pull.filter(() => i++ >= q.offset))
    }

    if (q.limit != null) {
      tasks.push(pull.take(q.limit))
    }

    return pull.apply(null, tasks)
  }
}

module.exports = LevelDatastore

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"datastore-level",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/index.js", {"./crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/crypto.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const multihash = require('multihashes')
const crypto = require('./crypto')

module.exports = Multihashing

/**
 * Hash the given `buf` using the algorithm specified
 * by `func`.
 *
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
function Multihashing (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  Multihashing.digest(buf, func, length, (err, digest) => {
    if (err) {
      return callback(err)
    }

    callback(null, multihash.encode(digest, func, length))
  })
}

/**
 * The `buffer` module for easy use in the browser.
 *
 * @type {Buffer}
 */
Multihashing.Buffer = Buffer // for browser things

/**
 * Expose multihash itself, to avoid silly double requires.
 */
Multihashing.multihash = multihash

/**
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
Multihashing.digest = function (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  let cb = callback
  if (length) {
    cb = (err, digest) => {
      if (err) {
        return callback(err)
      }

      callback(null, digest.slice(0, length))
    }
  }

  let hash
  try {
    hash = Multihashing.createHash(func)
  } catch (err) {
    return cb(err)
  }

  hash(buf, cb)
}

/**
 * @param {string|number} func
 *
 * @returns {function} - The to `func` corresponding hash function.
 */
Multihashing.createHash = function (func) {
  func = multihash.coerceCode(func)
  if (!Multihashing.functions[func]) {
    throw new Error('multihash function ' + func + ' not yet supported')
  }

  return Multihashing.functions[func]
}

/**
 * Mapping of multihash codes to their hashing functions.
 * @type {Object}
 */
Multihashing.functions = {
  // sha1
  0x11: crypto.sha1,
  // sha2-256
  0x12: crypto.sha2256,
  // sha2-512
  0x13: crypto.sha2512,
  // sha3-512
  0x14: crypto.sha3512,
  // sha3-384
  0x15: crypto.sha3384,
  // sha3-256
  0x16: crypto.sha3256,
  // sha3-224
  0x17: crypto.sha3224,
  // shake-128
  0x18: crypto.shake128,
  // shake-256
  0x19: crypto.shake256,
  // keccak-224
  0x1A: crypto.keccak224,
  // keccak-256
  0x1B: crypto.keccak256,
  // keccak-384
  0x1C: crypto.keccak384,
  // keccak-512
  0x1D: crypto.keccak512,
  // murmur3-128
  0x22: crypto.murmur3128,
  // murmur3-32
  0x23: crypto.murmur332,
  // dbl-sha2-256
  0x56: crypto.dblSha2256
}

// add blake functions
crypto.addBlake(Multihashing.functions)

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ed25519.js", {"async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","tweetnacl":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/tweetnacl/nacl-fast.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ed25519.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const nacl = require('tweetnacl')
const nextTick = require('async/nextTick')

exports.publicKeyLength = nacl.sign.publicKeyLength
exports.privateKeyLength = nacl.sign.secretKeyLength

exports.generateKey = function (callback) {
  nextTick(() => {
    let result
    try {
      result = nacl.sign.keyPair()
    } catch (err) {
      return callback(err)
    }
    callback(null, result)
  })
}

// seed should be a 32 byte uint8array
exports.generateKeyFromSeed = function (seed, callback) {
  nextTick(() => {
    let result
    try {
      result = nacl.sign.keyPair.fromSeed(seed)
    } catch (err) {
      return callback(err)
    }
    callback(null, result)
  })
}

exports.hashAndSign = function (key, msg, callback) {
  nextTick(() => {
    callback(null, Buffer.from(nacl.sign.detached(msg, key)))
  })
}

exports.hashAndVerify = function (key, sig, msg, callback) {
  nextTick(() => {
    let result
    try {
      result = nacl.sign.detached.verify(msg, sig, key)
    } catch (err) {
      return callback(err)
    }

    callback(null, result)
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ed25519.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/whilst.js", {"./internal/onlyOnce":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/onlyOnce.js","./internal/slice":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/slice.js","./internal/wrapAsync":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/wrapAsync.js","lodash/noop":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/noop.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/whilst.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = whilst;

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _slice = require('./internal/slice');

var _slice2 = _interopRequireDefault(_slice);

var _onlyOnce = require('./internal/onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
 * stopped, or an error occurs.
 *
 * @name whilst
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Function} test - synchronous truth test to perform before each
 * execution of `iteratee`. Invoked with ().
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` passes. Invoked with (callback).
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 * @returns undefined
 * @example
 *
 * var count = 0;
 * async.whilst(
 *     function() { return count < 5; },
 *     function(callback) {
 *         count++;
 *         setTimeout(function() {
 *             callback(null, count);
 *         }, 1000);
 *     },
 *     function (err, n) {
 *         // 5 seconds have passed, n = 5
 *     }
 * );
 */
function whilst(test, iteratee, callback) {
    callback = (0, _onlyOnce2.default)(callback || _noop2.default);
    var _iteratee = (0, _wrapAsync2.default)(iteratee);
    if (!test()) return callback(null);
    var next = function (err /*, ...args*/) {
        if (err) return callback(err);
        if (test()) return _iteratee(next);
        var args = (0, _slice2.default)(arguments, 1);
        callback.apply(null, [null].concat(args));
    };
    _iteratee(next);
}
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/whilst.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/oids.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/oids.js
      return function (require, module, exports) {
/**
 * Object IDs for ASN.1.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */
var forge = require('./forge');

forge.pki = forge.pki || {};
var oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {};

// set id to name mapping and name to id mapping
function _IN(id, name) {
  oids[id] = name;
  oids[name] = id;
}
// set id to name mapping only
function _I_(id, name) {
  oids[id] = name;
}

// algorithm OIDs
_IN('1.2.840.113549.1.1.1', 'rsaEncryption');
// Note: md2 & md4 not implemented
//_IN('1.2.840.113549.1.1.2', 'md2WithRSAEncryption');
//_IN('1.2.840.113549.1.1.3', 'md4WithRSAEncryption');
_IN('1.2.840.113549.1.1.4', 'md5WithRSAEncryption');
_IN('1.2.840.113549.1.1.5', 'sha1WithRSAEncryption');
_IN('1.2.840.113549.1.1.7', 'RSAES-OAEP');
_IN('1.2.840.113549.1.1.8', 'mgf1');
_IN('1.2.840.113549.1.1.9', 'pSpecified');
_IN('1.2.840.113549.1.1.10', 'RSASSA-PSS');
_IN('1.2.840.113549.1.1.11', 'sha256WithRSAEncryption');
_IN('1.2.840.113549.1.1.12', 'sha384WithRSAEncryption');
_IN('1.2.840.113549.1.1.13', 'sha512WithRSAEncryption');
// Edwards-curve Digital Signature Algorithm (EdDSA) Ed25519
_IN('1.3.101.112', 'EdDSA25519');

_IN('1.2.840.10040.4.3', 'dsa-with-sha1');

_IN('1.3.14.3.2.7', 'desCBC');

_IN('1.3.14.3.2.26', 'sha1');
_IN('2.16.840.1.101.3.4.2.1', 'sha256');
_IN('2.16.840.1.101.3.4.2.2', 'sha384');
_IN('2.16.840.1.101.3.4.2.3', 'sha512');
_IN('1.2.840.113549.2.5', 'md5');

// pkcs#7 content types
_IN('1.2.840.113549.1.7.1', 'data');
_IN('1.2.840.113549.1.7.2', 'signedData');
_IN('1.2.840.113549.1.7.3', 'envelopedData');
_IN('1.2.840.113549.1.7.4', 'signedAndEnvelopedData');
_IN('1.2.840.113549.1.7.5', 'digestedData');
_IN('1.2.840.113549.1.7.6', 'encryptedData');

// pkcs#9 oids
_IN('1.2.840.113549.1.9.1', 'emailAddress');
_IN('1.2.840.113549.1.9.2', 'unstructuredName');
_IN('1.2.840.113549.1.9.3', 'contentType');
_IN('1.2.840.113549.1.9.4', 'messageDigest');
_IN('1.2.840.113549.1.9.5', 'signingTime');
_IN('1.2.840.113549.1.9.6', 'counterSignature');
_IN('1.2.840.113549.1.9.7', 'challengePassword');
_IN('1.2.840.113549.1.9.8', 'unstructuredAddress');
_IN('1.2.840.113549.1.9.14', 'extensionRequest');

_IN('1.2.840.113549.1.9.20', 'friendlyName');
_IN('1.2.840.113549.1.9.21', 'localKeyId');
_IN('1.2.840.113549.1.9.22.1', 'x509Certificate');

// pkcs#12 safe bags
_IN('1.2.840.113549.1.12.10.1.1', 'keyBag');
_IN('1.2.840.113549.1.12.10.1.2', 'pkcs8ShroudedKeyBag');
_IN('1.2.840.113549.1.12.10.1.3', 'certBag');
_IN('1.2.840.113549.1.12.10.1.4', 'crlBag');
_IN('1.2.840.113549.1.12.10.1.5', 'secretBag');
_IN('1.2.840.113549.1.12.10.1.6', 'safeContentsBag');

// password-based-encryption for pkcs#12
_IN('1.2.840.113549.1.5.13', 'pkcs5PBES2');
_IN('1.2.840.113549.1.5.12', 'pkcs5PBKDF2');

_IN('1.2.840.113549.1.12.1.1', 'pbeWithSHAAnd128BitRC4');
_IN('1.2.840.113549.1.12.1.2', 'pbeWithSHAAnd40BitRC4');
_IN('1.2.840.113549.1.12.1.3', 'pbeWithSHAAnd3-KeyTripleDES-CBC');
_IN('1.2.840.113549.1.12.1.4', 'pbeWithSHAAnd2-KeyTripleDES-CBC');
_IN('1.2.840.113549.1.12.1.5', 'pbeWithSHAAnd128BitRC2-CBC');
_IN('1.2.840.113549.1.12.1.6', 'pbewithSHAAnd40BitRC2-CBC');

// hmac OIDs
_IN('1.2.840.113549.2.7', 'hmacWithSHA1');
_IN('1.2.840.113549.2.8', 'hmacWithSHA224');
_IN('1.2.840.113549.2.9', 'hmacWithSHA256');
_IN('1.2.840.113549.2.10', 'hmacWithSHA384');
_IN('1.2.840.113549.2.11', 'hmacWithSHA512');

// symmetric key algorithm oids
_IN('1.2.840.113549.3.7', 'des-EDE3-CBC');
_IN('2.16.840.1.101.3.4.1.2', 'aes128-CBC');
_IN('2.16.840.1.101.3.4.1.22', 'aes192-CBC');
_IN('2.16.840.1.101.3.4.1.42', 'aes256-CBC');

// certificate issuer/subject OIDs
_IN('2.5.4.3', 'commonName');
_IN('2.5.4.5', 'serialName');
_IN('2.5.4.6', 'countryName');
_IN('2.5.4.7', 'localityName');
_IN('2.5.4.8', 'stateOrProvinceName');
_IN('2.5.4.9', 'streetAddress');
_IN('2.5.4.10', 'organizationName');
_IN('2.5.4.11', 'organizationalUnitName');
_IN('2.5.4.13', 'description');
_IN('2.5.4.15', 'businessCategory');
_IN('2.5.4.17', 'postalCode');
_IN('1.3.6.1.4.1.311.60.2.1.2', 'jurisdictionOfIncorporationStateOrProvinceName');
_IN('1.3.6.1.4.1.311.60.2.1.3', 'jurisdictionOfIncorporationCountryName');

// X.509 extension OIDs
_IN('2.16.840.1.113730.1.1', 'nsCertType');
_IN('2.16.840.1.113730.1.13', 'nsComment'); // deprecated in theory; still widely used
_I_('2.5.29.1', 'authorityKeyIdentifier'); // deprecated, use .35
_I_('2.5.29.2', 'keyAttributes'); // obsolete use .37 or .15
_I_('2.5.29.3', 'certificatePolicies'); // deprecated, use .32
_I_('2.5.29.4', 'keyUsageRestriction'); // obsolete use .37 or .15
_I_('2.5.29.5', 'policyMapping'); // deprecated use .33
_I_('2.5.29.6', 'subtreesConstraint'); // obsolete use .30
_I_('2.5.29.7', 'subjectAltName'); // deprecated use .17
_I_('2.5.29.8', 'issuerAltName'); // deprecated use .18
_I_('2.5.29.9', 'subjectDirectoryAttributes');
_I_('2.5.29.10', 'basicConstraints'); // deprecated use .19
_I_('2.5.29.11', 'nameConstraints'); // deprecated use .30
_I_('2.5.29.12', 'policyConstraints'); // deprecated use .36
_I_('2.5.29.13', 'basicConstraints'); // deprecated use .19
_IN('2.5.29.14', 'subjectKeyIdentifier');
_IN('2.5.29.15', 'keyUsage');
_I_('2.5.29.16', 'privateKeyUsagePeriod');
_IN('2.5.29.17', 'subjectAltName');
_IN('2.5.29.18', 'issuerAltName');
_IN('2.5.29.19', 'basicConstraints');
_I_('2.5.29.20', 'cRLNumber');
_I_('2.5.29.21', 'cRLReason');
_I_('2.5.29.22', 'expirationDate');
_I_('2.5.29.23', 'instructionCode');
_I_('2.5.29.24', 'invalidityDate');
_I_('2.5.29.25', 'cRLDistributionPoints'); // deprecated use .31
_I_('2.5.29.26', 'issuingDistributionPoint'); // deprecated use .28
_I_('2.5.29.27', 'deltaCRLIndicator');
_I_('2.5.29.28', 'issuingDistributionPoint');
_I_('2.5.29.29', 'certificateIssuer');
_I_('2.5.29.30', 'nameConstraints');
_IN('2.5.29.31', 'cRLDistributionPoints');
_IN('2.5.29.32', 'certificatePolicies');
_I_('2.5.29.33', 'policyMappings');
_I_('2.5.29.34', 'policyConstraints'); // deprecated use .36
_IN('2.5.29.35', 'authorityKeyIdentifier');
_I_('2.5.29.36', 'policyConstraints');
_IN('2.5.29.37', 'extKeyUsage');
_I_('2.5.29.46', 'freshestCRL');
_I_('2.5.29.54', 'inhibitAnyPolicy');

// extKeyUsage purposes
_IN('1.3.6.1.4.1.11129.2.4.2', 'timestampList');
_IN('1.3.6.1.5.5.7.1.1', 'authorityInfoAccess');
_IN('1.3.6.1.5.5.7.3.1', 'serverAuth');
_IN('1.3.6.1.5.5.7.3.2', 'clientAuth');
_IN('1.3.6.1.5.5.7.3.3', 'codeSigning');
_IN('1.3.6.1.5.5.7.3.4', 'emailProtection');
_IN('1.3.6.1.5.5.7.3.8', 'timeStamping');

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/oids.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/md.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/md.js
      return function (require, module, exports) {
/**
 * Node.js module for Forge message digests.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2017 Digital Bazaar, Inc.
 */
var forge = require('./forge');

module.exports = forge.md = forge.md || {};
forge.md.algorithms = forge.md.algorithms || {};

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/md.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/aes.js", {"./cipher":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/cipher.js","./cipherModes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/cipherModes.js","./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/aes.js
      return function (require, module, exports) {
/**
 * Advanced Encryption Standard (AES) implementation.
 *
 * This implementation is based on the public domain library 'jscrypto' which
 * was written by:
 *
 * Emily Stark (estark@stanford.edu)
 * Mike Hamburg (mhamburg@stanford.edu)
 * Dan Boneh (dabo@cs.stanford.edu)
 *
 * Parts of this code are based on the OpenSSL implementation of AES:
 * http://www.openssl.org
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./cipher');
require('./cipherModes');
require('./util');

/* AES API */
module.exports = forge.aes = forge.aes || {};

/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.aes.startEncrypting = function(key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: false,
    mode: mode
  });
  cipher.start(iv);
  return cipher;
};

/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.aes.createEncryptionCipher = function(key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: false,
    mode: mode
  });
};

/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.aes.startDecrypting = function(key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: true,
    mode: mode
  });
  cipher.start(iv);
  return cipher;
};

/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.aes.createDecryptionCipher = function(key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: true,
    mode: mode
  });
};

/**
 * Creates a new AES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the AES algorithm object.
 */
forge.aes.Algorithm = function(name, mode) {
  if(!init) {
    initialize();
  }
  var self = this;
  self.name = name;
  self.mode = new mode({
    blockSize: 16,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock(self._w, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock(self._w, inBlock, outBlock, true);
      }
    }
  });
  self._init = false;
};

/**
 * Initializes this AES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */
forge.aes.Algorithm.prototype.initialize = function(options) {
  if(this._init) {
    return;
  }

  var key = options.key;
  var tmp;

  /* Note: The key may be a string of bytes, an array of bytes, a byte
    buffer, or an array of 32-bit integers. If the key is in bytes, then
    it must be 16, 24, or 32 bytes in length. If it is in 32-bit
    integers, it must be 4, 6, or 8 integers long. */

  if(typeof key === 'string' &&
    (key.length === 16 || key.length === 24 || key.length === 32)) {
    // convert key string into byte buffer
    key = forge.util.createBuffer(key);
  } else if(forge.util.isArray(key) &&
    (key.length === 16 || key.length === 24 || key.length === 32)) {
    // convert key integer array into byte buffer
    tmp = key;
    key = forge.util.createBuffer();
    for(var i = 0; i < tmp.length; ++i) {
      key.putByte(tmp[i]);
    }
  }

  // convert key byte buffer into 32-bit integer array
  if(!forge.util.isArray(key)) {
    tmp = key;
    key = [];

    // key lengths of 16, 24, 32 bytes allowed
    var len = tmp.length();
    if(len === 16 || len === 24 || len === 32) {
      len = len >>> 2;
      for(var i = 0; i < len; ++i) {
        key.push(tmp.getInt32());
      }
    }
  }

  // key must be an array of 32-bit integers by now
  if(!forge.util.isArray(key) ||
    !(key.length === 4 || key.length === 6 || key.length === 8)) {
    throw new Error('Invalid key parameter.');
  }

  // encryption operation is always used for these modes
  var mode = this.mode.name;
  var encryptOp = (['CFB', 'OFB', 'CTR', 'GCM'].indexOf(mode) !== -1);

  // do key expansion
  this._w = _expandKey(key, options.decrypt && !encryptOp);
  this._init = true;
};

/**
 * Expands a key. Typically only used for testing.
 *
 * @param key the symmetric key to expand, as an array of 32-bit words.
 * @param decrypt true to expand for decryption, false for encryption.
 *
 * @return the expanded key.
 */
forge.aes._expandKey = function(key, decrypt) {
  if(!init) {
    initialize();
  }
  return _expandKey(key, decrypt);
};

/**
 * Updates a single block. Typically only used for testing.
 *
 * @param w the expanded key to use.
 * @param input an array of block-size 32-bit words.
 * @param output an array of block-size 32-bit words.
 * @param decrypt true to decrypt, false to encrypt.
 */
forge.aes._updateBlock = _updateBlock;

/** Register AES algorithms **/

registerAlgorithm('AES-ECB', forge.cipher.modes.ecb);
registerAlgorithm('AES-CBC', forge.cipher.modes.cbc);
registerAlgorithm('AES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('AES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('AES-CTR', forge.cipher.modes.ctr);
registerAlgorithm('AES-GCM', forge.cipher.modes.gcm);

function registerAlgorithm(name, mode) {
  var factory = function() {
    return new forge.aes.Algorithm(name, mode);
  };
  forge.cipher.registerAlgorithm(name, factory);
}

/** AES implementation **/

var init = false; // not yet initialized
var Nb = 4;       // number of words comprising the state (AES = 4)
var sbox;         // non-linear substitution table used in key expansion
var isbox;        // inversion of sbox
var rcon;         // round constant word array
var mix;          // mix-columns table
var imix;         // inverse mix-columns table

/**
 * Performs initialization, ie: precomputes tables to optimize for speed.
 *
 * One way to understand how AES works is to imagine that 'addition' and
 * 'multiplication' are interfaces that require certain mathematical
 * properties to hold true (ie: they are associative) but they might have
 * different implementations and produce different kinds of results ...
 * provided that their mathematical properties remain true. AES defines
 * its own methods of addition and multiplication but keeps some important
 * properties the same, ie: associativity and distributivity. The
 * explanation below tries to shed some light on how AES defines addition
 * and multiplication of bytes and 32-bit words in order to perform its
 * encryption and decryption algorithms.
 *
 * The basics:
 *
 * The AES algorithm views bytes as binary representations of polynomials
 * that have either 1 or 0 as the coefficients. It defines the addition
 * or subtraction of two bytes as the XOR operation. It also defines the
 * multiplication of two bytes as a finite field referred to as GF(2^8)
 * (Note: 'GF' means "Galois Field" which is a field that contains a finite
 * number of elements so GF(2^8) has 256 elements).
 *
 * This means that any two bytes can be represented as binary polynomials;
 * when they multiplied together and modularly reduced by an irreducible
 * polynomial of the 8th degree, the results are the field GF(2^8). The
 * specific irreducible polynomial that AES uses in hexadecimal is 0x11b.
 * This multiplication is associative with 0x01 as the identity:
 *
 * (b * 0x01 = GF(b, 0x01) = b).
 *
 * The operation GF(b, 0x02) can be performed at the byte level by left
 * shifting b once and then XOR'ing it (to perform the modular reduction)
 * with 0x11b if b is >= 128. Repeated application of the multiplication
 * of 0x02 can be used to implement the multiplication of any two bytes.
 *
 * For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can
 * be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these
 * factors can each be multiplied by 0x57 and then added together. To do
 * the multiplication, values for 0x57 multiplied by each of these 3 factors
 * can be precomputed and stored in a table. To add them, the values from
 * the table are XOR'd together.
 *
 * AES also defines addition and multiplication of words, that is 4-byte
 * numbers represented as polynomials of 3 degrees where the coefficients
 * are the values of the bytes.
 *
 * The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.
 *
 * Addition is performed by XOR'ing like powers of x. Multiplication
 * is performed in two steps, the first is an algebriac expansion as
 * you would do normally (where addition is XOR). But the result is
 * a polynomial larger than 3 degrees and thus it cannot fit in a word. So
 * next the result is modularly reduced by an AES-specific polynomial of
 * degree 4 which will always produce a polynomial of less than 4 degrees
 * such that it will fit in a word. In AES, this polynomial is x^4 + 1.
 *
 * The modular product of two polynomials 'a' and 'b' is thus:
 *
 * d(x) = d3x^3 + d2x^2 + d1x + d0
 * with
 * d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)
 * d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)
 * d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)
 * d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)
 *
 * As a matrix:
 *
 * [d0] = [a0 a3 a2 a1][b0]
 * [d1]   [a1 a0 a3 a2][b1]
 * [d2]   [a2 a1 a0 a3][b2]
 * [d3]   [a3 a2 a1 a0][b3]
 *
 * Special polynomials defined by AES (0x02 == {02}):
 * a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}
 * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.
 *
 * These polynomials are used in the MixColumns() and InverseMixColumns()
 * operations, respectively, to cause each element in the state to affect
 * the output (referred to as diffusing).
 *
 * RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the
 * polynomial x3.
 *
 * The ShiftRows() method modifies the last 3 rows in the state (where
 * the state is 4 words with 4 bytes per word) by shifting bytes cyclically.
 * The 1st byte in the second row is moved to the end of the row. The 1st
 * and 2nd bytes in the third row are moved to the end of the row. The 1st,
 * 2nd, and 3rd bytes are moved in the fourth row.
 *
 * More details on how AES arithmetic works:
 *
 * In the polynomial representation of binary numbers, XOR performs addition
 * and subtraction and multiplication in GF(2^8) denoted as GF(a, b)
 * corresponds with the multiplication of polynomials modulo an irreducible
 * polynomial of degree 8. In other words, for AES, GF(a, b) will multiply
 * polynomial 'a' with polynomial 'b' and then do a modular reduction by
 * an AES-specific irreducible polynomial of degree 8.
 *
 * A polynomial is irreducible if its only divisors are one and itself. For
 * the AES algorithm, this irreducible polynomial is:
 *
 * m(x) = x^8 + x^4 + x^3 + x + 1,
 *
 * or {01}{1b} in hexadecimal notation, where each coefficient is a bit:
 * 100011011 = 283 = 0x11b.
 *
 * For example, GF(0x57, 0x83) = 0xc1 because
 *
 * 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1
 * 0x85 = 131 = 10000101 = x^7 + x + 1
 *
 * (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)
 * =  x^13 + x^11 + x^9 + x^8 + x^7 +
 *    x^7 + x^5 + x^3 + x^2 + x +
 *    x^6 + x^4 + x^2 + x + 1
 * =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y
 *    y modulo (x^8 + x^4 + x^3 + x + 1)
 * =  x^7 + x^6 + 1.
 *
 * The modular reduction by m(x) guarantees the result will be a binary
 * polynomial of less than degree 8, so that it can fit in a byte.
 *
 * The operation to multiply a binary polynomial b with x (the polynomial
 * x in binary representation is 00000010) is:
 *
 * b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1
 *
 * To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the
 * most significant bit is 0 in b) then the result is already reduced. If
 * it is 1, then we can reduce it by subtracting m(x) via an XOR.
 *
 * It follows that multiplication by x (00000010 or 0x02) can be implemented
 * by performing a left shift followed by a conditional bitwise XOR with
 * 0x1b. This operation on bytes is denoted by xtime(). Multiplication by
 * higher powers of x can be implemented by repeated application of xtime().
 *
 * By adding intermediate results, multiplication by any constant can be
 * implemented. For instance:
 *
 * GF(0x57, 0x13) = 0xfe because:
 *
 * xtime(b) = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1)
 *
 * Note: We XOR with 0x11b instead of 0x1b because in javascript our
 * datatype for b can be larger than 1 byte, so a left shift will not
 * automatically eliminate bits that overflow a byte ... by XOR'ing the
 * overflow bit with 1 (the extra one from 0x11b) we zero it out.
 *
 * GF(0x57, 0x02) = xtime(0x57) = 0xae
 * GF(0x57, 0x04) = xtime(0xae) = 0x47
 * GF(0x57, 0x08) = xtime(0x47) = 0x8e
 * GF(0x57, 0x10) = xtime(0x8e) = 0x07
 *
 * GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))
 *
 * And by the distributive property (since XOR is addition and GF() is
 * multiplication):
 *
 * = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)
 * = 0x57 ^ 0xae ^ 0x07
 * = 0xfe.
 */
function initialize() {
  init = true;

  /* Populate the Rcon table. These are the values given by
    [x^(i-1),{00},{00},{00}] where x^(i-1) are powers of x (and x = 0x02)
    in the field of GF(2^8), where i starts at 1.

    rcon[0] = [0x00, 0x00, 0x00, 0x00]
    rcon[1] = [0x01, 0x00, 0x00, 0x00] 2^(1-1) = 2^0 = 1
    rcon[2] = [0x02, 0x00, 0x00, 0x00] 2^(2-1) = 2^1 = 2
    ...
    rcon[9]  = [0x1B, 0x00, 0x00, 0x00] 2^(9-1)  = 2^8 = 0x1B
    rcon[10] = [0x36, 0x00, 0x00, 0x00] 2^(10-1) = 2^9 = 0x36

    We only store the first byte because it is the only one used.
  */
  rcon = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36];

  // compute xtime table which maps i onto GF(i, 0x02)
  var xtime = new Array(256);
  for(var i = 0; i < 128; ++i) {
    xtime[i] = i << 1;
    xtime[i + 128] = (i + 128) << 1 ^ 0x11B;
  }

  // compute all other tables
  sbox = new Array(256);
  isbox = new Array(256);
  mix = new Array(4);
  imix = new Array(4);
  for(var i = 0; i < 4; ++i) {
    mix[i] = new Array(256);
    imix[i] = new Array(256);
  }
  var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
  for(var i = 0; i < 256; ++i) {
    /* We need to generate the SubBytes() sbox and isbox tables so that
      we can perform byte substitutions. This requires us to traverse
      all of the elements in GF, find their multiplicative inverses,
      and apply to each the following affine transformation:

      bi' = bi ^ b(i + 4) mod 8 ^ b(i + 5) mod 8 ^ b(i + 6) mod 8 ^
            b(i + 7) mod 8 ^ ci
      for 0 <= i < 8, where bi is the ith bit of the byte, and ci is the
      ith bit of a byte c with the value {63} or {01100011}.

      It is possible to traverse every possible value in a Galois field
      using what is referred to as a 'generator'. There are many
      generators (128 out of 256): 3,5,6,9,11,82 to name a few. To fully
      traverse GF we iterate 255 times, multiplying by our generator
      each time.

      On each iteration we can determine the multiplicative inverse for
      the current element.

      Suppose there is an element in GF 'e'. For a given generator 'g',
      e = g^x. The multiplicative inverse of e is g^(255 - x). It turns
      out that if use the inverse of a generator as another generator
      it will produce all of the corresponding multiplicative inverses
      at the same time. For this reason, we choose 5 as our inverse
      generator because it only requires 2 multiplies and 1 add and its
      inverse, 82, requires relatively few operations as well.

      In order to apply the affine transformation, the multiplicative
      inverse 'ei' of 'e' can be repeatedly XOR'd (4 times) with a
      bit-cycling of 'ei'. To do this 'ei' is first stored in 's' and
      'x'. Then 's' is left shifted and the high bit of 's' is made the
      low bit. The resulting value is stored in 's'. Then 'x' is XOR'd
      with 's' and stored in 'x'. On each subsequent iteration the same
      operation is performed. When 4 iterations are complete, 'x' is
      XOR'd with 'c' (0x63) and the transformed value is stored in 'x'.
      For example:

      s = 01000001
      x = 01000001

      iteration 1: s = 10000010, x ^= s
      iteration 2: s = 00000101, x ^= s
      iteration 3: s = 00001010, x ^= s
      iteration 4: s = 00010100, x ^= s
      x ^= 0x63

      This can be done with a loop where s = (s << 1) | (s >> 7). However,
      it can also be done by using a single 16-bit (in this case 32-bit)
      number 'sx'. Since XOR is an associative operation, we can set 'sx'
      to 'ei' and then XOR it with 'sx' left-shifted 1,2,3, and 4 times.
      The most significant bits will flow into the high 8 bit positions
      and be correctly XOR'd with one another. All that remains will be
      to cycle the high 8 bits by XOR'ing them all with the lower 8 bits
      afterwards.

      At the same time we're populating sbox and isbox we can precompute
      the multiplication we'll need to do to do MixColumns() later.
    */

    // apply affine transformation
    sx = ei ^ (ei << 1) ^ (ei << 2) ^ (ei << 3) ^ (ei << 4);
    sx = (sx >> 8) ^ (sx & 255) ^ 0x63;

    // update tables
    sbox[e] = sx;
    isbox[sx] = e;

    /* Mixing columns is done using matrix multiplication. The columns
      that are to be mixed are each a single word in the current state.
      The state has Nb columns (4 columns). Therefore each column is a
      4 byte word. So to mix the columns in a single column 'c' where
      its rows are r0, r1, r2, and r3, we use the following matrix
      multiplication:

      [2 3 1 1]*[r0,c]=[r'0,c]
      [1 2 3 1] [r1,c] [r'1,c]
      [1 1 2 3] [r2,c] [r'2,c]
      [3 1 1 2] [r3,c] [r'3,c]

      r0, r1, r2, and r3 are each 1 byte of one of the words in the
      state (a column). To do matrix multiplication for each mixed
      column c' we multiply the corresponding row from the left matrix
      with the corresponding column from the right matrix. In total, we
      get 4 equations:

      r0,c' = 2*r0,c + 3*r1,c + 1*r2,c + 1*r3,c
      r1,c' = 1*r0,c + 2*r1,c + 3*r2,c + 1*r3,c
      r2,c' = 1*r0,c + 1*r1,c + 2*r2,c + 3*r3,c
      r3,c' = 3*r0,c + 1*r1,c + 1*r2,c + 2*r3,c

      As usual, the multiplication is as previously defined and the
      addition is XOR. In order to optimize mixing columns we can store
      the multiplication results in tables. If you think of the whole
      column as a word (it might help to visualize by mentally rotating
      the equations above by counterclockwise 90 degrees) then you can
      see that it would be useful to map the multiplications performed on
      each byte (r0, r1, r2, r3) onto a word as well. For instance, we
      could map 2*r0,1*r0,1*r0,3*r0 onto a word by storing 2*r0 in the
      highest 8 bits and 3*r0 in the lowest 8 bits (with the other two
      respectively in the middle). This means that a table can be
      constructed that uses r0 as an index to the word. We can do the
      same with r1, r2, and r3, creating a total of 4 tables.

      To construct a full c', we can just look up each byte of c in
      their respective tables and XOR the results together.

      Also, to build each table we only have to calculate the word
      for 2,1,1,3 for every byte ... which we can do on each iteration
      of this loop since we will iterate over every byte. After we have
      calculated 2,1,1,3 we can get the results for the other tables
      by cycling the byte at the end to the beginning. For instance
      we can take the result of table 2,1,1,3 and produce table 3,2,1,1
      by moving the right most byte to the left most position just like
      how you can imagine the 3 moved out of 2,1,1,3 and to the front
      to produce 3,2,1,1.

      There is another optimization in that the same multiples of
      the current element we need in order to advance our generator
      to the next iteration can be reused in performing the 2,1,1,3
      calculation. We also calculate the inverse mix column tables,
      with e,9,d,b being the inverse of 2,1,1,3.

      When we're done, and we need to actually mix columns, the first
      byte of each state word should be put through mix[0] (2,1,1,3),
      the second through mix[1] (3,2,1,1) and so forth. Then they should
      be XOR'd together to produce the fully mixed column.
    */

    // calculate mix and imix table values
    sx2 = xtime[sx];
    e2 = xtime[e];
    e4 = xtime[e2];
    e8 = xtime[e4];
    me =
      (sx2 << 24) ^  // 2
      (sx << 16) ^   // 1
      (sx << 8) ^    // 1
      (sx ^ sx2);    // 3
    ime =
      (e2 ^ e4 ^ e8) << 24 ^  // E (14)
      (e ^ e8) << 16 ^        // 9
      (e ^ e4 ^ e8) << 8 ^    // D (13)
      (e ^ e2 ^ e8);          // B (11)
    // produce each of the mix tables by rotating the 2,1,1,3 value
    for(var n = 0; n < 4; ++n) {
      mix[n][e] = me;
      imix[n][sx] = ime;
      // cycle the right most byte to the left most position
      // ie: 2,1,1,3 becomes 3,2,1,1
      me = me << 24 | me >>> 8;
      ime = ime << 24 | ime >>> 8;
    }

    // get next element and inverse
    if(e === 0) {
      // 1 is the inverse of 1
      e = ei = 1;
    } else {
      // e = 2e + 2*2*2*(10e)) = multiply e by 82 (chosen generator)
      // ei = ei + 2*2*ei = multiply ei by 5 (inverse generator)
      e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
      ei ^= xtime[xtime[ei]];
    }
  }
}

/**
 * Generates a key schedule using the AES key expansion algorithm.
 *
 * The AES algorithm takes the Cipher Key, K, and performs a Key Expansion
 * routine to generate a key schedule. The Key Expansion generates a total
 * of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,
 * and each of the Nr rounds requires Nb words of key data. The resulting
 * key schedule consists of a linear array of 4-byte words, denoted [wi ],
 * with i in the range 0 <= i < Nb(Nr + 1).
 *
 * KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)
 * AES-128 (Nb=4, Nk=4, Nr=10)
 * AES-192 (Nb=4, Nk=6, Nr=12)
 * AES-256 (Nb=4, Nk=8, Nr=14)
 * Note: Nr=Nk+6.
 *
 * Nb is the number of columns (32-bit words) comprising the State (or
 * number of bytes in a block). For AES, Nb=4.
 *
 * @param key the key to schedule (as an array of 32-bit words).
 * @param decrypt true to modify the key schedule to decrypt, false not to.
 *
 * @return the generated key schedule.
 */
function _expandKey(key, decrypt) {
  // copy the key's words to initialize the key schedule
  var w = key.slice(0);

  /* RotWord() will rotate a word, moving the first byte to the last
    byte's position (shifting the other bytes left).

    We will be getting the value of Rcon at i / Nk. 'i' will iterate
    from Nk to (Nb * Nr+1). Nk = 4 (4 byte key), Nb = 4 (4 words in
    a block), Nr = Nk + 6 (10). Therefore 'i' will iterate from
    4 to 44 (exclusive). Each time we iterate 4 times, i / Nk will
    increase by 1. We use a counter iNk to keep track of this.
   */

  // go through the rounds expanding the key
  var temp, iNk = 1;
  var Nk = w.length;
  var Nr1 = Nk + 6 + 1;
  var end = Nb * Nr1;
  for(var i = Nk; i < end; ++i) {
    temp = w[i - 1];
    if(i % Nk === 0) {
      // temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk]
      temp =
        sbox[temp >>> 16 & 255] << 24 ^
        sbox[temp >>> 8 & 255] << 16 ^
        sbox[temp & 255] << 8 ^
        sbox[temp >>> 24] ^ (rcon[iNk] << 24);
      iNk++;
    } else if(Nk > 6 && (i % Nk === 4)) {
      // temp = SubWord(temp)
      temp =
        sbox[temp >>> 24] << 24 ^
        sbox[temp >>> 16 & 255] << 16 ^
        sbox[temp >>> 8 & 255] << 8 ^
        sbox[temp & 255];
    }
    w[i] = w[i - Nk] ^ temp;
  }

  /* When we are updating a cipher block we always use the code path for
     encryption whether we are decrypting or not (to shorten code and
     simplify the generation of look up tables). However, because there
     are differences in the decryption algorithm, other than just swapping
     in different look up tables, we must transform our key schedule to
     account for these changes:

     1. The decryption algorithm gets its key rounds in reverse order.
     2. The decryption algorithm adds the round key before mixing columns
       instead of afterwards.

     We don't need to modify our key schedule to handle the first case,
     we can just traverse the key schedule in reverse order when decrypting.

     The second case requires a little work.

     The tables we built for performing rounds will take an input and then
     perform SubBytes() and MixColumns() or, for the decrypt version,
     InvSubBytes() and InvMixColumns(). But the decrypt algorithm requires
     us to AddRoundKey() before InvMixColumns(). This means we'll need to
     apply some transformations to the round key to inverse-mix its columns
     so they'll be correct for moving AddRoundKey() to after the state has
     had its columns inverse-mixed.

     To inverse-mix the columns of the state when we're decrypting we use a
     lookup table that will apply InvSubBytes() and InvMixColumns() at the
     same time. However, the round key's bytes are not inverse-substituted
     in the decryption algorithm. To get around this problem, we can first
     substitute the bytes in the round key so that when we apply the
     transformation via the InvSubBytes()+InvMixColumns() table, it will
     undo our substitution leaving us with the original value that we
     want -- and then inverse-mix that value.

     This change will correctly alter our key schedule so that we can XOR
     each round key with our already transformed decryption state. This
     allows us to use the same code path as the encryption algorithm.

     We make one more change to the decryption key. Since the decryption
     algorithm runs in reverse from the encryption algorithm, we reverse
     the order of the round keys to avoid having to iterate over the key
     schedule backwards when running the encryption algorithm later in
     decryption mode. In addition to reversing the order of the round keys,
     we also swap each round key's 2nd and 4th rows. See the comments
     section where rounds are performed for more details about why this is
     done. These changes are done inline with the other substitution
     described above.
  */
  if(decrypt) {
    var tmp;
    var m0 = imix[0];
    var m1 = imix[1];
    var m2 = imix[2];
    var m3 = imix[3];
    var wnew = w.slice(0);
    end = w.length;
    for(var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
      // do not sub the first or last round key (round keys are Nb
      // words) as no column mixing is performed before they are added,
      // but do change the key order
      if(i === 0 || i === (end - Nb)) {
        wnew[i] = w[wi];
        wnew[i + 1] = w[wi + 3];
        wnew[i + 2] = w[wi + 2];
        wnew[i + 3] = w[wi + 1];
      } else {
        // substitute each round key byte because the inverse-mix
        // table will inverse-substitute it (effectively cancel the
        // substitution because round key bytes aren't sub'd in
        // decryption mode) and swap indexes 3 and 1
        for(var n = 0; n < Nb; ++n) {
          tmp = w[wi + n];
          wnew[i + (3&-n)] =
            m0[sbox[tmp >>> 24]] ^
            m1[sbox[tmp >>> 16 & 255]] ^
            m2[sbox[tmp >>> 8 & 255]] ^
            m3[sbox[tmp & 255]];
        }
      }
    }
    w = wnew;
  }

  return w;
}

/**
 * Updates a single block (16 bytes) using AES. The update will either
 * encrypt or decrypt the block.
 *
 * @param w the key schedule.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */
function _updateBlock(w, input, output, decrypt) {
  /*
  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[0, Nb-1])
    for round = 1 step 1 to Nr-1
      SubBytes(state)
      ShiftRows(state)
      MixColumns(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
    end for
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    out = state
  end

  InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    for round = Nr-1 step -1 downto 1
      InvShiftRows(state)
      InvSubBytes(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
      InvMixColumns(state)
    end for
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
    out = state
  end
  */

  // Encrypt: AddRoundKey(state, w[0, Nb-1])
  // Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
  var Nr = w.length / 4 - 1;
  var m0, m1, m2, m3, sub;
  if(decrypt) {
    m0 = imix[0];
    m1 = imix[1];
    m2 = imix[2];
    m3 = imix[3];
    sub = isbox;
  } else {
    m0 = mix[0];
    m1 = mix[1];
    m2 = mix[2];
    m3 = mix[3];
    sub = sbox;
  }
  var a, b, c, d, a2, b2, c2;
  a = input[0] ^ w[0];
  b = input[decrypt ? 3 : 1] ^ w[1];
  c = input[2] ^ w[2];
  d = input[decrypt ? 1 : 3] ^ w[3];
  var i = 3;

  /* In order to share code we follow the encryption algorithm when both
    encrypting and decrypting. To account for the changes required in the
    decryption algorithm, we use different lookup tables when decrypting
    and use a modified key schedule to account for the difference in the
    order of transformations applied when performing rounds. We also get
    key rounds in reverse order (relative to encryption). */
  for(var round = 1; round < Nr; ++round) {
    /* As described above, we'll be using table lookups to perform the
      column mixing. Each column is stored as a word in the state (the
      array 'input' has one column as a word at each index). In order to
      mix a column, we perform these transformations on each row in c,
      which is 1 byte in each word. The new column for c0 is c'0:

               m0      m1      m2      m3
      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0
      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0
      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0
      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0

      So using mix tables where c0 is a word with r0 being its upper
      8 bits and r3 being its lower 8 bits:

      m0[c0 >> 24] will yield this word: [2*r0,1*r0,1*r0,3*r0]
      ...
      m3[c0 & 255] will yield this word: [1*r3,1*r3,3*r3,2*r3]

      Therefore to mix the columns in each word in the state we
      do the following (& 255 omitted for brevity):
      c'0,r0 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r1 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r2 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r3 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]

      However, before mixing, the algorithm requires us to perform
      ShiftRows(). The ShiftRows() transformation cyclically shifts the
      last 3 rows of the state over different offsets. The first row
      (r = 0) is not shifted.

      s'_r,c = s_r,(c + shift(r, Nb) mod Nb
      for 0 < r < 4 and 0 <= c < Nb and
      shift(1, 4) = 1
      shift(2, 4) = 2
      shift(3, 4) = 3.

      This causes the first byte in r = 1 to be moved to the end of
      the row, the first 2 bytes in r = 2 to be moved to the end of
      the row, the first 3 bytes in r = 3 to be moved to the end of
      the row:

      r1: [c0 c1 c2 c3] => [c1 c2 c3 c0]
      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1]
      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2]

      We can make these substitutions inline with our column mixing to
      generate an updated set of equations to produce each word in the
      state (note the columns have changed positions):

      c0 c1 c2 c3 => c0 c1 c2 c3
      c0 c1 c2 c3    c1 c2 c3 c0  (cycled 1 byte)
      c0 c1 c2 c3    c2 c3 c0 c1  (cycled 2 bytes)
      c0 c1 c2 c3    c3 c0 c1 c2  (cycled 3 bytes)

      Therefore:

      c'0 = 2*r0,c0 + 3*r1,c1 + 1*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 2*r1,c1 + 3*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 1*r1,c1 + 2*r2,c2 + 3*r3,c3
      c'0 = 3*r0,c0 + 1*r1,c1 + 1*r2,c2 + 2*r3,c3

      c'1 = 2*r0,c1 + 3*r1,c2 + 1*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 2*r1,c2 + 3*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 1*r1,c2 + 2*r2,c3 + 3*r3,c0
      c'1 = 3*r0,c1 + 1*r1,c2 + 1*r2,c3 + 2*r3,c0

      ... and so forth for c'2 and c'3. The important distinction is
      that the columns are cycling, with c0 being used with the m0
      map when calculating c0, but c1 being used with the m0 map when
      calculating c1 ... and so forth.

      When performing the inverse we transform the mirror image and
      skip the bottom row, instead of the top one, and move upwards:

      c3 c2 c1 c0 => c0 c3 c2 c1  (cycled 3 bytes) *same as encryption
      c3 c2 c1 c0    c1 c0 c3 c2  (cycled 2 bytes)
      c3 c2 c1 c0    c2 c1 c0 c3  (cycled 1 byte)  *same as encryption
      c3 c2 c1 c0    c3 c2 c1 c0

      If you compare the resulting matrices for ShiftRows()+MixColumns()
      and for InvShiftRows()+InvMixColumns() the 2nd and 4th columns are
      different (in encrypt mode vs. decrypt mode). So in order to use
      the same code to handle both encryption and decryption, we will
      need to do some mapping.

      If in encryption mode we let a=c0, b=c1, c=c2, d=c3, and r<N> be
      a row number in the state, then the resulting matrix in encryption
      mode for applying the above transformations would be:

      r1: a b c d
      r2: b c d a
      r3: c d a b
      r4: d a b c

      If we did the same in decryption mode we would get:

      r1: a d c b
      r2: b a d c
      r3: c b a d
      r4: d c b a

      If instead we swap d and b (set b=c3 and d=c1), then we get:

      r1: a b c d
      r2: d a b c
      r3: c d a b
      r4: b c d a

      Now the 1st and 3rd rows are the same as the encryption matrix. All
      we need to do then to make the mapping exactly the same is to swap
      the 2nd and 4th rows when in decryption mode. To do this without
      having to do it on each iteration, we swapped the 2nd and 4th rows
      in the decryption key schedule. We also have to do the swap above
      when we first pull in the input and when we set the final output. */
    a2 =
      m0[a >>> 24] ^
      m1[b >>> 16 & 255] ^
      m2[c >>> 8 & 255] ^
      m3[d & 255] ^ w[++i];
    b2 =
      m0[b >>> 24] ^
      m1[c >>> 16 & 255] ^
      m2[d >>> 8 & 255] ^
      m3[a & 255] ^ w[++i];
    c2 =
      m0[c >>> 24] ^
      m1[d >>> 16 & 255] ^
      m2[a >>> 8 & 255] ^
      m3[b & 255] ^ w[++i];
    d =
      m0[d >>> 24] ^
      m1[a >>> 16 & 255] ^
      m2[b >>> 8 & 255] ^
      m3[c & 255] ^ w[++i];
    a = a2;
    b = b2;
    c = c2;
  }

  /*
    Encrypt:
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])

    Decrypt:
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
   */
  // Note: rows are shifted inline
  output[0] =
    (sub[a >>> 24] << 24) ^
    (sub[b >>> 16 & 255] << 16) ^
    (sub[c >>> 8 & 255] << 8) ^
    (sub[d & 255]) ^ w[++i];
  output[decrypt ? 3 : 1] =
    (sub[b >>> 24] << 24) ^
    (sub[c >>> 16 & 255] << 16) ^
    (sub[d >>> 8 & 255] << 8) ^
    (sub[a & 255]) ^ w[++i];
  output[2] =
    (sub[c >>> 24] << 24) ^
    (sub[d >>> 16 & 255] << 16) ^
    (sub[a >>> 8 & 255] << 8) ^
    (sub[b & 255]) ^ w[++i];
  output[decrypt ? 1 : 3] =
    (sub[d >>> 24] << 24) ^
    (sub[a >>> 16 & 255] << 16) ^
    (sub[b >>> 8 & 255] << 8) ^
    (sub[c & 255]) ^ w[++i];
}

/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('AES-<mode>', key);
 * forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates a deprecated AES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key and iv may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param options the options to use.
 *          key the symmetric key to use.
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
function _createCipher(options) {
  options = options || {};
  var mode = (options.mode || 'CBC').toUpperCase();
  var algorithm = 'AES-' + mode;

  var cipher;
  if(options.decrypt) {
    cipher = forge.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge.cipher.createCipher(algorithm, options.key);
  }

  // backwards compatible start API
  var start = cipher.start;
  cipher.start = function(iv, options) {
    // backwards compatibility: support second arg as output buffer
    var output = null;
    if(options instanceof forge.util.ByteBuffer) {
      output = options;
      options = {};
    }
    options = options || {};
    options.output = output;
    options.iv = iv;
    start.call(cipher, options);
  };

  return cipher;
}

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/aes.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pem.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pem.js
      return function (require, module, exports) {
/**
 * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.
 *
 * See: RFC 1421.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 *
 * A Forge PEM object has the following fields:
 *
 * type: identifies the type of message (eg: "RSA PRIVATE KEY").
 *
 * procType: identifies the type of processing performed on the message,
 *   it has two subfields: version and type, eg: 4,ENCRYPTED.
 *
 * contentDomain: identifies the type of content in the message, typically
 *   only uses the value: "RFC822".
 *
 * dekInfo: identifies the message encryption algorithm and mode and includes
 *   any parameters for the algorithm, it has two subfields: algorithm and
 *   parameters, eg: DES-CBC,F8143EDE5960C597.
 *
 * headers: contains all other PEM encapsulated headers -- where order is
 *   significant (for pairing data like recipient ID + key info).
 *
 * body: the binary-encoded body.
 */
var forge = require('./forge');
require('./util');

// shortcut for pem API
var pem = module.exports = forge.pem = forge.pem || {};

/**
 * Encodes (serializes) the given PEM object.
 *
 * @param msg the PEM message object to encode.
 * @param options the options to use:
 *          maxline the maximum characters per line for the body, (default: 64).
 *
 * @return the PEM-formatted string.
 */
pem.encode = function(msg, options) {
  options = options || {};
  var rval = '-----BEGIN ' + msg.type + '-----\r\n';

  // encode special headers
  var header;
  if(msg.procType) {
    header = {
      name: 'Proc-Type',
      values: [String(msg.procType.version), msg.procType.type]
    };
    rval += foldHeader(header);
  }
  if(msg.contentDomain) {
    header = {name: 'Content-Domain', values: [msg.contentDomain]};
    rval += foldHeader(header);
  }
  if(msg.dekInfo) {
    header = {name: 'DEK-Info', values: [msg.dekInfo.algorithm]};
    if(msg.dekInfo.parameters) {
      header.values.push(msg.dekInfo.parameters);
    }
    rval += foldHeader(header);
  }

  if(msg.headers) {
    // encode all other headers
    for(var i = 0; i < msg.headers.length; ++i) {
      rval += foldHeader(msg.headers[i]);
    }
  }

  // terminate header
  if(msg.procType) {
    rval += '\r\n';
  }

  // add body
  rval += forge.util.encode64(msg.body, options.maxline || 64) + '\r\n';

  rval += '-----END ' + msg.type + '-----\r\n';
  return rval;
};

/**
 * Decodes (deserializes) all PEM messages found in the given string.
 *
 * @param str the PEM-formatted string to decode.
 *
 * @return the PEM message objects in an array.
 */
pem.decode = function(str) {
  var rval = [];

  // split string into PEM messages (be lenient w/EOF on BEGIN line)
  var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
  var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
  var rCRLF = /\r?\n/;
  var match;
  while(true) {
    match = rMessage.exec(str);
    if(!match) {
      break;
    }

    var msg = {
      type: match[1],
      procType: null,
      contentDomain: null,
      dekInfo: null,
      headers: [],
      body: forge.util.decode64(match[3])
    };
    rval.push(msg);

    // no headers
    if(!match[2]) {
      continue;
    }

    // parse headers
    var lines = match[2].split(rCRLF);
    var li = 0;
    while(match && li < lines.length) {
      // get line, trim any rhs whitespace
      var line = lines[li].replace(/\s+$/, '');

      // RFC2822 unfold any following folded lines
      for(var nl = li + 1; nl < lines.length; ++nl) {
        var next = lines[nl];
        if(!/\s/.test(next[0])) {
          break;
        }
        line += next;
        li = nl;
      }

      // parse header
      match = line.match(rHeader);
      if(match) {
        var header = {name: match[1], values: []};
        var values = match[2].split(',');
        for(var vi = 0; vi < values.length; ++vi) {
          header.values.push(ltrim(values[vi]));
        }

        // Proc-Type must be the first header
        if(!msg.procType) {
          if(header.name !== 'Proc-Type') {
            throw new Error('Invalid PEM formatted message. The first ' +
              'encapsulated header must be "Proc-Type".');
          } else if(header.values.length !== 2) {
            throw new Error('Invalid PEM formatted message. The "Proc-Type" ' +
              'header must have two subfields.');
          }
          msg.procType = {version: values[0], type: values[1]};
        } else if(!msg.contentDomain && header.name === 'Content-Domain') {
          // special-case Content-Domain
          msg.contentDomain = values[0] || '';
        } else if(!msg.dekInfo && header.name === 'DEK-Info') {
          // special-case DEK-Info
          if(header.values.length === 0) {
            throw new Error('Invalid PEM formatted message. The "DEK-Info" ' +
              'header must have at least one subfield.');
          }
          msg.dekInfo = {algorithm: values[0], parameters: values[1] || null};
        } else {
          msg.headers.push(header);
        }
      }

      ++li;
    }

    if(msg.procType === 'ENCRYPTED' && !msg.dekInfo) {
      throw new Error('Invalid PEM formatted message. The "DEK-Info" ' +
        'header must be present if "Proc-Type" is "ENCRYPTED".');
    }
  }

  if(rval.length === 0) {
    throw new Error('Invalid PEM formatted message.');
  }

  return rval;
};

function foldHeader(header) {
  var rval = header.name + ': ';

  // ensure values with CRLF are folded
  var values = [];
  var insertSpace = function(match, $1) {
    return ' ' + $1;
  };
  for(var i = 0; i < header.values.length; ++i) {
    values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
  }
  rval += values.join(',') + '\r\n';

  // do folding
  var length = 0;
  var candidate = -1;
  for(var i = 0; i < rval.length; ++i, ++length) {
    if(length > 65 && candidate !== -1) {
      var insert = rval[candidate];
      if(insert === ',') {
        ++candidate;
        rval = rval.substr(0, candidate) + '\r\n ' + rval.substr(candidate);
      } else {
        rval = rval.substr(0, candidate) +
          '\r\n' + insert + rval.substr(candidate + 1);
      }
      length = (i - candidate - 1);
      candidate = -1;
      ++i;
    } else if(rval[i] === ' ' || rval[i] === '\t' || rval[i] === ',') {
      candidate = i;
    }
  }

  return rval;
}

function ltrim(str) {
  return str.replace(/^\s+/, '');
}

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pem.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/rc2.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/rc2.js
      return function (require, module, exports) {
/**
 * RC2 implementation.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * Information on the RC2 cipher is available from RFC #2268,
 * http://www.ietf.org/rfc/rfc2268.txt
 */
var forge = require('./forge');
require('./util');

var piTable = [
  0xd9, 0x78, 0xf9, 0xc4, 0x19, 0xdd, 0xb5, 0xed, 0x28, 0xe9, 0xfd, 0x79, 0x4a, 0xa0, 0xd8, 0x9d,
  0xc6, 0x7e, 0x37, 0x83, 0x2b, 0x76, 0x53, 0x8e, 0x62, 0x4c, 0x64, 0x88, 0x44, 0x8b, 0xfb, 0xa2,
  0x17, 0x9a, 0x59, 0xf5, 0x87, 0xb3, 0x4f, 0x13, 0x61, 0x45, 0x6d, 0x8d, 0x09, 0x81, 0x7d, 0x32,
  0xbd, 0x8f, 0x40, 0xeb, 0x86, 0xb7, 0x7b, 0x0b, 0xf0, 0x95, 0x21, 0x22, 0x5c, 0x6b, 0x4e, 0x82,
  0x54, 0xd6, 0x65, 0x93, 0xce, 0x60, 0xb2, 0x1c, 0x73, 0x56, 0xc0, 0x14, 0xa7, 0x8c, 0xf1, 0xdc,
  0x12, 0x75, 0xca, 0x1f, 0x3b, 0xbe, 0xe4, 0xd1, 0x42, 0x3d, 0xd4, 0x30, 0xa3, 0x3c, 0xb6, 0x26,
  0x6f, 0xbf, 0x0e, 0xda, 0x46, 0x69, 0x07, 0x57, 0x27, 0xf2, 0x1d, 0x9b, 0xbc, 0x94, 0x43, 0x03,
  0xf8, 0x11, 0xc7, 0xf6, 0x90, 0xef, 0x3e, 0xe7, 0x06, 0xc3, 0xd5, 0x2f, 0xc8, 0x66, 0x1e, 0xd7,
  0x08, 0xe8, 0xea, 0xde, 0x80, 0x52, 0xee, 0xf7, 0x84, 0xaa, 0x72, 0xac, 0x35, 0x4d, 0x6a, 0x2a,
  0x96, 0x1a, 0xd2, 0x71, 0x5a, 0x15, 0x49, 0x74, 0x4b, 0x9f, 0xd0, 0x5e, 0x04, 0x18, 0xa4, 0xec,
  0xc2, 0xe0, 0x41, 0x6e, 0x0f, 0x51, 0xcb, 0xcc, 0x24, 0x91, 0xaf, 0x50, 0xa1, 0xf4, 0x70, 0x39,
  0x99, 0x7c, 0x3a, 0x85, 0x23, 0xb8, 0xb4, 0x7a, 0xfc, 0x02, 0x36, 0x5b, 0x25, 0x55, 0x97, 0x31,
  0x2d, 0x5d, 0xfa, 0x98, 0xe3, 0x8a, 0x92, 0xae, 0x05, 0xdf, 0x29, 0x10, 0x67, 0x6c, 0xba, 0xc9,
  0xd3, 0x00, 0xe6, 0xcf, 0xe1, 0x9e, 0xa8, 0x2c, 0x63, 0x16, 0x01, 0x3f, 0x58, 0xe2, 0x89, 0xa9,
  0x0d, 0x38, 0x34, 0x1b, 0xab, 0x33, 0xff, 0xb0, 0xbb, 0x48, 0x0c, 0x5f, 0xb9, 0xb1, 0xcd, 0x2e,
  0xc5, 0xf3, 0xdb, 0x47, 0xe5, 0xa5, 0x9c, 0x77, 0x0a, 0xa6, 0x20, 0x68, 0xfe, 0x7f, 0xc1, 0xad
];

var s = [1, 2, 3, 5];

/**
 * Rotate a word left by given number of bits.
 *
 * Bits that are shifted out on the left are put back in on the right
 * hand side.
 *
 * @param word The word to shift left.
 * @param bits The number of bits to shift by.
 * @return The rotated word.
 */
var rol = function(word, bits) {
  return ((word << bits) & 0xffff) | ((word & 0xffff) >> (16 - bits));
};

/**
 * Rotate a word right by given number of bits.
 *
 * Bits that are shifted out on the right are put back in on the left
 * hand side.
 *
 * @param word The word to shift right.
 * @param bits The number of bits to shift by.
 * @return The rotated word.
 */
var ror = function(word, bits) {
  return ((word & 0xffff) >> bits) | ((word << (16 - bits)) & 0xffff);
};

/* RC2 API */
module.exports = forge.rc2 = forge.rc2 || {};

/**
 * Perform RC2 key expansion as per RFC #2268, section 2.
 *
 * @param key variable-length user key (between 1 and 128 bytes)
 * @param effKeyBits number of effective key bits (default: 128)
 * @return the expanded RC2 key (ByteBuffer of 128 bytes)
 */
forge.rc2.expandKey = function(key, effKeyBits) {
  if(typeof key === 'string') {
    key = forge.util.createBuffer(key);
  }
  effKeyBits = effKeyBits || 128;

  /* introduce variables that match the names used in RFC #2268 */
  var L = key;
  var T = key.length();
  var T1 = effKeyBits;
  var T8 = Math.ceil(T1 / 8);
  var TM = 0xff >> (T1 & 0x07);
  var i;

  for(i = T; i < 128; i++) {
    L.putByte(piTable[(L.at(i - 1) + L.at(i - T)) & 0xff]);
  }

  L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);

  for(i = 127 - T8; i >= 0; i--) {
    L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
  }

  return L;
};

/**
 * Creates a RC2 cipher object.
 *
 * @param key the symmetric key to use (as base for key generation).
 * @param bits the number of effective key bits.
 * @param encrypt false for decryption, true for encryption.
 *
 * @return the cipher.
 */
var createCipher = function(key, bits, encrypt) {
  var _finish = false, _input = null, _output = null, _iv = null;
  var mixRound, mashRound;
  var i, j, K = [];

  /* Expand key and fill into K[] Array */
  key = forge.rc2.expandKey(key, bits);
  for(i = 0; i < 64; i++) {
    K.push(key.getInt16Le());
  }

  if(encrypt) {
    /**
     * Perform one mixing round "in place".
     *
     * @param R Array of four words to perform mixing on.
     */
    mixRound = function(R) {
      for(i = 0; i < 4; i++) {
        R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) +
          ((~R[(i + 3) % 4]) & R[(i + 1) % 4]);
        R[i] = rol(R[i], s[i]);
        j++;
      }
    };

    /**
     * Perform one mashing round "in place".
     *
     * @param R Array of four words to perform mashing on.
     */
    mashRound = function(R) {
      for(i = 0; i < 4; i++) {
        R[i] += K[R[(i + 3) % 4] & 63];
      }
    };
  } else {
    /**
     * Perform one r-mixing round "in place".
     *
     * @param R Array of four words to perform mixing on.
     */
    mixRound = function(R) {
      for(i = 3; i >= 0; i--) {
        R[i] = ror(R[i], s[i]);
        R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) +
          ((~R[(i + 3) % 4]) & R[(i + 1) % 4]);
        j--;
      }
    };

    /**
     * Perform one r-mashing round "in place".
     *
     * @param R Array of four words to perform mashing on.
     */
    mashRound = function(R) {
      for(i = 3; i >= 0; i--) {
        R[i] -= K[R[(i + 3) % 4] & 63];
      }
    };
  }

  /**
   * Run the specified cipher execution plan.
   *
   * This function takes four words from the input buffer, applies the IV on
   * it (if requested) and runs the provided execution plan.
   *
   * The plan must be put together in form of a array of arrays.  Where the
   * outer one is simply a list of steps to perform and the inner one needs
   * to have two elements: the first one telling how many rounds to perform,
   * the second one telling what to do (i.e. the function to call).
   *
   * @param {Array} plan The plan to execute.
   */
  var runPlan = function(plan) {
    var R = [];

    /* Get data from input buffer and fill the four words into R */
    for(i = 0; i < 4; i++) {
      var val = _input.getInt16Le();

      if(_iv !== null) {
        if(encrypt) {
          /* We're encrypting, apply the IV first. */
          val ^= _iv.getInt16Le();
        } else {
          /* We're decryption, keep cipher text for next block. */
          _iv.putInt16Le(val);
        }
      }

      R.push(val & 0xffff);
    }

    /* Reset global "j" variable as per spec. */
    j = encrypt ? 0 : 63;

    /* Run execution plan. */
    for(var ptr = 0; ptr < plan.length; ptr++) {
      for(var ctr = 0; ctr < plan[ptr][0]; ctr++) {
        plan[ptr][1](R);
      }
    }

    /* Write back result to output buffer. */
    for(i = 0; i < 4; i++) {
      if(_iv !== null) {
        if(encrypt) {
          /* We're encrypting in CBC-mode, feed back encrypted bytes into
             IV buffer to carry it forward to next block. */
          _iv.putInt16Le(R[i]);
        } else {
          R[i] ^= _iv.getInt16Le();
        }
      }

      _output.putInt16Le(R[i]);
    }
  };

  /* Create cipher object */
  var cipher = null;
  cipher = {
    /**
     * Starts or restarts the encryption or decryption process, whichever
     * was previously configured.
     *
     * To use the cipher in CBC mode, iv may be given either as a string
     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
     *
     * @param iv the initialization vector to use, null for ECB mode.
     * @param output the output the buffer to write to, null to create one.
     */
    start: function(iv, output) {
      if(iv) {
        /* CBC mode */
        if(typeof iv === 'string') {
          iv = forge.util.createBuffer(iv);
        }
      }

      _finish = false;
      _input = forge.util.createBuffer();
      _output = output || new forge.util.createBuffer();
      _iv = iv;

      cipher.output = _output;
    },

    /**
     * Updates the next block.
     *
     * @param input the buffer to read from.
     */
    update: function(input) {
      if(!_finish) {
        // not finishing, so fill the input buffer with more input
        _input.putBuffer(input);
      }

      while(_input.length() >= 8) {
        runPlan([
            [ 5, mixRound ],
            [ 1, mashRound ],
            [ 6, mixRound ],
            [ 1, mashRound ],
            [ 5, mixRound ]
          ]);
      }
    },

    /**
     * Finishes encrypting or decrypting.
     *
     * @param pad a padding function to use, null for PKCS#7 padding,
     *           signature(blockSize, buffer, decrypt).
     *
     * @return true if successful, false on error.
     */
    finish: function(pad) {
      var rval = true;

      if(encrypt) {
        if(pad) {
          rval = pad(8, _input, !encrypt);
        } else {
          // add PKCS#7 padding to block (each pad byte is the
          // value of the number of pad bytes)
          var padding = (_input.length() === 8) ? 8 : (8 - _input.length());
          _input.fillWithByte(padding, padding);
        }
      }

      if(rval) {
        // do final update
        _finish = true;
        cipher.update();
      }

      if(!encrypt) {
        // check for error: input data not a multiple of block size
        rval = (_input.length() === 0);
        if(rval) {
          if(pad) {
            rval = pad(8, _output, !encrypt);
          } else {
            // ensure padding byte count is valid
            var len = _output.length();
            var count = _output.at(len - 1);

            if(count > len) {
              rval = false;
            } else {
              // trim off padding bytes
              _output.truncate(count);
            }
          }
        }
      }

      return rval;
    }
  };

  return cipher;
};

/**
 * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
 * given symmetric key. The output will be stored in the 'output' member
 * of the returned cipher.
 *
 * The key and iv may be given as a string of bytes or a byte buffer.
 * The cipher is initialized to use 128 effective key bits.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 *
 * @return the cipher.
 */
forge.rc2.startEncrypting = function(key, iv, output) {
  var cipher = forge.rc2.createEncryptionCipher(key, 128);
  cipher.start(iv, output);
  return cipher;
};

/**
 * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
 * given symmetric key.
 *
 * The key may be given as a string of bytes or a byte buffer.
 *
 * To start encrypting call start() on the cipher with an iv and optional
 * output buffer.
 *
 * @param key the symmetric key to use.
 *
 * @return the cipher.
 */
forge.rc2.createEncryptionCipher = function(key, bits) {
  return createCipher(key, bits, true);
};

/**
 * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
 * given symmetric key. The output will be stored in the 'output' member
 * of the returned cipher.
 *
 * The key and iv may be given as a string of bytes or a byte buffer.
 * The cipher is initialized to use 128 effective key bits.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 *
 * @return the cipher.
 */
forge.rc2.startDecrypting = function(key, iv, output) {
  var cipher = forge.rc2.createDecryptionCipher(key, 128);
  cipher.start(iv, output);
  return cipher;
};

/**
 * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
 * given symmetric key.
 *
 * The key may be given as a string of bytes or a byte buffer.
 *
 * To start decrypting call start() on the cipher with an iv and optional
 * output buffer.
 *
 * @param key the symmetric key to use.
 *
 * @return the cipher.
 */
forge.rc2.createDecryptionCipher = function(key, bits) {
  return createCipher(key, bits, false);
};

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/rc2.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/des.js", {"./cipher":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/cipher.js","./cipherModes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/cipherModes.js","./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/des.js
      return function (require, module, exports) {
/**
 * DES (Data Encryption Standard) implementation.
 *
 * This implementation supports DES as well as 3DES-EDE in ECB and CBC mode.
 * It is based on the BSD-licensed implementation by Paul Tero:
 *
 * Paul Tero, July 2001
 * http://www.tero.co.uk/des/
 *
 * Optimised for performance with large blocks by
 * Michael Hayworth, November 2001
 * http://www.netdealing.com
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2012-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./cipher');
require('./cipherModes');
require('./util');

/* DES API */
module.exports = forge.des = forge.des || {};

/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('DES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an DES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as binary-encoded strings of bytes or
 * byte buffers.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC' if IV is
 *          given, 'ECB' if null).
 *
 * @return the cipher.
 */
forge.des.startEncrypting = function(key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: false,
    mode: mode || (iv === null ? 'ECB' : 'CBC')
  });
  cipher.start(iv);
  return cipher;
};

/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('DES-<mode>', key);
 *
 * Creates an DES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.des.createEncryptionCipher = function(key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: false,
    mode: mode
  });
};

/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('DES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an DES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as binary-encoded strings of bytes or
 * byte buffers.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC' if IV is
 *          given, 'ECB' if null).
 *
 * @return the cipher.
 */
forge.des.startDecrypting = function(key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: true,
    mode: mode || (iv === null ? 'ECB' : 'CBC')
  });
  cipher.start(iv);
  return cipher;
};

/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('DES-<mode>', key);
 *
 * Creates an DES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.des.createDecryptionCipher = function(key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: true,
    mode: mode
  });
};

/**
 * Creates a new DES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the DES algorithm object.
 */
forge.des.Algorithm = function(name, mode) {
  var self = this;
  self.name = name;
  self.mode = new mode({
    blockSize: 8,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock(self._keys, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock(self._keys, inBlock, outBlock, true);
      }
    }
  });
  self._init = false;
};

/**
 * Initializes this DES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */
forge.des.Algorithm.prototype.initialize = function(options) {
  if(this._init) {
    return;
  }

  var key = forge.util.createBuffer(options.key);
  if(this.name.indexOf('3DES') === 0) {
    if(key.length() !== 24) {
      throw new Error('Invalid Triple-DES key size: ' + key.length() * 8);
    }
  }

  // do key expansion to 16 or 48 subkeys (single or triple DES)
  this._keys = _createKeys(key);
  this._init = true;
};

/** Register DES algorithms **/

registerAlgorithm('DES-ECB', forge.cipher.modes.ecb);
registerAlgorithm('DES-CBC', forge.cipher.modes.cbc);
registerAlgorithm('DES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('DES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('DES-CTR', forge.cipher.modes.ctr);

registerAlgorithm('3DES-ECB', forge.cipher.modes.ecb);
registerAlgorithm('3DES-CBC', forge.cipher.modes.cbc);
registerAlgorithm('3DES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('3DES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('3DES-CTR', forge.cipher.modes.ctr);

function registerAlgorithm(name, mode) {
  var factory = function() {
    return new forge.des.Algorithm(name, mode);
  };
  forge.cipher.registerAlgorithm(name, factory);
}

/** DES implementation **/

var spfunction1 = [0x1010400,0,0x10000,0x1010404,0x1010004,0x10404,0x4,0x10000,0x400,0x1010400,0x1010404,0x400,0x1000404,0x1010004,0x1000000,0x4,0x404,0x1000400,0x1000400,0x10400,0x10400,0x1010000,0x1010000,0x1000404,0x10004,0x1000004,0x1000004,0x10004,0,0x404,0x10404,0x1000000,0x10000,0x1010404,0x4,0x1010000,0x1010400,0x1000000,0x1000000,0x400,0x1010004,0x10000,0x10400,0x1000004,0x400,0x4,0x1000404,0x10404,0x1010404,0x10004,0x1010000,0x1000404,0x1000004,0x404,0x10404,0x1010400,0x404,0x1000400,0x1000400,0,0x10004,0x10400,0,0x1010004];
var spfunction2 = [-0x7fef7fe0,-0x7fff8000,0x8000,0x108020,0x100000,0x20,-0x7fefffe0,-0x7fff7fe0,-0x7fffffe0,-0x7fef7fe0,-0x7fef8000,-0x80000000,-0x7fff8000,0x100000,0x20,-0x7fefffe0,0x108000,0x100020,-0x7fff7fe0,0,-0x80000000,0x8000,0x108020,-0x7ff00000,0x100020,-0x7fffffe0,0,0x108000,0x8020,-0x7fef8000,-0x7ff00000,0x8020,0,0x108020,-0x7fefffe0,0x100000,-0x7fff7fe0,-0x7ff00000,-0x7fef8000,0x8000,-0x7ff00000,-0x7fff8000,0x20,-0x7fef7fe0,0x108020,0x20,0x8000,-0x80000000,0x8020,-0x7fef8000,0x100000,-0x7fffffe0,0x100020,-0x7fff7fe0,-0x7fffffe0,0x100020,0x108000,0,-0x7fff8000,0x8020,-0x80000000,-0x7fefffe0,-0x7fef7fe0,0x108000];
var spfunction3 = [0x208,0x8020200,0,0x8020008,0x8000200,0,0x20208,0x8000200,0x20008,0x8000008,0x8000008,0x20000,0x8020208,0x20008,0x8020000,0x208,0x8000000,0x8,0x8020200,0x200,0x20200,0x8020000,0x8020008,0x20208,0x8000208,0x20200,0x20000,0x8000208,0x8,0x8020208,0x200,0x8000000,0x8020200,0x8000000,0x20008,0x208,0x20000,0x8020200,0x8000200,0,0x200,0x20008,0x8020208,0x8000200,0x8000008,0x200,0,0x8020008,0x8000208,0x20000,0x8000000,0x8020208,0x8,0x20208,0x20200,0x8000008,0x8020000,0x8000208,0x208,0x8020000,0x20208,0x8,0x8020008,0x20200];
var spfunction4 = [0x802001,0x2081,0x2081,0x80,0x802080,0x800081,0x800001,0x2001,0,0x802000,0x802000,0x802081,0x81,0,0x800080,0x800001,0x1,0x2000,0x800000,0x802001,0x80,0x800000,0x2001,0x2080,0x800081,0x1,0x2080,0x800080,0x2000,0x802080,0x802081,0x81,0x800080,0x800001,0x802000,0x802081,0x81,0,0,0x802000,0x2080,0x800080,0x800081,0x1,0x802001,0x2081,0x2081,0x80,0x802081,0x81,0x1,0x2000,0x800001,0x2001,0x802080,0x800081,0x2001,0x2080,0x800000,0x802001,0x80,0x800000,0x2000,0x802080];
var spfunction5 = [0x100,0x2080100,0x2080000,0x42000100,0x80000,0x100,0x40000000,0x2080000,0x40080100,0x80000,0x2000100,0x40080100,0x42000100,0x42080000,0x80100,0x40000000,0x2000000,0x40080000,0x40080000,0,0x40000100,0x42080100,0x42080100,0x2000100,0x42080000,0x40000100,0,0x42000000,0x2080100,0x2000000,0x42000000,0x80100,0x80000,0x42000100,0x100,0x2000000,0x40000000,0x2080000,0x42000100,0x40080100,0x2000100,0x40000000,0x42080000,0x2080100,0x40080100,0x100,0x2000000,0x42080000,0x42080100,0x80100,0x42000000,0x42080100,0x2080000,0,0x40080000,0x42000000,0x80100,0x2000100,0x40000100,0x80000,0,0x40080000,0x2080100,0x40000100];
var spfunction6 = [0x20000010,0x20400000,0x4000,0x20404010,0x20400000,0x10,0x20404010,0x400000,0x20004000,0x404010,0x400000,0x20000010,0x400010,0x20004000,0x20000000,0x4010,0,0x400010,0x20004010,0x4000,0x404000,0x20004010,0x10,0x20400010,0x20400010,0,0x404010,0x20404000,0x4010,0x404000,0x20404000,0x20000000,0x20004000,0x10,0x20400010,0x404000,0x20404010,0x400000,0x4010,0x20000010,0x400000,0x20004000,0x20000000,0x4010,0x20000010,0x20404010,0x404000,0x20400000,0x404010,0x20404000,0,0x20400010,0x10,0x4000,0x20400000,0x404010,0x4000,0x400010,0x20004010,0,0x20404000,0x20000000,0x400010,0x20004010];
var spfunction7 = [0x200000,0x4200002,0x4000802,0,0x800,0x4000802,0x200802,0x4200800,0x4200802,0x200000,0,0x4000002,0x2,0x4000000,0x4200002,0x802,0x4000800,0x200802,0x200002,0x4000800,0x4000002,0x4200000,0x4200800,0x200002,0x4200000,0x800,0x802,0x4200802,0x200800,0x2,0x4000000,0x200800,0x4000000,0x200800,0x200000,0x4000802,0x4000802,0x4200002,0x4200002,0x2,0x200002,0x4000000,0x4000800,0x200000,0x4200800,0x802,0x200802,0x4200800,0x802,0x4000002,0x4200802,0x4200000,0x200800,0,0x2,0x4200802,0,0x200802,0x4200000,0x800,0x4000002,0x4000800,0x800,0x200002];
var spfunction8 = [0x10001040,0x1000,0x40000,0x10041040,0x10000000,0x10001040,0x40,0x10000000,0x40040,0x10040000,0x10041040,0x41000,0x10041000,0x41040,0x1000,0x40,0x10040000,0x10000040,0x10001000,0x1040,0x41000,0x40040,0x10040040,0x10041000,0x1040,0,0,0x10040040,0x10000040,0x10001000,0x41040,0x40000,0x41040,0x40000,0x10041000,0x1000,0x40,0x10040040,0x1000,0x41040,0x10001000,0x40,0x10000040,0x10040000,0x10040040,0x10000000,0x40000,0x10001040,0,0x10041040,0x40040,0x10000040,0x10040000,0x10001000,0x10001040,0,0x10041040,0x41000,0x41000,0x1040,0x1040,0x40040,0x10000000,0x10041000];

/**
 * Create necessary sub keys.
 *
 * @param key the 64-bit or 192-bit key.
 *
 * @return the expanded keys.
 */
function _createKeys(key) {
  var pc2bytes0  = [0,0x4,0x20000000,0x20000004,0x10000,0x10004,0x20010000,0x20010004,0x200,0x204,0x20000200,0x20000204,0x10200,0x10204,0x20010200,0x20010204],
      pc2bytes1  = [0,0x1,0x100000,0x100001,0x4000000,0x4000001,0x4100000,0x4100001,0x100,0x101,0x100100,0x100101,0x4000100,0x4000101,0x4100100,0x4100101],
      pc2bytes2  = [0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808,0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808],
      pc2bytes3  = [0,0x200000,0x8000000,0x8200000,0x2000,0x202000,0x8002000,0x8202000,0x20000,0x220000,0x8020000,0x8220000,0x22000,0x222000,0x8022000,0x8222000],
      pc2bytes4  = [0,0x40000,0x10,0x40010,0,0x40000,0x10,0x40010,0x1000,0x41000,0x1010,0x41010,0x1000,0x41000,0x1010,0x41010],
      pc2bytes5  = [0,0x400,0x20,0x420,0,0x400,0x20,0x420,0x2000000,0x2000400,0x2000020,0x2000420,0x2000000,0x2000400,0x2000020,0x2000420],
      pc2bytes6  = [0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002,0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002],
      pc2bytes7  = [0,0x10000,0x800,0x10800,0x20000000,0x20010000,0x20000800,0x20010800,0x20000,0x30000,0x20800,0x30800,0x20020000,0x20030000,0x20020800,0x20030800],
      pc2bytes8  = [0,0x40000,0,0x40000,0x2,0x40002,0x2,0x40002,0x2000000,0x2040000,0x2000000,0x2040000,0x2000002,0x2040002,0x2000002,0x2040002],
      pc2bytes9  = [0,0x10000000,0x8,0x10000008,0,0x10000000,0x8,0x10000008,0x400,0x10000400,0x408,0x10000408,0x400,0x10000400,0x408,0x10000408],
      pc2bytes10 = [0,0x20,0,0x20,0x100000,0x100020,0x100000,0x100020,0x2000,0x2020,0x2000,0x2020,0x102000,0x102020,0x102000,0x102020],
      pc2bytes11 = [0,0x1000000,0x200,0x1000200,0x200000,0x1200000,0x200200,0x1200200,0x4000000,0x5000000,0x4000200,0x5000200,0x4200000,0x5200000,0x4200200,0x5200200],
      pc2bytes12 = [0,0x1000,0x8000000,0x8001000,0x80000,0x81000,0x8080000,0x8081000,0x10,0x1010,0x8000010,0x8001010,0x80010,0x81010,0x8080010,0x8081010],
      pc2bytes13 = [0,0x4,0x100,0x104,0,0x4,0x100,0x104,0x1,0x5,0x101,0x105,0x1,0x5,0x101,0x105];

  // how many iterations (1 for des, 3 for triple des)
  // changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys
  var iterations = key.length() > 8 ? 3 : 1;

  // stores the return keys
  var keys = [];

  // now define the left shifts which need to be done
  var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];

  var n = 0, tmp;
  for(var j = 0; j < iterations; j++) {
    var left = key.getInt32();
    var right = key.getInt32();

    tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
    right ^= tmp;
    left ^= (tmp << 4);

    tmp = ((right >>> -16) ^ left) & 0x0000ffff;
    left ^= tmp;
    right ^= (tmp << -16);

    tmp = ((left >>> 2) ^ right) & 0x33333333;
    right ^= tmp;
    left ^= (tmp << 2);

    tmp = ((right >>> -16) ^ left) & 0x0000ffff;
    left ^= tmp;
    right ^= (tmp << -16);

    tmp = ((left >>> 1) ^ right) & 0x55555555;
    right ^= tmp;
    left ^= (tmp << 1);

    tmp = ((right >>> 8) ^ left) & 0x00ff00ff;
    left ^= tmp;
    right ^= (tmp << 8);

    tmp = ((left >>> 1) ^ right) & 0x55555555;
    right ^= tmp;
    left ^= (tmp << 1);

    // right needs to be shifted and OR'd with last four bits of left
    tmp = (left << 8) | ((right >>> 20) & 0x000000f0);

    // left needs to be put upside down
    left = ((right << 24) | ((right << 8) & 0xff0000) |
      ((right >>> 8) & 0xff00) | ((right >>> 24) & 0xf0));
    right = tmp;

    // now go through and perform these shifts on the left and right keys
    for(var i = 0; i < shifts.length; ++i) {
      //shift the keys either one or two bits to the left
      if(shifts[i]) {
        left = (left << 2) | (left >>> 26);
        right = (right << 2) | (right >>> 26);
      } else {
        left = (left << 1) | (left >>> 27);
        right = (right << 1) | (right >>> 27);
      }
      left &= -0xf;
      right &= -0xf;

      // now apply PC-2, in such a way that E is easier when encrypting or
      // decrypting this conversion will look like PC-2 except only the last 6
      // bits of each byte are used rather than 48 consecutive bits and the
      // order of lines will be according to how the S selection functions will
      // be applied: S2, S4, S6, S8, S1, S3, S5, S7
      var lefttmp = (
        pc2bytes0[left >>> 28] | pc2bytes1[(left >>> 24) & 0xf] |
        pc2bytes2[(left >>> 20) & 0xf] | pc2bytes3[(left >>> 16) & 0xf] |
        pc2bytes4[(left >>> 12) & 0xf] | pc2bytes5[(left >>> 8) & 0xf] |
        pc2bytes6[(left >>> 4) & 0xf]);
      var righttmp = (
        pc2bytes7[right >>> 28] | pc2bytes8[(right >>> 24) & 0xf] |
        pc2bytes9[(right >>> 20) & 0xf] | pc2bytes10[(right >>> 16) & 0xf] |
        pc2bytes11[(right >>> 12) & 0xf] | pc2bytes12[(right >>> 8) & 0xf] |
        pc2bytes13[(right >>> 4) & 0xf]);
      tmp = ((righttmp >>> 16) ^ lefttmp) & 0x0000ffff;
      keys[n++] = lefttmp ^ tmp;
      keys[n++] = righttmp ^ (tmp << 16);
    }
  }

  return keys;
}

/**
 * Updates a single block (1 byte) using DES. The update will either
 * encrypt or decrypt the block.
 *
 * @param keys the expanded keys.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */
function _updateBlock(keys, input, output, decrypt) {
  // set up loops for single or triple DES
  var iterations = keys.length === 32 ? 3 : 9;
  var looping;
  if(iterations === 3) {
    looping = decrypt ? [30, -2, -2] : [0, 32, 2];
  } else {
    looping = (decrypt ?
      [94, 62, -2, 32, 64, 2, 30, -2, -2] :
      [0, 32, 2, 62, 30, -2, 64, 96, 2]);
  }

  var tmp;

  var left = input[0];
  var right = input[1];

  // first each 64 bit chunk of the message must be permuted according to IP
  tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
  right ^= tmp;
  left ^= (tmp << 4);

  tmp = ((left >>> 16) ^ right) & 0x0000ffff;
  right ^= tmp;
  left ^= (tmp << 16);

  tmp = ((right >>> 2) ^ left) & 0x33333333;
  left ^= tmp;
  right ^= (tmp << 2);

  tmp = ((right >>> 8) ^ left) & 0x00ff00ff;
  left ^= tmp;
  right ^= (tmp << 8);

  tmp = ((left >>> 1) ^ right) & 0x55555555;
  right ^= tmp;
  left ^= (tmp << 1);

  // rotate left 1 bit
  left = ((left << 1) | (left >>> 31));
  right = ((right << 1) | (right >>> 31));

  for(var j = 0; j < iterations; j += 3) {
    var endloop = looping[j + 1];
    var loopinc = looping[j + 2];

    // now go through and perform the encryption or decryption
    for(var i = looping[j]; i != endloop; i += loopinc) {
      var right1 = right ^ keys[i];
      var right2 = ((right >>> 4) | (right << 28)) ^ keys[i + 1];

      // passing these bytes through the S selection functions
      tmp = left;
      left = right;
      right = tmp ^ (
        spfunction2[(right1 >>> 24) & 0x3f] |
        spfunction4[(right1 >>> 16) & 0x3f] |
        spfunction6[(right1 >>>  8) & 0x3f] |
        spfunction8[right1 & 0x3f] |
        spfunction1[(right2 >>> 24) & 0x3f] |
        spfunction3[(right2 >>> 16) & 0x3f] |
        spfunction5[(right2 >>>  8) & 0x3f] |
        spfunction7[right2 & 0x3f]);
    }
    // unreverse left and right
    tmp = left;
    left = right;
    right = tmp;
  }

  // rotate right 1 bit
  left = ((left >>> 1) | (left << 31));
  right = ((right >>> 1) | (right << 31));

  // now perform IP-1, which is IP in the opposite direction
  tmp = ((left >>> 1) ^ right) & 0x55555555;
  right ^= tmp;
  left ^= (tmp << 1);

  tmp = ((right >>> 8) ^ left) & 0x00ff00ff;
  left ^= tmp;
  right ^= (tmp << 8);

  tmp = ((right >>> 2) ^ left) & 0x33333333;
  left ^= tmp;
  right ^= (tmp << 2);

  tmp = ((left >>> 16) ^ right) & 0x0000ffff;
  right ^= tmp;
  left ^= (tmp << 16);

  tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
  right ^= tmp;
  left ^= (tmp << 4);

  output[0] = left;
  output[1] = right;
}

/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('DES-<mode>', key);
 * forge.cipher.createDecipher('DES-<mode>', key);
 *
 * Creates a deprecated DES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param options the options to use.
 *          key the symmetric key to use (64 or 192 bits).
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
function _createCipher(options) {
  options = options || {};
  var mode = (options.mode || 'CBC').toUpperCase();
  var algorithm = 'DES-' + mode;

  var cipher;
  if(options.decrypt) {
    cipher = forge.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge.cipher.createCipher(algorithm, options.key);
  }

  // backwards compatible start API
  var start = cipher.start;
  cipher.start = function(iv, options) {
    // backwards compatibility: support second arg as output buffer
    var output = null;
    if(options instanceof forge.util.ByteBuffer) {
      output = options;
      options = {};
    }
    options = options || {};
    options.output = output;
    options.iv = iv;
    start.call(cipher, options);
  };

  return cipher;
}

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/des.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/random.js", {"./aes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/aes.js","./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./prng":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/prng.js","./sha256":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/sha256.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/random.js
      return function (require, module, exports) {
/**
 * An API for getting cryptographically-secure random bytes. The bytes are
 * generated using the Fortuna algorithm devised by Bruce Schneier and
 * Niels Ferguson.
 *
 * Getting strong random bytes is not yet easy to do in javascript. The only
 * truish random entropy that can be collected is from the mouse, keyboard, or
 * from timing with respect to page loads, etc. This generator makes a poor
 * attempt at providing random bytes when those sources haven't yet provided
 * enough entropy to initially seed or to reseed the PRNG.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2009-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./aes');
require('./sha256');
require('./prng');
require('./util');

(function() {

// forge.random already defined
if(forge.random && forge.random.getBytes) {
  module.exports = forge.random;
  return;
}

(function(jQuery) {

// the default prng plugin, uses AES-128
var prng_aes = {};
var _prng_aes_output = new Array(4);
var _prng_aes_buffer = forge.util.createBuffer();
prng_aes.formatKey = function(key) {
  // convert the key into 32-bit integers
  var tmp = forge.util.createBuffer(key);
  key = new Array(4);
  key[0] = tmp.getInt32();
  key[1] = tmp.getInt32();
  key[2] = tmp.getInt32();
  key[3] = tmp.getInt32();

  // return the expanded key
  return forge.aes._expandKey(key, false);
};
prng_aes.formatSeed = function(seed) {
  // convert seed into 32-bit integers
  var tmp = forge.util.createBuffer(seed);
  seed = new Array(4);
  seed[0] = tmp.getInt32();
  seed[1] = tmp.getInt32();
  seed[2] = tmp.getInt32();
  seed[3] = tmp.getInt32();
  return seed;
};
prng_aes.cipher = function(key, seed) {
  forge.aes._updateBlock(key, seed, _prng_aes_output, false);
  _prng_aes_buffer.putInt32(_prng_aes_output[0]);
  _prng_aes_buffer.putInt32(_prng_aes_output[1]);
  _prng_aes_buffer.putInt32(_prng_aes_output[2]);
  _prng_aes_buffer.putInt32(_prng_aes_output[3]);
  return _prng_aes_buffer.getBytes();
};
prng_aes.increment = function(seed) {
  // FIXME: do we care about carry or signed issues?
  ++seed[3];
  return seed;
};
prng_aes.md = forge.md.sha256;

/**
 * Creates a new PRNG.
 */
function spawnPrng() {
  var ctx = forge.prng.create(prng_aes);

  /**
   * Gets random bytes. If a native secure crypto API is unavailable, this
   * method tries to make the bytes more unpredictable by drawing from data that
   * can be collected from the user of the browser, eg: mouse movement.
   *
   * If a callback is given, this method will be called asynchronously.
   *
   * @param count the number of random bytes to get.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return the random bytes in a string.
   */
  ctx.getBytes = function(count, callback) {
    return ctx.generate(count, callback);
  };

  /**
   * Gets random bytes asynchronously. If a native secure crypto API is
   * unavailable, this method tries to make the bytes more unpredictable by
   * drawing from data that can be collected from the user of the browser,
   * eg: mouse movement.
   *
   * @param count the number of random bytes to get.
   *
   * @return the random bytes in a string.
   */
  ctx.getBytesSync = function(count) {
    return ctx.generate(count);
  };

  return ctx;
}

// create default prng context
var _ctx = spawnPrng();

// add other sources of entropy only if window.crypto.getRandomValues is not
// available -- otherwise this source will be automatically used by the prng
var getRandomValues = null;
var globalScope = forge.util.globalScope;
var _crypto = globalScope.crypto || globalScope.msCrypto;
if(_crypto && _crypto.getRandomValues) {
  getRandomValues = function(arr) {
    return _crypto.getRandomValues(arr);
  };
}

if(forge.options.usePureJavaScript ||
  (!forge.util.isNodejs && !getRandomValues)) {
  // if this is a web worker, do not use weak entropy, instead register to
  // receive strong entropy asynchronously from the main thread
  if(typeof window === 'undefined' || window.document === undefined) {
    // FIXME:
  }

  // get load time entropy
  _ctx.collectInt(+new Date(), 32);

  // add some entropy from navigator object
  if(typeof(navigator) !== 'undefined') {
    var _navBytes = '';
    for(var key in navigator) {
      try {
        if(typeof(navigator[key]) == 'string') {
          _navBytes += navigator[key];
        }
      } catch(e) {
        /* Some navigator keys might not be accessible, e.g. the geolocation
          attribute throws an exception if touched in Mozilla chrome://
          context.

          Silently ignore this and just don't use this as a source of
          entropy. */
      }
    }
    _ctx.collect(_navBytes);
    _navBytes = null;
  }

  // add mouse and keyboard collectors if jquery is available
  if(jQuery) {
    // set up mouse entropy capture
    jQuery().mousemove(function(e) {
      // add mouse coords
      _ctx.collectInt(e.clientX, 16);
      _ctx.collectInt(e.clientY, 16);
    });

    // set up keyboard entropy capture
    jQuery().keypress(function(e) {
      _ctx.collectInt(e.charCode, 8);
    });
  }
}

/* Random API */
if(!forge.random) {
  forge.random = _ctx;
} else {
  // extend forge.random with _ctx
  for(var key in _ctx) {
    forge.random[key] = _ctx[key];
  }
}

// expose spawn PRNG
forge.random.createInstance = spawnPrng;

module.exports = forge.random;

})(typeof(jQuery) !== 'undefined' ? jQuery : null);

})();

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/random.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/jsbn.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/jsbn.js
      return function (require, module, exports) {
// Copyright (c) 2005  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.

// Basic JavaScript BN library - subset useful for RSA encryption.

/*
Licensing (LICENSE)
-------------------

This software is covered under the following copyright:
*/
/*
 * Copyright (c) 2003-2005  Tom Wu
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
 * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * In addition, the following condition applies:
 *
 * All redistributions must retain an intact copy of this copyright notice
 * and disclaimer.
 */
/*
Address all questions regarding this license to:

  Tom Wu
  tjw@cs.Stanford.EDU
*/
var forge = require('./forge');

module.exports = forge.jsbn = forge.jsbn || {};

// Bits per digit
var dbits;

// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary&0xffffff)==0xefcafe);

// (public) Constructor
function BigInteger(a,b,c) {
  this.data = [];
  if(a != null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null && "string" != typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}
forge.jsbn.BigInteger = BigInteger;

// return new, unset BigInteger
function nbi() { return new BigInteger(null); }

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i,x,w,j,c,n) {
  while(--n >= 0) {
    var v = x*this.data[i++]+w.data[j]+c;
    c = Math.floor(v/0x4000000);
    w.data[j++] = v&0x3ffffff;
  }
  return c;
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i,x,w,j,c,n) {
  var xl = x&0x7fff, xh = x>>15;
  while(--n >= 0) {
    var l = this.data[i]&0x7fff;
    var h = this.data[i++]>>15;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x7fff)<<15)+w.data[j]+(c&0x3fffffff);
    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
    w.data[j++] = l&0x3fffffff;
  }
  return c;
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i,x,w,j,c,n) {
  var xl = x&0x3fff, xh = x>>14;
  while(--n >= 0) {
    var l = this.data[i]&0x3fff;
    var h = this.data[i++]>>14;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x3fff)<<14)+w.data[j]+c;
    c = (l>>28)+(m>>14)+xh*h;
    w.data[j++] = l&0xfffffff;
  }
  return c;
}

// node.js (no browser)
if(typeof(navigator) === 'undefined')
{
   BigInteger.prototype.am = am3;
   dbits = 28;
} else if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
  BigInteger.prototype.am = am2;
  dbits = 30;
} else if(j_lm && (navigator.appName != "Netscape")) {
  BigInteger.prototype.am = am1;
  dbits = 26;
} else { // Mozilla/Netscape seems to prefer am3
  BigInteger.prototype.am = am3;
  dbits = 28;
}

BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1<<dbits)-1);
BigInteger.prototype.DV = (1<<dbits);

var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2,BI_FP);
BigInteger.prototype.F1 = BI_FP-dbits;
BigInteger.prototype.F2 = 2*dbits-BI_FP;

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr,vv;
rr = "0".charCodeAt(0);
for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

function int2char(n) { return BI_RM.charAt(n); }
function intAt(s,i) {
  var c = BI_RC[s.charCodeAt(i)];
  return (c==null)?-1:c;
}

// (protected) copy this to r
function bnpCopyTo(r) {
  for(var i = this.t-1; i >= 0; --i) r.data[i] = this.data[i];
  r.t = this.t;
  r.s = this.s;
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
  this.t = 1;
  this.s = (x<0)?-1:0;
  if(x > 0) this.data[0] = x;
  else if(x < -1) this.data[0] = x+this.DV;
  else this.t = 0;
}

// return bigint initialized to value
function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

// (protected) set from string and radix
function bnpFromString(s,b) {
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 256) k = 8; // byte array
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else { this.fromRadix(s,b); return; }
  this.t = 0;
  this.s = 0;
  var i = s.length, mi = false, sh = 0;
  while(--i >= 0) {
    var x = (k==8)?s[i]&0xff:intAt(s,i);
    if(x < 0) {
      if(s.charAt(i) == "-") mi = true;
      continue;
    }
    mi = false;
    if(sh == 0)
      this.data[this.t++] = x;
    else if(sh+k > this.DB) {
      this.data[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
      this.data[this.t++] = (x>>(this.DB-sh));
    } else
      this.data[this.t-1] |= x<<sh;
    sh += k;
    if(sh >= this.DB) sh -= this.DB;
  }
  if(k == 8 && (s[0]&0x80) != 0) {
    this.s = -1;
    if(sh > 0) this.data[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
  }
  this.clamp();
  if(mi) BigInteger.ZERO.subTo(this,this);
}

// (protected) clamp off excess high words
function bnpClamp() {
  var c = this.s&this.DM;
  while(this.t > 0 && this.data[this.t-1] == c) --this.t;
}

// (public) return string representation in given radix
function bnToString(b) {
  if(this.s < 0) return "-"+this.negate().toString(b);
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else return this.toRadix(b);
  var km = (1<<k)-1, d, m = false, r = "", i = this.t;
  var p = this.DB-(i*this.DB)%k;
  if(i-- > 0) {
    if(p < this.DB && (d = this.data[i]>>p) > 0) { m = true; r = int2char(d); }
    while(i >= 0) {
      if(p < k) {
        d = (this.data[i]&((1<<p)-1))<<(k-p);
        d |= this.data[--i]>>(p+=this.DB-k);
      } else {
        d = (this.data[i]>>(p-=k))&km;
        if(p <= 0) { p += this.DB; --i; }
      }
      if(d > 0) m = true;
      if(m) r += int2char(d);
    }
  }
  return m?r:"0";
}

// (public) -this
function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

// (public) |this|
function bnAbs() { return (this.s<0)?this.negate():this; }

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
  var r = this.s-a.s;
  if(r != 0) return r;
  var i = this.t;
  r = i-a.t;
  if(r != 0) return (this.s<0)?-r:r;
  while(--i >= 0) if((r=this.data[i]-a.data[i]) != 0) return r;
  return 0;
}

// returns bit length of the integer x
function nbits(x) {
  var r = 1, t;
  if((t=x>>>16) != 0) { x = t; r += 16; }
  if((t=x>>8) != 0) { x = t; r += 8; }
  if((t=x>>4) != 0) { x = t; r += 4; }
  if((t=x>>2) != 0) { x = t; r += 2; }
  if((t=x>>1) != 0) { x = t; r += 1; }
  return r;
}

// (public) return the number of bits in "this"
function bnBitLength() {
  if(this.t <= 0) return 0;
  return this.DB*(this.t-1)+nbits(this.data[this.t-1]^(this.s&this.DM));
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n,r) {
  var i;
  for(i = this.t-1; i >= 0; --i) r.data[i+n] = this.data[i];
  for(i = n-1; i >= 0; --i) r.data[i] = 0;
  r.t = this.t+n;
  r.s = this.s;
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n,r) {
  for(var i = n; i < this.t; ++i) r.data[i-n] = this.data[i];
  r.t = Math.max(this.t-n,0);
  r.s = this.s;
}

// (protected) r = this << n
function bnpLShiftTo(n,r) {
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1<<cbs)-1;
  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
  for(i = this.t-1; i >= 0; --i) {
    r.data[i+ds+1] = (this.data[i]>>cbs)|c;
    c = (this.data[i]&bm)<<bs;
  }
  for(i = ds-1; i >= 0; --i) r.data[i] = 0;
  r.data[ds] = c;
  r.t = this.t+ds+1;
  r.s = this.s;
  r.clamp();
}

// (protected) r = this >> n
function bnpRShiftTo(n,r) {
  r.s = this.s;
  var ds = Math.floor(n/this.DB);
  if(ds >= this.t) { r.t = 0; return; }
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1<<bs)-1;
  r.data[0] = this.data[ds]>>bs;
  for(var i = ds+1; i < this.t; ++i) {
    r.data[i-ds-1] |= (this.data[i]&bm)<<cbs;
    r.data[i-ds] = this.data[i]>>bs;
  }
  if(bs > 0) r.data[this.t-ds-1] |= (this.s&bm)<<cbs;
  r.t = this.t-ds;
  r.clamp();
}

// (protected) r = this - a
function bnpSubTo(a,r) {
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this.data[i]-a.data[i];
    r.data[i++] = c&this.DM;
    c >>= this.DB;
  }
  if(a.t < this.t) {
    c -= a.s;
    while(i < this.t) {
      c += this.data[i];
      r.data[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while(i < a.t) {
      c -= a.data[i];
      r.data[i++] = c&this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = (c<0)?-1:0;
  if(c < -1) r.data[i++] = this.DV+c;
  else if(c > 0) r.data[i++] = c;
  r.t = i;
  r.clamp();
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i+y.t;
  while(--i >= 0) r.data[i] = 0;
  for(i = 0; i < y.t; ++i) r.data[i+x.t] = x.am(0,y.data[i],r,i,0,x.t);
  r.s = 0;
  r.clamp();
  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
  var x = this.abs();
  var i = r.t = 2*x.t;
  while(--i >= 0) r.data[i] = 0;
  for(i = 0; i < x.t-1; ++i) {
    var c = x.am(i,x.data[i],r,2*i,0,1);
    if((r.data[i+x.t]+=x.am(i+1,2*x.data[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
      r.data[i+x.t] -= x.DV;
      r.data[i+x.t+1] = 1;
    }
  }
  if(r.t > 0) r.data[r.t-1] += x.am(i,x.data[i],r,2*i,0,1);
  r.s = 0;
  r.clamp();
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m,q,r) {
  var pm = m.abs();
  if(pm.t <= 0) return;
  var pt = this.abs();
  if(pt.t < pm.t) {
    if(q != null) q.fromInt(0);
    if(r != null) this.copyTo(r);
    return;
  }
  if(r == null) r = nbi();
  var y = nbi(), ts = this.s, ms = m.s;
  var nsh = this.DB-nbits(pm.data[pm.t-1]);	// normalize modulus
  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); } else { pm.copyTo(y); pt.copyTo(r); }
  var ys = y.t;
  var y0 = y.data[ys-1];
  if(y0 == 0) return;
  var yt = y0*(1<<this.F1)+((ys>1)?y.data[ys-2]>>this.F2:0);
  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
  var i = r.t, j = i-ys, t = (q==null)?nbi():q;
  y.dlShiftTo(j,t);
  if(r.compareTo(t) >= 0) {
    r.data[r.t++] = 1;
    r.subTo(t,r);
  }
  BigInteger.ONE.dlShiftTo(ys,t);
  t.subTo(y,y);	// "negative" y so we can replace sub with am later
  while(y.t < ys) y.data[y.t++] = 0;
  while(--j >= 0) {
    // Estimate quotient digit
    var qd = (r.data[--i]==y0)?this.DM:Math.floor(r.data[i]*d1+(r.data[i-1]+e)*d2);
    if((r.data[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
      y.dlShiftTo(j,t);
      r.subTo(t,r);
      while(r.data[i] < --qd) r.subTo(t,r);
    }
  }
  if(q != null) {
    r.drShiftTo(ys,q);
    if(ts != ms) BigInteger.ZERO.subTo(q,q);
  }
  r.t = ys;
  r.clamp();
  if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
  if(ts < 0) BigInteger.ZERO.subTo(r,r);
}

// (public) this mod a
function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a,null,r);
  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
  return r;
}

// Modular reduction using "classic" algorithm
function Classic(m) { this.m = m; }
function cConvert(x) {
  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
  else return x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m,null,x); }
function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
  if(this.t < 1) return 0;
  var x = this.data[0];
  if((x&1) == 0) return 0;
  var y = x&3;		// y == 1/x mod 2^2
  y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
  y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly;
  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
  y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV < y < DV
  return (y>0)?this.DV-y:-y;
}

// Montgomery reduction
function Montgomery(m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp&0x7fff;
  this.mph = this.mp>>15;
  this.um = (1<<(m.DB-15))-1;
  this.mt2 = 2*m.t;
}

// xR mod m
function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t,r);
  r.divRemTo(this.m,null,r);
  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
  return r;
}

// x/R mod m
function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
  while(x.t <= this.mt2)	// pad x so am has enough room later
    x.data[x.t++] = 0;
  for(var i = 0; i < this.m.t; ++i) {
    // faster way of calculating u0 = x.data[i]*mp mod DV
    var j = x.data[i]&0x7fff;
    var u0 = (j*this.mpl+(((j*this.mph+(x.data[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
    // use am to combine the multiply-shift-add into one call
    j = i+this.m.t;
    x.data[j] += this.m.am(0,u0,x,i,0,this.m.t);
    // propagate carry
    while(x.data[j] >= x.DV) { x.data[j] -= x.DV; x.data[++j]++; }
  }
  x.clamp();
  x.drShiftTo(this.m.t,x);
  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

// r = "xy/R mod m"; x,y != r
function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;

// (protected) true iff this is even
function bnpIsEven() { return ((this.t>0)?(this.data[0]&1):this.s) == 0; }

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e,z) {
  if(e > 0xffffffff || e < 1) return BigInteger.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
  g.copyTo(r);
  while(--i >= 0) {
    z.sqrTo(r,r2);
    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
    else { var t = r; r = r2; r2 = t; }
  }
  return z.revert(r);
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e,m) {
  var z;
  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
  return this.exp(e,z);
}

// protected
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;

// public
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;

// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

// jsbn2 lib

//Copyright (c) 2005-2009  Tom Wu
//All Rights Reserved.
//See "LICENSE" for details (See jsbn.js for LICENSE).

//Extended JavaScript BN functions, required for RSA private ops.

//Version 1.1: new BigInteger("0", 10) returns "proper" zero

//(public)
function bnClone() { var r = nbi(); this.copyTo(r); return r; }

//(public) return value as integer
function bnIntValue() {
if(this.s < 0) {
 if(this.t == 1) return this.data[0]-this.DV;
 else if(this.t == 0) return -1;
} else if(this.t == 1) return this.data[0];
else if(this.t == 0) return 0;
// assumes 16 < DB < 32
return ((this.data[1]&((1<<(32-this.DB))-1))<<this.DB)|this.data[0];
}

//(public) return value as byte
function bnByteValue() { return (this.t==0)?this.s:(this.data[0]<<24)>>24; }

//(public) return value as short (assumes DB>=16)
function bnShortValue() { return (this.t==0)?this.s:(this.data[0]<<16)>>16; }

//(protected) return x s.t. r^x < DV
function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

//(public) 0 if this == 0, 1 if this > 0
function bnSigNum() {
if(this.s < 0) return -1;
else if(this.t <= 0 || (this.t == 1 && this.data[0] <= 0)) return 0;
else return 1;
}

//(protected) convert to radix string
function bnpToRadix(b) {
if(b == null) b = 10;
if(this.signum() == 0 || b < 2 || b > 36) return "0";
var cs = this.chunkSize(b);
var a = Math.pow(b,cs);
var d = nbv(a), y = nbi(), z = nbi(), r = "";
this.divRemTo(d,y,z);
while(y.signum() > 0) {
 r = (a+z.intValue()).toString(b).substr(1) + r;
 y.divRemTo(d,y,z);
}
return z.intValue().toString(b) + r;
}

//(protected) convert from radix string
function bnpFromRadix(s,b) {
this.fromInt(0);
if(b == null) b = 10;
var cs = this.chunkSize(b);
var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
for(var i = 0; i < s.length; ++i) {
 var x = intAt(s,i);
 if(x < 0) {
   if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
   continue;
 }
 w = b*w+x;
 if(++j >= cs) {
   this.dMultiply(d);
   this.dAddOffset(w,0);
   j = 0;
   w = 0;
 }
}
if(j > 0) {
 this.dMultiply(Math.pow(b,j));
 this.dAddOffset(w,0);
}
if(mi) BigInteger.ZERO.subTo(this,this);
}

//(protected) alternate constructor
function bnpFromNumber(a,b,c) {
if("number" == typeof b) {
 // new BigInteger(int,int,RNG)
 if(a < 2) this.fromInt(1);
 else {
   this.fromNumber(a,c);
   if(!this.testBit(a-1))  // force MSB set
     this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
   if(this.isEven()) this.dAddOffset(1,0); // force odd
   while(!this.isProbablePrime(b)) {
     this.dAddOffset(2,0);
     if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
   }
 }
} else {
 // new BigInteger(int,RNG)
 var x = new Array(), t = a&7;
 x.length = (a>>3)+1;
 b.nextBytes(x);
 if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
 this.fromString(x,256);
}
}

//(public) convert to bigendian byte array
function bnToByteArray() {
var i = this.t, r = new Array();
r[0] = this.s;
var p = this.DB-(i*this.DB)%8, d, k = 0;
if(i-- > 0) {
 if(p < this.DB && (d = this.data[i]>>p) != (this.s&this.DM)>>p)
   r[k++] = d|(this.s<<(this.DB-p));
 while(i >= 0) {
   if(p < 8) {
     d = (this.data[i]&((1<<p)-1))<<(8-p);
     d |= this.data[--i]>>(p+=this.DB-8);
   } else {
     d = (this.data[i]>>(p-=8))&0xff;
     if(p <= 0) { p += this.DB; --i; }
   }
   if((d&0x80) != 0) d |= -256;
   if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
   if(k > 0 || d != this.s) r[k++] = d;
 }
}
return r;
}

function bnEquals(a) { return(this.compareTo(a)==0); }
function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

//(protected) r = this op a (bitwise)
function bnpBitwiseTo(a,op,r) {
var i, f, m = Math.min(a.t,this.t);
for(i = 0; i < m; ++i) r.data[i] = op(this.data[i],a.data[i]);
if(a.t < this.t) {
 f = a.s&this.DM;
 for(i = m; i < this.t; ++i) r.data[i] = op(this.data[i],f);
 r.t = this.t;
} else {
 f = this.s&this.DM;
 for(i = m; i < a.t; ++i) r.data[i] = op(f,a.data[i]);
 r.t = a.t;
}
r.s = op(this.s,a.s);
r.clamp();
}

//(public) this & a
function op_and(x,y) { return x&y; }
function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

//(public) this | a
function op_or(x,y) { return x|y; }
function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

//(public) this ^ a
function op_xor(x,y) { return x^y; }
function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

//(public) this & ~a
function op_andnot(x,y) { return x&~y; }
function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

//(public) ~this
function bnNot() {
var r = nbi();
for(var i = 0; i < this.t; ++i) r.data[i] = this.DM&~this.data[i];
r.t = this.t;
r.s = ~this.s;
return r;
}

//(public) this << n
function bnShiftLeft(n) {
var r = nbi();
if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
return r;
}

//(public) this >> n
function bnShiftRight(n) {
var r = nbi();
if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
return r;
}

//return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
if(x == 0) return -1;
var r = 0;
if((x&0xffff) == 0) { x >>= 16; r += 16; }
if((x&0xff) == 0) { x >>= 8; r += 8; }
if((x&0xf) == 0) { x >>= 4; r += 4; }
if((x&3) == 0) { x >>= 2; r += 2; }
if((x&1) == 0) ++r;
return r;
}

//(public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit() {
for(var i = 0; i < this.t; ++i)
 if(this.data[i] != 0) return i*this.DB+lbit(this.data[i]);
if(this.s < 0) return this.t*this.DB;
return -1;
}

//return number of 1 bits in x
function cbit(x) {
var r = 0;
while(x != 0) { x &= x-1; ++r; }
return r;
}

//(public) return number of set bits
function bnBitCount() {
var r = 0, x = this.s&this.DM;
for(var i = 0; i < this.t; ++i) r += cbit(this.data[i]^x);
return r;
}

//(public) true iff nth bit is set
function bnTestBit(n) {
var j = Math.floor(n/this.DB);
if(j >= this.t) return(this.s!=0);
return((this.data[j]&(1<<(n%this.DB)))!=0);
}

//(protected) this op (1<<n)
function bnpChangeBit(n,op) {
var r = BigInteger.ONE.shiftLeft(n);
this.bitwiseTo(r,op,r);
return r;
}

//(public) this | (1<<n)
function bnSetBit(n) { return this.changeBit(n,op_or); }

//(public) this & ~(1<<n)
function bnClearBit(n) { return this.changeBit(n,op_andnot); }

//(public) this ^ (1<<n)
function bnFlipBit(n) { return this.changeBit(n,op_xor); }

//(protected) r = this + a
function bnpAddTo(a,r) {
var i = 0, c = 0, m = Math.min(a.t,this.t);
while(i < m) {
 c += this.data[i]+a.data[i];
 r.data[i++] = c&this.DM;
 c >>= this.DB;
}
if(a.t < this.t) {
 c += a.s;
 while(i < this.t) {
   c += this.data[i];
   r.data[i++] = c&this.DM;
   c >>= this.DB;
 }
 c += this.s;
} else {
 c += this.s;
 while(i < a.t) {
   c += a.data[i];
   r.data[i++] = c&this.DM;
   c >>= this.DB;
 }
 c += a.s;
}
r.s = (c<0)?-1:0;
if(c > 0) r.data[i++] = c;
else if(c < -1) r.data[i++] = this.DV+c;
r.t = i;
r.clamp();
}

//(public) this + a
function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

//(public) this - a
function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

//(public) this * a
function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

//(public) this / a
function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

//(public) this % a
function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

//(public) [this/a,this%a]
function bnDivideAndRemainder(a) {
var q = nbi(), r = nbi();
this.divRemTo(a,q,r);
return new Array(q,r);
}

//(protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n) {
this.data[this.t] = this.am(0,n-1,this,0,0,this.t);
++this.t;
this.clamp();
}

//(protected) this += n << w words, this >= 0
function bnpDAddOffset(n,w) {
if(n == 0) return;
while(this.t <= w) this.data[this.t++] = 0;
this.data[w] += n;
while(this.data[w] >= this.DV) {
 this.data[w] -= this.DV;
 if(++w >= this.t) this.data[this.t++] = 0;
 ++this.data[w];
}
}

//A "null" reducer
function NullExp() {}
function nNop(x) { return x; }
function nMulTo(x,y,r) { x.multiplyTo(y,r); }
function nSqrTo(x,r) { x.squareTo(r); }

NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;

//(public) this^e
function bnPow(e) { return this.exp(e,new NullExp()); }

//(protected) r = lower n words of "this * a", a.t <= n
//"this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a,n,r) {
var i = Math.min(this.t+a.t,n);
r.s = 0; // assumes a,this >= 0
r.t = i;
while(i > 0) r.data[--i] = 0;
var j;
for(j = r.t-this.t; i < j; ++i) r.data[i+this.t] = this.am(0,a.data[i],r,i,0,this.t);
for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a.data[i],r,i,0,n-i);
r.clamp();
}

//(protected) r = "this * a" without lower n words, n > 0
//"this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a,n,r) {
--n;
var i = r.t = this.t+a.t-n;
r.s = 0; // assumes a,this >= 0
while(--i >= 0) r.data[i] = 0;
for(i = Math.max(n-this.t,0); i < a.t; ++i)
 r.data[this.t+i-n] = this.am(n-i,a.data[i],r,0,0,this.t+i-n);
r.clamp();
r.drShiftTo(1,r);
}

//Barrett modular reduction
function Barrett(m) {
// setup Barrett
this.r2 = nbi();
this.q3 = nbi();
BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
this.mu = this.r2.divide(m);
this.m = m;
}

function barrettConvert(x) {
if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
else if(x.compareTo(this.m) < 0) return x;
else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
}

function barrettRevert(x) { return x; }

//x = x mod m (HAC 14.42)
function barrettReduce(x) {
x.drShiftTo(this.m.t-1,this.r2);
if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
x.subTo(this.r2,x);
while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

//r = x^2 mod m; x != r
function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

//r = x*y mod m; x,y != r
function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;

//(public) this^e % m (HAC 14.85)
function bnModPow(e,m) {
var i = e.bitLength(), k, r = nbv(1), z;
if(i <= 0) return r;
else if(i < 18) k = 1;
else if(i < 48) k = 3;
else if(i < 144) k = 4;
else if(i < 768) k = 5;
else k = 6;
if(i < 8)
 z = new Classic(m);
else if(m.isEven())
 z = new Barrett(m);
else
 z = new Montgomery(m);

// precomputation
var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
g[1] = z.convert(this);
if(k > 1) {
 var g2 = nbi();
 z.sqrTo(g[1],g2);
 while(n <= km) {
   g[n] = nbi();
   z.mulTo(g2,g[n-2],g[n]);
   n += 2;
 }
}

var j = e.t-1, w, is1 = true, r2 = nbi(), t;
i = nbits(e.data[j])-1;
while(j >= 0) {
 if(i >= k1) w = (e.data[j]>>(i-k1))&km;
 else {
   w = (e.data[j]&((1<<(i+1))-1))<<(k1-i);
   if(j > 0) w |= e.data[j-1]>>(this.DB+i-k1);
 }

 n = k;
 while((w&1) == 0) { w >>= 1; --n; }
 if((i -= n) < 0) { i += this.DB; --j; }
 if(is1) {  // ret == 1, don't bother squaring or multiplying it
   g[w].copyTo(r);
   is1 = false;
 } else {
   while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
   if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
   z.mulTo(r2,g[w],r);
 }

 while(j >= 0 && (e.data[j]&(1<<i)) == 0) {
   z.sqrTo(r,r2); t = r; r = r2; r2 = t;
   if(--i < 0) { i = this.DB-1; --j; }
 }
}
return z.revert(r);
}

//(public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
var x = (this.s<0)?this.negate():this.clone();
var y = (a.s<0)?a.negate():a.clone();
if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
var i = x.getLowestSetBit(), g = y.getLowestSetBit();
if(g < 0) return x;
if(i < g) g = i;
if(g > 0) {
 x.rShiftTo(g,x);
 y.rShiftTo(g,y);
}
while(x.signum() > 0) {
 if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
 if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
 if(x.compareTo(y) >= 0) {
   x.subTo(y,x);
   x.rShiftTo(1,x);
 } else {
   y.subTo(x,y);
   y.rShiftTo(1,y);
 }
}
if(g > 0) y.lShiftTo(g,y);
return y;
}

//(protected) this % n, n < 2^26
function bnpModInt(n) {
if(n <= 0) return 0;
var d = this.DV%n, r = (this.s<0)?n-1:0;
if(this.t > 0)
 if(d == 0) r = this.data[0]%n;
 else for(var i = this.t-1; i >= 0; --i) r = (d*r+this.data[i])%n;
return r;
}

//(public) 1/this % m (HAC 14.61)
function bnModInverse(m) {
var ac = m.isEven();
if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
var u = m.clone(), v = this.clone();
var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
while(u.signum() != 0) {
 while(u.isEven()) {
   u.rShiftTo(1,u);
   if(ac) {
     if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
     a.rShiftTo(1,a);
   } else if(!b.isEven()) b.subTo(m,b);
   b.rShiftTo(1,b);
 }
 while(v.isEven()) {
   v.rShiftTo(1,v);
   if(ac) {
     if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
     c.rShiftTo(1,c);
   } else if(!d.isEven()) d.subTo(m,d);
   d.rShiftTo(1,d);
 }
 if(u.compareTo(v) >= 0) {
   u.subTo(v,u);
   if(ac) a.subTo(c,a);
   b.subTo(d,b);
 } else {
   v.subTo(u,v);
   if(ac) c.subTo(a,c);
   d.subTo(b,d);
 }
}
if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
if(d.compareTo(m) >= 0) return d.subtract(m);
if(d.signum() < 0) d.addTo(m,d); else return d;
if(d.signum() < 0) return d.add(m); else return d;
}

var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];
var lplim = (1<<26)/lowprimes[lowprimes.length-1];

//(public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t) {
var i, x = this.abs();
if(x.t == 1 && x.data[0] <= lowprimes[lowprimes.length-1]) {
 for(i = 0; i < lowprimes.length; ++i)
   if(x.data[0] == lowprimes[i]) return true;
 return false;
}
if(x.isEven()) return false;
i = 1;
while(i < lowprimes.length) {
 var m = lowprimes[i], j = i+1;
 while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
 m = x.modInt(m);
 while(i < j) if(m%lowprimes[i++] == 0) return false;
}
return x.millerRabin(t);
}

//(protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
var n1 = this.subtract(BigInteger.ONE);
var k = n1.getLowestSetBit();
if(k <= 0) return false;
var r = n1.shiftRight(k);
var prng = bnGetPrng();
var a;
for(var i = 0; i < t; ++i) {
 // select witness 'a' at random from between 1 and n1
 do {
   a = new BigInteger(this.bitLength(), prng);
 }
 while(a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
 var y = a.modPow(r,this);
 if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
   var j = 1;
   while(j++ < k && y.compareTo(n1) != 0) {
     y = y.modPowInt(2,this);
     if(y.compareTo(BigInteger.ONE) == 0) return false;
   }
   if(y.compareTo(n1) != 0) return false;
 }
}
return true;
}

// get pseudo random number generator
function bnGetPrng() {
  // create prng with api that matches BigInteger secure random
  return {
    // x is an array to fill with bytes
    nextBytes: function(x) {
      for(var i = 0; i < x.length; ++i) {
        x[i] = Math.floor(Math.random() * 0x0100);
      }
    }
  };
}

//protected
BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;

//public
BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

//BigInteger interfaces not implemented in jsbn:

//BigInteger(int signum, byte[] magnitude)
//double doubleValue()
//float floatValue()
//int hashCode()
//long longValue()
//static BigInteger valueOf(long val)

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/jsbn.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/prime.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./jsbn":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/jsbn.js","./random":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/random.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/prime.js
      return function (require, module, exports) {
/**
 * Prime number generation API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./util');
require('./jsbn');
require('./random');

(function() {

// forge.prime already defined
if(forge.prime) {
  module.exports = forge.prime;
  return;
}

/* PRIME API */
var prime = module.exports = forge.prime = forge.prime || {};

var BigInteger = forge.jsbn.BigInteger;

// primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29
var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
var THIRTY = new BigInteger(null);
THIRTY.fromInt(30);
var op_or = function(x, y) {return x|y;};

/**
 * Generates a random probable prime with the given number of bits.
 *
 * Alternative algorithms can be specified by name as a string or as an
 * object with custom options like so:
 *
 * {
 *   name: 'PRIMEINC',
 *   options: {
 *     maxBlockTime: <the maximum amount of time to block the main
 *       thread before allowing I/O other JS to run>,
 *     millerRabinTests: <the number of miller-rabin tests to run>,
 *     workerScript: <the worker script URL>,
 *     workers: <the number of web workers (if supported) to use,
 *       -1 to use estimated cores minus one>.
 *     workLoad: the size of the work load, ie: number of possible prime
 *       numbers for each web worker to check per work assignment,
 *       (default: 100).
 *   }
 * }
 *
 * @param bits the number of bits for the prime number.
 * @param options the options to use.
 *          [algorithm] the algorithm to use (default: 'PRIMEINC').
 *          [prng] a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *
 * @return callback(err, num) called once the operation completes.
 */
prime.generateProbablePrime = function(bits, options, callback) {
  if(typeof options === 'function') {
    callback = options;
    options = {};
  }
  options = options || {};

  // default to PRIMEINC algorithm
  var algorithm = options.algorithm || 'PRIMEINC';
  if(typeof algorithm === 'string') {
    algorithm = {name: algorithm};
  }
  algorithm.options = algorithm.options || {};

  // create prng with api that matches BigInteger secure random
  var prng = options.prng || forge.random;
  var rng = {
    // x is an array to fill with bytes
    nextBytes: function(x) {
      var b = prng.getBytesSync(x.length);
      for(var i = 0; i < x.length; ++i) {
        x[i] = b.charCodeAt(i);
      }
    }
  };

  if(algorithm.name === 'PRIMEINC') {
    return primeincFindPrime(bits, rng, algorithm.options, callback);
  }

  throw new Error('Invalid prime generation algorithm: ' + algorithm.name);
};

function primeincFindPrime(bits, rng, options, callback) {
  if('workers' in options) {
    return primeincFindPrimeWithWorkers(bits, rng, options, callback);
  }
  return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
}

function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
  // initialize random number
  var num = generateRandom(bits, rng);

  /* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The
  number we are given is always aligned at 30k + 1. Each time the number is
  determined not to be prime we add to get to the next 'i', eg: if the number
  was at 30k + 1 we add 6. */
  var deltaIdx = 0;

  // get required number of MR tests
  var mrTests = getMillerRabinTests(num.bitLength());
  if('millerRabinTests' in options) {
    mrTests = options.millerRabinTests;
  }

  // find prime nearest to 'num' for maxBlockTime ms
  // 10 ms gives 5ms of leeway for other calculations before dropping
  // below 60fps (1000/60 == 16.67), but in reality, the number will
  // likely be higher due to an 'atomic' big int modPow
  var maxBlockTime = 10;
  if('maxBlockTime' in options) {
    maxBlockTime = options.maxBlockTime;
  }

  _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
}

function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
  var start = +new Date();
  do {
    // overflow, regenerate random number
    if(num.bitLength() > bits) {
      num = generateRandom(bits, rng);
    }
    // do primality test
    if(num.isProbablePrime(mrTests)) {
      return callback(null, num);
    }
    // get next potential prime
    num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
  } while(maxBlockTime < 0 || (+new Date() - start < maxBlockTime));

  // keep trying later
  forge.util.setImmediate(function() {
    _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
  });
}

// NOTE: This algorithm is indeterminate in nature because workers
// run in parallel looking at different segments of numbers. Even if this
// algorithm is run twice with the same input from a predictable RNG, it
// may produce different outputs.
function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
  // web workers unavailable
  if(typeof Worker === 'undefined') {
    return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
  }

  // initialize random number
  var num = generateRandom(bits, rng);

  // use web workers to generate keys
  var numWorkers = options.workers;
  var workLoad = options.workLoad || 100;
  var range = workLoad * 30 / 8;
  var workerScript = options.workerScript || 'forge/prime.worker.js';
  if(numWorkers === -1) {
    return forge.util.estimateCores(function(err, cores) {
      if(err) {
        // default to 2
        cores = 2;
      }
      numWorkers = cores - 1;
      generate();
    });
  }
  generate();

  function generate() {
    // require at least 1 worker
    numWorkers = Math.max(1, numWorkers);

    // TODO: consider optimizing by starting workers outside getPrime() ...
    // note that in order to clean up they will have to be made internally
    // asynchronous which may actually be slower

    // start workers immediately
    var workers = [];
    for(var i = 0; i < numWorkers; ++i) {
      // FIXME: fix path or use blob URLs
      workers[i] = new Worker(workerScript);
    }
    var running = numWorkers;

    // listen for requests from workers and assign ranges to find prime
    for(var i = 0; i < numWorkers; ++i) {
      workers[i].addEventListener('message', workerMessage);
    }

    /* Note: The distribution of random numbers is unknown. Therefore, each
    web worker is continuously allocated a range of numbers to check for a
    random number until one is found.

    Every 30 numbers will be checked just 8 times, because prime numbers
    have the form:

    30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)

    Therefore, if we want a web worker to run N checks before asking for
    a new range of numbers, each range must contain N*30/8 numbers.

    For 100 checks (workLoad), this is a range of 375. */

    var found = false;
    function workerMessage(e) {
      // ignore message, prime already found
      if(found) {
        return;
      }

      --running;
      var data = e.data;
      if(data.found) {
        // terminate all workers
        for(var i = 0; i < workers.length; ++i) {
          workers[i].terminate();
        }
        found = true;
        return callback(null, new BigInteger(data.prime, 16));
      }

      // overflow, regenerate random number
      if(num.bitLength() > bits) {
        num = generateRandom(bits, rng);
      }

      // assign new range to check
      var hex = num.toString(16);

      // start prime search
      e.target.postMessage({
        hex: hex,
        workLoad: workLoad
      });

      num.dAddOffset(range, 0);
    }
  }
}

/**
 * Generates a random number using the given number of bits and RNG.
 *
 * @param bits the number of bits for the number.
 * @param rng the random number generator to use.
 *
 * @return the random number.
 */
function generateRandom(bits, rng) {
  var num = new BigInteger(bits, rng);
  // force MSB set
  var bits1 = bits - 1;
  if(!num.testBit(bits1)) {
    num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
  }
  // align number on 30k+1 boundary
  num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
  return num;
}

/**
 * Returns the required number of Miller-Rabin tests to generate a
 * prime with an error probability of (1/2)^80.
 *
 * See Handbook of Applied Cryptography Chapter 4, Table 4.4.
 *
 * @param bits the bit size.
 *
 * @return the required number of iterations.
 */
function getMillerRabinTests(bits) {
  if(bits <= 100) return 27;
  if(bits <= 150) return 18;
  if(bits <= 200) return 15;
  if(bits <= 250) return 12;
  if(bits <= 300) return 9;
  if(bits <= 350) return 8;
  if(bits <= 400) return 7;
  if(bits <= 500) return 6;
  if(bits <= 600) return 5;
  if(bits <= 800) return 4;
  if(bits <= 1250) return 3;
  return 2;
}

})();

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/prime.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pkcs1.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./random":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/random.js","./sha1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/sha1.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pkcs1.js
      return function (require, module, exports) {
/**
 * Partial implementation of PKCS#1 v2.2: RSA-OEAP
 *
 * Modified but based on the following MIT and BSD licensed code:
 *
 * https://github.com/kjur/jsjws/blob/master/rsa.js:
 *
 * The 'jsjws'(JSON Web Signature JavaScript Library) License
 *
 * Copyright (c) 2012 Kenji Urushima
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:
 *
 * RSAES-OAEP.js
 * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $
 * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)
 * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.
 * Contact: ellis@nukinetics.com
 * Distributed under the BSD License.
 *
 * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125
 *
 * @author Evan Jones (http://evanjones.ca/)
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./util');
require('./random');
require('./sha1');

// shortcut for PKCS#1 API
var pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};

/**
 * Encode the given RSAES-OAEP message (M) using key, with optional label (L)
 * and seed.
 *
 * This method does not perform RSA encryption, it only encodes the message
 * using RSAES-OAEP.
 *
 * @param key the RSA key to use.
 * @param message the message to encode.
 * @param options the options to use:
 *          label an optional label to use.
 *          seed the seed to use.
 *          md the message digest object to use, undefined for SHA-1.
 *          mgf1 optional mgf1 parameters:
 *            md the message digest object to use for MGF1.
 *
 * @return the encoded message bytes.
 */
pkcs1.encode_rsa_oaep = function(key, message, options) {
  // parse arguments
  var label;
  var seed;
  var md;
  var mgf1Md;
  // legacy args (label, seed, md)
  if(typeof options === 'string') {
    label = options;
    seed = arguments[3] || undefined;
    md = arguments[4] || undefined;
  } else if(options) {
    label = options.label || undefined;
    seed = options.seed || undefined;
    md = options.md || undefined;
    if(options.mgf1 && options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  }

  // default OAEP to SHA-1 message digest
  if(!md) {
    md = forge.md.sha1.create();
  } else {
    md.start();
  }

  // default MGF-1 to same as OAEP
  if(!mgf1Md) {
    mgf1Md = md;
  }

  // compute length in bytes and check output
  var keyLength = Math.ceil(key.n.bitLength() / 8);
  var maxLength = keyLength - 2 * md.digestLength - 2;
  if(message.length > maxLength) {
    var error = new Error('RSAES-OAEP input message length is too long.');
    error.length = message.length;
    error.maxLength = maxLength;
    throw error;
  }

  if(!label) {
    label = '';
  }
  md.update(label, 'raw');
  var lHash = md.digest();

  var PS = '';
  var PS_length = maxLength - message.length;
  for(var i = 0; i < PS_length; i++) {
    PS += '\x00';
  }

  var DB = lHash.getBytes() + PS + '\x01' + message;

  if(!seed) {
    seed = forge.random.getBytes(md.digestLength);
  } else if(seed.length !== md.digestLength) {
    var error = new Error('Invalid RSAES-OAEP seed. The seed length must ' +
      'match the digest length.');
    error.seedLength = seed.length;
    error.digestLength = md.digestLength;
    throw error;
  }

  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);

  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);

  // return encoded message
  return '\x00' + maskedSeed + maskedDB;
};

/**
 * Decode the given RSAES-OAEP encoded message (EM) using key, with optional
 * label (L).
 *
 * This method does not perform RSA decryption, it only decodes the message
 * using RSAES-OAEP.
 *
 * @param key the RSA key to use.
 * @param em the encoded message to decode.
 * @param options the options to use:
 *          label an optional label to use.
 *          md the message digest object to use for OAEP, undefined for SHA-1.
 *          mgf1 optional mgf1 parameters:
 *            md the message digest object to use for MGF1.
 *
 * @return the decoded message bytes.
 */
pkcs1.decode_rsa_oaep = function(key, em, options) {
  // parse args
  var label;
  var md;
  var mgf1Md;
  // legacy args
  if(typeof options === 'string') {
    label = options;
    md = arguments[3] || undefined;
  } else if(options) {
    label = options.label || undefined;
    md = options.md || undefined;
    if(options.mgf1 && options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  }

  // compute length in bytes
  var keyLength = Math.ceil(key.n.bitLength() / 8);

  if(em.length !== keyLength) {
    var error = new Error('RSAES-OAEP encoded message length is invalid.');
    error.length = em.length;
    error.expectedLength = keyLength;
    throw error;
  }

  // default OAEP to SHA-1 message digest
  if(md === undefined) {
    md = forge.md.sha1.create();
  } else {
    md.start();
  }

  // default MGF-1 to same as OAEP
  if(!mgf1Md) {
    mgf1Md = md;
  }

  if(keyLength < 2 * md.digestLength + 2) {
    throw new Error('RSAES-OAEP key is too short for the hash function.');
  }

  if(!label) {
    label = '';
  }
  md.update(label, 'raw');
  var lHash = md.digest().getBytes();

  // split the message into its parts
  var y = em.charAt(0);
  var maskedSeed = em.substring(1, md.digestLength + 1);
  var maskedDB = em.substring(1 + md.digestLength);

  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);

  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);

  var lHashPrime = db.substring(0, md.digestLength);

  // constant time check that all values match what is expected
  var error = (y !== '\x00');

  // constant time check lHash vs lHashPrime
  for(var i = 0; i < md.digestLength; ++i) {
    error |= (lHash.charAt(i) !== lHashPrime.charAt(i));
  }

  // "constant time" find the 0x1 byte separating the padding (zeros) from the
  // message
  // TODO: It must be possible to do this in a better/smarter way?
  var in_ps = 1;
  var index = md.digestLength;
  for(var j = md.digestLength; j < db.length; j++) {
    var code = db.charCodeAt(j);

    var is_0 = (code & 0x1) ^ 0x1;

    // non-zero if not 0 or 1 in the ps section
    var error_mask = in_ps ? 0xfffe : 0x0000;
    error |= (code & error_mask);

    // latch in_ps to zero after we find 0x1
    in_ps = in_ps & is_0;
    index += in_ps;
  }

  if(error || db.charCodeAt(index) !== 0x1) {
    throw new Error('Invalid RSAES-OAEP padding.');
  }

  return db.substring(index + 1);
};

function rsa_mgf1(seed, maskLength, hash) {
  // default to SHA-1 message digest
  if(!hash) {
    hash = forge.md.sha1.create();
  }
  var t = '';
  var count = Math.ceil(maskLength / hash.digestLength);
  for(var i = 0; i < count; ++i) {
    var c = String.fromCharCode(
      (i >> 24) & 0xFF, (i >> 16) & 0xFF, (i >> 8) & 0xFF, i & 0xFF);
    hash.start();
    hash.update(seed + c);
    t += hash.digest().getBytes();
  }
  return t.substring(0, maskLength);
}

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pkcs1.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/rsa-browser.js", {"../nodeify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/nodeify.js","../random-bytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/random-bytes.js","../webcrypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/webcrypto.js","./rsa-utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/rsa-utils.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/rsa-browser.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const nodeify = require('../nodeify')
const webcrypto = require('../webcrypto')
const randomBytes = require('../random-bytes')

exports.utils = require('./rsa-utils')

exports.generateKey = function (bits, callback) {
  nodeify(webcrypto.subtle.generateKey(
    {
      name: 'RSASSA-PKCS1-v1_5',
      modulusLength: bits,
      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
      hash: { name: 'SHA-256' }
    },
    true,
    ['sign', 'verify']
  )
    .then(exportKey)
    .then((keys) => ({
      privateKey: keys[0],
      publicKey: keys[1]
    })), callback)
}

// Takes a jwk key
exports.unmarshalPrivateKey = function (key, callback) {
  const privateKey = webcrypto.subtle.importKey(
    'jwk',
    key,
    {
      name: 'RSASSA-PKCS1-v1_5',
      hash: { name: 'SHA-256' }
    },
    true,
    ['sign']
  )

  nodeify(Promise.all([
    privateKey,
    derivePublicFromPrivate(key)
  ]).then((keys) => exportKey({
    privateKey: keys[0],
    publicKey: keys[1]
  })).then((keys) => ({
    privateKey: keys[0],
    publicKey: keys[1]
  })), callback)
}

exports.getRandomValues = randomBytes

exports.hashAndSign = function (key, msg, callback) {
  nodeify(webcrypto.subtle.importKey(
    'jwk',
    key,
    {
      name: 'RSASSA-PKCS1-v1_5',
      hash: { name: 'SHA-256' }
    },
    false,
    ['sign']
  ).then((privateKey) => {
    return webcrypto.subtle.sign(
      { name: 'RSASSA-PKCS1-v1_5' },
      privateKey,
      Uint8Array.from(msg)
    )
  }).then((sig) => Buffer.from(sig)), callback)
}

exports.hashAndVerify = function (key, sig, msg, callback) {
  nodeify(webcrypto.subtle.importKey(
    'jwk',
    key,
    {
      name: 'RSASSA-PKCS1-v1_5',
      hash: { name: 'SHA-256' }
    },
    false,
    ['verify']
  ).then((publicKey) => {
    return webcrypto.subtle.verify(
      { name: 'RSASSA-PKCS1-v1_5' },
      publicKey,
      sig,
      msg
    )
  }), callback)
}

function exportKey (pair) {
  return Promise.all([
    webcrypto.subtle.exportKey('jwk', pair.privateKey),
    webcrypto.subtle.exportKey('jwk', pair.publicKey)
  ])
}

function derivePublicFromPrivate (jwKey) {
  return webcrypto.subtle.importKey(
    'jwk',
    {
      kty: jwKey.kty,
      n: jwKey.n,
      e: jwKey.e
    },
    {
      name: 'RSASSA-PKCS1-v1_5',
      hash: { name: 'SHA-256' }
    },
    true,
    ['verify']
  )
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/rsa-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/sha512.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./md":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/md.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/sha512.js
      return function (require, module, exports) {
/**
 * Secure Hash Algorithm with a 1024-bit block size implementation.
 *
 * This includes: SHA-512, SHA-384, SHA-512/224, and SHA-512/256. For
 * SHA-256 (block size 512 bits), see sha256.js.
 *
 * See FIPS 180-4 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2014-2015 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./md');
require('./util');

var sha512 = module.exports = forge.sha512 = forge.sha512 || {};

// SHA-512
forge.md.sha512 = forge.md.algorithms.sha512 = sha512;

// SHA-384
var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
sha384.create = function() {
  return sha512.create('SHA-384');
};
forge.md.sha384 = forge.md.algorithms.sha384 = sha384;

// SHA-512/256
forge.sha512.sha256 = forge.sha512.sha256 || {
  create: function() {
    return sha512.create('SHA-512/256');
  }
};
forge.md['sha512/256'] = forge.md.algorithms['sha512/256'] =
  forge.sha512.sha256;

// SHA-512/224
forge.sha512.sha224 = forge.sha512.sha224 || {
  create: function() {
    return sha512.create('SHA-512/224');
  }
};
forge.md['sha512/224'] = forge.md.algorithms['sha512/224'] =
  forge.sha512.sha224;

/**
 * Creates a SHA-2 message digest object.
 *
 * @param algorithm the algorithm to use (SHA-512, SHA-384, SHA-512/224,
 *          SHA-512/256).
 *
 * @return a message digest object.
 */
sha512.create = function(algorithm) {
  // do initialization as necessary
  if(!_initialized) {
    _init();
  }

  if(typeof algorithm === 'undefined') {
    algorithm = 'SHA-512';
  }

  if(!(algorithm in _states)) {
    throw new Error('Invalid SHA-512 algorithm: ' + algorithm);
  }

  // SHA-512 state contains eight 64-bit integers (each as two 32-bit ints)
  var _state = _states[algorithm];
  var _h = null;

  // input buffer
  var _input = forge.util.createBuffer();

  // used for 64-bit word storage
  var _w = new Array(80);
  for(var wi = 0; wi < 80; ++wi) {
    _w[wi] = new Array(2);
  }

  // determine digest length by algorithm name (default)
  var digestLength = 64;
  switch(algorithm) {
    case 'SHA-384':
      digestLength = 48;
      break;
    case 'SHA-512/256':
      digestLength = 32;
      break;
    case 'SHA-512/224':
      digestLength = 28;
      break;
  }

  // message digest object
  var md = {
    // SHA-512 => sha512
    algorithm: algorithm.replace('-', '').toLowerCase(),
    blockLength: 128,
    digestLength: digestLength,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 16
  };

  /**
   * Starts the digest.
   *
   * @return this digest object.
   */
  md.start = function() {
    // up to 56-bit message length for convenience
    md.messageLength = 0;

    // full message length (set md.messageLength128 for backwards-compatibility)
    md.fullMessageLength = md.messageLength128 = [];
    var int32s = md.messageLengthSize / 4;
    for(var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge.util.createBuffer();
    _h = new Array(_state.length);
    for(var i = 0; i < _state.length; ++i) {
      _h[i] = _state[i].slice(0);
    }
    return md;
  };
  // start digest automatically for first time
  md.start();

  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */
  md.update = function(msg, encoding) {
    if(encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    }

    // update message length
    var len = msg.length;
    md.messageLength += len;
    len = [(len / 0x100000000) >>> 0, len >>> 0];
    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = ((len[1] / 0x100000000) >>> 0);
    }

    // add bytes to input buffer
    _input.putBytes(msg);

    // process bytes
    _update(_h, _w, _input);

    // compact input buffer every 2K or if empty
    if(_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };

  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */
  md.digest = function() {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-512 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 896 mod 1024. In other words,
    the data to be digested must be a multiple of 1024 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 16 bytes (128
    bits), that means that the last segment of the data must have 112 bytes
    (896 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 896 mod 1024 because
    1024 - 128 = 896.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 896 mod 1024, then 1024 padding bits must be added. */

    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes());

    // compute remaining size to be digested (include message length size)
    var remaining = (
      md.fullMessageLength[md.fullMessageLength.length - 1] +
      md.messageLengthSize);

    // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), then
    // there may be up to (blockSize - 1) other pad bytes
    var overflow = remaining & (md.blockLength - 1);
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));

    // serialize message length in bits in big-endian order; since length
    // is stored in bytes we multiply by 8 and add carry from next int
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for(var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = (next / 0x100000000) >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);

    var h = new Array(_h.length);
    for(var i = 0; i < _h.length; ++i) {
      h[i] = _h[i].slice(0);
    }
    _update(h, _w, finalBlock);
    var rval = forge.util.createBuffer();
    var hlen;
    if(algorithm === 'SHA-512') {
      hlen = h.length;
    } else if(algorithm === 'SHA-384') {
      hlen = h.length - 2;
    } else {
      hlen = h.length - 4;
    }
    for(var i = 0; i < hlen; ++i) {
      rval.putInt32(h[i][0]);
      if(i !== hlen - 1 || algorithm !== 'SHA-512/224') {
        rval.putInt32(h[i][1]);
      }
    }
    return rval;
  };

  return md;
};

// sha-512 padding bytes not initialized yet
var _padding = null;
var _initialized = false;

// table of constants
var _k = null;

// initial hash states
var _states = null;

/**
 * Initializes the constant tables.
 */
function _init() {
  // create padding
  _padding = String.fromCharCode(128);
  _padding += forge.util.fillString(String.fromCharCode(0x00), 128);

  // create K table for SHA-512
  _k = [
    [0x428a2f98, 0xd728ae22], [0x71374491, 0x23ef65cd],
    [0xb5c0fbcf, 0xec4d3b2f], [0xe9b5dba5, 0x8189dbbc],
    [0x3956c25b, 0xf348b538], [0x59f111f1, 0xb605d019],
    [0x923f82a4, 0xaf194f9b], [0xab1c5ed5, 0xda6d8118],
    [0xd807aa98, 0xa3030242], [0x12835b01, 0x45706fbe],
    [0x243185be, 0x4ee4b28c], [0x550c7dc3, 0xd5ffb4e2],
    [0x72be5d74, 0xf27b896f], [0x80deb1fe, 0x3b1696b1],
    [0x9bdc06a7, 0x25c71235], [0xc19bf174, 0xcf692694],
    [0xe49b69c1, 0x9ef14ad2], [0xefbe4786, 0x384f25e3],
    [0x0fc19dc6, 0x8b8cd5b5], [0x240ca1cc, 0x77ac9c65],
    [0x2de92c6f, 0x592b0275], [0x4a7484aa, 0x6ea6e483],
    [0x5cb0a9dc, 0xbd41fbd4], [0x76f988da, 0x831153b5],
    [0x983e5152, 0xee66dfab], [0xa831c66d, 0x2db43210],
    [0xb00327c8, 0x98fb213f], [0xbf597fc7, 0xbeef0ee4],
    [0xc6e00bf3, 0x3da88fc2], [0xd5a79147, 0x930aa725],
    [0x06ca6351, 0xe003826f], [0x14292967, 0x0a0e6e70],
    [0x27b70a85, 0x46d22ffc], [0x2e1b2138, 0x5c26c926],
    [0x4d2c6dfc, 0x5ac42aed], [0x53380d13, 0x9d95b3df],
    [0x650a7354, 0x8baf63de], [0x766a0abb, 0x3c77b2a8],
    [0x81c2c92e, 0x47edaee6], [0x92722c85, 0x1482353b],
    [0xa2bfe8a1, 0x4cf10364], [0xa81a664b, 0xbc423001],
    [0xc24b8b70, 0xd0f89791], [0xc76c51a3, 0x0654be30],
    [0xd192e819, 0xd6ef5218], [0xd6990624, 0x5565a910],
    [0xf40e3585, 0x5771202a], [0x106aa070, 0x32bbd1b8],
    [0x19a4c116, 0xb8d2d0c8], [0x1e376c08, 0x5141ab53],
    [0x2748774c, 0xdf8eeb99], [0x34b0bcb5, 0xe19b48a8],
    [0x391c0cb3, 0xc5c95a63], [0x4ed8aa4a, 0xe3418acb],
    [0x5b9cca4f, 0x7763e373], [0x682e6ff3, 0xd6b2b8a3],
    [0x748f82ee, 0x5defb2fc], [0x78a5636f, 0x43172f60],
    [0x84c87814, 0xa1f0ab72], [0x8cc70208, 0x1a6439ec],
    [0x90befffa, 0x23631e28], [0xa4506ceb, 0xde82bde9],
    [0xbef9a3f7, 0xb2c67915], [0xc67178f2, 0xe372532b],
    [0xca273ece, 0xea26619c], [0xd186b8c7, 0x21c0c207],
    [0xeada7dd6, 0xcde0eb1e], [0xf57d4f7f, 0xee6ed178],
    [0x06f067aa, 0x72176fba], [0x0a637dc5, 0xa2c898a6],
    [0x113f9804, 0xbef90dae], [0x1b710b35, 0x131c471b],
    [0x28db77f5, 0x23047d84], [0x32caab7b, 0x40c72493],
    [0x3c9ebe0a, 0x15c9bebc], [0x431d67c4, 0x9c100d4c],
    [0x4cc5d4be, 0xcb3e42b6], [0x597f299c, 0xfc657e2a],
    [0x5fcb6fab, 0x3ad6faec], [0x6c44198c, 0x4a475817]
  ];

  // initial hash states
  _states = {};
  _states['SHA-512'] = [
    [0x6a09e667, 0xf3bcc908],
    [0xbb67ae85, 0x84caa73b],
    [0x3c6ef372, 0xfe94f82b],
    [0xa54ff53a, 0x5f1d36f1],
    [0x510e527f, 0xade682d1],
    [0x9b05688c, 0x2b3e6c1f],
    [0x1f83d9ab, 0xfb41bd6b],
    [0x5be0cd19, 0x137e2179]
  ];
  _states['SHA-384'] = [
    [0xcbbb9d5d, 0xc1059ed8],
    [0x629a292a, 0x367cd507],
    [0x9159015a, 0x3070dd17],
    [0x152fecd8, 0xf70e5939],
    [0x67332667, 0xffc00b31],
    [0x8eb44a87, 0x68581511],
    [0xdb0c2e0d, 0x64f98fa7],
    [0x47b5481d, 0xbefa4fa4]
  ];
  _states['SHA-512/256'] = [
    [0x22312194, 0xFC2BF72C],
    [0x9F555FA3, 0xC84C64C2],
    [0x2393B86B, 0x6F53B151],
    [0x96387719, 0x5940EABD],
    [0x96283EE2, 0xA88EFFE3],
    [0xBE5E1E25, 0x53863992],
    [0x2B0199FC, 0x2C85B8AA],
    [0x0EB72DDC, 0x81C52CA2]
  ];
  _states['SHA-512/224'] = [
    [0x8C3D37C8, 0x19544DA2],
    [0x73E19966, 0x89DCD4D6],
    [0x1DFAB7AE, 0x32FF9C82],
    [0x679DD514, 0x582F9FCF],
    [0x0F6D2B69, 0x7BD44DA8],
    [0x77E36F73, 0x04C48942],
    [0x3F9D85A8, 0x6A1D36C8],
    [0x1112E6AD, 0x91D692A1]
  ];

  // now initialized
  _initialized = true;
}

/**
 * Updates a SHA-512 state with the given byte buffer.
 *
 * @param s the SHA-512 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */
function _update(s, w, bytes) {
  // consume 512 bit (128 byte) chunks
  var t1_hi, t1_lo;
  var t2_hi, t2_lo;
  var s0_hi, s0_lo;
  var s1_hi, s1_lo;
  var ch_hi, ch_lo;
  var maj_hi, maj_lo;
  var a_hi, a_lo;
  var b_hi, b_lo;
  var c_hi, c_lo;
  var d_hi, d_lo;
  var e_hi, e_lo;
  var f_hi, f_lo;
  var g_hi, g_lo;
  var h_hi, h_lo;
  var i, hi, lo, w2, w7, w15, w16;
  var len = bytes.length();
  while(len >= 128) {
    // the w array will be populated with sixteen 64-bit big-endian words
    // and then extended into 64 64-bit words according to SHA-512
    for(i = 0; i < 16; ++i) {
      w[i][0] = bytes.getInt32() >>> 0;
      w[i][1] = bytes.getInt32() >>> 0;
    }
    for(; i < 80; ++i) {
      // for word 2 words ago: ROTR 19(x) ^ ROTR 61(x) ^ SHR 6(x)
      w2 = w[i - 2];
      hi = w2[0];
      lo = w2[1];

      // high bits
      t1_hi = (
        ((hi >>> 19) | (lo << 13)) ^ // ROTR 19
        ((lo >>> 29) | (hi << 3)) ^ // ROTR 61/(swap + ROTR 29)
        (hi >>> 6)) >>> 0; // SHR 6
      // low bits
      t1_lo = (
        ((hi << 13) | (lo >>> 19)) ^ // ROTR 19
        ((lo << 3) | (hi >>> 29)) ^ // ROTR 61/(swap + ROTR 29)
        ((hi << 26) | (lo >>> 6))) >>> 0; // SHR 6

      // for word 15 words ago: ROTR 1(x) ^ ROTR 8(x) ^ SHR 7(x)
      w15 = w[i - 15];
      hi = w15[0];
      lo = w15[1];

      // high bits
      t2_hi = (
        ((hi >>> 1) | (lo << 31)) ^ // ROTR 1
        ((hi >>> 8) | (lo << 24)) ^ // ROTR 8
        (hi >>> 7)) >>> 0; // SHR 7
      // low bits
      t2_lo = (
        ((hi << 31) | (lo >>> 1)) ^ // ROTR 1
        ((hi << 24) | (lo >>> 8)) ^ // ROTR 8
        ((hi << 25) | (lo >>> 7))) >>> 0; // SHR 7

      // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^64 (carry lo overflow)
      w7 = w[i - 7];
      w16 = w[i - 16];
      lo = (t1_lo + w7[1] + t2_lo + w16[1]);
      w[i][0] = (t1_hi + w7[0] + t2_hi + w16[0] +
        ((lo / 0x100000000) >>> 0)) >>> 0;
      w[i][1] = lo >>> 0;
    }

    // initialize hash value for this chunk
    a_hi = s[0][0];
    a_lo = s[0][1];
    b_hi = s[1][0];
    b_lo = s[1][1];
    c_hi = s[2][0];
    c_lo = s[2][1];
    d_hi = s[3][0];
    d_lo = s[3][1];
    e_hi = s[4][0];
    e_lo = s[4][1];
    f_hi = s[5][0];
    f_lo = s[5][1];
    g_hi = s[6][0];
    g_lo = s[6][1];
    h_hi = s[7][0];
    h_lo = s[7][1];

    // round function
    for(i = 0; i < 80; ++i) {
      // Sum1(e) = ROTR 14(e) ^ ROTR 18(e) ^ ROTR 41(e)
      s1_hi = (
        ((e_hi >>> 14) | (e_lo << 18)) ^ // ROTR 14
        ((e_hi >>> 18) | (e_lo << 14)) ^ // ROTR 18
        ((e_lo >>> 9) | (e_hi << 23))) >>> 0; // ROTR 41/(swap + ROTR 9)
      s1_lo = (
        ((e_hi << 18) | (e_lo >>> 14)) ^ // ROTR 14
        ((e_hi << 14) | (e_lo >>> 18)) ^ // ROTR 18
        ((e_lo << 23) | (e_hi >>> 9))) >>> 0; // ROTR 41/(swap + ROTR 9)

      // Ch(e, f, g) (optimized the same way as SHA-1)
      ch_hi = (g_hi ^ (e_hi & (f_hi ^ g_hi))) >>> 0;
      ch_lo = (g_lo ^ (e_lo & (f_lo ^ g_lo))) >>> 0;

      // Sum0(a) = ROTR 28(a) ^ ROTR 34(a) ^ ROTR 39(a)
      s0_hi = (
        ((a_hi >>> 28) | (a_lo << 4)) ^ // ROTR 28
        ((a_lo >>> 2) | (a_hi << 30)) ^ // ROTR 34/(swap + ROTR 2)
        ((a_lo >>> 7) | (a_hi << 25))) >>> 0; // ROTR 39/(swap + ROTR 7)
      s0_lo = (
        ((a_hi << 4) | (a_lo >>> 28)) ^ // ROTR 28
        ((a_lo << 30) | (a_hi >>> 2)) ^ // ROTR 34/(swap + ROTR 2)
        ((a_lo << 25) | (a_hi >>> 7))) >>> 0; // ROTR 39/(swap + ROTR 7)

      // Maj(a, b, c) (optimized the same way as SHA-1)
      maj_hi = ((a_hi & b_hi) | (c_hi & (a_hi ^ b_hi))) >>> 0;
      maj_lo = ((a_lo & b_lo) | (c_lo & (a_lo ^ b_lo))) >>> 0;

      // main algorithm
      // t1 = (h + s1 + ch + _k[i] + _w[i]) modulo 2^64 (carry lo overflow)
      lo = (h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1]);
      t1_hi = (h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] +
        ((lo / 0x100000000) >>> 0)) >>> 0;
      t1_lo = lo >>> 0;

      // t2 = s0 + maj modulo 2^64 (carry lo overflow)
      lo = s0_lo + maj_lo;
      t2_hi = (s0_hi + maj_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
      t2_lo = lo >>> 0;

      h_hi = g_hi;
      h_lo = g_lo;

      g_hi = f_hi;
      g_lo = f_lo;

      f_hi = e_hi;
      f_lo = e_lo;

      // e = (d + t1) modulo 2^64 (carry lo overflow)
      lo = d_lo + t1_lo;
      e_hi = (d_hi + t1_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
      e_lo = lo >>> 0;

      d_hi = c_hi;
      d_lo = c_lo;

      c_hi = b_hi;
      c_lo = b_lo;

      b_hi = a_hi;
      b_lo = a_lo;

      // a = (t1 + t2) modulo 2^64 (carry lo overflow)
      lo = t1_lo + t2_lo;
      a_hi = (t1_hi + t2_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
      a_lo = lo >>> 0;
    }

    // update hash state (additional modulo 2^64)
    lo = s[0][1] + a_lo;
    s[0][0] = (s[0][0] + a_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
    s[0][1] = lo >>> 0;

    lo = s[1][1] + b_lo;
    s[1][0] = (s[1][0] + b_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
    s[1][1] = lo >>> 0;

    lo = s[2][1] + c_lo;
    s[2][0] = (s[2][0] + c_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
    s[2][1] = lo >>> 0;

    lo = s[3][1] + d_lo;
    s[3][0] = (s[3][0] + d_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
    s[3][1] = lo >>> 0;

    lo = s[4][1] + e_lo;
    s[4][0] = (s[4][0] + e_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
    s[4][1] = lo >>> 0;

    lo = s[5][1] + f_lo;
    s[5][0] = (s[5][0] + f_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
    s[5][1] = lo >>> 0;

    lo = s[6][1] + g_lo;
    s[6][0] = (s[6][0] + g_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
    s[6][1] = lo >>> 0;

    lo = s[7][1] + h_lo;
    s[7][0] = (s[7][0] + h_hi + ((lo / 0x100000000) >>> 0)) >>> 0;
    s[7][1] = lo >>> 0;

    len -= 128;
  }
}

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/sha512.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/index.js", {"./parse":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/parse.js","./stringify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/stringify.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/index.js
      return function (require, module, exports) {
var parse = require('./parse')
var stringify = require('./stringify')

module.exports = parse
module.exports.parse = parse
module.exports.stringify = stringify

      };
    };
  }
}, {package:"protocol-buffers-schema",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/index.js", {"./decode":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/decode.js","./encode":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/encode.js","./encoding-length":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/encoding-length.js","./encodings":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/encodings.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/index.js
      return function (require, module, exports) {
'use strict'

var encodings = require('./encodings')
var compileDecode = require('./decode')
var compileEncode = require('./encode')
var compileEncodingLength = require('./encoding-length')
var varint = require('varint')

var flatten = function (values) {
  if (!values) return null
  var result = {}
  Object.keys(values).forEach(function (k) {
    result[k] = values[k].value
  })
  return result
}

module.exports = function (schema, extraEncodings) {
  var messages = {}
  var enums = {}
  var cache = {}

  var visit = function (schema, prefix) {
    if (schema.enums) {
      schema.enums.forEach(function (e) {
        e.id = prefix + (prefix ? '.' : '') + e.name
        enums[e.id] = e
        visit(e, e.id)
      })
    }
    if (schema.messages) {
      schema.messages.forEach(function (m) {
        m.id = prefix + (prefix ? '.' : '') + m.name
        messages[m.id] = m
        m.fields.forEach(function (f) {
          if (!f.map) return

          var name = 'Map_' + f.map.from + '_' + f.map.to
          var map = {
            name: name,
            enums: [],
            messages: [],
            fields: [{
              name: 'key',
              type: f.map.from,
              tag: 1,
              repeated: false,
              required: true
            }, {
              name: 'value',
              type: f.map.to,
              tag: 2,
              repeated: false,
              required: false
            }],
            extensions: null,
            id: prefix + (prefix ? '.' : '') + name
          }

          if (!messages[map.id]) {
            messages[map.id] = map
            schema.messages.push(map)
          }
          f.type = name
          f.repeated = true
        })
        visit(m, m.id)
      })
    }
  }

  visit(schema, '')

  var compileEnum = function (e) {
    var values = Object.keys(e.values || []).map(function (k) {
      return parseInt(e.values[k].value, 10)
    })

    var encode = function encode (val, buf, offset) {
      if (!values.length || values.indexOf(val) === -1) {
        throw new Error('Invalid enum value: ' + val)
      }
      varint.encode(val, buf, offset)
      encode.bytes = varint.encode.bytes
      return buf
    }

    var decode = function decode (buf, offset) {
      var val = varint.decode(buf, offset)
      if (!values.length || values.indexOf(val) === -1) {
        throw new Error('Invalid enum value: ' + val)
      }
      decode.bytes = varint.decode.bytes
      return val
    }

    return encodings.make(0, encode, decode, varint.encodingLength)
  }

  var compileMessage = function (m, exports) {
    m.messages.forEach(function (nested) {
      exports[nested.name] = resolve(nested.name, m.id)
    })

    m.enums.forEach(function (val) {
      exports[val.name] = flatten(val.values)
    })

    exports.type = 2
    exports.message = true
    exports.name = m.name

    var oneofs = {}

    m.fields.forEach(function (f) {
      if (!f.oneof) return
      if (!oneofs[f.oneof]) oneofs[f.oneof] = []
      oneofs[f.oneof].push(f.name)
    })

    var enc = m.fields.map(function (f) {
      return resolve(f.type, m.id)
    })

    var encodingLength = compileEncodingLength(m, enc, oneofs)
    var encode = compileEncode(m, resolve, enc, oneofs, encodingLength)
    var decode = compileDecode(m, resolve, enc)

    // end of compilation - return all the things

    encode.bytes = decode.bytes = 0

    exports.buffer = true
    exports.encode = encode
    exports.decode = decode
    exports.encodingLength = encodingLength

    return exports
  }

  var resolve = function (name, from, compile) {
    if (extraEncodings && extraEncodings[name]) return extraEncodings[name]
    if (encodings[name]) return encodings[name]

    var m = (from ? from + '.' + name : name).split('.')
      .map(function (part, i, list) {
        return list.slice(0, i).concat(name).join('.')
      })
      .reverse()
      .reduce(function (result, id) {
        return result || messages[id] || enums[id]
      }, null)

    if (compile === false) return m
    if (!m) throw new Error('Could not resolve ' + name)

    if (m.values) return compileEnum(m)
    var res = cache[m.id] || compileMessage(m, cache[m.id] = {})
    return res
  }

  return (schema.enums || []).concat((schema.messages || []).map(function (message) {
    return resolve(message.id)
  }))
}

      };
    };
  }
}, {package:"protons",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ecdh-browser.js", {"../nodeify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/nodeify.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/util.js","../webcrypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/webcrypto.js","asn1.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ecdh-browser.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const webcrypto = require('../webcrypto')
const nodeify = require('../nodeify')
const BN = require('asn1.js').bignum

const util = require('../util')
const toBase64 = util.toBase64
const toBn = util.toBn

const bits = {
  'P-256': 256,
  'P-384': 384,
  'P-521': 521
}

exports.generateEphmeralKeyPair = function (curve, callback) {
  nodeify(webcrypto.subtle.generateKey(
    {
      name: 'ECDH',
      namedCurve: curve
    },
    true,
    ['deriveBits']
  ).then((pair) => {
    // forcePrivate is used for testing only
    const genSharedKey = (theirPub, forcePrivate, cb) => {
      if (typeof forcePrivate === 'function') {
        cb = forcePrivate
        forcePrivate = undefined
      }

      let privateKey

      if (forcePrivate) {
        privateKey = webcrypto.subtle.importKey(
          'jwk',
          unmarshalPrivateKey(curve, forcePrivate),
          {
            name: 'ECDH',
            namedCurve: curve
          },
          false,
          ['deriveBits']
        )
      } else {
        privateKey = Promise.resolve(pair.privateKey)
      }

      const keys = Promise.all([
        webcrypto.subtle.importKey(
          'jwk',
          unmarshalPublicKey(curve, theirPub),
          {
            name: 'ECDH',
            namedCurve: curve
          },
          false,
          []
        ),
        privateKey
      ])

      nodeify(keys.then((keys) => webcrypto.subtle.deriveBits(
        {
          name: 'ECDH',
          namedCurve: curve,
          public: keys[0]
        },
        keys[1],
        bits[curve]
      )).then((bits) => Buffer.from(bits)), cb)
    }

    return webcrypto.subtle.exportKey('jwk', pair.publicKey)
      .then((publicKey) => {
        return {
          key: marshalPublicKey(publicKey),
          genSharedKey
        }
      })
  }), callback)
}

const curveLengths = {
  'P-256': 32,
  'P-384': 48,
  'P-521': 66
}

// Marshal converts a jwk encodec ECDH public key into the
// form specified in section 4.3.6 of ANSI X9.62. (This is the format
// go-ipfs uses)
function marshalPublicKey (jwk) {
  const byteLen = curveLengths[jwk.crv]

  return Buffer.concat([
    Buffer.from([4]), // uncompressed point
    toBn(jwk.x).toArrayLike(Buffer, 'be', byteLen),
    toBn(jwk.y).toArrayLike(Buffer, 'be', byteLen)
  ], 1 + byteLen * 2)
}

// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key
function unmarshalPublicKey (curve, key) {
  const byteLen = curveLengths[curve]

  if (!key.slice(0, 1).equals(Buffer.from([4]))) {
    throw new Error('Invalid key format')
  }
  const x = new BN(key.slice(1, byteLen + 1))
  const y = new BN(key.slice(1 + byteLen))

  return {
    kty: 'EC',
    crv: curve,
    x: toBase64(x, byteLen),
    y: toBase64(y, byteLen),
    ext: true
  }
}

function unmarshalPrivateKey (curve, key) {
  const result = unmarshalPublicKey(curve, key.public)
  result.d = toBase64(new BN(key.private))
  return result
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ecdh-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/index.js", {"./crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/crypto.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const multihash = require('multihashes')
const crypto = require('./crypto')

module.exports = Multihashing

/**
 * Hash the given `buf` using the algorithm specified
 * by `func`.
 *
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
function Multihashing (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  Multihashing.digest(buf, func, length, (err, digest) => {
    if (err) {
      return callback(err)
    }

    callback(null, multihash.encode(digest, func, length))
  })
}

/**
 * The `buffer` module for easy use in the browser.
 *
 * @type {Buffer}
 */
Multihashing.Buffer = Buffer // for browser things

/**
 * Expose multihash itself, to avoid silly double requires.
 */
Multihashing.multihash = multihash

/**
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
Multihashing.digest = function (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  let cb = callback
  if (length) {
    cb = (err, digest) => {
      if (err) {
        return callback(err)
      }

      callback(null, digest.slice(0, length))
    }
  }

  let hash
  try {
    hash = Multihashing.createHash(func)
  } catch (err) {
    return cb(err)
  }

  hash(buf, cb)
}

/**
 * @param {string|number} func
 *
 * @returns {function} - The to `func` corresponding hash function.
 */
Multihashing.createHash = function (func) {
  func = multihash.coerceCode(func)
  if (!Multihashing.functions[func]) {
    throw new Error('multihash function ' + func + ' not yet supported')
  }

  return Multihashing.functions[func]
}

/**
 * Mapping of multihash codes to their hashing functions.
 * @type {Object}
 */
Multihashing.functions = {
  // sha1
  0x11: crypto.sha1,
  // sha2-256
  0x12: crypto.sha2256,
  // sha2-512
  0x13: crypto.sha2512,
  // sha3-512
  0x14: crypto.sha3512,
  // sha3-384
  0x15: crypto.sha3384,
  // sha3-256
  0x16: crypto.sha3256,
  // sha3-224
  0x17: crypto.sha3224,
  // shake-128
  0x18: crypto.shake128,
  // shake-256
  0x19: crypto.shake256,
  // keccak-224
  0x1A: crypto.keccak224,
  // keccak-256
  0x1B: crypto.keccak256,
  // keccak-384
  0x1C: crypto.keccak384,
  // keccak-512
  0x1D: crypto.keccak512,
  // murmur3-128
  0x22: crypto.murmur3128,
  // murmur3-32
  0x23: crypto.murmur332,
  // dbl-sha2-256
  0x56: crypto.dblSha2256
}

// add blake functions
crypto.addBlake(Multihashing.functions)

Multihashing.validate = (data, hash, callback) => {
  let algo = multihash.decode(hash).name
  Multihashing(data, algo, (err, newHash) => {
    if (err) return callback(err)
    callback(err, Buffer.compare(hash, newHash) === 0)
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/src/crypto.js", {"async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/index.js","secp256k1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/js.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/src/crypto.js
      return function (require, module, exports) {
'use strict'

const secp256k1 = require('secp256k1')
const multihashing = require('multihashing-async')
const setImmediate = require('async/setImmediate')

const HASH_ALGORITHM = 'sha2-256'

module.exports = (randomBytes) => {
  const privateKeyLength = 32

  function generateKey (callback) {
    const done = (err, res) => setImmediate(() => callback(err, res))

    let privateKey
    do {
      privateKey = randomBytes(32)
    } while (!secp256k1.privateKeyVerify(privateKey))

    done(null, privateKey)
  }

  function hashAndSign (key, msg, callback) {
    const done = (err, res) => setImmediate(() => callback(err, res))

    multihashing.digest(msg, HASH_ALGORITHM, (err, digest) => {
      if (err) { return done(err) }

      try {
        const sig = secp256k1.sign(digest, key)
        const sigDER = secp256k1.signatureExport(sig.signature)
        return done(null, sigDER)
      } catch (err) { done(err) }
    })
  }

  function hashAndVerify (key, sig, msg, callback) {
    const done = (err, res) => setImmediate(() => callback(err, res))

    multihashing.digest(msg, HASH_ALGORITHM, (err, digest) => {
      if (err) { return done(err) }
      try {
        sig = secp256k1.signatureImport(sig)
        const valid = secp256k1.verify(digest, sig, key)
        return done(null, valid)
      } catch (err) { done(err) }
    })
  }

  function compressPublicKey (key) {
    if (!secp256k1.publicKeyVerify(key)) {
      throw new Error('Invalid public key')
    }
    return secp256k1.publicKeyConvert(key, true)
  }

  function decompressPublicKey (key) {
    return secp256k1.publicKeyConvert(key, false)
  }

  function validatePrivateKey (key) {
    if (!secp256k1.privateKeyVerify(key)) {
      throw new Error('Invalid private key')
    }
  }

  function validatePublicKey (key) {
    if (!secp256k1.publicKeyVerify(key)) {
      throw new Error('Invalid public key')
    }
  }

  function computePublicKey (privateKey) {
    validatePrivateKey(privateKey)
    return secp256k1.publicKeyCreate(privateKey)
  }

  return {
    generateKey: generateKey,
    privateKeyLength: privateKeyLength,
    hashAndSign: hashAndSign,
    hashAndVerify: hashAndVerify,
    compressPublicKey: compressPublicKey,
    decompressPublicKey: decompressPublicKey,
    validatePrivateKey: validatePrivateKey,
    validatePublicKey: validatePublicKey,
    computePublicKey: computePublicKey
  }
}

      };
    };
  }
}, {package:"libp2p-crypto-secp256k1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/src/crypto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-circular/index.js", {"./lib/node":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-circular/lib/node.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/is-circular/index.js
      return function (require, module, exports) {
var Node = require('./lib/node')

module.exports = isCircular

/**
 * checks whether the object is circular
 * @param  {object}  obj - object to check circularity for
 * @return {Boolean} true if obj is circular, false if it is not
 */
function isCircular (obj) {
  if (!(obj instanceof Object)) {
    throw new TypeError('"obj" must be an object (or inherit from it)')
  }
  return _isCircular(obj)
}

/**
 * @private
 * checks whether the object is circular
 * @param  {object}  obj - object to check circularity for
 * @param  {Node}    parentList - linked-list that contains all the object's parents
 * @return {Boolean} true if obj is circular, false if it is not
 */
function _isCircular (obj, parentList) {
  parentList = new Node(obj, parentList)

  // breadth-first search for circular object
  for (var key in obj) {
    var val = obj[key]
    if (val instanceof Object) {
      if (parentList.contains(val) || _isCircular(val, parentList)) {
        return true
      }
    }
  }

  return false
}

      };
    };
  }
}, {package:"is-circular",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-circular/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag.proto.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag.proto.js
      return function (require, module, exports) {
'use strict'

module.exports = `// An IPFS MerkleDAG Link
message PBLink {

  // multihash of the target object
  optional bytes Hash = 1;

  // utf string name. should be unique per object
  optional string Name = 2;

  // cumulative size of target object
  optional uint64 Tsize = 3;
}

// An IPFS MerkleDAG Node
message PBNode {

  // refs to other objects
  repeated PBLink Links = 2;

  // opaque user data
  optional bytes Data = 1;
}`

      };
    };
  }
}, {package:"ipld-dag-pb",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag.proto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/visibility.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/visibility.js
      return function (require, module, exports) {
'use strict'

/**
 * Make certain getters enumnerable
 *
 * This can be used to add additional getters that are enumerable and hence
 * show up on an `Object.keys()` call.
 *
 * @param {Object} object - The object it should be applied to
 * @param {Array.<String>} fields - The fields that should be made enumnerable
 */
const addEnumerableGetters = (object, fields) => {
  for (const field of fields) {
    let prop
    let proto = object
    // Walk up the proottype chain until a property with the given name is
    // found
    while (prop === undefined) {
      proto = Object.getPrototypeOf(proto)
      if (proto === null) {
        throw new Error(`no getter named '${field}' found`)
      }
      prop = Object.getOwnPropertyDescriptor(proto, field)
    }

    // There is a property with the correct name, but it's not a getter
    if (prop.get === undefined) {
      throw new Error(`no getter named '${field}' found`)
    }
    Object.defineProperty(object, field, {
      enumerable: true,
      get: prop.get
    })
  }
}

/**
 * Makes all properties with a leading underscore non-enumerable.
 *
 * @param {Object} object - The object it should be applied to
 */
const hidePrivateFields = (object) => {
  for (const key in object) {
    if (key[0] === '_') {
      Object.defineProperty(object, key, { enumerable: false })
    }
  }
}

module.exports = {
  addEnumerableGetters,
  hidePrivateFields
}

      };
    };
  }
}, {package:"ipld-dag-pb",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/visibility.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-link/util.js", {"./index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-link/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-link/util.js
      return function (require, module, exports) {
'use strict'

const DAGLink = require('./index')

function createDagLinkFromB58EncodedHash (link) {
  return new DAGLink(
    link.Name || link.name || '',
    link.Tsize || link.Size || link.size || 0,
    link.Hash || link.hash || link.multihash || link.cid
  )
}

exports = module.exports
exports.createDagLinkFromB58EncodedHash = createDagLinkFromB58EncodedHash

      };
    };
  }
}, {package:"ipld-dag-pb",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-link/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/addNamedLink.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/addNamedLink.js
      return function (require, module, exports) {
'use strict'

/**
 * Adds a link with its name as property to an object.
 *
 * The link won't be added if its name is empty or matches one of the existing
 * properties.
 *
 * @param {Object} object - The object that contains an array of links
 * @param {string} name - The name of the link to add
 * @param {numner} position - The position within the array of links
 */
const addNamedLink = (object, name, position) => {
  const skipNames = ['', ...Object.keys(object)]
  if (skipNames.includes(name)) {
    return
  }
  Object.defineProperty(object, name, {
    enumerable: true,
    configurable: true,
    get: () => object._links[position].Hash
  })
}

module.exports = addNamedLink

      };
    };
  }
}, {package:"ipld-dag-pb",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/addNamedLink.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/clone.js", {"./create":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/create.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/clone.js
      return function (require, module, exports) {
'use strict'

const dagNodeUtil = require('./util')
const cloneLinks = dagNodeUtil.cloneLinks
const cloneData = dagNodeUtil.cloneData
const create = require('./create')

function clone (dagNode) {
  const data = cloneData(dagNode)
  const links = cloneLinks(dagNode)
  return create(data, links)
}

module.exports = clone

      };
    };
  }
}, {package:"ipld-dag-pb",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/clone.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/addLink.js", {"../dag-link":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-link/index.js","./create":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/create.js","./index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/index.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/addLink.js
      return function (require, module, exports) {
'use strict'

const dagNodeUtil = require('./util')
const cloneLinks = dagNodeUtil.cloneLinks
const cloneData = dagNodeUtil.cloneData
const toDAGLink = dagNodeUtil.toDAGLink
const DAGLink = require('../dag-link')
const DAGNode = require('./index')
const create = require('./create')

const asDAGLink = async (link) => {
  if (DAGLink.isDAGLink(link)) {
    // It's a DAGLink instance
    // no need to do anything
    return link
  }

  if (DAGNode.isDAGNode(link)) {
    // It's a DAGNode instance
    // convert to link
    return toDAGLink(link, {})
  }

  // It's a Object with name, multihash/hash/cid and size
  return new DAGLink(link.Name || link.name, link.Tsize || link.size, link.Hash || link.multihash || link.hash || link.cid)
}

const addLink = async (node, link) => {
  const links = cloneLinks(node)
  const data = cloneData(node)

  const dagLink = await asDAGLink(link)
  links.push(dagLink)
  return create(data, links)
}

module.exports = addLink

      };
    };
  }
}, {package:"ipld-dag-pb",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/addLink.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/rmLink.js", {"../../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./create":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/create.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/util.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/rmLink.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const dagNodeUtil = require('./util')
const cloneLinks = dagNodeUtil.cloneLinks
const cloneData = dagNodeUtil.cloneData
const create = require('./create')
const CID = require('cids')

const rmLink = (dagNode, nameOrCid) => {
  const data = cloneData(dagNode)
  let links = cloneLinks(dagNode)

  if (typeof nameOrCid === 'string') {
    links = links.filter((link) => link.Name !== nameOrCid)
  } else if (Buffer.isBuffer(nameOrCid) || CID.isCID(nameOrCid)) {
    links = links.filter((link) => !link.Hash.equals(nameOrCid))
  } else {
    throw new Error('second arg needs to be a name or CID')
  }

  return create(data, links)
}

module.exports = rmLink

}).call(this)}).call(this,{"isBuffer":require("../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipld-dag-pb",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/rmLink.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/create.js", {"../dag-link":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-link/index.js","../util.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/util.js","./index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/index.js","./util.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/util.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","stable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stable/stable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/create.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const sort = require('stable')
const {
  serialize
} = require('../util.js')
const dagNodeUtil = require('./util.js')
const linkSort = dagNodeUtil.linkSort
const DAGNode = require('./index.js')
const DAGLink = require('../dag-link')

const create = (data, links = []) => {
  if (typeof data === 'string') {
    data = Buffer.from(data)
  }

  if (!Buffer.isBuffer(data)) {
    throw new Error('Passed \'data\' is not a buffer or a string!')
  }
  links = links.map((link) => {
    return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link)
  })
  links = sort(links, linkSort)

  const serialized = serialize({
    Data: data,
    Links: links
  })

  return new DAGNode(data, links, serialized.length)
}

module.exports = create

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipld-dag-pb",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/create.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/crypto.js", {"./blake":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/blake.js","./sha":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/sha.browser.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/utils.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha3/src/sha3.js","murmurhash3js-revisited":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js-revisited/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/crypto.js
      return function (require, module, exports) {
'use strict'

const { Buffer } = require('buffer')
const sha3 = require('js-sha3')
const mur = require('murmurhash3js-revisited')
const sha = require('./sha')
const { fromNumberTo32BitBuf } = require('./utils')

// Note that although this function doesn't do any asynchronous work, we mark
// the function as async because it must return a Promise to match the API
// for other functions that do perform asynchronous work (see sha.browser.js)
const hash = (algorithm) => async (data) => {
  switch (algorithm) {
    case 'sha3-224':
      return Buffer.from(sha3.sha3_224.arrayBuffer(data))
    case 'sha3-256':
      return Buffer.from(sha3.sha3_256.arrayBuffer(data))
    case 'sha3-384':
      return Buffer.from(sha3.sha3_384.arrayBuffer(data))
    case 'sha3-512':
      return Buffer.from(sha3.sha3_512.arrayBuffer(data))
    case 'shake-128':
      return Buffer.from(sha3.shake128.create(128).update(data).arrayBuffer())
    case 'shake-256':
      return Buffer.from(sha3.shake256.create(256).update(data).arrayBuffer())
    case 'keccak-224':
      return Buffer.from(sha3.keccak224.arrayBuffer(data))
    case 'keccak-256':
      return Buffer.from(sha3.keccak256.arrayBuffer(data))
    case 'keccak-384':
      return Buffer.from(sha3.keccak384.arrayBuffer(data))
    case 'keccak-512':
      return Buffer.from(sha3.keccak512.arrayBuffer(data))
    case 'murmur3-128':
      return Buffer.from(mur.x64.hash128(data), 'hex')
    case 'murmur3-32':
      return fromNumberTo32BitBuf(mur.x86.hash32(data))

    default:
      throw new TypeError(`${algorithm} is not a supported algorithm`)
  }
}

module.exports = {
  sha1: sha('sha1'),
  sha2256: sha('sha2-256'),
  sha2512: sha('sha2-512'),
  dblSha2256: sha('dbl-sha2-256'),
  sha3224: hash('sha3-224'),
  sha3256: hash('sha3-256'),
  sha3384: hash('sha3-384'),
  sha3512: hash('sha3-512'),
  shake128: hash('shake-128'),
  shake256: hash('shake-256'),
  keccak224: hash('keccak-224'),
  keccak256: hash('keccak-256'),
  keccak384: hash('keccak-384'),
  keccak512: hash('keccak-512'),
  murmur3128: hash('murmur3-128'),
  murmur332: hash('murmur3-32'),
  addBlake: require('./blake')
}

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/crypto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/hi-base32/src/base32.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/hi-base32/src/base32.js
      return function (require, module, exports) {
(function (process){(function (){
/*
 * [hi-base32]{@link https://github.com/emn178/hi-base32}
 *
 * @version 0.5.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var root = typeof window === 'object' ? window : {};
  var NODE_JS = !root.HI_BASE32_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  }
  var COMMON_JS = !root.HI_BASE32_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var BASE32_ENCODE_CHAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'.split('');
  var BASE32_DECODE_CHAR = {
    'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6, 'H': 7, 'I': 8,
    'J': 9, 'K': 10, 'L': 11, 'M': 12, 'N': 13, 'O': 14, 'P': 15, 'Q': 16,
    'R': 17, 'S': 18, 'T': 19, 'U': 20, 'V': 21, 'W': 22, 'X': 23, 'Y': 24,
    'Z': 25, '2': 26, '3': 27, '4': 28, '5': 29, '6': 30, '7': 31
  };

  var blocks = [0, 0, 0, 0, 0, 0, 0, 0];

  var throwInvalidUtf8 = function (position, partial) {
    if (partial.length > 10) {
      partial = '...' + partial.substr(-10);
    }
    var err = new Error('Decoded data is not valid UTF-8.'
      + ' Maybe try base32.decode.asBytes()?'
      + ' Partial data after reading ' + position + ' bytes: ' + partial + ' <-');
    err.position = position;
    throw err;
  };

  var toUtf8String = function (bytes) {
    var str = '', length = bytes.length, i = 0, followingChars = 0, b, c;
    while (i < length) {
      b = bytes[i++];
      if (b <= 0x7F) {
        str += String.fromCharCode(b);
        continue;
      } else if (b > 0xBF && b <= 0xDF) {
        c = b & 0x1F;
        followingChars = 1;
      } else if (b <= 0xEF) {
        c = b & 0x0F;
        followingChars = 2;
      } else if (b <= 0xF7) {
        c = b & 0x07;
        followingChars = 3;
      } else {
        throwInvalidUtf8(i, str);
      }

      for (var j = 0; j < followingChars; ++j) {
        b = bytes[i++];
        if (b < 0x80 || b > 0xBF) {
          throwInvalidUtf8(i, str);
        }
        c <<= 6;
        c += b & 0x3F;
      }
      if (c >= 0xD800 && c <= 0xDFFF) {
        throwInvalidUtf8(i, str);
      }
      if (c > 0x10FFFF) {
        throwInvalidUtf8(i, str);
      }

      if (c <= 0xFFFF) {
        str += String.fromCharCode(c);
      } else {
        c -= 0x10000;
        str += String.fromCharCode((c >> 10) + 0xD800);
        str += String.fromCharCode((c & 0x3FF) + 0xDC00);
      }
    }
    return str;
  };

  var decodeAsBytes = function (base32Str) {
    if (!/^[A-Z2-7=]+$/.test(base32Str)) {
      throw new Error('Invalid base32 characters');
    }
    base32Str = base32Str.replace(/=/g, '');
    var v1, v2, v3, v4, v5, v6, v7, v8, bytes = [], index = 0, length = base32Str.length;

    // 4 char to 3 bytes
    for (var i = 0, count = length >> 3 << 3; i < count;) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
      bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
      bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
      bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
      bytes[index++] = (v7 << 5 | v8) & 255;
    }

    // remain bytes
    var remain = length - count;
    if (remain === 2) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
    } else if (remain === 4) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
      bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
    } else if (remain === 5) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
      bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
      bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
    } else if (remain === 7) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
      bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
      bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
      bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
    }
    return bytes;
  };

  var encodeAscii = function (str) {
    var v1, v2, v3, v4, v5, base32Str = '', length = str.length;
    for (var i = 0, count = parseInt(length / 5) * 5; i < count;) {
      v1 = str.charCodeAt(i++);
      v2 = str.charCodeAt(i++);
      v3 = str.charCodeAt(i++);
      v4 = str.charCodeAt(i++);
      v5 = str.charCodeAt(i++);
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
        BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] +
        BASE32_ENCODE_CHAR[(v4 >>> 2) & 31] +
        BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] +
        BASE32_ENCODE_CHAR[v5 & 31];
    }

    // remain char
    var remain = length - count;
    if (remain === 1) {
      v1 = str.charCodeAt(i);
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2) & 31] +
        '======';
    } else if (remain === 2) {
      v1 = str.charCodeAt(i++);
      v2 = str.charCodeAt(i);
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4) & 31] +
        '====';
    } else if (remain === 3) {
      v1 = str.charCodeAt(i++);
      v2 = str.charCodeAt(i++);
      v3 = str.charCodeAt(i);
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
        BASE32_ENCODE_CHAR[(v3 << 1) & 31] +
        '===';
    } else if (remain === 4) {
      v1 = str.charCodeAt(i++);
      v2 = str.charCodeAt(i++);
      v3 = str.charCodeAt(i++);
      v4 = str.charCodeAt(i);
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
        BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] +
        BASE32_ENCODE_CHAR[(v4 >>> 2) & 31] +
        BASE32_ENCODE_CHAR[(v4 << 3) & 31] +
        '=';
    }
    return base32Str;
  };

  var encodeUtf8 = function (str) {
    var v1, v2, v3, v4, v5, code, end = false, base32Str = '',
      index = 0, i, start = 0, bytes = 0, length = str.length;
    do {
      blocks[0] = blocks[5];
      blocks[1] = blocks[6];
      blocks[2] = blocks[7];
      for (i = start; index < length && i < 5; ++index) {
        code = str.charCodeAt(index);
        if (code < 0x80) {
          blocks[i++] = code;
        } else if (code < 0x800) {
          blocks[i++] = 0xc0 | (code >> 6);
          blocks[i++] = 0x80 | (code & 0x3f);
        } else if (code < 0xd800 || code >= 0xe000) {
          blocks[i++] = 0xe0 | (code >> 12);
          blocks[i++] = 0x80 | ((code >> 6) & 0x3f);
          blocks[i++] = 0x80 | (code & 0x3f);
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++index) & 0x3ff));
          blocks[i++] = 0xf0 | (code >> 18);
          blocks[i++] = 0x80 | ((code >> 12) & 0x3f);
          blocks[i++] = 0x80 | ((code >> 6) & 0x3f);
          blocks[i++] = 0x80 | (code & 0x3f);
        }
      }
      bytes += i - start;
      start = i - 5;
      if (index === length) {
        ++index;
      }
      if (index > length && i < 6) {
        end = true;
      }
      v1 = blocks[0];
      if (i > 4) {
        v2 = blocks[1];
        v3 = blocks[2];
        v4 = blocks[3];
        v5 = blocks[4];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
          BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
          BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
          BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
          BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] +
          BASE32_ENCODE_CHAR[(v4 >>> 2) & 31] +
          BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] +
          BASE32_ENCODE_CHAR[v5 & 31];
      } else if (i === 1) {
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
          BASE32_ENCODE_CHAR[(v1 << 2) & 31] +
          '======';
      } else if (i === 2) {
        v2 = blocks[1];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
          BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
          BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
          BASE32_ENCODE_CHAR[(v2 << 4) & 31] +
          '====';
      } else if (i === 3) {
        v2 = blocks[1];
        v3 = blocks[2];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
          BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
          BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
          BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
          BASE32_ENCODE_CHAR[(v3 << 1) & 31] +
          '===';
      } else {
        v2 = blocks[1];
        v3 = blocks[2];
        v4 = blocks[3];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
          BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
          BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
          BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
          BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] +
          BASE32_ENCODE_CHAR[(v4 >>> 2) & 31] +
          BASE32_ENCODE_CHAR[(v4 << 3) & 31] +
          '=';
      }
    } while (!end);
    return base32Str;
  };

  var encodeBytes = function (bytes) {
    var v1, v2, v3, v4, v5, base32Str = '', length = bytes.length;
    for (var i = 0, count = parseInt(length / 5) * 5; i < count;) {
      v1 = bytes[i++];
      v2 = bytes[i++];
      v3 = bytes[i++];
      v4 = bytes[i++];
      v5 = bytes[i++];
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
        BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] +
        BASE32_ENCODE_CHAR[(v4 >>> 2) & 31] +
        BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] +
        BASE32_ENCODE_CHAR[v5 & 31];
    }

    // remain char
    var remain = length - count;
    if (remain === 1) {
      v1 = bytes[i];
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2) & 31] +
        '======';
    } else if (remain === 2) {
      v1 = bytes[i++];
      v2 = bytes[i];
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4) & 31] +
        '====';
    } else if (remain === 3) {
      v1 = bytes[i++];
      v2 = bytes[i++];
      v3 = bytes[i];
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
        BASE32_ENCODE_CHAR[(v3 << 1) & 31] +
        '===';
    } else if (remain === 4) {
      v1 = bytes[i++];
      v2 = bytes[i++];
      v3 = bytes[i++];
      v4 = bytes[i];
      base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] +
        BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] +
        BASE32_ENCODE_CHAR[(v2 >>> 1) & 31] +
        BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] +
        BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] +
        BASE32_ENCODE_CHAR[(v4 >>> 2) & 31] +
        BASE32_ENCODE_CHAR[(v4 << 3) & 31] +
        '=';
    }
    return base32Str;
  };

  var encode = function (input, asciiOnly) {
    var notString = typeof(input) !== 'string';
    if (notString && input.constructor === ArrayBuffer) {
      input = new Uint8Array(input);
    }
    if (notString) {
      return encodeBytes(input);
    } else if (asciiOnly) {
      return encodeAscii(input);
    } else {
      return encodeUtf8(input);
    }
  };

  var decode = function (base32Str, asciiOnly) {
    if (!asciiOnly) {
      return toUtf8String(decodeAsBytes(base32Str));
    }
    if (!/^[A-Z2-7=]+$/.test(base32Str)) {
      throw new Error('Invalid base32 characters');
    }
    var v1, v2, v3, v4, v5, v6, v7, v8, str = '', length = base32Str.indexOf('=');
    if (length === -1) {
      length = base32Str.length;
    }

    // 8 char to 5 bytes
    for (var i = 0, count = length >> 3 << 3; i < count;) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) +
        String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) +
        String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) +
        String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255) +
        String.fromCharCode((v7 << 5 | v8) & 255);
    }

    // remain bytes
    var remain = length - count;
    if (remain === 2) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255);
    } else if (remain === 4) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) +
        String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255);
    } else if (remain === 5) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) +
        String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) +
        String.fromCharCode((v4 << 4 | v5 >>> 1) & 255);
    } else if (remain === 7) {
      v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
      str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) +
        String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) +
        String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) +
        String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255);
    }
    return str;
  };

  var exports = {
    encode: encode,
    decode: decode
  };
  decode.asBytes = decodeAsBytes;

  if (COMMON_JS) {
    module.exports = exports;
  } else {
    root.base32 = exports;
    if (AMD) {
      define(function() {
        return exports;
      });
    }
  }
})();

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"hi-base32",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/hi-base32/src/base32.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ip/lib/ip.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","os":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/os-browserify/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ip/lib/ip.js
      return function (require, module, exports) {
'use strict';

var ip = exports;
var Buffer = require('buffer').Buffer;
var os = require('os');

ip.toBuffer = function(ip, buff, offset) {
  offset = ~~offset;

  var result;

  if (this.isV4Format(ip)) {
    result = buff || new Buffer(offset + 4);
    ip.split(/\./g).map(function(byte) {
      result[offset++] = parseInt(byte, 10) & 0xff;
    });
  } else if (this.isV6Format(ip)) {
    var sections = ip.split(':', 8);

    var i;
    for (i = 0; i < sections.length; i++) {
      var isv4 = this.isV4Format(sections[i]);
      var v4Buffer;

      if (isv4) {
        v4Buffer = this.toBuffer(sections[i]);
        sections[i] = v4Buffer.slice(0, 2).toString('hex');
      }

      if (v4Buffer && ++i < 8) {
        sections.splice(i, 0, v4Buffer.slice(2, 4).toString('hex'));
      }
    }

    if (sections[0] === '') {
      while (sections.length < 8) sections.unshift('0');
    } else if (sections[sections.length - 1] === '') {
      while (sections.length < 8) sections.push('0');
    } else if (sections.length < 8) {
      for (i = 0; i < sections.length && sections[i] !== ''; i++);
      var argv = [ i, 1 ];
      for (i = 9 - sections.length; i > 0; i--) {
        argv.push('0');
      }
      sections.splice.apply(sections, argv);
    }

    result = buff || new Buffer(offset + 16);
    for (i = 0; i < sections.length; i++) {
      var word = parseInt(sections[i], 16);
      result[offset++] = (word >> 8) & 0xff;
      result[offset++] = word & 0xff;
    }
  }

  if (!result) {
    throw Error('Invalid ip address: ' + ip);
  }

  return result;
};

ip.toString = function(buff, offset, length) {
  offset = ~~offset;
  length = length || (buff.length - offset);

  var result = [];
  if (length === 4) {
    // IPv4
    for (var i = 0; i < length; i++) {
      result.push(buff[offset + i]);
    }
    result = result.join('.');
  } else if (length === 16) {
    // IPv6
    for (var i = 0; i < length; i += 2) {
      result.push(buff.readUInt16BE(offset + i).toString(16));
    }
    result = result.join(':');
    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');
    result = result.replace(/:{3,4}/, '::');
  }

  return result;
};

var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;
var ipv6Regex =
    /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;

ip.isV4Format = function(ip) {
  return ipv4Regex.test(ip);
};

ip.isV6Format = function(ip) {
  return ipv6Regex.test(ip);
};
function _normalizeFamily(family) {
  return family ? family.toLowerCase() : 'ipv4';
}

ip.fromPrefixLen = function(prefixlen, family) {
  if (prefixlen > 32) {
    family = 'ipv6';
  } else {
    family = _normalizeFamily(family);
  }

  var len = 4;
  if (family === 'ipv6') {
    len = 16;
  }
  var buff = new Buffer(len);

  for (var i = 0, n = buff.length; i < n; ++i) {
    var bits = 8;
    if (prefixlen < 8) {
      bits = prefixlen;
    }
    prefixlen -= bits;

    buff[i] = ~(0xff >> bits) & 0xff;
  }

  return ip.toString(buff);
};

ip.mask = function(addr, mask) {
  addr = ip.toBuffer(addr);
  mask = ip.toBuffer(mask);

  var result = new Buffer(Math.max(addr.length, mask.length));

  var i = 0;
  // Same protocol - do bitwise and
  if (addr.length === mask.length) {
    for (i = 0; i < addr.length; i++) {
      result[i] = addr[i] & mask[i];
    }
  } else if (mask.length === 4) {
    // IPv6 address and IPv4 mask
    // (Mask low bits)
    for (i = 0; i < mask.length; i++) {
      result[i] = addr[addr.length - 4  + i] & mask[i];
    }
  } else {
    // IPv6 mask and IPv4 addr
    for (var i = 0; i < result.length - 6; i++) {
      result[i] = 0;
    }

    // ::ffff:ipv4
    result[10] = 0xff;
    result[11] = 0xff;
    for (i = 0; i < addr.length; i++) {
      result[i + 12] = addr[i] & mask[i + 12];
    }
    i = i + 12;
  }
  for (; i < result.length; i++)
    result[i] = 0;

  return ip.toString(result);
};

ip.cidr = function(cidrString) {
  var cidrParts = cidrString.split('/');

  var addr = cidrParts[0];
  if (cidrParts.length !== 2)
    throw new Error('invalid CIDR subnet: ' + addr);

  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

  return ip.mask(addr, mask);
};

ip.subnet = function(addr, mask) {
  var networkAddress = ip.toLong(ip.mask(addr, mask));

  // Calculate the mask's length.
  var maskBuffer = ip.toBuffer(mask);
  var maskLength = 0;

  for (var i = 0; i < maskBuffer.length; i++) {
    if (maskBuffer[i] === 0xff) {
      maskLength += 8;
    } else {
      var octet = maskBuffer[i] & 0xff;
      while (octet) {
        octet = (octet << 1) & 0xff;
        maskLength++;
      }
    }
  }

  var numberOfAddresses = Math.pow(2, 32 - maskLength);

  return {
    networkAddress: ip.fromLong(networkAddress),
    firstAddress: numberOfAddresses <= 2 ?
                    ip.fromLong(networkAddress) :
                    ip.fromLong(networkAddress + 1),
    lastAddress: numberOfAddresses <= 2 ?
                    ip.fromLong(networkAddress + numberOfAddresses - 1) :
                    ip.fromLong(networkAddress + numberOfAddresses - 2),
    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
    subnetMask: mask,
    subnetMaskLength: maskLength,
    numHosts: numberOfAddresses <= 2 ?
                numberOfAddresses : numberOfAddresses - 2,
    length: numberOfAddresses,
    contains: function(other) {
      return networkAddress === ip.toLong(ip.mask(other, mask));
    }
  };
};

ip.cidrSubnet = function(cidrString) {
  var cidrParts = cidrString.split('/');

  var addr = cidrParts[0];
  if (cidrParts.length !== 2)
    throw new Error('invalid CIDR subnet: ' + addr);

  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

  return ip.subnet(addr, mask);
};

ip.not = function(addr) {
  var buff = ip.toBuffer(addr);
  for (var i = 0; i < buff.length; i++) {
    buff[i] = 0xff ^ buff[i];
  }
  return ip.toString(buff);
};

ip.or = function(a, b) {
  a = ip.toBuffer(a);
  b = ip.toBuffer(b);

  // same protocol
  if (a.length === b.length) {
    for (var i = 0; i < a.length; ++i) {
      a[i] |= b[i];
    }
    return ip.toString(a);

  // mixed protocols
  } else {
    var buff = a;
    var other = b;
    if (b.length > a.length) {
      buff = b;
      other = a;
    }

    var offset = buff.length - other.length;
    for (var i = offset; i < buff.length; ++i) {
      buff[i] |= other[i - offset];
    }

    return ip.toString(buff);
  }
};

ip.isEqual = function(a, b) {
  a = ip.toBuffer(a);
  b = ip.toBuffer(b);

  // Same protocol
  if (a.length === b.length) {
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }

  // Swap
  if (b.length === 4) {
    var t = b;
    b = a;
    a = t;
  }

  // a - IPv4, b - IPv6
  for (var i = 0; i < 10; i++) {
    if (b[i] !== 0) return false;
  }

  var word = b.readUInt16BE(10);
  if (word !== 0 && word !== 0xffff) return false;

  for (var i = 0; i < 4; i++) {
    if (a[i] !== b[i + 12]) return false;
  }

  return true;
};

ip.isPrivate = function(addr) {
  return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i
      .test(addr) ||
    /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i
      .test(addr) ||
    /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^f[cd][0-9a-f]{2}:/i.test(addr) ||
    /^fe80:/i.test(addr) ||
    /^::1$/.test(addr) ||
    /^::$/.test(addr);
};

ip.isPublic = function(addr) {
  return !ip.isPrivate(addr);
};

ip.isLoopback = function(addr) {
  return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/
      .test(addr) ||
    /^fe80::1$/.test(addr) ||
    /^::1$/.test(addr) ||
    /^::$/.test(addr);
};

ip.loopback = function(family) {
  //
  // Default to `ipv4`
  //
  family = _normalizeFamily(family);

  if (family !== 'ipv4' && family !== 'ipv6') {
    throw new Error('family must be ipv4 or ipv6');
  }

  return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';
};

//
// ### function address (name, family)
// #### @name {string|'public'|'private'} **Optional** Name or security
//      of the network interface.
// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults
//      to ipv4).
//
// Returns the address for the network interface on the current system with
// the specified `name`:
//   * String: First `family` address of the interface.
//             If not found see `undefined`.
//   * 'public': the first public ip address of family.
//   * 'private': the first private ip address of family.
//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.
//
ip.address = function(name, family) {
  var interfaces = os.networkInterfaces();
  var all;

  //
  // Default to `ipv4`
  //
  family = _normalizeFamily(family);

  //
  // If a specific network interface has been named,
  // return the address.
  //
  if (name && name !== 'private' && name !== 'public') {
    var res = interfaces[name].filter(function(details) {
      var itemFamily = details.family.toLowerCase();
      return itemFamily === family;
    });
    if (res.length === 0)
      return undefined;
    return res[0].address;
  }

  var all = Object.keys(interfaces).map(function (nic) {
    //
    // Note: name will only be `public` or `private`
    // when this is called.
    //
    var addresses = interfaces[nic].filter(function (details) {
      details.family = details.family.toLowerCase();
      if (details.family !== family || ip.isLoopback(details.address)) {
        return false;
      } else if (!name) {
        return true;
      }

      return name === 'public' ? ip.isPrivate(details.address) :
          ip.isPublic(details.address);
    });

    return addresses.length ? addresses[0].address : undefined;
  }).filter(Boolean);

  return !all.length ? ip.loopback(family) : all[0];
};

ip.toLong = function(ip) {
  var ipl = 0;
  ip.split('.').forEach(function(octet) {
    ipl <<= 8;
    ipl += parseInt(octet);
  });
  return(ipl >>> 0);
};

ip.fromLong = function(ipl) {
  return ((ipl >>> 24) + '.' +
      (ipl >> 16 & 255) + '.' +
      (ipl >> 8 & 255) + '.' +
      (ipl & 255) );
};

      };
    };
  }
}, {package:"ip",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ip/lib/ip.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-ip/index.js", {"ip-regex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ip-regex/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/is-ip/index.js
      return function (require, module, exports) {
'use strict';
const ipRegex = require('ip-regex');

const isIp = module.exports = x => ipRegex({exact: true}).test(x);
isIp.v4 = x => ipRegex.v4({exact: true}).test(x);
isIp.v6 = x => ipRegex.v6({exact: true}).test(x);

      };
    };
  }
}, {package:"is-ip",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-ip/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js/lib/murmurHash3js.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js/lib/murmurHash3js.js
      return function (require, module, exports) {
/* jshint -W086: true */
// +----------------------------------------------------------------------+
// | murmurHash3js.js v3.0.1 // https://github.com/pid/murmurHash3js
// | A javascript implementation of MurmurHash3's x86 hashing algorithms. |
// |----------------------------------------------------------------------|
// | Copyright (c) 2012-2015 Karan Lyons                                       |
// | https://github.com/karanlyons/murmurHash3.js/blob/c1778f75792abef7bdd74bc85d2d4e1a3d25cfe9/murmurHash3.js |
// | Freely distributable under the MIT license.                          |
// +----------------------------------------------------------------------+

;(function (root, undefined) {
    'use strict';

    // Create a local object that'll be exported or referenced globally.
    var library = {
        'version': '3.0.1',
        'x86': {},
        'x64': {}
    };

    // PRIVATE FUNCTIONS
    // -----------------

    function _x86Multiply(m, n) {
        //
        // Given two 32bit ints, returns the two multiplied together as a
        // 32bit int.
        //

        return ((m & 0xffff) * n) + ((((m >>> 16) * n) & 0xffff) << 16);
    }

    function _x86Rotl(m, n) {
        //
        // Given a 32bit int and an int representing a number of bit positions,
        // returns the 32bit int rotated left by that number of positions.
        //

        return (m << n) | (m >>> (32 - n));
    }

    function _x86Fmix(h) {
        //
        // Given a block, returns murmurHash3's final x86 mix of that block.
        //

        h ^= h >>> 16;
        h = _x86Multiply(h, 0x85ebca6b);
        h ^= h >>> 13;
        h = _x86Multiply(h, 0xc2b2ae35);
        h ^= h >>> 16;

        return h;
    }

    function _x64Add(m, n) {
        //
        // Given two 64bit ints (as an array of two 32bit ints) returns the two
        // added together as a 64bit int (as an array of two 32bit ints).
        //

        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];
        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];
        var o = [0, 0, 0, 0];

        o[3] += m[3] + n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 0xffff;

        o[2] += m[2] + n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 0xffff;

        o[1] += m[1] + n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;

        o[0] += m[0] + n[0];
        o[0] &= 0xffff;

        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];
    }

    function _x64Multiply(m, n) {
        //
        // Given two 64bit ints (as an array of two 32bit ints) returns the two
        // multiplied together as a 64bit int (as an array of two 32bit ints).
        //

        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];
        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];
        var o = [0, 0, 0, 0];

        o[3] += m[3] * n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 0xffff;

        o[2] += m[2] * n[3];
        o[1] += o[2] >>> 16;
        o[2] &= 0xffff;

        o[2] += m[3] * n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 0xffff;

        o[1] += m[1] * n[3];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;

        o[1] += m[2] * n[2];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;

        o[1] += m[3] * n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;

        o[0] += (m[0] * n[3]) + (m[1] * n[2]) + (m[2] * n[1]) + (m[3] * n[0]);
        o[0] &= 0xffff;

        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];
    }

    function _x64Rotl(m, n) {
        //
        // Given a 64bit int (as an array of two 32bit ints) and an int
        // representing a number of bit positions, returns the 64bit int (as an
        // array of two 32bit ints) rotated left by that number of positions.
        //

        n %= 64;

        if (n === 32) {
            return [m[1], m[0]];
        } else if (n < 32) {
            return [(m[0] << n) | (m[1] >>> (32 - n)), (m[1] << n) | (m[0] >>> (32 - n))];
        } else {
            n -= 32;
            return [(m[1] << n) | (m[0] >>> (32 - n)), (m[0] << n) | (m[1] >>> (32 - n))];
        }
    }

    function _x64LeftShift(m, n) {
        //
        // Given a 64bit int (as an array of two 32bit ints) and an int
        // representing a number of bit positions, returns the 64bit int (as an
        // array of two 32bit ints) shifted left by that number of positions.
        //

        n %= 64;

        if (n === 0) {
            return m;
        } else if (n < 32) {
            return [(m[0] << n) | (m[1] >>> (32 - n)), m[1] << n];
        } else {
            return [m[1] << (n - 32), 0];
        }
    }

    function _x64Xor(m, n) {
        //
        // Given two 64bit ints (as an array of two 32bit ints) returns the two
        // xored together as a 64bit int (as an array of two 32bit ints).
        //

        return [m[0] ^ n[0], m[1] ^ n[1]];
    }

    function _x64Fmix(h) {
        //
        // Given a block, returns murmurHash3's final x64 mix of that block.
        // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the
        // only place where we need to right shift 64bit ints.)
        //

        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [0xff51afd7, 0xed558ccd]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [0xc4ceb9fe, 0x1a85ec53]);
        h = _x64Xor(h, [0, h[0] >>> 1]);

        return h;
    }

    // PUBLIC FUNCTIONS
    // ----------------

    library.x86.hash32 = function (key, seed) {
        //
        // Given a string and an optional seed as an int, returns a 32 bit hash
        // using the x86 flavor of MurmurHash3, as an unsigned int.
        //

        key = key || '';
        seed = seed || 0;

        var remainder = key.length % 4;
        var bytes = key.length - remainder;

        var h1 = seed;

        var k1 = 0;

        var c1 = 0xcc9e2d51;
        var c2 = 0x1b873593;

        for (var i = 0; i < bytes; i = i + 4) {
            k1 = ((key.charCodeAt(i) & 0xff)) | ((key.charCodeAt(i + 1) & 0xff) << 8) | ((key.charCodeAt(i + 2) & 0xff) << 16) | ((key.charCodeAt(i + 3) & 0xff) << 24);

            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);

            h1 ^= k1;
            h1 = _x86Rotl(h1, 13);
            h1 = _x86Multiply(h1, 5) + 0xe6546b64;
        }

        k1 = 0;

        switch (remainder) {
            case 3:
                k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;

            case 2:
                k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;

            case 1:
                k1 ^= (key.charCodeAt(i) & 0xff);
                k1 = _x86Multiply(k1, c1);
                k1 = _x86Rotl(k1, 15);
                k1 = _x86Multiply(k1, c2);
                h1 ^= k1;
        }

        h1 ^= key.length;
        h1 = _x86Fmix(h1);

        return h1 >>> 0;
    };

    library.x86.hash128 = function (key, seed) {
        //
        // Given a string and an optional seed as an int, returns a 128 bit
        // hash using the x86 flavor of MurmurHash3, as an unsigned hex.
        //

        key = key || '';
        seed = seed || 0;

        var remainder = key.length % 16;
        var bytes = key.length - remainder;

        var h1 = seed;
        var h2 = seed;
        var h3 = seed;
        var h4 = seed;

        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;

        var c1 = 0x239b961b;
        var c2 = 0xab0e9789;
        var c3 = 0x38b34ae5;
        var c4 = 0xa1e38b93;

        for (var i = 0; i < bytes; i = i + 16) {
            k1 = ((key.charCodeAt(i) & 0xff)) | ((key.charCodeAt(i + 1) & 0xff) << 8) | ((key.charCodeAt(i + 2) & 0xff) << 16) | ((key.charCodeAt(i + 3) & 0xff) << 24);
            k2 = ((key.charCodeAt(i + 4) & 0xff)) | ((key.charCodeAt(i + 5) & 0xff) << 8) | ((key.charCodeAt(i + 6) & 0xff) << 16) | ((key.charCodeAt(i + 7) & 0xff) << 24);
            k3 = ((key.charCodeAt(i + 8) & 0xff)) | ((key.charCodeAt(i + 9) & 0xff) << 8) | ((key.charCodeAt(i + 10) & 0xff) << 16) | ((key.charCodeAt(i + 11) & 0xff) << 24);
            k4 = ((key.charCodeAt(i + 12) & 0xff)) | ((key.charCodeAt(i + 13) & 0xff) << 8) | ((key.charCodeAt(i + 14) & 0xff) << 16) | ((key.charCodeAt(i + 15) & 0xff) << 24);

            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;

            h1 = _x86Rotl(h1, 19);
            h1 += h2;
            h1 = _x86Multiply(h1, 5) + 0x561ccd1b;

            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;

            h2 = _x86Rotl(h2, 17);
            h2 += h3;
            h2 = _x86Multiply(h2, 5) + 0x0bcaa747;

            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;

            h3 = _x86Rotl(h3, 15);
            h3 += h4;
            h3 = _x86Multiply(h3, 5) + 0x96cd1c35;

            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;

            h4 = _x86Rotl(h4, 13);
            h4 += h1;
            h4 = _x86Multiply(h4, 5) + 0x32ac3b17;
        }

        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;

        switch (remainder) {
            case 15:
                k4 ^= key.charCodeAt(i + 14) << 16;

            case 14:
                k4 ^= key.charCodeAt(i + 13) << 8;

            case 13:
                k4 ^= key.charCodeAt(i + 12);
                k4 = _x86Multiply(k4, c4);
                k4 = _x86Rotl(k4, 18);
                k4 = _x86Multiply(k4, c1);
                h4 ^= k4;

            case 12:
                k3 ^= key.charCodeAt(i + 11) << 24;

            case 11:
                k3 ^= key.charCodeAt(i + 10) << 16;

            case 10:
                k3 ^= key.charCodeAt(i + 9) << 8;

            case 9:
                k3 ^= key.charCodeAt(i + 8);
                k3 = _x86Multiply(k3, c3);
                k3 = _x86Rotl(k3, 17);
                k3 = _x86Multiply(k3, c4);
                h3 ^= k3;

            case 8:
                k2 ^= key.charCodeAt(i + 7) << 24;

            case 7:
                k2 ^= key.charCodeAt(i + 6) << 16;

            case 6:
                k2 ^= key.charCodeAt(i + 5) << 8;

            case 5:
                k2 ^= key.charCodeAt(i + 4);
                k2 = _x86Multiply(k2, c2);
                k2 = _x86Rotl(k2, 16);
                k2 = _x86Multiply(k2, c3);
                h2 ^= k2;

            case 4:
                k1 ^= key.charCodeAt(i + 3) << 24;

            case 3:
                k1 ^= key.charCodeAt(i + 2) << 16;

            case 2:
                k1 ^= key.charCodeAt(i + 1) << 8;

            case 1:
                k1 ^= key.charCodeAt(i);
                k1 = _x86Multiply(k1, c1);
                k1 = _x86Rotl(k1, 15);
                k1 = _x86Multiply(k1, c2);
                h1 ^= k1;
        }

        h1 ^= key.length;
        h2 ^= key.length;
        h3 ^= key.length;
        h4 ^= key.length;

        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;

        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);

        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;

        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
    };

    library.x64.hash128 = function (key, seed) {
        //
        // Given a string and an optional seed as an int, returns a 128 bit
        // hash using the x64 flavor of MurmurHash3, as an unsigned hex.
        //

        key = key || '';
        seed = seed || 0;

        var remainder = key.length % 16;
        var bytes = key.length - remainder;

        var h1 = [0, seed];
        var h2 = [0, seed];

        var k1 = [0, 0];
        var k2 = [0, 0];

        var c1 = [0x87c37b91, 0x114253d5];
        var c2 = [0x4cf5ad43, 0x2745937f];

        for (var i = 0; i < bytes; i = i + 16) {
            k1 = [((key.charCodeAt(i + 4) & 0xff)) | ((key.charCodeAt(i + 5) & 0xff) << 8) | ((key.charCodeAt(i + 6) & 0xff) << 16) | ((key.charCodeAt(i + 7) & 0xff) << 24), ((key.charCodeAt(i) & 0xff)) | ((key.charCodeAt(i + 1) &
                0xff) << 8) | ((key.charCodeAt(i + 2) & 0xff) << 16) | ((key.charCodeAt(i + 3) & 0xff) << 24)];
            k2 = [((key.charCodeAt(i + 12) & 0xff)) | ((key.charCodeAt(i + 13) & 0xff) << 8) | ((key.charCodeAt(i + 14) & 0xff) << 16) | ((key.charCodeAt(i + 15) & 0xff) << 24), ((key.charCodeAt(i + 8) & 0xff)) | ((key.charCodeAt(i +
                9) & 0xff) << 8) | ((key.charCodeAt(i + 10) & 0xff) << 16) | ((key.charCodeAt(i + 11) & 0xff) << 24)];

            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);

            h1 = _x64Rotl(h1, 27);
            h1 = _x64Add(h1, h2);
            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 0x52dce729]);

            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);

            h2 = _x64Rotl(h2, 31);
            h2 = _x64Add(h2, h1);
            h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 0x38495ab5]);
        }

        k1 = [0, 0];
        k2 = [0, 0];

        switch (remainder) {
            case 15:
                k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i + 14)], 48));

            case 14:
                k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i + 13)], 40));

            case 13:
                k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i + 12)], 32));

            case 12:
                k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i + 11)], 24));

            case 11:
                k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i + 10)], 16));

            case 10:
                k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i + 9)], 8));

            case 9:
                k2 = _x64Xor(k2, [0, key.charCodeAt(i + 8)]);
                k2 = _x64Multiply(k2, c2);
                k2 = _x64Rotl(k2, 33);
                k2 = _x64Multiply(k2, c1);
                h2 = _x64Xor(h2, k2);

            case 8:
                k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i + 7)], 56));

            case 7:
                k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i + 6)], 48));

            case 6:
                k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i + 5)], 40));

            case 5:
                k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i + 4)], 32));

            case 4:
                k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i + 3)], 24));

            case 3:
                k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i + 2)], 16));

            case 2:
                k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i + 1)], 8));

            case 1:
                k1 = _x64Xor(k1, [0, key.charCodeAt(i)]);
                k1 = _x64Multiply(k1, c1);
                k1 = _x64Rotl(k1, 31);
                k1 = _x64Multiply(k1, c2);
                h1 = _x64Xor(h1, k1);
        }

        h1 = _x64Xor(h1, [0, key.length]);
        h2 = _x64Xor(h2, [0, key.length]);

        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);

        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);

        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);

        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
    };

    // INITIALIZATION
    // --------------

    // Export murmurHash3 for CommonJS, either as an AMD module or just as part
    // of the global object.
    if (typeof exports !== 'undefined') {

        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = library;
        }

        exports.murmurHash3 = library;

    } else if (typeof define === 'function' && define.amd) {

        define([], function () {
            return library;
        });
    } else {

        // Use murmurHash3.noConflict to restore `murmurHash3` back to its
        // original value. Returns a reference to the library object, to allow
        // it to be used under a different name.
        library._murmurHash3 = root.murmurHash3;

        library.noConflict = function () {
            root.murmurHash3 = library._murmurHash3;
            library._murmurHash3 = undefined;
            library.noConflict = undefined;

            return library;
        };

        root.murmurHash3 = library;
    }
})(this);

      };
    };
  }
}, {package:"murmurhash3js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js/lib/murmurHash3js.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/index.js", {"./blake2b":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/blake2b.js","./blake2s":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/blake2s.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/index.js
      return function (require, module, exports) {
var b2b = require('./blake2b')
var b2s = require('./blake2s')

module.exports = {
  blake2b: b2b.blake2b,
  blake2bHex: b2b.blake2bHex,
  blake2bInit: b2b.blake2bInit,
  blake2bUpdate: b2b.blake2bUpdate,
  blake2bFinal: b2b.blake2bFinal,
  blake2s: b2s.blake2s,
  blake2sHex: b2s.blake2sHex,
  blake2sInit: b2s.blake2sInit,
  blake2sUpdate: b2s.blake2sUpdate,
  blake2sFinal: b2s.blake2sFinal
}

      };
    };
  }
}, {package:"blakejs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/nodeify/index.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","is-promise":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-promise/index.js","promise":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promise/index.js","timers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/timers-browserify/main.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/nodeify/index.js
      return function (require, module, exports) {
(function (process,setImmediate){(function (){
var Promise = require('promise');
var isPromise = require('is-promise');

var nextTick;
if (typeof setImmediate === 'function') nextTick = setImmediate
else if (typeof process === 'object' && process && process.nextTick) nextTick = process.nextTick
else nextTick = function (cb) { setTimeout(cb, 0) }

module.exports = nodeify;
function nodeify(promise, cb) {
  if (typeof cb !== 'function') return promise;
  return promise
    .then(function (res) {
      nextTick(function () {
        cb(null, res);
      });
    }, function (err) {
      nextTick(function () {
        cb(err);
      });
    });
}
function nodeifyThis(cb) {
  return nodeify(this, cb);
}

nodeify.extend = extend;
nodeify.Promise = NodeifyPromise;

function extend(prom) {
  if (prom && isPromise(prom)) {
    prom.nodeify = nodeifyThis;
    var then = prom.then;
    prom.then = function () {
      return extend(then.apply(this, arguments));
    };
    return prom;
  } else if (typeof prom === 'function') {
    prom.prototype.nodeify = nodeifyThis;
  } else {
    Promise.prototype.nodeify = nodeifyThis;
  }
}

function NodeifyPromise(fn) {
  if (!(this instanceof NodeifyPromise)) {
    return new NodeifyPromise(fn);
  }
  Promise.call(this, fn);
  extend(this);
}

NodeifyPromise.prototype = Object.create(Promise.prototype);
NodeifyPromise.prototype.constructor = NodeifyPromise;
}).call(this)}).call(this,require('_process'),require("timers").setImmediate)

      };
    };
  }
}, {package:"nodeify",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/nodeify/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/hmac.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./md":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/md.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/hmac.js
      return function (require, module, exports) {
/**
 * Hash-based Message Authentication Code implementation. Requires a message
 * digest object that can be obtained, for example, from forge.md.sha1 or
 * forge.md.md5.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.
 */
var forge = require('./forge');
require('./md');
require('./util');

/* HMAC API */
var hmac = module.exports = forge.hmac = forge.hmac || {};

/**
 * Creates an HMAC object that uses the given message digest object.
 *
 * @return an HMAC object.
 */
hmac.create = function() {
  // the hmac key to use
  var _key = null;

  // the message digest to use
  var _md = null;

  // the inner padding
  var _ipadding = null;

  // the outer padding
  var _opadding = null;

  // hmac context
  var ctx = {};

  /**
   * Starts or restarts the HMAC with the given key and message digest.
   *
   * @param md the message digest to use, null to reuse the previous one,
   *           a string to use builtin 'sha1', 'md5', 'sha256'.
   * @param key the key to use as a string, array of bytes, byte buffer,
   *           or null to reuse the previous key.
   */
  ctx.start = function(md, key) {
    if(md !== null) {
      if(typeof md === 'string') {
        // create builtin message digest
        md = md.toLowerCase();
        if(md in forge.md.algorithms) {
          _md = forge.md.algorithms[md].create();
        } else {
          throw new Error('Unknown hash algorithm "' + md + '"');
        }
      } else {
        // store message digest
        _md = md;
      }
    }

    if(key === null) {
      // reuse previous key
      key = _key;
    } else {
      if(typeof key === 'string') {
        // convert string into byte buffer
        key = forge.util.createBuffer(key);
      } else if(forge.util.isArray(key)) {
        // convert byte array into byte buffer
        var tmp = key;
        key = forge.util.createBuffer();
        for(var i = 0; i < tmp.length; ++i) {
          key.putByte(tmp[i]);
        }
      }

      // if key is longer than blocksize, hash it
      var keylen = key.length();
      if(keylen > _md.blockLength) {
        _md.start();
        _md.update(key.bytes());
        key = _md.digest();
      }

      // mix key into inner and outer padding
      // ipadding = [0x36 * blocksize] ^ key
      // opadding = [0x5C * blocksize] ^ key
      _ipadding = forge.util.createBuffer();
      _opadding = forge.util.createBuffer();
      keylen = key.length();
      for(var i = 0; i < keylen; ++i) {
        var tmp = key.at(i);
        _ipadding.putByte(0x36 ^ tmp);
        _opadding.putByte(0x5C ^ tmp);
      }

      // if key is shorter than blocksize, add additional padding
      if(keylen < _md.blockLength) {
        var tmp = _md.blockLength - keylen;
        for(var i = 0; i < tmp; ++i) {
          _ipadding.putByte(0x36);
          _opadding.putByte(0x5C);
        }
      }
      _key = key;
      _ipadding = _ipadding.bytes();
      _opadding = _opadding.bytes();
    }

    // digest is done like so: hash(opadding | hash(ipadding | message))

    // prepare to do inner hash
    // hash(ipadding | message)
    _md.start();
    _md.update(_ipadding);
  };

  /**
   * Updates the HMAC with the given message bytes.
   *
   * @param bytes the bytes to update with.
   */
  ctx.update = function(bytes) {
    _md.update(bytes);
  };

  /**
   * Produces the Message Authentication Code (MAC).
   *
   * @return a byte buffer containing the digest value.
   */
  ctx.getMac = function() {
    // digest is done like so: hash(opadding | hash(ipadding | message))
    // here we do the outer hashing
    var inner = _md.digest().bytes();
    _md.start();
    _md.update(_opadding);
    _md.update(inner);
    return _md.digest();
  };
  // alias for getMac
  ctx.digest = ctx.getMac;

  return ctx;
};

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/hmac.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/baseN.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/baseN.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/**
 * Base-N/Base-X encoding/decoding functions.
 *
 * Original implementation from base-x:
 * https://github.com/cryptocoinjs/base-x
 *
 * Which is MIT licensed:
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
var api = {};
module.exports = api;

// baseN alphabet indexes
var _reverseAlphabets = {};

/**
 * BaseN-encodes a Uint8Array using the given alphabet.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the baseN-encoded output string.
 */
api.encode = function(input, alphabet, maxline) {
  if(typeof alphabet !== 'string') {
    throw new TypeError('"alphabet" must be a string.');
  }
  if(maxline !== undefined && typeof maxline !== 'number') {
    throw new TypeError('"maxline" must be a number.');
  }

  var output = '';

  if(!(input instanceof Uint8Array)) {
    // assume forge byte buffer
    output = _encodeWithByteBuffer(input, alphabet);
  } else {
    var i = 0;
    var base = alphabet.length;
    var first = alphabet.charAt(0);
    var digits = [0];
    for(i = 0; i < input.length; ++i) {
      for(var j = 0, carry = input[i]; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % base;
        carry = (carry / base) | 0;
      }

      while(carry > 0) {
        digits.push(carry % base);
        carry = (carry / base) | 0;
      }
    }

    // deal with leading zeros
    for(i = 0; input[i] === 0 && i < input.length - 1; ++i) {
      output += first;
    }
    // convert digits to a string
    for(i = digits.length - 1; i >= 0; --i) {
      output += alphabet[digits[i]];
    }
  }

  if(maxline) {
    var regex = new RegExp('.{1,' + maxline + '}', 'g');
    output = output.match(regex).join('\r\n');
  }

  return output;
};

/**
 * Decodes a baseN-encoded (using the given alphabet) string to a
 * Uint8Array.
 *
 * @param input the baseN-encoded input string.
 *
 * @return the Uint8Array.
 */
api.decode = function(input, alphabet) {
  if(typeof input !== 'string') {
    throw new TypeError('"input" must be a string.');
  }
  if(typeof alphabet !== 'string') {
    throw new TypeError('"alphabet" must be a string.');
  }

  var table = _reverseAlphabets[alphabet];
  if(!table) {
    // compute reverse alphabet
    table = _reverseAlphabets[alphabet] = [];
    for(var i = 0; i < alphabet.length; ++i) {
      table[alphabet.charCodeAt(i)] = i;
    }
  }

  // remove whitespace characters
  input = input.replace(/\s/g, '');

  var base = alphabet.length;
  var first = alphabet.charAt(0);
  var bytes = [0];
  for(var i = 0; i < input.length; i++) {
    var value = table[input.charCodeAt(i)];
    if(value === undefined) {
      return;
    }

    for(var j = 0, carry = value; j < bytes.length; ++j) {
      carry += bytes[j] * base;
      bytes[j] = carry & 0xff;
      carry >>= 8;
    }

    while(carry > 0) {
      bytes.push(carry & 0xff);
      carry >>= 8;
    }
  }

  // deal with leading zeros
  for(var k = 0; input[k] === first && k < input.length - 1; ++k) {
    bytes.push(0);
  }

  if(typeof Buffer !== 'undefined') {
    return Buffer.from(bytes.reverse());
  }

  return new Uint8Array(bytes.reverse());
};

function _encodeWithByteBuffer(input, alphabet) {
  var i = 0;
  var base = alphabet.length;
  var first = alphabet.charAt(0);
  var digits = [0];
  for(i = 0; i < input.length(); ++i) {
    for(var j = 0, carry = input.at(i); j < digits.length; ++j) {
      carry += digits[j] << 8;
      digits[j] = carry % base;
      carry = (carry / base) | 0;
    }

    while(carry > 0) {
      digits.push(carry % base);
      carry = (carry / base) | 0;
    }
  }

  var output = '';

  // deal with leading zeros
  for(i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
    output += first;
  }
  // convert digits to a string
  for(i = digits.length - 1; i >= 0; --i) {
    output += alphabet[digits[i]];
  }

  return output;
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/baseN.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/index.js", {"./collect":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/collect.js","./concat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/concat.js","./drain":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/drain.js","./find":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/find.js","./log":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/log.js","./on-end":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/on-end.js","./reduce":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/reduce.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/index.js
      return function (require, module, exports) {
'use strict'

module.exports = {
  drain: require('./drain'),
  onEnd: require('./on-end'),
  log: require('./log'),
  find: require('./find'),
  reduce: require('./reduce'),
  collect: require('./collect'),
  concat: require('./concat')
}


      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/index.js", {"./count":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/count.js","./empty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/empty.js","./error":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/error.js","./infinite":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/infinite.js","./keys":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/keys.js","./once":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/once.js","./values":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/values.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/index.js
      return function (require, module, exports) {
'use strict'
module.exports = {
  keys: require('./keys'),
  once: require('./once'),
  values: require('./values'),
  count: require('./count'),
  infinite: require('./infinite'),
  empty: require('./empty'),
  error: require('./error')
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/index.js", {"./async-map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/async-map.js","./filter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/filter.js","./filter-not":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/filter-not.js","./flatten":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/flatten.js","./map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/map.js","./non-unique":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/non-unique.js","./take":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/take.js","./through":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/through.js","./unique":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/unique.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/index.js
      return function (require, module, exports) {
'use strict'

module.exports = {
  map: require('./map'),
  asyncMap: require('./async-map'),
  filter: require('./filter'),
  filterNot: require('./filter-not'),
  through: require('./through'),
  take: require('./take'),
  unique: require('./unique'),
  nonUnique: require('./non-unique'),
  flatten: require('./flatten')
}




      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/unixfs.proto.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/unixfs.proto.js
      return function (require, module, exports) {
'use strict'

module.exports = `message Data {
  enum DataType {
    Raw = 0;
    Directory = 1;
    File = 2;
    Metadata = 3;
    Symlink = 4;
    HAMTShard = 5;
  }

  required DataType Type = 1;
  optional bytes Data = 2;
  optional uint64 filesize = 3;
  repeated uint64 blocksizes = 4;

  optional uint64 hashType = 5;
  optional uint64 fanout = 6;
}

message Metadata {
  optional string MimeType = 1;
}`

      };
    };
  }
}, {package:"ipfs-unixfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/unixfs.proto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/createTester.js", {"./breakLoop":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/breakLoop.js","lodash/noop":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/noop.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/createTester.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _createTester;

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _breakLoop = require('./breakLoop');

var _breakLoop2 = _interopRequireDefault(_breakLoop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _createTester(check, getResult) {
    return function (eachfn, arr, iteratee, cb) {
        cb = cb || _noop2.default;
        var testPassed = false;
        var testResult;
        eachfn(arr, function (value, _, callback) {
            iteratee(value, function (err, result) {
                if (err) {
                    callback(err);
                } else if (check(result) && !testResult) {
                    testPassed = true;
                    testResult = getResult(true, value);
                    callback(null, _breakLoop2.default);
                } else {
                    callback();
                }
            });
        }, function (err) {
            if (err) {
                cb(err);
            } else {
                cb(null, testPassed ? testResult : getResult(false));
            }
        });
    };
}
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/createTester.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/notId.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/notId.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = notId;
function notId(v) {
    return !v;
}
module.exports = exports["default"];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/notId.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/get-iterator/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/get-iterator/index.js
      return function (require, module, exports) {
// If the passed object is an (async) iterable, then get the iterator
// If it's probably an iterator already (i.e. has next function) return it
// else throw
module.exports = function getIterator (obj) {
  if (obj) {
    if (typeof obj[Symbol.iterator] === 'function') {
      return obj[Symbol.iterator]()
    }
    if (typeof obj[Symbol.asyncIterator] === 'function') {
      return obj[Symbol.asyncIterator]()
    }
    if (typeof obj.next === 'function') {
      return obj // probably an iterator
    }
  }
  throw new Error('argument is not an iterator or iterable')
}

      };
    };
  }
}, {package:"get-iterator",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/get-iterator/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/mapLimit.js", {"./internal/doParallelLimit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/doParallelLimit.js","./internal/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/map.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/mapLimit.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _doParallelLimit = require('./internal/doParallelLimit');

var _doParallelLimit2 = _interopRequireDefault(_doParallelLimit);

var _map = require('./internal/map');

var _map2 = _interopRequireDefault(_map);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
 *
 * @name mapLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 */
exports.default = (0, _doParallelLimit2.default)(_map2.default);
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/mapLimit.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/errors.js", {"err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/errors.js
      return function (require, module, exports) {
'use strict'

const errcode = require('err-code')

module.exports.dbOpenFailedError = (err) => {
  err = err || new Error('Cannot open database')
  return errcode(err, 'ERR_DB_OPEN_FAILED')
}

module.exports.dbDeleteFailedError = (err) => {
  err = err || new Error('Delete failed')
  return errcode(err, 'ERR_DB_DELETE_FAILED')
}

module.exports.dbWriteFailedError = (err) => {
  err = err || new Error('Write failed')
  return errcode(err, 'ERR_DB_WRITE_FAILED')
}

module.exports.notFoundError = (err) => {
  err = err || new Error('Not Found')
  return errcode(err, 'ERR_NOT_FOUND')
}

      };
    };
  }
}, {package:"interface-datastore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/errors.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/memory.js", {"./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/errors.js","./key":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/key.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/utils.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/memory.js
      return function (require, module, exports) {
/* @flow */
'use strict'

/* :: import type {Batch, Query, QueryResult, Callback} from './' */

const pull = require('pull-stream')
const setImmediate = require('async/setImmediate')

const asyncFilter = require('./utils').asyncFilter
const asyncSort = require('./utils').asyncSort
const Key = require('./key')

// Errors
const Errors = require('./errors')

class MemoryDatastore {
  /* :: data: {[key: string]: Buffer} */

  constructor () {
    this.data = {}
  }

  open (callback /* : Callback<void> */) /* : void */ {
    setImmediate(callback)
  }

  put (key /* : Key */, val /* : Buffer */, callback /* : Callback<void> */) /* : void */ {
    this.data[key.toString()] = val

    setImmediate(callback)
  }

  get (key /* : Key */, callback /* : Callback<Buffer> */) /* : void */ {
    this.has(key, (err, exists) => {
      if (err) {
        return callback(err)
      }

      if (!exists) {
        return callback(Errors.notFoundError())
      }

      callback(null, this.data[key.toString()])
    })
  }

  has (key /* : Key */, callback /* : Callback<bool> */) /* : void */ {
    setImmediate(() => {
      callback(null, this.data[key.toString()] !== undefined)
    })
  }

  delete (key /* : Key */, callback /* : Callback<void> */) /* : void */ {
    delete this.data[key.toString()]

    setImmediate(() => {
      callback()
    })
  }

  batch () /* : Batch<Buffer> */ {
    let puts = []
    let dels = []

    return {
      put (key /* : Key */, value /* : Buffer */) /* : void */ {
        puts.push([key, value])
      },
      delete (key /* : Key */) /* : void */ {
        dels.push(key)
      },
      commit: (callback /* : Callback<void> */) /* : void */ => {
        puts.forEach(v => {
          this.data[v[0].toString()] = v[1]
        })

        puts = []
        dels.forEach(key => {
          delete this.data[key.toString()]
        })
        dels = []

        setImmediate(callback)
      }
    }
  }

  query (q /* : Query<Buffer> */) /* : QueryResult<Buffer> */ {
    let tasks = [pull.keys(this.data), pull.map(k => ({
      key: new Key(k),
      value: this.data[k]
    }))]

    let filters = []

    if (q.prefix != null) {
      const prefix = q.prefix
      filters.push((e, cb) => cb(null, e.key.toString().startsWith(prefix)))
    }

    if (q.filters != null) {
      filters = filters.concat(q.filters)
    }

    tasks = tasks.concat(filters.map(f => asyncFilter(f)))

    if (q.orders != null) {
      tasks = tasks.concat(q.orders.map(o => asyncSort(o)))
    }

    if (q.offset != null) {
      let i = 0
      // $FlowFixMe
      tasks.push(pull.filter(() => i++ >= q.offset))
    }

    if (q.limit != null) {
      tasks.push(pull.take(q.limit))
    }

    if (q.keysOnly === true) {
      tasks.push(pull.map(e => ({ key: e.key })))
    }

    return pull.apply(null, tasks)
  }

  close (callback /* : Callback<void> */) /* : void */ {
    setImmediate(callback)
  }
}

module.exports = MemoryDatastore

      };
    };
  }
}, {package:"interface-datastore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/memory.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/utils.js", {"os":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/os-browserify/browser.js","path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/path-browserify/index.js","pull-defer/source":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/source.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js","uuid/v4":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/node_modules/uuid/v4.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/utils.js
      return function (require, module, exports) {
'use strict'

const pull = require('pull-stream')
const Source = require('pull-defer/source')
const path = require('path')
const os = require('os')
const uuid = require('uuid/v4')

exports.asyncFilter = function (test) {
  let busy = false
  let abortCb
  let aborted

  return function (read) {
    return function next (abort, cb) {
      if (aborted) return cb(aborted)
      if (abort) {
        aborted = abort
        if (!busy) {
          read(abort, cb)
        } else {
          read(abort, () => {
            // if we are still busy, wait for the test to complete.
            if (busy) abortCb = cb; else cb(abort)
          })
        }
      } else {
        read(null, (end, data) => {
          if (end) cb(end); else if (aborted) cb(aborted); else {
            busy = true
            test(data, (err, valid) => {
              busy = false
              if (aborted) {
                cb(aborted)
                abortCb(aborted)
              } else if (err) {
                next(err, cb)
              } else if (valid) {
                cb(null, data)
              } else {
                next(null, cb)
              }
            })
          }
        })
      }
    }
  }
}

exports.asyncSort = function (sorter) {
  const source = Source()

  const sink = pull.collect((err, ary) => {
    if (err) {
      return source.abort(err)
    }
    sorter(ary, (err, res) => {
      if (err) {
        return source.abort(err)
      }
      source.resolve(pull.values(ary))
    })
  })

  return function (read) {
    sink(read)
    return source
  }
}

exports.replaceStartWith = function (s, r) {
  const matcher = new RegExp('^' + r)
  return s.replace(matcher, '')
}

exports.tmpdir = () => {
  return path.join(os.tmpdir(), uuid())
}

      };
    };
  }
}, {package:"interface-datastore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/key.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","class-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js","uuid/v4":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/node_modules/uuid/v4.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/key.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* @flow */
'use strict'

const uuid = require('uuid/v4')
const withIs = require('class-is')

const pathSepS = '/'
const pathSepB = Buffer.from(pathSepS)
const pathSep = pathSepB[0]

/**
 * A Key represents the unique identifier of an object.
 * Our Key scheme is inspired by file systems and Google App Engine key model.
 * Keys are meant to be unique across a system. Keys are hierarchical,
 * incorporating more and more specific namespaces. Thus keys can be deemed
 * 'children' or 'ancestors' of other keys:
 * - `new Key('/Comedy')`
 * - `new Key('/Comedy/MontyPython')`
 * Also, every namespace can be parametrized to embed relevant object
 * information. For example, the Key `name` (most specific namespace) could
 * include the object type:
 * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`
 * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`
 * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`
 *
 */
class Key {
  /* :: _buf: Buffer */

  constructor (s /* : string|Buffer */, clean /* : ?bool */) {
    if (typeof s === 'string') {
      this._buf = Buffer.from(s)
    } else if (Buffer.isBuffer(s)) {
      this._buf = s
    }

    if (clean == null) {
      clean = true
    }

    if (clean) {
      this.clean()
    }

    if (this._buf.length === 0 || this._buf[0] !== pathSep) {
      throw new Error(`Invalid key: ${this.toString()}`)
    }
  }

  /**
   * Convert to the string representation
   *
   * @param {string} [encoding='utf8']
   * @returns {string}
   */
  toString (encoding/* : ?buffer$Encoding */)/* : string */ {
    return this._buf.toString(encoding || 'utf8')
  }

  /**
   * Return the buffer representation of the key
   *
   * @returns {Buffer}
   */
  toBuffer () /* : Buffer */ {
    return this._buf
  }

  // waiting on https://github.com/facebook/flow/issues/2286
  // $FlowFixMe
  get [Symbol.toStringTag] () /* : string */ {
    return `[Key ${this.toString()}]`
  }

  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list
   * @returns {Key}
   *
   * @example
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   *
   */
  static withNamespaces (list /* : Array<string> */) /* : Key */ {
    return new _Key(list.join(pathSepS))
  }

  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * Key.random()
   * // => Key('/f98719ea086343f7b71f32ea9d9d521d')
   *
   */
  static random () /* : Key */ {
    return new _Key(uuid().replace(/-/g, ''))
  }

  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean () {
    if (!this._buf || this._buf.length === 0) {
      this._buf = Buffer.from(pathSepS)
    }

    if (this._buf[0] !== pathSep) {
      this._buf = Buffer.concat([pathSepB, this._buf])
    }

    // normalize does not remove trailing slashes
    while (this._buf.length > 1 && this._buf[this._buf.length - 1] === pathSep) {
      this._buf = this._buf.slice(0, -1)
    }
  }

  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key
   * @returns {bool}
   */
  less (key /* : Key */) /* : bool */ {
    const list1 = this.list()
    const list2 = key.list()

    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false
      }

      const c1 = list1[i]
      const c2 = list2[i]

      if (c1 < c2) {
        return true
      } else if (c1 > c2) {
        return false
      }
    }

    return list1.length < list2.length
  }

  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   */
  reverse () /* : Key */ {
    return Key.withNamespaces(this.list().slice().reverse())
  }

  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces () /* : Array<string> */ {
    return this.list()
  }

  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   *
   */
  baseNamespace () /* : string */ {
    const ns = this.namespaces()
    return ns[ns.length - 1]
  }

  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   *
   */
  list () /* : Array<string> */ {
    return this.toString().split(pathSepS).slice(1)
  }

  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   *
   */
  type () /* : string */ {
    return namespaceType(this.baseNamespace())
  }

  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   */
  name () /* : string */ {
    return namespaceValue(this.baseNamespace())
  }

  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s
   * @returns {Key}
   *
   * @example
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   */
  instance (s /* : string */) /* : Key */ {
    return new _Key(this.toString() + ':' + s)
  }

  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   *
   */
  path () /* : Key */ {
    let p = this.parent().toString()
    if (!p.endsWith(pathSepS)) {
      p += pathSepS
    }
    p += this.type()
    return new _Key(p)
  }

  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   *
   */
  parent () /* : Key */ {
    const list = this.list()
    if (list.length === 1) {
      return new _Key(pathSepS)
    }

    return new _Key(list.slice(0, -1).join(pathSepS))
  }

  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key
   * @returns {Key}
   *
   * @example
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   *
   */
  child (key /* : Key */) /* : Key */ {
    if (this.toString() === pathSepS) {
      return key
    } else if (key.toString() === pathSepS) {
      return this
    }

    return new _Key(this.toString() + key.toString(), false)
  }

  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other
   * @returns {bool}
   *
   * @example
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   *
   */
  isAncestorOf (other /* : Key */) /* : bool */ {
    if (other.toString() === this.toString()) {
      return false
    }

    return other.toString().startsWith(this.toString())
  }

  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other
   * @returns {bool}
   *
   * @example
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   *
   */
  isDecendantOf (other /* : Key */) /* : bool */ {
    if (other.toString() === this.toString()) {
      return false
    }

    return this.toString().startsWith(other.toString())
  }

  /**
   * Returns wether this key has only one namespace.
   *
   * @returns {bool}
   *
   */
  isTopLevel () /* : bool */ {
    return this.list().length === 1
  }
}

/**
 * The first component of a namespace. `foo` in `foo:bar`
 *
 * @param {string} ns
 * @returns {string}
 */
function namespaceType (ns /* : string */) /* : string */ {
  const parts = ns.split(':')
  if (parts.length < 2) {
    return ''
  }
  return parts.slice(0, -1).join(':')
}

/**
 * The last component of a namespace, `baz` in `foo:bar:baz`.
 *
 * @param {string} ns
 * @returns {string}
 */
function namespaceValue (ns /* : string */) /* : string */ {
  const parts = ns.split(':')
  return parts[parts.length - 1]
}

const _Key = withIs(Key, { className: 'Key', symbolName: '@ipfs/interface-datastore/key' })

module.exports = _Key

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"interface-datastore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/key.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/findGetResult.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/findGetResult.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _findGetResult;
function _findGetResult(v, x) {
    return x;
}
module.exports = exports["default"];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/findGetResult.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/doParallelLimit.js", {"./eachOfLimit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/eachOfLimit.js","./wrapAsync":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/wrapAsync.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/doParallelLimit.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = doParallelLimit;

var _eachOfLimit = require('./eachOfLimit');

var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

var _wrapAsync = require('./wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function doParallelLimit(fn) {
    return function (obj, limit, iteratee, callback) {
        return fn((0, _eachOfLimit2.default)(limit), obj, (0, _wrapAsync2.default)(iteratee), callback);
    };
}
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/doParallelLimit.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pin.proto.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pin.proto.js
      return function (require, module, exports) {
'use strict'

/**
 * Protobuf interface
 * from go-ipfs/pin/internal/pb/header.proto
 */
module.exports = `
  syntax = "proto2";

  package ipfs.pin;

  option go_package = "pb";

  message Set {
    optional uint32 version = 1;
    optional uint32 fanout = 2;
    optional fixed32 seed = 3;
  }
`

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pin.proto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/fnv1a/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/fnv1a/index.js
      return function (require, module, exports) {
/**
 * Created by schwarzkopfb on 15/11/17.
 */

/**
 * FNV-1a hash generation init value.
 * It's exposed, because this allows user to override it.
 *
 * @type {number}
 */
hash.BASE = 0x811c9dc5

/**
 * Generates 32 bit FNV-1a hash from the given string.
 * As explained here: http://isthe.com/chongo/tech/comp/fnv/
 *
 * @param s {string} String to generate hash from.
 * @returns {number} The result integer hash.
 */
function hash(s) {
    var h = hash.BASE

    for (var i = 0, l = s.length; i < l; i++) {
        h ^= s.charCodeAt(i)
        h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24)
    }

    return h >>> 0
}

module.exports = hash

      };
    };
  }
}, {package:"fnv1a",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fnv1a/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/someSeries.js", {"./internal/doLimit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/doLimit.js","./someLimit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/someLimit.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/someSeries.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _someLimit = require('./someLimit');

var _someLimit2 = _interopRequireDefault(_someLimit);

var _doLimit = require('./internal/doLimit');

var _doLimit2 = _interopRequireDefault(_doLimit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
 *
 * @name someSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]{@link module:Collections.some}
 * @alias anySeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in series.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 */
exports.default = (0, _doLimit2.default)(_someLimit2.default, 1);
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/someSeries.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/pubsub-datastore.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","class-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js","datastore-pubsub":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-pubsub/src/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipns":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/pubsub-datastore.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const ipns = require('ipns')
const { fromB58String, toB58String } = require('multihashes')
const PubsubDatastore = require('datastore-pubsub')

const withIs = require('class-is')

const errcode = require('err-code')
const debug = require('debug')
const log = debug('ipfs:ipns:pubsub')
log.error = debug('ipfs:ipns:pubsub:error')

// Pubsub datastore aims to manage the pubsub subscriptions for IPNS
class IpnsPubsubDatastore {
  constructor (pubsub, localDatastore, peerId) {
    this._pubsub = pubsub
    this._subscriptions = {}

    // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.
    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this)
    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey)
  }

  /**
   * Put a value to the pubsub datastore indexed by the received key properly encoded.
   * @param {Buffer} key identifier of the value.
   * @param {Buffer} value value to be stored.
   * @param {function(Error)} callback
   * @returns {void}
   */
  put (key, value, callback) {
    this._pubsubDs.put(key, value, callback)
  }

  /**
   * Get a value from the pubsub datastore indexed by the received key properly encoded.
   * Moreover, the identifier topic is subscribed and the pubsub datastore records will be
   * updated once new publishes occur.
   * @param {Buffer} key identifier of the value to be obtained.
   * @param {function(Error, Buffer)} callback
   * @returns {void}
   */
  get (key, callback) {
    this._pubsubDs.get(key, (err, res) => {
      // Add topic subscribed
      const ns = key.slice(0, ipns.namespaceLength)

      if (ns.toString() === ipns.namespace) {
        const stringifiedTopic = key.toString()
        const id = toB58String(key.slice(ipns.namespaceLength))

        this._subscriptions[stringifiedTopic] = id

        log(`subscribed pubsub ${stringifiedTopic}: ${id}`)
      }

      // If no data was obtained, after storing the subscription, return the error.
      if (err) {
        return callback(err)
      }

      callback(null, res)
    })
  }

  // Modify subscription key to have a proper encoding
  _handleSubscriptionKey (key, callback) {
    const subscriber = this._subscriptions[key]

    if (!subscriber) {
      const errMsg = `key ${key} does not correspond to a subscription`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_KEY'))
    }

    let keys
    try {
      keys = ipns.getIdKeys(fromB58String(subscriber))
    } catch (err) {
      log.error(err)
      return callback(err)
    }

    callback(null, keys.routingKey.toBuffer())
  }

  /**
   * Get pubsub subscriptions related to ipns.
   * @param {function(Error, Object)} callback
   * @returns {void}
   */
  getSubscriptions (callback) {
    const subscriptions = Object.values(this._subscriptions).filter(Boolean)

    return callback(null, subscriptions.map((sub) => `${ipns.namespace}${sub}`))
  }

  /**
   * Cancel pubsub subscriptions related to ipns.
   * @param {String} name ipns path to cancel the pubsub subscription.
   * @param {function(Error, Object)} callback
   * @returns {void}
   */
  cancel (name, callback) {
    if (typeof name !== 'string') {
      const errMsg = `received subscription name is not valid`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_SUBSCRIPTION_NAME'))
    }

    // Trim /ipns/ prefix from the name
    if (name.startsWith(ipns.namespace)) {
      name = name.substring(ipns.namespaceLength)
    }

    const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name)

    // Not found topic
    if (!stringifiedTopic) {
      return callback(null, {
        canceled: false
      })
    }

    // Unsubscribe topic
    try {
      const bufTopic = Buffer.from(stringifiedTopic)

      this._pubsubDs.unsubscribe(bufTopic)
    } catch (err) {
      return callback(err)
    }

    this._subscriptions[stringifiedTopic] = undefined
    log(`unsubscribed pubsub ${stringifiedTopic}: ${name}`)

    callback(null, {
      canceled: true
    })
  }
}

exports = module.exports = withIs(IpnsPubsubDatastore, { className: 'IpnsPubsubDatastore', symbolName: '@js-ipfs/ipns/IpnsPubsubDatastore' })

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/pubsub-datastore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/keychain.js", {"./cms":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/cms.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js","libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js","merge-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/merge-options/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js","pull-stream/sinks/collect":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/collect.js","sanitize-filename":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/sanitize-filename/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/keychain.js
      return function (require, module, exports) {
/* eslint max-nested-callbacks: ["error", 5] */
'use strict'

const sanitize = require('sanitize-filename')
const mergeOptions = require('merge-options')
const crypto = require('libp2p-crypto')
const DS = require('interface-datastore')
const collect = require('pull-stream/sinks/collect')
const pull = require('pull-stream/pull')
const CMS = require('./cms')
const errcode = require('err-code')

const keyPrefix = '/pkcs8/'
const infoPrefix = '/info/'

// NIST SP 800-132
const NIST = {
  minKeyLength: 112 / 8,
  minSaltLength: 128 / 8,
  minIterationCount: 1000
}

const defaultOptions = {
  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/
  dek: {
    keyLength: 512 / 8,
    iterationCount: 10000,
    salt: 'you should override this value with a crypto secure random number',
    hash: 'sha2-512'
  }
}

function validateKeyName (name) {
  if (!name) return false
  if (typeof name !== 'string') return false
  return name === sanitize(name.trim())
}

/**
 * Returns an error to the caller, after a delay
 *
 * This assumes than an error indicates that the keychain is under attack. Delay returning an
 * error to make brute force attacks harder.
 *
 * @param {function(Error)} callback - The caller
 * @param {string | Error} err - The error
 * @returns {undefined}
 * @private
 */
function _error (callback, err) {
  const min = 200
  const max = 1000
  const delay = Math.random() * (max - min) + min

  setTimeout(callback, delay, err, null)
}

/**
 * Converts a key name into a datastore name.
 *
 * @param {string} name
 * @returns {DS.Key}
 * @private
 */
function DsName (name) {
  return new DS.Key(keyPrefix + name)
}

/**
 * Converts a key name into a datastore info name.
 *
 * @param {string} name
 * @returns {DS.Key}
 * @private
 */
function DsInfoName (name) {
  return new DS.Key(infoPrefix + name)
}

/**
 * Information about a key.
 *
 * @typedef {Object} KeyInfo
 *
 * @property {string} id - The universally unique key id.
 * @property {string} name - The local key name.
 */

/**
 * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.
 *
 * A key in the store has two entries
 * - '/info/*key-name*', contains the KeyInfo for the key
 * - '/pkcs8/*key-name*', contains the PKCS #8 for the key
 *
 */
class Keychain {
  /**
   * Creates a new instance of a key chain.
   *
   * @param {DS} store - where the key are.
   * @param {object} options - ???
   */
  constructor (store, options) {
    if (!store) {
      throw new Error('store is required')
    }
    this.store = store

    const opts = mergeOptions(defaultOptions, options)

    // Enforce NIST SP 800-132
    if (!opts.passPhrase || opts.passPhrase.length < 20) {
      throw new Error('passPhrase must be least 20 characters')
    }
    if (opts.dek.keyLength < NIST.minKeyLength) {
      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`)
    }
    if (opts.dek.salt.length < NIST.minSaltLength) {
      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`)
    }
    if (opts.dek.iterationCount < NIST.minIterationCount) {
      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`)
    }

    // Create the derived encrypting key
    const dek = crypto.pbkdf2(
      opts.passPhrase,
      opts.dek.salt,
      opts.dek.iterationCount,
      opts.dek.keyLength,
      opts.dek.hash)
    Object.defineProperty(this, '_', { value: () => dek })
  }

  /**
   * Gets an object that can encrypt/decrypt protected data
   * using the Cryptographic Message Syntax (CMS).
   *
   * CMS describes an encapsulation syntax for data protection. It
   * is used to digitally sign, digest, authenticate, or encrypt
   * arbitrary message content.
   *
   * @returns {CMS}
   */
  get cms () {
    return new CMS(this)
  }

  /**
   * Generates the options for a keychain.  A random salt is produced.
   *
   * @returns {object}
   */
  static generateOptions () {
    const options = Object.assign({}, defaultOptions)
    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3 // no base64 padding
    options.dek.salt = crypto.randomBytes(saltLength).toString('base64')
    return options
  }

  /**
   * Gets an object that can encrypt/decrypt protected data.
   * The default options for a keychain.
   *
   * @returns {object}
   */
  static get options () {
    return defaultOptions
  }

  /**
   * Create a new key.
   *
   * @param {string} name - The local key name; cannot already exist.
   * @param {string} type - One of the key types; 'rsa'.
   * @param {int} size - The key size in bits.
   * @param {function(Error, KeyInfo)} callback
   * @returns {undefined}
   */
  createKey (name, type, size, callback) {
    const self = this

    if (!validateKeyName(name) || name === 'self') {
      return _error(callback, errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))
    }

    if (typeof type !== 'string') {
      return _error(callback, errcode(new Error(`Invalid key type '${type}'`), 'ERR_INVALID_KEY_TYPE'))
    }

    if (!Number.isSafeInteger(size)) {
      return _error(callback, errcode(new Error(`Invalid key size '${size}'`), 'ERR_INVALID_KEY_SIZE'))
    }

    const dsname = DsName(name)
    self.store.has(dsname, (err, exists) => {
      if (err) return _error(callback, err)
      if (exists) return _error(callback, errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))

      switch (type.toLowerCase()) {
        case 'rsa':
          if (size < 2048) {
            return _error(callback, errcode(new Error(`Invalid RSA key size ${size}`), 'ERR_INVALID_KEY_SIZE'))
          }
          break
        default:
          break
      }

      crypto.keys.generateKeyPair(type, size, (err, keypair) => {
        if (err) return _error(callback, err)
        keypair.id((err, kid) => {
          if (err) return _error(callback, err)
          keypair.export(this._(), (err, pem) => {
            if (err) return _error(callback, err)
            const keyInfo = {
              name: name,
              id: kid
            }
            const batch = self.store.batch()
            batch.put(dsname, pem)
            batch.put(DsInfoName(name), JSON.stringify(keyInfo))
            batch.commit((err) => {
              if (err) return _error(callback, err)

              callback(null, keyInfo)
            })
          })
        })
      })
    })
  }

  /**
   * List all the keys.
   *
   * @param {function(Error, KeyInfo[])} callback
   * @returns {undefined}
   */
  listKeys (callback) {
    const self = this
    const query = {
      prefix: infoPrefix
    }
    pull(
      self.store.query(query),
      collect((err, res) => {
        if (err) return _error(callback, err)

        const info = res.map(r => JSON.parse(r.value))
        callback(null, info)
      })
    )
  }

  /**
   * Find a key by it's id.
   *
   * @param {string} id - The universally unique key identifier.
   * @param {function(Error, KeyInfo)} callback
   * @returns {undefined}
   */
  findKeyById (id, callback) {
    this.listKeys((err, keys) => {
      if (err) return _error(callback, err)

      const key = keys.find((k) => k.id === id)
      callback(null, key)
    })
  }

  /**
   * Find a key by it's name.
   *
   * @param {string} name - The local key name.
   * @param {function(Error, KeyInfo)} callback
   * @returns {undefined}
   */
  findKeyByName (name, callback) {
    if (!validateKeyName(name)) {
      return _error(callback, errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))
    }

    const dsname = DsInfoName(name)
    this.store.get(dsname, (err, res) => {
      if (err) {
        return _error(callback, errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))
      }

      callback(null, JSON.parse(res.toString()))
    })
  }

  /**
   * Remove an existing key.
   *
   * @param {string} name - The local key name; must already exist.
   * @param {function(Error, KeyInfo)} callback
   * @returns {undefined}
   */
  removeKey (name, callback) {
    const self = this
    if (!validateKeyName(name) || name === 'self') {
      return _error(callback, errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))
    }
    const dsname = DsName(name)
    self.findKeyByName(name, (err, keyinfo) => {
      if (err) return _error(callback, err)
      const batch = self.store.batch()
      batch.delete(dsname)
      batch.delete(DsInfoName(name))
      batch.commit((err) => {
        if (err) return _error(callback, err)
        callback(null, keyinfo)
      })
    })
  }

  /**
   * Rename a key
   *
   * @param {string} oldName - The old local key name; must already exist.
   * @param {string} newName - The new local key name; must not already exist.
   * @param {function(Error, KeyInfo)} callback
   * @returns {undefined}
   */
  renameKey (oldName, newName, callback) {
    const self = this
    if (!validateKeyName(oldName) || oldName === 'self') {
      return _error(callback, errcode(new Error(`Invalid old key name '${oldName}'`), 'ERR_OLD_KEY_NAME_INVALID'))
    }
    if (!validateKeyName(newName) || newName === 'self') {
      return _error(callback, errcode(new Error(`Invalid new key name '${newName}'`), 'ERR_NEW_KEY_NAME_INVALID'))
    }
    const oldDsname = DsName(oldName)
    const newDsname = DsName(newName)
    const oldInfoName = DsInfoName(oldName)
    const newInfoName = DsInfoName(newName)
    this.store.get(oldDsname, (err, res) => {
      if (err) {
        return _error(callback, errcode(new Error(`Key '${oldName}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))
      }
      const pem = res.toString()
      self.store.has(newDsname, (err, exists) => {
        if (err) return _error(callback, err)
        if (exists) return _error(callback, errcode(new Error(`Key '${newName}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))

        self.store.get(oldInfoName, (err, res) => {
          if (err) return _error(callback, err)

          const keyInfo = JSON.parse(res.toString())
          keyInfo.name = newName
          const batch = self.store.batch()
          batch.put(newDsname, pem)
          batch.put(newInfoName, JSON.stringify(keyInfo))
          batch.delete(oldDsname)
          batch.delete(oldInfoName)
          batch.commit((err) => {
            if (err) return _error(callback, err)
            callback(null, keyInfo)
          })
        })
      })
    })
  }

  /**
   * Export an existing key as a PEM encrypted PKCS #8 string
   *
   * @param {string} name - The local key name; must already exist.
   * @param {string} password - The password
   * @param {function(Error, string)} callback
   * @returns {undefined}
   */
  exportKey (name, password, callback) {
    if (!validateKeyName(name)) {
      return _error(callback, errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))
    }
    if (!password) {
      return _error(callback, errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED'))
    }

    const dsname = DsName(name)
    this.store.get(dsname, (err, res) => {
      if (err) {
        return _error(callback, errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))
      }
      const pem = res.toString()
      crypto.keys.__import__(pem, this._(), (err, privateKey) => {
        if (err) return _error(callback, err)
        privateKey.export(password, callback)
      })
    })
  }

  /**
   * Import a new key from a PEM encoded PKCS #8 string
   *
   * @param {string} name - The local key name; must not already exist.
   * @param {string} pem - The PEM encoded PKCS #8 string
   * @param {string} password - The password.
   * @param {function(Error, KeyInfo)} callback
   * @returns {undefined}
   */
  importKey (name, pem, password, callback) {
    const self = this
    if (!validateKeyName(name) || name === 'self') {
      return _error(callback, errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))
    }
    if (!pem) {
      return _error(callback, 'PEM encoded key is required')
    }
    const dsname = DsName(name)
    self.store.has(dsname, (err, exists) => {
      if (err) return _error(callback, err)
      if (exists) return _error(callback, errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))
      crypto.keys.__import__(pem, password, (err, privateKey) => {
        if (err) return _error(callback, errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY'))
        privateKey.id((err, kid) => {
          if (err) return _error(callback, err)
          privateKey.export(this._(), (err, pem) => {
            if (err) return _error(callback, err)
            const keyInfo = {
              name: name,
              id: kid
            }
            const batch = self.store.batch()
            batch.put(dsname, pem)
            batch.put(DsInfoName(name), JSON.stringify(keyInfo))
            batch.commit((err) => {
              if (err) return _error(callback, err)

              callback(null, keyInfo)
            })
          })
        })
      })
    })
  }

  importPeer (name, peer, callback) {
    const self = this
    if (!validateKeyName(name)) {
      return _error(callback, errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))
    }
    if (!peer || !peer.privKey) {
      return _error(callback, errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY'))
    }

    const privateKey = peer.privKey
    const dsname = DsName(name)
    self.store.has(dsname, (err, exists) => {
      if (err) return _error(callback, err)
      if (exists) return _error(callback, errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))

      privateKey.id((err, kid) => {
        if (err) return _error(callback, err)
        privateKey.export(this._(), (err, pem) => {
          if (err) return _error(callback, err)
          const keyInfo = {
            name: name,
            id: kid
          }
          const batch = self.store.batch()
          batch.put(dsname, pem)
          batch.put(DsInfoName(name), JSON.stringify(keyInfo))
          batch.commit((err) => {
            if (err) return _error(callback, err)

            callback(null, keyInfo)
          })
        })
      })
    })
  }

  /**
   * Gets the private key as PEM encoded PKCS #8 string.
   *
   * @param {string} name
   * @param {function(Error, string)} callback
   * @returns {undefined}
   * @private
   */
  _getPrivateKey (name, callback) {
    if (!validateKeyName(name)) {
      return _error(callback, errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))
    }
    this.store.get(DsName(name), (err, res) => {
      if (err) {
        return _error(callback, errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))
      }
      callback(null, res.toString())
    })
  }
}

module.exports = Keychain

      };
    };
  }
}, {package:"libp2p-keychain",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/keychain.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/resolver.js", {"debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipns":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/index.js","libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/resolver.js
      return function (require, module, exports) {
'use strict'

const ipns = require('ipns')
const crypto = require('libp2p-crypto')
const PeerId = require('peer-id')
const errcode = require('err-code')

const debug = require('debug')
const log = debug('ipfs:ipns:resolver')
log.error = debug('ipfs:ipns:resolver:error')

const defaultMaximumRecursiveDepth = 32

class IpnsResolver {
  constructor (routing) {
    this._routing = routing
  }

  resolve (name, options, callback) {
    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    if (typeof name !== 'string') {
      const errMsg = `one or more of the provided parameters are not valid`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_PARAMETER'))
    }

    options = options || {}
    const recursive = options.recursive && options.recursive.toString() === 'true'

    const nameSegments = name.split('/')

    if (nameSegments.length !== 3 || nameSegments[0] !== '') {
      const errMsg = `invalid name syntax for ${name}`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_NAME_SYNTAX'))
    }

    const key = nameSegments[2]

    // Define a maximum depth if recursive option enabled
    let depth

    if (recursive) {
      depth = defaultMaximumRecursiveDepth
    }

    this.resolver(key, depth, (err, res) => {
      if (err) {
        return callback(err)
      }

      log(`${name} was locally resolved correctly`)
      callback(null, res)
    })
  }

  // Recursive resolver according to the specified depth
  resolver (name, depth, callback) {
    // Exceeded recursive maximum depth
    if (depth === 0) {
      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT'))
    }

    this._resolveName(name, (err, res) => {
      if (err) {
        return callback(err)
      }

      const nameSegments = res.split('/')

      // If obtained a ipfs cid or recursive option is disabled
      if (nameSegments[1] === 'ipfs' || !depth) {
        return callback(null, res)
      }

      // continue recursively until depth equals 0
      this.resolver(nameSegments[2], depth - 1, callback)
    })
  }

  // resolve ipns entries from the provided routing
  _resolveName (name, callback) {
    let peerId

    try {
      peerId = PeerId.createFromB58String(name)
    } catch (err) {
      return callback(err)
    }

    const { routingKey, routingPubKey } = ipns.getIdKeys(peerId.toBytes())

    this._routing.get(routingKey.toBuffer(), (err, record) => {
      if (err) {
        if (err.code !== 'ERR_NOT_FOUND') {
          const errMsg = `unexpected error getting the ipns record ${peerId.id}`

          log.error(errMsg)
          return callback(errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD'))
        }
        const errMsg = `record requested was not found for ${name} (${routingKey}) in the network`

        log.error(errMsg)
        return callback(errcode(new Error(errMsg), 'ERR_NO_RECORD_FOUND'))
      }

      // IPNS entry
      let ipnsEntry
      try {
        ipnsEntry = ipns.unmarshal(record)
      } catch (err) {
        const errMsg = `found ipns record that we couldn't convert to a value`

        log.error(errMsg)
        return callback(errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED'))
      }

      // if the record has a public key validate it
      if (ipnsEntry.pubKey) {
        return this._validateRecord(peerId, ipnsEntry, callback)
      }

      // Otherwise, try to get the public key from routing
      this._routing.get(routingKey.toBuffer(), (err, pubKey) => {
        if (err) {
          if (err.code !== 'ERR_NOT_FOUND') {
            const errMsg = `unexpected error getting the public key for the ipns record ${peerId.id}`

            log.error(errMsg)
            return callback(errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_PUB_KEY'))
          }
          const errMsg = `public key requested was not found for ${name} (${routingPubKey}) in the network`

          log.error(errMsg)
          return callback(errcode(new Error(errMsg), 'ERR_NO_RECORD_FOUND'))
        }

        try {
          // Insert it into the peer id, in order to be validated by IPNS validator
          peerId.pubKey = crypto.keys.unmarshalPublicKey(pubKey)
        } catch (err) {
          const errMsg = `found public key record that we couldn't convert to a value`

          log.error(errMsg)
          return callback(errcode(new Error(errMsg), 'ERR_INVALID_PUB_KEY_RECEIVED'))
        }

        this._validateRecord(peerId, ipnsEntry, callback)
      })
    })
  }

  // validate a resolved record
  _validateRecord (peerId, ipnsEntry, callback) {
    ipns.extractPublicKey(peerId, ipnsEntry, (err, pubKey) => {
      if (err) {
        return callback(err)
      }

      // IPNS entry validation
      ipns.validate(pubKey, ipnsEntry, (err) => {
        if (err) {
          return callback(err)
        }

        callback(null, ipnsEntry.value.toString())
      })
    })
  }
}

exports = module.exports = IpnsResolver

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/resolver.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/receptacle/index.js", {"ms":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ms/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/receptacle/index.js
      return function (require, module, exports) {
'use strict'

module.exports = Receptacle
var toMS = require('ms')
var cache = Receptacle.prototype
var counter = new Date() % 1e9

function getUID () { return (Math.random() * 1e9 >>> 0) + (counter++) }

/**
 * Creates a cache with a maximum key size.
 *
 * @constructor
 * @param {Object} options
 * @param {Number} [options.max=Infinity] the maximum number of keys allowed in the cache (lru).
 * @param {Array} [options.items=[]] the default items in the cache.
 */
function Receptacle (options) {
  options = options || {}
  this.id = options.id || getUID()
  this.max = options.max || Infinity
  this.items = options.items || []
  this._lookup = {}
  this.size = this.items.length
  this.lastModified = new Date(options.lastModified || new Date())

  // Setup initial timers and indexes for the cache.
  for (var item, ttl, i = this.items.length; i--;) {
    item = this.items[i]
    ttl = new Date(item.expires) - new Date()
    this._lookup[item.key] = item
    if (ttl > 0) this.expire(item.key, ttl)
    else if (ttl <= 0) this.delete(item.key)
  }
}

/**
 * Tests if a key is currently in the cache.
 * Does not check if slot is empty.
 *
 * @param {String} key - the key to retrieve from the cache.
 * @return {Boolean}
 */
cache.has = function (key) {
  return key in this._lookup
}

/**
 * Retrieves a key from the cache and marks it as recently used.
 *
 * @param {String} key - the key to retrieve from the cache.
 * @return {*}
 */
cache.get = function (key) {
  if (!this.has(key)) return null
  var record = this._lookup[key]
  // Update expiry for "refresh" keys
  if (record.refresh) this.expire(key, record.refresh)
  // Move to front of the line.
  this.items.splice(this.items.indexOf(record), 1)
  this.items.push(record)
  return record.value
}

/**
 * Retrieves user meta data for a cached item.
 *
 * @param {String} key - the key to retrieve meta data from the cache.
 * @return {*}
 */
cache.meta = function (key) {
  if (!this.has(key)) return null
  var record = this._lookup[key]
  if (!('meta' in record)) return null
  return record.meta
}

/**
 * Puts a key into the cache with an optional expiry time.
 *
 * @param {String} key - the key for the value in the cache.
 * @param {*} value - the value to place at the key.
 * @param {Number} [options.ttl] - a time after which the key will be removed.
 * @return {Receptacle}
 */
cache.set = function (key, value, options) {
  var oldRecord = this._lookup[key]
  var record = this._lookup[key] = { key: key, value: value }
  // Mark cache as modified.
  this.lastModified = new Date()

  if (oldRecord) {
    // Replace an old key.
    clearTimeout(oldRecord.timeout)
    this.items.splice(this.items.indexOf(oldRecord), 1, record)
  } else {
    // Remove least used item if needed.
    if (this.size >= this.max) this.delete(this.items[0].key)
    // Add a new key.
    this.items.push(record)
    this.size++
  }

  if (options) {
    // Setup key expiry.
    if ('ttl' in options) this.expire(key, options.ttl)
    // Store user options in the record.
    if ('meta' in options) record.meta = options.meta
    // Mark a auto refresh key.
    if (options.refresh) record.refresh = options.ttl
  }

  return this
}

/**
 * Deletes an item from the cache.
 *
 * @param {String} key - the key to remove.
 * @return {Receptacle}
 */
cache.delete = function (key) {
  var record = this._lookup[key]
  if (!record) return false
  this.lastModified = new Date()
  this.items.splice(this.items.indexOf(record), 1)
  clearTimeout(record.timeout)
  delete this._lookup[key]
  this.size--
  return this
}

/**
 * Utility to register a key that will be removed after some time.
 *
 * @param {String} key - the key to remove.
 * @param {Number} [ms] - the timeout before removal.
 * @return {Receptacle}
 */
cache.expire = function (key, ttl) {
  var ms = ttl || 0
  var record = this._lookup[key]
  if (!record) return this
  if (typeof ms === 'string') ms = toMS(ttl)
  if (typeof ms !== 'number') throw new TypeError('Expiration time must be a string or number.')
  clearTimeout(record.timeout)
  record.timeout = setTimeout(this.delete.bind(this, record.key), ms)
  record.expires = Number(new Date()) + ms
  return this
}

/**
 * Deletes all items from the cache.
 * @return {Receptacle}
 */
cache.clear = function () {
  for (var i = this.items.length; i--;) this.delete(this.items[i].key)
  return this
}

/**
 * Fixes serialization issues in polyfilled environments.
 * Ensures non-cyclical serialized object.
 */
cache.toJSON = function () {
  var items = new Array(this.items.length)
  var item
  for (var i = items.length; i--;) {
    item = this.items[i]
    items[i] = {
      key: item.key,
      meta: item.meta,
      value: item.value,
      expires: item.expires,
      refresh: item.refresh
    }
  }

  return {
    id: this.id,
    max: isFinite(this.max) ? this.max : undefined,
    lastModified: this.lastModified,
    items: items
  }
}

      };
    };
  }
}, {package:"receptacle",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/receptacle/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/publisher.js", {"async/series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/series.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js","ipns":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/publisher.js
      return function (require, module, exports) {
'use strict'

const PeerId = require('peer-id')
const { Key } = require('interface-datastore')
const series = require('async/series')
const errcode = require('err-code')

const debug = require('debug')
const log = debug('ipfs:ipns:publisher')
log.error = debug('ipfs:ipns:publisher:error')

const ipns = require('ipns')

const defaultRecordTtl = 60 * 60 * 1000

// IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.
class IpnsPublisher {
  constructor (routing, datastore) {
    this._routing = routing
    this._datastore = datastore
  }

  // publish record with a eol
  publishWithEOL (privKey, value, lifetime, callback) {
    if (!privKey || !privKey.bytes) {
      const errMsg = `one or more of the provided parameters are not defined`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER'))
    }

    PeerId.createFromPrivKey(privKey.bytes, (err, peerId) => {
      if (err) {
        return callback(err)
      }

      this._updateOrCreateRecord(privKey, value, lifetime, peerId, (err, record) => {
        if (err) {
          return callback(err)
        }

        this._putRecordToRouting(record, peerId, callback)
      })
    })
  }

  // Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system
  publish (privKey, value, callback) {
    this.publishWithEOL(privKey, value, defaultRecordTtl, callback)
  }

  _putRecordToRouting (record, peerId, callback) {
    if (!(PeerId.isPeerId(peerId))) {
      const errMsg = `peerId received is not valid`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'))
    }
    const publicKey = peerId._pubKey

    ipns.embedPublicKey(publicKey, record, (err, embedPublicKeyRecord) => {
      if (err) {
        return callback(err)
      }

      let keys
      try {
        keys = ipns.getIdKeys(peerId.toBytes())
      } catch (err) {
        log.error(err)
        return callback(err)
      }

      series([
        (cb) => this._publishEntry(keys.routingKey, embedPublicKeyRecord || record, peerId, cb),
        // Publish the public key to support old go-ipfs nodes that are looking for it in the routing
        // We will be able to deprecate this part in the future, since the public keys will be only
        // in IPNS record and the peerId.
        (cb) => this._publishPublicKey(keys.routingPubKey, publicKey, peerId, cb)
      ], (err) => {
        if (err) {
          log.error(err)
          return callback(err)
        }

        callback(null, embedPublicKeyRecord || record)
      })
    })
  }

  _publishEntry (key, entry, peerId, callback) {
    if (!(Key.isKey(key))) {
      const errMsg = `datastore key does not have a valid format`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'))
    }

    let entryData
    try {
      // Marshal record
      entryData = ipns.marshal(entry)
    } catch (err) {
      log.error(err)
      return callback(err)
    }

    // Add record to routing (buffer key)
    this._routing.put(key.toBuffer(), entryData, (err, res) => {
      if (err) {
        const errMsg = `ipns record for ${key.toString()} could not be stored in the routing`

        log.error(errMsg)
        return callback(errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING'))
      }

      log(`ipns record for ${key.toString()} was stored in the routing`)
      callback(null, res)
    })
  }

  _publishPublicKey (key, publicKey, peerId, callback) {
    if ((!Key.isKey(key))) {
      const errMsg = `datastore key does not have a valid format`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'))
    }

    if (!publicKey || !publicKey.bytes) {
      const errMsg = `one or more of the provided parameters are not defined`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER'))
    }

    // Add public key to routing (buffer key)
    this._routing.put(key.toBuffer(), publicKey.bytes, (err, res) => {
      if (err) {
        const errMsg = `public key for ${key.toString()} could not be stored in the routing`

        log.error(errMsg)
        return callback(errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING'))
      }

      log(`public key for ${key.toString()} was stored in the routing`)
      callback(null, res)
    })
  }

  // Returns the record this node has published corresponding to the given peer ID.
  // If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.
  _getPublished (peerId, options, callback) {
    if (!(PeerId.isPeerId(peerId))) {
      const errMsg = `peerId received is not valid`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'))
    }

    options = options || {}
    const checkRouting = options.checkRouting !== false

    this._datastore.get(ipns.getLocalKey(peerId.id), (err, dsVal) => {
      if (err) {
        if (err.code !== 'ERR_NOT_FOUND') {
          const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`

          log.error(errMsg)
          return callback(errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE'))
        }

        if (!checkRouting) {
          return callback((errcode(err)))
        }

        // Try to get from routing
        let keys
        try {
          keys = ipns.getIdKeys(peerId.toBytes())
        } catch (err) {
          log.error(err)
          return callback(err)
        }

        this._routing.get(keys.routingKey.toBuffer(), (err, res) => {
          if (err) {
            return callback(err)
          }

          // unmarshal data
          this._unmarshalData(res, callback)
        })
      } else {
        // unmarshal data
        this._unmarshalData(dsVal, callback)
      }
    })
  }

  _unmarshalData (data, callback) {
    let result
    try {
      result = ipns.unmarshal(data)
    } catch (err) {
      log.error(err)
      return callback(errcode(err, 'ERR_INVALID_RECORD_DATA'))
    }

    callback(null, result)
  }

  _updateOrCreateRecord (privKey, value, validity, peerId, callback) {
    if (!(PeerId.isPeerId(peerId))) {
      const errMsg = `peerId received is not valid`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'))
    }

    const getPublishedOptions = {
      checkRouting: true
    }

    this._getPublished(peerId, getPublishedOptions, (err, record) => {
      if (err) {
        if (err.code !== 'ERR_NOT_FOUND') {
          const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id}`

          log.error(errMsg)
          return callback(errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD'))
        }
      }

      // Determinate the record sequence number
      let seqNumber = 0
      if (record && record.sequence !== undefined) {
        seqNumber = record.value.toString() !== value ? record.sequence + 1 : record.sequence
      }

      // Create record
      ipns.create(privKey, value, seqNumber, validity, (err, entryData) => {
        if (err) {
          const errMsg = `ipns record for ${value} could not be created`

          log.error(errMsg)
          return callback(errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD'))
        }

        // TODO IMPROVEMENT - set ttl (still experimental feature for go)

        // Marshal record
        const data = ipns.marshal(entryData)

        // Store the new record
        this._datastore.put(ipns.getLocalKey(peerId.id), data, (err, res) => {
          if (err) {
            const errMsg = `ipns record for ${value} could not be stored in the datastore`

            log.error(errMsg)
            return callback(errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE'))
          }

          log(`ipns record for ${value} was stored in the datastore`)
          callback(null, entryData)
        })
      })
    })
  }
}

exports = module.exports = IpnsPublisher

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/publisher.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/republisher.js", {"../../../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","async/each":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipns":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/index.js","libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/republisher.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const ipns = require('ipns')
const crypto = require('libp2p-crypto')
const PeerId = require('peer-id')
const errcode = require('err-code')

const debug = require('debug')
const each = require('async/each')
const waterfall = require('async/waterfall')
const log = debug('ipfs:ipns:republisher')
log.error = debug('ipfs:ipns:republisher:error')

const minute = 60 * 1000
const hour = 60 * minute

const defaultBroadcastInterval = 4 * hour
const defaultRecordLifetime = 24 * hour

class IpnsRepublisher {
  constructor (publisher, datastore, peerInfo, keychain, options) {
    this._publisher = publisher
    this._datastore = datastore
    this._peerInfo = peerInfo
    this._keychain = keychain
    this._options = options
    this._republishHandle = null
  }

  start () {
    if (this._republishHandle) {
      const errMsg = 'already running'

      log.error(errMsg)
      throw errcode(new Error(errMsg), 'ERR_REPUBLISH_ALREADY_RUNNING')
    }

    // TODO: this handler should be isolated in another module
    const republishHandle = {
      _onCancel: null,
      _timeoutId: null,
      runPeriodically: (fn, period) => {
        republishHandle._timeoutId = setTimeout(() => {
          republishHandle._timeoutId = null

          fn((nextPeriod) => {
            // Was republish cancelled while fn was being called?
            if (republishHandle._onCancel) {
              return republishHandle._onCancel()
            }
            // Schedule next
            republishHandle.runPeriodically(fn, nextPeriod || period)
          })
        }, period)
      },
      cancel: (cb) => {
        // Not currently running a republish, can callback immediately
        if (republishHandle._timeoutId) {
          clearTimeout(republishHandle._timeoutId)
          return cb()
        }
        // Wait for republish to finish then call callback
        republishHandle._onCancel = cb
      }
    }

    const { privKey } = this._peerInfo.id
    const { pass } = this._options

    republishHandle.runPeriodically((done) => {
      this._republishEntries(privKey, pass, () => done(defaultBroadcastInterval))
    }, minute)

    this._republishHandle = republishHandle
  }

  stop (callback) {
    const republishHandle = this._republishHandle

    if (!republishHandle) {
      const errMsg = 'not running'

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_REPUBLISH_NOT_RUNNING'))
    }

    this._republishHandle = null
    republishHandle.cancel(callback)
  }

  _republishEntries (privateKey, pass, callback) {
    // TODO: Should use list of published entries.
    // We can't currently *do* that because go uses this method for now.
    this._republishEntry(privateKey, (err) => {
      if (err) {
        const errMsg = 'cannot republish entry for the node\'s private key'

        log.error(errMsg)
        return
      }

      // keychain needs pass to get the cryptographic keys
      if (pass) {
        this._keychain.listKeys((err, list) => {
          if (err) {
            log.error(err)
            return
          }

          each(list, (key, cb) => {
            waterfall([
              (cb) => this._keychain.exportKey(key.name, pass, cb),
              (pem, cb) => crypto.keys.__import__(pem, pass, cb)
            ], (err, privKey) => {
              if (err) {
                log.error(err)
                return
              }

              this._republishEntry(privKey, cb)
            })
          }, (err) => {
            if (err) {
              log.error(err)
            }
            callback(null)
          })
        })
      } else {
        callback(null)
      }
    })
  }

  _republishEntry (privateKey, callback) {
    if (!privateKey || !privateKey.bytes) {
      const errMsg = `one or more of the provided parameters are not defined`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER'))
    }

    waterfall([
      (cb) => PeerId.createFromPrivKey(privateKey.bytes, cb),
      (peerId, cb) => this._getPreviousValue(peerId, cb)
    ], (err, value) => {
      if (err) {
        return callback(err.code === 'ERR_NO_ENTRY_FOUND' ? null : err)
      }

      this._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime, callback)
    })
  }

  _getPreviousValue (peerId, callback) {
    if (!(PeerId.isPeerId(peerId))) {
      const errMsg = `peerId received is not valid`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'))
    }

    this._datastore.get(ipns.getLocalKey(peerId.id), (err, dsVal) => {
      // error handling
      // no need to republish
      if (err && err.notFound) {
        const errMsg = `no previous entry for record with id: ${peerId.id}`

        log.error(errMsg)
        return callback(errcode(new Error(errMsg), 'ERR_NO_ENTRY_FOUND'))
      } else if (err) {
        return callback(err)
      }

      if (!Buffer.isBuffer(dsVal)) {
        const errMsg = `found ipns record that we couldn't process`

        log.error(errMsg)
        return callback(errcode(new Error(errMsg), 'ERR_INVALID_IPNS_RECORD'))
      }

      // unmarshal data
      let record
      try {
        record = ipns.unmarshal(dsVal)
      } catch (err) {
        const errMsg = `found ipns record that we couldn't convert to a value`

        log.error(errMsg)
        return callback(errcode(new Error(errMsg), 'ERR_INVALID_IPNS_RECORD'))
      }

      callback(null, record.value)
    })
  }
}

exports = module.exports = IpnsRepublisher

}).call(this)}).call(this,{"isBuffer":require("../../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/republisher.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/notifications.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/constants.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/utils.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/notifications.js
      return function (require, module, exports) {
'use strict'

const EventEmitter = require('events').EventEmitter

const CONSTANTS = require('./constants')
const logger = require('./utils').logger

const unwantEvent = (c) => `unwant:${c}`
const blockEvent = (c) => `block:${c}`

/**
 * Internal module used to track events about incoming blocks,
 * wants and unwants.
 *
 * @param {PeerId} peerId
 * @private
 */
class Notifications extends EventEmitter {
  constructor (peerId) {
    super()

    this.setMaxListeners(CONSTANTS.maxListeners)

    this._log = logger(peerId, 'notif')

    this._unwantListeners = {}
    this._blockListeners = {}
  }

  /**
   * Signal the system that we received `block`.
   *
   * @param {Block} block
   * @return {void}
   */
  hasBlock (block) {
    const str = `block:${block.cid.buffer.toString()}`
    this._log(str)
    this.emit(str, block)
  }

  /**
   * Signal the system that we are waiting to receive the
   * block associated with the given `cid`.
   *
   * @param {CID} cid
   * @param {function(Block)} onBlock - called when the block is received
   * @param {function()} onUnwant - called when the block is unwanted
   * @returns {void}
   */
  wantBlock (cid, onBlock, onUnwant) {
    const cidStr = cid.buffer.toString()
    this._log(`wantBlock:${cidStr}`)

    this._unwantListeners[cidStr] = () => {
      this._log(`manual unwant: ${cidStr}`)
      this._cleanup(cidStr)
      onUnwant()
    }

    this._blockListeners[cidStr] = (block) => {
      this._cleanup(cidStr)
      onBlock(block)
    }

    this.once(
      unwantEvent(cidStr),
      this._unwantListeners[cidStr]
    )
    this.once(
      blockEvent(cidStr),
      this._blockListeners[cidStr]
    )
  }

  /**
   * Signal that the block is not wanted anymore.
   *
   * @param {CID} cid - the CID of the block that is not wanted anymore.
   * @returns {void}
   */
  unwantBlock (cid) {
    const str = `unwant:${cid.buffer.toString()}`
    this._log(str)
    this.emit(str)
  }

  /**
   * Internal method to clean up once a block was received or unwanted.
   *
   * @private
   * @param  {string} cidStr
   * @returns {void}
   */
  _cleanup (cidStr) {
    if (this._unwantListeners[cidStr]) {
      this.removeListener(
        unwantEvent(cidStr),
        this._unwantListeners[cidStr]
      )
      delete this._unwantListeners[cidStr]
    }

    if (this._blockListeners[cidStr]) {
      this.removeListener(
        blockEvent(cidStr),
        this._blockListeners[cidStr]
      )
      delete this._blockListeners[cidStr]
    }
  }
}

module.exports = Notifications

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/notifications.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/utils.js", {"debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/utils.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')

/**
 * Creates a logger for the given subsystem
 *
 * @param {PeerId} [id]
 * @param {string} [subsystem]
 * @returns {debug}
 *
 * @private
 */
const logger = (id, subsystem) => {
  const name = ['bitswap']
  if (subsystem) {
    name.push(subsystem)
  }
  if (id) {
    name.push(`${id.toB58String().slice(0, 8)}`)
  }
  const logger = debug(name.join(':'))
  logger.error = debug(name.concat(['error']).join(':'))

  return logger
}

const includesWith = (pred, x, list) => {
  let idx = 0
  const len = list.length
  while (idx < len) {
    if (pred(x, list[idx])) {
      return true
    }
    idx += 1
  }
  return false
}

const uniqWith = (pred, list) => {
  let idx = 0
  const len = list.length
  const result = []
  let item

  while (idx < len) {
    item = list[idx]
    if (!includesWith(pred, item, result)) {
      result[result.length] = item
    }
    idx += 1
  }
  return result
}

const groupBy = (pred, list) => {
  return list.reduce((acc, v) => {
    const k = pred(v)

    if (acc[k]) {
      acc[k].push(v)
    } else {
      acc[k] = [v]
    }
    return acc
  }, {})
}

const pullAllWith = (pred, list, values) => {
  return list.filter(i => {
    return !includesWith(pred, i, values)
  })
}

const sortBy = (fn, list) => {
  return Array.prototype.slice.call(list, 0).sort((a, b) => {
    const aa = fn(a)
    const bb = fn(b)
    return aa < bb ? -1 : aa > bb ? 1 : 0
  })
}

module.exports = {
  logger,
  includesWith,
  uniqWith,
  groupBy,
  pullAllWith,
  sortBy
}

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/decision-engine/index.js", {"../types/message":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/index.js","../types/wantlist":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/wantlist/index.js","../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/utils.js","./ledger":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/decision-engine/ledger.js","async/each":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js","async/eachSeries":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/eachSeries.js","async/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/map.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","just-debounce-it":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/just-debounce-it/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/decision-engine/index.js
      return function (require, module, exports) {
'use strict'

const each = require('async/each')
const eachSeries = require('async/eachSeries')
const waterfall = require('async/waterfall')
const nextTick = require('async/nextTick')

const map = require('async/map')
const debounce = require('just-debounce-it')

const Message = require('../types/message')
const Wantlist = require('../types/wantlist')
const Ledger = require('./ledger')
const { logger, groupBy, pullAllWith, uniqWith } = require('../utils')

const MAX_MESSAGE_SIZE = 512 * 1024

class DecisionEngine {
  constructor (peerId, blockstore, network, stats) {
    this._log = logger(peerId, 'engine')
    this.blockstore = blockstore
    this.network = network
    this._stats = stats

    // A list of of ledgers by their partner id
    this.ledgerMap = new Map()
    this._running = false

    // List of tasks to be processed
    this._tasks = []

    this._outbox = debounce(this._processTasks.bind(this), 100)
  }

  _sendBlocks (peer, blocks, cb) {
    // split into messges of max 512 * 1024 bytes
    const total = blocks.reduce((acc, b) => {
      return acc + b.data.byteLength
    }, 0)

    if (total < MAX_MESSAGE_SIZE) {
      return this._sendSafeBlocks(peer, blocks, cb)
    }

    let size = 0
    let batch = []
    let outstanding = blocks.length

    eachSeries(blocks, (b, cb) => {
      outstanding--
      batch.push(b)
      size += b.data.byteLength

      if (size >= MAX_MESSAGE_SIZE ||
          // need to ensure the last remaining items get sent
          outstanding === 0) {
        size = 0
        const nextBatch = batch.slice()
        batch = []
        this._sendSafeBlocks(peer, nextBatch, (err) => {
          if (err) {
            this._log('sendblock error: %s', err.message)
          }
          // not returning the error, so we send as much as we can
          // as otherwise `eachSeries` would cancel
          cb()
        })
      } else {
        nextTick(cb)
      }
    }, cb)
  }

  _sendSafeBlocks (peer, blocks, cb) {
    const msg = new Message(false)
    blocks.forEach((b) => msg.addBlock(b))

    this.network.sendMessage(peer, msg, cb)
  }

  _processTasks () {
    if (!this._running || !this._tasks.length) {
      return
    }

    const tasks = this._tasks
    this._tasks = []
    const entries = tasks.map((t) => t.entry)
    const cids = entries.map((e) => e.cid)
    const uniqCids = uniqWith((a, b) => a.equals(b), cids)
    const groupedTasks = groupBy(task => task.target.toB58String(), tasks)

    waterfall([
      (callback) => map(uniqCids, (cid, cb) => {
        this.blockstore.get(cid, cb)
      }, callback),
      (blocks, callback) => each(Object.values(groupedTasks), (tasks, cb) => {
        // all tasks have the same target
        const peer = tasks[0].target
        const blockList = cids.map((cid) => {
          return blocks.find(b => b.cid.equals(cid))
        })

        this._sendBlocks(peer, blockList, (err) => {
          if (err) {
            // `_sendBlocks` actually doesn't return any errors
            this._log.error('should never happen: ', err)
          } else {
            blockList.forEach((block) => this.messageSent(peer, block))
          }

          cb()
        })
      }, callback)
    ], (err) => {
      this._tasks = []

      if (err) {
        this._log.error(err)
      }
    })
  }

  wantlistForPeer (peerId) {
    const peerIdStr = peerId.toB58String()
    if (!this.ledgerMap.has(peerIdStr)) {
      return new Map()
    }

    return this.ledgerMap.get(peerIdStr).wantlist.sortedEntries()
  }

  ledgerForPeer (peerId) {
    const peerIdStr = peerId.toB58String()

    const ledger = this.ledgerMap.get(peerIdStr)
    if (!ledger) {
      return null
    }
    return {
      peer: ledger.partner.toPrint(),
      value: ledger.debtRatio(),
      sent: ledger.accounting.bytesSent,
      recv: ledger.accounting.bytesRecv,
      exchanged: ledger.exchangeCount
    }
  }

  peers () {
    return Array.from(this.ledgerMap.values()).map((l) => l.partner)
  }

  receivedBlocks (cids) {
    if (!cids.length) {
      return
    }
    // Check all connected peers if they want the block we received
    this.ledgerMap.forEach((ledger) => {
      cids
        .map((cid) => ledger.wantlistContains(cid))
        .filter(Boolean)
        .forEach((entry) => {
          this._tasks.push({
            entry: entry,
            target: ledger.partner
          })
        })
    })
    this._outbox()
  }

  // Handle incoming messages
  messageReceived (peerId, msg, cb) {
    const ledger = this._findOrCreate(peerId)

    if (msg.empty) {
      return nextTick(cb)
    }

    // If the message was a full wantlist clear the current one
    if (msg.full) {
      ledger.wantlist = new Wantlist()
    }

    this._processBlocks(msg.blocks, ledger)

    if (msg.wantlist.size === 0) {
      return nextTick(cb)
    }

    let cancels = []
    let wants = []
    msg.wantlist.forEach((entry) => {
      if (entry.cancel) {
        ledger.cancelWant(entry.cid)
        cancels.push(entry)
      } else {
        ledger.wants(entry.cid, entry.priority)
        wants.push(entry)
      }
    })

    this._cancelWants(ledger, peerId, cancels)
    this._addWants(ledger, peerId, wants, cb)
  }

  _cancelWants (ledger, peerId, entries) {
    const id = peerId.toB58String()

    this._tasks = pullAllWith((t, e) => {
      const sameTarget = t.target.toB58String() === id
      const sameCid = t.entry.cid.equals(e.cid)
      return sameTarget && sameCid
    }, this._tasks, entries)
  }

  _addWants (ledger, peerId, entries, callback) {
    each(entries, (entry, cb) => {
      // If we already have the block, serve it
      this.blockstore.has(entry.cid, (err, exists) => {
        if (err) {
          this._log.error('failed existence check')
        } else if (exists) {
          this._tasks.push({
            entry: entry.entry,
            target: peerId
          })
        }
        cb()
      })
    }, () => {
      this._outbox()
      callback()
    })
  }

  _processBlocks (blocks, ledger, callback) {
    const cids = []
    blocks.forEach((b, cidStr) => {
      this._log('got block (%s bytes)', b.data.length)
      ledger.receivedBytes(b.data.length)
      cids.push(b.cid)
    })

    this.receivedBlocks(cids)
  }

  // Clear up all accounting things after message was sent
  messageSent (peerId, block) {
    const ledger = this._findOrCreate(peerId)
    ledger.sentBytes(block ? block.data.length : 0)
    if (block && block.cid) {
      ledger.wantlist.remove(block.cid)
    }
  }

  numBytesSentTo (peerId) {
    return this._findOrCreate(peerId).accounting.bytesSent
  }

  numBytesReceivedFrom (peerId) {
    return this._findOrCreate(peerId).accounting.bytesRecv
  }

  peerDisconnected (peerId) {
    // if (this.ledgerMap.has(peerId.toB58String())) {
    //   this.ledgerMap.delete(peerId.toB58String())
    // }
    //
    // TODO: figure out how to remove all other references
    // in the peer request queue
  }

  _findOrCreate (peerId) {
    const peerIdStr = peerId.toB58String()
    if (this.ledgerMap.has(peerIdStr)) {
      return this.ledgerMap.get(peerIdStr)
    }

    const l = new Ledger(peerId)

    this.ledgerMap.set(peerIdStr, l)
    if (this._stats) {
      this._stats.push(peerIdStr, 'peerCount', 1)
    }

    return l
  }

  start (callback) {
    this._running = true
    nextTick(() => callback())
  }

  stop (callback) {
    this._running = false
    nextTick(() => callback())
  }
}

module.exports = DecisionEngine

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/decision-engine/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/stats/index.js", {"./stat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/stats/stat.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/stats/index.js
      return function (require, module, exports) {
'use strict'

const EventEmitter = require('events')
const Stat = require('./stat')

const defaultOptions = {
  movingAverageIntervals: [
    60 * 1000, // 1 minute
    5 * 60 * 1000, // 5 minutes
    15 * 60 * 1000 // 15 minutes
  ]
}

class Stats extends EventEmitter {
  constructor (initialCounters, _options) {
    super()

    const options = Object.assign({}, defaultOptions, _options)

    if (typeof options.computeThrottleTimeout !== 'number') {
      throw new Error('need computeThrottleTimeout')
    }

    if (typeof options.computeThrottleMaxQueueSize !== 'number') {
      throw new Error('need computeThrottleMaxQueueSize')
    }

    this._initialCounters = initialCounters
    this._options = options
    this._enabled = this._options.enabled

    this._global = new Stat(initialCounters, options)
    this._global.on('update', (stats) => this.emit('update', stats))

    this._peers = new Map()
  }

  enable () {
    this._enabled = true
    this._options.enabled = true
    this._global.enable()
  }

  disable () {
    this._enabled = false
    this._options.enabled = false
    this._global.disable()
  }

  stop () {
    this._enabled = false
    this._global.stop()
    for (let peerStat of this._peers) {
      peerStat[1].stop()
    }
  }

  get snapshot () {
    return this._global.snapshot
  }

  get movingAverages () {
    return this._global.movingAverages
  }

  forPeer (peerId) {
    if (peerId.toB58String) {
      peerId = peerId.toB58String()
    }
    return this._peers.get(peerId)
  }

  push (peer, counter, inc) {
    if (this._enabled) {
      this._global.push(counter, inc)

      if (peer) {
        let peerStats = this._peers.get(peer)
        if (!peerStats) {
          peerStats = new Stat(this._initialCounters, this._options)
          this._peers.set(peer, peerStats)
        }

        peerStats.push(counter, inc)
      }
    }
  }

  disconnected (peer) {
    const peerId = peer.toB58String()
    const peerStats = this._peers.get(peerId)
    if (peerStats) {
      peerStats.stop()
      this._peers.delete(peerId)
    }
  }
}

module.exports = Stats

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/stats/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/want-manager/index.js", {"../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/constants.js","../types/message":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/index.js","../types/wantlist":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/wantlist/index.js","../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/utils.js","./msg-queue":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/want-manager/msg-queue.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/want-manager/index.js
      return function (require, module, exports) {
'use strict'

const nextTick = require('async/nextTick')
const Message = require('../types/message')
const Wantlist = require('../types/wantlist')
const CONSTANTS = require('../constants')
const MsgQueue = require('./msg-queue')
const logger = require('../utils').logger

module.exports = class WantManager {
  constructor (peerId, network, stats) {
    this.peers = new Map()
    this.wantlist = new Wantlist(stats)

    this.network = network
    this._stats = stats

    this._peerId = peerId
    this._log = logger(peerId, 'want')
  }

  _addEntries (cids, cancel, force) {
    const entries = cids.map((cid, i) => {
      return new Message.Entry(cid, CONSTANTS.kMaxPriority - i, cancel)
    })

    entries.forEach((e) => {
      // add changes to our wantlist
      if (e.cancel) {
        if (force) {
          this.wantlist.removeForce(e.cid)
        } else {
          this.wantlist.remove(e.cid)
        }
      } else {
        this._log('adding to wl')
        this.wantlist.add(e.cid, e.priority)
      }
    })

    // broadcast changes
    for (let p of this.peers.values()) {
      p.addEntries(entries)
    }
  }

  _startPeerHandler (peerId) {
    let mq = this.peers.get(peerId.toB58String())

    if (mq) {
      mq.refcnt++
      return
    }

    mq = new MsgQueue(this._peerId, peerId, this.network)

    // new peer, give them the full wantlist
    const fullwantlist = new Message(true)

    for (let entry of this.wantlist.entries()) {
      fullwantlist.addEntry(entry[1].cid, entry[1].priority)
    }

    mq.addMessage(fullwantlist)

    this.peers.set(peerId.toB58String(), mq)
    return mq
  }

  _stopPeerHandler (peerId) {
    const mq = this.peers.get(peerId.toB58String())

    if (!mq) {
      return
    }

    mq.refcnt--
    if (mq.refcnt > 0) {
      return
    }

    this.peers.delete(peerId.toB58String())
  }

  // add all the cids to the wantlist
  wantBlocks (cids) {
    this._addEntries(cids, false)
  }

  // remove blocks of all the given keys without respecting refcounts
  unwantBlocks (cids) {
    this._log('unwant blocks: %s', cids.length)
    this._addEntries(cids, true, true)
  }

  // cancel wanting all of the given keys
  cancelWants (cids) {
    this._log('cancel wants: %s', cids.length)
    this._addEntries(cids, true)
  }

  // Returns a list of all currently connected peers
  connectedPeers () {
    return Array.from(this.peers.keys())
  }

  connected (peerId) {
    this._startPeerHandler(peerId)
  }

  disconnected (peerId) {
    this._stopPeerHandler(peerId)
  }

  start (callback) {
    // resend entire wantlist every so often
    this.timer = setInterval(() => {
      this._log('resend full-wantlist')
      const fullwantlist = new Message(true)
      this.wantlist.forEach((entry) => {
        fullwantlist.addEntry(entry.cid, entry.priority)
      })

      this.peers.forEach((p) => p.addMessage(fullwantlist))
    }, 60 * 1000)

    nextTick(() => callback())
  }

  stop (callback) {
    this.peers.forEach((mq) => this.disconnected(mq.peerId))

    clearInterval(this.timer)
    nextTick(() => callback())
  }
}

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/want-manager/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/network.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/constants.js","./types/message":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/index.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/utils.js","async/each":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","pull-length-prefixed":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/network.js
      return function (require, module, exports) {
'use strict'

const lp = require('pull-length-prefixed')
const pull = require('pull-stream')
const waterfall = require('async/waterfall')
const each = require('async/each')
const nextTick = require('async/nextTick')

const Message = require('./types/message')
const CONSTANTS = require('./constants')
const logger = require('./utils').logger

const BITSWAP100 = '/ipfs/bitswap/1.0.0'
const BITSWAP110 = '/ipfs/bitswap/1.1.0'

class Network {
  constructor (libp2p, bitswap, options, stats) {
    this._log = logger(libp2p.peerInfo.id, 'network')
    options = options || {}
    this.libp2p = libp2p
    this.bitswap = bitswap
    this.b100Only = options.b100Only || false

    this._stats = stats
    this._running = false
  }

  start (callback) {
    this._running = true
    // bind event listeners
    this._onPeerConnect = this._onPeerConnect.bind(this)
    this._onPeerDisconnect = this._onPeerDisconnect.bind(this)

    this._onConnection = this._onConnection.bind(this)
    this.libp2p.handle(BITSWAP100, this._onConnection)
    if (!this.b100Only) { this.libp2p.handle(BITSWAP110, this._onConnection) }

    this.libp2p.on('peer:connect', this._onPeerConnect)
    this.libp2p.on('peer:disconnect', this._onPeerDisconnect)

    // All existing connections are like new ones for us
    this.libp2p.peerBook
      .getAllArray()
      .filter((peer) => peer.isConnected())
      .forEach((peer) => this._onPeerConnect((peer)))

    nextTick(() => callback())
  }

  stop (callback) {
    this._running = false

    this.libp2p.unhandle(BITSWAP100)
    if (!this.b100Only) { this.libp2p.unhandle(BITSWAP110) }

    this.libp2p.removeListener('peer:connect', this._onPeerConnect)
    this.libp2p.removeListener('peer:disconnect', this._onPeerDisconnect)

    nextTick(() => callback())
  }

  // Handles both types of bitswap messgages
  _onConnection (protocol, conn) {
    if (!this._running) { return }
    this._log('incomming new bitswap connection: %s', protocol)

    pull(
      conn,
      lp.decode(),
      pull.asyncMap((data, cb) => Message.deserialize(data, cb)),
      pull.asyncMap((msg, cb) => {
        conn.getPeerInfo((err, peerInfo) => {
          if (err) { return cb(err) }

          // this._log('data from', peerInfo.id.toB58String())
          this.bitswap._receiveMessage(peerInfo.id, msg, cb)
        })
      }),
      pull.onEnd((err) => {
        this._log('ending connection')
        if (err) {
          this.bitswap._receiveError(err)
        }
      })
    )
  }

  _onPeerConnect (peerInfo) {
    if (!this._running) { return }

    this.bitswap._onPeerConnected(peerInfo.id)
  }

  _onPeerDisconnect (peerInfo) {
    if (!this._running) { return }

    this.bitswap._onPeerDisconnected(peerInfo.id)
  }

  findProviders (cid, maxProviders, callback) {
    this.libp2p.contentRouting.findProviders(cid, {
      maxTimeout: CONSTANTS.providerRequestTimeout,
      maxNumProviders: maxProviders
    }, callback)
  }

  findAndConnect (cid, callback) {
    waterfall([
      (cb) => this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, cb),
      (provs, cb) => {
        this._log('connecting to providers', provs.map((p) => p.id.toB58String()))
        each(provs, (p, cb) => this.connectTo(p, cb))
      }
    ], callback)
  }

  provide (cid, callback) {
    this.libp2p.contentRouting.provide(cid, callback)
  }

  // Connect to the given peer
  // Send the given msg (instance of Message) to the given peer
  sendMessage (peer, msg, callback) {
    if (!this._running) { return callback(new Error(`network isn't running`)) }

    const stringId = peer.toB58String() ? peer.toB58String() : peer.id.toB58String()
    this._log('sendMessage to %s', stringId, msg)

    this._dialPeer(peer, (err, conn, protocol) => {
      if (err) {
        return callback(err)
      }

      let serialized
      switch (protocol) {
        case BITSWAP100:
          serialized = msg.serializeToBitswap100()
          break
        case BITSWAP110:
          serialized = msg.serializeToBitswap110()
          break
        default:
          return callback(new Error('Unkown protocol: ' + protocol))
      }
      // TODO: why doesn't the error get propageted back??
      writeMessage(conn, serialized, (err) => {
        if (err) {
          this._log.error(err)
        }
      })
      callback()
      this._updateSentStats(peer, msg.blocks)
    })
  }

  connectTo (peer, callback) {
    if (!this._running) { return callback(new Error(`network isn't running`)) }

    this.libp2p.dial(peer, callback)
  }

  // Dial to the peer and try to use the most recent Bitswap
  _dialPeer (peer, callback) {
    // Attempt Bitswap 1.1.0
    this.libp2p.dialProtocol(peer, BITSWAP110, (err, conn) => {
      if (err) {
        // Attempt Bitswap 1.0.0
        this.libp2p.dialProtocol(peer, BITSWAP100, (err, conn) => {
          if (err) { return callback(err) }

          callback(null, conn, BITSWAP100)
        })

        return
      }

      callback(null, conn, BITSWAP110)
    })
  }

  _updateSentStats (peer, blocks) {
    const peerId = peer.toB58String()
    if (this._stats) {
      blocks.forEach((block) => this._stats.push(peerId, 'dataSent', block.data.length))
      this._stats.push(peerId, 'blocksSent', blocks.size)
    }
  }
}

function writeMessage (conn, msg, callback) {
  pull(
    pull.values([msg]),
    lp.encode(),
    conn,
    pull.onEnd(callback)
  )
}

module.exports = Network

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/network.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/index.js", {"./record":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/record.js","./selection":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/selection.js","./validator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/validator.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/index.js
      return function (require, module, exports) {
'use strict'

module.exports = {
  Record: require('./record'),
  validator: require('./validator'),
  selection: require('./selection')
}

      };
    };
  }
}, {package:"libp2p-record",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/index.js", {"./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/errors.js","./pb/ipns.proto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/pb/ipns.proto.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/utils.js","base32-encode":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base32-encode/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js","libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","timestamp-nano":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/timestamp-nano/timestamp.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const base32Encode = require('base32-encode')
const NanoDate = require('timestamp-nano')
const { Key } = require('interface-datastore')
const crypto = require('libp2p-crypto')
const PeerId = require('peer-id')
const multihash = require('multihashes')

const debug = require('debug')
const log = debug('jsipns')
log.error = debug('jsipns:error')

const ipnsEntryProto = require('./pb/ipns.proto')
const { parseRFC3339 } = require('./utils')
const ERRORS = require('./errors')

const ID_MULTIHASH_CODE = multihash.names.id

const namespace = '/ipns/'

/**
 * Creates a new ipns entry and signs it with the given private key.
 * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.
 * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.
 *
 * @param {Object} privateKey private key for signing the record.
 * @param {string} value value to be stored in the record.
 * @param {number} seq number representing the current version of the record.
 * @param {number|string} lifetime lifetime of the record (in milliseconds).
 * @param {function(Error, entry)} [callback]
 */
const create = (privateKey, value, seq, lifetime, callback) => {
  // Validity in ISOString with nanoseconds precision and validity type EOL
  const isoValidity = new NanoDate(Date.now() + Number(lifetime)).toString()
  const validityType = ipnsEntryProto.ValidityType.EOL
  _create(privateKey, value, seq, isoValidity, validityType, callback)
}

/**
 * Same as create(), but instead of generating a new Date, it receives the intended expiration time
 * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.
 * @param {Object} privateKey private key for signing the record.
 * @param {string} value value to be stored in the record.
 * @param {number} seq number representing the current version of the record.
 * @param {string} expiration expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.
 * @param {function(Error, entry)} [callback]
 */
const createWithExpiration = (privateKey, value, seq, expiration, callback) => {
  const validityType = ipnsEntryProto.ValidityType.EOL
  _create(privateKey, value, seq, expiration, validityType, callback)
}

const _create = (privateKey, value, seq, isoValidity, validityType, callback) => {
  sign(privateKey, value, validityType, isoValidity, (error, signature) => {
    if (error) {
      log.error('record signature creation failed')
      return callback(Object.assign(new Error('record signature verification failed'), { code: ERRORS.ERR_SIGNATURE_CREATION }))
    }

    const entry = {
      value: value,
      signature: signature,
      validityType: validityType,
      validity: isoValidity,
      sequence: seq
    }

    log(`ipns entry for ${value} created`)
    return callback(null, entry)
  })
}

/**
 * Validates the given ipns entry against the given public key.
 *
 * @param {Object} publicKey public key for validating the record.
 * @param {Object} entry ipns entry record.
 * @param {function(Error)} [callback]
 */
const validate = (publicKey, entry, callback) => {
  const { value, validityType, validity } = entry
  const dataForSignature = ipnsEntryDataForSig(value, validityType, validity)

  // Validate Signature
  publicKey.verify(dataForSignature, entry.signature, (err, isValid) => {
    if (err || !isValid) {
      log.error('record signature verification failed')
      return callback(Object.assign(new Error('record signature verification failed'), { code: ERRORS.ERR_SIGNATURE_VERIFICATION }))
    }

    // Validate according to the validity type
    if (validityType === ipnsEntryProto.ValidityType.EOL) {
      let validityDate

      try {
        validityDate = parseRFC3339(validity.toString())
      } catch (e) {
        log.error('unrecognized validity format (not an rfc3339 format)')
        return callback(Object.assign(new Error('unrecognized validity format (not an rfc3339 format)'), { code: ERRORS.ERR_UNRECOGNIZED_FORMAT }))
      }

      if (validityDate < Date.now()) {
        log.error('record has expired')
        return callback(Object.assign(new Error('record has expired'), { code: ERRORS.ERR_IPNS_EXPIRED_RECORD }))
      }
    } else if (validityType) {
      log.error('unrecognized validity type')
      return callback(Object.assign(new Error('unrecognized validity type'), { code: ERRORS.ERR_UNRECOGNIZED_VALIDITY }))
    }

    log(`ipns entry for ${value} is valid`)
    return callback(null, null)
  })
}

/**
 * Embed the given public key in the given entry. While not strictly required,
 * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their
 * public keys as they may not be able to validate them efficiently.
 * As a consequence of nodes needing to validade a record upon receipt, they need
 * the public key associated with it. For olde RSA keys, it is easier if we just
 * send this as part of the record itself. For newer ed25519 keys, the public key
 * can be embedded in the peerId.
 *
 * @param {Object} publicKey public key to embed.
 * @param {Object} entry ipns entry record.
 * @param {function(Error)} [callback]
 * @return {Void}
 */
const embedPublicKey = (publicKey, entry, callback) => {
  if (!publicKey || !publicKey.bytes || !entry) {
    const error = 'one or more of the provided parameters are not defined'

    log.error(error)
    return callback(Object.assign(new Error(error), { code: ERRORS.ERR_UNDEFINED_PARAMETER }))
  }

  // Create a peer id from the public key.
  PeerId.createFromPubKey(publicKey.bytes, (err, peerId) => {
    if (err) {
      log.error(err)
      return callback(Object.assign(new Error(err), { code: ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY }))
    }

    // Try to extract the public key from the ID. If we can, no need to embed it
    let extractedPublicKey
    try {
      extractedPublicKey = extractPublicKeyFromId(peerId)
    } catch (err) {
      log.error(err)
      return callback(Object.assign(new Error(err), { code: ERRORS.ERR_PUBLIC_KEY_FROM_ID }))
    }

    if (extractedPublicKey) {
      return callback(null, null)
    }

    // If we failed to extract the public key from the peer ID, embed it in the record.
    try {
      entry.pubKey = crypto.keys.marshalPublicKey(publicKey)
    } catch (err) {
      log.error(err)
      return callback(err)
    }
    callback(null, entry)
  })
}

/**
 * Extracts a public key matching `pid` from the ipns record.
 *
 * @param {Object} peerId peer identifier object.
 * @param {Object} entry ipns entry record.
 * @param {function(Error)} [callback]
 * @return {Void}
 */
const extractPublicKey = (peerId, entry, callback) => {
  if (!entry || !peerId) {
    const error = 'one or more of the provided parameters are not defined'

    log.error(error)
    return callback(Object.assign(new Error(error), { code: ERRORS.ERR_UNDEFINED_PARAMETER }))
  }

  if (entry.pubKey) {
    let pubKey
    try {
      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey)
    } catch (err) {
      log.error(err)
      return callback(err)
    }
    return callback(null, pubKey)
  }

  if (peerId.pubKey) {
    callback(null, peerId.pubKey)
  } else {
    callback(Object.assign(new Error('no public key is available'), { code: ERRORS.ERR_UNDEFINED_PARAMETER }))
  }
}

// rawStdEncoding with RFC4648
const rawStdEncoding = (key) => base32Encode(key, 'RFC4648', { padding: false })

/**
 * Get key for storing the record locally.
 * Format: /ipns/${base32(<HASH>)}
 *
 * @param {Buffer} key peer identifier object.
 * @returns {string}
 */
const getLocalKey = (key) => new Key(`/ipns/${rawStdEncoding(key)}`)

/**
 * Get key for sharing the record in the routing mechanism.
 * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}
 *
 * @param {Buffer} pid peer identifier represented by the multihash of the public key as Buffer.
 * @returns {Object} containing the `nameKey` and the `ipnsKey`.
 */
const getIdKeys = (pid) => {
  const pkBuffer = Buffer.from('/pk/')
  const ipnsBuffer = Buffer.from('/ipns/')

  return {
    routingPubKey: new Key(Buffer.concat([pkBuffer, pid])), // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)
    pkKey: new Key(rawStdEncoding(Buffer.concat([pkBuffer, pid]))),
    routingKey: new Key(Buffer.concat([ipnsBuffer, pid])), // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)
    ipnsKey: new Key(rawStdEncoding(Buffer.concat([ipnsBuffer, pid])))
  }
}

// Sign ipns record data
const sign = (privateKey, value, validityType, validity, callback) => {
  const dataForSignature = ipnsEntryDataForSig(value, validityType, validity)

  privateKey.sign(dataForSignature, (err, signature) => {
    if (err) {
      return callback(err)
    }
    return callback(null, signature)
  })
}

// Utility for getting the validity type code name of a validity
const getValidityType = (validityType) => {
  if (validityType.toString() === '0') {
    return 'EOL'
  } else {
    const error = `unrecognized validity type ${validityType.toString()}`
    log.error(error)
    throw Object.assign(new Error(error), { code: ERRORS.ERR_UNRECOGNIZED_VALIDITY })
  }
}

// Utility for creating the record data for being signed
const ipnsEntryDataForSig = (value, validityType, validity) => {
  const valueBuffer = Buffer.from(value)
  const validityTypeBuffer = Buffer.from(getValidityType(validityType))
  const validityBuffer = Buffer.from(validity)

  return Buffer.concat([valueBuffer, validityBuffer, validityTypeBuffer])
}

// Utility for extracting the public key from a peer-id
const extractPublicKeyFromId = (peerId) => {
  const decodedId = multihash.decode(peerId.id)

  if (decodedId.code !== ID_MULTIHASH_CODE) {
    return null
  }

  return crypto.keys.unmarshalPublicKey(decodedId.digest)
}

const marshal = ipnsEntryProto.encode

const unmarshal = ipnsEntryProto.decode

const validator = {
  validate: (marshalledData, key, callback) => {
    const receivedEntry = unmarshal(marshalledData)
    const bufferId = key.slice('/ipns/'.length)
    let peerId

    try {
      peerId = PeerId.createFromBytes(bufferId)
    } catch (err) {
      return callback(err)
    }

    // extract public key
    extractPublicKey(peerId, receivedEntry, (err, pubKey) => {
      if (err) {
        return callback(err)
      }

      // Record validation
      validate(pubKey, receivedEntry, (err) => {
        if (err) {
          return callback(err)
        }

        callback(null, true)
      })
    })
  },
  select: (dataA, dataB, callback) => {
    const entryA = unmarshal(dataA)
    const entryB = unmarshal(dataB)

    const index = entryA.sequence > entryB.sequence ? 0 : 1

    if (typeof callback !== 'function') {
      return index
    }

    callback(null, index)
  }
}

module.exports = {
  // create ipns entry record
  create,
  // create ipns entry record specifying the expiration time
  createWithExpiration,
  // validate ipns entry record
  validate,
  // embed public key in the record
  embedPublicKey,
  // extract public key from the record
  extractPublicKey,
  // get key for storing the entry locally
  getLocalKey,
  // get keys for routing
  getIdKeys,
  // marshal
  marshal,
  // unmarshal
  unmarshal,
  // validator
  validator,
  // namespace
  namespace,
  namespaceLength: namespace.length
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipns",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-bootstrap/src/index.js", {"async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","mafmt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mafmt/src/index.js","multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-bootstrap/src/index.js
      return function (require, module, exports) {
'use strict'

const PeerId = require('peer-id')
const PeerInfo = require('peer-info')
const multiaddr = require('multiaddr')
const mafmt = require('mafmt')
const EventEmitter = require('events').EventEmitter
const debug = require('debug')
const nextTick = require('async/nextTick')

const log = debug('libp2p:bootstrap')
log.error = debug('libp2p:bootstrap:error')

function isIPFS (addr) {
  try {
    return mafmt.IPFS.matches(addr)
  } catch (e) {
    return false
  }
}

class Bootstrap extends EventEmitter {
  constructor (options) {
    super()
    this._list = options.list
    this._interval = options.interval || 10000
    this._timer = null
  }

  start (callback) {
    if (this._timer) {
      return nextTick(() => callback())
    }

    this._timer = setInterval(() => this._discoverBootstrapPeers(), this._interval)

    nextTick(() => {
      callback()
      this._discoverBootstrapPeers()
    })
  }

  _discoverBootstrapPeers () {
    this._list.forEach((candidate) => {
      if (!isIPFS(candidate)) { return log.error('Invalid multiaddr') }

      const ma = multiaddr(candidate)

      const peerId = PeerId.createFromB58String(ma.getPeerId())

      PeerInfo.create(peerId, (err, peerInfo) => {
        if (err) { return log.error('Invalid bootstrap peer id', err) }
        peerInfo.multiaddrs.add(ma)
        this.emit('peer', peerInfo)
      })
    })
  }

  stop (callback) {
    nextTick(callback)

    if (this._timer) {
      clearInterval(this._timer)
      this._timer = null
    }
  }
}

exports = module.exports = Bootstrap
exports.tag = 'bootstrap'

      };
    };
  }
}, {package:"libp2p-bootstrap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-bootstrap/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/index.js", {"./codec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/codec.js","./mplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/mplex.js","./muxer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/muxer.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","pull-abortable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-abortable/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/index.js
      return function (require, module, exports) {
'use strict'

const abortable = require('pull-abortable')
const pull = require('pull-stream')
const debug = require('debug')

const MULTIPLEX_CODEC = require('./codec')
const Mplex = require('./mplex')
const Muxer = require('./muxer')

const log = debug('pull-plex')
log.err = debug('pull-plex:err')

/**
 * Wraps `conn` with a `StreamMuxer` and returns the `StreamMuxer`
 * @param {Connection} conn An `interface-connection` compliant connection
 * @param {boolean} isListener Whether or not the muxer is the listener
 * @returns {StreamMuxer}
 */
function create (conn, isListener) {
  const mpx = new Mplex(!isListener)
  const aborter = abortable()

  pull(
    conn,
    mpx,
    aborter,
    conn
  )

  const muxer = new Muxer(conn, mpx)
  muxer.once('error', (err) => {
    log.err('got error', err)
    aborter.abort(err) // TODO: should we do the abort here or just ignore?
  })

  muxer.on('close', () => {
    log('closing muxer')
    aborter.abort()
  })

  return muxer
}

exports = module.exports = create
exports.pullMplex = Mplex
exports.multicodec = MULTIPLEX_CODEC
exports.dialer = (conn) => create(conn, false)
exports.listener = (conn) => create(conn, true)

      };
    };
  }
}, {package:"pull-mplex",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websockets/src/index.js", {"./listener":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websockets/src/listener.js","class-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","interface-connection":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/index.js","mafmt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mafmt/src/index.js","multiaddr-to-uri":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr-to-uri/index.js","pull-ws/client":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/client.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websockets/src/index.js
      return function (require, module, exports) {
'use strict'

const connect = require('pull-ws/client')
const mafmt = require('mafmt')
const withIs = require('class-is')
const Connection = require('interface-connection').Connection

const toUri = require('multiaddr-to-uri')
const debug = require('debug')
const log = debug('libp2p:websockets:dialer')

const createListener = require('./listener')

class WebSockets {
  dial (ma, options, callback) {
    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    callback = callback || function () { }

    const url = toUri(ma)
    log('dialing %s', url)
    const socket = connect(url, {
      binary: true,
      onConnect: (err) => {
        callback(err)
      }
    })

    const conn = new Connection(socket)
    conn.getObservedAddrs = (cb) => cb(null, [ma])
    conn.close = (cb) => socket.close(cb)

    return conn
  }

  createListener (options, handler) {
    if (typeof options === 'function') {
      handler = options
      options = {}
    }

    return createListener(options, handler)
  }

  filter (multiaddrs) {
    if (!Array.isArray(multiaddrs)) {
      multiaddrs = [multiaddrs]
    }

    return multiaddrs.filter((ma) => {
      if (ma.protoNames().includes('p2p-circuit')) {
        return false
      }

      if (ma.protoNames().includes('ipfs')) {
        ma = ma.decapsulate('ipfs')
      }

      return mafmt.WebSockets.matches(ma) ||
        mafmt.WebSocketsSecure.matches(ma)
    })
  }
}

module.exports = withIs(WebSockets, { className: 'WebSockets', symbolName: '@libp2p/js-libp2p-websockets/websockets' })

      };
    };
  }
}, {package:"libp2p-websockets",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websockets/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/index.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/constants.js","./message":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/message/index.js","./network":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/network.js","./private":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/private.js","./providers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/providers.js","./query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/index.js","./query-manager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query-manager.js","./random-walk":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/random-walk.js","./routing":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/routing.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","async/each":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js","async/filter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/filter.js","async/timeout":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/timeout.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js","libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js","libp2p-record":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js","promise-to-callback":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promise-to-callback/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/index.js
      return function (require, module, exports) {
'use strict'

const { EventEmitter } = require('events')
const libp2pRecord = require('libp2p-record')
const MemoryStore = require('interface-datastore').MemoryDatastore
const waterfall = require('async/waterfall')
const each = require('async/each')
const filter = require('async/filter')
const timeout = require('async/timeout')
const PeerId = require('peer-id')
const PeerInfo = require('peer-info')
const crypto = require('libp2p-crypto')
const promiseToCallback = require('promise-to-callback')

const errcode = require('err-code')

const RoutingTable = require('./routing')
const utils = require('./utils')
const c = require('./constants')
const Query = require('./query')
const Network = require('./network')
const privateApi = require('./private')
const Providers = require('./providers')
const Message = require('./message')
const RandomWalk = require('./random-walk')
const QueryManager = require('./query-manager')
const assert = require('assert')

/**
 * A DHT implementation modeled after Kademlia with S/Kademlia modifications.
 *
 * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.
 */
class KadDHT extends EventEmitter {
  /**
   * Random walk options
   *
   * @typedef {Object} randomWalkOptions
   * @property {boolean} enabled discovery enabled (default: true)
   * @property {number} queriesPerPeriod how many queries to run per period (default: 1)
   * @property {number} interval how often to run the the random-walk process, in milliseconds (default: 300000)
   * @property {number} timeout how long to wait for the the random-walk query to run, in milliseconds (default: 30000)
   * @property {number} delay how long to wait before starting the first random walk, in milliseconds (default: 10000)
   */

  /**
   * Create a new KadDHT.
   *
   * @param {Switch} sw libp2p-switch instance
   * @param {object} options DHT options
   * @param {number} options.kBucketSize k-bucket size (default 20)
   * @param {number} options.concurrency alpha concurrency of queries (default 3)
   * @param {Datastore} options.datastore datastore (default MemoryDatastore)
   * @param {object} options.validators validators object with namespace as keys and function(key, record, callback)
   * @param {object} options.selectors selectors object with namespace as keys and function(key, records)
   * @param {randomWalkOptions} options.randomWalk randomWalk options
   */
  constructor (sw, options) {
    super()
    assert(sw, 'libp2p-kad-dht requires a instance of Switch')
    options = options || {}
    options.validators = options.validators || {}
    options.selectors = options.selectors || {}

    /**
     * Local reference to the libp2p-switch instance
     *
     * @type {Switch}
     */
    this.switch = sw

    /**
     * k-bucket size, defaults to 20
     *
     * @type {number}
     */
    this.kBucketSize = options.kBucketSize || c.K

    /**
     * ALPHA concurrency at which each query path with run, defaults to 3
     * @type {number}
     */
    this.concurrency = options.concurrency || c.ALPHA

    /**
     * Number of disjoint query paths to use
     * This is set to `kBucketSize`/2 per the S/Kademlia paper
     * @type {number}
     */
    this.disjointPaths = Math.ceil(this.kBucketSize / 2)

    /**
     * The routing table.
     *
     * @type {RoutingTable}
     */
    this.routingTable = new RoutingTable(this.peerInfo.id, this.kBucketSize)

    /**
     * Reference to the datastore, uses an in-memory store if none given.
     *
     * @type {Datastore}
     */
    this.datastore = options.datastore || new MemoryStore()

    /**
     * Provider management
     *
     * @type {Providers}
     */
    this.providers = new Providers(this.datastore, this.peerInfo.id)

    this.validators = {
      pk: libp2pRecord.validator.validators.pk,
      ...options.validators
    }

    this.selectors = {
      pk: libp2pRecord.selection.selectors.pk,
      ...options.selectors
    }

    this.network = new Network(this)

    this._log = utils.logger(this.peerInfo.id)

    // Inject private apis so we don't clutter up this file
    const pa = privateApi(this)
    Object.keys(pa).forEach((name) => { this[name] = pa[name] })

    /**
     * Random walk management
     *
     * @type {RandomWalk}
     */
    this.randomWalk = new RandomWalk(this, options.randomWalk)

    /**
     * Keeps track of running queries
     *
     * @type {QueryManager}
     */
    this._queryManager = new QueryManager()
  }

  /**
   * Is this DHT running.
   *
   * @type {bool}
   */
  get isStarted () {
    return this._running
  }

  /**
   * Start listening to incoming connections.
   *
   * @param {function(Error)} callback
   * @returns {void}
   */
  start (callback) {
    this._running = true
    this._queryManager.start()
    this.network.start((err) => {
      if (err) {
        return callback(err)
      }

      // Start random walk, it will not run if it's disabled
      this.randomWalk.start()
      callback()
    })
  }

  /**
   * Stop accepting incoming connections and sending outgoing
   * messages.
   *
   * @param {function(Error)} callback
   * @returns {void}
   */
  stop (callback) {
    this._running = false
    this.randomWalk.stop()
    this.providers.stop()
    this._queryManager.stop()
    this.network.stop(callback)
  }

  /**
   * Local peer (yourself)
   *
   * @type {PeerInfo}
   */
  get peerInfo () {
    return this.switch._peerInfo
  }

  get peerBook () {
    return this.switch._peerBook
  }

  /**
   * Store the given key/value  pair in the DHT.
   *
   * @param {Buffer} key
   * @param {Buffer} value
   * @param {Object} options - get options
   * @param {number} options.minPeers - minimum peers that must be put to to consider this a successful operation
   * (default: closestPeers.length)
   * @param {function(Error)} callback
   * @returns {void}
   */
  put (key, value, options, callback) {
    if (typeof options === 'function') {
      callback = options
      options = {}
    } else {
      options = options || {}
    }

    this._log('PutValue %b', key)

    waterfall([
      (cb) => utils.createPutRecord(key, value, cb),
      (rec, cb) => waterfall([
        (cb) => this._putLocal(key, rec, cb),
        (cb) => this.getClosestPeers(key, { shallow: true }, cb),
        (peers, cb) => {
          // Ensure we have a default `minPeers`
          options.minPeers = options.minPeers || peers.length
          // filter out the successful puts
          filter(peers, (peer, cb) => {
            this._putValueToPeer(key, rec, peer, (err) => {
              if (err) {
                this._log.error('Failed to put to peer (%b): %s', peer.id, err)
                return cb(null, false)
              }
              cb(null, true)
            })
          }, (err, results) => {
            if (err) return cb(err)

            // Did we put to enough peers?
            if (options.minPeers > results.length) {
              const error = errcode(new Error('Failed to put value to enough peers'), 'ERR_NOT_ENOUGH_PUT_PEERS')
              this._log.error(error)
              return cb(error)
            }

            cb()
          })
        }
      ], cb)
    ], callback)
  }

  /**
   * Get the value to the given key.
   * Times out after 1 minute.
   *
   * @param {Buffer} key
   * @param {Object} options - get options
   * @param {number} options.timeout - optional timeout (default: 60000)
   * @param {function(Error, Buffer)} callback
   * @returns {void}
   */
  get (key, options, callback) {
    if (typeof options === 'function') {
      callback = options
      options = {}
    } else {
      options = options || {}
    }

    if (!options.maxTimeout && !options.timeout) {
      options.timeout = c.minute // default
    } else if (options.maxTimeout && !options.timeout) { // TODO this will be deprecated in a next release
      options.timeout = options.maxTimeout
    }

    this._get(key, options, callback)
  }

  /**
   * Get the `n` values to the given key without sorting.
   *
   * @param {Buffer} key
   * @param {number} nvals
   * @param {Object} options - get options
   * @param {number} options.timeout - optional timeout (default: 60000)
   * @param {function(Error, Array<{from: PeerId, val: Buffer}>)} callback
   * @returns {void}
   */
  getMany (key, nvals, options, callback) {
    if (typeof options === 'function') {
      callback = options
      options = {}
    } else {
      options = options || {}
    }

    if (!options.maxTimeout && !options.timeout) {
      options.timeout = c.minute // default
    } else if (options.maxTimeout && !options.timeout) { // TODO this will be deprecated in a next release
      options.timeout = options.maxTimeout
    }

    this._log('getMany %b (%s)', key, nvals)
    let vals = []

    this._getLocal(key, (err, localRec) => {
      if (err && nvals === 0) {
        return callback(err)
      }

      if (err == null) {
        vals.push({
          val: localRec.value,
          from: this.peerInfo.id
        })
      }

      if (vals.length >= nvals) {
        return callback(null, vals)
      }

      const paths = []
      waterfall([
        (cb) => utils.convertBuffer(key, cb),
        (id, cb) => {
          const rtp = this.routingTable.closestPeers(id, this.kBucketSize)

          this._log('peers in rt: %d', rtp.length)
          if (rtp.length === 0) {
            const errMsg = 'Failed to lookup key! No peers from routing table!'

            this._log.error(errMsg)
            return cb(errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE'))
          }

          // we have peers, lets do the actual query to them
          const query = new Query(this, key, (pathIndex, numPaths) => {
            // This function body runs once per disjoint path
            const pathSize = utils.pathSize(nvals - vals.length, numPaths)
            const pathVals = []
            paths.push(pathVals)

            // Here we return the query function to use on this particular disjoint path
            return async (peer) => {
              let rec, peers, lookupErr
              try {
                const results = await this._getValueOrPeersAsync(peer, key)
                rec = results.record
                peers = results.peers
              } catch (err) {
                // If we have an invalid record we just want to continue and fetch a new one.
                if (err.code !== 'ERR_INVALID_RECORD') {
                  throw err
                }
                lookupErr = err
              }

              const res = { closerPeers: peers }

              if ((rec && rec.value) || lookupErr) {
                pathVals.push({
                  val: rec && rec.value,
                  from: peer
                })
              }

              // enough is enough
              if (pathVals.length >= pathSize) {
                res.pathComplete = true
              }

              return res
            }
          })

          // run our query
          timeout((_cb) => {
            promiseToCallback(query.run(rtp))(_cb)
          }, options.timeout)((err, res) => {
            query.stop()
            cb(err, res)
          })
        }
      ], (err) => {
        // combine vals from each path
        vals = [].concat.apply(vals, paths).slice(0, nvals)

        if (err && vals.length === 0) {
          return callback(err)
        }

        callback(null, vals)
      })
    })
  }

  /**
   * Kademlia 'node lookup' operation.
   *
   * @param {Buffer} key
   * @param {Object} options
   * @param {boolean} options.shallow shallow query
   * @param {function(Error, Array<PeerId>)} callback
   * @returns {void}
   */
  getClosestPeers (key, options, callback) {
    this._log('getClosestPeers to %b', key)

    if (typeof options === 'function') {
      callback = options
      options = {
        shallow: false
      }
    }

    utils.convertBuffer(key, (err, id) => {
      if (err) {
        return callback(err)
      }

      const tablePeers = this.routingTable.closestPeers(id, this.kBucketSize)

      const q = new Query(this, key, () => {
        // There is no distinction between the disjoint paths,
        // so there are no per-path variables in this scope.
        // Just return the actual query function.
        return async (peer) => {
          const closer = await this._closerPeersSingleAsync(key, peer)
          return {
            closerPeers: closer,
            pathComplete: options.shallow ? true : undefined
          }
        }
      })

      promiseToCallback(q.run(tablePeers))((err, res) => {
        if (err) {
          return callback(err)
        }

        if (!res || !res.finalSet) {
          return callback(null, [])
        }

        waterfall([
          (cb) => utils.sortClosestPeers(Array.from(res.finalSet), id, cb),
          (sorted, cb) => cb(null, sorted.slice(0, this.kBucketSize))
        ], callback)
      })
    })
  }

  /**
   * Get the public key for the given peer id.
   *
   * @param {PeerId} peer
   * @param {function(Error, PubKey)} callback
   * @returns {void}
   */
  getPublicKey (peer, callback) {
    this._log('getPublicKey %s', peer.toB58String())
    // local check
    let info
    if (this.peerBook.has(peer)) {
      info = this.peerBook.get(peer)

      if (info && info.id.pubKey) {
        this._log('getPublicKey: found local copy')
        return callback(null, info.id.pubKey)
      }
    } else {
      info = this.peerBook.put(new PeerInfo(peer))
    }
    // try the node directly
    this._getPublicKeyFromNode(peer, (err, pk) => {
      if (!err) {
        info.id = new PeerId(peer.id, null, pk)
        this.peerBook.put(info)

        return callback(null, pk)
      }

      // dht directly
      const pkKey = utils.keyForPublicKey(peer)
      this.get(pkKey, (err, value) => {
        if (err) {
          return callback(err)
        }

        const pk = crypto.unmarshalPublicKey(value)
        info.id = new PeerId(peer, null, pk)
        this.peerBook.put(info)

        callback(null, pk)
      })
    })
  }

  /**
   * Look if we are connected to a peer with the given id.
   * Returns the `PeerInfo` for it, if found, otherwise `undefined`.
   *
   * @param {PeerId} peer
   * @param {function(Error, PeerInfo)} callback
   * @returns {void}
   */
  findPeerLocal (peer, callback) {
    this._log('findPeerLocal %s', peer.toB58String())
    this.routingTable.find(peer, (err, p) => {
      if (err) {
        return callback(err)
      }
      if (!p || !this.peerBook.has(p)) {
        return callback()
      }
      callback(null, this.peerBook.get(p))
    })
  }

  // ----------- Content Routing

  /**
   * Announce to the network that we can provide given key's value.
   *
   * @param {CID} key
   * @param {function(Error)} callback
   * @returns {void}
   */
  provide (key, callback) {
    this._log('provide: %s', key.toBaseEncodedString())

    const errors = []
    waterfall([
      // TODO: refactor this in method in async and remove this wrapper
      (cb) => promiseToCallback(this.providers.addProvider(key, this.peerInfo.id))(err => cb(err)),
      (cb) => this.getClosestPeers(key.buffer, cb),
      (peers, cb) => {
        const msg = new Message(Message.TYPES.ADD_PROVIDER, key.buffer, 0)
        msg.providerPeers = [this.peerInfo]

        each(peers, (peer, cb) => {
          this._log('putProvider %s to %s', key.toBaseEncodedString(), peer.toB58String())
          this.network.sendMessage(peer, msg, (err) => {
            if (err) errors.push(err)
            cb()
          })
        }, cb)
      }
    ], (err) => {
      if (errors.length) {
        // This should be infrequent. This means a peer we previously connected
        // to failed to exchange the provide message. If getClosestPeers was an
        // iterator, we could continue to pull until we announce to kBucketSize peers.
        err = errcode(`Failed to provide to ${errors.length} of ${this.kBucketSize} peers`, 'ERR_SOME_PROVIDES_FAILED', { errors })
      }
      callback(err)
    })
  }

  /**
   * Search the dht for up to `K` providers of the given CID.
   *
   * @param {CID} key
   * @param {Object} options - findProviders options
   * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)
   * @param {number} options.maxNumProviders - maximum number of providers to find
   * @param {function(Error, Array<PeerInfo>)} callback
   * @returns {void}
   */
  findProviders (key, options, callback) {
    if (typeof options === 'function') {
      callback = options
      options = {}
    } else {
      options = options || {}
    }

    if (!options.maxTimeout && !options.timeout) {
      options.timeout = c.minute // default
    } else if (options.maxTimeout && !options.timeout) { // TODO this will be deprecated in a next release
      options.timeout = options.maxTimeout
    }

    options.maxNumProviders = options.maxNumProviders || c.K

    this._log('findProviders %s', key.toBaseEncodedString())
    this._findNProviders(key, options.timeout, options.maxNumProviders, callback)
  }

  // ----------- Peer Routing

  /**
   * Search for a peer with the given ID.
   *
   * @param {PeerId} id
   * @param {Object} options - findPeer options
   * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)
   * @param {function(Error, PeerInfo)} callback
   * @returns {void}
   */
  findPeer (id, options, callback) {
    if (typeof options === 'function') {
      callback = options
      options = {}
    } else {
      options = options || {}
    }

    if (!options.maxTimeout && !options.timeout) {
      options.timeout = c.minute // default
    } else if (options.maxTimeout && !options.timeout) { // TODO this will be deprecated in a next release
      options.timeout = options.maxTimeout
    }

    this._log('findPeer %s', id.toB58String())

    this.findPeerLocal(id, (err, pi) => {
      if (err) {
        return callback(err)
      }

      // already got it
      if (pi != null) {
        this._log('found local')
        return callback(null, pi)
      }

      waterfall([
        (cb) => utils.convertPeerId(id, cb),
        (key, cb) => {
          const peers = this.routingTable.closestPeers(key, this.kBucketSize)

          if (peers.length === 0) {
            return cb(errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED'))
          }

          // sanity check
          const match = peers.find((p) => p.isEqual(id))
          if (match && this.peerBook.has(id)) {
            this._log('found in peerbook')
            return cb(null, this.peerBook.get(id))
          }

          // query the network
          const query = new Query(this, id.id, () => {
            // There is no distinction between the disjoint paths,
            // so there are no per-path variables in this scope.
            // Just return the actual query function.
            return async (peer) => {
              const msg = await this._findPeerSingleAsync(peer, id)
              const match = msg.closerPeers.find((p) => p.id.isEqual(id))

              // found it
              if (match) {
                return {
                  peer: match,
                  queryComplete: true
                }
              }

              return {
                closerPeers: msg.closerPeers
              }
            }
          })

          timeout((_cb) => {
            promiseToCallback(query.run(peers))(_cb)
          }, options.timeout)((err, res) => {
            query.stop()
            cb(err, res)
          })
        },
        (result, cb) => {
          let success = false
          result.paths.forEach((result) => {
            if (result.success) {
              success = true
              this.peerBook.put(result.peer)
            }
          })
          this._log('findPeer %s: %s', id.toB58String(), success)
          if (!success) {
            return cb(errcode(new Error('No peer found'), 'ERR_NOT_FOUND'))
          }
          cb(null, this.peerBook.get(id))
        }
      ], callback)
    })
  }

  _peerDiscovered (peerInfo) {
    this.emit('peer', peerInfo)
  }
}

module.exports = KadDHT

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/index.js", {"./handshake":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/index.js","./state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/state.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","interface-connection":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/index.js","once":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/once/once.js","peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/index.js
      return function (require, module, exports) {
'use strict'

const pull = require('pull-stream/pull')
const Connection = require('interface-connection').Connection
const assert = require('assert')
const PeerInfo = require('peer-info')
const debug = require('debug')
const once = require('once')
const log = debug('libp2p:secio')
log.error = debug('libp2p:secio:error')

const handshake = require('./handshake')
const State = require('./state')

module.exports = {
  tag: '/secio/1.0.0',
  encrypt (localId, conn, remoteId, callback) {
    assert(localId, 'no local private key provided')
    assert(conn, 'no connection for the handshake  provided')

    if (typeof remoteId === 'function') {
      callback = remoteId
      remoteId = undefined
    }

    callback = once(callback || function (err) {
      if (err) { log.error(err) }
    })

    const timeout = 60 * 1000 * 5

    const state = new State(localId, remoteId, timeout, callback)

    function finish (err) {
      if (err) { return callback(err) }

      conn.getPeerInfo((err, peerInfo) => {
        encryptedConnection.setInnerConn(new Connection(state.secure, conn))

        if (err) { // no peerInfo yet, means I'm the receiver
          encryptedConnection.setPeerInfo(new PeerInfo(state.id.remote))
        }

        callback()
      })
    }

    const encryptedConnection = new Connection(undefined, conn)

    pull(
      conn,
      handshake(state, finish),
      conn
    )

    return encryptedConnection
  }
}

      };
    };
  }
}, {package:"libp2p-secio",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star-multi/src/index.js", {"async/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/map.js","async/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/parallel.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","libp2p-websocket-star":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/index.js","mafmt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mafmt/src/index.js","multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js","once":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/once/once.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star-multi/src/index.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')
const log = debug('libp2p:websocket-star:multi')
const once = require('once')

const EE = require('events').EventEmitter
const map = require('async/map')
const parallel = require('async/parallel')
const multiaddr = require('multiaddr')
const mafmt = require('mafmt')

const WSStar = require('libp2p-websocket-star')
class WebsocketStarMulti { // listen on multiple websocket star servers without having to worry about one being down.
  // NOTE: if no servers are reachable or provided an error is thrown
  constructor (opt) {
    this.opt = opt || {}
    this.servers = opt.servers || []
    this.ws = new WSStar(this.opt)
    this.discovery = this.ws.discovery
  }
  dial (ma, opt, cb) {
    log('dial', ma)
    return this.ws.dial(ma, opt, cb)
  }
  createListener (options, handler) {
    if (typeof options === 'function') {
      handler = options
      options = {}
    }

    const listener = new EE()
    listener.servers = {}
    listener.online = []
    this.servers.forEach(ser => {
      const s = this.ws.createListener(options, handler)
      s.once('error', () => {})
      s.url = ser
      listener.servers[ser] = s
    })

    listener.listen = (ma, cb) => {
      const id = ma.toString().split('ipfs/').pop()
      log('listen on %s server(s) with id %s', this.servers.length, id)
      parallel(this.servers.map(url => listener.servers[url]).map(server =>
        cb => {
          log('listen %s', server.url)
          const next = once(err => {
            log('listen %s ok %s', server.url, !err)
            if (err) return cb(log(err))
            listener.online.push(server)
            return cb()
          })
          setTimeout(next, this.opt.timeout || 5000, new Error('Timeout'))
          server.listen(multiaddr(server.url).encapsulate('/ipfs/' + id), next)
        }), () => {
        if (!listener.online.length && !this.opt.ignore_no_online) {
          const e = new Error("Couldn't listen on any of the servers")
          listener.emit('error', e)
          cb(e)
        } else {
          listener.emit('listening')
          cb()
        }
      })
    }

    listener.close = cb =>
      parallel(listener.online.map(s => cb => s.close(cb)), err => cb(err, (listener.online = [])))

    listener.getAddrs = cb => map(listener.online, (s, n) => s.getAddrs(n), (err, res) => {
      if (err) return cb(err)
      return cb(null, res.reduce((a, b) => a.concat(b), []))
    })

    return listener
  }

  filter (ma) {
    if (!Array.isArray(ma)) ma = [ma]
    return ma.filter(ma => ma.toString().startsWith('/p2p-websocket-star') || mafmt.WebSocketStar.matches(ma))
  }
}

module.exports = WebsocketStarMulti

      };
    };
  }
}, {package:"libp2p-websocket-star-multi",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star-multi/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-webrtc-star/src/index.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-webrtc-star/src/utils.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","class-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","interface-connection":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/index.js","mafmt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mafmt/src/index.js","multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js","once":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/once/once.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js","simple-peer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/index.js","socket.io-client":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/index.js","stream-to-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-to-pull-stream/index.js","webrtcsupport":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/webrtcsupport/index-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-webrtc-star/src/index.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')
const log = debug('libp2p:webrtc-star')
const multiaddr = require('multiaddr')
const mafmt = require('mafmt')
const withIs = require('class-is')
const io = require('socket.io-client')
const EE = require('events').EventEmitter
const SimplePeer = require('simple-peer')
const PeerId = require('peer-id')
const PeerInfo = require('peer-info')
const Connection = require('interface-connection').Connection
const toPull = require('stream-to-pull-stream')
const once = require('once')
const setImmediate = require('async/setImmediate')
const webrtcSupport = require('webrtcsupport')
const utils = require('./utils')
const cleanUrlSIO = utils.cleanUrlSIO
const cleanMultiaddr = utils.cleanMultiaddr

const noop = once(() => {})

const sioOptions = {
  transports: ['websocket'],
  'force new connection': true
}

class WebRTCStar {
  constructor (options) {
    options = options || {}

    this.maSelf = undefined

    this.sioOptions = {
      transports: ['websocket'],
      'force new connection': true
    }

    if (options.wrtc) {
      this.wrtc = options.wrtc
    }

    this.discovery = new EE()
    this.discovery.tag = 'webRTCStar'
    this.discovery._isStarted = false
    this.discovery.start = (callback) => {
      this.discovery._isStarted = true
      setImmediate(callback)
    }
    this.discovery.stop = (callback) => {
      this.discovery._isStarted = false
      setImmediate(callback)
    }

    this.listenersRefs = {}
    this._peerDiscovered = this._peerDiscovered.bind(this)
  }

  dial (ma, options, callback) {
    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    callback = callback ? once(callback) : noop

    const intentId = (~~(Math.random() * 1e9)).toString(36) + Date.now()

    const sioClient = this
      .listenersRefs[Object.keys(this.listenersRefs)[0]].io

    const spOptions = { initiator: true, trickle: false }

    // Use custom WebRTC implementation
    if (this.wrtc) { spOptions.wrtc = this.wrtc }

    let channel
    try {
      channel = new SimplePeer(spOptions)
    } catch (err) {
      log('Could not create connection:', err)
      return callback(err)
    }

    const conn = new Connection(toPull.duplex(channel))
    let connected = false

    channel.on('signal', (signal) => {
      sioClient.emit('ss-handshake', {
        intentId: intentId,
        srcMultiaddr: this.maSelf.toString(),
        dstMultiaddr: ma.toString(),
        signal: signal
      })
    })

    channel.once('timeout', () => callback(new Error('timeout')))

    channel.once('error', (err) => {
      if (!connected) { callback(err) }
    })

    // NOTE: aegir segfaults if we do .once on the socket.io event emitter and we
    // are clueless as to why.
    sioClient.on('ws-handshake', (offer) => {
      if (offer.intentId === intentId && offer.err) {
        return callback(new Error(offer.err))
      }

      if (offer.intentId !== intentId || !offer.answer) {
        return
      }

      channel.once('connect', () => {
        connected = true
        conn.destroy = channel.destroy.bind(channel)

        channel.once('close', () => conn.destroy())

        conn.getObservedAddrs = (callback) => callback(null, [ma])

        callback(null, conn)
      })

      channel.signal(offer.signal)
    })

    return conn
  }

  createListener (options, handler) {
    if (typeof options === 'function') {
      handler = options
      options = {}
    }

    const listener = new EE()

    listener.listen = (ma, callback) => {
      callback = callback ? once(callback) : noop

      if (!webrtcSupport.support && !this.wrtc) {
        return setImmediate(() => callback(new Error('no WebRTC support')))
      }

      this.maSelf = ma

      const sioUrl = cleanUrlSIO(ma)

      log('Dialing to Signalling Server on: ' + sioUrl)

      listener.io = io.connect(sioUrl, sioOptions)

      listener.io.once('connect_error', callback)
      listener.io.once('error', (err) => {
        listener.emit('error', err)
        listener.emit('close')
      })

      listener.io.on('ws-handshake', incommingDial)
      listener.io.on('ws-peer', this._peerDiscovered)

      listener.io.on('connect', () => {
        listener.io.emit('ss-join', ma.toString())
      })

      listener.io.once('connect', () => {
        listener.emit('listening')
        callback()
      })

      const self = this
      function incommingDial (offer) {
        if (offer.answer || offer.err) {
          return
        }

        const spOptions = { trickle: false }

        // Use custom WebRTC implementation
        if (self.wrtc) { spOptions.wrtc = self.wrtc }

        let channel
        try {
          channel = new SimplePeer(spOptions)
        } catch (err) {
          log('Could not create incoming connection:', err)
          return callback(err)
        }

        const conn = new Connection(toPull.duplex(channel))

        channel.once('connect', () => {
          conn.getObservedAddrs = (callback) => {
            return callback(null, [offer.srcMultiaddr])
          }

          listener.emit('connection', conn)
          handler(conn)
        })

        channel.once('signal', (signal) => {
          offer.signal = signal
          offer.answer = true
          listener.io.emit('ss-handshake', offer)
        })

        channel.signal(offer.signal)
      }
    }

    listener.close = (callback) => {
      callback = callback ? once(callback) : noop

      listener.io.emit('ss-leave')

      setImmediate(() => {
        listener.emit('close')
        callback()
      })
    }

    listener.getAddrs = (callback) => {
      setImmediate(() => callback(null, [this.maSelf]))
    }

    this.listenersRefs[multiaddr.toString()] = listener
    return listener
  }

  filter (multiaddrs) {
    if (!Array.isArray(multiaddrs)) {
      multiaddrs = [multiaddrs]
    }

    return multiaddrs.filter((ma) => {
      if (ma.protoNames().indexOf('p2p-circuit') > -1) {
        return false
      }

      return mafmt.WebRTCStar.matches(ma)
    })
  }

  _peerDiscovered (maStr) {
    if (!this.discovery._isStarted) return

    log('Peer Discovered:', maStr)
    maStr = cleanMultiaddr(maStr)

    const split = maStr.split('/ipfs/')
    const peerIdStr = split[split.length - 1]
    const peerId = PeerId.createFromB58String(peerIdStr)
    const peerInfo = new PeerInfo(peerId)
    peerInfo.multiaddrs.add(multiaddr(maStr))
    this.discovery.emit('peer', peerInfo)
  }
}

module.exports = withIs(WebRTCStar, { className: 'WebRTCStar', symbolName: '@libp2p/js-libp2p-webrtc-star/webrtcstar' })

      };
    };
  }
}, {package:"libp2p-webrtc-star",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-webrtc-star/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/index.js", {"./config":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/config.js","./content-routing":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/content-routing.js","./dht":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/dht.js","./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/errors.js","./get-peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/get-peer-info.js","./peer-routing":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/peer-routing.js","./pubsub":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/pubsub.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/util/index.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","async/each":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","async/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/parallel.js","async/series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/series.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","fsm-event":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fsm-event/index.js","libp2p-connection-manager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-connection-manager/src/index.js","libp2p-ping":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/index.js","libp2p-switch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/index.js","libp2p-websockets":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websockets/src/index.js","peer-book":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-book/src/index.js","peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/index.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict'

const FSM = require('fsm-event')
const EventEmitter = require('events').EventEmitter
const debug = require('debug')
const log = debug('libp2p')
log.error = debug('libp2p:error')
const errCode = require('err-code')

const each = require('async/each')
const series = require('async/series')
const parallel = require('async/parallel')
const nextTick = require('async/nextTick')

const PeerBook = require('peer-book')
const PeerInfo = require('peer-info')
const Switch = require('libp2p-switch')
const Ping = require('libp2p-ping')
const WebSockets = require('libp2p-websockets')
const ConnectionManager = require('libp2p-connection-manager')

const { emitFirst } = require('./util')
const peerRouting = require('./peer-routing')
const contentRouting = require('./content-routing')
const dht = require('./dht')
const pubsub = require('./pubsub')
const getPeerInfo = require('./get-peer-info')
const validateConfig = require('./config').validate
const { codes } = require('./errors')

const notStarted = (action, state) => {
  return errCode(
    new Error(`libp2p cannot ${action} when not started; state is ${state}`),
    codes.ERR_NODE_NOT_STARTED
  )
}

/**
 * @fires Libp2p#error Emitted when an error occurs
 * @fires Libp2p#peer:connect Emitted when a peer is connected to this node
 * @fires Libp2p#peer:disconnect Emitted when a peer disconnects from this node
 * @fires Libp2p#peer:discovery Emitted when a peer is discovered
 * @fires Libp2p#start Emitted when the node and its services has started
 * @fires Libp2p#stop Emitted when the node and its services has stopped
 */
class Libp2p extends EventEmitter {
  constructor (_options) {
    super()
    // validateConfig will ensure the config is correct,
    // and add default values where appropriate
    this._options = validateConfig(_options)

    this.datastore = this._options.datastore
    this.peerInfo = this._options.peerInfo
    this.peerBook = this._options.peerBook || new PeerBook()

    this._modules = this._options.modules
    this._config = this._options.config
    this._transport = [] // Transport instances/references
    this._discovery = [] // Discovery service instances/references

    // create the switch, and listen for errors
    this._switch = new Switch(this.peerInfo, this.peerBook, this._options.switch)
    this._switch.on('error', (...args) => this.emit('error', ...args))

    this.stats = this._switch.stats
    this.connectionManager = new ConnectionManager(this, this._options.connectionManager)

    // Attach stream multiplexers
    if (this._modules.streamMuxer) {
      let muxers = this._modules.streamMuxer
      muxers.forEach((muxer) => this._switch.connection.addStreamMuxer(muxer))

      // If muxer exists
      //   we can use Identify
      this._switch.connection.reuse()
      //   we can use Relay for listening/dialing
      this._switch.connection.enableCircuitRelay(this._config.relay)

      // Received incomming dial and muxer upgrade happened,
      // reuse this muxed connection
      this._switch.on('peer-mux-established', (peerInfo) => {
        this.emit('peer:connect', peerInfo)
      })

      this._switch.on('peer-mux-closed', (peerInfo) => {
        this.emit('peer:disconnect', peerInfo)
      })
    }

    // Events for anytime connections are created/removed
    this._switch.on('connection:start', (peerInfo) => {
      this.emit('connection:start', peerInfo)
    })
    this._switch.on('connection:end', (peerInfo) => {
      this.emit('connection:end', peerInfo)
    })

    // Attach crypto channels
    if (this._modules.connEncryption) {
      let cryptos = this._modules.connEncryption
      cryptos.forEach((crypto) => {
        this._switch.connection.crypto(crypto.tag, crypto.encrypt)
      })
    }

    // Attach private network protector
    if (this._modules.connProtector) {
      this._switch.protector = this._modules.connProtector
    } else if (process.env.LIBP2P_FORCE_PNET) {
      throw new Error('Private network is enforced, but no protector was provided')
    }

    // dht provided components (peerRouting, contentRouting, dht)
    if (this._config.dht.enabled) {
      const DHT = this._modules.dht

      this._dht = new DHT(this._switch, {
        datastore: this.datastore,
        ...this._config.dht
      })
    }

    // enable/disable pubsub
    if (this._config.EXPERIMENTAL.pubsub) {
      this.pubsub = pubsub(this)
    }

    // Attach remaining APIs
    // peer and content routing will automatically get modules from _modules and _dht
    this.peerRouting = peerRouting(this)
    this.contentRouting = contentRouting(this)
    this.dht = dht(this)

    this._getPeerInfo = getPeerInfo(this)

    // Mount default protocols
    Ping.mount(this._switch)

    this.state = new FSM('STOPPED', {
      STOPPED: {
        start: 'STARTING',
        stop: 'STOPPED'
      },
      STARTING: {
        done: 'STARTED',
        abort: 'STOPPED',
        stop: 'STOPPING'
      },
      STARTED: {
        stop: 'STOPPING',
        start: 'STARTED'
      },
      STOPPING: {
        stop: 'STOPPING',
        done: 'STOPPED'
      }
    })
    this.state.on('STARTING', () => {
      log('libp2p is starting')
      this._onStarting()
    })
    this.state.on('STOPPING', () => {
      log('libp2p is stopping')
      this._onStopping()
    })
    this.state.on('STARTED', () => {
      log('libp2p has started')
      this.emit('start')
    })
    this.state.on('STOPPED', () => {
      log('libp2p has stopped')
      this.emit('stop')
    })
    this.state.on('error', (err) => {
      log.error(err)
      this.emit('error', err)
    })

    // Once we start, emit and dial any peers we may have already discovered
    this.state.on('STARTED', () => {
      this.peerBook.getAllArray().forEach((peerInfo) => {
        this.emit('peer:discovery', peerInfo)
        this._maybeConnect(peerInfo)
      })
    })

    this._peerDiscovered = this._peerDiscovered.bind(this)
  }

  /**
   * Overrides EventEmitter.emit to conditionally emit errors
   * if there is a handler. If not, errors will be logged.
   * @param {string} eventName
   * @param  {...any} args
   * @returns {void}
   */
  emit (eventName, ...args) {
    if (eventName === 'error' && !this._events.error) {
      log.error(...args)
    } else {
      super.emit(eventName, ...args)
    }
  }

  /**
   * Starts the libp2p node and all sub services
   *
   * @param {function(Error)} callback
   * @returns {void}
   */
  start (callback = () => {}) {
    emitFirst(this, ['error', 'start'], callback)
    this.state('start')
  }

  /**
   * Stop the libp2p node by closing its listeners and open connections
   *
   * @param {function(Error)} callback
   * @returns {void}
   */
  stop (callback = () => {}) {
    emitFirst(this, ['error', 'stop'], callback)
    this.state('stop')
  }

  isStarted () {
    return this.state ? this.state._state === 'STARTED' : false
  }

  /**
   * Dials to the provided peer. If successful, the `PeerInfo` of the
   * peer will be added to the nodes `PeerBook`
   *
   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial
   * @param {function(Error)} callback
   * @returns {void}
   */
  dial (peer, callback) {
    this.dialProtocol(peer, null, callback)
  }

  /**
   * Dials to the provided peer and handshakes with the given protocol.
   * If successful, the `PeerInfo` of the peer will be added to the nodes `PeerBook`,
   * and the `Connection` will be sent in the callback
   *
   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial
   * @param {string} protocol
   * @param {function(Error, Connection)} callback
   * @returns {void}
   */
  dialProtocol (peer, protocol, callback) {
    if (!this.isStarted()) {
      return callback(notStarted('dial', this.state._state))
    }

    if (typeof protocol === 'function') {
      callback = protocol
      protocol = undefined
    }

    this._getPeerInfo(peer, (err, peerInfo) => {
      if (err) { return callback(err) }

      this._switch.dial(peerInfo, protocol, callback)
    })
  }

  /**
   * Similar to `dial` and `dialProtocol`, but the callback will contain a
   * Connection State Machine.
   *
   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial
   * @param {string} protocol
   * @param {function(Error, ConnectionFSM)} callback
   * @returns {void}
   */
  dialFSM (peer, protocol, callback) {
    if (!this.isStarted()) {
      return callback(notStarted('dial', this.state._state))
    }

    if (typeof protocol === 'function') {
      callback = protocol
      protocol = undefined
    }

    this._getPeerInfo(peer, (err, peerInfo) => {
      if (err) { return callback(err) }

      this._switch.dialFSM(peerInfo, protocol, callback)
    })
  }

  hangUp (peer, callback) {
    this._getPeerInfo(peer, (err, peerInfo) => {
      if (err) { return callback(err) }

      this._switch.hangUp(peerInfo, callback)
    })
  }

  ping (peer, callback) {
    if (!this.isStarted()) {
      return callback(notStarted('ping', this.state._state))
    }

    this._getPeerInfo(peer, (err, peerInfo) => {
      if (err) { return callback(err) }

      callback(null, new Ping(this._switch, peerInfo))
    })
  }

  handle (protocol, handlerFunc, matchFunc) {
    this._switch.handle(protocol, handlerFunc, matchFunc)
  }

  unhandle (protocol) {
    this._switch.unhandle(protocol)
  }

  _onStarting () {
    if (!this._modules.transport) {
      this.emit('error', new Error('no transports were present'))
      return this.state('abort')
    }

    let ws

    // so that we can have webrtc-star addrs without adding manually the id
    const maOld = []
    const maNew = []
    this.peerInfo.multiaddrs.toArray().forEach((ma) => {
      if (!ma.getPeerId()) {
        maOld.push(ma)
        maNew.push(ma.encapsulate('/p2p/' + this.peerInfo.id.toB58String()))
      }
    })
    this.peerInfo.multiaddrs.replace(maOld, maNew)

    const multiaddrs = this.peerInfo.multiaddrs.toArray()

    this._modules.transport.forEach((Transport) => {
      let t

      if (typeof Transport === 'function') {
        t = new Transport({ libp2p: this })
      } else {
        t = Transport
      }

      if (t.filter(multiaddrs).length > 0) {
        this._switch.transport.add(t.tag || t[Symbol.toStringTag], t)
      } else if (WebSockets.isWebSockets(t)) {
        // TODO find a cleaner way to signal that a transport is always used
        // for dialing, even if no listener
        ws = t
      }
      this._transport.push(t)
    })

    series([
      (cb) => {
        this.connectionManager.start()
        this._switch.start(cb)
      },
      (cb) => {
        if (ws) {
          // always add dialing on websockets
          this._switch.transport.add(ws.tag || ws.constructor.name, ws)
        }

        // detect which multiaddrs we don't have a transport for and remove them
        const multiaddrs = this.peerInfo.multiaddrs.toArray()

        multiaddrs.forEach((multiaddr) => {
          if (!multiaddr.toString().match(/\/p2p-circuit($|\/)/) &&
              !this._transport.find((transport) => transport.filter(multiaddr).length > 0)) {
            this.peerInfo.multiaddrs.delete(multiaddr)
          }
        })
        cb()
      },
      (cb) => {
        if (this._dht) {
          this._dht.start(() => {
            this._dht.on('peer', this._peerDiscovered)
            cb()
          })
        } else {
          cb()
        }
      },
      (cb) => {
        if (this._floodSub) {
          return this._floodSub.start(cb)
        }
        cb()
      },
      // Peer Discovery
      (cb) => {
        if (this._modules.peerDiscovery) {
          this._setupPeerDiscovery(cb)
        } else {
          cb()
        }
      }
    ], (err) => {
      if (err) {
        log.error(err)
        this.emit('error', err)
        return this.state('stop')
      }
      this.state('done')
    })
  }

  _onStopping () {
    series([
      (cb) => {
        // stop all discoveries before continuing with shutdown
        parallel(
          this._discovery.map((d) => {
            d.removeListener('peer', this._peerDiscovered)
            return (_cb) => d.stop((err) => {
              log.error('an error occurred stopping the discovery service', err)
              _cb()
            })
          }),
          cb
        )
      },
      (cb) => {
        if (this._floodSub) {
          return this._floodSub.stop(cb)
        }
        cb()
      },
      (cb) => {
        if (this._dht) {
          this._dht.removeListener('peer', this._peerDiscovered)
          return this._dht.stop(cb)
        }
        cb()
      },
      (cb) => {
        this.connectionManager.stop()
        this._switch.stop(cb)
      },
      (cb) => {
        // Ensures idempotent restarts, ignore any errors
        // from removeAll, they're not useful at this point
        this._switch.transport.removeAll(() => cb())
      }
    ], (err) => {
      if (err) {
        log.error(err)
        this.emit('error', err)
      }
      this.state('done')
    })
  }

  /**
   * Handles discovered peers. Each discovered peer will be emitted via
   * the `peer:discovery` event. If auto dial is enabled for libp2p
   * and the current connection count is under the low watermark, the
   * peer will be dialed.
   *
   * TODO: If `peerBook.put` becomes centralized, https://github.com/libp2p/js-libp2p/issues/345,
   * it would be ideal if only new peers were emitted. Currently, with
   * other modules adding peers to the `PeerBook` we have no way of knowing
   * if a peer is new or not, so it has to be emitted.
   *
   * @private
   * @param {PeerInfo} peerInfo
   */
  _peerDiscovered (peerInfo) {
    if (peerInfo.id.toB58String() === this.peerInfo.id.toB58String()) {
      log.error(new Error(codes.ERR_DISCOVERED_SELF))
      return
    }
    peerInfo = this.peerBook.put(peerInfo)

    if (!this.isStarted()) return

    this.emit('peer:discovery', peerInfo)
    this._maybeConnect(peerInfo)
  }

  /**
   * Will dial to the given `peerInfo` if the current number of
   * connected peers is less than the configured `ConnectionManager`
   * minPeers.
   * @private
   * @param {PeerInfo} peerInfo
   */
  _maybeConnect (peerInfo) {
    // If auto dialing is on, check if we should dial
    if (this._config.peerDiscovery.autoDial === true && !peerInfo.isConnected()) {
      const minPeers = this._options.connectionManager.minPeers || 0
      if (minPeers > Object.keys(this._switch.connection.connections).length) {
        log('connecting to discovered peer')
        this._switch.dialer.connect(peerInfo, (err) => {
          err && log.error('could not connect to discovered peer', err)
        })
      }
    }
  }

  /**
   * Initializes and starts peer discovery services
   *
   * @private
   * @param {function(Error)} callback
   */
  _setupPeerDiscovery (callback) {
    for (const DiscoveryService of this._modules.peerDiscovery) {
      let config = {
        enabled: true // on by default
      }

      if (DiscoveryService.tag &&
        this._config.peerDiscovery &&
        this._config.peerDiscovery[DiscoveryService.tag]) {
        config = { ...config, ...this._config.peerDiscovery[DiscoveryService.tag] }
      }

      if (config.enabled) {
        let discoveryService

        if (typeof DiscoveryService === 'function') {
          discoveryService = new DiscoveryService(Object.assign({}, config, { peerInfo: this.peerInfo }))
        } else {
          discoveryService = DiscoveryService
        }

        discoveryService.on('peer', this._peerDiscovered)
        this._discovery.push(discoveryService)
      }
    }

    each(this._discovery, (d, cb) => {
      d.start(cb)
    }, callback)
  }
}

module.exports = Libp2p
/**
 * Like `new Libp2p(options)` except it will create a `PeerInfo`
 * instance if one is not provided in options.
 * @param {object} options Libp2p configuration options
 * @param {function(Error, Libp2p)} callback
 * @returns {void}
 */
module.exports.createLibp2p = (options, callback) => {
  if (options.peerInfo) {
    return nextTick(callback, null, new Libp2p(options))
  }
  PeerInfo.create((err, peerInfo) => {
    if (err) return callback(err)
    options.peerInfo = peerInfo
    callback(null, new Libp2p(options))
  })
}

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"libp2p",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/fetch-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/fetch-browser.js
      return function (require, module, exports) {
/* eslint-env browser */
'use strict'
module.exports = fetch

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/fetch-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/index.js", {"./duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/duplex.js","./sink":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/sink.js","./source":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/source.js","./through":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/through.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/index.js
      return function (require, module, exports) {

exports.source = require('./source')
exports.through = require('./through')
exports.sink = require('./sink')
exports.duplex = require('./duplex')

      };
    };
  }
}, {package:"pull-defer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/utils.js", {"../../../utils/cid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/utils/cid.js","async-iterator-to-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-pull-stream/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/utils.js
      return function (require, module, exports) {
'use strict'

const CID = require('cids')
const { Buffer } = require('buffer')
const { cidToString } = require('../../../utils/cid')
const toPullStream = require('async-iterator-to-pull-stream')

const normalizePath = (path) => {
  if (Buffer.isBuffer(path)) {
    return new CID(path).toString()
  }
  if (CID.isCID(path)) {
    return path.toString()
  }
  if (path.indexOf('/ipfs/') === 0) {
    path = path.substring('/ipfs/'.length)
  }
  if (path.charAt(path.length - 1) === '/') {
    path = path.substring(0, path.length - 1)
  }
  return path
}

/**
 * Parses chunker string into options used by DAGBuilder in ipfs-unixfs-engine
 *
 *
 * @param  {String}   chunker Chunker algorithm supported formats:
 *                    "size-{size}"
 *                    "rabin"
 *                    "rabin-{avg}"
 *                    "rabin-{min}-{avg}-{max}"
 *
 * @return {Object}   Chunker options for DAGBuilder
 */
const parseChunkerString = (chunker) => {
  if (!chunker) {
    return {
      chunker: 'fixed'
    }
  } else if (chunker.startsWith('size-')) {
    const sizeStr = chunker.split('-')[1]
    const size = parseInt(sizeStr)
    if (isNaN(size)) {
      throw new Error('Chunker parameter size must be an integer')
    }
    return {
      chunker: 'fixed',
      chunkerOptions: {
        maxChunkSize: size
      }
    }
  } else if (chunker.startsWith('rabin')) {
    return {
      chunker: 'rabin',
      chunkerOptions: parseRabinString(chunker)
    }
  } else {
    throw new Error(`Unrecognized chunker option: ${chunker}`)
  }
}

/**
 * Parses rabin chunker string
 *
 * @param  {String}   chunker Chunker algorithm supported formats:
 *                            "rabin"
 *                            "rabin-{avg}"
 *                            "rabin-{min}-{avg}-{max}"
 *
 * @return {Object}   rabin chunker options
 */
const parseRabinString = (chunker) => {
  const options = {}
  const parts = chunker.split('-')
  switch (parts.length) {
    case 1:
      options.avgChunkSize = 262144
      break
    case 2:
      options.avgChunkSize = parseChunkSize(parts[1], 'avg')
      break
    case 4:
      options.minChunkSize = parseChunkSize(parts[1], 'min')
      options.avgChunkSize = parseChunkSize(parts[2], 'avg')
      options.maxChunkSize = parseChunkSize(parts[3], 'max')
      break
    default:
      throw new Error('Incorrect chunker format (expected "rabin" "rabin-[avg]" or "rabin-[min]-[avg]-[max]"')
  }

  return options
}

const parseChunkSize = (str, name) => {
  let size = parseInt(str)
  if (isNaN(size)) {
    throw new Error(`Chunker parameter ${name} must be an integer`)
  }

  return size
}

const mapFile = (options = {}) => {
  return (file) => {
    let size = 0
    let type = 'dir'

    if (file.unixfs && file.unixfs.type === 'file') {
      size = file.unixfs.fileSize()
      type = 'file'
    }

    const output = {
      hash: cidToString(file.cid, { base: options.cidBase }),
      path: file.path,
      name: file.name,
      depth: file.path.split('/').length,
      size,
      type
    }

    if (options.includeContent && file.unixfs && file.unixfs.type === 'file') {
      output.content = toPullStream.source(file.content())
    }

    return output
  }
}

module.exports = {
  normalizePath,
  parseChunkSize,
  parseRabinString,
  parseChunkerString,
  mapFile
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-traverse/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-traverse/index.js
      return function (require, module, exports) {

var once = exports.once =
function (value) {
  return function (abort, cb) {
    if(abort) return cb(abort)
    if(value != null) {
      var _value = value; value = null
      cb(null, _value)
    } else
      cb(true)
  }
}

var depthFirst = exports.depthFirst =
function (start, createStream) {
  var reads = [], ended

  reads.unshift(once(start))

  return function next (end, cb) {
    if(!reads.length)
      return cb(true)
    if(ended)
      return cb(ended)

    reads[0](end, function (end, data) {
      if(end) {
        if(end !== true) {
          ended = end
          reads.shift()

          while(reads.length)
            reads.shift()(end, function () {})
          
          return cb(end)
        }
        //if this stream has ended, go to the next queue
        reads.shift()
        return next(null, cb)
      }
      reads.unshift(createStream(data))
      cb(end, data)
    })
  }
}
//width first is just like depth first,
//but push each new stream onto the end of the queue
var widthFirst = exports.widthFirst = 
function (start, createStream) {
  var reads = []

  reads.push(once(start))

  return function next (end, cb) {
    if(!reads.length)
      return cb(true)
    reads[0](end, function (end, data) {
      if(end) {
        reads.shift()
        return next(null, cb)
      }
      reads.push(createStream(data))
      cb(end, data)
    })
  }
}

//this came out different to the first (strm)
//attempt at leafFirst, but it's still a valid
//topological sort.
var leafFirst = exports.leafFirst = 
function (start, createStream) {
  var reads = []
  var output = []
  reads.push(once(start))
  
  return function next (end, cb) {
    reads[0](end, function (end, data) {
      if(end) {
        reads.shift()
        if(!output.length)
          return cb(true)
        return cb(null, output.shift())
      }
      reads.unshift(createStream(data))
      output.unshift(data)
      next(null, cb)
    })
  }
}


      };
    };
  }
}, {package:"pull-traverse",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-traverse/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-cat/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-cat/index.js
      return function (require, module, exports) {
var noop = function () {}

function abortAll(ary, abort, cb) {
  var n = ary.length
  if(!n) return cb(abort)
  ary.forEach(function (f) {
    if(f) f(abort, next)
    else next()
  })

  function next() {
    if(--n) return
    cb(abort)
  }
  if(!n) next()
}

module.exports = function (streams) {
  return function (abort, cb) {
    ;(function next () {
      if(abort)
        abortAll(streams, abort, cb)
      else if(!streams.length)
        cb(true)
      else if(!streams[0])
        streams.shift(), next()
      else
        streams[0](null, function (err, data) {
          if(err) {
            streams.shift() //drop the first, has already ended.
            if(err === true) next()
            else             abortAll(streams, err, cb)
          }
          else
            cb(null, data)
        })
    })()
  }
}



      };
    };
  }
}, {package:"pull-cat",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-cat/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/add-from-fs-browser.js", {"promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/add-from-fs-browser.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')

module.exports = self => {
  return promisify((...args) => {
    const callback = args.pop()
    callback(new Error('not available in the browser'))
  })
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/add-from-fs-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/index.js", {"../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./resolvers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/index.js","async-iterator-last":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-last/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const errCode = require('err-code')
const CID = require('cids')
const resolve = require('./resolvers')
const last = require('async-iterator-last')

const toPathComponents = (path = '') => {
  // split on / unless escaped with \
  return (path
    .trim()
    .match(/([^\\^/]|\\\/)+/g) || [])
    .filter(Boolean)
}

const cidAndRest = (path) => {
  if (Buffer.isBuffer(path)) {
    return {
      cid: new CID(path),
      toResolve: []
    }
  }

  if (CID.isCID(path)) {
    return {
      cid: path,
      toResolve: []
    }
  }

  if (typeof path === 'string') {
    if (path.indexOf('/ipfs/') === 0) {
      path = path.substring(6)
    }

    const output = toPathComponents(path)

    return {
      cid: new CID(output[0]),
      toResolve: output.slice(1)
    }
  }

  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH')
}

const walkPath = async function * (path, ipld) {
  let {
    cid,
    toResolve
  } = cidAndRest(path)
  let name = cid.toBaseEncodedString()
  let entryPath = name
  const startingDepth = toResolve.length

  while (true) {
    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, ipld)

    if (!result.entry && !result.next) {
      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND')
    }

    if (result.entry) {
      yield result.entry
    }

    if (!result.next) {
      return
    }

    // resolve further parts
    toResolve = result.next.toResolve
    cid = result.next.cid
    name = result.next.name
    entryPath = result.next.path
  }
}

const exporter = (path, ipld) => {
  return last(walkPath(path, ipld))
}

const recursive = async function * (path, ipld) {
  const node = await exporter(path, ipld)

  yield node

  if (node.unixfs && node.unixfs.type.includes('dir')) {
    for await (const child of recurse(node)) {
      yield child
    }
  }

  async function * recurse (node) {
    for await (const file of node.content()) {
      yield file

      if (file.unixfs.type.includes('dir')) {
        for await (const subFile of recurse(file)) {
          yield subFile
        }
      }
    }
  }
}

module.exports = exporter
module.exports.path = walkPath
module.exports.recursive = recursive

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/once.js", {"../util/abort-cb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/abort-cb.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/once.js
      return function (require, module, exports) {
'use strict'
var abortCb = require('../util/abort-cb')

module.exports = function once (value, onAbort) {
  return function (abort, cb) {
    if(abort)
      return abortCb(cb, abort, onAbort)
    if(value != null) {
      var _value = value; value = null
      cb(null, _value)
    } else
      cb(true)
  }
}



      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/once.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/filter.js", {"../util/tester":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/tester.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/filter.js
      return function (require, module, exports) {
'use strict'

var tester = require('../util/tester')

module.exports = function filter (test) {
  //regexp
  test = tester(test)
  return function (read) {
    return function next (end, cb) {
      var sync, loop = true
      while(loop) {
        loop = false
        sync = true
        read(end, function (end, data) {
          if(!end && !test(data))
            return sync ? loop = true : next(end, cb)
          cb(end, data)
        })
        sync = false
      }
    }
  }
}


      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/filter.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-sort/index.js", {"pull-defer/source":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/source.js","pull-stream/sinks/collect":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/collect.js","pull-stream/sources/error":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/error.js","pull-stream/sources/values":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/values.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-sort/index.js
      return function (require, module, exports) {

var Source = require('pull-defer/source')
var error = require('pull-stream/sources/error')
var values = require('pull-stream/sources/values')
var collect = require('pull-stream/sinks/collect')

module.exports = function (compare) {
  var source = Source()

  var sink = collect(function (err, ary) {
    if (err) {
      return source.resolve(error(err))
    }

    source.resolve(values(ary.sort(compare)))
  })

  return function (read) {
    sink(read)
    return source
  }
}

      };
    };
  }
}, {package:"pull-sort",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-sort/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/src/files/add-input-validation.js", {"is-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/is-buffer/index.js","is-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-pull-stream/index.js","is-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/is-stream/index.js","kind-of":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/kind-of/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/src/files/add-input-validation.js
      return function (require, module, exports) {
'use strict'

const kindOf = require('kind-of')
const isStream = require('is-stream')
const { isSource } = require('is-pull-stream')
const isBuffer = require('is-buffer')

const validateAddInput = (input) => {
  // Buffer|ReadableStream|PullStream|File
  const isPrimitive = obj => isBuffer(obj) || isStream.readable(obj) || isSource(obj) || kindOf(obj) === 'file'

  // An object like { content?, path? }, where content isBufferOrStream and path isString
  const isContentObject = obj => {
    if (typeof obj !== 'object') return false
    // path is optional if content is present
    if (obj.content) return isPrimitive(obj.content)
    // path must be a non-empty string if no content
    return Boolean(obj.path) && typeof obj.path === 'string'
  }

  // An input atom: a buffer, stream or content object
  const isInput = obj => isPrimitive(obj) || isContentObject(obj)

  if (isInput(input) || (Array.isArray(input) && input.every(isInput))) {
    return true
  } else {
    throw new Error(`Input not supported. Expected Buffer|ReadableStream|PullStream|File|Array<Object> got ${kindOf(input)}. Check the documentation for more info https://github.com/ipfs/interface-js-ipfs-core/blob/master/SPEC/FILES.md#add`)
  }
}

module.exports = validateAddInput

      };
    };
  }
}, {package:"ipfs-utils",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/src/files/add-input-validation.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/is-stream/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/is-stream/index.js
      return function (require, module, exports) {
'use strict';

const isStream = stream =>
	stream !== null &&
	typeof stream === 'object' &&
	typeof stream.pipe === 'function';

isStream.writable = stream =>
	isStream(stream) &&
	stream.writable !== false &&
	typeof stream._write === 'function' &&
	typeof stream._writableState === 'object';

isStream.readable = stream =>
	isStream(stream) &&
	stream.readable !== false &&
	typeof stream._read === 'function' &&
	typeof stream._readableState === 'object';

isStream.duplex = stream =>
	isStream.writable(stream) &&
	isStream.readable(stream);

isStream.transform = stream =>
	isStream.duplex(stream) &&
	typeof stream._transform === 'function' &&
	typeof stream._transformState === 'object';

module.exports = isStream;

      };
    };
  }
}, {package:"is-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/is-stream/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/kind-of/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/kind-of/index.js
      return function (require, module, exports) {
var toString = Object.prototype.toString;

module.exports = function kindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';

  var type = typeof val;
  if (type === 'boolean') return 'boolean';
  if (type === 'string') return 'string';
  if (type === 'number') return 'number';
  if (type === 'symbol') return 'symbol';
  if (type === 'function') {
    return isGeneratorFn(val) ? 'generatorfunction' : 'function';
  }

  if (isArray(val)) return 'array';
  if (isBuffer(val)) return 'buffer';
  if (isArguments(val)) return 'arguments';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  if (isRegexp(val)) return 'regexp';

  switch (ctorName(val)) {
    case 'Symbol': return 'symbol';
    case 'Promise': return 'promise';

    // Set, Map, WeakSet, WeakMap
    case 'WeakMap': return 'weakmap';
    case 'WeakSet': return 'weakset';
    case 'Map': return 'map';
    case 'Set': return 'set';

    // 8-bit typed arrays
    case 'Int8Array': return 'int8array';
    case 'Uint8Array': return 'uint8array';
    case 'Uint8ClampedArray': return 'uint8clampedarray';

    // 16-bit typed arrays
    case 'Int16Array': return 'int16array';
    case 'Uint16Array': return 'uint16array';

    // 32-bit typed arrays
    case 'Int32Array': return 'int32array';
    case 'Uint32Array': return 'uint32array';
    case 'Float32Array': return 'float32array';
    case 'Float64Array': return 'float64array';
  }

  if (isGeneratorObj(val)) {
    return 'generator';
  }

  // Non-plain objects
  type = toString.call(val);
  switch (type) {
    case '[object Object]': return 'object';
    // iterators
    case '[object Map Iterator]': return 'mapiterator';
    case '[object Set Iterator]': return 'setiterator';
    case '[object String Iterator]': return 'stringiterator';
    case '[object Array Iterator]': return 'arrayiterator';
  }

  // other
  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
};

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isArray(val) {
  if (Array.isArray) return Array.isArray(val);
  return val instanceof Array;
}

function isError(val) {
  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function'
    && typeof val.getDate === 'function'
    && typeof val.setDate === 'function';
}

function isRegexp(val) {
  if (val instanceof RegExp) return true;
  return typeof val.flags === 'string'
    && typeof val.ignoreCase === 'boolean'
    && typeof val.multiline === 'boolean'
    && typeof val.global === 'boolean';
}

function isGeneratorFn(name, val) {
  return ctorName(name) === 'GeneratorFunction';
}

function isGeneratorObj(val) {
  return typeof val.throw === 'function'
    && typeof val.return === 'function'
    && typeof val.next === 'function';
}

function isArguments(val) {
  try {
    if (typeof val.length === 'number' && typeof val.callee === 'function') {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf('callee') !== -1) {
      return true;
    }
  }
  return false;
}

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer(val) {
  if (val.constructor && typeof val.constructor.isBuffer === 'function') {
    return val.constructor.isBuffer(val);
  }
  return false;
}

      };
    };
  }
}, {package:"kind-of",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/kind-of/index.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvZXRoLW1ldGhvZC1yZWdpc3RyeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvdGhyb3VnaDIvdGhyb3VnaDIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL29iamVjdC1tdWx0aXBsZXgvZGlzdC9TdWJzdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3Bvc3QtbWVzc2FnZS1zdHJlYW0vZGlzdC9CYXNlUG9zdE1lc3NhZ2VTdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3Bvc3QtbWVzc2FnZS1zdHJlYW0vZGlzdC9lbnVtcy5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9kaXN0LmJyb3dzZXIvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvZGlzdC5icm93c2VyL3RyYW5zYWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aC9kaXN0L2JjLXVyLXJlZ2lzdHJ5LWV0aC5janMucHJvZHVjdGlvbi5taW4uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoL2Rpc3QvYmMtdXItcmVnaXN0cnktZXRoLmNqcy5kZXZlbG9wbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXB1YnN1Yi1wZWVyLW1vbml0b3Ivc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3AtcmVkdWNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Atc2VyaWVzL25vZGVfbW9kdWxlcy9Ac2luZHJlc29yaHVzL2lzL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy1sb2cvc3JjL3V0aWxzL2RpZmZlcmVuY2UuanMiLCJub2RlX21vZHVsZXMvaXBmcy1sb2cvc3JjL3V0aWxzL2ZpbmQtdW5pcXVlcy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWxvZy9zcmMvdXRpbHMvaXMtZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWxvZy9zcmMvZW50cnktaW8uanMiLCJub2RlX21vZHVsZXMvanNvbi1zdHJpbmdpZnktZGV0ZXJtaW5pc3RpYy9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXBvcnQtYmFzZTY0dXJsL2Rpc3QvYmFzZTY0dXJsLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWlkZW50aXR5LXByb3ZpZGVyL3NyYy9pZGVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1pZGVudGl0eS1wcm92aWRlci9zcmMvb3JiaXQtZGItaWRlbnRpdHktcHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0dXJsL2Rpc3QvYmFzZTY0dXJsLmpzIiwibm9kZV9tb2R1bGVzL2RpZC1qd3QvbGliL1NpbXBsZVNpZ25lci5qcyIsIm5vZGVfbW9kdWxlcy9kaWQtand0L2xpYi9OYWNsU2lnbmVyLmpzIiwibm9kZV9tb2R1bGVzL2RpZC1qd3QvbGliL0pXVC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1hY2Nlc3MtY29udHJvbGxlcnMvc3JjL2FjY2Vzcy1jb250cm9sbGVyLWludGVyZmFjZS5qcyIsIm5vZGVfbW9kdWxlcy9wLW1hcC1zZXJpZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItYWNjZXNzLWNvbnRyb2xsZXJzL3NyYy91dGlscy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1zdG9yZS9zcmMvSW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItc3RvcmUvc3JjL3JlcGxpY2F0aW9uLWluZm8uanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItc3RvcmUvc3JjL1JlcGxpY2F0b3IuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItc3RvcmUvbm9kZV9tb2R1bGVzL3AtZWFjaC1zZXJpZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3JkdHMvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtcHVic3ViLTFvbjEvc3JjL3Byb3RvY29sLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtcHVic3ViLTFvbjEvc3JjL3dhaXQtZm9yLXBlZXJzLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtcHVic3ViLTFvbjEvc3JjL2dldC1wZWVyLWlkLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtcHVic3ViLTFvbjEvc3JjL2VuY29kaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xldmVsLWpzL3V0aWwvc3VwcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9sZXZlbC1qcy9pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9hYnN0cmFjdC1sZXZlbGRvd24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGV2ZWwtanMvdXRpbC9taXhlZC10by1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvbGV2ZWwtanMvdXRpbC9pbW1lZGlhdGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9scnUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIta2V5c3RvcmUvc3JjL3ZlcmlmaWVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1rZXlzdG9yZS9ub2RlX21vZHVsZXMvbGV2ZWx1cC9saWIvbGV2ZWx1cC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXJlcG8vc3JjL2xvY2stbWVtb3J5LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtcmVwby9zcmMvYmFja2VuZHMuanMiLCJub2RlX21vZHVsZXMvaXBmcy1yZXBvL3NyYy9kZWZhdWx0LWRhdGFzdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXJlcG8vc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXJlcG8vc3JjL2Vycm9ycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXJlcG8vbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanMiLCJub2RlX21vZHVsZXMvZGx2L2Rpc3QvZGx2LnVtZC5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXN0cmVhbS9wdWxsLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtcmVwby9zcmMvdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXJlcG8vc3JjL2FwaS1hZGRyLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2VhY2guanMiLCJub2RlX21vZHVsZXMvcHVsbC1zdHJlYW0vc2lua3MvcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL3Nlcmllcy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXJlcG8vc3JjL3NwZWMuanMiLCJub2RlX21vZHVsZXMvaXBmcy1yZXBvL3NyYy9jb25maWcuanMiLCJub2RlX21vZHVsZXMvaXBmcy1yZXBvL3NyYy9ibG9ja3N0b3JlLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtcmVwby9zcmMvZGVmYXVsdC1vcHRpb25zLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZnNtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VuaXF1ZS1ieS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvL3NyYy9rZXlzL2tleXMucHJvdG8uanMiLCJub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvZm9yZ2UuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNyeXB0by9zcmMva2V5cy9lZDI1NTE5LWNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jcnlwdG8vc3JjL2tleXMva2V5LXN0cmV0Y2hlci5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9hc24xLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BiZS5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9yc2EuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNyeXB0by9zcmMva2V5cy9yc2EtY2xhc3MuanMiLCJub2RlX21vZHVsZXMvcHJvdG9ucy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNyeXB0by9zcmMva2V5cy9lcGhlbWVyYWwta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvL25vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvLXNlY3AyNTZrMS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBsZC1kYWctY2Jvci9zcmMvcmVzb2x2ZXIuanMiLCJub2RlX21vZHVsZXMvaXBsZC1kYWctY2Jvci9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9pcGxkLWRhZy1wYi9zcmMvcmVzb2x2ZXIuanMiLCJub2RlX21vZHVsZXMvaXBsZC1kYWctcGIvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvaXBsZC1kYWctcGIvc3JjL2RhZy1saW5rL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwbGQtZGFnLXBiL3NyYy9kYWctbm9kZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2Jhc2UxNi5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2Jhc2UzMi5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvbm9kZV9tb2R1bGVzL2Jhc2UteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWFkZHIvc3JjL2NvbnZlcnQuanMiLCJub2RlX21vZHVsZXMvaXBmcy9ub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9tdXJtdXJoYXNoM2pzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvYmxha2UuanMiLCJub2RlX21vZHVsZXMvaXBmcy9ub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy9jcnlwdG8tc2hhMS0yLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNyeXB0by9zcmMvbm9kZWlmeS5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvL3NyYy93ZWJjcnlwdG8uanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNyeXB0by9zcmMvaG1hYy9sZW5ndGhzLmpzIiwibm9kZV9tb2R1bGVzL2lzby1yYW5kb20tc3RyZWFtL3NyYy9yYW5kb20uYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvL3NyYy9hZXMvY2lwaGVycy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3Bia2RmMi5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvcnVudGltZS9kbnMtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL3J1bnRpbWUvY29uZmlnLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXB1c2hhYmxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtc3RyZWFtLXRvLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lcnItY29kZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy91dGlscy9jaWQuanMiLCJub2RlX21vZHVsZXMvaHVtYW4tdG8tbWlsbGlzZWNvbmRzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9uZXh0VGljay5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9ldmVyeS5qcyIsIm5vZGVfbW9kdWxlcy9qdXN0LWZsYXR0ZW4taXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXN5bmMtaXRlcmF0b3ItdG8tcHVsbC1zdHJlYW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXN5bmMvbWFwU2VyaWVzLmpzIiwibm9kZV9tb2R1bGVzL2ludGVyZmFjZS1kYXRhc3RvcmUvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2RldGVjdExpbWl0LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9waW4tc2V0LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvaXBucy9wYXRoLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9uYW1lLXB1YnN1Yi5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvbm8ta2V5Y2hhaW4uanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWtleWNoYWluL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2lwbnMvcm91dGluZy9jb25maWcuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9pcG5zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtYml0c3dhcC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9pcG5zL3JvdXRpbmcvb2ZmbGluZS1kYXRhc3RvcmUuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9pcG5zL3JvdXRpbmcvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9ydW50aW1lL2xpYnAycC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9maWxlcy1yZWd1bGFyL2FkZC1mcm9tLXN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvZmlsZXMtcmVndWxhci9hZGQtZnJvbS11cmwuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL2ZpbGVzLXJlZ3VsYXIvYWRkLXJlYWRhYmxlLXN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvZmlsZXMtcmVndWxhci9jYXQuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL2ZpbGVzLXJlZ3VsYXIvY2F0LXJlYWRhYmxlLXN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvZmlsZXMtcmVndWxhci9nZXQuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL2ZpbGVzLXJlZ3VsYXIvZ2V0LXJlYWRhYmxlLXN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvZmlsZXMtcmVndWxhci9scy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvZmlsZXMtcmVndWxhci9scy1yZWFkYWJsZS1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL2ZpbGVzLXJlZ3VsYXIvcmVmcy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvZmlsZXMtcmVndWxhci9yZWZzLXJlYWRhYmxlLXN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvZmlsZXMtcmVndWxhci9yZWZzLWxvY2FsLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9maWxlcy1yZWd1bGFyL3JlZnMtbG9jYWwtcmVhZGFibGUtc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9maWxlcy1yZWd1bGFyL3JlZnMtbG9jYWwtcHVsbC1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL2ZpbGVzLXJlZ3VsYXIvcmVmcy1wdWxsLXN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvZmlsZXMtcmVndWxhci9hZGQtZnJvbS1mcy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvZmlsZXMtcmVndWxhci9nZXQtcHVsbC1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL2ZpbGVzLXJlZ3VsYXIvbHMtcHVsbC1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL2ZpbGVzLXJlZ3VsYXIvYWRkLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9maWxlcy1yZWd1bGFyL2NhdC1wdWxsLXN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvZmlsZXMtcmVndWxhci9hZGQtcHVsbC1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvY2FsbGJhY2tpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXN5bmMtaXRlcmF0b3ItYWxsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXB1bGwtc3RyZWFtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtc3RyZWFtLXRvLWFzeW5jLWl0ZXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtc3RyZWFtL3Rocm91Z2hzL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy1pdGVyYXRvci10by1zdHJlYW0vZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLW1mcy9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvZGlzdC9wZXJtaXR0ZWQvY29tbW9uL3NuYXBJbnN0YWxsYXRpb24uanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9jaWRzL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9nZW5lcmF0ZWQtdGFibGUuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9jaWRzL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL25vZGVfbW9kdWxlcy92YXJpbnQvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvY2lkcy9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvdmFyaW50L2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL2NpZHMvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvbm9kZV9tb2R1bGVzL3ZhcmludC9sZW5ndGguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9jaWRzL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL3JmYzQ2NDguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9jaWRzL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9iYXNlLXgvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvcmZjNDY0OC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMva2VjY2FrL2xpYi9rZWNjYWstc3RhdGUtdW5yb2xsLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9rZWNjYWsvbGliL2FwaS9rZWNjYWsuanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL2tlY2Nhay9saWIvYXBpL3NoYWtlLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLWFiaS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLWFiaS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2lnbmF0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLWFiaS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYWNjb3VudC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2J5dGVzLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLWFiaS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLWFiaS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMXYzLWFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS91dGlsaXRpZXMuanMiLCJub2RlX21vZHVsZXMvYm9yYy9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL2JvcmMvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2JvcmMvc3JjL2RlY29kZXIuYXNtLmpzIiwibm9kZV9tb2R1bGVzL2JvcmMvbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanMiLCJub2RlX21vZHVsZXMvaXNvLXVybC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvbm9kZV9tb2R1bGVzL3V1aWQvdjQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L2Rpc3QvdGhpcmRwYXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvZGlzdC9oZGtleS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvZXRoLW1ldGhvZC1yZWdpc3RyeS9yZWdpc3RyeS1tYXAuanNvbiIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvZXRoLW1ldGhvZC1yZWdpc3RyeS9hYmkuanNvbiIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvZXRoanMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9wb3N0LW1lc3NhZ2Utc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWxvZy9ub2RlX21vZHVsZXMvcC1tYXAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcC13aGlsc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbi1zdHJpbmdpZnktZGV0ZXJtaW5pc3RpYy9saWIvZGVmYXVsdHMuanMiLCJub2RlX21vZHVsZXMvanNvbi1zdHJpbmdpZnktZGV0ZXJtaW5pc3RpYy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy91cG9ydC1iYXNlNjR1cmwvZGlzdC9wYWQtc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWlkZW50aXR5LXByb3ZpZGVyL3NyYy9pcy1kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWlkZW50aXR5LXByb3ZpZGVyL3NyYy9pZGVudGl0eS1wcm92aWRlci1pbnRlcmZhY2UuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0dXJsL2Rpc3QvcGFkLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9kaWQtand0L2xpYi9EaWdlc3QuanMiLCJub2RlX21vZHVsZXMvZGlkLWp3dC9saWIvVmVyaWZpZXJBbGdvcml0aG0uanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQuanMiLCJub2RlX21vZHVsZXMvZGlkLWp3dC9saWIvU2lnbmVyQWxnb3JpdGhtLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWFjY2Vzcy1jb250cm9sbGVycy9zcmMvdXRpbHMvaXMtdmFsaWQtZXRoLWFkZHJlc3MuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItYWNjZXNzLWNvbnRyb2xsZXJzL3NyYy91dGlscy9pby5qcyIsIm5vZGVfbW9kdWxlcy9wLW1hcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXB1YnN1Yi0xb24xL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sdGd0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Fic3RyYWN0LWxldmVsZG93bi9hYnN0cmFjdC1jaGFpbmVkLWJhdGNoLmpzIiwibm9kZV9tb2R1bGVzL2Fic3RyYWN0LWxldmVsZG93bi9hYnN0cmFjdC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9hYnN0cmFjdC1sZXZlbGRvd24vYWJzdHJhY3QtbGV2ZWxkb3duLmpzIiwibm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktdG8tYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ltbWVkaWF0ZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIta2V5c3RvcmUvc3JjL3ZlcmlmaWVycy92ZXJpZmllcnYwLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWtleXN0b3JlL3NyYy92ZXJpZmllcnMvdmVyaWZpZXJ2MS5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1rZXlzdG9yZS9ub2RlX21vZHVsZXMvbGV2ZWx1cC9saWIvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWtleXN0b3JlL25vZGVfbW9kdWxlcy9sZXZlbHVwL2xpYi9wcm9taXNpZnkuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIta2V5c3RvcmUvbm9kZV9tb2R1bGVzL2xldmVsdXAvbGliL2JhdGNoLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWtleXN0b3JlL25vZGVfbW9kdWxlcy9kZWZlcnJlZC1sZXZlbGRvd24vZGVmZXJyZWQtbGV2ZWxkb3duLmpzIiwibm9kZV9tb2R1bGVzL2xldmVsLWVycm9ycy9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIta2V5c3RvcmUvbm9kZV9tb2R1bGVzL2xldmVsLWl0ZXJhdG9yLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXN0cmVhbS9zaW5rcy9kcmFpbi5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9lYWNoT2ZTZXJpZXMuanMiLCJub2RlX21vZHVsZXMvc29ydC1rZXlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2p1c3Qtc2FmZS1zZXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXN5bmMvcXVldWUuanMiLCJub2RlX21vZHVsZXMvYmFzZTMyLmpzL2Jhc2UzMi5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXN0cmVhbS9zaW5rcy9jb2xsZWN0LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFzdG9yZS1jb3JlL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9yZWplY3QuanMiLCJub2RlX21vZHVsZXMvZGF0YXN0b3JlLWxldmVsL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jcnlwdG8vc3JjL2tleXMvZWQyNTUxOS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy93aGlsc3QuanMiLCJub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvb2lkcy5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9tZC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9hZXMuanMiLCJub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGVtLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3JjMi5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9kZXMuanMiLCJub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2pzYm4uanMiLCJub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcHJpbWUuanMiLCJub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtjczEuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNyeXB0by9zcmMva2V5cy9yc2EtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9zaGE1MTIuanMiLCJub2RlX21vZHVsZXMvcHJvdG9jb2wtYnVmZmVycy1zY2hlbWEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvdG9ucy9zcmMvY29tcGlsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvL3NyYy9rZXlzL2VjZGgtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvL25vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvLXNlY3AyNTZrMS9ub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvL25vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvLXNlY3AyNTZrMS9zcmMvY3J5cHRvLmpzIiwibm9kZV9tb2R1bGVzL2lzLWNpcmN1bGFyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwbGQtZGFnLXBiL3NyYy9kYWcucHJvdG8uanMiLCJub2RlX21vZHVsZXMvaXBsZC1kYWctcGIvc3JjL3Zpc2liaWxpdHkuanMiLCJub2RlX21vZHVsZXMvaXBsZC1kYWctcGIvc3JjL2RhZy1saW5rL3V0aWwuanMiLCJub2RlX21vZHVsZXMvaXBsZC1kYWctcGIvc3JjL2RhZy1ub2RlL2FkZE5hbWVkTGluay5qcyIsIm5vZGVfbW9kdWxlcy9pcGxkLWRhZy1wYi9zcmMvZGFnLW5vZGUvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvaXBsZC1kYWctcGIvc3JjL2RhZy1ub2RlL2FkZExpbmsuanMiLCJub2RlX21vZHVsZXMvaXBsZC1kYWctcGIvc3JjL2RhZy1ub2RlL3JtTGluay5qcyIsIm5vZGVfbW9kdWxlcy9pcGxkLWRhZy1wYi9zcmMvZGFnLW5vZGUvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvY3J5cHRvLmpzIiwibm9kZV9tb2R1bGVzL2hpLWJhc2UzMi9zcmMvYmFzZTMyLmpzIiwibm9kZV9tb2R1bGVzL2lwL2xpYi9pcC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1pcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdXJtdXJoYXNoM2pzL2xpYi9tdXJtdXJIYXNoM2pzLmpzIiwibm9kZV9tb2R1bGVzL2JsYWtlanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbm9kZWlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9obWFjLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2Jhc2VOLmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtc3RyZWFtL3NpbmtzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtc3RyZWFtL3NvdXJjZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHVsbC1zdHJlYW0vdGhyb3VnaHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy11bml4ZnMvc3JjL3VuaXhmcy5wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9jcmVhdGVUZXN0ZXIuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvbm90SWQuanMiLCJub2RlX21vZHVsZXMvZ2V0LWl0ZXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL21hcExpbWl0LmpzIiwibm9kZV9tb2R1bGVzL2ludGVyZmFjZS1kYXRhc3RvcmUvc3JjL2Vycm9ycy5qcyIsIm5vZGVfbW9kdWxlcy9pbnRlcmZhY2UtZGF0YXN0b3JlL3NyYy9tZW1vcnkuanMiLCJub2RlX21vZHVsZXMvaW50ZXJmYWNlLWRhdGFzdG9yZS9zcmMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvaW50ZXJmYWNlLWRhdGFzdG9yZS9zcmMva2V5LmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL2ZpbmRHZXRSZXN1bHQuanMiLCJub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvZG9QYXJhbGxlbExpbWl0LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9waW4ucHJvdG8uanMiLCJub2RlX21vZHVsZXMvZm52MWEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXN5bmMvc29tZVNlcmllcy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2lwbnMvcm91dGluZy9wdWJzdWItZGF0YXN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rZXljaGFpbi9zcmMva2V5Y2hhaW4uanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9pcG5zL3Jlc29sdmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlY2VwdGFjbGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9pcG5zL3B1Ymxpc2hlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2lwbnMvcmVwdWJsaXNoZXIuanMiLCJub2RlX21vZHVsZXMvaXBmcy1iaXRzd2FwL3NyYy9ub3RpZmljYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtYml0c3dhcC9zcmMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvaXBmcy1iaXRzd2FwL3NyYy9kZWNpc2lvbi1lbmdpbmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy1iaXRzd2FwL3NyYy9zdGF0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWJpdHN3YXAvc3JjL3dhbnQtbWFuYWdlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWJpdHN3YXAvc3JjL25ldHdvcmsuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXJlY29yZC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBucy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWJvb3RzdHJhcC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHVsbC1tcGxleC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXdlYnNvY2tldHMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc2VjaW8vc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC13ZWJzb2NrZXQtc3Rhci1tdWx0aS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXdlYnJ0Yy1zdGFyL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvcnVudGltZS9mZXRjaC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtZGVmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL2ZpbGVzLXJlZ3VsYXIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvcHVsbC10cmF2ZXJzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLWNhdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL3J1bnRpbWUvYWRkLWZyb20tZnMtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1leHBvcnRlci9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHVsbC1zdHJlYW0vc291cmNlcy9vbmNlLmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtc3RyZWFtL3Rocm91Z2hzL2ZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXNvcnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy11dGlscy9zcmMvZmlsZXMvYWRkLWlucHV0LXZhbGlkYXRpb24uanMiLCJub2RlX21vZHVsZXMvaXBmcy9ub2RlX21vZHVsZXMvaXMtc3RyZWFtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2tpbmQtb2YvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDL1dBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvMUZBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoNENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy8vQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsMERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0MUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcExBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3p6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0MUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBOzs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN2UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNua0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaHZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25mQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDempCQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiYmFja2dyb3VuZC0zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xudmFyIGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbnZhciBzY3J5cHRfanNfMSA9IHJlcXVpcmUoXCJzY3J5cHQtanNcIik7XG52YXIgaGRrZXlfMSA9IHJlcXVpcmUoXCIuL2hka2V5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGRrZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhka2V5XzEuZGVmYXVsdDsgfSB9KTtcbnZhciB0aGlyZHBhcnR5XzEgPSByZXF1aXJlKFwiLi90aGlyZHBhcnR5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidGhpcmRwYXJ0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcmRwYXJ0eV8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgYnM1OGNoZWNrID0gcmVxdWlyZSgnYnM1OGNoZWNrJyk7XG52YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xudmFyIHV1aWR2NCA9IHJlcXVpcmUoJ3V1aWQvdjQnKTtcbmZ1bmN0aW9uIHZhbGlkYXRlSGV4U3RyaW5nKHBhcmFtTmFtZSwgc3RyLCBsZW5ndGgpIHtcbiAgICBpZiAoc3RyLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMik7XG4gICAgfVxuICAgIGlmICghc3RyICYmICFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAlIDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsZW5ndGggYXJndW1lbnQsIG11c3QgYmUgYW4gZXZlbiBudW1iZXJcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJyAmJiBzdHIubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBcIiArIHBhcmFtTmFtZSArIFwiLCBzdHJpbmcgbXVzdCBiZSBcIiArIGxlbmd0aCArIFwiIGhleCBjaGFyYWN0ZXJzXCIpO1xuICAgIH1cbiAgICBpZiAoIS9eKFswLTlhLWZdezJ9KSskL2kudGVzdChzdHIpKSB7XG4gICAgICAgIHZhciBob3dNYW55ID0gdHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgPyBsZW5ndGggOiAnZW1wdHkgb3IgYSBub24temVybyBldmVuIG51bWJlciBvZic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgXCIgKyBwYXJhbU5hbWUgKyBcIiwgc3RyaW5nIG11c3QgYmUgXCIgKyBob3dNYW55ICsgXCIgaGV4IGNoYXJhY3RlcnNcIik7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUJ1ZmZlcihwYXJhbU5hbWUsIGJ1ZmYsIGxlbmd0aCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmYpKSB7XG4gICAgICAgIHZhciBob3dNYW55SGV4ID0gdHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgPyBcIlwiICsgbGVuZ3RoICogMiA6ICdlbXB0eSBvciBhIG5vbi16ZXJvIGV2ZW4gbnVtYmVyIG9mJztcbiAgICAgICAgdmFyIGhvd01hbnlCeXRlcyA9IHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInID8gXCIgKFwiICsgbGVuZ3RoICsgXCIgYnl0ZXMpXCIgOiAnJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBcIiArIHBhcmFtTmFtZSArIFwiLCBtdXN0IGJlIGEgc3RyaW5nIChcIiArIGhvd01hbnlIZXggKyBcIiBoZXggY2hhcmFjdGVycykgb3IgYnVmZmVyXCIgKyBob3dNYW55Qnl0ZXMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgJiYgYnVmZi5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFwiICsgcGFyYW1OYW1lICsgXCIsIGJ1ZmZlciBtdXN0IGJlIFwiICsgbGVuZ3RoICsgXCIgYnl0ZXNcIik7XG4gICAgfVxuICAgIHJldHVybiBidWZmO1xufVxuZnVuY3Rpb24gbWVyZ2VUb1YzUGFyYW1zV2l0aERlZmF1bHRzKHBhcmFtcykge1xuICAgIHZhciB2M0RlZmF1bHRzID0ge1xuICAgICAgICBjaXBoZXI6ICdhZXMtMTI4LWN0cicsXG4gICAgICAgIGtkZjogJ3NjcnlwdCcsXG4gICAgICAgIHNhbHQ6IHJhbmRvbUJ5dGVzKDMyKSxcbiAgICAgICAgaXY6IHJhbmRvbUJ5dGVzKDE2KSxcbiAgICAgICAgdXVpZDogcmFuZG9tQnl0ZXMoMTYpLFxuICAgICAgICBka2xlbjogMzIsXG4gICAgICAgIGM6IDI2MjE0NCxcbiAgICAgICAgbjogMjYyMTQ0LFxuICAgICAgICByOiA4LFxuICAgICAgICBwOiAxLFxuICAgIH07XG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHYzRGVmYXVsdHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFyYW1zLnNhbHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcmFtcy5zYWx0ID0gQnVmZmVyLmZyb20odmFsaWRhdGVIZXhTdHJpbmcoJ3NhbHQnLCBwYXJhbXMuc2FsdCksICdoZXgnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcmFtcy5pdiA9IEJ1ZmZlci5mcm9tKHZhbGlkYXRlSGV4U3RyaW5nKCdpdicsIHBhcmFtcy5pdiwgMzIpLCAnaGV4Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFyYW1zLnV1aWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcmFtcy51dWlkID0gQnVmZmVyLmZyb20odmFsaWRhdGVIZXhTdHJpbmcoJ3V1aWQnLCBwYXJhbXMudXVpZCwgMzIpLCAnaGV4Jyk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuc2FsdCkge1xuICAgICAgICB2YWxpZGF0ZUJ1ZmZlcignc2FsdCcsIHBhcmFtcy5zYWx0KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5pdikge1xuICAgICAgICB2YWxpZGF0ZUJ1ZmZlcignaXYnLCBwYXJhbXMuaXYsIDE2KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy51dWlkKSB7XG4gICAgICAgIHZhbGlkYXRlQnVmZmVyKCd1dWlkJywgcGFyYW1zLnV1aWQsIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB2M0RlZmF1bHRzKSwgcGFyYW1zKTtcbn1cbmZ1bmN0aW9uIGtkZlBhcmFtc0ZvclBCS0RGKG9wdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBka2xlbjogb3B0cy5ka2xlbixcbiAgICAgICAgc2FsdDogb3B0cy5zYWx0LFxuICAgICAgICBjOiBvcHRzLmMsXG4gICAgICAgIHByZjogJ2htYWMtc2hhMjU2JyxcbiAgICB9O1xufVxuZnVuY3Rpb24ga2RmUGFyYW1zRm9yU2NyeXB0KG9wdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBka2xlbjogb3B0cy5ka2xlbixcbiAgICAgICAgc2FsdDogb3B0cy5zYWx0LFxuICAgICAgICBuOiBvcHRzLm4sXG4gICAgICAgIHI6IG9wdHMucixcbiAgICAgICAgcDogb3B0cy5wLFxuICAgIH07XG59XG4vLyB3YWxsZXQgaW1wbGVtZW50YXRpb25cbnZhciBXYWxsZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2FsbGV0KHByaXZhdGVLZXksIHB1YmxpY0tleSkge1xuICAgICAgICBpZiAocHVibGljS2V5ID09PSB2b2lkIDApIHsgcHVibGljS2V5ID0gdW5kZWZpbmVkOyB9XG4gICAgICAgIHRoaXMucHJpdmF0ZUtleSA9IHByaXZhdGVLZXk7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gcHVibGljS2V5O1xuICAgICAgICBpZiAocHJpdmF0ZUtleSAmJiBwdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN1cHBseSBib3RoIGEgcHJpdmF0ZSBhbmQgYSBwdWJsaWMga2V5IHRvIHRoZSBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcml2YXRlS2V5ICYmICFldGhlcmV1bWpzX3V0aWxfMS5pc1ZhbGlkUHJpdmF0ZShwcml2YXRlS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcml2YXRlIGtleSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBjdXJ2ZSByZXF1aXJlbWVudHMgKGllLiBpdCBpcyBpbnZhbGlkKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwdWJsaWNLZXkgJiYgIWV0aGVyZXVtanNfdXRpbF8xLmlzVmFsaWRQdWJsaWMocHVibGljS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHB1YmxpYyBrZXknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzdGF0aWMgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBiYXNlZCBvbiBhIG5ldyByYW5kb20ga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGljYXBEaXJlY3Qgc2V0dGluZyB0aGlzIHRvIGB0cnVlYCB3aWxsIGdlbmVyYXRlIGFuIGFkZHJlc3Mgc3VpdGFibGUgZm9yIHRoZSBgSUNBUCBEaXJlY3QgbW9kZWBcbiAgICAgKi9cbiAgICBXYWxsZXQuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoaWNhcERpcmVjdCkge1xuICAgICAgICBpZiAoaWNhcERpcmVjdCA9PT0gdm9pZCAwKSB7IGljYXBEaXJlY3QgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoaWNhcERpcmVjdCkge1xuICAgICAgICAgICAgdmFyIG1heCA9IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTignMDg4ZjkyNGVlY2VlZGE3ZmU5MmUxZjViMGZmZmZmZmZmZmZmZmZmZicsIDE2KTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByaXZhdGVLZXkgPSByYW5kb21CeXRlcygzMik7XG4gICAgICAgICAgICAgICAgaWYgKG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTihldGhlcmV1bWpzX3V0aWxfMS5wcml2YXRlVG9BZGRyZXNzKHByaXZhdGVLZXkpKS5sdGUobWF4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdhbGxldChwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdhbGxldChyYW5kb21CeXRlcygzMikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugd2hlcmUgdGhlIGFkZHJlc3MgaXMgdmFsaWQgYWdhaW5zdCB0aGUgc3VwcGxpZWQgcGF0dGVybiAoKip0aGlzIHdpbGwgYmUgdmVyeSBzbG93KiopXG4gICAgICovXG4gICAgV2FsbGV0LmdlbmVyYXRlVmFuaXR5QWRkcmVzcyA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgIGlmICghKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHByaXZhdGVLZXkgPSByYW5kb21CeXRlcygzMik7XG4gICAgICAgICAgICB2YXIgYWRkcmVzcyA9IGV0aGVyZXVtanNfdXRpbF8xLnByaXZhdGVUb0FkZHJlc3MocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBpZiAocGF0dGVybi50ZXN0KGFkZHJlc3MudG9TdHJpbmcoJ2hleCcpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2FsbGV0KHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2UgYmFzZWQgb24gYSBwdWJsaWMga2V5IChjZXJ0YWluIG1ldGhvZHMgd2lsbCBub3QgYmUgYXZhaWxhYmxlKVxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgb25seSBhY2NlcHRzIHVuY29tcHJlc3NlZCBFdGhlcmV1bS1zdHlsZSBwdWJsaWMga2V5cywgdW5sZXNzXG4gICAgICogdGhlIGBub25TdHJpY3RgIGZsYWcgaXMgc2V0IHRvIHRydWUuXG4gICAgICovXG4gICAgV2FsbGV0LmZyb21QdWJsaWNLZXkgPSBmdW5jdGlvbiAocHVibGljS2V5LCBub25TdHJpY3QpIHtcbiAgICAgICAgaWYgKG5vblN0cmljdCA9PT0gdm9pZCAwKSB7IG5vblN0cmljdCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChub25TdHJpY3QpIHtcbiAgICAgICAgICAgIHB1YmxpY0tleSA9IGV0aGVyZXVtanNfdXRpbF8xLmltcG9ydFB1YmxpYyhwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV2FsbGV0KHVuZGVmaW5lZCwgcHVibGljS2V5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBiYXNlZCBvbiBhIEJJUDMyIGV4dGVuZGVkIHB1YmxpYyBrZXkgKHhwdWIpXG4gICAgICovXG4gICAgV2FsbGV0LmZyb21FeHRlbmRlZFB1YmxpY0tleSA9IGZ1bmN0aW9uIChleHRlbmRlZFB1YmxpY0tleSkge1xuICAgICAgICBpZiAoZXh0ZW5kZWRQdWJsaWNLZXkuc2xpY2UoMCwgNCkgIT09ICd4cHViJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYW4gZXh0ZW5kZWQgcHVibGljIGtleScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdWJsaWNLZXkgPSBiczU4Y2hlY2suZGVjb2RlKGV4dGVuZGVkUHVibGljS2V5KS5zbGljZSg0NSk7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gYW4gRXRoZXJldW0gcHVibGljIGtleVxuICAgICAgICByZXR1cm4gV2FsbGV0LmZyb21QdWJsaWNLZXkocHVibGljS2V5LCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBiYXNlZCBvbiBhIHJhdyBwcml2YXRlIGtleVxuICAgICAqL1xuICAgIFdhbGxldC5mcm9tUHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgV2FsbGV0KHByaXZhdGVLZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIGJhc2VkIG9uIGEgQklQMzIgZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgKHhwcnYpXG4gICAgICovXG4gICAgV2FsbGV0LmZyb21FeHRlbmRlZFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoZXh0ZW5kZWRQcml2YXRlS2V5KSB7XG4gICAgICAgIGlmIChleHRlbmRlZFByaXZhdGVLZXkuc2xpY2UoMCwgNCkgIT09ICd4cHJ2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYW4gZXh0ZW5kZWQgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG1wID0gYnM1OGNoZWNrLmRlY29kZShleHRlbmRlZFByaXZhdGVLZXkpO1xuICAgICAgICBpZiAodG1wWzQ1XSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGV4dGVuZGVkIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFdhbGxldC5mcm9tUHJpdmF0ZUtleSh0bXAuc2xpY2UoNDYpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcG9ydCBhIHdhbGxldCAoVmVyc2lvbiAxIG9mIHRoZSBFdGhlcmV1bSB3YWxsZXQgZm9ybWF0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBBIEpTT04gc2VyaWFsaXplZCBzdHJpbmcsIG9yIGFuIG9iamVjdCByZXByZXNlbnRpbmcgVjEgS2V5c3RvcmUuXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFRoZSBrZXlzdG9yZSBwYXNzd29yZC5cbiAgICAgKi9cbiAgICBXYWxsZXQuZnJvbVYxID0gZnVuY3Rpb24gKGlucHV0LCBwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIganNvbiwga2RmcGFyYW1zLCBkZXJpdmVkS2V5LCBjaXBoZXJ0ZXh0LCBtYWMsIGRlY2lwaGVyLCBzZWVkO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgPyBpbnB1dCA6IEpTT04ucGFyc2UoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24uVmVyc2lvbiAhPT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBWMSBXYWxsZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uLkNyeXB0by5LZXlIZWFkZXIuS2RmICE9PSAnc2NyeXB0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2V5IGRlcml2YXRpb24gc2NoZW1lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBrZGZwYXJhbXMgPSBqc29uLkNyeXB0by5LZXlIZWFkZXIuS2RmUGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2NyeXB0X2pzXzEuc2NyeXB0KEJ1ZmZlci5mcm9tKHBhc3N3b3JkKSwgQnVmZmVyLmZyb20oanNvbi5DcnlwdG8uU2FsdCwgJ2hleCcpLCBrZGZwYXJhbXMuTiwga2RmcGFyYW1zLlIsIGtkZnBhcmFtcy5QLCBrZGZwYXJhbXMuRGtMZW4pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVyaXZlZEtleSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpcGhlcnRleHQgPSBCdWZmZXIuZnJvbShqc29uLkNyeXB0by5DaXBoZXJUZXh0LCAnaGV4Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWMgPSBldGhlcmV1bWpzX3V0aWxfMS5rZWNjYWsyNTYoQnVmZmVyLmNvbmNhdChbZGVyaXZlZEtleS5zbGljZSgxNiwgMzIpLCBjaXBoZXJ0ZXh0XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hYy50b1N0cmluZygnaGV4JykgIT09IGpzb24uQ3J5cHRvLk1BQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5IGRlcml2YXRpb24gZmFpbGVkIC0gcG9zc2libHkgd3JvbmcgcGFzc3BocmFzZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTEyOC1jYmMnLCBldGhlcmV1bWpzX3V0aWxfMS5rZWNjYWsyNTYoZGVyaXZlZEtleS5zbGljZSgwLCAxNikpLnNsaWNlKDAsIDE2KSwgQnVmZmVyLmZyb20oanNvbi5DcnlwdG8uSVYsICdoZXgnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVkID0gcnVuQ2lwaGVyQnVmZmVyKGRlY2lwaGVyLCBjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgV2FsbGV0KHNlZWQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbXBvcnQgYSB3YWxsZXQgKFZlcnNpb24gMyBvZiB0aGUgRXRoZXJldW0gd2FsbGV0IGZvcm1hdCkuIFNldCBgbm9uU3RyaWN0YCB0cnVlIHRvIGFjY2VwdCBmaWxlcyB3aXRoIG1peGVkLWNhcHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgQSBKU09OIHNlcmlhbGl6ZWQgc3RyaW5nLCBvciBhbiBvYmplY3QgcmVwcmVzZW50aW5nIFYzIEtleXN0b3JlLlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCBUaGUga2V5c3RvcmUgcGFzc3dvcmQuXG4gICAgICovXG4gICAgV2FsbGV0LmZyb21WMyA9IGZ1bmN0aW9uIChpbnB1dCwgcGFzc3dvcmQsIG5vblN0cmljdCkge1xuICAgICAgICBpZiAobm9uU3RyaWN0ID09PSB2b2lkIDApIHsgbm9uU3RyaWN0ID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGpzb24sIGRlcml2ZWRLZXksIGtkZnBhcmFtcywgY2lwaGVydGV4dCwgbWFjLCBkZWNpcGhlciwgc2VlZDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnID8gaW5wdXQgOiBKU09OLnBhcnNlKG5vblN0cmljdCA/IGlucHV0LnRvTG93ZXJDYXNlKCkgOiBpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi52ZXJzaW9uICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBWMyB3YWxsZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGpzb24uY3J5cHRvLmtkZiA9PT0gJ3NjcnlwdCcpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtkZnBhcmFtcyA9IGpzb24uY3J5cHRvLmtkZnBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNjcnlwdF9qc18xLnNjcnlwdChCdWZmZXIuZnJvbShwYXNzd29yZCksIEJ1ZmZlci5mcm9tKGtkZnBhcmFtcy5zYWx0LCAnaGV4JyksIGtkZnBhcmFtcy5uLCBrZGZwYXJhbXMuciwga2RmcGFyYW1zLnAsIGtkZnBhcmFtcy5ka2xlbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogc3VwcG9ydCBwcm9ncmVzcyByZXBvcnRpbmcgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24uY3J5cHRvLmtkZiA9PT0gJ3Bia2RmMicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZGZwYXJhbXMgPSBqc29uLmNyeXB0by5rZGZwYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtkZnBhcmFtcy5wcmYgIT09ICdobWFjLXNoYTI1NicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwYXJhbWV0ZXJzIHRvIFBCS0RGMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXJpdmVkS2V5ID0gY3J5cHRvLnBia2RmMlN5bmMoQnVmZmVyLmZyb20ocGFzc3dvcmQpLCBCdWZmZXIuZnJvbShrZGZwYXJhbXMuc2FsdCwgJ2hleCcpLCBrZGZwYXJhbXMuYywga2RmcGFyYW1zLmRrbGVuLCAnc2hhMjU2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtleSBkZXJpdmF0aW9uIHNjaGVtZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gQnVmZmVyLmZyb20oanNvbi5jcnlwdG8uY2lwaGVydGV4dCwgJ2hleCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFjID0gZXRoZXJldW1qc191dGlsXzEua2VjY2FrMjU2KEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKGRlcml2ZWRLZXkuc2xpY2UoMTYsIDMyKSksIGNpcGhlcnRleHRdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFjLnRvU3RyaW5nKCdoZXgnKSAhPT0ganNvbi5jcnlwdG8ubWFjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgZGVyaXZhdGlvbiBmYWlsZWQgLSBwb3NzaWJseSB3cm9uZyBwYXNzcGhyYXNlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGpzb24uY3J5cHRvLmNpcGhlciwgZGVyaXZlZEtleS5zbGljZSgwLCAxNiksIEJ1ZmZlci5mcm9tKGpzb24uY3J5cHRvLmNpcGhlcnBhcmFtcy5pdiwgJ2hleCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZWQgPSBydW5DaXBoZXJCdWZmZXIoZGVjaXBoZXIsIGNpcGhlcnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBXYWxsZXQoc2VlZCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qXG4gICAgICogSW1wb3J0IGFuIEV0aGVyZXVtIFByZSBTYWxlIHdhbGxldC5cbiAgICAgKiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vcHlldGhzYWxldG9vbC9ibG9iL21hc3Rlci9weWV0aHNhbGV0b29sLnB5XG4gICAgICogSlNPTiBmaWVsZHM6IGVuY3NlZWQsIGV0aGFkZHIsIGJ0Y2FkZHIsIGVtYWlsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgQSBKU09OIHNlcmlhbGl6ZWQgc3RyaW5nLCBvciBhbiBvYmplY3QgcmVwcmVzZW50aW5nIEV0aFNhbGUgS2V5c3RvcmUuXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFRoZSBrZXlzdG9yZSBwYXNzd29yZC5cbiAgICAgKi9cbiAgICBXYWxsZXQuZnJvbUV0aFNhbGUgPSBmdW5jdGlvbiAoaW5wdXQsIHBhc3N3b3JkKSB7XG4gICAgICAgIHZhciBqc29uID0gdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyA/IGlucHV0IDogSlNPTi5wYXJzZShpbnB1dCk7XG4gICAgICAgIHZhciBlbmNzZWVkID0gQnVmZmVyLmZyb20oanNvbi5lbmNzZWVkLCAnaGV4Jyk7XG4gICAgICAgIC8vIGtleSBkZXJpdmF0aW9uXG4gICAgICAgIHZhciBkZXJpdmVkS2V5ID0gY3J5cHRvLnBia2RmMlN5bmMocGFzc3dvcmQsIHBhc3N3b3JkLCAyMDAwLCAzMiwgJ3NoYTI1NicpLnNsaWNlKDAsIDE2KTtcbiAgICAgICAgLy8gc2VlZCBkZWNvZGluZyAoSVYgaXMgZmlyc3QgMTYgYnl0ZXMpXG4gICAgICAgIC8vIE5PVEU6IGNyeXB0byAoZGVyaXZlZCBmcm9tIG9wZW5zc2wpIHdoZW4gdXNlZCB3aXRoIGFlcy0qLWNiYyB3aWxsIGhhbmRsZSBQS0NTIzcgcGFkZGluZyBpbnRlcm5hbGx5XG4gICAgICAgIC8vICAgICAgIHNlZSBhbHNvIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxNjE0NzcwLzQ5NjQ4MTlcbiAgICAgICAgdmFyIGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoJ2Flcy0xMjgtY2JjJywgZGVyaXZlZEtleSwgZW5jc2VlZC5zbGljZSgwLCAxNikpO1xuICAgICAgICB2YXIgc2VlZCA9IHJ1bkNpcGhlckJ1ZmZlcihkZWNpcGhlciwgZW5jc2VlZC5zbGljZSgxNikpO1xuICAgICAgICB2YXIgd2FsbGV0ID0gbmV3IFdhbGxldChldGhlcmV1bWpzX3V0aWxfMS5rZWNjYWsyNTYoc2VlZCkpO1xuICAgICAgICBpZiAod2FsbGV0LmdldEFkZHJlc3MoKS50b1N0cmluZygnaGV4JykgIT09IGpzb24uZXRoYWRkcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGVkIGtleSBtaXNtYXRjaCAtIHBvc3NpYmx5IHdyb25nIHBhc3NwaHJhc2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdhbGxldC5wcm90b3R5cGUsIFwicHViS2V5XCIsIHtcbiAgICAgICAgLy8gcHJpdmF0ZSBnZXR0ZXJzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB3YWxsZXQncyBwdWJsaWMga2V5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWtleUV4aXN0cyh0aGlzLnB1YmxpY0tleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY0tleSA9IGV0aGVyZXVtanNfdXRpbF8xLnByaXZhdGVUb1B1YmxpYyh0aGlzLnByaXZhdGVLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVibGljS2V5O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdhbGxldC5wcm90b3R5cGUsIFwicHJpdktleVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB3YWxsZXQncyBwcml2YXRlIGtleS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFrZXlFeGlzdHModGhpcy5wcml2YXRlS2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBpcyBhIHB1YmxpYyBrZXkgb25seSB3YWxsZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVLZXk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvLyBwdWJsaWMgaW5zdGFuY2UgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdhbGxldCdzIHByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICovXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgV2FsbGV0LnByb3RvdHlwZS5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2S2V5O1xuICAgIH07XG4gICAgV2FsbGV0LnByb3RvdHlwZS5nZXRQcml2YXRlS2V5U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXRoZXJldW1qc191dGlsXzEuYnVmZmVyVG9IZXgodGhpcy5wcml2S2V5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdhbGxldCdzIHB1YmxpYyBrZXkuXG4gICAgICovXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgV2FsbGV0LnByb3RvdHlwZS5nZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YktleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdhbGxldCdzIHB1YmxpYyBrZXkgYXMgYSBcIjB4XCIgcHJlZml4ZWQgaGV4IHN0cmluZ1xuICAgICAqL1xuICAgIFdhbGxldC5wcm90b3R5cGUuZ2V0UHVibGljS2V5U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXRoZXJldW1qc191dGlsXzEuYnVmZmVyVG9IZXgodGhpcy5nZXRQdWJsaWNLZXkoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3YWxsZXQncyBhZGRyZXNzLlxuICAgICAqL1xuICAgIFdhbGxldC5wcm90b3R5cGUuZ2V0QWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLnB1YmxpY1RvQWRkcmVzcyh0aGlzLnB1YktleSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3YWxsZXQncyBhZGRyZXNzIGFzIGEgXCIweFwiIHByZWZpeGVkIGhleCBzdHJpbmdcbiAgICAgKi9cbiAgICBXYWxsZXQucHJvdG90eXBlLmdldEFkZHJlc3NTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS5idWZmZXJUb0hleCh0aGlzLmdldEFkZHJlc3MoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3YWxsZXQncyBwcml2YXRlIGtleSBhcyBhIFwiMHhcIiBwcmVmaXhlZCBoZXggc3RyaW5nIGNoZWNrc3VtbWVkXG4gICAgICogYWNjb3JkaW5nIHRvIFtFSVAgNTVdKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9FSVBzL2lzc3Vlcy81NSkuXG4gICAgICovXG4gICAgV2FsbGV0LnByb3RvdHlwZS5nZXRDaGVja3N1bUFkZHJlc3NTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS50b0NoZWNrc3VtQWRkcmVzcyh0aGlzLmdldEFkZHJlc3NTdHJpbmcoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIEV0aGVyZW0gVmVyc2lvbiAzIEtleXN0b3JlIEZvcm1hdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB3YWxsZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdXNlZCB0byBlbmNyeXB0IHRoZSBLZXlzdG9yZS5cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgb3B0aW9ucyBmb3IgdGhlIGtleXN0b3JlLiBTZWUgW2l0cyBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1dlYjMtU2VjcmV0LVN0b3JhZ2UtRGVmaW5pdGlvbikgZm9yIG1vcmUgaW5mby5cbiAgICAgKi9cbiAgICBXYWxsZXQucHJvdG90eXBlLnRvVjMgPSBmdW5jdGlvbiAocGFzc3dvcmQsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHYzUGFyYW1zLCBrZGZQYXJhbXMsIGRlcml2ZWRLZXksIF9hLCBjaXBoZXIsIGNpcGhlcnRleHQsIG1hYztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5RXhpc3RzKHRoaXMucHJpdmF0ZUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgaXMgYSBwdWJsaWMga2V5IG9ubHkgd2FsbGV0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2M1BhcmFtcyA9IG1lcmdlVG9WM1BhcmFtc1dpdGhEZWZhdWx0cyhvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdjNQYXJhbXMua2RmO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwYmtkZjJcIiAvKiBQQktERiAqLzogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjcnlwdFwiIC8qIFNjcnlwdCAqLzogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAga2RmUGFyYW1zID0ga2RmUGFyYW1zRm9yUEJLREYodjNQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVyaXZlZEtleSA9IGNyeXB0by5wYmtkZjJTeW5jKEJ1ZmZlci5mcm9tKHBhc3N3b3JkKSwga2RmUGFyYW1zLnNhbHQsIGtkZlBhcmFtcy5jLCBrZGZQYXJhbXMuZGtsZW4sICdzaGEyNTYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBrZGZQYXJhbXMgPSBrZGZQYXJhbXNGb3JTY3J5cHQodjNQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2NyeXB0X2pzXzEuc2NyeXB0KEJ1ZmZlci5mcm9tKHBhc3N3b3JkKSwga2RmUGFyYW1zLnNhbHQsIGtkZlBhcmFtcy5uLCBrZGZQYXJhbXMuciwga2RmUGFyYW1zLnAsIGtkZlBhcmFtcy5ka2xlbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogc3VwcG9ydCBwcm9ncmVzcyByZXBvcnRpbmcgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtkZicpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYodjNQYXJhbXMuY2lwaGVyLCBkZXJpdmVkS2V5LnNsaWNlKDAsIDE2KSwgdjNQYXJhbXMuaXYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaXBoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNpcGhlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2lwaGVydGV4dCA9IHJ1bkNpcGhlckJ1ZmZlcihjaXBoZXIsIHRoaXMucHJpdktleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWMgPSBldGhlcmV1bWpzX3V0aWxfMS5rZWNjYWsyNTYoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oZGVyaXZlZEtleS5zbGljZSgxNiwgMzIpKSwgQnVmZmVyLmZyb20oY2lwaGVydGV4dCldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdXVpZHY0KHsgcmFuZG9tOiB2M1BhcmFtcy51dWlkIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gdGhlIG9mZmljaWFsIFYzIGtleXN0b3JlIHNwZWMgb21pdHMgdGhlIGFkZHJlc3Mga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuZ2V0QWRkcmVzcygpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3J5cHRvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpcGhlcnBhcmFtczogeyBpdjogdjNQYXJhbXMuaXYudG9TdHJpbmcoJ2hleCcpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXBoZXI6IHYzUGFyYW1zLmNpcGhlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtkZjogdjNQYXJhbXMua2RmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2RmcGFyYW1zOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwga2RmUGFyYW1zKSwgeyBzYWx0OiBrZGZQYXJhbXMuc2FsdC50b1N0cmluZygnaGV4JykgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWM6IG1hYy50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzdWdnZXN0ZWQgZmlsZW5hbWUgZm9yIFYzIGtleXN0b3Jlcy5cbiAgICAgKi9cbiAgICBXYWxsZXQucHJvdG90eXBlLmdldFYzRmlsZW5hbWUgPSBmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFdlIHdhbnQgYSB0aW1lc3RhbXAgbGlrZSAyMDE2LTAzLTE1VDE3LTExLTMzLjAwNzU5ODI4OFouIERhdGUgZm9ybWF0dGluZ1xuICAgICAgICAgKiBpcyBhIHBhaW4gaW4gSmF2YXNjcmlwdCwgZXZlcmJvZHkga25vd3MgdGhhdC4gV2UgY291bGQgdXNlIG1vbWVudC5qcyxcbiAgICAgICAgICogYnV0IGRlY2lkZSB0byBkbyBpdCBtYW51YWxseSBpbiBvcmRlciB0byBzYXZlIHNwYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiB0b0pTT04oKSByZXR1cm5zIGEgcHJldHR5IGNsb3NlIHZlcnNpb24sIHNvIGxldCdzIHVzZSBpdC4gSXQgaXMgbm90IFVUQyB0aG91Z2gsXG4gICAgICAgICAqIGJ1dCBkb2VzIGl0IHJlYWxseSBtYXR0ZXI/XG4gICAgICAgICAqXG4gICAgICAgICAqIEFsdGVybmF0aXZlIG1hbnVhbCB3YXkgd2l0aCBwYWRkaW5nIGFuZCBEYXRlIGZpZWxkczogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzI0NDI4OC80OTY0ODE5XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdHMgPSB0aW1lc3RhbXAgPyBuZXcgRGF0ZSh0aW1lc3RhbXApIDogbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuIFsnVVRDLS0nLCB0cy50b0pTT04oKS5yZXBsYWNlKC86L2csICctJyksICctLScsIHRoaXMuZ2V0QWRkcmVzcygpLnRvU3RyaW5nKCdoZXgnKV0uam9pbignJyk7XG4gICAgfTtcbiAgICBXYWxsZXQucHJvdG90eXBlLnRvVjNTdHJpbmcgPSBmdW5jdGlvbiAocGFzc3dvcmQsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gSlNPTikuc3RyaW5naWZ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy50b1YzKHBhc3N3b3JkLCBvcHRzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBXYWxsZXQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gV2FsbGV0O1xuLy8gaGVscGVyc1xuZnVuY3Rpb24gcnVuQ2lwaGVyQnVmZmVyKGNpcGhlciwgZGF0YSkge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtjaXBoZXIudXBkYXRlKGRhdGEpLCBjaXBoZXIuZmluYWwoKV0pO1xufVxuZnVuY3Rpb24ga2V5RXhpc3RzKGspIHtcbiAgICByZXR1cm4gayAhPT0gdW5kZWZpbmVkICYmIGsgIT09IG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJjb25zdCBFdGggPSByZXF1aXJlKCdldGhqcycpXG5jb25zdCByZWdpc3RyeU1hcCA9IHJlcXVpcmUoJy4vcmVnaXN0cnktbWFwLmpzb24nKVxuY29uc3QgYWJpID0gcmVxdWlyZSgnLi9hYmknKVxuXG5jbGFzcyBNZXRob2RSZWdpc3RyeSB7XG5cbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSkge1xuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRzLnByb3ZpZGVyIHx8XG4gICAgICBuZXcgRXRoLkh0dHBQcm92aWRlcignaHR0cHM6Ly9tYWlubmV0LmluZnVyYS5pby9ldGgtY29udHJhY3QtcmVnaXN0cnknKVxuICAgIHRoaXMuZXRoID0gbmV3IEV0aCh0aGlzLnByb3ZpZGVyKVxuICAgIGNvbnN0IGFkZHJlc3MgPSByZWdpc3RyeU1hcFtvcHRzLm5ldHdvcmsgfHwgJzEnXVxuXG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1ldGhvZCByZWdpc3RyeSBmb3VuZCBvbiB0aGUgcmVxdWVzdGVkIG5ldHdvcmsuJylcbiAgICB9XG5cbiAgICB0aGlzLnJlZ2lzdHJ5ID0gdGhpcy5ldGguY29udHJhY3QoYWJpKS5hdChhZGRyZXNzKVxuICB9XG5cbiAgYXN5bmMgbG9va3VwIChieXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVnaXN0cnkuZW50cmllcyhieXRlcylcbiAgICByZXR1cm4gcmVzdWx0WzBdXG4gIH1cblxuICBwYXJzZSAoc2lnbmF0dXJlKSB7XG4gICAgbGV0IG5hbWUgPSBzaWduYXR1cmUubWF0Y2goL14uKyg/PVxcKCkvKVxuICAgIFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBuYW1lID0gbmFtZVswXS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWVbMF0uc2xpY2UoMSkuc3BsaXQoLyg/PVtBLVpdKS8pLmpvaW4oJyAnKVxuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gJydcbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaCA9IHNpZ25hdHVyZS5tYXRjaCgvXFwoLitcXCkvKVxuICAgIGxldCBhcmdzID0gW107XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBhcmdzID0gbWF0Y2hbMF0uc2xpY2UoMSwgLTEpLnNwbGl0KCcsJykubWFwKChhcmcpID0+IHsgcmV0dXJuIHt0eXBlOiBhcmd9fSlcbiAgICB9XG4gIFxuICAgIHJldHVybiB7XG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH1cbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWV0aG9kUmVnaXN0cnlcbiIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5UcmFuc2Zvcm1cbiAgLCBpbmhlcml0cyAgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbiAgLCB4dGVuZCAgICAgPSByZXF1aXJlKCd4dGVuZCcpXG5cbmZ1bmN0aW9uIERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdHMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0cylcbiAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoRGVzdHJveWFibGVUcmFuc2Zvcm0sIFRyYW5zZm9ybSlcblxuRGVzdHJveWFibGVUcmFuc2Zvcm0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWVcbiAgXG4gIHZhciBzZWxmID0gdGhpc1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGlmIChlcnIpXG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIHNlbGYuZW1pdCgnY2xvc2UnKVxuICB9KVxufVxuXG4vLyBhIG5vb3AgX3RyYW5zZm9ybSBmdW5jdGlvblxuZnVuY3Rpb24gbm9vcCAoY2h1bmssIGVuYywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sobnVsbCwgY2h1bmspXG59XG5cblxuLy8gY3JlYXRlIGEgbmV3IGV4cG9ydCBmdW5jdGlvbiwgdXNlZCBieSBib3RoIHRoZSBtYWluIGV4cG9ydCBhbmRcbi8vIHRoZSAuY3RvciBleHBvcnQsIGNvbnRhaW5zIGNvbW1vbiBsb2dpYyBmb3IgZGVhbGluZyB3aXRoIGFyZ3VtZW50c1xuZnVuY3Rpb24gdGhyb3VnaDIgKGNvbnN0cnVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmx1c2ggICAgID0gdHJhbnNmb3JtXG4gICAgICB0cmFuc2Zvcm0gPSBvcHRpb25zXG4gICAgICBvcHRpb25zICAgPSB7fVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtICE9ICdmdW5jdGlvbicpXG4gICAgICB0cmFuc2Zvcm0gPSBub29wXG5cbiAgICBpZiAodHlwZW9mIGZsdXNoICE9ICdmdW5jdGlvbicpXG4gICAgICBmbHVzaCA9IG51bGxcblxuICAgIHJldHVybiBjb25zdHJ1Y3Qob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaClcbiAgfVxufVxuXG5cbi8vIG1haW4gZXhwb3J0LCBqdXN0IG1ha2UgbWUgYSB0cmFuc2Zvcm0gc3RyZWFtIVxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0ob3B0aW9ucylcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuXG5cbi8vIG1ha2UgbWUgYSByZXVzYWJsZSBwcm90b3R5cGUgdGhhdCBJIGNhbiBgbmV3YCwgb3IgaW1wbGljaXRseSBgbmV3YFxuLy8gd2l0aCBhIGNvbnN0cnVjdG9yIGNhbGxcbm1vZHVsZS5leHBvcnRzLmN0b3IgPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICBmdW5jdGlvbiBUaHJvdWdoMiAob3ZlcnJpZGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGhyb3VnaDIpKVxuICAgICAgcmV0dXJuIG5ldyBUaHJvdWdoMihvdmVycmlkZSlcblxuICAgIHRoaXMub3B0aW9ucyA9IHh0ZW5kKG9wdGlvbnMsIG92ZXJyaWRlKVxuXG4gICAgRGVzdHJveWFibGVUcmFuc2Zvcm0uY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBpbmhlcml0cyhUaHJvdWdoMiwgRGVzdHJveWFibGVUcmFuc2Zvcm0pXG5cbiAgVGhyb3VnaDIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgVGhyb3VnaDIucHJvdG90eXBlLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIFRocm91Z2gyXG59KVxuXG5cbm1vZHVsZS5leHBvcnRzLm9iaiA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIHZhciB0MiA9IG5ldyBEZXN0cm95YWJsZVRyYW5zZm9ybSh4dGVuZCh7IG9iamVjdE1vZGU6IHRydWUsIGhpZ2hXYXRlck1hcms6IDE2IH0sIG9wdGlvbnMpKVxuXG4gIHQyLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgdDIuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gdDJcbn0pXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3Vic3RyZWFtID0gdm9pZCAwO1xuY29uc3QgcmVhZGFibGVfc3RyZWFtXzEgPSByZXF1aXJlKFwicmVhZGFibGUtc3RyZWFtXCIpO1xuY2xhc3MgU3Vic3RyZWFtIGV4dGVuZHMgcmVhZGFibGVfc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3Rvcih7IHBhcmVudCwgbmFtZSB9KSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwbGljaXRseSBzZXRzIHJlYWQgb3BlcmF0aW9ucyB0byBhIG5vLW9wLlxuICAgICAqL1xuICAgIF9yZWFkKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBkYXRhIHNob3VsZCBiZSB3cml0dGVuIHRvIHRoaXMgd3JpdGFibGUgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNodW5rIC0gQXJiaXRyYXJ5IG9iamVjdCB0byB3cml0ZVxuICAgICAqIEBwYXJhbSBlbmNvZGluZyAtIEVuY29kaW5nIHRvIHVzZSB3aGVuIHdyaXRpbmcgcGF5bG9hZFxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxlZCB3aGVuIHdyaXRpbmcgaXMgY29tcGxldGUgb3IgYW4gZXJyb3Igb2NjdXJzXG4gICAgICovXG4gICAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3BhcmVudC5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuX25hbWUsXG4gICAgICAgICAgICBkYXRhOiBjaHVuayxcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TdWJzdHJlYW0gPSBTdWJzdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VQb3N0TWVzc2FnZVN0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHJlYWRhYmxlX3N0cmVhbV8xID0gcmVxdWlyZShcInJlYWRhYmxlLXN0cmVhbVwiKTtcbmZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNvbnN0IFNZTiA9ICdTWU4nO1xuY29uc3QgQUNLID0gJ0FDSyc7XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHBvc3RNZXNzYWdlIHN0cmVhbXMuXG4gKi9cbmNsYXNzIEJhc2VQb3N0TWVzc2FnZVN0cmVhbSBleHRlbmRzIHJlYWRhYmxlX3N0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBmbGFnc1xuICAgICAgICB0aGlzLl9pbml0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hhdmVTeW4gPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVzdCBiZSBjYWxsZWQgYXQgZW5kIG9mIGNoaWxkIGNvbnN0cnVjdG9yIHRvIGluaXRpYXRlXG4gICAgICogY29tbXVuaWNhdGlvbiB3aXRoIG90aGVyIGVuZC5cbiAgICAgKi9cbiAgICBfaGFuZHNoYWtlKCkge1xuICAgICAgICAvLyBTZW5kIHN5bmNocm9uaXphdGlvbiBtZXNzYWdlXG4gICAgICAgIHRoaXMuX3dyaXRlKFNZTiwgbnVsbCwgbm9vcCk7XG4gICAgICAgIHRoaXMuY29yaygpO1xuICAgIH1cbiAgICBfb25EYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luaXQpIHtcbiAgICAgICAgICAgIC8vIEZvcndhcmQgbWVzc2FnZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YSA9PT0gU1lOKSB7XG4gICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGhhbmRzaGFrZVxuICAgICAgICAgICAgdGhpcy5faGF2ZVN5biA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl93cml0ZShBQ0ssIG51bGwsIG5vb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEgPT09IEFDSykge1xuICAgICAgICAgICAgdGhpcy5faW5pdCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hhdmVTeW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZShBQ0ssIG51bGwsIG5vb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bmNvcmsoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX3dyaXRlKGRhdGEsIF9lbmNvZGluZywgY2IpIHtcbiAgICAgICAgdGhpcy5fcG9zdE1lc3NhZ2UoZGF0YSk7XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlUG9zdE1lc3NhZ2VTdHJlYW0gPSBCYXNlUG9zdE1lc3NhZ2VTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlUG9zdE1lc3NhZ2VTdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFRElDQVRFRF9XT1JLRVJfTkFNRSA9IHZvaWQgMDtcbmV4cG9ydHMuREVESUNBVEVEX1dPUktFUl9OQU1FID0gJ2RlZGljYXRlZFdvcmtlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzICovXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xudmFyIGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbnZhciBjb21tb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQGV0aGVyZXVtanMvY29tbW9uXCIpKTtcbi8vIHNlY3AyNTZrMW4vMlxudmFyIE5fRElWXzIgPSBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oJzdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmNWQ1NzZlNzM1N2E0NTAxZGRmZTkyZjQ2NjgxYjIwYTAnLCAxNik7XG4vKipcbiAqIEFuIEV0aGVyZXVtIHRyYW5zYWN0aW9uLlxuICovXG52YXIgVHJhbnNhY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBjb25zdHJ1Y3RvciB0YWtlcyB0aGUgdmFsdWVzLCB2YWxpZGF0ZXMgdGhlbSwgYXNzaWducyB0aGVtIGFuZCBmcmVlemVzIHRoZSBvYmplY3QuXG4gICAgICogVXNlIHRoZSBzdGF0aWMgZmFjdG9yeSBtZXRob2RzIHRvIGFzc2lzdCBpbiBjcmVhdGluZyBhIFRyYW5zYWN0aW9uIG9iamVjdCBmcm9tIHZhcnlpbmcgZGF0YSB0eXBlcy5cbiAgICAgKiBAbm90ZSBUcmFuc2FjdGlvbiBvYmplY3RzIGltcGxlbWVudCBFSVAxNTUgYnkgZGVmYXVsdC4gVG8gZGlzYWJsZSBpdCwgcGFzcyBpbiBhbiBgQGV0aGVyZXVtanMvY29tbW9uYCBvYmplY3Qgc2V0IGJlZm9yZSBFSVAxNTUgYWN0aXZhdGlvbiAoaS5lLiBiZWZvcmUgU3B1cmlvdXMgRHJhZ29uKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbih0eERhdGEsIG9wdHMpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIG5vbmNlID0gdHhEYXRhLm5vbmNlLCBnYXNQcmljZSA9IHR4RGF0YS5nYXNQcmljZSwgZ2FzTGltaXQgPSB0eERhdGEuZ2FzTGltaXQsIHRvID0gdHhEYXRhLnRvLCB2YWx1ZSA9IHR4RGF0YS52YWx1ZSwgZGF0YSA9IHR4RGF0YS5kYXRhLCB2ID0gdHhEYXRhLnYsIHIgPSB0eERhdGEuciwgcyA9IHR4RGF0YS5zO1xuICAgICAgICB0aGlzLm5vbmNlID0gbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKGV0aGVyZXVtanNfdXRpbF8xLnRvQnVmZmVyKG5vbmNlKSk7XG4gICAgICAgIHRoaXMuZ2FzUHJpY2UgPSBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oZXRoZXJldW1qc191dGlsXzEudG9CdWZmZXIoZ2FzUHJpY2UpKTtcbiAgICAgICAgdGhpcy5nYXNMaW1pdCA9IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTihldGhlcmV1bWpzX3V0aWxfMS50b0J1ZmZlcihnYXNMaW1pdCkpO1xuICAgICAgICB0aGlzLnRvID0gdG8gPyBuZXcgZXRoZXJldW1qc191dGlsXzEuQWRkcmVzcyhldGhlcmV1bWpzX3V0aWxfMS50b0J1ZmZlcih0bykpIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKGV0aGVyZXVtanNfdXRpbF8xLnRvQnVmZmVyKHZhbHVlKSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGV0aGVyZXVtanNfdXRpbF8xLnRvQnVmZmVyKGRhdGEpO1xuICAgICAgICB0aGlzLnYgPSBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oZXRoZXJldW1qc191dGlsXzEudG9CdWZmZXIodikpO1xuICAgICAgICB0aGlzLnIgPSBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oZXRoZXJldW1qc191dGlsXzEudG9CdWZmZXIocikpO1xuICAgICAgICB0aGlzLnMgPSBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oZXRoZXJldW1qc191dGlsXzEudG9CdWZmZXIocykpO1xuICAgICAgICB2YXIgdmFsaWRhdGVDYW5ub3RFeGNlZWRNYXhJbnRlZ2VyID0ge1xuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXG4gICAgICAgICAgICBnYXNQcmljZTogdGhpcy5nYXNQcmljZSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0aGlzLmdhc0xpbWl0LFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICByOiB0aGlzLnIsXG4gICAgICAgICAgICBzOiB0aGlzLnMsXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKE9iamVjdC5lbnRyaWVzKHZhbGlkYXRlQ2Fubm90RXhjZWVkTWF4SW50ZWdlcikpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9lID0gX19yZWFkKF9kLnZhbHVlLCAyKSwga2V5ID0gX2VbMF0sIHZhbHVlXzEgPSBfZVsxXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVfMSAmJiB2YWx1ZV8xLmd0KGV0aGVyZXVtanNfdXRpbF8xLk1BWF9JTlRFR0VSKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioa2V5ICsgXCIgY2Fubm90IGV4Y2VlZCBNQVhfSU5URUdFUiwgZ2l2ZW4gXCIgKyB2YWx1ZV8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmNvbW1vbikge1xuICAgICAgICAgICAgdGhpcy5jb21tb24gPSBvcHRzLmNvbW1vbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBERUZBVUxUX0NIQUlOID0gJ21haW5uZXQnO1xuICAgICAgICAgICAgdGhpcy5jb21tb24gPSBuZXcgY29tbW9uXzEuZGVmYXVsdCh7IGNoYWluOiBERUZBVUxUX0NIQUlOIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlVHhWKHRoaXMudik7XG4gICAgICAgIHZhciBmcmVlemUgPSAoX2IgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZnJlZXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgICBpZiAoZnJlZXplKSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYW5zYWN0aW9uLmZyb21UeERhdGEgPSBmdW5jdGlvbiAodHhEYXRhLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24odHhEYXRhLCBvcHRzKTtcbiAgICB9O1xuICAgIFRyYW5zYWN0aW9uLmZyb21SbHBTZXJpYWxpemVkVHggPSBmdW5jdGlvbiAoc2VyaWFsaXplZCwgb3B0cykge1xuICAgICAgICB2YXIgdmFsdWVzID0gZXRoZXJldW1qc191dGlsXzEucmxwLmRlY29kZShzZXJpYWxpemVkKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJpYWxpemVkIHR4IGlucHV0LiBNdXN0IGJlIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVZhbHVlc0FycmF5KHZhbHVlcywgb3B0cyk7XG4gICAgfTtcbiAgICBUcmFuc2FjdGlvbi5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbiAodmFsdWVzLCBvcHRzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSA2ICYmIHZhbHVlcy5sZW5ndGggIT09IDkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbi4gT25seSBleHBlY3RpbmcgNiB2YWx1ZXMgKGZvciB1bnNpZ25lZCB0eCkgb3IgOSB2YWx1ZXMgKGZvciBzaWduZWQgdHgpLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCh2YWx1ZXMsIDkpLCBub25jZSA9IF9hWzBdLCBnYXNQcmljZSA9IF9hWzFdLCBnYXNMaW1pdCA9IF9hWzJdLCB0byA9IF9hWzNdLCB2YWx1ZSA9IF9hWzRdLCBkYXRhID0gX2FbNV0sIHYgPSBfYVs2XSwgciA9IF9hWzddLCBzID0gX2FbOF07XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgbm9uY2U6IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTihub25jZSksXG4gICAgICAgICAgICBnYXNQcmljZTogbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKGdhc1ByaWNlKSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oZ2FzTGltaXQpLFxuICAgICAgICAgICAgdG86IHRvICYmIHRvLmxlbmd0aCA+IDAgPyBuZXcgZXRoZXJldW1qc191dGlsXzEuQWRkcmVzcyh0bykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKHZhbHVlKSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEgfHwgYnVmZmVyXzEuQnVmZmVyLmZyb20oW10pLFxuICAgICAgICAgICAgdjogdiA/IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTih2KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHI6IHIgPyBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4ocikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzOiBzID8gbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKHMpIDogdW5kZWZpbmVkLFxuICAgICAgICB9LCBvcHRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoZSB0eCdzIGB0b2AgaXMgdG8gdGhlIGNyZWF0aW9uIGFkZHJlc3NcbiAgICAgKi9cbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUudG9DcmVhdGlvbkFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvID09PSB1bmRlZmluZWQgfHwgdGhpcy50by5idWYubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYSBzaGEzLTI1NiBoYXNoIG9mIHRoZSBzZXJpYWxpemVkIHR4XG4gICAgICovXG4gICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXG4gICAgICAgICAgICBldGhlcmV1bWpzX3V0aWxfMS5iblRvUmxwKHRoaXMubm9uY2UpLFxuICAgICAgICAgICAgZXRoZXJldW1qc191dGlsXzEuYm5Ub1JscCh0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIGV0aGVyZXVtanNfdXRpbF8xLmJuVG9SbHAodGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICB0aGlzLnRvICE9PSB1bmRlZmluZWQgPyB0aGlzLnRvLmJ1ZiA6IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFtdKSxcbiAgICAgICAgICAgIGV0aGVyZXVtanNfdXRpbF8xLmJuVG9SbHAodGhpcy52YWx1ZSksXG4gICAgICAgICAgICB0aGlzLmRhdGEsXG4gICAgICAgICAgICB0aGlzLnYgPyBldGhlcmV1bWpzX3V0aWxfMS5iblRvUmxwKHRoaXMudikgOiBidWZmZXJfMS5CdWZmZXIuZnJvbShbXSksXG4gICAgICAgICAgICB0aGlzLnIgPyBldGhlcmV1bWpzX3V0aWxfMS5iblRvUmxwKHRoaXMucikgOiBidWZmZXJfMS5CdWZmZXIuZnJvbShbXSksXG4gICAgICAgICAgICB0aGlzLnMgPyBldGhlcmV1bWpzX3V0aWxfMS5iblRvUmxwKHRoaXMucykgOiBidWZmZXJfMS5CdWZmZXIuZnJvbShbXSksXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS5ybHBoYXNoKHZhbHVlcyk7XG4gICAgfTtcbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuZ2V0TWVzc2FnZVRvU2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1lc3NhZ2VUb1NpZ24odGhpcy5fdW5zaWduZWRUeEltcGxlbWVudHNFSVAxNTUoKSk7XG4gICAgfTtcbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuZ2V0TWVzc2FnZVRvVmVyaWZ5U2lnbmF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TWVzc2FnZVRvU2lnbih0aGlzLl9zaWduZWRUeEltcGxlbWVudHNFSVAxNTUoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNoYWluIElEXG4gICAgICovXG4gICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmdldENoYWluSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1vbi5jaGFpbklkKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZW5kZXIncyBhZGRyZXNzXG4gICAgICovXG4gICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlckFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXRoZXJldW1qc191dGlsXzEuQWRkcmVzcyhldGhlcmV1bWpzX3V0aWxfMS5wdWJsaWNUb0FkZHJlc3ModGhpcy5nZXRTZW5kZXJQdWJsaWNLZXkoKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHVibGljIGtleSBvZiB0aGUgc2VuZGVyXG4gICAgICovXG4gICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlclB1YmxpY0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1zZ0hhc2ggPSB0aGlzLmdldE1lc3NhZ2VUb1ZlcmlmeVNpZ25hdHVyZSgpO1xuICAgICAgICAvLyBBbGwgdHJhbnNhY3Rpb24gc2lnbmF0dXJlcyB3aG9zZSBzLXZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBzZWNwMjU2azFuLzIgYXJlIGNvbnNpZGVyZWQgaW52YWxpZC5cbiAgICAgICAgaWYgKHRoaXMuY29tbW9uLmd0ZUhhcmRmb3JrKCdob21lc3RlYWQnKSAmJiB0aGlzLnMgJiYgdGhpcy5zLmd0KE5fRElWXzIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgU2lnbmF0dXJlOiBzLXZhbHVlcyBncmVhdGVyIHRoYW4gc2VjcDI1Nmsxbi8yIGFyZSBjb25zaWRlcmVkIGludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLCB2ID0gX2EudiwgciA9IF9hLnIsIHMgPSBfYS5zO1xuICAgICAgICBpZiAoIXYgfHwgIXIgfHwgIXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2YWx1ZXMgdG8gZGVyaXZlIHNlbmRlciBwdWJsaWMga2V5IGZyb20gc2lnbmVkIHR4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS5lY3JlY292ZXIobXNnSGFzaCwgdi50b051bWJlcigpLCBldGhlcmV1bWpzX3V0aWxfMS5iblRvUmxwKHIpLCBldGhlcmV1bWpzX3V0aWxfMS5iblRvUmxwKHMpLCB0aGlzLl9zaWduZWRUeEltcGxlbWVudHNFSVAxNTUoKSA/IHRoaXMuZ2V0Q2hhaW5JZCgpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFNpZ25hdHVyZScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBzaWduYXR1cmUgaXMgdmFsaWRcbiAgICAgKi9cbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUudmVyaWZ5U2lnbmF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTWFpbiBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGlzIGRvbmUgaW4gYGdldFNlbmRlclB1YmxpY0tleSgpYFxuICAgICAgICAgICAgdmFyIHB1YmxpY0tleSA9IHRoaXMuZ2V0U2VuZGVyUHVibGljS2V5KCk7XG4gICAgICAgICAgICByZXR1cm4gZXRoZXJldW1qc191dGlsXzEudW5wYWRCdWZmZXIocHVibGljS2V5KS5sZW5ndGggIT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2lnbiBhIHRyYW5zYWN0aW9uIHdpdGggYSBnaXZlbiBwcml2YXRlIGtleS5cbiAgICAgKiBSZXR1cm5zIGEgbmV3IFRyYW5zYWN0aW9uIG9iamVjdCAodGhlIG9yaWdpbmFsIHR4IHdpbGwgbm90IGJlIG1vZGlmaWVkKS5cbiAgICAgKiBFeGFtcGxlOlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCB1bnNpZ25lZFR4ID0gVHJhbnNhY3Rpb24uZnJvbVR4RGF0YSh0eERhdGEpXG4gICAgICogY29uc3Qgc2lnbmVkVHggPSB1bnNpZ25lZFR4LnNpZ24ocHJpdktleSlcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBNdXN0IGJlIDMyIGJ5dGVzIGluIGxlbmd0aC5cbiAgICAgKi9cbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgICAgIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJpdmF0ZSBrZXkgbXVzdCBiZSAzMiBieXRlcyBpbiBsZW5ndGguJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1zZ0hhc2ggPSB0aGlzLmdldE1lc3NhZ2VUb1NpZ24oKTtcbiAgICAgICAgLy8gT25seSBgdmAgaXMgcmVhc3NpZ25lZC5cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdCAqL1xuICAgICAgICB2YXIgX2EgPSBldGhlcmV1bWpzX3V0aWxfMS5lY3NpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSksIHYgPSBfYS52LCByID0gX2EuciwgcyA9IF9hLnM7XG4gICAgICAgIGlmICh0aGlzLl91bnNpZ25lZFR4SW1wbGVtZW50c0VJUDE1NSgpKSB7XG4gICAgICAgICAgICB2ICs9IHRoaXMuZ2V0Q2hhaW5JZCgpICogMiArIDg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICBjb21tb246IHRoaXMuY29tbW9uLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRoaXMuZ2FzUHJpY2UsXG4gICAgICAgICAgICBnYXNMaW1pdDogdGhpcy5nYXNMaW1pdCxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICB2OiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4odiksXG4gICAgICAgICAgICByOiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4ociksXG4gICAgICAgICAgICBzOiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4ocyksXG4gICAgICAgIH0sIG9wdHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGFtb3VudCBvZiBnYXMgcGFpZCBmb3IgdGhlIGRhdGEgaW4gdGhpcyB0eFxuICAgICAqL1xuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5nZXREYXRhRmVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHhEYXRhWmVybyA9IHRoaXMuY29tbW9uLnBhcmFtKCdnYXNQcmljZXMnLCAndHhEYXRhWmVybycpO1xuICAgICAgICB2YXIgdHhEYXRhTm9uWmVybyA9IHRoaXMuY29tbW9uLnBhcmFtKCdnYXNQcmljZXMnLCAndHhEYXRhTm9uWmVybycpO1xuICAgICAgICB2YXIgY29zdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPT09IDAgPyAoY29zdCArPSB0eERhdGFaZXJvKSA6IChjb3N0ICs9IHR4RGF0YU5vblplcm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oY29zdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWluaW11bSBhbW91bnQgb2YgZ2FzIHRoZSB0eCBtdXN0IGhhdmUgKERhdGFGZWUgKyBUeEZlZSArIENyZWF0aW9uIEZlZSlcbiAgICAgKi9cbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuZ2V0QmFzZUZlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZlZSA9IHRoaXMuZ2V0RGF0YUZlZSgpLmFkZG4odGhpcy5jb21tb24ucGFyYW0oJ2dhc1ByaWNlcycsICd0eCcpKTtcbiAgICAgICAgaWYgKHRoaXMuY29tbW9uLmd0ZUhhcmRmb3JrKCdob21lc3RlYWQnKSAmJiB0aGlzLnRvQ3JlYXRpb25BZGRyZXNzKCkpIHtcbiAgICAgICAgICAgIGZlZS5pYWRkbih0aGlzLmNvbW1vbi5wYXJhbSgnZ2FzUHJpY2VzJywgJ3R4Q3JlYXRpb24nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZlZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB1cCBmcm9udCBhbW91bnQgdGhhdCBhbiBhY2NvdW50IG11c3QgaGF2ZSBmb3IgdGhpcyB0cmFuc2FjdGlvbiB0byBiZSB2YWxpZFxuICAgICAqL1xuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5nZXRVcGZyb250Q29zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FzTGltaXQubXVsKHRoaXMuZ2FzUHJpY2UpLmFkZCh0aGlzLnZhbHVlKTtcbiAgICB9O1xuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChzdHJpbmdFcnJvcikge1xuICAgICAgICBpZiAoc3RyaW5nRXJyb3IgPT09IHZvaWQgMCkgeyBzdHJpbmdFcnJvciA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLnZlcmlmeVNpZ25hdHVyZSgpKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCgnSW52YWxpZCBTaWduYXR1cmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXRCYXNlRmVlKCkuZ3QodGhpcy5nYXNMaW1pdCkpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiZ2FzTGltaXQgaXMgdG9vIGxvdy4gZ2l2ZW4gXCIgKyB0aGlzLmdhc0xpbWl0ICsgXCIsIG5lZWQgYXQgbGVhc3QgXCIgKyB0aGlzLmdldEJhc2VGZWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ0Vycm9yID8gZXJyb3JzIDogZXJyb3JzLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCdWZmZXIgQXJyYXkgb2YgdGhlIHJhdyBCdWZmZXJzIG9mIHRoaXMgdHJhbnNhY3Rpb24sIGluIG9yZGVyLlxuICAgICAqL1xuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBldGhlcmV1bWpzX3V0aWxfMS5iblRvUmxwKHRoaXMubm9uY2UpLFxuICAgICAgICAgICAgZXRoZXJldW1qc191dGlsXzEuYm5Ub1JscCh0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIGV0aGVyZXVtanNfdXRpbF8xLmJuVG9SbHAodGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICB0aGlzLnRvICE9PSB1bmRlZmluZWQgPyB0aGlzLnRvLmJ1ZiA6IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFtdKSxcbiAgICAgICAgICAgIGV0aGVyZXVtanNfdXRpbF8xLmJuVG9SbHAodGhpcy52YWx1ZSksXG4gICAgICAgICAgICB0aGlzLmRhdGEsXG4gICAgICAgICAgICB0aGlzLnYgIT09IHVuZGVmaW5lZCA/IGV0aGVyZXVtanNfdXRpbF8xLmJuVG9SbHAodGhpcy52KSA6IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFtdKSxcbiAgICAgICAgICAgIHRoaXMuciAhPT0gdW5kZWZpbmVkID8gZXRoZXJldW1qc191dGlsXzEuYm5Ub1JscCh0aGlzLnIpIDogYnVmZmVyXzEuQnVmZmVyLmZyb20oW10pLFxuICAgICAgICAgICAgdGhpcy5zICE9PSB1bmRlZmluZWQgPyBldGhlcmV1bWpzX3V0aWxfMS5iblRvUmxwKHRoaXMucykgOiBidWZmZXJfMS5CdWZmZXIuZnJvbShbXSksXG4gICAgICAgIF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBybHAgZW5jb2Rpbmcgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS5ybHAuZW5jb2RlKHRoaXMucmF3KCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9uY2U6IGV0aGVyZXVtanNfdXRpbF8xLmJuVG9IZXgodGhpcy5ub25jZSksXG4gICAgICAgICAgICBnYXNQcmljZTogZXRoZXJldW1qc191dGlsXzEuYm5Ub0hleCh0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBldGhlcmV1bWpzX3V0aWxfMS5iblRvSGV4KHRoaXMuZ2FzTGltaXQpLFxuICAgICAgICAgICAgdG86IHRoaXMudG8gIT09IHVuZGVmaW5lZCA/IHRoaXMudG8udG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbHVlOiBldGhlcmV1bWpzX3V0aWxfMS5iblRvSGV4KHRoaXMudmFsdWUpLFxuICAgICAgICAgICAgZGF0YTogJzB4JyArIHRoaXMuZGF0YS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICB2OiB0aGlzLnYgIT09IHVuZGVmaW5lZCA/IGV0aGVyZXVtanNfdXRpbF8xLmJuVG9IZXgodGhpcy52KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHI6IHRoaXMuciAhPT0gdW5kZWZpbmVkID8gZXRoZXJldW1qc191dGlsXzEuYm5Ub0hleCh0aGlzLnIpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgczogdGhpcy5zICE9PSB1bmRlZmluZWQgPyBldGhlcmV1bWpzX3V0aWxfMS5iblRvSGV4KHRoaXMucykgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuaXNTaWduZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHYgPSBfYS52LCByID0gX2EuciwgcyA9IF9hLnM7XG4gICAgICAgIHJldHVybiAhIXYgJiYgISFyICYmICEhcztcbiAgICB9O1xuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fdW5zaWduZWRUeEltcGxlbWVudHNFSVAxNTUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1vbi5ndGVIYXJkZm9yaygnc3B1cmlvdXNEcmFnb24nKTtcbiAgICB9O1xuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fc2lnbmVkVHhJbXBsZW1lbnRzRUlQMTU1ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5pc1NpZ25lZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVGhpcyB0cmFuc2FjdGlvbiBpcyBub3Qgc2lnbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9uRUlQMTU1QmxvY2tPckxhdGVyID0gdGhpcy5jb21tb24uZ3RlSGFyZGZvcmsoJ3NwdXJpb3VzRHJhZ29uJyk7XG4gICAgICAgIC8vIEVJUDE1NSBzcGVjOlxuICAgICAgICAvLyBJZiBibG9jay5udW1iZXIgPj0gMiw2NzUsMDAwIGFuZCB2ID0gQ0hBSU5fSUQgKiAyICsgMzUgb3IgdiA9IENIQUlOX0lEICogMiArIDM2LCB0aGVuIHdoZW4gY29tcHV0aW5nIHRoZSBoYXNoIG9mIGEgdHJhbnNhY3Rpb24gZm9yIHB1cnBvc2VzIG9mIHNpZ25pbmcgb3IgcmVjb3ZlcmluZywgaW5zdGVhZCBvZiBoYXNoaW5nIG9ubHkgdGhlIGZpcnN0IHNpeCBlbGVtZW50cyAoaS5lLiBub25jZSwgZ2FzcHJpY2UsIHN0YXJ0Z2FzLCB0bywgdmFsdWUsIGRhdGEpLCBoYXNoIG5pbmUgZWxlbWVudHMsIHdpdGggdiByZXBsYWNlZCBieSBDSEFJTl9JRCwgciA9IDAgYW5kIHMgPSAwLlxuICAgICAgICB2YXIgdiA9IChfYSA9IHRoaXMudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTnVtYmVyKCk7XG4gICAgICAgIHZhciB2QW5kQ2hhaW5JZE1lZXRFSVAxNTVDb25kaXRpb25zID0gdiA9PT0gdGhpcy5nZXRDaGFpbklkKCkgKiAyICsgMzUgfHwgdiA9PT0gdGhpcy5nZXRDaGFpbklkKCkgKiAyICsgMzY7XG4gICAgICAgIHJldHVybiB2QW5kQ2hhaW5JZE1lZXRFSVAxNTVDb25kaXRpb25zICYmIG9uRUlQMTU1QmxvY2tPckxhdGVyO1xuICAgIH07XG4gICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9nZXRNZXNzYWdlVG9TaWduID0gZnVuY3Rpb24gKHdpdGhFSVAxNTUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtcbiAgICAgICAgICAgIGV0aGVyZXVtanNfdXRpbF8xLmJuVG9SbHAodGhpcy5ub25jZSksXG4gICAgICAgICAgICBldGhlcmV1bWpzX3V0aWxfMS5iblRvUmxwKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgZXRoZXJldW1qc191dGlsXzEuYm5Ub1JscCh0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIHRoaXMudG8gIT09IHVuZGVmaW5lZCA/IHRoaXMudG8uYnVmIDogYnVmZmVyXzEuQnVmZmVyLmZyb20oW10pLFxuICAgICAgICAgICAgZXRoZXJldW1qc191dGlsXzEuYm5Ub1JscCh0aGlzLnZhbHVlKSxcbiAgICAgICAgICAgIHRoaXMuZGF0YSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHdpdGhFSVAxNTUpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGV0aGVyZXVtanNfdXRpbF8xLnRvQnVmZmVyKHRoaXMuZ2V0Q2hhaW5JZCgpKSk7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChldGhlcmV1bWpzX3V0aWxfMS51bnBhZEJ1ZmZlcihldGhlcmV1bWpzX3V0aWxfMS50b0J1ZmZlcigwKSkpO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goZXRoZXJldW1qc191dGlsXzEudW5wYWRCdWZmZXIoZXRoZXJldW1qc191dGlsXzEudG9CdWZmZXIoMCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXRoZXJldW1qc191dGlsXzEucmxwaGFzaCh2YWx1ZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHR4J3MgYHZgIHZhbHVlXG4gICAgICovXG4gICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLl92YWxpZGF0ZVR4ViA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdi50b051bWJlcigpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbW1vbi5ndGVIYXJkZm9yaygnc3B1cmlvdXNEcmFnb24nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2SW50ID0gdi50b051bWJlcigpO1xuICAgICAgICBpZiAodkludCA9PT0gMjcgfHwgdkludCA9PT0gMjgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNWYWxpZEVJUDE1NVYgPSB2SW50ID09PSB0aGlzLmdldENoYWluSWQoKSAqIDIgKyAzNSB8fCB2SW50ID09PSB0aGlzLmdldENoYWluSWQoKSAqIDIgKyAzNjtcbiAgICAgICAgaWYgKCFpc1ZhbGlkRUlQMTU1Vikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb21wYXRpYmxlIEVJUDE1NS1iYXNlZCBWIFwiICsgdkludCArIFwiIGFuZCBjaGFpbiBpZCBcIiArIHRoaXMuZ2V0Q2hhaW5JZCgpICsgXCIuIFNlZSB0aGUgQ29tbW9uIHBhcmFtZXRlciBvZiB0aGUgVHJhbnNhY3Rpb24gY29uc3RydWN0b3IgdG8gc2V0IHRoZSBjaGFpbiBpZC5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUcmFuc2FjdGlvbjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUcmFuc2FjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB0LGU9cmVxdWlyZShcIkBrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5XCIpLHM9cmVxdWlyZShcInV1aWRcIiksYT0odD1yZXF1aXJlKFwiaGRrZXlcIikpJiZcIm9iamVjdFwiPT10eXBlb2YgdCYmXCJkZWZhdWx0XCJpbiB0P3QuZGVmYXVsdDp0LGk9cmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtjb25zdHtSZWdpc3RyeVR5cGU6cn09ZS5leHRlbmQsbj17RVRIX1NJR05fUkVRVUVTVDpuZXcgcihcImV0aC1zaWduLXJlcXVlc3RcIiw0MDEpLEVUSF9TSUdOQVRBVVJFOm5ldyByKFwiZXRoLXNpZ25hdHVyZVwiLDQwMil9LHtkZWNvZGVUb0RhdGFJdGVtOmQsUmVnaXN0cnlUeXBlczpvfT1lLmV4dGVuZDt2YXIgaCx1OyFmdW5jdGlvbih0KXt0W3QucmVxdWVzdElkPTFdPVwicmVxdWVzdElkXCIsdFt0LnNpZ25EYXRhPTJdPVwic2lnbkRhdGFcIix0W3QuZGF0YVR5cGU9M109XCJkYXRhVHlwZVwiLHRbdC5jaGFpbklkPTRdPVwiY2hhaW5JZFwiLHRbdC5kZXJpdmF0aW9uUGF0aD01XT1cImRlcml2YXRpb25QYXRoXCIsdFt0LmFkZHJlc3M9Nl09XCJhZGRyZXNzXCIsdFt0Lm9yaWdpbj03XT1cIm9yaWdpblwifShofHwoaD17fSkpLCh1PWV4cG9ydHMuRGF0YVR5cGV8fChleHBvcnRzLkRhdGFUeXBlPXt9KSlbdS50cmFuc2FjdGlvbj0xXT1cInRyYW5zYWN0aW9uXCIsdVt1LnR5cGVkRGF0YT0yXT1cInR5cGVkRGF0YVwiLHVbdS5wZXJzb25hbE1lc3NhZ2U9M109XCJwZXJzb25hbE1lc3NhZ2VcIix1W3UudHlwZWRUcmFuc2FjdGlvbj00XT1cInR5cGVkVHJhbnNhY3Rpb25cIjtjbGFzcyBnIGV4dGVuZHMgZS5SZWdpc3RyeUl0ZW17Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLmdldFJlZ2lzdHJ5VHlwZT0oKT0+bi5FVEhfU0lHTl9SRVFVRVNULHRoaXMuc2V0dXBEYXRhPXQ9Pnt0aGlzLnJlcXVlc3RJZD10LnJlcXVlc3RJZCx0aGlzLnNpZ25EYXRhPXQuc2lnbkRhdGEsdGhpcy5kYXRhVHlwZT10LmRhdGFUeXBlLHRoaXMuY2hhaW5JZD10LmNoYWluSWQsdGhpcy5kZXJpdmF0aW9uUGF0aD10LmRlcml2YXRpb25QYXRoLHRoaXMuYWRkcmVzcz10LmFkZHJlc3MsdGhpcy5vcmlnaW49dC5vcmlnaW59LHRoaXMuZ2V0UmVxdWVzdElkPSgpPT50aGlzLnJlcXVlc3RJZCx0aGlzLmdldFNpZ25EYXRhPSgpPT50aGlzLnNpZ25EYXRhLHRoaXMuZ2V0RGF0YVR5cGU9KCk9PnRoaXMuZGF0YVR5cGUsdGhpcy5nZXRDaGFpbklkPSgpPT50aGlzLmNoYWluSWQsdGhpcy5nZXREZXJpdmF0aW9uUGF0aD0oKT0+dGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRQYXRoKCksdGhpcy5nZXRTaWduUmVxdWVzdEFkZHJlc3M9KCk9PnRoaXMuYWRkcmVzcyx0aGlzLmdldE9yaWdpbj0oKT0+dGhpcy5vcmlnaW4sdGhpcy50b0RhdGFJdGVtPSgpPT57Y29uc3QgdD17fTt0aGlzLnJlcXVlc3RJZCYmKHRbaC5yZXF1ZXN0SWRdPW5ldyBlLkRhdGFJdGVtKHRoaXMucmVxdWVzdElkLG8uVVVJRC5nZXRUYWcoKSkpLHRoaXMuYWRkcmVzcyYmKHRbaC5hZGRyZXNzXT10aGlzLmFkZHJlc3MpLHRoaXMuY2hhaW5JZCYmKHRbaC5jaGFpbklkXT10aGlzLmNoYWluSWQpLHRoaXMub3JpZ2luJiYodFtoLm9yaWdpbl09dGhpcy5vcmlnaW4pLHRbaC5zaWduRGF0YV09dGhpcy5zaWduRGF0YSx0W2guZGF0YVR5cGVdPXRoaXMuZGF0YVR5cGU7Y29uc3Qgcz10aGlzLmRlcml2YXRpb25QYXRoLnRvRGF0YUl0ZW0oKTtyZXR1cm4gcy5zZXRUYWcodGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSksdFtoLmRlcml2YXRpb25QYXRoXT1zLG5ldyBlLkRhdGFJdGVtKHQpfSx0aGlzLnNldHVwRGF0YSh0KX1zdGF0aWMgY29uc3RydWN0RVRIUmVxdWVzdCh0LGEsaSxyLG4sZCxvLGgpe2NvbnN0IHU9aS5yZXBsYWNlKC9bbXxNXVxcLy8sXCJcIikuc3BsaXQoXCIvXCIpLGM9bmV3IGUuQ3J5cHRvS2V5cGF0aCh1Lm1hcCh0PT57Y29uc3Qgcz1wYXJzZUludCh0LnJlcGxhY2UoXCInXCIsXCJcIikpO2xldCBhPSExO3JldHVybiB0LmVuZHNXaXRoKFwiJ1wiKSYmKGE9ITApLG5ldyBlLlBhdGhDb21wb25lbnQoe2luZGV4OnMsaGFyZGVuZWQ6YX0pfSksQnVmZmVyLmZyb20ocixcImhleFwiKSk7cmV0dXJuIG5ldyBnKHtyZXF1ZXN0SWQ6bj9CdWZmZXIuZnJvbShzLnBhcnNlKG4pKTp2b2lkIDAsc2lnbkRhdGE6dCxkYXRhVHlwZTphLGRlcml2YXRpb25QYXRoOmMsY2hhaW5JZDpkLGFkZHJlc3M6bz9CdWZmZXIuZnJvbShvLnJlcGxhY2UoXCIweFwiLFwiXCIpLFwiaGV4XCIpOnZvaWQgMCxvcmlnaW46aHx8dm9pZCAwfSl9fWcuZnJvbURhdGFJdGVtPXQ9Pntjb25zdCBzPXQuZ2V0RGF0YSgpLGE9c1toLnNpZ25EYXRhXSxpPXNbaC5kYXRhVHlwZV0scj1lLkNyeXB0b0tleXBhdGguZnJvbURhdGFJdGVtKHNbaC5kZXJpdmF0aW9uUGF0aF0pLG49c1toLmNoYWluSWRdP3NbaC5jaGFpbklkXTp2b2lkIDAsZD1zW2guYWRkcmVzc10/c1toLmFkZHJlc3NdOnZvaWQgMCxvPXNbaC5yZXF1ZXN0SWRdP3NbaC5yZXF1ZXN0SWRdLmdldERhdGEoKTp2b2lkIDA7cmV0dXJuIG5ldyBnKHtyZXF1ZXN0SWQ6byxzaWduRGF0YTphLGRhdGFUeXBlOmksY2hhaW5JZDpuLGRlcml2YXRpb25QYXRoOnIsYWRkcmVzczpkLG9yaWdpbjpzW2gub3JpZ2luXT9zW2gub3JpZ2luXTp2b2lkIDB9KX0sZy5mcm9tQ0JPUj10PT57Y29uc3QgZT1kKHQpO3JldHVybiBnLmZyb21EYXRhSXRlbShlKX07Y29uc3R7UmVnaXN0cnlUeXBlczpjLGRlY29kZVRvRGF0YUl0ZW06SX09ZS5leHRlbmQ7dmFyIHA7IWZ1bmN0aW9uKHQpe3RbdC5yZXF1ZXN0SWQ9MV09XCJyZXF1ZXN0SWRcIix0W3Quc2lnbmF0dXJlPTJdPVwic2lnbmF0dXJlXCJ9KHB8fChwPXt9KSk7Y2xhc3MgeSBleHRlbmRzIGUuUmVnaXN0cnlJdGVte2NvbnN0cnVjdG9yKHQscyl7c3VwZXIoKSx0aGlzLmdldFJlZ2lzdHJ5VHlwZT0oKT0+bi5FVEhfU0lHTkFUQVVSRSx0aGlzLmdldFJlcXVlc3RJZD0oKT0+dGhpcy5yZXF1ZXN0SWQsdGhpcy5nZXRTaWduYXR1cmU9KCk9PnRoaXMuc2lnbmF0dXJlLHRoaXMudG9EYXRhSXRlbT0oKT0+e2NvbnN0IHQ9e307cmV0dXJuIHRoaXMucmVxdWVzdElkJiYodFtwLnJlcXVlc3RJZF09bmV3IGUuRGF0YUl0ZW0odGhpcy5yZXF1ZXN0SWQsYy5VVUlELmdldFRhZygpKSksdFtwLnNpZ25hdHVyZV09dGhpcy5zaWduYXR1cmUsbmV3IGUuRGF0YUl0ZW0odCl9LHRoaXMuc2lnbmF0dXJlPXQsdGhpcy5yZXF1ZXN0SWQ9c319eS5mcm9tRGF0YUl0ZW09dD0+e2NvbnN0IGU9dC5nZXREYXRhKCkscz1lW3Auc2lnbmF0dXJlXSxhPWVbcC5yZXF1ZXN0SWRdP2VbcC5yZXF1ZXN0SWRdLmdldERhdGEoKTp2b2lkIDA7cmV0dXJuIG5ldyB5KHMsYSl9LHkuZnJvbUNCT1I9dD0+e2NvbnN0IGU9SSh0KTtyZXR1cm4geS5mcm9tRGF0YUl0ZW0oZSl9O2NvbnN0IFQ9KHQsZSk9Pntjb25zdCBzPWEuZnJvbUV4dGVuZGVkS2V5KHQpLmRlcml2ZShlKSxyPVwiMHhcIitpLnB1YmxpY1RvQWRkcmVzcyhzLnB1YmxpY0tleSwhMCkudG9TdHJpbmcoXCJoZXhcIik7cmV0dXJuIGkudG9DaGVja3N1bUFkZHJlc3Mocil9LHtjYm9yOkR9PWUuZXh0ZW5kO0QucGF0Y2hUYWdzKE9iamVjdC52YWx1ZXMobikuZmlsdGVyKHQ9PiEhdC5nZXRUYWcoKSkubWFwKHQ9PnQuZ2V0VGFnKCkpKSxPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtcImRlZmF1bHRcIiE9PXQmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLHQse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbdF19fSl9KSksZXhwb3J0cy5FVEhTaWduYXR1cmU9eSxleHBvcnRzLkV0aFNpZ25SZXF1ZXN0PWcsZXhwb3J0cy5maW5kSERwYXRmcm9tQWRkcmVzcz0odCxlLHMsYSk9Pntmb3IobGV0IGk9MDtpPHM7aSsrKXtjb25zdCBzPVQoZSxcIk0vMC9cIitpKTtpZih0LnRvTG93ZXJDYXNlKCk9PXMudG9Mb3dlckNhc2UoKSlyZXR1cm5gJHthfS8wLyR7aX1gfXJldHVybiBudWxsfSxleHBvcnRzLmdlbmVyYXRlQWRkcmVzc2Zyb21YcHViPVQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYy11ci1yZWdpc3RyeS1ldGguY2pzLnByb2R1Y3Rpb24ubWluLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIGJjVXJSZWdpc3RyeSA9IHJlcXVpcmUoJ0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5Jyk7XG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKTtcbnZhciBIREtleSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdoZGtleScpKTtcbnZhciBldGhlcmV1bWpzVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpO1xuXG5jb25zdCB7XG4gIFJlZ2lzdHJ5VHlwZVxufSA9IGJjVXJSZWdpc3RyeS5leHRlbmQ7XG5jb25zdCBFeHRlbmRlZFJlZ2lzdHJ5VHlwZXMgPSB7XG4gIEVUSF9TSUdOX1JFUVVFU1Q6IC8qI19fUFVSRV9fKi9uZXcgUmVnaXN0cnlUeXBlKCdldGgtc2lnbi1yZXF1ZXN0JywgNDAxKSxcbiAgRVRIX1NJR05BVEFVUkU6IC8qI19fUFVSRV9fKi9uZXcgUmVnaXN0cnlUeXBlKCdldGgtc2lnbmF0dXJlJywgNDAyKVxufTtcblxuY29uc3Qge1xuICBkZWNvZGVUb0RhdGFJdGVtLFxuICBSZWdpc3RyeVR5cGVzXG59ID0gYmNVclJlZ2lzdHJ5LmV4dGVuZDtcbnZhciBLZXlzO1xuXG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgS2V5c1tLZXlzW1wicmVxdWVzdElkXCJdID0gMV0gPSBcInJlcXVlc3RJZFwiO1xuICBLZXlzW0tleXNbXCJzaWduRGF0YVwiXSA9IDJdID0gXCJzaWduRGF0YVwiO1xuICBLZXlzW0tleXNbXCJkYXRhVHlwZVwiXSA9IDNdID0gXCJkYXRhVHlwZVwiO1xuICBLZXlzW0tleXNbXCJjaGFpbklkXCJdID0gNF0gPSBcImNoYWluSWRcIjtcbiAgS2V5c1tLZXlzW1wiZGVyaXZhdGlvblBhdGhcIl0gPSA1XSA9IFwiZGVyaXZhdGlvblBhdGhcIjtcbiAgS2V5c1tLZXlzW1wiYWRkcmVzc1wiXSA9IDZdID0gXCJhZGRyZXNzXCI7XG4gIEtleXNbS2V5c1tcIm9yaWdpblwiXSA9IDddID0gXCJvcmlnaW5cIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuXG4oZnVuY3Rpb24gKERhdGFUeXBlKSB7XG4gIERhdGFUeXBlW0RhdGFUeXBlW1widHJhbnNhY3Rpb25cIl0gPSAxXSA9IFwidHJhbnNhY3Rpb25cIjtcbiAgRGF0YVR5cGVbRGF0YVR5cGVbXCJ0eXBlZERhdGFcIl0gPSAyXSA9IFwidHlwZWREYXRhXCI7XG4gIERhdGFUeXBlW0RhdGFUeXBlW1wicGVyc29uYWxNZXNzYWdlXCJdID0gM10gPSBcInBlcnNvbmFsTWVzc2FnZVwiO1xuICBEYXRhVHlwZVtEYXRhVHlwZVtcInR5cGVkVHJhbnNhY3Rpb25cIl0gPSA0XSA9IFwidHlwZWRUcmFuc2FjdGlvblwiO1xufSkoZXhwb3J0cy5EYXRhVHlwZSB8fCAoZXhwb3J0cy5EYXRhVHlwZSA9IHt9KSk7XG5cbmNsYXNzIEV0aFNpZ25SZXF1ZXN0IGV4dGVuZHMgYmNVclJlZ2lzdHJ5LlJlZ2lzdHJ5SXRlbSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiBFeHRlbmRlZFJlZ2lzdHJ5VHlwZXMuRVRIX1NJR05fUkVRVUVTVDtcblxuICAgIHRoaXMuc2V0dXBEYXRhID0gYXJncyA9PiB7XG4gICAgICB0aGlzLnJlcXVlc3RJZCA9IGFyZ3MucmVxdWVzdElkO1xuICAgICAgdGhpcy5zaWduRGF0YSA9IGFyZ3Muc2lnbkRhdGE7XG4gICAgICB0aGlzLmRhdGFUeXBlID0gYXJncy5kYXRhVHlwZTtcbiAgICAgIHRoaXMuY2hhaW5JZCA9IGFyZ3MuY2hhaW5JZDtcbiAgICAgIHRoaXMuZGVyaXZhdGlvblBhdGggPSBhcmdzLmRlcml2YXRpb25QYXRoO1xuICAgICAgdGhpcy5hZGRyZXNzID0gYXJncy5hZGRyZXNzO1xuICAgICAgdGhpcy5vcmlnaW4gPSBhcmdzLm9yaWdpbjtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRSZXF1ZXN0SWQgPSAoKSA9PiB0aGlzLnJlcXVlc3RJZDtcblxuICAgIHRoaXMuZ2V0U2lnbkRhdGEgPSAoKSA9PiB0aGlzLnNpZ25EYXRhO1xuXG4gICAgdGhpcy5nZXREYXRhVHlwZSA9ICgpID0+IHRoaXMuZGF0YVR5cGU7XG5cbiAgICB0aGlzLmdldENoYWluSWQgPSAoKSA9PiB0aGlzLmNoYWluSWQ7XG5cbiAgICB0aGlzLmdldERlcml2YXRpb25QYXRoID0gKCkgPT4gdGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRQYXRoKCk7XG5cbiAgICB0aGlzLmdldFNpZ25SZXF1ZXN0QWRkcmVzcyA9ICgpID0+IHRoaXMuYWRkcmVzcztcblxuICAgIHRoaXMuZ2V0T3JpZ2luID0gKCkgPT4gdGhpcy5vcmlnaW47XG5cbiAgICB0aGlzLnRvRGF0YUl0ZW0gPSAoKSA9PiB7XG4gICAgICBjb25zdCBtYXAgPSB7fTtcblxuICAgICAgaWYgKHRoaXMucmVxdWVzdElkKSB7XG4gICAgICAgIG1hcFtLZXlzLnJlcXVlc3RJZF0gPSBuZXcgYmNVclJlZ2lzdHJ5LkRhdGFJdGVtKHRoaXMucmVxdWVzdElkLCBSZWdpc3RyeVR5cGVzLlVVSUQuZ2V0VGFnKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hZGRyZXNzKSB7XG4gICAgICAgIG1hcFtLZXlzLmFkZHJlc3NdID0gdGhpcy5hZGRyZXNzO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jaGFpbklkKSB7XG4gICAgICAgIG1hcFtLZXlzLmNoYWluSWRdID0gdGhpcy5jaGFpbklkO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcmlnaW4pIHtcbiAgICAgICAgbWFwW0tleXMub3JpZ2luXSA9IHRoaXMub3JpZ2luO1xuICAgICAgfVxuXG4gICAgICBtYXBbS2V5cy5zaWduRGF0YV0gPSB0aGlzLnNpZ25EYXRhO1xuICAgICAgbWFwW0tleXMuZGF0YVR5cGVdID0gdGhpcy5kYXRhVHlwZTtcbiAgICAgIGNvbnN0IGtleVBhdGggPSB0aGlzLmRlcml2YXRpb25QYXRoLnRvRGF0YUl0ZW0oKTtcbiAgICAgIGtleVBhdGguc2V0VGFnKHRoaXMuZGVyaXZhdGlvblBhdGguZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VGFnKCkpO1xuICAgICAgbWFwW0tleXMuZGVyaXZhdGlvblBhdGhdID0ga2V5UGF0aDtcbiAgICAgIHJldHVybiBuZXcgYmNVclJlZ2lzdHJ5LkRhdGFJdGVtKG1hcCk7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0dXBEYXRhKGFyZ3MpO1xuICB9XG5cbiAgc3RhdGljIGNvbnN0cnVjdEVUSFJlcXVlc3Qoc2lnbkRhdGEsIHNpZ25EYXRhVHlwZSwgaGRQYXRoLCB4ZnAsIHV1aWRTdHJpbmcsIGNoYWluSWQsIGFkZHJlc3MsIG9yaWdpbikge1xuICAgIGNvbnN0IHBhdGhzID0gaGRQYXRoLnJlcGxhY2UoL1ttfE1dXFwvLywgJycpLnNwbGl0KCcvJyk7XG4gICAgY29uc3QgaGRwYXRoT2JqZWN0ID0gbmV3IGJjVXJSZWdpc3RyeS5DcnlwdG9LZXlwYXRoKHBhdGhzLm1hcChwYXRoID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQocGF0aC5yZXBsYWNlKFwiJ1wiLCAnJykpO1xuICAgICAgbGV0IGlzSGFyZGVuZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHBhdGguZW5kc1dpdGgoXCInXCIpKSB7XG4gICAgICAgIGlzSGFyZGVuZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IGJjVXJSZWdpc3RyeS5QYXRoQ29tcG9uZW50KHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGhhcmRlbmVkOiBpc0hhcmRlbmVkXG4gICAgICB9KTtcbiAgICB9KSwgQnVmZmVyLmZyb20oeGZwLCAnaGV4JykpO1xuICAgIHJldHVybiBuZXcgRXRoU2lnblJlcXVlc3Qoe1xuICAgICAgcmVxdWVzdElkOiB1dWlkU3RyaW5nID8gQnVmZmVyLmZyb20odXVpZC5wYXJzZSh1dWlkU3RyaW5nKSkgOiB1bmRlZmluZWQsXG4gICAgICBzaWduRGF0YSxcbiAgICAgIGRhdGFUeXBlOiBzaWduRGF0YVR5cGUsXG4gICAgICBkZXJpdmF0aW9uUGF0aDogaGRwYXRoT2JqZWN0LFxuICAgICAgY2hhaW5JZCxcbiAgICAgIGFkZHJlc3M6IGFkZHJlc3MgPyBCdWZmZXIuZnJvbShhZGRyZXNzLnJlcGxhY2UoJzB4JywgJycpLCAnaGV4JykgOiB1bmRlZmluZWQsXG4gICAgICBvcmlnaW46IG9yaWdpbiB8fCB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuXG59XG5cbkV0aFNpZ25SZXF1ZXN0LmZyb21EYXRhSXRlbSA9IGRhdGFJdGVtID0+IHtcbiAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICBjb25zdCBzaWduRGF0YSA9IG1hcFtLZXlzLnNpZ25EYXRhXTtcbiAgY29uc3QgZGF0YVR5cGUgPSBtYXBbS2V5cy5kYXRhVHlwZV07XG4gIGNvbnN0IGRlcml2YXRpb25QYXRoID0gYmNVclJlZ2lzdHJ5LkNyeXB0b0tleXBhdGguZnJvbURhdGFJdGVtKG1hcFtLZXlzLmRlcml2YXRpb25QYXRoXSk7XG4gIGNvbnN0IGNoYWluSWQgPSBtYXBbS2V5cy5jaGFpbklkXSA/IG1hcFtLZXlzLmNoYWluSWRdIDogdW5kZWZpbmVkO1xuICBjb25zdCBhZGRyZXNzID0gbWFwW0tleXMuYWRkcmVzc10gPyBtYXBbS2V5cy5hZGRyZXNzXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgcmVxdWVzdElkID0gbWFwW0tleXMucmVxdWVzdElkXSA/IG1hcFtLZXlzLnJlcXVlc3RJZF0uZ2V0RGF0YSgpIDogdW5kZWZpbmVkO1xuICBjb25zdCBvcmlnaW4gPSBtYXBbS2V5cy5vcmlnaW5dID8gbWFwW0tleXMub3JpZ2luXSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG5ldyBFdGhTaWduUmVxdWVzdCh7XG4gICAgcmVxdWVzdElkLFxuICAgIHNpZ25EYXRhLFxuICAgIGRhdGFUeXBlLFxuICAgIGNoYWluSWQsXG4gICAgZGVyaXZhdGlvblBhdGgsXG4gICAgYWRkcmVzcyxcbiAgICBvcmlnaW5cbiAgfSk7XG59O1xuXG5FdGhTaWduUmVxdWVzdC5mcm9tQ0JPUiA9IF9jYm9yUGF5bG9hZCA9PiB7XG4gIGNvbnN0IGRhdGFJdGVtID0gZGVjb2RlVG9EYXRhSXRlbShfY2JvclBheWxvYWQpO1xuICByZXR1cm4gRXRoU2lnblJlcXVlc3QuZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG5cbmNvbnN0IHtcbiAgUmVnaXN0cnlUeXBlczogUmVnaXN0cnlUeXBlcyQxLFxuICBkZWNvZGVUb0RhdGFJdGVtOiBkZWNvZGVUb0RhdGFJdGVtJDFcbn0gPSBiY1VyUmVnaXN0cnkuZXh0ZW5kO1xudmFyIEtleXMkMTtcblxuKGZ1bmN0aW9uIChLZXlzKSB7XG4gIEtleXNbS2V5c1tcInJlcXVlc3RJZFwiXSA9IDFdID0gXCJyZXF1ZXN0SWRcIjtcbiAgS2V5c1tLZXlzW1wic2lnbmF0dXJlXCJdID0gMl0gPSBcInNpZ25hdHVyZVwiO1xufSkoS2V5cyQxIHx8IChLZXlzJDEgPSB7fSkpO1xuXG5jbGFzcyBFVEhTaWduYXR1cmUgZXh0ZW5kcyBiY1VyUmVnaXN0cnkuUmVnaXN0cnlJdGVtIHtcbiAgY29uc3RydWN0b3Ioc2lnbmF0dXJlLCByZXF1ZXN0SWQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5nZXRSZWdpc3RyeVR5cGUgPSAoKSA9PiBFeHRlbmRlZFJlZ2lzdHJ5VHlwZXMuRVRIX1NJR05BVEFVUkU7XG5cbiAgICB0aGlzLmdldFJlcXVlc3RJZCA9ICgpID0+IHRoaXMucmVxdWVzdElkO1xuXG4gICAgdGhpcy5nZXRTaWduYXR1cmUgPSAoKSA9PiB0aGlzLnNpZ25hdHVyZTtcblxuICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5yZXF1ZXN0SWQpIHtcbiAgICAgICAgbWFwW0tleXMkMS5yZXF1ZXN0SWRdID0gbmV3IGJjVXJSZWdpc3RyeS5EYXRhSXRlbSh0aGlzLnJlcXVlc3RJZCwgUmVnaXN0cnlUeXBlcyQxLlVVSUQuZ2V0VGFnKCkpO1xuICAgICAgfVxuXG4gICAgICBtYXBbS2V5cyQxLnNpZ25hdHVyZV0gPSB0aGlzLnNpZ25hdHVyZTtcbiAgICAgIHJldHVybiBuZXcgYmNVclJlZ2lzdHJ5LkRhdGFJdGVtKG1hcCk7XG4gICAgfTtcblxuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICAgIHRoaXMucmVxdWVzdElkID0gcmVxdWVzdElkO1xuICB9XG5cbn1cblxuRVRIU2lnbmF0dXJlLmZyb21EYXRhSXRlbSA9IGRhdGFJdGVtID0+IHtcbiAgY29uc3QgbWFwID0gZGF0YUl0ZW0uZ2V0RGF0YSgpO1xuICBjb25zdCBzaWduYXR1cmUgPSBtYXBbS2V5cyQxLnNpZ25hdHVyZV07XG4gIGNvbnN0IHJlcXVlc3RJZCA9IG1hcFtLZXlzJDEucmVxdWVzdElkXSA/IG1hcFtLZXlzJDEucmVxdWVzdElkXS5nZXREYXRhKCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBuZXcgRVRIU2lnbmF0dXJlKHNpZ25hdHVyZSwgcmVxdWVzdElkKTtcbn07XG5cbkVUSFNpZ25hdHVyZS5mcm9tQ0JPUiA9IF9jYm9yUGF5bG9hZCA9PiB7XG4gIGNvbnN0IGRhdGFJdGVtID0gZGVjb2RlVG9EYXRhSXRlbSQxKF9jYm9yUGF5bG9hZCk7XG4gIHJldHVybiBFVEhTaWduYXR1cmUuZnJvbURhdGFJdGVtKGRhdGFJdGVtKTtcbn07XG5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGdlbmVyYXRlQWRkcmVzc2Zyb21YcHViID0gKHhwdWIsIGRlcml2ZVBhdGgpID0+IHtcbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBub2RlID0gSERLZXkuZnJvbUV4dGVuZGVkS2V5KHhwdWIpO1xuICBjb25zdCBwdWJsaWNLZXkgPSBub2RlLmRlcml2ZShkZXJpdmVQYXRoKTtcbiAgY29uc3QgYWRkcmVzcyA9ICcweCcgKyBldGhlcmV1bWpzVXRpbC5wdWJsaWNUb0FkZHJlc3MocHVibGljS2V5LnB1YmxpY0tleSwgdHJ1ZSkudG9TdHJpbmcoJ2hleCcpO1xuICByZXR1cm4gZXRoZXJldW1qc1V0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG59O1xuY29uc3QgZmluZEhEcGF0ZnJvbUFkZHJlc3MgPSAoYWRkcmVzcywgeHB1YiwgbnVtYmVyTGltaXQsIHJvb3RQYXRoKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyTGltaXQ7IGkrKykge1xuICAgIGNvbnN0IHBhdGggPSBgTS8wLyR7aX1gO1xuICAgIGNvbnN0IGNhY3VsYXRlQWRkcmVzcyA9IGdlbmVyYXRlQWRkcmVzc2Zyb21YcHViKHhwdWIsIHBhdGgpO1xuXG4gICAgaWYgKGFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PSBjYWN1bGF0ZUFkZHJlc3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgcmV0dXJuIGAke3Jvb3RQYXRofS8wLyR7aX1gO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuY29uc3Qge1xuICBjYm9yXG59ID0gYmNVclJlZ2lzdHJ5LmV4dGVuZDtcbmNib3IucGF0Y2hUYWdzKE9iamVjdC52YWx1ZXMoRXh0ZW5kZWRSZWdpc3RyeVR5cGVzKS5maWx0ZXIocnQgPT4gISFydC5nZXRUYWcoKSkubWFwKHJ0ID0+IHJ0LmdldFRhZygpKSk7XG5cbk9iamVjdC5rZXlzKGJjVXJSZWdpc3RyeSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGJjVXJSZWdpc3RyeVtrXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5leHBvcnRzLkVUSFNpZ25hdHVyZSA9IEVUSFNpZ25hdHVyZTtcbmV4cG9ydHMuRXRoU2lnblJlcXVlc3QgPSBFdGhTaWduUmVxdWVzdDtcbmV4cG9ydHMuZmluZEhEcGF0ZnJvbUFkZHJlc3MgPSBmaW5kSERwYXRmcm9tQWRkcmVzcztcbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzZnJvbVhwdWIgPSBnZW5lcmF0ZUFkZHJlc3Nmcm9tWHB1Yjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJjLXVyLXJlZ2lzdHJ5LWV0aC5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iLCIndXNlIHN0cmljdCdcblxuLy8gU2V0IHV0aWxzXG5jb25zdCBkaWZmZXJlbmNlID0gKHNldDEsIHNldDIpID0+IG5ldyBTZXQoWy4uLnNldDFdLmZpbHRlcih4ID0+ICFzZXQyLmhhcyh4KSkpXG5cbi8vIFBvbGwgdXRpbHNcbmNvbnN0IHNsZWVwID0gKHRpbWUpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lKSlcblxuY29uc3QgcnVuV2l0aERlbGF5ID0gYXN5bmMgKGZ1bmMsIHRvcGljLCBpbnRlcnZhbCkgPT4ge1xuICBjb25zdCBwZWVycyA9IGF3YWl0IGZ1bmModG9waWMpXG4gIGF3YWl0IHNsZWVwKGludGVydmFsKVxuICByZXR1cm4gcGVlcnNcbn1cblxubW9kdWxlLmV4cG9ydHMucnVuV2l0aERlbGF5ID0gcnVuV2l0aERlbGF5XG5tb2R1bGUuZXhwb3J0cy5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSAoaXRlcmFibGUsIHJlZHVjZXIsIGluaXRWYWwpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0Y29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG5cdGxldCBpID0gMDtcblxuXHRjb25zdCBuZXh0ID0gdG90YWwgPT4ge1xuXHRcdGNvbnN0IGVsID0gaXRlcmF0b3IubmV4dCgpO1xuXG5cdFx0aWYgKGVsLmRvbmUpIHtcblx0XHRcdHJlc29sdmUodG90YWwpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdFByb21pc2UuYWxsKFt0b3RhbCwgZWwudmFsdWVdKVxuXHRcdFx0LnRoZW4odmFsdWUgPT4ge1xuXHRcdFx0XHRuZXh0KHJlZHVjZXIodmFsdWVbMF0sIHZhbHVlWzFdLCBpKyspKTtcblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2gocmVqZWN0KTtcblx0fTtcblxuXHRuZXh0KGluaXRWYWwpO1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IGlzT2ZUeXBlID0gKHR5cGUpID0+ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSB0eXBlOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOnN0cmljdC10eXBlLXByZWRpY2F0ZXNcbmNvbnN0IGdldE9iamVjdFR5cGUgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCBvYmplY3ROYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChvYmplY3ROYW1lKSB7XG4gICAgICAgIHJldHVybiBvYmplY3ROYW1lO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCBpc09iamVjdE9mVHlwZSA9ICh0eXBlTmFtZSkgPT4gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIGdldE9iamVjdFR5cGUodmFsdWUpID09PSB0eXBlTmFtZTtcbn07XG5mdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCIgLyogbnVsbCAqLztcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gXCJib29sZWFuXCIgLyogYm9vbGVhbiAqLztcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgLyogdW5kZWZpbmVkICovO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgLyogc3RyaW5nICovO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCIgLyogbnVtYmVyICovO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuIFwic3ltYm9sXCIgLyogc3ltYm9sICovO1xuICAgIH1cbiAgICBpZiAoaXMuZnVuY3Rpb25fKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJGdW5jdGlvblwiIC8qIEZ1bmN0aW9uICovO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiQXJyYXlcIiAvKiBBcnJheSAqLztcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiQnVmZmVyXCIgLyogQnVmZmVyICovO1xuICAgIH1cbiAgICBjb25zdCB0YWdUeXBlID0gZ2V0T2JqZWN0VHlwZSh2YWx1ZSk7XG4gICAgaWYgKHRhZ1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRhZ1R5cGU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fCB2YWx1ZSBpbnN0YW5jZW9mIEJvb2xlYW4gfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIGRvblxcJ3QgdXNlIG9iamVjdCB3cmFwcGVycyBmb3IgcHJpbWl0aXZlIHR5cGVzJyk7XG4gICAgfVxuICAgIHJldHVybiBcIk9iamVjdFwiIC8qIE9iamVjdCAqLztcbn1cbihmdW5jdGlvbiAoaXMpIHtcbiAgICBjb25zdCBpc09iamVjdCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JztcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZTp2YXJpYWJsZS1uYW1lXG4gICAgaXMudW5kZWZpbmVkID0gaXNPZlR5cGUoJ3VuZGVmaW5lZCcpO1xuICAgIGlzLnN0cmluZyA9IGlzT2ZUeXBlKCdzdHJpbmcnKTtcbiAgICBpcy5udW1iZXIgPSBpc09mVHlwZSgnbnVtYmVyJyk7XG4gICAgaXMuZnVuY3Rpb25fID0gaXNPZlR5cGUoJ2Z1bmN0aW9uJyk7XG4gICAgaXMubnVsbF8gPSAodmFsdWUpID0+IHZhbHVlID09PSBudWxsO1xuICAgIGlzLmNsYXNzXyA9ICh2YWx1ZSkgPT4gaXMuZnVuY3Rpb25fKHZhbHVlKSAmJiB2YWx1ZS50b1N0cmluZygpLnN0YXJ0c1dpdGgoJ2NsYXNzICcpO1xuICAgIGlzLmJvb2xlYW4gPSAodmFsdWUpID0+IHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbiAgICAvLyB0c2xpbnQ6ZW5hYmxlOnZhcmlhYmxlLW5hbWVcbiAgICBpcy5zeW1ib2wgPSBpc09mVHlwZSgnc3ltYm9sJyk7XG4gICAgaXMuYXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAgIGlzLmJ1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcbiAgICBpcy5udWxsT3JVbmRlZmluZWQgPSAodmFsdWUpID0+IGlzLm51bGxfKHZhbHVlKSB8fCBpcy51bmRlZmluZWQodmFsdWUpO1xuICAgIGlzLm9iamVjdCA9ICh2YWx1ZSkgPT4gIWlzLm51bGxPclVuZGVmaW5lZCh2YWx1ZSkgJiYgKGlzLmZ1bmN0aW9uXyh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpKTtcbiAgICBpcy5pdGVyYWJsZSA9ICh2YWx1ZSkgPT4gIWlzLm51bGxPclVuZGVmaW5lZCh2YWx1ZSkgJiYgaXMuZnVuY3Rpb25fKHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0pO1xuICAgIGlzLmdlbmVyYXRvciA9ICh2YWx1ZSkgPT4gaXMuaXRlcmFibGUodmFsdWUpICYmIGlzLmZ1bmN0aW9uXyh2YWx1ZS5uZXh0KSAmJiBpcy5mdW5jdGlvbl8odmFsdWUudGhyb3cpO1xuICAgIGlzLm5hdGl2ZVByb21pc2UgPSBpc09iamVjdE9mVHlwZShcIlByb21pc2VcIiAvKiBQcm9taXNlICovKTtcbiAgICBjb25zdCBoYXNQcm9taXNlQVBJID0gKHZhbHVlKSA9PiAhaXMubnVsbF8odmFsdWUpICYmXG4gICAgICAgIGlzT2JqZWN0KHZhbHVlKSAmJlxuICAgICAgICBpcy5mdW5jdGlvbl8odmFsdWUudGhlbikgJiZcbiAgICAgICAgaXMuZnVuY3Rpb25fKHZhbHVlLmNhdGNoKTtcbiAgICBpcy5wcm9taXNlID0gKHZhbHVlKSA9PiBpcy5uYXRpdmVQcm9taXNlKHZhbHVlKSB8fCBoYXNQcm9taXNlQVBJKHZhbHVlKTtcbiAgICAvLyBUT0RPOiBDaGFuZ2UgdG8gdXNlIGBpc09iamVjdE9mVHlwZWAgb25jZSBOb2RlLmpzIDYgb3IgaGlnaGVyIGlzIHRhcmdldGVkXG4gICAgY29uc3QgaXNGdW5jdGlvbk9mVHlwZSA9ICh0eXBlKSA9PiAodmFsdWUpID0+IGlzLmZ1bmN0aW9uXyh2YWx1ZSkgJiYgaXMuZnVuY3Rpb25fKHZhbHVlLmNvbnN0cnVjdG9yKSAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlO1xuICAgIGlzLmdlbmVyYXRvckZ1bmN0aW9uID0gaXNGdW5jdGlvbk9mVHlwZSgnR2VuZXJhdG9yRnVuY3Rpb24nKTtcbiAgICBpcy5hc3luY0Z1bmN0aW9uID0gaXNGdW5jdGlvbk9mVHlwZSgnQXN5bmNGdW5jdGlvbicpO1xuICAgIGlzLmJvdW5kRnVuY3Rpb24gPSAodmFsdWUpID0+IGlzLmZ1bmN0aW9uXyh2YWx1ZSkgJiYgIXZhbHVlLmhhc093blByb3BlcnR5KCdwcm90b3R5cGUnKTtcbiAgICBpcy5yZWdFeHAgPSBpc09iamVjdE9mVHlwZShcIlJlZ0V4cFwiIC8qIFJlZ0V4cCAqLyk7XG4gICAgaXMuZGF0ZSA9IGlzT2JqZWN0T2ZUeXBlKFwiRGF0ZVwiIC8qIERhdGUgKi8pO1xuICAgIGlzLmVycm9yID0gaXNPYmplY3RPZlR5cGUoXCJFcnJvclwiIC8qIEVycm9yICovKTtcbiAgICBpcy5tYXAgPSBpc09iamVjdE9mVHlwZShcIk1hcFwiIC8qIE1hcCAqLyk7XG4gICAgaXMuc2V0ID0gaXNPYmplY3RPZlR5cGUoXCJTZXRcIiAvKiBTZXQgKi8pO1xuICAgIGlzLndlYWtNYXAgPSBpc09iamVjdE9mVHlwZShcIldlYWtNYXBcIiAvKiBXZWFrTWFwICovKTtcbiAgICBpcy53ZWFrU2V0ID0gaXNPYmplY3RPZlR5cGUoXCJXZWFrU2V0XCIgLyogV2Vha1NldCAqLyk7XG4gICAgaXMuaW50OEFycmF5ID0gaXNPYmplY3RPZlR5cGUoXCJJbnQ4QXJyYXlcIiAvKiBJbnQ4QXJyYXkgKi8pO1xuICAgIGlzLnVpbnQ4QXJyYXkgPSBpc09iamVjdE9mVHlwZShcIlVpbnQ4QXJyYXlcIiAvKiBVaW50OEFycmF5ICovKTtcbiAgICBpcy51aW50OENsYW1wZWRBcnJheSA9IGlzT2JqZWN0T2ZUeXBlKFwiVWludDhDbGFtcGVkQXJyYXlcIiAvKiBVaW50OENsYW1wZWRBcnJheSAqLyk7XG4gICAgaXMuaW50MTZBcnJheSA9IGlzT2JqZWN0T2ZUeXBlKFwiSW50MTZBcnJheVwiIC8qIEludDE2QXJyYXkgKi8pO1xuICAgIGlzLnVpbnQxNkFycmF5ID0gaXNPYmplY3RPZlR5cGUoXCJVaW50MTZBcnJheVwiIC8qIFVpbnQxNkFycmF5ICovKTtcbiAgICBpcy5pbnQzMkFycmF5ID0gaXNPYmplY3RPZlR5cGUoXCJJbnQzMkFycmF5XCIgLyogSW50MzJBcnJheSAqLyk7XG4gICAgaXMudWludDMyQXJyYXkgPSBpc09iamVjdE9mVHlwZShcIlVpbnQzMkFycmF5XCIgLyogVWludDMyQXJyYXkgKi8pO1xuICAgIGlzLmZsb2F0MzJBcnJheSA9IGlzT2JqZWN0T2ZUeXBlKFwiRmxvYXQzMkFycmF5XCIgLyogRmxvYXQzMkFycmF5ICovKTtcbiAgICBpcy5mbG9hdDY0QXJyYXkgPSBpc09iamVjdE9mVHlwZShcIkZsb2F0NjRBcnJheVwiIC8qIEZsb2F0NjRBcnJheSAqLyk7XG4gICAgaXMuYXJyYXlCdWZmZXIgPSBpc09iamVjdE9mVHlwZShcIkFycmF5QnVmZmVyXCIgLyogQXJyYXlCdWZmZXIgKi8pO1xuICAgIGlzLnNoYXJlZEFycmF5QnVmZmVyID0gaXNPYmplY3RPZlR5cGUoXCJTaGFyZWRBcnJheUJ1ZmZlclwiIC8qIFNoYXJlZEFycmF5QnVmZmVyICovKTtcbiAgICBpcy5kYXRhVmlldyA9IGlzT2JqZWN0T2ZUeXBlKFwiRGF0YVZpZXdcIiAvKiBEYXRhVmlldyAqLyk7XG4gICAgLy8gVE9ETzogUmVtb3ZlIGBvYmplY3RgIGNoZWNrcyB3aGVuIHRhcmdldGluZyBFUzIwMTUgb3IgaGlnaGVyXG4gICAgLy8gU2VlIGBOb3Rlc2A6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9nZXRQcm90b3R5cGVPZlxuICAgIGlzLmRpcmVjdEluc3RhbmNlT2YgPSAoaW5zdGFuY2UsIGtsYXNzKSA9PiBpcy5vYmplY3QoaW5zdGFuY2UpICYmIGlzLm9iamVjdChrbGFzcykgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGluc3RhbmNlKSA9PT0ga2xhc3MucHJvdG90eXBlO1xuICAgIGlzLnRydXRoeSA9ICh2YWx1ZSkgPT4gQm9vbGVhbih2YWx1ZSk7XG4gICAgaXMuZmFsc3kgPSAodmFsdWUpID0+ICF2YWx1ZTtcbiAgICBpcy5uYW4gPSAodmFsdWUpID0+IE51bWJlci5pc05hTih2YWx1ZSk7XG4gICAgY29uc3QgcHJpbWl0aXZlVHlwZXMgPSBuZXcgU2V0KFtcbiAgICAgICAgJ3VuZGVmaW5lZCcsXG4gICAgICAgICdzdHJpbmcnLFxuICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgJ2Jvb2xlYW4nLFxuICAgICAgICAnc3ltYm9sJ1xuICAgIF0pO1xuICAgIGlzLnByaW1pdGl2ZSA9ICh2YWx1ZSkgPT4gaXMubnVsbF8odmFsdWUpIHx8IHByaW1pdGl2ZVR5cGVzLmhhcyh0eXBlb2YgdmFsdWUpO1xuICAgIGlzLmludGVnZXIgPSAodmFsdWUpID0+IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xuICAgIGlzLnNhZmVJbnRlZ2VyID0gKHZhbHVlKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSk7XG4gICAgaXMucGxhaW5PYmplY3QgPSAodmFsdWUpID0+IHtcbiAgICAgICAgLy8gRnJvbTogaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9pcy1wbGFpbi1vYmovYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAgICAgICAgbGV0IHByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldE9iamVjdFR5cGUodmFsdWUpID09PSBcIk9iamVjdFwiIC8qIE9iamVjdCAqLyAmJlxuICAgICAgICAgICAgKHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSksIHByb3RvdHlwZSA9PT0gbnVsbCB8fCAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmJhbi1jb21tYS1vcGVyYXRvclxuICAgICAgICAgICAgICAgIHByb3RvdHlwZSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KSk7XG4gICAgfTtcbiAgICBjb25zdCB0eXBlZEFycmF5VHlwZXMgPSBuZXcgU2V0KFtcbiAgICAgICAgXCJJbnQ4QXJyYXlcIiAvKiBJbnQ4QXJyYXkgKi8sXG4gICAgICAgIFwiVWludDhBcnJheVwiIC8qIFVpbnQ4QXJyYXkgKi8sXG4gICAgICAgIFwiVWludDhDbGFtcGVkQXJyYXlcIiAvKiBVaW50OENsYW1wZWRBcnJheSAqLyxcbiAgICAgICAgXCJJbnQxNkFycmF5XCIgLyogSW50MTZBcnJheSAqLyxcbiAgICAgICAgXCJVaW50MTZBcnJheVwiIC8qIFVpbnQxNkFycmF5ICovLFxuICAgICAgICBcIkludDMyQXJyYXlcIiAvKiBJbnQzMkFycmF5ICovLFxuICAgICAgICBcIlVpbnQzMkFycmF5XCIgLyogVWludDMyQXJyYXkgKi8sXG4gICAgICAgIFwiRmxvYXQzMkFycmF5XCIgLyogRmxvYXQzMkFycmF5ICovLFxuICAgICAgICBcIkZsb2F0NjRBcnJheVwiIC8qIEZsb2F0NjRBcnJheSAqL1xuICAgIF0pO1xuICAgIGlzLnR5cGVkQXJyYXkgPSAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgb2JqZWN0VHlwZSA9IGdldE9iamVjdFR5cGUodmFsdWUpO1xuICAgICAgICBpZiAob2JqZWN0VHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlZEFycmF5VHlwZXMuaGFzKG9iamVjdFR5cGUpO1xuICAgIH07XG4gICAgY29uc3QgaXNWYWxpZExlbmd0aCA9ICh2YWx1ZSkgPT4gaXMuc2FmZUludGVnZXIodmFsdWUpICYmIHZhbHVlID4gLTE7XG4gICAgaXMuYXJyYXlMaWtlID0gKHZhbHVlKSA9PiAhaXMubnVsbE9yVW5kZWZpbmVkKHZhbHVlKSAmJiAhaXMuZnVuY3Rpb25fKHZhbHVlKSAmJiBpc1ZhbGlkTGVuZ3RoKHZhbHVlLmxlbmd0aCk7XG4gICAgaXMuaW5SYW5nZSA9ICh2YWx1ZSwgcmFuZ2UpID0+IHtcbiAgICAgICAgaWYgKGlzLm51bWJlcihyYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+PSBNYXRoLm1pbigwLCByYW5nZSkgJiYgdmFsdWUgPD0gTWF0aC5tYXgocmFuZ2UsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcy5hcnJheShyYW5nZSkgJiYgcmFuZ2UubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBVc2Ugc3ByZWFkIG9wZXJhdG9yIGhlcmUgd2hlbiB0YXJnZXRpbmcgTm9kZS5qcyA2IG9yIGhpZ2hlclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID49IE1hdGgubWluLmFwcGx5KG51bGwsIHJhbmdlKSAmJiB2YWx1ZSA8PSBNYXRoLm1heC5hcHBseShudWxsLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCByYW5nZTogJHt1dGlsLmluc3BlY3QocmFuZ2UpfWApO1xuICAgIH07XG4gICAgY29uc3QgTk9ERV9UWVBFX0VMRU1FTlQgPSAxO1xuICAgIGNvbnN0IERPTV9QUk9QRVJUSUVTX1RPX0NIRUNLID0gW1xuICAgICAgICAnaW5uZXJIVE1MJyxcbiAgICAgICAgJ293bmVyRG9jdW1lbnQnLFxuICAgICAgICAnc3R5bGUnLFxuICAgICAgICAnYXR0cmlidXRlcycsXG4gICAgICAgICdub2RlVmFsdWUnXG4gICAgXTtcbiAgICBpcy5kb21FbGVtZW50ID0gKHZhbHVlKSA9PiBpcy5vYmplY3QodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSBOT0RFX1RZUEVfRUxFTUVOVCAmJiBpcy5zdHJpbmcodmFsdWUubm9kZU5hbWUpICYmXG4gICAgICAgICFpcy5wbGFpbk9iamVjdCh2YWx1ZSkgJiYgRE9NX1BST1BFUlRJRVNfVE9fQ0hFQ0suZXZlcnkocHJvcGVydHkgPT4gcHJvcGVydHkgaW4gdmFsdWUpO1xuICAgIGlzLm5vZGVTdHJlYW0gPSAodmFsdWUpID0+ICFpcy5udWxsT3JVbmRlZmluZWQodmFsdWUpICYmIGlzT2JqZWN0KHZhbHVlKSAmJiBpcy5mdW5jdGlvbl8odmFsdWUucGlwZSk7XG4gICAgaXMuaW5maW5pdGUgPSAodmFsdWUpID0+IHZhbHVlID09PSBJbmZpbml0eSB8fCB2YWx1ZSA9PT0gLUluZmluaXR5O1xuICAgIGNvbnN0IGlzQWJzb2x1dGVNb2QyID0gKHZhbHVlKSA9PiAocmVtKSA9PiBpcy5pbnRlZ2VyKHJlbSkgJiYgTWF0aC5hYnMocmVtICUgMikgPT09IHZhbHVlO1xuICAgIGlzLmV2ZW4gPSBpc0Fic29sdXRlTW9kMigwKTtcbiAgICBpcy5vZGQgPSBpc0Fic29sdXRlTW9kMigxKTtcbiAgICBjb25zdCBpc1doaXRlU3BhY2VTdHJpbmcgPSAodmFsdWUpID0+IGlzLnN0cmluZyh2YWx1ZSkgJiYgL1xcUy8udGVzdCh2YWx1ZSkgPT09IGZhbHNlO1xuICAgIGNvbnN0IGlzRW1wdHlTdHJpbmdPckFycmF5ID0gKHZhbHVlKSA9PiAoaXMuc3RyaW5nKHZhbHVlKSB8fCBpcy5hcnJheSh2YWx1ZSkpICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICBjb25zdCBpc0VtcHR5T2JqZWN0ID0gKHZhbHVlKSA9PiAhaXMubWFwKHZhbHVlKSAmJiAhaXMuc2V0KHZhbHVlKSAmJiBpcy5vYmplY3QodmFsdWUpICYmIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDA7XG4gICAgY29uc3QgaXNFbXB0eU1hcE9yU2V0ID0gKHZhbHVlKSA9PiAoaXMubWFwKHZhbHVlKSB8fCBpcy5zZXQodmFsdWUpKSAmJiB2YWx1ZS5zaXplID09PSAwO1xuICAgIGlzLmVtcHR5ID0gKHZhbHVlKSA9PiBpcy5mYWxzeSh2YWx1ZSkgfHwgaXNFbXB0eVN0cmluZ09yQXJyYXkodmFsdWUpIHx8IGlzRW1wdHlPYmplY3QodmFsdWUpIHx8IGlzRW1wdHlNYXBPclNldCh2YWx1ZSk7XG4gICAgaXMuZW1wdHlPcldoaXRlc3BhY2UgPSAodmFsdWUpID0+IGlzLmVtcHR5KHZhbHVlKSB8fCBpc1doaXRlU3BhY2VTdHJpbmcodmFsdWUpO1xuICAgIGNvbnN0IHByZWRpY2F0ZU9uQXJyYXkgPSAobWV0aG9kLCBwcmVkaWNhdGUsIGFyZ3MpID0+IHtcbiAgICAgICAgLy8gYGFyZ3NgIGlzIHRoZSBjYWxsaW5nIGZ1bmN0aW9uJ3MgXCJhcmd1bWVudHMgb2JqZWN0XCIuXG4gICAgICAgIC8vIFdlIGhhdmUgdG8gZG8gaXQgdGhpcyB3YXkgdG8ga2VlcCBub2RlIHY0IHN1cHBvcnQuXG4gICAgICAgIC8vIFNvIGhlcmUgd2UgY29udmVydCBpdCB0byBhbiBhcnJheSBhbmQgc2xpY2Ugb2ZmIHRoZSBmaXJzdCBpdGVtLlxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKTtcbiAgICAgICAgaWYgKGlzLmZ1bmN0aW9uXyhwcmVkaWNhdGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBwcmVkaWNhdGU6ICR7dXRpbC5pbnNwZWN0KHByZWRpY2F0ZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIHZhbHVlcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2QuY2FsbCh2YWx1ZXMsIHByZWRpY2F0ZSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBhbnkocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVPbkFycmF5KEFycmF5LnByb3RvdHlwZS5zb21lLCBwcmVkaWNhdGUsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlzLmFueSA9IGFueTtcbiAgICBmdW5jdGlvbiBhbGwocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVPbkFycmF5KEFycmF5LnByb3RvdHlwZS5ldmVyeSwgcHJlZGljYXRlLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpcy5hbGwgPSBhbGw7XG4gICAgLy8gdHNsaW50OmVuYWJsZTpvbmx5LWFycm93LWZ1bmN0aW9ucyBuby1mdW5jdGlvbi1leHByZXNzaW9uXG59KShpcyB8fCAoaXMgPSB7fSkpO1xuLy8gU29tZSBmZXcga2V5d29yZHMgYXJlIHJlc2VydmVkLCBidXQgd2UnbGwgcG9wdWxhdGUgdGhlbSBmb3IgTm9kZS5qcyB1c2Vyc1xuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjUzNlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaXMsIHtcbiAgICBjbGFzczoge1xuICAgICAgICB2YWx1ZTogaXMuY2xhc3NfXG4gICAgfSxcbiAgICBmdW5jdGlvbjoge1xuICAgICAgICB2YWx1ZTogaXMuZnVuY3Rpb25fXG4gICAgfSxcbiAgICBudWxsOiB7XG4gICAgICAgIHZhbHVlOiBpcy5udWxsX1xuICAgIH1cbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXM7XG4vLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxubW9kdWxlLmV4cG9ydHMgPSBpcztcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBpcztcbiIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBkaWZmZXJlbmNlIChhLCBiLCBrZXkpIHtcbiAgLy8gSW5kaWNlcyBmb3IgcXVpY2sgbG9va3Vwc1xuICB2YXIgcHJvY2Vzc2VkID0ge31cbiAgdmFyIGV4aXN0aW5nID0ge31cblxuICAvLyBDcmVhdGUgYW4gaW5kZXggb2YgdGhlIGZpcnN0IGNvbGxlY3Rpb25cbiAgdmFyIGFkZFRvSW5kZXggPSBlID0+IChleGlzdGluZ1trZXkgPyBlW2tleV0gOiBlXSA9IHRydWUpXG4gIGEuZm9yRWFjaChhZGRUb0luZGV4KVxuXG4gIC8vIFJlZHVjZSB0byBlbnRyaWVzIHRoYXQgYXJlIG5vdCBpbiB0aGUgZmlyc3QgY29sbGVjdGlvblxuICB2YXIgcmVkdWNlciA9IChyZXMsIGVudHJ5KSA9PiB7XG4gICAgdmFyIGlzSW5GaXJzdCA9IGV4aXN0aW5nW2tleSA/IGVudHJ5W2tleV0gOiBlbnRyeV0gIT09IHVuZGVmaW5lZFxuICAgIHZhciBoYXNCZWVuUHJvY2Vzc2VkID0gcHJvY2Vzc2VkW2tleSA/IGVudHJ5W2tleV0gOiBlbnRyeV0gIT09IHVuZGVmaW5lZFxuICAgIGlmICghaXNJbkZpcnN0ICYmICFoYXNCZWVuUHJvY2Vzc2VkKSB7XG4gICAgICByZXMucHVzaChlbnRyeSlcbiAgICAgIHByb2Nlc3NlZFtrZXkgPyBlbnRyeVtrZXldIDogZW50cnldID0gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICByZXR1cm4gYi5yZWR1Y2UocmVkdWNlciwgW10pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGlmZmVyZW5jZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIGZpbmRVbmlxdWVzICh2YWx1ZSwga2V5KSB7XG4gIC8vIENyZWF0ZSBhbiBpbmRleCBvZiB0aGUgY29sbGVjdGlvblxuICBsZXQgdW5pcXVlcyA9IHt9XG4gIHZhciBnZXQgPSBlID0+IHVuaXF1ZXNbZV1cbiAgdmFyIGFkZFRvSW5kZXggPSBlID0+ICh1bmlxdWVzW2tleSA/IGVba2V5XSA6IGVdID0gZSlcbiAgdmFsdWUuZm9yRWFjaChhZGRUb0luZGV4KVxuICByZXR1cm4gT2JqZWN0LmtleXModW5pcXVlcykubWFwKGdldClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kVW5pcXVlc1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGlzRGVmaW5lZCA9IChhcmcpID0+IGFyZyAhPT0gdW5kZWZpbmVkICYmIGFyZyAhPT0gbnVsbFxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRGVmaW5lZFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBXaGlsc3QgPSByZXF1aXJlKCdwLXdoaWxzdCcpXG5jb25zdCBwTWFwID0gcmVxdWlyZSgncC1tYXAnKVxuY29uc3QgRW50cnkgPSByZXF1aXJlKCcuL2VudHJ5JylcblxuY2xhc3MgRW50cnlJTyB7XG4gIC8qKlxuICAgKiBGZXRjaCBsb2cgZW50cmllcyBpbiBwYXJhbGxlbC5cbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gaGFzaGVzIGhhc2hlcyBvZiB0aGUgZW50cmllcyB0byBmZXRjaFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZW5ndGggSG93IG1hbnkgZW50cmllcyB0byBmZXRjaFxuICAgKiBAcGFyYW0ge0FycmF5PEVudHJ5Pn0gb3B0aW9ucy5leGNsdWRlIEVudHJpZXMgdG8gbm90IGZldGNoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNvbmN1cnJlbmN5IE1heCBjb25jdXJyZW50IGZldGNoIG9wZXJhdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudGltZW91dCBNYXhpbXVtIHRpbWUgdG8gd2FpdCBmb3IgZWFjaCBmZXRjaCBvcGVyYXRpb24sIGluIG1zXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaGFzaCwgZW50cnksIHBhcmVudCwgZGVwdGgpfSBvcHRpb25zLm9uUHJvZ3Jlc3NDYWxsYmFja1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxFbnRyeT4+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZldGNoUGFyYWxsZWwgKGlwZnMsIGhhc2hlcyxcbiAgICB7IGxlbmd0aCA9IC0xLCBleGNsdWRlID0gW10sIGNvbmN1cnJlbmN5ID0gbnVsbCwgdGltZW91dCwgb25Qcm9ncmVzc0NhbGxiYWNrIH0gPSB7fSkge1xuICAgIGNvbnN0IGZldGNoT25lID0gKGhhc2gpID0+IEVudHJ5SU8uZmV0Y2hBbGwoaXBmcywgaGFzaCxcbiAgICAgIHsgbGVuZ3RoLCBleGNsdWRlLCB0aW1lb3V0LCBvblByb2dyZXNzQ2FsbGJhY2sgfSlcbiAgICBjb25zdCBnZXRIYXNoZXMgPSBlID0+IGUuaGFzaFxuICAgIGNvbnN0IHVuaXF1ZWx5Q29uY2F0QXJyYXlzID0gKGFycjEsIGFycjIpID0+IHtcbiAgICAgIC8vIEFkZCBhbnkgbmV3IGVudHJpZXMgdG8gYXJyMVxuICAgICAgY29uc3QgZW50cnlIYXNoZXMgPSBhcnIxLm1hcChnZXRIYXNoZXMpXG4gICAgICBhcnIyLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICBpZiAoZW50cnlIYXNoZXMuaW5kZXhPZihlbnRyeS5oYXNoKSA9PT0gLTEpIGFycjEucHVzaChlbnRyeSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gYXJyMVxuICAgIH1cbiAgICBjb25zdCBmbGF0dGVuID0gKGFycikgPT4gYXJyLnJlZHVjZSh1bmlxdWVseUNvbmNhdEFycmF5cywgW10pXG4gICAgY29uc3QgaGFzaGVzVG9GZXRjaCA9IEFycmF5LmlzQXJyYXkoaGFzaGVzKSA/IGhhc2hlcy5zbGljZSgpIDogW2hhc2hlc11cbiAgICBjb25jdXJyZW5jeSA9IE1hdGgubWF4KGNvbmN1cnJlbmN5IHx8IGhhc2hlc1RvRmV0Y2gubGVuZ3RoLCAxKVxuXG4gICAgY29uc3QgZW50cmllcyA9IGF3YWl0IHBNYXAoaGFzaGVzVG9GZXRjaCwgZmV0Y2hPbmUsIHsgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5IH0pXG4gICAgLy8gRmxhdHRlbiB0aGUgcmVzdWx0cyBhbmQgZ2V0IHVuaXF1ZSB2YWxzXG4gICAgcmV0dXJuIGZsYXR0ZW4oZW50cmllcylcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBsb2cgZW50cmllcyBzZXF1ZW50aWFsbHkuXG4gICAqIEBwYXJhbSB7SVBGU30gaXBmcyBBbiBJUEZTIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IGhhc2hlcyBoYXNoZXMgb2YgdGhlIGVudHJpZXMgdG8gZmV0Y2hcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubGVuZ3RoIEhvdyBtYW55IGVudHJpZXMgdG8gZmV0Y2hcbiAgICogQHBhcmFtIHtBcnJheTxFbnRyeT59IG9wdGlvbnMuZXhjbHVkZSBFbnRyaWVzIHRvIG5vdCBmZXRjaFxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jb25jdXJyZW5jeSBNYXggY29uY3VycmVudCBmZXRjaCBvcGVyYXRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbWVvdXQgTWF4aW11bSB0aW1lIHRvIHdhaXQgZm9yIGVhY2ggZmV0Y2ggb3BlcmF0aW9uLCBpbiBtc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGhhc2gsIGVudHJ5LCBwYXJlbnQsIGRlcHRoKX0gb3B0aW9ucy5vblByb2dyZXNzQ2FsbGJhY2tcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8RW50cnk+Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmZXRjaEFsbCAoaXBmcywgaGFzaGVzLFxuICAgIHsgbGVuZ3RoID0gLTEsIGV4Y2x1ZGUgPSBbXSwgdGltZW91dCA9IG51bGwsIG9uUHJvZ3Jlc3NDYWxsYmFjayB9KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdXG4gICAgbGV0IGNhY2hlID0ge31cbiAgICBsZXQgbG9hZGluZ1F1ZXVlID0gQXJyYXkuaXNBcnJheShoYXNoZXMpXG4gICAgICA/IGhhc2hlcy5zbGljZSgpXG4gICAgICA6IFtoYXNoZXNdXG5cbiAgICAvLyBBZGQgYSBoYXNoIHRvIHRoZSBsb2FkaW5nIHF1ZXVlXG4gICAgY29uc3QgYWRkVG9Mb2FkaW5nUXVldWUgPSBlID0+IGxvYWRpbmdRdWV1ZS5wdXNoKGUpXG5cbiAgICAvLyBBZGQgZW50cmllcyB0aGF0IHdlIGRvbid0IG5lZWQgdG8gZmV0Y2ggdG8gdGhlIFwiY2FjaGVcIlxuICAgIGV4Y2x1ZGUgPSBleGNsdWRlICYmIEFycmF5LmlzQXJyYXkoZXhjbHVkZSkgPyBleGNsdWRlIDogW11cbiAgICB2YXIgYWRkVG9FeGNsdWRlQ2FjaGUgPSBlID0+IHtcbiAgICAgIGlmIChFbnRyeS5pc0VudHJ5KGUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGUpXG4gICAgICAgIGNhY2hlW2UuaGFzaF0gPSBlXG4gICAgICB9XG4gICAgfVxuICAgIGV4Y2x1ZGUuZm9yRWFjaChhZGRUb0V4Y2x1ZGVDYWNoZSlcblxuICAgIGNvbnN0IHNob3VsZEZldGNoTW9yZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBsb2FkaW5nUXVldWUubGVuZ3RoID4gMCAmJlxuICAgICAgICAgIChyZXN1bHQubGVuZ3RoIDwgbGVuZ3RoIHx8IGxlbmd0aCA8IDApXG4gICAgfVxuXG4gICAgY29uc3QgZmV0Y2hFbnRyeSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGhhc2ggPSBsb2FkaW5nUXVldWUuc2hpZnQoKVxuXG4gICAgICBpZiAoY2FjaGVbaGFzaF0pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHByb21pc2UgYWZ0ZXIgYSB0aW1lb3V0IChpZiBnaXZlbikgaW4gb3JkZXIgdG9cbiAgICAgICAgLy8gbm90IGdldCBzdHVjayBsb2FkaW5nIGEgYmxvY2sgdGhhdCBpcyB1bnJlYWNoYWJsZVxuICAgICAgICBjb25zdCB0aW1lciA9IHRpbWVvdXRcbiAgICAgICAgICA/IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBXYXJuaW5nOiBDb3VsZG4ndCBmZXRjaCBlbnRyeSAnJHtoYXNofScsIHJlcXVlc3QgdGltZWQgb3V0ICgke3RpbWVvdXR9bXMpYClcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH0sIHRpbWVvdXQpXG4gICAgICAgICAgOiBudWxsXG5cbiAgICAgICAgY29uc3QgYWRkVG9SZXN1bHRzID0gKGVudHJ5KSA9PiB7XG4gICAgICAgICAgaWYgKEVudHJ5LmlzRW50cnkoZW50cnkpKSB7XG4gICAgICAgICAgICBlbnRyeS5uZXh0LmZvckVhY2goYWRkVG9Mb2FkaW5nUXVldWUpXG4gICAgICAgICAgICByZXN1bHQucHVzaChlbnRyeSlcbiAgICAgICAgICAgIGNhY2hlW2hhc2hdID0gZW50cnlcbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgb25Qcm9ncmVzc0NhbGxiYWNrKGhhc2gsIGVudHJ5LCByZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvYWQgdGhlIGVudHJ5XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBFbnRyeS5mcm9tTXVsdGloYXNoKGlwZnMsIGhhc2gpXG4gICAgICAgICAgYWRkVG9SZXN1bHRzKGVudHJ5KVxuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGF3YWl0IHBXaGlsc3Qoc2hvdWxkRmV0Y2hNb3JlLCBmZXRjaEVudHJ5KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVudHJ5SU9cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBERUZBVUxUUyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKVxuY29uc3QgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vdXRpbCcpLmlzRnVuY3Rpb25cbmNvbnN0IGlzQm9vbGVhbiA9IHJlcXVpcmUoJy4vdXRpbCcpLmlzQm9vbGVhblxuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL3V0aWwnKS5pc09iamVjdFxuY29uc3QgaXNBcnJheSA9IHJlcXVpcmUoJy4vdXRpbCcpLmlzQXJyYXlcbmNvbnN0IGlzUmVnZXggPSByZXF1aXJlKCcuL3V0aWwnKS5pc1JlZ2V4XG5jb25zdCBhc3NpZ24gPSByZXF1aXJlKCcuL3V0aWwnKS5hc3NpZ25cbmNvbnN0IGtleXMgPSByZXF1aXJlKCcuL3V0aWwnKS5rZXlzXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZSAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHJldHVybiBvYmpcbiAgaWYgKGlzUmVnZXgob2JqKSkgcmV0dXJuIG9iai50b1N0cmluZygpXG4gIHJldHVybiBvYmoudG9KU09OID8gb2JqLnRvSlNPTigpIDogb2JqXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeURldGVybWluaXN0aWMgKG9iaiwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCBhc3NpZ24oe30sIERFRkFVTFRTKVxuXG4gIGlmIChpc0Z1bmN0aW9uKG9wdHMpKSBvcHRzID0geyBjb21wYXJlOiBvcHRzIH1cblxuICBjb25zdCBzcGFjZSA9IG9wdHMuc3BhY2UgfHwgREVGQVVMVFMuc3BhY2VcbiAgY29uc3QgY3ljbGVzID0gaXNCb29sZWFuKG9wdHMuY3ljbGVzKSA/IG9wdHMuY3ljbGVzIDogREVGQVVMVFMuY3ljbGVzXG4gIGNvbnN0IHJlcGxhY2VyID0gb3B0cy5yZXBsYWNlciB8fCBERUZBVUxUUy5yZXBsYWNlclxuICBjb25zdCBzdHJpbmdpZnkgPSBvcHRzLnN0cmluZ2lmeSB8fCBERUZBVUxUUy5zdHJpbmdpZnlcblxuICBjb25zdCBjb21wYXJlID0gb3B0cy5jb21wYXJlICYmIChmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFvYmogPSB7a2V5OiBhLCB2YWx1ZTogbm9kZVthXX1cbiAgICAgICAgY29uc3QgYm9iaiA9IHtrZXk6IGIsIHZhbHVlOiBub2RlW2JdfVxuICAgICAgICByZXR1cm4gZihhb2JqLCBib2JqKVxuICAgICAgfVxuICAgIH1cbiAgfSkob3B0cy5jb21wYXJlKVxuXG4gIC8vIERldGVjdCBjaXJjdWxhciBzdHJ1Y3R1cmUgaW4gb2JqIGFuZCByYWlzZSBlcnJvciBlZmZpY2llbnRseS5cbiAgaWYgKCFjeWNsZXMpIHN0cmluZ2lmeShvYmopXG5cbiAgY29uc3Qgc2VlbiA9IFtdXG5cbiAgcmV0dXJuIChmdW5jdGlvbiBfZGV0ZXJtaW5pc3RpYyAocGFyZW50LCBrZXksIG5vZGUsIGxldmVsKSB7XG4gICAgY29uc3QgaW5kZW50ID0gc3BhY2UgPyAoJ1xcbicgKyBuZXcgQXJyYXkobGV2ZWwgKyAxKS5qb2luKHNwYWNlKSkgOiAnJ1xuICAgIGNvbnN0IGNvbG9uU2VwYXJhdG9yID0gc3BhY2UgPyAnOiAnIDogJzonXG5cbiAgICBub2RlID0gc2VyaWFsaXplKG5vZGUpXG4gICAgbm9kZSA9IHJlcGxhY2VyLmNhbGwocGFyZW50LCBrZXksIG5vZGUpXG5cbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cblxuICAgIGlmICghaXNPYmplY3Qobm9kZSkgfHwgbm9kZSA9PT0gbnVsbCkgcmV0dXJuIHN0cmluZ2lmeShub2RlKVxuXG4gICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGNvbnN0IG91dCA9IFtdXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IF9kZXRlcm1pbmlzdGljKG5vZGUsIGksIG5vZGVbaV0sIGxldmVsICsgMSkgfHwgc3RyaW5naWZ5KG51bGwpXG4gICAgICAgIG91dC5wdXNoKGluZGVudCArIHNwYWNlICsgaXRlbSlcbiAgICAgIH1cbiAgICAgIHJldHVybiAnWycgKyBvdXQuam9pbignLCcpICsgaW5kZW50ICsgJ10nXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjeWNsZXMpIHtcbiAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KCdbQ2lyY3VsYXJdJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuLnB1c2gobm9kZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlS2V5cyA9IGtleXMobm9kZSkuc29ydChjb21wYXJlICYmIGNvbXBhcmUobm9kZSkpXG4gICAgICBjb25zdCBvdXQgPSBbXVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBub2RlS2V5c1tpXVxuICAgICAgICBjb25zdCB2YWx1ZSA9IF9kZXRlcm1pbmlzdGljKG5vZGUsIGtleSwgbm9kZVtrZXldLCBsZXZlbCArIDEpXG5cbiAgICAgICAgaWYgKCF2YWx1ZSkgY29udGludWVcblxuICAgICAgICBjb25zdCBrZXlWYWx1ZSA9IHN0cmluZ2lmeShrZXkpICsgY29sb25TZXBhcmF0b3IgKyB2YWx1ZVxuICAgICAgICBvdXQucHVzaChpbmRlbnQgKyBzcGFjZSArIGtleVZhbHVlKVxuICAgICAgfVxuICAgICAgc2Vlbi5zcGxpY2Uoc2Vlbi5pbmRleE9mKG5vZGUpLCAxKVxuICAgICAgcmV0dXJuICd7JyArIG91dC5qb2luKCcsJykgKyBpbmRlbnQgKyAnfSdcbiAgICB9XG4gIH0pKHsgJyc6IG9iaiB9LCAnJywgb2JqLCAwKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ2lmeURldGVybWluaXN0aWNcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbnZhciBwYWRfc3RyaW5nXzEgPSByZXF1aXJlKFwiLi9wYWQtc3RyaW5nXCIpO1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0LCBlbmNvZGluZykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gdm9pZCAwKSB7IGVuY29kaW5nID0gXCJ1dGY4XCI7IH1cbiAgICBpZiAoYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZnJvbUJhc2U2NChpbnB1dC50b1N0cmluZyhcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIHJldHVybiBmcm9tQmFzZTY0KGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGlucHV0LCBlbmNvZGluZykudG9TdHJpbmcoXCJiYXNlNjRcIikpO1xufVxuO1xuZnVuY3Rpb24gZGVjb2RlKGJhc2U2NHVybCwgZW5jb2RpbmcpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9IFwidXRmOFwiOyB9XG4gICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHRvQmFzZTY0KGJhc2U2NHVybCksIFwiYmFzZTY0XCIpLnRvU3RyaW5nKGVuY29kaW5nKTtcbn1cbmZ1bmN0aW9uIHRvQmFzZTY0KGJhc2U2NHVybCkge1xuICAgIGJhc2U2NHVybCA9IGJhc2U2NHVybC50b1N0cmluZygpO1xuICAgIHJldHVybiBwYWRfc3RyaW5nXzEuZGVmYXVsdChiYXNlNjR1cmwpXG4gICAgICAgIC5yZXBsYWNlKC9cXC0vZywgXCIrXCIpXG4gICAgICAgIC5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbn1cbmZ1bmN0aW9uIGZyb21CYXNlNjQoYmFzZTY0KSB7XG4gICAgcmV0dXJuIGJhc2U2NFxuICAgICAgICAucmVwbGFjZSgvPS9nLCBcIlwiKVxuICAgICAgICAucmVwbGFjZSgvXFwrL2csIFwiLVwiKVxuICAgICAgICAucmVwbGFjZSgvXFwvL2csIFwiX1wiKTtcbn1cbmZ1bmN0aW9uIHRvQnVmZmVyKGJhc2U2NHVybCkge1xuICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbSh0b0Jhc2U2NChiYXNlNjR1cmwpLCBcImJhc2U2NFwiKTtcbn1cbnZhciBiYXNlNjR1cmwgPSBlbmNvZGU7XG5iYXNlNjR1cmwuZW5jb2RlID0gZW5jb2RlO1xuYmFzZTY0dXJsLmRlY29kZSA9IGRlY29kZTtcbmJhc2U2NHVybC50b0Jhc2U2NCA9IHRvQmFzZTY0O1xuYmFzZTY0dXJsLmZyb21CYXNlNjQgPSBmcm9tQmFzZTY0O1xuYmFzZTY0dXJsLnRvQnVmZmVyID0gdG9CdWZmZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBiYXNlNjR1cmw7XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IGlzRGVmaW5lZCA9IHJlcXVpcmUoJy4vaXMtZGVmaW5lZCcpXG5cbmNsYXNzIElkZW50aXR5IHtcbiAgY29uc3RydWN0b3IgKGlkLCBwdWJsaWNLZXksIGlkU2lnbmF0dXJlLCBwdWJLZXlJZFNpZ25hdHVyZSwgdHlwZSwgcHJvdmlkZXIpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChpZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWRlbnRpdHkgaWQgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIGlmICghaXNEZWZpbmVkKHB1YmxpY0tleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwdWJsaWMga2V5JylcbiAgICB9XG5cbiAgICBpZiAoIWlzRGVmaW5lZChpZFNpZ25hdHVyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIG9mIHRoZSBpZCAoaWRTaWduYXR1cmUpIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICBpZiAoIWlzRGVmaW5lZChwdWJLZXlJZFNpZ25hdHVyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIG9mIChwdWJsaWNLZXkgKyBpZFNpZ25hdHVyZSkgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIGlmICghaXNEZWZpbmVkKHR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lkZW50aXR5IHR5cGUgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIGlmICghaXNEZWZpbmVkKHByb3ZpZGVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZGVudGl0eSBwcm92aWRlciBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgdGhpcy5faWQgPSBpZFxuICAgIHRoaXMuX3B1YmxpY0tleSA9IHB1YmxpY0tleVxuICAgIHRoaXMuX3NpZ25hdHVyZXMgPSBPYmplY3QuYXNzaWduKHt9LCB7IGlkOiBpZFNpZ25hdHVyZSB9LCB7IHB1YmxpY0tleTogcHViS2V5SWRTaWduYXR1cmUgfSlcbiAgICB0aGlzLl90eXBlID0gdHlwZVxuICAgIHRoaXMuX3Byb3ZpZGVyID0gcHJvdmlkZXJcbiAgfVxuXG4gIC8qKlxuICAqIFRoaXMgaXMgb25seSB1c2VkIGFzIGEgZmFsbGJhY2sgdG8gdGhlIGNsb2NrIGlkIHdoZW4gbmVjZXNzYXJ5XG4gICogQHJldHVybiB7c3RyaW5nfSBwdWJsaWMga2V5IGhleCBlbmNvZGVkXG4gICovXG4gIGdldCBpZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkXG4gIH1cblxuICBnZXQgcHVibGljS2V5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVibGljS2V5XG4gIH1cblxuICBnZXQgc2lnbmF0dXJlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZXNcbiAgfVxuXG4gIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHlwZVxuICB9XG5cbiAgZ2V0IHByb3ZpZGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXJcbiAgfVxuXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgIHB1YmxpY0tleTogdGhpcy5fcHVibGljS2V5LFxuICAgICAgc2lnbmF0dXJlczogdGhpcy5fc2lnbmF0dXJlcyxcbiAgICAgIHR5cGU6IHRoaXMuX3R5cGVcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJZGVudGl0eVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCBJZGVudGl0eVByb3ZpZGVyID0gcmVxdWlyZSgnLi9pZGVudGl0eS1wcm92aWRlci1pbnRlcmZhY2UnKVxuY29uc3QgS2V5c3RvcmUgPSByZXF1aXJlKCdvcmJpdC1kYi1rZXlzdG9yZScpXG5jb25zdCBzaWduaW5nS2V5c1BhdGggPSAnLi9vcmJpdGRiL2lkZW50aXR5L3NpZ25pbmdrZXlzJ1xuY29uc3QgdHlwZSA9ICdvcmJpdGRiJ1xuXG5jbGFzcyBPcmJpdERCSWRlbnRpdHlQcm92aWRlciBleHRlbmRzIElkZW50aXR5UHJvdmlkZXIge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2tleXN0b3JlID0gb3B0aW9ucy5rZXlzdG9yZSB8fCBLZXlzdG9yZS5jcmVhdGUob3B0aW9ucy5zaWduaW5nS2V5c1BhdGggfHwgc2lnbmluZ0tleXNQYXRoKVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgaWRlbnRpdHkgcHJvdmlkZXJcbiAgc3RhdGljIGdldCB0eXBlICgpIHsgcmV0dXJuIHR5cGUgfVxuXG4gIGFzeW5jIGdldElkIChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBpZCA9IG9wdGlvbnMuaWRcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lkIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzdG9yZSA9IHRoaXMuX2tleXN0b3JlXG4gICAgY29uc3Qga2V5ID0gYXdhaXQga2V5c3RvcmUuZ2V0S2V5KGlkKSB8fCBhd2FpdCBrZXlzdG9yZS5jcmVhdGVLZXkoaWQpXG4gICAgcmV0dXJuIGtleS5wdWJsaWMubWFyc2hhbCgpLnRvU3RyaW5nKCdoZXgnKVxuICB9XG5cbiAgYXN5bmMgc2lnbklkZW50aXR5IChkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBpZCA9IG9wdGlvbnMuaWRcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lkIGlzIHJlcXVpcmVkJylcbiAgICB9XG4gICAgY29uc3Qga2V5c3RvcmUgPSB0aGlzLl9rZXlzdG9yZVxuICAgIGNvbnN0IGtleSA9IGF3YWl0IGtleXN0b3JlLmdldEtleShpZClcbiAgICBpZiAoIWtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaWduaW5nIGtleSBmb3IgJyR7aWR9JyBub3QgZm91bmRgKVxuICAgIH1cblxuICAgIHJldHVybiBrZXlzdG9yZS5zaWduKGtleSwgZGF0YSlcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyB2ZXJpZnlJZGVudGl0eSAoaWRlbnRpdHkpIHtcbiAgICAvLyBWZXJpZnkgdGhhdCBpZGVudGl0eSB3YXMgc2lnbmVkIGJ5IHRoZSBJRFxuICAgIHJldHVybiBLZXlzdG9yZS52ZXJpZnkoXG4gICAgICBpZGVudGl0eS5zaWduYXR1cmVzLnB1YmxpY0tleSxcbiAgICAgIGlkZW50aXR5LmlkLFxuICAgICAgaWRlbnRpdHkucHVibGljS2V5ICsgaWRlbnRpdHkuc2lnbmF0dXJlcy5pZFxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9yYml0REJJZGVudGl0eVByb3ZpZGVyXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwYWRfc3RyaW5nXzEgPSByZXF1aXJlKFwiLi9wYWQtc3RyaW5nXCIpO1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0LCBlbmNvZGluZykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gdm9pZCAwKSB7IGVuY29kaW5nID0gXCJ1dGY4XCI7IH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZnJvbUJhc2U2NChpbnB1dC50b1N0cmluZyhcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIHJldHVybiBmcm9tQmFzZTY0KEJ1ZmZlci5mcm9tKGlucHV0LCBlbmNvZGluZykudG9TdHJpbmcoXCJiYXNlNjRcIikpO1xufVxuO1xuZnVuY3Rpb24gZGVjb2RlKGJhc2U2NHVybCwgZW5jb2RpbmcpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9IFwidXRmOFwiOyB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRvQmFzZTY0KGJhc2U2NHVybCksIFwiYmFzZTY0XCIpLnRvU3RyaW5nKGVuY29kaW5nKTtcbn1cbmZ1bmN0aW9uIHRvQmFzZTY0KGJhc2U2NHVybCkge1xuICAgIGJhc2U2NHVybCA9IGJhc2U2NHVybC50b1N0cmluZygpO1xuICAgIHJldHVybiBwYWRfc3RyaW5nXzEuZGVmYXVsdChiYXNlNjR1cmwpXG4gICAgICAgIC5yZXBsYWNlKC9cXC0vZywgXCIrXCIpXG4gICAgICAgIC5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbn1cbmZ1bmN0aW9uIGZyb21CYXNlNjQoYmFzZTY0KSB7XG4gICAgcmV0dXJuIGJhc2U2NFxuICAgICAgICAucmVwbGFjZSgvPS9nLCBcIlwiKVxuICAgICAgICAucmVwbGFjZSgvXFwrL2csIFwiLVwiKVxuICAgICAgICAucmVwbGFjZSgvXFwvL2csIFwiX1wiKTtcbn1cbmZ1bmN0aW9uIHRvQnVmZmVyKGJhc2U2NHVybCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0b0Jhc2U2NChiYXNlNjR1cmwpLCBcImJhc2U2NFwiKTtcbn1cbnZhciBiYXNlNjR1cmwgPSBlbmNvZGU7XG5iYXNlNjR1cmwuZW5jb2RlID0gZW5jb2RlO1xuYmFzZTY0dXJsLmRlY29kZSA9IGRlY29kZTtcbmJhc2U2NHVybC50b0Jhc2U2NCA9IHRvQmFzZTY0O1xuYmFzZTY0dXJsLmZyb21CYXNlNjQgPSBmcm9tQmFzZTY0O1xuYmFzZTY0dXJsLnRvQnVmZmVyID0gdG9CdWZmZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBiYXNlNjR1cmw7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2VsbGlwdGljID0gcmVxdWlyZShcImVsbGlwdGljXCIpO1xuXG52YXIgX0RpZ2VzdCA9IHJlcXVpcmUoXCIuL0RpZ2VzdFwiKTtcblxudmFyIHNlY3AyNTZrMSA9IG5ldyBfZWxsaXB0aWMuZWMoJ3NlY3AyNTZrMScpO1xuXG5mdW5jdGlvbiBsZWZ0cGFkKGRhdGEpIHtcbiAgdmFyIHNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDY0O1xuICBpZiAoZGF0YS5sZW5ndGggPT09IHNpemUpIHJldHVybiBkYXRhO1xuICByZXR1cm4gJzAnLnJlcGVhdChzaXplIC0gZGF0YS5sZW5ndGgpICsgZGF0YTtcbn1cbi8qKlxuKiAgVGhlIFNpbXBsZVNpZ25lciByZXR1cm5zIGEgY29uZmlndXJlZCBmdW5jdGlvbiBmb3Igc2lnbmluZyBkYXRhLiBJdCBhbHNvIGRlZmluZXNcbiogIGFuIGludGVyZmFjZSB0aGF0IHlvdSBjYW4gYWxzbyBpbXBsZW1lbnQgeW91cnNlbGYgYW5kIHVzZSBpbiBvdXIgb3RoZXIgbW9kdWxlcy5cbipcbiogIEBleGFtcGxlXG4qICBjb25zdCBzaWduZXIgPSBTaW1wbGVTaWduZXIocHJvY2Vzcy5lbnYuUFJJVkFURV9LRVkpXG4qICBzaWduZXIoZGF0YSwgKGVyciwgc2lnbmF0dXJlKSA9PiB7XG4qICAgIC4uLlxuKiAgfSlcbipcbiogIEBwYXJhbSAgICB7U3RyaW5nfSAgICAgICAgIGhleFByaXZhdGVLZXkgICAgYSBoZXggZW5jb2RlZCBwcml2YXRlIGtleVxuKiAgQHJldHVybiAgIHtGdW5jdGlvbn0gICAgICAgICAgICAgICAgICAgICBhIGNvbmZpZ3VyZWQgc2lnbmVyIGZ1bmN0aW9uXG4qL1xuXG5cbmZ1bmN0aW9uIFNpbXBsZVNpZ25lcihoZXhQcml2YXRlS2V5KSB7XG4gIHZhciBwcml2YXRlS2V5ID0gc2VjcDI1NmsxLmtleUZyb21Qcml2YXRlKGhleFByaXZhdGVLZXkpO1xuICByZXR1cm4gKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoZGF0YSkge1xuICAgICAgICB2YXIgX3ByaXZhdGVLZXkkc2lnbiwgciwgcywgcmVjb3ZlcnlQYXJhbTtcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfcHJpdmF0ZUtleSRzaWduID0gcHJpdmF0ZUtleS5zaWduKCgwLCBfRGlnZXN0LnNoYTI1NikoZGF0YSkpLCByID0gX3ByaXZhdGVLZXkkc2lnbi5yLCBzID0gX3ByaXZhdGVLZXkkc2lnbi5zLCByZWNvdmVyeVBhcmFtID0gX3ByaXZhdGVLZXkkc2lnbi5yZWNvdmVyeVBhcmFtO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgcjogbGVmdHBhZChyLnRvU3RyaW5nKCdoZXgnKSksXG4gICAgICAgICAgICAgICAgICBzOiBsZWZ0cGFkKHMudG9TdHJpbmcoJ2hleCcpKSxcbiAgICAgICAgICAgICAgICAgIHJlY292ZXJ5UGFyYW06IHJlY292ZXJ5UGFyYW1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSgpXG4gICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlU2lnbmVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfdHdlZXRuYWNsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwidHdlZXRuYWNsXCIpKTtcblxudmFyIF90d2VldG5hY2xVdGlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwidHdlZXRuYWNsLXV0aWxcIikpO1xuXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRVcmwoZGF0YSkge1xuICByZXR1cm4gX3R3ZWV0bmFjbFV0aWwuZGVmYXVsdC5lbmNvZGVCYXNlNjQoZGF0YSkucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvPS9nLCAnJyk7XG59XG4vKipcbiogIFRoZSBOYWNsU2lnbmVyIHJldHVybnMgYSBjb25maWd1cmVkIGZ1bmN0aW9uIGZvciBzaWduaW5nIGRhdGEgdXNpbmcgdGhlIEVkMjU1MTkgYWxnb3JpdGhtLiBJdCBhbHNvIGRlZmluZXNcbiogIGFuIGludGVyZmFjZSB0aGF0IHlvdSBjYW4gYWxzbyBpbXBsZW1lbnQgeW91cnNlbGYgYW5kIHVzZSBpbiBvdXIgb3RoZXIgbW9kdWxlcy5cbipcbiogIFRoZSBzaWduaW5nIGZ1bmN0aW9uIGl0c2VsZiB0YWtlcyB0aGUgZGF0YSBhcyBhIHN0cmluZyBwYXJhbWV0ZXIgYW5kIHJldHVybHMgYSBiYXNlNjRVcmwgZW5jb2RlZCBzaWduYXR1cmVcbipcbiogIEBleGFtcGxlXG4qICBjb25zdCBzaWduZXIgPSBOYWNsU2lnbmVyKHByb2Nlc3MuZW52LlBSSVZBVEVfS0VZKVxuKiAgc2lnbmVyKGRhdGEsIChlcnIsIHNpZ25hdHVyZSkgPT4ge1xuKiAgICAuLi5cbiogIH0pXG4qXG4qICBAcGFyYW0gICAge1N0cmluZ30gICAgICAgICBiYXNlNjRQcml2YXRlS2V5ICAgIGEgNjQgYnl0ZSBiYXNlNjQgZW5jb2RlZCBwcml2YXRlIGtleVxuKiAgQHJldHVybiAgIHtGdW5jdGlvbn0gICAgICAgICAgICAgICAgICAgICBhIGNvbmZpZ3VyZWQgc2lnbmVyIGZ1bmN0aW9uXG4qL1xuXG5cbmZ1bmN0aW9uIE5hY2xTaWduZXIoYmFzZTY0UHJpdmF0ZUtleSkge1xuICB2YXIgcHJpdmF0ZUtleSA9IF90d2VldG5hY2xVdGlsLmRlZmF1bHQuZGVjb2RlQmFzZTY0KGJhc2U2NFByaXZhdGVLZXkpO1xuXG4gIHJldHVybiAoXG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShkYXRhKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZW5jb2RlQmFzZTY0VXJsKF90d2VldG5hY2wuZGVmYXVsdC5zaWduLmRldGFjaGVkKF90d2VldG5hY2xVdGlsLmRlZmF1bHQuZGVjb2RlVVRGOChkYXRhKSwgcHJpdmF0ZUtleSkpKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSgpXG4gICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTmFjbFNpZ25lcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5vcm1hbGl6ZURJRCA9IG5vcm1hbGl6ZURJRDtcbmV4cG9ydHMuZGVjb2RlSldUID0gZGVjb2RlSldUO1xuZXhwb3J0cy5jcmVhdGVKV1QgPSBjcmVhdGVKV1Q7XG5leHBvcnRzLnZlcmlmeUpXVCA9IHZlcmlmeUpXVDtcbmV4cG9ydHMucmVzb2x2ZUF1dGhlbnRpY2F0b3IgPSByZXNvbHZlQXV0aGVudGljYXRvcjtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuSUFUX1NLRVcgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfb2JqZWN0U3ByZWFkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfVmVyaWZpZXJBbGdvcml0aG0gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1ZlcmlmaWVyQWxnb3JpdGhtXCIpKTtcblxudmFyIF9TaWduZXJBbGdvcml0aG0gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1NpZ25lckFsZ29yaXRobVwiKSk7XG5cbnZhciBfYmFzZTY0dXJsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYmFzZTY0dXJsXCIpKTtcblxudmFyIF9kaWRSZXNvbHZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImRpZC1yZXNvbHZlclwiKSk7XG5cbnZhciBTVVBQT1JURURfUFVCTElDX0tFWV9UWVBFUyA9IHtcbiAgRVMyNTZLOiBbJ1NlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTgnLCAnU2VjcDI1NmsxU2lnbmF0dXJlVmVyaWZpY2F0aW9uS2V5MjAxOCcsICdFY2RzYVB1YmxpY0tleVNlY3AyNTZrMSddLFxuICAnRVMyNTZLLVInOiBbJ1NlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTgnLCAnU2VjcDI1NmsxU2lnbmF0dXJlVmVyaWZpY2F0aW9uS2V5MjAxOCcsICdFY2RzYVB1YmxpY0tleVNlY3AyNTZrMSddLFxuICAnRWQyNTUxOSc6IFsnRUQyNTUxOVNpZ25hdHVyZVZlcmlmaWNhdGlvbiddXG59O1xudmFyIEpPU0VfSEVBREVSID0ge1xuICB0eXA6ICdKV1QnXG59O1xudmFyIGRlZmF1bHRBbGcgPSAnRVMyNTZLJztcblxuZnVuY3Rpb24gZW5jb2RlU2VjdGlvbihkYXRhKSB7XG4gIHJldHVybiBfYmFzZTY0dXJsLmRlZmF1bHQuZW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbn1cblxudmFyIElBVF9TS0VXID0gMzAwO1xuLyoqICBAbW9kdWxlIGRpZC1qd3QvSldUICovXG5cbmV4cG9ydHMuSUFUX1NLRVcgPSBJQVRfU0tFVztcblxuZnVuY3Rpb24gaXNNTklEKGlkKSB7XG4gIHJldHVybiBpZC5tYXRjaCgvXlsxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XSskLyk7XG59XG5cbmZ1bmN0aW9uIGlzRElET3JNTklEKG1uaWRPckRpZCkge1xuICByZXR1cm4gbW5pZE9yRGlkICYmIChtbmlkT3JEaWQubWF0Y2goL15kaWQ6LykgfHwgaXNNTklEKG1uaWRPckRpZCkpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVESUQobW5pZE9yRGlkKSB7XG4gIGlmIChtbmlkT3JEaWQubWF0Y2goL15kaWQ6LykpIHJldHVybiBtbmlkT3JEaWQ7IC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbiAgaWYgKGlzTU5JRChtbmlkT3JEaWQpKSByZXR1cm4gXCJkaWQ6dXBvcnQ6XCIuY29uY2F0KG1uaWRPckRpZCk7XG4gIHRocm93IG5ldyBFcnJvcihcIk5vdCBhIHZhbGlkIERJRCAnXCIuY29uY2F0KG1uaWRPckRpZCwgXCInXCIpKTtcbn1cbi8qKlxuKiAgRGVjb2RlcyBhIEpXVCBhbmQgcmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwYXlsb2FkXG4qXG4qICBAZXhhbXBsZVxuKiAgZGVjb2RlSldUKCdleUowZVhBaU9pSktWMVFpTENKaGJHY2lPaUpGVXpJMU5rc2lmUS5leUpwWVhRaU9qRTFNalU1TWpjMU1UY3NJbUYxWkNJNkltUnBaRHAxY0c5eWREb3liM051WmtvMFYzazNURUpCYlRKdVVFSllhWEpsTVZkbVVXNDNOVkp5VmpaVWN5SXNJbVY0Y0NJNk1UVTFOelEyTXpReU1Td2libUZ0WlNJNkluVlFiM0owSUVSbGRtVnNiM0JsY2lJc0ltbHpjeUk2SW1ScFpEcDFjRzl5ZERveWIzTnVaa28wVjNrM1RFSkJiVEp1VUVKWWFYSmxNVmRtVVc0M05WSnlWalpVY3lKOS5SN293YnZOWm9MNHRpNWVjLUtwa3RiMGRhdHc5WS1Gc2hIc0Y1UjdjWHVLYWlHbFF6MWRjT09YYlhUT2Itd2c3LTMwQ0RmY2hGRVJSNlljOEY2MXltdycpXG4qXG4qICBAcGFyYW0gICAge1N0cmluZ30gICAgICAgICAgICBqd3QgICAgICAgICAgICAgICAgYSBKU09OIFdlYiBUb2tlbiB0byB2ZXJpZnlcbiogIEByZXR1cm4gICB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIEpTIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgSldUXG4qL1xuXG5cbmZ1bmN0aW9uIGRlY29kZUpXVChqd3QpIHtcbiAgaWYgKCFqd3QpIHRocm93IG5ldyBFcnJvcignbm8gSldUIHBhc3NlZCBpbnRvIGRlY29kZUpXVCcpO1xuICB2YXIgcGFydHMgPSBqd3QubWF0Y2goL14oW2EtekEtWjAtOV8tXSspXFwuKFthLXpBLVowLTlfLV0rKVxcLihbYS16QS1aMC05Xy1dKykkLyk7XG5cbiAgaWYgKHBhcnRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlYWRlcjogSlNPTi5wYXJzZShfYmFzZTY0dXJsLmRlZmF1bHQuZGVjb2RlKHBhcnRzWzFdKSksXG4gICAgICBwYXlsb2FkOiBKU09OLnBhcnNlKF9iYXNlNjR1cmwuZGVmYXVsdC5kZWNvZGUocGFydHNbMl0pKSxcbiAgICAgIHNpZ25hdHVyZTogcGFydHNbM10sXG4gICAgICBkYXRhOiBcIlwiLmNvbmNhdChwYXJ0c1sxXSwgXCIuXCIpLmNvbmNhdChwYXJ0c1syXSlcbiAgICB9O1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgZm9ybWF0IEpXVCcpO1xufVxuLyoqXG4qICBDcmVhdGVzIGEgc2lnbmVkIEpXVCBnaXZlbiBhbiBhZGRyZXNzIHdoaWNoIGJlY29tZXMgdGhlIGlzc3VlciwgYSBzaWduZXIsIGFuZCBhIHBheWxvYWQgZm9yIHdoaWNoIHRoZSBzaWduYXR1cmUgaXMgb3Zlci5cbipcbiogIEBleGFtcGxlXG4qICBjb25zdCBzaWduZXIgPSBTaW1wbGVTaWduZXIocHJvY2Vzcy5lbnYuUFJJVkFURV9LRVkpXG4qICBjcmVhdGVKV1Qoe2FkZHJlc3M6ICc1QThiUldVM0Y3ajNSRXgzdmtKLi4uJywgc2lnbmVyfSwge2tleTE6ICd2YWx1ZScsIGtleTI6IC4uLiwgLi4uIH0pLnRoZW4oand0ID0+IHtcbiogICAgICAuLi5cbiogIH0pXG4qXG4qICBAcGFyYW0gICAge09iamVjdH0gICAgICAgICAgICBwYXlsb2FkICAgICAgICAgICAgcGF5bG9hZCBvYmplY3RcbiogIEBwYXJhbSAgICB7T2JqZWN0fSAgICAgICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgYW4gdW5zaWduZWQgY3JlZGVudGlhbCBvYmplY3RcbiogIEBwYXJhbSAgICB7U3RyaW5nfSAgICAgICAgICAgIG9wdGlvbnMuaXNzdWVyICAgICAgVGhlIERJRCBvZiB0aGUgaXNzdWVyIChzaWduZXIpIG9mIEpXVFxuKiAgQHBhcmFtICAgIHtTdHJpbmd9ICAgICAgICAgICAgb3B0aW9ucy5hbGcgICAgICAgICBUaGUgSldUIHNpZ25pbmcgYWxnb3JpdGhtIHRvIHVzZS4gU3VwcG9ydHM6IFtFUzI1NkssIEVTMjU2Sy1SLCBFZDI1NTE5XSwgRGVmYXVsdHMgdG86IEVTMjU2S1xuKiAgQHBhcmFtICAgIHtTaW1wbGVTaWduZXJ9ICAgICAgb3B0aW9ucy5zaWduZXIgICAgICBhIHNpZ25lciwgcmVmZXJlbmNlIG91ciBTaW1wbGVTaWduZXIuanNcbiogIEByZXR1cm4gICB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn0gICAgICAgICAgICAgICBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2l0aCBhIHNpZ25lZCBKU09OIFdlYiBUb2tlbiBvciByZWplY3RzIHdpdGggYW4gZXJyb3JcbiovXG5cblxuZnVuY3Rpb24gY3JlYXRlSldUKF94LCBfeDIpIHtcbiAgcmV0dXJuIF9jcmVhdGVKV1QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8qKlxuKiAgVmVyaWZpZXMgZ2l2ZW4gSldULiBJZiB0aGUgSldUIGlzIHZhbGlkLCB0aGUgcHJvbWlzZSByZXR1cm5zIGFuIG9iamVjdCBpbmNsdWRpbmcgdGhlIEpXVCwgdGhlIHBheWxvYWQgb2YgdGhlIEpXVCxcbiogIGFuZCB0aGUgZGlkIGRvYyBvZiB0aGUgaXNzdWVyIG9mIHRoZSBKV1QuXG4qXG4qICBAZXhhbXBsZVxuKiAgdmVyaWZ5SldUKCdkaWQ6dXBvcnQ6ZXlKMGVYQWlPaUpLVjFRaUxDSmhiR2NpT2lKRlV6STFOa3NpZlEuZXlKeVpYRjFaLi4uLicsIHthdWRpZW5jZTogJzVBOGJSV1UzRjdqM1JFeDN2a0ouLi4nLCBjYWxsYmFja1VybDogJ2h0dHBzOi8vLi4uJ30pLnRoZW4ob2JqID0+IHtcbiogICAgICBjb25zdCBkaWQgPSBvYmouZGlkIC8vIERJRCBvZiBzaWduZXJcbiogICAgICBjb25zdCBwYXlsb2FkID0gb2JqLnBheWxvYWRcbiogICAgICBjb25zdCBkb2MgPSBvYmouZG9jIC8vIERJRCBEb2N1bWVudCBvZiBzaWduZXJcbiogICAgICBjb25zdCBqd3QgPSBvYmouand0XG4qICAgICAgY29uc3Qgc2lnbmVyS2V5SWQgPSBvYmouc2lnbmVyS2V5SWQgLy8gSUQgb2Yga2V5IGluIERJRCBkb2N1bWVudCB0aGF0IHNpZ25lZCBKV1RcbiogICAgICAuLi5cbiogIH0pXG4qXG4qICBAcGFyYW0gICAge1N0cmluZ30gICAgICAgICAgICBqd3QgICAgICAgICAgICAgICAgYSBKU09OIFdlYiBUb2tlbiB0byB2ZXJpZnlcbiogIEBwYXJhbSAgICB7T2JqZWN0fSAgICAgICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgYW4gdW5zaWduZWQgY3JlZGVudGlhbCBvYmplY3RcbiogIEBwYXJhbSAgICB7Qm9vbGVhbn0gICAgICAgICAgIG9wdGlvbnMuYXV0aCAgICAgICAgUmVxdWlyZSBzaWduZXIgdG8gYmUgbGlzdGVkIGluIHRoZSBhdXRoZW50aWNhdGlvbiBzZWN0aW9uIG9mIHRoZSBESUQgZG9jdW1lbnQgKGZvciBBdXRoZW50aWNhdGlvbiBwdXJwb3NlcylcbiogIEBwYXJhbSAgICB7U3RyaW5nfSAgICAgICAgICAgIG9wdGlvbnMuYXVkaWVuY2UgICAgRElEIG9mIHRoZSByZWNpcGllbnQgb2YgdGhlIEpXVFxuKiAgQHBhcmFtICAgIHtTdHJpbmd9ICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFja1VybCBjYWxsYmFjayB1cmwgaW4gSldUXG4qICBAcmV0dXJuICAge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59ICAgICAgICAgICAgICAgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdpdGggYSByZXNwb25zZSBvYmplY3Qgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yXG4qL1xuXG5cbmZ1bmN0aW9uIF9jcmVhdGVKV1QoKSB7XG4gIF9jcmVhdGVKV1QgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKFxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwYXlsb2FkLCBfcmVmKSB7XG4gICAgdmFyIGlzc3Vlciwgc2lnbmVyLCBhbGcsIGV4cGlyZXNJbiwgaGVhZGVyLCB0aW1lc3RhbXBzLCBzaWduaW5nSW5wdXQsIGp3dFNpZ25lciwgc2lnbmF0dXJlO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaXNzdWVyID0gX3JlZi5pc3N1ZXIsIHNpZ25lciA9IF9yZWYuc2lnbmVyLCBhbGcgPSBfcmVmLmFsZywgZXhwaXJlc0luID0gX3JlZi5leHBpcmVzSW47XG5cbiAgICAgICAgICAgIGlmIChzaWduZXIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFNpZ25lciBmdW5jdGlvbmFsaXR5IGhhcyBiZWVuIGNvbmZpZ3VyZWQnKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGlmIChpc3N1ZXIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGlzc3VpbmcgRElEIGhhcyBiZWVuIGNvbmZpZ3VyZWQnKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGhlYWRlciA9ICgwLCBfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgSk9TRV9IRUFERVIsIHtcbiAgICAgICAgICAgICAgYWxnOiBhbGcgfHwgZGVmYXVsdEFsZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aW1lc3RhbXBzID0ge1xuICAgICAgICAgICAgICBpYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIWV4cGlyZXNJbikge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgZXhwaXJlc0luID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGltZXN0YW1wcy5leHAgPSB0aW1lc3RhbXBzLmlhdCArIE1hdGguZmxvb3IoZXhwaXJlc0luKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSldUIGV4cGlyZXNJbiBpcyBub3QgYSBudW1iZXInKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBzaWduaW5nSW5wdXQgPSBbZW5jb2RlU2VjdGlvbihoZWFkZXIpLCBlbmNvZGVTZWN0aW9uKCgwLCBfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgdGltZXN0YW1wcywgcGF5bG9hZCwge1xuICAgICAgICAgICAgICBpc3M6IGlzc3VlclxuICAgICAgICAgICAgfSkpXS5qb2luKCcuJyk7XG4gICAgICAgICAgICBqd3RTaWduZXIgPSAoMCwgX1NpZ25lckFsZ29yaXRobS5kZWZhdWx0KShoZWFkZXIuYWxnKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNztcbiAgICAgICAgICAgIHJldHVybiBqd3RTaWduZXIoc2lnbmluZ0lucHV0LCBzaWduZXIpO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIFtzaWduaW5nSW5wdXQsIHNpZ25hdHVyZV0uam9pbignLicpKTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICB9KSk7XG4gIHJldHVybiBfY3JlYXRlSldULmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeUpXVChfeDMpIHtcbiAgcmV0dXJuIF92ZXJpZnlKV1QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8qKlxuKiBSZXNvbHZlcyByZWxldmFudCBwdWJsaWMga2V5cyBvciBvdGhlciBhdXRoZW50aWNhdGluZyBtYXRlcmlhbCB1c2VkIHRvIHZlcmlmeSBzaWduYXR1cmUgZnJvbSB0aGUgRElEIGRvY3VtZW50IG9mIHByb3ZpZGVkIERJRFxuKlxuKiAgQGV4YW1wbGVcbiogIHJlc29sdmVBdXRoZW50aWNhdG9yKCdFUzI1NksnLCAnZGlkOnVwb3J0OjJuUXRpUUc2Q2dtMUdZVEJhYUtBZ3I3NnVZN2lTZXhVa3FYJykudGhlbihvYmogPT4ge1xuKiAgICAgIGNvbnN0IHBheWxvYWQgPSBvYmoucGF5bG9hZFxuKiAgICAgIGNvbnN0IHByb2ZpbGUgPSBvYmoucHJvZmlsZVxuKiAgICAgIGNvbnN0IGp3dCA9IG9iai5qd3RcbiogICAgICAuLi5cbiogIH0pXG4qXG4qICBAcGFyYW0gICAge1N0cmluZ30gICAgICAgICAgICBhbGcgICAgICAgICAgICAgICAgYSBKV1QgYWxnb3JpdGhtXG4qICBAcGFyYW0gICAge1N0cmluZ30gICAgICAgICAgICBkaWQgICAgICAgICAgICAgICAgYSBEZWNlbnRyYWxpemVkIElEZW50aWZpZXIgKERJRCkgdG8gbG9va3VwXG4qICBAcGFyYW0gICAge0Jvb2xlYW59ICAgICAgICAgICBhdXRoICAgICAgICAgICAgICAgUmVzdHJpY3QgcHVibGljIGtleXMgdG8gb25lcyBzcGVjaWZpY2FsbHkgbGlzdGVkIGluIHRoZSAnYXV0aGVudGljYXRpb24nIHNlY3Rpb24gb2YgRElEIGRvY3VtZW50XG4qICBAcmV0dXJuICAge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59ICAgICAgICAgICAgICAgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdpdGggYSByZXNwb25zZSBvYmplY3QgY29udGFpbmluZyBhbiBhcnJheSBvZiBhdXRoZW50aWNhdG9ycyBvciBpZiBub24gZXhpc3QgcmVqZWN0cyB3aXRoIGFuIGVycm9yXG4qL1xuXG5cbmZ1bmN0aW9uIF92ZXJpZnlKV1QoKSB7XG4gIF92ZXJpZnlKV1QgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKFxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoand0KSB7XG4gICAgdmFyIG9wdGlvbnMsXG4gICAgICAgIGF1ZCxcbiAgICAgICAgX2RlY29kZUpXVCxcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgaGVhZGVyLFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIF9yZWYyLFxuICAgICAgICBkb2MsXG4gICAgICAgIGF1dGhlbnRpY2F0b3JzLFxuICAgICAgICBpc3N1ZXIsXG4gICAgICAgIHNpZ25lcixcbiAgICAgICAgbm93LFxuICAgICAgICBfYXJnczIgPSBhcmd1bWVudHM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBvcHRpb25zID0gX2FyZ3MyLmxlbmd0aCA+IDEgJiYgX2FyZ3MyWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczJbMV0gOiB7fTtcbiAgICAgICAgICAgIGF1ZCA9IG9wdGlvbnMuYXVkaWVuY2UgPyBub3JtYWxpemVESUQob3B0aW9ucy5hdWRpZW5jZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfZGVjb2RlSldUID0gZGVjb2RlSldUKGp3dCksIHBheWxvYWQgPSBfZGVjb2RlSldULnBheWxvYWQsIGhlYWRlciA9IF9kZWNvZGVKV1QuaGVhZGVyLCBzaWduYXR1cmUgPSBfZGVjb2RlSldULnNpZ25hdHVyZSwgZGF0YSA9IF9kZWNvZGVKV1QuZGF0YTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlQXV0aGVudGljYXRvcihoZWFkZXIuYWxnLCBwYXlsb2FkLmlzcywgb3B0aW9ucy5hdXRoKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF9yZWYyID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBkb2MgPSBfcmVmMi5kb2M7XG4gICAgICAgICAgICBhdXRoZW50aWNhdG9ycyA9IF9yZWYyLmF1dGhlbnRpY2F0b3JzO1xuICAgICAgICAgICAgaXNzdWVyID0gX3JlZjIuaXNzdWVyO1xuICAgICAgICAgICAgc2lnbmVyID0gKDAsIF9WZXJpZmllckFsZ29yaXRobS5kZWZhdWx0KShoZWFkZXIuYWxnKShkYXRhLCBzaWduYXR1cmUsIGF1dGhlbnRpY2F0b3JzKTtcbiAgICAgICAgICAgIG5vdyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuXG4gICAgICAgICAgICBpZiAoIXNpZ25lcikge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDMxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEocGF5bG9hZC5pYXQgJiYgcGF5bG9hZC5pYXQgPiBub3cgKyBJQVRfU0tFVykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpXVCBub3QgdmFsaWQgeWV0IChpc3N1ZWQgaW4gdGhlIGZ1dHVyZSk6IGlhdDogXCIuY29uY2F0KHBheWxvYWQuaWF0LCBcIiA+IG5vdzogXCIpLmNvbmNhdChub3cpKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBpZiAoIShwYXlsb2FkLmV4cCAmJiBwYXlsb2FkLmV4cCA8PSBub3cgLSBJQVRfU0tFVykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpXVCBoYXMgZXhwaXJlZDogZXhwOiBcIi5jb25jYXQocGF5bG9hZC5leHAsIFwiIDwgbm93OiBcIikuY29uY2F0KG5vdykpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIGlmICghcGF5bG9hZC5hdWQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNESURPck1OSUQocGF5bG9hZC5hdWQpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXVkKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBhdWRpZW5jZSBpcyByZXF1aXJlZCBidXQgeW91ciBhcHAgYWRkcmVzcyBoYXMgbm90IGJlZW4gY29uZmlndXJlZCcpO1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIGlmICghKGF1ZCAhPT0gbm9ybWFsaXplRElEKHBheWxvYWQuYXVkKSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpXVCBhdWRpZW5jZSBkb2VzIG5vdCBtYXRjaCB5b3VyIERJRDogYXVkOiBcIi5jb25jYXQocGF5bG9hZC5hdWQsIFwiICE9PSB5b3VyczogXCIpLmNvbmNhdChhdWQpKTtcblxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI4O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2tVcmwpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSldUIGF1ZGllbmNlIG1hdGNoaW5nIHlvdXIgY2FsbGJhY2sgdXJsIGlzIHJlcXVpcmVkIGJ1dCBvbmUgd2FzblxcJ3QgcGFzc2VkIGluJyk7XG5cbiAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgaWYgKCEocGF5bG9hZC5hdWQgIT09IG9wdGlvbnMuY2FsbGJhY2tVcmwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJKV1QgYXVkaWVuY2UgZG9lcyBub3QgbWF0Y2ggdGhlIGNhbGxiYWNrIHVybDogYXVkOiBcIi5jb25jYXQocGF5bG9hZC5hdWQsIFwiICE9PSB1cmw6IFwiKS5jb25jYXQob3B0aW9ucy5jYWxsYmFja1VybCkpO1xuXG4gICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgICAgICAgIGlzc3VlcjogaXNzdWVyLFxuICAgICAgICAgICAgICBzaWduZXI6IHNpZ25lcixcbiAgICAgICAgICAgICAgand0OiBqd3RcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX3ZlcmlmeUpXVC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQXV0aGVudGljYXRvcihfeDQsIF94NSwgX3g2KSB7XG4gIHJldHVybiBfcmVzb2x2ZUF1dGhlbnRpY2F0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVBdXRoZW50aWNhdG9yKCkge1xuICBfcmVzb2x2ZUF1dGhlbnRpY2F0b3IgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKFxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoYWxnLCBtbmlkT3JEaWQsIGF1dGgpIHtcbiAgICB2YXIgdHlwZXMsIGlzc3VlciwgZG9jLCBhdXRoZW50aWNhdGlvbktleXMsIGF1dGhlbnRpY2F0b3JzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHR5cGVzID0gU1VQUE9SVEVEX1BVQkxJQ19LRVlfVFlQRVNbYWxnXTtcblxuICAgICAgICAgICAgaWYgKCEoIXR5cGVzIHx8IHR5cGVzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VwcG9ydGVkIHNpZ25hdHVyZSB0eXBlcyBmb3IgYWxnb3JpdGhtIFwiLmNvbmNhdChhbGcpKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGlzc3VlciA9IG5vcm1hbGl6ZURJRChtbmlkT3JEaWQpO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfZGlkUmVzb2x2ZXIuZGVmYXVsdCkoaXNzdWVyKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGRvYyA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXNvbHZlIERJRCBkb2N1bWVudCBmb3IgXCIuY29uY2F0KGlzc3VlcikpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgYXV0aGVudGljYXRpb25LZXlzID0gYXV0aCA/IChkb2MuYXV0aGVudGljYXRpb24gfHwgW10pLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICAgICAgdmFyIHB1YmxpY0tleSA9IF9yZWYzLnB1YmxpY0tleTtcbiAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0tleTtcbiAgICAgICAgICAgIH0pIDogdHJ1ZTtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0b3JzID0gKGRvYy5wdWJsaWNLZXkgfHwgW10pLmZpbHRlcihmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBfcmVmNC50eXBlLFxuICAgICAgICAgICAgICAgICAgaWQgPSBfcmVmNC5pZDtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzLmZpbmQoZnVuY3Rpb24gKHN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0ZWQgPT09IHR5cGUgJiYgKCFhdXRoIHx8IGF1dGhlbnRpY2F0aW9uS2V5cy5pbmRleE9mKGlkKSA+PSAwKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCEoYXV0aCAmJiAoIWF1dGhlbnRpY2F0b3JzIHx8IGF1dGhlbnRpY2F0b3JzLmxlbmd0aCA9PT0gMCkpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJESUQgZG9jdW1lbnQgZm9yIFwiLmNvbmNhdChpc3N1ZXIsIFwiIGRvZXMgbm90IGhhdmUgcHVibGljIGtleXMgc3VpdGFibGUgZm9yIGF1dGhlbnRpY2F0aW9uZyB1c2VyXCIpKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBpZiAoISghYXV0aGVudGljYXRvcnMgfHwgYXV0aGVudGljYXRvcnMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRElEIGRvY3VtZW50IGZvciBcIi5jb25jYXQoaXNzdWVyLCBcIiBkb2VzIG5vdCBoYXZlIHB1YmxpYyBrZXlzIGZvciBcIikuY29uY2F0KGFsZykpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgYXV0aGVudGljYXRvcnM6IGF1dGhlbnRpY2F0b3JzLFxuICAgICAgICAgICAgICBpc3N1ZXI6IGlzc3VlcixcbiAgICAgICAgICAgICAgZG9jOiBkb2NcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgfSkpO1xuICByZXR1cm4gX3Jlc29sdmVBdXRoZW50aWNhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBfZGVmYXVsdCA9IHtcbiAgZGVjb2RlSldUOiBkZWNvZGVKV1QsXG4gIGNyZWF0ZUpXVDogY3JlYXRlSldULFxuICB2ZXJpZnlKV1Q6IHZlcmlmeUpXVCxcbiAgcmVzb2x2ZUF1dGhlbnRpY2F0b3I6IHJlc29sdmVBdXRoZW50aWNhdG9yXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgT3JiaXREQiBBY2Nlc3MgQ29udHJvbGxlcnNcbiAqXG4gKiBBbnkgT3JiaXREQiBhY2Nlc3MgY29udHJvbGxlciBuZWVkcyB0byBkZWZpbmUgYW5kIGltcGxlbWVudFxuICogdGhlIG1ldGhvZHMgZGVmaW5lZCBieSB0aGUgaW50ZXJmYWNlIGhlcmUuXG4gKi9cbmNsYXNzIEFjY2Vzc0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKlxuICAgIEV2ZXJ5IEFDIG5lZWRzIHRvIGhhdmUgYSAnRmFjdG9yeScgbWV0aG9kXG4gICAgdGhhdCBjcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSBBY2Nlc3NDb250cm9sbGVyXG4gICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUgKG9yYml0ZGIsIG9wdGlvbnMpIHt9XG5cbiAgLyogUmV0dXJuIHRoZSB0eXBlIGZvciB0aGlzIGNvbnRyb2xsZXIgKi9cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCdzdGF0aWMgZ2V0IHR5cGUgKCknIG5lZWRzIHRvIGJlIGRlZmluZWQgaW4gdGhlIGluaGVyaXRpbmcgY2xhc3NgKVxuICB9XG5cbiAgLypcbiAgICBSZXR1cm4gdGhlIHR5cGUgZm9yIHRoaXMgY29udHJvbGxlclxuICAgIE5PVEUhIFRoaXMgaXMgdGhlIG9ubHkgcHJvcGVydHkgb2YgdGhlIGludGVyZmFjZSB0aGF0XG4gICAgc2hvdWxkbid0IGJlIG92ZXJyaWRkZW4gaW4gdGhlIGluaGVyaXRlZCBBY2Nlc3MgQ29udHJvbGxlclxuICAqL1xuICBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudHlwZVxuICB9XG5cbiAgLyogRWFjaCBBY2Nlc3MgQ29udHJvbGxlciBoYXMgc29tZSBhZGRyZXNzIHRvIGFuY2hvciB0byAqL1xuICBnZXQgYWRkcmVzcyAoKSB7fVxuXG4gIC8qXG4gICAgQ2FsbGVkIGJ5IHRoZSBkYXRhYmFzZXMgKHRoZSBsb2cpIHRvIHNlZSBpZiBlbnRyeSBzaG91bGRcbiAgICBiZSBhbGxvd2VkIGluIHRoZSBkYXRhYmFzZS4gUmV0dXJuIHRydWUgaWYgdGhlIGVudHJ5IGlzIGFsbG93ZWQsXG4gICAgZmFsc2UgaXMgbm90IGFsbG93ZWRcbiAgKi9cbiAgYXN5bmMgY2FuQXBwZW5kIChlbnRyeSwgaWRlbnRpdHlQcm92aWRlcikge31cblxuICAvKiBBZGQgYW5kIHJlbW92ZSBhY2Nlc3MgKi9cbiAgYXN5bmMgZ3JhbnQgKGFjY2VzcywgaWRlbnRpdHkpIHt9XG4gIGFzeW5jIHJldm9rZSAoYWNjZXNzLCBpZGVudGl0eSkge31cblxuICAvKiBBQyBjcmVhdGlvbiBhbmQgbG9hZGluZyAqL1xuICBhc3luYyBsb2FkIChhZGRyZXNzKSB7fVxuICAvKiBSZXR1cm5zIEFDIG1hbmlmZXN0IHBhcmFtZXRlcnMgb2JqZWN0ICovXG4gIGFzeW5jIHNhdmUgKCkge31cbiAgLyogQ2FsbGVkIHdoZW4gdGhlIGRhdGFiYXNlIGZvciB0aGlzIEFDIGdldHMgY2xvc2VkICovXG4gIGFzeW5jIGNsb3NlICgpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWNjZXNzQ29udHJvbGxlclxuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcFJlZHVjZSA9IHJlcXVpcmUoJ3AtcmVkdWNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGl0ZXJhYmxlLCBpdGVyYXRvcikgPT4ge1xuXHRjb25zdCByZXQgPSBbXTtcblxuXHRyZXR1cm4gcFJlZHVjZShpdGVyYWJsZSwgKGEsIGIsIGkpID0+IHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGl0ZXJhdG9yKGIsIGkpKS50aGVuKHZhbCA9PiB7XG5cdFx0XHRyZXQucHVzaCh2YWwpO1xuXHRcdH0pO1xuXHR9KS50aGVuKCgpID0+IHJldCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGlzVmFsaWRFdGhBZGRyZXNzID0gcmVxdWlyZSgnLi9pcy12YWxpZC1ldGgtYWRkcmVzcycpXG5jb25zdCBpbyA9IHJlcXVpcmUoJy4vaW8uanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW8sXG4gIGlzVmFsaWRFdGhBZGRyZXNzLFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qXG4gIEluZGV4XG5cbiAgSW5kZXggY29udGFpbnMgdGhlIHN0YXRlIG9mIGEgZGF0YXN0b3JlLCBpZS4gd2hhdCBkYXRhIHdlIGN1cnJlbnRseSBoYXZlLlxuXG4gIEluZGV4IHJlY2VpdmVzIGEgY2FsbCBmcm9tIGEgU3RvcmUgd2hlbiB0aGUgb3BlcmF0aW9ucyBsb2cgZm9yIHRoZSBTdG9yZVxuICB3YXMgdXBkYXRlZCwgaWUuIG5ldyBvcGVyYXRpb25zIHdlcmUgYWRkZWQuIEluIHVwZGF0ZUluZGV4LCB0aGUgSW5kZXhcbiAgaW1wbGVtZW50cyBpdHMgQ1JEVCBsb2dpYzogYWRkLCByZW1vdmUgb3IgdXBkYXRlIGl0ZW1zIGluIHRoZSBkYXRhXG4gIHN0cnVjdHVyZS4gRWFjaCBuZXcgb3BlcmF0aW9uIHJlY2VpdmVkIGZyb20gdGhlIG9wZXJhdGlvbnMgbG9nIGlzIGFwcGxpZWRcbiAgaW4gb3JkZXIgb250byB0aGUgY3VycmVudCBzdGF0ZSwgaWUuIGVhY2ggbmV3IG9wZXJhdGlvbiBjaGFuZ2VzIHRoZSBkYXRhXG4gIGFuZCB0aGUgc3RhdGUgY2hhbmdlcy5cblxuICBJbXBsZW1lbnRpbmcgZWFjaCBDUkRUIGFzIGFuIEluZGV4LCB3ZSBjYW4gaW1wbGVtZW50IGJvdGggb3BlcmF0aW9uLWJhc2VkXG4gIGFuZCBzdGF0ZS1iYXNlZCBDUkRUcyB3aXRoIHRoZSBzYW1lIGhpZ2hlciBsZXZlbCBhYnN0cmFjdGlvbnMuXG5cbiAgVG8gcmVhZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGF0YWJhc2UsIEluZGV4IHByb3ZpZGVzIGEgc2luZ2xlIHB1YmxpY1xuICBmdW5jdGlvbjogYGdldCgpYC4gSXQgaXMgdXAgdG8gdGhlIFN0b3JlIHRvIGRlY2lkZSB3aGF0IGtpbmQgb2YgcXVlcnlcbiAgY2FwYWJpbGl0aWVzIGl0IHByb3ZpZGVzIHRvIHRoZSBjb25zdW1lci5cblxuICBVc2FnZTpcbiAgYGBgamF2YXNjcmlwdFxuICBjb25zdCBJbmRleCA9IG5ldyBJbmRleCh1c2VySWQpXG4gIGBgYFxuKi9cblxuY2xhc3MgSW5kZXgge1xuICAvKlxuICAgIEBwYXJhbSBpZCAtIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoaXMgaW5kZXgsIGVnLiBhIHVzZXIgaWQgb3IgYSBoYXNoXG4gICovXG4gIGNvbnN0cnVjdG9yIChpZCkge1xuICAgIHRoaXMuaWQgPSBpZFxuICAgIHRoaXMuX2luZGV4ID0gW11cbiAgfVxuXG4gIC8qXG4gICAgUmV0dXJucyB0aGUgc3RhdGUgb2YgdGhlIGRhdGFzdG9yZSwgaWUuIG1vc3QgdXAtdG8tZGF0ZSBkYXRhXG4gICAgQHJldHVybiAtIGN1cnJlbnQgc3RhdGVcbiAgKi9cbiAgZ2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXhcbiAgfVxuXG4gIC8qXG4gICAgQXBwbGllcyBvcGVyYXRpb25zIHRvIHRoZSBJbmRleCBhbmQgdXBkYXRlcyB0aGUgc3RhdGVcbiAgICBAcGFyYW0gb3Bsb2cgLSB0aGUgc291cmNlIG9wZXJhdGlvbnMgbG9nIHRoYXQgY2FsbGVkIHVwZGF0ZUluZGV4XG4gICAgQHBhcmFtIGVudHJpZXMgLSBvcGVyYXRpb25zIHRoYXQgd2VyZSBhZGRlZCB0byB0aGUgbG9nXG4gICovXG4gIGFzeW5jIHVwZGF0ZUluZGV4IChvcGxvZywgZW50cmllcykge1xuICAgIHRoaXMuX2luZGV4ID0gb3Bsb2cudmFsdWVzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbmRleFxuIiwiY2xhc3MgUmVwbGljYXRpb25JbmZvIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucmVzZXQoKVxuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIHRoaXMucHJvZ3Jlc3MgPSAwXG4gICAgdGhpcy5tYXggPSAwXG4gICAgdGhpcy5idWZmZXJlZCA9IDBcbiAgICB0aGlzLnF1ZXVlZCA9IDBcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcGxpY2F0aW9uSW5mb1xuIiwiY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBwTWFwID0gcmVxdWlyZSgncC1tYXAnKVxuY29uc3QgTG9nID0gcmVxdWlyZSgnaXBmcy1sb2cnKVxuXG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCdsb2dwbGVhc2UnKVxuY29uc3QgbG9nZ2VyID0gTG9nZ2VyLmNyZWF0ZSgncmVwbGljYXRvcicsIHsgY29sb3I6IExvZ2dlci5Db2xvcnMuQ3lhbiB9KVxuTG9nZ2VyLnNldExvZ0xldmVsKCdFUlJPUicpXG5cbmNvbnN0IGdldE5leHQgPSBlID0+IGUubmV4dFxuY29uc3QgZmxhdE1hcCA9IChyZXMsIHZhbCkgPT4gcmVzLmNvbmNhdCh2YWwpXG5jb25zdCBub3ROdWxsID0gZW50cnkgPT4gZW50cnkgIT09IG51bGwgJiYgZW50cnkgIT09IHVuZGVmaW5lZFxuY29uc3QgdW5pcXVlVmFsdWVzID0gKHJlcywgdmFsKSA9PiB7XG4gIHJlc1t2YWxdID0gdmFsXG4gIHJldHVybiByZXNcbn1cblxuY29uc3QgYmF0Y2hTaXplID0gMVxuXG5jbGFzcyBSZXBsaWNhdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKHN0b3JlLCBjb25jdXJyZW5jeSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9zdG9yZSA9IHN0b3JlXG4gICAgdGhpcy5fZmV0Y2hpbmcgPSB7fVxuICAgIHRoaXMuX3N0YXRzID0ge1xuICAgICAgdGFza3NSZXF1ZXN0ZWQ6IDAsXG4gICAgICB0YXNrc1N0YXJ0ZWQ6IDAsXG4gICAgICB0YXNrc1Byb2Nlc3NlZDogMFxuICAgIH1cbiAgICB0aGlzLl9idWZmZXIgPSBbXVxuXG4gICAgdGhpcy5fY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeSB8fCAxMjhcbiAgICB0aGlzLl9xdWV1ZSA9IHt9XG4gICAgdGhpcy5fcSA9IG5ldyBTZXQoKVxuXG4gICAgLy8gRmx1c2ggdGhlIHF1ZXVlIGFzIGFuIGVtZXJnZW5jeSBzd2l0Y2hcbiAgICB0aGlzLl9mbHVzaFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMudGFza3NSdW5uaW5nID09PSAwICYmIE9iamVjdC5rZXlzKHRoaXMuX3F1ZXVlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdIYWQgdG8gZmx1c2ggdGhlIHF1ZXVlIScsIE9iamVjdC5rZXlzKHRoaXMuX3F1ZXVlKS5sZW5ndGgsICdpdGVtcyBpbiB0aGUgcXVldWUsICcsIHRoaXMudGFza3NSZXF1ZXN0ZWQsIHRoaXMudGFza3NGaW5pc2hlZCwgJyB0YXNrcyByZXF1ZXN0ZWQvZmluaXNoZWQnKVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX3Byb2Nlc3NRdWV1ZSgpLCAwKVxuICAgICAgfVxuICAgIH0sIDMwMDApXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRhc2tzIHN0YXJ0ZWQgZHVyaW5nIHRoZSBsaWZlIHRpbWVcbiAgICogQHJldHVybiB7W0ludGVnZXJdfSBbTnVtYmVyIG9mIHRhc2tzIHN0YXJ0ZWRdXG4gICAqL1xuICBnZXQgdGFza3NSZXF1ZXN0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0cy50YXNrc1JlcXVlc3RlZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0YXNrcyBzdGFydGVkIGR1cmluZyB0aGUgbGlmZSB0aW1lXG4gICAqIEByZXR1cm4ge1tJbnRlZ2VyXX0gW051bWJlciBvZiB0YXNrcyBydW5uaW5nXVxuICAgKi9cbiAgZ2V0IHRhc2tzU3RhcnRlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRzLnRhc2tzU3RhcnRlZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0YXNrcyBydW5uaW5nIGN1cnJlbnRseVxuICAgKiBAcmV0dXJuIHtbSW50ZWdlcl19IFtOdW1iZXIgb2YgdGFza3MgcnVubmluZ11cbiAgICovXG4gIGdldCB0YXNrc1J1bm5pbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0cy50YXNrc1N0YXJ0ZWQgLSB0aGlzLl9zdGF0cy50YXNrc1Byb2Nlc3NlZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0YXNrcyBjdXJyZW50bHkgcXVldWVkXG4gICAqIEByZXR1cm4ge1tJbnRlZ2VyXX0gW051bWJlciBvZiB0YXNrcyBxdWV1ZWRdXG4gICAqL1xuICBnZXQgdGFza3NRdWV1ZWQgKCkge1xuICAgIHJldHVybiBNYXRoLm1heChPYmplY3Qua2V5cyh0aGlzLl9xdWV1ZSkubGVuZ3RoIC0gdGhpcy50YXNrc1J1bm5pbmcsIDApXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRhc2tzIGZpbmlzaGVkIGR1cmluZyB0aGUgbGlmZSB0aW1lXG4gICAqIEByZXR1cm4ge1tJbnRlZ2VyXX0gW051bWJlciBvZiB0YXNrcyBmaW5pc2hlZF1cbiAgICovXG4gIGdldCB0YXNrc0ZpbmlzaGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHMudGFza3NQcm9jZXNzZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoYXNoZXMgY3VycmVudGx5IHF1ZXVlZFxuICAgKiBAcmV0dXJuIHtbQXJyYXk8U3RyaW5nPl19IFtRdWV1ZWQgaGFzaGVzXVxuICAgKi9cbiAgZ2V0UXVldWUgKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX3F1ZXVlKVxuICB9XG5cbiAgLypcbiAgICBQcm9jZXNzIG5ldyBoZWFkcy5cbiAgICovXG4gIGxvYWQgKGVudHJpZXMpIHtcbiAgICBjb25zdCBub3RLbm93biA9IGVudHJ5ID0+IHtcbiAgICAgIGNvbnN0IGhhc2ggPSBlbnRyeS5oYXNoIHx8IGVudHJ5XG4gICAgICByZXR1cm4gIXRoaXMuX3N0b3JlLl9vcGxvZy5oYXMoaGFzaCkgJiYgIXRoaXMuX2ZldGNoaW5nW2hhc2hdICYmICF0aGlzLl9xdWV1ZVtoYXNoXVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBlbnRyaWVzXG4gICAgICAgIC5maWx0ZXIobm90TnVsbClcbiAgICAgICAgLmZpbHRlcihub3RLbm93bilcbiAgICAgICAgLmZvckVhY2godGhpcy5fYWRkVG9RdWV1ZS5iaW5kKHRoaXMpKVxuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX3Byb2Nlc3NRdWV1ZSgpLCAwKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICB9XG4gIH1cblxuICBzdG9wICgpIHtcbiAgICAvLyBDbGVhcnMgdGhlIHF1ZXVlIGZsdXNoZXJcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2ZsdXNoVGltZXIpXG4gIH1cblxuICBfYWRkVG9RdWV1ZSAoZW50cnkpIHtcbiAgICBjb25zdCBoYXNoID0gZW50cnkuaGFzaCB8fCBlbnRyeVxuICAgIHRoaXMuX3N0YXRzLnRhc2tzUmVxdWVzdGVkICs9IDFcbiAgICB0aGlzLl9xdWV1ZVtoYXNoXSA9IGVudHJ5XG4gIH1cblxuICBhc3luYyBfcHJvY2Vzc1F1ZXVlICgpIHtcbiAgICBpZiAodGhpcy50YXNrc1J1bm5pbmcgPCB0aGlzLl9jb25jdXJyZW5jeSkge1xuICAgICAgY29uc3QgY2FwYWNpdHkgPSB0aGlzLl9jb25jdXJyZW5jeSAtIHRoaXMudGFza3NSdW5uaW5nXG4gICAgICBjb25zdCBpdGVtcyA9IE9iamVjdC52YWx1ZXModGhpcy5fcXVldWUpLnNsaWNlKDAsIGNhcGFjaXR5KS5maWx0ZXIobm90TnVsbClcbiAgICAgIGl0ZW1zLmZvckVhY2goZW50cnkgPT4gZGVsZXRlIHRoaXMuX3F1ZXVlW2VudHJ5Lmhhc2ggfHwgZW50cnldKVxuXG4gICAgICBjb25zdCBmbGF0dGVuQW5kR2V0VW5pcXVlcyA9IChuZXh0cykgPT4gbmV4dHMucmVkdWNlKGZsYXRNYXAsIFtdKS5yZWR1Y2UodW5pcXVlVmFsdWVzLCB7fSlcbiAgICAgIGNvbnN0IHByb2Nlc3NWYWx1ZXMgPSAobmV4dHMpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhuZXh0cykuZmlsdGVyKG5vdE51bGwpXG5cbiAgICAgICAgaWYgKChpdGVtcy5sZW5ndGggPiAwICYmIHRoaXMuX2J1ZmZlci5sZW5ndGggPiAwKSB8fFxuICAgICAgICAodGhpcy50YXNrc1J1bm5pbmcgPT09IDAgJiYgdGhpcy5fYnVmZmVyLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgY29uc3QgbG9ncyA9IHRoaXMuX2J1ZmZlci5zbGljZSgpXG4gICAgICAgICAgdGhpcy5fYnVmZmVyID0gW11cbiAgICAgICAgICB0aGlzLmVtaXQoJ2xvYWQuZW5kJywgbG9ncylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMubG9hZCh2YWx1ZXMpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBNYXAoaXRlbXMsIGUgPT4gdGhpcy5fcHJvY2Vzc09uZShlKSlcbiAgICAgICAgLnRoZW4oZmxhdHRlbkFuZEdldFVuaXF1ZXMpXG4gICAgICAgIC50aGVuKHByb2Nlc3NWYWx1ZXMpXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX3Byb2Nlc3NPbmUgKGVudHJ5KSB7XG4gICAgY29uc3QgaGFzaCA9IGVudHJ5Lmhhc2ggfHwgZW50cnlcblxuICAgIGlmICh0aGlzLl9zdG9yZS5fb3Bsb2cuaGFzKGhhc2gpIHx8IHRoaXMuX2ZldGNoaW5nW2hhc2hdKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9mZXRjaGluZ1toYXNoXSA9IGhhc2hcbiAgICB0aGlzLmVtaXQoJ2xvYWQuYWRkZWQnLCBlbnRyeSlcbiAgICB0aGlzLl9zdGF0cy50YXNrc1N0YXJ0ZWQgKz0gMVxuXG4gICAgY29uc3QgZXhjbHVkZSA9IFtdXG4gICAgY29uc3QgbG9nID0gYXdhaXQgTG9nLmZyb21FbnRyeUhhc2godGhpcy5fc3RvcmUuX2lwZnMsIHRoaXMuX3N0b3JlLmlkZW50aXR5LCBoYXNoLCB7IGxvZ0lkOiB0aGlzLl9zdG9yZS5fb3Bsb2cuaWQsIGFjY2VzczogdGhpcy5fc3RvcmUuYWNjZXNzLCBsZW5ndGg6IGJhdGNoU2l6ZSwgZXhjbHVkZSB9KVxuICAgIHRoaXMuX2J1ZmZlci5wdXNoKGxvZylcblxuICAgIGNvbnN0IGxhdGVzdCA9IGxvZy52YWx1ZXNbMF1cbiAgICBkZWxldGUgdGhpcy5fcXVldWVbaGFzaF1cblxuICAgIC8vIE1hcmsgdGhpcyB0YXNrIGFzIHByb2Nlc3NlZFxuICAgIHRoaXMuX3N0YXRzLnRhc2tzUHJvY2Vzc2VkICs9IDFcblxuICAgIC8vIE5vdGlmeSBzdWJzY3JpYmVycyB0aGF0IHdlIG1hZGUgcHJvZ3Jlc3NcbiAgICB0aGlzLmVtaXQoJ2xvYWQucHJvZ3Jlc3MnLCB0aGlzLl9pZCwgaGFzaCwgbGF0ZXN0LCBudWxsLCB0aGlzLl9idWZmZXIubGVuZ3RoKVxuXG4gICAgLy8gUmV0dXJuIGFsbCBuZXh0IHBvaW50ZXJzXG4gICAgcmV0dXJuIGxvZy52YWx1ZXMubWFwKGdldE5leHQpLnJlZHVjZShmbGF0TWFwLCBbXSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcGxpY2F0b3JcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBSZWR1Y2UgPSByZXF1aXJlKCdwLXJlZHVjZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChpdGVyYWJsZSwgaXRlcmF0b3IpID0+IHBSZWR1Y2UoaXRlcmFibGUsIChhLCBiLCBpKSA9PiBpdGVyYXRvcihiLCBpKSkudGhlbigoKSA9PiBpdGVyYWJsZSk7XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5kZWVwRXF1YWwgPSAoYSwgYikgPT4ge1xuICBjb25zdCBwcm9wc0EgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhKVxuICBjb25zdCBwcm9wc0IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiKVxuXG4gIGlmKHByb3BzQS5sZW5ndGggIT09IHByb3BzQi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgZm9yKGxldCBpID0gMDsgaSA8IHByb3BzQS5sZW5ndGg7IGkgKyspIHtcbiAgICBjb25zdCBwcm9wID0gcHJvcHNBW2ldXG4gICAgaWYoYVtwcm9wXSAhPT0gYltwcm9wXSlcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuY2xhc3MgT3BlcmF0aW9uVHVwbGUzIHtcbiAgY29uc3RydWN0b3IgKHZhbHVlLCBhZGRlZCwgcmVtb3ZlZCkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMuYWRkZWQgPSBuZXcgU2V0KGFkZGVkKVxuICAgIHRoaXMucmVtb3ZlZCA9IG5ldyBTZXQocmVtb3ZlZClcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGUgKHZhbHVlLCBhZGRlZCwgcmVtb3ZlZCkge1xuICAgIHJldHVybiBuZXcgT3BlcmF0aW9uVHVwbGUzKHZhbHVlLCBhZGRlZCwgcmVtb3ZlZClcbiAgfVxuXG4gIHN0YXRpYyBmcm9tIChqc29uKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvblR1cGxlMy5jcmVhdGUoanNvbi52YWx1ZSwganNvbi5hZGRlZCwganNvbi5yZW1vdmVkKVxuICB9XG59XG5cbmV4cG9ydHMuT3BlcmF0aW9uVHVwbGUzID0gT3BlcmF0aW9uVHVwbGUzXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSAnaXBmcy1wdWJzdWItZGlyZWN0LWNoYW5uZWwvdjEnXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qgd2FpdEZvclBlZXJzID0gYXN5bmMgKGlwZnMsIHBlZXJzVG9XYWl0LCB0b3BpYykgPT4ge1xuICBjb25zdCBjaGVja1BlZXJzID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHBlZXJzID0gYXdhaXQgaXBmcy5wdWJzdWIucGVlcnModG9waWMpXG4gICAgY29uc3QgaGFzQWxsUGVlcnMgPSBwZWVyc1RvV2FpdC5tYXAoKGUpID0+IHBlZXJzLmluY2x1ZGVzKGUpKS5maWx0ZXIoKGUpID0+IGUgPT09IGZhbHNlKS5sZW5ndGggPT09IDBcbiAgICByZXR1cm4gaGFzQWxsUGVlcnNcbiAgfVxuXG4gIGlmIChhd2FpdCBjaGVja1BlZXJzKCkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoYXdhaXQgY2hlY2tQZWVycygpKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbClcbiAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSlcbiAgICAgIH1cbiAgICB9LCAxMDApXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FpdEZvclBlZXJzXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZ2V0UGVlcklEID0gYXN5bmMgKGlwZnMpID0+IHtcbiAgY29uc3QgcGVlckluZm8gPSBhd2FpdCBpcGZzLmlkKClcbiAgcmV0dXJuIHBlZXJJbmZvLmlkXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UGVlcklEXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSAoX21lc3NhZ2UpID0+IHtcbiAgbGV0IG1lc3NhZ2UgPSBfbWVzc2FnZVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlKSkge1xuICAgIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlKVxuICB9XG4gIHJldHVybiBtZXNzYWdlXG59XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy50ZXN0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gdGVzdCAoaW1wbCkge1xuICAgIHRyeSB7XG4gICAgICBpbXBsLmNtcChrZXksIDApXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuYmluYXJ5S2V5cyA9IGV4cG9ydHMudGVzdChuZXcgVWludDhBcnJheSgwKSlcbmV4cG9ydHMuYXJyYXlLZXlzID0gZXhwb3J0cy50ZXN0KFsxXSlcbiIsIi8qIGdsb2JhbCBJREJLZXlSYW5nZSAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEFic3RyYWN0SXRlcmF0b3IgPSByZXF1aXJlKCdhYnN0cmFjdC1sZXZlbGRvd24nKS5BYnN0cmFjdEl0ZXJhdG9yXG52YXIgbHRndCA9IHJlcXVpcmUoJ2x0Z3QnKVxudmFyIG1peGVkVG9CdWZmZXIgPSByZXF1aXJlKCcuL3V0aWwvbWl4ZWQtdG8tYnVmZmVyJylcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCcuL3V0aWwvaW1tZWRpYXRlJylcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cblxubW9kdWxlLmV4cG9ydHMgPSBJdGVyYXRvclxuXG5mdW5jdGlvbiBJdGVyYXRvciAoZGIsIGxvY2F0aW9uLCBvcHRpb25zKSB7XG4gIEFic3RyYWN0SXRlcmF0b3IuY2FsbCh0aGlzLCBkYilcblxuICB0aGlzLl9saW1pdCA9IG9wdGlvbnMubGltaXRcbiAgdGhpcy5fY291bnQgPSAwXG4gIHRoaXMuX2NhbGxiYWNrID0gbnVsbFxuICB0aGlzLl9jYWNoZSA9IFtdXG4gIHRoaXMuX2NvbXBsZXRlZCA9IGZhbHNlXG4gIHRoaXMuX2Fib3J0ZWQgPSBmYWxzZVxuICB0aGlzLl9lcnJvciA9IG51bGxcbiAgdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsXG5cbiAgdGhpcy5fa2V5QXNCdWZmZXIgPSBvcHRpb25zLmtleUFzQnVmZmVyXG4gIHRoaXMuX3ZhbHVlQXNCdWZmZXIgPSBvcHRpb25zLnZhbHVlQXNCdWZmZXJcblxuICBpZiAodGhpcy5fbGltaXQgPT09IDApIHtcbiAgICB0aGlzLl9jb21wbGV0ZWQgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH1cblxuICB0cnkge1xuICAgIHZhciBrZXlSYW5nZSA9IHRoaXMuY3JlYXRlS2V5UmFuZ2Uob3B0aW9ucylcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRoZSBsb3dlciBrZXkgaXMgZ3JlYXRlciB0aGFuIHRoZSB1cHBlciBrZXkuXG4gICAgLy8gSW5kZXhlZERCIHRocm93cyBhbiBlcnJvciwgYnV0IHdlJ2xsIGp1c3QgcmV0dXJuIDAgcmVzdWx0cy5cbiAgICB0aGlzLl9jb21wbGV0ZWQgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLmNyZWF0ZUl0ZXJhdG9yKGxvY2F0aW9uLCBrZXlSYW5nZSwgb3B0aW9ucy5yZXZlcnNlKVxufVxuXG5pbmhlcml0cyhJdGVyYXRvciwgQWJzdHJhY3RJdGVyYXRvcilcblxuSXRlcmF0b3IucHJvdG90eXBlLmNyZWF0ZUtleVJhbmdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGxvd2VyID0gbHRndC5sb3dlckJvdW5kKG9wdGlvbnMpXG4gIHZhciB1cHBlciA9IGx0Z3QudXBwZXJCb3VuZChvcHRpb25zKVxuICB2YXIgbG93ZXJPcGVuID0gbHRndC5sb3dlckJvdW5kRXhjbHVzaXZlKG9wdGlvbnMpXG4gIHZhciB1cHBlck9wZW4gPSBsdGd0LnVwcGVyQm91bmRFeGNsdXNpdmUob3B0aW9ucylcblxuICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCAmJiB1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIElEQktleVJhbmdlLmJvdW5kKGxvd2VyLCB1cHBlciwgbG93ZXJPcGVuLCB1cHBlck9wZW4pXG4gIH0gZWxzZSBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBJREJLZXlSYW5nZS5sb3dlckJvdW5kKGxvd2VyLCBsb3dlck9wZW4pXG4gIH0gZWxzZSBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBJREJLZXlSYW5nZS51cHBlckJvdW5kKHVwcGVyLCB1cHBlck9wZW4pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUuY3JlYXRlSXRlcmF0b3IgPSBmdW5jdGlvbiAobG9jYXRpb24sIGtleVJhbmdlLCByZXZlcnNlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgdHJhbnNhY3Rpb24gPSB0aGlzLmRiLmRiLnRyYW5zYWN0aW9uKFtsb2NhdGlvbl0sICdyZWFkb25seScpXG4gIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKGxvY2F0aW9uKVxuICB2YXIgcmVxID0gc3RvcmUub3BlbkN1cnNvcihrZXlSYW5nZSwgcmV2ZXJzZSA/ICdwcmV2JyA6ICduZXh0JylcblxuICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgdmFyIGN1cnNvciA9IGV2LnRhcmdldC5yZXN1bHRcbiAgICBpZiAoY3Vyc29yKSBzZWxmLm9uSXRlbShjdXJzb3IpXG4gIH1cblxuICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uXG5cbiAgLy8gSWYgYW4gZXJyb3Igb2NjdXJzIChvbiB0aGUgcmVxdWVzdCksIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGFib3J0LlxuICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25BYm9ydChzZWxmLl90cmFuc2FjdGlvbi5lcnJvciB8fCBuZXcgRXJyb3IoJ2Fib3J0ZWQgYnkgdXNlcicpKVxuICB9XG5cbiAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uQ29tcGxldGUoKVxuICB9XG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5vbkl0ZW0gPSBmdW5jdGlvbiAoY3Vyc29yKSB7XG4gIHRoaXMuX2NhY2hlLnB1c2goY3Vyc29yLmtleSwgY3Vyc29yLnZhbHVlKVxuXG4gIGlmICh0aGlzLl9saW1pdCA8PSAwIHx8ICsrdGhpcy5fY291bnQgPCB0aGlzLl9saW1pdCkge1xuICAgIGN1cnNvclsnY29udGludWUnXSgpXG4gIH1cblxuICB0aGlzLm1heWJlTmV4dCgpXG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5vbkFib3J0ID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLl9hYm9ydGVkID0gdHJ1ZVxuICB0aGlzLl9lcnJvciA9IGVyclxuICB0aGlzLm1heWJlTmV4dCgpXG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5vbkNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9jb21wbGV0ZWQgPSB0cnVlXG4gIHRoaXMubWF5YmVOZXh0KClcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLm1heWJlTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2NhbGxiYWNrKSB7XG4gICAgdGhpcy5fbmV4dCh0aGlzLl9jYWxsYmFjaylcbiAgICB0aGlzLl9jYWxsYmFjayA9IG51bGxcbiAgfVxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICAvLyBUaGUgZXJyb3Igc2hvdWxkIGJlIHBpY2tlZCB1cCBieSBlaXRoZXIgbmV4dCgpIG9yIGVuZCgpLlxuICAgIHZhciBlcnIgPSB0aGlzLl9lcnJvclxuICAgIHRoaXMuX2Vycm9yID0gbnVsbFxuXG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKGVycilcbiAgICB9KVxuICB9IGVsc2UgaWYgKHRoaXMuX2NhY2hlLmxlbmd0aCA+IDApIHtcbiAgICB2YXIga2V5ID0gdGhpcy5fY2FjaGUuc2hpZnQoKVxuICAgIHZhciB2YWx1ZSA9IHRoaXMuX2NhY2hlLnNoaWZ0KClcblxuICAgIGlmICh0aGlzLl9rZXlBc0J1ZmZlcikga2V5ID0gbWl4ZWRUb0J1ZmZlcihrZXkpXG4gICAgaWYgKHRoaXMuX3ZhbHVlQXNCdWZmZXIpIHZhbHVlID0gbWl4ZWRUb0J1ZmZlcih2YWx1ZSlcblxuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBrZXksIHZhbHVlKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAodGhpcy5fY29tcGxldGVkKSB7XG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2tcbiAgfVxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBpZiAodGhpcy5fYWJvcnRlZCB8fCB0aGlzLl9jb21wbGV0ZWQpIHtcbiAgICB2YXIgZXJyID0gdGhpcy5fZXJyb3JcblxuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfSlcblxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gRG9uJ3QgYWR2YW5jZSB0aGUgY3Vyc29yIGFueW1vcmUsIGFuZCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBjb21wbGV0ZVxuICAvLyBvbiBpdHMgb3duIGluIHRoZSBuZXh0IHRpY2suIFRoaXMgYXBwcm9hY2ggaXMgbXVjaCBjbGVhbmVyIHRoYW4gY2FsbGluZ1xuICAvLyB0cmFuc2FjdGlvbi5hYm9ydCgpIHdpdGggaXRzIHVucHJlZGljdGFibGUgZXZlbnQgb3JkZXIuXG4gIHRoaXMub25JdGVtID0gbm9vcFxuICB0aGlzLm9uQWJvcnQgPSBjYWxsYmFja1xuICB0aGlzLm9uQ29tcGxldGUgPSBjYWxsYmFja1xufVxuIiwiZXhwb3J0cy5BYnN0cmFjdExldmVsRE9XTiA9IHJlcXVpcmUoJy4vYWJzdHJhY3QtbGV2ZWxkb3duJylcbmV4cG9ydHMuQWJzdHJhY3RJdGVyYXRvciA9IHJlcXVpcmUoJy4vYWJzdHJhY3QtaXRlcmF0b3InKVxuZXhwb3J0cy5BYnN0cmFjdENoYWluZWRCYXRjaCA9IHJlcXVpcmUoJy4vYWJzdHJhY3QtY2hhaW5lZC1iYXRjaCcpXG4iLCIndXNlIHN0cmljdCdcblxudmFyIHRvQnVmZmVyID0gcmVxdWlyZSgndHlwZWRhcnJheS10by1idWZmZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSByZXR1cm4gdG9CdWZmZXIodmFsdWUpXG4gIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSlcbiAgZWxzZSByZXR1cm4gQnVmZmVyLmZyb20oU3RyaW5nKHZhbHVlKSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnaW1tZWRpYXRlJylcbiIsInZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IExSVVxuXG5mdW5jdGlvbiBMUlUgKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExSVSkpIHJldHVybiBuZXcgTFJVKG9wdHMpXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ251bWJlcicpIG9wdHMgPSB7bWF4OiBvcHRzfVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBldmVudHMuRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcbiAgdGhpcy5jYWNoZSA9IHt9XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGxcbiAgdGhpcy5sZW5ndGggPSAwXG4gIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMFxuICB0aGlzLm1heEFnZSA9IG9wdHMubWF4QWdlIHx8IDBcbn1cblxuaW5oZXJpdHMoTFJVLCBldmVudHMuRXZlbnRFbWl0dGVyKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVLnByb3RvdHlwZSwgJ2tleXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jYWNoZSkgfVxufSlcblxuTFJVLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jYWNoZSA9IHt9XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGxcbiAgdGhpcy5sZW5ndGggPSAwXG59XG5cbkxSVS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIGtleSA9ICcnICsga2V5XG4gIGlmICghdGhpcy5jYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm5cblxuICB2YXIgZWxlbWVudCA9IHRoaXMuY2FjaGVba2V5XVxuICBkZWxldGUgdGhpcy5jYWNoZVtrZXldXG4gIHRoaXMuX3VubGluayhrZXksIGVsZW1lbnQucHJldiwgZWxlbWVudC5uZXh0KVxuICByZXR1cm4gZWxlbWVudC52YWx1ZVxufVxuXG5MUlUucHJvdG90eXBlLl91bmxpbmsgPSBmdW5jdGlvbiAoa2V5LCBwcmV2LCBuZXh0KSB7XG4gIHRoaXMubGVuZ3RoLS1cblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuaGVhZCA9PT0ga2V5KSB7XG4gICAgICB0aGlzLmhlYWQgPSBwcmV2XG4gICAgICB0aGlzLmNhY2hlW3RoaXMuaGVhZF0ubmV4dCA9IG51bGxcbiAgICB9IGVsc2UgaWYgKHRoaXMudGFpbCA9PT0ga2V5KSB7XG4gICAgICB0aGlzLnRhaWwgPSBuZXh0XG4gICAgICB0aGlzLmNhY2hlW3RoaXMudGFpbF0ucHJldiA9IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYWNoZVtwcmV2XS5uZXh0ID0gbmV4dFxuICAgICAgdGhpcy5jYWNoZVtuZXh0XS5wcmV2ID0gcHJldlxuICAgIH1cbiAgfVxufVxuXG5MUlUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICghdGhpcy5jYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm5cblxuICB2YXIgZWxlbWVudCA9IHRoaXMuY2FjaGVba2V5XVxuXG4gIGlmICghdGhpcy5fY2hlY2tBZ2Uoa2V5LCBlbGVtZW50KSkgcmV0dXJuXG4gIHJldHVybiBlbGVtZW50LnZhbHVlXG59XG5cbkxSVS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSBrZXkgPSAnJyArIGtleVxuXG4gIHZhciBlbGVtZW50XG5cbiAgaWYgKHRoaXMuY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIGVsZW1lbnQgPSB0aGlzLmNhY2hlW2tleV1cbiAgICBlbGVtZW50LnZhbHVlID0gdmFsdWVcbiAgICBpZiAodGhpcy5tYXhBZ2UpIGVsZW1lbnQubW9kaWZpZWQgPSBEYXRlLm5vdygpXG5cbiAgICAvLyBJZiBpdCdzIGFscmVhZHkgdGhlIGhlYWQsIHRoZXJlJ3Mgbm90aGluZyBtb3JlIHRvIGRvOlxuICAgIGlmIChrZXkgPT09IHRoaXMuaGVhZCkgcmV0dXJuIHZhbHVlXG4gICAgdGhpcy5fdW5saW5rKGtleSwgZWxlbWVudC5wcmV2LCBlbGVtZW50Lm5leHQpXG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudCA9IHt2YWx1ZTogdmFsdWUsIG1vZGlmaWVkOiAwLCBuZXh0OiBudWxsLCBwcmV2OiBudWxsfVxuICAgIGlmICh0aGlzLm1heEFnZSkgZWxlbWVudC5tb2RpZmllZCA9IERhdGUubm93KClcbiAgICB0aGlzLmNhY2hlW2tleV0gPSBlbGVtZW50XG5cbiAgICAvLyBFdmljdGlvbiBpcyBvbmx5IHBvc3NpYmxlIGlmIHRoZSBrZXkgZGlkbid0IGFscmVhZHkgZXhpc3Q6XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSB0aGlzLm1heCkgdGhpcy5ldmljdCgpXG4gIH1cblxuICB0aGlzLmxlbmd0aCsrXG4gIGVsZW1lbnQubmV4dCA9IG51bGxcbiAgZWxlbWVudC5wcmV2ID0gdGhpcy5oZWFkXG5cbiAgaWYgKHRoaXMuaGVhZCkgdGhpcy5jYWNoZVt0aGlzLmhlYWRdLm5leHQgPSBrZXlcbiAgdGhpcy5oZWFkID0ga2V5XG5cbiAgaWYgKCF0aGlzLnRhaWwpIHRoaXMudGFpbCA9IGtleVxuICByZXR1cm4gdmFsdWVcbn1cblxuTFJVLnByb3RvdHlwZS5fY2hlY2tBZ2UgPSBmdW5jdGlvbiAoa2V5LCBlbGVtZW50KSB7XG4gIGlmICh0aGlzLm1heEFnZSAmJiAoRGF0ZS5ub3coKSAtIGVsZW1lbnQubW9kaWZpZWQpID4gdGhpcy5tYXhBZ2UpIHtcbiAgICB0aGlzLnJlbW92ZShrZXkpXG4gICAgdGhpcy5lbWl0KCdldmljdCcsIHtrZXk6IGtleSwgdmFsdWU6IGVsZW1lbnQudmFsdWV9KVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbkxSVS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIGtleSA9ICcnICsga2V5XG4gIGlmICghdGhpcy5jYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm5cblxuICB2YXIgZWxlbWVudCA9IHRoaXMuY2FjaGVba2V5XVxuXG4gIGlmICghdGhpcy5fY2hlY2tBZ2Uoa2V5LCBlbGVtZW50KSkgcmV0dXJuXG5cbiAgaWYgKHRoaXMuaGVhZCAhPT0ga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gdGhpcy50YWlsKSB7XG4gICAgICB0aGlzLnRhaWwgPSBlbGVtZW50Lm5leHRcbiAgICAgIHRoaXMuY2FjaGVbdGhpcy50YWlsXS5wcmV2ID0gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXQgcHJldi5uZXh0IC0+IGVsZW1lbnQubmV4dDpcbiAgICAgIHRoaXMuY2FjaGVbZWxlbWVudC5wcmV2XS5uZXh0ID0gZWxlbWVudC5uZXh0XG4gICAgfVxuXG4gICAgLy8gU2V0IGVsZW1lbnQubmV4dC5wcmV2IC0+IGVsZW1lbnQucHJldjpcbiAgICB0aGlzLmNhY2hlW2VsZW1lbnQubmV4dF0ucHJldiA9IGVsZW1lbnQucHJldlxuXG4gICAgLy8gRWxlbWVudCBpcyB0aGUgbmV3IGhlYWRcbiAgICB0aGlzLmNhY2hlW3RoaXMuaGVhZF0ubmV4dCA9IGtleVxuICAgIGVsZW1lbnQucHJldiA9IHRoaXMuaGVhZFxuICAgIGVsZW1lbnQubmV4dCA9IG51bGxcbiAgICB0aGlzLmhlYWQgPSBrZXlcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50LnZhbHVlXG59XG5cbkxSVS5wcm90b3R5cGUuZXZpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy50YWlsKSByZXR1cm5cbiAgdmFyIGtleSA9IHRoaXMudGFpbFxuICB2YXIgdmFsdWUgPSB0aGlzLnJlbW92ZSh0aGlzLnRhaWwpXG4gIHRoaXMuZW1pdCgnZXZpY3QnLCB7a2V5OiBrZXksIHZhbHVlOiB2YWx1ZX0pXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdmVyaWZpZXJzID0ge1xuICAndjAnOiByZXF1aXJlKCcuL3ZlcmlmaWVydjAnKSxcbiAgJ3YxJzogcmVxdWlyZSgnLi92ZXJpZmllcnYxJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZlcmlmaWVyOiAodikgPT4ge1xuICAgIHJldHVybiB2ZXJpZmllcnNbdl1cbiAgfVxufVxuIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIERlZmVycmVkTGV2ZWxET1dOID0gcmVxdWlyZSgnZGVmZXJyZWQtbGV2ZWxkb3duJylcbnZhciBJdGVyYXRvclN0cmVhbSA9IHJlcXVpcmUoJ2xldmVsLWl0ZXJhdG9yLXN0cmVhbScpXG52YXIgQmF0Y2ggPSByZXF1aXJlKCcuL2JhdGNoJylcbnZhciBlcnJvcnMgPSByZXF1aXJlKCdsZXZlbC1lcnJvcnMnKVxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgcHJvbWlzaWZ5ID0gcmVxdWlyZSgnLi9wcm9taXNpZnknKVxudmFyIGdldENhbGxiYWNrID0gcmVxdWlyZSgnLi9jb21tb24nKS5nZXRDYWxsYmFja1xudmFyIGdldE9wdGlvbnMgPSByZXF1aXJlKCcuL2NvbW1vbicpLmdldE9wdGlvbnNcblxudmFyIFdyaXRlRXJyb3IgPSBlcnJvcnMuV3JpdGVFcnJvclxudmFyIFJlYWRFcnJvciA9IGVycm9ycy5SZWFkRXJyb3JcbnZhciBOb3RGb3VuZEVycm9yID0gZXJyb3JzLk5vdEZvdW5kRXJyb3JcbnZhciBPcGVuRXJyb3IgPSBlcnJvcnMuT3BlbkVycm9yXG52YXIgSW5pdGlhbGl6YXRpb25FcnJvciA9IGVycm9ycy5Jbml0aWFsaXphdGlvbkVycm9yXG5cbi8vIFBvc3NpYmxlIEFic3RyYWN0TGV2ZWxET1dOI3N0YXR1cyB2YWx1ZXM6XG4vLyAgLSAnbmV3JyAgICAgLSBuZXdseSBjcmVhdGVkLCBub3Qgb3BlbmVkIG9yIGNsb3NlZFxuLy8gIC0gJ29wZW5pbmcnIC0gd2FpdGluZyBmb3IgdGhlIGRhdGFiYXNlIHRvIGJlIG9wZW5lZCwgcG9zdCBvcGVuKClcbi8vICAtICdvcGVuJyAgICAtIHN1Y2Nlc3NmdWxseSBvcGVuZWQgdGhlIGRhdGFiYXNlLCBhdmFpbGFibGUgZm9yIHVzZVxuLy8gIC0gJ2Nsb3NpbmcnIC0gd2FpdGluZyBmb3IgdGhlIGRhdGFiYXNlIHRvIGJlIGNsb3NlZCwgcG9zdCBjbG9zZSgpXG4vLyAgLSAnY2xvc2VkJyAgLSBkYXRhYmFzZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgY2xvc2VkLCBzaG91bGQgbm90IGJlXG4vLyAgICAgICAgICAgICAgICAgdXNlZCBleGNlcHQgZm9yIGFub3RoZXIgb3BlbigpIG9wZXJhdGlvblxuXG5mdW5jdGlvbiBMZXZlbFVQIChkYiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExldmVsVVApKSB7XG4gICAgcmV0dXJuIG5ldyBMZXZlbFVQKGRiLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgfVxuXG4gIHZhciBlcnJvclxuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpXG4gIHRoaXMuc2V0TWF4TGlzdGVuZXJzKEluZmluaXR5KVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAoIWRiIHx8IHR5cGVvZiBkYiAhPT0gJ29iamVjdCcpIHtcbiAgICBlcnJvciA9IG5ldyBJbml0aWFsaXphdGlvbkVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGFic3RyYWN0LWxldmVsZG93biBjb21wbGlhbnQgc3RvcmUnKVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBlcnJvcilcbiAgICB9XG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2YgZGIuc3RhdHVzLCAnc3RyaW5nJywgJy5zdGF0dXMgcmVxdWlyZWQsIG9sZCBhYnN0cmFjdC1sZXZlbGRvd24nKVxuXG4gIHRoaXMub3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucylcbiAgdGhpcy5fZGIgPSBkYlxuICB0aGlzLmRiID0gbmV3IERlZmVycmVkTGV2ZWxET1dOKGRiKVxuICB0aGlzLm9wZW4oY2FsbGJhY2spXG59XG5cbkxldmVsVVAucHJvdG90eXBlLmVtaXQgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXRcbkxldmVsVVAucHJvdG90eXBlLm9uY2UgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2VcbmluaGVyaXRzKExldmVsVVAsIEV2ZW50RW1pdHRlcilcblxuTGV2ZWxVUC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHByb21pc2VcblxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHNcbiAgICBvcHRzID0gbnVsbFxuICB9XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gcHJvbWlzaWZ5KClcbiAgICBwcm9taXNlID0gY2FsbGJhY2sucHJvbWlzZVxuICB9XG5cbiAgaWYgKCFvcHRzKSB7XG4gICAgb3B0cyA9IHRoaXMub3B0aW9uc1xuICB9XG5cbiAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBudWxsLCBzZWxmKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBpZiAodGhpcy5faXNPcGVuaW5nKCkpIHtcbiAgICB0aGlzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiAoKSB7IGNhbGxiYWNrKG51bGwsIHNlbGYpIH0pXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIHRoaXMuZW1pdCgnb3BlbmluZycpXG5cbiAgdGhpcy5kYi5vcGVuKG9wdHMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobmV3IE9wZW5FcnJvcihlcnIpKVxuICAgIH1cbiAgICBzZWxmLmRiID0gc2VsZi5fZGJcbiAgICBjYWxsYmFjayhudWxsLCBzZWxmKVxuICAgIHNlbGYuZW1pdCgnb3BlbicpXG4gICAgc2VsZi5lbWl0KCdyZWFkeScpXG4gIH0pXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuTGV2ZWxVUC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBwcm9taXNlXG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gcHJvbWlzaWZ5KClcbiAgICBwcm9taXNlID0gY2FsbGJhY2sucHJvbWlzZVxuICB9XG5cbiAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICB0aGlzLmRiLmNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnY2xvc2VkJylcbiAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9KVxuICAgIHRoaXMuZW1pdCgnY2xvc2luZycpXG4gICAgdGhpcy5kYiA9IG5ldyBEZWZlcnJlZExldmVsRE9XTih0aGlzLl9kYilcbiAgfSBlbHNlIGlmICh0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKVxuICB9IGVsc2UgaWYgKHRoaXMuZGIuc3RhdHVzID09PSAnY2xvc2luZycpIHtcbiAgICB0aGlzLm9uY2UoJ2Nsb3NlZCcsIGNhbGxiYWNrKVxuICB9IGVsc2UgaWYgKHRoaXMuX2lzT3BlbmluZygpKSB7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5jbG9zZShjYWxsYmFjaylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuTGV2ZWxVUC5wcm90b3R5cGUuaXNPcGVuID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5kYi5zdGF0dXMgPT09ICdvcGVuJ1xufVxuXG5MZXZlbFVQLnByb3RvdHlwZS5faXNPcGVuaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5kYi5zdGF0dXMgPT09ICdvcGVuaW5nJ1xufVxuXG5MZXZlbFVQLnByb3RvdHlwZS5pc0Nsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgvXmNsb3N8bmV3LykudGVzdCh0aGlzLmRiLnN0YXR1cylcbn1cblxuTGV2ZWxVUC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKGtleSA9PT0gbnVsbCB8fCBrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBSZWFkRXJyb3IoJ2dldCgpIHJlcXVpcmVzIGEga2V5IGFyZ3VtZW50JylcbiAgfVxuXG4gIHZhciBwcm9taXNlXG5cbiAgY2FsbGJhY2sgPSBnZXRDYWxsYmFjayhvcHRpb25zLCBjYWxsYmFjaylcblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBwcm9taXNpZnkoKVxuICAgIHByb21pc2UgPSBjYWxsYmFjay5wcm9taXNlXG4gIH1cblxuICBpZiAobWF5YmVFcnJvcih0aGlzLCBjYWxsYmFjaykpIHsgcmV0dXJuIHByb21pc2UgfVxuXG4gIG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpXG5cbiAgdGhpcy5kYi5nZXQoa2V5LCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmICgoL25vdGZvdW5kL2kpLnRlc3QoZXJyKSB8fCBlcnIubm90Rm91bmQpIHtcbiAgICAgICAgZXJyID0gbmV3IE5vdEZvdW5kRXJyb3IoJ0tleSBub3QgZm91bmQgaW4gZGF0YWJhc2UgWycgKyBrZXkgKyAnXScsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVyciA9IG5ldyBSZWFkRXJyb3IoZXJyKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgdmFsdWUpXG4gIH0pXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuTGV2ZWxVUC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChrZXkgPT09IG51bGwgfHwga2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgV3JpdGVFcnJvcigncHV0KCkgcmVxdWlyZXMgYSBrZXkgYXJndW1lbnQnKVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBwcm9taXNlXG5cbiAgY2FsbGJhY2sgPSBnZXRDYWxsYmFjayhvcHRpb25zLCBjYWxsYmFjaylcblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBwcm9taXNpZnkoKVxuICAgIHByb21pc2UgPSBjYWxsYmFjay5wcm9taXNlXG4gIH1cblxuICBpZiAobWF5YmVFcnJvcih0aGlzLCBjYWxsYmFjaykpIHsgcmV0dXJuIHByb21pc2UgfVxuXG4gIG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpXG5cbiAgdGhpcy5kYi5wdXQoa2V5LCB2YWx1ZSwgb3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgV3JpdGVFcnJvcihlcnIpKVxuICAgIH1cbiAgICBzZWxmLmVtaXQoJ3B1dCcsIGtleSwgdmFsdWUpXG4gICAgY2FsbGJhY2soKVxuICB9KVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbkxldmVsVVAucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChrZXkgPT09IG51bGwgfHwga2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgV3JpdGVFcnJvcignZGVsKCkgcmVxdWlyZXMgYSBrZXkgYXJndW1lbnQnKVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBwcm9taXNlXG5cbiAgY2FsbGJhY2sgPSBnZXRDYWxsYmFjayhvcHRpb25zLCBjYWxsYmFjaylcblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBwcm9taXNpZnkoKVxuICAgIHByb21pc2UgPSBjYWxsYmFjay5wcm9taXNlXG4gIH1cblxuICBpZiAobWF5YmVFcnJvcih0aGlzLCBjYWxsYmFjaykpIHsgcmV0dXJuIHByb21pc2UgfVxuXG4gIG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpXG5cbiAgdGhpcy5kYi5kZWwoa2V5LCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBXcml0ZUVycm9yKGVycikpXG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZGVsJywga2V5KVxuICAgIGNhbGxiYWNrKClcbiAgfSlcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5MZXZlbFVQLnByb3RvdHlwZS5iYXRjaCA9IGZ1bmN0aW9uIChhcnIsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgQmF0Y2godGhpcylcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgdGhyb3cgbmV3IFdyaXRlRXJyb3IoJ2JhdGNoKCkgcmVxdWlyZXMgYW4gYXJyYXkgYXJndW1lbnQnKVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBwcm9taXNlXG5cbiAgY2FsbGJhY2sgPSBnZXRDYWxsYmFjayhvcHRpb25zLCBjYWxsYmFjaylcblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBwcm9taXNpZnkoKVxuICAgIHByb21pc2UgPSBjYWxsYmFjay5wcm9taXNlXG4gIH1cblxuICBpZiAobWF5YmVFcnJvcih0aGlzLCBjYWxsYmFjaykpIHsgcmV0dXJuIHByb21pc2UgfVxuXG4gIG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpXG5cbiAgdGhpcy5kYi5iYXRjaChhcnIsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobmV3IFdyaXRlRXJyb3IoZXJyKSlcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdiYXRjaCcsIGFycilcbiAgICBjYWxsYmFjaygpXG4gIH0pXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuTGV2ZWxVUC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5kYi5pdGVyYXRvcihvcHRpb25zKVxufVxuXG5MZXZlbFVQLnByb3RvdHlwZS5yZWFkU3RyZWFtID1cbkxldmVsVVAucHJvdG90eXBlLmNyZWF0ZVJlYWRTdHJlYW0gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gZXh0ZW5kKHsga2V5czogdHJ1ZSwgdmFsdWVzOiB0cnVlIH0sIG9wdGlvbnMpXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5saW1pdCAhPT0gJ251bWJlcicpIHsgb3B0aW9ucy5saW1pdCA9IC0xIH1cbiAgcmV0dXJuIG5ldyBJdGVyYXRvclN0cmVhbSh0aGlzLmRiLml0ZXJhdG9yKG9wdGlvbnMpLCBvcHRpb25zKVxufVxuXG5MZXZlbFVQLnByb3RvdHlwZS5rZXlTdHJlYW0gPVxuTGV2ZWxVUC5wcm90b3R5cGUuY3JlYXRlS2V5U3RyZWFtID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlUmVhZFN0cmVhbShleHRlbmQob3B0aW9ucywgeyBrZXlzOiB0cnVlLCB2YWx1ZXM6IGZhbHNlIH0pKVxufVxuXG5MZXZlbFVQLnByb3RvdHlwZS52YWx1ZVN0cmVhbSA9XG5MZXZlbFVQLnByb3RvdHlwZS5jcmVhdGVWYWx1ZVN0cmVhbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmNyZWF0ZVJlYWRTdHJlYW0oZXh0ZW5kKG9wdGlvbnMsIHsga2V5czogZmFsc2UsIHZhbHVlczogdHJ1ZSB9KSlcbn1cblxuTGV2ZWxVUC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnTGV2ZWxVUCdcbn1cblxuZnVuY3Rpb24gbWF5YmVFcnJvciAoZGIsIGNhbGxiYWNrKSB7XG4gIGlmICghZGIuX2lzT3BlbmluZygpICYmICFkYi5pc09wZW4oKSkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBSZWFkRXJyb3IoJ0RhdGFiYXNlIGlzIG5vdCBvcGVuJykpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5MZXZlbFVQLmVycm9ycyA9IGVycm9yc1xubW9kdWxlLmV4cG9ydHMgPSBMZXZlbFVQLmRlZmF1bHQgPSBMZXZlbFVQXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuXG5jb25zdCBsb2cgPSBkZWJ1ZygncmVwbzpsb2NrJylcblxuY29uc3QgbG9ja0ZpbGUgPSAncmVwby5sb2NrJ1xuXG5jb25zdCBMT0NLUyA9IHt9XG5cbi8qKlxuICogTG9jayB0aGUgcmVwbyBpbiB0aGUgZ2l2ZW4gZGlyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIGxvY2spfSBjYWxsYmFja1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydHMubG9jayA9IChkaXIsIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGZpbGUgPSBkaXIgKyAnLycgKyBsb2NrRmlsZVxuICBsb2coJ2xvY2tpbmcgJXMnLCBmaWxlKVxuICBMT0NLU1tmaWxlXSA9IHRydWVcbiAgY29uc3QgY2xvc2VyID0ge1xuICAgIGNsb3NlIChjYikge1xuICAgICAgaWYgKExPQ0tTW2ZpbGVdKSB7XG4gICAgICAgIGRlbGV0ZSBMT0NLU1tmaWxlXVxuICAgICAgfVxuICAgICAgc2V0SW1tZWRpYXRlKGNiKVxuICAgIH1cbiAgfVxuICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgIGNhbGxiYWNrKG51bGwsIGNsb3NlcilcbiAgfSlcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcmVwbyBpbiB0aGUgZ2l2ZW4gZGlyZWN0b3J5IGlzIGxvY2tlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBib29sKX0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnRzLmxvY2tlZCA9IChkaXIsIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGZpbGUgPSBkaXIgKyAnLycgKyBsb2NrRmlsZVxuICBsb2coJ2NoZWNraW5nIGxvY2s6ICVzJylcblxuICBjb25zdCBsb2NrZWQgPSBMT0NLU1tmaWxlXVxuICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgIGNhbGxiYWNrKG51bGwsIGxvY2tlZClcbiAgfSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZUJhY2tlbmQgKG5hbWUsIHBhdGgsIG9wdGlvbnMpIHtcbiAgY29uc3QgQ3RvciA9IG9wdGlvbnMuc3RvcmFnZUJhY2tlbmRzW25hbWVdXG4gIGNvbnN0IGJhY2tlbmRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5zdG9yYWdlQmFja2VuZE9wdGlvbnNbbmFtZV0gfHwge30pXG4gIHJldHVybiBuZXcgQ3RvcihwYXRoLCBiYWNrZW5kT3B0aW9ucylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBEZWZhdWx0IGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBkYXRhc3RvcmUgc3BlYyBpbiBub2RlLmpzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU3BlYzoge1xuICAgIHR5cGU6ICdtb3VudCcsXG4gICAgbW91bnRzOiBbXG4gICAgICB7XG4gICAgICAgIG1vdW50cG9pbnQ6ICcvYmxvY2tzJyxcbiAgICAgICAgdHlwZTogJ21lYXN1cmUnLFxuICAgICAgICBwcmVmaXg6ICdmbGF0ZnMuZGF0YXN0b3JlJyxcbiAgICAgICAgY2hpbGQ6IHtcbiAgICAgICAgICB0eXBlOiAnZmxhdGZzJyxcbiAgICAgICAgICBwYXRoOiAnYmxvY2tzJyxcbiAgICAgICAgICBzeW5jOiB0cnVlLFxuICAgICAgICAgIHNoYXJkRnVuYzogJy9yZXBvL2ZsYXRmcy9zaGFyZC92MS9uZXh0LXRvLWxhc3QvMidcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbW91bnRwb2ludDogJy8nLFxuICAgICAgICB0eXBlOiAnbWVhc3VyZScsXG4gICAgICAgIHByZWZpeDogJ2xldmVsZGIuZGF0YXN0b3JlJyxcbiAgICAgICAgY2hpbGQ6IHtcbiAgICAgICAgICB0eXBlOiAnbGV2ZWxkcycsXG4gICAgICAgICAgcGF0aDogJ2RhdGFzdG9yZScsXG4gICAgICAgICAgY29tcHJlc3Npb246ICdub25lJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlcG9WZXJzaW9uOiA3XG59XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5FUlJfUkVQT19OT1RfSU5JVElBTElaRUQgPSAnRVJSX1JFUE9fTk9UX0lOSVRJQUxJWkVEJ1xuIiwiOyhmdW5jdGlvbiAoZ2xvYmFsT2JqZWN0KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuLypcclxuICogICAgICBiaWdudW1iZXIuanMgdjguMS4xXHJcbiAqICAgICAgQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gYXJpdGhtZXRpYy5cclxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanNcclxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMTkgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICogICAgICBNSVQgTGljZW5zZWQuXHJcbiAqXHJcbiAqICAgICAgQmlnTnVtYmVyLnByb3RvdHlwZSBtZXRob2RzICAgICB8ICBCaWdOdW1iZXIgbWV0aG9kc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGFic29sdXRlVmFsdWUgICAgICAgICAgICBhYnMgICAgfCAgY2xvbmVcclxuICogICAgICBjb21wYXJlZFRvICAgICAgICAgICAgICAgICAgICAgIHwgIGNvbmZpZyAgICAgICAgICAgICAgIHNldFxyXG4gKiAgICAgIGRlY2ltYWxQbGFjZXMgICAgICAgICAgICBkcCAgICAgfCAgICAgIERFQ0lNQUxfUExBQ0VTXHJcbiAqICAgICAgZGl2aWRlZEJ5ICAgICAgICAgICAgICAgIGRpdiAgICB8ICAgICAgUk9VTkRJTkdfTU9ERVxyXG4gKiAgICAgIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICBpZGl2ICAgfCAgICAgIEVYUE9ORU5USUFMX0FUXHJcbiAqICAgICAgZXhwb25lbnRpYXRlZEJ5ICAgICAgICAgIHBvdyAgICB8ICAgICAgUkFOR0VcclxuICogICAgICBpbnRlZ2VyVmFsdWUgICAgICAgICAgICAgICAgICAgIHwgICAgICBDUllQVE9cclxuICogICAgICBpc0VxdWFsVG8gICAgICAgICAgICAgICAgZXEgICAgIHwgICAgICBNT0RVTE9fTU9ERVxyXG4gKiAgICAgIGlzRmluaXRlICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgIFBPV19QUkVDSVNJT05cclxuICogICAgICBpc0dyZWF0ZXJUaGFuICAgICAgICAgICAgZ3QgICAgIHwgICAgICBGT1JNQVRcclxuICogICAgICBpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvICAgZ3RlICAgIHwgICAgICBBTFBIQUJFVFxyXG4gKiAgICAgIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgICAgICAgfCAgaXNCaWdOdW1iZXJcclxuICogICAgICBpc0xlc3NUaGFuICAgICAgICAgICAgICAgbHQgICAgIHwgIG1heGltdW0gICAgICAgICAgICAgIG1heFxyXG4gKiAgICAgIGlzTGVzc1RoYW5PckVxdWFsVG8gICAgICBsdGUgICAgfCAgbWluaW11bSAgICAgICAgICAgICAgbWluXHJcbiAqICAgICAgaXNOYU4gICAgICAgICAgICAgICAgICAgICAgICAgICB8ICByYW5kb21cclxuICogICAgICBpc05lZ2F0aXZlICAgICAgICAgICAgICAgICAgICAgIHwgIHN1bVxyXG4gKiAgICAgIGlzUG9zaXRpdmUgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGlzWmVybyAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1pbnVzICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1vZHVsbyAgICAgICAgICAgICAgICAgICBtb2QgICAgfFxyXG4gKiAgICAgIG11bHRpcGxpZWRCeSAgICAgICAgICAgICB0aW1lcyAgfFxyXG4gKiAgICAgIG5lZ2F0ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHBsdXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHByZWNpc2lvbiAgICAgICAgICAgICAgICBzZCAgICAgfFxyXG4gKiAgICAgIHNoaWZ0ZWRCeSAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHNxdWFyZVJvb3QgICAgICAgICAgICAgICBzcXJ0ICAgfFxyXG4gKiAgICAgIHRvRXhwb25lbnRpYWwgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRml4ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRm9ybWF0ICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRnJhY3Rpb24gICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvSlNPTiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvTnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvUHJlY2lzaW9uICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvU3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG4gIHZhciBCaWdOdW1iZXIsXHJcbiAgICBpc051bWVyaWMgPSAvXi0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPyQvaSxcclxuICAgIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnLFxyXG5cclxuICAgIG1hdGhjZWlsID0gTWF0aC5jZWlsLFxyXG4gICAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuXHJcbiAgICBiaWdudW1iZXJFcnJvciA9ICdbQmlnTnVtYmVyIEVycm9yXSAnLFxyXG4gICAgdG9vTWFueURpZ2l0cyA9IGJpZ251bWJlckVycm9yICsgJ051bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6ICcsXHJcblxyXG4gICAgQkFTRSA9IDFlMTQsXHJcbiAgICBMT0dfQkFTRSA9IDE0LFxyXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYsICAgICAgICAgLy8gMl41MyAtIDFcclxuICAgIC8vIE1BWF9JTlQzMiA9IDB4N2ZmZmZmZmYsICAgICAgICAgICAgICAgICAgIC8vIDJeMzEgLSAxXHJcbiAgICBQT1dTX1RFTiA9IFsxLCAxMCwgMTAwLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTksIDFlMTAsIDFlMTEsIDFlMTIsIDFlMTNdLFxyXG4gICAgU1FSVF9CQVNFID0gMWU3LFxyXG5cclxuICAgIC8vIEVESVRBQkxFXHJcbiAgICAvLyBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIERFQ0lNQUxfUExBQ0VTLCBUT19FWFBfTkVHLCBUT19FWFBfUE9TLCBNSU5fRVhQLCBNQVhfRVhQLCBhbmRcclxuICAgIC8vIHRoZSBhcmd1bWVudHMgdG8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQsIGFuZCB0b1ByZWNpc2lvbi5cclxuICAgIE1BWCA9IDFFOTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYX0lOVDMyXHJcblxyXG5cclxuICAvKlxyXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnTnVtYmVyIGNvbnN0cnVjdG9yLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNsb25lKGNvbmZpZ09iamVjdCkge1xyXG4gICAgdmFyIGRpdiwgY29udmVydEJhc2UsIHBhcnNlTnVtZXJpYyxcclxuICAgICAgUCA9IEJpZ051bWJlci5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBCaWdOdW1iZXIsIHRvU3RyaW5nOiBudWxsLCB2YWx1ZU9mOiBudWxsIH0sXHJcbiAgICAgIE9ORSA9IG5ldyBCaWdOdW1iZXIoMSksXHJcblxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUQUJMRSBDT05GSUcgREVGQVVMVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBzdGF0ZWQuXHJcbiAgICAgIC8vIFRoZSB2YWx1ZXMgY2FuIGFsc28gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyBCaWdOdW1iZXIuc2V0LlxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBvcGVyYXRpb25zIGludm9sdmluZyBkaXZpc2lvbi5cclxuICAgICAgREVDSU1BTF9QTEFDRVMgPSAyMCwgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIHJvdW5kaW5nIG1vZGUgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIHRoZSBhYm92ZSBkZWNpbWFsIHBsYWNlcywgYW5kIHdoZW4gdXNpbmdcclxuICAgICAgLy8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQgYW5kIHRvUHJlY2lzaW9uLCBhbmQgcm91bmQgKGRlZmF1bHQgdmFsdWUpLlxyXG4gICAgICAvLyBVUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXHJcbiAgICAgIC8vIERPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXHJcbiAgICAgIC8vIENFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxyXG4gICAgICAvLyBIQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXHJcbiAgICAgIC8vIEhBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cclxuICAgICAgLy8gSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgUk9VTkRJTkdfTU9ERSA9IDQsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAgIC8vIEVYUE9ORU5USUFMX0FUIDogW1RPX0VYUF9ORUcgLCBUT19FWFBfUE9TXVxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtN1xyXG4gICAgICBUT19FWFBfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogMjFcclxuICAgICAgVE9fRVhQX1BPUyA9IDIxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gUkFOR0UgOiBbTUlOX0VYUCwgTUFYX0VYUF1cclxuXHJcbiAgICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC0zMjQgICg1ZS0zMjQpXHJcbiAgICAgIE1JTl9FWFAgPSAtMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6ICAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgICAgLy8gRm9yIE1BWF9FWFAgPiAxZTcsIGUuZy4gbmV3IEJpZ051bWJlcignMWUxMDAwMDAwMDAnKS5wbHVzKDEpIG1heSBiZSBzbG93LlxyXG4gICAgICBNQVhfRVhQID0gMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYXHJcblxyXG4gICAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICAgIENSWVBUTyA9IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuICAgICAgLy8gVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgICAgLy8gVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgIC8vIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFVQICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAvLyBET1dOICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZC5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhpcyBtb2R1bG8gbW9kZSBpcyBjb21tb25seSBrbm93biBhcyAndHJ1bmNhdGVkIGRpdmlzaW9uJyBhbmQgaXNcclxuICAgICAgLy8gICAgICAgICAgICAgZXF1aXZhbGVudCB0byAoYSAlIG4pIGluIEphdmFTY3JpcHQuXHJcbiAgICAgIC8vIEZMT09SICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cclxuICAgICAgLy8gSEFMRl9FVkVOIDYgVGhpcyBtb2R1bG8gbW9kZSBpbXBsZW1lbnRzIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXHJcbiAgICAgIC8vIEVVQ0xJRCAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhlIHJlbWFpbmRlciBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRoZSB0cnVuY2F0ZWQgZGl2aXNpb24sIGZsb29yZWQgZGl2aXNpb24sIEV1Y2xpZGlhbiBkaXZpc2lvbiBhbmQgSUVFRSA3NTQgcmVtYWluZGVyXHJcbiAgICAgIC8vIG1vZGVzIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uXHJcbiAgICAgIC8vIEFsdGhvdWdoIHRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzbyBiZSB1c2VkLCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgICAgTU9EVUxPX01PREUgPSAxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDlcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHJlc3VsdCBvZiB0aGUgZXhwb25lbnRpYXRlZEJ5IG9wZXJhdGlvbi5cclxuICAgICAgLy8gSWYgUE9XX1BSRUNJU0lPTiBpcyAwLCB0aGVyZSB3aWxsIGJlIHVubGltaXRlZCBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgIFBPV19QUkVDSVNJT04gPSAwLCAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSBmb3JtYXQgc3BlY2lmaWNhdGlvbiB1c2VkIGJ5IHRoZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0IG1ldGhvZC5cclxuICAgICAgRk9STUFUID0ge1xyXG4gICAgICAgIHByZWZpeDogJycsXHJcbiAgICAgICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAgICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAgIHN1ZmZpeDogJydcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIFRoZSBhbHBoYWJldCB1c2VkIGZvciBiYXNlIGNvbnZlcnNpb24uIEl0IG11c3QgYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzIGxvbmcsIHdpdGggbm8gJysnLFxyXG4gICAgICAvLyAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAvLyAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXydcclxuICAgICAgQUxQSEFCRVQgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcclxuXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1JcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgYW5kIGV4cG9ydGVkIGZ1bmN0aW9uLlxyXG4gICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIHYge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygdi4gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCaWdOdW1iZXIodiwgYikge1xyXG4gICAgICB2YXIgYWxwaGFiZXQsIGMsIGNhc2VDaGFuZ2VkLCBlLCBpLCBpc051bSwgbGVuLCBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAvLyBFbmFibGUgY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IGBuZXdgLlxyXG4gICAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSkgcmV0dXJuIG5ldyBCaWdOdW1iZXIodiwgYik7XHJcblxyXG4gICAgICBpZiAoYiA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh2ICYmIHYuX2lzQmlnTnVtYmVyID09PSB0cnVlKSB7XHJcbiAgICAgICAgICB4LnMgPSB2LnM7XHJcblxyXG4gICAgICAgICAgaWYgKCF2LmMgfHwgdi5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgICAgeC5jID0gdi5jLnNsaWNlKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSAmJiB2ICogMCA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gVXNlIGAxIC8gbmAgdG8gaGFuZGxlIG1pbnVzIHplcm8gYWxzby5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/ICh2ID0gLXYsIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBpbnRlZ2Vycywgd2hlcmUgbiA8IDIxNDc0ODM2NDggKDIqKjMxKS5cclxuICAgICAgICAgIGlmICh2ID09PSB+fnYpIHtcclxuICAgICAgICAgICAgZm9yIChlID0gMCwgaSA9IHY7IGkgPj0gMTA7IGkgLz0gMTAsIGUrKyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgICAgeC5jID0gW3ZdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgaWYgKCFpc051bWVyaWMudGVzdChzdHIgPSBTdHJpbmcodikpKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0pO1xyXG5cclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgICAgICAgaWYgKChpID0gc3RyLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgICAgICAgaWYgKGUgPCAwKSBlID0gaTtcclxuICAgICAgICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XHJcbiAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLlxyXG4gICAgICAgICAgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuXHJcbiAgICAgICAgLy8gQWxsb3cgZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYmUgdXNlZCB3aXRoIGJhc2UgMTAgYXJndW1lbnQsIHdoaWxlXHJcbiAgICAgICAgLy8gYWxzbyByb3VuZGluZyB0byBERUNJTUFMX1BMQUNFUyBhcyB3aXRoIG90aGVyIGJhc2VzLlxyXG4gICAgICAgIGlmIChiID09IDEwKSB7XHJcbiAgICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih2KTtcclxuICAgICAgICAgIHJldHVybiByb3VuZCh4LCBERUNJTUFMX1BMQUNFUyArIHguZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG5cclxuICAgICAgICBpZiAoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykge1xyXG5cclxuICAgICAgICAgIC8vIEF2b2lkIHBvdGVudGlhbCBpbnRlcnByZXRhdGlvbiBvZiBJbmZpbml0eSBhbmQgTmFOIGFzIGJhc2UgNDQrIHZhbHVlcy5cclxuICAgICAgICAgIGlmICh2ICogMCAhPSAwKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0sIGIpO1xyXG5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcgJiYgc3RyLnJlcGxhY2UoL14wXFwuMCp8XFwuLywgJycpLmxlbmd0aCA+IDE1KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArIHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWxwaGFiZXQgPSBBTFBIQUJFVC5zbGljZSgwLCBiKTtcclxuICAgICAgICBlID0gaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgc3RyIGlzIGEgdmFsaWQgYmFzZSBiIG51bWJlci5cclxuICAgICAgICAvLyBEb24ndCB1c2UgUmVnRXhwLCBzbyBhbHBoYWJldCBjYW4gY29udGFpbiBzcGVjaWFsIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIGlmIChhbHBoYWJldC5pbmRleE9mKGMgPSBzdHIuY2hhckF0KGkpKSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKGMgPT0gJy4nKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmICcuJyBpcyBub3QgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXQgaGFzIG5vdCBiZSBmb3VuZCBiZWZvcmUuXHJcbiAgICAgICAgICAgICAgaWYgKGkgPiBlKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gbGVuO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjYXNlQ2hhbmdlZCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBBbGxvdyBlLmcuIGhleGFkZWNpbWFsICdGRicgYXMgd2VsbCBhcyAnZmYnLlxyXG4gICAgICAgICAgICAgIGlmIChzdHIgPT0gc3RyLnRvVXBwZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICAgICAgICAgICAgICBzdHIgPT0gc3RyLnRvTG93ZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWMoeCwgU3RyaW5nKHYpLCBpc051bSwgYik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cclxuICAgICAgICBpc051bSA9IGZhbHNlO1xyXG4gICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHN0ciwgYiwgMTAsIHgucyk7XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgZWxzZSBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdCgtLWxlbikgPT09IDQ4Oyk7XHJcblxyXG4gICAgICBpZiAoc3RyID0gc3RyLnNsaWNlKGksICsrbGVuKSkge1xyXG4gICAgICAgIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgIGlmIChpc051bSAmJiBCaWdOdW1iZXIuREVCVUcgJiZcclxuICAgICAgICAgIGxlbiA+IDE1ICYmICh2ID4gTUFYX1NBRkVfSU5URUdFUiB8fCB2ICE9PSBtYXRoZmxvb3IodikpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArICh4LnMgKiB2KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgaWYgKChlID0gZSAtIGkgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgIHguYyA9IFtdO1xyXG5cclxuICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgICAgICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cclxuICAgICAgICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29lZmZpY2llbnQgYXJyYXkuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGUgPCAwKSBpICs9IExPR19CQVNFOyAgLy8gaSA8IDFcclxuXHJcbiAgICAgICAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoaSkgeC5jLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjspIHtcclxuICAgICAgICAgICAgICB4LmMucHVzaCgrc3RyLnNsaWNlKGksIGkgKz0gTE9HX0JBU0UpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaSA9IExPR19CQVNFIC0gKHN0ciA9IHN0ci5zbGljZShpKSkubGVuZ3RoO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSAtPSBsZW47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB4LmMucHVzaCgrc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SIFBST1BFUlRJRVNcclxuXHJcblxyXG4gICAgQmlnTnVtYmVyLmNsb25lID0gY2xvbmU7XHJcblxyXG4gICAgQmlnTnVtYmVyLlJPVU5EX1VQID0gMDtcclxuICAgIEJpZ051bWJlci5ST1VORF9ET1dOID0gMTtcclxuICAgIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcclxuICAgIEJpZ051bWJlci5ST1VORF9GTE9PUiA9IDM7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0VWRU4gPSA2O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgICBCaWdOdW1iZXIuRVVDTElEID0gOTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEFjY2VwdCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIHByb3BlcnRpZXMgKGlmIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGlzXHJcbiAgICAgKiBhIG51bWJlciwgaXQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIHN0YXRlZCk6XHJcbiAgICAgKlxyXG4gICAgICogICBERUNJTUFMX1BMQUNFUyAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBST1VORElOR19NT0RFICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDhcclxuICAgICAqICAgRVhQT05FTlRJQUxfQVQgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggIG9yICBbLU1BWCB0byAwLCAwIHRvIE1BWF1cclxuICAgICAqICAgUkFOR0UgICAgICAgICAgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggKG5vdCB6ZXJvKSAgb3IgIFstTUFYIHRvIC0xLCAxIHRvIE1BWF1cclxuICAgICAqICAgQ1JZUFRPICAgICAgICAgICB7Ym9vbGVhbn0gICAgICAgICAgdHJ1ZSBvciBmYWxzZVxyXG4gICAgICogICBNT0RVTE9fTU9ERSAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDlcclxuICAgICAqICAgUE9XX1BSRUNJU0lPTiAgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgQUxQSEFCRVQgICAgICAgICB7c3RyaW5nfSAgICAgICAgICAgQSBzdHJpbmcgb2YgdHdvIG9yIG1vcmUgdW5pcXVlIGNoYXJhY3RlcnMgd2hpY2ggZG9lc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgY29udGFpbiAnLicuXHJcbiAgICAgKiAgIEZPUk1BVCAgICAgICAgICAge29iamVjdH0gICAgICAgICAgIEFuIG9iamVjdCB3aXRoIHNvbWUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogICAgIHByZWZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgc2Vjb25kYXJ5R3JvdXBTaXplICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGdyb3VwU2VwYXJhdG9yICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNpemUgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3Ige3N0cmluZ31cclxuICAgICAqICAgICBzdWZmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKlxyXG4gICAgICogKFRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhlIGFib3ZlIEZPUk1BVCBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IGNoZWNrZWQgZm9yIHZhbGlkaXR5LilcclxuICAgICAqXHJcbiAgICAgKiBFLmcuXHJcbiAgICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcclxuICAgICAqXHJcbiAgICAgKiBJZ25vcmUgcHJvcGVydGllcy9wYXJhbWV0ZXJzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZCwgZXhjZXB0IGZvciBBTFBIQUJFVC5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgY3VycmVudCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5jb25maWcgPSBCaWdOdW1iZXIuc2V0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICB2YXIgcCwgdjtcclxuXHJcbiAgICAgIGlmIChvYmogIT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgIC8vIERFQ0lNQUxfUExBQ0VTIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBERUNJTUFMX1BMQUNFUyB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnREVDSU1BTF9QTEFDRVMnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUk9VTkRJTkdfTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJPVU5ESU5HX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JPVU5ESU5HX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA4LCBwKTtcclxuICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQge251bWJlcnxudW1iZXJbXX1cclxuICAgICAgICAgIC8vIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAwIGluY2x1c2l2ZSwgMCB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBFWFBPTkVOVElBTF9BVCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRVhQT05FTlRJQUxfQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIDAsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IHZbMF07XHJcbiAgICAgICAgICAgICAgVE9fRVhQX1BPUyA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gLShUT19FWFBfUE9TID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUkFOR0Uge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIC0xIGluY2x1c2l2ZSwgaW50ZWdlciAxIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJBTkdFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZXxjYW5ub3QgYmUgemVyb306IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdSQU5HRScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgLTEsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDEsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgTUlOX0VYUCA9IHZbMF07XHJcbiAgICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgTUlOX0VYUCA9IC0oTUFYX0VYUCA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBjYW5ub3QgYmUgemVybzogJyArIHYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENSWVBUTyB7Ym9vbGVhbn0gdHJ1ZSBvciBmYWxzZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBDUllQVE8gbm90IHRydWUgb3IgZmFsc2U6IHt2fSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQ1JZUFRPJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgPT09ICEhdikge1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgICAgICAgICAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSAhdjtcclxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IHRydWUgb3IgZmFsc2U6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE1PRFVMT19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOSBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTU9EVUxPX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ01PRFVMT19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOSwgcCk7XHJcbiAgICAgICAgICAgIE1PRFVMT19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBQT1dfUFJFQ0lTSU9OIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBQT1dfUFJFQ0lTSU9OIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdQT1dfUFJFQ0lTSU9OJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRk9STUFUIHtvYmplY3R9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRk9STUFUIG5vdCBhbiBvYmplY3Q6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdGT1JNQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ29iamVjdCcpIEZPUk1BVCA9IHY7XHJcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCBhbiBvYmplY3Q6ICcgKyB2KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBBTFBIQUJFVCB7c3RyaW5nfVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEFMUEhBQkVUIGludmFsaWQ6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdBTFBIQUJFVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcblxyXG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBpZiBvbmx5IG9uZSBjaGFyYWN0ZXIsXHJcbiAgICAgICAgICAgIC8vIG9yIGlmIGl0IGNvbnRhaW5zICcrJywgJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIGEgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ3N0cmluZycgJiYgIS9eLiR8WystLlxcc118KC4pLipcXDEvLnRlc3QodikpIHtcclxuICAgICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogSWYgQmlnTnVtYmVyLkRFQlVHIGlzIHRydWUsIHRocm93IGlmIGEgQmlnTnVtYmVyIGluc3RhbmNlIGlzIG5vdCB3ZWxsLWZvcm1lZC5cclxuICAgICAqXHJcbiAgICAgKiB2IHthbnl9XHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoIUJpZ051bWJlci5ERUJVRykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICB2YXIgaSwgbixcclxuICAgICAgICBjID0gdi5jLFxyXG4gICAgICAgIGUgPSB2LmUsXHJcbiAgICAgICAgcyA9IHYucztcclxuXHJcbiAgICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgICBpZiAoKHMgPT09IDEgfHwgcyA9PT0gLTEpICYmIGUgPj0gLU1BWCAmJiBlIDw9IE1BWCAmJiBlID09PSBtYXRoZmxvb3IoZSkpIHtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZWxlbWVudCBpcyB6ZXJvLCB0aGUgQmlnTnVtYmVyIHZhbHVlIG11c3QgYmUgemVyby5cclxuICAgICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlID09PSAwICYmIGMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgY1swXSBzaG91bGQgaGF2ZSwgYmFzZWQgb24gdGhlIGV4cG9uZW50LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgICAgLy9pZiAoTWF0aC5jZWlsKE1hdGgubG9nKGNbMF0gKyAxKSAvIE1hdGguTE4xMCkgPT0gaSkge1xyXG4gICAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBuID0gY1tpXTtcclxuICAgICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMYXN0IGVsZW1lbnQgY2Fubm90IGJlIHplcm8sIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50LlxyXG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCAmJiBlID09PSBudWxsICYmIChzID09PSBudWxsIHx8IHMgPT09IDEgfHwgcyA9PT0gLTEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0ludmFsaWQgQmlnTnVtYmVyOiAnICsgdik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5sdCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5taW5pbXVtID0gQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5ndCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcH0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgICAvLyBJZiBpdCBkb2VzLCBhc3N1bWUgYXQgbGVhc3QgNTMgYml0cyBhcmUgcHJvZHVjZWQsIG90aGVyd2lzZSBhc3N1bWUgYXQgbGVhc3QgMzAgYml0cy5cclxuICAgICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmbG9vcihNYXRoLnJhbmRvbSgpICogcG93Ml81Myk7IH1cclxuICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkcCkge1xyXG4gICAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBjID0gW10sXHJcbiAgICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICBpZiAoZHAgPT0gbnVsbCkgZHAgPSBERUNJTUFMX1BMQUNFUztcclxuICAgICAgICBlbHNlIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG5cclxuICAgICAgICBrID0gbWF0aGNlaWwoZHAgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGsgKj0gMikpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDBcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDB4MjAwMDAgaXMgMl4yMS5cclxuICAgICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKTtcclxuICAgICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgICAgYVtpICsgMV0gPSBiWzFdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA3KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwIGlzIDJeMzIsIDB4MTAwMDAwMCBpcyAyXjI0XHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgdiA9ICgoYVtpXSAmIDMxKSAqIDB4MTAwMDAwMDAwMDAwMCkgKyAoYVtpICsgMV0gKiAweDEwMDAwMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDJdICogMHgxMDAwMDAwMDApICsgKGFbaSArIDNdICogMHgxMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDRdIDw8IDE2KSArIChhW2kgKyA1XSA8PCA4KSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShhLCBpKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQ1JZUFRPID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2UgTWF0aC5yYW5kb20uXHJcbiAgICAgICAgaWYgKCFDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgICAgIHYgPSByYW5kb201M2JpdEludCgpO1xyXG4gICAgICAgICAgICBpZiAodiA8IDllMTUpIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgICBkcCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICAgIGlmIChrICYmIGRwKSB7XHJcbiAgICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKGsgLyB2KSAqIHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgICAgZm9yICg7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBjID0gW2UgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBmb3IgKGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc3BsaWNlKDAsIDEpLCBlIC09IExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGlmIChpIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmFuZC5lID0gZTtcclxuICAgICAgICByYW5kLmMgPSBjO1xyXG4gICAgICAgIHJldHVybiByYW5kO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnN1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgc3VtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDspIHN1bSA9IHN1bS5wbHVzKGFyZ3NbaSsrXSk7XHJcbiAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBQUklWQVRFIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgICAvLyBDYWxsZWQgYnkgQmlnTnVtYmVyIGFuZCBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nLlxyXG4gICAgY29udmVydEJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgZGVjaW1hbCA9ICcwMTIzNDU2Nzg5JztcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBhbHBoYWJldCkge1xyXG4gICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgICAgYXJyTCxcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4pO1xyXG5cclxuICAgICAgICAgIGFyclswXSArPSBhbHBoYWJldC5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFycltqICsgMV0gPT0gbnVsbCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIHRvU3RyaW5nLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2UgMTAgdG8gYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyBCaWdOdW1iZXIsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZUluIHRvIGJhc2UgMTAuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIHNpZ24sIGNhbGxlcklzVG9TdHJpbmcpIHtcclxuICAgICAgICB2YXIgYWxwaGFiZXQsIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgICAgaSA9IHN0ci5pbmRleE9mKCcuJyksXHJcbiAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAvLyBVbmxpbWl0ZWQgcHJlY2lzaW9uLlxyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGJhc2VJbik7XHJcbiAgICAgICAgICB4ID0geS5wb3coc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgICAgLy8gQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiByZXN0b3JlIHRoZSBmcmFjdGlvbiBwYXJ0IGJ5IGRpdmlkaW5nIHRoZVxyXG4gICAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG5cclxuICAgICAgICAgIHkuYyA9IHRvQmFzZU91dCh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyh4LmMpLCB4LmUsICcwJyksXHJcbiAgICAgICAgICAgMTAsIGJhc2VPdXQsIGRlY2ltYWwpO1xyXG4gICAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBpbnRlZ2VyLlxyXG5cclxuICAgICAgICB4YyA9IHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgY2FsbGVySXNUb1N0cmluZ1xyXG4gICAgICAgICA/IChhbHBoYWJldCA9IEFMUEhBQkVULCBkZWNpbWFsKVxyXG4gICAgICAgICA6IChhbHBoYWJldCA9IGRlY2ltYWwsIEFMUEhBQkVUKSk7XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBhcyBhbiBpbnRlZ2VyIGFuZCBjb252ZXJ0ZWQgdG8gYmFzZU91dC4gZSBpcyB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSkgcmV0dXJuIGFscGhhYmV0LmNoYXJBdCgwKTtcclxuXHJcbiAgICAgICAgLy8gRG9lcyBzdHIgcmVwcmVzZW50IGFuIGludGVnZXI/IElmIHNvLCBubyBuZWVkIGZvciB0aGUgZGl2aXNpb24uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAtLWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgICAgeCA9IGRpdih4LCB5LCBkcCwgcm0sIGJhc2VPdXQpO1xyXG4gICAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgICByID0geC5yO1xyXG4gICAgICAgICAgZSA9IHguZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBjb252ZXJ0ZWQgdG8gYmFzZU91dC5cclxuXHJcbiAgICAgICAgLy8gVEhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0OiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIGkgPSB4Y1tkXTtcclxuXHJcbiAgICAgICAgLy8gTG9vayBhdCB0aGUgcm91bmRpbmcgZGlnaXRzIGFuZCBtb2RlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJvdW5kIHVwLlxyXG5cclxuICAgICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgICAgciA9IHIgfHwgZCA8IDAgfHwgeGNbZCArIDFdICE9IG51bGw7XHJcblxyXG4gICAgICAgIHIgPSBybSA8IDQgPyAoaSAhPSBudWxsIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG5vdCBncmVhdGVyIHRoYW4gemVybywgb3IgeGMgcmVwcmVzZW50c1xyXG4gICAgICAgIC8vIHplcm8sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYmFzZSBjb252ZXJzaW9uIGlzIHplcm8gb3IsIGlmIHJvdW5kaW5nIHVwLCBhIHZhbHVlXHJcbiAgICAgICAgLy8gc3VjaCBhcyAwLjAwMDAxLlxyXG4gICAgICAgIGlmIChkIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyAxXi1kcCBvciAwXHJcbiAgICAgICAgICBzdHIgPSByID8gdG9GaXhlZFBvaW50KGFscGhhYmV0LmNoYXJBdCgxKSwgLWRwLCBhbHBoYWJldC5jaGFyQXQoMCkpIDogYWxwaGFiZXQuY2hhckF0KDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gVHJ1bmNhdGUgeGMgdG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgIHhjLmxlbmd0aCA9IGQ7XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgICAgZm9yICgtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7KSB7XHJcbiAgICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIWQpIHtcclxuICAgICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICAgIHhjID0gWzFdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChrID0geGMubGVuZ3RoOyAheGNbLS1rXTspO1xyXG5cclxuICAgICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8PSBrOyBzdHIgKz0gYWxwaGFiZXQuY2hhckF0KHhjW2krK10pKTtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvcywgZGVjaW1hbCBwb2ludCBhbmQgdHJhaWxpbmcgemVyb3MgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gICAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgICBmdW5jdGlvbiBtdWx0aXBseSh4LCBrLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIG0sIHRlbXAsIHhsbywgeGhpLFxyXG4gICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgICAga2xvID0gayAlIFNRUlRfQkFTRSxcclxuICAgICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICAgIHhsbyA9IHhbaV0gJSBTUVJUX0JBU0U7XHJcbiAgICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgICB0ZW1wID0ga2xvICogeGxvICsgKChtICUgU1FSVF9CQVNFKSAqIFNRUlRfQkFTRSkgKyBjYXJyeTtcclxuICAgICAgICAgIGNhcnJ5ID0gKHRlbXAgLyBiYXNlIHwgMCkgKyAobSAvIFNRUlRfQkFTRSB8IDApICsga2hpICogeGhpO1xyXG4gICAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhcnJ5KSB4ID0gW2NhcnJ5XS5jb25jYXQoeCk7XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICAgIGlmIChhTCAhPSBiTCkge1xyXG4gICAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IGNtcCA9IDA7IGkgPCBhTDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyBhLnNwbGljZSgwLCAxKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHksIGRwLCBybSwgYmFzZSkge1xyXG4gICAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICAgIHlMLCB5eixcclxuICAgICAgICAgIHMgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgICAgICBpZiAoIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXHJcblxyXG4gICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YykgPyBOYU4gOlxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIMKxMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgwrEwLlxyXG4gICAgICAgICAgICB4YyAmJiB4Y1swXSA9PSAwIHx8ICF5YyA/IHMgKiAwIDogcyAvIDBcclxuICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHEgPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG4gICAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgICBzID0gZHAgKyBlICsgMTtcclxuXHJcbiAgICAgICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgLSBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBlLlxyXG4gICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICAgIGlmICh5Y1tpXSA+ICh4Y1tpXSB8fCAwKSkgZS0tO1xyXG5cclxuICAgICAgICBpZiAocyA8IDApIHtcclxuICAgICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgICBtb3JlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgICBuID0gbWF0aGZsb29yKGJhc2UgLyAoeWNbMF0gKyAxKSk7XHJcblxyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgICAvLyBpZiAobiA+IDEgfHwgbisrID09IDEgJiYgeWNbMF0gPCBiYXNlIC8gMikge1xyXG4gICAgICAgICAgaWYgKG4gPiAxKSB7XHJcbiAgICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB4YyA9IG11bHRpcGx5KHhjLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICAgIHl6ID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgIHl6ID0gWzBdLmNvbmNhdCh5eik7XHJcbiAgICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICAgIGlmICh5Y1sxXSA+PSBiYXNlIC8gMikgeWMwKys7XHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gcHJldmVudCB0cmlhbCBkaWdpdCBuID4gYmFzZSwgd2hlbiB1c2luZyBiYXNlIDMuXHJcbiAgICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vcihyZW0wIC8geWMwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgICAvLyAgcHJvZHVjdCA9IGRpdmlzb3IgbXVsdGlwbGllZCBieSB0cmlhbCBkaWdpdCAobikuXHJcbiAgICAgICAgICAgICAgLy8gIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgICAgLy8gICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QsIGRlY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAvLyAgU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAgIC8vICAgIENvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvci5cclxuICAgICAgICAgICAgICAvLyAgICBJZiByZW1haW5kZXIgaXMgZ3JlYXRlciB0aGFuIGRpdmlzb3I6XHJcbiAgICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICAgIGlmIChuID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGhpZ2ggYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCBpcyBub3Qga25vd24gdG8gaGF2ZVxyXG4gICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBuLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgY21wID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgICAgLy8gc28gY2hhbmdlIGNtcCB0byAxIHRvIGF2b2lkIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gZGl2aXNvciA8IHJlbWFpbmRlciwgc28gbiBtdXN0IGJlIGF0IGxlYXN0IDEuXHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yXHJcbiAgICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kID0gWzBdLmNvbmNhdChwcm9kKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4rKztcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgICB9IC8vIGVsc2UgY21wID09PSAxIGFuZCBuIHdpbGwgYmUgMFxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAocmVtWzBdKSB7XHJcbiAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZW0gPSBbeGNbeGldXTtcclxuICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCkgJiYgcy0tKTtcclxuXHJcbiAgICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICAgICAgaWYgKCFxY1swXSkgcWMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJhc2UgPT0gQkFTRSkge1xyXG5cclxuICAgICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICByb3VuZChxLCBkcCArIChxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgKyAxLCBybSwgbW9yZSk7XHJcblxyXG4gICAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcS5lID0gZTtcclxuICAgICAgICAgIHEuciA9ICttb3JlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgKlxyXG4gICAgICogbjogYSBCaWdOdW1iZXIuXHJcbiAgICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAgICogcm06IHRoZSByb3VuZGluZyBtb2RlLlxyXG4gICAgICogaWQ6IDEgKHRvRXhwb25lbnRpYWwpIG9yIDIgKHRvUHJlY2lzaW9uKS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0KG4sIGksIHJtLCBpZCkge1xyXG4gICAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgaWYgKCFuLmMpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBjMCA9IG4uY1swXTtcclxuICAgICAgbmUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoaSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIHN0ciA9IGlkID09IDEgfHwgaWQgPT0gMiAmJiAobmUgPD0gVE9fRVhQX05FRyB8fCBuZSA+PSBUT19FWFBfUE9TKVxyXG4gICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBuZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgaSwgcm0pO1xyXG5cclxuICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgaWYgKGlkID09IDEgfHwgaWQgPT0gMiAmJiAoaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRykpIHtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBmb3IgKDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKyspO1xyXG4gICAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbChzdHIsIGUpO1xyXG5cclxuICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGlmICgtLWkgPiAwKSBmb3IgKHN0ciArPSAnLic7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICAgIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG1ldGhvZCkge1xyXG4gICAgICB2YXIgbixcclxuICAgICAgICBpID0gMSxcclxuICAgICAgICBtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG5cclxuICAgICAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgICAgICBpZiAoIW4ucykge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZC5jYWxsKG0sIG4pKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFjWy0tal07IGMucG9wKCkpO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbi5lID0gZTtcclxuICAgICAgICBuLmMgPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgZG90QmVmb3JlID0gL15cXC4oW14uXSspJC8sXHJcbiAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgc3RyLCBpc051bSwgYikge1xyXG4gICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShiYXNlUHJlZml4LCBmdW5jdGlvbiAobSwgcDEsIHAyKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzdHIgIT0gcykgcmV0dXJuIG5ldyBCaWdOdW1iZXIocywgYmFzZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdOb3QgYScgKyAoYiA/ICcgYmFzZSAnICsgYiA6ICcnKSArICcgbnVtYmVyOiAnICsgc3RyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBOYU5cclxuICAgICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUm91bmQgeCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS4gQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kKHgsIHNkLCBybSwgcikge1xyXG4gICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHBvd3MxMCA9IFBPV1NfVEVOO1xyXG5cclxuICAgICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgcmQgPSBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuaSA9IG1hdGhjZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmkgPj0geGMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApKTtcclxuICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBkID0gMTtcclxuICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBuID0gayA9IHhjW25pXTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgZm9yIChkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgciA9IHIgfHwgc2QgPCAwIHx8XHJcblxyXG4gICAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbZCAtIGogLSAxXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgICA/IChyZCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICAgKChpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFtkIC0gal0gOiAwIDogeGNbbmkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNkIDwgMSB8fCAheGNbMF0pIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFXTtcclxuICAgICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICAgIGsgPSBwb3dzMTBbTE9HX0JBU0UgLSBpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGpdICUgcG93czEwW2pdKSAqIGsgOiAwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgICAgaWYgKG5pID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGNbbmldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuXHJcbiAgICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICovXHJcbiAgICBQLmNvbXBhcmVkVG8gPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgICAqIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgKiAgbiAvIE4gPSBOXHJcbiAgICAgKiAgbiAvIEkgPSAwXHJcbiAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgKiAgMCAvIDAgPSBOXHJcbiAgICAgKiAgMCAvIE4gPSBOXHJcbiAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgKiAgTiAvIG4gPSBOXHJcbiAgICAgKiAgTiAvIDAgPSBOXHJcbiAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgKiAgTiAvIEkgPSBOXHJcbiAgICAgKiAgSSAvIG4gPSBJXHJcbiAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgKiAgSSAvIE4gPSBOXHJcbiAgICAgKiAgSSAvIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciBieSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgMCwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBleHBvbmVudGlhdGVkIGJ5IG4uXHJcbiAgICAgKlxyXG4gICAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgICAqIElmIG4gaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBtb2R1bGFyIHBvd2VyIG9wZXJhdGlvbiB3b3JrcyBlZmZpY2llbnRseSB3aGVuIHgsIG4sIGFuZCBtIGFyZSBpbnRlZ2Vycywgb3RoZXJ3aXNlIGl0XHJcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAgICpcclxuICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgZXhwb25lbnQuIEFuIGludGVnZXIuXHJcbiAgICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gRXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgICAqL1xyXG4gICAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICAgIHZhciBoYWxmLCBpc01vZEV4cCwgaSwgaywgbW9yZSwgbklzQmlnLCBuSXNOZWcsIG5Jc09kZCwgeSxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgICAgLy8gQWxsb3cgTmFOIGFuZCDCsUluZmluaXR5LCBidXQgbm90IG90aGVyIG5vbi1pbnRlZ2Vycy5cclxuICAgICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnRXhwb25lbnQgbm90IGFuIGludGVnZXI6ICcgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG0gIT0gbnVsbCkgbSA9IG5ldyBCaWdOdW1iZXIobSk7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudCBvZiBNQVhfU0FGRV9JTlRFR0VSIGlzIDE1LlxyXG4gICAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgTmFOLCDCsUluZmluaXR5LCDCsTAgb3IgwrExLCBvciBuIGlzIMKxSW5maW5pdHksIE5hTiBvciDCsTAuXHJcbiAgICAgIGlmICgheC5jIHx8ICF4LmNbMF0gfHwgeC5jWzBdID09IDEgJiYgIXguZSAmJiB4LmMubGVuZ3RoID09IDEgfHwgIW4uYyB8fCAhbi5jWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byDCsUluZmluaXR5LCB0aGUgZXZlbm5lc3Mgb2YgbiB3b3VsZCBiZSBub3QgYmUga25vd24uXHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoTWF0aC5wb3coK3ZhbHVlT2YoeCksIG5Jc0JpZyA/IDIgLSBpc09kZChuKSA6ICt2YWx1ZU9mKG4pKSk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5Jc05lZyA9IG4ucyA8IDA7XHJcblxyXG4gICAgICBpZiAobSkge1xyXG5cclxuICAgICAgICAvLyB4ICUgbSByZXR1cm5zIE5hTiBpZiBhYnMobSkgaXMgemVybywgb3IgbSBpcyBOYU4uXHJcbiAgICAgICAgaWYgKG0uYyA/ICFtLmNbMF0gOiAhbS5zKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgICBpc01vZEV4cCA9ICFuSXNOZWcgJiYgeC5pc0ludGVnZXIoKSAmJiBtLmlzSW50ZWdlcigpO1xyXG5cclxuICAgICAgICBpZiAoaXNNb2RFeHApIHggPSB4Lm1vZChtKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93IHRvIMKxSW5maW5pdHk6ID49MioqMWUxMCBvciA+PTEuMDAwMDAyNCoqMWUxNS5cclxuICAgICAgLy8gVW5kZXJmbG93IHRvIMKxMDogPD0wLjc5KioxZTEwIG9yIDw9MC45OTk5OTc1KioxZTE1LlxyXG4gICAgICB9IGVsc2UgaWYgKG4uZSA+IDkgJiYgKHguZSA+IDAgfHwgeC5lIDwgLTEgfHwgKHguZSA9PSAwXHJcbiAgICAgICAgLy8gWzEsIDI0MDAwMDAwMF1cclxuICAgICAgICA/IHguY1swXSA+IDEgfHwgbklzQmlnICYmIHguY1sxXSA+PSAyNGU3XHJcbiAgICAgICAgLy8gWzgwMDAwMDAwMDAwMDAwXSAgWzk5OTk5NzUwMDAwMDAwXVxyXG4gICAgICAgIDogeC5jWzBdIDwgOGUxMyB8fCBuSXNCaWcgJiYgeC5jWzBdIDw9IDk5OTk5NzVlNykpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHggaXMgbmVnYXRpdmUgYW5kIG4gaXMgb2RkLCBrID0gLTAsIGVsc2UgayA9IDAuXHJcbiAgICAgICAgayA9IHgucyA8IDAgJiYgaXNPZGQobikgPyAtMCA6IDA7XHJcblxyXG4gICAgICAgIC8vIElmIHggPj0gMSwgayA9IMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IC0xKSBrID0gMSAvIGs7XHJcblxyXG4gICAgICAgIC8vIElmIG4gaXMgbmVnYXRpdmUgcmV0dXJuIMKxMCwgZWxzZSByZXR1cm4gwrFJbmZpbml0eS5cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihuSXNOZWcgPyAxIC8gayA6IGspO1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChQT1dfUFJFQ0lTSU9OKSB7XHJcblxyXG4gICAgICAgIC8vIFRydW5jYXRpbmcgZWFjaCBjb2VmZmljaWVudCBhcnJheSB0byBhIGxlbmd0aCBvZiBrIGFmdGVyIGVhY2ggbXVsdGlwbGljYXRpb25cclxuICAgICAgICAvLyBlcXVhdGVzIHRvIHRydW5jYXRpbmcgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIFBPV19QUkVDSVNJT04gKyBbMjgsIDQxXSxcclxuICAgICAgICAvLyBpLmUuIHRoZXJlIHdpbGwgYmUgYSBtaW5pbXVtIG9mIDI4IGd1YXJkIGRpZ2l0cyByZXRhaW5lZC5cclxuICAgICAgICBrID0gbWF0aGNlaWwoUE9XX1BSRUNJU0lPTiAvIExPR19CQVNFICsgMik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChuSXNCaWcpIHtcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcigwLjUpO1xyXG4gICAgICAgIGlmIChuSXNOZWcpIG4ucyA9IDE7XHJcbiAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaSA9IE1hdGguYWJzKCt2YWx1ZU9mKG4pKTtcclxuICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1zIDU0IGxvb3AgaXRlcmF0aW9ucyBmb3IgbiBvZiA5MDA3MTk5MjU0NzQwOTkxLlxyXG4gICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICBpZiAobklzT2RkKSB7XHJcbiAgICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICAgIGlmICgheS5jKSBicmVhaztcclxuXHJcbiAgICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgICBpZiAoeS5jLmxlbmd0aCA+IGspIHkuYy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgICB5ID0geS5tb2QobSk7ICAgIC8veSA9IHkubWludXMoZGl2KHksIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaSkge1xyXG4gICAgICAgICAgaSA9IG1hdGhmbG9vcihpIC8gMik7XHJcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IG4udGltZXMoaGFsZik7XHJcbiAgICAgICAgICByb3VuZChuLCBuLmUgKyAxLCAxKTtcclxuXHJcbiAgICAgICAgICBpZiAobi5lID4gMTQpIHtcclxuICAgICAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpID0gK3ZhbHVlT2Yobik7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4ID0geC50aW1lcyh4KTtcclxuXHJcbiAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgIGlmICh4LmMgJiYgeC5jLmxlbmd0aCA+IGspIHguYy5sZW5ndGggPSBrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgIHggPSB4Lm1vZChtKTsgICAgLy94ID0geC5taW51cyhkaXYoeCwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc01vZEV4cCkgcmV0dXJuIHk7XHJcbiAgICAgIGlmIChuSXNOZWcpIHkgPSBPTkUuZGl2KHkpO1xyXG5cclxuICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IGsgPyByb3VuZCh5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFLCBtb3JlKSA6IHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhbiBpbnRlZ2VyXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7cm19J1xyXG4gICAgICovXHJcbiAgICBQLmludGVnZXJWYWx1ZSA9IGZ1bmN0aW9uIChybSkge1xyXG4gICAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG4gICAgICByZXR1cm4gcm91bmQobiwgbi5lICsgMSwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0VxdWFsVG8gPSBQLmVxID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gMSB8fCBiID09PSAwO1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYW4gaW50ZWdlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0ludGVnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmMubGVuZ3RoIC0gMjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IC0xIHx8IGIgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICF0aGlzLnM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiB0aGlzLmNbMF0gPT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAtIDAgPSBuXHJcbiAgICAgKiAgbiAtIE4gPSBOXHJcbiAgICAgKiAgbiAtIEkgPSAtSVxyXG4gICAgICogIDAgLSBuID0gLW5cclxuICAgICAqICAwIC0gMCA9IDBcclxuICAgICAqICAwIC0gTiA9IE5cclxuICAgICAqICAwIC0gSSA9IC1JXHJcbiAgICAgKiAgTiAtIG4gPSBOXHJcbiAgICAgKiAgTiAtIDAgPSBOXHJcbiAgICAgKiAgTiAtIE4gPSBOXHJcbiAgICAgKiAgTiAtIEkgPSBOXHJcbiAgICAgKiAgSSAtIG4gPSBJXHJcbiAgICAgKiAgSSAtIDAgPSBJXHJcbiAgICAgKiAgSSAtIE4gPSBOXHJcbiAgICAgKiAgSSAtIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbWludXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubWludXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4geGMgPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih5YyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgcmV0dXJuIHljWzBdID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDpcclxuXHJcbiAgICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxyXG4gICAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcblxyXG4gICAgICAgIGlmICh4TFR5ID0gYSA8IDApIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgICBmb3IgKGIgPSBhOyBiLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50cyBlcXVhbC4gQ2hlY2sgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICAgICAgaiA9ICh4TFR5ID0gKGEgPSB4Yy5sZW5ndGgpIDwgKGIgPSB5Yy5sZW5ndGgpKSA/IGEgOiBiO1xyXG5cclxuICAgICAgICBmb3IgKGEgPSBiID0gMDsgYiA8IGo7IGIrKykge1xyXG5cclxuICAgICAgICAgIGlmICh4Y1tiXSAhPSB5Y1tiXSkge1xyXG4gICAgICAgICAgICB4TFR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoeExUeSkgdCA9IHhjLCB4YyA9IHljLCB5YyA9IHQsIHkucyA9IC15LnM7XHJcblxyXG4gICAgICBiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zIHRvIHhjIGlmIHNob3J0ZXIuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIHplcm9zIHRvIHljIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Qgb25seSBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXHJcbiAgICAgIGlmIChiID4gMCkgZm9yICg7IGItLTsgeGNbaSsrXSA9IDApO1xyXG4gICAgICBiID0gQkFTRSAtIDE7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB5YyBmcm9tIHhjLlxyXG4gICAgICBmb3IgKDsgaiA+IGE7KSB7XHJcblxyXG4gICAgICAgIGlmICh4Y1stLWpdIDwgeWNbal0pIHtcclxuICAgICAgICAgIGZvciAoaSA9IGo7IGkgJiYgIXhjWy0taV07IHhjW2ldID0gYik7XHJcbiAgICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgICAgeGNbal0gKz0gQkFTRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICBmb3IgKDsgeGNbMF0gPT0gMDsgeGMuc3BsaWNlKDAsIDEpLCAtLXllKTtcclxuXHJcbiAgICAgIC8vIFplcm8/XHJcbiAgICAgIGlmICgheGNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXHJcbiAgICAgICAgLy8gbiAtIG4gPSArMCAgYnV0ICBuIC0gbiA9IC0wICB3aGVuIHJvdW5kaW5nIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAgIHkucyA9IFJPVU5ESU5HX01PREUgPT0gMyA/IC0xIDogMTtcclxuICAgICAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIEluZmluaXR5IGFzICt4IC0gK3kgIT0gSW5maW5pdHkgJiYgLXggLSAteSAhPSBJbmZpbml0eVxyXG4gICAgICAvLyBmb3IgZmluaXRlIHggYW5kIHkuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgIG4gJSAwID0gIE5cclxuICAgICAqICAgbiAlIE4gPSAgTlxyXG4gICAgICogICBuICUgSSA9ICBuXHJcbiAgICAgKiAgIDAgJSBuID0gIDBcclxuICAgICAqICAtMCAlIG4gPSAtMFxyXG4gICAgICogICAwICUgMCA9ICBOXHJcbiAgICAgKiAgIDAgJSBOID0gIE5cclxuICAgICAqICAgMCAlIEkgPSAgMFxyXG4gICAgICogICBOICUgbiA9ICBOXHJcbiAgICAgKiAgIE4gJSAwID0gIE5cclxuICAgICAqICAgTiAlIE4gPSAgTlxyXG4gICAgICogICBOICUgSSA9ICBOXHJcbiAgICAgKiAgIEkgJSBuID0gIE5cclxuICAgICAqICAgSSAlIDAgPSAgTlxyXG4gICAgICogICBJICUgTiA9ICBOXHJcbiAgICAgKiAgIEkgJSBJID0gIE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtb2R1bG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgTU9EVUxPX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgcSwgcyxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIEluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgemVyby5cclxuICAgICAgaWYgKCF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIEluZmluaXR5IG9yIHggaXMgemVyby5cclxuICAgICAgfSBlbHNlIGlmICgheS5jIHx8IHguYyAmJiAheC5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChNT0RVTE9fTU9ERSA9PSA5KSB7XHJcblxyXG4gICAgICAgIC8vIEV1Y2xpZGlhbiBkaXZpc2lvbjogcSA9IHNpZ24oeSkgKiBmbG9vcih4IC8gYWJzKHkpKVxyXG4gICAgICAgIC8vIHIgPSB4IC0gcXkgICAgd2hlcmUgIDAgPD0gciA8IGFicyh5KVxyXG4gICAgICAgIHMgPSB5LnM7XHJcbiAgICAgICAgeS5zID0gMTtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIDMpO1xyXG4gICAgICAgIHkucyA9IHM7XHJcbiAgICAgICAgcS5zICo9IHM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCBNT0RVTE9fTU9ERSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSB4Lm1pbnVzKHEudGltZXMoeSkpO1xyXG5cclxuICAgICAgLy8gVG8gbWF0Y2ggSmF2YVNjcmlwdCAlLCBlbnN1cmUgc2lnbiBvZiB6ZXJvIGlzIHNpZ24gb2YgZGl2aWRlbmQuXHJcbiAgICAgIGlmICgheS5jWzBdICYmIE1PRFVMT19NT0RFID09IDEpIHkucyA9IHgucztcclxuXHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICogMCA9IDBcclxuICAgICAqICBuICogTiA9IE5cclxuICAgICAqICBuICogSSA9IElcclxuICAgICAqICAwICogbiA9IDBcclxuICAgICAqICAwICogMCA9IDBcclxuICAgICAqICAwICogTiA9IE5cclxuICAgICAqICAwICogSSA9IE5cclxuICAgICAqICBOICogbiA9IE5cclxuICAgICAqICBOICogMCA9IE5cclxuICAgICAqICBOICogTiA9IE5cclxuICAgICAqICBOICogSSA9IE5cclxuICAgICAqICBJICogbiA9IElcclxuICAgICAqICBJICogMCA9IE5cclxuICAgICAqICBJICogTiA9IE5cclxuICAgICAqICBJICogSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZVxyXG4gICAgICogb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm11bHRpcGxpZWRCeSA9IFAudGltZXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgYywgZSwgaSwgaiwgaywgbSwgeGNMLCB4bG8sIHhoaSwgeWNMLCB5bG8sIHloaSwgemMsXHJcbiAgICAgICAgYmFzZSwgc3FydEJhc2UsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSAoeSA9IG5ldyBCaWdOdW1iZXIoeSwgYikpLmM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgICAgaWYgKCF4YyB8fCAheWMgfHwgIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4sIG9yIG9uZSBpcyAwIGFuZCB0aGUgb3RoZXIgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4LnMgfHwgIXkucyB8fCB4YyAmJiAheGNbMF0gJiYgIXljIHx8IHljICYmICF5Y1swXSAmJiAheGMpIHtcclxuICAgICAgICAgIHkuYyA9IHkuZSA9IHkucyA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIGlzIMKxSW5maW5pdHkuXHJcbiAgICAgICAgICBpZiAoIXhjIHx8ICF5Yykge1xyXG4gICAgICAgICAgICB5LmMgPSB5LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgZWl0aGVyIGlzIMKxMC5cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgICAgeS5lID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICB5LnMgKj0geC5zO1xyXG4gICAgICB4Y0wgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSB4YyBwb2ludHMgdG8gbG9uZ2VyIGFycmF5IGFuZCB4Y0wgdG8gaXRzIGxlbmd0aC5cclxuICAgICAgaWYgKHhjTCA8IHljTCkgemMgPSB4YywgeGMgPSB5YywgeWMgPSB6YywgaSA9IHhjTCwgeGNMID0geWNMLCB5Y0wgPSBpO1xyXG5cclxuICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApKTtcclxuXHJcbiAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICAgIGZvciAoaSA9IHljTDsgLS1pID49IDA7KSB7XHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgICAgZm9yIChrID0geGNMLCBqID0gaSArIGs7IGogPiBpOykge1xyXG4gICAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgICBtID0geWhpICogeGxvICsgeGhpICogeWxvO1xyXG4gICAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgICAgYyA9ICh4bG8gLyBiYXNlIHwgMCkgKyAobSAvIHNxcnRCYXNlIHwgMCkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHpjW2pdID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGMpIHtcclxuICAgICAgICArK2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHpjLCBlKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBuZWdhdGVkLFxyXG4gICAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAgICovXHJcbiAgICBQLm5lZ2F0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgKiAgbiArIE4gPSBOXHJcbiAgICAgKiAgbiArIEkgPSBJXHJcbiAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgKiAgMCArIDAgPSAwXHJcbiAgICAgKiAgMCArIE4gPSBOXHJcbiAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgKiAgTiArIG4gPSBOXHJcbiAgICAgKiAgTiArIDAgPSBOXHJcbiAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgKiAgTiArIEkgPSBOXHJcbiAgICAgKiAgSSArIG4gPSBJXHJcbiAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgKiAgSSArIE4gPSBOXHJcbiAgICAgKiAgSSArIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBuZXcgQmlnTnVtYmVyKGEgLyAwKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6IGEgKiAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG4gICAgICAgIGlmIChhID4gMCkge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgZm9yICg7IGEtLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYSA9IHhjLmxlbmd0aDtcclxuICAgICAgYiA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgICAgaWYgKGEgLSBiIDwgMCkgdCA9IHljLCB5YyA9IHhjLCB4YyA9IHQsIGIgPSBhO1xyXG5cclxuICAgICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICAgIGZvciAoYSA9IDA7IGI7KSB7XHJcbiAgICAgICAgYSA9ICh4Y1stLWJdID0geGNbYl0gKyB5Y1tiXSArIGEpIC8gQkFTRSB8IDA7XHJcbiAgICAgICAgeGNbYl0gPSBCQVNFID09PSB4Y1tiXSA/IDAgOiB4Y1tiXSAlIEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgeGMgPSBbYV0uY29uY2F0KHhjKTtcclxuICAgICAgICArK3llO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIHNkIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZlxyXG4gICAgICogdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqIElmIHNkIGlzIHRydWUgaW5jbHVkZSBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGNvdW50LlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgc2QgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBzZCB7bnVtYmVyfGJvb2xlYW59IG51bWJlcjogc2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IHdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKHNkICE9IG51bGwgJiYgc2QgIT09ICEhc2QpIHtcclxuICAgICAgICBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgc2QsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICB2ID0gYy5sZW5ndGggLSAxO1xyXG4gICAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkge1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICh2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgbisrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNkICYmIHguZSArIDEgPiBuKSBuID0geC5lICsgMTtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHNoaWZ0ZWQgYnkgayBwbGFjZXNcclxuICAgICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cclxuICAgICAqXHJcbiAgICAgKiBrIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfU0FGRV9JTlRFR0VSIHRvIE1BWF9TQUZFX0lOVEVHRVIgaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7a30nXHJcbiAgICAgKi9cclxuICAgIFAuc2hpZnRlZEJ5ID0gZnVuY3Rpb24gKGspIHtcclxuICAgICAgaW50Q2hlY2soaywgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpO1xyXG4gICAgICByZXR1cm4gdGhpcy50aW1lcygnMWUnICsgayk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIHNxcnQoLW4pID0gIE5cclxuICAgICAqICBzcXJ0KE4pID0gIE5cclxuICAgICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICAgKiAgc3FydChJKSA9ICBJXHJcbiAgICAgKiAgc3FydCgwKSA9ICAwXHJcbiAgICAgKiAgc3FydCgtMCkgPSAtMFxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlcixcclxuICAgICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBtLCBuLCByLCByZXAsIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYyA9IHguYyxcclxuICAgICAgICBzID0geC5zLFxyXG4gICAgICAgIGUgPSB4LmUsXHJcbiAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xyXG5cclxuICAgICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICAgIGlmIChzICE9PSAxIHx8ICFjIHx8ICFjWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIXMgfHwgcyA8IDAgJiYgKCFjIHx8IGNbMF0pID8gTmFOIDogYyA/IHggOiAxIC8gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgICAgIHMgPSBNYXRoLnNxcnQoK3ZhbHVlT2YoeCkpO1xyXG5cclxuICAgICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgICAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XHJcbiAgICAgICAgbiA9IGNvZWZmVG9TdHJpbmcoYyk7XHJcbiAgICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgICBzID0gTWF0aC5zcXJ0KCtuKTtcclxuICAgICAgICBlID0gYml0Rmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICAgIG4gPSAnMWUnICsgZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihzICsgJycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgemVyby5cclxuICAgICAgLy8gciBjb3VsZCBiZSB6ZXJvIGlmIE1JTl9FWFAgaXMgY2hhbmdlZCBhZnRlciB0aGUgdGhpcyB2YWx1ZSB3YXMgY3JlYXRlZC5cclxuICAgICAgLy8gVGhpcyB3b3VsZCBjYXVzZSBhIGRpdmlzaW9uIGJ5IHplcm8gKHgvdCkgYW5kIGhlbmNlIEluZmluaXR5IGJlbG93LCB3aGljaCB3b3VsZCBjYXVzZVxyXG4gICAgICAvLyBjb2VmZlRvU3RyaW5nIHRvIHRocm93LlxyXG4gICAgICBpZiAoci5jWzBdKSB7XHJcbiAgICAgICAgZSA9IHIuZTtcclxuICAgICAgICBzID0gZSArIGRwO1xyXG4gICAgICAgIGlmIChzIDwgMykgcyA9IDA7XHJcblxyXG4gICAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICAgICAgICBmb3IgKDsgOykge1xyXG4gICAgICAgICAgdCA9IHI7XHJcbiAgICAgICAgICByID0gaGFsZi50aW1lcyh0LnBsdXMoZGl2KHgsIHQsIGRwLCAxKSkpO1xyXG5cclxuICAgICAgICAgIGlmIChjb2VmZlRvU3RyaW5nKHQuYykuc2xpY2UoMCwgcykgPT09IChuID0gY29lZmZUb1N0cmluZyhyLmMpKS5zbGljZSgwLCBzKSkge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxyXG4gICAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tID4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICBpZiAoci5lIDwgZSkgLS1zO1xyXG4gICAgICAgICAgICBuID0gbi5zbGljZShzIC0gMywgcyArIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICAgIHJvdW5kKHQsIHQuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgZHAgKz0gNDtcclxuICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XHJcbiAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHArKztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwID0gZHAgKyB0aGlzLmUgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZvcm1hdHRpbmcgb2JqZWN0IG1heSBjb250YWluIHNvbWUgb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIHNob3duIGJlbG93LlxyXG4gICAgICpcclxuICAgICAqIEZPUk1BVCA9IHtcclxuICAgICAqICAgcHJlZml4OiAnJyxcclxuICAgICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICogICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgKiAgIHN1ZmZpeDogJydcclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICogW2Zvcm1hdF0ge29iamVjdH0gRm9ybWF0dGluZyBvcHRpb25zLiBTZWUgRk9STUFUIHBiamVjdCBhYm92ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCBub3QgYW4gb2JqZWN0OiB7Zm9ybWF0fSdcclxuICAgICAqL1xyXG4gICAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uIChkcCwgcm0sIGZvcm1hdCkge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGRwICE9IG51bGwgJiYgcm0gJiYgdHlwZW9mIHJtID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICAgIHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRwICYmIHR5cGVvZiBkcCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgICBkcCA9IHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCBub3QgYW4gb2JqZWN0OiAnICsgZm9ybWF0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgICBpZiAoeC5jKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgIGcxID0gK2Zvcm1hdC5ncm91cFNpemUsXHJcbiAgICAgICAgICBnMiA9ICtmb3JtYXQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChnMikgaSA9IGcxLCBnMSA9IGcyLCBnMiA9IGksIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICBpZiAoZzEgPiAwICYmIGxlbiA+IDApIHtcclxuICAgICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gZzEpIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKGksIGcxKTtcclxuICAgICAgICAgIGlmIChnMiA+IDApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyksXHJcbiAgICAgICAgICAgJyQmJyArIChmb3JtYXQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB8fCAnJykpXHJcbiAgICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICAgKiBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICAgKiB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAgICpcclxuICAgICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX0gOiB7bWR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGV4cCwgbiwgbjAsIG4xLCBxLCByLCBzLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jO1xyXG5cclxuICAgICAgaWYgKG1kICE9IG51bGwpIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAgIC8vIFRocm93IGlmIG1kIGlzIGxlc3MgdGhhbiBvbmUgb3IgaXMgbm90IGFuIGludGVnZXIsIHVubGVzcyBpdCBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkgJiYgKG4uYyB8fCBuLnMgIT09IDEpIHx8IG4ubHQoT05FKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50ICcgK1xyXG4gICAgICAgICAgICAgIChuLmlzSW50ZWdlcigpID8gJ291dCBvZiByYW5nZTogJyA6ICdub3QgYW4gaW50ZWdlcjogJykgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgheGMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG5cclxuICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgICBkLmNbMF0gPSBQT1dTX1RFTlsoZXhwID0gZSAlIExPR19CQVNFKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cF07XHJcbiAgICAgIG1kID0gIW1kIHx8IG4uY29tcGFyZWRUbyhkKSA+IDAgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuXHJcbiAgICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyA7KSAge1xyXG4gICAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgICBpZiAoZDIuY29tcGFyZWRUbyhtZCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgICAgZDAgPSBkMTtcclxuICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyID0gbjEpKTtcclxuICAgICAgICBuMCA9IGQyO1xyXG4gICAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIgPSBkKSk7XHJcbiAgICAgICAgbiA9IGQyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkMiA9IGRpdihtZC5taW51cyhkMCksIGQxLCAwLCAxKTtcclxuICAgICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgICAgZSA9IGUgKiAyO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgICByID0gZGl2KG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkuY29tcGFyZWRUbyhcclxuICAgICAgICAgIGRpdihuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICt2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBzZCwgcm0sIDIpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAqL1xyXG4gICAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgcyA9IG4ucyxcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICBzdHIgPSAnSW5maW5pdHknO1xyXG4gICAgICAgICAgaWYgKHMgPCAwKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0ciA9ICdOYU4nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKGNvZWZmVG9TdHJpbmcobi5jKSwgZSlcclxuICAgICAgICAgICA6IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAxMCkge1xyXG4gICAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIERFQ0lNQUxfUExBQ0VTICsgZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgbi5lLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcbiAgICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZSh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpLCAxMCwgYiwgcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocyA8IDAgJiYgbi5jWzBdKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFzIHRvU3RyaW5nLCBidXQgZG8gbm90IGFjY2VwdCBhIGJhc2UgYXJndW1lbnQsIGFuZCBpbmNsdWRlIHRoZSBtaW51cyBzaWduIGZvclxyXG4gICAgICogbmVnYXRpdmUgemVyby5cclxuICAgICAqL1xyXG4gICAgUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgUC5faXNCaWdOdW1iZXIgPSB0cnVlO1xyXG5cclxuICAgIGlmIChoYXNTeW1ib2wpIHtcclxuICAgICAgUFtTeW1ib2wudG9TdHJpbmdUYWddID0gJ0JpZ051bWJlcic7XHJcblxyXG4gICAgICAvLyBOb2RlLmpzIHYxMC4xMi4wK1xyXG4gICAgICBQW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gUC52YWx1ZU9mO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWdPYmplY3QgIT0gbnVsbCkgQmlnTnVtYmVyLnNldChjb25maWdPYmplY3QpO1xyXG5cclxuICAgIHJldHVybiBCaWdOdW1iZXI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUFJJVkFURSBIRUxQRVIgRlVOQ1RJT05TXHJcblxyXG4gIC8vIFRoZXNlIGZ1bmN0aW9ucyBkb24ndCBuZWVkIGFjY2VzcyB0byB2YXJpYWJsZXMsXHJcbiAgLy8gZS5nLiBERUNJTUFMX1BMQUNFUywgaW4gdGhlIHNjb3BlIG9mIHRoZSBgY2xvbmVgIGZ1bmN0aW9uIGFib3ZlLlxyXG5cclxuXHJcbiAgZnVuY3Rpb24gYml0Rmxvb3Iobikge1xyXG4gICAgdmFyIGkgPSBuIHwgMDtcclxuICAgIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFJldHVybiBhIGNvZWZmaWNpZW50IGFycmF5IGFzIGEgc3RyaW5nIG9mIGJhc2UgMTAgZGlnaXRzLlxyXG4gIGZ1bmN0aW9uIGNvZWZmVG9TdHJpbmcoYSkge1xyXG4gICAgdmFyIHMsIHosXHJcbiAgICAgIGkgPSAxLFxyXG4gICAgICBqID0gYS5sZW5ndGgsXHJcbiAgICAgIHIgPSBhWzBdICsgJyc7XHJcblxyXG4gICAgZm9yICg7IGkgPCBqOykge1xyXG4gICAgICBzID0gYVtpKytdICsgJyc7XHJcbiAgICAgIHogPSBMT0dfQkFTRSAtIHMubGVuZ3RoO1xyXG4gICAgICBmb3IgKDsgei0tOyBzID0gJzAnICsgcyk7XHJcbiAgICAgIHIgKz0gcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGogPSByLmxlbmd0aDsgci5jaGFyQ29kZUF0KC0taikgPT09IDQ4Oyk7XHJcblxyXG4gICAgcmV0dXJuIHIuc2xpY2UoMCwgaiArIDEgfHwgMSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ29tcGFyZSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVycyB4IGFuZCB5LlxyXG4gIGZ1bmN0aW9uIGNvbXBhcmUoeCwgeSkge1xyXG4gICAgdmFyIGEsIGIsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYyxcclxuICAgICAgaSA9IHgucyxcclxuICAgICAgaiA9IHkucyxcclxuICAgICAgayA9IHguZSxcclxuICAgICAgbCA9IHkuZTtcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgaWYgKCFpIHx8ICFqKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBhID0geGMgJiYgIXhjWzBdO1xyXG4gICAgYiA9IHljICYmICF5Y1swXTtcclxuXHJcbiAgICAvLyBFaXRoZXIgemVybz9cclxuICAgIGlmIChhIHx8IGIpIHJldHVybiBhID8gYiA/IDAgOiAtaiA6IGk7XHJcblxyXG4gICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgaWYgKGkgIT0gaikgcmV0dXJuIGk7XHJcblxyXG4gICAgYSA9IGkgPCAwO1xyXG4gICAgYiA9IGsgPT0gbDtcclxuXHJcbiAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIGIgPyAwIDogIXhjIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICAgIGlmICghYikgcmV0dXJuIGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICBqID0gKGsgPSB4Yy5sZW5ndGgpIDwgKGwgPSB5Yy5sZW5ndGgpID8gayA6IGw7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIGlmICh4Y1tpXSAhPSB5Y1tpXSkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICAgIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ2hlY2sgdGhhdCBuIGlzIGEgcHJpbWl0aXZlIG51bWJlciwgYW4gaW50ZWdlciwgYW5kIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaW50Q2hlY2sobiwgbWluLCBtYXgsIG5hbWUpIHtcclxuICAgIGlmIChuIDwgbWluIHx8IG4gPiBtYXggfHwgbiAhPT0gbWF0aGZsb29yKG4pKSB7XHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAobmFtZSB8fCAnQXJndW1lbnQnKSArICh0eXBlb2YgbiA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICA/IG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlOiAnIDogJyBub3QgYW4gaW50ZWdlcjogJ1xyXG4gICAgICAgICA6ICcgbm90IGEgcHJpbWl0aXZlIG51bWJlcjogJykgKyBTdHJpbmcobikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIEFzc3VtZXMgZmluaXRlIG4uXHJcbiAgZnVuY3Rpb24gaXNPZGQobikge1xyXG4gICAgdmFyIGsgPSBuLmMubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiBiaXRGbG9vcihuLmUgLyBMT0dfQkFTRSkgPT0gayAmJiBuLmNba10gJSAyICE9IDA7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9FeHBvbmVudGlhbChzdHIsIGUpIHtcclxuICAgIHJldHVybiAoc3RyLmxlbmd0aCA+IDEgPyBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpIDogc3RyKSArXHJcbiAgICAgKGUgPCAwID8gJ2UnIDogJ2UrJykgKyBlO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRml4ZWRQb2ludChzdHIsIGUsIHopIHtcclxuICAgIHZhciBsZW4sIHpzO1xyXG5cclxuICAgIC8vIE5lZ2F0aXZlIGV4cG9uZW50P1xyXG4gICAgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zLlxyXG4gICAgICBmb3IgKHpzID0geiArICcuJzsgKytlOyB6cyArPSB6KTtcclxuICAgICAgc3RyID0genMgKyBzdHI7XHJcblxyXG4gICAgLy8gUG9zaXRpdmUgZXhwb25lbnRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MuXHJcbiAgICAgIGlmICgrK2UgPiBsZW4pIHtcclxuICAgICAgICBmb3IgKHpzID0geiwgZSAtPSBsZW47IC0tZTsgenMgKz0geik7XHJcbiAgICAgICAgc3RyICs9IHpzO1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBsZW4pIHtcclxuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEVYUE9SVFxyXG5cclxuXHJcbiAgQmlnTnVtYmVyID0gY2xvbmUoKTtcclxuICBCaWdOdW1iZXJbJ2RlZmF1bHQnXSA9IEJpZ051bWJlci5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEFNRC5cclxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7IHJldHVybiBCaWdOdW1iZXI7IH0pO1xyXG5cclxuICAvLyBOb2RlLmpzIGFuZCBvdGhlciBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLlxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEJyb3dzZXIuXHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICghZ2xvYmFsT2JqZWN0KSB7XHJcbiAgICAgIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYgPyBzZWxmIDogd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIGdsb2JhbE9iamVjdC5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcbiAgfVxyXG59KSh0aGlzKTtcclxuIiwiIWZ1bmN0aW9uKHQsbil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24odCxuLGUsaSxvKXtmb3Iobj1uLnNwbGl0P24uc3BsaXQoXCIuXCIpOm4saT0wO2k8bi5sZW5ndGg7aSsrKXQ9dD90W25baV1dOm87cmV0dXJuIHQ9PT1vP2U6dH06XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LG4sZSxpLG8pe2ZvcihuPW4uc3BsaXQ/bi5zcGxpdChcIi5cIik6bixpPTA7aTxuLmxlbmd0aDtpKyspdD10P3RbbltpXV06bztyZXR1cm4gdD09PW8/ZTp0fX0pOnQuZGx2PWZ1bmN0aW9uKHQsbixlLGksbyl7Zm9yKG49bi5zcGxpdD9uLnNwbGl0KFwiLlwiKTpuLGk9MDtpPG4ubGVuZ3RoO2krKyl0PXQ/dFtuW2ldXTpvO3JldHVybiB0PT09bz9lOnR9fSh0aGlzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRsdi51bWQuanMubWFwXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwdWxsIChhKSB7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyAmJiBhLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbmd0aClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWFkKSB7XG4gICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwYXJ0aWFsIHNpbmsgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uY2UhXCIpXG4gICAgICB9XG5cbiAgICAgIC8vIEdyYWIgdGhlIHJlZmVyZW5jZSBhZnRlciB0aGUgY2hlY2ssIGJlY2F1c2UgaXQncyBhbHdheXMgYW4gYXJyYXkgbm93XG4gICAgICAvLyAoZW5naW5lcyBsaWtlIHRoYXQga2luZCBvZiBjb25zaXN0ZW5jeSkuXG4gICAgICB2YXIgcmVmID0gYXJnc1xuICAgICAgYXJncyA9IG51bGxcblxuICAgICAgLy8gUHJpb3JpdGl6ZSBjb21tb24gY2FzZSBvZiBzbWFsbCBudW1iZXIgb2YgcHVsbHMuXG4gICAgICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gcHVsbChyZWFkLCByZWZbMF0pXG4gICAgICBjYXNlIDI6IHJldHVybiBwdWxsKHJlYWQsIHJlZlswXSwgcmVmWzFdKVxuICAgICAgY2FzZSAzOiByZXR1cm4gcHVsbChyZWFkLCByZWZbMF0sIHJlZlsxXSwgcmVmWzJdKVxuICAgICAgY2FzZSA0OiByZXR1cm4gcHVsbChyZWFkLCByZWZbMF0sIHJlZlsxXSwgcmVmWzJdLCByZWZbM10pXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZWYudW5zaGlmdChyZWFkKVxuICAgICAgICByZXR1cm4gcHVsbC5hcHBseShudWxsLCByZWYpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlYWQgPSBhXG5cbiAgaWYgKHJlYWQgJiYgdHlwZW9mIHJlYWQuc291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVhZCA9IHJlYWQuc291cmNlXG4gIH1cblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHMgPSBhcmd1bWVudHNbaV1cbiAgICBpZiAodHlwZW9mIHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlYWQgPSBzKHJlYWQpXG4gICAgfSBlbHNlIGlmIChzICYmIHR5cGVvZiBzID09PSAnb2JqZWN0Jykge1xuICAgICAgcy5zaW5rKHJlYWQpXG4gICAgICByZWFkID0gcy5zb3VyY2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEtleSA9IHJlcXVpcmUoJ2ludGVyZmFjZS1kYXRhc3RvcmUnKS5LZXlcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ3JlcG86dmVyc2lvbicpXG5cbmNvbnN0IHZlcnNpb25LZXkgPSBuZXcgS2V5KCd2ZXJzaW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSAoc3RvcmUpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHZlcnNpb24gZmlsZSBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBib29sKX0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBleGlzdHMgKGNhbGxiYWNrKSB7XG4gICAgICBzdG9yZS5oYXModmVyc2lvbktleSwgY2FsbGJhY2spXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdmVyc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIG51bWJlcil9IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZ2V0IChjYWxsYmFjaykge1xuICAgICAgc3RvcmUuZ2V0KHZlcnNpb25LZXksIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCBwYXJzZUludChidWYudG9TdHJpbmcoKS50cmltKCksIDEwKSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZlcnNpb24gb2YgdGhlIHJlcG8sIHdyaXRpbmcgaXQgdG8gdGhlIHVuZGVybHlpbmcgc3RvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmVyc2lvblxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHNldCAodmVyc2lvbiwgY2FsbGJhY2spIHtcbiAgICAgIHN0b3JlLnB1dCh2ZXJzaW9uS2V5LCBCdWZmZXIuZnJvbShTdHJpbmcodmVyc2lvbikpLCBjYWxsYmFjaylcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoZSBjdXJyZW50IHZlcnNpb24sIGFuZCByZXR1cm4gYW4gZXJyb3Igb24gbWlzc21hdGNoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4cGVjdGVkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgY2hlY2sgKGV4cGVjdGVkLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5nZXQoKGVyciwgdmVyc2lvbikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuICAgICAgICBsb2coJ2NvbXBhcmluZyB2ZXJzaW9uOiAlcyBhbmQgJXMnLCB2ZXJzaW9uLCBleHBlY3RlZClcblxuICAgICAgICAvLyBWZXJzaW9uIDYgYW5kIDcgYXJlIHRoZSBzYW1lXG4gICAgICAgIC8vIFRPRE86IENsZWFuIHVwIHRoZSBjb21wYXRpYmlsaXR5IGxvZ2ljLiBSZXBvIGZlYXR1cmUgZGV0ZWN0aW9uIHdvdWxkIGJlIGlkZWFsLCBvciBhIGJldHRlciB2ZXJzaW9uIHNjaGVtYVxuICAgICAgICBjb25zdCBjb21wYXRpYmxlVmVyc2lvbiA9ICh2ZXJzaW9uID09PSA2ICYmIGV4cGVjdGVkID09PSA3KSB8fCAoZXhwZWN0ZWQgPT09IDYgJiYgdmVyc2lvbiA9PT0gNylcblxuICAgICAgICBpZiAodmVyc2lvbiAhPT0gZXhwZWN0ZWQgJiYgIWNvbXBhdGlibGVWZXJzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihgaXBmcyByZXBvIG5lZWRzIG1pZ3JhdGlvbjogZXhwZWN0ZWQgdmVyc2lvbiB2JHtleHBlY3RlZH0sIGZvdW5kIHZlcnNpb24gdiR7dmVyc2lvbn1gKSlcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjaygpXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEtleSA9IHJlcXVpcmUoJ2ludGVyZmFjZS1kYXRhc3RvcmUnKS5LZXlcblxuY29uc3QgYXBpRmlsZSA9IG5ldyBLZXkoJ2FwaScpXG5cbm1vZHVsZS5leHBvcnRzID0gKHN0b3JlKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgcmVwby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIE9iamVjdCl9IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZ2V0IChjYWxsYmFjaykge1xuICAgICAgc3RvcmUuZ2V0KGFwaUZpbGUsIChlcnIsIHZhbHVlKSA9PiBjYWxsYmFjayhlcnIsIHZhbHVlICYmIHZhbHVlLnRvU3RyaW5nKCkpKVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgcmVwby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIHRoZSBhcGkgYWRkcmVzcyB0byBiZSB3cml0dGVuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc2V0ICh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgIHN0b3JlLnB1dChhcGlGaWxlLCBCdWZmZXIuZnJvbSh2YWx1ZS50b1N0cmluZygpKSwgY2FsbGJhY2spXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFwaSBmaWxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBib29sKX0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBkZWxldGUgKGNhbGxiYWNrKSB7XG4gICAgICBzdG9yZS5kZWxldGUoYXBpRmlsZSwgY2FsbGJhY2spXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBlYWNoTGltaXQ7XG5cbnZhciBfZWFjaE9mID0gcmVxdWlyZSgnLi9lYWNoT2YnKTtcblxudmFyIF9lYWNoT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaE9mKTtcblxudmFyIF93aXRob3V0SW5kZXggPSByZXF1aXJlKCcuL2ludGVybmFsL3dpdGhvdXRJbmRleCcpO1xuXG52YXIgX3dpdGhvdXRJbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93aXRob3V0SW5kZXgpO1xuXG52YXIgX3dyYXBBc3luYyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvd3JhcEFzeW5jJyk7XG5cbnZhciBfd3JhcEFzeW5jMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dyYXBBc3luYyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQXBwbGllcyB0aGUgZnVuY3Rpb24gYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLCBpbiBwYXJhbGxlbC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIGFuIGl0ZW0gZnJvbSB0aGUgbGlzdCwgYW5kIGEgY2FsbGJhY2sgZm9yIHdoZW5cbiAqIGl0IGhhcyBmaW5pc2hlZC4gSWYgdGhlIGBpdGVyYXRlZWAgcGFzc2VzIGFuIGVycm9yIHRvIGl0cyBgY2FsbGJhY2tgLCB0aGVcbiAqIG1haW4gYGNhbGxiYWNrYCAoZm9yIHRoZSBgZWFjaGAgZnVuY3Rpb24pIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZVxuICogZXJyb3IuXG4gKlxuICogTm90ZSwgdGhhdCBzaW5jZSB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gcGFyYWxsZWwsXG4gKiB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIHdpbGwgY29tcGxldGUgaW4gb3JkZXIuXG4gKlxuICogQG5hbWUgZWFjaFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGZvckVhY2hcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG9cbiAqIGVhY2ggaXRlbSBpbiBgY29sbGAuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLlxuICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZmAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBhc3N1bWluZyBvcGVuRmlsZXMgaXMgYW4gYXJyYXkgb2YgZmlsZSBuYW1lcyBhbmQgc2F2ZUZpbGUgaXMgYSBmdW5jdGlvblxuICogLy8gdG8gc2F2ZSB0aGUgbW9kaWZpZWQgY29udGVudHMgb2YgdGhhdCBmaWxlOlxuICpcbiAqIGFzeW5jLmVhY2gob3BlbkZpbGVzLCBzYXZlRmlsZSwgZnVuY3Rpb24oZXJyKXtcbiAqICAgLy8gaWYgYW55IG9mIHRoZSBzYXZlcyBwcm9kdWNlZCBhbiBlcnJvciwgZXJyIHdvdWxkIGVxdWFsIHRoYXQgZXJyb3JcbiAqIH0pO1xuICpcbiAqIC8vIGFzc3VtaW5nIG9wZW5GaWxlcyBpcyBhbiBhcnJheSBvZiBmaWxlIG5hbWVzXG4gKiBhc3luYy5lYWNoKG9wZW5GaWxlcywgZnVuY3Rpb24oZmlsZSwgY2FsbGJhY2spIHtcbiAqXG4gKiAgICAgLy8gUGVyZm9ybSBvcGVyYXRpb24gb24gZmlsZSBoZXJlLlxuICogICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIGZpbGUgJyArIGZpbGUpO1xuICpcbiAqICAgICBpZiggZmlsZS5sZW5ndGggPiAzMiApIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIGZpbGUgbmFtZSBpcyB0b28gbG9uZycpO1xuICogICAgICAgY2FsbGJhY2soJ0ZpbGUgbmFtZSB0b28gbG9uZycpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAvLyBEbyB3b3JrIHRvIHByb2Nlc3MgZmlsZSBoZXJlXG4gKiAgICAgICBjb25zb2xlLmxvZygnRmlsZSBwcm9jZXNzZWQnKTtcbiAqICAgICAgIGNhbGxiYWNrKCk7XG4gKiAgICAgfVxuICogfSwgZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgLy8gaWYgYW55IG9mIHRoZSBmaWxlIHByb2Nlc3NpbmcgcHJvZHVjZWQgYW4gZXJyb3IsIGVyciB3b3VsZCBlcXVhbCB0aGF0IGVycm9yXG4gKiAgICAgaWYoIGVyciApIHtcbiAqICAgICAgIC8vIE9uZSBvZiB0aGUgaXRlcmF0aW9ucyBwcm9kdWNlZCBhbiBlcnJvci5cbiAqICAgICAgIC8vIEFsbCBwcm9jZXNzaW5nIHdpbGwgbm93IHN0b3AuXG4gKiAgICAgICBjb25zb2xlLmxvZygnQSBmaWxlIGZhaWxlZCB0byBwcm9jZXNzJyk7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCBzdWNjZXNzZnVsbHknKTtcbiAqICAgICB9XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZWFjaExpbWl0KGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAoMCwgX2VhY2hPZjIuZGVmYXVsdCkoY29sbCwgKDAsIF93aXRob3V0SW5kZXgyLmRlZmF1bHQpKCgwLCBfd3JhcEFzeW5jMi5kZWZhdWx0KShpdGVyYXRlZSkpLCBjYWxsYmFjayk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCdcblxudmFyIGRyYWluID0gcmVxdWlyZSgnLi9kcmFpbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVkdWNlIChyZWR1Y2VyLCBhY2MsIGNiICkge1xuICBpZighY2IpIGNiID0gYWNjLCBhY2MgPSBudWxsXG4gIHZhciBzaW5rID0gZHJhaW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBhY2MgPSByZWR1Y2VyKGFjYywgZGF0YSlcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGNiKGVyciwgYWNjKVxuICB9KVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgc291cmNlKG51bGwsIGZ1bmN0aW9uIChlbmQsIGRhdGEpIHtcbiAgICAgICAgLy9pZiBlbmRlZCBpbW1lZGlhdGVseSwgYW5kIG5vIGluaXRpYWwuLi5cbiAgICAgICAgaWYoZW5kKSByZXR1cm4gY2IoZW5kID09PSB0cnVlID8gbnVsbCA6IGVuZClcbiAgICAgICAgYWNjID0gZGF0YTsgc2luayhzb3VyY2UpXG4gICAgICB9KVxuICAgIH1cbiAgZWxzZVxuICAgIHJldHVybiBzaW5rXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBzZXJpZXM7XG5cbnZhciBfcGFyYWxsZWwgPSByZXF1aXJlKCcuL2ludGVybmFsL3BhcmFsbGVsJyk7XG5cbnZhciBfcGFyYWxsZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyYWxsZWwpO1xuXG52YXIgX2VhY2hPZlNlcmllcyA9IHJlcXVpcmUoJy4vZWFjaE9mU2VyaWVzJyk7XG5cbnZhciBfZWFjaE9mU2VyaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2hPZlNlcmllcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogUnVuIHRoZSBmdW5jdGlvbnMgaW4gdGhlIGB0YXNrc2AgY29sbGVjdGlvbiBpbiBzZXJpZXMsIGVhY2ggb25lIHJ1bm5pbmcgb25jZVxuICogdGhlIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIElmIGFueSBmdW5jdGlvbnMgaW4gdGhlIHNlcmllcyBwYXNzIGFuXG4gKiBlcnJvciB0byBpdHMgY2FsbGJhY2ssIG5vIG1vcmUgZnVuY3Rpb25zIGFyZSBydW4sIGFuZCBgY2FsbGJhY2tgIGlzXG4gKiBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGVycm9yLiBPdGhlcndpc2UsIGBjYWxsYmFja2BcbiAqIHJlY2VpdmVzIGFuIGFycmF5IG9mIHJlc3VsdHMgd2hlbiBgdGFza3NgIGhhdmUgY29tcGxldGVkLlxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gdXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBFYWNoIHByb3BlcnR5IHdpbGxcbiAqIGJlIHJ1biBhcyBhIGZ1bmN0aW9uLCBhbmQgdGhlIHJlc3VsdHMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZpbmFsIGBjYWxsYmFja2BcbiAqIGFzIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBUaGlzIGNhbiBiZSBhIG1vcmUgcmVhZGFibGUgd2F5IG9mIGhhbmRsaW5nXG4gKiAgcmVzdWx0cyBmcm9tIHtAbGluayBhc3luYy5zZXJpZXN9LlxuICpcbiAqICoqTm90ZSoqIHRoYXQgd2hpbGUgbWFueSBpbXBsZW1lbnRhdGlvbnMgcHJlc2VydmUgdGhlIG9yZGVyIG9mIG9iamVjdFxuICogcHJvcGVydGllcywgdGhlIFtFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb25dKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy04LjYpXG4gKiBleHBsaWNpdGx5IHN0YXRlcyB0aGF0XG4gKlxuICogPiBUaGUgbWVjaGFuaWNzIGFuZCBvcmRlciBvZiBlbnVtZXJhdGluZyB0aGUgcHJvcGVydGllcyBpcyBub3Qgc3BlY2lmaWVkLlxuICpcbiAqIFNvIGlmIHlvdSByZWx5IG9uIHRoZSBvcmRlciBpbiB3aGljaCB5b3VyIHNlcmllcyBvZiBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkLFxuICogYW5kIHdhbnQgdGhpcyB0byB3b3JrIG9uIGFsbCBwbGF0Zm9ybXMsIGNvbnNpZGVyIHVzaW5nIGFuIGFycmF5LlxuICpcbiAqIEBuYW1lIHNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIGNvbnRhaW5pbmdcbiAqIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259IHRvIHJ1biBpbiBzZXJpZXMuXG4gKiBFYWNoIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2Ygb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFsbCB0aGVcbiAqIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZC4gVGhpcyBmdW5jdGlvbiBnZXRzIGEgcmVzdWx0cyBhcnJheSAob3Igb2JqZWN0KVxuICogY29udGFpbmluZyBhbGwgdGhlIHJlc3VsdCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBgdGFza2AgY2FsbGJhY2tzLiBJbnZva2VkXG4gKiB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAZXhhbXBsZVxuICogYXN5bmMuc2VyaWVzKFtcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBkbyBzb21lIHN0dWZmIC4uLlxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBkbyBzb21lIG1vcmUgc3R1ZmYgLi4uXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICB9XG4gKiBdLFxuICogLy8gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGVxdWFsIHRvIFsnb25lJywgJ3R3byddXG4gKiB9KTtcbiAqXG4gKiBhc3luYy5zZXJpZXMoe1xuICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjayl7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAyKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyBlcXVhbCB0bzoge29uZTogMSwgdHdvOiAyfVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHNlcmllcyh0YXNrcywgY2FsbGJhY2spIHtcbiAgKDAsIF9wYXJhbGxlbDIuZGVmYXVsdCkoX2VhY2hPZlNlcmllczIuZGVmYXVsdCwgdGFza3MsIGNhbGxiYWNrKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBLZXkgPSByZXF1aXJlKCdpbnRlcmZhY2UtZGF0YXN0b3JlJykuS2V5XG5jb25zdCBzb3J0S2V5cyA9IHJlcXVpcmUoJ3NvcnQta2V5cycpXG5cbmNvbnN0IHNwZWNLZXkgPSBuZXcgS2V5KCdkYXRhc3RvcmVfc3BlYycpXG5cbm1vZHVsZS5leHBvcnRzID0gKHN0b3JlKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBkYXRhc3RvcmUgc3BlYyBmaWxlIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIGJvb2wpfSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGV4aXN0cyAoY2FsbGJhY2spIHtcbiAgICAgIHN0b3JlLmhhcyhzcGVjS2V5LCBjYWxsYmFjaylcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBkYXRhc3RvcmUgc3BlYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIG51bWJlcil9IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZ2V0IChjYWxsYmFjaykge1xuICAgICAgc3RvcmUuZ2V0KHNwZWNLZXksIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCBKU09OLnBhcnNlKGJ1Zi50b1N0cmluZygpKSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGRhdGFzdG9yZSBzcGVjIG9mIHRoZSByZXBvLCB3cml0aW5nIGl0IHRvIHRoZSB1bmRlcmx5aW5nIHN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNwZWNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzZXQgKHNwZWMsIGNhbGxiYWNrKSB7XG4gICAgICBzdG9yZS5wdXQoc3BlY0tleSwgQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoc29ydEtleXMoc3BlYywgeyBkZWVwOiB0cnVlIH0pKSksIGNhbGxiYWNrKVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEtleSA9IHJlcXVpcmUoJ2ludGVyZmFjZS1kYXRhc3RvcmUnKS5LZXlcbmNvbnN0IHF1ZXVlID0gcmVxdWlyZSgnYXN5bmMvcXVldWUnKVxuY29uc3Qgd2F0ZXJmYWxsID0gcmVxdWlyZSgnYXN5bmMvd2F0ZXJmYWxsJylcbmNvbnN0IF9nZXQgPSByZXF1aXJlKCdkbHYnKVxuY29uc3QgX3NldCA9IHJlcXVpcmUoJ2p1c3Qtc2FmZS1zZXQnKVxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXG5cbmNvbnN0IGNvbmZpZ0tleSA9IG5ldyBLZXkoJ2NvbmZpZycpXG5cbm1vZHVsZS5leHBvcnRzID0gKHN0b3JlKSA9PiB7XG4gIGNvbnN0IHNldFF1ZXVlID0gcXVldWUoX2RvU2V0LCAxKVxuXG4gIGNvbnN0IGNvbmZpZ1N0b3JlID0ge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uIGZyb20gdGhlIHJlcG8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gdGhlIGNvbmZpZyBrZXkgdG8gZ2V0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgT2JqZWN0KX0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBnZXQgKGtleSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0ga2V5XG4gICAgICAgIGtleSA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAga2V5ID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgICBzdG9yZS5nZXQoY29uZmlnS2V5LCAoZXJyLCBlbmNvZGVkVmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKSB9XG5cbiAgICAgICAgbGV0IGNvbmZpZ1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoZW5jb2RlZFZhbHVlLnRvU3RyaW5nKCkpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgY29uZmlnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignS2V5ICcgKyBrZXkgKyAnIG11c3QgYmUgYSBzdHJpbmcuJykpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZSA9IF9nZXQoY29uZmlnLCBrZXksIG51bGwpXG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignS2V5ICcgKyBrZXkgKyAnIGRvZXMgbm90IGV4aXN0IGluIGNvbmZpZy4nKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHZhbHVlKVxuICAgICAgfSlcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uIGZvciB0aGlzIHJlcG8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gdGhlIGNvbmZpZyBrZXkgdG8gYmUgd3JpdHRlblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIHRoZSBjb25maWcgdmFsdWUgdG8gYmUgd3JpdHRlblxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHNldCAoa2V5LCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZVxuICAgICAgICB2YWx1ZSA9IGtleVxuICAgICAgICBrZXkgPSB1bmRlZmluZWRcbiAgICAgIH0gZWxzZSBpZiAoIWtleSB8fCB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdJbnZhbGlkIGtleSB0eXBlJykpXG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSB0eXBlJykpXG4gICAgICB9XG5cbiAgICAgIHNldFF1ZXVlLnB1c2goe1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9LCBjYWxsYmFjaylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBjb25maWcgZmlsZSBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBib29sKX0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBleGlzdHMgKGNhbGxiYWNrKSB7XG4gICAgICBzdG9yZS5oYXMoY29uZmlnS2V5LCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnU3RvcmVcblxuICBmdW5jdGlvbiBfZG9TZXQgKG0sIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qga2V5ID0gbS5rZXlcbiAgICBjb25zdCB2YWx1ZSA9IG0udmFsdWVcbiAgICBpZiAoa2V5KSB7XG4gICAgICB3YXRlcmZhbGwoXG4gICAgICAgIFtcbiAgICAgICAgICAoY2IpID0+IGNvbmZpZ1N0b3JlLmdldChjYiksXG4gICAgICAgICAgKGNvbmZpZywgY2IpID0+IHtcbiAgICAgICAgICAgIF9zZXQoY29uZmlnLCBrZXksIHZhbHVlKVxuICAgICAgICAgICAgY2IobnVsbCwgY29uZmlnKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgX3NhdmVBbGxcbiAgICAgICAgXSxcbiAgICAgICAgY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIF9zYXZlQWxsKHZhbHVlLCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfc2F2ZUFsbCAoY29uZmlnLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KGNvbmZpZywgbnVsbCwgMikpXG4gICAgc3RvcmUucHV0KGNvbmZpZ0tleSwgYnVmLCBjYWxsYmFjaylcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvcmUgPSByZXF1aXJlKCdkYXRhc3RvcmUtY29yZScpXG5jb25zdCBTaGFyZGluZ1N0b3JlID0gY29yZS5TaGFyZGluZ0RhdGFzdG9yZVxuY29uc3QgS2V5ID0gcmVxdWlyZSgnaW50ZXJmYWNlLWRhdGFzdG9yZScpLktleVxuY29uc3QgYmFzZTMyID0gcmVxdWlyZSgnYmFzZTMyLmpzJylcbmNvbnN0IEJsb2NrID0gcmVxdWlyZSgnaXBmcy1ibG9jaycpXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuY29uc3QgcmVqZWN0ID0gcmVxdWlyZSgnYXN5bmMvcmVqZWN0JylcbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKVxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3B1bGwnKVxuY29uc3QgY29sbGVjdCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3NpbmtzL2NvbGxlY3QnKVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHJhdyBidWZmZXIgdG8gYSBiYXNlMzIgZW5jb2RlZCBrZXkuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHJhd0tleVxuICogQHJldHVybnMge0tleX1cbiAqL1xuY29uc3Qga2V5RnJvbUJ1ZmZlciA9IChyYXdLZXkpID0+IHtcbiAgY29uc3QgZW5jID0gbmV3IGJhc2UzMi5FbmNvZGVyKClcbiAgcmV0dXJuIG5ldyBLZXkoJy8nICsgZW5jLndyaXRlKHJhd0tleSkuZmluYWxpemUoKSwgZmFsc2UpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgY2lkIHRvIHRoZSBhcHByb3ByaWF0ZSBkYXRhc3RvcmUga2V5LlxuICpcbiAqIEBwYXJhbSB7Q0lEfSBjaWRcbiAqIEByZXR1cm5zIHtLZXl9XG4gKi9cbmNvbnN0IGNpZFRvRHNLZXkgPSAoY2lkKSA9PiB7XG4gIHJldHVybiBrZXlGcm9tQnVmZmVyKGNpZC5idWZmZXIpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKGZpbGVzdG9yZSwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgbWF5YmVXaXRoU2hhcmRpbmcoZmlsZXN0b3JlLCBvcHRpb25zLCAoZXJyLCBzdG9yZSkgPT4ge1xuICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycikgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgY3JlYXRlQmFzZVN0b3JlKHN0b3JlKSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gbWF5YmVXaXRoU2hhcmRpbmcgKGZpbGVzdG9yZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKG9wdGlvbnMuc2hhcmRpbmcpIHtcbiAgICBjb25zdCBzaGFyZCA9IG5ldyBjb3JlLnNoYXJkLk5leHRUb0xhc3QoMilcbiAgICBTaGFyZGluZ1N0b3JlLmNyZWF0ZU9yT3BlbihmaWxlc3RvcmUsIHNoYXJkLCBjYWxsYmFjaylcbiAgfSBlbHNlIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobnVsbCwgZmlsZXN0b3JlKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVCYXNlU3RvcmUgKHN0b3JlKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogUXVlcnkgdGhlIHN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHF1ZXJ5XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQXJyYXkpfSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgcXVlcnkgKHF1ZXJ5LCBjYWxsYmFjaykge1xuICAgICAgcHVsbChcbiAgICAgICAgc3RvcmUucXVlcnkocXVlcnkpLFxuICAgICAgICBjb2xsZWN0KGNhbGxiYWNrKVxuICAgICAgKVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgc2luZ2xlIGJsb2NrIGJ5IENJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q0lEfSBjaWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCbG9jayl9IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZ2V0IChjaWQsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIUNJRC5pc0NJRChjaWQpKSB7XG4gICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignTm90IGEgdmFsaWQgY2lkJykpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleSA9IGNpZFRvRHNLZXkoY2lkKVxuICAgICAgc3RvcmUuZ2V0KGtleSwgKGVyciwgYmxvY2tEYXRhKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAvLyBJZiBub3QgZm91bmQsIHdlIHRyeSB3aXRoIHRoZSBvdGhlciBDSUQgdmVyc2lvbi5cbiAgICAgICAgICAvLyBJZiBleGlzdHMsIHRoZW4gc3RvcmUgdGhhdCBibG9jayB1bmRlciB0aGUgQ0lEIHRoYXQgd2FzIHJlcXVlc3RlZC5cbiAgICAgICAgICAvLyBTb21lIGR1cGxpY2F0aW9uIG9jY3Vycy5cbiAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFUlJfTk9UX0ZPVU5EJykge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJDaWQgPSBjaWRUb090aGVyVmVyc2lvbihjaWQpXG4gICAgICAgICAgICBpZiAoIW90aGVyQ2lkKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuXG4gICAgICAgICAgICBjb25zdCBvdGhlcktleSA9IGNpZFRvRHNLZXkob3RoZXJDaWQpXG4gICAgICAgICAgICByZXR1cm4gc3RvcmUuZ2V0KG90aGVyS2V5LCAoZXJyLCBibG9ja0RhdGEpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcblxuICAgICAgICAgICAgICBzdG9yZS5wdXQoa2V5LCBibG9ja0RhdGEsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG5ldyBCbG9jayhibG9ja0RhdGEsIGNpZCkpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCBuZXcgQmxvY2soYmxvY2tEYXRhLCBjaWQpKVxuICAgICAgfSlcbiAgICB9LFxuICAgIHB1dCAoYmxvY2ssIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIUJsb2NrLmlzQmxvY2soYmxvY2spKSB7XG4gICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignaW52YWxpZCBibG9jaycpKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBrID0gY2lkVG9Ec0tleShibG9jay5jaWQpXG5cbiAgICAgIHN0b3JlLmhhcyhrLCAoZXJyLCBleGlzdHMpID0+IHtcbiAgICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKSB9XG4gICAgICAgIGlmIChleGlzdHMpIHsgcmV0dXJuIGNhbGxiYWNrKCkgfVxuXG4gICAgICAgIHN0b3JlLnB1dChrLCBibG9jay5kYXRhLCBjYWxsYmFjaylcbiAgICAgIH0pXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBMaWtlIHB1dCwgYnV0IGZvciBtb3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxCbG9jaz59IGJsb2Nrc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHB1dE1hbnkgKGJsb2NrcywgY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGtleXMgPSBibG9ja3MubWFwKChiKSA9PiAoe1xuICAgICAgICBrZXk6IGNpZFRvRHNLZXkoYi5jaWQpLFxuICAgICAgICBibG9jazogYlxuICAgICAgfSkpXG5cbiAgICAgIGNvbnN0IGJhdGNoID0gc3RvcmUuYmF0Y2goKVxuICAgICAgcmVqZWN0KGtleXMsIChrLCBjYikgPT4gc3RvcmUuaGFzKGsua2V5LCBjYiksIChlcnIsIG5ld0tleXMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBuZXdLZXlzLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICBiYXRjaC5wdXQoay5rZXksIGsuYmxvY2suZGF0YSlcbiAgICAgICAgfSlcblxuICAgICAgICBiYXRjaC5jb21taXQoY2FsbGJhY2spXG4gICAgICB9KVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgc3RvcmUgY29udGFpbiBibG9jayB3aXRoIHRoaXMgY2lkP1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDSUR9IGNpZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIGJvb2wpfSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGhhcyAoY2lkLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFDSUQuaXNDSUQoY2lkKSkge1xuICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIGNpZCcpKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBzdG9yZS5oYXMoY2lkVG9Ec0tleShjaWQpLCAoZXJyLCBleGlzdHMpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgaWYgKGV4aXN0cykgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHRydWUpXG5cbiAgICAgICAgLy8gSWYgbm90IGZvdW5kLCB3ZSB0cnkgd2l0aCB0aGUgb3RoZXIgQ0lEIHZlcnNpb24uXG4gICAgICAgIGNvbnN0IG90aGVyQ2lkID0gY2lkVG9PdGhlclZlcnNpb24oY2lkKVxuICAgICAgICBpZiAoIW90aGVyQ2lkKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgZmFsc2UpXG5cbiAgICAgICAgc3RvcmUuaGFzKGNpZFRvRHNLZXkob3RoZXJDaWQpLCBjYWxsYmFjaylcbiAgICAgIH0pXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBibG9jayBmcm9tIHRoZSBzdG9yZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDSUR9IGNpZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGRlbGV0ZSAoY2lkLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFDSUQuaXNDSUQoY2lkKSkge1xuICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIGNpZCcpKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBzdG9yZS5kZWxldGUoY2lkVG9Ec0tleShjaWQpLCBjYWxsYmFjaylcbiAgICB9LFxuXG4gICAgY2xvc2UgKGNhbGxiYWNrKSB7XG4gICAgICBzdG9yZS5jbG9zZShjYWxsYmFjaylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2lkVG9PdGhlclZlcnNpb24gKGNpZCkge1xuICB0cnkge1xuICAgIHJldHVybiBjaWQudmVyc2lvbiA9PT0gMCA/IGNpZC50b1YxKCkgOiBjaWQudG9WMCgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBEZWZhdWx0IGNvbmZpZ3VyYXRpb24gZm9yIGEgcmVwbyBpbiB0aGUgYnJvd3NlclxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvY2s6ICdtZW1vcnknLFxuICBzdG9yYWdlQmFja2VuZHM6IHtcbiAgICByb290OiByZXF1aXJlKCdkYXRhc3RvcmUtbGV2ZWwnKSxcbiAgICBibG9ja3M6IHJlcXVpcmUoJ2RhdGFzdG9yZS1sZXZlbCcpLFxuICAgIGtleXM6IHJlcXVpcmUoJ2RhdGFzdG9yZS1sZXZlbCcpLFxuICAgIGRhdGFzdG9yZTogcmVxdWlyZSgnZGF0YXN0b3JlLWxldmVsJylcbiAgfSxcbiAgc3RvcmFnZUJhY2tlbmRPcHRpb25zOiB7XG4gICAgcm9vdDoge1xuICAgICAgZXh0ZW5zaW9uOiAnJ1xuICAgIH0sXG4gICAgYmxvY2tzOiB7XG4gICAgICBzaGFyZGluZzogZmFsc2VcbiAgICB9LFxuICAgIGtleXM6IHtcbiAgICAgIHNoYXJkaW5nOiBmYWxzZVxuICAgIH1cbiAgfVxufVxuIiwiZnVuY3Rpb24gZWFjaChvYmosIGl0ZXIpIHtcbiAgZm9yKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqW2tleV1cbiAgICBpdGVyKHZhbHVlLCBrZXksIG9iailcbiAgfVxufVxuXG5mdW5jdGlvbiBrZXlzIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikuc29ydCgpXG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zIChhLCB2KSB7XG4gIHJldHVybiB+YS5pbmRleE9mKHYpXG59XG5mdW5jdGlvbiB1bmlvbiAoYSwgYikge1xuICByZXR1cm4gYS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gY29udGFpbnMoYiwgdilcbiAgfSlcbn1cblxuZnVuY3Rpb24gZGlzdW5pb24xKGEsIGIpIHtcbiAgcmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuICFjb250YWlucyhiLCB2KVxuICB9KVxufVxuXG5mdW5jdGlvbiBkaXN1bmlvbihhLCBiKSB7XG4gIHJldHVybiBhLmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgIHJldHVybiAhY29udGFpbnMoYiwgdilcbiAgfSkuY29uY2F0KGIuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuICFjb250YWlucyhhLCB2KVxuICB9KSkuc29ydCgpXG59XG5cbmZ1bmN0aW9uIGVxdWFsIChhLCBiKSB7XG4gIGlmKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2VcbiAgZm9yKHZhciBpIGluIGEpXG4gICAgaWYoYltpXSAhPT0gYVtpXSkgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGVtcHR5ICh2KSB7XG4gIGZvcih2YXIgayBpbiB2KVxuICAgIHJldHVybiBmYWxzZVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vL2NoZWNrIHRoYXQgYWxsIHRyYW5zaXRpb25zIGFyZSB0byB2YWxpZCBzdGF0ZXMuXG52YXIgdmFsaWRhdGUgPSBleHBvcnRzLnZhbGlkYXRlID0gZnVuY3Rpb24gKGZzbSkge1xuICB2YXIgc3RhdGVzID0gT2JqZWN0LmtleXMoZnNtKVxuICBlYWNoKGZzbSwgZnVuY3Rpb24gKHN0YXRlLCBuYW1lKSB7XG4gICAgZWFjaChzdGF0ZSwgZnVuY3Rpb24gKF9zdGF0ZSwgZXZlbnQpIHtcbiAgICAgIGlmKCFmc21bX3N0YXRlXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ2ludmFsaWQgdHJhbnNpdGlvbiBmcm9tIHN0YXRlOicgKyBuYW1lXG4gICAgICAgICAgKyAnIHRvIHN0YXRlOicgKyBfc3RhdGVcbiAgICAgICAgICArICcgb24gZXZlbnQ6JyArIGV2ZW50XG4gICAgICAgIClcbiAgICB9KVxuICB9KVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vL2dldCBhIGxpc3Qgb2YgYWxsIHN0YXRlcyB0aGF0IGFyZSByZWFjaGFibGUgZnJvbSBhbnkgZ2l2ZW4gc3RhdGUuXG4vLyh3aXRoIHRoZSBzaG9ydGVzdCBwYXRocz8pXG4vLyByZXR1cm5zIG9iamVjdDoge1NUQVRFUzoge1JFQUNIQUJMRV9TVEFURTogcGF0aH19XG5cbnZhciByZWFjaGFibGUgPSBleHBvcnRzLnJlYWNoYWJsZSA9IGZ1bmN0aW9uIChmc20pIHtcbiAgdmFyIHJlYWNoYWJsZSA9IHt9XG4gIHZhciBhZGRlZCA9IGZhbHNlXG4gIGRvIHtcbiAgICBhZGRlZCA9IGZhbHNlXG4gICAgZWFjaChmc20sIGZ1bmN0aW9uIChzdGF0ZSwgbmFtZSkge1xuICAgICAgdmFyIHJlYWNoID0gcmVhY2hhYmxlW25hbWVdID0gcmVhY2hhYmxlW25hbWVdIHx8IHt9XG4gICAgICAvL2FkZCBhbnkgc3RhdGUgdGhhdCBjYW4gYmUgcmVhY2hlZCBkaXJlY3RseS5cbiAgICAgIGVhY2goc3RhdGUsIGZ1bmN0aW9uIChfbmFtZSwgZXZlbnQpIHtcbiAgICAgICAgaWYoIXJlYWNoW19uYW1lXSkgcmVhY2hbX25hbWVdID0gW2V2ZW50XSwgYWRkZWQgPSB0cnVlXG4gICAgICB9KVxuICAgICAgLy9hZGQgYW55IHN0YXRlIHRoYXQgY2FuIGJlIHJlYWNoZWQgZnJvbSBhIHN0YXRlIHlvdSBjYW4gcmVhY2ggZGlyZWN0bHkuXG4gICAgICBlYWNoKHN0YXRlLCBmdW5jdGlvbiAoX25hbWUsIGV2ZW50KSB7XG4gICAgICAgIHZhciBfc3RhdGUgPSByZWFjaGFibGVbX25hbWVdXG4gICAgICAgIGVhY2goX3N0YXRlLCBmdW5jdGlvbiAocGF0aCwgX25hbWUpIHtcbiAgICAgICAgICBpZighcmVhY2hbX25hbWVdKVxuICAgICAgICAgICAgcmVhY2hbX25hbWVdID0gW2V2ZW50XS5jb25jYXQocGF0aCksIGFkZGVkID0gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9IHdoaWxlKGFkZGVkKTtcbiAgcmV0dXJuIHJlYWNoYWJsZVxufVxuXG4vLyBkZWFkbG9jazogYXJlIHRoZXJlIGFueSBkZWFkIGVuZHMgdGhhdCBjYW5ub3QgcmVhY2ggYW5vdGhlciBzdGF0ZT9cblxuZXhwb3J0cy50ZXJtaW5hbCA9XG5leHBvcnRzLmRlYWRsb2NrID0gZnVuY3Rpb24gKGZzbSkge1xuICB2YXIgZGVhZCA9IFtdXG4gIGVhY2goZnNtLCBmdW5jdGlvbiAoc3RhdGUsIG5hbWUpIHtcbiAgICBpZihlbXB0eShzdGF0ZSkpIGRlYWQucHVzaChuYW1lKVxuICB9KVxuICByZXR1cm4gZGVhZFxufVxuXG4vLyBsaXZlbG9jazsgYXJlIHRoZXJlIGFueSBjeWNsZXMgdGhhdCBjYW5ub3QgcmVhY2ggYSB0ZXJtaW5hbCBzdGF0ZT9cbi8vIHJldHVybiBhbnkgc3RhdGVzIHRoYXQgY2Fubm90IHJlYWNoIHRoZSBnaXZlbiB0ZXJtaW5hbCBzdGF0ZXMsXG4vLyB1bmxlc3MgdGhleSBhcmUgdGhlbXNlbHZlcyB0ZXJtaW5hbCBzdGF0ZXMuXG5cbnZhciBsaXZlbG9jayA9IGV4cG9ydHMubGl2ZWxvY2sgPSBmdW5jdGlvbiAoZnNtLCB0ZXJtaW5hbHMpIHtcbiAgdmFyIHJlYWNoID0gcmVhY2hhYmxlKGZzbSksIGxvY2tlZCA9IFtdXG4gIGVhY2gocmVhY2gsIGZ1bmN0aW9uIChyZWFjaGVzLCBuYW1lKSB7XG4gICAgaWYoY29udGFpbnModGVybWluYWxzLCBuYW1lKSkgcmV0dXJuXG4gICAgZWFjaCh0ZXJtaW5hbHMsIGZ1bmN0aW9uIChfbmFtZSkge1xuICAgICAgaWYoIXJlYWNoZXNbX25hbWVdICYmICFjb250YWlucyhsb2NrZWQsIG5hbWUpKVxuICAgICAgICBsb2NrZWQucHVzaChuYW1lKVxuICAgIH0pXG4gIH0pXG4gIHJldHVybiBsb2NrZWQuc29ydCgpXG59XG5cblxuZnVuY3Rpb24gZXZlbnRzIChmc20pIHtcbiAgdmFyIGV2ZW50cyA9IFtdXG4gIGVhY2goZnNtLCBmdW5jdGlvbiAoc3RhdGUsIG5hbWUpIHtcbiAgICBlYWNoKHN0YXRlLCBmdW5jdGlvbiAoX3N0YXRlLCBldmVudCkge1xuICAgICAgaWYoIWNvbnRhaW5zKGV2ZW50cywgZXZlbnQpKSBldmVudHMucHVzaChldmVudClcbiAgICB9KVxuICB9KVxuICByZXR1cm4gZXZlbnRzLnNvcnQoKVxufVxuXG52YXIgY29tYmluZSA9IGV4cG9ydHMuY29tYmluZSA9IGZ1bmN0aW9uIChmc20xLCBmc20yLCBzdGFydDEsIHN0YXJ0Mikge1xuICB2YXIgY29tYmluZWQgPSB7fVxuICB2YXIgZXZlbnRzMSA9IGV2ZW50cyhmc20xKVxuICB2YXIgZXZlbnRzMiA9IGV2ZW50cyhmc20yKVxuICB2YXIgaW5kZXBlbmRlbnQgPSBkaXN1bmlvbihldmVudHMxLCBldmVudHMyKVxuXG4gIGZ1bmN0aW9uIGV4cGFuZChuYW1lMSwgbmFtZTIpIHtcbiAgICB2YXIgY05hbWUgPSBuYW1lMSArICctJyArIG5hbWUyLCBzdGF0ZVxuICAgIGlmKCFjb21iaW5lZFtjTmFtZV0pIGNvbWJpbmVkW2NOYW1lXSA9IHt9XG4gICAgc3RhdGUgPSBjb21iaW5lZFtjTmFtZV1cblxuICAgIC8vUTogd2hhdCBhcmUgdGhlIGV2ZW50cyB3aGljaCBhcmUgYWxsb3dlZCB0byBvY2N1ciBmcm9tIHRoaXMgc3RhdGU/XG4gICAgLy9BOiBpbmRlcGVuZGVudCBldmVudHMgKHVzZWQgaW4gb25seSBvbmUgZnNtKSBvciBldmVudHMgdGhhdCBvY2N1ciBpbiBib3RoIGZzbXMgaW4gY3VycmVudCBzdGF0ZS5cblxuICAgIHZhciB0cmFuczEgPSBrZXlzKGZzbTFbbmFtZTFdKSwgdHJhbnMyID0ga2V5cyhmc20yW25hbWUyXSlcbiAgICB2YXIgYWxsb3dlZCA9IHVuaW9uKHRyYW5zMSwgdHJhbnMyKVxuXG4gICAgLy9leHBhbmQgdG8gYSBuZXcgc3RhdGVcbiAgICBhbGxvd2VkLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBzdGF0ZVtldmVudF0gPSBmc20xW25hbWUxXVtldmVudF0gKyAnLScgKyBmc20yW25hbWUyXVtldmVudF1cbiAgICAgIGlmKCFjb21iaW5lZFtzdGF0ZVtldmVudF1dKVxuICAgICAgICBleHBhbmQoZnNtMVtuYW1lMV1bZXZlbnRdLCBmc20yW25hbWUyXVtldmVudF0pXG4gICAgfSlcblxuICAgIC8vb25seSB0cmFuc2l0aW9uIGZzbTFcbiAgICB1bmlvbihpbmRlcGVuZGVudCwgdHJhbnMxKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgc3RhdGVbZXZlbnRdID0gZnNtMVtuYW1lMV1bZXZlbnRdICsgJy0nICsgbmFtZTJcbiAgICAgIGlmKCFjb21iaW5lZFtzdGF0ZVtldmVudF1dKVxuICAgICAgICBleHBhbmQoZnNtMVtuYW1lMV1bZXZlbnRdLCBuYW1lMilcbiAgICB9KVxuXG4gICAgdW5pb24oaW5kZXBlbmRlbnQsIHRyYW5zMikuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHN0YXRlW2V2ZW50XSA9ICBuYW1lMSArICctJyArIGZzbTJbbmFtZTJdW2V2ZW50XVxuICAgICAgaWYoIWNvbWJpbmVkW3N0YXRlW2V2ZW50XV0pXG4gICAgICAgIGV4cGFuZChuYW1lMSwgZnNtMltuYW1lMl1bZXZlbnRdKVxuICAgIH0pXG5cbiAgICByZXR1cm4gY29tYmluZWRbY05hbWVdXG4gIH1cblxuICBleHBhbmQoc3RhcnQxLCBzdGFydDIpXG4gIHJldHVybiBjb21iaW5lZFxufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlQnk7XG5cbmZ1bmN0aW9uIHVuaXF1ZUJ5KGFyciwgZ2V0VmFsdWUpIHtcbiAgdmFyIHVuaXF1ZSA9IFtdO1xuICB2YXIgZm91bmQgPSB7fTtcblxuICBpZiAodHlwZW9mIGdldFZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGtleSA9IGdldFZhbHVlO1xuICAgIGdldFZhbHVlID0gZnVuY3Rpb24gZGVmYXVsdEdldFZhbHVlKG9iaikge1xuICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH07XG4gIH1cblxuICBhcnIuZm9yRWFjaChmdW5jdGlvbiBhZGRVbmlxdWVzKG9iaikge1xuICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iaik7XG4gICAgaWYgKCFmb3VuZFt2YWx1ZV0pIHtcbiAgICAgIGZvdW5kW3ZhbHVlXSA9IHRydWU7XG4gICAgICB1bmlxdWUucHVzaChvYmopO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHVuaXF1ZTtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGBlbnVtIEtleVR5cGUge1xuICBSU0EgPSAwO1xuICBFZDI1NTE5ID0gMTtcbiAgU2VjcDI1NmsxID0gMjtcbn1cbm1lc3NhZ2UgUHVibGljS2V5IHtcbiAgcmVxdWlyZWQgS2V5VHlwZSBUeXBlID0gMTtcbiAgcmVxdWlyZWQgYnl0ZXMgRGF0YSA9IDI7XG59XG5tZXNzYWdlIFByaXZhdGVLZXkge1xuICByZXF1aXJlZCBLZXlUeXBlIFR5cGUgPSAxO1xuICByZXF1aXJlZCBieXRlcyBEYXRhID0gMjtcbn1gIiwiLyoqXG4gKiBOb2RlLmpzIG1vZHVsZSBmb3IgRm9yZ2UuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE2IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9uczoge1xuICAgIHVzZVB1cmVKYXZhU2NyaXB0OiBmYWxzZVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG11bHRpaGFzaGluZyA9IHJlcXVpcmUoJ211bHRpaGFzaGluZy1hc3luYycpXG5jb25zdCBwcm90b2J1ZiA9IHJlcXVpcmUoJ3Byb3RvbnMnKVxuY29uc3QgYnM1OCA9IHJlcXVpcmUoJ2JzNTgnKVxuXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCcuL2VkMjU1MTknKVxuY29uc3QgcGJtID0gcHJvdG9idWYocmVxdWlyZSgnLi9rZXlzLnByb3RvJykpXG5cbmNsYXNzIEVkMjU1MTlQdWJsaWNLZXkge1xuICBjb25zdHJ1Y3RvciAoa2V5KSB7XG4gICAgdGhpcy5fa2V5ID0gZW5zdXJlS2V5KGtleSwgY3J5cHRvLnB1YmxpY0tleUxlbmd0aClcbiAgfVxuXG4gIHZlcmlmeSAoZGF0YSwgc2lnLCBjYWxsYmFjaykge1xuICAgIGVuc3VyZShjYWxsYmFjaylcbiAgICBjcnlwdG8uaGFzaEFuZFZlcmlmeSh0aGlzLl9rZXksIHNpZywgZGF0YSwgY2FsbGJhY2spXG4gIH1cblxuICBtYXJzaGFsICgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5fa2V5KVxuICB9XG5cbiAgZ2V0IGJ5dGVzICgpIHtcbiAgICByZXR1cm4gcGJtLlB1YmxpY0tleS5lbmNvZGUoe1xuICAgICAgVHlwZTogcGJtLktleVR5cGUuRWQyNTUxOSxcbiAgICAgIERhdGE6IHRoaXMubWFyc2hhbCgpXG4gICAgfSlcbiAgfVxuXG4gIGVxdWFscyAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZXMuZXF1YWxzKGtleS5ieXRlcylcbiAgfVxuXG4gIGhhc2ggKGNhbGxiYWNrKSB7XG4gICAgZW5zdXJlKGNhbGxiYWNrKVxuICAgIG11bHRpaGFzaGluZyh0aGlzLmJ5dGVzLCAnc2hhMi0yNTYnLCBjYWxsYmFjaylcbiAgfVxufVxuXG5jbGFzcyBFZDI1NTE5UHJpdmF0ZUtleSB7XG4gIC8vIGtleSAgICAgICAtIDY0IGJ5dGUgVWludDhBcnJheSBvciBCdWZmZXIgY29udGFpbmluZyBwcml2YXRlIGtleVxuICAvLyBwdWJsaWNLZXkgLSAzMiBieXRlIFVpbnQ4QXJyYXkgb3IgQnVmZmVyIGNvbnRhaW5pbmcgcHVibGljIGtleVxuICBjb25zdHJ1Y3RvciAoa2V5LCBwdWJsaWNLZXkpIHtcbiAgICB0aGlzLl9rZXkgPSBlbnN1cmVLZXkoa2V5LCBjcnlwdG8ucHJpdmF0ZUtleUxlbmd0aClcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBlbnN1cmVLZXkocHVibGljS2V5LCBjcnlwdG8ucHVibGljS2V5TGVuZ3RoKVxuICB9XG5cbiAgc2lnbiAobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBlbnN1cmUoY2FsbGJhY2spXG4gICAgY3J5cHRvLmhhc2hBbmRTaWduKHRoaXMuX2tleSwgbWVzc2FnZSwgY2FsbGJhY2spXG4gIH1cblxuICBnZXQgcHVibGljICgpIHtcbiAgICBpZiAoIXRoaXMuX3B1YmxpY0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdWJsaWMga2V5IG5vdCBwcm92aWRlZCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBFZDI1NTE5UHVibGljS2V5KHRoaXMuX3B1YmxpY0tleSlcbiAgfVxuXG4gIG1hcnNoYWwgKCkge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSh0aGlzLl9rZXkpLCBCdWZmZXIuZnJvbSh0aGlzLl9wdWJsaWNLZXkpXSlcbiAgfVxuXG4gIGdldCBieXRlcyAoKSB7XG4gICAgcmV0dXJuIHBibS5Qcml2YXRlS2V5LmVuY29kZSh7XG4gICAgICBUeXBlOiBwYm0uS2V5VHlwZS5FZDI1NTE5LFxuICAgICAgRGF0YTogdGhpcy5tYXJzaGFsKClcbiAgICB9KVxuICB9XG5cbiAgZXF1YWxzIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlcy5lcXVhbHMoa2V5LmJ5dGVzKVxuICB9XG5cbiAgaGFzaCAoY2FsbGJhY2spIHtcbiAgICBlbnN1cmUoY2FsbGJhY2spXG4gICAgbXVsdGloYXNoaW5nKHRoaXMuYnl0ZXMsICdzaGEyLTI1NicsIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIElEIG9mIHRoZSBrZXkuXG4gICAqXG4gICAqIFRoZSBrZXkgaWQgaXMgdGhlIGJhc2U1OCBlbmNvZGluZyBvZiB0aGUgU0hBLTI1NiBtdWx0aWhhc2ggb2YgaXRzIHB1YmxpYyBrZXkuXG4gICAqIFRoZSBwdWJsaWMga2V5IGlzIGEgcHJvdG9idWYgZW5jb2RpbmcgY29udGFpbmluZyBhIHR5cGUgYW5kIHRoZSBERVIgZW5jb2RpbmdcbiAgICogb2YgdGhlIFBLQ1MgU3ViamVjdFB1YmxpY0tleUluZm8uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIGlkKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGlkIChjYWxsYmFjaykge1xuICAgIHRoaXMucHVibGljLmhhc2goKGVyciwgaGFzaCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgYnM1OC5lbmNvZGUoaGFzaCkpXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1bm1hcnNoYWxFZDI1NTE5UHJpdmF0ZUtleSAoYnl0ZXMsIGNhbGxiYWNrKSB7XG4gIHRyeSB7XG4gICAgYnl0ZXMgPSBlbnN1cmVLZXkoYnl0ZXMsIGNyeXB0by5wcml2YXRlS2V5TGVuZ3RoICsgY3J5cHRvLnB1YmxpY0tleUxlbmd0aClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgfVxuICBjb25zdCBwcml2YXRlS2V5Qnl0ZXMgPSBieXRlcy5zbGljZSgwLCBjcnlwdG8ucHJpdmF0ZUtleUxlbmd0aClcbiAgY29uc3QgcHVibGljS2V5Qnl0ZXMgPSBieXRlcy5zbGljZShjcnlwdG8ucHJpdmF0ZUtleUxlbmd0aCwgYnl0ZXMubGVuZ3RoKVxuICBjYWxsYmFjayhudWxsLCBuZXcgRWQyNTUxOVByaXZhdGVLZXkocHJpdmF0ZUtleUJ5dGVzLCBwdWJsaWNLZXlCeXRlcykpXG59XG5cbmZ1bmN0aW9uIHVubWFyc2hhbEVkMjU1MTlQdWJsaWNLZXkgKGJ5dGVzKSB7XG4gIGJ5dGVzID0gZW5zdXJlS2V5KGJ5dGVzLCBjcnlwdG8ucHVibGljS2V5TGVuZ3RoKVxuICByZXR1cm4gbmV3IEVkMjU1MTlQdWJsaWNLZXkoYnl0ZXMpXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5UGFpciAoX2JpdHMsIGNiKSB7XG4gIGlmIChjYiA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBfYml0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gX2JpdHNcbiAgfVxuXG4gIGNyeXB0by5nZW5lcmF0ZUtleSgoZXJyLCBrZXlzKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycilcbiAgICB9XG4gICAgbGV0IHByaXZrZXlcbiAgICB0cnkge1xuICAgICAgcHJpdmtleSA9IG5ldyBFZDI1NTE5UHJpdmF0ZUtleShrZXlzLnNlY3JldEtleSwga2V5cy5wdWJsaWNLZXkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjYihudWxsLCBwcml2a2V5KVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUtleVBhaXJGcm9tU2VlZCAoc2VlZCwgX2JpdHMsIGNiKSB7XG4gIGlmIChjYiA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBfYml0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gX2JpdHNcbiAgfVxuXG4gIGNyeXB0by5nZW5lcmF0ZUtleUZyb21TZWVkKHNlZWQsIChlcnIsIGtleXMpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IoZXJyKVxuICAgIH1cbiAgICBsZXQgcHJpdmtleVxuICAgIHRyeSB7XG4gICAgICBwcml2a2V5ID0gbmV3IEVkMjU1MTlQcml2YXRlS2V5KGtleXMuc2VjcmV0S2V5LCBrZXlzLnB1YmxpY0tleSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNiKG51bGwsIHByaXZrZXkpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGVuc3VyZSAoY2IpIHtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgaXMgcmVxdWlyZWQnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUtleSAoa2V5LCBsZW5ndGgpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihrZXkpKSB7XG4gICAga2V5ID0gbmV3IFVpbnQ4QXJyYXkoa2V5KVxuICB9XG4gIGlmICghKGtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8IGtleS5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignS2V5IG11c3QgYmUgYSBVaW50OEFycmF5IG9yIEJ1ZmZlciBvZiBsZW5ndGggJyArIGxlbmd0aClcbiAgfVxuICByZXR1cm4ga2V5XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFZDI1NTE5UHVibGljS2V5LFxuICBFZDI1NTE5UHJpdmF0ZUtleSxcbiAgdW5tYXJzaGFsRWQyNTUxOVByaXZhdGVLZXksXG4gIHVubWFyc2hhbEVkMjU1MTlQdWJsaWNLZXksXG4gIGdlbmVyYXRlS2V5UGFpcixcbiAgZ2VuZXJhdGVLZXlQYWlyRnJvbVNlZWRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB3aGlsc3QgPSByZXF1aXJlKCdhc3luYy93aGlsc3QnKVxuY29uc3QgaG1hYyA9IHJlcXVpcmUoJy4uL2htYWMnKVxuXG5jb25zdCBjaXBoZXJNYXAgPSB7XG4gICdBRVMtMTI4Jzoge1xuICAgIGl2U2l6ZTogMTYsXG4gICAga2V5U2l6ZTogMTZcbiAgfSxcbiAgJ0FFUy0yNTYnOiB7XG4gICAgaXZTaXplOiAxNixcbiAgICBrZXlTaXplOiAzMlxuICB9LFxuICBCbG93ZmlzaDoge1xuICAgIGl2U2l6ZTogOCxcbiAgICBjaXBoZXJLZXlTaXplOiAzMlxuICB9XG59XG5cbi8vIEdlbmVyYXRlcyBhIHNldCBvZiBrZXlzIGZvciBlYWNoIHBhcnR5IGJ5IHN0cmV0Y2hpbmcgdGhlIHNoYXJlZCBrZXkuXG4vLyAobXlJViwgdGhlaXJJViwgbXlDaXBoZXJLZXksIHRoZWlyQ2lwaGVyS2V5LCBteU1BQ0tleSwgdGhlaXJNQUNLZXkpXG5tb2R1bGUuZXhwb3J0cyA9IChjaXBoZXJUeXBlLCBoYXNoLCBzZWNyZXQsIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGNpcGhlciA9IGNpcGhlck1hcFtjaXBoZXJUeXBlXVxuXG4gIGlmICghY2lwaGVyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcigndW5rb3duIGNpcGhlclR5cGUgcGFzc2VkJykpXG4gIH1cblxuICBpZiAoIWhhc2gpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCd1bmtvd24gaGFzaFR5cGUgcGFzc2VkJykpXG4gIH1cblxuICBjb25zdCBjaXBoZXJLZXlTaXplID0gY2lwaGVyLmtleVNpemVcbiAgY29uc3QgaXZTaXplID0gY2lwaGVyLml2U2l6ZVxuICBjb25zdCBobWFjS2V5U2l6ZSA9IDIwXG4gIGNvbnN0IHNlZWQgPSBCdWZmZXIuZnJvbSgna2V5IGV4cGFuc2lvbicpXG4gIGNvbnN0IHJlc3VsdExlbmd0aCA9IDIgKiAoaXZTaXplICsgY2lwaGVyS2V5U2l6ZSArIGhtYWNLZXlTaXplKVxuXG4gIGhtYWMuY3JlYXRlKGhhc2gsIHNlY3JldCwgKGVyciwgbSkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgbS5kaWdlc3Qoc2VlZCwgKGVyciwgYSkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBsZXQgcmVzdWx0ID0gW11cbiAgICAgIGxldCBqID0gMFxuXG4gICAgICB3aGlsc3QoXG4gICAgICAgICgpID0+IGogPCByZXN1bHRMZW5ndGgsXG4gICAgICAgIHN0cmV0Y2gsXG4gICAgICAgIGZpbmlzaFxuICAgICAgKVxuXG4gICAgICBmdW5jdGlvbiBzdHJldGNoIChjYikge1xuICAgICAgICBtLmRpZ2VzdChCdWZmZXIuY29uY2F0KFthLCBzZWVkXSksIChlcnIsIGIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB0b2RvID0gYi5sZW5ndGhcblxuICAgICAgICAgIGlmIChqICsgdG9kbyA+IHJlc3VsdExlbmd0aCkge1xuICAgICAgICAgICAgdG9kbyA9IHJlc3VsdExlbmd0aCAtIGpcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQucHVzaChiKVxuXG4gICAgICAgICAgaiArPSB0b2RvXG5cbiAgICAgICAgICBtLmRpZ2VzdChhLCAoZXJyLCBfYSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSA9IF9hXG4gICAgICAgICAgICBjYigpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmluaXNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoYWxmID0gcmVzdWx0TGVuZ3RoIC8gMlxuICAgICAgICBjb25zdCByZXN1bHRCdWZmZXIgPSBCdWZmZXIuY29uY2F0KHJlc3VsdClcbiAgICAgICAgY29uc3QgcjEgPSByZXN1bHRCdWZmZXIuc2xpY2UoMCwgaGFsZilcbiAgICAgICAgY29uc3QgcjIgPSByZXN1bHRCdWZmZXIuc2xpY2UoaGFsZiwgcmVzdWx0TGVuZ3RoKVxuXG4gICAgICAgIGNvbnN0IGNyZWF0ZUtleSA9IChyZXMpID0+ICh7XG4gICAgICAgICAgaXY6IHJlcy5zbGljZSgwLCBpdlNpemUpLFxuICAgICAgICAgIGNpcGhlcktleTogcmVzLnNsaWNlKGl2U2l6ZSwgaXZTaXplICsgY2lwaGVyS2V5U2l6ZSksXG4gICAgICAgICAgbWFjS2V5OiByZXMuc2xpY2UoaXZTaXplICsgY2lwaGVyS2V5U2l6ZSlcbiAgICAgICAgfSlcblxuICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgazE6IGNyZWF0ZUtleShyMSksXG4gICAgICAgICAgazI6IGNyZWF0ZUtleShyMilcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuIiwiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFic3RyYWN0IFN5bnRheCBOb3RhdGlvbiBOdW1iZXIgT25lLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBBbiBBUEkgZm9yIHN0b3JpbmcgZGF0YSB1c2luZyB0aGUgQWJzdHJhY3QgU3ludGF4IE5vdGF0aW9uIE51bWJlciBPbmVcbiAqIGZvcm1hdCB1c2luZyBERVIgKERpc3Rpbmd1aXNoZWQgRW5jb2RpbmcgUnVsZXMpIGVuY29kaW5nLiBUaGlzIGVuY29kaW5nIGlzXG4gKiBjb21tb25seSB1c2VkIHRvIHN0b3JlIGRhdGEgZm9yIFBLSSwgaS5lLiBYLjUwOSBDZXJ0aWZpY2F0ZXMsIGFuZCB0aGlzXG4gKiBpbXBsZW1lbnRhdGlvbiBleGlzdHMgZm9yIHRoYXQgcHVycG9zZS5cbiAqXG4gKiBBYnN0cmFjdCBTeW50YXggTm90YXRpb24gTnVtYmVyIE9uZSAoQVNOLjEpIGlzIHVzZWQgdG8gZGVmaW5lIHRoZSBhYnN0cmFjdFxuICogc3ludGF4IG9mIGluZm9ybWF0aW9uIHdpdGhvdXQgcmVzdHJpY3RpbmcgdGhlIHdheSB0aGUgaW5mb3JtYXRpb24gaXMgZW5jb2RlZFxuICogZm9yIHRyYW5zbWlzc2lvbi4gSXQgcHJvdmlkZXMgYSBzdGFuZGFyZCB0aGF0IGFsbG93cyBmb3Igb3BlbiBzeXN0ZW1zXG4gKiBjb21tdW5pY2F0aW9uLiBBU04uMSBkZWZpbmVzIHRoZSBzeW50YXggb2YgaW5mb3JtYXRpb24gZGF0YSBhbmQgYSBudW1iZXIgb2ZcbiAqIHNpbXBsZSBkYXRhIHR5cGVzIGFzIHdlbGwgYXMgYSBub3RhdGlvbiBmb3IgZGVzY3JpYmluZyB0aGVtIGFuZCBzcGVjaWZ5aW5nXG4gKiB2YWx1ZXMgZm9yIHRoZW0uXG4gKlxuICogVGhlIFJTQSBhbGdvcml0aG0gY3JlYXRlcyBwdWJsaWMgYW5kIHByaXZhdGUga2V5cyB0aGF0IGFyZSBvZnRlbiBzdG9yZWQgaW5cbiAqIFguNTA5IG9yIFBLQ1MjWCBmb3JtYXRzIC0tIHdoaWNoIHVzZSBBU04uMSAoZW5jb2RlZCBpbiBERVIgZm9ybWF0KS4gVGhpc1xuICogY2xhc3MgcHJvdmlkZXMgdGhlIG1vc3QgYmFzaWMgZnVuY3Rpb25hbGl0eSByZXF1aXJlZCB0byBzdG9yZSBhbmQgbG9hZCBEU0FcbiAqIGtleXMgdGhhdCBhcmUgZW5jb2RlZCBhY2NvcmRpbmcgdG8gQVNOLjEuXG4gKlxuICogVGhlIG1vc3QgY29tbW9uIGJpbmFyeSBlbmNvZGluZ3MgZm9yIEFTTi4xIGFyZSBCRVIgKEJhc2ljIEVuY29kaW5nIFJ1bGVzKVxuICogYW5kIERFUiAoRGlzdGluZ3Vpc2hlZCBFbmNvZGluZyBSdWxlcykuIERFUiBpcyBqdXN0IGEgc3Vic2V0IG9mIEJFUiB0aGF0XG4gKiBoYXMgc3RyaWN0ZXIgcmVxdWlyZW1lbnRzIGZvciBob3cgZGF0YSBtdXN0IGJlIGVuY29kZWQuXG4gKlxuICogRWFjaCBBU04uMSBzdHJ1Y3R1cmUgaGFzIGEgdGFnIChhIGJ5dGUgaWRlbnRpZnlpbmcgdGhlIEFTTi4xIHN0cnVjdHVyZSB0eXBlKVxuICogYW5kIGEgYnl0ZSBhcnJheSBmb3IgdGhlIHZhbHVlIG9mIHRoaXMgQVNOMSBzdHJ1Y3R1cmUgd2hpY2ggbWF5IGJlIGRhdGEgb3IgYVxuICogbGlzdCBvZiBBU04uMSBzdHJ1Y3R1cmVzLlxuICpcbiAqIEVhY2ggQVNOLjEgc3RydWN0dXJlIHVzaW5nIEJFUiBpcyAoVGFnLUxlbmd0aC1WYWx1ZSk6XG4gKlxuICogfCBieXRlIDAgfCBieXRlcyBYIHwgYnl0ZXMgWSB8XG4gKiB8LS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS1cbiAqIHwgIHRhZyAgIHwgbGVuZ3RoICB8ICB2YWx1ZSAgfFxuICpcbiAqIEFTTi4xIGFsbG93cyBmb3IgdGFncyB0byBiZSBvZiBcIkhpZ2gtdGFnLW51bWJlciBmb3JtXCIgd2hpY2ggYWxsb3dzIGEgdGFnIHRvXG4gKiBiZSB0d28gb3IgbW9yZSBvY3RldHMsIGJ1dCB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBjbGFzcy4gQSB0YWcgaXNcbiAqIG9ubHkgMSBieXRlLiBCaXRzIDEtNSBnaXZlIHRoZSB0YWcgbnVtYmVyIChpZSB0aGUgZGF0YSB0eXBlIHdpdGhpbiBhXG4gKiBwYXJ0aWN1bGFyICdjbGFzcycpLCA2IGluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgQVNOLjEgdmFsdWUgaXNcbiAqIGNvbnN0cnVjdGVkIGZyb20gb3RoZXIgQVNOLjEgdmFsdWVzLCBhbmQgYml0cyA3IGFuZCA4IGdpdmUgdGhlICdjbGFzcycuIElmXG4gKiBiaXRzIDcgYW5kIDggYXJlIGJvdGggemVybywgdGhlIGNsYXNzIGlzIFVOSVZFUlNBTC4gSWYgb25seSBiaXQgNyBpcyBzZXQsXG4gKiB0aGVuIHRoZSBjbGFzcyBpcyBBUFBMSUNBVElPTi4gSWYgb25seSBiaXQgOCBpcyBzZXQsIHRoZW4gdGhlIGNsYXNzIGlzXG4gKiBDT05URVhUX1NQRUNJRklDLiBJZiBib3RoIGJpdHMgNyBhbmQgOCBhcmUgc2V0LCB0aGVuIHRoZSBjbGFzcyBpcyBQUklWQVRFLlxuICogVGhlIHRhZyBudW1iZXJzIGZvciB0aGUgZGF0YSB0eXBlcyBmb3IgdGhlIGNsYXNzIFVOSVZFUlNBTCBhcmUgbGlzdGVkIGJlbG93OlxuICpcbiAqIFVOSVZFUlNBTCAwIFJlc2VydmVkIGZvciB1c2UgYnkgdGhlIGVuY29kaW5nIHJ1bGVzXG4gKiBVTklWRVJTQUwgMSBCb29sZWFuIHR5cGVcbiAqIFVOSVZFUlNBTCAyIEludGVnZXIgdHlwZVxuICogVU5JVkVSU0FMIDMgQml0c3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCA0IE9jdGV0c3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCA1IE51bGwgdHlwZVxuICogVU5JVkVSU0FMIDYgT2JqZWN0IGlkZW50aWZpZXIgdHlwZVxuICogVU5JVkVSU0FMIDcgT2JqZWN0IGRlc2NyaXB0b3IgdHlwZVxuICogVU5JVkVSU0FMIDggRXh0ZXJuYWwgdHlwZSBhbmQgSW5zdGFuY2Utb2YgdHlwZVxuICogVU5JVkVSU0FMIDkgUmVhbCB0eXBlXG4gKiBVTklWRVJTQUwgMTAgRW51bWVyYXRlZCB0eXBlXG4gKiBVTklWRVJTQUwgMTEgRW1iZWRkZWQtcGR2IHR5cGVcbiAqIFVOSVZFUlNBTCAxMiBVVEY4U3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCAxMyBSZWxhdGl2ZSBvYmplY3QgaWRlbnRpZmllciB0eXBlXG4gKiBVTklWRVJTQUwgMTQtMTUgUmVzZXJ2ZWQgZm9yIGZ1dHVyZSBlZGl0aW9uc1xuICogVU5JVkVSU0FMIDE2IFNlcXVlbmNlIGFuZCBTZXF1ZW5jZS1vZiB0eXBlc1xuICogVU5JVkVSU0FMIDE3IFNldCBhbmQgU2V0LW9mIHR5cGVzXG4gKiBVTklWRVJTQUwgMTgtMjIsIDI1LTMwIENoYXJhY3RlciBzdHJpbmcgdHlwZXNcbiAqIFVOSVZFUlNBTCAyMy0yNCBUaW1lIHR5cGVzXG4gKlxuICogVGhlIGxlbmd0aCBvZiBhbiBBU04uMSBzdHJ1Y3R1cmUgaXMgc3BlY2lmaWVkIGFmdGVyIHRoZSB0YWcgaWRlbnRpZmllci5cbiAqIFRoZXJlIGlzIGEgZGVmaW5pdGUgZm9ybSBhbmQgYW4gaW5kZWZpbml0ZSBmb3JtLiBUaGUgaW5kZWZpbml0ZSBmb3JtIG1heVxuICogYmUgdXNlZCBpZiB0aGUgZW5jb2RpbmcgaXMgY29uc3RydWN0ZWQgYW5kIG5vdCBhbGwgaW1tZWRpYXRlbHkgYXZhaWxhYmxlLlxuICogVGhlIGluZGVmaW5pdGUgZm9ybSBpcyBlbmNvZGVkIHVzaW5nIGEgbGVuZ3RoIGJ5dGUgd2l0aCBvbmx5IHRoZSA4dGggYml0XG4gKiBzZXQuIFRoZSBlbmQgb2YgdGhlIGNvbnN0cnVjdGVkIG9iamVjdCBpcyBtYXJrZWQgdXNpbmcgZW5kLW9mLWNvbnRlbnRzXG4gKiBvY3RldHMgKHR3byB6ZXJvIGJ5dGVzKS5cbiAqXG4gKiBUaGUgZGVmaW5pdGUgZm9ybSBsb29rcyBsaWtlIHRoaXM6XG4gKlxuICogVGhlIGxlbmd0aCBtYXkgdGFrZSB1cCAxIG9yIG1vcmUgYnl0ZXMsIGl0IGRlcGVuZHMgb24gdGhlIGxlbmd0aCBvZiB0aGVcbiAqIHZhbHVlIG9mIHRoZSBBU04uMSBzdHJ1Y3R1cmUuIERFUiBlbmNvZGluZyByZXF1aXJlcyB0aGF0IGlmIHRoZSBBU04uMVxuICogc3RydWN0dXJlIGhhcyBhIHZhbHVlIHRoYXQgaGFzIGEgbGVuZ3RoIGdyZWF0ZXIgdGhhbiAxMjcsIG1vcmUgdGhhbiAxIGJ5dGVcbiAqIHdpbGwgYmUgdXNlZCB0byBzdG9yZSBpdHMgbGVuZ3RoLCBvdGhlcndpc2UganVzdCBvbmUgYnl0ZSB3aWxsIGJlIHVzZWQuXG4gKiBUaGlzIGlzIHN0cmljdC5cbiAqXG4gKiBJbiB0aGUgY2FzZSB0aGF0IHRoZSBsZW5ndGggb2YgdGhlIEFTTi4xIHZhbHVlIGlzIGxlc3MgdGhhbiAxMjcsIDEgb2N0ZXRcbiAqIChieXRlKSBpcyB1c2VkIHRvIHN0b3JlIHRoZSBcInNob3J0IGZvcm1cIiBsZW5ndGguIFRoZSA4dGggYml0IGhhcyBhIHZhbHVlIG9mXG4gKiAwIGluZGljYXRpbmcgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBhbmQgbm90IFwibG9uZyBmb3JtXCIgYW5kIGJpdHMgNy0xXG4gKiBnaXZlIHRoZSBsZW5ndGggb2YgdGhlIGRhdGEuIChUaGUgOHRoIGJpdCBpcyB0aGUgbGVmdC1tb3N0LCBtb3N0IHNpZ25pZmljYW50XG4gKiBiaXQ6IGFsc28ga25vd24gYXMgYmlnIGVuZGlhbiBvciBuZXR3b3JrIGZvcm1hdCkuXG4gKlxuICogSW4gdGhlIGNhc2UgdGhhdCB0aGUgbGVuZ3RoIG9mIHRoZSBBU04uMSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gMTI3LCAyIHRvXG4gKiAxMjcgb2N0ZXRzIChieXRlcykgYXJlIHVzZWQgdG8gc3RvcmUgdGhlIFwibG9uZyBmb3JtXCIgbGVuZ3RoLiBUaGUgZmlyc3RcbiAqIGJ5dGUncyA4dGggYml0IGlzIHNldCB0byAxIHRvIGluZGljYXRlIHRoZSBsZW5ndGggaXMgXCJsb25nIGZvcm0uXCIgQml0cyA3LTFcbiAqIGdpdmUgdGhlIG51bWJlciBvZiBhZGRpdGlvbmFsIG9jdGV0cy4gQWxsIGZvbGxvd2luZyBvY3RldHMgYXJlIGluIGJhc2UgMjU2XG4gKiB3aXRoIHRoZSBtb3N0IHNpZ25pZmljYW50IGRpZ2l0IGZpcnN0ICh0eXBpY2FsIGJpZy1lbmRpYW4gYmluYXJ5IHVuc2lnbmVkXG4gKiBpbnRlZ2VyIHN0b3JhZ2UpLiBTbywgZm9yIGluc3RhbmNlLCBpZiB0aGUgbGVuZ3RoIG9mIGEgdmFsdWUgd2FzIDI1NywgdGhlXG4gKiBmaXJzdCBieXRlIHdvdWxkIGJlIHNldCB0bzpcbiAqXG4gKiAxMDAwMDAxMCA9IDEzMCA9IDB4ODIuXG4gKlxuICogVGhpcyBpbmRpY2F0ZXMgdGhlcmUgYXJlIDIgb2N0ZXRzIChiYXNlIDI1NikgZm9yIHRoZSBsZW5ndGguIFRoZSBzZWNvbmQgYW5kXG4gKiB0aGlyZCBieXRlcyAodGhlIG9jdGV0cyBqdXN0IG1lbnRpb25lZCkgd291bGQgc3RvcmUgdGhlIGxlbmd0aCBpbiBiYXNlIDI1NjpcbiAqXG4gKiBvY3RldCAyOiAwMDAwMDAwMSA9IDEgKiAyNTZeMSA9IDI1NlxuICogb2N0ZXQgMzogMDAwMDAwMDEgPSAxICogMjU2XjAgPSAxXG4gKiB0b3RhbCA9IDI1N1xuICpcbiAqIFRoZSBhbGdvcml0aG0gZm9yIGNvbnZlcnRpbmcgYSBqcyBpbnRlZ2VyIHZhbHVlIG9mIDI1NyB0byBiYXNlLTI1NiBpczpcbiAqXG4gKiB2YXIgdmFsdWUgPSAyNTc7XG4gKiB2YXIgYnl0ZXMgPSBbXTtcbiAqIGJ5dGVzWzBdID0gKHZhbHVlID4+PiA4KSAmIDB4RkY7IC8vIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdFxuICogYnl0ZXNbMV0gPSB2YWx1ZSAmIDB4RkY7ICAgICAgICAvLyBsZWFzdCBzaWduaWZpY2FudCBieXRlIGxhc3RcbiAqXG4gKiBPbiB0aGUgQVNOLjEgVU5JVkVSU0FMIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIHR5cGU6XG4gKlxuICogQW4gT0lEIGNhbiBiZSB3cml0dGVuIGxpa2U6IFwidmFsdWUxLnZhbHVlMi52YWx1ZTMuLi52YWx1ZU5cIlxuICpcbiAqIFRoZSBERVIgZW5jb2RpbmcgcnVsZXM6XG4gKlxuICogVGhlIGZpcnN0IGJ5dGUgaGFzIHRoZSB2YWx1ZSA0MCAqIHZhbHVlMSArIHZhbHVlMi5cbiAqIFRoZSBmb2xsb3dpbmcgYnl0ZXMsIGlmIGFueSwgZW5jb2RlIHRoZSByZW1haW5pbmcgdmFsdWVzLiBFYWNoIHZhbHVlIGlzXG4gKiBlbmNvZGVkIGluIGJhc2UgMTI4LCBtb3N0IHNpZ25pZmljYW50IGRpZ2l0IGZpcnN0IChiaWcgZW5kaWFuKSwgd2l0aCBhc1xuICogZmV3IGRpZ2l0cyBhcyBwb3NzaWJsZSwgYW5kIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiBlYWNoIGJ5dGUgc2V0XG4gKiB0byAxIGV4Y2VwdCB0aGUgbGFzdCBpbiBlYWNoIHZhbHVlJ3MgZW5jb2RpbmcuIEZvciBleGFtcGxlOiBHaXZlbiB0aGVcbiAqIE9JRCBcIjEuMi44NDAuMTEzNTQ5XCIsIGl0cyBERVIgZW5jb2RpbmcgaXMgKHJlbWVtYmVyIGVhY2ggYnl0ZSBleGNlcHQgdGhlXG4gKiBsYXN0IG9uZSBpbiBlYWNoIGVuY29kaW5nIGlzIE9SJ2Qgd2l0aCAweDgwKTpcbiAqXG4gKiBieXRlIDE6IDQwICogMSArIDIgPSA0MiA9IDB4MkEuXG4gKiBieXRlcyAyLTM6IDEyOCAqIDYgKyA3MiA9IDg0MCA9IDYgNzIgPSA2IDcyID0gMHgwNjQ4ID0gMHg4NjQ4XG4gKiBieXRlcyA0LTY6IDE2Mzg0ICogNiArIDEyOCAqIDExOSArIDEzID0gNiAxMTkgMTMgPSAweDA2NzcwRCA9IDB4ODZGNzBEXG4gKlxuICogVGhlIGZpbmFsIHZhbHVlIGlzOiAweDJBODY0ODg2RjcwRC5cbiAqIFRoZSBmdWxsIE9JRCAoaW5jbHVkaW5nIEFTTi4xIHRhZyBhbmQgbGVuZ3RoIG9mIDYgYnl0ZXMpIGlzOlxuICogMHgwNjA2MkE4NjQ4ODZGNzBEXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xucmVxdWlyZSgnLi9vaWRzJyk7XG5cbi8qIEFTTi4xIEFQSSAqL1xudmFyIGFzbjEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmFzbjEgPSBmb3JnZS5hc24xIHx8IHt9O1xuXG4vKipcbiAqIEFTTi4xIGNsYXNzZXMuXG4gKi9cbmFzbjEuQ2xhc3MgPSB7XG4gIFVOSVZFUlNBTDogICAgICAgIDB4MDAsXG4gIEFQUExJQ0FUSU9OOiAgICAgIDB4NDAsXG4gIENPTlRFWFRfU1BFQ0lGSUM6IDB4ODAsXG4gIFBSSVZBVEU6ICAgICAgICAgIDB4QzBcbn07XG5cbi8qKlxuICogQVNOLjEgdHlwZXMuIE5vdCBhbGwgdHlwZXMgYXJlIHN1cHBvcnRlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uLCBvbmx5XG4gKiB0aG9zZSBuZWNlc3NhcnkgdG8gaW1wbGVtZW50IGEgc2ltcGxlIFBLSSBhcmUgaW1wbGVtZW50ZWQuXG4gKi9cbmFzbjEuVHlwZSA9IHtcbiAgTk9ORTogICAgICAgICAgICAgMCxcbiAgQk9PTEVBTjogICAgICAgICAgMSxcbiAgSU5URUdFUjogICAgICAgICAgMixcbiAgQklUU1RSSU5HOiAgICAgICAgMyxcbiAgT0NURVRTVFJJTkc6ICAgICAgNCxcbiAgTlVMTDogICAgICAgICAgICAgNSxcbiAgT0lEOiAgICAgICAgICAgICAgNixcbiAgT0RFU0M6ICAgICAgICAgICAgNyxcbiAgRVhURVJOQUw6ICAgICAgICAgOCxcbiAgUkVBTDogICAgICAgICAgICAgOSxcbiAgRU5VTUVSQVRFRDogICAgICAxMCxcbiAgRU1CRURERUQ6ICAgICAgICAxMSxcbiAgVVRGODogICAgICAgICAgICAxMixcbiAgUk9JRDogICAgICAgICAgICAxMyxcbiAgU0VRVUVOQ0U6ICAgICAgICAxNixcbiAgU0VUOiAgICAgICAgICAgICAxNyxcbiAgUFJJTlRBQkxFU1RSSU5HOiAxOSxcbiAgSUE1U1RSSU5HOiAgICAgICAyMixcbiAgVVRDVElNRTogICAgICAgICAyMyxcbiAgR0VORVJBTElaRURUSU1FOiAyNCxcbiAgQk1QU1RSSU5HOiAgICAgICAzMFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGFzbjEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB0YWdDbGFzcyB0aGUgdGFnIGNsYXNzIGZvciB0aGUgb2JqZWN0LlxuICogQHBhcmFtIHR5cGUgdGhlIGRhdGEgdHlwZSAodGFnIG51bWJlcikgZm9yIHRoZSBvYmplY3QuXG4gKiBAcGFyYW0gY29uc3RydWN0ZWQgdHJ1ZSBpZiB0aGUgYXNuMSBvYmplY3QgaXMgaW4gY29uc3RydWN0ZWQgZm9ybS5cbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgZm9yIHRoZSBvYmplY3QsIGlmIGl0IGlzIG5vdCBjb25zdHJ1Y3RlZC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2JpdFN0cmluZ0NvbnRlbnRzXSB0aGUgcGxhaW4gQklUIFNUUklORyBjb250ZW50IGluY2x1ZGluZyBwYWRkaW5nXG4gKiAgICAgICAgICAgIGJ5dGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSBvYmplY3QuXG4gKi9cbmFzbjEuY3JlYXRlID0gZnVuY3Rpb24odGFnQ2xhc3MsIHR5cGUsIGNvbnN0cnVjdGVkLCB2YWx1ZSwgb3B0aW9ucykge1xuICAvKiBBbiBhc24xIG9iamVjdCBoYXMgYSB0YWdDbGFzcywgYSB0eXBlLCBhIGNvbnN0cnVjdGVkIGZsYWcsIGFuZCBhXG4gICAgdmFsdWUuIFRoZSB2YWx1ZSdzIHR5cGUgZGVwZW5kcyBvbiB0aGUgY29uc3RydWN0ZWQgZmxhZy4gSWZcbiAgICBjb25zdHJ1Y3RlZCwgaXQgd2lsbCBjb250YWluIGEgbGlzdCBvZiBvdGhlciBhc24xIG9iamVjdHMuIElmIG5vdCxcbiAgICBpdCB3aWxsIGNvbnRhaW4gdGhlIEFTTi4xIHZhbHVlIGFzIGFuIGFycmF5IG9mIGJ5dGVzIGZvcm1hdHRlZFxuICAgIGFjY29yZGluZyB0byB0aGUgQVNOLjEgZGF0YSB0eXBlLiAqL1xuXG4gIC8vIHJlbW92ZSB1bmRlZmluZWQgdmFsdWVzXG4gIGlmKGZvcmdlLnV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgdG1wID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZih2YWx1ZVtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRtcC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUgPSB0bXA7XG4gIH1cblxuICB2YXIgb2JqID0ge1xuICAgIHRhZ0NsYXNzOiB0YWdDbGFzcyxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbnN0cnVjdGVkOiBjb25zdHJ1Y3RlZCxcbiAgICBjb21wb3NlZDogY29uc3RydWN0ZWQgfHwgZm9yZ2UudXRpbC5pc0FycmF5KHZhbHVlKSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbiAgaWYob3B0aW9ucyAmJiAnYml0U3RyaW5nQ29udGVudHMnIGluIG9wdGlvbnMpIHtcbiAgICAvLyBUT0RPOiBjb3B5IGJ5dGUgYnVmZmVyIGlmIGl0J3MgYSBidWZmZXIgbm90IGEgc3RyaW5nXG4gICAgb2JqLmJpdFN0cmluZ0NvbnRlbnRzID0gb3B0aW9ucy5iaXRTdHJpbmdDb250ZW50cztcbiAgICAvLyBUT0RPOiBhZGQgcmVhZG9ubHkgZmxhZyB0byBhdm9pZCB0aGlzIG92ZXJoZWFkXG4gICAgLy8gc2F2ZSBjb3B5IHRvIGRldGVjdCBjaGFuZ2VzXG4gICAgb2JqLm9yaWdpbmFsID0gYXNuMS5jb3B5KG9iaik7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogQ29waWVzIGFuIGFzbjEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIGFzbjEgb2JqZWN0LlxuICogQHBhcmFtIFtvcHRpb25zXSBjb3B5IG9wdGlvbnM6XG4gKiAgICAgICAgICBbZXhjbHVkZUJpdFN0cmluZ0NvbnRlbnRzXSB0cnVlIHRvIG5vdCBjb3B5IGJpdFN0cmluZ0NvbnRlbnRzXG4gKlxuICogQHJldHVybiB0aGUgYSBjb3B5IG9mIHRoZSBhc24xIG9iamVjdC5cbiAqL1xuYXNuMS5jb3B5ID0gZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG4gIHZhciBjb3B5O1xuXG4gIGlmKGZvcmdlLnV0aWwuaXNBcnJheShvYmopKSB7XG4gICAgY29weSA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvcHkucHVzaChhc24xLmNvcHkob2JqW2ldLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9XG5cbiAgaWYodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUT0RPOiBjb3B5IGJ5dGUgYnVmZmVyIGlmIGl0J3MgYSBidWZmZXIgbm90IGEgc3RyaW5nXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGNvcHkgPSB7XG4gICAgdGFnQ2xhc3M6IG9iai50YWdDbGFzcyxcbiAgICB0eXBlOiBvYmoudHlwZSxcbiAgICBjb25zdHJ1Y3RlZDogb2JqLmNvbnN0cnVjdGVkLFxuICAgIGNvbXBvc2VkOiBvYmouY29tcG9zZWQsXG4gICAgdmFsdWU6IGFzbjEuY29weShvYmoudmFsdWUsIG9wdGlvbnMpXG4gIH07XG4gIGlmKG9wdGlvbnMgJiYgIW9wdGlvbnMuZXhjbHVkZUJpdFN0cmluZ0NvbnRlbnRzKSB7XG4gICAgLy8gVE9ETzogY29weSBieXRlIGJ1ZmZlciBpZiBpdCdzIGEgYnVmZmVyIG5vdCBhIHN0cmluZ1xuICAgIGNvcHkuYml0U3RyaW5nQ29udGVudHMgPSBvYmouYml0U3RyaW5nQ29udGVudHM7XG4gIH1cbiAgcmV0dXJuIGNvcHk7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIGFzbjEgb2JqZWN0cyBmb3IgZXF1YWxpdHkuXG4gKlxuICogTm90ZSB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHJ1biBpbiBjb25zdGFudCB0aW1lLlxuICpcbiAqIEBwYXJhbSBvYmoxIHRoZSBmaXJzdCBhc24xIG9iamVjdC5cbiAqIEBwYXJhbSBvYmoyIHRoZSBzZWNvbmQgYXNuMSBvYmplY3QuXG4gKiBAcGFyYW0gW29wdGlvbnNdIGNvbXBhcmUgb3B0aW9uczpcbiAqICAgICAgICAgIFtpbmNsdWRlQml0U3RyaW5nQ29udGVudHNdIHRydWUgdG8gY29tcGFyZSBiaXRTdHJpbmdDb250ZW50c1xuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgYXNuMSBvYmplY3RzIGFyZSBlcXVhbC5cbiAqL1xuYXNuMS5lcXVhbHMgPSBmdW5jdGlvbihvYmoxLCBvYmoyLCBvcHRpb25zKSB7XG4gIGlmKGZvcmdlLnV0aWwuaXNBcnJheShvYmoxKSkge1xuICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkob2JqMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoxLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZighYXNuMS5lcXVhbHMob2JqMVtpXSwgb2JqMltpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmKHR5cGVvZiBvYmoxICE9PSB0eXBlb2Ygb2JqMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmKHR5cGVvZiBvYmoxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBvYmoxID09PSBvYmoyO1xuICB9XG5cbiAgdmFyIGVxdWFsID0gb2JqMS50YWdDbGFzcyA9PT0gb2JqMi50YWdDbGFzcyAmJlxuICAgIG9iajEudHlwZSA9PT0gb2JqMi50eXBlICYmXG4gICAgb2JqMS5jb25zdHJ1Y3RlZCA9PT0gb2JqMi5jb25zdHJ1Y3RlZCAmJlxuICAgIG9iajEuY29tcG9zZWQgPT09IG9iajIuY29tcG9zZWQgJiZcbiAgICBhc24xLmVxdWFscyhvYmoxLnZhbHVlLCBvYmoyLnZhbHVlKTtcbiAgaWYob3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVCaXRTdHJpbmdDb250ZW50cykge1xuICAgIGVxdWFsID0gZXF1YWwgJiYgKG9iajEuYml0U3RyaW5nQ29udGVudHMgPT09IG9iajIuYml0U3RyaW5nQ29udGVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGVxdWFsO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsZW5ndGggb2YgYSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZS5cbiAqXG4gKiBJbiBjYXNlIHRoZSBsZW5ndGggaXMgbm90IHNwZWNpZmllZCwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBCRVItZW5jb2RlZCBBU04uMSBieXRlIGJ1ZmZlciwgc3RhcnRpbmcgd2l0aCB0aGUgZmlyc3RcbiAqICAgICAgICAgIGxlbmd0aCBieXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgQkVSLWVuY29kZWQgQVNOLjEgdmFsdWUgb3IgdW5kZWZpbmVkLlxuICovXG5hc24xLmdldEJlclZhbHVlTGVuZ3RoID0gZnVuY3Rpb24oYikge1xuICAvLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gYW5kIHJlbGF0ZWQgREVSL0JFUiBmdW5jdGlvbnMgdG8gYSBkZXIuanNcbiAgLy8gZmlsZTsgYmV0dGVyIGFic3RyYWN0IEFTTi4xIGF3YXkgZnJvbSBkZXIvYmVyLlxuICB2YXIgYjIgPSBiLmdldEJ5dGUoKTtcbiAgaWYoYjIgPT09IDB4ODApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gc2VlIGlmIHRoZSBsZW5ndGggaXMgXCJzaG9ydCBmb3JtXCIgb3IgXCJsb25nIGZvcm1cIiAoYml0IDggc2V0KVxuICB2YXIgbGVuZ3RoO1xuICB2YXIgbG9uZ0Zvcm0gPSBiMiAmIDB4ODA7XG4gIGlmKCFsb25nRm9ybSkge1xuICAgIC8vIGxlbmd0aCBpcyBqdXN0IHRoZSBmaXJzdCBieXRlXG4gICAgbGVuZ3RoID0gYjI7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgbGVuZ3RoIGlzIHNwZWNpZmllZCBpbiBiaXRzIDcgdGhyb3VnaCAxXG4gICAgLy8gYW5kIGVhY2ggbGVuZ3RoIGJ5dGUgaXMgaW4gYmlnLWVuZGlhbiBiYXNlLTI1NlxuICAgIGxlbmd0aCA9IGIuZ2V0SW50KChiMiAmIDB4N0YpIDw8IDMpO1xuICB9XG4gIHJldHVybiBsZW5ndGg7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBieXRlIGJ1ZmZlciBoYXMgZW5vdWdoIGJ5dGVzLiBUaHJvd3MgYW4gRXJyb3IgaWYgbm90LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gcGFyc2UgZnJvbS5cbiAqIEBwYXJhbSByZW1haW5pbmcgdGhlIGJ5dGVzIHJlbWFpbmluZyBpbiB0aGUgY3VycmVudCBwYXJzaW5nIHN0YXRlLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIG11c3QgaGF2ZS5cbiAqL1xuZnVuY3Rpb24gX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIG4pIHtcbiAgaWYobiA+IHJlbWFpbmluZykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVG9vIGZldyBieXRlcyB0byBwYXJzZSBERVIuJyk7XG4gICAgZXJyb3IuYXZhaWxhYmxlID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgZXJyb3IucmVtYWluaW5nID0gcmVtYWluaW5nO1xuICAgIGVycm9yLnJlcXVlc3RlZCA9IG47XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsZW5ndGggb2YgYSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZS5cbiAqXG4gKiBJbiBjYXNlIHRoZSBsZW5ndGggaXMgbm90IHNwZWNpZmllZCwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gcGFyc2UgZnJvbS5cbiAqIEBwYXJhbSByZW1haW5pbmcgdGhlIGJ5dGVzIHJlbWFpbmluZyBpbiB0aGUgY3VycmVudCBwYXJzaW5nIHN0YXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgQkVSLWVuY29kZWQgQVNOLjEgdmFsdWUgb3IgdW5kZWZpbmVkLlxuICovXG52YXIgX2dldFZhbHVlTGVuZ3RoID0gZnVuY3Rpb24oYnl0ZXMsIHJlbWFpbmluZykge1xuICAvLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gYW5kIHJlbGF0ZWQgREVSL0JFUiBmdW5jdGlvbnMgdG8gYSBkZXIuanNcbiAgLy8gZmlsZTsgYmV0dGVyIGFic3RyYWN0IEFTTi4xIGF3YXkgZnJvbSBkZXIvYmVyLlxuICAvLyBmcm9tRGVyIGFscmVhZHkgY2hlY2tlZCB0aGF0IHRoaXMgYnl0ZSBleGlzdHNcbiAgdmFyIGIyID0gYnl0ZXMuZ2V0Qnl0ZSgpO1xuICByZW1haW5pbmctLTtcbiAgaWYoYjIgPT09IDB4ODApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gc2VlIGlmIHRoZSBsZW5ndGggaXMgXCJzaG9ydCBmb3JtXCIgb3IgXCJsb25nIGZvcm1cIiAoYml0IDggc2V0KVxuICB2YXIgbGVuZ3RoO1xuICB2YXIgbG9uZ0Zvcm0gPSBiMiAmIDB4ODA7XG4gIGlmKCFsb25nRm9ybSkge1xuICAgIC8vIGxlbmd0aCBpcyBqdXN0IHRoZSBmaXJzdCBieXRlXG4gICAgbGVuZ3RoID0gYjI7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgbGVuZ3RoIGlzIHNwZWNpZmllZCBpbiBiaXRzIDcgdGhyb3VnaCAxXG4gICAgLy8gYW5kIGVhY2ggbGVuZ3RoIGJ5dGUgaXMgaW4gYmlnLWVuZGlhbiBiYXNlLTI1NlxuICAgIHZhciBsb25nRm9ybUJ5dGVzID0gYjIgJiAweDdGO1xuICAgIF9jaGVja0J1ZmZlckxlbmd0aChieXRlcywgcmVtYWluaW5nLCBsb25nRm9ybUJ5dGVzKTtcbiAgICBsZW5ndGggPSBieXRlcy5nZXRJbnQobG9uZ0Zvcm1CeXRlcyA8PCAzKTtcbiAgfVxuICAvLyBGSVhNRTogdGhpcyB3aWxsIG9ubHkgaGFwcGVuIGZvciAzMiBiaXQgZ2V0SW50IHdpdGggaGlnaCBiaXQgc2V0XG4gIGlmKGxlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZ2F0aXZlIGxlbmd0aDogJyArIGxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8qKlxuICogUGFyc2VzIGFuIGFzbjEgb2JqZWN0IGZyb20gYSBieXRlIGJ1ZmZlciBpbiBERVIgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gcGFyc2UgZnJvbS5cbiAqIEBwYXJhbSBbc3RyaWN0XSB0cnVlIHRvIGJlIHN0cmljdCB3aGVuIGNoZWNraW5nIHZhbHVlIGxlbmd0aHMsIGZhbHNlIHRvXG4gKiAgICAgICAgICBhbGxvdyB0cnVuY2F0ZWQgdmFsdWVzIChkZWZhdWx0OiB0cnVlKS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gb2JqZWN0IHdpdGggb3B0aW9ucyBvciBib29sZWFuIHN0cmljdCBmbGFnXG4gKiAgICAgICAgICBbc3RyaWN0XSB0cnVlIHRvIGJlIHN0cmljdCB3aGVuIGNoZWNraW5nIHZhbHVlIGxlbmd0aHMsIGZhbHNlIHRvXG4gKiAgICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICogICAgICAgICAgW2RlY29kZUJpdFN0cmluZ3NdIHRydWUgdG8gYXR0ZW1wdCB0byBkZWNvZGUgdGhlIGNvbnRlbnQgb2ZcbiAqICAgICAgICAgICAgQklUIFNUUklOR3MgKG5vdCBPQ1RFVCBTVFJJTkdzKSB1c2luZyBzdHJpY3QgbW9kZS4gTm90ZSB0aGF0XG4gKiAgICAgICAgICAgIHdpdGhvdXQgc2NoZW1hIHN1cHBvcnQgdG8gdW5kZXJzdGFuZCB0aGUgZGF0YSBjb250ZXh0IHRoaXMgY2FuXG4gKiAgICAgICAgICAgIGVycm9uZW91c2x5IGRlY29kZSB2YWx1ZXMgdGhhdCBoYXBwZW4gdG8gYmUgdmFsaWQgQVNOLjEuIFRoaXNcbiAqICAgICAgICAgICAgZmxhZyB3aWxsIGJlIGRlcHJlY2F0ZWQgb3IgcmVtb3ZlZCBhcyBzb29uIGFzIHNjaGVtYSBzdXBwb3J0IGlzXG4gKiAgICAgICAgICAgIGF2YWlsYWJsZS4gKGRlZmF1bHQ6IHRydWUpXG4gKlxuICogQHJldHVybiB0aGUgcGFyc2VkIGFzbjEgb2JqZWN0LlxuICovXG5hc24xLmZyb21EZXIgPSBmdW5jdGlvbihieXRlcywgb3B0aW9ucykge1xuICBpZihvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgZGVjb2RlQml0U3RyaW5nczogdHJ1ZVxuICAgIH07XG4gIH1cbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBzdHJpY3Q6IG9wdGlvbnMsXG4gICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgfTtcbiAgfVxuICBpZighKCdzdHJpY3QnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5zdHJpY3QgPSB0cnVlO1xuICB9XG4gIGlmKCEoJ2RlY29kZUJpdFN0cmluZ3MnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5kZWNvZGVCaXRTdHJpbmdzID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIHdyYXAgaW4gYnVmZmVyIGlmIG5lZWRlZFxuICBpZih0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihieXRlcyk7XG4gIH1cblxuICByZXR1cm4gX2Zyb21EZXIoYnl0ZXMsIGJ5dGVzLmxlbmd0aCgpLCAwLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gcGFyc2UgYW4gYXNuMSBvYmplY3QgZnJvbSBhIGJ5dGUgYnVmZmVyIGluIERFUiBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIHJlbWFpbmluZyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHJlbWFpbmluZyBmb3IgdGhpcyBjaHVuay5cbiAqIEBwYXJhbSBkZXB0aCB0aGUgY3VycmVudCBwYXJzaW5nIGRlcHRoLlxuICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHdpdGggc2FtZSBvcHRpb25zIGFzIGZyb21EZXIoKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwYXJzZWQgYXNuMSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIF9mcm9tRGVyKGJ5dGVzLCByZW1haW5pbmcsIGRlcHRoLCBvcHRpb25zKSB7XG4gIC8vIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb25zdW1wdGlvbiBjYWxjdWxhdGlvbnNcbiAgdmFyIHN0YXJ0O1xuXG4gIC8vIG1pbmltdW0gbGVuZ3RoIGZvciBBU04uMSBERVIgc3RydWN0dXJlIGlzIDJcbiAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDIpO1xuXG4gIC8vIGdldCB0aGUgZmlyc3QgYnl0ZVxuICB2YXIgYjEgPSBieXRlcy5nZXRCeXRlKCk7XG4gIC8vIGNvbnN1bWVkIG9uZSBieXRlXG4gIHJlbWFpbmluZy0tO1xuXG4gIC8vIGdldCB0aGUgdGFnIGNsYXNzXG4gIHZhciB0YWdDbGFzcyA9IChiMSAmIDB4QzApO1xuXG4gIC8vIGdldCB0aGUgdHlwZSAoYml0cyAxLTUpXG4gIHZhciB0eXBlID0gYjEgJiAweDFGO1xuXG4gIC8vIGdldCB0aGUgdmFyaWFibGUgdmFsdWUgbGVuZ3RoIGFuZCBhZGp1c3QgcmVtYWluaW5nIGJ5dGVzXG4gIHN0YXJ0ID0gYnl0ZXMubGVuZ3RoKCk7XG4gIHZhciBsZW5ndGggPSBfZ2V0VmFsdWVMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZyk7XG4gIHJlbWFpbmluZyAtPSBzdGFydCAtIGJ5dGVzLmxlbmd0aCgpO1xuXG4gIC8vIGVuc3VyZSB0aGVyZSBhcmUgZW5vdWdoIGJ5dGVzIHRvIGdldCB0aGUgdmFsdWVcbiAgaWYobGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgbGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgaWYob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVG9vIGZldyBieXRlcyB0byByZWFkIEFTTi4xIHZhbHVlLicpO1xuICAgICAgZXJyb3IuYXZhaWxhYmxlID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICBlcnJvci5yZW1haW5pbmcgPSByZW1haW5pbmc7XG4gICAgICBlcnJvci5yZXF1ZXN0ZWQgPSBsZW5ndGg7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLy8gTm90ZTogYmUgbGVuaWVudCB3aXRoIHRydW5jYXRlZCB2YWx1ZXMgYW5kIHVzZSByZW1haW5pbmcgc3RhdGUgYnl0ZXNcbiAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gIH1cblxuICAvLyB2YWx1ZSBzdG9yYWdlXG4gIHZhciB2YWx1ZTtcbiAgLy8gcG9zc2libGUgQklUIFNUUklORyBjb250ZW50cyBzdG9yYWdlXG4gIHZhciBiaXRTdHJpbmdDb250ZW50cztcblxuICAvLyBjb25zdHJ1Y3RlZCBmbGFnIGlzIGJpdCA2ICgzMiA9IDB4MjApIG9mIHRoZSBmaXJzdCBieXRlXG4gIHZhciBjb25zdHJ1Y3RlZCA9ICgoYjEgJiAweDIwKSA9PT0gMHgyMCk7XG4gIGlmKGNvbnN0cnVjdGVkKSB7XG4gICAgLy8gcGFyc2UgY2hpbGQgYXNuMSBvYmplY3RzIGZyb20gdGhlIHZhbHVlXG4gICAgdmFsdWUgPSBbXTtcbiAgICBpZihsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYXNuMSBvYmplY3Qgb2YgaW5kZWZpbml0ZSBsZW5ndGgsIHJlYWQgdW50aWwgZW5kIHRhZ1xuICAgICAgZm9yKDs7KSB7XG4gICAgICAgIF9jaGVja0J1ZmZlckxlbmd0aChieXRlcywgcmVtYWluaW5nLCAyKTtcbiAgICAgICAgaWYoYnl0ZXMuYnl0ZXMoMikgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMCkpIHtcbiAgICAgICAgICBieXRlcy5nZXRCeXRlcygyKTtcbiAgICAgICAgICByZW1haW5pbmcgLT0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YWx1ZS5wdXNoKF9mcm9tRGVyKGJ5dGVzLCByZW1haW5pbmcsIGRlcHRoICsgMSwgb3B0aW9ucykpO1xuICAgICAgICByZW1haW5pbmcgLT0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGFyc2luZyBhc24xIG9iamVjdCBvZiBkZWZpbml0ZSBsZW5ndGhcbiAgICAgIHdoaWxlKGxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RhcnQgPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgdmFsdWUucHVzaChfZnJvbURlcihieXRlcywgbGVuZ3RoLCBkZXB0aCArIDEsIG9wdGlvbnMpKTtcbiAgICAgICAgcmVtYWluaW5nIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICAgIGxlbmd0aCAtPSBzdGFydCAtIGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGlmIGEgQklUIFNUUklORywgc2F2ZSB0aGUgY29udGVudHMgaW5jbHVkaW5nIHBhZGRpbmdcbiAgaWYodmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0YWdDbGFzcyA9PT0gYXNuMS5DbGFzcy5VTklWRVJTQUwgJiZcbiAgICB0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HKSB7XG4gICAgYml0U3RyaW5nQ29udGVudHMgPSBieXRlcy5ieXRlcyhsZW5ndGgpO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGlmIGEgbm9uLWNvbnN0cnVjdGVkIHZhbHVlIHNob3VsZCBiZSBkZWNvZGVkIGFzIGEgY29tcG9zZWRcbiAgLy8gdmFsdWUgdGhhdCBjb250YWlucyBvdGhlciBBU04uMSBvYmplY3RzLiBCSVQgU1RSSU5HcyAoYW5kIE9DVEVUIFNUUklOR3MpXG4gIC8vIGNhbiBiZSB1c2VkIHRoaXMgd2F5LlxuICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuZGVjb2RlQml0U3RyaW5ncyAmJlxuICAgIHRhZ0NsYXNzID09PSBhc24xLkNsYXNzLlVOSVZFUlNBTCAmJlxuICAgIC8vIEZJWE1FOiBPQ1RFVCBTVFJJTkdzIG5vdCB5ZXQgc3VwcG9ydGVkIGhlcmVcbiAgICAvLyAuLiBvdGhlciBwYXJ0cyBvZiBmb3JnZSBleHBlY3QgdG8gZGVjb2RlIE9DVEVUIFNUUklOR3MgbWFudWFsbHlcbiAgICAodHlwZSA9PT0gYXNuMS5UeXBlLkJJVFNUUklORyAvKnx8IHR5cGUgPT09IGFzbjEuVHlwZS5PQ1RFVFNUUklORyovKSAmJlxuICAgIGxlbmd0aCA+IDEpIHtcbiAgICAvLyBzYXZlIHJlYWQgcG9zaXRpb25cbiAgICB2YXIgc2F2ZWRSZWFkID0gYnl0ZXMucmVhZDtcbiAgICB2YXIgc2F2ZWRSZW1haW5pbmcgPSByZW1haW5pbmc7XG4gICAgdmFyIHVudXNlZCA9IDA7XG4gICAgaWYodHlwZSA9PT0gYXNuMS5UeXBlLkJJVFNUUklORykge1xuICAgICAgLyogVGhlIGZpcnN0IG9jdGV0IGdpdmVzIHRoZSBudW1iZXIgb2YgYml0cyBieSB3aGljaCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgICAgICBiaXQgc3RyaW5nIGlzIGxlc3MgdGhhbiB0aGUgbmV4dCBtdWx0aXBsZSBvZiBlaWdodCAodGhpcyBpcyBjYWxsZWRcbiAgICAgICAgdGhlIFwibnVtYmVyIG9mIHVudXNlZCBiaXRzXCIpLlxuXG4gICAgICAgIFRoZSBzZWNvbmQgYW5kIGZvbGxvd2luZyBvY3RldHMgZ2l2ZSB0aGUgdmFsdWUgb2YgdGhlIGJpdCBzdHJpbmdcbiAgICAgICAgY29udmVydGVkIHRvIGFuIG9jdGV0IHN0cmluZy4gKi9cbiAgICAgIF9jaGVja0J1ZmZlckxlbmd0aChieXRlcywgcmVtYWluaW5nLCAxKTtcbiAgICAgIHVudXNlZCA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgICAgIHJlbWFpbmluZy0tO1xuICAgIH1cbiAgICAvLyBpZiBhbGwgYml0cyBhcmUgdXNlZCwgbWF5YmUgdGhlIEJJVC9PQ1RFVCBTVFJJTkcgaG9sZHMgQVNOLjEgb2Jqc1xuICAgIGlmKHVudXNlZCA9PT0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gYXR0ZW1wdCB0byBwYXJzZSBjaGlsZCBhc24xIG9iamVjdCBmcm9tIHRoZSB2YWx1ZVxuICAgICAgICAvLyAoc3RvcmVkIGluIGFycmF5IHRvIHNpZ25hbCBjb21wb3NlZCB2YWx1ZSlcbiAgICAgICAgc3RhcnQgPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgdmFyIHN1Yk9wdGlvbnMgPSB7XG4gICAgICAgICAgLy8gZW5mb3JjZSBzdHJpY3QgbW9kZSB0byBhdm9pZCBwYXJzaW5nIEFTTi4xIGZyb20gcGxhaW4gZGF0YVxuICAgICAgICAgIHZlcmJvc2U6IG9wdGlvbnMudmVyYm9zZSxcbiAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgZGVjb2RlQml0U3RyaW5nczogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29tcG9zZWQgPSBfZnJvbURlcihieXRlcywgcmVtYWluaW5nLCBkZXB0aCArIDEsIHN1Yk9wdGlvbnMpO1xuICAgICAgICB2YXIgdXNlZCA9IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICAgIHJlbWFpbmluZyAtPSB1c2VkO1xuICAgICAgICBpZih0eXBlID09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICAgICAgICB1c2VkKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgZGF0YSBhbGwgZGVjb2RlZCBhbmQgdGhlIGNsYXNzIGluZGljYXRlcyBVTklWRVJTQUwgb3JcbiAgICAgICAgLy8gQ09OVEVYVF9TUEVDSUZJQyB0aGVuIGFzc3VtZSB3ZSd2ZSBnb3QgYW4gZW5jYXBzdWxhdGVkIEFTTi4xIG9iamVjdFxuICAgICAgICB2YXIgdGMgPSBjb21wb3NlZC50YWdDbGFzcztcbiAgICAgICAgaWYodXNlZCA9PT0gbGVuZ3RoICYmXG4gICAgICAgICAgKHRjID09PSBhc24xLkNsYXNzLlVOSVZFUlNBTCB8fCB0YyA9PT0gYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDKSkge1xuICAgICAgICAgIHZhbHVlID0gW2NvbXBvc2VkXTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaChleCkge1xuICAgICAgfVxuICAgIH1cbiAgICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXN0b3JlIHJlYWQgcG9zaXRpb25cbiAgICAgIGJ5dGVzLnJlYWQgPSBzYXZlZFJlYWQ7XG4gICAgICByZW1haW5pbmcgPSBzYXZlZFJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gYXNuMSBub3QgY29uc3RydWN0ZWQgb3IgY29tcG9zZWQsIGdldCByYXcgdmFsdWVcbiAgICAvLyBUT0RPOiBkbyBERVIgdG8gT0lEIGNvbnZlcnNpb24gYW5kIHZpY2UtdmVyc2EgaW4gLnRvRGVyP1xuXG4gICAgaWYobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLWNvbnN0cnVjdGVkIEFTTi4xIG9iamVjdCBvZiBpbmRlZmluaXRlIGxlbmd0aC4nKTtcbiAgICAgIH1cbiAgICAgIC8vIGJlIGxlbmllbnQgYW5kIHVzZSByZW1haW5pbmcgc3RhdGUgYnl0ZXNcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG5cbiAgICBpZih0eXBlID09PSBhc24xLlR5cGUuQk1QU1RSSU5HKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgICAgZm9yKDsgbGVuZ3RoID4gMDsgbGVuZ3RoIC09IDIpIHtcbiAgICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDIpO1xuICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzLmdldEludDE2KCkpO1xuICAgICAgICByZW1haW5pbmcgLT0gMjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBieXRlcy5nZXRCeXRlcyhsZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBCSVQgU1RSSU5HIGNvbnRlbnRzIGlmIGF2YWlsYWJsZVxuICB2YXIgYXNuMU9wdGlvbnMgPSBiaXRTdHJpbmdDb250ZW50cyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHtcbiAgICBiaXRTdHJpbmdDb250ZW50czogYml0U3RyaW5nQ29udGVudHNcbiAgfTtcblxuICAvLyBjcmVhdGUgYW5kIHJldHVybiBhc24xIG9iamVjdFxuICByZXR1cm4gYXNuMS5jcmVhdGUodGFnQ2xhc3MsIHR5cGUsIGNvbnN0cnVjdGVkLCB2YWx1ZSwgYXNuMU9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBhc24xIG9iamVjdCB0byBhIGJ1ZmZlciBvZiBieXRlcyBpbiBERVIgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBhc24xIHRoZSBhc24xIG9iamVjdCB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ1ZmZlciBvZiBieXRlcy5cbiAqL1xuYXNuMS50b0RlciA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGJ1aWxkIHRoZSBmaXJzdCBieXRlXG4gIHZhciBiMSA9IG9iai50YWdDbGFzcyB8IG9iai50eXBlO1xuXG4gIC8vIGZvciBzdG9yaW5nIHRoZSBBU04uMSB2YWx1ZVxuICB2YXIgdmFsdWUgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIHVzZSBCSVQgU1RSSU5HIGNvbnRlbnRzIGlmIGF2YWlsYWJsZSBhbmQgZGF0YSBub3QgY2hhbmdlZFxuICB2YXIgdXNlQml0U3RyaW5nQ29udGVudHMgPSBmYWxzZTtcbiAgaWYoJ2JpdFN0cmluZ0NvbnRlbnRzJyBpbiBvYmopIHtcbiAgICB1c2VCaXRTdHJpbmdDb250ZW50cyA9IHRydWU7XG4gICAgaWYob2JqLm9yaWdpbmFsKSB7XG4gICAgICB1c2VCaXRTdHJpbmdDb250ZW50cyA9IGFzbjEuZXF1YWxzKG9iaiwgb2JqLm9yaWdpbmFsKTtcbiAgICB9XG4gIH1cblxuICBpZih1c2VCaXRTdHJpbmdDb250ZW50cykge1xuICAgIHZhbHVlLnB1dEJ5dGVzKG9iai5iaXRTdHJpbmdDb250ZW50cyk7XG4gIH0gZWxzZSBpZihvYmouY29tcG9zZWQpIHtcbiAgICAvLyBpZiBjb21wb3NlZCwgdXNlIGVhY2ggY2hpbGQgYXNuMSBvYmplY3QncyBERVIgYnl0ZXMgYXMgdmFsdWVcbiAgICAvLyB0dXJuIG9uIDZ0aCBiaXQgKDB4MjAgPSAzMikgdG8gaW5kaWNhdGUgYXNuMSBpcyBjb25zdHJ1Y3RlZFxuICAgIC8vIGZyb20gb3RoZXIgYXNuMSBvYmplY3RzXG4gICAgaWYob2JqLmNvbnN0cnVjdGVkKSB7XG4gICAgICBiMSB8PSAweDIwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0eXBlIGlzIGEgYml0IHN0cmluZywgYWRkIHVudXNlZCBiaXRzIG9mIDB4MDBcbiAgICAgIHZhbHVlLnB1dEJ5dGUoMHgwMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGFsbCBvZiB0aGUgY2hpbGQgREVSIGJ5dGVzIHRvZ2V0aGVyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYob2JqLnZhbHVlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUucHV0QnVmZmVyKGFzbjEudG9EZXIob2JqLnZhbHVlW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBhc24xLnZhbHVlIGRpcmVjdGx5XG4gICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5CTVBTVFJJTkcpIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsdWUucHV0SW50MTYob2JqLnZhbHVlLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnN1cmUgaW50ZWdlciBpcyBtaW5pbWFsbHktZW5jb2RlZFxuICAgICAgLy8gVE9ETzogc2hvdWxkIGFsbCBsZWFkaW5nIGJ5dGVzIGJlIHN0cmlwcGVkIHZzIGp1c3Qgb25lP1xuICAgICAgLy8gLi4gZXggJzAwIDAwIDAxJyA9PiAnMDEnP1xuICAgICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JTlRFR0VSICYmXG4gICAgICAgIG9iai52YWx1ZS5sZW5ndGggPiAxICYmXG4gICAgICAgIC8vIGxlYWRpbmcgMHgwMCBmb3IgcG9zaXRpdmUgaW50ZWdlclxuICAgICAgICAoKG9iai52YWx1ZS5jaGFyQ29kZUF0KDApID09PSAwICYmXG4gICAgICAgIChvYmoudmFsdWUuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAwKSB8fFxuICAgICAgICAvLyBsZWFkaW5nIDB4RkYgZm9yIG5lZ2F0aXZlIGludGVnZXJcbiAgICAgICAgKG9iai52YWx1ZS5jaGFyQ29kZUF0KDApID09PSAweEZGICYmXG4gICAgICAgIChvYmoudmFsdWUuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAweDgwKSkpIHtcbiAgICAgICAgdmFsdWUucHV0Qnl0ZXMob2JqLnZhbHVlLnN1YnN0cigxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZS5wdXRCeXRlcyhvYmoudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCB0YWcgYnl0ZVxuICBieXRlcy5wdXRCeXRlKGIxKTtcblxuICAvLyB1c2UgXCJzaG9ydCBmb3JtXCIgZW5jb2RpbmdcbiAgaWYodmFsdWUubGVuZ3RoKCkgPD0gMTI3KSB7XG4gICAgLy8gb25lIGJ5dGUgZGVzY3JpYmVzIHRoZSBsZW5ndGhcbiAgICAvLyBiaXQgOCA9IDAgYW5kIGJpdHMgNy0xID0gbGVuZ3RoXG4gICAgYnl0ZXMucHV0Qnl0ZSh2YWx1ZS5sZW5ndGgoKSAmIDB4N0YpO1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBcImxvbmcgZm9ybVwiIGVuY29kaW5nXG4gICAgLy8gMiB0byAxMjcgYnl0ZXMgZGVzY3JpYmUgdGhlIGxlbmd0aFxuICAgIC8vIGZpcnN0IGJ5dGU6IGJpdCA4ID0gMSBhbmQgYml0cyA3LTEgPSAjIG9mIGFkZGl0aW9uYWwgYnl0ZXNcbiAgICAvLyBvdGhlciBieXRlczogbGVuZ3RoIGluIGJhc2UgMjU2LCBiaWctZW5kaWFuXG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCgpO1xuICAgIHZhciBsZW5CeXRlcyA9ICcnO1xuICAgIGRvIHtcbiAgICAgIGxlbkJ5dGVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuICYgMHhGRik7XG4gICAgICBsZW4gPSBsZW4gPj4+IDg7XG4gICAgfSB3aGlsZShsZW4gPiAwKTtcblxuICAgIC8vIHNldCBmaXJzdCBieXRlIHRvICMgYnl0ZXMgdXNlZCB0byBzdG9yZSB0aGUgbGVuZ3RoIGFuZCB0dXJuIG9uXG4gICAgLy8gYml0IDggdG8gaW5kaWNhdGUgbG9uZy1mb3JtIGxlbmd0aCBpcyB1c2VkXG4gICAgYnl0ZXMucHV0Qnl0ZShsZW5CeXRlcy5sZW5ndGggfCAweDgwKTtcblxuICAgIC8vIGNvbmNhdGVuYXRlIGxlbmd0aCBieXRlcyBpbiByZXZlcnNlIHNpbmNlIHRoZXkgd2VyZSBnZW5lcmF0ZWRcbiAgICAvLyBsaXR0bGUgZW5kaWFuIGFuZCB3ZSBuZWVkIGJpZyBlbmRpYW5cbiAgICBmb3IodmFyIGkgPSBsZW5CeXRlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgYnl0ZXMucHV0Qnl0ZShsZW5CeXRlcy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH1cblxuICAvLyBjb25jYXRlbmF0ZSB2YWx1ZSBieXRlc1xuICBieXRlcy5wdXRCdWZmZXIodmFsdWUpO1xuICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZyB0byBhIGJ5dGUgYnVmZmVyLiBUaGUgYnl0ZSBidWZmZXJcbiAqIGNvbnRhaW5zIG9ubHkgdGhlIERFUi1lbmNvZGVkIHZhbHVlLCBub3QgYW55IHRhZyBvciBsZW5ndGggYnl0ZXMuXG4gKlxuICogQHBhcmFtIG9pZCB0aGUgT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUgYnVmZmVyLlxuICovXG5hc24xLm9pZFRvRGVyID0gZnVuY3Rpb24ob2lkKSB7XG4gIC8vIHNwbGl0IE9JRCBpbnRvIGluZGl2aWR1YWwgdmFsdWVzXG4gIHZhciB2YWx1ZXMgPSBvaWQuc3BsaXQoJy4nKTtcbiAgdmFyIGJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyBmaXJzdCBieXRlIGlzIDQwICogdmFsdWUxICsgdmFsdWUyXG4gIGJ5dGVzLnB1dEJ5dGUoNDAgKiBwYXJzZUludCh2YWx1ZXNbMF0sIDEwKSArIHBhcnNlSW50KHZhbHVlc1sxXSwgMTApKTtcbiAgLy8gb3RoZXIgYnl0ZXMgYXJlIGVhY2ggdmFsdWUgaW4gYmFzZSAxMjggd2l0aCA4dGggYml0IHNldCBleGNlcHQgZm9yXG4gIC8vIHRoZSBsYXN0IGJ5dGUgZm9yIGVhY2ggdmFsdWVcbiAgdmFyIGxhc3QsIHZhbHVlQnl0ZXMsIHZhbHVlLCBiO1xuICBmb3IodmFyIGkgPSAyOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gcHJvZHVjZSB2YWx1ZSBieXRlcyBpbiByZXZlcnNlIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyBob3cgbWFueVxuICAgIC8vIGJ5dGVzIGl0IHdpbGwgdGFrZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICBsYXN0ID0gdHJ1ZTtcbiAgICB2YWx1ZUJ5dGVzID0gW107XG4gICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZXNbaV0sIDEwKTtcbiAgICBkbyB7XG4gICAgICBiID0gdmFsdWUgJiAweDdGO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcbiAgICAgIC8vIGlmIHZhbHVlIGlzIG5vdCBsYXN0LCB0aGVuIHR1cm4gb24gOHRoIGJpdFxuICAgICAgaWYoIWxhc3QpIHtcbiAgICAgICAgYiB8PSAweDgwO1xuICAgICAgfVxuICAgICAgdmFsdWVCeXRlcy5wdXNoKGIpO1xuICAgICAgbGFzdCA9IGZhbHNlO1xuICAgIH0gd2hpbGUodmFsdWUgPiAwKTtcblxuICAgIC8vIGFkZCB2YWx1ZSBieXRlcyBpbiByZXZlcnNlIChuZWVkcyB0byBiZSBpbiBiaWcgZW5kaWFuKVxuICAgIGZvcih2YXIgbiA9IHZhbHVlQnl0ZXMubGVuZ3RoIC0gMTsgbiA+PSAwOyAtLW4pIHtcbiAgICAgIGJ5dGVzLnB1dEJ5dGUodmFsdWVCeXRlc1tuXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIGJ5dGUgYnVmZmVyIHRvIGFuIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZy4gVGhlXG4gKiBieXRlIGJ1ZmZlciBzaG91bGQgY29udGFpbiBvbmx5IHRoZSBERVItZW5jb2RlZCB2YWx1ZSwgbm90IGFueSB0YWcgb3JcbiAqIGxlbmd0aCBieXRlcy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZy5cbiAqL1xuYXNuMS5kZXJUb09pZCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHZhciBvaWQ7XG5cbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIC8vIGZpcnN0IGJ5dGUgaXMgNDAgKiB2YWx1ZTEgKyB2YWx1ZTJcbiAgdmFyIGIgPSBieXRlcy5nZXRCeXRlKCk7XG4gIG9pZCA9IE1hdGguZmxvb3IoYiAvIDQwKSArICcuJyArIChiICUgNDApO1xuXG4gIC8vIG90aGVyIGJ5dGVzIGFyZSBlYWNoIHZhbHVlIGluIGJhc2UgMTI4IHdpdGggOHRoIGJpdCBzZXQgZXhjZXB0IGZvclxuICAvLyB0aGUgbGFzdCBieXRlIGZvciBlYWNoIHZhbHVlXG4gIHZhciB2YWx1ZSA9IDA7XG4gIHdoaWxlKGJ5dGVzLmxlbmd0aCgpID4gMCkge1xuICAgIGIgPSBieXRlcy5nZXRCeXRlKCk7XG4gICAgdmFsdWUgPSB2YWx1ZSA8PCA3O1xuICAgIC8vIG5vdCB0aGUgbGFzdCBieXRlIGZvciB0aGUgdmFsdWVcbiAgICBpZihiICYgMHg4MCkge1xuICAgICAgdmFsdWUgKz0gYiAmIDB4N0Y7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxhc3QgYnl0ZVxuICAgICAgb2lkICs9ICcuJyArICh2YWx1ZSArIGIpO1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvaWQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVVRDVGltZSB2YWx1ZSB0byBhIGRhdGUuXG4gKlxuICogTm90ZTogR2VuZXJhbGl6ZWRUaW1lIGhhcyA0IGRpZ2l0cyBmb3IgdGhlIHllYXIgYW5kIGlzIHVzZWQgZm9yIFguNTA5XG4gKiBkYXRlcyBwYXN0IDIwNDkuIFBhcnNpbmcgdGhhdCBzdHJ1Y3R1cmUgaGFzbid0IGJlZW4gaW1wbGVtZW50ZWQgeWV0LlxuICpcbiAqIEBwYXJhbSB1dGMgdGhlIFVUQ1RpbWUgdmFsdWUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkYXRlLlxuICovXG5hc24xLnV0Y1RpbWVUb0RhdGUgPSBmdW5jdGlvbih1dGMpIHtcbiAgLyogVGhlIGZvbGxvd2luZyBmb3JtYXRzIGNhbiBiZSB1c2VkOlxuXG4gICAgWVlNTUREaGhtbVpcbiAgICBZWU1NRERoaG1tK2hoJ21tJ1xuICAgIFlZTU1ERGhobW0taGgnbW0nXG4gICAgWVlNTUREaGhtbXNzWlxuICAgIFlZTU1ERGhobW1zcytoaCdtbSdcbiAgICBZWU1NRERoaG1tc3MtaGgnbW0nXG5cbiAgICBXaGVyZTpcblxuICAgIFlZIGlzIHRoZSBsZWFzdCBzaWduaWZpY2FudCB0d28gZGlnaXRzIG9mIHRoZSB5ZWFyXG4gICAgTU0gaXMgdGhlIG1vbnRoICgwMSB0byAxMilcbiAgICBERCBpcyB0aGUgZGF5ICgwMSB0byAzMSlcbiAgICBoaCBpcyB0aGUgaG91ciAoMDAgdG8gMjMpXG4gICAgbW0gYXJlIHRoZSBtaW51dGVzICgwMCB0byA1OSlcbiAgICBzcyBhcmUgdGhlIHNlY29uZHMgKDAwIHRvIDU5KVxuICAgIFogaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBHTVQsICsgaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpc1xuICAgIGxhdGVyIHRoYW4gR01ULCBhbmQgLSBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzIGVhcmxpZXIgdGhhbiBHTVRcbiAgICBoaCcgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gaG91cnNcbiAgICBtbScgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gbWludXRlcyAqL1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgLy8gaWYgWVkgPj0gNTAgdXNlIDE5eHgsIGlmIFlZIDwgNTAgdXNlIDIweHhcbiAgdmFyIHllYXIgPSBwYXJzZUludCh1dGMuc3Vic3RyKDAsIDIpLCAxMCk7XG4gIHllYXIgPSAoeWVhciA+PSA1MCkgPyAxOTAwICsgeWVhciA6IDIwMDAgKyB5ZWFyO1xuICB2YXIgTU0gPSBwYXJzZUludCh1dGMuc3Vic3RyKDIsIDIpLCAxMCkgLSAxOyAvLyB1c2UgMC0xMSBmb3IgbW9udGhcbiAgdmFyIEREID0gcGFyc2VJbnQodXRjLnN1YnN0cig0LCAyKSwgMTApO1xuICB2YXIgaGggPSBwYXJzZUludCh1dGMuc3Vic3RyKDYsIDIpLCAxMCk7XG4gIHZhciBtbSA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoOCwgMiksIDEwKTtcbiAgdmFyIHNzID0gMDtcblxuICAvLyBub3QganVzdCBZWU1NRERoaG1tWlxuICBpZih1dGMubGVuZ3RoID4gMTEpIHtcbiAgICAvLyBnZXQgY2hhcmFjdGVyIGFmdGVyIG1pbnV0ZXNcbiAgICB2YXIgYyA9IHV0Yy5jaGFyQXQoMTApO1xuICAgIHZhciBlbmQgPSAxMDtcblxuICAgIC8vIHNlZSBpZiBzZWNvbmRzIGFyZSBwcmVzZW50XG4gICAgaWYoYyAhPT0gJysnICYmIGMgIT09ICctJykge1xuICAgICAgLy8gZ2V0IHNlY29uZHNcbiAgICAgIHNzID0gcGFyc2VJbnQodXRjLnN1YnN0cigxMCwgMiksIDEwKTtcbiAgICAgIGVuZCArPSAyO1xuICAgIH1cbiAgfVxuXG4gIC8vIHVwZGF0ZSBkYXRlXG4gIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgTU0sIEREKTtcbiAgZGF0ZS5zZXRVVENIb3VycyhoaCwgbW0sIHNzLCAwKTtcblxuICBpZihlbmQpIHtcbiAgICAvLyBnZXQgKy8tIGFmdGVyIGVuZCBvZiB0aW1lXG4gICAgYyA9IHV0Yy5jaGFyQXQoZW5kKTtcbiAgICBpZihjID09PSAnKycgfHwgYyA9PT0gJy0nKSB7XG4gICAgICAvLyBnZXQgaG91cnMrbWludXRlcyBvZmZzZXRcbiAgICAgIHZhciBoaG9mZnNldCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoZW5kICsgMSwgMiksIDEwKTtcbiAgICAgIHZhciBtbW9mZnNldCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoZW5kICsgNCwgMiksIDEwKTtcblxuICAgICAgLy8gY2FsY3VsYXRlIG9mZnNldCBpbiBtaWxsaXNlY29uZHNcbiAgICAgIHZhciBvZmZzZXQgPSBoaG9mZnNldCAqIDYwICsgbW1vZmZzZXQ7XG4gICAgICBvZmZzZXQgKj0gNjAwMDA7XG5cbiAgICAgIC8vIGFwcGx5IG9mZnNldFxuICAgICAgaWYoYyA9PT0gJysnKSB7XG4gICAgICAgIGRhdGUuc2V0VGltZSgrZGF0ZSAtIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEdlbmVyYWxpemVkVGltZSB2YWx1ZSB0byBhIGRhdGUuXG4gKlxuICogQHBhcmFtIGdlbnRpbWUgdGhlIEdlbmVyYWxpemVkVGltZSB2YWx1ZSB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGRhdGUuXG4gKi9cbmFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlID0gZnVuY3Rpb24oZ2VudGltZSkge1xuICAvKiBUaGUgZm9sbG93aW5nIGZvcm1hdHMgY2FuIGJlIHVzZWQ6XG5cbiAgICBZWVlZTU1EREhITU1TU1xuICAgIFlZWVlNTURESEhNTVNTLmZmZlxuICAgIFlZWVlNTURESEhNTVNTWlxuICAgIFlZWVlNTURESEhNTVNTLmZmZlpcbiAgICBZWVlZTU1EREhITU1TUytoaCdtbSdcbiAgICBZWVlZTU1EREhITU1TUy5mZmYraGgnbW0nXG4gICAgWVlZWU1NRERISE1NU1MtaGgnbW0nXG4gICAgWVlZWU1NRERISE1NU1MuZmZmLWhoJ21tJ1xuXG4gICAgV2hlcmU6XG5cbiAgICBZWVlZIGlzIHRoZSB5ZWFyXG4gICAgTU0gaXMgdGhlIG1vbnRoICgwMSB0byAxMilcbiAgICBERCBpcyB0aGUgZGF5ICgwMSB0byAzMSlcbiAgICBoaCBpcyB0aGUgaG91ciAoMDAgdG8gMjMpXG4gICAgbW0gYXJlIHRoZSBtaW51dGVzICgwMCB0byA1OSlcbiAgICBzcyBhcmUgdGhlIHNlY29uZHMgKDAwIHRvIDU5KVxuICAgIC5mZmYgaXMgdGhlIHNlY29uZCBmcmFjdGlvbiwgYWNjdXJhdGUgdG8gdGhyZWUgZGVjaW1hbCBwbGFjZXNcbiAgICBaIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXMgR01ULCArIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXNcbiAgICBsYXRlciB0aGFuIEdNVCwgYW5kIC0gaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBlYXJsaWVyIHRoYW4gR01UXG4gICAgaGgnIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgb2Zmc2V0IGZyb20gR01UIGluIGhvdXJzXG4gICAgbW0nIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgb2Zmc2V0IGZyb20gR01UIGluIG1pbnV0ZXMgKi9cbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gIHZhciBZWVlZID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoMCwgNCksIDEwKTtcbiAgdmFyIE1NID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoNCwgMiksIDEwKSAtIDE7IC8vIHVzZSAwLTExIGZvciBtb250aFxuICB2YXIgREQgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig2LCAyKSwgMTApO1xuICB2YXIgaGggPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig4LCAyKSwgMTApO1xuICB2YXIgbW0gPSBwYXJzZUludChnZW50aW1lLnN1YnN0cigxMCwgMiksIDEwKTtcbiAgdmFyIHNzID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoMTIsIDIpLCAxMCk7XG4gIHZhciBmZmYgPSAwO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIGlzVVRDID0gZmFsc2U7XG5cbiAgaWYoZ2VudGltZS5jaGFyQXQoZ2VudGltZS5sZW5ndGggLSAxKSA9PT0gJ1onKSB7XG4gICAgaXNVVEMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGVuZCA9IGdlbnRpbWUubGVuZ3RoIC0gNSwgYyA9IGdlbnRpbWUuY2hhckF0KGVuZCk7XG4gIGlmKGMgPT09ICcrJyB8fCBjID09PSAnLScpIHtcbiAgICAvLyBnZXQgaG91cnMrbWludXRlcyBvZmZzZXRcbiAgICB2YXIgaGhvZmZzZXQgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cihlbmQgKyAxLCAyKSwgMTApO1xuICAgIHZhciBtbW9mZnNldCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKGVuZCArIDQsIDIpLCAxMCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kc1xuICAgIG9mZnNldCA9IGhob2Zmc2V0ICogNjAgKyBtbW9mZnNldDtcbiAgICBvZmZzZXQgKj0gNjAwMDA7XG5cbiAgICAvLyBhcHBseSBvZmZzZXRcbiAgICBpZihjID09PSAnKycpIHtcbiAgICAgIG9mZnNldCAqPSAtMTtcbiAgICB9XG5cbiAgICBpc1VUQyA9IHRydWU7XG4gIH1cblxuICAvLyBjaGVjayBmb3Igc2Vjb25kIGZyYWN0aW9uXG4gIGlmKGdlbnRpbWUuY2hhckF0KDE0KSA9PT0gJy4nKSB7XG4gICAgZmZmID0gcGFyc2VGbG9hdChnZW50aW1lLnN1YnN0cigxNCksIDEwKSAqIDEwMDA7XG4gIH1cblxuICBpZihpc1VUQykge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoWVlZWSwgTU0sIEREKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKGhoLCBtbSwgc3MsIGZmZik7XG5cbiAgICAvLyBhcHBseSBvZmZzZXRcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBvZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoWVlZWSwgTU0sIEREKTtcbiAgICBkYXRlLnNldEhvdXJzKGhoLCBtbSwgc3MsIGZmZik7XG4gIH1cblxuICByZXR1cm4gZGF0ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkYXRlIHRvIGEgVVRDVGltZSB2YWx1ZS5cbiAqXG4gKiBOb3RlOiBHZW5lcmFsaXplZFRpbWUgaGFzIDQgZGlnaXRzIGZvciB0aGUgeWVhciBhbmQgaXMgdXNlZCBmb3IgWC41MDlcbiAqIGRhdGVzIHBhc3QgMjA0OS4gQ29udmVydGluZyB0byBhIEdlbmVyYWxpemVkVGltZSBoYXNuJ3QgYmVlblxuICogaW1wbGVtZW50ZWQgeWV0LlxuICpcbiAqIEBwYXJhbSBkYXRlIHRoZSBkYXRlIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgVVRDVGltZSB2YWx1ZS5cbiAqL1xuYXNuMS5kYXRlVG9VdGNUaW1lID0gZnVuY3Rpb24oZGF0ZSkge1xuICAvLyBUT0RPOiB2YWxpZGF0ZTsgY3VycmVudGx5IGFzc3VtZXMgcHJvcGVyIGZvcm1hdFxuICBpZih0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIHZhciBydmFsID0gJyc7XG5cbiAgLy8gY3JlYXRlIGZvcm1hdCBZWU1NRERoaG1tc3NaXG4gIHZhciBmb3JtYXQgPSBbXTtcbiAgZm9ybWF0LnB1c2goKCcnICsgZGF0ZS5nZXRVVENGdWxsWWVhcigpKS5zdWJzdHIoMikpO1xuICBmb3JtYXQucHVzaCgnJyArIChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENEYXRlKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDSG91cnMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENNaW51dGVzKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDU2Vjb25kcygpKTtcblxuICAvLyBlbnN1cmUgMiBkaWdpdHMgYXJlIHVzZWQgZm9yIGVhY2ggZm9ybWF0IGVudHJ5XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBmb3JtYXQubGVuZ3RoOyArK2kpIHtcbiAgICBpZihmb3JtYXRbaV0ubGVuZ3RoIDwgMikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gZm9ybWF0W2ldO1xuICB9XG4gIHJ2YWwgKz0gJ1onO1xuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRhdGUgdG8gYSBHZW5lcmFsaXplZFRpbWUgdmFsdWUuXG4gKlxuICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBHZW5lcmFsaXplZFRpbWUgdmFsdWUgYXMgYSBzdHJpbmcuXG4gKi9cbmFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lID0gZnVuY3Rpb24oZGF0ZSkge1xuICAvLyBUT0RPOiB2YWxpZGF0ZTsgY3VycmVudGx5IGFzc3VtZXMgcHJvcGVyIGZvcm1hdFxuICBpZih0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIHZhciBydmFsID0gJyc7XG5cbiAgLy8gY3JlYXRlIGZvcm1hdCBZWVlZTU1EREhITU1TU1pcbiAgdmFyIGZvcm1hdCA9IFtdO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ0RhdGUoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENIb3VycygpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ01pbnV0ZXMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENTZWNvbmRzKCkpO1xuXG4gIC8vIGVuc3VyZSAyIGRpZ2l0cyBhcmUgdXNlZCBmb3IgZWFjaCBmb3JtYXQgZW50cnlcbiAgZm9yKHZhciBpID0gMDsgaSA8IGZvcm1hdC5sZW5ndGg7ICsraSkge1xuICAgIGlmKGZvcm1hdFtpXS5sZW5ndGggPCAyKSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBmb3JtYXRbaV07XG4gIH1cbiAgcnZhbCArPSAnWic7XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgamF2YXNjcmlwdCBpbnRlZ2VyIHRvIGEgREVSLWVuY29kZWQgYnl0ZSBidWZmZXIgdG8gYmUgdXNlZFxuICogYXMgdGhlIHZhbHVlIGZvciBhbiBJTlRFR0VSIHR5cGUuXG4gKlxuICogQHBhcmFtIHggdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBidWZmZXIuXG4gKi9cbmFzbjEuaW50ZWdlclRvRGVyID0gZnVuY3Rpb24oeCkge1xuICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGlmKHggPj0gLTB4ODAgJiYgeCA8IDB4ODApIHtcbiAgICByZXR1cm4gcnZhbC5wdXRTaWduZWRJbnQoeCwgOCk7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwICYmIHggPCAweDgwMDApIHtcbiAgICByZXR1cm4gcnZhbC5wdXRTaWduZWRJbnQoeCwgMTYpO1xuICB9XG4gIGlmKHggPj0gLTB4ODAwMDAwICYmIHggPCAweDgwMDAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAyNCk7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwMDAwMCAmJiB4IDwgMHg4MDAwMDAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAzMik7XG4gIH1cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdJbnRlZ2VyIHRvbyBsYXJnZTsgbWF4IGlzIDMyLWJpdHMuJyk7XG4gIGVycm9yLmludGVnZXIgPSB4O1xuICB0aHJvdyBlcnJvcjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBERVItZW5jb2RlZCBieXRlIGJ1ZmZlciB0byBhIGphdmFzY3JpcHQgaW50ZWdlci4gVGhpcyBpc1xuICogdHlwaWNhbGx5IHVzZWQgdG8gZGVjb2RlIHRoZSB2YWx1ZSBvZiBhbiBJTlRFR0VSIHR5cGUuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG5hc24xLmRlclRvSW50ZWdlciA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIC8vIHdyYXAgaW4gYnVmZmVyIGlmIG5lZWRlZFxuICBpZih0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihieXRlcyk7XG4gIH1cblxuICB2YXIgbiA9IGJ5dGVzLmxlbmd0aCgpICogODtcbiAgaWYobiA+IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlZ2VyIHRvbyBsYXJnZTsgbWF4IGlzIDMyLWJpdHMuJyk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzLmdldFNpZ25lZEludChuKTtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgdGhlIGdpdmVuIEFTTi4xIG9iamVjdCBpcyBhdCBsZWFzdCBhIHN1cGVyIHNldCBvZiB0aGVcbiAqIGdpdmVuIEFTTi4xIHN0cnVjdHVyZS4gT25seSB0YWcgY2xhc3NlcyBhbmQgdHlwZXMgYXJlIGNoZWNrZWQuIEFuXG4gKiBvcHRpb25hbCBtYXAgbWF5IGFsc28gYmUgcHJvdmlkZWQgdG8gY2FwdHVyZSBBU04uMSB2YWx1ZXMgd2hpbGUgdGhlXG4gKiBzdHJ1Y3R1cmUgaXMgY2hlY2tlZC5cbiAqXG4gKiBUbyBjYXB0dXJlIGFuIEFTTi4xIHZhbHVlLCBzZXQgYW4gb2JqZWN0IGluIHRoZSB2YWxpZGF0b3IncyAnY2FwdHVyZSdcbiAqIHBhcmFtZXRlciB0byB0aGUga2V5IHRvIHVzZSBpbiB0aGUgY2FwdHVyZSBtYXAuIFRvIGNhcHR1cmUgdGhlIGZ1bGxcbiAqIEFTTi4xIG9iamVjdCwgc3BlY2lmeSAnY2FwdHVyZUFzbjEnLiBUbyBjYXB0dXJlIEJJVCBTVFJJTkcgYnl0ZXMsIGluY2x1ZGluZ1xuICogdGhlIGxlYWRpbmcgdW51c2VkIGJpdHMgY291bnRlciBieXRlLCBzcGVjaWZ5ICdjYXB0dXJlQml0U3RyaW5nQ29udGVudHMnLlxuICogVG8gY2FwdHVyZSBCSVQgU1RSSU5HIGJ5dGVzLCB3aXRob3V0IHRoZSBsZWFkaW5nIHVudXNlZCBiaXRzIGNvdW50ZXIgYnl0ZSxcbiAqIHNwZWNpZnkgJ2NhcHR1cmVCaXRTdHJpbmdWYWx1ZScuXG4gKlxuICogT2JqZWN0cyBpbiB0aGUgdmFsaWRhdG9yIG1heSBzZXQgYSBmaWVsZCAnb3B0aW9uYWwnIHRvIHRydWUgdG8gaW5kaWNhdGVcbiAqIHRoYXQgaXQgaXNuJ3QgbmVjZXNzYXJ5IHRvIHBhc3MgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBvYmplY3QgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gdiB0aGUgQVNOLjEgc3RydWN0dXJlIHZhbGlkYXRvci5cbiAqIEBwYXJhbSBjYXB0dXJlIGFuIG9wdGlvbmFsIG1hcCB0byBjYXB0dXJlIHZhbHVlcyBpbi5cbiAqIEBwYXJhbSBlcnJvcnMgYW4gb3B0aW9uYWwgYXJyYXkgZm9yIHN0b3JpbmcgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKlxuICogQHJldHVybiB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUuXG4gKi9cbmFzbjEudmFsaWRhdGUgPSBmdW5jdGlvbihvYmosIHYsIGNhcHR1cmUsIGVycm9ycykge1xuICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gIC8vIGVuc3VyZSB0YWcgY2xhc3MgYW5kIHR5cGUgYXJlIHRoZSBzYW1lIGlmIHNwZWNpZmllZFxuICBpZigob2JqLnRhZ0NsYXNzID09PSB2LnRhZ0NsYXNzIHx8IHR5cGVvZih2LnRhZ0NsYXNzKSA9PT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgKG9iai50eXBlID09PSB2LnR5cGUgfHwgdHlwZW9mKHYudHlwZSkgPT09ICd1bmRlZmluZWQnKSkge1xuICAgIC8vIGVuc3VyZSBjb25zdHJ1Y3RlZCBmbGFnIGlzIHRoZSBzYW1lIGlmIHNwZWNpZmllZFxuICAgIGlmKG9iai5jb25zdHJ1Y3RlZCA9PT0gdi5jb25zdHJ1Y3RlZCB8fFxuICAgICAgdHlwZW9mKHYuY29uc3RydWN0ZWQpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcnZhbCA9IHRydWU7XG5cbiAgICAgIC8vIGhhbmRsZSBzdWIgdmFsdWVzXG4gICAgICBpZih2LnZhbHVlICYmIGZvcmdlLnV0aWwuaXNBcnJheSh2LnZhbHVlKSkge1xuICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IHJ2YWwgJiYgaSA8IHYudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBydmFsID0gdi52YWx1ZVtpXS5vcHRpb25hbCB8fCBmYWxzZTtcbiAgICAgICAgICBpZihvYmoudmFsdWVbal0pIHtcbiAgICAgICAgICAgIHJ2YWwgPSBhc24xLnZhbGlkYXRlKG9iai52YWx1ZVtqXSwgdi52YWx1ZVtpXSwgY2FwdHVyZSwgZXJyb3JzKTtcbiAgICAgICAgICAgIGlmKHJ2YWwpIHtcbiAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHYudmFsdWVbaV0ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgcnZhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCFydmFsICYmIGVycm9ycykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAgICAgICAnVGFnIGNsYXNzIFwiJyArIHYudGFnQ2xhc3MgKyAnXCIsIHR5cGUgXCInICtcbiAgICAgICAgICAgICAgdi50eXBlICsgJ1wiIGV4cGVjdGVkIHZhbHVlIGxlbmd0aCBcIicgK1xuICAgICAgICAgICAgICB2LnZhbHVlLmxlbmd0aCArICdcIiwgZ290IFwiJyArXG4gICAgICAgICAgICAgIG9iai52YWx1ZS5sZW5ndGggKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYocnZhbCAmJiBjYXB0dXJlKSB7XG4gICAgICAgIGlmKHYuY2FwdHVyZSkge1xuICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlXSA9IG9iai52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih2LmNhcHR1cmVBc24xKSB7XG4gICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVBc24xXSA9IG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZih2LmNhcHR1cmVCaXRTdHJpbmdDb250ZW50cyAmJiAnYml0U3RyaW5nQ29udGVudHMnIGluIG9iaikge1xuICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlQml0U3RyaW5nQ29udGVudHNdID0gb2JqLmJpdFN0cmluZ0NvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmKHYuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlICYmICdiaXRTdHJpbmdDb250ZW50cycgaW4gb2JqKSB7XG4gICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgIGlmKG9iai5iaXRTdHJpbmdDb250ZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBjYXB0dXJlW3YuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlXSA9ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogc3VwcG9ydCB1bnVzZWQgYml0cyB3aXRoIGRhdGEgc2hpZnRpbmdcbiAgICAgICAgICAgIHZhciB1bnVzZWQgPSBvYmouYml0U3RyaW5nQ29udGVudHMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmKHVudXNlZCAhPT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ2NhcHR1cmVCaXRTdHJpbmdWYWx1ZSBvbmx5IHN1cHBvcnRlZCBmb3IgemVybyB1bnVzZWQgYml0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVCaXRTdHJpbmdWYWx1ZV0gPSBvYmouYml0U3RyaW5nQ29udGVudHMuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGVycm9ycykge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgY29uc3RydWN0ZWQgXCInICsgdi5jb25zdHJ1Y3RlZCArICdcIiwgZ290IFwiJyArXG4gICAgICAgIG9iai5jb25zdHJ1Y3RlZCArICdcIicpO1xuICAgIH1cbiAgfSBlbHNlIGlmKGVycm9ycykge1xuICAgIGlmKG9iai50YWdDbGFzcyAhPT0gdi50YWdDbGFzcykge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgdGFnIGNsYXNzIFwiJyArIHYudGFnQ2xhc3MgKyAnXCIsIGdvdCBcIicgK1xuICAgICAgICBvYmoudGFnQ2xhc3MgKyAnXCInKTtcbiAgICB9XG4gICAgaWYob2JqLnR5cGUgIT09IHYudHlwZSkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgdHlwZSBcIicgKyB2LnR5cGUgKyAnXCIsIGdvdCBcIicgKyBvYmoudHlwZSArICdcIicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8vIHJlZ2V4IGZvciB0ZXN0aW5nIGZvciBub24tbGF0aW4gY2hhcmFjdGVyc1xudmFyIF9ub25MYXRpblJlZ2V4ID0gL1teXFxcXHUwMDAwLVxcXFx1MDBmZl0vO1xuXG4vKipcbiAqIFByZXR0eSBwcmludHMgYW4gQVNOLjEgb2JqZWN0IHRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIG9iamVjdCB0byB3cml0ZSBvdXQuXG4gKiBAcGFyYW0gbGV2ZWwgdGhlIGxldmVsIGluIHRoZSB0cmVlLlxuICogQHBhcmFtIGluZGVudGF0aW9uIHRoZSBpbmRlbnRhdGlvbiB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgc3RyaW5nLlxuICovXG5hc24xLnByZXR0eVByaW50ID0gZnVuY3Rpb24ob2JqLCBsZXZlbCwgaW5kZW50YXRpb24pIHtcbiAgdmFyIHJ2YWwgPSAnJztcblxuICAvLyBzZXQgZGVmYXVsdCBsZXZlbCBhbmQgaW5kZW50YXRpb25cbiAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xuICBpbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uIHx8IDI7XG5cbiAgLy8gc3RhcnQgbmV3IGxpbmUgZm9yIGRlZXAgbGV2ZWxzXG4gIGlmKGxldmVsID4gMCkge1xuICAgIHJ2YWwgKz0gJ1xcbic7XG4gIH1cblxuICAvLyBjcmVhdGUgaW5kZW50XG4gIHZhciBpbmRlbnQgPSAnJztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxldmVsICogaW5kZW50YXRpb247ICsraSkge1xuICAgIGluZGVudCArPSAnICc7XG4gIH1cblxuICAvLyBwcmludCBjbGFzczp0eXBlXG4gIHJ2YWwgKz0gaW5kZW50ICsgJ1RhZzogJztcbiAgc3dpdGNoKG9iai50YWdDbGFzcykge1xuICBjYXNlIGFzbjEuQ2xhc3MuVU5JVkVSU0FMOlxuICAgIHJ2YWwgKz0gJ1VuaXZlcnNhbDonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuQVBQTElDQVRJT046XG4gICAgcnZhbCArPSAnQXBwbGljYXRpb246JztcbiAgICBicmVhaztcbiAgY2FzZSBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUM6XG4gICAgcnZhbCArPSAnQ29udGV4dC1TcGVjaWZpYzonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuUFJJVkFURTpcbiAgICBydmFsICs9ICdQcml2YXRlOic7XG4gICAgYnJlYWs7XG4gIH1cblxuICBpZihvYmoudGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMKSB7XG4gICAgcnZhbCArPSBvYmoudHlwZTtcblxuICAgIC8vIGtub3duIHR5cGVzXG4gICAgc3dpdGNoKG9iai50eXBlKSB7XG4gICAgY2FzZSBhc24xLlR5cGUuTk9ORTpcbiAgICAgIHJ2YWwgKz0gJyAoTm9uZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQk9PTEVBTjpcbiAgICAgIHJ2YWwgKz0gJyAoQm9vbGVhbiknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuSU5URUdFUjpcbiAgICAgIHJ2YWwgKz0gJyAoSW50ZWdlciknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQklUU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChCaXQgc3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PQ1RFVFNUUklORzpcbiAgICAgIHJ2YWwgKz0gJyAoT2N0ZXQgc3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5OVUxMOlxuICAgICAgcnZhbCArPSAnIChOdWxsKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PSUQ6XG4gICAgICBydmFsICs9ICcgKE9iamVjdCBJZGVudGlmaWVyKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PREVTQzpcbiAgICAgIHJ2YWwgKz0gJyAoT2JqZWN0IERlc2NyaXB0b3IpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLkVYVEVSTkFMOlxuICAgICAgcnZhbCArPSAnIChFeHRlcm5hbCBvciBJbnN0YW5jZSBvZiknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUkVBTDpcbiAgICAgIHJ2YWwgKz0gJyAoUmVhbCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRU5VTUVSQVRFRDpcbiAgICAgIHJ2YWwgKz0gJyAoRW51bWVyYXRlZCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRU1CRURERUQ6XG4gICAgICBydmFsICs9ICcgKEVtYmVkZGVkIFBEViknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuVVRGODpcbiAgICAgIHJ2YWwgKz0gJyAoVVRGOCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUk9JRDpcbiAgICAgIHJ2YWwgKz0gJyAoUmVsYXRpdmUgT2JqZWN0IElkZW50aWZpZXIpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLlNFUVVFTkNFOlxuICAgICAgcnZhbCArPSAnIChTZXF1ZW5jZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuU0VUOlxuICAgICAgcnZhbCArPSAnIChTZXQpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORzpcbiAgICAgIHJ2YWwgKz0gJyAoUHJpbnRhYmxlIFN0cmluZyknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuSUE1U3RyaW5nOlxuICAgICAgcnZhbCArPSAnIChJQTVTdHJpbmcgKEFTQ0lJKSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuVVRDVElNRTpcbiAgICAgIHJ2YWwgKz0gJyAoVVRDIHRpbWUpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLkdFTkVSQUxJWkVEVElNRTpcbiAgICAgIHJ2YWwgKz0gJyAoR2VuZXJhbGl6ZWQgdGltZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQk1QU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChCTVAgU3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcnZhbCArPSBvYmoudHlwZTtcbiAgfVxuXG4gIHJ2YWwgKz0gJ1xcbic7XG4gIHJ2YWwgKz0gaW5kZW50ICsgJ0NvbnN0cnVjdGVkOiAnICsgb2JqLmNvbnN0cnVjdGVkICsgJ1xcbic7XG5cbiAgaWYob2JqLmNvbXBvc2VkKSB7XG4gICAgdmFyIHN1YnZhbHVlcyA9IDA7XG4gICAgdmFyIHN1YiA9ICcnO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKG9iai52YWx1ZVtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YnZhbHVlcyArPSAxO1xuICAgICAgICBzdWIgKz0gYXNuMS5wcmV0dHlQcmludChvYmoudmFsdWVbaV0sIGxldmVsICsgMSwgaW5kZW50YXRpb24pO1xuICAgICAgICBpZigoaSArIDEpIDwgb2JqLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHN1YiArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcnZhbCArPSBpbmRlbnQgKyAnU3ViIHZhbHVlczogJyArIHN1YnZhbHVlcyArIHN1YjtcbiAgfSBlbHNlIHtcbiAgICBydmFsICs9IGluZGVudCArICdWYWx1ZTogJztcbiAgICBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLk9JRCkge1xuICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQob2JqLnZhbHVlKTtcbiAgICAgIHJ2YWwgKz0gb2lkO1xuICAgICAgaWYoZm9yZ2UucGtpICYmIGZvcmdlLnBraS5vaWRzKSB7XG4gICAgICAgIGlmKG9pZCBpbiBmb3JnZS5wa2kub2lkcykge1xuICAgICAgICAgIHJ2YWwgKz0gJyAoJyArIGZvcmdlLnBraS5vaWRzW29pZF0gKyAnKSAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmKG9iai50eXBlID09PSBhc24xLlR5cGUuSU5URUdFUikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnZhbCArPSBhc24xLmRlclRvSW50ZWdlcihvYmoudmFsdWUpO1xuICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICAgIC8vIFRPRE86IHNoaWZ0IGJpdHMgYXMgbmVlZGVkIHRvIGRpc3BsYXkgd2l0aG91dCBwYWRkaW5nXG4gICAgICBpZihvYmoudmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyByZW1vdmUgdW51c2VkIGJpdHMgZmllbGRcbiAgICAgICAgcnZhbCArPSAnMHgnICsgZm9yZ2UudXRpbC5ieXRlc1RvSGV4KG9iai52YWx1ZS5zbGljZSgxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsICs9ICcobm9uZSknO1xuICAgICAgfVxuICAgICAgLy8gc2hvdyB1bnVzZWQgYml0IGNvdW50XG4gICAgICBpZihvYmoudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdW51c2VkID0gb2JqLnZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmKHVudXNlZCA9PSAxKSB7XG4gICAgICAgICAgcnZhbCArPSAnICgxIHVudXNlZCBiaXQgc2hvd24pJztcbiAgICAgICAgfSBlbHNlIGlmKHVudXNlZCA+IDEpIHtcbiAgICAgICAgICBydmFsICs9ICcgKCcgKyB1bnVzZWQgKyAnIHVudXNlZCBiaXRzIHNob3duKSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5PQ1RFVFNUUklORykge1xuICAgICAgaWYoIV9ub25MYXRpblJlZ2V4LnRlc3Qob2JqLnZhbHVlKSkge1xuICAgICAgICBydmFsICs9ICcoJyArIG9iai52YWx1ZSArICcpICc7XG4gICAgICB9XG4gICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5VVEY4KSB7XG4gICAgICBydmFsICs9IGZvcmdlLnV0aWwuZGVjb2RlVXRmOChvYmoudmFsdWUpO1xuICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORyB8fFxuICAgICAgb2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JQTVTdHJpbmcpIHtcbiAgICAgIHJ2YWwgKz0gb2JqLnZhbHVlO1xuICAgIH0gZWxzZSBpZihfbm9uTGF0aW5SZWdleC50ZXN0KG9iai52YWx1ZSkpIHtcbiAgICAgIHJ2YWwgKz0gJzB4JyArIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChvYmoudmFsdWUpO1xuICAgIH0gZWxzZSBpZihvYmoudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICBydmFsICs9ICdbbnVsbF0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBydmFsICs9IG9iai52YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG4iLCIvKipcbiAqIFBhc3N3b3JkLWJhc2VkIGVuY3J5cHRpb24gZnVuY3Rpb25zLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbCA8c3Rlc2llQGJyb2tlbnBpcGUuZGU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIEFuIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvOlxuICpcbiAqIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGVuY3J5cHRpb25BbGdvcml0aG0gIEVuY3J5cHRpb25BbGdvcml0aG1JZGVudGlmaWVyLFxuICogICBlbmNyeXB0ZWREYXRhICAgICAgICBFbmNyeXB0ZWREYXRhIH1cbiAqXG4gKiBFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEVuY3J5cHRlZERhdGEgOjo9IE9DVEVUIFNUUklOR1xuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL2FlcycpO1xucmVxdWlyZSgnLi9hc24xJyk7XG5yZXF1aXJlKCcuL2RlcycpO1xucmVxdWlyZSgnLi9tZCcpO1xucmVxdWlyZSgnLi9vaWRzJyk7XG5yZXF1aXJlKCcuL3Bia2RmMicpO1xucmVxdWlyZSgnLi9wZW0nKTtcbnJlcXVpcmUoJy4vcmFuZG9tJyk7XG5yZXF1aXJlKCcuL3JjMicpO1xucmVxdWlyZSgnLi9yc2EnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG5pZih0eXBlb2YgQmlnSW50ZWdlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG59XG5cbi8vIHNob3J0Y3V0IGZvciBhc24uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLyogUGFzc3dvcmQtYmFzZWQgZW5jcnlwdGlvbiBpbXBsZW1lbnRhdGlvbi4gKi9cbnZhciBwa2kgPSBmb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG5tb2R1bGUuZXhwb3J0cyA9IHBraS5wYmUgPSBmb3JnZS5wYmUgPSBmb3JnZS5wYmUgfHwge307XG52YXIgb2lkcyA9IHBraS5vaWRzO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgdy9hbGdvcml0aG0gcGFyYW1zXG52YXIgZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0VuY3J5cHRlZFByaXZhdGVLZXlJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uZW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2VuY3J5cHRpb25PaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0FsZ29yaXRobUlkZW50aWZpZXIucGFyYW1ldGVycycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnZW5jcnlwdGlvblBhcmFtcydcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gZW5jcnlwdGVkRGF0YVxuICAgIG5hbWU6ICdFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5lbmNyeXB0ZWREYXRhJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnZW5jcnlwdGVkRGF0YSdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYSBQQkVTMkFsZ29yaXRobXMgc3RydWN0dXJlXG4vLyBOb3RlOiBDdXJyZW50bHkgb25seSB3b3JrcyB3L1BCS0RGMiArIEFFUyBlbmNyeXB0aW9uIHNjaGVtZXNcbnZhciBQQkVTMkFsZ29yaXRobXNWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMua2V5RGVyaXZhdGlvbkZ1bmMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmtleURlcml2YXRpb25GdW5jLm9pZCcsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2tkZk9pZCdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5zYWx0JyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2tkZlNhbHQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMucGFyYW1zLml0ZXJhdGlvbkNvdW50JyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAna2RmSXRlcmF0aW9uQ291bnQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMucGFyYW1zLmtleUxlbmd0aCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6ICdrZXlMZW5ndGgnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIHByZlxuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5wcmYnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5wcmYuYWxnb3JpdGhtJyxcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogJ3ByZk9pZCdcbiAgICAgICAgfV1cbiAgICAgIH1dXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZS5vaWQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5lbmNyeXB0aW9uU2NoZW1lLml2JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNJdidcbiAgICB9XVxuICB9XVxufTtcblxudmFyIHBrY3MxMlBiZVBhcmFtc1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ3BrY3MtMTJQYmVQYXJhbXMnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdwa2NzLTEyUGJlUGFyYW1zLnNhbHQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdzYWx0J1xuICB9LCB7XG4gICAgbmFtZTogJ3BrY3MtMTJQYmVQYXJhbXMuaXRlcmF0aW9ucycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnaXRlcmF0aW9ucydcbiAgfV1cbn07XG5cbi8qKlxuICogRW5jcnlwdHMgYSBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QsIHByb2R1Y2luZyBhbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqXG4gKiBQQkVTMkFsZ29yaXRobXMgQUxHT1JJVEhNLUlERU5USUZJRVIgOjo9XG4gKiAgIHsge1BCRVMyLXBhcmFtcyBJREVOVElGSUVEIEJZIGlkLVBCRVMyfSwgLi4ufVxuICpcbiAqIGlkLVBCRVMyIE9CSkVDVCBJREVOVElGSUVSIDo6PSB7cGtjcy01IDEzfVxuICpcbiAqIFBCRVMyLXBhcmFtcyA6Oj0gU0VRVUVOQ0Uge1xuICogICBrZXlEZXJpdmF0aW9uRnVuYyBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJFUzItS0RGc319LFxuICogICBlbmNyeXB0aW9uU2NoZW1lIEFsZ29yaXRobUlkZW50aWZpZXIge3tQQkVTMi1FbmNzfX1cbiAqIH1cbiAqXG4gKiBQQkVTMi1LREZzIEFMR09SSVRITS1JREVOVElGSUVSIDo6PVxuICogICB7IHtQQktERjItcGFyYW1zIElERU5USUZJRUQgQlkgaWQtUEJLREYyfSwgLi4uIH1cbiAqXG4gKiBQQkVTMi1FbmNzIEFMR09SSVRITS1JREVOVElGSUVSIDo6PSB7IC4uLiB9XG4gKlxuICogUEJLREYyLXBhcmFtcyA6Oj0gU0VRVUVOQ0Uge1xuICogICBzYWx0IENIT0lDRSB7XG4gKiAgICAgc3BlY2lmaWVkIE9DVEVUIFNUUklORyxcbiAqICAgICBvdGhlclNvdXJjZSBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJLREYyLVNhbHRTb3VyY2VzfX1cbiAqICAgfSxcbiAqICAgaXRlcmF0aW9uQ291bnQgSU5URUdFUiAoMS4uTUFYKSxcbiAqICAga2V5TGVuZ3RoIElOVEVHRVIgKDEuLk1BWCkgT1BUSU9OQUwsXG4gKiAgIHByZiBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJLREYyLVBSRnN9fSBERUZBVUxUIGFsZ2lkLWhtYWNXaXRoU0hBMVxuICogfVxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZW5jcnlwdCB3aXRoLlxuICogQHBhcmFtIG9wdGlvbnM6XG4gKiAgICAgICAgICBhbGdvcml0aG0gdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ2FlczEyOCcsICdhZXMxOTInLCAnYWVzMjU2JywgJzNkZXMnKSwgZGVmYXVsdHMgdG8gJ2FlczEyOCcuXG4gKiAgICAgICAgICBjb3VudCB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIHVzZS5cbiAqICAgICAgICAgIHNhbHRTaXplIHRoZSBzYWx0IHNpemUgdG8gdXNlLlxuICogICAgICAgICAgcHJmQWxnb3JpdGhtIHRoZSBQUkYgbWVzc2FnZSBkaWdlc3QgYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ3NoYTEnLCAnc2hhMjI0JywgJ3NoYTI1NicsICdzaGEzODQnLCAnc2hhNTEyJylcbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRQcml2YXRlS2V5SW5mbyA9IGZ1bmN0aW9uKG9iaiwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5zYWx0U2l6ZSA9IG9wdGlvbnMuc2FsdFNpemUgfHwgODtcbiAgb3B0aW9ucy5jb3VudCA9IG9wdGlvbnMuY291bnQgfHwgMjA0ODtcbiAgb3B0aW9ucy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobSB8fCAnYWVzMTI4JztcbiAgb3B0aW9ucy5wcmZBbGdvcml0aG0gPSBvcHRpb25zLnByZkFsZ29yaXRobSB8fCAnc2hhMSc7XG5cbiAgLy8gZ2VuZXJhdGUgUEJFIHBhcmFtc1xuICB2YXIgc2FsdCA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMob3B0aW9ucy5zYWx0U2l6ZSk7XG4gIHZhciBjb3VudCA9IG9wdGlvbnMuY291bnQ7XG4gIHZhciBjb3VudEJ5dGVzID0gYXNuMS5pbnRlZ2VyVG9EZXIoY291bnQpO1xuICB2YXIgZGtMZW47XG4gIHZhciBlbmNyeXB0aW9uQWxnb3JpdGhtO1xuICB2YXIgZW5jcnlwdGVkRGF0YTtcbiAgaWYob3B0aW9ucy5hbGdvcml0aG0uaW5kZXhPZignYWVzJykgPT09IDAgfHwgb3B0aW9ucy5hbGdvcml0aG0gPT09ICdkZXMnKSB7XG4gICAgLy8gZG8gUEJFUzJcbiAgICB2YXIgaXZMZW4sIGVuY09pZCwgY2lwaGVyRm47XG4gICAgc3dpdGNoKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnYWVzMTI4JzpcbiAgICAgIGRrTGVuID0gMTY7XG4gICAgICBpdkxlbiA9IDE2O1xuICAgICAgZW5jT2lkID0gb2lkc1snYWVzMTI4LUNCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FlczE5Mic6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgaXZMZW4gPSAxNjtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2FlczE5Mi1DQkMnXTtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhZXMyNTYnOlxuICAgICAgZGtMZW4gPSAzMjtcbiAgICAgIGl2TGVuID0gMTY7XG4gICAgICBlbmNPaWQgPSBvaWRzWydhZXMyNTYtQ0JDJ107XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGVzJzpcbiAgICAgIGRrTGVuID0gODtcbiAgICAgIGl2TGVuID0gODtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2Rlc0NCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IHByaXZhdGUga2V5LiBVbmtub3duIGVuY3J5cHRpb24gYWxnb3JpdGhtLicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gICAgdmFyIHByZkFsZ29yaXRobSA9ICdobWFjV2l0aCcgKyBvcHRpb25zLnByZkFsZ29yaXRobS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBtZCA9IHByZkFsZ29yaXRobVRvTWVzc2FnZURpZ2VzdChwcmZBbGdvcml0aG0pO1xuXG4gICAgLy8gZW5jcnlwdCBwcml2YXRlIGtleSB1c2luZyBwYmUgU0hBLTEgYW5kIEFFUy9ERVNcbiAgICB2YXIgZGsgPSBmb3JnZS5wa2NzNS5wYmtkZjIocGFzc3dvcmQsIHNhbHQsIGNvdW50LCBka0xlbiwgbWQpO1xuICAgIHZhciBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoaXZMZW4pO1xuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gICAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgICBjaXBoZXIudXBkYXRlKGFzbjEudG9EZXIob2JqKSk7XG4gICAgY2lwaGVyLmZpbmlzaCgpO1xuICAgIGVuY3J5cHRlZERhdGEgPSBjaXBoZXIub3V0cHV0LmdldEJ5dGVzKCk7XG5cbiAgICAvLyBnZXQgUEJLREYyLXBhcmFtc1xuICAgIHZhciBwYXJhbXMgPSBjcmVhdGVQYmtkZjJQYXJhbXMoc2FsdCwgY291bnRCeXRlcywgZGtMZW4sIHByZkFsZ29yaXRobSk7XG5cbiAgICBlbmNyeXB0aW9uQWxnb3JpdGhtID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIob2lkc1sncGtjczVQQkVTMiddKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8ga2V5RGVyaXZhdGlvbkZ1bmNcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIob2lkc1sncGtjczVQQktERjInXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgLy8gUEJLREYyLXBhcmFtc1xuICAgICAgICAgIHBhcmFtc1xuICAgICAgICBdKSxcbiAgICAgICAgLy8gZW5jcnlwdGlvblNjaGVtZVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihlbmNPaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgIC8vIGl2XG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgaXYpXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF0pO1xuICB9IGVsc2UgaWYob3B0aW9ucy5hbGdvcml0aG0gPT09ICczZGVzJykge1xuICAgIC8vIERvIFBLQ1MxMiBQQkVcbiAgICBka0xlbiA9IDI0O1xuXG4gICAgdmFyIHNhbHRCeXRlcyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoc2FsdCk7XG4gICAgdmFyIGRrID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdEJ5dGVzLCAxLCBjb3VudCwgZGtMZW4pO1xuICAgIHZhciBpdiA9IHBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkocGFzc3dvcmQsIHNhbHRCeXRlcywgMiwgY291bnQsIGRrTGVuKTtcbiAgICB2YXIgY2lwaGVyID0gZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIoZGspO1xuICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgY2lwaGVyLnVwZGF0ZShhc24xLnRvRGVyKG9iaikpO1xuICAgIGNpcGhlci5maW5pc2goKTtcbiAgICBlbmNyeXB0ZWREYXRhID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKG9pZHNbJ3BiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkMnXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwa2NzLTEyUGJlUGFyYW1zXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIHNhbHRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHNhbHQpLFxuICAgICAgICAvLyBpdGVyYXRpb24gY291bnRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgICBjb3VudEJ5dGVzLmdldEJ5dGVzKCkpXG4gICAgICBdKVxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgcHJpdmF0ZSBrZXkuIFVua25vd24gZW5jcnlwdGlvbiBhbGdvcml0aG0uJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mb1xuICB2YXIgcnZhbCA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBlbmNyeXB0aW9uQWxnb3JpdGhtXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSxcbiAgICAvLyBlbmNyeXB0ZWREYXRhXG4gICAgYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgZW5jcnlwdGVkRGF0YSlcbiAgXSk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBEZWNyeXB0cyBhIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBQcml2YXRlS2V5SW5mbyBvbiBzdWNjZXNzLCBudWxsIG9uIGZhaWx1cmUuXG4gKi9cbnBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8gPSBmdW5jdGlvbihvYmosIHBhc3N3b3JkKSB7XG4gIHZhciBydmFsID0gbnVsbDtcblxuICAvLyBnZXQgUEJFIHBhcmFtc1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBjaXBoZXJcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNyeXB0aW9uT2lkKTtcbiAgdmFyIGNpcGhlciA9IHBraS5wYmUuZ2V0Q2lwaGVyKG9pZCwgY2FwdHVyZS5lbmNyeXB0aW9uUGFyYW1zLCBwYXNzd29yZCk7XG5cbiAgLy8gZ2V0IGVuY3J5cHRlZCBkYXRhXG4gIHZhciBlbmNyeXB0ZWQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmVuY3J5cHRlZERhdGEpO1xuXG4gIGNpcGhlci51cGRhdGUoZW5jcnlwdGVkKTtcbiAgaWYoY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgcnZhbCA9IGFzbjEuZnJvbURlcihjaXBoZXIub3V0cHV0KTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGVwa2kgdGhlIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkuXG4gKi9cbnBraS5lbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0gPSBmdW5jdGlvbihlcGtpLCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKGVwa2kpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBFTS1lbmNvZGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHRvIEFTTi4xIGZvcm1hdC4gRGVjcnlwdGlvblxuICogaXMgbm90IHBlcmZvcm1lZC5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBpbiBQRU0tZm9ybWF0LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICovXG5wa2kuZW5jcnlwdGVkUHJpdmF0ZUtleUZyb21QZW0gPSBmdW5jdGlvbihwZW0pIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ0VOQ1JZUFRFRCBQUklWQVRFIEtFWScpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGVuY3J5cHRlZCBwcml2YXRlIGtleSBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGhlYWRlciB0eXBlIGlzIFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGVuY3J5cHRlZCBwcml2YXRlIGtleSBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICByZXR1cm4gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcbn07XG5cbi8qKlxuICogRW5jcnlwdHMgYW4gUlNBIHByaXZhdGUga2V5LiBCeSBkZWZhdWx0LCB0aGUga2V5IHdpbGwgYmUgd3JhcHBlZCBpblxuICogYSBQcml2YXRlS2V5SW5mbyBhbmQgZW5jcnlwdGVkIHRvIHByb2R1Y2UgYSBQS0NTIzggRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKiBUaGlzIGlzIHRoZSBzdGFuZGFyZCwgcHJlZmVycmVkIHdheSB0byBlbmNyeXB0IGEgcHJpdmF0ZSBrZXkuXG4gKlxuICogVG8gcHJvZHVjZSBhIG5vbi1zdGFuZGFyZCBQRU0tZW5jcnlwdGVkIHByaXZhdGUga2V5IHRoYXQgdXNlcyBlbmNhcHN1bGF0ZWRcbiAqIGhlYWRlcnMgdG8gaW5kaWNhdGUgdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIChvbGQtc3R5bGUgbm9uLVBLQ1MjOCBPcGVuU1NMXG4gKiBwcml2YXRlIGtleSBlbmNyeXB0aW9uKSwgc2V0IHRoZSAnbGVnYWN5JyBvcHRpb24gdG8gdHJ1ZS4gTm90ZTogVXNpbmcgdGhpc1xuICogb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGl0ZXJhdGlvbiBjb3VudCB0byBiZSBmb3JjZWQgdG8gMS5cbiAqXG4gKiBOb3RlOiBUaGUgJ2RlcycgYWxnb3JpdGhtIGlzIHN1cHBvcnRlZCwgYnV0IGl0IGlzIG5vdCBjb25zaWRlcmVkIHRvIGJlXG4gKiBzZWN1cmUgYmVjYXVzZSBpdCBvbmx5IHVzZXMgYSBzaW5nbGUgNTYtYml0IGtleS4gSWYgcG9zc2libGUsIGl0IGlzIGhpZ2hseVxuICogcmVjb21tZW5kZWQgdGhhdCBhIGRpZmZlcmVudCBhbGdvcml0aG0gYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gcnNhS2V5IHRoZSBSU0Ega2V5IHRvIGVuY3J5cHQuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIHVzZS5cbiAqIEBwYXJhbSBvcHRpb25zOlxuICogICAgICAgICAgYWxnb3JpdGhtOiB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0gdG8gdXNlXG4gKiAgICAgICAgICAgICgnYWVzMTI4JywgJ2FlczE5MicsICdhZXMyNTYnLCAnM2RlcycsICdkZXMnKS5cbiAqICAgICAgICAgIGNvdW50OiB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIHVzZS5cbiAqICAgICAgICAgIHNhbHRTaXplOiB0aGUgc2FsdCBzaXplIHRvIHVzZS5cbiAqICAgICAgICAgIGxlZ2FjeTogb3V0cHV0IGFuIG9sZCBub24tUEtDUyM4IFBFTS1lbmNyeXB0ZWQrZW5jYXBzdWxhdGVkXG4gKiAgICAgICAgICAgIGhlYWRlcnMgKERFSy1JbmZvKSBwcml2YXRlIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZW5jb2RlZCBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRSc2FQcml2YXRlS2V5ID0gZnVuY3Rpb24ocnNhS2V5LCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAvLyBzdGFuZGFyZCBQS0NTIzhcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKCFvcHRpb25zLmxlZ2FjeSkge1xuICAgIC8vIGVuY3J5cHQgUHJpdmF0ZUtleUluZm9cbiAgICB2YXIgcnZhbCA9IHBraS53cmFwUnNhUHJpdmF0ZUtleShwa2kucHJpdmF0ZUtleVRvQXNuMShyc2FLZXkpKTtcbiAgICBydmFsID0gcGtpLmVuY3J5cHRQcml2YXRlS2V5SW5mbyhydmFsLCBwYXNzd29yZCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHBraS5lbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0ocnZhbCk7XG4gIH1cblxuICAvLyBsZWdhY3kgbm9uLVBLQ1MjOFxuICB2YXIgYWxnb3JpdGhtO1xuICB2YXIgaXY7XG4gIHZhciBka0xlbjtcbiAgdmFyIGNpcGhlckZuO1xuICBzd2l0Y2gob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgY2FzZSAnYWVzMTI4JzpcbiAgICBhbGdvcml0aG0gPSAnQUVTLTEyOC1DQkMnO1xuICAgIGRrTGVuID0gMTY7XG4gICAgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDE2KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdhZXMxOTInOlxuICAgIGFsZ29yaXRobSA9ICdBRVMtMTkyLUNCQyc7XG4gICAgZGtMZW4gPSAyNDtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoMTYpO1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczI1Nic6XG4gICAgYWxnb3JpdGhtID0gJ0FFUy0yNTYtQ0JDJztcbiAgICBka0xlbiA9IDMyO1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYygxNik7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnM2Rlcyc6XG4gICAgYWxnb3JpdGhtID0gJ0RFUy1FREUzLUNCQyc7XG4gICAgZGtMZW4gPSAyNDtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoOCk7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzJzpcbiAgICBhbGdvcml0aG0gPSAnREVTLUNCQyc7XG4gICAgZGtMZW4gPSA4O1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYyg4KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGVuY3J5cHQgUlNBIHByaXZhdGUga2V5OyB1bnN1cHBvcnRlZCAnICtcbiAgICAgICdlbmNyeXB0aW9uIGFsZ29yaXRobSBcIicgKyBvcHRpb25zLmFsZ29yaXRobSArICdcIi4nKTtcbiAgICBlcnJvci5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgcHJpdmF0ZSBrZXkgdXNpbmcgT3BlblNTTCBsZWdhY3kga2V5IGRlcml2YXRpb25cbiAgdmFyIGRrID0gZm9yZ2UucGJlLm9wZW5zc2xEZXJpdmVCeXRlcyhwYXNzd29yZCwgaXYuc3Vic3RyKDAsIDgpLCBka0xlbik7XG4gIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIGNpcGhlci51cGRhdGUoYXNuMS50b0Rlcihwa2kucHJpdmF0ZUtleVRvQXNuMShyc2FLZXkpKSk7XG4gIGNpcGhlci5maW5pc2goKTtcblxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdSU0EgUFJJVkFURSBLRVknLFxuICAgIHByb2NUeXBlOiB7XG4gICAgICB2ZXJzaW9uOiAnNCcsXG4gICAgICB0eXBlOiAnRU5DUllQVEVEJ1xuICAgIH0sXG4gICAgZGVrSW5mbzoge1xuICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG0sXG4gICAgICBwYXJhbWV0ZXJzOiBmb3JnZS51dGlsLmJ5dGVzVG9IZXgoaXYpLnRvVXBwZXJDYXNlKClcbiAgICB9LFxuICAgIGJvZHk6IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2cpO1xufTtcblxuLyoqXG4gKiBEZWNyeXB0cyBhbiBSU0EgcHJpdmF0ZSBrZXkuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyB0byBkZWNyeXB0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgUlNBIGtleSBvbiBzdWNjZXNzLCBudWxsIG9uIGZhaWx1cmUuXG4gKi9cbnBraS5kZWNyeXB0UnNhUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHBlbSwgcGFzc3dvcmQpIHtcbiAgdmFyIHJ2YWwgPSBudWxsO1xuXG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknICYmXG4gICAgbXNnLnR5cGUgIT09ICdQUklWQVRFIEtFWScgJiZcbiAgICBtc2cudHlwZSAhPT0gJ1JTQSBQUklWQVRFIEtFWScpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHByaXZhdGUga2V5IGZyb20gUEVNOyBQRU0gaGVhZGVyIHR5cGUgJyArXG4gICAgICAnaXMgbm90IFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIsIFwiUFJJVkFURSBLRVlcIiwgb3IgXCJSU0EgUFJJVkFURSBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gZXJyb3I7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdmFyIGRrTGVuO1xuICAgIHZhciBjaXBoZXJGbjtcbiAgICBzd2l0Y2gobXNnLmRla0luZm8uYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnREVTLUNCQyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnREVTLUVERTMtQ0JDJzpcbiAgICAgIGRrTGVuID0gMjQ7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQUVTLTEyOC1DQkMnOlxuICAgICAgZGtMZW4gPSAxNjtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdBRVMtMTkyLUNCQyc6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0FFUy0yNTYtQ0JDJzpcbiAgICAgIGRrTGVuID0gMzI7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTQwLUNCQyc6XG4gICAgICBka0xlbiA9IDU7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA0MCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTY0LUNCQyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA2NCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTEyOC1DQkMnOlxuICAgICAgZGtMZW4gPSAxNjtcbiAgICAgIGNpcGhlckZuID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBmb3JnZS5yYzIuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcihrZXksIDEyOCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGRlY3J5cHQgcHJpdmF0ZSBrZXk7IHVuc3VwcG9ydGVkICcgK1xuICAgICAgICAnZW5jcnlwdGlvbiBhbGdvcml0aG0gXCInICsgbXNnLmRla0luZm8uYWxnb3JpdGhtICsgJ1wiLicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gbXNnLmRla0luZm8uYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gdXNlIE9wZW5TU0wgbGVnYWN5IGtleSBkZXJpdmF0aW9uXG4gICAgdmFyIGl2ID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpO1xuICAgIHZhciBkayA9IGZvcmdlLnBiZS5vcGVuc3NsRGVyaXZlQnl0ZXMocGFzc3dvcmQsIGl2LnN1YnN0cigwLCA4KSwgZGtMZW4pO1xuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gICAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgICBjaXBoZXIudXBkYXRlKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG1zZy5ib2R5KSk7XG4gICAgaWYoY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgICBydmFsID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcnZhbCA9IG1zZy5ib2R5O1xuICB9XG5cbiAgaWYobXNnLnR5cGUgPT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknKSB7XG4gICAgcnZhbCA9IHBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8oYXNuMS5mcm9tRGVyKHJ2YWwpLCBwYXNzd29yZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVjcnlwdGlvbiBhbHJlYWR5IHBlcmZvcm1lZCBhYm92ZVxuICAgIHJ2YWwgPSBhc24xLmZyb21EZXIocnZhbCk7XG4gIH1cblxuICBpZihydmFsICE9PSBudWxsKSB7XG4gICAgcnZhbCA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEocnZhbCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVyaXZlcyBhIFBLQ1MjMTIga2V5LlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgbWF0ZXJpYWwgZnJvbSwgbnVsbCBvclxuICogICAgICAgICAgdW5kZWZpbmVkIGZvciBub25lLlxuICogQHBhcmFtIHNhbHQgdGhlIHNhbHQsIGFzIGEgQnl0ZUJ1ZmZlciwgdG8gdXNlLlxuICogQHBhcmFtIGlkIHRoZSBQS0NTIzEyIElEIGJ5dGUgKDEgPSBrZXkgbWF0ZXJpYWwsIDIgPSBJViwgMyA9IE1BQykuXG4gKiBAcGFyYW0gaXRlciB0aGUgaXRlcmF0aW9uIGNvdW50LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBkZXJpdmUgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZSwgZGVmYXVsdHMgdG8gU0hBLTEuXG4gKlxuICogQHJldHVybiBhIEJ5dGVCdWZmZXIgd2l0aCB0aGUgYnl0ZXMgZGVyaXZlZCBmcm9tIHRoZSBwYXNzd29yZC5cbiAqL1xucGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleSA9IGZ1bmN0aW9uKHBhc3N3b3JkLCBzYWx0LCBpZCwgaXRlciwgbiwgbWQpIHtcbiAgdmFyIGosIGw7XG5cbiAgaWYodHlwZW9mIG1kID09PSAndW5kZWZpbmVkJyB8fCBtZCA9PT0gbnVsbCkge1xuICAgIGlmKCEoJ3NoYTEnIGluIGZvcmdlLm1kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNoYTFcIiBoYXNoIGFsZ29yaXRobSB1bmF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICB9XG5cbiAgdmFyIHUgPSBtZC5kaWdlc3RMZW5ndGg7XG4gIHZhciB2ID0gbWQuYmxvY2tMZW5ndGg7XG4gIHZhciByZXN1bHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG5cbiAgLyogQ29udmVydCBwYXNzd29yZCB0byBVbmljb2RlIGJ5dGUgYnVmZmVyICsgdHJhaWxpbmcgMC1ieXRlLiAqL1xuICB2YXIgcGFzc0J1ZiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgaWYocGFzc3dvcmQgIT09IG51bGwgJiYgcGFzc3dvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvcihsID0gMDsgbCA8IHBhc3N3b3JkLmxlbmd0aDsgbCsrKSB7XG4gICAgICBwYXNzQnVmLnB1dEludDE2KHBhc3N3b3JkLmNoYXJDb2RlQXQobCkpO1xuICAgIH1cbiAgICBwYXNzQnVmLnB1dEludDE2KDApO1xuICB9XG5cbiAgLyogTGVuZ3RoIG9mIHNhbHQgYW5kIHBhc3N3b3JkIGluIEJZVEVTLiAqL1xuICB2YXIgcCA9IHBhc3NCdWYubGVuZ3RoKCk7XG4gIHZhciBzID0gc2FsdC5sZW5ndGgoKTtcblxuICAvKiAxLiBDb25zdHJ1Y3QgYSBzdHJpbmcsIEQgKHRoZSBcImRpdmVyc2lmaWVyXCIpLCBieSBjb25jYXRlbmF0aW5nXG4gICAgICAgIHYgY29waWVzIG9mIElELiAqL1xuICB2YXIgRCA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgRC5maWxsV2l0aEJ5dGUoaWQsIHYpO1xuXG4gIC8qIDIuIENvbmNhdGVuYXRlIGNvcGllcyBvZiB0aGUgc2FsdCB0b2dldGhlciB0byBjcmVhdGUgYSBzdHJpbmcgUyBvZiBsZW5ndGhcbiAgICAgICAgdiAqIGNlaWwocyAvIHYpIGJ5dGVzICh0aGUgZmluYWwgY29weSBvZiB0aGUgc2FsdCBtYXkgYmUgdHJ1bmFjdGVkXG4gICAgICAgIHRvIGNyZWF0ZSBTKS5cbiAgICAgICAgTm90ZSB0aGF0IGlmIHRoZSBzYWx0IGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc28gaXMgUy4gKi9cbiAgdmFyIFNsZW4gPSB2ICogTWF0aC5jZWlsKHMgLyB2KTtcbiAgdmFyIFMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gIGZvcihsID0gMDsgbCA8IFNsZW47IGwrKykge1xuICAgIFMucHV0Qnl0ZShzYWx0LmF0KGwgJSBzKSk7XG4gIH1cblxuICAvKiAzLiBDb25jYXRlbmF0ZSBjb3BpZXMgb2YgdGhlIHBhc3N3b3JkIHRvZ2V0aGVyIHRvIGNyZWF0ZSBhIHN0cmluZyBQIG9mXG4gICAgICAgIGxlbmd0aCB2ICogY2VpbChwIC8gdikgYnl0ZXMgKHRoZSBmaW5hbCBjb3B5IG9mIHRoZSBwYXNzd29yZCBtYXkgYmVcbiAgICAgICAgdHJ1bmNhdGVkIHRvIGNyZWF0ZSBQKS5cbiAgICAgICAgTm90ZSB0aGF0IGlmIHRoZSBwYXNzd29yZCBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNvIGlzIFAuICovXG4gIHZhciBQbGVuID0gdiAqIE1hdGguY2VpbChwIC8gdik7XG4gIHZhciBQID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICBmb3IobCA9IDA7IGwgPCBQbGVuOyBsKyspIHtcbiAgICBQLnB1dEJ5dGUocGFzc0J1Zi5hdChsICUgcCkpO1xuICB9XG5cbiAgLyogNC4gU2V0IEk9U3x8UCB0byBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBTIGFuZCBQLiAqL1xuICB2YXIgSSA9IFM7XG4gIEkucHV0QnVmZmVyKFApO1xuXG4gIC8qIDUuIFNldCBjPWNlaWwobiAvIHUpLiAqL1xuICB2YXIgYyA9IE1hdGguY2VpbChuIC8gdSk7XG5cbiAgLyogNi4gRm9yIGk9MSwgMiwgLi4uLCBjLCBkbyB0aGUgZm9sbG93aW5nOiAqL1xuICBmb3IodmFyIGkgPSAxOyBpIDw9IGM7IGkrKykge1xuICAgIC8qIGEpIFNldCBBaT1IXnIoRHx8SSkuIChsLmUuIHRoZSBydGggaGFzaCBvZiBEfHxJLCBIKEgoSCguLi5IKER8fEkpKSkpICovXG4gICAgdmFyIGJ1ZiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBidWYucHV0Qnl0ZXMoRC5ieXRlcygpKTtcbiAgICBidWYucHV0Qnl0ZXMoSS5ieXRlcygpKTtcbiAgICBmb3IodmFyIHJvdW5kID0gMDsgcm91bmQgPCBpdGVyOyByb3VuZCsrKSB7XG4gICAgICBtZC5zdGFydCgpO1xuICAgICAgbWQudXBkYXRlKGJ1Zi5nZXRCeXRlcygpKTtcbiAgICAgIGJ1ZiA9IG1kLmRpZ2VzdCgpO1xuICAgIH1cblxuICAgIC8qIGIpIENvbmNhdGVuYXRlIGNvcGllcyBvZiBBaSB0byBjcmVhdGUgYSBzdHJpbmcgQiBvZiBsZW5ndGggdiBieXRlcyAodGhlXG4gICAgICAgICAgZmluYWwgY29weSBvZiBBaSBtYXkgYmUgdHJ1bmNhdGVkIHRvIGNyZWF0ZSBCKS4gKi9cbiAgICB2YXIgQiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBmb3IobCA9IDA7IGwgPCB2OyBsKyspIHtcbiAgICAgIEIucHV0Qnl0ZShidWYuYXQobCAlIHUpKTtcbiAgICB9XG5cbiAgICAvKiBjKSBUcmVhdGluZyBJIGFzIGEgY29uY2F0ZW5hdGlvbiBJMCwgSTEsIC4uLiwgSWstMSBvZiB2LWJ5dGUgYmxvY2tzLFxuICAgICAgICAgIHdoZXJlIGs9Y2VpbChzIC8gdikgKyBjZWlsKHAgLyB2KSwgbW9kaWZ5IEkgYnkgc2V0dGluZ1xuICAgICAgICAgIElqPShJaitCKzEpIG1vZCAydiBmb3IgZWFjaCBqLiAgKi9cbiAgICB2YXIgayA9IE1hdGguY2VpbChzIC8gdikgKyBNYXRoLmNlaWwocCAvIHYpO1xuICAgIHZhciBJbmV3ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIGZvcihqID0gMDsgaiA8IGs7IGorKykge1xuICAgICAgdmFyIGNodW5rID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcihJLmdldEJ5dGVzKHYpKTtcbiAgICAgIHZhciB4ID0gMHgxZmY7XG4gICAgICBmb3IobCA9IEIubGVuZ3RoKCkgLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgICB4ID0geCA+PiA4O1xuICAgICAgICB4ICs9IEIuYXQobCkgKyBjaHVuay5hdChsKTtcbiAgICAgICAgY2h1bmsuc2V0QXQobCwgeCAmIDB4ZmYpO1xuICAgICAgfVxuICAgICAgSW5ldy5wdXRCdWZmZXIoY2h1bmspO1xuICAgIH1cbiAgICBJID0gSW5ldztcblxuICAgIC8qIEFkZCBBaSB0byBBLiAqL1xuICAgIHJlc3VsdC5wdXRCdWZmZXIoYnVmKTtcbiAgfVxuXG4gIHJlc3VsdC50cnVuY2F0ZShyZXN1bHQubGVuZ3RoKCkgLSBuKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvaWQgdGhlIE9JRCAoaW4gc3RyaW5nIG5vdGF0aW9uKS5cbiAqIEBwYXJhbSBwYXJhbXMgdGhlIEFTTi4xIHBhcmFtcyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlciA9IGZ1bmN0aW9uKG9pZCwgcGFyYW1zLCBwYXNzd29yZCkge1xuICBzd2l0Y2gob2lkKSB7XG4gIGNhc2UgcGtpLm9pZHNbJ3BrY3M1UEJFUzInXTpcbiAgICByZXR1cm4gcGtpLnBiZS5nZXRDaXBoZXJGb3JQQkVTMihvaWQsIHBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIGNhc2UgcGtpLm9pZHNbJ3BiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkMnXTpcbiAgY2FzZSBwa2kub2lkc1sncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQyddOlxuICAgIHJldHVybiBwa2kucGJlLmdldENpcGhlckZvclBLQ1MxMlBCRShvaWQsIHBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIGRlZmF1bHQ6XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBlbmNyeXB0ZWQgUEJFIGRhdGEgYmxvY2suIFVuc3VwcG9ydGVkIE9JRC4nKTtcbiAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgZXJyb3Iuc3VwcG9ydGVkT2lkcyA9IFtcbiAgICAgICdwa2NzNVBCRVMyJyxcbiAgICAgICdwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJyxcbiAgICAgICdwYmV3aXRoU0hBQW5kNDBCaXRSQzItQ0JDJ1xuICAgIF07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlIGFjY29yZGluZyB0byBQQkVTMiBwYXJhbXMgYmxvY2suXG4gKlxuICogVGhlIHJldHVybmVkIGNpcGhlciBpbnN0YW5jZSBpcyBhbHJlYWR5IHN0YXJ0ZWQgdXNpbmcgdGhlIElWXG4gKiBmcm9tIFBCRVMyIHBhcmFtZXRlciBibG9jay5cbiAqXG4gKiBAcGFyYW0gb2lkIHRoZSBQS0NTIzUgUEJLREYyIE9JRCAoaW4gc3RyaW5nIG5vdGF0aW9uKS5cbiAqIEBwYXJhbSBwYXJhbXMgdGhlIEFTTi4xIFBCRVMyLXBhcmFtcyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlckZvclBCRVMyID0gZnVuY3Rpb24ob2lkLCBwYXJhbXMsIHBhc3N3b3JkKSB7XG4gIC8vIGdldCBQQkUgcGFyYW1zXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUocGFyYW1zLCBQQkVTMkFsZ29yaXRobXNWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gYWxnb3JpdGhtICcgK1xuICAgICAgJ3BhcmFtZXRlcnMuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gY2hlY2sgb2lkc1xuICBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUua2RmT2lkKTtcbiAgaWYob2lkICE9PSBwa2kub2lkc1sncGtjczVQQktERjInXSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdVbnN1cHBvcnRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBPSUQuJyk7XG4gICAgZXJyb3Iub2lkID0gb2lkO1xuICAgIGVycm9yLnN1cHBvcnRlZE9pZHMgPSBbJ3BrY3M1UEJLREYyJ107XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmVuY09pZCk7XG4gIGlmKG9pZCAhPT0gcGtpLm9pZHNbJ2FlczEyOC1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2FlczE5Mi1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2FlczI1Ni1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2Rlcy1FREUzLUNCQyddICYmXG4gICAgb2lkICE9PSBwa2kub2lkc1snZGVzQ0JDJ10pIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIGVuY3J5cHRlZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnVW5zdXBwb3J0ZWQgZW5jcnlwdGlvbiBzY2hlbWUgT0lELicpO1xuICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICBlcnJvci5zdXBwb3J0ZWRPaWRzID0gW1xuICAgICAgJ2FlczEyOC1DQkMnLCAnYWVzMTkyLUNCQycsICdhZXMyNTYtQ0JDJywgJ2Rlcy1FREUzLUNCQycsICdkZXNDQkMnXTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIHNldCBQQkUgcGFyYW1zXG4gIHZhciBzYWx0ID0gY2FwdHVyZS5rZGZTYWx0O1xuICB2YXIgY291bnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmtkZkl0ZXJhdGlvbkNvdW50KTtcbiAgY291bnQgPSBjb3VudC5nZXRJbnQoY291bnQubGVuZ3RoKCkgPDwgMyk7XG4gIHZhciBka0xlbjtcbiAgdmFyIGNpcGhlckZuO1xuICBzd2l0Y2gocGtpLm9pZHNbb2lkXSkge1xuICBjYXNlICdhZXMxMjgtQ0JDJzpcbiAgICBka0xlbiA9IDE2O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczE5Mi1DQkMnOlxuICAgIGRrTGVuID0gMjQ7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnYWVzMjU2LUNCQyc6XG4gICAgZGtMZW4gPSAzMjtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdkZXMtRURFMy1DQkMnOlxuICAgIGRrTGVuID0gMjQ7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzQ0JDJzpcbiAgICBka0xlbiA9IDg7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGdldCBQUkYgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIG1kID0gcHJmT2lkVG9NZXNzYWdlRGlnZXN0KGNhcHR1cmUucHJmT2lkKTtcblxuICAvLyBkZWNyeXB0IHByaXZhdGUga2V5IHVzaW5nIHBiZSB3aXRoIGNob3NlbiBQUkYgYW5kIEFFUy9ERVNcbiAgdmFyIGRrID0gZm9yZ2UucGtjczUucGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgdmFyIGl2ID0gY2FwdHVyZS5lbmNJdjtcbiAgdmFyIGNpcGhlciA9IGNpcGhlckZuKGRrKTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcblxuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBHZXQgbmV3IEZvcmdlIGNpcGhlciBvYmplY3QgaW5zdGFuY2UgZm9yIFBLQ1MjMTIgUEJFLlxuICpcbiAqIFRoZSByZXR1cm5lZCBjaXBoZXIgaW5zdGFuY2UgaXMgYWxyZWFkeSBzdGFydGVkIHVzaW5nIHRoZSBrZXkgJiBJVlxuICogZGVyaXZlZCBmcm9tIHRoZSBwcm92aWRlZCBwYXNzd29yZCBhbmQgUEtDUyMxMiBQQkUgc2FsdC5cbiAqXG4gKiBAcGFyYW0gb2lkIFRoZSBQS0NTIzEyIFBCRSBPSUQgKGluIHN0cmluZyBub3RhdGlvbikuXG4gKiBAcGFyYW0gcGFyYW1zIFRoZSBBU04uMSBQS0NTIzEyIFBCRS1wYXJhbXMgb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiB0aGUgbmV3IGNpcGhlciBvYmplY3QgaW5zdGFuY2UuXG4gKi9cbnBraS5wYmUuZ2V0Q2lwaGVyRm9yUEtDUzEyUEJFID0gZnVuY3Rpb24ob2lkLCBwYXJhbXMsIHBhc3N3b3JkKSB7XG4gIC8vIGdldCBQQkUgcGFyYW1zXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUocGFyYW1zLCBwa2NzMTJQYmVQYXJhbXNWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gYWxnb3JpdGhtICcgK1xuICAgICAgJ3BhcmFtZXRlcnMuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIHNhbHQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnNhbHQpO1xuICB2YXIgY291bnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLml0ZXJhdGlvbnMpO1xuICBjb3VudCA9IGNvdW50LmdldEludChjb3VudC5sZW5ndGgoKSA8PCAzKTtcblxuICB2YXIgZGtMZW4sIGRJdkxlbiwgY2lwaGVyRm47XG4gIHN3aXRjaChvaWQpIHtcbiAgICBjYXNlIHBraS5vaWRzWydwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJ106XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgZEl2TGVuID0gODtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLnN0YXJ0RGVjcnlwdGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwa2kub2lkc1sncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQyddOlxuICAgICAgZGtMZW4gPSA1O1xuICAgICAgZEl2TGVuID0gODtcbiAgICAgIGNpcGhlckZuID0gZnVuY3Rpb24oa2V5LCBpdikge1xuICAgICAgICB2YXIgY2lwaGVyID0gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA0MCk7XG4gICAgICAgIGNpcGhlci5zdGFydChpdiwgbnVsbCk7XG4gICAgICAgIHJldHVybiBjaXBoZXI7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTICMxMiBQQkUgZGF0YSBibG9jay4gVW5zdXBwb3J0ZWQgT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gb2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBtZCA9IHByZk9pZFRvTWVzc2FnZURpZ2VzdChjYXB0dXJlLnByZk9pZCk7XG4gIHZhciBrZXkgPSBwa2kucGJlLmdlbmVyYXRlUGtjczEyS2V5KHBhc3N3b3JkLCBzYWx0LCAxLCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgbWQuc3RhcnQoKTtcbiAgdmFyIGl2ID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdCwgMiwgY291bnQsIGRJdkxlbiwgbWQpO1xuXG4gIHJldHVybiBjaXBoZXJGbihrZXksIGl2KTtcbn07XG5cbi8qKlxuICogT3BlblNTTCdzIGxlZ2FjeSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBTZWU6IGh0dHA6Ly93d3cub3BlbnNzbC5vcmcvZG9jcy9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgZnJvbS5cbiAqIEBwYXJhbSBzYWx0IHRoZSBzYWx0IHRvIHVzZSwgbnVsbCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBka0xlbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCBmb3IgdGhlIGRlcml2ZWQga2V5LlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbbWRdIGFuIG9wdGlvbmFsIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UuXG4gKi9cbnBraS5wYmUub3BlbnNzbERlcml2ZUJ5dGVzID0gZnVuY3Rpb24ocGFzc3dvcmQsIHNhbHQsIGRrTGVuLCBtZCkge1xuICBpZih0eXBlb2YgbWQgPT09ICd1bmRlZmluZWQnIHx8IG1kID09PSBudWxsKSB7XG4gICAgaWYoISgnbWQ1JyBpbiBmb3JnZS5tZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZDVcIiBoYXNoIGFsZ29yaXRobSB1bmF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gIH1cbiAgaWYoc2FsdCA9PT0gbnVsbCkge1xuICAgIHNhbHQgPSAnJztcbiAgfVxuICB2YXIgZGlnZXN0cyA9IFtoYXNoKG1kLCBwYXNzd29yZCArIHNhbHQpXTtcbiAgZm9yKHZhciBsZW5ndGggPSAxNiwgaSA9IDE7IGxlbmd0aCA8IGRrTGVuOyArK2ksIGxlbmd0aCArPSAxNikge1xuICAgIGRpZ2VzdHMucHVzaChoYXNoKG1kLCBkaWdlc3RzW2kgLSAxXSArIHBhc3N3b3JkICsgc2FsdCkpO1xuICB9XG4gIHJldHVybiBkaWdlc3RzLmpvaW4oJycpLnN1YnN0cigwLCBka0xlbik7XG59O1xuXG5mdW5jdGlvbiBoYXNoKG1kLCBieXRlcykge1xuICByZXR1cm4gbWQuc3RhcnQoKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG59XG5cbmZ1bmN0aW9uIHByZk9pZFRvTWVzc2FnZURpZ2VzdChwcmZPaWQpIHtcbiAgLy8gZ2V0IFBSRiBhbGdvcml0aG0sIGRlZmF1bHQgdG8gU0hBLTFcbiAgdmFyIHByZkFsZ29yaXRobTtcbiAgaWYoIXByZk9pZCkge1xuICAgIHByZkFsZ29yaXRobSA9ICdobWFjV2l0aFNIQTEnO1xuICB9IGVsc2Uge1xuICAgIHByZkFsZ29yaXRobSA9IHBraS5vaWRzW2FzbjEuZGVyVG9PaWQocHJmT2lkKV07XG4gICAgaWYoIXByZkFsZ29yaXRobSkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQUkYgT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gcHJmT2lkO1xuICAgICAgZXJyb3Iuc3VwcG9ydGVkID0gW1xuICAgICAgICAnaG1hY1dpdGhTSEExJywgJ2htYWNXaXRoU0hBMjI0JywgJ2htYWNXaXRoU0hBMjU2JywgJ2htYWNXaXRoU0hBMzg0JyxcbiAgICAgICAgJ2htYWNXaXRoU0hBNTEyJ107XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByZkFsZ29yaXRobVRvTWVzc2FnZURpZ2VzdChwcmZBbGdvcml0aG0pO1xufVxuXG5mdW5jdGlvbiBwcmZBbGdvcml0aG1Ub01lc3NhZ2VEaWdlc3QocHJmQWxnb3JpdGhtKSB7XG4gIHZhciBmYWN0b3J5ID0gZm9yZ2UubWQ7XG4gIHN3aXRjaChwcmZBbGdvcml0aG0pIHtcbiAgY2FzZSAnaG1hY1dpdGhTSEEyMjQnOlxuICAgIGZhY3RvcnkgPSBmb3JnZS5tZC5zaGE1MTI7XG4gIGNhc2UgJ2htYWNXaXRoU0hBMSc6XG4gIGNhc2UgJ2htYWNXaXRoU0hBMjU2JzpcbiAgY2FzZSAnaG1hY1dpdGhTSEEzODQnOlxuICBjYXNlICdobWFjV2l0aFNIQTUxMic6XG4gICAgcHJmQWxnb3JpdGhtID0gcHJmQWxnb3JpdGhtLnN1YnN0cig4KS50b0xvd2VyQ2FzZSgpO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUFJGIGFsZ29yaXRobS4nKTtcbiAgICBlcnJvci5hbGdvcml0aG0gPSBwcmZBbGdvcml0aG07XG4gICAgZXJyb3Iuc3VwcG9ydGVkID0gW1xuICAgICAgJ2htYWNXaXRoU0hBMScsICdobWFjV2l0aFNIQTIyNCcsICdobWFjV2l0aFNIQTI1NicsICdobWFjV2l0aFNIQTM4NCcsXG4gICAgICAnaG1hY1dpdGhTSEE1MTInXTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZighZmFjdG9yeSB8fCAhKHByZkFsZ29yaXRobSBpbiBmYWN0b3J5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBoYXNoIGFsZ29yaXRobTogJyArIHByZkFsZ29yaXRobSk7XG4gIH1cbiAgcmV0dXJuIGZhY3RvcnlbcHJmQWxnb3JpdGhtXS5jcmVhdGUoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGJrZGYyUGFyYW1zKHNhbHQsIGNvdW50Qnl0ZXMsIGRrTGVuLCBwcmZBbGdvcml0aG0pIHtcbiAgdmFyIHBhcmFtcyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBzYWx0XG4gICAgYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgc2FsdCksXG4gICAgLy8gaXRlcmF0aW9uIGNvdW50XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGNvdW50Qnl0ZXMuZ2V0Qnl0ZXMoKSlcbiAgXSk7XG4gIC8vIHdoZW4gUFJGIGFsZ29yaXRobSBpcyBub3QgU0hBLTEgZGVmYXVsdCwgYWRkIGtleSBsZW5ndGggYW5kIFBSRiBhbGdvcml0aG1cbiAgaWYocHJmQWxnb3JpdGhtICE9PSAnaG1hY1dpdGhTSEExJykge1xuICAgIHBhcmFtcy52YWx1ZS5wdXNoKFxuICAgICAgLy8ga2V5IGxlbmd0aFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGRrTGVuLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllclxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBhbGdvcml0aG1cbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHNbcHJmQWxnb3JpdGhtXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIHBhcmFtZXRlcnMgKG51bGwpXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgXSkpO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG4iLCIvKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYmFzaWMgUlNBIGFsZ29yaXRobXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIFRoZSBvbmx5IGFsZ29yaXRobSBjdXJyZW50bHkgc3VwcG9ydGVkIGZvciBQS0kgaXMgUlNBLlxuICpcbiAqIEFuIFJTQSBrZXkgaXMgb2Z0ZW4gc3RvcmVkIGluIEFTTi4xIERFUiBmb3JtYXQuIFRoZSBTdWJqZWN0UHVibGljS2V5SW5mb1xuICogQVNOLjEgc3RydWN0dXJlIGlzIGNvbXBvc2VkIG9mIGFuIGFsZ29yaXRobSBvZiB0eXBlIEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIGFuZCBhIHN1YmplY3RQdWJsaWNLZXkgb2YgdHlwZSBiaXQgc3RyaW5nLlxuICpcbiAqIFRoZSBBbGdvcml0aG1JZGVudGlmaWVyIGNvbnRhaW5zIGFuIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIGFuZCBwYXJhbWV0ZXJzXG4gKiBmb3IgdGhlIGFsZ29yaXRobSwgaWYgYW55LiBJbiB0aGUgY2FzZSBvZiBSU0EsIHRoZXJlIGFyZW4ndCBhbnkuXG4gKlxuICogU3ViamVjdFB1YmxpY0tleUluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgYWxnb3JpdGhtIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXkgQklUIFNUUklOR1xuICogfVxuICpcbiAqIEFsZ29yaXRobUlkZW50aWZlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogRm9yIGFuIFJTQSBwdWJsaWMga2V5LCB0aGUgc3ViamVjdFB1YmxpY0tleSBpczpcbiAqXG4gKiBSU0FQdWJsaWNLZXkgOjo9IFNFUVVFTkNFIHtcbiAqICAgbW9kdWx1cyAgICAgICAgICAgIElOVEVHRVIsICAgIC0tIG5cbiAqICAgcHVibGljRXhwb25lbnQgICAgIElOVEVHRVIgICAgIC0tIGVcbiAqIH1cbiAqXG4gKiBQcml2YXRlS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIHByaXZhdGVLZXlBbGdvcml0aG0gICAgICAgUHJpdmF0ZUtleUFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHByaXZhdGVLZXkgICAgICAgICAgICAgICAgUHJpdmF0ZUtleSxcbiAqICAgYXR0cmlidXRlcyAgICAgICAgICAgWzBdICBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUlxuICogUHJpdmF0ZUtleUFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIFByaXZhdGVLZXkgOjo9IE9DVEVUIFNUUklOR1xuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEFuIFJTQSBwcml2YXRlIGtleSBhcyB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqXG4gKiBSU0FQcml2YXRlS2V5IDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gVmVyc2lvbixcbiAqICAgbW9kdWx1cyBJTlRFR0VSLCAtLSBuXG4gKiAgIHB1YmxpY0V4cG9uZW50IElOVEVHRVIsIC0tIGVcbiAqICAgcHJpdmF0ZUV4cG9uZW50IElOVEVHRVIsIC0tIGRcbiAqICAgcHJpbWUxIElOVEVHRVIsIC0tIHBcbiAqICAgcHJpbWUyIElOVEVHRVIsIC0tIHFcbiAqICAgZXhwb25lbnQxIElOVEVHRVIsIC0tIGQgbW9kIChwLTEpXG4gKiAgIGV4cG9uZW50MiBJTlRFR0VSLCAtLSBkIG1vZCAocS0xKVxuICogICBjb2VmZmljaWVudCBJTlRFR0VSIC0tIChpbnZlcnNlIG9mIHEpIG1vZCBwXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUlxuICpcbiAqIFRoZSBPSUQgZm9yIHRoZSBSU0Ega2V5IGFsZ29yaXRobSBpczogMS4yLjg0MC4xMTM1NDkuMS4xLjFcbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9hc24xJyk7XG5yZXF1aXJlKCcuL2pzYm4nKTtcbnJlcXVpcmUoJy4vb2lkcycpO1xucmVxdWlyZSgnLi9wa2NzMScpO1xucmVxdWlyZSgnLi9wcmltZScpO1xucmVxdWlyZSgnLi9yYW5kb20nKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG5pZih0eXBlb2YgQmlnSW50ZWdlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG59XG5cbnZhciBfY3J5cHRvID0gZm9yZ2UudXRpbC5pc05vZGVqcyA/IHJlcXVpcmUoJ2NyeXB0bycpIDogbnVsbDtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vLyBzaG9ydGN1dCBmb3IgdXRpbCBBUElcbnZhciB1dGlsID0gZm9yZ2UudXRpbDtcblxuLypcbiAqIFJTQSBlbmNyeXB0aW9uIGFuZCBkZWNyeXB0aW9uLCBzZWUgUkZDIDIzMTMuXG4gKi9cbmZvcmdlLnBraSA9IGZvcmdlLnBraSB8fCB7fTtcbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpLnJzYSA9IGZvcmdlLnJzYSA9IGZvcmdlLnJzYSB8fCB7fTtcbnZhciBwa2kgPSBmb3JnZS5wa2k7XG5cbi8vIGZvciBmaW5kaW5nIHByaW1lcywgd2hpY2ggYXJlIDMwaytpIGZvciBpID0gMSwgNywgMTEsIDEzLCAxNywgMTksIDIzLCAyOVxudmFyIEdDRF8zMF9ERUxUQSA9IFs2LCA0LCAyLCA0LCAyLCA0LCA2LCAyXTtcblxuLy8gdmFsaWRhdG9yIGZvciBhIFByaXZhdGVLZXlJbmZvIHN0cnVjdHVyZVxudmFyIHByaXZhdGVLZXlWYWxpZGF0b3IgPSB7XG4gIC8vIFByaXZhdGVLZXlJbmZvXG4gIG5hbWU6ICdQcml2YXRlS2V5SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgLy8gVmVyc2lvbiAoSU5URUdFUilcbiAgICBuYW1lOiAnUHJpdmF0ZUtleUluZm8udmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVZlcnNpb24nXG4gIH0sIHtcbiAgICAvLyBwcml2YXRlS2V5QWxnb3JpdGhtXG4gICAgbmFtZTogJ1ByaXZhdGVLZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5T2lkJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBQcml2YXRlS2V5XG4gICAgbmFtZTogJ1ByaXZhdGVLZXlJbmZvJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleSdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYW4gUlNBIHByaXZhdGUga2V5XG52YXIgcnNhUHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgLy8gUlNBUHJpdmF0ZUtleVxuICBuYW1lOiAnUlNBUHJpdmF0ZUtleScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgLy8gVmVyc2lvbiAoSU5URUdFUilcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS52ZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5VmVyc2lvbidcbiAgfSwge1xuICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkubW9kdWx1cycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleU1vZHVsdXMnXG4gIH0sIHtcbiAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5wdWJsaWNFeHBvbmVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVB1YmxpY0V4cG9uZW50J1xuICB9LCB7XG4gICAgLy8gcHJpdmF0ZUV4cG9uZW50IChkKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnByaXZhdGVFeHBvbmVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVByaXZhdGVFeHBvbmVudCdcbiAgfSwge1xuICAgIC8vIHByaW1lMSAocClcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5wcmltZTEnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlQcmltZTEnXG4gIH0sIHtcbiAgICAvLyBwcmltZTIgKHEpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkucHJpbWUyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5UHJpbWUyJ1xuICB9LCB7XG4gICAgLy8gZXhwb25lbnQxIChkIG1vZCAocC0xKSlcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5leHBvbmVudDEnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlFeHBvbmVudDEnXG4gIH0sIHtcbiAgICAvLyBleHBvbmVudDIgKGQgbW9kIChxLTEpKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LmV4cG9uZW50MicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleUV4cG9uZW50MidcbiAgfSwge1xuICAgIC8vIGNvZWZmaWNpZW50ICgoaW52ZXJzZSBvZiBxKSBtb2QgcClcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5jb2VmZmljaWVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleUNvZWZmaWNpZW50J1xuICB9XVxufTtcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBSU0EgcHVibGljIGtleVxudmFyIHJzYVB1YmxpY0tleVZhbGlkYXRvciA9IHtcbiAgLy8gUlNBUHVibGljS2V5XG4gIG5hbWU6ICdSU0FQdWJsaWNLZXknLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgbmFtZTogJ1JTQVB1YmxpY0tleS5tb2R1bHVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwdWJsaWNLZXlNb2R1bHVzJ1xuICB9LCB7XG4gICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgbmFtZTogJ1JTQVB1YmxpY0tleS5leHBvbmVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHVibGljS2V5RXhwb25lbnQnXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFN1YmplY3RQdWJsaWNLZXlJbmZvIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgd2l0aCBhbiBSU0EgcHVibGljIGtleVxudmFyIHB1YmxpY0tleVZhbGlkYXRvciA9IGZvcmdlLnBraS5yc2EucHVibGljS2V5VmFsaWRhdG9yID0ge1xuICBuYW1lOiAnU3ViamVjdFB1YmxpY0tleUluZm8nLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIGNhcHR1cmVBc24xOiAnc3ViamVjdFB1YmxpY0tleUluZm8nLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnU3ViamVjdFB1YmxpY0tleUluZm8uQWxnb3JpdGhtSWRlbnRpZmllcicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3B1YmxpY0tleU9pZCdcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gc3ViamVjdFB1YmxpY0tleVxuICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgdmFsdWU6IFt7XG4gICAgICAvLyBSU0FQdWJsaWNLZXlcbiAgICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5LlJTQVB1YmxpY0tleScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdyc2FQdWJsaWNLZXknXG4gICAgfV1cbiAgfV1cbn07XG5cbi8qKlxuICogV3JhcCBkaWdlc3QgaW4gRGlnZXN0SW5mbyBvYmplY3QuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIEVNU0EtUEtDUzEtdjFfNS1FTkNPREUgYXMgcGVyIFJGQyAzNDQ3LlxuICpcbiAqIERpZ2VzdEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGRpZ2VzdCBEaWdlc3RcbiAqIH1cbiAqXG4gKiBEaWdlc3RBbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKiBEaWdlc3QgOjo9IE9DVEVUIFNUUklOR1xuICpcbiAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHdpdGggdGhlIGhhc2ggdG8gc2lnbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBlbmNvZGVkIG1lc3NhZ2UgKHJlYWR5IGZvciBSU0EgZW5jcnl0aW9uKVxuICovXG52YXIgZW1zYVBrY3MxdjE1ZW5jb2RlID0gZnVuY3Rpb24obWQpIHtcbiAgLy8gZ2V0IHRoZSBvaWQgZm9yIHRoZSBhbGdvcml0aG1cbiAgdmFyIG9pZDtcbiAgaWYobWQuYWxnb3JpdGhtIGluIHBraS5vaWRzKSB7XG4gICAgb2lkID0gcGtpLm9pZHNbbWQuYWxnb3JpdGhtXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vua25vd24gbWVzc2FnZSBkaWdlc3QgYWxnb3JpdGhtLicpO1xuICAgIGVycm9yLmFsZ29yaXRobSA9IG1kLmFsZ29yaXRobTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICB2YXIgb2lkQnl0ZXMgPSBhc24xLm9pZFRvRGVyKG9pZCkuZ2V0Qnl0ZXMoKTtcblxuICAvLyBjcmVhdGUgdGhlIGRpZ2VzdCBpbmZvXG4gIHZhciBkaWdlc3RJbmZvID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICB2YXIgZGlnZXN0QWxnb3JpdGhtID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICBkaWdlc3RBbGdvcml0aG0udmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsIG9pZEJ5dGVzKSk7XG4gIGRpZ2VzdEFsZ29yaXRobS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKSk7XG4gIHZhciBkaWdlc3QgPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGZhbHNlLCBtZC5kaWdlc3QoKS5nZXRCeXRlcygpKTtcbiAgZGlnZXN0SW5mby52YWx1ZS5wdXNoKGRpZ2VzdEFsZ29yaXRobSk7XG4gIGRpZ2VzdEluZm8udmFsdWUucHVzaChkaWdlc3QpO1xuXG4gIC8vIGVuY29kZSBkaWdlc3QgaW5mb1xuICByZXR1cm4gYXNuMS50b0RlcihkaWdlc3RJbmZvKS5nZXRCeXRlcygpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyB4XmMgbW9kIG4gKFJTQSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gb3BlcmF0aW9uKS5cbiAqXG4gKiBAcGFyYW0geCB0aGUgbnVtYmVyIHRvIHJhaXNlIGFuZCBtb2QuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIHB1YiB0cnVlIGlmIHRoZSBrZXkgaXMgcHVibGljLCBmYWxzZSBpZiBwcml2YXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdCBvZiB4XmMgbW9kIG4uXG4gKi9cbnZhciBfbW9kUG93ID0gZnVuY3Rpb24oeCwga2V5LCBwdWIpIHtcbiAgaWYocHViKSB7XG4gICAgcmV0dXJuIHgubW9kUG93KGtleS5lLCBrZXkubik7XG4gIH1cblxuICBpZigha2V5LnAgfHwgIWtleS5xKSB7XG4gICAgLy8gYWxsb3cgY2FsY3VsYXRpb24gd2l0aG91dCBDUlQgcGFyYW1zIChzbG93KVxuICAgIHJldHVybiB4Lm1vZFBvdyhrZXkuZCwga2V5Lm4pO1xuICB9XG5cbiAgLy8gcHJlLWNvbXB1dGUgZFAsIGRRLCBhbmQgcUludiBpZiBuZWNlc3NhcnlcbiAgaWYoIWtleS5kUCkge1xuICAgIGtleS5kUCA9IGtleS5kLm1vZChrZXkucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkpO1xuICB9XG4gIGlmKCFrZXkuZFEpIHtcbiAgICBrZXkuZFEgPSBrZXkuZC5tb2Qoa2V5LnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpKTtcbiAgfVxuICBpZigha2V5LnFJbnYpIHtcbiAgICBrZXkucUludiA9IGtleS5xLm1vZEludmVyc2Uoa2V5LnApO1xuICB9XG5cbiAgLyogQ2hpbmVzZSByZW1haW5kZXIgdGhlb3JlbSAoQ1JUKSBzdGF0ZXM6XG5cbiAgICBTdXBwb3NlIG4xLCBuMiwgLi4uLCBuayBhcmUgcG9zaXRpdmUgaW50ZWdlcnMgd2hpY2ggYXJlIHBhaXJ3aXNlXG4gICAgY29wcmltZSAobjEgYW5kIG4yIGhhdmUgbm8gY29tbW9uIGZhY3RvcnMgb3RoZXIgdGhhbiAxKS4gRm9yIGFueVxuICAgIGludGVnZXJzIHgxLCB4MiwgLi4uLCB4ayB0aGVyZSBleGlzdHMgYW4gaW50ZWdlciB4IHNvbHZpbmcgdGhlXG4gICAgc3lzdGVtIG9mIHNpbXVsdGFuZW91cyBjb25ncnVlbmNlcyAod2hlcmUgfj0gbWVhbnMgbW9kdWxhcmx5XG4gICAgY29uZ3J1ZW50IHNvIGEgfj0gYiBtb2QgbiBtZWFucyBhIG1vZCBuID0gYiBtb2Qgbik6XG5cbiAgICB4IH49IHgxIG1vZCBuMVxuICAgIHggfj0geDIgbW9kIG4yXG4gICAgLi4uXG4gICAgeCB+PSB4ayBtb2QgbmtcblxuICAgIFRoaXMgc3lzdGVtIG9mIGNvbmdydWVuY2VzIGhhcyBhIHNpbmdsZSBzaW11bHRhbmVvdXMgc29sdXRpb24geFxuICAgIGJldHdlZW4gMCBhbmQgbiAtIDEuIEZ1cnRoZXJtb3JlLCBlYWNoIHhrIHNvbHV0aW9uIGFuZCB4IGl0c2VsZlxuICAgIGlzIGNvbmdydWVudCBtb2R1bG8gdGhlIHByb2R1Y3QgbiA9IG4xKm4yKi4uLipuay5cbiAgICBTbyB4MSBtb2QgbiA9IHgyIG1vZCBuID0geGsgbW9kIG4gPSB4IG1vZCBuLlxuXG4gICAgVGhlIHNpbmdsZSBzaW11bHRhbmVvdXMgc29sdXRpb24geCBjYW4gYmUgc29sdmVkIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgIGVxdWF0aW9uOlxuXG4gICAgeCA9IHN1bSh4aSpyaSpzaSkgbW9kIG4gd2hlcmUgcmkgPSBuL25pIGFuZCBzaSA9IHJpXi0xIG1vZCBuaS5cblxuICAgIFdoZXJlIHggaXMgbGVzcyB0aGFuIG4sIHhpID0geCBtb2QgbmkuXG5cbiAgICBGb3IgUlNBIHdlIGFyZSBvbmx5IGNvbmNlcm5lZCB3aXRoIGsgPSAyLiBUaGUgbW9kdWx1cyBuID0gcHEsIHdoZXJlXG4gICAgcCBhbmQgcSBhcmUgY29wcmltZS4gVGhlIFJTQSBkZWNyeXB0aW9uIGFsZ29yaXRobSBpczpcblxuICAgIHkgPSB4XmQgbW9kIG5cblxuICAgIEdpdmVuIHRoZSBhYm92ZTpcblxuICAgIHgxID0geF5kIG1vZCBwXG4gICAgcjEgPSBuL3AgPSBxXG4gICAgczEgPSBxXi0xIG1vZCBwXG4gICAgeDIgPSB4XmQgbW9kIHFcbiAgICByMiA9IG4vcSA9IHBcbiAgICBzMiA9IHBeLTEgbW9kIHFcblxuICAgIFNvIHkgPSAoeDFyMXMxICsgeDJyMnMyKSBtb2QgblxuICAgICAgICAgPSAoKHheZCBtb2QgcClxKHFeLTEgbW9kIHApICsgKHheZCBtb2QgcSlwKHBeLTEgbW9kIHEpKSBtb2QgblxuXG4gICAgQWNjb3JkaW5nIHRvIEZlcm1hdCdzIExpdHRsZSBUaGVvcmVtLCBpZiB0aGUgbW9kdWx1cyBQIGlzIHByaW1lLFxuICAgIGZvciBhbnkgaW50ZWdlciBBIG5vdCBldmVubHkgZGl2aXNpYmxlIGJ5IFAsIEFeKFAtMSkgfj0gMSBtb2QgUC5cbiAgICBTaW5jZSBBIGlzIG5vdCBkaXZpc2libGUgYnkgUCBpdCBmb2xsb3dzIHRoYXQgaWY6XG4gICAgTiB+PSBNIG1vZCAoUCAtIDEpLCB0aGVuIEFeTiBtb2QgUCA9IEFeTSBtb2QgUC4gVGhlcmVmb3JlOlxuXG4gICAgQV5OIG1vZCBQID0gQV4oTSBtb2QgKFAgLSAxKSkgbW9kIFAuIChUaGUgbGF0dGVyIHRha2VzIGxlc3MgZWZmb3J0XG4gICAgdG8gY2FsY3VsYXRlKS4gSW4gb3JkZXIgdG8gY2FsY3VsYXRlIHheZCBtb2QgcCBtb3JlIHF1aWNrbHkgdGhlXG4gICAgZXhwb25lbnQgZCBtb2QgKHAgLSAxKSBpcyBzdG9yZWQgaW4gdGhlIFJTQSBwcml2YXRlIGtleSAodGhlIHNhbWVcbiAgICBpcyBkb25lIGZvciB4XmQgbW9kIHEpLiBUaGVzZSB2YWx1ZXMgYXJlIHJlZmVycmVkIHRvIGFzIGRQIGFuZCBkUVxuICAgIHJlc3BlY3RpdmVseS4gVGhlcmVmb3JlIHdlIG5vdyBoYXZlOlxuXG4gICAgeSA9ICgoeF5kUCBtb2QgcClxKHFeLTEgbW9kIHApICsgKHheZFEgbW9kIHEpcChwXi0xIG1vZCBxKSkgbW9kIG5cblxuICAgIFNpbmNlIHdlJ2xsIGJlIHJlZHVjaW5nIHheZFAgYnkgbW9kdWxvIHAgKHNhbWUgZm9yIHEpIHdlIGNhbiBhbHNvXG4gICAgcmVkdWNlIHggYnkgcCAoYW5kIHEgcmVzcGVjdGl2ZWx5KSBiZWZvcmUgaGFuZC4gVGhlcmVmb3JlLCBsZXRcblxuICAgIHhwID0gKCh4IG1vZCBwKV5kUCBtb2QgcCksIGFuZFxuICAgIHhxID0gKCh4IG1vZCBxKV5kUSBtb2QgcSksIHlpZWxkaW5nOlxuXG4gICAgeSA9ICh4cCpxKihxXi0xIG1vZCBwKSArIHhxKnAqKHBeLTEgbW9kIHEpKSBtb2QgblxuXG4gICAgVGhpcyBjYW4gYmUgZnVydGhlciByZWR1Y2VkIHRvIGEgc2ltcGxlIGFsZ29yaXRobSB0aGF0IG9ubHlcbiAgICByZXF1aXJlcyAxIGludmVyc2UgKHRoZSBxIGludmVyc2UgaXMgdXNlZCkgdG8gYmUgdXNlZCBhbmQgc3RvcmVkLlxuICAgIFRoZSBhbGdvcml0aG0gaXMgY2FsbGVkIEdhcm5lcidzIGFsZ29yaXRobS4gSWYgcUludiBpcyB0aGVcbiAgICBpbnZlcnNlIG9mIHEsIHdlIHNpbXBseSBjYWxjdWxhdGU6XG5cbiAgICB5ID0gKHFJbnYqKHhwIC0geHEpIG1vZCBwKSAqIHEgKyB4cVxuXG4gICAgSG93ZXZlciwgdGhlcmUgYXJlIHR3byBmdXJ0aGVyIGNvbXBsaWNhdGlvbnMuIEZpcnN0LCB3ZSBuZWVkIHRvXG4gICAgZW5zdXJlIHRoYXQgeHAgPiB4cSB0byBwcmV2ZW50IHNpZ25lZCBCaWdJbnRlZ2VycyBmcm9tIGJlaW5nIHVzZWRcbiAgICBzbyB3ZSBhZGQgcCB1bnRpbCB0aGlzIGlzIHRydWUgKHNpbmNlIHdlIHdpbGwgYmUgbW9kJ2luZyB3aXRoXG4gICAgcCBhbnl3YXkpLiBUaGVuLCB0aGVyZSBpcyBhIGtub3duIHRpbWluZyBhdHRhY2sgb24gYWxnb3JpdGhtc1xuICAgIHVzaW5nIHRoZSBDUlQuIFRvIG1pdGlnYXRlIHRoaXMgcmlzaywgXCJjcnlwdG9ncmFwaGljIGJsaW5kaW5nXCJcbiAgICBzaG91bGQgYmUgdXNlZC4gVGhpcyByZXF1aXJlcyBzaW1wbHkgZ2VuZXJhdGluZyBhIHJhbmRvbSBudW1iZXIgclxuICAgIGJldHdlZW4gMCBhbmQgbi0xIGFuZCBpdHMgaW52ZXJzZSBhbmQgbXVsdGlwbHlpbmcgeCBieSByXmUgYmVmb3JlXG4gICAgY2FsY3VsYXRpbmcgeSBhbmQgdGhlbiBtdWx0aXBseWluZyB5IGJ5IHJeLTEgYWZ0ZXJ3YXJkcy4gTm90ZSB0aGF0XG4gICAgciBtdXN0IGJlIGNvcHJpbWUgd2l0aCBuIChnY2QociwgbikgPT09IDEpIGluIG9yZGVyIHRvIGhhdmUgYW5cbiAgICBpbnZlcnNlLlxuICAqL1xuXG4gIC8vIGNyeXB0b2dyYXBoaWMgYmxpbmRpbmdcbiAgdmFyIHI7XG4gIGRvIHtcbiAgICByID0gbmV3IEJpZ0ludGVnZXIoXG4gICAgICBmb3JnZS51dGlsLmJ5dGVzVG9IZXgoZm9yZ2UucmFuZG9tLmdldEJ5dGVzKGtleS5uLmJpdExlbmd0aCgpIC8gOCkpLFxuICAgICAgMTYpO1xuICB9IHdoaWxlKHIuY29tcGFyZVRvKGtleS5uKSA+PSAwIHx8ICFyLmdjZChrZXkubikuZXF1YWxzKEJpZ0ludGVnZXIuT05FKSk7XG4gIHggPSB4Lm11bHRpcGx5KHIubW9kUG93KGtleS5lLCBrZXkubikpLm1vZChrZXkubik7XG5cbiAgLy8gY2FsY3VsYXRlIHhwIGFuZCB4cVxuICB2YXIgeHAgPSB4Lm1vZChrZXkucCkubW9kUG93KGtleS5kUCwga2V5LnApO1xuICB2YXIgeHEgPSB4Lm1vZChrZXkucSkubW9kUG93KGtleS5kUSwga2V5LnEpO1xuXG4gIC8vIHhwIG11c3QgYmUgbGFyZ2VyIHRoYW4geHEgdG8gYXZvaWQgc2lnbmVkIGJpdCB1c2FnZVxuICB3aGlsZSh4cC5jb21wYXJlVG8oeHEpIDwgMCkge1xuICAgIHhwID0geHAuYWRkKGtleS5wKTtcbiAgfVxuXG4gIC8vIGRvIGxhc3Qgc3RlcFxuICB2YXIgeSA9IHhwLnN1YnRyYWN0KHhxKVxuICAgIC5tdWx0aXBseShrZXkucUludikubW9kKGtleS5wKVxuICAgIC5tdWx0aXBseShrZXkucSkuYWRkKHhxKTtcblxuICAvLyByZW1vdmUgZWZmZWN0IG9mIHJhbmRvbSBmb3IgY3J5cHRvZ3JhcGhpYyBibGluZGluZ1xuICB5ID0geS5tdWx0aXBseShyLm1vZEludmVyc2Uoa2V5Lm4pKS5tb2Qoa2V5Lm4pO1xuXG4gIHJldHVybiB5O1xufTtcblxuLyoqXG4gKiBOT1RFOiBUSElTIE1FVEhPRCBJUyBERVBSRUNBVEVELCB1c2UgJ3NpZ24nIG9uIGEgcHJpdmF0ZSBrZXkgb2JqZWN0IG9yXG4gKiAnZW5jcnlwdCcgb24gYSBwdWJsaWMga2V5IG9iamVjdCBpbnN0ZWFkLlxuICpcbiAqIFBlcmZvcm1zIFJTQSBlbmNyeXB0aW9uLlxuICpcbiAqIFRoZSBwYXJhbWV0ZXIgYnQgY29udHJvbHMgd2hldGhlciB0byBwdXQgcGFkZGluZyBieXRlcyBiZWZvcmUgdGhlXG4gKiBtZXNzYWdlIHBhc3NlZCBpbi4gU2V0IGJ0IHRvIGVpdGhlciB0cnVlIG9yIGZhbHNlIHRvIGRpc2FibGUgcGFkZGluZ1xuICogY29tcGxldGVseSAoaW4gb3JkZXIgdG8gaGFuZGxlIGUuZy4gRU1TQS1QU1MgZW5jb2Rpbmcgc2VwZXJhdGVseSBiZWZvcmUpLFxuICogc2lnbmFsaW5nIHdoZXRoZXIgdGhlIGVuY3J5cHRpb24gb3BlcmF0aW9uIGlzIGEgcHVibGljIGtleSBvcGVyYXRpb25cbiAqIChpLmUuIGVuY3J5cHRpbmcgZGF0YSkgb3Igbm90LCBpLmUuIHByaXZhdGUga2V5IG9wZXJhdGlvbiAoZGF0YSBzaWduaW5nKS5cbiAqXG4gKiBGb3IgUEtDUyMxIHYxLjUgcGFkZGluZyBwYXNzIGluIHRoZSBibG9jayB0eXBlIHRvIHVzZSwgaS5lLiBlaXRoZXIgMHgwMVxuICogKGZvciBzaWduaW5nKSBvciAweDAyIChmb3IgZW5jcnlwdGlvbikuIFRoZSBrZXkgb3BlcmF0aW9uIG1vZGUgKHByaXZhdGVcbiAqIG9yIHB1YmxpYykgaXMgZGVyaXZlZCBmcm9tIHRoaXMgZmxhZyBpbiB0aGF0IGNhc2UpLlxuICpcbiAqIEBwYXJhbSBtIHRoZSBtZXNzYWdlIHRvIGVuY3J5cHQgYXMgYSBieXRlIHN0cmluZy5cbiAqIEBwYXJhbSBrZXkgdGhlIFJTQSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGJ0IGZvciBQS0NTIzEgdjEuNSBwYWRkaW5nLCB0aGUgYmxvY2sgdHlwZSB0byB1c2VcbiAqICAgKDB4MDEgZm9yIHByaXZhdGUga2V5LCAweDAyIGZvciBwdWJsaWMpLFxuICogICB0byBkaXNhYmxlIHBhZGRpbmc6IHRydWUgPSBwdWJsaWMga2V5LCBmYWxzZSA9IHByaXZhdGUga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIGVuY3J5cHRlZCBieXRlcyBhcyBhIHN0cmluZy5cbiAqL1xucGtpLnJzYS5lbmNyeXB0ID0gZnVuY3Rpb24obSwga2V5LCBidCkge1xuICB2YXIgcHViID0gYnQ7XG4gIHZhciBlYjtcblxuICAvLyBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgbW9kdWx1cyBpbiBieXRlc1xuICB2YXIgayA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIGlmKGJ0ICE9PSBmYWxzZSAmJiBidCAhPT0gdHJ1ZSkge1xuICAgIC8vIGxlZ2FjeSwgZGVmYXVsdCB0byBQS0NTIzEgdjEuNSBwYWRkaW5nXG4gICAgcHViID0gKGJ0ID09PSAweDAyKTtcbiAgICBlYiA9IF9lbmNvZGVQa2NzMV92MV81KG0sIGtleSwgYnQpO1xuICB9IGVsc2Uge1xuICAgIGViID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBlYi5wdXRCeXRlcyhtKTtcbiAgfVxuXG4gIC8vIGxvYWQgZW5jcnlwdGlvbiBibG9jayBhcyBiaWcgaW50ZWdlciAneCdcbiAgLy8gRklYTUU6IGhleCBjb252ZXJzaW9uIGluZWZmaWNpZW50LCBnZXQgQmlnSW50ZWdlciB3L2J5dGUgc3RyaW5nc1xuICB2YXIgeCA9IG5ldyBCaWdJbnRlZ2VyKGViLnRvSGV4KCksIDE2KTtcblxuICAvLyBkbyBSU0EgZW5jcnlwdGlvblxuICB2YXIgeSA9IF9tb2RQb3coeCwga2V5LCBwdWIpO1xuXG4gIC8vIGNvbnZlcnQgeSBpbnRvIHRoZSBlbmNyeXB0ZWQgZGF0YSBieXRlIHN0cmluZywgaWYgeSBpcyBzaG9ydGVyIGluXG4gIC8vIGJ5dGVzIHRoYW4gaywgdGhlbiBwcmVwZW5kIHplcm8gYnl0ZXMgdG8gZmlsbCB1cCBlZFxuICAvLyBGSVhNRTogaGV4IGNvbnZlcnNpb24gaW5lZmZpY2llbnQsIGdldCBCaWdJbnRlZ2VyIHcvYnl0ZSBzdHJpbmdzXG4gIHZhciB5aGV4ID0geS50b1N0cmluZygxNik7XG4gIHZhciBlZCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHZhciB6ZXJvcyA9IGsgLSBNYXRoLmNlaWwoeWhleC5sZW5ndGggLyAyKTtcbiAgd2hpbGUoemVyb3MgPiAwKSB7XG4gICAgZWQucHV0Qnl0ZSgweDAwKTtcbiAgICAtLXplcm9zO1xuICB9XG4gIGVkLnB1dEJ5dGVzKGZvcmdlLnV0aWwuaGV4VG9CeXRlcyh5aGV4KSk7XG4gIHJldHVybiBlZC5nZXRCeXRlcygpO1xufTtcblxuLyoqXG4gKiBOT1RFOiBUSElTIE1FVEhPRCBJUyBERVBSRUNBVEVELCB1c2UgJ2RlY3J5cHQnIG9uIGEgcHJpdmF0ZSBrZXkgb2JqZWN0IG9yXG4gKiAndmVyaWZ5JyBvbiBhIHB1YmxpYyBrZXkgb2JqZWN0IGluc3RlYWQuXG4gKlxuICogUGVyZm9ybXMgUlNBIGRlY3J5cHRpb24uXG4gKlxuICogVGhlIHBhcmFtZXRlciBtbCBjb250cm9scyB3aGV0aGVyIHRvIGFwcGx5IFBLQ1MjMSB2MS41IHBhZGRpbmdcbiAqIG9yIG5vdC4gIFNldCBtbCA9IGZhbHNlIHRvIGRpc2FibGUgcGFkZGluZyByZW1vdmFsIGNvbXBsZXRlbHlcbiAqIChpbiBvcmRlciB0byBoYW5kbGUgZS5nLiBFTVNBLVBTUyBsYXRlciBvbikgYW5kIHNpbXBseSBwYXNzIGJhY2tcbiAqIHRoZSBSU0EgZW5jcnlwdGlvbiBibG9jay5cbiAqXG4gKiBAcGFyYW0gZWQgdGhlIGVuY3J5cHRlZCBkYXRhIHRvIGRlY3J5cHQgaW4gYXMgYSBieXRlIHN0cmluZy5cbiAqIEBwYXJhbSBrZXkgdGhlIFJTQSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIHB1YiB0cnVlIGZvciBhIHB1YmxpYyBrZXkgb3BlcmF0aW9uLCBmYWxzZSBmb3IgcHJpdmF0ZS5cbiAqIEBwYXJhbSBtbCB0aGUgbWVzc2FnZSBsZW5ndGgsIGlmIGtub3duLCBmYWxzZSB0byBkaXNhYmxlIHBhZGRpbmcuXG4gKlxuICogQHJldHVybiB0aGUgZGVjcnlwdGVkIG1lc3NhZ2UgYXMgYSBieXRlIHN0cmluZy5cbiAqL1xucGtpLnJzYS5kZWNyeXB0ID0gZnVuY3Rpb24oZWQsIGtleSwgcHViLCBtbCkge1xuICAvLyBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgbW9kdWx1cyBpbiBieXRlc1xuICB2YXIgayA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIC8vIGVycm9yIGlmIHRoZSBsZW5ndGggb2YgdGhlIGVuY3J5cHRlZCBkYXRhIEVEIGlzIG5vdCBrXG4gIGlmKGVkLmxlbmd0aCAhPT0gaykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignRW5jcnlwdGVkIG1lc3NhZ2UgbGVuZ3RoIGlzIGludmFsaWQuJyk7XG4gICAgZXJyb3IubGVuZ3RoID0gZWQubGVuZ3RoO1xuICAgIGVycm9yLmV4cGVjdGVkID0gaztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgZW5jcnlwdGVkIGRhdGEgaW50byBhIGJpZyBpbnRlZ2VyXG4gIC8vIEZJWE1FOiBoZXggY29udmVyc2lvbiBpbmVmZmljaWVudCwgZ2V0IEJpZ0ludGVnZXIgdy9ieXRlIHN0cmluZ3NcbiAgdmFyIHkgPSBuZXcgQmlnSW50ZWdlcihmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihlZCkudG9IZXgoKSwgMTYpO1xuXG4gIC8vIHkgbXVzdCBiZSBsZXNzIHRoYW4gdGhlIG1vZHVsdXMgb3IgaXQgd2Fzbid0IHRoZSByZXN1bHQgb2ZcbiAgLy8gYSBwcmV2aW91cyBtb2Qgb3BlcmF0aW9uIChlbmNyeXB0aW9uKSB1c2luZyB0aGF0IG1vZHVsdXNcbiAgaWYoeS5jb21wYXJlVG8oa2V5Lm4pID49IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZCBtZXNzYWdlIGlzIGludmFsaWQuJyk7XG4gIH1cblxuICAvLyBkbyBSU0EgZGVjcnlwdGlvblxuICB2YXIgeCA9IF9tb2RQb3coeSwga2V5LCBwdWIpO1xuXG4gIC8vIGNyZWF0ZSB0aGUgZW5jcnlwdGlvbiBibG9jaywgaWYgeCBpcyBzaG9ydGVyIGluIGJ5dGVzIHRoYW4gaywgdGhlblxuICAvLyBwcmVwZW5kIHplcm8gYnl0ZXMgdG8gZmlsbCB1cCBlYlxuICAvLyBGSVhNRTogaGV4IGNvbnZlcnNpb24gaW5lZmZpY2llbnQsIGdldCBCaWdJbnRlZ2VyIHcvYnl0ZSBzdHJpbmdzXG4gIHZhciB4aGV4ID0geC50b1N0cmluZygxNik7XG4gIHZhciBlYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHZhciB6ZXJvcyA9IGsgLSBNYXRoLmNlaWwoeGhleC5sZW5ndGggLyAyKTtcbiAgd2hpbGUoemVyb3MgPiAwKSB7XG4gICAgZWIucHV0Qnl0ZSgweDAwKTtcbiAgICAtLXplcm9zO1xuICB9XG4gIGViLnB1dEJ5dGVzKGZvcmdlLnV0aWwuaGV4VG9CeXRlcyh4aGV4KSk7XG5cbiAgaWYobWwgIT09IGZhbHNlKSB7XG4gICAgLy8gbGVnYWN5LCBkZWZhdWx0IHRvIFBLQ1MjMSB2MS41IHBhZGRpbmdcbiAgICByZXR1cm4gX2RlY29kZVBrY3MxX3YxXzUoZWIuZ2V0Qnl0ZXMoKSwga2V5LCBwdWIpO1xuICB9XG5cbiAgLy8gcmV0dXJuIG1lc3NhZ2VcbiAgcmV0dXJuIGViLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUlNBIGtleS1wYWlyIGdlbmVyYXRpb24gc3RhdGUgb2JqZWN0LiBJdCBpcyB1c2VkIHRvIGFsbG93XG4gKiBrZXktZ2VuZXJhdGlvbiB0byBiZSBwZXJmb3JtZWQgaW4gc3RlcHMuIEl0IGFsc28gYWxsb3dzIGZvciBhIFVJIHRvXG4gKiBkaXNwbGF5IHByb2dyZXNzIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIGJpdHMgdGhlIHNpemUgZm9yIHRoZSBwcml2YXRlIGtleSBpbiBiaXRzLCBkZWZhdWx0cyB0byAyMDQ4LlxuICogQHBhcmFtIGUgdGhlIHB1YmxpYyBleHBvbmVudCB0byB1c2UsIGRlZmF1bHRzIHRvIDY1NTM3ICgweDEwMDAxKS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAgcHJuZyBhIGN1c3RvbSBjcnlwdG8tc2VjdXJlIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciB0byB1c2UsXG4gKiAgICAgICAgICAgIHRoYXQgbXVzdCBkZWZpbmUgXCJnZXRCeXRlc1N5bmNcIi5cbiAqICAgICAgICAgIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSAoZGVmYXVsdDogJ1BSSU1FSU5DJykuXG4gKlxuICogQHJldHVybiB0aGUgc3RhdGUgb2JqZWN0IHRvIHVzZSB0byBnZW5lcmF0ZSB0aGUga2V5LXBhaXIuXG4gKi9cbnBraS5yc2EuY3JlYXRlS2V5UGFpckdlbmVyYXRpb25TdGF0ZSA9IGZ1bmN0aW9uKGJpdHMsIGUsIG9wdGlvbnMpIHtcbiAgLy8gVE9ETzogbWlncmF0ZSBzdGVwLWJhc2VkIHByaW1lIGdlbmVyYXRpb24gY29kZSB0byBmb3JnZS5wcmltZVxuXG4gIC8vIHNldCBkZWZhdWx0IGJpdHNcbiAgaWYodHlwZW9mKGJpdHMpID09PSAnc3RyaW5nJykge1xuICAgIGJpdHMgPSBwYXJzZUludChiaXRzLCAxMCk7XG4gIH1cbiAgYml0cyA9IGJpdHMgfHwgMjA0ODtcblxuICAvLyBjcmVhdGUgcHJuZyB3aXRoIGFwaSB0aGF0IG1hdGNoZXMgQmlnSW50ZWdlciBzZWN1cmUgcmFuZG9tXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcHJuZyA9IG9wdGlvbnMucHJuZyB8fCBmb3JnZS5yYW5kb207XG4gIHZhciBybmcgPSB7XG4gICAgLy8geCBpcyBhbiBhcnJheSB0byBmaWxsIHdpdGggYnl0ZXNcbiAgICBuZXh0Qnl0ZXM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBiID0gcHJuZy5nZXRCeXRlc1N5bmMoeC5sZW5ndGgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeFtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtIHx8ICdQUklNRUlOQyc7XG5cbiAgLy8gY3JlYXRlIFBSSU1FSU5DIGFsZ29yaXRobSBzdGF0ZVxuICB2YXIgcnZhbDtcbiAgaWYoYWxnb3JpdGhtID09PSAnUFJJTUVJTkMnKSB7XG4gICAgcnZhbCA9IHtcbiAgICAgIGFsZ29yaXRobTogYWxnb3JpdGhtLFxuICAgICAgc3RhdGU6IDAsXG4gICAgICBiaXRzOiBiaXRzLFxuICAgICAgcm5nOiBybmcsXG4gICAgICBlSW50OiBlIHx8IDY1NTM3LFxuICAgICAgZTogbmV3IEJpZ0ludGVnZXIobnVsbCksXG4gICAgICBwOiBudWxsLFxuICAgICAgcTogbnVsbCxcbiAgICAgIHFCaXRzOiBiaXRzID4+IDEsXG4gICAgICBwQml0czogYml0cyAtIChiaXRzID4+IDEpLFxuICAgICAgcHFTdGF0ZTogMCxcbiAgICAgIG51bTogbnVsbCxcbiAgICAgIGtleXM6IG51bGxcbiAgICB9O1xuICAgIHJ2YWwuZS5mcm9tSW50KHJ2YWwuZUludCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBnZW5lcmF0aW9uIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcnVucyB0aGUga2V5LWdlbmVyYXRpb24gYWxnb3JpdGhtIGZvciBhdCBtb3N0IG4gc2Vjb25kc1xuICogKGFwcHJveGltYXRlbHkpIHVzaW5nIHRoZSBnaXZlbiBzdGF0ZS4gV2hlbiBrZXktZ2VuZXJhdGlvbiBoYXMgY29tcGxldGVkLFxuICogdGhlIGtleXMgd2lsbCBiZSBzdG9yZWQgaW4gc3RhdGUua2V5cy5cbiAqXG4gKiBUbyB1c2UgdGhpcyBmdW5jdGlvbiB0byB1cGRhdGUgYSBVSSB3aGlsZSBnZW5lcmF0aW5nIGEga2V5IG9yIHRvIHByZXZlbnRcbiAqIGNhdXNpbmcgYnJvd3NlciBsb2NrdXBzL3dhcm5pbmdzLCBzZXQgXCJuXCIgdG8gYSB2YWx1ZSBvdGhlciB0aGFuIDAuIEFcbiAqIHNpbXBsZSBwYXR0ZXJuIGZvciBnZW5lcmF0aW5nIGEga2V5IGFuZCBzaG93aW5nIGEgcHJvZ3Jlc3MgaW5kaWNhdG9yIGlzOlxuICpcbiAqIHZhciBzdGF0ZSA9IHBraS5yc2EuY3JlYXRlS2V5UGFpckdlbmVyYXRpb25TdGF0ZSgyMDQ4KTtcbiAqIHZhciBzdGVwID0gZnVuY3Rpb24oKSB7XG4gKiAgIC8vIHN0ZXAga2V5LWdlbmVyYXRpb24sIHJ1biBhbGdvcml0aG0gZm9yIDEwMCBtcywgcmVwZWF0XG4gKiAgIGlmKCFmb3JnZS5wa2kucnNhLnN0ZXBLZXlQYWlyR2VuZXJhdGlvblN0YXRlKHN0YXRlLCAxMDApKSB7XG4gKiAgICAgc2V0VGltZW91dChzdGVwLCAxKTtcbiAqICAgfSBlbHNlIHtcbiAqICAgICAvLyBrZXktZ2VuZXJhdGlvbiBjb21wbGV0ZVxuICogICAgIC8vIFRPRE86IHR1cm4gb2ZmIHByb2dyZXNzIGluZGljYXRvciBoZXJlXG4gKiAgICAgLy8gVE9ETzogdXNlIHRoZSBnZW5lcmF0ZWQga2V5LXBhaXIgaW4gXCJzdGF0ZS5rZXlzXCJcbiAqICAgfVxuICogfTtcbiAqIC8vIFRPRE86IHR1cm4gb24gcHJvZ3Jlc3MgaW5kaWNhdG9yIGhlcmVcbiAqIHNldFRpbWVvdXQoc3RlcCwgMCk7XG4gKlxuICogQHBhcmFtIHN0YXRlIHRoZSBzdGF0ZSB0byB1c2UuXG4gKiBAcGFyYW0gbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHJ1biB0aGUgYWxnb3JpdGhtIGZvciwgMFxuICogICAgICAgICAgdG8gcnVuIHRoZSBhbGdvcml0aG0gdG8gY29tcGxldGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIGtleS1nZW5lcmF0aW9uIGNvbXBsZXRlZCwgZmFsc2UgaWYgbm90LlxuICovXG5wa2kucnNhLnN0ZXBLZXlQYWlyR2VuZXJhdGlvblN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIG4pIHtcbiAgLy8gc2V0IGRlZmF1bHQgYWxnb3JpdGhtIGlmIG5vdCBzZXRcbiAgaWYoISgnYWxnb3JpdGhtJyBpbiBzdGF0ZSkpIHtcbiAgICBzdGF0ZS5hbGdvcml0aG0gPSAnUFJJTUVJTkMnO1xuICB9XG5cbiAgLy8gVE9ETzogbWlncmF0ZSBzdGVwLWJhc2VkIHByaW1lIGdlbmVyYXRpb24gY29kZSB0byBmb3JnZS5wcmltZVxuICAvLyBUT0RPOiBhYnN0cmFjdCBhcyBQUklNRUlOQyBhbGdvcml0aG1cblxuICAvLyBkbyBrZXkgZ2VuZXJhdGlvbiAoYmFzZWQgb24gVG9tIFd1J3MgcnNhLmpzLCBzZWUganNibi5qcyBsaWNlbnNlKVxuICAvLyB3aXRoIHNvbWUgbWlub3Igb3B0aW1pemF0aW9ucyBhbmQgZGVzaWduZWQgdG8gcnVuIGluIHN0ZXBzXG5cbiAgLy8gbG9jYWwgc3RhdGUgdmFyc1xuICB2YXIgVEhJUlRZID0gbmV3IEJpZ0ludGVnZXIobnVsbCk7XG4gIFRISVJUWS5mcm9tSW50KDMwKTtcbiAgdmFyIGRlbHRhSWR4ID0gMDtcbiAgdmFyIG9wX29yID0gZnVuY3Rpb24oeCwgeSkge3JldHVybiB4IHwgeTt9O1xuXG4gIC8vIGtlZXAgc3RlcHBpbmcgdW50aWwgdGltZSBsaW1pdCBpcyByZWFjaGVkIG9yIGRvbmVcbiAgdmFyIHQxID0gK25ldyBEYXRlKCk7XG4gIHZhciB0MjtcbiAgdmFyIHRvdGFsID0gMDtcbiAgd2hpbGUoc3RhdGUua2V5cyA9PT0gbnVsbCAmJiAobiA8PSAwIHx8IHRvdGFsIDwgbikpIHtcbiAgICAvLyBnZW5lcmF0ZSBwIG9yIHFcbiAgICBpZihzdGF0ZS5zdGF0ZSA9PT0gMCkge1xuICAgICAgLyogTm90ZTogQWxsIHByaW1lcyBhcmUgb2YgdGhlIGZvcm06XG5cbiAgICAgICAgMzBrK2ksIGZvciBpIDwgMzAgYW5kIGdjZCgzMCwgaSk9MSwgd2hlcmUgdGhlcmUgYXJlIDggdmFsdWVzIGZvciBpXG5cbiAgICAgICAgV2hlbiB3ZSBnZW5lcmF0ZSBhIHJhbmRvbSBudW1iZXIsIHdlIGFsd2F5cyBhbGlnbiBpdCBhdCAzMGsgKyAxLiBFYWNoXG4gICAgICAgIHRpbWUgdGhlIG51bWJlciBpcyBkZXRlcm1pbmVkIG5vdCB0byBiZSBwcmltZSB3ZSBhZGQgdG8gZ2V0IHRvIHRoZVxuICAgICAgICBuZXh0ICdpJywgZWc6IGlmIHRoZSBudW1iZXIgd2FzIGF0IDMwayArIDEgd2UgYWRkIDYuICovXG4gICAgICB2YXIgYml0cyA9IChzdGF0ZS5wID09PSBudWxsKSA/IHN0YXRlLnBCaXRzIDogc3RhdGUucUJpdHM7XG4gICAgICB2YXIgYml0czEgPSBiaXRzIC0gMTtcblxuICAgICAgLy8gZ2V0IGEgcmFuZG9tIG51bWJlclxuICAgICAgaWYoc3RhdGUucHFTdGF0ZSA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5udW0gPSBuZXcgQmlnSW50ZWdlcihiaXRzLCBzdGF0ZS5ybmcpO1xuICAgICAgICAvLyBmb3JjZSBNU0Igc2V0XG4gICAgICAgIGlmKCFzdGF0ZS5udW0udGVzdEJpdChiaXRzMSkpIHtcbiAgICAgICAgICBzdGF0ZS5udW0uYml0d2lzZVRvKFxuICAgICAgICAgICAgQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGJpdHMxKSwgb3Bfb3IsIHN0YXRlLm51bSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxpZ24gbnVtYmVyIG9uIDMwaysxIGJvdW5kYXJ5XG4gICAgICAgIHN0YXRlLm51bS5kQWRkT2Zmc2V0KDMxIC0gc3RhdGUubnVtLm1vZChUSElSVFkpLmJ5dGVWYWx1ZSgpLCAwKTtcbiAgICAgICAgZGVsdGFJZHggPSAwO1xuXG4gICAgICAgICsrc3RhdGUucHFTdGF0ZTtcbiAgICAgIH0gZWxzZSBpZihzdGF0ZS5wcVN0YXRlID09PSAxKSB7XG4gICAgICAgIC8vIHRyeSB0byBtYWtlIHRoZSBudW1iZXIgYSBwcmltZVxuICAgICAgICBpZihzdGF0ZS5udW0uYml0TGVuZ3RoKCkgPiBiaXRzKSB7XG4gICAgICAgICAgLy8gb3ZlcmZsb3csIHRyeSBhZ2FpblxuICAgICAgICAgIHN0YXRlLnBxU3RhdGUgPSAwO1xuICAgICAgICAgIC8vIGRvIHByaW1hbGl0eSB0ZXN0XG4gICAgICAgIH0gZWxzZSBpZihzdGF0ZS5udW0uaXNQcm9iYWJsZVByaW1lKFxuICAgICAgICAgIF9nZXRNaWxsZXJSYWJpblRlc3RzKHN0YXRlLm51bS5iaXRMZW5ndGgoKSkpKSB7XG4gICAgICAgICAgKytzdGF0ZS5wcVN0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGdldCBuZXh0IHBvdGVudGlhbCBwcmltZVxuICAgICAgICAgIHN0YXRlLm51bS5kQWRkT2Zmc2V0KEdDRF8zMF9ERUxUQVtkZWx0YUlkeCsrICUgOF0sIDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoc3RhdGUucHFTdGF0ZSA9PT0gMikge1xuICAgICAgICAvLyBlbnN1cmUgbnVtYmVyIGlzIGNvcHJpbWUgd2l0aCBlXG4gICAgICAgIHN0YXRlLnBxU3RhdGUgPVxuICAgICAgICAgIChzdGF0ZS5udW0uc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpLmdjZChzdGF0ZS5lKVxuICAgICAgICAgICAgLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT09IDApID8gMyA6IDA7XG4gICAgICB9IGVsc2UgaWYoc3RhdGUucHFTdGF0ZSA9PT0gMykge1xuICAgICAgICAvLyBzdG9yZSBwIG9yIHFcbiAgICAgICAgc3RhdGUucHFTdGF0ZSA9IDA7XG4gICAgICAgIGlmKHN0YXRlLnAgPT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5wID0gc3RhdGUubnVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnEgPSBzdGF0ZS5udW07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZHZhbmNlIHN0YXRlIGlmIGJvdGggcCBhbmQgcSBhcmUgcmVhZHlcbiAgICAgICAgaWYoc3RhdGUucCAhPT0gbnVsbCAmJiBzdGF0ZS5xICE9PSBudWxsKSB7XG4gICAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5udW0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihzdGF0ZS5zdGF0ZSA9PT0gMSkge1xuICAgICAgLy8gZW5zdXJlIHAgaXMgbGFyZ2VyIHRoYW4gcSAoc3dhcCB0aGVtIGlmIG5vdClcbiAgICAgIGlmKHN0YXRlLnAuY29tcGFyZVRvKHN0YXRlLnEpIDwgMCkge1xuICAgICAgICBzdGF0ZS5udW0gPSBzdGF0ZS5wO1xuICAgICAgICBzdGF0ZS5wID0gc3RhdGUucTtcbiAgICAgICAgc3RhdGUucSA9IHN0YXRlLm51bTtcbiAgICAgIH1cbiAgICAgICsrc3RhdGUuc3RhdGU7XG4gICAgfSBlbHNlIGlmKHN0YXRlLnN0YXRlID09PSAyKSB7XG4gICAgICAvLyBjb21wdXRlIHBoaTogKHAgLSAxKShxIC0gMSkgKEV1bGVyJ3MgdG90aWVudCBmdW5jdGlvbilcbiAgICAgIHN0YXRlLnAxID0gc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICBzdGF0ZS5xMSA9IHN0YXRlLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgc3RhdGUucGhpID0gc3RhdGUucDEubXVsdGlwbHkoc3RhdGUucTEpO1xuICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDMpIHtcbiAgICAgIC8vIGVuc3VyZSBlIGFuZCBwaGkgYXJlIGNvcHJpbWVcbiAgICAgIGlmKHN0YXRlLnBoaS5nY2Qoc3RhdGUuZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PT0gMCkge1xuICAgICAgICAvLyBwaGkgYW5kIGUgYXJlIGNvcHJpbWUsIGFkdmFuY2VcbiAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBoaSBhbmQgZSBhcmVuJ3QgY29wcmltZSwgc28gZ2VuZXJhdGUgYSBuZXcgcCBhbmQgcVxuICAgICAgICBzdGF0ZS5wID0gbnVsbDtcbiAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDQpIHtcbiAgICAgIC8vIGNyZWF0ZSBuLCBlbnN1cmUgbiBpcyBoYXMgdGhlIHJpZ2h0IG51bWJlciBvZiBiaXRzXG4gICAgICBzdGF0ZS5uID0gc3RhdGUucC5tdWx0aXBseShzdGF0ZS5xKTtcblxuICAgICAgLy8gZW5zdXJlIG4gaXMgcmlnaHQgbnVtYmVyIG9mIGJpdHNcbiAgICAgIGlmKHN0YXRlLm4uYml0TGVuZ3RoKCkgPT09IHN0YXRlLmJpdHMpIHtcbiAgICAgICAgLy8gc3VjY2VzcywgYWR2YW5jZVxuICAgICAgICArK3N0YXRlLnN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFpbGVkLCBnZXQgbmV3IHFcbiAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDUpIHtcbiAgICAgIC8vIHNldCBrZXlzXG4gICAgICB2YXIgZCA9IHN0YXRlLmUubW9kSW52ZXJzZShzdGF0ZS5waGkpO1xuICAgICAgc3RhdGUua2V5cyA9IHtcbiAgICAgICAgcHJpdmF0ZUtleTogcGtpLnJzYS5zZXRQcml2YXRlS2V5KFxuICAgICAgICAgIHN0YXRlLm4sIHN0YXRlLmUsIGQsIHN0YXRlLnAsIHN0YXRlLnEsXG4gICAgICAgICAgZC5tb2Qoc3RhdGUucDEpLCBkLm1vZChzdGF0ZS5xMSksXG4gICAgICAgICAgc3RhdGUucS5tb2RJbnZlcnNlKHN0YXRlLnApKSxcbiAgICAgICAgcHVibGljS2V5OiBwa2kucnNhLnNldFB1YmxpY0tleShzdGF0ZS5uLCBzdGF0ZS5lKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGltaW5nXG4gICAgdDIgPSArbmV3IERhdGUoKTtcbiAgICB0b3RhbCArPSB0MiAtIHQxO1xuICAgIHQxID0gdDI7XG4gIH1cblxuICByZXR1cm4gc3RhdGUua2V5cyAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIFJTQSBwdWJsaWMtcHJpdmF0ZSBrZXkgcGFpciBpbiBhIHNpbmdsZSBjYWxsLlxuICpcbiAqIFRvIGdlbmVyYXRlIGEga2V5LXBhaXIgaW4gc3RlcHMgKHRvIGFsbG93IGZvciBwcm9ncmVzcyB1cGRhdGVzIGFuZCB0b1xuICogcHJldmVudCBibG9ja2luZyBvciB3YXJuaW5ncyBpbiBzbG93IGJyb3dzZXJzKSB0aGVuIHVzZSB0aGUga2V5LXBhaXJcbiAqIGdlbmVyYXRpb24gc3RhdGUgZnVuY3Rpb25zLlxuICpcbiAqIFRvIGdlbmVyYXRlIGEga2V5LXBhaXIgYXN5bmNocm9ub3VzbHkgKGVpdGhlciB0aHJvdWdoIHdlYi13b3JrZXJzLCBpZlxuICogYXZhaWxhYmxlLCBvciBieSBicmVha2luZyB1cCB0aGUgd29yayBvbiB0aGUgbWFpbiB0aHJlYWQpLCBwYXNzIGFcbiAqIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBbYml0c10gdGhlIHNpemUgZm9yIHRoZSBwcml2YXRlIGtleSBpbiBiaXRzLCBkZWZhdWx0cyB0byAyMDQ4LlxuICogQHBhcmFtIFtlXSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgZGVmYXVsdHMgdG8gNjU1MzcuXG4gKiBAcGFyYW0gW29wdGlvbnNdIG9wdGlvbnMgZm9yIGtleS1wYWlyIGdlbmVyYXRpb24sIGlmIGdpdmVuIHRoZW4gJ2JpdHMnXG4gKiAgICAgICAgICAgIGFuZCAnZScgbXVzdCAqbm90KiBiZSBnaXZlbjpcbiAqICAgICAgICAgIGJpdHMgdGhlIHNpemUgZm9yIHRoZSBwcml2YXRlIGtleSBpbiBiaXRzLCAoZGVmYXVsdDogMjA0OCkuXG4gKiAgICAgICAgICBlIHRoZSBwdWJsaWMgZXhwb25lbnQgdG8gdXNlLCAoZGVmYXVsdDogNjU1MzcgKDB4MTAwMDEpKS5cbiAqICAgICAgICAgIHdvcmtlclNjcmlwdCB0aGUgd29ya2VyIHNjcmlwdCBVUkwuXG4gKiAgICAgICAgICB3b3JrZXJzIHRoZSBudW1iZXIgb2Ygd2ViIHdvcmtlcnMgKGlmIHN1cHBvcnRlZCkgdG8gdXNlLFxuICogICAgICAgICAgICAoZGVmYXVsdDogMikuXG4gKiAgICAgICAgICB3b3JrTG9hZCB0aGUgc2l6ZSBvZiB0aGUgd29yayBsb2FkLCBpZTogbnVtYmVyIG9mIHBvc3NpYmxlIHByaW1lXG4gKiAgICAgICAgICAgIG51bWJlcnMgZm9yIGVhY2ggd2ViIHdvcmtlciB0byBjaGVjayBwZXIgd29yayBhc3NpZ25tZW50LFxuICogICAgICAgICAgICAoZGVmYXVsdDogMTAwKS5cbiAqICAgICAgICAgIHBybmcgYSBjdXN0b20gY3J5cHRvLXNlY3VyZSBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgdG8gdXNlLFxuICogICAgICAgICAgICB0aGF0IG11c3QgZGVmaW5lIFwiZ2V0Qnl0ZXNTeW5jXCIuIERpc2FibGVzIHVzZSBvZiBuYXRpdmUgQVBJcy5cbiAqICAgICAgICAgIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSAoZGVmYXVsdDogJ1BSSU1FSU5DJykuXG4gKiBAcGFyYW0gW2NhbGxiYWNrKGVyciwga2V5cGFpcildIGNhbGxlZCBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICpcbiAqIEByZXR1cm4gYW4gb2JqZWN0IHdpdGggcHJpdmF0ZUtleSBhbmQgcHVibGljS2V5IHByb3BlcnRpZXMuXG4gKi9cbnBraS5yc2EuZ2VuZXJhdGVLZXlQYWlyID0gZnVuY3Rpb24oYml0cywgZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgLy8gKGJpdHMpLCAob3B0aW9ucyksIChjYWxsYmFjaylcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmKHR5cGVvZiBiaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IGJpdHM7XG4gICAgICBiaXRzID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZih0eXBlb2YgYml0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBiaXRzO1xuICAgICAgYml0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gKGJpdHMsIGUpLCAoYml0cywgb3B0aW9ucyksIChiaXRzLCBjYWxsYmFjayksIChvcHRpb25zLCBjYWxsYmFjaylcbiAgICBpZih0eXBlb2YgYml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmKHR5cGVvZiBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZTtcbiAgICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZih0eXBlb2YgZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgb3B0aW9ucyA9IGU7XG4gICAgICAgIGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBiaXRzO1xuICAgICAgY2FsbGJhY2sgPSBlO1xuICAgICAgYml0cyA9IHVuZGVmaW5lZDtcbiAgICAgIGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIC8vIChiaXRzLCBlLCBvcHRpb25zKSwgKGJpdHMsIGUsIGNhbGxiYWNrKSwgKGJpdHMsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIGlmKHR5cGVvZiBlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gZTtcbiAgICAgIGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZihiaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBiaXRzID0gb3B0aW9ucy5iaXRzIHx8IDIwNDg7XG4gIH1cbiAgaWYoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZSA9IG9wdGlvbnMuZSB8fCAweDEwMDAxO1xuICB9XG5cbiAgLy8gdXNlIG5hdGl2ZSBjb2RlIGlmIHBlcm1pdHRlZCwgYXZhaWxhYmxlLCBhbmQgcGFyYW1ldGVycyBhcmUgYWNjZXB0YWJsZVxuICBpZighZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJiAhb3B0aW9ucy5wcm5nICYmXG4gICAgYml0cyA+PSAyNTYgJiYgYml0cyA8PSAxNjM4NCAmJiAoZSA9PT0gMHgxMDAwMSB8fCBlID09PSAzKSkge1xuICAgIGlmKGNhbGxiYWNrKSB7XG4gICAgICAvLyB0cnkgbmF0aXZlIGFzeW5jXG4gICAgICBpZihfZGV0ZWN0Tm9kZUNyeXB0bygnZ2VuZXJhdGVLZXlQYWlyJykpIHtcbiAgICAgICAgcmV0dXJuIF9jcnlwdG8uZ2VuZXJhdGVLZXlQYWlyKCdyc2EnLCB7XG4gICAgICAgICAgbW9kdWx1c0xlbmd0aDogYml0cyxcbiAgICAgICAgICBwdWJsaWNFeHBvbmVudDogZSxcbiAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xuICAgICAgICAgICAgdHlwZTogJ3Nwa2knLFxuICAgICAgICAgICAgZm9ybWF0OiAncGVtJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJpdmF0ZUtleUVuY29kaW5nOiB7XG4gICAgICAgICAgICB0eXBlOiAncGtjczgnLFxuICAgICAgICAgICAgZm9ybWF0OiAncGVtJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBwdWIsIHByaXYpIHtcbiAgICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBwa2kucHJpdmF0ZUtleUZyb21QZW0ocHJpdiksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHBraS5wdWJsaWNLZXlGcm9tUGVtKHB1YilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZihfZGV0ZWN0U3VidGxlQ3J5cHRvKCdnZW5lcmF0ZUtleScpICYmXG4gICAgICAgIF9kZXRlY3RTdWJ0bGVDcnlwdG8oJ2V4cG9ydEtleScpKSB7XG4gICAgICAgIC8vIHVzZSBzdGFuZGFyZCBuYXRpdmUgZ2VuZXJhdGVLZXlcbiAgICAgICAgcmV0dXJuIHV0aWwuZ2xvYmFsU2NvcGUuY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgICAgICBtb2R1bHVzTGVuZ3RoOiBiaXRzLFxuICAgICAgICAgIHB1YmxpY0V4cG9uZW50OiBfaW50VG9VaW50OEFycmF5KGUpLFxuICAgICAgICAgIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9XG4gICAgICAgIH0sIHRydWUgLyoga2V5IGNhbiBiZSBleHBvcnRlZCovLCBbJ3NpZ24nLCAndmVyaWZ5J10pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC5nbG9iYWxTY29wZS5jcnlwdG8uc3VidGxlLmV4cG9ydEtleShcbiAgICAgICAgICAgICdwa2NzOCcsIHBhaXIucHJpdmF0ZUtleSk7XG4gICAgICAgIC8vIGF2b2lkaW5nIGNhdGNoKGZ1bmN0aW9uKGVycikgey4uLn0pIHRvIHN1cHBvcnQgSUUgPD0gOFxuICAgICAgICB9KS50aGVuKHVuZGVmaW5lZCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihwa2NzOCkge1xuICAgICAgICAgIGlmKHBrY3M4KSB7XG4gICAgICAgICAgICB2YXIgcHJpdmF0ZUtleSA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEoXG4gICAgICAgICAgICAgIGFzbjEuZnJvbURlcihmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihwa2NzOCkpKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgcHVibGljS2V5OiBwa2kuc2V0UnNhUHVibGljS2V5KHByaXZhdGVLZXkubiwgcHJpdmF0ZUtleS5lKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmKF9kZXRlY3RTdWJ0bGVNc0NyeXB0bygnZ2VuZXJhdGVLZXknKSAmJlxuICAgICAgICBfZGV0ZWN0U3VidGxlTXNDcnlwdG8oJ2V4cG9ydEtleScpKSB7XG4gICAgICAgIHZhciBnZW5PcCA9IHV0aWwuZ2xvYmFsU2NvcGUubXNDcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IGJpdHMsXG4gICAgICAgICAgcHVibGljRXhwb25lbnQ6IF9pbnRUb1VpbnQ4QXJyYXkoZSksXG4gICAgICAgICAgaGFzaDoge25hbWU6ICdTSEEtMjU2J31cbiAgICAgICAgfSwgdHJ1ZSAvKiBrZXkgY2FuIGJlIGV4cG9ydGVkKi8sIFsnc2lnbicsICd2ZXJpZnknXSk7XG4gICAgICAgIGdlbk9wLm9uY29tcGxldGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdmFyIHBhaXIgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgdmFyIGV4cG9ydE9wID0gdXRpbC5nbG9iYWxTY29wZS5tc0NyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KFxuICAgICAgICAgICAgJ3BrY3M4JywgcGFpci5wcml2YXRlS2V5KTtcbiAgICAgICAgICBleHBvcnRPcC5vbmNvbXBsZXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIHBrY3M4ID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgdmFyIHByaXZhdGVLZXkgPSBwa2kucHJpdmF0ZUtleUZyb21Bc24xKFxuICAgICAgICAgICAgICBhc24xLmZyb21EZXIoZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIocGtjczgpKSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXksXG4gICAgICAgICAgICAgIHB1YmxpY0tleTogcGtpLnNldFJzYVB1YmxpY0tleShwcml2YXRlS2V5Lm4sIHByaXZhdGVLZXkuZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZXhwb3J0T3Aub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBnZW5PcC5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0cnkgbmF0aXZlIHN5bmNcbiAgICAgIGlmKF9kZXRlY3ROb2RlQ3J5cHRvKCdnZW5lcmF0ZUtleVBhaXJTeW5jJykpIHtcbiAgICAgICAgdmFyIGtleXBhaXIgPSBfY3J5cHRvLmdlbmVyYXRlS2V5UGFpclN5bmMoJ3JzYScsIHtcbiAgICAgICAgICBtb2R1bHVzTGVuZ3RoOiBiaXRzLFxuICAgICAgICAgIHB1YmxpY0V4cG9uZW50OiBlLFxuICAgICAgICAgIHB1YmxpY0tleUVuY29kaW5nOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3BraScsXG4gICAgICAgICAgICBmb3JtYXQ6ICdwZW0nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcml2YXRlS2V5RW5jb2Rpbmc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdwa2NzOCcsXG4gICAgICAgICAgICBmb3JtYXQ6ICdwZW0nXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcml2YXRlS2V5OiBwa2kucHJpdmF0ZUtleUZyb21QZW0oa2V5cGFpci5wcml2YXRlS2V5KSxcbiAgICAgICAgICBwdWJsaWNLZXk6IHBraS5wdWJsaWNLZXlGcm9tUGVtKGtleXBhaXIucHVibGljS2V5KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHVzZSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uXG4gIHZhciBzdGF0ZSA9IHBraS5yc2EuY3JlYXRlS2V5UGFpckdlbmVyYXRpb25TdGF0ZShiaXRzLCBlLCBvcHRpb25zKTtcbiAgaWYoIWNhbGxiYWNrKSB7XG4gICAgcGtpLnJzYS5zdGVwS2V5UGFpckdlbmVyYXRpb25TdGF0ZShzdGF0ZSwgMCk7XG4gICAgcmV0dXJuIHN0YXRlLmtleXM7XG4gIH1cbiAgX2dlbmVyYXRlS2V5UGFpcihzdGF0ZSwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTZXRzIGFuIFJTQSBwdWJsaWMga2V5IGZyb20gQmlnSW50ZWdlcnMgbW9kdWx1cyBhbmQgZXhwb25lbnQuXG4gKlxuICogQHBhcmFtIG4gdGhlIG1vZHVsdXMuXG4gKiBAcGFyYW0gZSB0aGUgZXhwb25lbnQuXG4gKlxuICogQHJldHVybiB0aGUgcHVibGljIGtleS5cbiAqL1xucGtpLnNldFJzYVB1YmxpY0tleSA9IHBraS5yc2Euc2V0UHVibGljS2V5ID0gZnVuY3Rpb24obiwgZSkge1xuICB2YXIga2V5ID0ge1xuICAgIG46IG4sXG4gICAgZTogZVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbmNyeXB0cyB0aGUgZ2l2ZW4gZGF0YSB3aXRoIHRoaXMgcHVibGljIGtleS4gTmV3ZXIgYXBwbGljYXRpb25zXG4gICAqIHNob3VsZCB1c2UgdGhlICdSU0EtT0FFUCcgZGVjcnlwdGlvbiBzY2hlbWUsICdSU0FFUy1QS0NTMS1WMV81JyBpcyBmb3JcbiAgICogbGVnYWN5IGFwcGxpY2F0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgdGhlIGJ5dGUgc3RyaW5nIHRvIGVuY3J5cHQuXG4gICAqIEBwYXJhbSBzY2hlbWUgdGhlIGVuY3J5cHRpb24gc2NoZW1lIHRvIHVzZTpcbiAgICogICAgICAgICAgJ1JTQUVTLVBLQ1MxLVYxXzUnIChkZWZhdWx0KSxcbiAgICogICAgICAgICAgJ1JTQS1PQUVQJyxcbiAgICogICAgICAgICAgJ1JBVycsICdOT05FJywgb3IgbnVsbCB0byBwZXJmb3JtIHJhdyBSU0EgZW5jcnlwdGlvbixcbiAgICogICAgICAgICAgYW4gb2JqZWN0IHdpdGggYW4gJ2VuY29kZScgcHJvcGVydHkgc2V0IHRvIGEgZnVuY3Rpb25cbiAgICogICAgICAgICAgd2l0aCB0aGUgc2lnbmF0dXJlICdmdW5jdGlvbihkYXRhLCBrZXkpJyB0aGF0IHJldHVybnNcbiAgICogICAgICAgICAgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBlbmNvZGVkIGRhdGEuXG4gICAqIEBwYXJhbSBzY2hlbWVPcHRpb25zIGFueSBzY2hlbWUtc3BlY2lmaWMgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybiB0aGUgZW5jcnlwdGVkIGJ5dGUgc3RyaW5nLlxuICAgKi9cbiAga2V5LmVuY3J5cHQgPSBmdW5jdGlvbihkYXRhLCBzY2hlbWUsIHNjaGVtZU9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgc2NoZW1lID0gc2NoZW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzY2hlbWUgPSAnUlNBRVMtUEtDUzEtVjFfNSc7XG4gICAgfVxuXG4gICAgaWYoc2NoZW1lID09PSAnUlNBRVMtUEtDUzEtVjFfNScpIHtcbiAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbihtLCBrZXksIHB1Yikge1xuICAgICAgICAgIHJldHVybiBfZW5jb2RlUGtjczFfdjFfNShtLCBrZXksIDB4MDIpLmdldEJ5dGVzKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gJ1JTQS1PQUVQJyB8fCBzY2hlbWUgPT09ICdSU0FFUy1PQUVQJykge1xuICAgICAgc2NoZW1lID0ge1xuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uKG0sIGtleSkge1xuICAgICAgICAgIHJldHVybiBmb3JnZS5wa2NzMS5lbmNvZGVfcnNhX29hZXAoa2V5LCBtLCBzY2hlbWVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoWydSQVcnLCAnTk9ORScsICdOVUxMJywgbnVsbF0uaW5kZXhPZihzY2hlbWUpICE9PSAtMSkge1xuICAgICAgc2NoZW1lID0ge2VuY29kZTogZnVuY3Rpb24oZSkge3JldHVybiBlO319O1xuICAgIH0gZWxzZSBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNyeXB0aW9uIHNjaGVtZTogXCInICsgc2NoZW1lICsgJ1wiLicpO1xuICAgIH1cblxuICAgIC8vIGRvIHNjaGVtZS1iYXNlZCBlbmNvZGluZyB0aGVuIHJzYSBlbmNyeXB0aW9uXG4gICAgdmFyIGUgPSBzY2hlbWUuZW5jb2RlKGRhdGEsIGtleSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHBraS5yc2EuZW5jcnlwdChlLCBrZXksIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGFnYWluc3QgdGhlIGdpdmVuIGRpZ2VzdC5cbiAgICpcbiAgICogUEtDUyMxIHN1cHBvcnRzIG11bHRpcGxlIChjdXJyZW50bHkgdHdvKSBzaWduYXR1cmUgc2NoZW1lczpcbiAgICogUlNBU1NBLVBLQ1MxLVYxXzUgYW5kIFJTQVNTQS1QU1MuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSBcIm9sZCBzY2hlbWVcIiwgaS5lLlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNSwgaW4gd2hpY2ggY2FzZSBvbmNlIFJTQS1kZWNyeXB0ZWQsIHRoZVxuICAgKiBzaWduYXR1cmUgaXMgYW4gT0NURVQgU1RSSU5HIHRoYXQgaG9sZHMgYSBEaWdlc3RJbmZvLlxuICAgKlxuICAgKiBEaWdlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gICAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gICAqICAgZGlnZXN0IERpZ2VzdFxuICAgKiB9XG4gICAqIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICogRGlnZXN0IDo6PSBPQ1RFVCBTVFJJTkdcbiAgICpcbiAgICogVG8gcGVyZm9ybSBQU1Mgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiwgcHJvdmlkZSBhbiBpbnN0YW5jZVxuICAgKiBvZiBGb3JnZSBQU1Mgb2JqZWN0IGFzIHRoZSBzY2hlbWUgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0gZGlnZXN0IHRoZSBtZXNzYWdlIGRpZ2VzdCBoYXNoIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgc2lnbmF0dXJlLFxuICAgKiAgICAgICAgICBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZy5cbiAgICogQHBhcmFtIHNpZ25hdHVyZSB0aGUgc2lnbmF0dXJlIHRvIHZlcmlmeSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuXG4gICAqIEBwYXJhbSBzY2hlbWUgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBU1NBLVBLQ1MxLVYxXzUnIG9yIHVuZGVmaW5lZCBmb3IgUlNBU1NBIFBLQ1MjMSB2MS41LFxuICAgKiAgICAgICAgICBhIEZvcmdlIFBTUyBvYmplY3QgZm9yIFJTQVNTQS1QU1MsXG4gICAqICAgICAgICAgICdOT05FJyBvciBudWxsIGZvciBub25lLCBEaWdlc3RJbmZvIHdpbGwgbm90IGJlIGV4cGVjdGVkLCBidXRcbiAgICogICAgICAgICAgICBQS0NTIzEgdjEuNSBwYWRkaW5nIHdpbGwgc3RpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBzaWduYXR1cmUgd2FzIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBrZXkudmVyaWZ5ID0gZnVuY3Rpb24oZGlnZXN0LCBzaWduYXR1cmUsIHNjaGVtZSkge1xuICAgIGlmKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNjaGVtZSA9ICdSU0FTU0EtUEtDUzEtVjFfNSc7XG4gICAgfVxuXG4gICAgaWYoc2NoZW1lID09PSAnUlNBU1NBLVBLQ1MxLVYxXzUnKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIHZlcmlmeTogZnVuY3Rpb24oZGlnZXN0LCBkKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHBhZGRpbmdcbiAgICAgICAgICBkID0gX2RlY29kZVBrY3MxX3YxXzUoZCwga2V5LCB0cnVlKTtcbiAgICAgICAgICAvLyBkIGlzIEFTTi4xIEJFUi1lbmNvZGVkIERpZ2VzdEluZm9cbiAgICAgICAgICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKGQpO1xuICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIGdpdmVuIGRpZ2VzdCB0byB0aGUgZGVjcnlwdGVkIG9uZVxuICAgICAgICAgIHJldHVybiBkaWdlc3QgPT09IG9iai52YWx1ZVsxXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnTk9ORScgfHwgc2NoZW1lID09PSAnTlVMTCcgfHwgc2NoZW1lID09PSBudWxsKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIHZlcmlmeTogZnVuY3Rpb24oZGlnZXN0LCBkKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHBhZGRpbmdcbiAgICAgICAgICBkID0gX2RlY29kZVBrY3MxX3YxXzUoZCwga2V5LCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gZGlnZXN0ID09PSBkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGRvIHJzYSBkZWNyeXB0aW9uIHcvbyBhbnkgZGVjb2RpbmcsIHRoZW4gdmVyaWZ5IC0tIHdoaWNoIGRvZXMgZGVjb2RpbmdcbiAgICB2YXIgZCA9IHBraS5yc2EuZGVjcnlwdChzaWduYXR1cmUsIGtleSwgdHJ1ZSwgZmFsc2UpO1xuICAgIHJldHVybiBzY2hlbWUudmVyaWZ5KGRpZ2VzdCwgZCwga2V5Lm4uYml0TGVuZ3RoKCkpO1xuICB9O1xuXG4gIHJldHVybiBrZXk7XG59O1xuXG4vKipcbiAqIFNldHMgYW4gUlNBIHByaXZhdGUga2V5IGZyb20gQmlnSW50ZWdlcnMgbW9kdWx1cywgZXhwb25lbnQsIHByaW1lcyxcbiAqIHByaW1lIGV4cG9uZW50cywgYW5kIG1vZHVsYXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZS5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbW9kdWx1cy5cbiAqIEBwYXJhbSBlIHRoZSBwdWJsaWMgZXhwb25lbnQuXG4gKiBAcGFyYW0gZCB0aGUgcHJpdmF0ZSBleHBvbmVudCAoKGludmVyc2Ugb2YgZSkgbW9kIG4pLlxuICogQHBhcmFtIHAgdGhlIGZpcnN0IHByaW1lLlxuICogQHBhcmFtIHEgdGhlIHNlY29uZCBwcmltZS5cbiAqIEBwYXJhbSBkUCBleHBvbmVudDEgKGQgbW9kIChwLTEpKS5cbiAqIEBwYXJhbSBkUSBleHBvbmVudDIgKGQgbW9kIChxLTEpKS5cbiAqIEBwYXJhbSBxSW52ICgoaW52ZXJzZSBvZiBxKSBtb2QgcClcbiAqXG4gKiBAcmV0dXJuIHRoZSBwcml2YXRlIGtleS5cbiAqL1xucGtpLnNldFJzYVByaXZhdGVLZXkgPSBwa2kucnNhLnNldFByaXZhdGVLZXkgPSBmdW5jdGlvbihcbiAgbiwgZSwgZCwgcCwgcSwgZFAsIGRRLCBxSW52KSB7XG4gIHZhciBrZXkgPSB7XG4gICAgbjogbixcbiAgICBlOiBlLFxuICAgIGQ6IGQsXG4gICAgcDogcCxcbiAgICBxOiBxLFxuICAgIGRQOiBkUCxcbiAgICBkUTogZFEsXG4gICAgcUludjogcUludlxuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNyeXB0cyB0aGUgZ2l2ZW4gZGF0YSB3aXRoIHRoaXMgcHJpdmF0ZSBrZXkuIFRoZSBkZWNyeXB0aW9uIHNjaGVtZVxuICAgKiBtdXN0IG1hdGNoIHRoZSBvbmUgdXNlZCB0byBlbmNyeXB0IHRoZSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB0aGUgYnl0ZSBzdHJpbmcgdG8gZGVjcnlwdC5cbiAgICogQHBhcmFtIHNjaGVtZSB0aGUgZGVjcnlwdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBRVMtUEtDUzEtVjFfNScgKGRlZmF1bHQpLFxuICAgKiAgICAgICAgICAnUlNBLU9BRVAnLFxuICAgKiAgICAgICAgICAnUkFXJywgJ05PTkUnLCBvciBudWxsIHRvIHBlcmZvcm0gcmF3IFJTQSBkZWNyeXB0aW9uLlxuICAgKiBAcGFyYW0gc2NoZW1lT3B0aW9ucyBhbnkgc2NoZW1lLXNwZWNpZmljIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGRlY3J5cHRlZCBieXRlIHN0cmluZy5cbiAgICovXG4gIGtleS5kZWNyeXB0ID0gZnVuY3Rpb24oZGF0YSwgc2NoZW1lLCBzY2hlbWVPcHRpb25zKSB7XG4gICAgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNjaGVtZSA9IHNjaGVtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2NoZW1lID0gJ1JTQUVTLVBLQ1MxLVYxXzUnO1xuICAgIH1cblxuICAgIC8vIGRvIHJzYSBkZWNyeXB0aW9uIHcvbyBhbnkgZGVjb2RpbmdcbiAgICB2YXIgZCA9IHBraS5yc2EuZGVjcnlwdChkYXRhLCBrZXksIGZhbHNlLCBmYWxzZSk7XG5cbiAgICBpZihzY2hlbWUgPT09ICdSU0FFUy1QS0NTMS1WMV81Jykge1xuICAgICAgc2NoZW1lID0ge2RlY29kZTogX2RlY29kZVBrY3MxX3YxXzV9O1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09ICdSU0EtT0FFUCcgfHwgc2NoZW1lID09PSAnUlNBRVMtT0FFUCcpIHtcbiAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgZGVjb2RlOiBmdW5jdGlvbihkLCBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gZm9yZ2UucGtjczEuZGVjb2RlX3JzYV9vYWVwKGtleSwgZCwgc2NoZW1lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmKFsnUkFXJywgJ05PTkUnLCAnTlVMTCcsIG51bGxdLmluZGV4T2Yoc2NoZW1lKSAhPT0gLTEpIHtcbiAgICAgIHNjaGVtZSA9IHtkZWNvZGU6IGZ1bmN0aW9uKGQpIHtyZXR1cm4gZDt9fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNyeXB0aW9uIHNjaGVtZTogXCInICsgc2NoZW1lICsgJ1wiLicpO1xuICAgIH1cblxuICAgIC8vIGRlY29kZSBhY2NvcmRpbmcgdG8gc2NoZW1lXG4gICAgcmV0dXJuIHNjaGVtZS5kZWNvZGUoZCwga2V5LCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpZ25zIHRoZSBnaXZlbiBkaWdlc3QsIHByb2R1Y2luZyBhIHNpZ25hdHVyZS5cbiAgICpcbiAgICogUEtDUyMxIHN1cHBvcnRzIG11bHRpcGxlIChjdXJyZW50bHkgdHdvKSBzaWduYXR1cmUgc2NoZW1lczpcbiAgICogUlNBU1NBLVBLQ1MxLVYxXzUgYW5kIFJTQVNTQS1QU1MuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSBcIm9sZCBzY2hlbWVcIiwgaS5lLlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNS4gSW4gb3JkZXIgdG8gZ2VuZXJhdGUgYSBQU1Mgc2lnbmF0dXJlLCBwcm92aWRlXG4gICAqIGFuIGluc3RhbmNlIG9mIEZvcmdlIFBTUyBvYmplY3QgYXMgdGhlIHNjaGVtZSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHdpdGggdGhlIGhhc2ggdG8gc2lnbi5cbiAgICogQHBhcmFtIHNjaGVtZSB0aGUgc2lnbmF0dXJlIHNjaGVtZSB0byB1c2U6XG4gICAqICAgICAgICAgICdSU0FTU0EtUEtDUzEtVjFfNScgb3IgdW5kZWZpbmVkIGZvciBSU0FTU0EgUEtDUyMxIHYxLjUsXG4gICAqICAgICAgICAgIGEgRm9yZ2UgUFNTIG9iamVjdCBmb3IgUlNBU1NBLVBTUyxcbiAgICogICAgICAgICAgJ05PTkUnIG9yIG51bGwgZm9yIG5vbmUsIERpZ2VzdEluZm8gd2lsbCBub3QgYmUgdXNlZCBidXRcbiAgICogICAgICAgICAgICBQS0NTIzEgdjEuNSBwYWRkaW5nIHdpbGwgc3RpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogQHJldHVybiB0aGUgc2lnbmF0dXJlIGFzIGEgYnl0ZSBzdHJpbmcuXG4gICAqL1xuICBrZXkuc2lnbiA9IGZ1bmN0aW9uKG1kLCBzY2hlbWUpIHtcbiAgICAvKiBOb3RlOiBUaGUgaW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgUlNBIG9wZXJhdGlvbnMgaXMgYmVpbmdcbiAgICAgIHRyYW5zaXRpb25lZCBhd2F5IGZyb20gYSBQS0NTIzEgdjEuNSBoYXJkLWNvZGVkIHNjaGVtZS4gU29tZSBsZWdhY3lcbiAgICAgIGNvZGUgbGlrZSB0aGUgdXNlIG9mIGFuIGVuY29kaW5nIGJsb2NrIGlkZW50aWZpZXIgJ2J0JyB3aWxsIGV2ZW50dWFsbHlcbiAgICAgIGJlIHJlbW92ZWQuICovXG5cbiAgICAvLyBwcml2YXRlIGtleSBvcGVyYXRpb25cbiAgICB2YXIgYnQgPSBmYWxzZTtcblxuICAgIGlmKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZihzY2hlbWUgPT09IHVuZGVmaW5lZCB8fCBzY2hlbWUgPT09ICdSU0FTU0EtUEtDUzEtVjFfNScpIHtcbiAgICAgIHNjaGVtZSA9IHtlbmNvZGU6IGVtc2FQa2NzMXYxNWVuY29kZX07XG4gICAgICBidCA9IDB4MDE7XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gJ05PTkUnIHx8IHNjaGVtZSA9PT0gJ05VTEwnIHx8IHNjaGVtZSA9PT0gbnVsbCkge1xuICAgICAgc2NoZW1lID0ge2VuY29kZTogZnVuY3Rpb24oKSB7cmV0dXJuIG1kO319O1xuICAgICAgYnQgPSAweDAxO1xuICAgIH1cblxuICAgIC8vIGVuY29kZSBhbmQgdGhlbiBlbmNyeXB0XG4gICAgdmFyIGQgPSBzY2hlbWUuZW5jb2RlKG1kLCBrZXkubi5iaXRMZW5ndGgoKSk7XG4gICAgcmV0dXJuIHBraS5yc2EuZW5jcnlwdChkLCBrZXksIGJ0KTtcbiAgfTtcblxuICByZXR1cm4ga2V5O1xufTtcblxuLyoqXG4gKiBXcmFwcyBhbiBSU0FQcml2YXRlS2V5IEFTTi4xIG9iamVjdCBpbiBhbiBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHJzYUtleSB0aGUgQVNOLjEgUlNBUHJpdmF0ZUtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLndyYXBSc2FQcml2YXRlS2V5ID0gZnVuY3Rpb24ocnNhS2V5KSB7XG4gIC8vIFByaXZhdGVLZXlJbmZvXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gdmVyc2lvbiAoMClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoMCkuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gcHJpdmF0ZUtleUFsZ29yaXRobVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMucnNhRW5jcnlwdGlvbikuZ2V0Qnl0ZXMoKSksXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICBdKSxcbiAgICAvLyBQcml2YXRlS2V5XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICBhc24xLnRvRGVyKHJzYUtleSkuZ2V0Qnl0ZXMoKSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcHJpdmF0ZSBrZXkgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgYSBQcml2YXRlS2V5SW5mbyBjb250YWluaW5nIGFuXG4gKiAgICAgICAgICBSU0FQcml2YXRlS2V5IG9yIGFuIFJTQVByaXZhdGVLZXkuXG4gKlxuICogQHJldHVybiB0aGUgcHJpdmF0ZSBrZXkuXG4gKi9cbnBraS5wcml2YXRlS2V5RnJvbUFzbjEgPSBmdW5jdGlvbihvYmopIHtcbiAgLy8gZ2V0IFByaXZhdGVLZXlJbmZvXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoYXNuMS52YWxpZGF0ZShvYmosIHByaXZhdGVLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICBvYmogPSBhc24xLmZyb21EZXIoZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5KSk7XG4gIH1cblxuICAvLyBnZXQgUlNBUHJpdmF0ZUtleVxuICBjYXB0dXJlID0ge307XG4gIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIHJzYVByaXZhdGVLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhbiBSU0FQcml2YXRlS2V5LicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIE5vdGU6IFZlcnNpb24gaXMgY3VycmVudGx5IGlnbm9yZWQuXG4gIC8vIGNhcHR1cmUucHJpdmF0ZUtleVZlcnNpb25cbiAgLy8gRklYTUU6IGluZWZmaWNpZW50LCBnZXQgYSBCaWdJbnRlZ2VyIHRoYXQgdXNlcyBieXRlIHN0cmluZ3NcbiAgdmFyIG4sIGUsIGQsIHAsIHEsIGRQLCBkUSwgcUludjtcbiAgbiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleU1vZHVsdXMpLnRvSGV4KCk7XG4gIGUgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQdWJsaWNFeHBvbmVudCkudG9IZXgoKTtcbiAgZCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleVByaXZhdGVFeHBvbmVudCkudG9IZXgoKTtcbiAgcCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleVByaW1lMSkudG9IZXgoKTtcbiAgcSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleVByaW1lMikudG9IZXgoKTtcbiAgZFAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlFeHBvbmVudDEpLnRvSGV4KCk7XG4gIGRRID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5RXhwb25lbnQyKS50b0hleCgpO1xuICBxSW52ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5Q29lZmZpY2llbnQpLnRvSGV4KCk7XG5cbiAgLy8gc2V0IHByaXZhdGUga2V5XG4gIHJldHVybiBwa2kuc2V0UnNhUHJpdmF0ZUtleShcbiAgICBuZXcgQmlnSW50ZWdlcihuLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIoZSwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGQsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihwLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIocSwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGRQLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIoZFEsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihxSW52LCAxNikpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHByaXZhdGUga2V5IHRvIGFuIEFTTi4xIFJTQVByaXZhdGVLZXkuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgYW4gUlNBUHJpdmF0ZUtleS5cbiAqL1xucGtpLnByaXZhdGVLZXlUb0FzbjEgPSBwa2kucHJpdmF0ZUtleVRvUlNBUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAvLyBSU0FQcml2YXRlS2V5XG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gdmVyc2lvbiAoMCA9IG9ubHkgMiBwcmltZXMsIDEgbXVsdGlwbGUgcHJpbWVzKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBhc24xLmludGVnZXJUb0RlcigwKS5nZXRCeXRlcygpKSxcbiAgICAvLyBtb2R1bHVzIChuKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5uKSksXG4gICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LmUpKSxcbiAgICAvLyBwcml2YXRlRXhwb25lbnQgKGQpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LmQpKSxcbiAgICAvLyBwcml2YXRlS2V5UHJpbWUxIChwKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5wKSksXG4gICAgLy8gcHJpdmF0ZUtleVByaW1lMiAocSlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkucSkpLFxuICAgIC8vIHByaXZhdGVLZXlFeHBvbmVudDEgKGRQKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5kUCkpLFxuICAgIC8vIHByaXZhdGVLZXlFeHBvbmVudDIgKGRRKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5kUSkpLFxuICAgIC8vIGNvZWZmaWNpZW50IChxSW52KVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5xSW52KSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcHVibGljIGtleSBmcm9tIGFuIEFTTi4xIFN1YmplY3RQdWJsaWNLZXlJbmZvIG9yIFJTQVB1YmxpY0tleS5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBhc24xIHJlcHJlc2VudGF0aW9uIG9mIGEgU3ViamVjdFB1YmxpY0tleUluZm8gb3IgUlNBUHVibGljS2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIHB1YmxpYyBrZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaikge1xuICAvLyBnZXQgU3ViamVjdFB1YmxpY0tleUluZm9cbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZihhc24xLnZhbGlkYXRlKG9iaiwgcHVibGljS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgLy8gZ2V0IG9pZFxuICAgIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUucHVibGljS2V5T2lkKTtcbiAgICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgcHVibGljIGtleS4gVW5rbm93biBPSUQuJyk7XG4gICAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgb2JqID0gY2FwdHVyZS5yc2FQdWJsaWNLZXk7XG4gIH1cblxuICAvLyBnZXQgUlNBIHBhcmFtc1xuICBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCByc2FQdWJsaWNLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGFuIFJTQVB1YmxpY0tleS4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBGSVhNRTogaW5lZmZpY2llbnQsIGdldCBhIEJpZ0ludGVnZXIgdGhhdCB1c2VzIGJ5dGUgc3RyaW5nc1xuICB2YXIgbiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHVibGljS2V5TW9kdWx1cykudG9IZXgoKTtcbiAgdmFyIGUgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnB1YmxpY0tleUV4cG9uZW50KS50b0hleCgpO1xuXG4gIC8vIHNldCBwdWJsaWMga2V5XG4gIHJldHVybiBwa2kuc2V0UnNhUHVibGljS2V5KFxuICAgIG5ldyBCaWdJbnRlZ2VyKG4sIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihlLCAxNikpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gYW4gQVNOLjEgU3ViamVjdFB1YmxpY0tleUluZm8uXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHVibGljIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIHJlcHJlc2VudGF0aW9uIG9mIGEgU3ViamVjdFB1YmxpY0tleUluZm8uXG4gKi9cbnBraS5wdWJsaWNLZXlUb0FzbjEgPSBwa2kucHVibGljS2V5VG9TdWJqZWN0UHVibGljS2V5SW5mbyA9IGZ1bmN0aW9uKGtleSkge1xuICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBhbGdvcml0aG1cbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5yc2FFbmNyeXB0aW9uKS5nZXRCeXRlcygpKSxcbiAgICAgIC8vIHBhcmFtZXRlcnMgKG51bGwpXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICBdKSxcbiAgICAvLyBzdWJqZWN0UHVibGljS2V5XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CSVRTVFJJTkcsIGZhbHNlLCBbXG4gICAgICBwa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXkoa2V5KVxuICAgIF0pXG4gIF0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gYW4gQVNOLjEgUlNBUHVibGljS2V5LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFJTQVB1YmxpY0tleS5cbiAqL1xucGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIC8vIFJTQVB1YmxpY0tleVxuICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5Lm4pKSxcbiAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZSkpXG4gIF0pO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgbWVzc2FnZSB1c2luZyBQS0NTIzEgdjEuNSBwYWRkaW5nLlxuICpcbiAqIEBwYXJhbSBtIHRoZSBtZXNzYWdlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBrZXkgdGhlIFJTQSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGJ0IHRoZSBibG9jayB0eXBlIHRvIHVzZSwgaS5lLiBlaXRoZXIgMHgwMSAoZm9yIHNpZ25pbmcpIG9yIDB4MDJcbiAqICAgICAgICAgIChmb3IgZW5jcnlwdGlvbikuXG4gKlxuICogQHJldHVybiB0aGUgcGFkZGVkIGJ5dGUgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfZW5jb2RlUGtjczFfdjFfNShtLCBrZXksIGJ0KSB7XG4gIHZhciBlYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gZ2V0IHRoZSBsZW5ndGggb2YgdGhlIG1vZHVsdXMgaW4gYnl0ZXNcbiAgdmFyIGsgPSBNYXRoLmNlaWwoa2V5Lm4uYml0TGVuZ3RoKCkgLyA4KTtcblxuICAvKiB1c2UgUEtDUyMxIHYxLjUgcGFkZGluZyAqL1xuICBpZihtLmxlbmd0aCA+IChrIC0gMTEpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdNZXNzYWdlIGlzIHRvbyBsb25nIGZvciBQS0NTIzEgdjEuNSBwYWRkaW5nLicpO1xuICAgIGVycm9yLmxlbmd0aCA9IG0ubGVuZ3RoO1xuICAgIGVycm9yLm1heCA9IGsgLSAxMTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8qIEEgYmxvY2sgdHlwZSBCVCwgYSBwYWRkaW5nIHN0cmluZyBQUywgYW5kIHRoZSBkYXRhIEQgc2hhbGwgYmVcbiAgICBmb3JtYXR0ZWQgaW50byBhbiBvY3RldCBzdHJpbmcgRUIsIHRoZSBlbmNyeXB0aW9uIGJsb2NrOlxuXG4gICAgRUIgPSAwMCB8fCBCVCB8fCBQUyB8fCAwMCB8fCBEXG5cbiAgICBUaGUgYmxvY2sgdHlwZSBCVCBzaGFsbCBiZSBhIHNpbmdsZSBvY3RldCBpbmRpY2F0aW5nIHRoZSBzdHJ1Y3R1cmUgb2ZcbiAgICB0aGUgZW5jcnlwdGlvbiBibG9jay4gRm9yIHRoaXMgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQgaXQgc2hhbGwgaGF2ZVxuICAgIHZhbHVlIDAwLCAwMSwgb3IgMDIuIEZvciBhIHByaXZhdGUta2V5IG9wZXJhdGlvbiwgdGhlIGJsb2NrIHR5cGVcbiAgICBzaGFsbCBiZSAwMCBvciAwMS4gRm9yIGEgcHVibGljLWtleSBvcGVyYXRpb24sIGl0IHNoYWxsIGJlIDAyLlxuXG4gICAgVGhlIHBhZGRpbmcgc3RyaW5nIFBTIHNoYWxsIGNvbnNpc3Qgb2Ygay0zLXx8RHx8IG9jdGV0cy4gRm9yIGJsb2NrXG4gICAgdHlwZSAwMCwgdGhlIG9jdGV0cyBzaGFsbCBoYXZlIHZhbHVlIDAwOyBmb3IgYmxvY2sgdHlwZSAwMSwgdGhleVxuICAgIHNoYWxsIGhhdmUgdmFsdWUgRkY7IGFuZCBmb3IgYmxvY2sgdHlwZSAwMiwgdGhleSBzaGFsbCBiZVxuICAgIHBzZXVkb3JhbmRvbWx5IGdlbmVyYXRlZCBhbmQgbm9uemVyby4gVGhpcyBtYWtlcyB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIGVuY3J5cHRpb24gYmxvY2sgRUIgZXF1YWwgdG8gay4gKi9cblxuICAvLyBidWlsZCB0aGUgZW5jcnlwdGlvbiBibG9ja1xuICBlYi5wdXRCeXRlKDB4MDApO1xuICBlYi5wdXRCeXRlKGJ0KTtcblxuICAvLyBjcmVhdGUgdGhlIHBhZGRpbmdcbiAgdmFyIHBhZE51bSA9IGsgLSAzIC0gbS5sZW5ndGg7XG4gIHZhciBwYWRCeXRlO1xuICAvLyBwcml2YXRlIGtleSBvcFxuICBpZihidCA9PT0gMHgwMCB8fCBidCA9PT0gMHgwMSkge1xuICAgIHBhZEJ5dGUgPSAoYnQgPT09IDB4MDApID8gMHgwMCA6IDB4RkY7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHBhZE51bTsgKytpKSB7XG4gICAgICBlYi5wdXRCeXRlKHBhZEJ5dGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBwdWJsaWMga2V5IG9wXG4gICAgLy8gcGFkIHdpdGggcmFuZG9tIG5vbi16ZXJvIHZhbHVlc1xuICAgIHdoaWxlKHBhZE51bSA+IDApIHtcbiAgICAgIHZhciBudW1aZXJvcyA9IDA7XG4gICAgICB2YXIgcGFkQnl0ZXMgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMocGFkTnVtKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYWROdW07ICsraSkge1xuICAgICAgICBwYWRCeXRlID0gcGFkQnl0ZXMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYocGFkQnl0ZSA9PT0gMCkge1xuICAgICAgICAgICsrbnVtWmVyb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWIucHV0Qnl0ZShwYWRCeXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFkTnVtID0gbnVtWmVyb3M7XG4gICAgfVxuICB9XG5cbiAgLy8gemVybyBmb2xsb3dlZCBieSBtZXNzYWdlXG4gIGViLnB1dEJ5dGUoMHgwMCk7XG4gIGViLnB1dEJ5dGVzKG0pO1xuXG4gIHJldHVybiBlYjtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSB1c2luZyBQS0NTIzEgdjEuNSBwYWRkaW5nLlxuICpcbiAqIEBwYXJhbSBlbSB0aGUgbWVzc2FnZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBwdWIgdHJ1ZSBpZiB0aGUga2V5IGlzIGEgcHVibGljIGtleSwgZmFsc2UgaWYgaXQgaXMgcHJpdmF0ZS5cbiAqIEBwYXJhbSBtbCB0aGUgbWVzc2FnZSBsZW5ndGgsIGlmIHNwZWNpZmllZC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWNvZGVkIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBfZGVjb2RlUGtjczFfdjFfNShlbSwga2V5LCBwdWIsIG1sKSB7XG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgLyogSXQgaXMgYW4gZXJyb3IgaWYgYW55IG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBvY2N1cnM6XG5cbiAgICAxLiBUaGUgZW5jcnlwdGlvbiBibG9jayBFQiBjYW5ub3QgYmUgcGFyc2VkIHVuYW1iaWd1b3VzbHkuXG4gICAgMi4gVGhlIHBhZGRpbmcgc3RyaW5nIFBTIGNvbnNpc3RzIG9mIGZld2VyIHRoYW4gZWlnaHQgb2N0ZXRzXG4gICAgICBvciBpcyBpbmNvbnNpc2VudCB3aXRoIHRoZSBibG9jayB0eXBlIEJULlxuICAgIDMuIFRoZSBkZWNyeXB0aW9uIHByb2Nlc3MgaXMgYSBwdWJsaWMta2V5IG9wZXJhdGlvbiBhbmQgdGhlIGJsb2NrXG4gICAgICB0eXBlIEJUIGlzIG5vdCAwMCBvciAwMSwgb3IgdGhlIGRlY3J5cHRpb24gcHJvY2VzcyBpcyBhXG4gICAgICBwcml2YXRlLWtleSBvcGVyYXRpb24gYW5kIHRoZSBibG9jayB0eXBlIGlzIG5vdCAwMi5cbiAgICovXG5cbiAgLy8gcGFyc2UgdGhlIGVuY3J5cHRpb24gYmxvY2tcbiAgdmFyIGViID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoZW0pO1xuICB2YXIgZmlyc3QgPSBlYi5nZXRCeXRlKCk7XG4gIHZhciBidCA9IGViLmdldEJ5dGUoKTtcbiAgaWYoZmlyc3QgIT09IDB4MDAgfHxcbiAgICAocHViICYmIGJ0ICE9PSAweDAwICYmIGJ0ICE9PSAweDAxKSB8fFxuICAgICghcHViICYmIGJ0ICE9IDB4MDIpIHx8XG4gICAgKHB1YiAmJiBidCA9PT0gMHgwMCAmJiB0eXBlb2YobWwpID09PSAndW5kZWZpbmVkJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gYmxvY2sgaXMgaW52YWxpZC4nKTtcbiAgfVxuXG4gIHZhciBwYWROdW0gPSAwO1xuICBpZihidCA9PT0gMHgwMCkge1xuICAgIC8vIGNoZWNrIGFsbCBwYWRkaW5nIGJ5dGVzIGZvciAweDAwXG4gICAgcGFkTnVtID0gayAtIDMgLSBtbDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFkTnVtOyArK2kpIHtcbiAgICAgIGlmKGViLmdldEJ5dGUoKSAhPT0gMHgwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gYmxvY2sgaXMgaW52YWxpZC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZihidCA9PT0gMHgwMSkge1xuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGJ5dGUgdGhhdCBpc24ndCAweEZGLCBzaG91bGQgYmUgYWZ0ZXIgYWxsIHBhZGRpbmdcbiAgICBwYWROdW0gPSAwO1xuICAgIHdoaWxlKGViLmxlbmd0aCgpID4gMSkge1xuICAgICAgaWYoZWIuZ2V0Qnl0ZSgpICE9PSAweEZGKSB7XG4gICAgICAgIC0tZWIucmVhZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICArK3BhZE51bTtcbiAgICB9XG4gIH0gZWxzZSBpZihidCA9PT0gMHgwMikge1xuICAgIC8vIGxvb2sgZm9yIDB4MDAgYnl0ZVxuICAgIHBhZE51bSA9IDA7XG4gICAgd2hpbGUoZWIubGVuZ3RoKCkgPiAxKSB7XG4gICAgICBpZihlYi5nZXRCeXRlKCkgPT09IDB4MDApIHtcbiAgICAgICAgLS1lYi5yZWFkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgICsrcGFkTnVtO1xuICAgIH1cbiAgfVxuXG4gIC8vIHplcm8gbXVzdCBiZSAweDAwIGFuZCBwYWROdW0gbXVzdCBiZSAoayAtIDMgLSBtZXNzYWdlIGxlbmd0aClcbiAgdmFyIHplcm8gPSBlYi5nZXRCeXRlKCk7XG4gIGlmKHplcm8gIT09IDB4MDAgfHwgcGFkTnVtICE9PSAoayAtIDMgLSBlYi5sZW5ndGgoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gYmxvY2sgaXMgaW52YWxpZC4nKTtcbiAgfVxuXG4gIHJldHVybiBlYi5nZXRCeXRlcygpO1xufVxuXG4vKipcbiAqIFJ1bnMgdGhlIGtleS1nZW5lcmF0aW9uIGFsZ29yaXRobSBhc3luY2hyb25vdXNseSwgZWl0aGVyIGluIHRoZSBiYWNrZ3JvdW5kXG4gKiB2aWEgV2ViIFdvcmtlcnMsIG9yIHVzaW5nIHRoZSBtYWluIHRocmVhZCBhbmQgc2V0SW1tZWRpYXRlLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSB0aGUga2V5LXBhaXIgZ2VuZXJhdGlvbiBzdGF0ZS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gb3B0aW9ucyBmb3Iga2V5LXBhaXIgZ2VuZXJhdGlvbjpcbiAqICAgICAgICAgIHdvcmtlclNjcmlwdCB0aGUgd29ya2VyIHNjcmlwdCBVUkwuXG4gKiAgICAgICAgICB3b3JrZXJzIHRoZSBudW1iZXIgb2Ygd2ViIHdvcmtlcnMgKGlmIHN1cHBvcnRlZCkgdG8gdXNlLFxuICogICAgICAgICAgICAoZGVmYXVsdDogMiwgLTEgdG8gdXNlIGVzdGltYXRlZCBjb3JlcyBtaW51cyBvbmUpLlxuICogICAgICAgICAgd29ya0xvYWQgdGhlIHNpemUgb2YgdGhlIHdvcmsgbG9hZCwgaWU6IG51bWJlciBvZiBwb3NzaWJsZSBwcmltZVxuICogICAgICAgICAgICBudW1iZXJzIGZvciBlYWNoIHdlYiB3b3JrZXIgdG8gY2hlY2sgcGVyIHdvcmsgYXNzaWdubWVudCxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiBAcGFyYW0gY2FsbGJhY2soZXJyLCBrZXlwYWlyKSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAqL1xuZnVuY3Rpb24gX2dlbmVyYXRlS2V5UGFpcihzdGF0ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBvcHRzID0ge1xuICAgIGFsZ29yaXRobToge1xuICAgICAgbmFtZTogb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgd29ya2Vyczogb3B0aW9ucy53b3JrZXJzIHx8IDIsXG4gICAgICAgIHdvcmtMb2FkOiBvcHRpb25zLndvcmtMb2FkIHx8IDEwMCxcbiAgICAgICAgd29ya2VyU2NyaXB0OiBvcHRpb25zLndvcmtlclNjcmlwdFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgaWYoJ3BybmcnIGluIG9wdGlvbnMpIHtcbiAgICBvcHRzLnBybmcgPSBvcHRpb25zLnBybmc7XG4gIH1cblxuICBnZW5lcmF0ZSgpO1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuICAgIC8vIGZpbmQgcCBhbmQgdGhlbiBxIChkb25lIGluIHNlcmllcyB0byBzaW1wbGlmeSlcbiAgICBnZXRQcmltZShzdGF0ZS5wQml0cywgZnVuY3Rpb24oZXJyLCBudW0pIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnAgPSBudW07XG4gICAgICBpZihzdGF0ZS5xICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmaW5pc2goZXJyLCBzdGF0ZS5xKTtcbiAgICAgIH1cbiAgICAgIGdldFByaW1lKHN0YXRlLnFCaXRzLCBmaW5pc2gpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJpbWUoYml0cywgY2FsbGJhY2spIHtcbiAgICBmb3JnZS5wcmltZS5nZW5lcmF0ZVByb2JhYmxlUHJpbWUoYml0cywgb3B0cywgY2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoKGVyciwgbnVtKSB7XG4gICAgaWYoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgcVxuICAgIHN0YXRlLnEgPSBudW07XG5cbiAgICAvLyBlbnN1cmUgcCBpcyBsYXJnZXIgdGhhbiBxIChzd2FwIHRoZW0gaWYgbm90KVxuICAgIGlmKHN0YXRlLnAuY29tcGFyZVRvKHN0YXRlLnEpIDwgMCkge1xuICAgICAgdmFyIHRtcCA9IHN0YXRlLnA7XG4gICAgICBzdGF0ZS5wID0gc3RhdGUucTtcbiAgICAgIHN0YXRlLnEgPSB0bXA7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHAgaXMgY29wcmltZSB3aXRoIGVcbiAgICBpZihzdGF0ZS5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2Qoc3RhdGUuZSlcbiAgICAgIC5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9PSAwKSB7XG4gICAgICBzdGF0ZS5wID0gbnVsbDtcbiAgICAgIGdlbmVyYXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHEgaXMgY29wcmltZSB3aXRoIGVcbiAgICBpZihzdGF0ZS5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2Qoc3RhdGUuZSlcbiAgICAgIC5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9PSAwKSB7XG4gICAgICBzdGF0ZS5xID0gbnVsbDtcbiAgICAgIGdldFByaW1lKHN0YXRlLnFCaXRzLCBmaW5pc2gpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgcGhpOiAocCAtIDEpKHEgLSAxKSAoRXVsZXIncyB0b3RpZW50IGZ1bmN0aW9uKVxuICAgIHN0YXRlLnAxID0gc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgc3RhdGUucTEgPSBzdGF0ZS5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICBzdGF0ZS5waGkgPSBzdGF0ZS5wMS5tdWx0aXBseShzdGF0ZS5xMSk7XG5cbiAgICAvLyBlbnN1cmUgZSBhbmQgcGhpIGFyZSBjb3ByaW1lXG4gICAgaWYoc3RhdGUucGhpLmdjZChzdGF0ZS5lKS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9PSAwKSB7XG4gICAgICAvLyBwaGkgYW5kIGUgYXJlbid0IGNvcHJpbWUsIHNvIGdlbmVyYXRlIGEgbmV3IHAgYW5kIHFcbiAgICAgIHN0YXRlLnAgPSBzdGF0ZS5xID0gbnVsbDtcbiAgICAgIGdlbmVyYXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIG4sIGVuc3VyZSBuIGlzIGhhcyB0aGUgcmlnaHQgbnVtYmVyIG9mIGJpdHNcbiAgICBzdGF0ZS5uID0gc3RhdGUucC5tdWx0aXBseShzdGF0ZS5xKTtcbiAgICBpZihzdGF0ZS5uLmJpdExlbmd0aCgpICE9PSBzdGF0ZS5iaXRzKSB7XG4gICAgICAvLyBmYWlsZWQsIGdldCBuZXcgcVxuICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICBnZXRQcmltZShzdGF0ZS5xQml0cywgZmluaXNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQga2V5c1xuICAgIHZhciBkID0gc3RhdGUuZS5tb2RJbnZlcnNlKHN0YXRlLnBoaSk7XG4gICAgc3RhdGUua2V5cyA9IHtcbiAgICAgIHByaXZhdGVLZXk6IHBraS5yc2Euc2V0UHJpdmF0ZUtleShcbiAgICAgICAgc3RhdGUubiwgc3RhdGUuZSwgZCwgc3RhdGUucCwgc3RhdGUucSxcbiAgICAgICAgZC5tb2Qoc3RhdGUucDEpLCBkLm1vZChzdGF0ZS5xMSksXG4gICAgICAgIHN0YXRlLnEubW9kSW52ZXJzZShzdGF0ZS5wKSksXG4gICAgICBwdWJsaWNLZXk6IHBraS5yc2Euc2V0UHVibGljS2V5KHN0YXRlLm4sIHN0YXRlLmUpXG4gICAgfTtcblxuICAgIGNhbGxiYWNrKG51bGwsIHN0YXRlLmtleXMpO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBwb3NpdGl2ZSBCaWdJbnRlZ2VyIGludG8gMidzLWNvbXBsZW1lbnQgYmlnLWVuZGlhbiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gYiB0aGUgYmlnIGludGVnZXIgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlcy5cbiAqL1xuZnVuY3Rpb24gX2JuVG9CeXRlcyhiKSB7XG4gIC8vIHByZXBlbmQgMHgwMCBpZiBmaXJzdCBieXRlID49IDB4ODBcbiAgdmFyIGhleCA9IGIudG9TdHJpbmcoMTYpO1xuICBpZihoZXhbMF0gPj0gJzgnKSB7XG4gICAgaGV4ID0gJzAwJyArIGhleDtcbiAgfVxuICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmhleFRvQnl0ZXMoaGV4KTtcblxuICAvLyBlbnN1cmUgaW50ZWdlciBpcyBtaW5pbWFsbHktZW5jb2RlZFxuICBpZihieXRlcy5sZW5ndGggPiAxICYmXG4gICAgLy8gbGVhZGluZyAweDAwIGZvciBwb3NpdGl2ZSBpbnRlZ2VyXG4gICAgKChieXRlcy5jaGFyQ29kZUF0KDApID09PSAwICYmXG4gICAgKGJ5dGVzLmNoYXJDb2RlQXQoMSkgJiAweDgwKSA9PT0gMCkgfHxcbiAgICAvLyBsZWFkaW5nIDB4RkYgZm9yIG5lZ2F0aXZlIGludGVnZXJcbiAgICAoYnl0ZXMuY2hhckNvZGVBdCgwKSA9PT0gMHhGRiAmJlxuICAgIChieXRlcy5jaGFyQ29kZUF0KDEpICYgMHg4MCkgPT09IDB4ODApKSkge1xuICAgIHJldHVybiBieXRlcy5zdWJzdHIoMSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlcXVpcmVkIG51bWJlciBvZiBNaWxsZXItUmFiaW4gdGVzdHMgdG8gZ2VuZXJhdGUgYVxuICogcHJpbWUgd2l0aCBhbiBlcnJvciBwcm9iYWJpbGl0eSBvZiAoMS8yKV44MC5cbiAqXG4gKiBTZWUgSGFuZGJvb2sgb2YgQXBwbGllZCBDcnlwdG9ncmFwaHkgQ2hhcHRlciA0LCBUYWJsZSA0LjQuXG4gKlxuICogQHBhcmFtIGJpdHMgdGhlIGJpdCBzaXplLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBpdGVyYXRpb25zLlxuICovXG5mdW5jdGlvbiBfZ2V0TWlsbGVyUmFiaW5UZXN0cyhiaXRzKSB7XG4gIGlmKGJpdHMgPD0gMTAwKSByZXR1cm4gMjc7XG4gIGlmKGJpdHMgPD0gMTUwKSByZXR1cm4gMTg7XG4gIGlmKGJpdHMgPD0gMjAwKSByZXR1cm4gMTU7XG4gIGlmKGJpdHMgPD0gMjUwKSByZXR1cm4gMTI7XG4gIGlmKGJpdHMgPD0gMzAwKSByZXR1cm4gOTtcbiAgaWYoYml0cyA8PSAzNTApIHJldHVybiA4O1xuICBpZihiaXRzIDw9IDQwMCkgcmV0dXJuIDc7XG4gIGlmKGJpdHMgPD0gNTAwKSByZXR1cm4gNjtcbiAgaWYoYml0cyA8PSA2MDApIHJldHVybiA1O1xuICBpZihiaXRzIDw9IDgwMCkgcmV0dXJuIDQ7XG4gIGlmKGJpdHMgPD0gMTI1MCkgcmV0dXJuIDM7XG4gIHJldHVybiAyO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGZlYXR1cmUgZGV0ZWN0aW9uIG9uIHRoZSBOb2RlIGNyeXB0byBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGZuIHRoZSBmZWF0dXJlIChmdW5jdGlvbikgdG8gZGV0ZWN0LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBkZXRlY3RlZCwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfZGV0ZWN0Tm9kZUNyeXB0byhmbikge1xuICByZXR1cm4gZm9yZ2UudXRpbC5pc05vZGVqcyAmJiB0eXBlb2YgX2NyeXB0b1tmbl0gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZmVhdHVyZSBkZXRlY3Rpb24gb24gdGhlIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGZuIHRoZSBmZWF0dXJlIChmdW5jdGlvbikgdG8gZGV0ZWN0LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBkZXRlY3RlZCwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfZGV0ZWN0U3VidGxlQ3J5cHRvKGZuKSB7XG4gIHJldHVybiAodHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUuY3J5cHRvID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlLmNyeXB0by5zdWJ0bGUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUuY3J5cHRvLnN1YnRsZVtmbl0gPT09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGZlYXR1cmUgZGV0ZWN0aW9uIG9uIHRoZSBkZXByZWNhdGVkIE1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlclxuICogb3V0ZGF0ZWQgU3VidGxlQ3J5cHRvIGludGVyZmFjZS4gVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSB1c2VkIGFmdGVyXG4gKiBjaGVja2luZyBmb3IgdGhlIG1vZGVybiwgc3RhbmRhcmQgU3VidGxlQ3J5cHRvIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gZm4gdGhlIGZlYXR1cmUgKGZ1bmN0aW9uKSB0byBkZXRlY3QuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIGRldGVjdGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIF9kZXRlY3RTdWJ0bGVNc0NyeXB0byhmbikge1xuICByZXR1cm4gKHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlLm1zQ3J5cHRvID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlLm1zQ3J5cHRvLnN1YnRsZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdXRpbC5nbG9iYWxTY29wZS5tc0NyeXB0by5zdWJ0bGVbZm5dID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gX2ludFRvVWludDhBcnJheSh4KSB7XG4gIHZhciBieXRlcyA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyh4LnRvU3RyaW5nKDE2KSk7XG4gIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShieXRlcy5sZW5ndGgpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXJbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIF9wcml2YXRlS2V5RnJvbUp3ayhqd2spIHtcbiAgaWYoandrLmt0eSAhPT0gJ1JTQScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnVW5zdXBwb3J0ZWQga2V5IGFsZ29yaXRobSBcIicgKyBqd2sua3R5ICsgJ1wiOyBhbGdvcml0aG0gbXVzdCBiZSBcIlJTQVwiLicpO1xuICB9XG4gIHJldHVybiBwa2kuc2V0UnNhUHJpdmF0ZUtleShcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLm4pLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2suZSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kKSxcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLnApLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2sucSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kcCksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kcSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5xaSkpO1xufVxuXG5mdW5jdGlvbiBfcHVibGljS2V5RnJvbUp3ayhqd2spIHtcbiAgaWYoandrLmt0eSAhPT0gJ1JTQScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBhbGdvcml0aG0gbXVzdCBiZSBcIlJTQVwiLicpO1xuICB9XG4gIHJldHVybiBwa2kuc2V0UnNhUHVibGljS2V5KFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2subiksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5lKSk7XG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRUb0JpZ0ludChiNjQpIHtcbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGZvcmdlLnV0aWwuYnl0ZXNUb0hleChmb3JnZS51dGlsLmRlY29kZTY0KGI2NCkpLCAxNik7XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbXVsdGloYXNoaW5nID0gcmVxdWlyZSgnbXVsdGloYXNoaW5nLWFzeW5jJylcbmNvbnN0IHByb3RvYnVmID0gcmVxdWlyZSgncHJvdG9ucycpXG5jb25zdCBiczU4ID0gcmVxdWlyZSgnYnM1OCcpXG5jb25zdCBuZXh0VGljayA9IHJlcXVpcmUoJ2FzeW5jL25leHRUaWNrJylcblxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnLi9yc2EnKVxuY29uc3QgcGJtID0gcHJvdG9idWYocmVxdWlyZSgnLi9rZXlzLnByb3RvJykpXG5yZXF1aXJlKCdub2RlLWZvcmdlL2xpYi9zaGE1MTInKVxucmVxdWlyZSgnbm9kZS1mb3JnZS9saWIvcGJlJylcbmNvbnN0IGZvcmdlID0gcmVxdWlyZSgnbm9kZS1mb3JnZS9saWIvZm9yZ2UnKVxuXG5jbGFzcyBSc2FQdWJsaWNLZXkge1xuICBjb25zdHJ1Y3RvciAoa2V5KSB7XG4gICAgdGhpcy5fa2V5ID0ga2V5XG4gIH1cblxuICB2ZXJpZnkgKGRhdGEsIHNpZywgY2FsbGJhY2spIHtcbiAgICBlbnN1cmUoY2FsbGJhY2spXG4gICAgY3J5cHRvLmhhc2hBbmRWZXJpZnkodGhpcy5fa2V5LCBzaWcsIGRhdGEsIGNhbGxiYWNrKVxuICB9XG5cbiAgbWFyc2hhbCAoKSB7XG4gICAgcmV0dXJuIGNyeXB0by51dGlscy5qd2tUb1BraXgodGhpcy5fa2V5KVxuICB9XG5cbiAgZ2V0IGJ5dGVzICgpIHtcbiAgICByZXR1cm4gcGJtLlB1YmxpY0tleS5lbmNvZGUoe1xuICAgICAgVHlwZTogcGJtLktleVR5cGUuUlNBLFxuICAgICAgRGF0YTogdGhpcy5tYXJzaGFsKClcbiAgICB9KVxuICB9XG5cbiAgZW5jcnlwdCAoYnl0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5LmVuY3J5cHQoYnl0ZXMsICdSU0FFUy1QS0NTMS1WMV81JylcbiAgfVxuXG4gIGVxdWFscyAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZXMuZXF1YWxzKGtleS5ieXRlcylcbiAgfVxuXG4gIGhhc2ggKGNhbGxiYWNrKSB7XG4gICAgZW5zdXJlKGNhbGxiYWNrKVxuICAgIG11bHRpaGFzaGluZyh0aGlzLmJ5dGVzLCAnc2hhMi0yNTYnLCBjYWxsYmFjaylcbiAgfVxufVxuXG5jbGFzcyBSc2FQcml2YXRlS2V5IHtcbiAgLy8ga2V5ICAgICAgIC0gT2JqZWN0IG9mIHRoZSBqd2sgZm9ybWF0XG4gIC8vIHB1YmxpY0tleSAtIEJ1ZmZlciBvZiB0aGUgc3BraSBmb3JtYXRcbiAgY29uc3RydWN0b3IgKGtleSwgcHVibGljS2V5KSB7XG4gICAgdGhpcy5fa2V5ID0ga2V5XG4gICAgdGhpcy5fcHVibGljS2V5ID0gcHVibGljS2V5XG4gIH1cblxuICBnZW5TZWNyZXQgKCkge1xuICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKDE2KVxuICB9XG5cbiAgc2lnbiAobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBlbnN1cmUoY2FsbGJhY2spXG4gICAgY3J5cHRvLmhhc2hBbmRTaWduKHRoaXMuX2tleSwgbWVzc2FnZSwgY2FsbGJhY2spXG4gIH1cblxuICBnZXQgcHVibGljICgpIHtcbiAgICBpZiAoIXRoaXMuX3B1YmxpY0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdWJsaWMga2V5IG5vdCBwcm92aWRlZCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSc2FQdWJsaWNLZXkodGhpcy5fcHVibGljS2V5KVxuICB9XG5cbiAgZGVjcnlwdCAobXNnLCBjYWxsYmFjaykge1xuICAgIGNyeXB0by5kZWNyeXB0KHRoaXMuX2tleSwgbXNnLCBjYWxsYmFjaylcbiAgfVxuXG4gIG1hcnNoYWwgKCkge1xuICAgIHJldHVybiBjcnlwdG8udXRpbHMuandrVG9Qa2NzMSh0aGlzLl9rZXkpXG4gIH1cblxuICBnZXQgYnl0ZXMgKCkge1xuICAgIHJldHVybiBwYm0uUHJpdmF0ZUtleS5lbmNvZGUoe1xuICAgICAgVHlwZTogcGJtLktleVR5cGUuUlNBLFxuICAgICAgRGF0YTogdGhpcy5tYXJzaGFsKClcbiAgICB9KVxuICB9XG5cbiAgZXF1YWxzIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlcy5lcXVhbHMoa2V5LmJ5dGVzKVxuICB9XG5cbiAgaGFzaCAoY2FsbGJhY2spIHtcbiAgICBlbnN1cmUoY2FsbGJhY2spXG4gICAgbXVsdGloYXNoaW5nKHRoaXMuYnl0ZXMsICdzaGEyLTI1NicsIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIElEIG9mIHRoZSBrZXkuXG4gICAqXG4gICAqIFRoZSBrZXkgaWQgaXMgdGhlIGJhc2U1OCBlbmNvZGluZyBvZiB0aGUgU0hBLTI1NiBtdWx0aWhhc2ggb2YgaXRzIHB1YmxpYyBrZXkuXG4gICAqIFRoZSBwdWJsaWMga2V5IGlzIGEgcHJvdG9idWYgZW5jb2RpbmcgY29udGFpbmluZyBhIHR5cGUgYW5kIHRoZSBERVIgZW5jb2RpbmdcbiAgICogb2YgdGhlIFBLQ1MgU3ViamVjdFB1YmxpY0tleUluZm8uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIGlkKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGlkIChjYWxsYmFjaykge1xuICAgIHRoaXMucHVibGljLmhhc2goKGVyciwgaGFzaCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgYnM1OC5lbmNvZGUoaGFzaCkpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnRzIHRoZSBrZXkgaW50byBhIHBhc3N3b3JkIHByb3RlY3RlZCBQRU0gZm9ybWF0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZm9ybWF0XSAtIERlZmF1bHRzIHRvICdwa2NzLTgnLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBUaGUgcGFzc3dvcmQgdG8gcmVhZCB0aGUgZW5jcnlwdGVkIFBFTVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBLZXlJbmZvKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGV4cG9ydCAoZm9ybWF0LCBwYXNzd29yZCwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IHBhc3N3b3JkXG4gICAgICBwYXNzd29yZCA9IGZvcm1hdFxuICAgICAgZm9ybWF0ID0gJ3BrY3MtOCdcbiAgICB9XG5cbiAgICBlbnN1cmUoY2FsbGJhY2spXG5cbiAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgZXJyID0gbnVsbFxuICAgICAgbGV0IHBlbSA9IG51bGxcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIodGhpcy5tYXJzaGFsKCkpXG4gICAgICAgIGNvbnN0IGFzbjEgPSBmb3JnZS5hc24xLmZyb21EZXIoYnVmZmVyKVxuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gZm9yZ2UucGtpLnByaXZhdGVLZXlGcm9tQXNuMShhc24xKVxuICAgICAgICBpZiAoZm9ybWF0ID09PSAncGtjcy04Jykge1xuICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhbGdvcml0aG06ICdhZXMyNTYnLFxuICAgICAgICAgICAgY291bnQ6IDEwMDAwLFxuICAgICAgICAgICAgc2FsdFNpemU6IDEyOCAvIDgsXG4gICAgICAgICAgICBwcmZBbGdvcml0aG06ICdzaGE1MTInXG4gICAgICAgICAgfVxuICAgICAgICAgIHBlbSA9IGZvcmdlLnBraS5lbmNyeXB0UnNhUHJpdmF0ZUtleShwcml2YXRlS2V5LCBwYXNzd29yZCwgb3B0aW9ucylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoYFVua25vd24gZXhwb3J0IGZvcm1hdCAnJHtmb3JtYXR9J2ApXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgZXJyID0gX2VyclxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhlcnIsIHBlbSlcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHVubWFyc2hhbFJzYVByaXZhdGVLZXkgKGJ5dGVzLCBjYWxsYmFjaykge1xuICBjb25zdCBqd2sgPSBjcnlwdG8udXRpbHMucGtjczFUb0p3ayhieXRlcylcblxuICBjcnlwdG8udW5tYXJzaGFsUHJpdmF0ZUtleShqd2ssIChlcnIsIGtleXMpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIG5ldyBSc2FQcml2YXRlS2V5KGtleXMucHJpdmF0ZUtleSwga2V5cy5wdWJsaWNLZXkpKVxuICB9KVxufVxuXG5mdW5jdGlvbiB1bm1hcnNoYWxSc2FQdWJsaWNLZXkgKGJ5dGVzKSB7XG4gIGNvbnN0IGp3ayA9IGNyeXB0by51dGlscy5wa2l4VG9Kd2soYnl0ZXMpXG5cbiAgcmV0dXJuIG5ldyBSc2FQdWJsaWNLZXkoandrKVxufVxuXG5mdW5jdGlvbiBmcm9tSndrIChqd2ssIGNhbGxiYWNrKSB7XG4gIGNyeXB0by51bm1hcnNoYWxQcml2YXRlS2V5KGp3aywgKGVyciwga2V5cykgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgbmV3IFJzYVByaXZhdGVLZXkoa2V5cy5wcml2YXRlS2V5LCBrZXlzLnB1YmxpY0tleSkpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5UGFpciAoYml0cywgY2FsbGJhY2spIHtcbiAgY3J5cHRvLmdlbmVyYXRlS2V5KGJpdHMsIChlcnIsIGtleXMpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIG5ldyBSc2FQcml2YXRlS2V5KGtleXMucHJpdmF0ZUtleSwga2V5cy5wdWJsaWNLZXkpKVxuICB9KVxufVxuXG5mdW5jdGlvbiBlbnN1cmUgKGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIGlzIHJlcXVpcmVkJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUnNhUHVibGljS2V5LFxuICBSc2FQcml2YXRlS2V5LFxuICB1bm1hcnNoYWxSc2FQdWJsaWNLZXksXG4gIHVubWFyc2hhbFJzYVByaXZhdGVLZXksXG4gIGdlbmVyYXRlS2V5UGFpcixcbiAgZnJvbUp3a1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBzY2hlbWEgPSByZXF1aXJlKCdwcm90b2NvbC1idWZmZXJzLXNjaGVtYScpXG52YXIgY29tcGlsZSA9IHJlcXVpcmUoJy4vY29tcGlsZScpXG5cbnZhciBmbGF0dGVuID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICBpZiAoIXZhbHVlcykgcmV0dXJuIG51bGxcbiAgdmFyIHJlc3VsdCA9IHt9XG4gIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHJlc3VsdFtrXSA9IHZhbHVlc1trXS52YWx1ZVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHByb3RvLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIGlmICghcHJvdG8pIHRocm93IG5ldyBFcnJvcignUGFzcyBpbiBhIC5wcm90byBzdHJpbmcgb3IgYSBwcm90b2J1Zi1zY2hlbWEgcGFyc2VkIG9iamVjdCcpXG5cbiAgdmFyIHNjaCA9ICh0eXBlb2YgcHJvdG8gPT09ICdvYmplY3QnICYmICFCdWZmZXIuaXNCdWZmZXIocHJvdG8pKSA/IHByb3RvIDogc2NoZW1hLnBhcnNlKHByb3RvKVxuXG4gIC8vIHRvIG5vdCBtYWtlIHRvU3RyaW5nLHRvSlNPTiBlbnVtYXJhYmxlIHdlIG1ha2UgYSBmaXJlLWFuZC1mb3JnZXQgcHJvdG90eXBlXG4gIHZhciBNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcblxuICAgIGNvbXBpbGUoc2NoLCBvcHRzLmVuY29kaW5ncyB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgc2VsZlttLm5hbWVdID0gZmxhdHRlbihtLnZhbHVlcykgfHwgbVxuICAgIH0pXG4gIH1cblxuICBNZXNzYWdlcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5zdHJpbmdpZnkoc2NoKVxuICB9XG5cbiAgTWVzc2FnZXMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2NoXG4gIH1cblxuICByZXR1cm4gbmV3IE1lc3NhZ2VzKClcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBlY2RoID0gcmVxdWlyZSgnLi9lY2RoJylcblxuLy8gR2VuZXJhdGVzIGFuIGVwaGVtZXJhbCBwdWJsaWMga2V5IGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNvbXB1dGVcbi8vIHRoZSBzaGFyZWQgc2VjcmV0IGtleS5cbi8vXG4vLyBGb2N1c2VzIG9ubHkgb24gRUNESCBub3csIGJ1dCBjYW4gYmUgbWFkZSBtb3JlIGdlbmVyYWwgaW4gdGhlIGZ1dHVyZS5cbm1vZHVsZS5leHBvcnRzID0gKGN1cnZlLCBjYWxsYmFjaykgPT4ge1xuICBlY2RoLmdlbmVyYXRlRXBobWVyYWxLZXlQYWlyKGN1cnZlLCBjYWxsYmFjaylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiczU4ID0gcmVxdWlyZSgnYnM1OCcpXG5jb25zdCBtdWx0aWhhc2hpbmcgPSByZXF1aXJlKCdtdWx0aWhhc2hpbmctYXN5bmMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChrZXlzUHJvdG9idWYsIHJhbmRvbUJ5dGVzLCBjcnlwdG8pID0+IHtcbiAgY3J5cHRvID0gY3J5cHRvIHx8IHJlcXVpcmUoJy4vY3J5cHRvJykocmFuZG9tQnl0ZXMpXG5cbiAgY2xhc3MgU2VjcDI1NmsxUHVibGljS2V5IHtcbiAgICBjb25zdHJ1Y3RvciAoa2V5KSB7XG4gICAgICBjcnlwdG8udmFsaWRhdGVQdWJsaWNLZXkoa2V5KVxuICAgICAgdGhpcy5fa2V5ID0ga2V5XG4gICAgfVxuXG4gICAgdmVyaWZ5IChkYXRhLCBzaWcsIGNhbGxiYWNrKSB7XG4gICAgICBlbnN1cmUoY2FsbGJhY2spXG4gICAgICBjcnlwdG8uaGFzaEFuZFZlcmlmeSh0aGlzLl9rZXksIHNpZywgZGF0YSwgY2FsbGJhY2spXG4gICAgfVxuXG4gICAgbWFyc2hhbCAoKSB7XG4gICAgICByZXR1cm4gY3J5cHRvLmNvbXByZXNzUHVibGljS2V5KHRoaXMuX2tleSlcbiAgICB9XG5cbiAgICBnZXQgYnl0ZXMgKCkge1xuICAgICAgcmV0dXJuIGtleXNQcm90b2J1Zi5QdWJsaWNLZXkuZW5jb2RlKHtcbiAgICAgICAgVHlwZToga2V5c1Byb3RvYnVmLktleVR5cGUuU2VjcDI1NmsxLFxuICAgICAgICBEYXRhOiB0aGlzLm1hcnNoYWwoKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBlcXVhbHMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuZXF1YWxzKGtleS5ieXRlcylcbiAgICB9XG5cbiAgICBoYXNoIChjYWxsYmFjaykge1xuICAgICAgZW5zdXJlKGNhbGxiYWNrKVxuICAgICAgbXVsdGloYXNoaW5nKHRoaXMuYnl0ZXMsICdzaGEyLTI1NicsIGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIGNsYXNzIFNlY3AyNTZrMVByaXZhdGVLZXkge1xuICAgIGNvbnN0cnVjdG9yIChrZXksIHB1YmxpY0tleSkge1xuICAgICAgdGhpcy5fa2V5ID0ga2V5XG4gICAgICB0aGlzLl9wdWJsaWNLZXkgPSBwdWJsaWNLZXkgfHwgY3J5cHRvLmNvbXB1dGVQdWJsaWNLZXkoa2V5KVxuICAgICAgY3J5cHRvLnZhbGlkYXRlUHJpdmF0ZUtleSh0aGlzLl9rZXkpXG4gICAgICBjcnlwdG8udmFsaWRhdGVQdWJsaWNLZXkodGhpcy5fcHVibGljS2V5KVxuICAgIH1cblxuICAgIHNpZ24gKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgICBlbnN1cmUoY2FsbGJhY2spXG4gICAgICBjcnlwdG8uaGFzaEFuZFNpZ24odGhpcy5fa2V5LCBtZXNzYWdlLCBjYWxsYmFjaylcbiAgICB9XG5cbiAgICBnZXQgcHVibGljICgpIHtcbiAgICAgIHJldHVybiBuZXcgU2VjcDI1NmsxUHVibGljS2V5KHRoaXMuX3B1YmxpY0tleSlcbiAgICB9XG5cbiAgICBtYXJzaGFsICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9rZXlcbiAgICB9XG5cbiAgICBnZXQgYnl0ZXMgKCkge1xuICAgICAgcmV0dXJuIGtleXNQcm90b2J1Zi5Qcml2YXRlS2V5LmVuY29kZSh7XG4gICAgICAgIFR5cGU6IGtleXNQcm90b2J1Zi5LZXlUeXBlLlNlY3AyNTZrMSxcbiAgICAgICAgRGF0YTogdGhpcy5tYXJzaGFsKClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZXF1YWxzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmVxdWFscyhrZXkuYnl0ZXMpXG4gICAgfVxuXG4gICAgaGFzaCAoY2FsbGJhY2spIHtcbiAgICAgIGVuc3VyZShjYWxsYmFjaylcbiAgICAgIG11bHRpaGFzaGluZyh0aGlzLmJ5dGVzLCAnc2hhMi0yNTYnLCBjYWxsYmFjaylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBJRCBvZiB0aGUga2V5LlxuICAgICAqXG4gICAgICogVGhlIGtleSBpZCBpcyB0aGUgYmFzZTU4IGVuY29kaW5nIG9mIHRoZSBTSEEtMjU2IG11bHRpaGFzaCBvZiBpdHMgcHVibGljIGtleS5cbiAgICAgKiBUaGUgcHVibGljIGtleSBpcyBhIHByb3RvYnVmIGVuY29kaW5nIGNvbnRhaW5pbmcgYSB0eXBlIGFuZCB0aGUgREVSIGVuY29kaW5nXG4gICAgICogb2YgdGhlIFBLQ1MgU3ViamVjdFB1YmxpY0tleUluZm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBpZCl9IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBpZCAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMucHVibGljLmhhc2goKGVyciwgaGFzaCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCBiczU4LmVuY29kZShoYXNoKSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdW5tYXJzaGFsU2VjcDI1NmsxUHJpdmF0ZUtleSAoYnl0ZXMsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgbmV3IFNlY3AyNTZrMVByaXZhdGVLZXkoYnl0ZXMpKVxuICB9XG5cbiAgZnVuY3Rpb24gdW5tYXJzaGFsU2VjcDI1NmsxUHVibGljS2V5IChieXRlcykge1xuICAgIHJldHVybiBuZXcgU2VjcDI1NmsxUHVibGljS2V5KGJ5dGVzKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVLZXlQYWlyIChfYml0cywgY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgX2JpdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gX2JpdHNcbiAgICB9XG5cbiAgICBlbnN1cmUoY2FsbGJhY2spXG5cbiAgICBjcnlwdG8uZ2VuZXJhdGVLZXkoKGVyciwgcHJpdmF0ZUtleUJ5dGVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpIH1cblxuICAgICAgbGV0IHByaXZrZXlcbiAgICAgIHRyeSB7XG4gICAgICAgIHByaXZrZXkgPSBuZXcgU2VjcDI1NmsxUHJpdmF0ZUtleShwcml2YXRlS2V5Qnl0ZXMpXG4gICAgICB9IGNhdGNoIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycikgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBwcml2a2V5KVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmUgKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBpcyByZXF1aXJlZCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBTZWNwMjU2azFQdWJsaWNLZXksXG4gICAgU2VjcDI1NmsxUHJpdmF0ZUtleSxcbiAgICB1bm1hcnNoYWxTZWNwMjU2azFQcml2YXRlS2V5LFxuICAgIHVubWFyc2hhbFNlY3AyNTZrMVB1YmxpY0tleSxcbiAgICBnZW5lcmF0ZUtleVBhaXJcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKVxuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqXG4gKiBSZXNvbHZlcyBhIHBhdGggd2l0aGluIGEgQ0JPUiBibG9jay5cbiAqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvciBhIGxpbmsgYW5kIHRoZSBwYXJ0aWFsIG1pc2luZyBwYXRoLiBUaGlzIHdheSB0aGVcbiAqIElQTEQgUmVzb2x2ZXIgY2FuIGZldGNoIHRoZSBsaW5rIGFuZCBjb250aW51ZSB0byByZXNvbHZlLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBiaW5hcnlCbG9iIC0gQmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIGEgQ0JPUiBibG9ja1xuICogQHBhcmFtIHtzdHJpbmd9IFtwYXRoPScvJ10gLSBQYXRoIHRoYXQgc2hvdWxkIGJlIHJlc29sdmVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSByZXN1bHQgLSBSZXN1bHQgb2YgdGhlIHBhdGggaXQgaXQgd2FzIHJlc29sdmVkIHN1Y2Nlc3NmdWxseVxuICogQHJldHVybnMgeyp9IHJlc3VsdC52YWx1ZSAtIFZhbHVlIHRoZSBwYXRoIHJlc29sdmVzIHRvXG4gKiBAcmV0dXJucyB7c3RyaW5nfSByZXN1bHQucmVtYWluZGVyUGF0aCAtIElmIHRoZSBwYXRoIHJlc29sdmVzIGhhbGYtd2F5IHRvIGFcbiAqICAgbGluaywgdGhlbiB0aGUgYHJlbWFpbmRlclBhdGhgIGlzIHRoZSBwYXJ0IGFmdGVyIHRoZSBsaW5rIHRoYXQgY2FuIGJlIHVzZWRcbiAqICAgZm9yIGZ1cnRoZXIgcmVzb2x2aW5nXG4gKi9cbmV4cG9ydHMucmVzb2x2ZSA9IChiaW5hcnlCbG9iLCBwYXRoKSA9PiB7XG4gIGxldCBub2RlID0gdXRpbC5kZXNlcmlhbGl6ZShiaW5hcnlCbG9iKVxuXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpLmZpbHRlcihCb29sZWFuKVxuICB3aGlsZSAocGFydHMubGVuZ3RoKSB7XG4gICAgY29uc3Qga2V5ID0gcGFydHMuc2hpZnQoKVxuICAgIGlmIChub2RlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgaGFzIG5vIHByb3BlcnR5ICcke2tleX0nYClcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZVtrZXldXG4gICAgaWYgKENJRC5pc0NJRChub2RlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICAgIHJlbWFpbmRlclBhdGg6IHBhcnRzLmpvaW4oJy8nKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IG5vZGUsXG4gICAgcmVtYWluZGVyUGF0aDogJydcbiAgfVxufVxuXG5jb25zdCB0cmF2ZXJzZSA9IGZ1bmN0aW9uICogKG5vZGUsIHBhdGgpIHtcbiAgLy8gVHJhdmVyc2Ugb25seSBvYmplY3RzIGFuZCBhcnJheXNcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihub2RlKSB8fCBDSUQuaXNDSUQobm9kZSkgfHwgdHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8XG4gICAgICBub2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZm9yIChjb25zdCBpdGVtIG9mIE9iamVjdC5rZXlzKG5vZGUpKSB7XG4gICAgY29uc3QgbmV4dHBhdGggPSBwYXRoID09PSB1bmRlZmluZWQgPyBpdGVtIDogcGF0aCArICcvJyArIGl0ZW1cbiAgICB5aWVsZCBuZXh0cGF0aFxuICAgIHlpZWxkICogdHJhdmVyc2Uobm9kZVtpdGVtXSwgbmV4dHBhdGgpXG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gYWxsIGF2YWlsYWJsZSBwYXRocyBvZiBhIGJsb2NrLlxuICpcbiAqIEBnZW5lcmF0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfSBiaW5hcnlCbG9iIC0gQmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIGEgQ0JPUiBibG9ja1xuICogQHlpZWxkcyB7c3RyaW5nfSAtIEEgc2luZ2xlIHBhdGhcbiAqL1xuZXhwb3J0cy50cmVlID0gZnVuY3Rpb24gKiAoYmluYXJ5QmxvYikge1xuICBjb25zdCBub2RlID0gdXRpbC5kZXNlcmlhbGl6ZShiaW5hcnlCbG9iKVxuXG4gIHlpZWxkICogdHJhdmVyc2Uobm9kZSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjYm9yID0gcmVxdWlyZSgnYm9yYycpXG5jb25zdCBtdWx0aWNvZGVjID0gcmVxdWlyZSgnbXVsdGljb2RlYycpXG5jb25zdCBtdWx0aWhhc2hpbmcgPSByZXF1aXJlKCdtdWx0aWhhc2hpbmctYXN5bmMnKVxuY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpXG5jb25zdCBpc0NpcmN1bGFyID0gcmVxdWlyZSgnaXMtY2lyY3VsYXInKVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vaXBmcy9nby1pcGZzL2lzc3Vlcy8zNTcwI2lzc3VlY29tbWVudC0yNzM5MzE2OTJcbmNvbnN0IENJRF9DQk9SX1RBRyA9IDQyXG5cbmZ1bmN0aW9uIHRhZ0NJRCAoY2lkKSB7XG4gIGlmICh0eXBlb2YgY2lkID09PSAnc3RyaW5nJykge1xuICAgIGNpZCA9IG5ldyBDSUQoY2lkKS5idWZmZXJcbiAgfSBlbHNlIGlmIChDSUQuaXNDSUQoY2lkKSkge1xuICAgIGNpZCA9IGNpZC5idWZmZXJcbiAgfVxuXG4gIHJldHVybiBuZXcgY2Jvci5UYWdnZWQoQ0lEX0NCT1JfVEFHLCBCdWZmZXIuY29uY2F0KFtcbiAgICBCdWZmZXIuZnJvbSgnMDAnLCAnaGV4JyksIC8vIHRoYW5rcyBqZGFnXG4gICAgY2lkXG4gIF0pKVxufVxuXG5mdW5jdGlvbiByZXBsYWNlQ0lEYnlUQUcgKGRhZ05vZGUpIHtcbiAgbGV0IGNpcmN1bGFyXG4gIHRyeSB7XG4gICAgY2lyY3VsYXIgPSBpc0NpcmN1bGFyKGRhZ05vZGUpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjaXJjdWxhciA9IGZhbHNlXG4gIH1cbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgb2JqZWN0IHBhc3NlZCBoYXMgY2lyY3VsYXIgcmVmZXJlbmNlcycpXG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm0gKG9iaikge1xuICAgIGlmICghb2JqIHx8IEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gb2JqXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuIG9iai5tYXAodHJhbnNmb3JtKVxuICAgIH1cblxuICAgIGlmIChDSUQuaXNDSUQob2JqKSkge1xuICAgICAgcmV0dXJuIHRhZ0NJRChvYmopXG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iailcblxuICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFJlY3Vyc2l2ZSB0cmFuc2Zvcm1cbiAgICAgIGNvbnN0IG91dCA9IHt9XG4gICAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIG91dFtrZXldID0gdHJhbnNmb3JtKG9ialtrZXldKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dFtrZXldID0gb2JqW2tleV1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHJldHVybiBvdXRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9ialxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cmFuc2Zvcm0oZGFnTm9kZSlcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzXG5cbmV4cG9ydHMuY29kZWMgPSBtdWx0aWNvZGVjLkRBR19DQk9SXG5leHBvcnRzLmRlZmF1bHRIYXNoQWxnID0gbXVsdGljb2RlYy5TSEEyXzI1NlxuXG5jb25zdCBkZWZhdWx0VGFncyA9IHtcbiAgW0NJRF9DQk9SX1RBR106ICh2YWwpID0+IHtcbiAgICAvLyByZW1vdmUgdGhhdCAwXG4gICAgdmFsID0gdmFsLnNsaWNlKDEpXG4gICAgcmV0dXJuIG5ldyBDSUQodmFsKVxuICB9XG59XG5jb25zdCBkZWZhdWx0U2l6ZSA9IDY0ICogMTAyNCAvLyBjdXJyZW50IGRlY29kZXIgaGVhcCBzaXplLCA2NCBLYlxubGV0IGN1cnJlbnRTaXplID0gZGVmYXVsdFNpemVcbmNvbnN0IGRlZmF1bHRNYXhTaXplID0gNjQgKiAxMDI0ICogMTAyNCAvLyBtYXggaGVhcCBzaXplIHdoZW4gYXV0by1ncm93aW5nLCA2NCBNYlxubGV0IG1heFNpemUgPSBkZWZhdWx0TWF4U2l6ZVxubGV0IGRlY29kZXIgPSBudWxsXG5cbi8qKlxuICogQ29uZmlndXJlIHRoZSB1bmRlcmx5aW5nIENCT1IgZGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMgdGhlIGRlY29kZXIgdGFrZXMuIFRoZSBkZWNvZGVyIHdpbGwgcmVzZXQgdG8gdGhlIGRlZmF1bCB2YWx1ZXMgaWYgbm8gb3B0aW9ucyBhcmUgZ2l2ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2l6ZT02NTUzNl0gLSBUaGUgY3VycmVudCBoZWFwIHNpemUgdXNlZCBpbiBDQk9SIHBhcnNpbmcsIHRoaXMgbWF5IGdyb3cgYXV0b21hdGljYWxseSBhcyBsYXJnZXIgYmxvY2tzIGFyZSBlbmNvdW50ZXJlZCB1cCB0byBgbWF4U2l6ZWBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhTaXplPTY3MTA4ODY0XSAtIFRoZSBtYXhpbXVtIHNpemUgdGhlIENCT1IgcGFyc2luZyBoZWFwIGlzIGFsbG93ZWQgdG8gZ3JvdyB0byBiZWZvcmUgYGRhZ0NCT1IudXRpbC5kZXNlcmlhbGl6ZSgpYCByZXR1cm5zIGFuIGVycm9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudGFnc10gLSBBbiBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgQ0JPUiB0YWcgbnVtYmVycyBhbmQgdmFsdWVzIGFyZSB0cmFuc2Zvcm0gZnVuY3Rpb25zIHRoYXQgYWNjZXB0IGEgYHZhbHVlYCBhbmQgcmV0dXJuIGEgZGVjb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGF0IGB2YWx1ZWBcbiAqL1xuZXhwb3J0cy5jb25maWd1cmVEZWNvZGVyID0gKG9wdGlvbnMpID0+IHtcbiAgbGV0IHRhZ3MgPSBkZWZhdWx0VGFnc1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICBjdXJyZW50U2l6ZSA9IG9wdGlvbnMuc2l6ZVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubWF4U2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIG1heFNpemUgPSBvcHRpb25zLm1heFNpemVcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGFncykge1xuICAgICAgdGFncyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRUYWdzLCBvcHRpb25zICYmIG9wdGlvbnMudGFncylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbm8gb3B0aW9ucywgcmVzZXQgdG8gZGVmYXVsdHNcbiAgICBjdXJyZW50U2l6ZSA9IGRlZmF1bHRTaXplXG4gICAgbWF4U2l6ZSA9IGRlZmF1bHRNYXhTaXplXG4gIH1cblxuICBsZXQgZGVjb2Rlck9wdGlvbnMgPSB7XG4gICAgdGFnczogdGFncyxcbiAgICBzaXplOiBjdXJyZW50U2l6ZVxuICB9XG5cbiAgZGVjb2RlciA9IG5ldyBjYm9yLkRlY29kZXIoZGVjb2Rlck9wdGlvbnMpXG4gIC8vIGJvcmMgZWRpdHMgb3B0cy5zaXplIGluLXBsYWNlIHNvIHdlIGNhbiBjYXB0dXJlIF9hY3R1YWxfIHNpemVcbiAgY3VycmVudFNpemUgPSBkZWNvZGVyT3B0aW9ucy5zaXplXG59XG5cbmV4cG9ydHMuY29uZmlndXJlRGVjb2RlcigpIC8vIFNldHVwIGRlZmF1bHQgY2Jvci5EZWNvZGVyXG5cbi8qKlxuICogU2VyaWFsaXplIGludGVybmFsIHJlcHJlc2VudGF0aW9uIGludG8gYSBiaW5hcnkgQ0JPUiBibG9jay5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSAtIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgQ0JPUiBibG9ja1xuICogQHJldHVybnMge0J1ZmZlcn0gLSBUaGUgZW5jb2RlZCBiaW5hcnkgcmVwcmVzZW50YXRpb25cbiAqL1xuZXhwb3J0cy5zZXJpYWxpemUgPSAobm9kZSkgPT4ge1xuICBjb25zdCBub2RlVGFnZ2VkID0gcmVwbGFjZUNJRGJ5VEFHKG5vZGUpXG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSBjYm9yLmVuY29kZShub2RlVGFnZ2VkKVxuXG4gIHJldHVybiBzZXJpYWxpemVkXG59XG5cbi8qKlxuICogRGVzZXJpYWxpemUgQ0JPUiBibG9jayBpbnRvIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSAtIEJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBhIENCT1IgYmxvY2tcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gQW4gb2JqZWN0IHRoYXQgY29uZm9ybXMgdG8gdGhlIElQTEQgRGF0YSBNb2RlbFxuICovXG5leHBvcnRzLmRlc2VyaWFsaXplID0gKGRhdGEpID0+IHtcbiAgaWYgKGRhdGEubGVuZ3RoID4gY3VycmVudFNpemUgJiYgZGF0YS5sZW5ndGggPD0gbWF4U2l6ZSkge1xuICAgIGV4cG9ydHMuY29uZmlndXJlRGVjb2Rlcih7IHNpemU6IGRhdGEubGVuZ3RoIH0pXG4gIH1cblxuICBpZiAoZGF0YS5sZW5ndGggPiBjdXJyZW50U2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBpcyB0b28gbGFyZ2UgdG8gZGVzZXJpYWxpemUgd2l0aCBjdXJyZW50IGRlY29kZXInKVxuICB9XG5cbiAgY29uc3QgZGVzZXJpYWxpemVkID0gZGVjb2Rlci5kZWNvZGVGaXJzdChkYXRhKVxuXG4gIHJldHVybiBkZXNlcmlhbGl6ZWRcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIENJRCBvZiB0aGUgYmluYXJ5IGJsb2IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGJpbmFyeUJsb2IgLSBFbmNvZGVkIElQTEQgTm9kZVxuICogQHBhcmFtIHtPYmplY3R9IFt1c2VyT3B0aW9uc10gLSBPcHRpb25zIHRvIGNyZWF0ZSB0aGUgQ0lEXG4gKiBAcGFyYW0ge251bWJlcn0gW3VzZXJPcHRpb25zLmNpZFZlcnNpb249MV0gLSBDSUQgdmVyc2lvbiBudW1iZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbVXNlck9wdGlvbnMuaGFzaEFsZ10gLSBEZWZhdWx0cyB0byB0aGUgZGVmYXVsdEhhc2hBbGcgb2YgdGhlIGZvcm1hdFxuICogQHJldHVybnMge1Byb21pc2UuPENJRD59XG4gKi9cbmV4cG9ydHMuY2lkID0gYXN5bmMgKGJpbmFyeUJsb2IsIHVzZXJPcHRpb25zKSA9PiB7XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0geyBjaWRWZXJzaW9uOiAxLCBoYXNoQWxnOiBleHBvcnRzLmRlZmF1bHRIYXNoQWxnIH1cbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbnMsIHVzZXJPcHRpb25zKVxuXG4gIGNvbnN0IG11bHRpaGFzaCA9IGF3YWl0IG11bHRpaGFzaGluZyhiaW5hcnlCbG9iLCBvcHRpb25zLmhhc2hBbGcpXG4gIGNvbnN0IGNvZGVjTmFtZSA9IG11bHRpY29kZWMucHJpbnRbZXhwb3J0cy5jb2RlY11cbiAgY29uc3QgY2lkID0gbmV3IENJRChvcHRpb25zLmNpZFZlcnNpb24sIGNvZGVjTmFtZSwgbXVsdGloYXNoKVxuXG4gIHJldHVybiBjaWRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qKlxuICogUmVzb2x2ZXMgYSBwYXRoIHdpdGhpbiBhIFBCIGJsb2NrLlxuICpcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9yIGEgbGluayBhbmQgdGhlIHBhcnRpYWwgbWlzaW5nIHBhdGguIFRoaXMgd2F5IHRoZVxuICogSVBMRCBSZXNvbHZlciBjYW4gZmV0Y2ggdGhlIGxpbmsgYW5kIGNvbnRpbnVlIHRvIHJlc29sdmUuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJpbmFyeUJsb2IgLSBCaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgYSBQQiBibG9ja1xuICogQHBhcmFtIHtzdHJpbmd9IFtwYXRoPScvJ10gLSBQYXRoIHRoYXQgc2hvdWxkIGJlIHJlc29sdmVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSByZXN1bHQgLSBSZXN1bHQgb2YgdGhlIHBhdGggaXQgaXQgd2FzIHJlc29sdmVkIHN1Y2Nlc3NmdWxseVxuICogQHJldHVybnMgeyp9IHJlc3VsdC52YWx1ZSAtIFZhbHVlIHRoZSBwYXRoIHJlc29sdmVzIHRvXG4gKiBAcmV0dXJucyB7c3RyaW5nfSByZXN1bHQucmVtYWluZGVyUGF0aCAtIElmIHRoZSBwYXRoIHJlc29sdmVzIGhhbGYtd2F5IHRvIGFcbiAqICAgbGluaywgdGhlbiB0aGUgYHJlbWFpbmRlclBhdGhgIGlzIHRoZSBwYXJ0IGFmdGVyIHRoZSBsaW5rIHRoYXQgY2FuIGJlIHVzZWRcbiAqICAgZm9yIGZ1cnRoZXIgcmVzb2x2aW5nXG4gKi9cbmV4cG9ydHMucmVzb2x2ZSA9IChiaW5hcnlCbG9iLCBwYXRoKSA9PiB7XG4gIGxldCBub2RlID0gdXRpbC5kZXNlcmlhbGl6ZShiaW5hcnlCbG9iKVxuXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpLmZpbHRlcihCb29sZWFuKVxuICB3aGlsZSAocGFydHMubGVuZ3RoKSB7XG4gICAgY29uc3Qga2V5ID0gcGFydHMuc2hpZnQoKVxuICAgIGlmIChub2RlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgaGFzIG5vIHByb3BlcnR5ICcke2tleX0nYClcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZVtrZXldXG4gICAgaWYgKENJRC5pc0NJRChub2RlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICAgIHJlbWFpbmRlclBhdGg6IHBhcnRzLmpvaW4oJy8nKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IG5vZGUsXG4gICAgcmVtYWluZGVyUGF0aDogJydcbiAgfVxufVxuXG5jb25zdCB0cmF2ZXJzZSA9IGZ1bmN0aW9uICogKG5vZGUsIHBhdGgpIHtcbiAgLy8gVHJhdmVyc2Ugb25seSBvYmplY3RzIGFuZCBhcnJheXNcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihub2RlKSB8fCBDSUQuaXNDSUQobm9kZSkgfHwgdHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8XG4gICAgICBub2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZm9yIChjb25zdCBpdGVtIG9mIE9iamVjdC5rZXlzKG5vZGUpKSB7XG4gICAgY29uc3QgbmV4dHBhdGggPSBwYXRoID09PSB1bmRlZmluZWQgPyBpdGVtIDogcGF0aCArICcvJyArIGl0ZW1cbiAgICB5aWVsZCBuZXh0cGF0aFxuICAgIHlpZWxkICogdHJhdmVyc2Uobm9kZVtpdGVtXSwgbmV4dHBhdGgpXG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gYWxsIGF2YWlsYWJsZSBwYXRocyBvZiBhIGJsb2NrLlxuICpcbiAqIEBnZW5lcmF0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfSBiaW5hcnlCbG9iIC0gQmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIGEgUEIgYmxvY2tcbiAqIEB5aWVsZHMge3N0cmluZ30gLSBBIHNpbmdsZSBwYXRoXG4gKi9cbmV4cG9ydHMudHJlZSA9IGZ1bmN0aW9uICogKGJpbmFyeUJsb2IpIHtcbiAgY29uc3Qgbm9kZSA9IHV0aWwuZGVzZXJpYWxpemUoYmluYXJ5QmxvYilcblxuICB5aWVsZCAqIHRyYXZlcnNlKG5vZGUpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpXG5jb25zdCBwcm90b25zID0gcmVxdWlyZSgncHJvdG9ucycpXG5jb25zdCBwcm90byA9IHByb3RvbnMocmVxdWlyZSgnLi9kYWcucHJvdG8uanMnKSlcbmNvbnN0IERBR0xpbmsgPSByZXF1aXJlKCcuL2RhZy1saW5rJylcbmNvbnN0IERBR05vZGUgPSByZXF1aXJlKCcuL2RhZy1ub2RlJylcbmNvbnN0IG11bHRpY29kZWMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJylcbmNvbnN0IG11bHRpaGFzaGluZyA9IHJlcXVpcmUoJ211bHRpaGFzaGluZy1hc3luYycpXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0c1xuXG5leHBvcnRzLmNvZGVjID0gbXVsdGljb2RlYy5EQUdfUEJcbmV4cG9ydHMuZGVmYXVsdEhhc2hBbGcgPSBtdWx0aWNvZGVjLlNIQTJfMjU2XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBDSUQgb2YgdGhlIGJpbmFyeSBibG9iLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBiaW5hcnlCbG9iIC0gRW5jb2RlZCBJUExEIE5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbdXNlck9wdGlvbnNdIC0gT3B0aW9ucyB0byBjcmVhdGUgdGhlIENJRFxuICogQHBhcmFtIHtudW1iZXJ9IFt1c2VyT3B0aW9ucy5jaWRWZXJzaW9uPTFdIC0gQ0lEIHZlcnNpb24gbnVtYmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gW1VzZXJPcHRpb25zLmhhc2hBbGddIC0gRGVmYXVsdHMgdG8gdGhlIGRlZmF1bHRIYXNoQWxnIG9mIHRoZSBmb3JtYXRcbiAqIEByZXR1cm5zIHtQcm9taXNlLjxDSUQ+fVxuICovXG5jb25zdCBjaWQgPSBhc3luYyAoYmluYXJ5QmxvYiwgdXNlck9wdGlvbnMpID0+IHtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7IGNpZFZlcnNpb246IDEsIGhhc2hBbGc6IGV4cG9ydHMuZGVmYXVsdEhhc2hBbGcgfVxuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgdXNlck9wdGlvbnMpXG5cbiAgY29uc3QgbXVsdGloYXNoID0gYXdhaXQgbXVsdGloYXNoaW5nKGJpbmFyeUJsb2IsIG9wdGlvbnMuaGFzaEFsZylcbiAgY29uc3QgY29kZWNOYW1lID0gbXVsdGljb2RlYy5wcmludFtleHBvcnRzLmNvZGVjXVxuICBjb25zdCBjaWQgPSBuZXcgQ0lEKG9wdGlvbnMuY2lkVmVyc2lvbiwgY29kZWNOYW1lLCBtdWx0aWhhc2gpXG5cbiAgcmV0dXJuIGNpZFxufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBpbnRvIGEgYmluYXJ5IFBCIGJsb2NrLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIC0gSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBDQk9SIGJsb2NrXG4gKiBAcmV0dXJucyB7QnVmZmVyfSAtIFRoZSBlbmNvZGVkIGJpbmFyeSByZXByZXNlbnRhdGlvblxuICovXG5jb25zdCBzZXJpYWxpemUgPSAobm9kZSkgPT4ge1xuICBsZXQgZGF0YSA9IG5vZGUuRGF0YVxuICBsZXQgbGlua3MgPSBub2RlLkxpbmtzIHx8IFtdXG5cbiAgLy8gSWYgdGhlIG5vZGUgaXMgbm90IGFuIGluc3RhbmNlIG9mIGEgREFHTm9kZSwgdGhlIGxpbmsuaGFzaCBtaWdodCBiZSBhIEJhc2U1OCBlbmNvZGVkIHN0cmluZzsgZGVjb2RlIGl0XG4gIGlmICghREFHTm9kZS5pc0RBR05vZGUobm9kZSkgJiYgbGlua3MpIHtcbiAgICBsaW5rcyA9IGxpbmtzLm1hcCgobGluaykgPT4ge1xuICAgICAgcmV0dXJuIERBR0xpbmsuaXNEQUdMaW5rKGxpbmspID8gbGluayA6IERBR0xpbmsudXRpbC5jcmVhdGVEYWdMaW5rRnJvbUI1OEVuY29kZWRIYXNoKGxpbmspXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSBwcm90by5QQk5vZGUuZW5jb2RlKHRvUHJvdG9CdWYoe1xuICAgIERhdGE6IGRhdGEsXG4gICAgTGlua3M6IGxpbmtzXG4gIH0pKVxuXG4gIHJldHVybiBzZXJpYWxpemVkXG59XG5cbi8qKlxuICogRGVzZXJpYWxpemUgUEIgYmxvY2sgaW50byB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciAtIEJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBhIFBCIGJsb2NrXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIEFuIG9iamVjdCB0aGF0IGNvbmZvcm1zIHRvIHRoZSBJUExEIERhdGEgTW9kZWxcbiAqL1xuY29uc3QgZGVzZXJpYWxpemUgPSAoYnVmZmVyKSA9PiB7XG4gIGNvbnN0IHBibiA9IHByb3RvLlBCTm9kZS5kZWNvZGUoYnVmZmVyKVxuXG4gIGNvbnN0IGxpbmtzID0gcGJuLkxpbmtzLm1hcCgobGluaykgPT4ge1xuICAgIHJldHVybiBuZXcgREFHTGluayhsaW5rLk5hbWUsIGxpbmsuVHNpemUsIGxpbmsuSGFzaClcbiAgfSlcblxuICBjb25zdCBkYXRhID0gcGJuLkRhdGEgPT0gbnVsbCA/IEJ1ZmZlci5hbGxvYygwKSA6IHBibi5EYXRhXG5cbiAgcmV0dXJuIG5ldyBEQUdOb2RlKGRhdGEsIGxpbmtzLCBidWZmZXIubGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB0b1Byb3RvQnVmIChub2RlKSB7XG4gIGNvbnN0IHBibiA9IHt9XG5cbiAgaWYgKG5vZGUuRGF0YSAmJiBub2RlLkRhdGEubGVuZ3RoID4gMCkge1xuICAgIHBibi5EYXRhID0gbm9kZS5EYXRhXG4gIH0gZWxzZSB7XG4gICAgLy8gTk9URTogdGhpcyBoYXMgdG8gYmUgbnVsbCBpbiBvcmRlciB0byBtYXRjaCBnby1pcGZzIHNlcmlhbGl6YXRpb24gYG51bGwgIT09IG5ldyBCdWZmZXIoMClgXG4gICAgcGJuLkRhdGEgPSBudWxsXG4gIH1cblxuICBpZiAobm9kZS5MaW5rcyAmJiBub2RlLkxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICBwYm4uTGlua3MgPSBub2RlLkxpbmtzXG4gICAgICAubWFwKChsaW5rKSA9PiAoe1xuICAgICAgICBIYXNoOiBsaW5rLkhhc2guYnVmZmVyLFxuICAgICAgICBOYW1lOiBsaW5rLk5hbWUsXG4gICAgICAgIFRzaXplOiBsaW5rLlRzaXplXG4gICAgICB9KSlcbiAgfSBlbHNlIHtcbiAgICBwYm4uTGlua3MgPSBudWxsXG4gIH1cblxuICByZXR1cm4gcGJuXG59XG5cbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplXG5leHBvcnRzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcbmV4cG9ydHMuY2lkID0gY2lkXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3Qgd2l0aElzID0gcmVxdWlyZSgnY2xhc3MtaXMnKVxuY29uc3QgdmlzaWJpbGl0eSA9IHJlcXVpcmUoJy4uL3Zpc2liaWxpdHknKVxuXG4vLyBMaW5rIHJlcHJlc2VudHMgYW4gSVBGUyBNZXJrbGUgREFHIExpbmsgYmV0d2VlbiBOb2Rlcy5cbmNsYXNzIERBR0xpbmsge1xuICBjb25zdHJ1Y3RvciAobmFtZSwgc2l6ZSwgY2lkKSB7XG4gICAgYXNzZXJ0KGNpZCwgJ0EgbGluayByZXF1aXJlcyBhIGNpZCB0byBwb2ludCB0bycpXG4gICAgLy8gYXNzZXJ0KHNpemUsICdBIGxpbmsgcmVxdWlyZXMgYSBzaXplJylcbiAgICAvLyAgbm90ZSAtIGxpbmtzIHNob3VsZCBpbmNsdWRlIHNpemUsIGJ1dCB0aGlzIGFzc2VydCBpcyBkaXNhYmxlZFxuICAgIC8vICBmb3Igbm93IHRvIG1haW50YWluIGNvbnNpc3RlbmN5IHdpdGggZ28taXBmcyBwaW5zZXRcblxuICAgIHRoaXMuX25hbWUgPSBuYW1lIHx8ICcnXG4gICAgdGhpcy5fbmFtZUJ1ZiA9IG51bGxcbiAgICB0aGlzLl9zaXplID0gc2l6ZVxuICAgIHRoaXMuX2NpZCA9IG5ldyBDSUQoY2lkKVxuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBuaWNlIHB1YmxpYyBBUEkgdGhhdCBjYW4gYmUgdXNlZCBieSBhbiBJUExEIHJlc29sdmVyXG4gICAgdmlzaWJpbGl0eS5oaWRlUHJpdmF0ZUZpZWxkcyh0aGlzKVxuICAgIHZpc2liaWxpdHkuYWRkRW51bWVyYWJsZUdldHRlcnModGhpcywgWydIYXNoJywgJ05hbWUnLCAnVHNpemUnXSlcbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gYERBR0xpbmsgPCR7dGhpcy5fY2lkLnRvQmFzZUVuY29kZWRTdHJpbmcoKX0gLSBuYW1lOiBcIiR7dGhpcy5OYW1lfVwiLCBzaXplOiAke3RoaXMuVHNpemV9PmBcbiAgfVxuXG4gIHRvSlNPTiAoKSB7XG4gICAgaWYgKCF0aGlzLl9qc29uKSB7XG4gICAgICB0aGlzLl9qc29uID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIG5hbWU6IHRoaXMuTmFtZSxcbiAgICAgICAgc2l6ZTogdGhpcy5Uc2l6ZSxcbiAgICAgICAgY2lkOiB0aGlzLkhhc2gudG9CYXNlRW5jb2RlZFN0cmluZygpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9qc29uKVxuICB9XG5cbiAgZ2V0IE5hbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lXG4gIH1cblxuICAvLyBNZW1vaXplIHRoZSBCdWZmZXIgcmVwcmVzZW50YXRpb24gb2YgbmFtZVxuICAvLyBXZSBuZWVkIHRoaXMgdG8gc29ydCB0aGUgbGlua3MsIG90aGVyd2lzZVxuICAvLyB3ZSB3aWxsIHJlYWxsb2NhdGUgbmV3IGJ1ZmZlcnMgZXZlcnkgdGltZVxuICBnZXQgbmFtZUFzQnVmZmVyICgpIHtcbiAgICBpZiAodGhpcy5fbmFtZUJ1ZiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWVCdWZcbiAgICB9XG5cbiAgICB0aGlzLl9uYW1lQnVmID0gQnVmZmVyLmZyb20odGhpcy5fbmFtZSlcbiAgICByZXR1cm4gdGhpcy5fbmFtZUJ1ZlxuICB9XG5cbiAgc2V0IE5hbWUgKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzZXQgcHJvcGVydHk6ICduYW1lJyBpcyBpbW11dGFibGVcIilcbiAgfVxuXG4gIGdldCBUc2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemVcbiAgfVxuXG4gIHNldCBUc2l6ZSAoc2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHNldCBwcm9wZXJ0eTogJ3NpemUnIGlzIGltbXV0YWJsZVwiKVxuICB9XG5cbiAgZ2V0IEhhc2ggKCkge1xuICAgIHJldHVybiB0aGlzLl9jaWRcbiAgfVxuXG4gIHNldCBIYXNoIChjaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzZXQgcHJvcGVydHk6ICdjaWQnIGlzIGltbXV0YWJsZVwiKVxuICB9XG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHdpdGhJcyhEQUdMaW5rLCB7IGNsYXNzTmFtZTogJ0RBR0xpbmsnLCBzeW1ib2xOYW1lOiAnQGlwbGQvanMtaXBsZC1kYWctcGIvZGFnbGluaycgfSlcbmV4cG9ydHMudXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHdpdGhJcyA9IHJlcXVpcmUoJ2NsYXNzLWlzJylcbmNvbnN0IGFkZE5hbWVkTGluayA9IHJlcXVpcmUoJy4vYWRkTmFtZWRMaW5rJylcbmNvbnN0IHZpc2liaWxpdHkgPSByZXF1aXJlKCcuLi92aXNpYmlsaXR5JylcblxuY2xhc3MgREFHTm9kZSB7XG4gIGNvbnN0cnVjdG9yIChkYXRhLCBsaW5rcywgc2VyaWFsaXplZFNpemUpIHtcbiAgICBpZiAoc2VyaWFsaXplZFNpemUgIT09IDApIHtcbiAgICAgIGFzc2VydChzZXJpYWxpemVkU2l6ZSwgJ0EgREFHTm9kZSByZXF1aXJlcyBpdFxcJ3Mgc2VyaWFsaXplZCBzaXplJylcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhID0gZGF0YSB8fCBCdWZmZXIuYWxsb2MoMClcbiAgICB0aGlzLl9saW5rcyA9IGxpbmtzXG4gICAgdGhpcy5fc2VyaWFsaXplZFNpemUgPSBzZXJpYWxpemVkU2l6ZVxuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBuaWNlIHB1YmxpYyBBUEkgdGhhdCBjYW4gYmUgdXNlZCBieSBhbiBJUExEIHJlc29sdmVyXG4gICAgdmlzaWJpbGl0eS5oaWRlUHJpdmF0ZUZpZWxkcyh0aGlzKVxuICAgIHZpc2liaWxpdHkuYWRkRW51bWVyYWJsZUdldHRlcnModGhpcywgWydEYXRhJywgJ0xpbmtzJ10pXG5cbiAgICAvLyBBZGQgZ2V0dGVycyBmb3IgZXhpc3RpbmcgbGlua3MgYnkgdGhlIG5hbWUgb2YgdGhlIGxpbmtcbiAgICAvLyBUaGlzIGlzIGhvdyBwYXRocyBhcmUgdHJhdmVyc2VkIGluIElQRlMuIExpbmtzIHdpdGggbmFtZXMgd29uJ3RcbiAgICAvLyBvdmVycmlkZSBleGlzdGluZyBmaWVsZHMgbGlrZSBgZGF0YWAgb3IgYGxpbmtzYC5cbiAgICBsaW5rcy5mb3JFYWNoKChsaW5rLCBwb3NpdGlvbikgPT4ge1xuICAgICAgYWRkTmFtZWRMaW5rKHRoaXMsIGxpbmsuTmFtZSwgcG9zaXRpb24pXG4gICAgfSlcbiAgfVxuXG4gIHRvSlNPTiAoKSB7XG4gICAgaWYgKCF0aGlzLl9qc29uKSB7XG4gICAgICB0aGlzLl9qc29uID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGRhdGE6IHRoaXMuRGF0YSxcbiAgICAgICAgbGlua3M6IHRoaXMuX2xpbmtzLm1hcCgobCkgPT4gbC50b0pTT04oKSksXG4gICAgICAgIHNpemU6IHRoaXMuc2l6ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fanNvbilcbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gYERBR05vZGUgPGRhdGE6IFwiJHt0aGlzLkRhdGEudG9TdHJpbmcoJ2Jhc2U2NCcpfVwiLCBsaW5rczogJHt0aGlzLkxpbmtzLmxlbmd0aH0sIHNpemU6ICR7dGhpcy5zaXplfT5gXG4gIH1cblxuICBnZXQgc2l6ZSAoKSB7XG4gICAgaWYgKHRoaXMuX3NpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc2l6ZSA9IHRoaXMuX2xpbmtzLnJlZHVjZSgoc3VtLCBsKSA9PiBzdW0gKyBsLlRzaXplLCB0aGlzLl9zZXJpYWxpemVkU2l6ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc2l6ZVxuICB9XG5cbiAgc2V0IHNpemUgKHNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzZXQgcHJvcGVydHk6ICdzaXplJyBpcyBpbW11dGFibGVcIilcbiAgfVxuXG4gIC8vIEdldHRlcnMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmxlIHBhdGggcmVzb2x2aW5nXG4gIGdldCBEYXRhICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVxuICB9XG4gIHNldCBEYXRhIChfKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc2V0IHByb3BlcnR5OiAnRGF0YScgaXMgaW1tdXRhYmxlXCIpXG4gIH1cbiAgZ2V0IExpbmtzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGlua3MubWFwKChsaW5rKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBOYW1lOiBsaW5rLk5hbWUsXG4gICAgICAgIFRzaXplOiBsaW5rLlRzaXplLFxuICAgICAgICBIYXNoOiBsaW5rLkhhc2hcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIHNldCBMaW5rcyAoXykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHNldCBwcm9wZXJ0eTogJ0xpbmtzJyBpcyBpbW11dGFibGVcIilcbiAgfVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB3aXRoSXMoREFHTm9kZSwgeyBjbGFzc05hbWU6ICdEQUdOb2RlJywgc3ltYm9sTmFtZTogJ0BpcGxkL2pzLWlwbGQtZGFnLXBiL2RhZ25vZGUnIH0pXG5leHBvcnRzLmNyZWF0ZSA9IHJlcXVpcmUoJy4vY3JlYXRlJylcbmV4cG9ydHMuY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lJylcbmV4cG9ydHMuYWRkTGluayA9IHJlcXVpcmUoJy4vYWRkTGluaycpXG5leHBvcnRzLnJtTGluayA9IHJlcXVpcmUoJy4vcm1MaW5rJylcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IGVycmNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCBtdWx0aWhhc2ggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpXG5cbi8qKlxuICogSGFzaCB0aGUgZ2l2ZW4gYGJ1ZmAgdXNpbmcgdGhlIGFsZ29yaXRobSBzcGVjaWZpZWQgYnkgYGFsZ2AuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIC0gVGhlIHZhbHVlIHRvIGhhc2guXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGFsZyAtIFRoZSBhbGdvcml0aG0gdG8gdXNlIGVnICdzaGExJ1xuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIC0gT3B0aW9uYWxseSB0cmltIHRoZSByZXN1bHQgdG8gdGhpcyBsZW5ndGguXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXI+fVxuICovXG5hc3luYyBmdW5jdGlvbiBNdWx0aWhhc2hpbmcgKGJ1ZiwgYWxnLCBsZW5ndGgpIHtcbiAgY29uc3QgZGlnZXN0ID0gYXdhaXQgTXVsdGloYXNoaW5nLmRpZ2VzdChidWYsIGFsZywgbGVuZ3RoKVxuICByZXR1cm4gbXVsdGloYXNoLmVuY29kZShkaWdlc3QsIGFsZywgbGVuZ3RoKVxufVxuXG4vKipcbiAqIFRoZSBgYnVmZmVyYCBtb2R1bGUgZm9yIGVhc3kgdXNlIGluIHRoZSBicm93c2VyLlxuICpcbiAqIEB0eXBlIHtCdWZmZXJ9XG4gKi9cbk11bHRpaGFzaGluZy5CdWZmZXIgPSBCdWZmZXIgLy8gZm9yIGJyb3dzZXIgdGhpbmdzXG5cbi8qKlxuICogRXhwb3NlIG11bHRpaGFzaCBpdHNlbGYsIHRvIGF2b2lkIHNpbGx5IGRvdWJsZSByZXF1aXJlcy5cbiAqL1xuTXVsdGloYXNoaW5nLm11bHRpaGFzaCA9IG11bHRpaGFzaFxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgLSBUaGUgdmFsdWUgdG8gaGFzaC5cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gYWxnIC0gVGhlIGFsZ29yaXRobSB0byB1c2UgZWcgJ3NoYTEnXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gLSBPcHRpb25hbGx5IHRyaW0gdGhlIHJlc3VsdCB0byB0aGlzIGxlbmd0aC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59XG4gKi9cbk11bHRpaGFzaGluZy5kaWdlc3QgPSBhc3luYyAoYnVmLCBhbGcsIGxlbmd0aCkgPT4ge1xuICBjb25zdCBoYXNoID0gTXVsdGloYXNoaW5nLmNyZWF0ZUhhc2goYWxnKVxuICBjb25zdCBkaWdlc3QgPSBhd2FpdCBoYXNoKGJ1ZilcbiAgcmV0dXJuIGxlbmd0aCA/IGRpZ2VzdC5zbGljZSgwLCBsZW5ndGgpIDogZGlnZXN0XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaGFzaGVzIHdpdGggdGhlIGdpdmVuIGFsZ29yaXRobVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYWxnIC0gVGhlIGFsZ29yaXRobSB0byB1c2UgZWcgJ3NoYTEnXG4gKlxuICogQHJldHVybnMge2Z1bmN0aW9ufSAtIFRoZSBoYXNoIGZ1bmN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gYGFsZ2BcbiAqL1xuTXVsdGloYXNoaW5nLmNyZWF0ZUhhc2ggPSBmdW5jdGlvbiAoYWxnKSB7XG4gIGlmICghYWxnKSB7XG4gICAgdGhyb3cgZXJyY29kZSgnaGFzaCBhbGdvcml0aG0gbXVzdCBiZSBzcGVjaWZpZWQnLCAnRVJSX0hBU0hfQUxHT1JJVEhNX05PVF9TUEVDSUZJRUQnKVxuICB9XG5cbiAgYWxnID0gbXVsdGloYXNoLmNvZXJjZUNvZGUoYWxnKVxuICBpZiAoIU11bHRpaGFzaGluZy5mdW5jdGlvbnNbYWxnXSkge1xuICAgIHRocm93IGVycmNvZGUoYG11bHRpaGFzaCBmdW5jdGlvbiAnJHthbGd9JyBub3QgeWV0IHN1cHBvcnRlZGAsICdFUlJfSEFTSF9BTEdPUklUSE1fTk9UX1NVUFBPUlRFRCcpXG4gIH1cblxuICByZXR1cm4gTXVsdGloYXNoaW5nLmZ1bmN0aW9uc1thbGddXG59XG5cbi8qKlxuICogTWFwcGluZyBvZiBtdWx0aWhhc2ggY29kZXMgdG8gdGhlaXIgaGFzaGluZyBmdW5jdGlvbnMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5NdWx0aWhhc2hpbmcuZnVuY3Rpb25zID0ge1xuICAvLyBzaGExXG4gIDB4MTE6IGNyeXB0by5zaGExLFxuICAvLyBzaGEyLTI1NlxuICAweDEyOiBjcnlwdG8uc2hhMjI1NixcbiAgLy8gc2hhMi01MTJcbiAgMHgxMzogY3J5cHRvLnNoYTI1MTIsXG4gIC8vIHNoYTMtNTEyXG4gIDB4MTQ6IGNyeXB0by5zaGEzNTEyLFxuICAvLyBzaGEzLTM4NFxuICAweDE1OiBjcnlwdG8uc2hhMzM4NCxcbiAgLy8gc2hhMy0yNTZcbiAgMHgxNjogY3J5cHRvLnNoYTMyNTYsXG4gIC8vIHNoYTMtMjI0XG4gIDB4MTc6IGNyeXB0by5zaGEzMjI0LFxuICAvLyBzaGFrZS0xMjhcbiAgMHgxODogY3J5cHRvLnNoYWtlMTI4LFxuICAvLyBzaGFrZS0yNTZcbiAgMHgxOTogY3J5cHRvLnNoYWtlMjU2LFxuICAvLyBrZWNjYWstMjI0XG4gIDB4MUE6IGNyeXB0by5rZWNjYWsyMjQsXG4gIC8vIGtlY2Nhay0yNTZcbiAgMHgxQjogY3J5cHRvLmtlY2NhazI1NixcbiAgLy8ga2VjY2FrLTM4NFxuICAweDFDOiBjcnlwdG8ua2VjY2FrMzg0LFxuICAvLyBrZWNjYWstNTEyXG4gIDB4MUQ6IGNyeXB0by5rZWNjYWs1MTIsXG4gIC8vIG11cm11cjMtMTI4XG4gIDB4MjI6IGNyeXB0by5tdXJtdXIzMTI4LFxuICAvLyBtdXJtdXIzLTMyXG4gIDB4MjM6IGNyeXB0by5tdXJtdXIzMzIsXG4gIC8vIGRibC1zaGEyLTI1NlxuICAweDU2OiBjcnlwdG8uZGJsU2hhMjI1NlxufVxuXG4vLyBhZGQgYmxha2UgZnVuY3Rpb25zXG5jcnlwdG8uYWRkQmxha2UoTXVsdGloYXNoaW5nLmZ1bmN0aW9ucylcblxuTXVsdGloYXNoaW5nLnZhbGlkYXRlID0gYXN5bmMgKGJ1ZiwgaGFzaCkgPT4ge1xuICBjb25zdCBuZXdIYXNoID0gYXdhaXQgTXVsdGloYXNoaW5nKGJ1ZiwgbXVsdGloYXNoLmRlY29kZShoYXNoKS5uYW1lKVxuXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZShoYXNoLCBuZXdIYXNoKSA9PT0gMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE11bHRpaGFzaGluZ1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIEJhc2Uge1xuICBjb25zdHJ1Y3RvciAobmFtZSwgY29kZSwgaW1wbGVtZW50YXRpb24sIGFscGhhYmV0KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuY29kZSA9IGNvZGVcbiAgICB0aGlzLmFscGhhYmV0ID0gYWxwaGFiZXRcbiAgICBpZiAoaW1wbGVtZW50YXRpb24gJiYgYWxwaGFiZXQpIHtcbiAgICAgIHRoaXMuZW5naW5lID0gaW1wbGVtZW50YXRpb24oYWxwaGFiZXQpXG4gICAgfVxuICB9XG5cbiAgZW5jb2RlIChzdHJpbmdPckJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLmVuZ2luZS5lbmNvZGUoc3RyaW5nT3JCdWZmZXIpXG4gIH1cblxuICBkZWNvZGUgKHN0cmluZ09yQnVmZmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5naW5lLmRlY29kZShzdHJpbmdPckJ1ZmZlcilcbiAgfVxuXG4gIGlzSW1wbGVtZW50ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLmVuZ2luZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFzZTE2IChhbHBoYWJldCkge1xuICByZXR1cm4ge1xuICAgIGVuY29kZSAoaW5wdXQpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShpbnB1dCkudG9TdHJpbmcoJ2hleCcpXG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXQudG9TdHJpbmcoJ2hleCcpXG4gICAgfSxcbiAgICBkZWNvZGUgKGlucHV0KSB7XG4gICAgICBmb3IgKGxldCBjaGFyIG9mIGlucHV0KSB7XG4gICAgICAgIGlmIChhbHBoYWJldC5pbmRleE9mKGNoYXIpIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiYXNlMTYgY2hhcmFjdGVyJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGlucHV0LCAnaGV4JylcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBkZWNvZGUgKGlucHV0LCBhbHBoYWJldCkge1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UobmV3IFJlZ0V4cCgnPScsICdnJyksICcnKVxuICBsZXQgbGVuZ3RoID0gaW5wdXQubGVuZ3RoXG5cbiAgbGV0IGJpdHMgPSAwXG4gIGxldCB2YWx1ZSA9IDBcblxuICBsZXQgaW5kZXggPSAwXG4gIGxldCBvdXRwdXQgPSBuZXcgVWludDhBcnJheSgobGVuZ3RoICogNSAvIDgpIHwgMClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWUgPSAodmFsdWUgPDwgNSkgfCBhbHBoYWJldC5pbmRleE9mKGlucHV0W2ldKVxuICAgIGJpdHMgKz0gNVxuXG4gICAgaWYgKGJpdHMgPj0gOCkge1xuICAgICAgb3V0cHV0W2luZGV4KytdID0gKHZhbHVlID4+PiAoYml0cyAtIDgpKSAmIDI1NVxuICAgICAgYml0cyAtPSA4XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dC5idWZmZXJcbn1cblxuZnVuY3Rpb24gZW5jb2RlIChidWZmZXIsIGFscGhhYmV0KSB7XG4gIGxldCBsZW5ndGggPSBidWZmZXIuYnl0ZUxlbmd0aFxuICBsZXQgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcilcbiAgbGV0IHBhZGRpbmcgPSBhbHBoYWJldC5pbmRleE9mKCc9JykgPT09IGFscGhhYmV0Lmxlbmd0aCAtIDFcblxuICBpZiAocGFkZGluZykge1xuICAgIGFscGhhYmV0ID0gYWxwaGFiZXQuc3Vic3RyaW5nKDAsIGFscGhhYmV0Lmxlbmd0aCAtIDIpXG4gIH1cblxuICBsZXQgYml0cyA9IDBcbiAgbGV0IHZhbHVlID0gMFxuICBsZXQgb3V0cHV0ID0gJydcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWUgPSAodmFsdWUgPDwgOCkgfCB2aWV3W2ldXG4gICAgYml0cyArPSA4XG5cbiAgICB3aGlsZSAoYml0cyA+PSA1KSB7XG4gICAgICBvdXRwdXQgKz0gYWxwaGFiZXRbKHZhbHVlID4+PiAoYml0cyAtIDUpKSAmIDMxXVxuICAgICAgYml0cyAtPSA1XG4gICAgfVxuICB9XG5cbiAgaWYgKGJpdHMgPiAwKSB7XG4gICAgb3V0cHV0ICs9IGFscGhhYmV0Wyh2YWx1ZSA8PCAoNSAtIGJpdHMpKSAmIDMxXVxuICB9XG5cbiAgaWYgKHBhZGRpbmcpIHtcbiAgICB3aGlsZSAoKG91dHB1dC5sZW5ndGggJSA4KSAhPT0gMCkge1xuICAgICAgb3V0cHV0ICs9ICc9J1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYXNlMzIgKGFscGhhYmV0KSB7XG4gIHJldHVybiB7XG4gICAgZW5jb2RlIChpbnB1dCkge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZShCdWZmZXIuZnJvbShpbnB1dCksIGFscGhhYmV0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW5jb2RlKGlucHV0LCBhbHBoYWJldClcbiAgICB9LFxuICAgIGRlY29kZSAoaW5wdXQpIHtcbiAgICAgIGZvciAobGV0IGNoYXIgb2YgaW5wdXQpIHtcbiAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoY2hhcikgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJhc2UzMiBjaGFyYWN0ZXInKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWNvZGUoaW5wdXQsIGFscGhhYmV0KVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFzZTY0IChhbHBoYWJldCkge1xuICAvLyBUaGUgYWxwaGFiZXQgaXMgb25seSB1c2VkIHRvIGtub3c6XG4gIC8vICAgMS4gSWYgcGFkZGluZyBpcyBlbmFibGVkIChtdXN0IGNvbnRhaW4gJz0nKVxuICAvLyAgIDIuIElmIHRoZSBvdXRwdXQgbXVzdCBiZSB1cmwtc2FmZSAobXVzdCBjb250YWluICctJyBhbmQgJ18nKVxuICAvLyAgIDMuIElmIHRoZSBpbnB1dCBvZiB0aGUgb3V0cHV0IGZ1bmN0aW9uIGlzIHZhbGlkXG4gIC8vIFRoZSBhbHBoYWJldHMgZnJvbSBSRkMgNDY0OCBhcmUgYWx3YXlzIHVzZWQuXG4gIGNvbnN0IHBhZGRpbmcgPSBhbHBoYWJldC5pbmRleE9mKCc9JykgPiAtMVxuICBjb25zdCB1cmwgPSBhbHBoYWJldC5pbmRleE9mKCctJykgPiAtMSAmJiBhbHBoYWJldC5pbmRleE9mKCdfJykgPiAtMVxuXG4gIHJldHVybiB7XG4gICAgZW5jb2RlIChpbnB1dCkge1xuICAgICAgbGV0IG91dHB1dCA9ICcnXG5cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG91dHB1dCA9IEJ1ZmZlci5mcm9tKGlucHV0KS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IGlucHV0LnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgfVxuXG4gICAgICBpZiAodXJsKSB7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwYWQgPSBvdXRwdXQuaW5kZXhPZignPScpXG4gICAgICBpZiAocGFkID4gMCAmJiAhcGFkZGluZykge1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3Vic3RyaW5nKDAsIHBhZClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dFxuICAgIH0sXG4gICAgZGVjb2RlIChpbnB1dCkge1xuICAgICAgZm9yIChsZXQgY2hhciBvZiBpbnB1dCkge1xuICAgICAgICBpZiAoYWxwaGFiZXQuaW5kZXhPZihjaGFyKSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmFzZTY0IGNoYXJhY3RlcicpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGlucHV0LCAnYmFzZTY0JylcbiAgICB9XG4gIH1cbn1cbiIsIi8vIGJhc2UteCBlbmNvZGluZ1xuLy8gRm9ya2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9iczU4XG4vLyBPcmlnaW5hbGx5IHdyaXR0ZW4gYnkgTWlrZSBIZWFybiBmb3IgQml0Y29pbkpcbi8vIENvcHlyaWdodCAoYykgMjAxMSBHb29nbGUgSW5jXG4vLyBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBTdGVmYW4gVGhvbWFzXG4vLyBNZXJnZWQgQnVmZmVyIHJlZmFjdG9yaW5ncyBmcm9tIGJhc2U1OC1uYXRpdmUgYnkgU3RlcGhlbiBQYWlyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQml0UGF5IEluY1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYXNlIChBTFBIQUJFVCkge1xuICB2YXIgQUxQSEFCRVRfTUFQID0ge31cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGhcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKVxuXG4gIC8vIHByZS1jb21wdXRlIGxvb2t1cCB0YWJsZVxuICBmb3IgKHZhciB6ID0gMDsgeiA8IEFMUEhBQkVULmxlbmd0aDsgeisrKSB7XG4gICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoeilcblxuICAgIGlmIChBTFBIQUJFVF9NQVBbeF0gIT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKVxuICAgIEFMUEhBQkVUX01BUFt4XSA9IHpcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVybiAnJ1xuXG4gICAgdmFyIGRpZ2l0cyA9IFswXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgY2FycnkgPSBzb3VyY2VbaV07IGogPCBkaWdpdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgY2FycnkgKz0gZGlnaXRzW2pdIDw8IDhcbiAgICAgICAgZGlnaXRzW2pdID0gY2FycnkgJSBCQVNFXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgfCAwXG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcbiAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBCQVNFKVxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpIHwgMFxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdHJpbmcgPSAnJ1xuXG4gICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICBmb3IgKHZhciBrID0gMDsgc291cmNlW2tdID09PSAwICYmIGsgPCBzb3VyY2UubGVuZ3RoIC0gMTsgKytrKSBzdHJpbmcgKz0gTEVBREVSXG4gICAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgICBmb3IgKHZhciBxID0gZGlnaXRzLmxlbmd0aCAtIDE7IHEgPj0gMDsgLS1xKSBzdHJpbmcgKz0gQUxQSEFCRVRbZGlnaXRzW3FdXVxuXG4gICAgcmV0dXJuIHN0cmluZ1xuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpXG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoMClcblxuICAgIHZhciBieXRlcyA9IFswXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBBTFBIQUJFVF9NQVBbc3RyaW5nW2ldXVxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVyblxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgY2FycnkgPSB2YWx1ZTsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNhcnJ5ICs9IGJ5dGVzW2pdICogQkFTRVxuICAgICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZlxuICAgICAgICBjYXJyeSA+Pj0gOFxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goY2FycnkgJiAweGZmKVxuICAgICAgICBjYXJyeSA+Pj0gOFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgZm9yICh2YXIgayA9IDA7IHN0cmluZ1trXSA9PT0gTEVBREVSICYmIGsgPCBzdHJpbmcubGVuZ3RoIC0gMTsgKytrKSB7XG4gICAgICBieXRlcy5wdXNoKDApXG4gICAgfVxuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzLnJldmVyc2UoKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGJ1ZmZlclxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgaXAgPSByZXF1aXJlKCdpcCcpXG5jb25zdCBpc0lwID0gcmVxdWlyZSgnaXMtaXAnKVxuY29uc3QgcHJvdG9jb2xzID0gcmVxdWlyZSgnLi9wcm90b2NvbHMtdGFibGUnKVxuY29uc3QgYnM1OCA9IHJlcXVpcmUoJ2JzNTgnKVxuY29uc3QgYmFzZTMyID0gcmVxdWlyZSgnaGktYmFzZTMyJylcbmNvbnN0IHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5cbm1vZHVsZS5leHBvcnRzID0gQ29udmVydFxuXG4vLyBjb252ZXJ0cyAoc2VyaWFsaXplcykgYWRkcmVzc2VzXG5mdW5jdGlvbiBDb252ZXJ0IChwcm90bywgYSkge1xuICBpZiAoYSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIHJldHVybiBDb252ZXJ0LnRvU3RyaW5nKHByb3RvLCBhKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBDb252ZXJ0LnRvQnVmZmVyKHByb3RvLCBhKVxuICB9XG59XG5cbkNvbnZlcnQudG9TdHJpbmcgPSBmdW5jdGlvbiBjb252ZXJ0VG9TdHJpbmcgKHByb3RvLCBidWYpIHtcbiAgcHJvdG8gPSBwcm90b2NvbHMocHJvdG8pXG4gIHN3aXRjaCAocHJvdG8uY29kZSkge1xuICAgIGNhc2UgNDogLy8gaXB2NFxuICAgIGNhc2UgNDE6IC8vIGlwdjZcbiAgICAgIHJldHVybiBidWYyaXAoYnVmKVxuXG4gICAgY2FzZSA2OiAvLyB0Y3BcbiAgICBjYXNlIDI3MzogLy8gdWRwXG4gICAgY2FzZSAzMzogLy8gZGNjcFxuICAgIGNhc2UgMTMyOiAvLyBzY3RwXG4gICAgICByZXR1cm4gYnVmMnBvcnQoYnVmKVxuXG4gICAgY2FzZSA1MzogLy8gZG5zXG4gICAgY2FzZSA1NDogLy8gZG5zNFxuICAgIGNhc2UgNTU6IC8vIGRuczZcbiAgICBjYXNlIDU2OiAvLyBkbnNhZGRyXG4gICAgY2FzZSA0MDA6IC8vIHVuaXhcbiAgICAgIHJldHVybiBidWYyc3RyKGJ1ZilcblxuICAgIGNhc2UgNDIxOiAvLyBpcGZzXG4gICAgICByZXR1cm4gYnVmMm1oKGJ1ZilcbiAgICBjYXNlIDQ0NDogLy8gb25pb25cbiAgICAgIHJldHVybiBidWYyb25pb24oYnVmKVxuICAgIGNhc2UgNDQ1OiAvLyBvbmlvbjNcbiAgICAgIHJldHVybiBidWYyb25pb24oYnVmKVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCdoZXgnKSAvLyBubyBjbHVlLiBjb252ZXJ0IHRvIGhleFxuICB9XG59XG5cbkNvbnZlcnQudG9CdWZmZXIgPSBmdW5jdGlvbiBjb252ZXJ0VG9CdWZmZXIgKHByb3RvLCBzdHIpIHtcbiAgcHJvdG8gPSBwcm90b2NvbHMocHJvdG8pXG4gIHN3aXRjaCAocHJvdG8uY29kZSkge1xuICAgIGNhc2UgNDogLy8gaXB2NFxuICAgICAgcmV0dXJuIGlwMmJ1ZihzdHIpXG4gICAgY2FzZSA0MTogLy8gaXB2NlxuICAgICAgcmV0dXJuIGlwMmJ1ZihzdHIpXG5cbiAgICBjYXNlIDY6IC8vIHRjcFxuICAgIGNhc2UgMjczOiAvLyB1ZHBcbiAgICBjYXNlIDMzOiAvLyBkY2NwXG4gICAgY2FzZSAxMzI6IC8vIHNjdHBcbiAgICAgIHJldHVybiBwb3J0MmJ1ZihwYXJzZUludChzdHIsIDEwKSlcblxuICAgIGNhc2UgNTM6IC8vIGRuc1xuICAgIGNhc2UgNTQ6IC8vIGRuczRcbiAgICBjYXNlIDU1OiAvLyBkbnM2XG4gICAgY2FzZSA1NjogLy8gZG5zYWRkclxuICAgIGNhc2UgNDAwOiAvLyB1bml4XG4gICAgICByZXR1cm4gc3RyMmJ1ZihzdHIpXG5cbiAgICBjYXNlIDQyMTogLy8gaXBmc1xuICAgICAgcmV0dXJuIG1oMmJ1ZihzdHIpXG4gICAgY2FzZSA0NDQ6IC8vIG9uaW9uXG4gICAgICByZXR1cm4gb25pb24yYnVmKHN0cilcbiAgICBjYXNlIDQ0NTogLy8gb25pb24zXG4gICAgICByZXR1cm4gb25pb24zMmJ1ZihzdHIpXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIsICdoZXgnKSAvLyBubyBjbHVlLiBjb252ZXJ0IGZyb20gaGV4XG4gIH1cbn1cblxuZnVuY3Rpb24gaXAyYnVmIChpcFN0cmluZykge1xuICBpZiAoIWlzSXAoaXBTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlwIGFkZHJlc3MnKVxuICB9XG4gIHJldHVybiBpcC50b0J1ZmZlcihpcFN0cmluZylcbn1cblxuZnVuY3Rpb24gYnVmMmlwIChpcEJ1ZmYpIHtcbiAgY29uc3QgaXBTdHJpbmcgPSBpcC50b1N0cmluZyhpcEJ1ZmYpXG4gIGlmICghaXNJcChpcFN0cmluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaXAgYWRkcmVzcycpXG4gIH1cbiAgcmV0dXJuIGlwU3RyaW5nXG59XG5cbmZ1bmN0aW9uIHBvcnQyYnVmIChwb3J0KSB7XG4gIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYygyKVxuICBidWYud3JpdGVVSW50MTZCRShwb3J0LCAwKVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGJ1ZjJwb3J0IChidWYpIHtcbiAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoMClcbn1cblxuZnVuY3Rpb24gc3RyMmJ1ZiAoc3RyKSB7XG4gIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKHN0cilcbiAgY29uc3Qgc2l6ZSA9IEJ1ZmZlci5mcm9tKHZhcmludC5lbmNvZGUoYnVmLmxlbmd0aCkpXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtzaXplLCBidWZdKVxufVxuXG5mdW5jdGlvbiBidWYyc3RyIChidWYpIHtcbiAgY29uc3Qgc2l6ZSA9IHZhcmludC5kZWNvZGUoYnVmKVxuICBidWYgPSBidWYuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcblxuICBpZiAoYnVmLmxlbmd0aCAhPT0gc2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5jb25zaXN0ZW50IGxlbmd0aHMnKVxuICB9XG5cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygpXG59XG5cbmZ1bmN0aW9uIG1oMmJ1ZiAoaGFzaCkge1xuICAvLyB0aGUgYWRkcmVzcyBpcyBhIHZhcmludCBwcmVmaXhlZCBtdWx0aWhhc2ggc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gIGNvbnN0IG1oID0gQnVmZmVyLmZyb20oYnM1OC5kZWNvZGUoaGFzaCkpXG4gIGNvbnN0IHNpemUgPSBCdWZmZXIuZnJvbSh2YXJpbnQuZW5jb2RlKG1oLmxlbmd0aCkpXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtzaXplLCBtaF0pXG59XG5cbmZ1bmN0aW9uIGJ1ZjJtaCAoYnVmKSB7XG4gIGNvbnN0IHNpemUgPSB2YXJpbnQuZGVjb2RlKGJ1ZilcbiAgY29uc3QgYWRkcmVzcyA9IGJ1Zi5zbGljZSh2YXJpbnQuZGVjb2RlLmJ5dGVzKVxuXG4gIGlmIChhZGRyZXNzLmxlbmd0aCAhPT0gc2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5jb25zaXN0ZW50IGxlbmd0aHMnKVxuICB9XG5cbiAgcmV0dXJuIGJzNTguZW5jb2RlKGFkZHJlc3MpXG59XG5cbmZ1bmN0aW9uIG9uaW9uMmJ1ZiAoc3RyKSB7XG4gIGNvbnN0IGFkZHIgPSBzdHIuc3BsaXQoJzonKVxuICBpZiAoYWRkci5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSBvbmlvbiBhZGRyOiAnICsgYWRkciArICcgZG9lcyBub3QgY29udGFpbiBhIHBvcnQgbnVtYmVyJylcbiAgfVxuICBpZiAoYWRkclswXS5sZW5ndGggIT09IDE2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gcGFyc2Ugb25pb24gYWRkcjogJyArIGFkZHJbMF0gKyAnIG5vdCBhIFRvciBvbmlvbiBhZGRyZXNzLicpXG4gIH1cbiAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20oYmFzZTMyLmRlY29kZS5hc0J5dGVzKGFkZHJbMF0udG9VcHBlckNhc2UoKSkpXG5cbiAgLy8gb25pb24gcG9ydCBudW1iZXJcbiAgY29uc3QgcG9ydCA9IHBhcnNlSW50KGFkZHJbMV0sIDEwKVxuICBpZiAocG9ydCA8IDEgfHwgcG9ydCA+IDY1NTM2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IG51bWJlciBpcyBub3QgaW4gcmFuZ2UoMSwgNjU1MzYpJylcbiAgfVxuICBjb25zdCBwb3J0QnVmID0gcG9ydDJidWYocG9ydClcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2J1ZiwgcG9ydEJ1Zl0pXG59XG5cbmZ1bmN0aW9uIG9uaW9uMzJidWYgKHN0cikge1xuICBjb25zdCBhZGRyID0gc3RyLnNwbGl0KCc6JylcbiAgaWYgKGFkZHIubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gcGFyc2Ugb25pb24gYWRkcjogJyArIGFkZHIgKyAnIGRvZXMgbm90IGNvbnRhaW4gYSBwb3J0IG51bWJlcicpXG4gIH1cbiAgaWYgKGFkZHJbMF0ubGVuZ3RoICE9PSA1Nikge1xuICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHBhcnNlIG9uaW9uIGFkZHI6ICcgKyBhZGRyWzBdICsgJyBub3QgYSBUb3Igb25pb24zIGFkZHJlc3MuJylcbiAgfVxuICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShiYXNlMzIuZGVjb2RlLmFzQnl0ZXMoYWRkclswXS50b1VwcGVyQ2FzZSgpKSlcblxuICAvLyBvbmlvbiBwb3J0IG51bWJlclxuICBjb25zdCBwb3J0ID0gcGFyc2VJbnQoYWRkclsxXSwgMTApXG4gIGlmIChwb3J0IDwgMSB8fCBwb3J0ID4gNjU1MzYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnQgbnVtYmVyIGlzIG5vdCBpbiByYW5nZSgxLCA2NTUzNiknKVxuICB9XG4gIGNvbnN0IHBvcnRCdWYgPSBwb3J0MmJ1Zihwb3J0KVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbYnVmLCBwb3J0QnVmXSlcbn1cblxuZnVuY3Rpb24gYnVmMm9uaW9uIChidWYpIHtcbiAgY29uc3QgYWRkckJ5dGVzID0gYnVmLnNsaWNlKDAsIGJ1Zi5sZW5ndGggLSAyKVxuICBjb25zdCBwb3J0Qnl0ZXMgPSBidWYuc2xpY2UoYnVmLmxlbmd0aCAtIDIpXG4gIGNvbnN0IGFkZHIgPSBiYXNlMzIuZW5jb2RlKGFkZHJCeXRlcykudG9TdHJpbmcoJ2FzY2lpJykudG9Mb3dlckNhc2UoKVxuICBjb25zdCBwb3J0ID0gYnVmMnBvcnQocG9ydEJ5dGVzKVxuICByZXR1cm4gYWRkciArICc6JyArIHBvcnRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLnRvQ2FsbGJhY2sgPSAoZG9Xb3JrKSA9PiB7XG4gIHJldHVybiBmdW5jdGlvbiAoaW5wdXQsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBkb1dvcmsoaW5wdXQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBudWxsLCByZXMpXG4gIH1cbn1cblxuZXhwb3J0cy50b0J1ZiA9IChkb1dvcmssIG90aGVyKSA9PiAoaW5wdXQpID0+IHtcbiAgbGV0IHJlc3VsdCA9IGRvV29yayhpbnB1dCwgb3RoZXIpXG4gIHJldHVybiBCdWZmZXIuZnJvbShyZXN1bHQsICdoZXgnKVxufVxuXG5leHBvcnRzLmZyb21TdHJpbmcgPSAoZG9Xb3JrLCBvdGhlcikgPT4gKF9pbnB1dCkgPT4ge1xuICBjb25zdCBpbnB1dCA9IEJ1ZmZlci5pc0J1ZmZlcihfaW5wdXQpID8gX2lucHV0LnRvU3RyaW5nKCkgOiBfaW5wdXRcbiAgcmV0dXJuIGRvV29yayhpbnB1dCwgb3RoZXIpXG59XG5cbmV4cG9ydHMuZnJvbU51bWJlclRvMzJCaXRCdWYgPSAoZG9Xb3JrLCBvdGhlcikgPT4gKGlucHV0KSA9PiB7XG4gIGxldCBudW1iZXIgPSBkb1dvcmsoaW5wdXQsIG90aGVyKVxuICBjb25zdCBieXRlcyA9IG5ldyBBcnJheSg0KVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBudW1iZXIgJiAweGZmXG4gICAgbnVtYmVyID0gbnVtYmVyID4+IDhcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShieXRlcylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvbXVybXVySGFzaDNqcycpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJsYWtlID0gcmVxdWlyZSgnYmxha2VqcycpXG5cbmNvbnN0IHRvQ2FsbGJhY2sgPSByZXF1aXJlKCcuL3V0aWxzJykudG9DYWxsYmFja1xuXG5jb25zdCBtaW5CID0gMHhiMjAxXG5jb25zdCBtaW5TID0gMHhiMjQxXG5cbmNvbnN0IGJsYWtlMmIgPSB7XG4gIGluaXQ6IGJsYWtlLmJsYWtlMmJJbml0LFxuICB1cGRhdGU6IGJsYWtlLmJsYWtlMmJVcGRhdGUsXG4gIGRpZ2VzdDogYmxha2UuYmxha2UyYkZpbmFsXG59XG5cbmNvbnN0IGJsYWtlMnMgPSB7XG4gIGluaXQ6IGJsYWtlLmJsYWtlMnNJbml0LFxuICB1cGRhdGU6IGJsYWtlLmJsYWtlMnNVcGRhdGUsXG4gIGRpZ2VzdDogYmxha2UuYmxha2Uyc0ZpbmFsXG59XG5cbmNvbnN0IG1ha2VCMkhhc2ggPSAoc2l6ZSwgaGYpID0+IHRvQ2FsbGJhY2soKGJ1ZikgPT4ge1xuICBjb25zdCBjdHggPSBoZi5pbml0KHNpemUsIG51bGwpXG4gIGhmLnVwZGF0ZShjdHgsIGJ1ZilcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhmLmRpZ2VzdChjdHgpKVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSAodGFibGUpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgdGFibGVbbWluQiArIGldID0gbWFrZUIySGFzaChpICsgMSwgYmxha2UyYilcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICB0YWJsZVttaW5TICsgaV0gPSBtYWtlQjJIYXNoKGkgKyAxLCBibGFrZTJzKVxuICB9XG59XG4iLCIvKiBnbG9iYWwgc2VsZiAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3Qgbm9kZWlmeSA9IHJlcXVpcmUoJ25vZGVpZnknKVxuXG5jb25zdCB3ZWJDcnlwdG8gPSBnZXRXZWJDcnlwdG8oKVxuXG5mdW5jdGlvbiBnZXRXZWJDcnlwdG8gKCkge1xuICBpZiAoc2VsZi5jcnlwdG8pIHtcbiAgICByZXR1cm4gc2VsZi5jcnlwdG8uc3VidGxlIHx8IHNlbGYuY3J5cHRvLndlYmtpdFN1YnRsZVxuICB9XG5cbiAgaWYgKHNlbGYubXNDcnlwdG8pIHtcbiAgICByZXR1cm4gc2VsZi5tc0NyeXB0by5zdWJ0bGVcbiAgfVxufVxuXG5mdW5jdGlvbiB3ZWJDcnlwdG9IYXNoICh0eXBlKSB7XG4gIGlmICghd2ViQ3J5cHRvKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgdXNlIGEgYnJvd3NlciB3aXRoIHdlYmNyeXB0byBzdXBwb3J0IGFuZCBlbnN1cmUgdGhlIGNvZGUgaGFzIGJlZW4gZGVsaXZlcmVkIHNlY3VyZWx5IHZpYSBIVFRQUy9UTFMgYW5kIHJ1biB3aXRoaW4gYSBTZWN1cmUgQ29udGV4dCcpXG4gIH1cblxuICByZXR1cm4gKGRhdGEsIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgcmVzID0gd2ViQ3J5cHRvLmRpZ2VzdCh7IG5hbWU6IHR5cGUgfSwgZGF0YSlcblxuICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gIT09ICdmdW5jdGlvbicpIHsgLy8gSUUxMVxuICAgICAgcmVzLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgaGFzaGluZyBkYXRhIHVzaW5nICR7dHlwZX1gKSlcbiAgICAgIH1cbiAgICAgIHJlcy5vbmNvbXBsZXRlID0gKGUpID0+IHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZS50YXJnZXQucmVzdWx0KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbm9kZWlmeShcbiAgICAgIHJlcy50aGVuKChyYXcpID0+IEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHJhdykpKSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNoYTEgKGJ1ZiwgY2FsbGJhY2spIHtcbiAgd2ViQ3J5cHRvSGFzaCgnU0hBLTEnKShidWYsIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiBzaGEyMjU2IChidWYsIGNhbGxiYWNrKSB7XG4gIHdlYkNyeXB0b0hhc2goJ1NIQS0yNTYnKShidWYsIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiBzaGEyNTEyIChidWYsIGNhbGxiYWNrKSB7XG4gIHdlYkNyeXB0b0hhc2goJ1NIQS01MTInKShidWYsIGNhbGxiYWNrKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2hhMTogc2hhMSxcbiAgc2hhMjI1Njogc2hhMjI1NixcbiAgc2hhMjUxMjogc2hhMjUxMlxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIEJhc2VkIG9uIG5wbWpzLmNvbS9ub2RlaWZ5IGJ1dCB3aXRob3V0IGFkZGl0aW9uYWwgYG5leHRUaWNrYCBjYWxsc1xuLy8gdG8ga2VlcCB0aGUgb3ZlcmhlYWQgbG93XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vZGVpZnkgKHByb21pc2UsIGNiKSB7XG4gIHJldHVybiBwcm9taXNlLnRoZW4oKHJlcykgPT4ge1xuICAgIGNiKG51bGwsIHJlcylcbiAgfSwgKGVycikgPT4ge1xuICAgIGNiKGVycilcbiAgfSlcbn1cbiIsIi8qIGdsb2JhbCBzZWxmICovXG5cbid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbGYuY3J5cHRvIHx8IHNlbGYubXNDcnlwdG9cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU0hBMTogMjAsXG4gIFNIQTI1NjogMzIsXG4gIFNIQTUxMjogNjRcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY3J5cHRvID0gZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG87XG5cbi8vIGxpbWl0IG9mIENyeXB0by5nZXRSYW5kb21WYWx1ZXMoKVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NyeXB0by9nZXRSYW5kb21WYWx1ZXNcbmNvbnN0IE1BWF9CWVRFUyA9IDY1NTM2O1xuXG5mdW5jdGlvbiBvbGRCcm93c2VyKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuXFxuVXNlIENocm9tZSwgRmlyZWZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMSdcbiAgICApO1xufVxuXG5pZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbUJ5dGVzO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG9sZEJyb3dzZXI7XG59XG5cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKHNpemUpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGxldCBnZW5lcmF0ZWQgPSAwO1xuXG4gICAgaWYgKHNpemUgPiAwKSB7XG4gICAgICAgIC8vIGdldFJhbmRvbVZhbHVlcyBmYWlscyBvbiBJRSBpZiBzaXplID09IDBcbiAgICAgICAgaWYgKHNpemUgPiBNQVhfQllURVMpIHtcbiAgICAgICAgICAgIHdoaWxlIChnZW5lcmF0ZWQgPCBieXRlcykge1xuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZWQgKyBNQVhfQllURVMgPiBieXRlcykge1xuICAgICAgICAgICAgICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMuc3ViYXJyYXkoZ2VuZXJhdGVkLCBieXRlcyAtIGdlbmVyYXRlZClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMuc3ViYXJyYXkoZ2VuZXJhdGVkLCBnZW5lcmF0ZWQgKyBNQVhfQllURVMpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZCArPSBNQVhfQllURVM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUNpcGhlcml2OiBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYsXG4gIGNyZWF0ZURlY2lwaGVyaXY6IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2XG59XG4iLCIvKipcbiAqIFBhc3N3b3JkLUJhc2VkIEtleS1EZXJpdmF0aW9uIEZ1bmN0aW9uICMyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFNlZSBSRkMgMjg5OCBmb3IgZGV0YWlscy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vaG1hYycpO1xucmVxdWlyZSgnLi9tZCcpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBwa2NzNSA9IGZvcmdlLnBrY3M1ID0gZm9yZ2UucGtjczUgfHwge307XG5cbnZhciBjcnlwdG87XG5pZihmb3JnZS51dGlsLmlzTm9kZWpzICYmICFmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0KSB7XG4gIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xufVxuXG4vKipcbiAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSBwIHRoZSBwYXNzd29yZCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBzIHRoZSBzYWx0IGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICogQHBhcmFtIGMgdGhlIGl0ZXJhdGlvbiBjb3VudCwgYSBwb3NpdGl2ZSBpbnRlZ2VyLlxuICogQHBhcmFtIGRrTGVuIHRoZSBpbnRlbmRlZCBsZW5ndGgsIGluIGJ5dGVzLCBvZiB0aGUgZGVyaXZlZCBrZXksXG4gKiAgICAgICAgICAobWF4OiAyXjMyIC0gMSkgKiBoYXNoIGxlbmd0aCBvZiB0aGUgUFJGLlxuICogQHBhcmFtIFttZF0gdGhlIG1lc3NhZ2UgZGlnZXN0IChvciBhbGdvcml0aG0gaWRlbnRpZmllciBhcyBhIHN0cmluZykgdG8gdXNlXG4gKiAgICAgICAgICBpbiB0aGUgUFJGLCBkZWZhdWx0cyB0byBTSEEtMS5cbiAqIEBwYXJhbSBbY2FsbGJhY2soZXJyLCBrZXkpXSBwcmVzZW5jZSB0cmlnZ2VycyBhc3luY2hyb25vdXMgdmVyc2lvbiwgY2FsbGVkXG4gKiAgICAgICAgICBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlcml2ZWQga2V5LCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcywgZm9yIHRoZVxuICogICAgICAgICAgIHN5bmNocm9ub3VzIHZlcnNpb24gKGlmIG5vIGNhbGxiYWNrIGlzIHNwZWNpZmllZCkuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGJrZGYyID0gcGtjczUucGJrZGYyID0gZnVuY3Rpb24oXG4gIHAsIHMsIGMsIGRrTGVuLCBtZCwgY2FsbGJhY2spIHtcbiAgaWYodHlwZW9mIG1kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBtZDtcbiAgICBtZCA9IG51bGw7XG4gIH1cblxuICAvLyB1c2UgbmF0aXZlIGltcGxlbWVudGF0aW9uIGlmIHBvc3NpYmxlIGFuZCBub3QgZGlzYWJsZWQsIG5vdGUgdGhhdFxuICAvLyBzb21lIG5vZGUgdmVyc2lvbnMgb25seSBzdXBwb3J0IFNIQS0xLCBvdGhlcnMgYWxsb3cgZGlnZXN0IHRvIGJlIGNoYW5nZWRcbiAgaWYoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJlxuICAgIGNyeXB0by5wYmtkZjIgJiYgKG1kID09PSBudWxsIHx8IHR5cGVvZiBtZCAhPT0gJ29iamVjdCcpICYmXG4gICAgKGNyeXB0by5wYmtkZjJTeW5jLmxlbmd0aCA+IDQgfHwgKCFtZCB8fCBtZCA9PT0gJ3NoYTEnKSkpIHtcbiAgICBpZih0eXBlb2YgbWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkZWZhdWx0IHByZiB0byBTSEEtMVxuICAgICAgbWQgPSAnc2hhMSc7XG4gICAgfVxuICAgIHAgPSBCdWZmZXIuZnJvbShwLCAnYmluYXJ5Jyk7XG4gICAgcyA9IEJ1ZmZlci5mcm9tKHMsICdiaW5hcnknKTtcbiAgICBpZighY2FsbGJhY2spIHtcbiAgICAgIGlmKGNyeXB0by5wYmtkZjJTeW5jLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvLnBia2RmMlN5bmMocCwgcywgYywgZGtMZW4pLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcnlwdG8ucGJrZGYyU3luYyhwLCBzLCBjLCBka0xlbiwgbWQpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICB9XG4gICAgaWYoY3J5cHRvLnBia2RmMlN5bmMubGVuZ3RoID09PSA0KSB7XG4gICAgICByZXR1cm4gY3J5cHRvLnBia2RmMihwLCBzLCBjLCBka0xlbiwgZnVuY3Rpb24oZXJyLCBrZXkpIHtcbiAgICAgICAgaWYoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwga2V5LnRvU3RyaW5nKCdiaW5hcnknKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyeXB0by5wYmtkZjIocCwgcywgYywgZGtMZW4sIG1kLCBmdW5jdGlvbihlcnIsIGtleSkge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwga2V5LnRvU3RyaW5nKCdiaW5hcnknKSk7XG4gICAgfSk7XG4gIH1cblxuICBpZih0eXBlb2YgbWQgPT09ICd1bmRlZmluZWQnIHx8IG1kID09PSBudWxsKSB7XG4gICAgLy8gZGVmYXVsdCBwcmYgdG8gU0hBLTFcbiAgICBtZCA9ICdzaGExJztcbiAgfVxuICBpZih0eXBlb2YgbWQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYoIShtZCBpbiBmb3JnZS5tZC5hbGdvcml0aG1zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGhhc2ggYWxnb3JpdGhtOiAnICsgbWQpO1xuICAgIH1cbiAgICBtZCA9IGZvcmdlLm1kW21kXS5jcmVhdGUoKTtcbiAgfVxuXG4gIHZhciBoTGVuID0gbWQuZGlnZXN0TGVuZ3RoO1xuXG4gIC8qIDEuIElmIGRrTGVuID4gKDJeMzIgLSAxKSAqIGhMZW4sIG91dHB1dCBcImRlcml2ZWQga2V5IHRvbyBsb25nXCIgYW5kXG4gICAgc3RvcC4gKi9cbiAgaWYoZGtMZW4gPiAoMHhGRkZGRkZGRiAqIGhMZW4pKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignRGVyaXZlZCBrZXkgaXMgdG9vIGxvbmcuJyk7XG4gICAgaWYoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICAvKiAyLiBMZXQgbGVuIGJlIHRoZSBudW1iZXIgb2YgaExlbi1vY3RldCBibG9ja3MgaW4gdGhlIGRlcml2ZWQga2V5LFxuICAgIHJvdW5kaW5nIHVwLCBhbmQgbGV0IHIgYmUgdGhlIG51bWJlciBvZiBvY3RldHMgaW4gdGhlIGxhc3RcbiAgICBibG9jazpcblxuICAgIGxlbiA9IENFSUwoZGtMZW4gLyBoTGVuKSxcbiAgICByID0gZGtMZW4gLSAobGVuIC0gMSkgKiBoTGVuLiAqL1xuICB2YXIgbGVuID0gTWF0aC5jZWlsKGRrTGVuIC8gaExlbik7XG4gIHZhciByID0gZGtMZW4gLSAobGVuIC0gMSkgKiBoTGVuO1xuXG4gIC8qIDMuIEZvciBlYWNoIGJsb2NrIG9mIHRoZSBkZXJpdmVkIGtleSBhcHBseSB0aGUgZnVuY3Rpb24gRiBkZWZpbmVkXG4gICAgYmVsb3cgdG8gdGhlIHBhc3N3b3JkIFAsIHRoZSBzYWx0IFMsIHRoZSBpdGVyYXRpb24gY291bnQgYywgYW5kXG4gICAgdGhlIGJsb2NrIGluZGV4IHRvIGNvbXB1dGUgdGhlIGJsb2NrOlxuXG4gICAgVF8xID0gRihQLCBTLCBjLCAxKSxcbiAgICBUXzIgPSBGKFAsIFMsIGMsIDIpLFxuICAgIC4uLlxuICAgIFRfbGVuID0gRihQLCBTLCBjLCBsZW4pLFxuXG4gICAgd2hlcmUgdGhlIGZ1bmN0aW9uIEYgaXMgZGVmaW5lZCBhcyB0aGUgZXhjbHVzaXZlLW9yIHN1bSBvZiB0aGVcbiAgICBmaXJzdCBjIGl0ZXJhdGVzIG9mIHRoZSB1bmRlcmx5aW5nIHBzZXVkb3JhbmRvbSBmdW5jdGlvbiBQUkZcbiAgICBhcHBsaWVkIHRvIHRoZSBwYXNzd29yZCBQIGFuZCB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgc2FsdCBTXG4gICAgYW5kIHRoZSBibG9jayBpbmRleCBpOlxuXG4gICAgRihQLCBTLCBjLCBpKSA9IHVfMSBYT1IgdV8yIFhPUiAuLi4gWE9SIHVfY1xuXG4gICAgd2hlcmVcblxuICAgIHVfMSA9IFBSRihQLCBTIHx8IElOVChpKSksXG4gICAgdV8yID0gUFJGKFAsIHVfMSksXG4gICAgLi4uXG4gICAgdV9jID0gUFJGKFAsIHVfe2MtMX0pLlxuXG4gICAgSGVyZSwgSU5UKGkpIGlzIGEgZm91ci1vY3RldCBlbmNvZGluZyBvZiB0aGUgaW50ZWdlciBpLCBtb3N0XG4gICAgc2lnbmlmaWNhbnQgb2N0ZXQgZmlyc3QuICovXG4gIHZhciBwcmYgPSBmb3JnZS5obWFjLmNyZWF0ZSgpO1xuICBwcmYuc3RhcnQobWQsIHApO1xuICB2YXIgZGsgPSAnJztcbiAgdmFyIHhvciwgdV9jLCB1X2MxO1xuXG4gIC8vIHN5bmMgdmVyc2lvblxuICBpZighY2FsbGJhY2spIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDw9IGxlbjsgKytpKSB7XG4gICAgICAvLyBQUkYoUCwgUyB8fCBJTlQoaSkpIChmaXJzdCBpdGVyYXRpb24pXG4gICAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgICBwcmYudXBkYXRlKHMpO1xuICAgICAgcHJmLnVwZGF0ZShmb3JnZS51dGlsLmludDMyVG9CeXRlcyhpKSk7XG4gICAgICB4b3IgPSB1X2MxID0gcHJmLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAgIC8vIFBSRihQLCB1X3tjLTF9KSAob3RoZXIgaXRlcmF0aW9ucylcbiAgICAgIGZvcih2YXIgaiA9IDI7IGogPD0gYzsgKytqKSB7XG4gICAgICAgIHByZi5zdGFydChudWxsLCBudWxsKTtcbiAgICAgICAgcHJmLnVwZGF0ZSh1X2MxKTtcbiAgICAgICAgdV9jID0gcHJmLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gICAgICAgIC8vIEYocCwgcywgYywgaSlcbiAgICAgICAgeG9yID0gZm9yZ2UudXRpbC54b3JCeXRlcyh4b3IsIHVfYywgaExlbik7XG4gICAgICAgIHVfYzEgPSB1X2M7XG4gICAgICB9XG5cbiAgICAgIC8qIDQuIENvbmNhdGVuYXRlIHRoZSBibG9ja3MgYW5kIGV4dHJhY3QgdGhlIGZpcnN0IGRrTGVuIG9jdGV0cyB0b1xuICAgICAgICBwcm9kdWNlIGEgZGVyaXZlZCBrZXkgREs6XG5cbiAgICAgICAgREsgPSBUXzEgfHwgVF8yIHx8ICAuLi4gIHx8IFRfbGVuPDAuLnItMT4gKi9cbiAgICAgIGRrICs9IChpIDwgbGVuKSA/IHhvciA6IHhvci5zdWJzdHIoMCwgcik7XG4gICAgfVxuICAgIC8qIDUuIE91dHB1dCB0aGUgZGVyaXZlZCBrZXkgREsuICovXG4gICAgcmV0dXJuIGRrO1xuICB9XG5cbiAgLy8gYXN5bmMgdmVyc2lvblxuICB2YXIgaSA9IDEsIGo7XG4gIGZ1bmN0aW9uIG91dGVyKCkge1xuICAgIGlmKGkgPiBsZW4pIHtcbiAgICAgIC8vIGRvbmVcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBkayk7XG4gICAgfVxuXG4gICAgLy8gUFJGKFAsIFMgfHwgSU5UKGkpKSAoZmlyc3QgaXRlcmF0aW9uKVxuICAgIHByZi5zdGFydChudWxsLCBudWxsKTtcbiAgICBwcmYudXBkYXRlKHMpO1xuICAgIHByZi51cGRhdGUoZm9yZ2UudXRpbC5pbnQzMlRvQnl0ZXMoaSkpO1xuICAgIHhvciA9IHVfYzEgPSBwcmYuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgIC8vIFBSRihQLCB1X3tjLTF9KSAob3RoZXIgaXRlcmF0aW9ucylcbiAgICBqID0gMjtcbiAgICBpbm5lcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5uZXIoKSB7XG4gICAgaWYoaiA8PSBjKSB7XG4gICAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgICBwcmYudXBkYXRlKHVfYzEpO1xuICAgICAgdV9jID0gcHJmLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gICAgICAvLyBGKHAsIHMsIGMsIGkpXG4gICAgICB4b3IgPSBmb3JnZS51dGlsLnhvckJ5dGVzKHhvciwgdV9jLCBoTGVuKTtcbiAgICAgIHVfYzEgPSB1X2M7XG4gICAgICArK2o7XG4gICAgICByZXR1cm4gZm9yZ2UudXRpbC5zZXRJbW1lZGlhdGUoaW5uZXIpO1xuICAgIH1cblxuICAgIC8qIDQuIENvbmNhdGVuYXRlIHRoZSBibG9ja3MgYW5kIGV4dHJhY3QgdGhlIGZpcnN0IGRrTGVuIG9jdGV0cyB0b1xuICAgICAgcHJvZHVjZSBhIGRlcml2ZWQga2V5IERLOlxuXG4gICAgICBESyA9IFRfMSB8fCBUXzIgfHwgIC4uLiAgfHwgVF9sZW48MC4uci0xPiAqL1xuICAgIGRrICs9IChpIDwgbGVuKSA/IHhvciA6IHhvci5zdWJzdHIoMCwgcik7XG5cbiAgICArK2k7XG4gICAgb3V0ZXIoKTtcbiAgfVxuXG4gIG91dGVyKCk7XG59O1xuIiwiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd2ViIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE4IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnZhciBiYXNlTiA9IHJlcXVpcmUoJy4vYmFzZU4nKTtcblxuLyogVXRpbGl0aWVzIEFQSSAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnV0aWwgPSBmb3JnZS51dGlsIHx8IHt9O1xuXG4vLyBkZWZpbmUgc2V0SW1tZWRpYXRlIGFuZCBuZXh0VGlja1xuKGZ1bmN0aW9uKCkge1xuICAvLyB1c2UgbmF0aXZlIG5leHRUaWNrICh1bmxlc3Mgd2UncmUgaW4gd2VicGFjaylcbiAgLy8gd2VicGFjayAob3IgYmV0dGVyIG5vZGUtbGlicy1icm93c2VyIHBvbHlmaWxsKSBzZXRzIHByb2Nlc3MuYnJvd3Nlci5cbiAgLy8gdGhpcyB3YXkgd2UgY2FuIGRldGVjdCB3ZWJwYWNrIHByb3Blcmx5XG4gIGlmKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5leHRUaWNrICYmICFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICB1dGlsLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICBpZih0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1dGlsLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcG9seWZpbGwgc2V0SW1tZWRpYXRlIHdpdGggbmV4dFRpY2ssIG9sZGVyIHZlcnNpb25zIG9mIG5vZGVcbiAgICAgIC8vICh0aG9zZSB3L28gc2V0SW1tZWRpYXRlKSB3b24ndCB0b3RhbGx5IHN0YXJ2ZSBJT1xuICAgICAgdXRpbC5zZXRJbW1lZGlhdGUgPSB1dGlsLm5leHRUaWNrO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBwb2x5ZmlsbCBuZXh0VGljayB3aXRoIG5hdGl2ZSBzZXRJbW1lZGlhdGVcbiAgaWYodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHV0aWwuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBzZXRJbW1lZGlhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpOyB9O1xuICAgIHV0aWwubmV4dFRpY2sgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiBOb3RlOiBBIHBvbHlmaWxsIHVwZ3JhZGUgcGF0dGVybiBpcyB1c2VkIGhlcmUgdG8gYWxsb3cgY29tYmluaW5nXG4gIHBvbHlmaWxscy4gRm9yIGV4YW1wbGUsIE11dGF0aW9uT2JzZXJ2ZXIgaXMgZmFzdCwgYnV0IGJsb2NrcyBVSSB1cGRhdGVzLFxuICBzbyBpdCBuZWVkcyB0byBhbGxvdyBVSSB1cGRhdGVzIHBlcmlvZGljYWxseSwgc28gaXQgZmFsbHMgYmFjayBvblxuICBwb3N0TWVzc2FnZSBvciBzZXRUaW1lb3V0LiAqL1xuXG4gIC8vIHBvbHlmaWxsIHdpdGggc2V0VGltZW91dFxuICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gIH07XG5cbiAgLy8gdXBncmFkZSBwb2x5ZmlsbCB0byB1c2UgcG9zdE1lc3NhZ2VcbiAgaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG1zZyA9ICdmb3JnZS5zZXRJbW1lZGlhdGUnO1xuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAvLyBvbmx5IHNlbmQgbWVzc2FnZSB3aGVuIG9uZSBoYXNuJ3QgYmVlbiBzZW50IGluXG4gICAgICAvLyB0aGUgY3VycmVudCB0dXJuIG9mIHRoZSBldmVudCBsb29wXG4gICAgICBpZihjYWxsYmFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtc2csICcqJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICBpZihldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhID09PSBtc2cpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBjb3B5ID0gY2FsbGJhY2tzLnNsaWNlKCk7XG4gICAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgfVxuXG4gIC8vIHVwZ3JhZGUgcG9seWZpbGwgdG8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJcbiAgaWYodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gcG9seWZpbGwgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIGF0dHIgPSB0cnVlO1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weSA9IGNhbGxiYWNrcy5zbGljZSgpO1xuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH0pLm9ic2VydmUoZGl2LCB7YXR0cmlidXRlczogdHJ1ZX0pO1xuICAgIHZhciBvbGRTZXRJbW1lZGlhdGUgPSB1dGlsLnNldEltbWVkaWF0ZTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZihEYXRlLm5vdygpIC0gbm93ID4gMTUpIHtcbiAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgb2xkU2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgLy8gb25seSB0cmlnZ2VyIG9ic2VydmVyIHdoZW4gaXQgaGFzbid0IGJlZW4gdHJpZ2dlcmVkIGluXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHR1cm4gb2YgdGhlIGV2ZW50IGxvb3BcbiAgICAgICAgaWYoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2EnLCBhdHRyID0gIWF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHV0aWwubmV4dFRpY2sgPSB1dGlsLnNldEltbWVkaWF0ZTtcbn0pKCk7XG5cbi8vIGNoZWNrIGlmIHJ1bm5pbmcgdW5kZXIgTm9kZS5qc1xudXRpbC5pc05vZGVqcyA9XG4gIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcblxuXG4vLyAnc2VsZicgd2lsbCBhbHNvIHdvcmsgaW4gV2ViIFdvcmtlcnMgKGluc3RhbmNlIG9mIFdvcmtlckdsb2JhbFNjb3BlKSB3aGlsZVxuLy8gaXQgd2lsbCBwb2ludCB0byBgd2luZG93YCBpbiB0aGUgbWFpbiB0aHJlYWQuXG4vLyBUbyByZW1haW4gY29tcGF0aWJsZSB3aXRoIG9sZGVyIGJyb3dzZXJzLCB3ZSBmYWxsIGJhY2sgdG8gJ3dpbmRvdycgaWYgJ3NlbGYnXG4vLyBpcyBub3QgYXZhaWxhYmxlLlxudXRpbC5nbG9iYWxTY29wZSA9IChmdW5jdGlvbigpIHtcbiAgaWYodXRpbC5pc05vZGVqcykge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cblxuICByZXR1cm4gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnID8gd2luZG93IDogc2VsZjtcbn0pKCk7XG5cbi8vIGRlZmluZSBpc0FycmF5XG51dGlsLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8vIGRlZmluZSBpc0FycmF5QnVmZmVyXG51dGlsLmlzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn07XG5cbi8vIGRlZmluZSBpc0FycmF5QnVmZmVyVmlld1xudXRpbC5pc0FycmF5QnVmZmVyVmlldyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggJiYgdXRpbC5pc0FycmF5QnVmZmVyKHguYnVmZmVyKSAmJiB4LmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogRW5zdXJlIGEgYml0cyBwYXJhbSBpcyA4LCAxNiwgMjQsIG9yIDMyLiBVc2VkIHRvIHZhbGlkYXRlIGlucHV0IGZvclxuICogYWxnb3JpdGhtcyB3aGVyZSBiaXQgbWFuaXB1bGF0aW9uLCBKYXZhU2NyaXB0IGxpbWl0YXRpb25zLCBhbmQvb3IgYWxnb3JpdGhtXG4gKiBkZXNpZ24gb25seSBhbGxvdyBmb3IgYnl0ZSBvcGVyYXRpb25zIG9mIGEgbGltaXRlZCBzaXplLlxuICpcbiAqIEBwYXJhbSBuIG51bWJlciBvZiBiaXRzLlxuICpcbiAqIFRocm93IEVycm9yIGlmIG4gaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gX2NoZWNrQml0c1BhcmFtKG4pIHtcbiAgaWYoIShuID09PSA4IHx8IG4gPT09IDE2IHx8IG4gPT09IDI0IHx8IG4gPT09IDMyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignT25seSA4LCAxNiwgMjQsIG9yIDMyIGJpdHMgc3VwcG9ydGVkOiAnICsgbik7XG4gIH1cbn1cblxuLy8gVE9ETzogc2V0IEJ5dGVCdWZmZXIgdG8gYmVzdCBhdmFpbGFibGUgYmFja2luZ1xudXRpbC5CeXRlQnVmZmVyID0gQnl0ZVN0cmluZ0J1ZmZlcjtcblxuLyoqIEJ1ZmZlciB3L0JpbmFyeVN0cmluZyBiYWNraW5nICovXG5cbi8qKlxuICogQ29uc3RydWN0b3IgZm9yIGEgYmluYXJ5IHN0cmluZyBiYWNrZWQgYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIFtiXSB0aGUgYnl0ZXMgdG8gd3JhcCAoZWl0aGVyIGVuY29kZWQgYXMgc3RyaW5nLCBvbmUgYnl0ZSBwZXJcbiAqICAgICAgICAgIGNoYXJhY3Rlciwgb3IgYXMgYW4gQXJyYXlCdWZmZXIgb3IgVHlwZWQgQXJyYXkpLlxuICovXG5mdW5jdGlvbiBCeXRlU3RyaW5nQnVmZmVyKGIpIHtcbiAgLy8gVE9ETzogdXBkYXRlIHRvIG1hdGNoIERhdGFCdWZmZXIgQVBJXG5cbiAgLy8gdGhlIGRhdGEgaW4gdGhpcyBidWZmZXJcbiAgdGhpcy5kYXRhID0gJyc7XG4gIC8vIHRoZSBwb2ludGVyIGZvciByZWFkaW5nIGZyb20gdGhpcyBidWZmZXJcbiAgdGhpcy5yZWFkID0gMDtcblxuICBpZih0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmRhdGEgPSBiO1xuICB9IGVsc2UgaWYodXRpbC5pc0FycmF5QnVmZmVyKGIpIHx8IHV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoYikpIHtcbiAgICBpZih0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBiIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICB0aGlzLmRhdGEgPSBiLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29udmVydCBuYXRpdmUgYnVmZmVyIHRvIGZvcmdlIGJ1ZmZlclxuICAgICAgLy8gRklYTUU6IHN1cHBvcnQgbmF0aXZlIGJ1ZmZlcnMgaW50ZXJuYWxseSBpbnN0ZWFkXG4gICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycik7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRoaXMucHV0Qnl0ZShhcnJbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYoYiBpbnN0YW5jZW9mIEJ5dGVTdHJpbmdCdWZmZXIgfHxcbiAgICAodHlwZW9mIGIgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiLmRhdGEgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIGIucmVhZCA9PT0gJ251bWJlcicpKSB7XG4gICAgLy8gY29weSBleGlzdGluZyBidWZmZXJcbiAgICB0aGlzLmRhdGEgPSBiLmRhdGE7XG4gICAgdGhpcy5yZWFkID0gYi5yZWFkO1xuICB9XG5cbiAgLy8gdXNlZCBmb3Igdjggb3B0aW1pemF0aW9uXG4gIHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoID0gMDtcbn1cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlciA9IEJ5dGVTdHJpbmdCdWZmZXI7XG5cbi8qIE5vdGU6IFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIGZvciBWOC1iYXNlZCBicm93c2Vycy4gV2hlbiBWOCBjb25jYXRlbmF0ZXNcbiAgYSBzdHJpbmcsIHRoZSBzdHJpbmdzIGFyZSBvbmx5IGpvaW5lZCBsb2dpY2FsbHkgdXNpbmcgYSBcImNvbnMgc3RyaW5nXCIgb3JcbiAgXCJjb25zdHJ1Y3RlZC9jb25jYXRlbmF0ZWQgc3RyaW5nXCIuIFRoZXNlIGNvbnRhaW5lcnMga2VlcCByZWZlcmVuY2VzIHRvIG9uZVxuICBhbm90aGVyIGFuZCBjYW4gcmVzdWx0IGluIHZlcnkgbGFyZ2UgbWVtb3J5IHVzYWdlLiBGb3IgZXhhbXBsZSwgaWYgYSAyTUJcbiAgc3RyaW5nIGlzIGNvbnN0cnVjdGVkIGJ5IGNvbmNhdGVuYXRpbmcgNCBieXRlcyB0b2dldGhlciBhdCBhIHRpbWUsIHRoZVxuICBtZW1vcnkgdXNhZ2Ugd2lsbCBiZSB+NDRNQjsgc28gfjIyeCBpbmNyZWFzZS4gVGhlIHN0cmluZ3MgYXJlIG9ubHkgam9pbmVkXG4gIHRvZ2V0aGVyIHdoZW4gYW4gb3BlcmF0aW9uIHJlcXVpcmluZyB0aGVpciBqb2luaW5nIHRha2VzIHBsYWNlLCBzdWNoIGFzXG4gIHN1YnN0cigpLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGFkZGluZyBkYXRhIHRvIHRoaXMgYnVmZmVyIHRvIGVuc3VyZVxuICB0aGVzZSB0eXBlcyBvZiBzdHJpbmdzIGFyZSBwZXJpb2RpY2FsbHkgam9pbmVkIHRvIHJlZHVjZSB0aGUgbWVtb3J5XG4gIGZvb3RwcmludC4gKi9cbnZhciBfTUFYX0NPTlNUUlVDVEVEX1NUUklOR19MRU5HVEggPSA0MDk2O1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5fb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggKz0geDtcbiAgaWYodGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPiBfTUFYX0NPTlNUUlVDVEVEX1NUUklOR19MRU5HVEgpIHtcbiAgICAvLyB0aGlzIHN1YnN0cigpIHNob3VsZCBjYXVzZSB0aGUgY29uc3RydWN0ZWQgc3RyaW5nIHRvIGpvaW5cbiAgICB0aGlzLmRhdGEuc3Vic3RyKDAsIDEpO1xuICAgIHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aCAtIHRoaXMucmVhZDtcbn07XG5cbi8qKlxuICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGlzIGJ1ZmZlciBpcyBlbXB0eS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBidWZmZXIgaXMgZW1wdHksIGZhbHNlIGlmIG5vdC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aCgpIDw9IDA7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGUgPSBmdW5jdGlvbihiKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoYikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlciBOIHRpbWVzLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdmFsdWUgYiB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5maWxsV2l0aEJ5dGUgPSBmdW5jdGlvbihiLCBuKSB7XG4gIGIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpO1xuICB2YXIgZCA9IHRoaXMuZGF0YTtcbiAgd2hpbGUobiA+IDApIHtcbiAgICBpZihuICYgMSkge1xuICAgICAgZCArPSBiO1xuICAgIH1cbiAgICBuID4+Pj0gMTtcbiAgICBpZihuID4gMCkge1xuICAgICAgYiArPSBiO1xuICAgIH1cbiAgfVxuICB0aGlzLmRhdGEgPSBkO1xuICB0aGlzLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nKG4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIChhcyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZykgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZXMgPSBmdW5jdGlvbihieXRlcykge1xuICB0aGlzLmRhdGEgKz0gYnl0ZXM7XG4gIHRoaXMuX29wdGltaXplQ29uc3RydWN0ZWRTdHJpbmcoYnl0ZXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBVVEYtMTYgZW5jb2RlZCBzdHJpbmcgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0U3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKHV0aWwuZW5jb2RlVXRmOChzdHIpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MTYgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MjQgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAzMi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAzMi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDMyID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMjQgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MTZMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMjQtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMjQtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNExlID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMzItYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMzItYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMkxlID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAyNCAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhbiBuLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIG4tYml0IGludGVnZXIuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50ID0gZnVuY3Rpb24oaSwgbikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHZhciBieXRlcyA9ICcnO1xuICBkbyB7XG4gICAgbiAtPSA4O1xuICAgIGJ5dGVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGkgPj4gbikgJiAweEZGKTtcbiAgfSB3aGlsZShuID4gMCk7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKGJ5dGVzKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIHNpZ25lZCBuLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuIFR3bydzXG4gKiBjb21wbGVtZW50IHJlcHJlc2VudGF0aW9uIGlzIHVzZWQuXG4gKlxuICogQHBhcmFtIGkgdGhlIG4tYml0IGludGVnZXIuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0U2lnbmVkSW50ID0gZnVuY3Rpb24oaSwgbikge1xuICAvLyBwdXRJbnQgY2hlY2tzIG5cbiAgaWYoaSA8IDApIHtcbiAgICBpICs9IDIgPDwgKG4gLSAxKTtcbiAgfVxuICByZXR1cm4gdGhpcy5wdXRJbnQoaSwgbik7XG59O1xuXG4vKipcbiAqIFB1dHMgdGhlIGdpdmVuIGJ1ZmZlciBpbnRvIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBidWZmZXIgdGhlIGJ1ZmZlciB0byBwdXQgaW50byB0aGlzIG9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhidWZmZXIuZ2V0Qnl0ZXMoKSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBieXRlIGZyb20gdGhpcyBidWZmZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIgYnkgMS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCsrKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQxNiBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDIuXG4gKlxuICogQHJldHVybiB0aGUgdWludDE2LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDE2ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIDw8IDE2IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSk7XG4gIHRoaXMucmVhZCArPSAzO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQzMiBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDQuXG4gKlxuICogQHJldHVybiB0aGUgd29yZC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIDw8IDI0IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCAxNiBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMykpO1xuICB0aGlzLnJlYWQgKz0gNDtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDgpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNExlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDE2KTtcbiAgdGhpcy5yZWFkICs9IDM7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDMyIGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgNC5cbiAqXG4gKiBAcmV0dXJuIHRoZSB3b3JkLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDMyTGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikgPDwgMTYgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDMpIDw8IDI0KTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGVcbiAqIHJlYWQgcG9pbnRlciBieSBjZWlsKG4vOCkuXG4gKlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludCA9IGZ1bmN0aW9uKG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgcnZhbCA9IDA7XG4gIGRvIHtcbiAgICAvLyBUT0RPOiBVc2UgKHJ2YWwgKiAweDEwMCkgaWYgYWRkaW5nIHN1cHBvcnQgZm9yIDMzIHRvIDUzIGJpdHMuXG4gICAgcnZhbCA9IChydmFsIDw8IDgpICsgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKyspO1xuICAgIG4gLT0gODtcbiAgfSB3aGlsZShuID4gMCk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgc2lnbmVkIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLCB1c2luZ1xuICogdHdvJ3MgY29tcGxlbWVudCwgYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIgYnkgbi84LlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRTaWduZWRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIC8vIGdldEludCBjaGVja3MgblxuICB2YXIgeCA9IHRoaXMuZ2V0SW50KG4pO1xuICB2YXIgbWF4ID0gMiA8PCAobiAtIDIpO1xuICBpZih4ID49IG1heCkge1xuICAgIHggLT0gbWF4IDw8IDE7XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuXG4vKipcbiAqIFJlYWRzIGJ5dGVzIG91dCBhcyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBhbmQgY2xlYXJzIHRoZW0gZnJvbSB0aGVcbiAqIGJ1ZmZlci4gTm90ZSB0aGF0IHRoZSByZXN1bHRpbmcgc3RyaW5nIGlzIGJpbmFyeSBlbmNvZGVkIChpbiBub2RlLmpzIHRoaXNcbiAqIGVuY29kaW5nIGlzIHJlZmVycmVkIHRvIGFzIGBiaW5hcnlgLCBpdCBpcyAqbm90KiBgdXRmOGApLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQsIHVuZGVmaW5lZCBvciBudWxsIGZvciBhbGwuXG4gKlxuICogQHJldHVybiBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBydmFsO1xuICBpZihjb3VudCkge1xuICAgIC8vIHJlYWQgY291bnQgYnl0ZXNcbiAgICBjb3VudCA9IE1hdGgubWluKHRoaXMubGVuZ3RoKCksIGNvdW50KTtcbiAgICBydmFsID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpO1xuICAgIHRoaXMucmVhZCArPSBjb3VudDtcbiAgfSBlbHNlIGlmKGNvdW50ID09PSAwKSB7XG4gICAgcnZhbCA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgYWxsIGJ5dGVzLCBvcHRpbWl6ZSB0byBvbmx5IGNvcHkgd2hlbiBuZWVkZWRcbiAgICBydmFsID0gKHRoaXMucmVhZCA9PT0gMCkgPyB0aGlzLmRhdGEgOiB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJ5dGVzIGZyb20gdGhpcyBidWZmZXIgd2l0aG91dFxuICogbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2V0LCBvbWl0IHRvIGdldCBhbGwuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyBmdWxsIG9mIGJpbmFyeSBlbmNvZGVkIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbihjb3VudCkge1xuICByZXR1cm4gKHR5cGVvZihjb3VudCkgPT09ICd1bmRlZmluZWQnID9cbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKSA6XG4gICAgdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIGkpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24oaSwgYikge1xuICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc3Vic3RyKDAsIHRoaXMucmVhZCArIGkpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpICtcbiAgICB0aGlzLmRhdGEuc3Vic3RyKHRoaXMucmVhZCArIGkgKyAxKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGxhc3QgYnl0ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGxhc3QgYnl0ZS5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLmRhdGEubGVuZ3RoIC0gMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNvcHkuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYyA9IHV0aWwuY3JlYXRlQnVmZmVyKHRoaXMuZGF0YSk7XG4gIGMucmVhZCA9IHRoaXMucmVhZDtcbiAgcmV0dXJuIGM7XG59O1xuXG4vKipcbiAqIENvbXBhY3RzIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLnJlYWQgPiAwKSB7XG4gICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCk7XG4gICAgdGhpcy5yZWFkID0gMDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kYXRhID0gJyc7XG4gIHRoaXMucmVhZCA9IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTaG9ydGVucyB0aGlzIGJ1ZmZlciBieSB0cmltaW5nIGJ5dGVzIG9mZiBvZiB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHRyaW0gb2ZmLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihjb3VudCkge1xuICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgdGhpcy5sZW5ndGgoKSAtIGNvdW50KTtcbiAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnN1YnN0cih0aGlzLnJlYWQsIGxlbik7XG4gIHRoaXMucmVhZCA9IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGJ1ZmZlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gJyc7XG4gIGZvcih2YXIgaSA9IHRoaXMucmVhZDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBiID0gdGhpcy5kYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYoYiA8IDE2KSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBiLnRvU3RyaW5nKDE2KTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBVVEYtMTYgc3RyaW5nIChzdGFuZGFyZCBKYXZhU2NyaXB0IHN0cmluZykuXG4gKlxuICogQHJldHVybiBhIFVURi0xNiBzdHJpbmcuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHV0aWwuZGVjb2RlVXRmOCh0aGlzLmJ5dGVzKCkpO1xufTtcblxuLyoqIEVuZCBCdWZmZXIgdy9CaW5hcnlTdHJpbmcgYmFja2luZyAqL1xuXG4vKiogQnVmZmVyIHcvVUludDhBcnJheSBiYWNraW5nICovXG5cbi8qKlxuICogRklYTUU6IEV4cGVyaW1lbnRhbC4gRG8gbm90IHVzZSB5ZXQuXG4gKlxuICogQ29uc3RydWN0b3IgZm9yIGFuIEFycmF5QnVmZmVyLWJhY2tlZCBieXRlIGJ1ZmZlci5cbiAqXG4gKiBUaGUgYnVmZmVyIG1heSBiZSBjb25zdHJ1Y3RlZCBmcm9tIGEgc3RyaW5nLCBhbiBBcnJheUJ1ZmZlciwgRGF0YVZpZXcsIG9yIGFcbiAqIFR5cGVkQXJyYXkuXG4gKlxuICogSWYgYSBzdHJpbmcgaXMgZ2l2ZW4sIGl0cyBlbmNvZGluZyBzaG91bGQgYmUgcHJvdmlkZWQgYXMgYW4gb3B0aW9uLFxuICogb3RoZXJ3aXNlIGl0IHdpbGwgZGVmYXVsdCB0byAnYmluYXJ5Jy4gQSAnYmluYXJ5JyBzdHJpbmcgaXMgZW5jb2RlZCBzdWNoXG4gKiB0aGF0IGVhY2ggY2hhcmFjdGVyIGlzIG9uZSBieXRlIGluIGxlbmd0aCBhbmQgc2l6ZS5cbiAqXG4gKiBJZiBhbiBBcnJheUJ1ZmZlciwgRGF0YVZpZXcsIG9yIFR5cGVkQXJyYXkgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgdXNlZFxuICogKmRpcmVjdGx5KiB3aXRob3V0IGFueSBjb3B5aW5nLiBOb3RlIHRoYXQsIGlmIGEgd3JpdGUgdG8gdGhlIGJ1ZmZlciByZXF1aXJlc1xuICogbW9yZSBzcGFjZSwgdGhlIGJ1ZmZlciB3aWxsIGFsbG9jYXRlIGEgbmV3IGJhY2tpbmcgQXJyYXlCdWZmZXIgdG9cbiAqIGFjY29tbW9kYXRlLiBUaGUgc3RhcnRpbmcgcmVhZCBhbmQgd3JpdGUgb2Zmc2V0cyBmb3IgdGhlIGJ1ZmZlciBtYXkgYmVcbiAqIGdpdmVuIGFzIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIFtiXSB0aGUgaW5pdGlhbCBieXRlcyBmb3IgdGhpcyBidWZmZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbcmVhZE9mZnNldF0gdGhlIHN0YXJ0aW5nIHJlYWQgb2Zmc2V0IHRvIHVzZSAoZGVmYXVsdDogMCkuXG4gKiAgICAgICAgICBbd3JpdGVPZmZzZXRdIHRoZSBzdGFydGluZyB3cml0ZSBvZmZzZXQgdG8gdXNlIChkZWZhdWx0OiB0aGVcbiAqICAgICAgICAgICAgbGVuZ3RoIG9mIHRoZSBmaXJzdCBwYXJhbWV0ZXIpLlxuICogICAgICAgICAgW2dyb3dTaXplXSB0aGUgbWluaW11bSBhbW91bnQsIGluIGJ5dGVzLCB0byBncm93IHRoZSBidWZmZXIgYnkgdG9cbiAqICAgICAgICAgICAgYWNjb21tb2RhdGUgd3JpdGVzIChkZWZhdWx0OiAxMDI0KS5cbiAqICAgICAgICAgIFtlbmNvZGluZ10gdGhlIGVuY29kaW5nICgnYmluYXJ5JywgJ3V0ZjgnLCAndXRmMTYnLCAnaGV4JykgZm9yIHRoZVxuICogICAgICAgICAgICBmaXJzdCBwYXJhbWV0ZXIsIGlmIGl0IGlzIGEgc3RyaW5nIChkZWZhdWx0OiAnYmluYXJ5JykuXG4gKi9cbmZ1bmN0aW9uIERhdGFCdWZmZXIoYiwgb3B0aW9ucykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gcG9pbnRlcnMgZm9yIHJlYWQgZnJvbS93cml0ZSB0byBidWZmZXJcbiAgdGhpcy5yZWFkID0gb3B0aW9ucy5yZWFkT2Zmc2V0IHx8IDA7XG4gIHRoaXMuZ3Jvd1NpemUgPSBvcHRpb25zLmdyb3dTaXplIHx8IDEwMjQ7XG5cbiAgdmFyIGlzQXJyYXlCdWZmZXIgPSB1dGlsLmlzQXJyYXlCdWZmZXIoYik7XG4gIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IHV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoYik7XG4gIGlmKGlzQXJyYXlCdWZmZXIgfHwgaXNBcnJheUJ1ZmZlclZpZXcpIHtcbiAgICAvLyB1c2UgQXJyYXlCdWZmZXIgZGlyZWN0bHlcbiAgICBpZihpc0FycmF5QnVmZmVyKSB7XG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcoYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IGFkanVzdCByZWFkL3dyaXRlIG9mZnNldCBiYXNlZCBvbiB0aGUgdHlwZSBvZiB2aWV3XG4gICAgICAvLyBvciBzcGVjaWZ5IHRoYXQgdGhpcyBtdXN0IGJlIGRvbmUgaW4gdGhlIG9wdGlvbnMgLi4uIHRoYXQgdGhlXG4gICAgICAvLyBvZmZzZXRzIGFyZSBieXRlLWJhc2VkXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcoYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgdGhpcy53cml0ZSA9ICgnd3JpdGVPZmZzZXQnIGluIG9wdGlvbnMgP1xuICAgICAgb3B0aW9ucy53cml0ZU9mZnNldCA6IHRoaXMuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBpbml0aWFsaXplIHRvIGVtcHR5IGFycmF5IGJ1ZmZlciBhbmQgYWRkIGFueSBnaXZlbiBieXRlcyB1c2luZyBwdXRCeXRlc1xuICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgdGhpcy53cml0ZSA9IDA7XG5cbiAgaWYoYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnB1dEJ5dGVzKGIpO1xuICB9XG5cbiAgaWYoJ3dyaXRlT2Zmc2V0JyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy53cml0ZSA9IG9wdGlvbnMud3JpdGVPZmZzZXQ7XG4gIH1cbn1cbnV0aWwuRGF0YUJ1ZmZlciA9IERhdGFCdWZmZXI7XG5cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUgLSB0aGlzLnJlYWQ7XG59O1xuXG4vKipcbiAqIEdldHMgd2hldGhlciBvciBub3QgdGhpcyBidWZmZXIgaXMgZW1wdHkuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoaXMgYnVmZmVyIGlzIGVtcHR5LCBmYWxzZSBpZiBub3QuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGgoKSA8PSAwO1xufTtcblxuLyoqXG4gKiBFbnN1cmVzIHRoaXMgYnVmZmVyIGhhcyBlbm91Z2ggZW1wdHkgc3BhY2UgdG8gYWNjb21tb2RhdGUgdGhlIGdpdmVuIG51bWJlclxuICogb2YgYnl0ZXMuIEFuIG9wdGlvbmFsIHBhcmFtZXRlciBtYXkgYmUgZ2l2ZW4gdGhhdCBpbmRpY2F0ZXMgYSBtaW5pbXVtXG4gKiBhbW91bnQgdG8gZ3JvdyB0aGUgYnVmZmVyIGlmIG5lY2Vzc2FyeS4gSWYgdGhlIHBhcmFtZXRlciBpcyBub3QgZ2l2ZW4sXG4gKiB0aGUgYnVmZmVyIHdpbGwgYmUgZ3Jvd24gYnkgc29tZSBwcmV2aW91c2x5LXNwZWNpZmllZCBkZWZhdWx0IGFtb3VudFxuICogb3IgaGV1cmlzdGljLlxuICpcbiAqIEBwYXJhbSBhbW91bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byBhY2NvbW1vZGF0ZS5cbiAqIEBwYXJhbSBbZ3Jvd1NpemVdIHRoZSBtaW5pbXVtIGFtb3VudCwgaW4gYnl0ZXMsIHRvIGdyb3cgdGhlIGJ1ZmZlciBieSBpZlxuICogICAgICAgICAgbmVjZXNzYXJ5LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmFjY29tbW9kYXRlID0gZnVuY3Rpb24oYW1vdW50LCBncm93U2l6ZSkge1xuICBpZih0aGlzLmxlbmd0aCgpID49IGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyb3dTaXplID0gTWF0aC5tYXgoZ3Jvd1NpemUgfHwgdGhpcy5ncm93U2l6ZSwgYW1vdW50KTtcblxuICAvLyBncm93IGJ1ZmZlclxuICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgdGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy5kYXRhLmJ5dGVPZmZzZXQsIHRoaXMuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKCkgKyBncm93U2l6ZSk7XG4gIGRzdC5zZXQoc3JjKTtcbiAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGRzdC5idWZmZXIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlID0gZnVuY3Rpb24oYikge1xuICB0aGlzLmFjY29tbW9kYXRlKDEpO1xuICB0aGlzLmRhdGEuc2V0VWludDgodGhpcy53cml0ZSsrLCBiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGluIHRoaXMgYnVmZmVyIE4gdGltZXMuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyBvZiB2YWx1ZSBiIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmZpbGxXaXRoQnl0ZSA9IGZ1bmN0aW9uKGIsIG4pIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZShuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHRoaXMuZGF0YS5zZXRVaW50OChiKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBieXRlcyBpbiB0aGlzIGJ1ZmZlci4gVGhlIGJ5dGVzIG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZywgYW5cbiAqIEFycmF5QnVmZmVyLCBhIERhdGFWaWV3LCBvciBhIFR5cGVkQXJyYXkuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBwdXQuXG4gKiBAcGFyYW0gW2VuY29kaW5nXSB0aGUgZW5jb2RpbmcgZm9yIHRoZSBmaXJzdCBwYXJhbWV0ZXIgKCdiaW5hcnknLCAndXRmOCcsXG4gKiAgICAgICAgICAndXRmMTYnLCAnaGV4JyksIGlmIGl0IGlzIGEgc3RyaW5nIChkZWZhdWx0OiAnYmluYXJ5JykuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlcyA9IGZ1bmN0aW9uKGJ5dGVzLCBlbmNvZGluZykge1xuICBpZih1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGJ5dGVzKSkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheShieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgIHZhciBsZW4gPSBzcmMuYnl0ZUxlbmd0aCAtIHNyYy5ieXRlT2Zmc2V0O1xuICAgIHRoaXMuYWNjb21tb2RhdGUobGVuKTtcbiAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMud3JpdGUgKz0gbGVuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYodXRpbC5pc0FycmF5QnVmZmVyKGJ5dGVzKSkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgdGhpcy5hY2NvbW1vZGF0ZShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIpO1xuICAgIGRzdC5zZXQoc3JjLCB0aGlzLndyaXRlKTtcbiAgICB0aGlzLndyaXRlICs9IHNyYy5ieXRlTGVuZ3RoO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gYnl0ZXMgaXMgYSB1dGlsLkRhdGFCdWZmZXIgb3IgZXF1aXZhbGVudFxuICBpZihieXRlcyBpbnN0YW5jZW9mIHV0aWwuRGF0YUJ1ZmZlciB8fFxuICAgICh0eXBlb2YgYnl0ZXMgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIGJ5dGVzLnJlYWQgPT09ICdudW1iZXInICYmIHR5cGVvZiBieXRlcy53cml0ZSA9PT0gJ251bWJlcicgJiZcbiAgICB1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGJ5dGVzLmRhdGEpKSkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheShieXRlcy5kYXRhLmJ5dGVMZW5ndGgsIGJ5dGVzLnJlYWQsIGJ5dGVzLmxlbmd0aCgpKTtcbiAgICB0aGlzLmFjY29tbW9kYXRlKHNyYy5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuZGF0YS5ieXRlTGVuZ3RoLCB0aGlzLndyaXRlKTtcbiAgICBkc3Quc2V0KHNyYyk7XG4gICAgdGhpcy53cml0ZSArPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmKGJ5dGVzIGluc3RhbmNlb2YgdXRpbC5CeXRlU3RyaW5nQnVmZmVyKSB7XG4gICAgLy8gY29weSBiaW5hcnkgc3RyaW5nIGFuZCBwcm9jZXNzIGFzIHRoZSBzYW1lIGFzIGEgc3RyaW5nIHBhcmFtZXRlciBiZWxvd1xuICAgIGJ5dGVzID0gYnl0ZXMuZGF0YTtcbiAgICBlbmNvZGluZyA9ICdiaW5hcnknO1xuICB9XG5cbiAgLy8gc3RyaW5nIGNvbnZlcnNpb25cbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAnYmluYXJ5JztcbiAgaWYodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIHZhciB2aWV3O1xuXG4gICAgLy8gZGVjb2RlIGZyb20gc3RyaW5nXG4gICAgaWYoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgICB0aGlzLmFjY29tbW9kYXRlKE1hdGguY2VpbChieXRlcy5sZW5ndGggLyAyKSk7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlICs9IHV0aWwuYmluYXJ5LmhleC5kZWNvZGUoYnl0ZXMsIHZpZXcsIHRoaXMud3JpdGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShNYXRoLmNlaWwoYnl0ZXMubGVuZ3RoIC8gNCkgKiAzKTtcbiAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgIHRoaXMud3JpdGUgKz0gdXRpbC5iaW5hcnkuYmFzZTY0LmRlY29kZShieXRlcywgdmlldywgdGhpcy53cml0ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBlbmNvZGUgdGV4dCBhcyBVVEYtOCBieXRlc1xuICAgIGlmKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgIC8vIGVuY29kZSBhcyBVVEYtOCB0aGVuIGRlY29kZSBzdHJpbmcgYXMgcmF3IGJpbmFyeVxuICAgICAgYnl0ZXMgPSB1dGlsLmVuY29kZVV0ZjgoYnl0ZXMpO1xuICAgICAgZW5jb2RpbmcgPSAnYmluYXJ5JztcbiAgICB9XG5cbiAgICAvLyBkZWNvZGUgc3RyaW5nIGFzIHJhdyBiaW5hcnlcbiAgICBpZihlbmNvZGluZyA9PT0gJ2JpbmFyeScgfHwgZW5jb2RpbmcgPT09ICdyYXcnKSB7XG4gICAgICAvLyBvbmUgYnl0ZSBwZXIgY2hhcmFjdGVyXG4gICAgICB0aGlzLmFjY29tbW9kYXRlKGJ5dGVzLmxlbmd0aCk7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlICs9IHV0aWwuYmluYXJ5LnJhdy5kZWNvZGUodmlldyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBlbmNvZGUgdGV4dCBhcyBVVEYtMTYgYnl0ZXNcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjE2Jykge1xuICAgICAgLy8gdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXJcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUoYnl0ZXMubGVuZ3RoICogMik7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLnRleHQudXRmMTYuZW5jb2RlKHZpZXcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG5cbiAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyOiAnICsgYnl0ZXMpO1xufTtcblxuLyoqXG4gKiBQdXRzIHRoZSBnaXZlbiBidWZmZXIgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIHRoZSBidWZmZXIgdG8gcHV0IGludG8gdGhpcyBvbmUuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdGhpcy5wdXRCeXRlcyhidWZmZXIpO1xuICBidWZmZXIuY2xlYXIoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzdHJpbmcgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gcHV0LlxuICogQHBhcmFtIFtlbmNvZGluZ10gdGhlIGVuY29kaW5nIGZvciB0aGUgc3RyaW5nIChkZWZhdWx0OiAndXRmMTYnKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhzdHIsICd1dGYxNicpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMTYtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMTYtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQxNiA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgyKTtcbiAgdGhpcy5kYXRhLnNldEludDE2KHRoaXMud3JpdGUsIGkpO1xuICB0aGlzLndyaXRlICs9IDI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMjQtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMjQtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNCA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgzKTtcbiAgdGhpcy5kYXRhLnNldEludDE2KHRoaXMud3JpdGUsIGkgPj4gOCAmIDB4RkZGRik7XG4gIHRoaXMuZGF0YS5zZXRJbnQ4KHRoaXMud3JpdGUsIGkgPj4gMTYgJiAweEZGKTtcbiAgdGhpcy53cml0ZSArPSAzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MzIgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoNCk7XG4gIHRoaXMuZGF0YS5zZXRJbnQzMih0aGlzLndyaXRlLCBpKTtcbiAgdGhpcy53cml0ZSArPSA0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MTZMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgyKTtcbiAgdGhpcy5kYXRhLnNldEludDE2KHRoaXMud3JpdGUsIGksIHRydWUpO1xuICB0aGlzLndyaXRlICs9IDI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMjQtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMjQtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNExlID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDMpO1xuICB0aGlzLmRhdGEuc2V0SW50OCh0aGlzLndyaXRlLCBpID4+IDE2ICYgMHhGRik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpID4+IDggJiAweEZGRkYsIHRydWUpO1xuICB0aGlzLndyaXRlICs9IDM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMzItYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMzItYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMkxlID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDQpO1xuICB0aGlzLmRhdGEuc2V0SW50MzIodGhpcy53cml0ZSwgaSwgdHJ1ZSk7XG4gIHRoaXMud3JpdGUgKz0gNDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYW4gbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB0aGlzLmFjY29tbW9kYXRlKG4gLyA4KTtcbiAgZG8ge1xuICAgIG4gLT0gODtcbiAgICB0aGlzLmRhdGEuc2V0SW50OCh0aGlzLndyaXRlKyssIChpID4+IG4pICYgMHhGRik7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIHNpZ25lZCBuLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuIFR3bydzXG4gKiBjb21wbGVtZW50IHJlcHJlc2VudGF0aW9uIGlzIHVzZWQuXG4gKlxuICogQHBhcmFtIGkgdGhlIG4tYml0IGludGVnZXIuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRTaWduZWRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdGhpcy5hY2NvbW1vZGF0ZShuIC8gOCk7XG4gIGlmKGkgPCAwKSB7XG4gICAgaSArPSAyIDw8IChuIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMucHV0SW50KGksIG4pO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBmcm9tIHRoaXMgYnVmZmVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IDEuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQrKyk7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5yZWFkKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQgKyAyKSk7XG4gIHRoaXMucmVhZCArPSAzO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQzMiBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDQuXG4gKlxuICogQHJldHVybiB0aGUgd29yZC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQzMih0aGlzLnJlYWQpO1xuICB0aGlzLnJlYWQgKz0gNDtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCwgdHJ1ZSk7XG4gIHRoaXMucmVhZCArPSAyO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQyNCBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDMuXG4gKlxuICogQHJldHVybiB0aGUgdWludDI0LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDI0TGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKSBeXG4gICAgdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCArIDEsIHRydWUpIDw8IDgpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzJMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQzMih0aGlzLnJlYWQsIHRydWUpO1xuICB0aGlzLnJlYWQgKz0gNDtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gbi1iaXQgaW50ZWdlciBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZVxuICogcmVhZCBwb2ludGVyIGJ5IG4vOC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50ID0gZnVuY3Rpb24obikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHZhciBydmFsID0gMDtcbiAgZG8ge1xuICAgIC8vIFRPRE86IFVzZSAocnZhbCAqIDB4MTAwKSBpZiBhZGRpbmcgc3VwcG9ydCBmb3IgMzMgdG8gNTMgYml0cy5cbiAgICBydmFsID0gKHJ2YWwgPDwgOCkgKyB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQrKyk7XG4gICAgbiAtPSA4O1xuICB9IHdoaWxlKG4gPiAwKTtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIsIHVzaW5nXG4gKiB0d28ncyBjb21wbGVtZW50LCBhbmQgYWR2YW5jZXMgdGhlIHJlYWQgcG9pbnRlciBieSBuLzguXG4gKlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldFNpZ25lZEludCA9IGZ1bmN0aW9uKG4pIHtcbiAgLy8gZ2V0SW50IGNoZWNrcyBuXG4gIHZhciB4ID0gdGhpcy5nZXRJbnQobik7XG4gIHZhciBtYXggPSAyIDw8IChuIC0gMik7XG4gIGlmKHggPj0gbWF4KSB7XG4gICAgeCAtPSBtYXggPDwgMTtcbiAgfVxuICByZXR1cm4geDtcbn07XG5cbi8qKlxuICogUmVhZHMgYnl0ZXMgb3V0IGFzIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nIGFuZCBjbGVhcnMgdGhlbSBmcm9tIHRoZVxuICogYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQsIHVuZGVmaW5lZCBvciBudWxsIGZvciBhbGwuXG4gKlxuICogQHJldHVybiBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZSB0aGlzIG1ldGhvZCwgaXQgaXMgcG9vcmx5IG5hbWVkIGFuZFxuICAvLyB0aGlzLnRvU3RyaW5nKCdiaW5hcnknKSByZXBsYWNlcyBpdFxuICAvLyBhZGQgYSB0b1R5cGVkQXJyYXkoKS90b0FycmF5QnVmZmVyKCkgZnVuY3Rpb25cbiAgdmFyIHJ2YWw7XG4gIGlmKGNvdW50KSB7XG4gICAgLy8gcmVhZCBjb3VudCBieXRlc1xuICAgIGNvdW50ID0gTWF0aC5taW4odGhpcy5sZW5ndGgoKSwgY291bnQpO1xuICAgIHJ2YWwgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLnJlYWQgKyBjb3VudCk7XG4gICAgdGhpcy5yZWFkICs9IGNvdW50O1xuICB9IGVsc2UgaWYoY291bnQgPT09IDApIHtcbiAgICBydmFsID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBhbGwgYnl0ZXMsIG9wdGltaXplIHRvIG9ubHkgY29weSB3aGVuIG5lZWRlZFxuICAgIHJ2YWwgPSAodGhpcy5yZWFkID09PSAwKSA/IHRoaXMuZGF0YSA6IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiB0aGUgYnl0ZXMgZnJvbSB0aGlzIGJ1ZmZlciB3aXRob3V0XG4gKiBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byBnZXQsIG9taXQgdG8gZ2V0IGFsbC5cbiAqXG4gKiBAcmV0dXJuIGEgc3RyaW5nIGZ1bGwgb2YgYmluYXJ5IGVuY29kZWQgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZSB0aGlzIG1ldGhvZCwgaXQgaXMgcG9vcmx5IG5hbWVkLCBhZGQgXCJnZXRTdHJpbmcoKVwiXG4gIHJldHVybiAodHlwZW9mKGNvdW50KSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpIDpcbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLnJlYWQgKyBjb3VudCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMucmVhZCArIGkpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24oaSwgYikge1xuICB0aGlzLmRhdGEuc2V0VWludDgoaSwgYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGJ5dGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsYXN0IGJ5dGUuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMud3JpdGUgLSAxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgY29weS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgdXRpbC5EYXRhQnVmZmVyKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDb21wYWN0cyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5yZWFkID4gMCkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLnJlYWQpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QpO1xuICAgIHRoaXMud3JpdGUgLT0gdGhpcy5yZWFkO1xuICAgIHRoaXMucmVhZCA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNob3J0ZW5zIHRoaXMgYnVmZmVyIGJ5IHRyaW1pbmcgYnl0ZXMgb2ZmIG9mIHRoZSBlbmQgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gdHJpbSBvZmYuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHRoaXMud3JpdGUgPSBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aCgpIC0gY291bnQpO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbih0aGlzLnJlYWQsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHJldHVybiBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9ICcnO1xuICBmb3IodmFyIGkgPSB0aGlzLnJlYWQ7IGkgPCB0aGlzLmRhdGEuYnl0ZUxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGIgPSB0aGlzLmRhdGEuZ2V0VWludDgoaSk7XG4gICAgaWYoYiA8IDE2KSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBiLnRvU3RyaW5nKDE2KTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBzdHJpbmcsIHVzaW5nIHRoZSBnaXZlbiBlbmNvZGluZy4gSWYgbm9cbiAqIGVuY29kaW5nIGlzIGdpdmVuLCAndXRmOCcgKFVURi04KSBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyB0byB1c2U6ICdiaW5hcnknLCAndXRmOCcsICd1dGYxNicsICdoZXgnLFxuICogICAgICAgICAgJ2Jhc2U2NCcgKGRlZmF1bHQ6ICd1dGY4JykuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSwgdGhpcy5yZWFkLCB0aGlzLmxlbmd0aCgpKTtcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gZW5jb2RlIHRvIHN0cmluZ1xuICBpZihlbmNvZGluZyA9PT0gJ2JpbmFyeScgfHwgZW5jb2RpbmcgPT09ICdyYXcnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LnJhdy5lbmNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LmhleC5lbmNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUodmlldyk7XG4gIH1cblxuICAvLyBkZWNvZGUgdG8gdGV4dFxuICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgcmV0dXJuIHV0aWwudGV4dC51dGY4LmRlY29kZSh2aWV3KTtcbiAgfVxuICBpZihlbmNvZGluZyA9PT0gJ3V0ZjE2Jykge1xuICAgIHJldHVybiB1dGlsLnRleHQudXRmMTYuZGVjb2RlKHZpZXcpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xufTtcblxuLyoqIEVuZCBCdWZmZXIgdy9VSW50OEFycmF5IGJhY2tpbmcgKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgYnVmZmVyIHRoYXQgc3RvcmVzIGJ5dGVzLiBBIHZhbHVlIG1heSBiZSBnaXZlbiB0byBwb3B1bGF0ZSB0aGVcbiAqIGJ1ZmZlciB3aXRoIGRhdGEuIFRoaXMgdmFsdWUgY2FuIGVpdGhlciBiZSBzdHJpbmcgb2YgZW5jb2RlZCBieXRlcyBvciBhXG4gKiByZWd1bGFyIHN0cmluZyBvZiBjaGFyYWN0ZXJzLiBXaGVuIHBhc3NpbmcgYSBzdHJpbmcgb2YgYmluYXJ5IGVuY29kZWRcbiAqIGJ5dGVzLCB0aGUgZW5jb2RpbmcgYHJhd2Agc2hvdWxkIGJlIGdpdmVuLiBUaGlzIGlzIGFsc28gdGhlIGRlZmF1bHQuIFdoZW5cbiAqIHBhc3NpbmcgYSBzdHJpbmcgb2YgY2hhcmFjdGVycywgdGhlIGVuY29kaW5nIGB1dGY4YCBzaG91bGQgYmUgZ2l2ZW4uXG4gKlxuICogQHBhcmFtIFtpbnB1dF0gYSBzdHJpbmcgd2l0aCBlbmNvZGVkIGJ5dGVzIHRvIHN0b3JlIGluIHRoZSBidWZmZXIuXG4gKiBAcGFyYW0gW2VuY29kaW5nXSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICovXG51dGlsLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGlucHV0LCBlbmNvZGluZykge1xuICAvLyBUT0RPOiBkZXByZWNhdGUsIHVzZSBuZXcgQnl0ZUJ1ZmZlcigpIGluc3RlYWRcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAncmF3JztcbiAgaWYoaW5wdXQgIT09IHVuZGVmaW5lZCAmJiBlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgaW5wdXQgPSB1dGlsLmVuY29kZVV0ZjgoaW5wdXQpO1xuICB9XG4gIHJldHVybiBuZXcgdXRpbC5CeXRlQnVmZmVyKGlucHV0KTtcbn07XG5cbi8qKlxuICogRmlsbHMgYSBzdHJpbmcgd2l0aCBhIHBhcnRpY3VsYXIgdmFsdWUuIElmIHlvdSB3YW50IHRoZSBzdHJpbmcgdG8gYmUgYSBieXRlXG4gKiBzdHJpbmcsIHBhc3MgaW4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGVCeXRlKS5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY2hhcmFjdGVyIHRvIGZpbGwgdGhlIHN0cmluZyB3aXRoLCB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZVxuICogICAgICAgICAgdG8gZmlsbCB0aGUgc3RyaW5nIHdpdGggYSBieXRlIHZhbHVlLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHZhbHVlIGMgdG8gZmlsbCB3aXRoLlxuICpcbiAqIEByZXR1cm4gdGhlIGZpbGxlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZmlsbFN0cmluZyA9IGZ1bmN0aW9uKGMsIG4pIHtcbiAgdmFyIHMgPSAnJztcbiAgd2hpbGUobiA+IDApIHtcbiAgICBpZihuICYgMSkge1xuICAgICAgcyArPSBjO1xuICAgIH1cbiAgICBuID4+Pj0gMTtcbiAgICBpZihuID4gMCkge1xuICAgICAgYyArPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBwZXIgYnl0ZSBYT1IgYmV0d2VlbiB0d28gYnl0ZSBzdHJpbmdzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYVxuICogc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzMSBmaXJzdCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiBAcGFyYW0gczIgc2Vjb25kIHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gWE9SLlxuICpcbiAqIEByZXR1cm4gdGhlIFhPUidkIHJlc3VsdC5cbiAqL1xudXRpbC54b3JCeXRlcyA9IGZ1bmN0aW9uKHMxLCBzMiwgbikge1xuICB2YXIgczMgPSAnJztcbiAgdmFyIGIgPSAnJztcbiAgdmFyIHQgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB2YXIgYyA9IDA7XG4gIGZvcig7IG4gPiAwOyAtLW4sICsraSkge1xuICAgIGIgPSBzMS5jaGFyQ29kZUF0KGkpIF4gczIuY2hhckNvZGVBdChpKTtcbiAgICBpZihjID49IDEwKSB7XG4gICAgICBzMyArPSB0O1xuICAgICAgdCA9ICcnO1xuICAgICAgYyA9IDA7XG4gICAgfVxuICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcbiAgICArK2M7XG4gIH1cbiAgczMgKz0gdDtcbiAgcmV0dXJuIHMzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgaW50byBhICdiaW5hcnknIGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBoZXggdGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5oZXhUb0J5dGVzID0gZnVuY3Rpb24oaGV4KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuaGV4LmRlY29kZSBpbnN0ZWFkLlwiXG4gIHZhciBydmFsID0gJyc7XG4gIHZhciBpID0gMDtcbiAgaWYoaGV4Lmxlbmd0aCAmIDEgPT0gMSkge1xuICAgIC8vIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgY29udmVydCBmaXJzdCBjaGFyYWN0ZXIgYWxvbmVcbiAgICBpID0gMTtcbiAgICBydmFsICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4WzBdLCAxNikpO1xuICB9XG4gIC8vIGNvbnZlcnQgMiBjaGFyYWN0ZXJzICgxIGJ5dGUpIGF0IGEgdGltZVxuICBmb3IoOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcnZhbCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgdG8gaGV4LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBzdHJpbmcgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5ieXRlc1RvSGV4ID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlOiBcIkRlcHJlY2F0ZWQuIFVzZSB1dGlsLmJpbmFyeS5oZXguZW5jb2RlIGluc3RlYWQuXCJcbiAgcmV0dXJuIHV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKS50b0hleCgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiAzMi1iaXQgaW50ZWdlciB0byA0LWJpZy1lbmRpYW4gYnl0ZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGkgdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBzdHJpbmcuXG4gKi9cbnV0aWwuaW50MzJUb0J5dGVzID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAyNCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLy8gYmFzZTY0IGNoYXJhY3RlcnMsIHJldmVyc2UgbWFwcGluZ1xudmFyIF9iYXNlNjQgPVxuICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xudmFyIF9iYXNlNjRJZHggPSBbXG4vKjQzIC00MyA9IDAqL1xuLyonKycsICAxLCAgMiwgIDMsJy8nICovXG4gICA2MiwgLTEsIC0xLCAtMSwgNjMsXG5cbi8qJzAnLCcxJywnMicsJzMnLCc0JywnNScsJzYnLCc3JywnOCcsJzknICovXG4gICA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA1OCwgNTksIDYwLCA2MSxcblxuLyoxNSwgMTYsIDE3LCc9JywgMTksIDIwLCAyMSAqL1xuICAtMSwgLTEsIC0xLCA2NCwgLTEsIC0xLCAtMSxcblxuLyo2NSAtIDQzID0gMjIqL1xuLyonQScsJ0InLCdDJywnRCcsJ0UnLCdGJywnRycsJ0gnLCdJJywnSicsJ0snLCdMJywnTScsICovXG4gICAwLCAgMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLFxuXG4vKidOJywnTycsJ1AnLCdRJywnUicsJ1MnLCdUJywnVScsJ1YnLCdXJywnWCcsJ1knLCdaJyAqL1xuICAgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsXG5cbi8qOTEgLSA0MyA9IDQ4ICovXG4vKjQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMgKi9cbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcblxuLyo5NyAtIDQzID0gNTQqL1xuLyonYScsJ2InLCdjJywnZCcsJ2UnLCdmJywnZycsJ2gnLCdpJywnaicsJ2snLCdsJywnbScgKi9cbiAgIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LFxuXG4vKiduJywnbycsJ3AnLCdxJywncicsJ3MnLCd0JywndScsJ3YnLCd3JywneCcsJ3knLCd6JyAqL1xuICAgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDQ2LCA0NywgNDgsIDQ5LCA1MCwgNTFcbl07XG5cbi8vIGJhc2U1OCBjaGFyYWN0ZXJzIChCaXRjb2luIGFscGhhYmV0KVxudmFyIF9iYXNlNTggPSAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eic7XG5cbi8qKlxuICogQmFzZTY0IGVuY29kZXMgYSAnYmluYXJ5JyBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiBieXRlcyB0byBiYXNlNjQtZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2U2NC1lbmNvZGVkIG91dHB1dC5cbiAqL1xudXRpbC5lbmNvZGU2NCA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuYmFzZTY0LmVuY29kZSBpbnN0ZWFkLlwiXG4gIHZhciBsaW5lID0gJyc7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgY2hyMiA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICBjaHIzID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuXG4gICAgLy8gZW5jb2RlIDQgY2hhcmFjdGVyIGdyb3VwXG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdChjaHIxID4+IDIpO1xuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KSk7XG4gICAgaWYoaXNOYU4oY2hyMikpIHtcbiAgICAgIGxpbmUgKz0gJz09JztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KSk7XG4gICAgICBsaW5lICs9IGlzTmFOKGNocjMpID8gJz0nIDogX2Jhc2U2NC5jaGFyQXQoY2hyMyAmIDYzKTtcbiAgICB9XG5cbiAgICBpZihtYXhsaW5lICYmIGxpbmUubGVuZ3RoID4gbWF4bGluZSkge1xuICAgICAgb3V0cHV0ICs9IGxpbmUuc3Vic3RyKDAsIG1heGxpbmUpICsgJ1xcclxcbic7XG4gICAgICBsaW5lID0gbGluZS5zdWJzdHIobWF4bGluZSk7XG4gICAgfVxuICB9XG4gIG91dHB1dCArPSBsaW5lO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBCYXNlNjQgZGVjb2RlcyBhIHN0cmluZyBpbnRvIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlNjQtZW5jb2RlZCBpbnB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZGVjb2RlNjQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGU6IFwiRGVwcmVjYXRlZC4gVXNlIHV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUgaW5zdGVhZC5cIlxuXG4gIC8vIHJlbW92ZSBhbGwgbm9uLWJhc2U2NCBjaGFyYWN0ZXJzXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csICcnKTtcblxuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGVuYzEgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMyID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMyA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzQgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcblxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCkpO1xuICAgIGlmKGVuYzMgIT09IDY0KSB7XG4gICAgICAvLyBkZWNvZGVkIGF0IGxlYXN0IDIgYnl0ZXNcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpKTtcbiAgICAgIGlmKGVuYzQgIT09IDY0KSB7XG4gICAgICAgIC8vIGRlY29kZWQgMyBieXRlc1xuICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBvZiBjaGFyYWN0ZXJzIChhIHN0YW5kYXJkIEphdmFTY3JpcHRcbiAqIHN0cmluZykgYXMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgd2hlcmUgdGhlIGJ5dGVzIHJlcHJlc2VudFxuICogYSBVVEYtOCBlbmNvZGVkIHN0cmluZyBvZiBjaGFyYWN0ZXJzLiBOb24tQVNDSUkgY2hhcmFjdGVycyB3aWxsIGJlXG4gKiBlbmNvZGVkIGFzIG11bHRpcGxlIGJ5dGVzIGFjY29yZGluZyB0byBVVEYtOC5cbiAqXG4gKiBAcGFyYW0gc3RyIGEgc3RhbmRhcmQgc3RyaW5nIG9mIGNoYXJhY3RlcnMgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeSBlbmNvZGVkIHN0cmluZy5cbiAqL1xudXRpbC5lbmNvZGVVdGY4ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgdGhhdCBjb250YWlucyBieXRlcyB0aGF0XG4gKiByZXByZXNlbnQgYSBVVEYtOCBlbmNvZGVkIHN0cmluZyBvZiBjaGFyYWN0ZXJzIC0tIGludG8gYVxuICogc3RyaW5nIG9mIGNoYXJhY3RlcnMgKGEgc3RhbmRhcmQgSmF2YVNjcmlwdCBzdHJpbmcpLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIGJpbmFyeSBlbmNvZGVkIHN0cmluZyB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0aW5nIHN0YW5kYXJkIHN0cmluZyBvZiBjaGFyYWN0ZXJzLlxuICovXG51dGlsLmRlY29kZVV0ZjggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyKSk7XG59O1xuXG4vLyBiaW5hcnkgZW5jb2RpbmcvZGVjb2RpbmcgdG9vbHNcbi8vIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxudXRpbC5iaW5hcnkgPSB7XG4gIHJhdzoge30sXG4gIGhleDoge30sXG4gIGJhc2U2NDoge30sXG4gIGJhc2U1ODoge30sXG4gIGJhc2VOIDoge1xuICAgIGVuY29kZTogYmFzZU4uZW5jb2RlLFxuICAgIGRlY29kZTogYmFzZU4uZGVjb2RlXG4gIH1cbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIFVpbnQ4QXJyYXkgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuIFRoaXMgZW5jb2RpbmcgdXNlc1xuICogYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NSBmb3IgZWFjaCBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBVaW50OEFycmF5IHRvIGVuY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuXG4gKi9cbnV0aWwuYmluYXJ5LnJhdy5lbmNvZGUgPSBmdW5jdGlvbihieXRlcykge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LiBUaGlzIGVuY29kaW5nIHVzZXNcbiAqIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTUgZm9yIGVhY2ggY2hhcmFjdGVyLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLmJpbmFyeS5yYXcuZGVjb2RlID0gZnVuY3Rpb24oc3RyLCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gIH1cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBqID0gb2Zmc2V0O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgb3V0W2orK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgJ2JpbmFyeScgc3RyaW5nLCBBcnJheUJ1ZmZlciwgRGF0YVZpZXcsIFR5cGVkQXJyYXksIG9yXG4gKiBCeXRlQnVmZmVyIGFzIGEgc3RyaW5nIG9mIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIHN0cmluZyBvZiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzLlxuICovXG51dGlsLmJpbmFyeS5oZXguZW5jb2RlID0gdXRpbC5ieXRlc1RvSGV4O1xuXG4vKipcbiAqIERlY29kZXMgYSBoZXgtZW5jb2RlZCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBoZXggdGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC5iaW5hcnkuaGV4LmRlY29kZSA9IGZ1bmN0aW9uKGhleCwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChoZXgubGVuZ3RoIC8gMikpO1xuICB9XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7XG4gIGlmKGhleC5sZW5ndGggJiAxKSB7XG4gICAgLy8gb2RkIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBjb252ZXJ0IGZpcnN0IGNoYXJhY3RlciBhbG9uZVxuICAgIGkgPSAxO1xuICAgIG91dFtqKytdID0gcGFyc2VJbnQoaGV4WzBdLCAxNik7XG4gIH1cbiAgLy8gY29udmVydCAyIGNoYXJhY3RlcnMgKDEgYnl0ZSkgYXQgYSB0aW1lXG4gIGZvcig7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBvdXRbaisrXSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBCYXNlNjQtZW5jb2RlcyBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBVaW50OEFycmF5IHRvIGVuY29kZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIG51bWJlciBvZiBlbmNvZGVkIGNoYXJhY3RlcnMgcGVyIGxpbmUgdG8gdXNlLFxuICogICAgICAgICAgZGVmYXVsdHMgdG8gbm9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiYXNlNjQtZW5jb2RlZCBvdXRwdXQgc3RyaW5nLlxuICovXG51dGlsLmJpbmFyeS5iYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQsIG1heGxpbmUpIHtcbiAgdmFyIGxpbmUgPSAnJztcbiAgdmFyIG91dHB1dCA9ICcnO1xuICB2YXIgY2hyMSwgY2hyMiwgY2hyMztcbiAgdmFyIGkgPSAwO1xuICB3aGlsZShpIDwgaW5wdXQuYnl0ZUxlbmd0aCkge1xuICAgIGNocjEgPSBpbnB1dFtpKytdO1xuICAgIGNocjIgPSBpbnB1dFtpKytdO1xuICAgIGNocjMgPSBpbnB1dFtpKytdO1xuXG4gICAgLy8gZW5jb2RlIDQgY2hhcmFjdGVyIGdyb3VwXG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdChjaHIxID4+IDIpO1xuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KSk7XG4gICAgaWYoaXNOYU4oY2hyMikpIHtcbiAgICAgIGxpbmUgKz0gJz09JztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KSk7XG4gICAgICBsaW5lICs9IGlzTmFOKGNocjMpID8gJz0nIDogX2Jhc2U2NC5jaGFyQXQoY2hyMyAmIDYzKTtcbiAgICB9XG5cbiAgICBpZihtYXhsaW5lICYmIGxpbmUubGVuZ3RoID4gbWF4bGluZSkge1xuICAgICAgb3V0cHV0ICs9IGxpbmUuc3Vic3RyKDAsIG1heGxpbmUpICsgJ1xcclxcbic7XG4gICAgICBsaW5lID0gbGluZS5zdWJzdHIobWF4bGluZSk7XG4gICAgfVxuICB9XG4gIG91dHB1dCArPSBsaW5lO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nIHRvIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJhc2U2NC1lbmNvZGVkIGlucHV0IHN0cmluZy5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChpbnB1dC5sZW5ndGggLyA0KSAqIDMpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFsbCBub24tYmFzZTY0IGNoYXJhY3RlcnNcbiAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgJycpO1xuXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiAgdmFyIGkgPSAwLCBqID0gb2Zmc2V0O1xuXG4gIHdoaWxlKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICBlbmMxID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMiA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzMgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmM0ID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG5cbiAgICBvdXRbaisrXSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgaWYoZW5jMyAhPT0gNjQpIHtcbiAgICAgIC8vIGRlY29kZWQgYXQgbGVhc3QgMiBieXRlc1xuICAgICAgb3V0W2orK10gPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgIGlmKGVuYzQgIT09IDY0KSB7XG4gICAgICAgIC8vIGRlY29kZWQgMyBieXRlc1xuICAgICAgICBvdXRbaisrXSA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgcmVzdWx0IGlzIHRoZSBleGFjdCBkZWNvZGVkIGxlbmd0aFxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0LnN1YmFycmF5KDAsIGopO1xufTtcblxuLy8gYWRkIHN1cHBvcnQgZm9yIGJhc2U1OCBlbmNvZGluZy9kZWNvZGluZyB3aXRoIEJpdGNvaW4gYWxwaGFiZXRcbnV0aWwuYmluYXJ5LmJhc2U1OC5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICByZXR1cm4gdXRpbC5iaW5hcnkuYmFzZU4uZW5jb2RlKGlucHV0LCBfYmFzZTU4LCBtYXhsaW5lKTtcbn07XG51dGlsLmJpbmFyeS5iYXNlNTguZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIG1heGxpbmUpIHtcbiAgcmV0dXJuIHV0aWwuYmluYXJ5LmJhc2VOLmRlY29kZShpbnB1dCwgX2Jhc2U1OCwgbWF4bGluZSk7XG59O1xuXG4vLyB0ZXh0IGVuY29kaW5nL2RlY29kaW5nIHRvb2xzXG4vLyBGSVhNRTogRXhwZXJpbWVudGFsLiBEbyBub3QgdXNlIHlldC5cbnV0aWwudGV4dCA9IHtcbiAgdXRmODoge30sXG4gIHV0ZjE2OiB7fVxufTtcblxuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBzdHJpbmcgYXMgVVRGLTggaW4gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLnRleHQudXRmOC5lbmNvZGUgPSBmdW5jdGlvbihzdHIsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHN0ciA9IHV0aWwuZW5jb2RlVXRmOChzdHIpO1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gIH1cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBqID0gb2Zmc2V0O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgb3V0W2orK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBVVEYtOCBjb250ZW50cyBmcm9tIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIFVpbnQ4QXJyYXkgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdGluZyBzdHJpbmcuXG4gKi9cbnV0aWwudGV4dC51dGY4LmRlY29kZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHJldHVybiB1dGlsLmRlY29kZVV0ZjgoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcykpO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBzdHJpbmcgYXMgVVRGLTE2IGluIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC50ZXh0LnV0ZjE2LmVuY29kZSA9IGZ1bmN0aW9uKHN0ciwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGggKiAyKTtcbiAgfVxuICB2YXIgdmlldyA9IG5ldyBVaW50MTZBcnJheShvdXQuYnVmZmVyKTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBqID0gb2Zmc2V0O1xuICB2YXIgayA9IG9mZnNldDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIHZpZXdbaysrXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGogKz0gMjtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBVVEYtMTYgY29udGVudHMgZnJvbSBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBVaW50OEFycmF5IHRvIGRlY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICovXG51dGlsLnRleHQudXRmMTYuZGVjb2RlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJ5dGVzLmJ1ZmZlcikpO1xufTtcblxuLyoqXG4gKiBEZWZsYXRlcyB0aGUgZ2l2ZW4gZGF0YSB1c2luZyBhIGZsYXNoIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGRhdGEuXG4gKiBAcGFyYW0gcmF3IHRydWUgdG8gcmV0dXJuIG9ubHkgcmF3IGRlZmxhdGUgZGF0YSwgZmFsc2UgdG8gaW5jbHVkZSB6bGliXG4gKiAgICAgICAgICBoZWFkZXIgYW5kIHRyYWlsZXIuXG4gKlxuICogQHJldHVybiB0aGUgZGVmbGF0ZWQgZGF0YSBhcyBhIHN0cmluZy5cbiAqL1xudXRpbC5kZWZsYXRlID0gZnVuY3Rpb24oYXBpLCBieXRlcywgcmF3KSB7XG4gIGJ5dGVzID0gdXRpbC5kZWNvZGU2NChhcGkuZGVmbGF0ZSh1dGlsLmVuY29kZTY0KGJ5dGVzKSkucnZhbCk7XG5cbiAgLy8gc3RyaXAgemxpYiBoZWFkZXIgYW5kIHRyYWlsZXIgaWYgbmVjZXNzYXJ5XG4gIGlmKHJhdykge1xuICAgIC8vIHpsaWIgaGVhZGVyIGlzIDIgYnl0ZXMgKENNRixGTEcpIHdoZXJlIEZMRyBpbmRpY2F0ZXMgdGhhdFxuICAgIC8vIHRoZXJlIGlzIGEgNC1ieXRlIERJQ1QgKGFsZGVyLTMyKSBibG9jayBiZWZvcmUgdGhlIGRhdGEgaWZcbiAgICAvLyBpdHMgNXRoIGJpdCBpcyBzZXRcbiAgICB2YXIgc3RhcnQgPSAyO1xuICAgIHZhciBmbGcgPSBieXRlcy5jaGFyQ29kZUF0KDEpO1xuICAgIGlmKGZsZyAmIDB4MjApIHtcbiAgICAgIHN0YXJ0ID0gNjtcbiAgICB9XG4gICAgLy8gemxpYiB0cmFpbGVyIGlzIDQgYnl0ZXMgb2YgYWRsZXItMzJcbiAgICBieXRlcyA9IGJ5dGVzLnN1YnN0cmluZyhzdGFydCwgYnl0ZXMubGVuZ3RoIC0gNCk7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vKipcbiAqIEluZmxhdGVzIHRoZSBnaXZlbiBkYXRhIHVzaW5nIGEgZmxhc2ggaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZS5cbiAqIEBwYXJhbSBieXRlcyB0aGUgZGF0YS5cbiAqIEBwYXJhbSByYXcgdHJ1ZSBpZiB0aGUgaW5jb21pbmcgZGF0YSBoYXMgbm8gemxpYiBoZWFkZXIgb3IgdHJhaWxlciBhbmQgaXNcbiAqICAgICAgICAgIHJhdyBERUZMQVRFIGRhdGEuXG4gKlxuICogQHJldHVybiB0aGUgaW5mbGF0ZWQgZGF0YSBhcyBhIHN0cmluZywgbnVsbCBvbiBlcnJvci5cbiAqL1xudXRpbC5pbmZsYXRlID0gZnVuY3Rpb24oYXBpLCBieXRlcywgcmF3KSB7XG4gIC8vIFRPRE86IGFkZCB6bGliIGhlYWRlciBhbmQgdHJhaWxlciBpZiBuZWNlc3NhcnkvcG9zc2libGVcbiAgdmFyIHJ2YWwgPSBhcGkuaW5mbGF0ZSh1dGlsLmVuY29kZTY0KGJ5dGVzKSkucnZhbDtcbiAgcmV0dXJuIChydmFsID09PSBudWxsKSA/IG51bGwgOiB1dGlsLmRlY29kZTY0KHJ2YWwpO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgc3RvcmFnZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIG9iaiB0aGUgc3RvcmFnZSBvYmplY3QsIG51bGwgdG8gcmVtb3ZlLlxuICovXG52YXIgX3NldFN0b3JhZ2VPYmplY3QgPSBmdW5jdGlvbihhcGksIGlkLCBvYmopIHtcbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignV2ViU3RvcmFnZSBub3QgYXZhaWxhYmxlLicpO1xuICB9XG5cbiAgdmFyIHJ2YWw7XG4gIGlmKG9iaiA9PT0gbnVsbCkge1xuICAgIHJ2YWwgPSBhcGkucmVtb3ZlSXRlbShpZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8ganNvbi1lbmNvZGUgYW5kIGJhc2U2NC1lbmNvZGUgb2JqZWN0XG4gICAgb2JqID0gdXRpbC5lbmNvZGU2NChKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICBydmFsID0gYXBpLnNldEl0ZW0oaWQsIG9iaik7XG4gIH1cblxuICAvLyBoYW5kbGUgcG90ZW50aWFsIGZsYXNoIGVycm9yXG4gIGlmKHR5cGVvZihydmFsKSAhPT0gJ3VuZGVmaW5lZCcgJiYgcnZhbC5ydmFsICE9PSB0cnVlKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHJ2YWwuZXJyb3IubWVzc2FnZSk7XG4gICAgZXJyb3IuaWQgPSBydmFsLmVycm9yLmlkO1xuICAgIGVycm9yLm5hbWUgPSBydmFsLmVycm9yLm5hbWU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyBhIHN0b3JhZ2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdG9yYWdlIG9iamVjdCBlbnRyeSBvciBudWxsIGlmIG5vbmUgZXhpc3RzLlxuICovXG52YXIgX2dldFN0b3JhZ2VPYmplY3QgPSBmdW5jdGlvbihhcGksIGlkKSB7XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlN0b3JhZ2Ugbm90IGF2YWlsYWJsZS4nKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgZXhpc3RpbmcgZW50cnlcbiAgdmFyIHJ2YWwgPSBhcGkuZ2V0SXRlbShpZCk7XG5cbiAgLyogTm90ZTogV2UgY2hlY2sgYXBpLmluaXQgYmVjYXVzZSB3ZSBjYW4ndCBkbyAoYXBpID09IGxvY2FsU3RvcmFnZSlcbiAgICBvbiBJRSBiZWNhdXNlIG9mIFwiQ2xhc3MgZG9lc24ndCBzdXBwb3J0IEF1dG9tYXRpb25cIiBleGNlcHRpb24uIE9ubHlcbiAgICB0aGUgZmxhc2ggYXBpIGhhcyBhbiBpbml0IG1ldGhvZCBzbyB0aGlzIHdvcmtzIHRvbywgYnV0IHdlIG5lZWQgYVxuICAgIGJldHRlciBzb2x1dGlvbiBpbiB0aGUgZnV0dXJlLiAqL1xuXG4gIC8vIGZsYXNoIHJldHVybnMgaXRlbSB3cmFwcGVkIGluIGFuIG9iamVjdCwgaGFuZGxlIHNwZWNpYWwgY2FzZVxuICBpZihhcGkuaW5pdCkge1xuICAgIGlmKHJ2YWwucnZhbCA9PT0gbnVsbCkge1xuICAgICAgaWYocnZhbC5lcnJvcikge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocnZhbC5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3IuaWQgPSBydmFsLmVycm9yLmlkO1xuICAgICAgICBlcnJvci5uYW1lID0gcnZhbC5lcnJvci5uYW1lO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIC8vIG5vIGVycm9yLCBidXQgYWxzbyBubyBpdGVtXG4gICAgICBydmFsID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcnZhbCA9IHJ2YWwucnZhbDtcbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgZGVjb2RpbmdcbiAgaWYocnZhbCAhPT0gbnVsbCkge1xuICAgIC8vIGJhc2U2NC1kZWNvZGUgYW5kIGpzb24tZGVjb2RlIGRhdGFcbiAgICBydmFsID0gSlNPTi5wYXJzZSh1dGlsLmRlY29kZTY0KHJ2YWwpKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBTdG9yZXMgYW4gaXRlbSBpbiBsb2NhbCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBmb3IgdGhlIGl0ZW0gKGFueSBqYXZhc2NyaXB0IG9iamVjdC9wcmltaXRpdmUpLlxuICovXG52YXIgX3NldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGRhdGEpIHtcbiAgLy8gZ2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIHZhciBvYmogPSBfZ2V0U3RvcmFnZU9iamVjdChhcGksIGlkKTtcbiAgaWYob2JqID09PSBudWxsKSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IHN0b3JhZ2Ugb2JqZWN0XG4gICAgb2JqID0ge307XG4gIH1cbiAgLy8gdXBkYXRlIGtleVxuICBvYmpba2V5XSA9IGRhdGE7XG5cbiAgLy8gc2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIF9zZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQsIG9iaik7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gaXRlbSBmcm9tIGxvY2FsIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpdGVtLlxuICovXG52YXIgX2dldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXkpIHtcbiAgLy8gZ2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIHZhciBydmFsID0gX2dldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCk7XG4gIGlmKHJ2YWwgIT09IG51bGwpIHtcbiAgICAvLyByZXR1cm4gZGF0YSBhdCBrZXlcbiAgICBydmFsID0gKGtleSBpbiBydmFsKSA/IHJ2YWxba2V5XSA6IG51bGw7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICovXG52YXIgX3JlbW92ZUl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXkpIHtcbiAgLy8gZ2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIHZhciBvYmogPSBfZ2V0U3RvcmFnZU9iamVjdChhcGksIGlkKTtcbiAgaWYob2JqICE9PSBudWxsICYmIGtleSBpbiBvYmopIHtcbiAgICAvLyByZW1vdmUga2V5XG4gICAgZGVsZXRlIG9ialtrZXldO1xuXG4gICAgLy8gc2VlIGlmIGVudHJ5IGhhcyBubyBrZXlzIHJlbWFpbmluZ1xuICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgZm9yKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZihlbXB0eSkge1xuICAgICAgLy8gcmVtb3ZlIGVudHJ5IGVudGlyZWx5IGlmIG5vIGtleXMgYXJlIGxlZnRcbiAgICAgIG9iaiA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gc2V0IHN0b3JhZ2Ugb2JqZWN0XG4gICAgX3NldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCwgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGxvY2FsIGRpc2sgc3RvcmFnZSBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBJRC5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKi9cbnZhciBfY2xlYXJJdGVtcyA9IGZ1bmN0aW9uKGFwaSwgaWQpIHtcbiAgX3NldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCwgbnVsbCk7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgc3RvcmFnZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gZnVuYyB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAqIEBwYXJhbSBhcmdzIHRoZSBhcmd1bWVudHMgZm9yIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSBsb2NhdGlvbiB0aGUgbG9jYXRpb24gYXJndW1lbnQuXG4gKlxuICogQHJldHVybiB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uLlxuICovXG52YXIgX2NhbGxTdG9yYWdlRnVuY3Rpb24gPSBmdW5jdGlvbihmdW5jLCBhcmdzLCBsb2NhdGlvbikge1xuICB2YXIgcnZhbCA9IG51bGw7XG5cbiAgLy8gZGVmYXVsdCBzdG9yYWdlIHR5cGVzXG4gIGlmKHR5cGVvZihsb2NhdGlvbikgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYXRpb24gPSBbJ3dlYicsICdmbGFzaCddO1xuICB9XG5cbiAgLy8gYXBwbHkgc3RvcmFnZSB0eXBlcyBpbiBvcmRlciBvZiBwcmVmZXJlbmNlXG4gIHZhciB0eXBlO1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB2YXIgZXhjZXB0aW9uID0gbnVsbDtcbiAgZm9yKHZhciBpZHggaW4gbG9jYXRpb24pIHtcbiAgICB0eXBlID0gbG9jYXRpb25baWR4XTtcbiAgICB0cnkge1xuICAgICAgaWYodHlwZSA9PT0gJ2ZsYXNoJyB8fCB0eXBlID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYoYXJnc1swXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhc2ggbG9jYWwgc3RvcmFnZSBub3QgYXZhaWxhYmxlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJ2YWwgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBkb25lID0gKHR5cGUgPT09ICdmbGFzaCcpO1xuICAgICAgfVxuICAgICAgaWYodHlwZSA9PT0gJ3dlYicgfHwgdHlwZSA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIGFyZ3NbMF0gPSBsb2NhbFN0b3JhZ2U7XG4gICAgICAgIHJ2YWwgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGV4KSB7XG4gICAgICBleGNlcHRpb24gPSBleDtcbiAgICB9XG4gICAgaWYoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYoIWRvbmUpIHtcbiAgICB0aHJvdyBleGNlcHRpb247XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogU3RvcmVzIGFuIGl0ZW0gb24gbG9jYWwgZGlzay5cbiAqXG4gKiBUaGUgYXZhaWxhYmxlIHR5cGVzIG9mIGxvY2FsIHN0b3JhZ2UgaW5jbHVkZSAnZmxhc2gnLCAnd2ViJywgYW5kICdib3RoJy5cbiAqXG4gKiBUaGUgdHlwZSAnZmxhc2gnIHJlZmVycyB0byBmbGFzaCBsb2NhbCBzdG9yYWdlIChTaGFyZWRPYmplY3QpLiBJbiBvcmRlclxuICogdG8gdXNlIGZsYXNoIGxvY2FsIHN0b3JhZ2UsIHRoZSAnYXBpJyBwYXJhbWV0ZXIgbXVzdCBiZSB2YWxpZC4gVGhlIHR5cGVcbiAqICd3ZWInIHJlZmVycyB0byBXZWJTdG9yYWdlLCBpZiBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuIFRoZSB0eXBlICdib3RoJ1xuICogcmVmZXJzIHRvIHN0b3JpbmcgdXNpbmcgYm90aCAnZmxhc2gnIGFuZCAnd2ViJywgbm90IGp1c3Qgb25lIG9yIHRoZVxuICogb3RoZXIuXG4gKlxuICogVGhlIGxvY2F0aW9uIGFycmF5IHNob3VsZCBsaXN0IHRoZSBzdG9yYWdlIHR5cGVzIHRvIHVzZSBpbiBvcmRlciBvZlxuICogcHJlZmVyZW5jZTpcbiAqXG4gKiBbJ2ZsYXNoJ106IGZsYXNoIG9ubHkgc3RvcmFnZVxuICogWyd3ZWInXTogd2ViIG9ubHkgc3RvcmFnZVxuICogWydib3RoJ106IHRyeSB0byBzdG9yZSBpbiBib3RoXG4gKiBbJ2ZsYXNoJywnd2ViJ106IHN0b3JlIGluIGZsYXNoIGZpcnN0LCBidXQgaWYgbm90IGF2YWlsYWJsZSwgJ3dlYidcbiAqIFsnd2ViJywnZmxhc2gnXTogc3RvcmUgaW4gd2ViIGZpcnN0LCBidXQgaWYgbm90IGF2YWlsYWJsZSwgJ2ZsYXNoJ1xuICpcbiAqIFRoZSBsb2NhdGlvbiBhcnJheSBkZWZhdWx0cyB0bzogWyd3ZWInLCAnZmxhc2gnXVxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZSwgbnVsbCB0byB1c2Ugb25seSBXZWJTdG9yYWdlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBmb3IgdGhlIGl0ZW0gKGFueSBqYXZhc2NyaXB0IG9iamVjdC9wcmltaXRpdmUpLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqL1xudXRpbC5zZXRJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5LCBkYXRhLCBsb2NhdGlvbikge1xuICBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfc2V0SXRlbSwgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gaXRlbSBvbiBsb2NhbCBkaXNrLlxuICpcbiAqIFNldCBzZXRJdGVtKCkgZm9yIGRldGFpbHMgb24gc3RvcmFnZSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UsIG51bGwgdG8gdXNlIG9ubHkgV2ViU3RvcmFnZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpdGVtLlxuICovXG51dGlsLmdldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGxvY2F0aW9uKSB7XG4gIHJldHVybiBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfZ2V0SXRlbSwgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gaXRlbSBvbiBsb2NhbCBkaXNrLlxuICpcbiAqIFNldCBzZXRJdGVtKCkgZm9yIGRldGFpbHMgb24gc3RvcmFnZSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBsb2NhdGlvbiBhbiBhcnJheSB3aXRoIHRoZSBwcmVmZXJyZWQgdHlwZXMgb2Ygc3RvcmFnZSB0byB1c2UuXG4gKi9cbnV0aWwucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgbG9jYXRpb24pIHtcbiAgX2NhbGxTdG9yYWdlRnVuY3Rpb24oX3JlbW92ZUl0ZW0sIGFyZ3VtZW50cywgbG9jYXRpb24pO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGxvY2FsIGRpc2sgc3RvcmFnZSBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBJRC5cbiAqXG4gKiBTZXQgc2V0SXRlbSgpIGZvciBkZXRhaWxzIG9uIHN0b3JhZ2UgdHlwZXMuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlIGlmIGZsYXNoIGlzIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICovXG51dGlsLmNsZWFySXRlbXMgPSBmdW5jdGlvbihhcGksIGlkLCBsb2NhdGlvbikge1xuICBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfY2xlYXJJdGVtcywgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgc2NoZW1lLCBob3N0LCBhbmQgcG9ydCBmcm9tIGFuIGh0dHAocykgdXJsLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHVybCBzdHJpbmcuXG4gKlxuICogQHJldHVybiB0aGUgcGFyc2VkIHVybCBvYmplY3Qgb3IgbnVsbCBpZiB0aGUgdXJsIGlzIGludmFsaWQuXG4gKi9cbnV0aWwucGFyc2VVcmwgPSBmdW5jdGlvbihzdHIpIHtcbiAgLy8gRklYTUU6IHRoaXMgcmVnZXggbG9va3MgYSBiaXQgYnJva2VuXG4gIHZhciByZWdleCA9IC9eKGh0dHBzPyk6XFwvXFwvKFteOiZeXFwvXSopOj8oXFxkKikoLiopJC9nO1xuICByZWdleC5sYXN0SW5kZXggPSAwO1xuICB2YXIgbSA9IHJlZ2V4LmV4ZWMoc3RyKTtcbiAgdmFyIHVybCA9IChtID09PSBudWxsKSA/IG51bGwgOiB7XG4gICAgZnVsbDogc3RyLFxuICAgIHNjaGVtZTogbVsxXSxcbiAgICBob3N0OiBtWzJdLFxuICAgIHBvcnQ6IG1bM10sXG4gICAgcGF0aDogbVs0XVxuICB9O1xuICBpZih1cmwpIHtcbiAgICB1cmwuZnVsbEhvc3QgPSB1cmwuaG9zdDtcbiAgICBpZih1cmwucG9ydCkge1xuICAgICAgaWYodXJsLnBvcnQgIT09IDgwICYmIHVybC5zY2hlbWUgPT09ICdodHRwJykge1xuICAgICAgICB1cmwuZnVsbEhvc3QgKz0gJzonICsgdXJsLnBvcnQ7XG4gICAgICB9IGVsc2UgaWYodXJsLnBvcnQgIT09IDQ0MyAmJiB1cmwuc2NoZW1lID09PSAnaHR0cHMnKSB7XG4gICAgICAgIHVybC5mdWxsSG9zdCArPSAnOicgKyB1cmwucG9ydDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYodXJsLnNjaGVtZSA9PT0gJ2h0dHAnKSB7XG4gICAgICB1cmwucG9ydCA9IDgwO1xuICAgIH0gZWxzZSBpZih1cmwuc2NoZW1lID09PSAnaHR0cHMnKSB7XG4gICAgICB1cmwucG9ydCA9IDQ0MztcbiAgICB9XG4gICAgdXJsLmZ1bGwgPSB1cmwuc2NoZW1lICsgJzovLycgKyB1cmwuZnVsbEhvc3Q7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn07XG5cbi8qIFN0b3JhZ2UgZm9yIHF1ZXJ5IHZhcmlhYmxlcyAqL1xudmFyIF9xdWVyeVZhcmlhYmxlcyA9IG51bGw7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgd2luZG93IGxvY2F0aW9uIHF1ZXJ5IHZhcmlhYmxlcy4gUXVlcnkgaXMgcGFyc2VkIG9uIHRoZSBmaXJzdFxuICogY2FsbCBhbmQgdGhlIHNhbWUgb2JqZWN0IGlzIHJldHVybmVkIG9uIHN1YnNlcXVlbnQgY2FsbHMuIFRoZSBtYXBwaW5nXG4gKiBpcyBmcm9tIGtleXMgdG8gYW4gYXJyYXkgb2YgdmFsdWVzLiBQYXJhbWV0ZXJzIHdpdGhvdXQgdmFsdWVzIHdpbGwgaGF2ZVxuICogYW4gb2JqZWN0IGtleSBzZXQgYnV0IG5vIHZhbHVlIGFkZGVkIHRvIHRoZSB2YWx1ZSBhcnJheS4gVmFsdWVzIGFyZVxuICogdW5lc2NhcGVkLlxuICpcbiAqIC4uLj9rMT12MSZrMj12MjpcbiAqIHtcbiAqICAgXCJrMVwiOiBbXCJ2MVwiXSxcbiAqICAgXCJrMlwiOiBbXCJ2MlwiXVxuICogfVxuICpcbiAqIC4uLj9rMT12MSZrMT12MjpcbiAqIHtcbiAqICAgXCJrMVwiOiBbXCJ2MVwiLCBcInYyXCJdXG4gKiB9XG4gKlxuICogLi4uP2sxPXYxJmsyOlxuICoge1xuICogICBcImsxXCI6IFtcInYxXCJdLFxuICogICBcImsyXCI6IFtdXG4gKiB9XG4gKlxuICogLi4uP2sxPXYxJmsxOlxuICoge1xuICogICBcImsxXCI6IFtcInYxXCJdXG4gKiB9XG4gKlxuICogLi4uP2sxJmsxOlxuICoge1xuICogICBcImsxXCI6IFtdXG4gKiB9XG4gKlxuICogQHBhcmFtIHF1ZXJ5IHRoZSBxdWVyeSBzdHJpbmcgdG8gcGFyc2UgKG9wdGlvbmFsLCBkZWZhdWx0IHRvIGNhY2hlZFxuICogICAgICAgICAgcmVzdWx0cyBmcm9tIHBhcnNpbmcgd2luZG93IGxvY2F0aW9uIHNlYXJjaCBxdWVyeSkuXG4gKlxuICogQHJldHVybiBvYmplY3QgbWFwcGluZyBrZXlzIHRvIHZhcmlhYmxlcy5cbiAqL1xudXRpbC5nZXRRdWVyeVZhcmlhYmxlcyA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZSA9IGZ1bmN0aW9uKHEpIHtcbiAgICB2YXIgcnZhbCA9IHt9O1xuICAgIHZhciBrdnBhaXJzID0gcS5zcGxpdCgnJicpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBrdnBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcG9zID0ga3ZwYWlyc1tpXS5pbmRleE9mKCc9Jyk7XG4gICAgICB2YXIga2V5O1xuICAgICAgdmFyIHZhbDtcbiAgICAgIGlmKHBvcyA+IDApIHtcbiAgICAgICAga2V5ID0ga3ZwYWlyc1tpXS5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICAgICAgdmFsID0ga3ZwYWlyc1tpXS5zdWJzdHJpbmcocG9zICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSBrdnBhaXJzW2ldO1xuICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYoIShrZXkgaW4gcnZhbCkpIHtcbiAgICAgICAgcnZhbFtrZXldID0gW107XG4gICAgICB9XG4gICAgICAvLyBkaXNhbGxvdyBvdmVycmlkaW5nIG9iamVjdCBwcm90b3R5cGUga2V5c1xuICAgICAgaWYoIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgIHJ2YWxba2V5XS5wdXNoKHVuZXNjYXBlKHZhbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAgdmFyIHJ2YWw7XG4gICBpZih0eXBlb2YocXVlcnkpID09PSAndW5kZWZpbmVkJykge1xuICAgICAvLyBzZXQgY2FjaGVkIHZhcmlhYmxlcyBpZiBuZWVkZWRcbiAgICAgaWYoX3F1ZXJ5VmFyaWFibGVzID09PSBudWxsKSB7XG4gICAgICAgaWYodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICAgICAgLy8gcGFyc2Ugd2luZG93IHNlYXJjaCBxdWVyeVxuICAgICAgICAgIF9xdWVyeVZhcmlhYmxlcyA9IHBhcnNlKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIHF1ZXJ5IHZhcmlhYmxlcyBhdmFpbGFibGVcbiAgICAgICAgICBfcXVlcnlWYXJpYWJsZXMgPSB7fTtcbiAgICAgICB9XG4gICAgIH1cbiAgICAgcnZhbCA9IF9xdWVyeVZhcmlhYmxlcztcbiAgIH0gZWxzZSB7XG4gICAgIC8vIHBhcnNlIGdpdmVuIHF1ZXJ5XG4gICAgIHJ2YWwgPSBwYXJzZShxdWVyeSk7XG4gICB9XG4gICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgZnJhZ21lbnQgaW50byBhIHBhdGggYW5kIHF1ZXJ5LiBUaGlzIG1ldGhvZCB3aWxsIHRha2UgYSBVUklcbiAqIGZyYWdtZW50IGFuZCBicmVhayBpdCB1cCBhcyBpZiBpdCB3ZXJlIHRoZSBtYWluIFVSSS4gRm9yIGV4YW1wbGU6XG4gKiAgICAvYmFyL2Jhej9hPTEmYj0yXG4gKiByZXN1bHRzIGluOlxuICogICAge1xuICogICAgICAgcGF0aDogW1wiYmFyXCIsIFwiYmF6XCJdLFxuICogICAgICAgcXVlcnk6IHtcImsxXCI6IFtcInYxXCJdLCBcImsyXCI6IFtcInYyXCJdfVxuICogICAgfVxuICpcbiAqIEByZXR1cm4gb2JqZWN0IHdpdGggYSBwYXRoIGFycmF5IGFuZCBxdWVyeSBvYmplY3QuXG4gKi9cbnV0aWwucGFyc2VGcmFnbWVudCA9IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gIC8vIGRlZmF1bHQgdG8gd2hvbGUgZnJhZ21lbnRcbiAgdmFyIGZwID0gZnJhZ21lbnQ7XG4gIHZhciBmcSA9ICcnO1xuICAvLyBzcGxpdCBpbnRvIHBhdGggYW5kIHF1ZXJ5IGlmIHBvc3NpYmxlIGF0IHRoZSBmaXJzdCAnPydcbiAgdmFyIHBvcyA9IGZyYWdtZW50LmluZGV4T2YoJz8nKTtcbiAgaWYocG9zID4gMCkge1xuICAgIGZwID0gZnJhZ21lbnQuc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgZnEgPSBmcmFnbWVudC5zdWJzdHJpbmcocG9zICsgMSk7XG4gIH1cbiAgLy8gc3BsaXQgcGF0aCBiYXNlZCBvbiAnLycgYW5kIGlnbm9yZSBmaXJzdCBlbGVtZW50IGlmIGVtcHR5XG4gIHZhciBwYXRoID0gZnAuc3BsaXQoJy8nKTtcbiAgaWYocGF0aC5sZW5ndGggPiAwICYmIHBhdGhbMF0gPT09ICcnKSB7XG4gICAgcGF0aC5zaGlmdCgpO1xuICB9XG4gIC8vIGNvbnZlcnQgcXVlcnkgaW50byBvYmplY3RcbiAgdmFyIHF1ZXJ5ID0gKGZxID09PSAnJykgPyB7fSA6IHV0aWwuZ2V0UXVlcnlWYXJpYWJsZXMoZnEpO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aFN0cmluZzogZnAsXG4gICAgcXVlcnlTdHJpbmc6IGZxLFxuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5XG4gIH07XG59O1xuXG4vKipcbiAqIE1ha2VzIGEgcmVxdWVzdCBvdXQgb2YgYSBVUkktbGlrZSByZXF1ZXN0IHN0cmluZy4gVGhpcyBpcyBpbnRlbmRlZCB0b1xuICogYmUgdXNlZCB3aGVyZSBhIGZyYWdtZW50IGlkIChhZnRlciBhIFVSSSAnIycpIGlzIHBhcnNlZCBhcyBhIFVSSSB3aXRoXG4gKiBwYXRoIGFuZCBxdWVyeSBwYXJ0cy4gVGhlIHN0cmluZyBzaG91bGQgaGF2ZSBhIHBhdGggYmVnaW5uaW5nIGFuZFxuICogZGVsaW1pdGVkIGJ5ICcvJyBhbmQgb3B0aW9uYWwgcXVlcnkgcGFyYW1ldGVycyBmb2xsb3dpbmcgYSAnPycuIFRoZVxuICogcXVlcnkgc2hvdWxkIGJlIGEgc3RhbmRhcmQgVVJMIHNldCBvZiBrZXkgdmFsdWUgcGFpcnMgZGVsaW1pdGVkIGJ5XG4gKiAnJicuIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB0aGUgaW5pdGlhbCAnLycgb24gdGhlIHBhdGggaXMgbm90XG4gKiByZXF1aXJlZC4gVGhlIHJlcXVlc3Qgb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIEFQSSwgKGZ1bGx5IGRlc2NyaWJlZFxuICogaW4gdGhlIG1ldGhvZCBjb2RlKTpcbiAqICAgIHtcbiAqICAgICAgIHBhdGg6IDx0aGUgcGF0aCBzdHJpbmcgcGFydD4uXG4gKiAgICAgICBxdWVyeTogPHRoZSBxdWVyeSBzdHJpbmcgcGFydD4sXG4gKiAgICAgICBnZXRQYXRoKGkpOiBnZXQgcGFydCBvciBhbGwgb2YgdGhlIHNwbGl0IHBhdGggYXJyYXksXG4gKiAgICAgICBnZXRRdWVyeShrLCBpKTogZ2V0IHBhcnQgb3IgYWxsIG9mIGEgcXVlcnkga2V5IGFycmF5LFxuICogICAgICAgZ2V0UXVlcnlMYXN0KGssIF9kZWZhdWx0KTogZ2V0IGxhc3QgZWxlbWVudCBvZiBhIHF1ZXJ5IGtleSBhcnJheS5cbiAqICAgIH1cbiAqXG4gKiBAcmV0dXJuIG9iamVjdCB3aXRoIHJlcXVlc3QgcGFyYW1ldGVycy5cbiAqL1xudXRpbC5tYWtlUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcVN0cmluZykge1xuICB2YXIgZnJhZyA9IHV0aWwucGFyc2VGcmFnbWVudChyZXFTdHJpbmcpO1xuICB2YXIgcmVxID0ge1xuICAgIC8vIGZ1bGwgcGF0aCBzdHJpbmdcbiAgICBwYXRoOiBmcmFnLnBhdGhTdHJpbmcsXG4gICAgLy8gZnVsbCBxdWVyeSBzdHJpbmdcbiAgICBxdWVyeTogZnJhZy5xdWVyeVN0cmluZyxcbiAgICAvKipcbiAgICAgKiBHZXQgcGF0aCBvciBlbGVtZW50IGluIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaSBvcHRpb25hbCBwYXRoIGluZGV4LlxuICAgICAqXG4gICAgICogQHJldHVybiBwYXRoIG9yIHBhcnQgb2YgcGF0aCBpZiBpIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIGdldFBhdGg6IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiAodHlwZW9mKGkpID09PSAndW5kZWZpbmVkJykgPyBmcmFnLnBhdGggOiBmcmFnLnBhdGhbaV07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgcXVlcnksIHZhbHVlcyBmb3IgYSBrZXksIG9yIHZhbHVlIGZvciBhIGtleSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrIG9wdGlvbmFsIHF1ZXJ5IGtleS5cbiAgICAgKiBAcGFyYW0gaSBvcHRpb25hbCBxdWVyeSBrZXkgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHF1ZXJ5LCB2YWx1ZXMgZm9yIGEga2V5LCBvciB2YWx1ZSBmb3IgYSBrZXkgaW5kZXguXG4gICAgICovXG4gICAgZ2V0UXVlcnk6IGZ1bmN0aW9uKGssIGkpIHtcbiAgICAgIHZhciBydmFsO1xuICAgICAgaWYodHlwZW9mKGspID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBydmFsID0gZnJhZy5xdWVyeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgPSBmcmFnLnF1ZXJ5W2tdO1xuICAgICAgICBpZihydmFsICYmIHR5cGVvZihpKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgcnZhbCA9IHJ2YWxbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH0sXG4gICAgZ2V0UXVlcnlMYXN0OiBmdW5jdGlvbihrLCBfZGVmYXVsdCkge1xuICAgICAgdmFyIHJ2YWw7XG4gICAgICB2YXIgdmFscyA9IHJlcS5nZXRRdWVyeShrKTtcbiAgICAgIGlmKHZhbHMpIHtcbiAgICAgICAgcnZhbCA9IHZhbHNbdmFscy5sZW5ndGggLSAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgPSBfZGVmYXVsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogTWFrZXMgYSBVUkkgb3V0IG9mIGEgcGF0aCwgYW4gb2JqZWN0IHdpdGggcXVlcnkgcGFyYW1ldGVycywgYW5kIGFcbiAqIGZyYWdtZW50LiBVc2VzIGpRdWVyeS5wYXJhbSgpIGludGVybmFsbHkgZm9yIHF1ZXJ5IHN0cmluZyBjcmVhdGlvbi5cbiAqIElmIHRoZSBwYXRoIGlzIGFuIGFycmF5LCBpdCB3aWxsIGJlIGpvaW5lZCB3aXRoICcvJy5cbiAqXG4gKiBAcGFyYW0gcGF0aCBzdHJpbmcgcGF0aCBvciBhcnJheSBvZiBzdHJpbmdzLlxuICogQHBhcmFtIHF1ZXJ5IG9iamVjdCB3aXRoIHF1ZXJ5IHBhcmFtZXRlcnMuIChvcHRpb25hbClcbiAqIEBwYXJhbSBmcmFnbWVudCBmcmFnbWVudCBzdHJpbmcuIChvcHRpb25hbClcbiAqXG4gKiBAcmV0dXJuIHN0cmluZyBvYmplY3Qgd2l0aCByZXF1ZXN0IHBhcmFtZXRlcnMuXG4gKi9cbnV0aWwubWFrZUxpbmsgPSBmdW5jdGlvbihwYXRoLCBxdWVyeSwgZnJhZ21lbnQpIHtcbiAgLy8gam9pbiBwYXRoIHBhcnRzIGlmIG5lZWRlZFxuICBwYXRoID0galF1ZXJ5LmlzQXJyYXkocGF0aCkgPyBwYXRoLmpvaW4oJy8nKSA6IHBhdGg7XG5cbiAgdmFyIHFzdHIgPSBqUXVlcnkucGFyYW0ocXVlcnkgfHwge30pO1xuICBmcmFnbWVudCA9IGZyYWdtZW50IHx8ICcnO1xuICByZXR1cm4gcGF0aCArXG4gICAgKChxc3RyLmxlbmd0aCA+IDApID8gKCc/JyArIHFzdHIpIDogJycpICtcbiAgICAoKGZyYWdtZW50Lmxlbmd0aCA+IDApID8gKCcjJyArIGZyYWdtZW50KSA6ICcnKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGVtcHR5LlxuICpcbiAqIFRha2VuIGZyb206XG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY3OTkxNS9ob3ctZG8taS10ZXN0LWZvci1hbi1lbXB0eS1qYXZhc2NyaXB0LW9iamVjdC1mcm9tLWpzb24vNjc5OTM3IzY3OTkzN1xuICpcbiAqIEBwYXJhbSBvYmplY3QgdGhlIG9iamVjdCB0byBjaGVjay5cbiAqL1xudXRpbC5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gIGZvcih2YXIgcHJvcCBpbiBvYmopIHtcbiAgICBpZihvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEZvcm1hdCB3aXRoIHNpbXBsZSBwcmludGYtc3R5bGUgaW50ZXJwb2xhdGlvbi5cbiAqXG4gKiAlJTogbGl0ZXJhbCAnJSdcbiAqICVzLCVvOiBjb252ZXJ0IG5leHQgYXJndW1lbnQgaW50byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gZm9ybWF0IHRoZSBzdHJpbmcgdG8gZm9ybWF0LlxuICogQHBhcmFtIC4uLiBhcmd1bWVudHMgdG8gaW50ZXJwb2xhdGUgaW50byB0aGUgZm9ybWF0IHN0cmluZy5cbiAqL1xudXRpbC5mb3JtYXQgPSBmdW5jdGlvbihmb3JtYXQpIHtcbiAgdmFyIHJlID0gLyUuL2c7XG4gIC8vIGN1cnJlbnQgbWF0Y2hcbiAgdmFyIG1hdGNoO1xuICAvLyBjdXJyZW50IHBhcnRcbiAgdmFyIHBhcnQ7XG4gIC8vIGN1cnJlbnQgYXJnIGluZGV4XG4gIHZhciBhcmdpID0gMDtcbiAgLy8gY29sbGVjdGVkIHBhcnRzIHRvIHJlY29tYmluZSBsYXRlclxuICB2YXIgcGFydHMgPSBbXTtcbiAgLy8gbGFzdCBpbmRleCBmb3VuZFxuICB2YXIgbGFzdCA9IDA7XG4gIC8vIGxvb3Agd2hpbGUgbWF0Y2hlcyByZW1haW5cbiAgd2hpbGUoKG1hdGNoID0gcmUuZXhlYyhmb3JtYXQpKSkge1xuICAgIHBhcnQgPSBmb3JtYXQuc3Vic3RyaW5nKGxhc3QsIHJlLmxhc3RJbmRleCAtIDIpO1xuICAgIC8vIGRvbid0IGFkZCBlbXB0eSBzdHJpbmdzIChpZSwgcGFydHMgYmV0d2VlbiAlcyVzKVxuICAgIGlmKHBhcnQubGVuZ3RoID4gMCkge1xuICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgbGFzdCA9IHJlLmxhc3RJbmRleDtcbiAgICAvLyBzd2l0Y2ggb24gJSBjb2RlXG4gICAgdmFyIGNvZGUgPSBtYXRjaFswXVsxXTtcbiAgICBzd2l0Y2goY29kZSkge1xuICAgIGNhc2UgJ3MnOlxuICAgIGNhc2UgJ28nOlxuICAgICAgLy8gY2hlY2sgaWYgZW5vdWdoIGFyZ3VtZW50cyB3ZXJlIGdpdmVuXG4gICAgICBpZihhcmdpIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBwYXJ0cy5wdXNoKGFyZ3VtZW50c1thcmdpKysgKyAxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5wdXNoKCc8Pz4nKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIC8vIEZJWE1FOiBkbyBwcm9wZXIgZm9ybWF0aW5nIGZvciBudW1iZXJzLCBldGNcbiAgICAvL2Nhc2UgJ2YnOlxuICAgIC8vY2FzZSAnZCc6XG4gICAgY2FzZSAnJSc6XG4gICAgICBwYXJ0cy5wdXNoKCclJyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcGFydHMucHVzaCgnPCUnICsgY29kZSArICc/PicpO1xuICAgIH1cbiAgfVxuICAvLyBhZGQgdHJhaWxpbmcgcGFydCBvZiBmb3JtYXQgc3RyaW5nXG4gIHBhcnRzLnB1c2goZm9ybWF0LnN1YnN0cmluZyhsYXN0KSk7XG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyBhIG51bWJlci5cbiAqXG4gKiBodHRwOi8vc25pcHBsci5jb20vdmlldy81OTQ1L2phdmFzY3JpcHQtbnVtYmVyZm9ybWF0LS1wb3J0ZWQtZnJvbS1waHAvXG4gKi9cbnV0aWwuZm9ybWF0TnVtYmVyID0gZnVuY3Rpb24obnVtYmVyLCBkZWNpbWFscywgZGVjX3BvaW50LCB0aG91c2FuZHNfc2VwKSB7XG4gIC8vIGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0XG4gIC8vICsgICBvcmlnaW5hbCBieTogSm9uYXMgUmFvbmkgU29hcmVzIFNpbHZhIChodHRwOi8vd3d3LmpzZnJvbWhlbGwuY29tKVxuICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAvLyArICAgICBidWdmaXggYnk6IE1pY2hhZWwgV2hpdGUgKGh0dHA6Ly9jcmVzdGlkZy5jb20pXG4gIC8vICsgICAgIGJ1Z2ZpeCBieTogQmVuamFtaW4gTHVwdG9uXG4gIC8vICsgICAgIGJ1Z2ZpeCBieTogQWxsYW4gSmVuc2VuIChodHRwOi8vd3d3LndpbnRlcm5ldC5ubylcbiAgLy8gKyAgICByZXZpc2VkIGJ5OiBKb25hcyBSYW9uaSBTb2FyZXMgU2lsdmEgKGh0dHA6Ly93d3cuanNmcm9taGVsbC5jb20pXG4gIC8vICogICAgIGV4YW1wbGUgMTogbnVtYmVyX2Zvcm1hdCgxMjM0LjU2NzgsIDIsICcuJywgJycpO1xuICAvLyAqICAgICByZXR1cm5zIDE6IDEyMzQuNTdcblxuICB2YXIgbiA9IG51bWJlciwgYyA9IGlzTmFOKGRlY2ltYWxzID0gTWF0aC5hYnMoZGVjaW1hbHMpKSA/IDIgOiBkZWNpbWFscztcbiAgdmFyIGQgPSBkZWNfcG9pbnQgPT09IHVuZGVmaW5lZCA/ICcsJyA6IGRlY19wb2ludDtcbiAgdmFyIHQgPSB0aG91c2FuZHNfc2VwID09PSB1bmRlZmluZWQgP1xuICAgJy4nIDogdGhvdXNhbmRzX3NlcCwgcyA9IG4gPCAwID8gJy0nIDogJyc7XG4gIHZhciBpID0gcGFyc2VJbnQoKG4gPSBNYXRoLmFicygrbiB8fCAwKS50b0ZpeGVkKGMpKSwgMTApICsgJyc7XG4gIHZhciBqID0gKGkubGVuZ3RoID4gMykgPyBpLmxlbmd0aCAlIDMgOiAwO1xuICByZXR1cm4gcyArIChqID8gaS5zdWJzdHIoMCwgaikgKyB0IDogJycpICtcbiAgICBpLnN1YnN0cihqKS5yZXBsYWNlKC8oXFxkezN9KSg/PVxcZCkvZywgJyQxJyArIHQpICtcbiAgICAoYyA/IGQgKyBNYXRoLmFicyhuIC0gaSkudG9GaXhlZChjKS5zbGljZSgyKSA6ICcnKTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyBhIGJ5dGUgc2l6ZS5cbiAqXG4gKiBodHRwOi8vc25pcHBsci5jb20vdmlldy81OTQ5L2Zvcm1hdC1odW1hbml6ZS1maWxlLWJ5dGUtc2l6ZS1wcmVzZW50YXRpb24taW4tamF2YXNjcmlwdC9cbiAqL1xudXRpbC5mb3JtYXRTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICBpZihzaXplID49IDEwNzM3NDE4MjQpIHtcbiAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSAvIDEwNzM3NDE4MjQsIDIsICcuJywgJycpICsgJyBHaUInO1xuICB9IGVsc2UgaWYoc2l6ZSA+PSAxMDQ4NTc2KSB7XG4gICAgc2l6ZSA9IHV0aWwuZm9ybWF0TnVtYmVyKHNpemUgLyAxMDQ4NTc2LCAyLCAnLicsICcnKSArICcgTWlCJztcbiAgfSBlbHNlIGlmKHNpemUgPj0gMTAyNCkge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplIC8gMTAyNCwgMCkgKyAnIEtpQic7XG4gIH0gZWxzZSB7XG4gICAgc2l6ZSA9IHV0aWwuZm9ybWF0TnVtYmVyKHNpemUsIDApICsgJyBieXRlcyc7XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjQgb3IgSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW50byBieXRlcyAoaW4gbmV0d29yayBvcmRlcikuXG4gKlxuICogQHBhcmFtIGlwIHRoZSBJUHY0IG9yIElQdjYgYWRkcmVzcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIDQtYnl0ZSBJUHY2IG9yIDE2LWJ5dGUgSVB2NiBhZGRyZXNzIG9yIG51bGwgaWYgdGhlIGFkZHJlc3MgY2FuJ3RcbiAqICAgICAgICAgYmUgcGFyc2VkLlxuICovXG51dGlsLmJ5dGVzRnJvbUlQID0gZnVuY3Rpb24oaXApIHtcbiAgaWYoaXAuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgIHJldHVybiB1dGlsLmJ5dGVzRnJvbUlQdjQoaXApO1xuICB9XG4gIGlmKGlwLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc0Zyb21JUHY2KGlwKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gSVB2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW50byBieXRlcyAoaW4gbmV0d29yayBvcmRlcikuXG4gKlxuICogQHBhcmFtIGlwIHRoZSBJUHY0IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSA0LWJ5dGUgYWRkcmVzcyBvciBudWxsIGlmIHRoZSBhZGRyZXNzIGNhbid0IGJlIHBhcnNlZC5cbiAqL1xudXRpbC5ieXRlc0Zyb21JUHY0ID0gZnVuY3Rpb24oaXApIHtcbiAgaXAgPSBpcC5zcGxpdCgnLicpO1xuICBpZihpcC5sZW5ndGggIT09IDQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgYiA9IHV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpcC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBudW0gPSBwYXJzZUludChpcFtpXSwgMTApO1xuICAgIGlmKGlzTmFOKG51bSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBiLnB1dEJ5dGUobnVtKTtcbiAgfVxuICByZXR1cm4gYi5nZXRCeXRlcygpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbiBpbnRvIGJ5dGVzIChpbiBuZXR3b3JrIG9yZGVyKS5cbiAqXG4gKiBAcGFyYW0gaXAgdGhlIElQdjYgYWRkcmVzcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIDE2LWJ5dGUgYWRkcmVzcyBvciBudWxsIGlmIHRoZSBhZGRyZXNzIGNhbid0IGJlIHBhcnNlZC5cbiAqL1xudXRpbC5ieXRlc0Zyb21JUHY2ID0gZnVuY3Rpb24oaXApIHtcbiAgdmFyIGJsYW5rcyA9IDA7XG4gIGlwID0gaXAuc3BsaXQoJzonKS5maWx0ZXIoZnVuY3Rpb24oZSkge1xuICAgIGlmKGUubGVuZ3RoID09PSAwKSArK2JsYW5rcztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIHZhciB6ZXJvcyA9ICg4IC0gaXAubGVuZ3RoICsgYmxhbmtzKSAqIDI7XG4gIHZhciBiID0gdXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDg7ICsraSkge1xuICAgIGlmKCFpcFtpXSB8fCBpcFtpXS5sZW5ndGggPT09IDApIHtcbiAgICAgIGIuZmlsbFdpdGhCeXRlKDAsIHplcm9zKTtcbiAgICAgIHplcm9zID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgYnl0ZXMgPSB1dGlsLmhleFRvQnl0ZXMoaXBbaV0pO1xuICAgIGlmKGJ5dGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGIucHV0Qnl0ZSgwKTtcbiAgICB9XG4gICAgYi5wdXRCeXRlcyhieXRlcyk7XG4gIH1cbiAgcmV0dXJuIGIuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgNC1ieXRlcyBpbnRvIGFuIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIDE2LWJ5dGVzIGludG9cbiAqIGFuIElQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiBUaGUgYnl0ZXMgbXVzdCBiZSBpbiBuZXR3b3JrIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBJUHY0IG9yIElQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGlmIDQgb3IgMTYgYnl0ZXMsXG4gKiAgICAgICAgIHJlc3BlY3RpdmVseSwgYXJlIGdpdmVuLCBvdGhlcndpc2UgbnVsbC5cbiAqL1xudXRpbC5ieXRlc1RvSVAgPSBmdW5jdGlvbihieXRlcykge1xuICBpZihieXRlcy5sZW5ndGggPT09IDQpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc1RvSVB2NChieXRlcyk7XG4gIH1cbiAgaWYoYnl0ZXMubGVuZ3RoID09PSAxNikge1xuICAgIHJldHVybiB1dGlsLmJ5dGVzVG9JUHY2KGJ5dGVzKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgNC1ieXRlcyBpbnRvIGFuIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiBUaGUgYnl0ZXMgbXVzdCBiZVxuICogaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb3IgbnVsbCBmb3IgYW4gaW52YWxpZCAjIG9mIGJ5dGVzLlxuICovXG51dGlsLmJ5dGVzVG9JUHY0ID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgaWYoYnl0ZXMubGVuZ3RoICE9PSA0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGlwID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7ICsraSkge1xuICAgIGlwLnB1c2goYnl0ZXMuY2hhckNvZGVBdChpKSk7XG4gIH1cbiAgcmV0dXJuIGlwLmpvaW4oJy4nKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgMTYtYnl0ZXMgaW50byBhbiBJUHYxNiBzdHJpbmcgcmVwcmVzZW50YXRpb24uIFRoZSBieXRlcyBtdXN0IGJlXG4gKiBpbiBuZXR3b3JrIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBJUHYxNiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb3IgbnVsbCBmb3IgYW4gaW52YWxpZCAjIG9mIGJ5dGVzLlxuICovXG51dGlsLmJ5dGVzVG9JUHY2ID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgaWYoYnl0ZXMubGVuZ3RoICE9PSAxNikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpcCA9IFtdO1xuICB2YXIgemVyb0dyb3VwcyA9IFtdO1xuICB2YXIgemVyb01heEdyb3VwID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGhleCA9IHV0aWwuYnl0ZXNUb0hleChieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSk7XG4gICAgLy8gY2Fub25pY2FsaXplIHplcm8gcmVwcmVzZW50YXRpb25cbiAgICB3aGlsZShoZXhbMF0gPT09ICcwJyAmJiBoZXggIT09ICcwJykge1xuICAgICAgaGV4ID0gaGV4LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaWYoaGV4ID09PSAnMCcpIHtcbiAgICAgIHZhciBsYXN0ID0gemVyb0dyb3Vwc1t6ZXJvR3JvdXBzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGlkeCA9IGlwLmxlbmd0aDtcbiAgICAgIGlmKCFsYXN0IHx8IGlkeCAhPT0gbGFzdC5lbmQgKyAxKSB7XG4gICAgICAgIHplcm9Hcm91cHMucHVzaCh7c3RhcnQ6IGlkeCwgZW5kOiBpZHh9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3QuZW5kID0gaWR4O1xuICAgICAgICBpZigobGFzdC5lbmQgLSBsYXN0LnN0YXJ0KSA+XG4gICAgICAgICAgKHplcm9Hcm91cHNbemVyb01heEdyb3VwXS5lbmQgLSB6ZXJvR3JvdXBzW3plcm9NYXhHcm91cF0uc3RhcnQpKSB7XG4gICAgICAgICAgemVyb01heEdyb3VwID0gemVyb0dyb3Vwcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlwLnB1c2goaGV4KTtcbiAgfVxuICBpZih6ZXJvR3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZ3JvdXAgPSB6ZXJvR3JvdXBzW3plcm9NYXhHcm91cF07XG4gICAgLy8gb25seSBzaG9ydGVuIGdyb3VwIG9mIGxlbmd0aCA+IDBcbiAgICBpZihncm91cC5lbmQgLSBncm91cC5zdGFydCA+IDApIHtcbiAgICAgIGlwLnNwbGljZShncm91cC5zdGFydCwgZ3JvdXAuZW5kIC0gZ3JvdXAuc3RhcnQgKyAxLCAnJyk7XG4gICAgICBpZihncm91cC5zdGFydCA9PT0gMCkge1xuICAgICAgICBpcC51bnNoaWZ0KCcnKTtcbiAgICAgIH1cbiAgICAgIGlmKGdyb3VwLmVuZCA9PT0gNykge1xuICAgICAgICBpcC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlwLmpvaW4oJzonKTtcbn07XG5cbi8qKlxuICogRXN0aW1hdGVzIHRoZSBudW1iZXIgb2YgcHJvY2Vzc2VzIHRoYXQgY2FuIGJlIHJ1biBjb25jdXJyZW50bHkuIElmXG4gKiBjcmVhdGluZyBXZWIgV29ya2Vycywga2VlcCBpbiBtaW5kIHRoYXQgdGhlIG1haW4gSmF2YVNjcmlwdCBwcm9jZXNzIG5lZWRzXG4gKiBpdHMgb3duIGNvcmUuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgdXBkYXRlIHRydWUgdG8gZm9yY2UgYW4gdXBkYXRlIChub3QgdXNlIHRoZSBjYWNoZWQgdmFsdWUpLlxuICogQHBhcmFtIGNhbGxiYWNrKGVyciwgbWF4KSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAqL1xudXRpbC5lc3RpbWF0ZUNvcmVzID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZignY29yZXMnIGluIHV0aWwgJiYgIW9wdGlvbnMudXBkYXRlKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgJ2hhcmR3YXJlQ29uY3VycmVuY3knIGluIG5hdmlnYXRvciAmJlxuICAgIG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5ID4gMCkge1xuICAgIHV0aWwuY29yZXMgPSBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gIH1cbiAgaWYodHlwZW9mIFdvcmtlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyB3b3JrZXJzIG5vdCBhdmFpbGFibGVcbiAgICB1dGlsLmNvcmVzID0gMTtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gIH1cbiAgaWYodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gY2FuJ3QgZXN0aW1hdGUsIGRlZmF1bHQgdG8gMlxuICAgIHV0aWwuY29yZXMgPSAyO1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSB3b3JrZXIgY29uY3VycmVuY3kgZXN0aW1hdGlvbiBjb2RlIGFzIGJsb2JcbiAgdmFyIGJsb2JVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFsnKCcsXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vIHJ1biB3b3JrZXIgZm9yIDQgbXNcbiAgICAgICAgdmFyIHN0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIGV0ID0gc3QgKyA0O1xuICAgICAgICB3aGlsZShEYXRlLm5vdygpIDwgZXQpO1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtzdDogc3QsIGV0OiBldH0pO1xuICAgICAgfSk7XG4gICAgfS50b1N0cmluZygpLFxuICAnKSgpJ10sIHt0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCd9KSk7XG5cbiAgLy8gdGFrZSA1IHNhbXBsZXMgdXNpbmcgMTYgd29ya2Vyc1xuICBzYW1wbGUoW10sIDUsIDE2KTtcblxuICBmdW5jdGlvbiBzYW1wbGUobWF4LCBzYW1wbGVzLCBudW1Xb3JrZXJzKSB7XG4gICAgaWYoc2FtcGxlcyA9PT0gMCkge1xuICAgICAgLy8gZ2V0IG92ZXJsYXAgYXZlcmFnZVxuICAgICAgdmFyIGF2ZyA9IE1hdGguZmxvb3IobWF4LnJlZHVjZShmdW5jdGlvbihhdmcsIHgpIHtcbiAgICAgICAgcmV0dXJuIGF2ZyArIHg7XG4gICAgICB9LCAwKSAvIG1heC5sZW5ndGgpO1xuICAgICAgdXRpbC5jb3JlcyA9IE1hdGgubWF4KDEsIGF2Zyk7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVcmwpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICAgIH1cbiAgICBtYXAobnVtV29ya2VycywgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgICBtYXgucHVzaChyZWR1Y2UobnVtV29ya2VycywgcmVzdWx0cykpO1xuICAgICAgc2FtcGxlKG1heCwgc2FtcGxlcyAtIDEsIG51bVdvcmtlcnMpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwKG51bVdvcmtlcnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHdvcmtlcnMgPSBbXTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKGJsb2JVcmwpO1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChlLmRhdGEpO1xuICAgICAgICBpZihyZXN1bHRzLmxlbmd0aCA9PT0gbnVtV29ya2Vycykge1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgICAgICAgIHdvcmtlcnNbaV0udGVybWluYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdvcmtlcnMucHVzaCh3b3JrZXIpO1xuICAgIH1cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICB3b3JrZXJzW2ldLnBvc3RNZXNzYWdlKGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZHVjZShudW1Xb3JrZXJzLCByZXN1bHRzKSB7XG4gICAgLy8gZmluZCBvdmVybGFwcGluZyB0aW1lIHdpbmRvd3NcbiAgICB2YXIgb3ZlcmxhcHMgPSBbXTtcbiAgICBmb3IodmFyIG4gPSAwOyBuIDwgbnVtV29ya2VyczsgKytuKSB7XG4gICAgICB2YXIgcjEgPSByZXN1bHRzW25dO1xuICAgICAgdmFyIG92ZXJsYXAgPSBvdmVybGFwc1tuXSA9IFtdO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgICBpZihuID09PSBpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIyID0gcmVzdWx0c1tpXTtcbiAgICAgICAgaWYoKHIxLnN0ID4gcjIuc3QgJiYgcjEuc3QgPCByMi5ldCkgfHxcbiAgICAgICAgICAocjIuc3QgPiByMS5zdCAmJiByMi5zdCA8IHIxLmV0KSkge1xuICAgICAgICAgIG92ZXJsYXAucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBnZXQgbWF4aW11bSBvdmVybGFwcyAuLi4gZG9uJ3QgaW5jbHVkZSBvdmVybGFwcGluZyB3b3JrZXIgaXRzZWxmXG4gICAgLy8gYXMgdGhlIG1haW4gSlMgcHJvY2VzcyB3YXMgYWxzbyBiZWluZyBzY2hlZHVsZWQgZHVyaW5nIHRoZSB3b3JrIGFuZFxuICAgIC8vIHdvdWxkIGhhdmUgdG8gYmUgc3VidHJhY3RlZCBmcm9tIHRoZSBlc3RpbWF0ZSBhbnl3YXlcbiAgICByZXR1cm4gb3ZlcmxhcHMucmVkdWNlKGZ1bmN0aW9uKG1heCwgb3ZlcmxhcCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KG1heCwgb3ZlcmxhcC5sZW5ndGgpO1xuICAgIH0sIDApO1xuICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJpcGZzXCIsXG4gIFwidmVyc2lvblwiOiBcIjAuMzYuNFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgSVBGUyBzcGVjaWZpY2F0aW9uXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiSVBGU1wiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2pzLmlwZnMuaW9cIixcbiAgXCJidWdzXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2lwZnMvanMtaXBmcy9pc3N1ZXNcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibGVhZE1haW50YWluZXJcIjogXCJBbGFuIFNoYXcgPGFsYW5AdGFibGVmbGlwLmlvPlwiLFxuICBcImZpbGVzXCI6IFtcbiAgICBcInNyY1wiLFxuICAgIFwiZGlzdFwiXG4gIF0sXG4gIFwibWFpblwiOiBcInNyYy9jb3JlL2luZGV4LmpzXCIsXG4gIFwiYnJvd3NlclwiOiB7XG4gICAgXCIuL3NyYy9jb3JlL2NvbXBvbmVudHMvaW5pdC1hc3NldHMuanNcIjogZmFsc2UsXG4gICAgXCIuL3NyYy9jb3JlL3J1bnRpbWUvYWRkLWZyb20tZnMtbm9kZWpzLmpzXCI6IFwiLi9zcmMvY29yZS9ydW50aW1lL2FkZC1mcm9tLWZzLWJyb3dzZXIuanNcIixcbiAgICBcIi4vc3JjL2NvcmUvcnVudGltZS9jb25maWctbm9kZWpzLmpzXCI6IFwiLi9zcmMvY29yZS9ydW50aW1lL2NvbmZpZy1icm93c2VyLmpzXCIsXG4gICAgXCIuL3NyYy9jb3JlL3J1bnRpbWUvZG5zLW5vZGVqcy5qc1wiOiBcIi4vc3JjL2NvcmUvcnVudGltZS9kbnMtYnJvd3Nlci5qc1wiLFxuICAgIFwiLi9zcmMvY29yZS9ydW50aW1lL2ZldGNoLW5vZGVqcy5qc1wiOiBcIi4vc3JjL2NvcmUvcnVudGltZS9mZXRjaC1icm93c2VyLmpzXCIsXG4gICAgXCIuL3NyYy9jb3JlL3J1bnRpbWUvbGlicDJwLW5vZGVqcy5qc1wiOiBcIi4vc3JjL2NvcmUvcnVudGltZS9saWJwMnAtYnJvd3Nlci5qc1wiLFxuICAgIFwiLi9zcmMvY29yZS9ydW50aW1lL3ByZWxvYWQtbm9kZWpzLmpzXCI6IFwiLi9zcmMvY29yZS9ydW50aW1lL3ByZWxvYWQtYnJvd3Nlci5qc1wiLFxuICAgIFwiLi9zcmMvY29yZS9ydW50aW1lL3JlcG8tbm9kZWpzLmpzXCI6IFwiLi9zcmMvY29yZS9ydW50aW1lL3JlcG8tYnJvd3Nlci5qc1wiLFxuICAgIFwiLi9zcmMvY29yZS9ydW50aW1lL2lwbGQtbm9kZWpzLmpzXCI6IFwiLi9zcmMvY29yZS9ydW50aW1lL2lwbGQtYnJvd3Nlci5qc1wiLFxuICAgIFwiLi90ZXN0L3V0aWxzL2NyZWF0ZS1yZXBvLW5vZGVqcy5qc1wiOiBcIi4vdGVzdC91dGlscy9jcmVhdGUtcmVwby1icm93c2VyLmpzXCIsXG4gICAgXCJzdHJlYW1cIjogXCJyZWFkYWJsZS1zdHJlYW1cIlxuICB9LFxuICBcImJyb3dzZXItYWxsLWlwbGQtZm9ybWF0c1wiOiB7XG4gICAgXCIuL3NyYy9jb3JlL3J1bnRpbWUvaXBsZC1icm93c2VyLmpzXCI6IFwiLi9zcmMvY29yZS9ydW50aW1lL2lwbGQtYnJvd3Nlci1hbGwuanNcIlxuICB9LFxuICBcImJpblwiOiB7XG4gICAgXCJqc2lwZnNcIjogXCJzcmMvY2xpL2Jpbi5qc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiBcImdpdGh1YjppcGZzL2pzLWlwZnNcIixcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImxpbnRcIjogXCJhZWdpciBsaW50XCIsXG4gICAgXCJidWlsZFwiOiBcImFlZ2lyIGJ1aWxkXCIsXG4gICAgXCJ0ZXN0XCI6IFwiYWVnaXIgdGVzdFwiLFxuICAgIFwidGVzdDpub2RlXCI6IFwiYWVnaXIgdGVzdCAtdCBub2RlXCIsXG4gICAgXCJ0ZXN0OmJyb3dzZXJcIjogXCJhZWdpciB0ZXN0IC10IGJyb3dzZXJcIixcbiAgICBcInRlc3Q6d2Vid29ya2VyXCI6IFwiYWVnaXIgdGVzdCAtdCB3ZWJ3b3JrZXJcIixcbiAgICBcInRlc3Q6bm9kZTpjb3JlXCI6IFwiYWVnaXIgdGVzdCAtdCBub2RlIC1mIHRlc3QvY29yZS8qKi8qLmpzXCIsXG4gICAgXCJ0ZXN0Om5vZGU6aHR0cFwiOiBcImFlZ2lyIHRlc3QgLXQgbm9kZSAtZiB0ZXN0L2h0dHAtYXBpL2luZGV4LmpzXCIsXG4gICAgXCJ0ZXN0Om5vZGU6Z2F0ZXdheVwiOiBcImFlZ2lyIHRlc3QgLXQgbm9kZSAtZiB0ZXN0L2dhdGV3YXkvaW5kZXguanNcIixcbiAgICBcInRlc3Q6bm9kZTpjbGlcIjogXCJhZWdpciB0ZXN0IC10IG5vZGUgLWYgdGVzdC9jbGkvaW5kZXguanNcIixcbiAgICBcInRlc3Q6bm9kZTppbnRlcmZhY2VcIjogXCJhZWdpciB0ZXN0IC10IG5vZGUgLWYgdGVzdC9jb3JlL2ludGVyZmFjZS5zcGVjLmpzXCIsXG4gICAgXCJ0ZXN0OmJvb3RzdHJhcGVyc1wiOiBcIklQRlNfVEVTVD1ib290c3RyYXBlcnMgYWVnaXIgdGVzdCAtdCBicm93c2VyIC1mIHRlc3QvYm9vdHN0cmFwZXJzLmpzXCIsXG4gICAgXCJiZW5jaG1hcmtcIjogXCJlY2hvIFxcXCJFcnJvcjogbm8gYmVuY2htYXJrcyB5ZXRcXFwiICYmIGV4aXQgMVwiLFxuICAgIFwiYmVuY2htYXJrOm5vZGVcIjogXCJlY2hvIFxcXCJFcnJvcjogbm8gYmVuY2htYXJrcyB5ZXRcXFwiICYmIGV4aXQgMVwiLFxuICAgIFwiYmVuY2htYXJrOm5vZGU6Y29yZVwiOiBcImVjaG8gXFxcIkVycm9yOiBubyBiZW5jaG1hcmtzIHlldFxcXCIgJiYgZXhpdCAxXCIsXG4gICAgXCJiZW5jaG1hcms6bm9kZTpodHRwXCI6IFwiZWNobyBcXFwiRXJyb3I6IG5vIGJlbmNobWFya3MgeWV0XFxcIiAmJiBleGl0IDFcIixcbiAgICBcImJlbmNobWFyazpicm93c2VyXCI6IFwiZWNobyBcXFwiRXJyb3I6IG5vIGJlbmNobWFya3MgeWV0XFxcIiAmJiBleGl0IDFcIixcbiAgICBcInJlbGVhc2VcIjogXCJhZWdpciByZWxlYXNlIC10IG5vZGUgLXQgYnJvd3NlclwiLFxuICAgIFwicmVsZWFzZS1taW5vclwiOiBcImFlZ2lyIHJlbGVhc2UgLS10eXBlIG1pbm9yIC10IG5vZGUgLXQgYnJvd3NlclwiLFxuICAgIFwicmVsZWFzZS1tYWpvclwiOiBcImFlZ2lyIHJlbGVhc2UgLS10eXBlIG1ham9yIC10IG5vZGUgLXQgYnJvd3NlclwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBoYXBpL2FtbW9cIjogXCJeMy4xLjBcIixcbiAgICBcIkBoYXBpL2hhcGlcIjogXCJeMTguMy4xXCIsXG4gICAgXCJAaGFwaS9qb2lcIjogXCJeMTUuMC4xXCIsXG4gICAgXCJhc3luY1wiOiBcIl4yLjYuMVwiLFxuICAgIFwiYXN5bmMtaXRlcmF0b3ItYWxsXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJhc3luYy1pdGVyYXRvci10by1wdWxsLXN0cmVhbVwiOiBcIl4xLjEuMFwiLFxuICAgIFwiYXN5bmMtaXRlcmF0b3ItdG8tc3RyZWFtXCI6IFwiXjEuMS4wXCIsXG4gICAgXCJiYXNlMzIuanNcIjogXCJ+MC4xLjBcIixcbiAgICBcImJpZ251bWJlci5qc1wiOiBcIl45LjAuMFwiLFxuICAgIFwiYmluYXJ5LXF1ZXJ5c3RyaW5nXCI6IFwifjAuMS4yXCIsXG4gICAgXCJibFwiOiBcIl4zLjAuMFwiLFxuICAgIFwiYm9vbVwiOiBcIl43LjIuMFwiLFxuICAgIFwiYnM1OFwiOiBcIl40LjAuMVwiLFxuICAgIFwiYnVmZmVyLXBlZWstc3RyZWFtXCI6IFwiXjEuMC4xXCIsXG4gICAgXCJieXRlbWFuXCI6IFwiXjEuMy41XCIsXG4gICAgXCJjYWxsYmFja2lmeVwiOiBcIl4xLjEuMFwiLFxuICAgIFwiY2lkLXRvb2xcIjogXCJ+MC4zLjBcIixcbiAgICBcImNpZHNcIjogXCJ+MC43LjFcIixcbiAgICBcImNsYXNzLWlzXCI6IFwiXjEuMS4wXCIsXG4gICAgXCJkYXRhc3RvcmUtY29yZVwiOiBcIn4wLjYuMFwiLFxuICAgIFwiZGF0YXN0b3JlLXB1YnN1YlwiOiBcIn4wLjEuMVwiLFxuICAgIFwiZGVidWdcIjogXCJeNC4xLjBcIixcbiAgICBcImRsdlwiOiBcIl4xLjEuM1wiLFxuICAgIFwiZXJyLWNvZGVcIjogXCJeMS4xLjJcIixcbiAgICBcImZpbGUtdHlwZVwiOiBcIl4xMS4xLjBcIixcbiAgICBcImZudjFhXCI6IFwiXjEuMC4xXCIsXG4gICAgXCJmc20tZXZlbnRcIjogXCJeMi4xLjBcIixcbiAgICBcImdldC1mb2xkZXItc2l6ZVwiOiBcIl4yLjAuMFwiLFxuICAgIFwiZ2xvYlwiOiBcIl43LjEuM1wiLFxuICAgIFwiaGFwaS1waW5vXCI6IFwiXjYuMC4wXCIsXG4gICAgXCJodW1hbi10by1taWxsaXNlY29uZHNcIjogXCJeMS4wLjBcIixcbiAgICBcImludGVyZmFjZS1kYXRhc3RvcmVcIjogXCJ+MC42LjBcIixcbiAgICBcImlwZnMtYml0c3dhcFwiOiBcIn4wLjI0LjFcIixcbiAgICBcImlwZnMtYmxvY2tcIjogXCJ+MC44LjFcIixcbiAgICBcImlwZnMtYmxvY2stc2VydmljZVwiOiBcIn4wLjE1LjFcIixcbiAgICBcImlwZnMtaHR0cC1jbGllbnRcIjogXCJeMzIuMC4wXCIsXG4gICAgXCJpcGZzLWh0dHAtcmVzcG9uc2VcIjogXCJ+MC4zLjBcIixcbiAgICBcImlwZnMtbWZzXCI6IFwifjAuMTEuNFwiLFxuICAgIFwiaXBmcy1tdWx0aXBhcnRcIjogXCJ+MC4xLjBcIixcbiAgICBcImlwZnMtcmVwb1wiOiBcIn4wLjI2LjZcIixcbiAgICBcImlwZnMtdW5peGZzXCI6IFwifjAuMS4xNlwiLFxuICAgIFwiaXBmcy11bml4ZnMtZXhwb3J0ZXJcIjogXCJ+MC4zNy42XCIsXG4gICAgXCJpcGZzLXVuaXhmcy1pbXBvcnRlclwiOiBcIn4wLjM5LjlcIixcbiAgICBcImlwZnMtdXRpbHNcIjogXCJ+MC4wLjNcIixcbiAgICBcImlwbGRcIjogXCJ+MC4yNC4xXCIsXG4gICAgXCJpcGxkLWJpdGNvaW5cIjogXCJ+MC4zLjBcIixcbiAgICBcImlwbGQtZGFnLWNib3JcIjogXCJ+MC4xNS4wXCIsXG4gICAgXCJpcGxkLWRhZy1wYlwiOiBcIn4wLjE3LjRcIixcbiAgICBcImlwbGQtZXRoZXJldW1cIjogXCJeNC4wLjBcIixcbiAgICBcImlwbGQtZ2l0XCI6IFwifjAuNS4wXCIsXG4gICAgXCJpcGxkLXJhd1wiOiBcIl40LjAuMFwiLFxuICAgIFwiaXBsZC16Y2FzaFwiOiBcIn4wLjMuMFwiLFxuICAgIFwiaXBuc1wiOiBcIn4wLjUuMlwiLFxuICAgIFwiaXMtaXBmc1wiOiBcIn4wLjYuMVwiLFxuICAgIFwiaXMtcHVsbC1zdHJlYW1cIjogXCJ+MC4wLjBcIixcbiAgICBcImlzLXN0cmVhbVwiOiBcIl4yLjAuMFwiLFxuICAgIFwiaXNvLXVybFwiOiBcIn4wLjQuNlwiLFxuICAgIFwianVzdC1mbGF0dGVuLWl0XCI6IFwiXjIuMS4wXCIsXG4gICAgXCJqdXN0LXNhZmUtc2V0XCI6IFwiXjIuMS4wXCIsXG4gICAgXCJraW5kLW9mXCI6IFwiXjYuMC4yXCIsXG4gICAgXCJsaWJwMnBcIjogXCJ+MC4yNS4zXCIsXG4gICAgXCJsaWJwMnAtYm9vdHN0cmFwXCI6IFwifjAuOS4zXCIsXG4gICAgXCJsaWJwMnAtY3J5cHRvXCI6IFwifjAuMTYuMFwiLFxuICAgIFwibGlicDJwLWthZC1kaHRcIjogXCJ+MC4xNS4xXCIsXG4gICAgXCJsaWJwMnAta2V5Y2hhaW5cIjogXCJ+MC40LjFcIixcbiAgICBcImxpYnAycC1tZG5zXCI6IFwifjAuMTIuMFwiLFxuICAgIFwibGlicDJwLXJlY29yZFwiOiBcIn4wLjYuM1wiLFxuICAgIFwibGlicDJwLXNlY2lvXCI6IFwifjAuMTEuMFwiLFxuICAgIFwibGlicDJwLXRjcFwiOiBcIn4wLjEzLjBcIixcbiAgICBcImxpYnAycC13ZWJydGMtc3RhclwiOiBcIn4wLjE2LjBcIixcbiAgICBcImxpYnAycC13ZWJzb2NrZXQtc3Rhci1tdWx0aVwiOiBcIn4wLjQuM1wiLFxuICAgIFwibGlicDJwLXdlYnNvY2tldHNcIjogXCJ+MC4xMi4yXCIsXG4gICAgXCJsb2Rhc2hcIjogXCJeNC4xNy4xMVwiLFxuICAgIFwibWFmbXRcIjogXCJeNi4wLjJcIixcbiAgICBcIm1lcmdlLW9wdGlvbnNcIjogXCJeMS4wLjFcIixcbiAgICBcIm1pbWUtdHlwZXNcIjogXCJeMi4xLjIxXCIsXG4gICAgXCJta2RpcnBcIjogXCJ+MC41LjFcIixcbiAgICBcIm11bHRpYWRkclwiOiBcIl42LjAuNVwiLFxuICAgIFwibXVsdGlhZGRyLXRvLXVyaVwiOiBcIl40LjAuMVwiLFxuICAgIFwibXVsdGliYXNlXCI6IFwifjAuNi4wXCIsXG4gICAgXCJtdWx0aWNvZGVjXCI6IFwifjAuNS4xXCIsXG4gICAgXCJtdWx0aWhhc2hlc1wiOiBcIn4wLjQuMTRcIixcbiAgICBcIm11bHRpaGFzaGluZy1hc3luY1wiOiBcIn4wLjYuMFwiLFxuICAgIFwibm9kZS1mZXRjaFwiOiBcIl4yLjMuMFwiLFxuICAgIFwicGVlci1ib29rXCI6IFwifjAuOS4wXCIsXG4gICAgXCJwZWVyLWlkXCI6IFwifjAuMTIuMFwiLFxuICAgIFwicGVlci1pbmZvXCI6IFwifjAuMTUuMFwiLFxuICAgIFwicHJvZ3Jlc3NcIjogXCJeMi4wLjFcIixcbiAgICBcInByb21pc2lmeS1lczZcIjogXCJeMS4wLjNcIixcbiAgICBcInByb3RvbnNcIjogXCJeMS4wLjFcIixcbiAgICBcInB1bGwtYWJvcnRhYmxlXCI6IFwiXjQuMS4xXCIsXG4gICAgXCJwdWxsLWNhdFwiOiBcIl4xLjEuMTFcIixcbiAgICBcInB1bGwtZGVmZXJcIjogXCJ+MC4yLjNcIixcbiAgICBcInB1bGwtZmlsZVwiOiBcIl4xLjEuMFwiLFxuICAgIFwicHVsbC1tcGxleFwiOiBcIn4wLjEuMVwiLFxuICAgIFwicHVsbC1uZGpzb25cIjogXCJ+MC4xLjFcIixcbiAgICBcInB1bGwtcHVzaGFibGVcIjogXCJeMi4yLjBcIixcbiAgICBcInB1bGwtc29ydFwiOiBcIl4xLjAuMVwiLFxuICAgIFwicHVsbC1zdHJlYW1cIjogXCJeMy42LjlcIixcbiAgICBcInB1bGwtc3RyZWFtLXRvLWFzeW5jLWl0ZXJhdG9yXCI6IFwiXjEuMC4xXCIsXG4gICAgXCJwdWxsLXN0cmVhbS10by1zdHJlYW1cIjogXCJeMS4zLjRcIixcbiAgICBcInB1bGwtdHJhdmVyc2VcIjogXCJeMS4wLjNcIixcbiAgICBcInJlYWRhYmxlLXN0cmVhbVwiOiBcIl4zLjQuMFwiLFxuICAgIFwicmVjZXB0YWNsZVwiOiBcIl4xLjMuMlwiLFxuICAgIFwic2VtdmVyXCI6IFwiXjYuMS4xXCIsXG4gICAgXCJzdHJlYW0tdG8tcHVsbC1zdHJlYW1cIjogXCJeMS43LjNcIixcbiAgICBcInN1cGVyc3RydWN0XCI6IFwifjAuNi4wXCIsXG4gICAgXCJ0YXItc3RyZWFtXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJ0ZW1wXCI6IFwifjAuOS4wXCIsXG4gICAgXCJ1cGRhdGUtbm90aWZpZXJcIjogXCJeMy4wLjBcIixcbiAgICBcInVyaS10by1tdWx0aWFkZHJcIjogXCJeMy4wLjFcIixcbiAgICBcInZhcmludFwiOiBcIl41LjAuMFwiLFxuICAgIFwieWFyZ3NcIjogXCJeMTMuMi40XCIsXG4gICAgXCJ5YXJncy1wcm9taXNlXCI6IFwiXjEuMS4wXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYWVnaXJcIjogXCJeMTkuMC4zXCIsXG4gICAgXCJiYXNlNjR1cmxcIjogXCJeMy4wLjFcIixcbiAgICBcImNoYWlcIjogXCJeNC4yLjBcIixcbiAgICBcImRlbGF5XCI6IFwiXjQuMS4wXCIsXG4gICAgXCJkZXRlY3Qtbm9kZVwiOiBcIl4yLjAuNFwiLFxuICAgIFwiZGlyLWNvbXBhcmVcIjogXCJeMS40LjBcIixcbiAgICBcImRpcnR5LWNoYWlcIjogXCJeMi4wLjFcIixcbiAgICBcImV4ZWNhXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJmb3JtLWRhdGFcIjogXCJeMi4zLjNcIixcbiAgICBcImhhdFwiOiBcIjAuMC4zXCIsXG4gICAgXCJpbnRlcmZhY2UtaXBmcy1jb3JlXCI6IFwifjAuMTA0LjBcIixcbiAgICBcImlwZnNkLWN0bFwiOiBcIn4wLjQyLjBcIixcbiAgICBcImxpYnAycC13ZWJzb2NrZXQtc3RhclwiOiBcIn4wLjEwLjJcIixcbiAgICBcIm5jcFwiOiBcIl4yLjAuMFwiLFxuICAgIFwicXNcIjogXCJeNi41LjJcIixcbiAgICBcInJpbXJhZlwiOiBcIl4yLjYuMlwiLFxuICAgIFwic2lub25cIjogXCJeNy4zLjFcIixcbiAgICBcInN0cmVhbS10by1wcm9taXNlXCI6IFwiXjIuMi4wXCJcbiAgfSxcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJwcm9tLWNsaWVudFwiOiBcIl4xMS4xLjNcIixcbiAgICBcInByb21ldGhldXMtZ2Mtc3RhdHNcIjogXCJ+MC42LjBcIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49MTAuMC4wXCIsXG4gICAgXCJucG1cIjogXCI+PTYuMC4wXCJcbiAgfSxcbiAgXCJjb250cmlidXRvcnNcIjogW1xuICAgIFwiMHhmbG90dXMgPDB4ZmxvdHVzQGdtYWlsLmNvbT5cIixcbiAgICBcIkFfQSA8MjEwNDA3NTErT3R0by1BQUB1c2Vycy5ub3JlcGx5LmdpdGh1Yi5jb20+XCIsXG4gICAgXCJBbGFuIFNoYXcgPGFsYW4uc2hhd0Bwcm90b2NvbC5haT5cIixcbiAgICBcIkFsYW4gU2hhdyA8YWxhbkB0YWJsZWZsaXAuaW8+XCIsXG4gICAgXCJBbGV4IE5vcnRoIDxhbGV4QGFsZXhub3J0aC5tZT5cIixcbiAgICBcIkFsZXggUG90c2lkZXMgPGFsZXhAYWNoaW5nYnJhaW4ubmV0PlwiLFxuICAgIFwiQW5kcmV3IE5lc2JpdHQgPGFuZHJld25lekBnbWFpbC5jb20+XCIsXG4gICAgXCJBbmRyZXcgZGUgQW5kcmFkZSA8YW5kcmV3QGRlYW5kcmFkZS5jb20uYnI+XCIsXG4gICAgXCJBbmRyw6kgQ3J1eiA8YW5kcmVtaWd1ZWxjcnV6QG1zbi5jb20+XCIsXG4gICAgXCJBcmthZGl5IEt1a2Fya2luIDxwYXJrYW5AdXNlcnMubm9yZXBseS5naXRodWIuY29tPlwiLFxuICAgIFwiQXJwaXQgQWdhcndhbCA8OTNhcnBpdEBnbWFpbC5jb20+XCIsXG4gICAgXCJBcnBpdCBBZ2Fyd2FsIDxhdHZhbmd1YXJkQHVzZXJzLm5vcmVwbHkuZ2l0aHViLmNvbT5cIixcbiAgICBcIkJlcm5hcmQgTW9yZGFuIDxiZXJuYXJkQHRhYmxlZmxpcC5pbz5cIixcbiAgICBcIkJyaWFuIFZhbmRlciBTY2hhYWYgPGJ2czMzMEBnbWFpbC5jb20+XCIsXG4gICAgXCJCcnVubyBaZWxsIDxicnVuby56emVsbEBnbWFpbC5jb20+XCIsXG4gICAgXCJDSEVWQUxBWSBKT1NTRUxJTiA8am9zc2VsaW41NC5jaGV2YWxheUBnbWFpbC5jb20+XCIsXG4gICAgXCJDYWlvIEdvbmRpbSA8bWVAY2Fpb2dvbmRpbS5jb20+XCIsXG4gICAgXCJDaGFuY2UgSHVkc29uIDxqY2hhbmNlaHVkQGdtYWlsLmNvbT5cIixcbiAgICBcIkNoaXJhZyBTaGluZGUgPGNoaXJhZy1zaGluZGVAdXNlcnMubm9yZXBseS5naXRodWIuY29tPlwiLFxuICAgIFwiQ2hyaXN0aWFuIENvdWRlciA8Y2hyaXNjb29sQHR1eGZhbWlseS5vcmc+XCIsXG4gICAgXCJEYWZlbmcgPGRmZ3VvLmpvZUBnbWFpbC5jb20+XCIsXG4gICAgXCJEYW4gT3JkaWxsZSA8ZG9yZGlsbGVAZ21haWwuY29tPlwiLFxuICAgIFwiRGFuaWVsIEouIE8nUXVpbm4gPGRhbmllbGpvcXVpbm5AZ21haWwuY29tPlwiLFxuICAgIFwiRGFuaWVsYSBCb3JnZXMgTWF0b3MgZGUgQ2FydmFsaG8gPGFsdW5hc3NlcnRpdmFAZ21haWwuY29tPlwiLFxuICAgIFwiRGF2aWQgRGlhcyA8ZGF2aWRkaWFzLnBAZ21haWwuY29tPlwiLFxuICAgIFwiRGF2aWQgR2lsYmVydHNvbiA8Z2lsYmVydHNvbi5kYXZpZEBnbWFpbC5jb20+XCIsXG4gICAgXCJEYXZpZCBkYSBTaWx2YSA8ZGFzaWx2YWNvbnRpbkBnbWFpbC5jb20+XCIsXG4gICAgXCJEaW9nbyBTaWx2YSA8ZnNkaW9nb0BnbWFpbC5jb20+XCIsXG4gICAgXCJEbWl0cml5IFJ5YWpvdiA8ZHJ5YWpvdkBnbWFpbC5jb20+XCIsXG4gICAgXCJEem1pdHJ5IERhcyA8ZGJhY2hrb0BnbWFpbC5jb20+XCIsXG4gICAgXCJFbnJpY28gTWFyaW5vIDxlbnJpY28ubWFyaW5vQGVtYWlsLmNvbT5cIixcbiAgICBcIkZhaGVlbCBBaG1hZCA8ZmFoZWVsQGxpdmUuaW4+XCIsXG4gICAgXCJGZWxpeCBZYW4gPGZlbGl4b25tYXJzQGFyY2hsaW51eC5vcmc+XCIsXG4gICAgXCJGcmFuY2lzY28gQmFpbyBEaWFzIDx4aWNvbWJkQGdtYWlsLmNvbT5cIixcbiAgICBcIkZyYW5jaXNjbyBCYWlvIERpYXMgPGZyYW5jaXNjb0B0eXBlZm9ybS5jb20+XCIsXG4gICAgXCJGcmllZGVsIFppZWdlbG1heWVyIDxkaWduaWZpZWRxdWlyZUBnbWFpbC5jb20+XCIsXG4gICAgXCJHYXIgPGdhcitnaEBkYW5nZXIuY29tcHV0ZXI+XCIsXG4gICAgXCJHZW9yZ2lvcyBSYXNzaWFzIDxnZW9yYXNzaWFzQGdtYWlsLmNvbT5cIixcbiAgICBcIkdvcmthIEx1ZGxvdyA8Z29ya2FAYXF1aWdvcmthLmNvbT5cIixcbiAgICBcIkdyYW50IEhlcm1hbiA8Z3JhbnRsb3Vpc2hlcm1hbjA0MUBnbWFpbC5jb20+XCIsXG4gICAgXCJHcmVlbmtlZXBlciA8c3VwcG9ydEBncmVlbmtlZXBlci5pbz5cIixcbiAgICBcIkhhYWQgPGhhYWRjb2RlQHVzZXJzLm5vcmVwbHkuZ2l0aHViLmNvbT5cIixcbiAgICBcIkhhb2xpYW5nIFl1IDxoYW9saWFuZ3l1QHVzZXJzLm5vcmVwbHkuZ2l0aHViLmNvbT5cIixcbiAgICBcIkhhcnNoIFZha2hhcmlhIDxoYXJzaGp2QHVzZXJzLm5vcmVwbHkuZ2l0aHViLmNvbT5cIixcbiAgICBcIkhlbnJpcXVlIERpYXMgPGhhY2RpYXNAZ21haWwuY29tPlwiLFxuICAgIFwiSGVucnkgUm9kcmljayA8bW9zaGlzdXNoaUBnbWFpbC5jb20+XCIsXG4gICAgXCJIZW8gU2FuZ21pbiA8aGVvQG1hcGlhY29tcGFueS5jb20+XCIsXG4gICAgXCJIdWdvIERpYXMgPG1haWxAaHVnb2RpYXMubWU+XCIsXG4gICAgXCJIdWdvIERpYXMgPGh1Z29tcmRpYXNAZ21haWwuY29tPlwiLFxuICAgIFwiSXJha2xpIEdvemFsaXNodmlsaSA8Y29udGFjdEBnb3phbGEuaW8+XCIsXG4gICAgXCJKYWNvYiBIZXVuIDxqYWNvYmhldW5AZ21haWwuY29tPlwiLFxuICAgIFwiSmFjb2IgSGV1biA8amFrZUBhbmR5ZXQubmV0PlwiLFxuICAgIFwiSmFkZSBNZXNraWxsIDxqYWRlLm1lc2tpbGxAZ21haWwuY29tPlwiLFxuICAgIFwiSm9oYW5uZXMgV2lrbmVyIDxqb2hhbm5lcy53aWtuZXJAZ21haWwuY29tPlwiLFxuICAgIFwiSm9uIFNjaGxpbmtlcnQgPGRldkBzZWxsc2lkZS5jb20+XCIsXG4gICAgXCJKb25hdGhhbiA8amtyb25lQHZ0LmVkdT5cIixcbiAgICBcIkpvbnliYW5nIDxKb255YmFuZ2VAZ21haWwuY29tPlwiLFxuICAgIFwiSm/Do28gQW50dW5lcyA8ai5nb25jYWxvLmFudHVuZXNAZ21haWwuY29tPlwiLFxuICAgIFwiSm/Do28gU2FudG9zIDxqb2Fvc2FudG9zMTVAdXNlcnMubm9yZXBseS5naXRodWIuY29tPlwiLFxuICAgIFwiS2V2aW4gV2FuZyA8a2V2aW5AZm9zc2EuaW8+XCIsXG4gICAgXCJMYXJzIEdpZXJ0aCA8bGFyc2dAc3lzdGVtbGkub3JnPlwiLFxuICAgIFwiTHVrYXMgRHJnb24gPGx1a2FzLmRyZ29uQGdtYWlsLmNvbT5cIixcbiAgICBcIk1hY2llaiBLcsO8Z2VyIDxta2cyMDAwMUBnbWFpbC5jb20+XCIsXG4gICAgXCJNYXJjaW4gUmF0YWogPGxpZGVsQGxpZGVsLm9yZz5cIixcbiAgICBcIk1hcml1cyBEYXJpbGEgPG1hcml1cy5kYXJpbGFAZ21haWwuY29tPlwiLFxuICAgIFwiTWF0IEtlbGx5IDxtYWNoYXdrMUBnbWFpbC5jb20+XCIsXG4gICAgXCJNaWNoZWxsZSBMZWUgPG1pY2hlbGxlQHByb3RvY29sLmFpPlwiLFxuICAgIFwiTWlrZWFsIFJvZ2VycyA8bWlrZWFsLnJvZ2Vyc0BnbWFpbC5jb20+XCIsXG4gICAgXCJNaXRoZ29sIDxnZXRnaXRAbWl0aGdvbC5ydT5cIixcbiAgICBcIk1vbGx5IDxtb21hY2syQHVzZXJzLm5vcmVwbHkuZ2l0aHViLmNvbT5cIixcbiAgICBcIk1vdW5pc2ggU2FpIDxwdnNtb3VuaXNoQGdtYWlsLmNvbT5cIixcbiAgICBcIk15OUJvdCA8MzQ5MDQzMTIrTXk5Qm90QHVzZXJzLm5vcmVwbHkuZ2l0aHViLmNvbT5cIixcbiAgICBcIk5pdGluIFBhdGVsIDwzMTUzOTM2NituaWlucGF0ZWxAdXNlcnMubm9yZXBseS5naXRodWIuY29tPlwiLFxuICAgIFwiTnVubyBOb2d1ZWlyYSA8bnVub2ZtbkBnbWFpbC5jb20+XCIsXG4gICAgXCJPbGkgRXZhbnMgPG9saUB0YWJsZWZsaXAuaW8+XCIsXG4gICAgXCJPc2thciBOeWJlcmcgPG9za2FyQG9za2FybnliZXJnLmNvbT5cIixcbiAgICBcIlBhc2NhbCBQcmVjaHQgPHBhc2NhbC5wcmVjaHRAZ29vZ2xlbWFpbC5jb20+XCIsXG4gICAgXCJQYXUgUmFtb24gUmV2aWxsYSA8bWFzeWx1bUBnbWFpbC5jb20+XCIsXG4gICAgXCJQYXVsbyBSb2RyaWd1ZXMgPG1lQHBhdWxvZ3IuY29tPlwiLFxuICAgIFwiUGVkcm8gVGVpeGVpcmEgPGlAcGd0ZS5tZT5cIixcbiAgICBcIlBvcnRpYSBCdXJ0b24gPHBsYnVydG9uQGdtYWlsLmNvbT5cIixcbiAgICBcIlByYWJoYWthciBQb3VkZWwgPHl1dnJhanpvaGFuQGdtYWlsLmNvbT5cIixcbiAgICBcIlJhb3VsIE1pbGxhaXMgPHJhb3VsQHJhb3VsbWlsbGFpcy5jb20+XCIsXG4gICAgXCJSYXNtdXNFcmlrIFZvZWwgSmVuc2VuIDxnaXRodWJAc29sc29ydC5jb20+XCIsXG4gICAgXCJSaWNoYXJkIExpdHRhdWVyIDxyaWNoYXJkLmxpdHRhdWVyQGdtYWlsLmNvbT5cIixcbiAgICBcIlJpY2hhcmQgU2NobmVpZGVyIDxtYWthcmV0dUBnbWFpbC5jb20+XCIsXG4gICAgXCJSb2IgQnJhY2tldHQgPHJvYkByb2JicmFja2V0dC5jb20+XCIsXG4gICAgXCJSb2QgS2V5cyA8cm9kQHpva29zLmNvbT5cIixcbiAgICBcIlNhbmd3b24gSG9uZyA8cXBha3prQGdtYWlsLmNvbT5cIixcbiAgICBcIlNpZCBIYXJkZXIgPHNpZGVoYXJkZXJAZ21haWwuY29tPlwiLFxuICAgIFwiU2lkSGFyZGVyIDxzb2Z0d2FyZW5hdmlnYXRvckBnbWFpbC5jb20+XCIsXG4gICAgXCJTdGVwaGVuIFdoaXRtb3JlIDxzdGVwaGVuLndoaXRtb3JlQGdtYWlsLmNvbT5cIixcbiAgICBcIlN0ZXBoZW4gV2hpdG1vcmUgPG5vZmZsZUB1c2Vycy5ub3JlcGx5LmdpdGh1Yi5jb20+XCIsXG4gICAgXCJTdGV2ZW4gQWxsZW4gPHN0ZXZlbkBzdGViYWxpZW4uY29tPlwiLFxuICAgIFwiVGVyZW5jZSBQYWUgPHRlcmVuY2VwYWVAZ21haWwuY29tPlwiLFxuICAgIFwiVXJvxaEgSnVyZ2xpxI0gPGp1cmdsaWNAZ21haWwuY29tPlwiLFxuICAgIFwiVmFzY28gU2FudG9zIDx2YXNjby5zYW50b3NAbW94eS5zdHVkaW8+XCIsXG4gICAgXCJWYXNjbyBTYW50b3MgPHZhc2NvLnNhbnRvc0B1YS5wdD5cIixcbiAgICBcIlZvbGtlciBNaXNjaGUgPHZvbGtlci5taXNjaGVAZ21haWwuY29tPlwiLFxuICAgIFwiWGlhbyBMaWFuZyA8eXhsaWFuZzAxQHVzZXJzLm5vcmVwbHkuZ2l0aHViLmNvbT5cIixcbiAgICBcIllhaHlhIDx5YTd5YXpAZ21haWwuY29tPlwiLFxuICAgIFwiWW9sZSA8eW9sZUB1bHRpbGVkZ2VyLmlvPlwiLFxuICAgIFwiYml0c3BpbGwgPGJpdHNwaWxsK2dpdGh1YkBiaXRzcGlsbC5uZXQ+XCIsXG4gICAgXCJkYXRhZmF0bXVuZ2VyIDxqYmdAcGVlcnBhcnR5Lm9yZz5cIixcbiAgICBcImRpcmttYyA8ZGlya21kZXZAZ21haWwuY29tPlwiLFxuICAgIFwiZGlya21jIDxkaXJrQG1jY29ybWljay5jeD5cIixcbiAgICBcImdyZWVua2VlcGVyW2JvdF0gPGdyZWVua2VlcGVyW2JvdF1AdXNlcnMubm9yZXBseS5naXRodWIuY29tPlwiLFxuICAgIFwiaGFhZCA8aGFhZEBoZWFkYmFuZ2dhbWVzLmNvbT5cIixcbiAgICBcImpiZW5ldCA8anVhbkBiZW5ldC5haT5cIixcbiAgICBcImpvbmFod2Vpc3NtYW4gPDE5ODA0NDU1K2pvbmFod2Vpc3NtYW5AdXNlcnMubm9yZXBseS5naXRodWIuY29tPlwiLFxuICAgIFwia2V2aW5nemhhbmcgPGtldmluLnpoYW5nLmNhbmFkYUBnbWFpbC5jb20+XCIsXG4gICAgXCJrdW1hdmlzIDxrdW1hdmlzQHVzZXJzLm5vcmVwbHkuZ2l0aHViLmNvbT5cIixcbiAgICBcIm5naW5uZXZlciA8Z2lubmV2ZXJzb3VyY2VAZ21haWwuY29tPlwiLFxuICAgIFwibnBtY2RuLXRvLXVucGtnLWJvdCA8bnBtY2RuLXRvLXVucGtnLWJvdEB1c2Vycy5ub3JlcGx5LmdpdGh1Yi5jb20+XCIsXG4gICAgXCJyb2Jic29sdGVyIDwzNTg3OTgwNityb2Jic29sdGVyQHVzZXJzLm5vcmVwbHkuZ2l0aHViLmNvbT5cIixcbiAgICBcInNldW5nd29uLWthbmcgPGtzdzM4OTRAZ21haWwuY29tPlwiLFxuICAgIFwidGNtZSA8aGlAdGhpcy1jb25uZWN0Lm1lPlwiLFxuICAgIFwidmljdG9yYmplbGtob2xtIDx2aWN0b3JiamVsa2hvbG1AZ21haWwuY29tPlwiLFxuICAgIFwixYF1a2FzeiBNYWdpZXJhIDxtYWdpazZrQHVzZXJzLm5vcmVwbHkuZ2l0aHViLmNvbT5cIixcbiAgICBcItCc0LDQutGB0LjQvCDQmNC70YzQuNC9IDxuZWdhbWF4aUBnbWFpbC5jb20+XCJcbiAgXVxufVxuIiwiLyogZ2xvYmFsIHNlbGYgKi9cbid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IChkb21haW4sIG9wdHMsIGNhbGxiYWNrKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBkb21haW4gPSBlbmNvZGVVUklDb21wb25lbnQoZG9tYWluKVxuICBsZXQgdXJsID0gYGh0dHBzOi8vaXBmcy5pby9hcGkvdjAvZG5zP2FyZz0ke2RvbWFpbn1gXG5cbiAgT2JqZWN0LmtleXMob3B0cykuZm9yRWFjaChwcm9wID0+IHtcbiAgICB1cmwgKz0gYCYke2VuY29kZVVSSUNvbXBvbmVudChwcm9wKX09JHtlbmNvZGVVUklDb21wb25lbnQob3B0c1twcm9wXSl9YFxuICB9KVxuXG4gIHNlbGYuZmV0Y2godXJsLCB7IG1vZGU6ICdjb3JzJyB9KVxuICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0pXG4gICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2UuUGF0aCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UuUGF0aClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IocmVzcG9uc2UuTWVzc2FnZSkpXG4gICAgICB9XG4gICAgfSlcbiAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBjYWxsYmFjayhlcnJvcilcbiAgICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gKCkgPT4gKHtcbiAgQWRkcmVzc2VzOiB7XG4gICAgU3dhcm06IFtcbiAgICBdLFxuICAgIEFQSTogJycsXG4gICAgR2F0ZXdheTogJydcbiAgfSxcbiAgRGlzY292ZXJ5OiB7XG4gICAgTUROUzoge1xuICAgICAgRW5hYmxlZDogZmFsc2UsXG4gICAgICBJbnRlcnZhbDogMTBcbiAgICB9LFxuICAgIHdlYlJUQ1N0YXI6IHtcbiAgICAgIEVuYWJsZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIEJvb3RzdHJhcDogW1xuICAgICcvZG5zNC9hbXMtMS5ib290c3RyYXAubGlicDJwLmlvL3RjcC80NDMvd3NzL2lwZnMvUW1Tb0xlcjI2NU5SZ1NwMkxBM2RQYWV5a2lTMUo2RGlmVEM4OGY1dVZRS05BZCcsXG4gICAgJy9kbnM0L2xvbi0xLmJvb3RzdHJhcC5saWJwMnAuaW8vdGNwLzQ0My93c3MvaXBmcy9RbVNvTE1lV3FCN1lHVkxKTjNwTkxRcG1tRWszNXY2d1l0c01HTHpTcjVRQlUzJyxcbiAgICAnL2RuczQvc2ZvLTMuYm9vdHN0cmFwLmxpYnAycC5pby90Y3AvNDQzL3dzcy9pcGZzL1FtU29MUHBwdUJ0UVNHd0tEWlQyTTczVUxwanZmZDNhWjZoYTRvRkdMMUtyR00nLFxuICAgICcvZG5zNC9zZ3AtMS5ib290c3RyYXAubGlicDJwLmlvL3RjcC80NDMvd3NzL2lwZnMvUW1Tb0xTYWZUTUJzUEthZFRFZ2FYY3REUVZjcU44OENOTEhYTWtUTndNS1BudScsXG4gICAgJy9kbnM0L255Yy0xLmJvb3RzdHJhcC5saWJwMnAuaW8vdGNwLzQ0My93c3MvaXBmcy9RbVNvTHVlUjR4QmVVYlk5V1o5eEdVVXh1bmJLV2NyTkZUREFhZFFKbW9jbldtJyxcbiAgICAnL2RuczQvbnljLTIuYm9vdHN0cmFwLmxpYnAycC5pby90Y3AvNDQzL3dzcy9pcGZzL1FtU29MVjRCYm01MWpNOUM0Z0RZWlE5Q3kzVTZhWE1KREFiemd1MmZ6YURzNjQnLFxuICAgICcvZG5zNC9ub2RlMC5wcmVsb2FkLmlwZnMuaW8vdGNwLzQ0My93c3MvaXBmcy9RbVpNeE5kcE1rZXdpVlpMTVJ4YU54VWVacERVYjM0cFdqWjFrWnZzZDE2WmljJyxcbiAgICAnL2RuczQvbm9kZTEucHJlbG9hZC5pcGZzLmlvL3RjcC80NDMvd3NzL2lwZnMvUW1idXQ5WXd6OVlFRHJ6OHlTQlNnV3lKazQxVXZtMlFKUGh3REp6SnlHRnNENidcbiAgXSxcbiAgU3dhcm06IHtcbiAgICBDb25uTWdyOiB7XG4gICAgICBMb3dXYXRlcjogMjAwLFxuICAgICAgSGlnaFdhdGVyOiA1MDBcbiAgICB9XG4gIH1cbn0pXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgncHJvbWlzaWZ5LWVzNicpXG5jb25zdCBtYXAgPSByZXF1aXJlKCdhc3luYy9tYXAnKVxuY29uc3QgaXNJcGZzID0gcmVxdWlyZSgnaXMtaXBmcycpXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcblxuY29uc3QgRVJSX0JBRF9QQVRIID0gJ0VSUl9CQURfUEFUSCdcbmV4cG9ydHMuT0ZGTElORV9FUlJPUiA9ICdUaGlzIGNvbW1hbmQgbXVzdCBiZSBydW4gaW4gb25saW5lIG1vZGUuIFRyeSBydW5uaW5nIFxcJ2lwZnMgZGFlbW9uXFwnIGZpcnN0LidcblxuLyoqXG4gKiBCcmVhayBhbiBpcGZzLXBhdGggZG93biBpbnRvIGl0J3MgaGFzaCBhbmQgYW4gYXJyYXkgb2YgbGlua3MuXG4gKlxuICogZXhhbXBsZXM6XG4gKiAgYjU4SGFzaCAtPiB7IGhhc2g6ICdiNThIYXNoJywgbGlua3M6IFtdIH1cbiAqICBiNThIYXNoL21lcmN1cnkvdmVudXMgLT4geyBoYXNoOiAnYjU4SGFzaCcsIGxpbmtzOiBbJ21lcmN1cnknLCAndmVudXMnXX1cbiAqICAvaXBmcy9iNThIYXNoL2xpbmtzL2J5L25hbWUgLT4geyBoYXNoOiAnYjU4SGFzaCcsIGxpbmtzOiBbJ2xpbmtzJywgJ2J5JywgJ25hbWUnXSB9XG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBpcGZzUGF0aCBBbiBpcGZzLXBhdGhcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICB7IGhhc2g6IGJhc2U1OCBzdHJpbmcsIGxpbmtzOiBbc3RyaW5nXSwgP2VycjogRXJyb3IgfVxuICogQHRocm93cyBvbiBhbiBpbnZhbGlkIEBwYXJhbSBpcGZzUGF0aFxuICovXG5mdW5jdGlvbiBwYXJzZUlwZnNQYXRoIChpcGZzUGF0aCkge1xuICBjb25zdCBpbnZhbGlkUGF0aEVyciA9IG5ldyBFcnJvcignaW52YWxpZCBpcGZzIHJlZiBwYXRoJylcbiAgaXBmc1BhdGggPSBpcGZzUGF0aC5yZXBsYWNlKC9eXFwvaXBmc1xcLy8sICcnKVxuICBjb25zdCBtYXRjaGVkID0gaXBmc1BhdGgubWF0Y2goLyhbXi9dKyg/OlxcL1teL10rKSopXFwvPyQvKVxuICBpZiAoIW1hdGNoZWQpIHtcbiAgICB0aHJvdyBpbnZhbGlkUGF0aEVyclxuICB9XG5cbiAgY29uc3QgW2hhc2gsIC4uLmxpbmtzXSA9IG1hdGNoZWRbMV0uc3BsaXQoJy8nKVxuXG4gIC8vIGNoZWNrIHRoYXQgYSBDSUQgY2FuIGJlIGNvbnN0cnVjdGVkIHdpdGggdGhlIGhhc2hcbiAgaWYgKGlzSXBmcy5jaWQoaGFzaCkpIHtcbiAgICByZXR1cm4geyBoYXNoLCBsaW5rcyB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgaW52YWxpZFBhdGhFcnJcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSB3ZWxsLWZvcm1lZCBpcGZzIFBhdGguXG4gKiBUaGUgcmV0dXJuZWQgcGF0aCB3aWxsIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIC9pcGZzLyBvciAvaXBucy8uXG4gKiBJZiB0aGUgcmVjZWl2ZWQgc3RyaW5nIGlzIG5vdCBhIHZhbGlkIGlwZnMgcGF0aCwgYW4gZXJyb3Igd2lsbCBiZSByZXR1cm5lZFxuICogZXhhbXBsZXM6XG4gKiAgYjU4SGFzaCAtPiB7IGhhc2g6ICdiNThIYXNoJywgbGlua3M6IFtdIH1cbiAqICBiNThIYXNoL21lcmN1cnkvdmVudXMgLT4geyBoYXNoOiAnYjU4SGFzaCcsIGxpbmtzOiBbJ21lcmN1cnknLCAndmVudXMnXX1cbiAqICAvaXBmcy9iNThIYXNoL2xpbmtzL2J5L25hbWUgLT4geyBoYXNoOiAnYjU4SGFzaCcsIGxpbmtzOiBbJ2xpbmtzJywgJ2J5JywgJ25hbWUnXSB9XG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBwYXRoU3RyIEFuIGlwZnMtcGF0aCwgb3IgaXBucy1wYXRoIG9yIGEgY2lkXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGlwZnMtcGF0aCBvciBpcG5zLXBhdGhcbiAqIEB0aHJvd3Mgb24gYW4gaW52YWxpZCBAcGFyYW0gaXBmc1BhdGhcbiAqL1xuY29uc3Qgbm9ybWFsaXplUGF0aCA9IChwYXRoU3RyKSA9PiB7XG4gIGlmIChpc0lwZnMuY2lkKHBhdGhTdHIpKSB7XG4gICAgcmV0dXJuIGAvaXBmcy8ke3BhdGhTdHJ9YFxuICB9IGVsc2UgaWYgKGlzSXBmcy5wYXRoKHBhdGhTdHIpKSB7XG4gICAgcmV0dXJuIHBhdGhTdHJcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihgaW52YWxpZCAke3BhdGhTdHJ9IHBhdGhgKSwgeyBjb2RlOiBFUlJfQkFEX1BBVEggfSlcbiAgfVxufVxuXG4vKipcbiAqIFJlc29sdmUgdmFyaW91cyBzdHlsZXMgb2YgYW4gaXBmcy1wYXRoIHRvIHRoZSBoYXNoIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAqIEZvbGxvd3MgbGlua3MgaW4gdGhlIHBhdGguXG4gKlxuICogQWNjZXB0cyBmb3JtYXRzOlxuICogIC0gPGJhc2U1OCBzdHJpbmc+XG4gKiAgLSA8YmFzZTU4IHN0cmluZz4vbGluay90by92ZW51c1xuICogIC0gL2lwZnMvPGJhc2U1OCBzdHJpbmc+L2xpbmsvdG8vcGx1dG9cbiAqICAtIG11bHRpaGFzaCBCdWZmZXJcbiAqICAtIEFycmF5cyBvZiB0aGUgYWJvdmVcbiAqXG4gKiBAcGFyYW0gIHtJUEZTfSAgICAgICAgICAgICAgIG9iamVjdEFQSSBUaGUgSVBGUyBvYmplY3QgYXBpXG4gKiBAcGFyYW0gIHtEZXNjcmliZWQgYWJvdmV9ICAgIGlwZnNQYXRocyBBIHNpbmdsZSBvciBjb2xsZWN0aW9uIG9mIGlwZnMtcGF0aHNcbiAqIEBwYXJhbSAge0Z1bmN0aW9uPGVyciwgcmVzPn0gY2FsbGJhY2sgcmVzIGlzIEFycmF5PEJ1ZmZlcihoYXNoKT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkLCByZXR1cm5zIGEgUHJvbWlzZVxuICogQHJldHVybiB7UHJvbWlzZXx2b2lkfVxuICovXG5jb25zdCByZXNvbHZlUGF0aCA9IHByb21pc2lmeShmdW5jdGlvbiAob2JqZWN0QVBJLCBpcGZzUGF0aHMsIGNhbGxiYWNrKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShpcGZzUGF0aHMpKSB7XG4gICAgaXBmc1BhdGhzID0gW2lwZnNQYXRoc11cbiAgfVxuXG4gIG1hcChpcGZzUGF0aHMsIChwYXRoLCBjYikgPT4ge1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBjaWRcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY2lkID0gbmV3IENJRChwYXRoKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYihudWxsLCBjaWQuYnVmZmVyKVxuICAgIH1cblxuICAgIGxldCBwYXJzZWRQYXRoXG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFBhdGggPSBleHBvcnRzLnBhcnNlSXBmc1BhdGgocGF0aClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBjYihlcnIpXG4gICAgfVxuXG4gICAgY29uc3Qgcm9vdEhhc2ggPSBuZXcgQ0lEKHBhcnNlZFBhdGguaGFzaClcbiAgICBjb25zdCByb290TGlua3MgPSBwYXJzZWRQYXRoLmxpbmtzXG5cbiAgICBpZiAoIXJvb3RMaW5rcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjYihudWxsLCByb290SGFzaC5idWZmZXIpXG4gICAgfVxuXG4gICAgb2JqZWN0QVBJLmdldChyb290SGFzaCwgZm9sbG93LmJpbmQobnVsbCwgcm9vdEhhc2gsIHJvb3RMaW5rcykpXG5cbiAgICAvLyByZWN1cnNpdmVseSBmb2xsb3cgbmFtZWQgbGlua3MgdG8gdGhlIHRhcmdldCBub2RlXG4gICAgZnVuY3Rpb24gZm9sbG93IChjaWQsIGxpbmtzLCBlcnIsIG9iaikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuXG4gICAgICBpZiAoIWxpbmtzLmxlbmd0aCkge1xuICAgICAgICAvLyBkb25lIHRyYWNpbmcsIG9iaiBpcyB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIGNpZC5idWZmZXIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxpbmtOYW1lID0gbGlua3NbMF1cbiAgICAgIGNvbnN0IG5leHRPYmogPSBvYmouTGlua3MuZmluZChsaW5rID0+IGxpbmsuTmFtZSA9PT0gbGlua05hbWUpXG5cbiAgICAgIGlmICghbmV4dE9iaikge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBubyBsaW5rIG5hbWVkIFwiJHtsaW5rTmFtZX1cIiB1bmRlciAke2NpZH1gKSlcbiAgICAgIH1cblxuICAgICAgb2JqZWN0QVBJLmdldChuZXh0T2JqLkhhc2gsIGZvbGxvdy5iaW5kKG51bGwsIG5leHRPYmouSGFzaCwgbGlua3Muc2xpY2UoMSkpKVxuICAgIH1cbiAgfSwgY2FsbGJhY2spXG59KVxuXG5leHBvcnRzLm5vcm1hbGl6ZVBhdGggPSBub3JtYWxpemVQYXRoXG5leHBvcnRzLnBhcnNlSXBmc1BhdGggPSBwYXJzZUlwZnNQYXRoXG5leHBvcnRzLnJlc29sdmVQYXRoID0gcmVzb2x2ZVBhdGhcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgc291cmNlcyAgPSByZXF1aXJlKCcuL3NvdXJjZXMnKVxudmFyIHNpbmtzICAgID0gcmVxdWlyZSgnLi9zaW5rcycpXG52YXIgdGhyb3VnaHMgPSByZXF1aXJlKCcuL3Rocm91Z2hzJylcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9wdWxsJylcblxuZXhwb3J0cy5wdWxsID0gZXhwb3J0c1xuXG5mb3IodmFyIGsgaW4gc291cmNlcylcbiAgZXhwb3J0c1trXSA9IHNvdXJjZXNba11cblxuZm9yKHZhciBrIGluIHRocm91Z2hzKVxuICBleHBvcnRzW2tdID0gdGhyb3VnaHNba11cblxuZm9yKHZhciBrIGluIHNpbmtzKVxuICBleHBvcnRzW2tdID0gc2lua3Nba11cblxuIiwibW9kdWxlLmV4cG9ydHMgPSBwdWxsUHVzaGFibGVcblxuZnVuY3Rpb24gcHVsbFB1c2hhYmxlIChzZXBhcmF0ZWQsIG9uQ2xvc2UpIHtcbiAgaWYgKHR5cGVvZiBzZXBhcmF0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkNsb3NlID0gc2VwYXJhdGVkXG4gICAgc2VwYXJhdGVkID0gZmFsc2VcbiAgfVxuXG4gIC8vIGNyZWF0ZSBhIGJ1ZmZlciBmb3IgZGF0YVxuICAvLyB0aGF0IGhhdmUgYmVlbiBwdXNoZWRcbiAgLy8gYnV0IG5vdCB5ZXQgcHVsbGVkLlxuICB2YXIgYnVmZmVyID0gW11cblxuICAvLyBhIHB1c2hhYmxlIGlzIGEgc291cmNlIHN0cmVhbVxuICAvLyAoYWJvcnQsIGNiKSA9PiBjYihlbmQsIGRhdGEpXG4gIC8vXG4gIC8vIHdoZW4gcHVzaGFibGUgaXMgcHVsbGVkLFxuICAvLyBrZWVwIHJlZmVyZW5jZXMgdG8gYWJvcnQgYW5kIGNiXG4gIC8vIHNvIHdlIGNhbiBjYWxsIGJhY2sgYWZ0ZXJcbiAgLy8gLmVuZChlbmQpIG9yIC5wdXNoKGRhdGEpXG4gIHZhciBhYm9ydCwgY2JcbiAgZnVuY3Rpb24gcmVhZCAoX2Fib3J0LCBfY2IpIHtcbiAgICBpZiAoX2Fib3J0KSB7XG4gICAgICBhYm9ydCA9IF9hYm9ydFxuICAgICAgLy8gaWYgdGhlcmUgaXMgYWxyZWFkeSBhIGNiIHdhaXRpbmcsIGFib3J0IGl0LlxuICAgICAgaWYgKGNiKSBjYWxsYmFjayhhYm9ydClcbiAgICB9XG4gICAgY2IgPSBfY2JcbiAgICBkcmFpbigpXG4gIH1cblxuICB2YXIgZW5kZWRcbiAgZnVuY3Rpb24gZW5kIChlbmQpIHtcbiAgICBlbmRlZCA9IGVuZGVkIHx8IGVuZCB8fCB0cnVlXG4gICAgLy8gYXR0ZW1wdCB0byBkcmFpblxuICAgIGRyYWluKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2ggKGRhdGEpIHtcbiAgICBpZiAoZW5kZWQpIHJldHVyblxuICAgIC8vIGlmIHNpbmsgYWxyZWFkeSB3YWl0aW5nLFxuICAgIC8vIHdlIGNhbiBjYWxsIGJhY2sgZGlyZWN0bHkuXG4gICAgaWYgKGNiKSB7XG4gICAgICBjYWxsYmFjayhhYm9ydCwgZGF0YSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgYnVmZmVyIGRhdGFcbiAgICBidWZmZXIucHVzaChkYXRhKVxuICB9XG5cbiAgLy8gUmV0dXJuIGZ1bmN0aW9ucyBzZXBhcmF0ZWQgZnJvbSBzb3VyY2UgeyBwdXNoLCBlbmQsIHNvdXJjZSB9XG4gIGlmIChzZXBhcmF0ZWQpIHtcbiAgICByZXR1cm4geyBwdXNoOiBwdXNoLCBlbmQ6IGVuZCwgc291cmNlOiByZWFkLCBidWZmZXI6IGJ1ZmZlciB9XG4gIH1cblxuICAvLyBSZXR1cm4gbm9ybWFsXG4gIHJlYWQucHVzaCA9IHB1c2hcbiAgcmVhZC5lbmQgPSBlbmRcbiAgcmVhZC5idWZmZXIgPSBidWZmZXJcbiAgcmV0dXJuIHJlYWRcblxuICAvLyBgZHJhaW5gIGNhbGxzIGJhY2sgdG8gKGlmIGFueSkgd2FpdGluZ1xuICAvLyBzaW5rIHdpdGggYWJvcnQsIGVuZCwgb3IgbmV4dCBkYXRhLlxuICBmdW5jdGlvbiBkcmFpbiAoKSB7XG4gICAgaWYgKCFjYikgcmV0dXJuXG5cbiAgICBpZiAoYWJvcnQpIGNhbGxiYWNrKGFib3J0KVxuICAgIGVsc2UgaWYgKCFidWZmZXIubGVuZ3RoICYmIGVuZGVkKSBjYWxsYmFjayhlbmRlZClcbiAgICBlbHNlIGlmIChidWZmZXIubGVuZ3RoKSBjYWxsYmFjayhudWxsLCBidWZmZXIuc2hpZnQoKSlcbiAgfVxuXG4gIC8vIGBjYWxsYmFja2AgY2FsbHMgYmFjayB0byB3YWl0aW5nIHNpbmssXG4gIC8vIGFuZCByZW1vdmVzIHJlZmVyZW5jZXMgdG8gc2luayBjYi5cbiAgZnVuY3Rpb24gY2FsbGJhY2sgKGVyciwgdmFsKSB7XG4gICAgdmFyIF9jYiA9IGNiXG4gICAgLy8gaWYgZXJyb3IgYW5kIHB1c2hhYmxlIHBhc3NlZCBvbkNsb3NlLCBjYWxsIGl0XG4gICAgLy8gdGhlIGZpcnN0IHRpbWUgdGhpcyBzdHJlYW0gZW5kcyBvciBlcnJvcnMuXG4gICAgaWYgKGVyciAmJiBvbkNsb3NlKSB7XG4gICAgICB2YXIgYyA9IG9uQ2xvc2VcbiAgICAgIG9uQ2xvc2UgPSBudWxsXG4gICAgICBjKGVyciA9PT0gdHJ1ZSA/IG51bGwgOiBlcnIpXG4gICAgfVxuICAgIGNiID0gbnVsbFxuICAgIF9jYihlcnIsIHZhbClcbiAgfVxufVxuIiwiXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcblxubW9kdWxlLmV4cG9ydHMgPSBkdXBsZXhcblxuXG5tb2R1bGUuZXhwb3J0cy5zb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gIHJldHVybiBkdXBsZXgobnVsbCwgc291cmNlKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5zaW5rID0gZnVuY3Rpb24gKHNpbmspIHtcbiAgcmV0dXJuIGR1cGxleChzaW5rLCBudWxsKVxufVxuXG52YXIgbmV4dCA9IChcbiAgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiBzZXRJbW1lZGlhdGVcbiAgPyBwcm9jZXNzLm5leHRUaWNrXG4gIDogc2V0SW1tZWRpYXRlXG4pXG5cbmZ1bmN0aW9uIGR1cGxleCAocmVhZGVyLCByZWFkKSB7XG4gIGlmKHJlYWRlciAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHJlYWRlcikge1xuICAgIHJlYWQgPSByZWFkZXIuc291cmNlXG4gICAgcmVhZGVyID0gcmVhZGVyLnNpbmtcbiAgfVxuXG4gIHZhciBjYnMgPSBbXSwgaW5wdXQgPSBbXSwgZW5kZWQsIG5lZWREcmFpblxuICB2YXIgcyA9IG5ldyBTdHJlYW0oKVxuICBzLndyaXRhYmxlID0gcy5yZWFkYWJsZSA9IHRydWVcbiAgcy53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYoY2JzLmxlbmd0aClcbiAgICAgIGNicy5zaGlmdCgpKG51bGwsIGRhdGEpXG4gICAgZWxzZVxuICAgICAgaW5wdXQucHVzaChkYXRhKVxuXG4gICAgaWYgKCFjYnMubGVuZ3RoKSB7XG4gICAgICBuZWVkRHJhaW4gPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiAhIWNicy5sZW5ndGhcbiAgfVxuXG4gIHMuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHJlYWQpIHtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGgpXG4gICAgICAgIGRyYWluKClcbiAgICAgIGVsc2VcbiAgICAgICAgcmVhZChlbmRlZCA9IHRydWUsIGNicy5sZW5ndGggPyBjYnMuc2hpZnQoKSA6IGZ1bmN0aW9uICgpIHt9KVxuICAgIH0gZWxzZSBpZihjYnMubGVuZ3RoKSB7XG4gICAgICBjYnMuc2hpZnQoKSh0cnVlKVxuICAgIH1cbiAgfVxuXG4gIHMuc291cmNlID0gZnVuY3Rpb24gKGVuZCwgY2IpIHtcbiAgICBpZihpbnB1dC5sZW5ndGgpIHtcbiAgICAgIGNiKG51bGwsIGlucHV0LnNoaWZ0KCkpXG4gICAgICBpZighaW5wdXQubGVuZ3RoKVxuICAgICAgICBzLmVtaXQoJ2RyYWluJylcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZihlbmRlZCA9IGVuZGVkIHx8IGVuZClcbiAgICAgICAgY2IoZW5kZWQpXG4gICAgICBlbHNlXG4gICAgICAgIGNicy5wdXNoKGNiKVxuXG4gICAgICBpZiAobmVlZERyYWluKSB7XG4gICAgICAgIG5lZWREcmFpbiA9IGZhbHNlXG4gICAgICAgIHMuZW1pdCgnZHJhaW4nKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBuXG4gIGlmKHJlYWRlcikgbiA9IHJlYWRlcihzLnNvdXJjZSlcbiAgaWYobiAmJiAhcmVhZCkgcmVhZCA9IG5cblxuICB2YXIgb3V0cHV0ID0gW10sIF9jYnMgPSBbXVxuICB2YXIgX2VuZGVkID0gZmFsc2UsIHdhaXRpbmcgPSBmYWxzZSwgYnVzeSA9IGZhbHNlXG5cbiAgcy5zaW5rID0gZnVuY3Rpb24gKF9yZWFkKSB7XG4gICAgcmVhZCA9IF9yZWFkXG4gICAgbmV4dChkcmFpbilcbiAgfVxuXG4gIGlmKHJlYWQpIHtcbiAgICBzLnNpbmsocmVhZClcblxuICAgIHZhciBwaXBlID0gcy5waXBlLmJpbmQocylcbiAgICBzLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgb3B0cykge1xuICAgICAgdmFyIHJlcyA9IHBpcGUoZGVzdCwgb3B0cylcblxuICAgICAgaWYocy5wYXVzZWQpIHMucmVzdW1lKClcblxuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWluICgpIHtcbiAgICB3YWl0aW5nID0gZmFsc2VcbiAgICBpZighcmVhZCB8fCBidXN5KSByZXR1cm5cbiAgICB3aGlsZShvdXRwdXQubGVuZ3RoICYmICFzLnBhdXNlZCkge1xuICAgICAgcy5lbWl0KCdkYXRhJywgb3V0cHV0LnNoaWZ0KCkpXG4gICAgfVxuICAgIGlmKHMucGF1c2VkKSByZXR1cm5cbiAgICBpZihfZW5kZWQpXG4gICAgICByZXR1cm4gcy5lbWl0KCdlbmQnKVxuXG4gICAgYnVzeSA9IHRydWVcbiAgICByZWFkKG51bGwsIGZ1bmN0aW9uIG5leHQgKGVuZCwgZGF0YSkge1xuICAgICAgYnVzeSA9IGZhbHNlXG4gICAgICBpZihzLnBhdXNlZCkge1xuICAgICAgICBpZihlbmQgPT09IHRydWUpIF9lbmRlZCA9IGVuZFxuICAgICAgICBlbHNlIGlmKGVuZCkgcy5lbWl0KCdlcnJvcicsIGVuZClcbiAgICAgICAgZWxzZSBvdXRwdXQucHVzaChkYXRhKVxuICAgICAgICB3YWl0aW5nID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoZW5kICYmIChlbmRlZCA9IGVuZCkgIT09IHRydWUpXG4gICAgICAgICAgcy5lbWl0KCdlcnJvcicsIGVuZClcbiAgICAgICAgZWxzZSBpZihlbmRlZCA9IGVuZGVkIHx8IGVuZCkgcy5lbWl0KCdlbmQnKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgICAgICAgIGJ1c3kgPSB0cnVlXG4gICAgICAgICAgcmVhZChudWxsLCBuZXh0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHMucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcy5wYXVzZWQgPSB0cnVlXG4gICAgcmV0dXJuIHNcbiAgfVxuXG4gIHMucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHMucGF1c2VkID0gZmFsc2VcbiAgICBkcmFpbigpXG4gICAgcmV0dXJuIHNcbiAgfVxuXG4gIHMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighZW5kZWQgJiYgcmVhZClcbiAgICAgIHJlYWQoZW5kZWQgPSB0cnVlLCBmdW5jdGlvbiAoKSB7fSlcbiAgICBlbmRlZCA9IHRydWVcbiAgICBpZihjYnMubGVuZ3RoKVxuICAgICAgY2JzLnNoaWZ0KCkodHJ1ZSlcblxuICAgIHMuZW1pdCgnY2xvc2UnKVxuICB9XG5cbiAgcmV0dXJuIHNcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3IobXNnLCBjb2RlLCBwcm9wcykge1xuICAgIHZhciBlcnIgPSBtc2cgaW5zdGFuY2VvZiBFcnJvciA/IG1zZyA6IG5ldyBFcnJvcihtc2cpO1xuICAgIHZhciBrZXk7XG5cbiAgICBpZiAodHlwZW9mIGNvZGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHByb3BzID0gY29kZTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICBlcnIuY29kZSA9IGNvZGU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICBlcnJba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHByb3RvbnMgPSByZXF1aXJlKCdwcm90b25zJylcbmNvbnN0IHBiID0gcHJvdG9ucyhyZXF1aXJlKCcuL3VuaXhmcy5wcm90bycpKVxuLy8gZW5jb2RlL2RlY29kZVxuY29uc3QgdW5peGZzRGF0YSA9IHBiLkRhdGFcbi8vIGNvbnN0IHVuaXhmc01ldGFkYXRhID0gcGIuTWV0YURhdGEgLy8gZW5jb2RlL2RlY29kZVxuXG5jb25zdCB0eXBlcyA9IFtcbiAgJ3JhdycsXG4gICdkaXJlY3RvcnknLFxuICAnZmlsZScsXG4gICdtZXRhZGF0YScsXG4gICdzeW1saW5rJyxcbiAgJ2hhbXQtc2hhcmRlZC1kaXJlY3RvcnknXG5dXG5cbmNvbnN0IGRpclR5cGVzID0gW1xuICAnZGlyZWN0b3J5JyxcbiAgJ2hhbXQtc2hhcmRlZC1kaXJlY3RvcnknXG5dXG5cbmZ1bmN0aW9uIERhdGEgKHR5cGUsIGRhdGEpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERhdGEpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhKHR5cGUsIGRhdGEpXG4gIH1cbiAgaWYgKHR5cGVzLmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlOiAnICsgdHlwZSArICcgaXMgbm90IHZhbGlkJylcbiAgfVxuXG4gIHRoaXMudHlwZSA9IHR5cGVcbiAgdGhpcy5kYXRhID0gZGF0YVxuICB0aGlzLmJsb2NrU2l6ZXMgPSBbXVxuXG4gIHRoaXMuYWRkQmxvY2tTaXplID0gKHNpemUpID0+IHtcbiAgICB0aGlzLmJsb2NrU2l6ZXMucHVzaChzaXplKVxuICB9XG5cbiAgdGhpcy5yZW1vdmVCbG9ja1NpemUgPSAoaW5kZXgpID0+IHtcbiAgICB0aGlzLmJsb2NrU2l6ZXMuc3BsaWNlKGluZGV4LCAxKVxuICB9XG5cbiAgLy8gZGF0YS5sZW5ndGggKyBibG9ja1NpemVzXG4gIHRoaXMuZmlsZVNpemUgPSAoKSA9PiB7XG4gICAgaWYgKGRpclR5cGVzLmluZGV4T2YodGhpcy50eXBlKSA+PSAwKSB7XG4gICAgICAvLyBkaXJzIGRvbid0IGhhdmUgZmlsZSBzaXplXG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgbGV0IHN1bSA9IDBcbiAgICB0aGlzLmJsb2NrU2l6ZXMuZm9yRWFjaCgoc2l6ZSkgPT4ge1xuICAgICAgc3VtICs9IHNpemVcbiAgICB9KVxuICAgIGlmIChkYXRhKSB7XG4gICAgICBzdW0gKz0gZGF0YS5sZW5ndGhcbiAgICB9XG4gICAgcmV0dXJuIHN1bVxuICB9XG5cbiAgLy8gZW5jb2RlIHRvIHByb3RvYnVmXG4gIHRoaXMubWFyc2hhbCA9ICgpID0+IHtcbiAgICBsZXQgdHlwZVxuXG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3Jhdyc6IHR5cGUgPSB1bml4ZnNEYXRhLkRhdGFUeXBlLlJhdzsgYnJlYWtcbiAgICAgIGNhc2UgJ2RpcmVjdG9yeSc6IHR5cGUgPSB1bml4ZnNEYXRhLkRhdGFUeXBlLkRpcmVjdG9yeTsgYnJlYWtcbiAgICAgIGNhc2UgJ2ZpbGUnOiB0eXBlID0gdW5peGZzRGF0YS5EYXRhVHlwZS5GaWxlOyBicmVha1xuICAgICAgY2FzZSAnbWV0YWRhdGEnOiB0eXBlID0gdW5peGZzRGF0YS5EYXRhVHlwZS5NZXRhZGF0YTsgYnJlYWtcbiAgICAgIGNhc2UgJ3N5bWxpbmsnOiB0eXBlID0gdW5peGZzRGF0YS5EYXRhVHlwZS5TeW1saW5rOyBicmVha1xuICAgICAgY2FzZSAnaGFtdC1zaGFyZGVkLWRpcmVjdG9yeSc6IHR5cGUgPSB1bml4ZnNEYXRhLkRhdGFUeXBlLkhBTVRTaGFyZDsgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rb3duIHR5cGU6IFwiJHt0aGlzLnR5cGV9XCJgKVxuICAgIH1cbiAgICBsZXQgZmlsZVNpemUgPSB0aGlzLmZpbGVTaXplKClcblxuICAgIGxldCBkYXRhID0gdGhpcy5kYXRhXG5cbiAgICBpZiAoIXRoaXMuZGF0YSB8fCAhdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgZGF0YSA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGxldCBibG9ja1NpemVzID0gdGhpcy5ibG9ja1NpemVzXG5cbiAgICBpZiAoIXRoaXMuYmxvY2tTaXplcyB8fCAhdGhpcy5ibG9ja1NpemVzLmxlbmd0aCkge1xuICAgICAgYmxvY2tTaXplcyA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHJldHVybiB1bml4ZnNEYXRhLmVuY29kZSh7XG4gICAgICBUeXBlOiB0eXBlLFxuICAgICAgRGF0YTogZGF0YSxcbiAgICAgIGZpbGVzaXplOiBmaWxlU2l6ZSxcbiAgICAgIGJsb2Nrc2l6ZXM6IGJsb2NrU2l6ZXMsXG4gICAgICBoYXNoVHlwZTogdGhpcy5oYXNoVHlwZSxcbiAgICAgIGZhbm91dDogdGhpcy5mYW5vdXRcbiAgICB9KVxuICB9XG59XG5cbi8vIGRlY29kZSBmcm9tIHByb3RvYnVmIGh0dHBzOi8vZ2l0aHViLmNvbS9pcGZzL2dvLWlwZnMvYmxvYi9tYXN0ZXIvdW5peGZzL2Zvcm1hdC5nbyNMMjRcbkRhdGEudW5tYXJzaGFsID0gKG1hcnNoZWxlZCkgPT4ge1xuICBjb25zdCBkZWNvZGVkID0gdW5peGZzRGF0YS5kZWNvZGUobWFyc2hlbGVkKVxuICBpZiAoIWRlY29kZWQuRGF0YSkge1xuICAgIGRlY29kZWQuRGF0YSA9IHVuZGVmaW5lZFxuICB9XG4gIGNvbnN0IG9iaiA9IG5ldyBEYXRhKHR5cGVzW2RlY29kZWQuVHlwZV0sIGRlY29kZWQuRGF0YSlcbiAgb2JqLmJsb2NrU2l6ZXMgPSBkZWNvZGVkLmJsb2Nrc2l6ZXNcbiAgcmV0dXJuIG9ialxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBEYXRhXG4iLCI7KGZ1bmN0aW9uIChnbG9iYWxPYmplY3QpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4vKlxyXG4gKiAgICAgIGJpZ251bWJlci5qcyB2OS4wLjFcclxuICogICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAyMCBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgICAgIE1JVCBMaWNlbnNlZC5cclxuICpcclxuICogICAgICBCaWdOdW1iZXIucHJvdG90eXBlIG1ldGhvZHMgICAgIHwgIEJpZ051bWJlciBtZXRob2RzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgIGFicyAgICB8ICBjbG9uZVxyXG4gKiAgICAgIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgICAgICAgfCAgY29uZmlnICAgICAgICAgICAgICAgc2V0XHJcbiAqICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgIGRwICAgICB8ICAgICAgREVDSU1BTF9QTEFDRVNcclxuICogICAgICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgZGl2ICAgIHwgICAgICBST1VORElOR19NT0RFXHJcbiAqICAgICAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgIGlkaXYgICB8ICAgICAgRVhQT05FTlRJQUxfQVRcclxuICogICAgICBleHBvbmVudGlhdGVkQnkgICAgICAgICAgcG93ICAgIHwgICAgICBSQU5HRVxyXG4gKiAgICAgIGludGVnZXJWYWx1ZSAgICAgICAgICAgICAgICAgICAgfCAgICAgIENSWVBUT1xyXG4gKiAgICAgIGlzRXF1YWxUbyAgICAgICAgICAgICAgICBlcSAgICAgfCAgICAgIE1PRFVMT19NT0RFXHJcbiAqICAgICAgaXNGaW5pdGUgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgUE9XX1BSRUNJU0lPTlxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW4gICAgICAgICAgICBndCAgICAgfCAgICAgIEZPUk1BVFxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8gICBndGUgICAgfCAgICAgIEFMUEhBQkVUXHJcbiAqICAgICAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgICB8ICBpc0JpZ051bWJlclxyXG4gKiAgICAgIGlzTGVzc1RoYW4gICAgICAgICAgICAgICBsdCAgICAgfCAgbWF4aW11bSAgICAgICAgICAgICAgbWF4XHJcbiAqICAgICAgaXNMZXNzVGhhbk9yRXF1YWxUbyAgICAgIGx0ZSAgICB8ICBtaW5pbXVtICAgICAgICAgICAgICBtaW5cclxuICogICAgICBpc05hTiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJhbmRvbVxyXG4gKiAgICAgIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgICAgICAgfCAgc3VtXHJcbiAqICAgICAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgaXNaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbWludXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbW9kdWxvICAgICAgICAgICAgICAgICAgIG1vZCAgICB8XHJcbiAqICAgICAgbXVsdGlwbGllZEJ5ICAgICAgICAgICAgIHRpbWVzICB8XHJcbiAqICAgICAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcGx1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcHJlY2lzaW9uICAgICAgICAgICAgICAgIHNkICAgICB8XHJcbiAqICAgICAgc2hpZnRlZEJ5ICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgIHNxcnQgICB8XHJcbiAqICAgICAgdG9FeHBvbmVudGlhbCAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GaXhlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9Gb3JtYXQgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GcmFjdGlvbiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9KU09OICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9OdW1iZXIgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9QcmVjaXNpb24gICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbiAgdmFyIEJpZ051bWJlcixcclxuICAgIGlzTnVtZXJpYyA9IC9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cclxuICAgIGJpZ251bWJlckVycm9yID0gJ1tCaWdOdW1iZXIgRXJyb3JdICcsXHJcbiAgICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgICBCQVNFID0gMWUxNCxcclxuICAgIExPR19CQVNFID0gMTQsXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXHJcbiAgICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gICAgLy8gRURJVEFCTEVcclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxyXG4gICAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gICAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xvbmUoY29uZmlnT2JqZWN0KSB7XHJcbiAgICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IEJpZ051bWJlciwgdG9TdHJpbmc6IG51bGwsIHZhbHVlT2Y6IG51bGwgfSxcclxuICAgICAgT05FID0gbmV3IEJpZ051bWJlcigxKSxcclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cclxuICAgICAgLy8gVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5zZXQuXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAgIC8vIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgLy8gRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgLy8gSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAvLyBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzICd0cnVuY2F0ZWQgZGl2aXNpb24nIGFuZCBpc1xyXG4gICAgICAvLyAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cclxuICAgICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgICAgLy8gRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcclxuICAgICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgICAgLy8gQWx0aG91Z2ggdGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvIGJlIHVzZWQsIHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgUE9XX1BSRUNJU0lPTiA9IDAsICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgICBGT1JNQVQgPSB7XHJcbiAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgICAgc3VmZml4OiAnJ1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gVGhlIGFscGhhYmV0IHVzZWQgZm9yIGJhc2UgY29udmVyc2lvbi4gSXQgbXVzdCBiZSBhdCBsZWFzdCAyIGNoYXJhY3RlcnMgbG9uZywgd2l0aCBubyAnKycsXHJcbiAgICAgIC8vICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgIC8vICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJ1xyXG4gICAgICBBTFBIQUJFVCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xyXG5cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUlxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhlIEJpZ051bWJlciBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJpZ051bWJlciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogdiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAqIFtiXSB7bnVtYmVyfSBUaGUgYmFzZSBvZiB2LiBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJpZ051bWJlcih2LCBiKSB7XHJcbiAgICAgIHZhciBhbHBoYWJldCwgYywgY2FzZUNoYW5nZWQsIGUsIGksIGlzTnVtLCBsZW4sIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgYG5ld2AuXHJcbiAgICAgIGlmICghKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpKSByZXR1cm4gbmV3IEJpZ051bWJlcih2LCBiKTtcclxuXHJcbiAgICAgIGlmIChiID09IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHYgJiYgdi5faXNCaWdOdW1iZXIgPT09IHRydWUpIHtcclxuICAgICAgICAgIHgucyA9IHYucztcclxuXHJcbiAgICAgICAgICBpZiAoIXYuYyB8fCB2LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHYuZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5lID0gdi5lO1xyXG4gICAgICAgICAgICB4LmMgPSB2LmMuc2xpY2UoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpICYmIHYgKiAwID09IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBVc2UgYDEgLyBuYCB0byBoYW5kbGUgbWludXMgemVybyBhbHNvLlxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHYgPSAtdiwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGludGVnZXJzLCB3aGVyZSBuIDwgMjE0NzQ4MzY0OCAoMioqMzEpLlxyXG4gICAgICAgICAgaWYgKHYgPT09IH5+dikge1xyXG4gICAgICAgICAgICBmb3IgKGUgPSAwLCBpID0gdjsgaSA+PSAxMDsgaSAvPSAxMCwgZSsrKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgICB4LmMgPSBbdl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBpZiAoIWlzTnVtZXJpYy50ZXN0KHN0ciA9IFN0cmluZyh2KSkpIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSk7XHJcblxyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgICAgICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgICAgICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgICAgIC8vIEludGVnZXIuXHJcbiAgICAgICAgICBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG5cclxuICAgICAgICAvLyBBbGxvdyBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudCwgd2hpbGVcclxuICAgICAgICAvLyBhbHNvIHJvdW5kaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXHJcbiAgICAgICAgaWYgKGIgPT0gMTApIHtcclxuICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHYpO1xyXG4gICAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcblxyXG4gICAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgaWYgKHYgKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICAgIGUgPSBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBzdHIgaXMgYSB2YWxpZCBiYXNlIGIgbnVtYmVyLlxyXG4gICAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcodiksIGlzTnVtLCBiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICAgIGlzTnVtID0gZmFsc2U7XHJcbiAgICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7KTtcclxuXHJcbiAgICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgICAgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgICAgbGVuID4gMTUgJiYgKHYgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHYgIT09IG1hdGhmbG9vcih2KSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7ICAvLyBpIDwgMVxyXG5cclxuICAgICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpID0gTE9HX0JBU0UgLSAoc3RyID0gc3RyLnNsaWNlKGkpKS5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIHguYy5wdXNoKCtzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICAgIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQWNjZXB0IGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyAoaWYgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaXNcclxuICAgICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgICAqXHJcbiAgICAgKiAgIERFQ0lNQUxfUExBQ0VTICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAgICogICBFWFBPTkVOVElBTF9BVCAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAgb3IgIFstTUFYIHRvIDAsIDAgdG8gTUFYXVxyXG4gICAgICogICBSQU5HRSAgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAobm90IHplcm8pICBvciAgWy1NQVggdG8gLTEsIDEgdG8gTUFYXVxyXG4gICAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICAgKiAgIE1PRFVMT19NT0RFICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOVxyXG4gICAgICogICBQT1dfUFJFQ0lTSU9OICAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb250YWluICcuJy5cclxuICAgICAqICAgRk9STUFUICAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggc29tZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cclxuICAgICAqICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGRlY2ltYWxTZXBhcmF0b3IgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAgICogICAgIHN1ZmZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICpcclxuICAgICAqIEUuZy5cclxuICAgICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAgICpcclxuICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCBleGNlcHQgZm9yIEFMUEhBQkVULlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHZhciBwLCB2O1xyXG5cclxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIERFQ0lNQUxfUExBQ0VTIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUk9VTkRJTkdfTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdFWFBPTkVOVElBTF9BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgMCwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtKFRPX0VYUF9QT1MgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JBTkdFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAtMSwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMSwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgICBNQVhfRVhQID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBNSU5fRVhQID0gLShNQVhfRVhQID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGNhbm5vdCBiZSB6ZXJvOiAnICsgdik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIENSWVBUTyBub3QgdHJ1ZSBvciBmYWxzZToge3Z9J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gISF2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9ICF2O1xyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgdHJ1ZSBvciBmYWxzZTogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnTU9EVUxPX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgICAgTU9EVUxPX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFBPV19QUkVDSVNJT04ge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1BPV19QUkVDSVNJT04nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnb2JqZWN0JykgRk9STUFUID0gdjtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IGFuIG9iamVjdDogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQUxQSEFCRVQgaW52YWxpZDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0FMUEhBQkVUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FsbG93IGlmIGxlc3MgdGhhbiB0d28gY2hhcmFjdGVycyxcclxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgY29udGFpbnMgJysnLCAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgYSByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uPyR8WytcXC0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICAgIEFMUEhBQkVUID0gdjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBpbnZhbGlkOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gT2JqZWN0IGV4cGVjdGVkOiB7dn0nXHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdPYmplY3QgZXhwZWN0ZWQ6ICcgKyBvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBERUNJTUFMX1BMQUNFUzogREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgUk9VTkRJTkdfTU9ERTogUk9VTkRJTkdfTU9ERSxcclxuICAgICAgICBFWFBPTkVOVElBTF9BVDogW1RPX0VYUF9ORUcsIFRPX0VYUF9QT1NdLFxyXG4gICAgICAgIFJBTkdFOiBbTUlOX0VYUCwgTUFYX0VYUF0sXHJcbiAgICAgICAgQ1JZUFRPOiBDUllQVE8sXHJcbiAgICAgICAgTU9EVUxPX01PREU6IE1PRFVMT19NT0RFLFxyXG4gICAgICAgIFBPV19QUkVDSVNJT046IFBPV19QUkVDSVNJT04sXHJcbiAgICAgICAgRk9STUFUOiBGT1JNQVQsXHJcbiAgICAgICAgQUxQSEFCRVQ6IEFMUEhBQkVUXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdiBpcyBhIEJpZ051bWJlciBpbnN0YW5jZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBJZiBCaWdOdW1iZXIuREVCVUcgaXMgdHJ1ZSwgdGhyb3cgaWYgYSBCaWdOdW1iZXIgaW5zdGFuY2UgaXMgbm90IHdlbGwtZm9ybWVkLlxyXG4gICAgICpcclxuICAgICAqIHYge2FueX1cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gSW52YWxpZCBCaWdOdW1iZXI6IHt2fSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgaWYgKCF2IHx8IHYuX2lzQmlnTnVtYmVyICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICghQmlnTnVtYmVyLkRFQlVHKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciBpLCBuLFxyXG4gICAgICAgIGMgPSB2LmMsXHJcbiAgICAgICAgZSA9IHYuZSxcclxuICAgICAgICBzID0gdi5zO1xyXG5cclxuICAgICAgb3V0OiBpZiAoe30udG9TdHJpbmcuY2FsbChjKSA9PSAnW29iamVjdCBBcnJheV0nKSB7XHJcblxyXG4gICAgICAgIGlmICgocyA9PT0gMSB8fCBzID09PSAtMSkgJiYgZSA+PSAtTUFYICYmIGUgPD0gTUFYICYmIGUgPT09IG1hdGhmbG9vcihlKSkge1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBlbGVtZW50IGlzIHplcm8sIHRoZSBCaWdOdW1iZXIgdmFsdWUgbXVzdCBiZSB6ZXJvLlxyXG4gICAgICAgICAgaWYgKGNbMF0gPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGUgPT09IDAgJiYgYy5sZW5ndGggPT09IDEpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgdGhhdCBjWzBdIHNob3VsZCBoYXZlLCBiYXNlZCBvbiB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGkgPCAxKSBpICs9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgICAgICAvL2lmIChNYXRoLmNlaWwoTWF0aC5sb2coY1swXSArIDEpIC8gTWF0aC5MTjEwKSA9PSBpKSB7XHJcbiAgICAgICAgICBpZiAoU3RyaW5nKGNbMF0pLmxlbmd0aCA9PSBpKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIG4gPSBjW2ldO1xyXG4gICAgICAgICAgICAgIGlmIChuIDwgMCB8fCBuID49IEJBU0UgfHwgbiAhPT0gbWF0aGZsb29yKG4pKSBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExhc3QgZWxlbWVudCBjYW5ub3QgYmUgemVybywgdW5sZXNzIGl0IGlzIHRoZSBvbmx5IGVsZW1lbnQuXHJcbiAgICAgICAgICAgIGlmIChuICE9PSAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAvLyBJbmZpbml0eS9OYU5cclxuICAgICAgfSBlbHNlIGlmIChjID09PSBudWxsICYmIGUgPT09IG51bGwgJiYgKHMgPT09IG51bGwgfHwgcyA9PT0gMSB8fCBzID09PSAtMSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnSW52YWxpZCBCaWdOdW1iZXI6ICcgKyB2KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1heGltdW0gPSBCaWdOdW1iZXIubWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmx0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1pbmltdW0gPSBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmd0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLFxyXG4gICAgICogYW5kIHdpdGggZHAsIG9yIERFQ0lNQUxfUExBQ0VTIGlmIGRwIGlzIG9taXR0ZWQsIGRlY2ltYWwgcGxhY2VzIChvciBsZXNzIGlmIHRyYWlsaW5nXHJcbiAgICAgKiB6ZXJvcyBhcmUgcHJvZHVjZWQpLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5yYW5kb20gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgcG93Ml81MyA9IDB4MjAwMDAwMDAwMDAwMDA7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gYSA1MyBiaXQgaW50ZWdlciBuLCB3aGVyZSAwIDw9IG4gPCA5MDA3MTk5MjU0NzQwOTkyLlxyXG4gICAgICAvLyBDaGVjayBpZiBNYXRoLnJhbmRvbSgpIHByb2R1Y2VzIG1vcmUgdGhhbiAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXHJcbiAgICAgIC8vIElmIGl0IGRvZXMsIGFzc3VtZSBhdCBsZWFzdCA1MyBiaXRzIGFyZSBwcm9kdWNlZCwgb3RoZXJ3aXNlIGFzc3VtZSBhdCBsZWFzdCAzMCBiaXRzLlxyXG4gICAgICAvLyAweDQwMDAwMDAwIGlzIDJeMzAsIDB4ODAwMDAwIGlzIDJeMjMsIDB4MWZmZmZmIGlzIDJeMjEgLSAxLlxyXG4gICAgICB2YXIgcmFuZG9tNTNiaXRJbnQgPSAoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpICYgMHgxZmZmZmZcclxuICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aGZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKTsgfVxyXG4gICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKE1hdGgucmFuZG9tKCkgKiAweDQwMDAwMDAwIHwgMCkgKiAweDgwMDAwMCkgK1xyXG4gICAgICAgICAoTWF0aC5yYW5kb20oKSAqIDB4ODAwMDAwIHwgMCk7IH07XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRwKSB7XHJcbiAgICAgICAgdmFyIGEsIGIsIGUsIGssIHYsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGMgPSBbXSxcclxuICAgICAgICAgIHJhbmQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAgIGlmIChkcCA9PSBudWxsKSBkcCA9IERFQ0lNQUxfUExBQ0VTO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcblxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChkcCAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgaWYgKENSWVBUTykge1xyXG5cclxuICAgICAgICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICAgICAgICAgIGlmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcblxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoayAqPSAyKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDUzIGJpdHM6XHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSAqIE1hdGgucG93KDIsIDIxKSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTEwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMFxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgPj4+IDExKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMHgyMDAwMCBpcyAyXjIxLlxyXG4gICAgICAgICAgICAgIHYgPSBhW2ldICogMHgyMDAwMCArIChhW2kgKyAxXSA+Pj4gMTEpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBSZWplY3Rpb24gc2FtcGxpbmc6XHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIC8vIFByb2JhYmlsaXR5IHRoYXQgdiA+PSA5ZTE1LCBpc1xyXG4gICAgICAgICAgICAgIC8vIDcxOTkyNTQ3NDA5OTIgLyA5MDA3MTk5MjU0NzQwOTkyIH49IDAuMDAwOCwgaS5lLiAxIGluIDEyNTFcclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBiID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpO1xyXG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbMF07XHJcbiAgICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPD0gODk5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBidWZmZXJcclxuICAgICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDcpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMDAwMDAgaXMgMl40OCwgMHgxMDAwMDAwMDAwMCBpcyAyXjQwXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAgaXMgMl4zMiwgMHgxMDAwMDAwIGlzIDJeMjRcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICB2ID0gKChhW2ldICYgMzEpICogMHgxMDAwMDAwMDAwMDAwKSArIChhW2kgKyAxXSAqIDB4MTAwMDAwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgMl0gKiAweDEwMDAwMDAwMCkgKyAoYVtpICsgM10gKiAweDEwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgNF0gPDwgMTYpICsgKGFbaSArIDVdIDw8IDgpICsgYVtpICsgNl07XHJcblxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KGEsIGkpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSA3O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBDUllQVE8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbS5cclxuICAgICAgICBpZiAoIUNSWVBUTykge1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuICAgICAgICAgICAgdiA9IHJhbmRvbTUzYml0SW50KCk7XHJcbiAgICAgICAgICAgIGlmICh2IDwgOWUxNSkgY1tpKytdID0gdiAlIDFlMTQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBrID0gY1stLWldO1xyXG4gICAgICAgIGRwICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gZHAuXHJcbiAgICAgICAgaWYgKGsgJiYgZHApIHtcclxuICAgICAgICAgIHYgPSBQT1dTX1RFTltMT0dfQkFTRSAtIGRwXTtcclxuICAgICAgICAgIGNbaV0gPSBtYXRoZmxvb3IoayAvIHYpICogdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVyby5cclxuICAgICAgICBmb3IgKDsgY1tpXSA9PT0gMDsgYy5wb3AoKSwgaS0tKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIGMgPSBbZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8gYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGZvciAoZSA9IC0xIDsgY1swXSA9PT0gMDsgYy5zcGxpY2UoMCwgMSksIGUgLT0gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYyB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcywgYW5kLi4uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCB2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICAvLyBhZGp1c3QgdGhlIGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgaWYgKGkgPCBMT0dfQkFTRSkgZSAtPSBMT0dfQkFTRSAtIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByYW5kLmUgPSBlO1xyXG4gICAgICAgIHJhbmQuYyA9IGM7XHJcbiAgICAgICAgcmV0dXJuIHJhbmQ7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuc3VtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgICBzdW0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOykgc3VtID0gc3VtLnBsdXMoYXJnc1tpKytdKTtcclxuICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIFBSSVZBVEUgRlVOQ1RJT05TXHJcblxyXG5cclxuICAgIC8vIENhbGxlZCBieSBCaWdOdW1iZXIgYW5kIEJpZ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcuXHJcbiAgICBjb252ZXJ0QmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBkZWNpbWFsID0gJzAxMjM0NTY3ODknO1xyXG5cclxuICAgICAgLypcclxuICAgICAgICogQ29udmVydCBzdHJpbmcgb2YgYmFzZUluIHRvIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYmFzZU91dC5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGFscGhhYmV0KSB7XHJcbiAgICAgICAgdmFyIGosXHJcbiAgICAgICAgICBhcnIgPSBbMF0sXHJcbiAgICAgICAgICBhcnJMLFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGxlbjspIHtcclxuICAgICAgICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgYXJyW2FyckxdICo9IGJhc2VJbik7XHJcblxyXG4gICAgICAgICAgYXJyWzBdICs9IGFscGhhYmV0LmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcclxuXHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcclxuICAgICAgICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PSBudWxsKSBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyLnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VJbiB0byBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgdG9TdHJpbmcsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZSAxMCB0byBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIEJpZ051bWJlciwgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlSW4gdG8gYmFzZSAxMC5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIsIGJhc2VJbiwgYmFzZU91dCwgc2lnbiwgY2FsbGVySXNUb1N0cmluZykge1xyXG4gICAgICAgIHZhciBhbHBoYWJldCwgZCwgZSwgaywgciwgeCwgeGMsIHksXHJcbiAgICAgICAgICBpID0gc3RyLmluZGV4T2YoJy4nKSxcclxuICAgICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgICBybSA9IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICAgIGsgPSBQT1dfUFJFQ0lTSU9OO1xyXG5cclxuICAgICAgICAgIC8vIFVubGltaXRlZCBwcmVjaXNpb24uXHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gMDtcclxuICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYmFzZUluKTtcclxuICAgICAgICAgIHggPSB5LnBvdyhzdHIubGVuZ3RoIC0gaSk7XHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gaztcclxuXHJcbiAgICAgICAgICAvLyBDb252ZXJ0IHN0ciBhcyBpZiBhbiBpbnRlZ2VyLCB0aGVuIHJlc3RvcmUgdGhlIGZyYWN0aW9uIHBhcnQgYnkgZGl2aWRpbmcgdGhlXHJcbiAgICAgICAgICAvLyByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIuXHJcblxyXG4gICAgICAgICAgeS5jID0gdG9CYXNlT3V0KHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKHguYyksIHguZSwgJzAnKSxcclxuICAgICAgICAgICAxMCwgYmFzZU91dCwgZGVjaW1hbCk7XHJcbiAgICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGludGVnZXIuXHJcblxyXG4gICAgICAgIHhjID0gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBjYWxsZXJJc1RvU3RyaW5nXHJcbiAgICAgICAgID8gKGFscGhhYmV0ID0gQUxQSEFCRVQsIGRlY2ltYWwpXHJcbiAgICAgICAgIDogKGFscGhhYmV0ID0gZGVjaW1hbCwgQUxQSEFCRVQpKTtcclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGFzIGFuIGludGVnZXIgYW5kIGNvbnZlcnRlZCB0byBiYXNlT3V0LiBlIGlzIHRoZSBleHBvbmVudC5cclxuICAgICAgICBlID0gayA9IHhjLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyB4Y1stLWtdID09IDA7IHhjLnBvcCgpKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoIXhjWzBdKSByZXR1cm4gYWxwaGFiZXQuY2hhckF0KDApO1xyXG5cclxuICAgICAgICAvLyBEb2VzIHN0ciByZXByZXNlbnQgYW4gaW50ZWdlcj8gSWYgc28sIG5vIG5lZWQgZm9yIHRoZSBkaXZpc2lvbi5cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIC0tZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5jID0geGM7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG5cclxuICAgICAgICAgIC8vIFRoZSBzaWduIGlzIG5lZWRlZCBmb3IgY29ycmVjdCByb3VuZGluZy5cclxuICAgICAgICAgIHgucyA9IHNpZ247XHJcbiAgICAgICAgICB4ID0gZGl2KHgsIHksIGRwLCBybSwgYmFzZU91dCk7XHJcbiAgICAgICAgICB4YyA9IHguYztcclxuICAgICAgICAgIHIgPSB4LnI7XHJcbiAgICAgICAgICBlID0geC5lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGNvbnZlcnRlZCB0byBiYXNlT3V0LlxyXG5cclxuICAgICAgICAvLyBUSGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgIGQgPSBlICsgZHAgKyAxO1xyXG5cclxuICAgICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQ6IHRoZSBkaWdpdCB0byB0aGUgcmlnaHQgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgaSA9IHhjW2RdO1xyXG5cclxuICAgICAgICAvLyBMb29rIGF0IHRoZSByb3VuZGluZyBkaWdpdHMgYW5kIG1vZGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcm91bmQgdXAuXHJcblxyXG4gICAgICAgIGsgPSBiYXNlT3V0IC8gMjtcclxuICAgICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgciA9IHJtIDwgNCA/IChpICE9IG51bGwgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgICAgOiBpID4gayB8fCBpID09IGsgJiYocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiYgeGNbZCAtIDFdICYgMSB8fFxyXG4gICAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgbm90IGdyZWF0ZXIgdGhhbiB6ZXJvLCBvciB4YyByZXByZXNlbnRzXHJcbiAgICAgICAgLy8gemVybywgdGhlbiB0aGUgcmVzdWx0IG9mIHRoZSBiYXNlIGNvbnZlcnNpb24gaXMgemVybyBvciwgaWYgcm91bmRpbmcgdXAsIGEgdmFsdWVcclxuICAgICAgICAvLyBzdWNoIGFzIDAuMDAwMDEuXHJcbiAgICAgICAgaWYgKGQgPCAxIHx8ICF4Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIDFeLWRwIG9yIDBcclxuICAgICAgICAgIHN0ciA9IHIgPyB0b0ZpeGVkUG9pbnQoYWxwaGFiZXQuY2hhckF0KDEpLCAtZHAsIGFscGhhYmV0LmNoYXJBdCgwKSkgOiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBUcnVuY2F0ZSB4YyB0byB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgeGMubGVuZ3RoID0gZDtcclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxyXG4gICAgICAgICAgICBmb3IgKC0tYmFzZU91dDsgKyt4Y1stLWRdID4gYmFzZU91dDspIHtcclxuICAgICAgICAgICAgICB4Y1tkXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgIGlmICghZCkge1xyXG4gICAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgICAgeGMgPSBbMV0uY29uY2F0KHhjKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGsgPSB4Yy5sZW5ndGg7ICF4Y1stLWtdOyk7XHJcblxyXG4gICAgICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cclxuICAgICAgICAgIGZvciAoaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBhbHBoYWJldC5jaGFyQXQoeGNbaSsrXSkpO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm9zLCBkZWNpbWFsIHBvaW50IGFuZCB0cmFpbGluZyB6ZXJvcyBhcyByZXF1aXJlZC5cclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsIGFscGhhYmV0LmNoYXJBdCgwKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgYWRkIHRoZSBzaWduLlxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvLyBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS4gQ2FsbGVkIGJ5IGRpdiBhbmQgY29udmVydEJhc2UuXHJcbiAgICBkaXYgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgLy8gQXNzdW1lIG5vbi16ZXJvIHggYW5kIGsuXHJcbiAgICAgIGZ1bmN0aW9uIG11bHRpcGx5KHgsIGssIGJhc2UpIHtcclxuICAgICAgICB2YXIgbSwgdGVtcCwgeGxvLCB4aGksXHJcbiAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICBpID0geC5sZW5ndGgsXHJcbiAgICAgICAgICBrbG8gPSBrICUgU1FSVF9CQVNFLFxyXG4gICAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoeCA9IHguc2xpY2UoKTsgaS0tOykge1xyXG4gICAgICAgICAgeGxvID0geFtpXSAlIFNRUlRfQkFTRTtcclxuICAgICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xyXG4gICAgICAgICAgbSA9IGtoaSAqIHhsbyArIHhoaSAqIGtsbztcclxuICAgICAgICAgIHRlbXAgPSBrbG8gKiB4bG8gKyAoKG0gJSBTUVJUX0JBU0UpICogU1FSVF9CQVNFKSArIGNhcnJ5O1xyXG4gICAgICAgICAgY2FycnkgPSAodGVtcCAvIGJhc2UgfCAwKSArIChtIC8gU1FSVF9CQVNFIHwgMCkgKyBraGkgKiB4aGk7XHJcbiAgICAgICAgICB4W2ldID0gdGVtcCAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2FycnkpIHggPSBbY2FycnldLmNvbmNhdCh4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XHJcbiAgICAgICAgdmFyIGksIGNtcDtcclxuXHJcbiAgICAgICAgaWYgKGFMICE9IGJMKSB7XHJcbiAgICAgICAgICBjbXAgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgZm9yIChpID0gY21wID0gMDsgaSA8IGFMOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgICAgICBjbXAgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IGIgZnJvbSBhLlxyXG4gICAgICAgIGZvciAoOyBhTC0tOykge1xyXG4gICAgICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XHJcbiAgICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc3BsaWNlKDAsIDEpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geDogZGl2aWRlbmQsIHk6IGRpdmlzb3IuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgZHAsIHJtLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgICAgeUwsIHl6LFxyXG4gICAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICAgIGlmICgheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcclxuXHJcbiAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXHJcbiAgICAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4YyA/IHljICYmIHhjWzBdID09IHljWzBdIDogIXljKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgwrEwIG9yIHkgaXMgwrFJbmZpbml0eSwgb3IgcmV0dXJuIMKxSW5maW5pdHkgYXMgeSBpcyDCsTAuXHJcbiAgICAgICAgICAgIHhjICYmIHhjWzBdID09IDAgfHwgIXljID8gcyAqIDAgOiBzIC8gMFxyXG4gICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcSA9IG5ldyBCaWdOdW1iZXIocyk7XHJcbiAgICAgICAgcWMgPSBxLmMgPSBbXTtcclxuICAgICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgICAgIHMgPSBkcCArIGUgKyAxO1xyXG5cclxuICAgICAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSAtIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgICAgIHMgPSBzIC8gTE9HX0JBU0UgfCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIGUuXHJcbiAgICAgICAgLy8gVGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgQmlnTnVtYmVycyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoaSA9IDA7IHljW2ldID09ICh4Y1tpXSB8fCAwKTsgaSsrKTtcclxuXHJcbiAgICAgICAgaWYgKHljW2ldID4gKHhjW2ldIHx8IDApKSBlLS07XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCkge1xyXG4gICAgICAgICAgcWMucHVzaCgxKTtcclxuICAgICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICBzICs9IDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9ybWFsaXNlIHhjIGFuZCB5YyBzbyBoaWdoZXN0IG9yZGVyIGRpZ2l0IG9mIHljIGlzID49IGJhc2UgLyAyLlxyXG5cclxuICAgICAgICAgIG4gPSBtYXRoZmxvb3IoYmFzZSAvICh5Y1swXSArIDEpKTtcclxuXHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gaGFuZGxlIG9kZCBiYXNlcyB3aGVyZSB5Y1swXSA9PSAoYmFzZSAvIDIpIC0gMS5cclxuICAgICAgICAgIC8vIGlmIChuID4gMSB8fCBuKysgPT0gMSAmJiB5Y1swXSA8IGJhc2UgLyAyKSB7XHJcbiAgICAgICAgICBpZiAobiA+IDEpIHtcclxuICAgICAgICAgICAgeWMgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHhjID0gbXVsdGlwbHkoeGMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICAgIHJlbSA9IHhjLnNsaWNlKDAsIHlMKTtcclxuICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOyByZW1bcmVtTCsrXSA9IDApO1xyXG4gICAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgeXogPSBbMF0uY29uY2F0KHl6KTtcclxuICAgICAgICAgIHljMCA9IHljWzBdO1xyXG4gICAgICAgICAgaWYgKHljWzFdID49IGJhc2UgLyAyKSB5YzArKztcclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAgIC8vIGVsc2UgaWYgKGJhc2UgPT0gMyAmJiB5YzAgPT0gMSkgeWMwID0gMSArIDFlLTE1O1xyXG5cclxuICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbiA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgY21wID0gY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIG4uXHJcblxyXG4gICAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgICAgaWYgKHlMICE9IHJlbUwpIHJlbTAgPSByZW0wICogYmFzZSArIChyZW1bMV0gfHwgMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG4gaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBuID0gbWF0aGZsb29yKHJlbTAgLyB5YzApO1xyXG5cclxuICAgICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAgIC8vICBwcm9kdWN0ID0gZGl2aXNvciBtdWx0aXBsaWVkIGJ5IHRyaWFsIGRpZ2l0IChuKS5cclxuICAgICAgICAgICAgICAvLyAgQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3QgaXMgZ3JlYXRlciB0aGFuIHJlbWFpbmRlcjpcclxuICAgICAgICAgICAgICAvLyAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdCwgZGVjcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIC8vICBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IHdhcyBsZXNzIHRoYW4gcmVtYWluZGVyIGF0IHRoZSBsYXN0IGNvbXBhcmU6XHJcbiAgICAgICAgICAgICAgLy8gICAgQ29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yLlxyXG4gICAgICAgICAgICAgIC8vICAgIElmIHJlbWFpbmRlciBpcyBncmVhdGVyIHRoYW4gZGl2aXNvcjpcclxuICAgICAgICAgICAgICAvLyAgICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIsIGluY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuXHJcbiAgICAgICAgICAgICAgaWYgKG4gPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBtYXkgYmUgPiBiYXNlIG9ubHkgd2hlbiBiYXNlIGlzIDMuXHJcbiAgICAgICAgICAgICAgICBpZiAobiA+PSBiYXNlKSBuID0gYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0ID4gcmVtYWluZGVyIHRoZW4gdHJpYWwgZGlnaXQgbiB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gaGlnaCBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIGlzIG5vdCBrbm93biB0byBoYXZlXHJcbiAgICAgICAgICAgICAgICAvLyBldmVyIGJlZW4gbW9yZSB0aGFuIDEgdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4tLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5YywgcHJvZEwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICBjbXAgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byBjb21wYXJlIHljIGFuZCByZW0gYWdhaW4gYmVsb3csXHJcbiAgICAgICAgICAgICAgICAvLyBzbyBjaGFuZ2UgY21wIHRvIDEgdG8gYXZvaWQgaXQuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICBpZiAobiA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgcmVtYWluZGVyLCBzbyBuIG11c3QgYmUgYXQgbGVhc3QgMS5cclxuICAgICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3JcclxuICAgICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QgPSBbMF0uY29uY2F0KHByb2QpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbisrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCB5TCA8IHJlbUwgPyB5eiA6IHljLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgICByZW0gPSBbMF07XHJcbiAgICAgICAgICAgIH0gLy8gZWxzZSBjbXAgPT09IDEgYW5kIG4gd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgIHFjW2krK10gPSBuO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChyZW1bMF0pIHtcclxuICAgICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhjW3hpXSB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlbSA9IFt4Y1t4aV1dO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsKSAmJiBzLS0pO1xyXG5cclxuICAgICAgICAgIG1vcmUgPSByZW1bMF0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgICAgICBpZiAoIXFjWzBdKSBxYy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYmFzZSA9PSBCQVNFKSB7XHJcblxyXG4gICAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFjWzBdLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgcyA9IHFjWzBdOyBzID49IDEwOyBzIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIHJvdW5kKHEsIGRwICsgKHEuZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSArIDEsIHJtLCBtb3JlKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbGVyIGlzIGNvbnZlcnRCYXNlLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBxLmUgPSBlO1xyXG4gICAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcTtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAgICogbm90YXRpb24gcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIGRlY2ltYWwgcGxhY2VzIG9yIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAqXHJcbiAgICAgKiBuOiBhIEJpZ051bWJlci5cclxuICAgICAqIGk6IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBkaWdpdCByZXF1aXJlZCAoaS5lLiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cCkuXHJcbiAgICAgKiBybTogdGhlIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgKiBpZDogMSAodG9FeHBvbmVudGlhbCkgb3IgMiAodG9QcmVjaXNpb24pLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmb3JtYXQobiwgaSwgcm0sIGlkKSB7XHJcbiAgICAgIHZhciBjMCwgZSwgbmUsIGxlbiwgc3RyO1xyXG5cclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICBpZiAoIW4uYykgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIGMwID0gbi5jWzBdO1xyXG4gICAgICBuZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChpID09IG51bGwpIHtcclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgc3RyID0gaWQgPT0gMSB8fCBpZCA9PSAyICYmIChuZSA8PSBUT19FWFBfTkVHIHx8IG5lID49IFRPX0VYUF9QT1MpXHJcbiAgICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIG5lKVxyXG4gICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIG5lLCAnMCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBpLCBybSk7XHJcblxyXG4gICAgICAgIC8vIG4uZSBtYXkgaGF2ZSBjaGFuZ2VkIGlmIHRoZSB2YWx1ZSB3YXMgcm91bmRlZCB1cC5cclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICAgIC8vIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlclxyXG4gICAgICAgIC8vIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICBpZiAoaWQgPT0gMSB8fCBpZCA9PSAyICYmIChpIDw9IGUgfHwgZSA8PSBUT19FWFBfTkVHKSkge1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGZvciAoOyBsZW4gPCBpOyBzdHIgKz0gJzAnLCBsZW4rKyk7XHJcbiAgICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKHN0ciwgZSk7XHJcblxyXG4gICAgICAgIC8vIEZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpIC09IG5lO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBpZiAoZSArIDEgPiBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKC0taSA+IDApIGZvciAoc3RyICs9ICcuJzsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgKz0gZSAtIGxlbjtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGUgKyAxID09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSBCaWdOdW1iZXIubWF4IGFuZCBCaWdOdW1iZXIubWluLlxyXG4gICAgZnVuY3Rpb24gbWF4T3JNaW4oYXJncywgbWV0aG9kKSB7XHJcbiAgICAgIHZhciBuLFxyXG4gICAgICAgIGkgPSAxLFxyXG4gICAgICAgIG0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIoYXJnc1tpXSk7XHJcblxyXG4gICAgICAgIC8vIElmIGFueSBudW1iZXIgaXMgTmFOLCByZXR1cm4gTmFOLlxyXG4gICAgICAgIGlmICghbi5zKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kLmNhbGwobSwgbikpIHtcclxuICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBTdHJpcCB0cmFpbGluZyB6ZXJvcywgY2FsY3VsYXRlIGJhc2UgMTAgZXhwb25lbnQgYW5kIGNoZWNrIGFnYWluc3QgTUlOX0VYUCBhbmQgTUFYX0VYUC5cclxuICAgICAqIENhbGxlZCBieSBtaW51cywgcGx1cyBhbmQgdGltZXMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGlzZShuLCBjLCBlKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBqID0gYy5sZW5ndGg7XHJcblxyXG4gICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgIWNbLS1qXTsgYy5wb3AoKSk7XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQuIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICBmb3IgKGogPSBjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgIGlmICgoZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgbi5jID0gbi5lID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIG4uYyA9IFtuLmUgPSAwXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuLmUgPSBlO1xyXG4gICAgICAgIG4uYyA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgdmFsdWVzIHRoYXQgZmFpbCB0aGUgdmFsaWRpdHkgdGVzdCBpbiBCaWdOdW1iZXIuXHJcbiAgICBwYXJzZU51bWVyaWMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2ksXHJcbiAgICAgICAgZG90QWZ0ZXIgPSAvXihbXi5dKylcXC4kLyxcclxuICAgICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcclxuICAgICAgICBpc0luZmluaXR5T3JOYU4gPSAvXi0/KEluZmluaXR5fE5hTikkLyxcclxuICAgICAgICB3aGl0ZXNwYWNlT3JQbHVzID0gL15cXHMqXFwrKD89W1xcdy5dKXxeXFxzK3xcXHMrJC9nO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBzdHIsIGlzTnVtLCBiKSB7XHJcbiAgICAgICAgdmFyIGJhc2UsXHJcbiAgICAgICAgICBzID0gaXNOdW0gPyBzdHIgOiBzdHIucmVwbGFjZSh3aGl0ZXNwYWNlT3JQbHVzLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAgICBpZiAoaXNJbmZpbml0eU9yTmFOLnRlc3QocykpIHtcclxuICAgICAgICAgIHgucyA9IGlzTmFOKHMpID8gbnVsbCA6IHMgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoIWlzTnVtKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaVxyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGJhc2VQcmVmaXgsIGZ1bmN0aW9uIChtLCBwMSwgcDIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gKHAyID0gcDIudG9Mb3dlckNhc2UoKSkgPT0gJ3gnID8gMTYgOiBwMiA9PSAnYicgPyAyIDogODtcclxuICAgICAgICAgICAgICByZXR1cm4gIWIgfHwgYiA9PSBiYXNlID8gcDEgOiBtO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IGI7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEUuZy4gJzEuJyB0byAnMScsICcuMScgdG8gJzAuMSdcclxuICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGRvdEFmdGVyLCAnJDEnKS5yZXBsYWNlKGRvdEJlZm9yZSwgJzAuJDEnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHN0ciAhPSBzKSByZXR1cm4gbmV3IEJpZ051bWJlcihzLCBiYXNlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ05vdCBhJyArIChiID8gJyBiYXNlICcgKyBiIDogJycpICsgJyBudW1iZXI6ICcgKyBzdHIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE5hTlxyXG4gICAgICAgICAgeC5zID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSb3VuZCB4IHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gICAgICogSWYgciBpcyB0cnV0aHksIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgYXJlIG1vcmUgZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcm91bmQoeCwgc2QsIHJtLCByKSB7XHJcbiAgICAgIHZhciBkLCBpLCBqLCBrLCBuLCBuaSwgcmQsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgcG93czEwID0gUE9XU19URU47XHJcblxyXG4gICAgICAvLyBpZiB4IGlzIG5vdCBJbmZpbml0eSBvciBOYU4uLi5cclxuICAgICAgaWYgKHhjKSB7XHJcblxyXG4gICAgICAgIC8vIHJkIGlzIHRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgLy8gbiBpcyBhIGJhc2UgMWUxNCBudW1iZXIsIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBvZiBhcnJheSB4LmMgY29udGFpbmluZyByZC5cclxuICAgICAgICAvLyBuaSBpcyB0aGUgaW5kZXggb2YgbiB3aXRoaW4geC5jLlxyXG4gICAgICAgIC8vIGQgaXMgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAvLyBpIGlzIHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiBpbmNsdWRpbmcgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAvLyBqIGlzIHRoZSBhY3R1YWwgaW5kZXggb2YgcmQgd2l0aGluIG4gKGlmIDwgMCwgcmQgaXMgYSBsZWFkaW5nIHplcm8pLlxyXG4gICAgICAgIG91dDoge1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy5cclxuICAgICAgICAgIGZvciAoZCA9IDEsIGsgPSB4Y1swXTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuICAgICAgICAgIGkgPSBzZCAtIGQ7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgICAgaSArPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgaiA9IHNkO1xyXG4gICAgICAgICAgICBuID0geGNbbmkgPSAwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICByZCA9IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5pID0gbWF0aGNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuaSA+PSB4Yy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cclxuICAgICAgICAgICAgICAgIGZvciAoOyB4Yy5sZW5ndGggPD0gbmk7IHhjLnB1c2goMCkpO1xyXG4gICAgICAgICAgICAgICAgbiA9IHJkID0gMDtcclxuICAgICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG4gPSBrID0geGNbbmldO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAgICAgICBmb3IgKGQgPSAxOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLlxyXG4gICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuIGlzIGdpdmVuIGJ5IExPR19CQVNFIC0gZC5cclxuICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcclxuXHJcbiAgICAgICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICAgICAgICAvLyBUaGUgZXhwcmVzc2lvbiAgbiAlIHBvd3MxMFtkIC0gaiAtIDFdICByZXR1cm5zIGFsbCBkaWdpdHMgb2YgbiB0byB0aGUgcmlnaHRcclxuICAgICAgICAgIC8vIG9mIHRoZSBkaWdpdCBhdCBqLCBlLmcuIGlmIG4gaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uIGdpdmVzIDcxNC5cclxuICAgICAgICAgICB4Y1tuaSArIDFdICE9IG51bGwgfHwgKGogPCAwID8gbiA6IG4gJSBwb3dzMTBbZCAtIGogLSAxXSk7XHJcblxyXG4gICAgICAgICAgciA9IHJtIDwgNFxyXG4gICAgICAgICAgID8gKHJkIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxyXG4gICAgICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwW2QgLSBqXSA6IDAgOiB4Y1tuaSAtIDFdKSAlIDEwKSAmIDEgfHxcclxuICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgICBpZiAoc2QgPCAxIHx8ICF4Y1swXSkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29udmVydCBzZCB0byBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0gcG93czEwWyhMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0VdO1xyXG4gICAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0geC5lID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGV4Y2VzcyBkaWdpdHMuXHJcbiAgICAgICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xyXG4gICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgbmktLTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pICsgMTtcclxuICAgICAgICAgICAgayA9IHBvd3MxMFtMT0dfQkFTRSAtIGldO1xyXG5cclxuICAgICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygbi5cclxuICAgICAgICAgICAgeGNbbmldID0gaiA+IDAgPyBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gal0gJSBwb3dzMTBbal0pICogayA6IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgICAgICBpZiAobmkgPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhjWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IHhjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG4gICAgICAgICAgICAgICAgaiA9IHhjWzBdICs9IGs7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKyspO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoeGNbMF0gPT0gQkFTRSkgeGNbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaV0gKz0gaztcclxuICAgICAgICAgICAgICAgIGlmICh4Y1tuaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaS0tXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGkgPSB4Yy5sZW5ndGg7IHhjWy0taV0gPT09IDA7IHhjLnBvcCgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE92ZXJmbG93PyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93PyBaZXJvLlxyXG4gICAgICAgIH0gZWxzZSBpZiAoeC5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHZhbHVlT2Yobikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuXHJcbiAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBlKVxyXG4gICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBQUk9UT1RZUEUvSU5TVEFOQ0UgTUVUSE9EU1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXHJcbiAgICAgKi9cclxuICAgIFAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmICh4LnMgPCAwKSB4LnMgPSAxO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm5cclxuICAgICAqICAgMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIC0xIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAgICAgKiAgIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBpcyBOYU4uXHJcbiAgICAgKi9cclxuICAgIFAuY29tcGFyZWRUbyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIGRwIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9mIHRoZVxyXG4gICAgICogdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgZHAgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXM6IGludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICBuID0gKCh2ID0gYy5sZW5ndGggLSAxKSAtIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSkgKiBMT0dfQkFTRTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgbnVtYmVyLlxyXG4gICAgICBpZiAodiA9IGNbdl0pIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuICAgICAgaWYgKG4gPCAwKSBuID0gMDtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC8gMCA9IElcclxuICAgICAqICBuIC8gTiA9IE5cclxuICAgICAqICBuIC8gSSA9IDBcclxuICAgICAqICAwIC8gbiA9IDBcclxuICAgICAqICAwIC8gMCA9IE5cclxuICAgICAqICAwIC8gTiA9IE5cclxuICAgICAqICAwIC8gSSA9IDBcclxuICAgICAqICBOIC8gbiA9IE5cclxuICAgICAqICBOIC8gMCA9IE5cclxuICAgICAqICBOIC8gTiA9IE5cclxuICAgICAqICBOIC8gSSA9IE5cclxuICAgICAqICBJIC8gbiA9IElcclxuICAgICAqICBJIC8gMCA9IElcclxuICAgICAqICBJIC8gTiA9IE5cclxuICAgICAqICBJIC8gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgREVDSU1BTF9QTEFDRVMsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIGJ5IHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5pZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCAwLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGV4cG9uZW50aWF0ZWQgYnkgbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBtIGlzIHByZXNlbnQsIHJldHVybiB0aGUgcmVzdWx0IG1vZHVsbyBtLlxyXG4gICAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vbi16ZXJvIGFuZCBtIGlzIG5vdCBwcmVzZW50LCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIG1vZHVsYXIgcG93ZXIgb3BlcmF0aW9uIHdvcmtzIGVmZmljaWVudGx5IHdoZW4geCwgbiwgYW5kIG0gYXJlIGludGVnZXJzLCBvdGhlcndpc2UgaXRcclxuICAgICAqIGlzIGVxdWl2YWxlbnQgdG8gY2FsY3VsYXRpbmcgeC5leHBvbmVudGlhdGVkQnkobikubW9kdWxvKG0pIHdpdGggYSBQT1dfUFJFQ0lTSU9OIG9mIDAuXHJcbiAgICAgKlxyXG4gICAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBleHBvbmVudC4gQW4gaW50ZWdlci5cclxuICAgICAqIFttXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBtb2R1bHVzLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBFeHBvbmVudCBub3QgYW4gaW50ZWdlcjoge259J1xyXG4gICAgICovXHJcbiAgICBQLmV4cG9uZW50aWF0ZWRCeSA9IFAucG93ID0gZnVuY3Rpb24gKG4sIG0pIHtcclxuICAgICAgdmFyIGhhbGYsIGlzTW9kRXhwLCBpLCBrLCBtb3JlLCBuSXNCaWcsIG5Jc05lZywgbklzT2RkLCB5LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobik7XHJcblxyXG4gICAgICAvLyBBbGxvdyBOYU4gYW5kIMKxSW5maW5pdHksIGJ1dCBub3Qgb3RoZXIgbm9uLWludGVnZXJzLlxyXG4gICAgICBpZiAobi5jICYmICFuLmlzSW50ZWdlcigpKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogJyArIHZhbHVlT2YobikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobSAhPSBudWxsKSBtID0gbmV3IEJpZ051bWJlcihtKTtcclxuXHJcbiAgICAgIC8vIEV4cG9uZW50IG9mIE1BWF9TQUZFX0lOVEVHRVIgaXMgMTUuXHJcbiAgICAgIG5Jc0JpZyA9IG4uZSA+IDE0O1xyXG5cclxuICAgICAgLy8gSWYgeCBpcyBOYU4sIMKxSW5maW5pdHksIMKxMCBvciDCsTEsIG9yIG4gaXMgwrFJbmZpbml0eSwgTmFOIG9yIMKxMC5cclxuICAgICAgaWYgKCF4LmMgfHwgIXguY1swXSB8fCB4LmNbMF0gPT0gMSAmJiAheC5lICYmIHguYy5sZW5ndGggPT0gMSB8fCAhbi5jIHx8ICFuLmNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gVGhlIHNpZ24gb2YgdGhlIHJlc3VsdCBvZiBwb3cgd2hlbiB4IGlzIG5lZ2F0aXZlIGRlcGVuZHMgb24gdGhlIGV2ZW5uZXNzIG9mIG4uXHJcbiAgICAgICAgLy8gSWYgK24gb3ZlcmZsb3dzIHRvIMKxSW5maW5pdHksIHRoZSBldmVubmVzcyBvZiBuIHdvdWxkIGJlIG5vdCBiZSBrbm93bi5cclxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihNYXRoLnBvdygrdmFsdWVPZih4KSwgbklzQmlnID8gMiAtIGlzT2RkKG4pIDogK3ZhbHVlT2YobikpKTtcclxuICAgICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogeTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbklzTmVnID0gbi5zIDwgMDtcclxuXHJcbiAgICAgIGlmIChtKSB7XHJcblxyXG4gICAgICAgIC8vIHggJSBtIHJldHVybnMgTmFOIGlmIGFicyhtKSBpcyB6ZXJvLCBvciBtIGlzIE5hTi5cclxuICAgICAgICBpZiAobS5jID8gIW0uY1swXSA6ICFtLnMpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAgIGlzTW9kRXhwID0gIW5Jc05lZyAmJiB4LmlzSW50ZWdlcigpICYmIG0uaXNJbnRlZ2VyKCk7XHJcblxyXG4gICAgICAgIGlmIChpc01vZEV4cCkgeCA9IHgubW9kKG0pO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3cgdG8gwrFJbmZpbml0eTogPj0yKioxZTEwIG9yID49MS4wMDAwMDI0KioxZTE1LlxyXG4gICAgICAvLyBVbmRlcmZsb3cgdG8gwrEwOiA8PTAuNzkqKjFlMTAgb3IgPD0wLjk5OTk5NzUqKjFlMTUuXHJcbiAgICAgIH0gZWxzZSBpZiAobi5lID4gOSAmJiAoeC5lID4gMCB8fCB4LmUgPCAtMSB8fCAoeC5lID09IDBcclxuICAgICAgICAvLyBbMSwgMjQwMDAwMDAwXVxyXG4gICAgICAgID8geC5jWzBdID4gMSB8fCBuSXNCaWcgJiYgeC5jWzFdID49IDI0ZTdcclxuICAgICAgICAvLyBbODAwMDAwMDAwMDAwMDBdICBbOTk5OTk3NTAwMDAwMDBdXHJcbiAgICAgICAgOiB4LmNbMF0gPCA4ZTEzIHx8IG5Jc0JpZyAmJiB4LmNbMF0gPD0gOTk5OTk3NWU3KSkpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgeCBpcyBuZWdhdGl2ZSBhbmQgbiBpcyBvZGQsIGsgPSAtMCwgZWxzZSBrID0gMC5cclxuICAgICAgICBrID0geC5zIDwgMCAmJiBpc09kZChuKSA/IC0wIDogMDtcclxuXHJcbiAgICAgICAgLy8gSWYgeCA+PSAxLCBrID0gwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gLTEpIGsgPSAxIC8gaztcclxuXHJcbiAgICAgICAgLy8gSWYgbiBpcyBuZWdhdGl2ZSByZXR1cm4gwrEwLCBlbHNlIHJldHVybiDCsUluZmluaXR5LlxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG5Jc05lZyA/IDEgLyBrIDogayk7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKFBPV19QUkVDSVNJT04pIHtcclxuXHJcbiAgICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgIC8vIGVxdWF0ZXMgdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLFxyXG4gICAgICAgIC8vIGkuZS4gdGhlcmUgd2lsbCBiZSBhIG1pbmltdW0gb2YgMjggZ3VhcmQgZGlnaXRzIHJldGFpbmVkLlxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5Jc0JpZykge1xyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKDAuNSk7XHJcbiAgICAgICAgaWYgKG5Jc05lZykgbi5zID0gMTtcclxuICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpID0gTWF0aC5hYnMoK3ZhbHVlT2YobikpO1xyXG4gICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgLy8gUGVyZm9ybXMgNTQgbG9vcCBpdGVyYXRpb25zIGZvciBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEuXHJcbiAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgIGlmIChuSXNPZGQpIHtcclxuICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgICAgaWYgKCF5LmMpIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICAgIGlmICh5LmMubGVuZ3RoID4gaykgeS5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICAgIHkgPSB5Lm1vZChtKTsgICAgLy95ID0geS5taW51cyhkaXYoeSwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgICBpID0gbWF0aGZsb29yKGkgLyAyKTtcclxuICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gbi50aW1lcyhoYWxmKTtcclxuICAgICAgICAgIHJvdW5kKG4sIG4uZSArIDEsIDEpO1xyXG5cclxuICAgICAgICAgIGlmIChuLmUgPiAxNCkge1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgPSArdmFsdWVPZihuKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggPSB4LnRpbWVzKHgpO1xyXG5cclxuICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgaWYgKHguYyAmJiB4LmMubGVuZ3RoID4gaykgeC5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgeCA9IHgubW9kKG0pOyAgICAvL3ggPSB4Lm1pbnVzKGRpdih4LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzTW9kRXhwKSByZXR1cm4geTtcclxuICAgICAgaWYgKG5Jc05lZykgeSA9IE9ORS5kaXYoeSk7XHJcblxyXG4gICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogayA/IHJvdW5kKHksIFBPV19QUkVDSVNJT04sIFJPVU5ESU5HX01PREUsIG1vcmUpIDogeTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGFuIGludGVnZXJcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtybX0nXHJcbiAgICAgKi9cclxuICAgIFAuaW50ZWdlclZhbHVlID0gZnVuY3Rpb24gKHJtKSB7XHJcbiAgICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcbiAgICAgIHJldHVybiByb3VuZChuLCBuLmUgKyAxLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRXF1YWxUbyA9IFAuZXEgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAxIHx8IGIgPT09IDA7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzSW50ZWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuYy5sZW5ndGggLSAyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gLTEgfHwgYiA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMucztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIHBvc2l0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC0gMCA9IG5cclxuICAgICAqICBuIC0gTiA9IE5cclxuICAgICAqICBuIC0gSSA9IC1JXHJcbiAgICAgKiAgMCAtIG4gPSAtblxyXG4gICAgICogIDAgLSAwID0gMFxyXG4gICAgICogIDAgLSBOID0gTlxyXG4gICAgICogIDAgLSBJID0gLUlcclxuICAgICAqICBOIC0gbiA9IE5cclxuICAgICAqICBOIC0gMCA9IE5cclxuICAgICAqICBOIC0gTiA9IE5cclxuICAgICAqICBOIC0gSSA9IE5cclxuICAgICAqICBJIC0gbiA9IElcclxuICAgICAqICBJIC0gMCA9IElcclxuICAgICAqICBJIC0gTiA9IE5cclxuICAgICAqICBJIC0gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5taW51cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBpLCBqLCB0LCB4TFR5LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiB4YyA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHljID8geCA6IE5hTik7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICByZXR1cm4geWNbMF0gPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOlxyXG5cclxuICAgICAgICAgICAvLyBJRUVFIDc1NCAoMjAwOCkgNi4zOiBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5XHJcbiAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSAzID8gLTAgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICAgICAgaWYgKHhMVHkgPSBhIDwgMCkge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICAgIGZvciAoYiA9IGE7IGItLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgICBqID0gKHhMVHkgPSAoYSA9IHhjLmxlbmd0aCkgPCAoYiA9IHljLmxlbmd0aCkpID8gYSA6IGI7XHJcblxyXG4gICAgICAgIGZvciAoYSA9IGIgPSAwOyBiIDwgajsgYisrKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmICh4TFR5KSB0ID0geGMsIHhjID0geWMsIHljID0gdCwgeS5zID0gLXkucztcclxuXHJcbiAgICAgIGIgPSAoaiA9IHljLmxlbmd0aCkgLSAoaSA9IHhjLmxlbmd0aCk7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgICAgaWYgKGIgPiAwKSBmb3IgKDsgYi0tOyB4Y1tpKytdID0gMCk7XHJcbiAgICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgIGZvciAoOyBqID4gYTspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAgIC0teGNbaV07XHJcbiAgICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGNbal0gLT0geWNbal07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgIGZvciAoOyB4Y1swXSA9PSAwOyB4Yy5zcGxpY2UoMCwgMSksIC0teWUpO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBGb2xsb3dpbmcgSUVFRSA3NTQgKDIwMDgpIDYuMyxcclxuICAgICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgIHkuYyA9IFt5LmUgPSAwXTtcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICAgbiAlIDAgPSAgTlxyXG4gICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgKiAgIG4gJSBJID0gIG5cclxuICAgICAqICAgMCAlIG4gPSAgMFxyXG4gICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgKiAgIDAgJSAwID0gIE5cclxuICAgICAqICAgMCAlIE4gPSAgTlxyXG4gICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgKiAgIE4gJSBuID0gIE5cclxuICAgICAqICAgTiAlIDAgPSAgTlxyXG4gICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgKiAgIE4gJSBJID0gIE5cclxuICAgICAqICAgSSAlIG4gPSAgTlxyXG4gICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgKiAgIEkgJSBOID0gIE5cclxuICAgICAqICAgSSAlIEkgPSAgTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgICBpZiAoIXguYyB8fCAheS5zIHx8IHkuYyAmJiAheS5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKCF5LmMgfHwgeC5jICYmICF4LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKE1PRFVMT19NT0RFID09IDkpIHtcclxuXHJcbiAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgcyA9IHkucztcclxuICAgICAgICB5LnMgPSAxO1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgICAgeS5zID0gcztcclxuICAgICAgICBxLnMgKj0gcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIE1PRFVMT19NT0RFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgICAvLyBUbyBtYXRjaCBKYXZhU2NyaXB0ICUsIGVuc3VyZSBzaWduIG9mIHplcm8gaXMgc2lnbiBvZiBkaXZpZGVuZC5cclxuICAgICAgaWYgKCF5LmNbMF0gJiYgTU9EVUxPX01PREUgPT0gMSkgeS5zID0geC5zO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKiAwID0gMFxyXG4gICAgICogIG4gKiBOID0gTlxyXG4gICAgICogIG4gKiBJID0gSVxyXG4gICAgICogIDAgKiBuID0gMFxyXG4gICAgICogIDAgKiAwID0gMFxyXG4gICAgICogIDAgKiBOID0gTlxyXG4gICAgICogIDAgKiBJID0gTlxyXG4gICAgICogIE4gKiBuID0gTlxyXG4gICAgICogIE4gKiAwID0gTlxyXG4gICAgICogIE4gKiBOID0gTlxyXG4gICAgICogIE4gKiBJID0gTlxyXG4gICAgICogIEkgKiBuID0gSVxyXG4gICAgICogIEkgKiAwID0gTlxyXG4gICAgICogIEkgKiBOID0gTlxyXG4gICAgICogIEkgKiBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlXHJcbiAgICAgKiBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubXVsdGlwbGllZEJ5ID0gUC50aW1lcyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcclxuICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIMKxSW5maW5pdHkgb3IgwrEwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeS5zICo9IHgucztcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICAgIHkuYyA9IHkuZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeS5jID0gWzBdO1xyXG4gICAgICAgICAgICB5LmUgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgIHkucyAqPSB4LnM7XHJcbiAgICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgICAgeWNMID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHhjIHBvaW50cyB0byBsb25nZXIgYXJyYXkgYW5kIHhjTCB0byBpdHMgbGVuZ3RoLlxyXG4gICAgICBpZiAoeGNMIDwgeWNMKSB6YyA9IHhjLCB4YyA9IHljLCB5YyA9IHpjLCBpID0geGNMLCB4Y0wgPSB5Y0wsIHljTCA9IGk7XHJcblxyXG4gICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgICAgZm9yIChpID0geGNMICsgeWNMLCB6YyA9IFtdOyBpLS07IHpjLnB1c2goMCkpO1xyXG5cclxuICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgICAgZm9yIChpID0geWNMOyAtLWkgPj0gMDspIHtcclxuICAgICAgICBjID0gMDtcclxuICAgICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHloaSA9IHljW2ldIC8gc3FydEJhc2UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgICB4aGkgPSB4Y1trXSAvIHNxcnRCYXNlIHwgMDtcclxuICAgICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoKG0gJSBzcXJ0QmFzZSkgKiBzcXJ0QmFzZSkgKyB6Y1tqXSArIGM7XHJcbiAgICAgICAgICBjID0gKHhsbyAvIGJhc2UgfCAwKSArIChtIC8gc3FydEJhc2UgfCAwKSArIHloaSAqIHhoaTtcclxuICAgICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgemNbal0gPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYykge1xyXG4gICAgICAgICsrZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgKi9cclxuICAgIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICB4LnMgPSAteC5zIHx8IG51bGw7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICsgMCA9IG5cclxuICAgICAqICBuICsgTiA9IE5cclxuICAgICAqICBuICsgSSA9IElcclxuICAgICAqICAwICsgbiA9IG5cclxuICAgICAqICAwICsgMCA9IDBcclxuICAgICAqICAwICsgTiA9IE5cclxuICAgICAqICAwICsgSSA9IElcclxuICAgICAqICBOICsgbiA9IE5cclxuICAgICAqICBOICsgMCA9IE5cclxuICAgICAqICBOICsgTiA9IE5cclxuICAgICAqICBOICsgSSA9IE5cclxuICAgICAqICBJICsgbiA9IElcclxuICAgICAqICBJICsgMCA9IElcclxuICAgICAqICBJICsgTiA9IE5cclxuICAgICAqICBJICsgSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLnBsdXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYSAvIDApO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuIHljWzBdID8geSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDogYSAqIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcbiAgICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICBmb3IgKDsgYS0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhID0geGMubGVuZ3RoO1xyXG4gICAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheSwgYW5kIGIgdG8gdGhlIHNob3J0ZXIgbGVuZ3RoLlxyXG4gICAgICBpZiAoYSAtIGIgPCAwKSB0ID0geWMsIHljID0geGMsIHhjID0gdCwgYiA9IGE7XHJcblxyXG4gICAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cclxuICAgICAgZm9yIChhID0gMDsgYjspIHtcclxuICAgICAgICBhID0gKHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSkgLyBCQVNFIHwgMDtcclxuICAgICAgICB4Y1tiXSA9IEJBU0UgPT09IHhjW2JdID8gMCA6IHhjW2JdICUgQkFTRTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGEpIHtcclxuICAgICAgICB4YyA9IFthXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICsreWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgICAgLy8geWUgPSBNQVhfRVhQICsgMSBwb3NzaWJsZVxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgc2QgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mXHJcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICogSWYgc2QgaXMgdHJ1ZSBpbmNsdWRlIGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgY291bnQuXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBzZCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIHNkIHtudW1iZXJ8Ym9vbGVhbn0gbnVtYmVyOiBzaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogd2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoc2QgIT0gbnVsbCAmJiBzZCAhPT0gISFzZCkge1xyXG4gICAgICAgIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBzZCwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIHYgPSBjLmxlbmd0aCAtIDE7XHJcbiAgICAgIG4gPSB2ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSB7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBuKyspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2QgJiYgeC5lICsgMSA+IG4pIG4gPSB4LmUgKyAxO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xyXG4gICAgICogKHBvd2VycyBvZiAxMCkuIFNoaWZ0IHRvIHRoZSByaWdodCBpZiBuID4gMCwgYW5kIHRvIHRoZSBsZWZ0IGlmIG4gPCAwLlxyXG4gICAgICpcclxuICAgICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtrfSdcclxuICAgICAqL1xyXG4gICAgUC5zaGlmdGVkQnkgPSBmdW5jdGlvbiAoaykge1xyXG4gICAgICBpbnRDaGVjayhrLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUik7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWVzKCcxZScgKyBrKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAgICogIHNxcnQoTikgPSAgTlxyXG4gICAgICogIHNxcnQoLUkpID0gIE5cclxuICAgICAqICBzcXJ0KEkpID0gIElcclxuICAgICAqICBzcXJ0KDApID0gIDBcclxuICAgICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxyXG4gICAgICogcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBjID0geC5jLFxyXG4gICAgICAgIHMgPSB4LnMsXHJcbiAgICAgICAgZSA9IHguZSxcclxuICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTICsgNCxcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XHJcblxyXG4gICAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgICAgaWYgKHMgIT09IDEgfHwgIWMgfHwgIWNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcighcyB8fCBzIDwgMCAmJiAoIWMgfHwgY1swXSkgPyBOYU4gOiBjID8geCA6IDEgLyAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgICAgcyA9IE1hdGguc3FydCgrdmFsdWVPZih4KSk7XHJcblxyXG4gICAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcclxuICAgICAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApIG4gKz0gJzAnO1xyXG4gICAgICAgIHMgPSBNYXRoLnNxcnQoK24pO1xyXG4gICAgICAgIGUgPSBiaXRGbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICAgICAgbiA9ICc1ZScgKyBlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKHMgKyAnJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciB6ZXJvLlxyXG4gICAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXHJcbiAgICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXHJcbiAgICAgIGlmIChyLmNbMF0pIHtcclxuICAgICAgICBlID0gci5lO1xyXG4gICAgICAgIHMgPSBlICsgZHA7XHJcbiAgICAgICAgaWYgKHMgPCAzKSBzID0gMDtcclxuXHJcbiAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgICB0ID0gcjtcclxuICAgICAgICAgIHIgPSBoYWxmLnRpbWVzKHQucGx1cyhkaXYoeCwgdCwgZHAsIDEpKSk7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZWZmVG9TdHJpbmcodC5jKS5zbGljZSgwLCBzKSA9PT0gKG4gPSBjb2VmZlRvU3RyaW5nKHIuYykpLnNsaWNlKDAsIHMpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXHJcbiAgICAgICAgICAgIC8vIGUuZyAwLjAwMDk5OTkgKGUtNCkgLS0gPiAwLjAwMSAoZS0zKSwgc28gYWRqdXN0IHMgc28gdGhlIHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgaW5kZXhlZCBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgIGlmIChyLmUgPCBlKSAtLXM7XHJcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKHMgLSAzLCBzICsgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIDk5OTkgb3IgNDk5OSAoaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5KSBjb250aW51ZSB0aGVcclxuICAgICAgICAgICAgLy8gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgICAgICAgcm91bmQodCwgdC5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBkcCArPSA0O1xyXG4gICAgICAgICAgICAgIHMgKz0gNDtcclxuICAgICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcclxuICAgICAgICAgICAgICAvLyByZXN1bHQuIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXHJcbiAgICAgICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAxKTtcclxuICAgICAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbiBhbmRcclxuICAgICAqIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCsrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xyXG4gICAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxyXG4gICAgICogYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHAgPSBkcCArIHRoaXMuZSArIDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kZWRcclxuICAgICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBvZiB0aGUgZm9ybWF0IG9yIEZPUk1BVCBvYmplY3QgKHNlZSBCaWdOdW1iZXIuc2V0KS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZm9ybWF0dGluZyBvYmplY3QgbWF5IGNvbnRhaW4gc29tZSBvciBhbGwgb2YgdGhlIHByb3BlcnRpZXMgc2hvd24gYmVsb3cuXHJcbiAgICAgKlxyXG4gICAgICogRk9STUFUID0ge1xyXG4gICAgICogICBwcmVmaXg6ICcnLFxyXG4gICAgICogICBncm91cFNpemU6IDMsXHJcbiAgICAgKiAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAqICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAqICAgc3VmZml4OiAnJ1xyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbZm9ybWF0XSB7b2JqZWN0fSBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZSBGT1JNQVQgcGJqZWN0IGFib3ZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IG5vdCBhbiBvYmplY3Q6IHtmb3JtYXR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRm9ybWF0ID0gZnVuY3Rpb24gKGRwLCBybSwgZm9ybWF0KSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICBpZiAoZHAgIT0gbnVsbCAmJiBybSAmJiB0eXBlb2Ygcm0gPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IHJtO1xyXG4gICAgICAgICAgcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHAgJiYgdHlwZW9mIGRwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBkcDtcclxuICAgICAgICAgIGRwID0gcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBGT1JNQVQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT0gJ29iamVjdCcpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50IG5vdCBhbiBvYmplY3Q6ICcgKyBmb3JtYXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSB4LnRvRml4ZWQoZHAsIHJtKTtcclxuXHJcbiAgICAgIGlmICh4LmMpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLicpLFxyXG4gICAgICAgICAgZzEgPSArZm9ybWF0Lmdyb3VwU2l6ZSxcclxuICAgICAgICAgIGcyID0gK2Zvcm1hdC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgICBncm91cFNlcGFyYXRvciA9IGZvcm1hdC5ncm91cFNlcGFyYXRvciB8fCAnJyxcclxuICAgICAgICAgIGludFBhcnQgPSBhcnJbMF0sXHJcbiAgICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICAgICAgICBpbnREaWdpdHMgPSBpc05lZyA/IGludFBhcnQuc2xpY2UoMSkgOiBpbnRQYXJ0LFxyXG4gICAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKGcyKSBpID0gZzEsIGcxID0gZzIsIGcyID0gaSwgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIGlmIChnMSA+IDAgJiYgbGVuID4gMCkge1xyXG4gICAgICAgICAgaSA9IGxlbiAlIGcxIHx8IGcxO1xyXG4gICAgICAgICAgaW50UGFydCA9IGludERpZ2l0cy5zdWJzdHIoMCwgaSk7XHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSBnMSkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zdWJzdHIoaSwgZzEpO1xyXG4gICAgICAgICAgaWYgKGcyID4gMCkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zbGljZShpKTtcclxuICAgICAgICAgIGlmIChpc05lZykgaW50UGFydCA9ICctJyArIGludFBhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBmcmFjdGlvblBhcnRcclxuICAgICAgICAgPyBpbnRQYXJ0ICsgKGZvcm1hdC5kZWNpbWFsU2VwYXJhdG9yIHx8ICcnKSArICgoZzIgPSArZm9ybWF0LmZyYWN0aW9uR3JvdXBTaXplKVxyXG4gICAgICAgICAgPyBmcmFjdGlvblBhcnQucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcZHsnICsgZzIgKyAnfVxcXFxCJywgJ2cnKSxcclxuICAgICAgICAgICAnJCYnICsgKGZvcm1hdC5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHx8ICcnKSlcclxuICAgICAgICAgIDogZnJhY3Rpb25QYXJ0KVxyXG4gICAgICAgICA6IGludFBhcnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAoZm9ybWF0LnByZWZpeCB8fCAnJykgKyBzdHIgKyAoZm9ybWF0LnN1ZmZpeCB8fCAnJyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHR3byBCaWdOdW1iZXJzIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgYXMgYSBzaW1wbGVcclxuICAgICAqIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlciBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuXHJcbiAgICAgKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKiBtYXhpbXVtIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmVcclxuICAgICAqIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogW21kXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEludGVnZXIgPj0gMSwgb3IgSW5maW5pdHkuIFRoZSBtYXhpbXVtIGRlbm9taW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfSA6IHttZH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtZCkge1xyXG4gICAgICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgZXhwLCBuLCBuMCwgbjEsIHEsIHIsIHMsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmM7XHJcblxyXG4gICAgICBpZiAobWQgIT0gbnVsbCkge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG1kKTtcclxuXHJcbiAgICAgICAgLy8gVGhyb3cgaWYgbWQgaXMgbGVzcyB0aGFuIG9uZSBvciBpcyBub3QgYW4gaW50ZWdlciwgdW5sZXNzIGl0IGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICghbi5pc0ludGVnZXIoKSAmJiAobi5jIHx8IG4ucyAhPT0gMSkgfHwgbi5sdChPTkUpKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgJyArXHJcbiAgICAgICAgICAgICAgKG4uaXNJbnRlZ2VyKCkgPyAnb3V0IG9mIHJhbmdlOiAnIDogJ25vdCBhbiBpbnRlZ2VyOiAnKSArIHZhbHVlT2YobikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF4YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcblxyXG4gICAgICBkID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBuMSA9IGQwID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBzID0gY29lZmZUb1N0cmluZyh4Yyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBkZW5vbWluYXRvci5cclxuICAgICAgLy8gZCBpcyBhIHBvd2VyIG9mIDEwIGFuZCB0aGUgbWluaW11bSBtYXggZGVub21pbmF0b3IgdGhhdCBzcGVjaWZpZXMgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICAgIGUgPSBkLmUgPSBzLmxlbmd0aCAtIHguZSAtIDE7XHJcbiAgICAgIGQuY1swXSA9IFBPV1NfVEVOWyhleHAgPSBlICUgTE9HX0JBU0UpIDwgMCA/IExPR19CQVNFICsgZXhwIDogZXhwXTtcclxuICAgICAgbWQgPSAhbWQgfHwgbi5jb21wYXJlZFRvKGQpID4gMCA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG5cclxuICAgICAgZXhwID0gTUFYX0VYUDtcclxuICAgICAgTUFYX0VYUCA9IDEgLyAwO1xyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihzKTtcclxuXHJcbiAgICAgIC8vIG4wID0gZDEgPSAwXHJcbiAgICAgIG4wLmNbMF0gPSAwO1xyXG5cclxuICAgICAgZm9yICg7IDspICB7XHJcbiAgICAgICAgcSA9IGRpdihuLCBkLCAwLCAxKTtcclxuICAgICAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgICAgIGlmIChkMi5jb21wYXJlZFRvKG1kKSA9PSAxKSBicmVhaztcclxuICAgICAgICBkMCA9IGQxO1xyXG4gICAgICAgIGQxID0gZDI7XHJcbiAgICAgICAgbjEgPSBuMC5wbHVzKHEudGltZXMoZDIgPSBuMSkpO1xyXG4gICAgICAgIG4wID0gZDI7XHJcbiAgICAgICAgZCA9IG4ubWludXMocS50aW1lcyhkMiA9IGQpKTtcclxuICAgICAgICBuID0gZDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGQyID0gZGl2KG1kLm1pbnVzKGQwKSwgZDEsIDAsIDEpO1xyXG4gICAgICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICAgICAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XHJcbiAgICAgIG4wLnMgPSBuMS5zID0geC5zO1xyXG4gICAgICBlID0gZSAqIDI7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZnJhY3Rpb24gaXMgY2xvc2VyIHRvIHgsIG4wL2QwIG9yIG4xL2QxXHJcbiAgICAgIHIgPSBkaXYobjEsIGQxLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKS5jb21wYXJlZFRvKFxyXG4gICAgICAgICAgZGl2KG4wLCBkMCwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkpIDwgMSA/IFtuMSwgZDFdIDogW24wLCBkMF07XHJcblxyXG4gICAgICBNQVhfRVhQID0gZXhwO1xyXG5cclxuICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAgICovXHJcbiAgICBQLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gK3ZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0gb3IgUk9VTkRJTkdfTU9ERS4gSWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzXHJcbiAgICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxyXG4gICAgICogZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgaWYgKHNkICE9IG51bGwpIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIHNkLCBybSwgMik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgICAqIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLCByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kXHJcbiAgICAgKiBST1VORElOR19NT0RFLiBJZiBhIGJhc2UgaXMgbm90IHNwZWNpZmllZCwgYW5kIHRoaXMgQmlnTnVtYmVyIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogVE9fRVhQX05FRywgcmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICovXHJcbiAgICBQLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBuID0gdGhpcyxcclxuICAgICAgICBzID0gbi5zLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eSBvciBOYU4/XHJcbiAgICAgIGlmIChlID09PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgIHN0ciA9ICdJbmZpbml0eSc7XHJcbiAgICAgICAgICBpZiAocyA8IDApIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RyID0gJ05hTic7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChiID09IG51bGwpIHtcclxuICAgICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgICA/IHRvRXhwb25lbnRpYWwoY29lZmZUb1N0cmluZyhuLmMpLCBlKVxyXG4gICAgICAgICAgIDogdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDEwKSB7XHJcbiAgICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgREVDSU1BTF9QTEFDRVMgKyBlICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBuLmUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyksIDEwLCBiLCBzLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCAmJiBuLmNbMF0pIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudCwgYW5kIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24gZm9yXHJcbiAgICAgKiBuZWdhdGl2ZSB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBQLl9pc0JpZ051bWJlciA9IHRydWU7XHJcblxyXG4gICAgaWYgKGNvbmZpZ09iamVjdCAhPSBudWxsKSBCaWdOdW1iZXIuc2V0KGNvbmZpZ09iamVjdCk7XHJcblxyXG4gICAgcmV0dXJuIEJpZ051bWJlcjtcclxuICB9XHJcblxyXG5cclxuICAvLyBQUklWQVRFIEhFTFBFUiBGVU5DVElPTlNcclxuXHJcbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRvbid0IG5lZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyxcclxuICAvLyBlLmcuIERFQ0lNQUxfUExBQ0VTLCBpbiB0aGUgc2NvcGUgb2YgdGhlIGBjbG9uZWAgZnVuY3Rpb24gYWJvdmUuXHJcblxyXG5cclxuICBmdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgICB2YXIgaSA9IG4gfCAwO1xyXG4gICAgcmV0dXJuIG4gPiAwIHx8IG4gPT09IGkgPyBpIDogaSAtIDE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbiAgZnVuY3Rpb24gY29lZmZUb1N0cmluZyhhKSB7XHJcbiAgICB2YXIgcywgeixcclxuICAgICAgaSA9IDEsXHJcbiAgICAgIGogPSBhLmxlbmd0aCxcclxuICAgICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgICBmb3IgKDsgaSA8IGo7KSB7XHJcbiAgICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoOyB6LS07IHMgPSAnMCcgKyBzKTtcclxuICAgICAgciArPSBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7KTtcclxuXHJcbiAgICByZXR1cm4gci5zbGljZSgwLCBqICsgMSB8fCAxKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbiAgZnVuY3Rpb24gY29tcGFyZSh4LCB5KSB7XHJcbiAgICB2YXIgYSwgYixcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jLFxyXG4gICAgICBpID0geC5zLFxyXG4gICAgICBqID0geS5zLFxyXG4gICAgICBrID0geC5lLFxyXG4gICAgICBsID0geS5lO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICBpZiAoIWkgfHwgIWopIHJldHVybiBudWxsO1xyXG5cclxuICAgIGEgPSB4YyAmJiAheGNbMF07XHJcbiAgICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgaWYgKGEgfHwgYikgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgICBhID0gaSA8IDA7XHJcbiAgICBiID0gayA9PSBsO1xyXG5cclxuICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gICAgaWYgKCFiKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDaGVjayB0aGF0IG4gaXMgYSBwcmltaXRpdmUgbnVtYmVyLCBhbiBpbnRlZ2VyLCBhbmQgaW4gcmFuZ2UsIG90aGVyd2lzZSB0aHJvdy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBpbnRDaGVjayhuLCBtaW4sIG1heCwgbmFtZSkge1xyXG4gICAgaWYgKG4gPCBtaW4gfHwgbiA+IG1heCB8fCBuICE9PSBtYXRoZmxvb3IobikpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgIChiaWdudW1iZXJFcnJvciArIChuYW1lIHx8ICdBcmd1bWVudCcpICsgKHR5cGVvZiBuID09ICdudW1iZXInXHJcbiAgICAgICAgID8gbiA8IG1pbiB8fCBuID4gbWF4ID8gJyBvdXQgb2YgcmFuZ2U6ICcgOiAnIG5vdCBhbiBpbnRlZ2VyOiAnXHJcbiAgICAgICAgIDogJyBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiAnKSArIFN0cmluZyhuKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQXNzdW1lcyBmaW5pdGUgbi5cclxuICBmdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgICB2YXIgayA9IG4uYy5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIGJpdEZsb29yKG4uZSAvIExPR19CQVNFKSA9PSBrICYmIG4uY1trXSAlIDIgIT0gMDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0V4cG9uZW50aWFsKHN0ciwgZSkge1xyXG4gICAgcmV0dXJuIChzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIpICtcclxuICAgICAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9GaXhlZFBvaW50KHN0ciwgZSwgeikge1xyXG4gICAgdmFyIGxlbiwgenM7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgICBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICAgIGZvciAoenMgPSB6ICsgJy4nOyArK2U7IHpzICs9IHopO1xyXG4gICAgICBzdHIgPSB6cyArIHN0cjtcclxuXHJcbiAgICAvLyBQb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgaWYgKCsrZSA+IGxlbikge1xyXG4gICAgICAgIGZvciAoenMgPSB6LCBlIC09IGxlbjsgLS1lOyB6cyArPSB6KTtcclxuICAgICAgICBzdHIgKz0genM7XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IGxlbikge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gRVhQT1JUXHJcblxyXG5cclxuICBCaWdOdW1iZXIgPSBjbG9uZSgpO1xyXG4gIEJpZ051bWJlclsnZGVmYXVsdCddID0gQmlnTnVtYmVyLkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQU1ELlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZ051bWJlcjsgfSk7XHJcblxyXG4gIC8vIE5vZGUuanMgYW5kIG90aGVyIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQnJvd3Nlci5cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFnbG9iYWxPYmplY3QpIHtcclxuICAgICAgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiA/IHNlbGYgOiB3aW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgZ2xvYmFsT2JqZWN0LkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuICB9XHJcbn0pKHRoaXMpO1xyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpXG5cbi8qKlxuKiBTdHJpbmdpZnkgYSBDSUQgZW5jb2RlZCBpbiB0aGUgcmVxdWVzdGVkIGJhc2UsIHVwZ3JhZGluZyB0byB2MSBpZiBuZWNlc3NhcnkuXG4qXG4qIFNldHRpbmcgdXBncmFkZSB0byBmYWxzZSB3aWxsIGRpc2FibGUgYXV0b21hdGljIENJRCB1cGdyYWRpbmcgZnJvbSB2MCB0byB2MVxuKiB3aGljaCBpcyBuZWNlc3NhcnkgaWYgdGhlIG11bHRpYmFzZSBpcyBzb21ldGhpbmcgb3RoZXIgdGhhbiBiYXNlNThidGMuIE5vdGVcbiogdGhhdCBpdCB3aWxsIGFsc28gbm90IGFwcGx5IHRoZSBlbmNvZGluZyAoc2luY2UgdjAgQ0lEcyBjYW4gb25seSBiZSBlbmNvZGVkXG4qIGFzIGJhc2U1OGJ0YykuXG4qXG4qIEBwYXJhbSB7Q0lEfEJ1ZmZlcnxTdHJpbmd9IGNpZCBUaGUgQ0lEIHRvIGVuY29kZVxuKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnNcbiogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJhc2VdIE5hbWUgb2YgbXVsdGliYXNlIGNvZGVjIHRvIGVuY29kZSB0aGUgQ0lEIHdpdGhcbiogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51cGdyYWRlXSBBdXRvbWF0aWNhbGx5IHVwZ3JhZGUgdjAgQ0lEcyB0byB2MSB3aGVuXG4qIG5lY2Vzc2FyeS4gRGVmYXVsdDogdHJ1ZS5cbiogQHJldHVybnMge1N0cmluZ31cbiovXG5leHBvcnRzLmNpZFRvU3RyaW5nID0gKGNpZCwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICBvcHRpb25zLnVwZ3JhZGUgPSBvcHRpb25zLnVwZ3JhZGUgIT09IGZhbHNlXG5cbiAgaWYgKCFDSUQuaXNDSUQoY2lkKSkge1xuICAgIGNpZCA9IG5ldyBDSUQoY2lkKVxuICB9XG5cbiAgaWYgKGNpZC52ZXJzaW9uID09PSAwICYmIG9wdGlvbnMuYmFzZSAmJiBvcHRpb25zLmJhc2UgIT09ICdiYXNlNThidGMnKSB7XG4gICAgaWYgKCFvcHRpb25zLnVwZ3JhZGUpIHJldHVybiBjaWQudG9TdHJpbmcoKVxuICAgIGNpZCA9IGNpZC50b1YxKClcbiAgfVxuXG4gIHJldHVybiBjaWQudG9CYXNlRW5jb2RlZFN0cmluZyhvcHRpb25zLmJhc2UpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgncHJvbWlzaWZ5LWVzNicpXG5cbmNvbnN0IHdob2xlID0gL14oKFxcZCsoXFwuXFxkKykqKShuc3xtc3x1c3zCtXN8bXxzfGgpKSskL1xuY29uc3QgcGllY2VzID0gLygoXFxkKyhcXC5cXGQrKSopKG5zfG1zfHVzfMK1c3xtfHN8aCkpL2dcbmNvbnN0IG1lYXN1cmUgPSAvKG5zfG1zfHVzfMK1c3xtfHN8aCkvZ1xuXG5jb25zdCBtdWx0aXBsaWVycyA9IHtcbiAgbnM6IDFlLTYsXG4gIHVzOiAwLjAwMSxcbiAgwrVzOiAwLjAwMSxcbiAgbXM6IDEsXG4gIHM6IDEwMDAsXG4gIG06IDYwMDAwLFxuICBoOiAzLjZlKzZcbn1cblxuZnVuY3Rpb24gYW5hbHlzZSAodGltZSkge1xuICBsZXQgdW5pdCA9IHRpbWUubWF0Y2gobWVhc3VyZSlbMF1cbiAgdGltZSA9IHRpbWUuc3Vic3RyaW5nKDAsIHRpbWUubGVuZ3RoIC0gdW5pdC5sZW5ndGgpXG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQodGltZSkgKiBtdWx0aXBsaWVyc1t1bml0XVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb21pc2lmeShmdW5jdGlvbiAodGltZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiB0aW1lICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ3RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJykpXG4gIH1cblxuICBpZiAoIXdob2xlLnRlc3QodGltZSkpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdpbnZhbGlkIHRpbWUnKSlcbiAgfVxuXG4gIGNhbGxiYWNrKG51bGwsIHRpbWUubWF0Y2gocGllY2VzKS5yZWR1Y2UoKHN1bSwgY3VycmVudFZhbCkgPT4ge1xuICAgIHJldHVybiBzdW0gKyBhbmFseXNlKGN1cnJlbnRWYWwpXG4gIH0sIDApKVxufSlcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NldEltbWVkaWF0ZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc2V0SW1tZWRpYXRlJyk7XG5cbi8qKlxuICogQ2FsbHMgYGNhbGxiYWNrYCBvbiBhIGxhdGVyIGxvb3AgYXJvdW5kIHRoZSBldmVudCBsb29wLiBJbiBOb2RlLmpzIHRoaXMganVzdFxuICogY2FsbHMgYHByb2Nlc3MubmV4dFRpY2tgLiAgSW4gdGhlIGJyb3dzZXIgaXQgd2lsbCB1c2UgYHNldEltbWVkaWF0ZWAgaWZcbiAqIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKWAsIHdoaWNoIG1lYW5zIG90aGVyIGhpZ2hlclxuICogcHJpb3JpdHkgZXZlbnRzIG1heSBwcmVjZWRlIHRoZSBleGVjdXRpb24gb2YgYGNhbGxiYWNrYC5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBmb3IgYnJvd3Nlci1jb21wYXRpYmlsaXR5IHB1cnBvc2VzLlxuICpcbiAqIEBuYW1lIG5leHRUaWNrXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5zZXRJbW1lZGlhdGVde0BsaW5rIG1vZHVsZTpVdGlscy5zZXRJbW1lZGlhdGV9XG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBhIGxhdGVyIGxvb3AgYXJvdW5kXG4gKiB0aGUgZXZlbnQgbG9vcC4gSW52b2tlZCB3aXRoIChhcmdzLi4uKS5cbiAqIEBwYXJhbSB7Li4uKn0gYXJncy4uLiAtIGFueSBudW1iZXIgb2YgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGVcbiAqIGNhbGxiYWNrIG9uIHRoZSBuZXh0IHRpY2suXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBjYWxsX29yZGVyID0gW107XG4gKiBhc3luYy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAqICAgICBjYWxsX29yZGVyLnB1c2goJ3R3bycpO1xuICogICAgIC8vIGNhbGxfb3JkZXIgbm93IGVxdWFscyBbJ29uZScsJ3R3byddXG4gKiB9KTtcbiAqIGNhbGxfb3JkZXIucHVzaCgnb25lJyk7XG4gKlxuICogYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gKiAgICAgLy8gYSwgYiwgYW5kIGMgZXF1YWwgMSwgMiwgYW5kIDNcbiAqIH0sIDEsIDIsIDMpO1xuICovXG52YXIgX2RlZmVyO1xuXG5pZiAoX3NldEltbWVkaWF0ZS5oYXNOZXh0VGljaykge1xuICAgIF9kZWZlciA9IHByb2Nlc3MubmV4dFRpY2s7XG59IGVsc2UgaWYgKF9zZXRJbW1lZGlhdGUuaGFzU2V0SW1tZWRpYXRlKSB7XG4gICAgX2RlZmVyID0gc2V0SW1tZWRpYXRlO1xufSBlbHNlIHtcbiAgICBfZGVmZXIgPSBfc2V0SW1tZWRpYXRlLmZhbGxiYWNrO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX3NldEltbWVkaWF0ZS53cmFwKShfZGVmZXIpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZVRlc3RlciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvY3JlYXRlVGVzdGVyJyk7XG5cbnZhciBfY3JlYXRlVGVzdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRlc3Rlcik7XG5cbnZhciBfZG9QYXJhbGxlbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvZG9QYXJhbGxlbCcpO1xuXG52YXIgX2RvUGFyYWxsZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9QYXJhbGxlbCk7XG5cbnZhciBfbm90SWQgPSByZXF1aXJlKCcuL2ludGVybmFsL25vdElkJyk7XG5cbnZhciBfbm90SWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm90SWQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGV2ZXJ5IGVsZW1lbnQgaW4gYGNvbGxgIHNhdGlzZmllcyBhbiBhc3luYyB0ZXN0LiBJZiBhbnlcbiAqIGl0ZXJhdGVlIGNhbGwgcmV0dXJucyBgZmFsc2VgLCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZC5cbiAqXG4gKiBAbmFtZSBldmVyeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGFsbFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbVxuICogaW4gdGhlIGNvbGxlY3Rpb24gaW4gcGFyYWxsZWwuXG4gKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiByZXN1bHQgdmFsdWUuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWBcbiAqIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luYyB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmV2ZXJ5KFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZ1bmN0aW9uKGZpbGVQYXRoLCBjYWxsYmFjaykge1xuICogICAgIGZzLmFjY2VzcyhmaWxlUGF0aCwgZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICFlcnIpXG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGlmIHJlc3VsdCBpcyB0cnVlIHRoZW4gZXZlcnkgZmlsZSBleGlzdHNcbiAqIH0pO1xuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2RvUGFyYWxsZWwyLmRlZmF1bHQpKCgwLCBfY3JlYXRlVGVzdGVyMi5kZWZhdWx0KShfbm90SWQyLmRlZmF1bHQsIF9ub3RJZDIuZGVmYXVsdCkpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwibW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuO1xuXG4vKlxuICBmbGF0dGVuKFtbMSwgWzIsIDNdXSwgW1s0LCA1XSwgNiwgNywgWzgsIDldXV0pO1xuICAvLyBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV1cbiovXG5cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBhbiBhcnJheScpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZWxlbSA9IGFycltpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtKSkge1xuICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBmbGF0dGVuKGVsZW0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goZWxlbSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJjb25zdCBnZXRJdGVyYXRvciA9IHJlcXVpcmUoJ2dldC1pdGVyYXRvcicpXG5jb25zdCB0b0l0ZXJhYmxlID0gcmVxdWlyZSgncHVsbC1zdHJlYW0tdG8tYXN5bmMtaXRlcmF0b3InKVxuXG5mdW5jdGlvbiB0b1B1bGwgKHNvdXJjZSkge1xuICBzb3VyY2UgPSBnZXRJdGVyYXRvcihzb3VyY2UpXG5cbiAgcmV0dXJuIGFzeW5jIChlbmQsIGNiKSA9PiB7XG4gICAgaWYgKGVuZCkge1xuICAgICAgaWYgKHNvdXJjZS5yZXR1cm4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBzb3VyY2UucmV0dXJuKClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNiKGVuZClcbiAgICB9XG5cbiAgICBsZXQgbmV4dFxuICAgIHRyeSB7XG4gICAgICBuZXh0ID0gYXdhaXQgc291cmNlLm5leHQoKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycilcbiAgICB9XG5cbiAgICBpZiAobmV4dC5kb25lKSByZXR1cm4gY2IodHJ1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGNiKG51bGwsIG5leHQudmFsdWUpXG4gIH1cbn1cblxudG9QdWxsLnNvdXJjZSA9IHRvUHVsbFxuXG50b1B1bGwudHJhbnNmb3JtID0gdG9QdWxsLnRocm91Z2ggPSBzb3VyY2UgPT4gcmVhZCA9PiB0b1B1bGwoc291cmNlKHRvSXRlcmFibGUocmVhZCkpKVxuXG50b1B1bGwuZHVwbGV4ID0gZHVwbGV4ID0+ICh7XG4gIHNpbms6IHRvUHVsbC5zaW5rKGR1cGxleC5zaW5rKSxcbiAgc291cmNlOiB0b1B1bGwoZHVwbGV4LnNvdXJjZSlcbn0pXG5cbnRvUHVsbC5zaW5rID0gc2luayA9PiB7XG4gIHJldHVybiByZWFkID0+IHtcbiAgICBzaW5rKHtcbiAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gKCkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcblxuICAgICAgbmV4dDogKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZWFkKG51bGwsIChlbmQsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgaWYgKGVuZCA9PT0gdHJ1ZSkgcmV0dXJuIHJlc29sdmUoeyBkb25lOiB0cnVlLCB2YWx1ZSB9KVxuICAgICAgICAgIGlmIChlbmQpIHJldHVybiByZWplY3QoZW5kKVxuICAgICAgICAgIHJlc29sdmUoeyBkb25lOiBmYWxzZSwgdmFsdWUgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pLFxuXG4gICAgICByZXR1cm46ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcmVhZCh0cnVlLCAoZW5kLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGlmIChlbmQgJiYgZW5kICE9PSB0cnVlKSByZXR1cm4gcmVqZWN0KGVuZClcbiAgICAgICAgICByZXNvbHZlKHsgZG9uZTogdHJ1ZSwgdmFsdWUgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pLFxuXG4gICAgICB0aHJvdzogZXJyID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcmVhZChlcnIsIChlbmQsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgaWYgKGVuZCAmJiBlbmQgIT09IHRydWUpIHJldHVybiByZWplY3QoZW5kKVxuICAgICAgICAgIHJlc29sdmUoeyBkb25lOiB0cnVlLCB2YWx1ZSB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QdWxsXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWFwTGltaXQgPSByZXF1aXJlKCcuL21hcExpbWl0Jyk7XG5cbnZhciBfbWFwTGltaXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWFwTGltaXQpO1xuXG52YXIgX2RvTGltaXQgPSByZXF1aXJlKCcuL2ludGVybmFsL2RvTGltaXQnKTtcblxudmFyIF9kb0xpbWl0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvTGltaXQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgbWFwYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIG1hcFNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMubWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgaXRlbS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXkgb2YgdGhlXG4gKiB0cmFuc2Zvcm1lZCBpdGVtcyBmcm9tIHRoZSBgY29sbGAuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9kb0xpbWl0Mi5kZWZhdWx0KShfbWFwTGltaXQyLmRlZmF1bHQsIDEpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiLyogQGZsb3cgKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBLZXkgPSByZXF1aXJlKCcuL2tleScpXG5jb25zdCBNZW1vcnlEYXRhc3RvcmUgPSByZXF1aXJlKCcuL21lbW9yeScpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKVxuXG5leHBvcnRzLktleSA9IEtleVxuZXhwb3J0cy5NZW1vcnlEYXRhc3RvcmUgPSBNZW1vcnlEYXRhc3RvcmVcbmV4cG9ydHMudXRpbHMgPSB1dGlsc1xuZXhwb3J0cy5FcnJvcnMgPSBFcnJvcnNcblxuLyogOjpcbi8vIC0tIEJhc2ljc1xuXG5leHBvcnQgdHlwZSBDYWxsYmFjazxWYWx1ZT4gPSAoZXJyOiA/RXJyb3IsID9WYWx1ZSkgPT4gdm9pZFxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YXN0b3JlPFZhbHVlPiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBwdXQoS2V5LCBWYWx1ZSwgQ2FsbGJhY2s8dm9pZD4pOiB2b2lkO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgZ2V0KEtleSwgQ2FsbGJhY2s8VmFsdWU+KTogdm9pZDtcbiAgaGFzKEtleSwgQ2FsbGJhY2s8Ym9vbD4pOiB2b2lkO1xuICBkZWxldGUoS2V5LCBDYWxsYmFjazx2b2lkPik6IHZvaWQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBxdWVyeShRdWVyeTxWYWx1ZT4pOiBRdWVyeVJlc3VsdDxWYWx1ZT47XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIGJhdGNoKCk6IEJhdGNoPFZhbHVlPjtcbiAgY2xvc2UoQ2FsbGJhY2s8dm9pZD4pOiB2b2lkO1xuICBvcGVuKENhbGxiYWNrPHZvaWQ+KTogdm9pZDtcbn1cblxuLy8gLS0gQmF0Y2hcbmV4cG9ydCB0eXBlIEJhdGNoPFZhbHVlPiA9IHtcbiAgcHV0KEtleSwgVmFsdWUpOiB2b2lkLFxuICBkZWxldGUoS2V5KTogdm9pZCxcbiAgY29tbWl0KENhbGxiYWNrPHZvaWQ+KTogdm9pZFxufVxuXG4vLyAtLSBRdWVyeVxuXG5leHBvcnQgdHlwZSBRdWVyeTxWYWx1ZT4gPSB7XG4gIHByZWZpeD86IHN0cmluZyxcbiAgZmlsdGVycz86IEFycmF5PEZpbHRlcjxWYWx1ZT4+LFxuICBvcmRlcnM/OiBBcnJheTxPcmRlcjxWYWx1ZT4+LFxuICBsaW1pdD86IG51bWJlcixcbiAgb2Zmc2V0PzogbnVtYmVyLFxuICBrZXlzT25seT86IGJvb2xcbn1cblxuZXhwb3J0IHR5cGUgUHVsbEVuZCA9IGJvb2wgfCBFcnJvclxuZXhwb3J0IHR5cGUgUHVsbFNvdXJjZTxWYWw+ID0gKGVuZDogP1B1bGxFbmQsIChlbmQ6ID9QdWxsRW5kLCBWYWwpID0+IHZvaWQpID0+IHZvaWRcblxuZXhwb3J0IHR5cGUgUXVlcnlSZXN1bHQ8VmFsdWU+ID0gUHVsbFNvdXJjZTxRdWVyeUVudHJ5PFZhbHVlPj5cblxuZXhwb3J0IHR5cGUgUXVlcnlFbnRyeTxWYWx1ZT4gPSB7XG4gIGtleTogS2V5LFxuICB2YWx1ZT86IFZhbHVlXG59XG5cbmV4cG9ydCB0eXBlIEZpbHRlcjxWYWx1ZT4gPSAoUXVlcnlFbnRyeTxWYWx1ZT4sIENhbGxiYWNrPGJvb2w+KSA9PiB2b2lkXG5cbmV4cG9ydCB0eXBlIE9yZGVyPFZhbHVlPiA9IChRdWVyeVJlc3VsdDxWYWx1ZT4sIENhbGxiYWNrPFF1ZXJ5UmVzdWx0PFZhbHVlPj4pID0+IHZvaWRcblxuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9pZGVudGl0eSA9IHJlcXVpcmUoJ2xvZGFzaC9pZGVudGl0eScpO1xuXG52YXIgX2lkZW50aXR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lkZW50aXR5KTtcblxudmFyIF9jcmVhdGVUZXN0ZXIgPSByZXF1aXJlKCcuL2ludGVybmFsL2NyZWF0ZVRlc3RlcicpO1xuXG52YXIgX2NyZWF0ZVRlc3RlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUZXN0ZXIpO1xuXG52YXIgX2RvUGFyYWxsZWxMaW1pdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvZG9QYXJhbGxlbExpbWl0Jyk7XG5cbnZhciBfZG9QYXJhbGxlbExpbWl0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvUGFyYWxsZWxMaW1pdCk7XG5cbnZhciBfZmluZEdldFJlc3VsdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvZmluZEdldFJlc3VsdCcpO1xuXG52YXIgX2ZpbmRHZXRSZXN1bHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmluZEdldFJlc3VsdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BkZXRlY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgZGV0ZWN0TGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmRldGVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH1cbiAqIEBhbGlhcyBmaW5kTGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIHRoZSB0cnV0aCB0ZXN0XG4gKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHQpLlxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2RvUGFyYWxsZWxMaW1pdDIuZGVmYXVsdCkoKDAsIF9jcmVhdGVUZXN0ZXIyLmRlZmF1bHQpKF9pZGVudGl0eTIuZGVmYXVsdCwgX2ZpbmRHZXRSZXN1bHQyLmRlZmF1bHQpKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtdWx0aWhhc2hlcyA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJylcbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKVxuY29uc3QgcHJvdG9idWYgPSByZXF1aXJlKCdwcm90b25zJylcbmNvbnN0IGZudjFhID0gcmVxdWlyZSgnZm52MWEnKVxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmNvbnN0IHsgREFHTm9kZSwgREFHTGluayB9ID0gcmVxdWlyZSgnaXBsZC1kYWctcGInKVxuY29uc3QgbXVsdGljb2RlYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuY29uc3Qgc29tZVNlcmllcyA9IHJlcXVpcmUoJ2FzeW5jL3NvbWVTZXJpZXMnKVxuY29uc3QgZWFjaE9mU2VyaWVzID0gcmVxdWlyZSgnYXN5bmMvZWFjaE9mU2VyaWVzJylcblxuY29uc3QgcGJTY2hlbWEgPSByZXF1aXJlKCcuL3Bpbi5wcm90bycpXG5cbmNvbnN0IGVtcHR5S2V5SGFzaCA9ICdRbWRmVGJCcUJQUTdWTnhaRVlFajE0Vm1SdVpCa3FGYml3UmVvZ0pnUzF6UjFuJ1xuY29uc3QgZW1wdHlLZXkgPSBtdWx0aWhhc2hlcy5mcm9tQjU4U3RyaW5nKGVtcHR5S2V5SGFzaClcbmNvbnN0IGRlZmF1bHRGYW5vdXQgPSAyNTZcbmNvbnN0IG1heEl0ZW1zID0gODE5MlxuY29uc3QgcGIgPSBwcm90b2J1ZihwYlNjaGVtYSlcblxuZnVuY3Rpb24gdG9CNThTdHJpbmcgKGhhc2gpIHtcbiAgcmV0dXJuIG5ldyBDSUQoaGFzaCkudG9CYXNlRW5jb2RlZFN0cmluZygpXG59XG5cbmZ1bmN0aW9uIHJlYWRIZWFkZXIgKHJvb3ROb2RlKSB7XG4gIC8vIHJvb3ROb2RlLmRhdGEgc2hvdWxkIGJlIGEgYnVmZmVyIG9mIHRoZSBmb3JtYXQ6XG4gIC8vIDwgdmFyaW50KGhlYWRlckxlbmd0aCkgfCBoZWFkZXIgfCBpdGVtRGF0YS4uLiA+XG4gIGNvbnN0IHJvb3REYXRhID0gcm9vdE5vZGUuRGF0YVxuICBjb25zdCBoZHJMZW5ndGggPSB2YXJpbnQuZGVjb2RlKHJvb3REYXRhKVxuICBjb25zdCB2Qnl0ZXMgPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gIGlmICh2Qnl0ZXMgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBTZXQgaGVhZGVyIGxlbmd0aCcpXG4gIH1cbiAgaWYgKHZCeXRlcyArIGhkckxlbmd0aCA+IHJvb3REYXRhLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW1wb3NzaWJseSBsYXJnZSBzZXQgaGVhZGVyIGxlbmd0aCcpXG4gIH1cbiAgY29uc3QgaGRyU2xpY2UgPSByb290RGF0YS5zbGljZSh2Qnl0ZXMsIGhkckxlbmd0aCArIHZCeXRlcylcbiAgY29uc3QgaGVhZGVyID0gcGIuU2V0LmRlY29kZShoZHJTbGljZSlcbiAgaWYgKGhlYWRlci52ZXJzaW9uICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBTZXQgdmVyc2lvbjogJHtoZWFkZXIudmVyc2lvbn1gKVxuICB9XG4gIGlmIChoZWFkZXIuZmFub3V0ID4gcm9vdE5vZGUuTGlua3MubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvc3NpYmx5IGxhcmdlIGZhbm91dCcpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoZWFkZXI6IGhlYWRlcixcbiAgICBkYXRhOiByb290RGF0YS5zbGljZShoZHJMZW5ndGggKyB2Qnl0ZXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzaCAoc2VlZCwga2V5KSB7XG4gIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyg0KVxuICBidWYud3JpdGVVSW50MzJMRShzZWVkLCAwKVxuICBjb25zdCBkYXRhID0gQnVmZmVyLmNvbmNhdChbXG4gICAgYnVmLCBCdWZmZXIuZnJvbSh0b0I1OFN0cmluZyhrZXkpKVxuICBdKVxuICByZXR1cm4gZm52MWEoZGF0YS50b1N0cmluZygnYmluYXJ5JykpXG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkYWcpIHtcbiAgY29uc3QgcGluU2V0ID0ge1xuICAgIC8vIHNob3VsZCB0aGlzIGJlIHBhcnQgb2YgYG9iamVjdGAgQVBJP1xuICAgIGhhc0Rlc2NlbmRhbnQ6IChyb290LCBjaGlsZGhhc2gsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBzZWVuID0ge31cblxuICAgICAgaWYgKENJRC5pc0NJRChjaGlsZGhhc2gpIHx8IEJ1ZmZlci5pc0J1ZmZlcihjaGlsZGhhc2gpKSB7XG4gICAgICAgIGNoaWxkaGFzaCA9IHRvQjU4U3RyaW5nKGNoaWxkaGFzaClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlYXJjaENoaWxkcmVuKHJvb3QsIGNhbGxiYWNrKVxuXG4gICAgICBmdW5jdGlvbiBzZWFyY2hDaGlsZHJlbiAocm9vdCwgY2IpIHtcbiAgICAgICAgc29tZVNlcmllcyhyb290LkxpbmtzLCAobGluaywgZG9uZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNpZCA9IGxpbmsuSGFzaFxuICAgICAgICAgIGNvbnN0IGJzNThMaW5rID0gdG9CNThTdHJpbmcoY2lkKVxuXG4gICAgICAgICAgaWYgKGJzNThMaW5rID09PSBjaGlsZGhhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwsIHRydWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJzNThMaW5rIGluIHNlZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwsIGZhbHNlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlZW5bYnM1OExpbmtdID0gdHJ1ZVxuXG4gICAgICAgICAgZGFnLmdldChjaWQsICcnLCB7IHByZWxvYWQ6IGZhbHNlIH0sIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlYXJjaENoaWxkcmVuKHJlcy52YWx1ZSwgZG9uZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9LCBjYilcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcmVTZXQ6IChrZXlzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgcGlucyA9IGtleXMubWFwKGtleSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIoa2V5KSkge1xuICAgICAgICAgIGtleSA9IG5ldyBDSUQoa2V5KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHBpblNldC5zdG9yZUl0ZW1zKHBpbnMsIChlcnIsIHJvb3ROb2RlKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycikgfVxuXG4gICAgICAgIGRhZy5wdXQocm9vdE5vZGUsIHtcbiAgICAgICAgICB2ZXJzaW9uOiAwLFxuICAgICAgICAgIGZvcm1hdDogbXVsdGljb2RlYy5EQUdfUEIsXG4gICAgICAgICAgaGFzaEFsZzogbXVsdGljb2RlYy5TSEEyXzI1NixcbiAgICAgICAgICBwcmVsb2FkOiBmYWxzZVxuICAgICAgICB9LCAoZXJyLCBjaWQpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIsIGNpZCkgfVxuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsgbm9kZTogcm9vdE5vZGUsIGNpZCB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgc3RvcmVJdGVtczogKGl0ZW1zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgcmV0dXJuIHN0b3JlUGlucyhpdGVtcywgMCwgY2FsbGJhY2spXG5cbiAgICAgIGZ1bmN0aW9uIHN0b3JlUGlucyAocGlucywgZGVwdGgsIHN0b3JlUGluc0NiKSB7XG4gICAgICAgIGNvbnN0IHBiSGVhZGVyID0gcGIuU2V0LmVuY29kZSh7XG4gICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICBmYW5vdXQ6IGRlZmF1bHRGYW5vdXQsXG4gICAgICAgICAgc2VlZDogZGVwdGhcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QgaGVhZGVyQnVmID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgQnVmZmVyLmZyb20odmFyaW50LmVuY29kZShwYkhlYWRlci5sZW5ndGgpKSwgcGJIZWFkZXJcbiAgICAgICAgXSlcbiAgICAgICAgY29uc3QgZmFub3V0TGlua3MgPSBbXVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmF1bHRGYW5vdXQ7IGkrKykge1xuICAgICAgICAgIGZhbm91dExpbmtzLnB1c2gobmV3IERBR0xpbmsoJycsIDEsIGVtcHR5S2V5KSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwaW5zLmxlbmd0aCA8PSBtYXhJdGVtcykge1xuICAgICAgICAgIGNvbnN0IG5vZGVzID0gcGluc1xuICAgICAgICAgICAgLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgbGluazogbmV3IERBR0xpbmsoJycsIDEsIGl0ZW0ua2V5KSxcbiAgICAgICAgICAgICAgICBkYXRhOiBpdGVtLmRhdGEgfHwgQnVmZmVyLmFsbG9jKDApXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy8gc29ydGluZyBtYWtlcyBhbnkgb3JkZXJpbmcgb2YgYHBpbnNgIHByb2R1Y2UgdGhlIHNhbWUgREFHTm9kZVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IEJ1ZmZlci5jb21wYXJlKGEubGluay5IYXNoLmJ1ZmZlciwgYi5saW5rLkhhc2guYnVmZmVyKSlcblxuICAgICAgICAgIGNvbnN0IHJvb3RMaW5rcyA9IGZhbm91dExpbmtzLmNvbmNhdChub2Rlcy5tYXAoaXRlbSA9PiBpdGVtLmxpbmspKVxuICAgICAgICAgIGNvbnN0IHJvb3REYXRhID0gQnVmZmVyLmNvbmNhdChcbiAgICAgICAgICAgIFtoZWFkZXJCdWZdLmNvbmNhdChub2Rlcy5tYXAoaXRlbSA9PiBpdGVtLmRhdGEpKVxuICAgICAgICAgIClcblxuICAgICAgICAgIGxldCByb290Tm9kZVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJvb3ROb2RlID0gREFHTm9kZS5jcmVhdGUocm9vdERhdGEsIHJvb3RMaW5rcylcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZVBpbnNDYihlcnIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlUGluc0NiKG51bGwsIHJvb3ROb2RlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBvZiBwaW5zIGlzID4gbWF4SXRlbXMsIHdlOlxuICAgICAgICAgIC8vICAtIGRpc3RyaWJ1dGUgdGhlIHBpbnMgYW1vbmcgYGRlZmF1bHRGYW5vdXRgIGJpbnNcbiAgICAgICAgICAvLyAgICAtIGNyZWF0ZSBhIERBR05vZGUgZm9yIGVhY2ggYmluXG4gICAgICAgICAgLy8gICAgICAtIGFkZCBlYWNoIHBpbiBhcyBhIERBR0xpbmsgdG8gdGhhdCBiaW5cbiAgICAgICAgICAvLyAgLSBjcmVhdGUgYSByb290IERBR05vZGVcbiAgICAgICAgICAvLyAgICAtIGFkZCBlYWNoIGJpbiBhcyBhIERBR0xpbmtcbiAgICAgICAgICAvLyAgLSBzZW5kIHRoYXQgcm9vdCBEQUdOb2RlIHZpYSBjYWxsYmFja1xuICAgICAgICAgIC8vICh1c2luZyBnby1pcGZzJyBcIndhc3RlZnVsIGJ1dCBzaW1wbGVcIiBhcHByb2FjaCBmb3IgY29uc2lzdGVuY3kpXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lwZnMvZ28taXBmcy9ibG9iL21hc3Rlci9waW4vc2V0LmdvI0w1N1xuXG4gICAgICAgICAgY29uc3QgYmlucyA9IHBpbnMucmVkdWNlKChiaW5zLCBwaW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBoYXNoKGRlcHRoLCBwaW4ua2V5KSAlIGRlZmF1bHRGYW5vdXRcbiAgICAgICAgICAgIGJpbnNbbl0gPSBuIGluIGJpbnMgPyBiaW5zW25dLmNvbmNhdChbcGluXSkgOiBbcGluXVxuICAgICAgICAgICAgcmV0dXJuIGJpbnNcbiAgICAgICAgICB9LCB7fSlcblxuICAgICAgICAgIGVhY2hPZlNlcmllcyhiaW5zLCAoYmluLCBpZHgsIGVhY2hDYikgPT4ge1xuICAgICAgICAgICAgc3RvcmVQaW5zKFxuICAgICAgICAgICAgICBiaW4sXG4gICAgICAgICAgICAgIGRlcHRoICsgMSxcbiAgICAgICAgICAgICAgKGVyciwgY2hpbGQpID0+IHN0b3JlQ2hpbGQoZXJyLCBjaGlsZCwgaWR4LCBlYWNoQ2IpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIHN0b3JlUGluc0NiKGVycikgfVxuXG4gICAgICAgICAgICBsZXQgcm9vdE5vZGVcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcm9vdE5vZGUgPSBEQUdOb2RlLmNyZWF0ZShoZWFkZXJCdWYsIGZhbm91dExpbmtzKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdG9yZVBpbnNDYihlcnIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdG9yZVBpbnNDYihudWxsLCByb290Tm9kZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3RvcmVDaGlsZCAoZXJyLCBjaGlsZCwgYmluSWR4LCBjYikge1xuICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNiKGVycikgfVxuXG4gICAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIHZlcnNpb246IDAsXG4gICAgICAgICAgICBmb3JtYXQ6IG11bHRpY29kZWMuREFHX1BCLFxuICAgICAgICAgICAgaGFzaEFsZzogbXVsdGljb2RlYy5TSEEyXzI1NixcbiAgICAgICAgICAgIHByZWxvYWQ6IGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGFnLnB1dChjaGlsZCwgb3B0cywgKGVyciwgY2lkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBjYihlcnIpIH1cbiAgICAgICAgICAgIGZhbm91dExpbmtzW2JpbklkeF0gPSBuZXcgREFHTGluaygnJywgY2hpbGQuc2l6ZSwgY2lkKVxuICAgICAgICAgICAgY2IobnVsbClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGxvYWRTZXQ6IChyb290Tm9kZSwgbmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IGxpbmsgPSByb290Tm9kZS5MaW5rcy5maW5kKGwgPT4gbC5OYW1lID09PSBuYW1lKVxuICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ05vIGxpbmsgZm91bmQgd2l0aCBuYW1lICcgKyBuYW1lKSlcbiAgICAgIH1cblxuICAgICAgZGFnLmdldChsaW5rLkhhc2gsICcnLCB7IHByZWxvYWQ6IGZhbHNlIH0sIChlcnIsIHJlcykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IFtdXG4gICAgICAgIGNvbnN0IHN0ZXAgPSBsaW5rID0+IGtleXMucHVzaChsaW5rLkhhc2guYnVmZmVyKVxuICAgICAgICBwaW5TZXQud2Fsa0l0ZW1zKHJlcy52YWx1ZSwgc3RlcCwgZXJyID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwga2V5cylcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIHdhbGtJdGVtczogKG5vZGUsIHN0ZXAsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBsZXQgcGJoXG4gICAgICB0cnkge1xuICAgICAgICBwYmggPSByZWFkSGVhZGVyKG5vZGUpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgZWFjaE9mU2VyaWVzKG5vZGUuTGlua3MsIChsaW5rLCBpZHgsIGVhY2hDYikgPT4ge1xuICAgICAgICBpZiAoaWR4IDwgcGJoLmhlYWRlci5mYW5vdXQpIHtcbiAgICAgICAgICAvLyB0aGUgZmlyc3QgcGJoLmhlYWRlci5mYW5vdXQgbGlua3MgYXJlIGZhbm91dCBiaW5zXG4gICAgICAgICAgLy8gaWYgYSBmYW5vdXQgYmluIGlzIG5vdCAnZW1wdHknLCBkaWcgaW50byBhbmQgd2FsayBpdHMgREFHTGlua3NcbiAgICAgICAgICBjb25zdCBsaW5rSGFzaCA9IGxpbmsuSGFzaC5idWZmZXJcblxuICAgICAgICAgIGlmICghZW1wdHlLZXkuZXF1YWxzKGxpbmtIYXNoKSkge1xuICAgICAgICAgICAgLy8gd2FsayB0aGUgbGlua3Mgb2YgdGhpcyBmYW5vdXQgYmluXG4gICAgICAgICAgICByZXR1cm4gZGFnLmdldChsaW5rSGFzaCwgJycsIHsgcHJlbG9hZDogZmFsc2UgfSwgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGVhY2hDYihlcnIpIH1cbiAgICAgICAgICAgICAgcGluU2V0LndhbGtJdGVtcyhyZXMudmFsdWUsIHN0ZXAsIGVhY2hDYilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSwgdGhlIGxpbmsgaXMgYSBwaW5cbiAgICAgICAgICBzdGVwKGxpbmssIGlkeCwgcGJoLmRhdGEpXG4gICAgICAgIH1cblxuICAgICAgICBlYWNoQ2IobnVsbClcbiAgICAgIH0sIGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGluU2V0XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgaXNJUEZTID0gcmVxdWlyZSgnaXMtaXBmcycpXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2lwZnM6aXBuczpwYXRoJylcbmxvZy5lcnJvciA9IGRlYnVnKCdpcGZzOmlwbnM6cGF0aDplcnJvcicpXG5cbi8vIHJlc29sdmVzIHRoZSBnaXZlbiBwYXRoIGJ5IHBhcnNpbmcgb3V0IHByb3RvY29sLXNwZWNpZmljIGVudHJpZXNcbi8vIChlLmcuIC9pcG5zLzxub2RlLWtleT4pIGFuZCB0aGVuIGdvaW5nIHRocm91Z2ggdGhlIC9pcGZzLyBlbnRyaWVzIGFuZCByZXR1cm5pbmcgdGhlIGZpbmFsIG5vZGVcbmNvbnN0IHJlc29sdmVQYXRoID0gKGlwZnNOb2RlLCBuYW1lLCBjYWxsYmFjaykgPT4ge1xuICAvLyBpcG5zIHBhdGhcbiAgaWYgKGlzSVBGUy5pcG5zUGF0aChuYW1lKSkge1xuICAgIGxvZyhgcmVzb2x2ZSBpcG5zIHBhdGggJHtuYW1lfWApXG5cbiAgICByZXR1cm4gaXBmc05vZGUuX2lwbnMucmVzb2x2ZShuYW1lLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8vIGlwZnMgcGF0aFxuICBpcGZzTm9kZS5kYWcuZ2V0KG5hbWUuc3Vic3RyaW5nKCcvaXBmcy8nLmxlbmd0aCksIChlcnIsIHZhbHVlKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdmFsdWUpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZXNvbHZlUGF0aFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgZXJyY29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuXG5jb25zdCBJcG5zUHVic3ViRGF0YXN0b3JlID0gcmVxdWlyZSgnLi4vaXBucy9yb3V0aW5nL3B1YnN1Yi1kYXRhc3RvcmUnKVxuXG5jb25zdCBsb2cgPSBkZWJ1ZygnaXBmczpuYW1lLXB1YnN1YicpXG5sb2cuZXJyb3IgPSBkZWJ1ZygnaXBmczpuYW1lLXB1YnN1YjplcnJvcicpXG5cbi8vIElzIHB1YnN1YiBlbmFibGVkXG5jb25zdCBpc05hbWVQdWJzdWJFbmFibGVkID0gKG5vZGUpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gQm9vbGVhbihnZXRQdWJzdWJSb3V0aW5nKG5vZGUpKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vLyBHZXQgcHVic3ViIGZyb20gSVBOUyByb3V0aW5nXG5jb25zdCBnZXRQdWJzdWJSb3V0aW5nID0gKG5vZGUpID0+IHtcbiAgaWYgKCFub2RlLl9pcG5zIHx8ICFub2RlLl9vcHRpb25zLkVYUEVSSU1FTlRBTC5pcG5zUHVic3ViKSB7XG4gICAgY29uc3QgZXJyTXNnID0gJ0lQTlMgcHVic3ViIHN1YnN5c3RlbSBpcyBub3QgZW5hYmxlZCdcblxuICAgIHRocm93IGVycmNvZGUoZXJyTXNnLCAnRVJSX0lQTlNfUFVCU1VCX05PVF9FTkFCTEVEJylcbiAgfVxuXG4gIC8vIE9ubHkgb25lIHN0b3JlIGFuZCBpdCBpcyBwdWJzdWJcbiAgaWYgKElwbnNQdWJzdWJEYXRhc3RvcmUuaXNJcG5zUHVic3ViRGF0YXN0b3JlKG5vZGUuX2lwbnMucm91dGluZykpIHtcbiAgICByZXR1cm4gbm9kZS5faXBucy5yb3V0aW5nXG4gIH1cblxuICAvLyBGaW5kIGluIHRpZXJlZFxuICBjb25zdCBwdWJzdWIgPSAobm9kZS5faXBucy5yb3V0aW5nLnN0b3JlcyB8fCBbXSkuZmluZChzID0+IElwbnNQdWJzdWJEYXRhc3RvcmUuaXNJcG5zUHVic3ViRGF0YXN0b3JlKHMpKVxuXG4gIGlmICghcHVic3ViKSB7XG4gICAgY29uc3QgZXJyTXNnID0gJ0lQTlMgcHVic3ViIGRhdGFzdG9yZSBub3QgZm91bmQnXG5cbiAgICB0aHJvdyBlcnJjb2RlKGVyck1zZywgJ0VSUl9QVUJTVUJfREFUQVNUT1JFX05PVF9GT1VORCcpXG4gIH1cblxuICByZXR1cm4gcHVic3ViXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbmFtZVB1YnN1YiAoc2VsZikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFF1ZXJ5IHRoZSBzdGF0ZSBvZiBJUE5TIHB1YnN1Yi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfHZvaWR9XG4gICAgICovXG4gICAgc3RhdGU6IHByb21pc2lmeSgoY2FsbGJhY2spID0+IHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgZW5hYmxlZDogaXNOYW1lUHVic3ViRW5hYmxlZChzZWxmKVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYSBuYW1lIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHN1YnNjcmlwdGlvbiBuYW1lLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBbY2FsbGJhY2tdXG4gICAgICogQHJldHVybnMge1Byb21pc2V8dm9pZH1cbiAgICAgKi9cbiAgICBjYW5jZWw6IHByb21pc2lmeSgobmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgIGxldCBwdWJzdWJcbiAgICAgIHRyeSB7XG4gICAgICAgIHB1YnN1YiA9IGdldFB1YnN1YlJvdXRpbmcoc2VsZilcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBwdWJzdWIuY2FuY2VsKG5hbWUsIGNhbGxiYWNrKVxuICAgIH0pLFxuICAgIC8qKlxuICAgICAqIFNob3cgY3VycmVudCBuYW1lIHN1YnNjcmlwdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gW2NhbGxiYWNrXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfHZvaWR9XG4gICAgICovXG4gICAgc3ViczogcHJvbWlzaWZ5KChjYWxsYmFjaykgPT4ge1xuICAgICAgbGV0IHB1YnN1YlxuICAgICAgdHJ5IHtcbiAgICAgICAgcHVic3ViID0gZ2V0UHVic3ViUm91dGluZyhzZWxmKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIHB1YnN1Yi5nZXRTdWJzY3JpcHRpb25zKGNhbGxiYWNrKVxuICAgIH0pXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBmYWlsICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdLZXkgbWFuYWdlbWVudCByZXF1aXJlcyBcXCctLXBhc3MgLi4uXFwnIG9wdGlvbicpXG59XG5cbmNsYXNzIE5vS2V5Y2hhaW4ge1xuICBzdGF0aWMgZ2V0IG9wdGlvbnMgKCkgeyBmYWlsKCkgfVxuICBzdGF0aWMgZ2VuZXJhdGVPcHRpb25zICgpIHsgZmFpbCgpIH1cblxuICBjcmVhdGVLZXkgKCkgeyBmYWlsKCkgfVxuICBsaXN0S2V5cyAoKSB7IGZhaWwoKSB9XG4gIGZpbmRLZXlCeUlkICgpIHsgZmFpbCgpIH1cbiAgZmluZEtleUJ5TmFtZSAoKSB7IGZhaWwoKSB9XG4gIHJlbmFtZUtleSAoKSB7IGZhaWwoKSB9XG4gIHJlbW92ZUtleSAoKSB7IGZhaWwoKSB9XG4gIGV4cG9ydEtleSAoKSB7IGZhaWwoKSB9XG4gIGltcG9ydEtleSAoKSB7IGZhaWwoKSB9XG4gIGltcG9ydFBlZXIgKCkgeyBmYWlsKCkgfVxuXG4gIGdldCBjbXMgKCkgeyBmYWlsKCkgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5vS2V5Y2hhaW5cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4va2V5Y2hhaW4nKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgVGllcmVkRGF0YXN0b3JlIH0gPSByZXF1aXJlKCdkYXRhc3RvcmUtY29yZScpXG5jb25zdCBnZXQgPSByZXF1aXJlKCdkbHYnKVxuXG5jb25zdCBQdWJzdWJEYXRhc3RvcmUgPSByZXF1aXJlKCcuL3B1YnN1Yi1kYXRhc3RvcmUnKVxuY29uc3QgT2ZmbGluZURhdGFzdG9yZSA9IHJlcXVpcmUoJy4vb2ZmbGluZS1kYXRhc3RvcmUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChpcGZzKSA9PiB7XG4gIC8vIFNldHVwIG9ubGluZSByb3V0aW5nIGZvciBJUE5TIHdpdGggYSB0aWVyZWQgcm91dGluZyBjb21wb3NlZCBieSBhIERIVCBhbmQgYSBQdWJzdWIgcm91dGVyIChpZiBwcm9wZXJseSBlbmFibGVkKVxuICBjb25zdCBpcG5zU3RvcmVzID0gW11cblxuICAvLyBBZGQgSVBOUyBwdWJzdWIgaWYgZW5hYmxlZFxuICBsZXQgcHVic3ViRHNcbiAgaWYgKGdldChpcGZzLl9vcHRpb25zLCAnRVhQRVJJTUVOVEFMLmlwbnNQdWJzdWInLCBmYWxzZSkpIHtcbiAgICBjb25zdCBwdWJzdWIgPSBpcGZzLmxpYnAycC5wdWJzdWJcbiAgICBjb25zdCBsb2NhbERhdGFzdG9yZSA9IGlwZnMuX3JlcG8uZGF0YXN0b3JlXG4gICAgY29uc3QgcGVlcklkID0gaXBmcy5fcGVlckluZm8uaWRcblxuICAgIHB1YnN1YkRzID0gbmV3IFB1YnN1YkRhdGFzdG9yZShwdWJzdWIsIGxvY2FsRGF0YXN0b3JlLCBwZWVySWQpXG4gICAgaXBuc1N0b3Jlcy5wdXNoKHB1YnN1YkRzKVxuICB9XG5cbiAgLy8gREhUIHNob3VsZCBub3QgYmUgYWRkZWQgYXMgcm91dGluZyBpZiB3ZSBhcmUgb2ZmbGluZSBvciBpdCBpcyBkaXNhYmxlZFxuICBpZiAoZ2V0KGlwZnMuX29wdGlvbnMsICdvZmZsaW5lJykgfHwgIWdldChpcGZzLl9vcHRpb25zLCAnbGlicDJwLmRodC5lbmFibGVkJywgZmFsc2UpKSB7XG4gICAgY29uc3Qgb2ZmbGluZURhdGFzdG9yZSA9IG5ldyBPZmZsaW5lRGF0YXN0b3JlKGlwZnMuX3JlcG8pXG4gICAgaXBuc1N0b3Jlcy5wdXNoKG9mZmxpbmVEYXRhc3RvcmUpXG4gIH0gZWxzZSB7XG4gICAgaXBuc1N0b3Jlcy5wdXNoKGlwZnMubGlicDJwLmRodClcbiAgfVxuXG4gIC8vIENyZWF0ZSBpcG5zIHJvdXRpbmcgd2l0aCBhIHNldCBvZiBkYXRhc3RvcmVzXG4gIHJldHVybiBuZXcgVGllcmVkRGF0YXN0b3JlKGlwbnNTdG9yZXMpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBjcmVhdGVGcm9tUHJpdktleSB9ID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCBzZXJpZXMgPSByZXF1aXJlKCdhc3luYy9zZXJpZXMnKVxuY29uc3QgUmVjZXB0YWNsZSA9IHJlcXVpcmUoJ3JlY2VwdGFjbGUnKVxuXG5jb25zdCBlcnJjb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBsb2cgPSBkZWJ1ZygnaXBmczppcG5zJylcbmxvZy5lcnJvciA9IGRlYnVnKCdpcGZzOmlwbnM6ZXJyb3InKVxuXG5jb25zdCBJcG5zUHVibGlzaGVyID0gcmVxdWlyZSgnLi9wdWJsaXNoZXInKVxuY29uc3QgSXBuc1JlcHVibGlzaGVyID0gcmVxdWlyZSgnLi9yZXB1Ymxpc2hlcicpXG5jb25zdCBJcG5zUmVzb2x2ZXIgPSByZXF1aXJlKCcuL3Jlc29sdmVyJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKVxuXG5jb25zdCBkZWZhdWx0UmVjb3JkVHRsID0gNjAgKiAxMDAwXG5cbmNsYXNzIElQTlMge1xuICBjb25zdHJ1Y3RvciAocm91dGluZywgZGF0YXN0b3JlLCBwZWVySW5mbywga2V5Y2hhaW4sIG9wdGlvbnMpIHtcbiAgICB0aGlzLnB1Ymxpc2hlciA9IG5ldyBJcG5zUHVibGlzaGVyKHJvdXRpbmcsIGRhdGFzdG9yZSlcbiAgICB0aGlzLnJlcHVibGlzaGVyID0gbmV3IElwbnNSZXB1Ymxpc2hlcih0aGlzLnB1Ymxpc2hlciwgZGF0YXN0b3JlLCBwZWVySW5mbywga2V5Y2hhaW4sIG9wdGlvbnMpXG4gICAgdGhpcy5yZXNvbHZlciA9IG5ldyBJcG5zUmVzb2x2ZXIocm91dGluZylcbiAgICB0aGlzLmNhY2hlID0gbmV3IFJlY2VwdGFjbGUoeyBtYXg6IDEwMDAgfSkgLy8gQ3JlYXRlIGFuIExSVSBjYWNoZSB3aXRoIG1heCAxMDAwIGl0ZW1zXG4gICAgdGhpcy5yb3V0aW5nID0gcm91dGluZ1xuICB9XG5cbiAgLy8gUHVibGlzaFxuICBwdWJsaXNoIChwcml2S2V5LCB2YWx1ZSwgbGlmZXRpbWUsIGNhbGxiYWNrKSB7XG4gICAgc2VyaWVzKFtcbiAgICAgIChjYikgPT4gY3JlYXRlRnJvbVByaXZLZXkocHJpdktleS5ieXRlcywgY2IpLFxuICAgICAgKGNiKSA9PiB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoV2l0aEVPTChwcml2S2V5LCB2YWx1ZSwgbGlmZXRpbWUsIGNiKVxuICAgIF0sIChlcnIsIHJlc3VsdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yKGVycilcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgbG9nKGBJUE5TIHZhbHVlICR7dmFsdWV9IHdhcyBwdWJsaXNoZWQgY29ycmVjdGx5YClcblxuICAgICAgLy8gQWRkIHRvIGNhY2hlXG4gICAgICBjb25zdCBpZCA9IHJlc3VsdHNbMF0udG9CNThTdHJpbmcoKVxuICAgICAgY29uc3QgdHRFb2wgPSBwYXJzZUZsb2F0KGxpZmV0aW1lKVxuICAgICAgY29uc3QgdHRsID0gKHR0RW9sIDwgZGVmYXVsdFJlY29yZFR0bCkgPyB0dEVvbCA6IGRlZmF1bHRSZWNvcmRUdGxcblxuICAgICAgdGhpcy5jYWNoZS5zZXQoaWQsIHZhbHVlLCB7IHR0bDogdHRsIH0pXG5cbiAgICAgIGxvZyhgSVBOUyB2YWx1ZSAke3ZhbHVlfSB3YXMgY2FjaGVkIGNvcnJlY3RseWApXG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgbmFtZTogaWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLy8gUmVzb2x2ZVxuICByZXNvbHZlIChuYW1lLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGVyck1zZyA9IGBuYW1lIHJlY2VpdmVkIGlzIG5vdCB2YWxpZGBcblxuICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKG5ldyBFcnJvcihlcnJNc2cpLCAnRVJSX0lOVkFMSURfTkFNRScpKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgLy8gSWYgcmVjdXJzaXZlLCB3ZSBzaG91bGQgbm90IHRyeSB0byBnZXQgdGhlIGNhY2hlZCB2YWx1ZVxuICAgIGlmICghb3B0aW9ucy5ub2NhY2hlICYmICFvcHRpb25zLnJlY3Vyc2l2ZSkge1xuICAgICAgLy8gVHJ5IHRvIGdldCB0aGUgcmVjb3JkIGZyb20gY2FjaGVcbiAgICAgIGNvbnN0IGlkID0gbmFtZS5zcGxpdCgnLycpWzJdXG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNhY2hlLmdldChpZClcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgIHBhdGg6IHJlc3VsdFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVzb2x2ZXIucmVzb2x2ZShuYW1lLCBvcHRpb25zLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yKGVycilcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgbG9nKGBJUE5TIHJlY29yZCBmcm9tICR7bmFtZX0gd2FzIHJlc29sdmVkIGNvcnJlY3RseWApXG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgcGF0aDogcmVzdWx0XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBJbml0aWFsaXplIGtleXNwYWNlXG4gIC8vIHNldHMgdGhlIGlwbnMgcmVjb3JkIGZvciB0aGUgZ2l2ZW4ga2V5IHRvIHBvaW50IHRvIGFuIGVtcHR5IGRpcmVjdG9yeVxuICBpbml0aWFsaXplS2V5c3BhY2UgKHByaXZLZXksIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHRoaXMucHVibGlzaGVyLnB1Ymxpc2gocHJpdktleSwgdmFsdWUsIGNhbGxiYWNrKVxuICB9XG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IElQTlNcbmV4cG9ydHMucGF0aCA9IHBhdGhcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB3YXRlcmZhbGwgPSByZXF1aXJlKCdhc3luYy93YXRlcmZhbGwnKVxuY29uc3QgcmVqZWN0ID0gcmVxdWlyZSgnYXN5bmMvcmVqZWN0JylcbmNvbnN0IGVhY2ggPSByZXF1aXJlKCdhc3luYy9lYWNoJylcbmNvbnN0IHNlcmllcyA9IHJlcXVpcmUoJ2FzeW5jL3NlcmllcycpXG5jb25zdCBtYXAgPSByZXF1aXJlKCdhc3luYy9tYXAnKVxuY29uc3QgbmV4dFRpY2sgPSByZXF1aXJlKCdhc3luYy9uZXh0VGljaycpXG5cbmNvbnN0IFdhbnRNYW5hZ2VyID0gcmVxdWlyZSgnLi93YW50LW1hbmFnZXInKVxuY29uc3QgTmV0d29yayA9IHJlcXVpcmUoJy4vbmV0d29yaycpXG5jb25zdCBEZWNpc2lvbkVuZ2luZSA9IHJlcXVpcmUoJy4vZGVjaXNpb24tZW5naW5lJylcbmNvbnN0IE5vdGlmaWNhdGlvbnMgPSByZXF1aXJlKCcuL25vdGlmaWNhdGlvbnMnKVxuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi91dGlscycpLmxvZ2dlclxuY29uc3QgU3RhdHMgPSByZXF1aXJlKCcuL3N0YXRzJylcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHN0YXRzRW5hYmxlZDogZmFsc2UsXG4gIHN0YXRzQ29tcHV0ZVRocm90dGxlVGltZW91dDogMTAwMCxcbiAgc3RhdHNDb21wdXRlVGhyb3R0bGVNYXhRdWV1ZVNpemU6IDEwMDBcbn1cbmNvbnN0IHN0YXRzS2V5cyA9IFtcbiAgJ2Jsb2Nrc1JlY2VpdmVkJyxcbiAgJ2RhdGFSZWNlaXZlZCcsXG4gICdkdXBCbGtzUmVjZWl2ZWQnLFxuICAnZHVwRGF0YVJlY2VpdmVkJyxcbiAgJ2Jsb2Nrc1NlbnQnLFxuICAnZGF0YVNlbnQnLFxuICAncHJvdmlkZXNCdWZmZXJMZW5ndGgnLFxuICAnd2FudExpc3RMZW5ndGgnLFxuICAncGVlckNvdW50J1xuXVxuXG4vKipcbiAqIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIEJpdHN3YXAgJ2RhdGEgZXhjaGFuZ2UnIHByb3RvY29sXG4gKiB1c2VkIGJ5IElQRlMuXG4gKlxuICogQHBhcmFtIHtMaWJwMnB9IGxpYnAycFxuICogQHBhcmFtIHtCbG9ja3N0b3JlfSBibG9ja3N0b3JlXG4gKi9cbmNsYXNzIEJpdHN3YXAge1xuICBjb25zdHJ1Y3RvciAobGlicDJwLCBibG9ja3N0b3JlLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fbGlicDJwID0gbGlicDJwXG4gICAgdGhpcy5fbG9nID0gbG9nZ2VyKHRoaXMucGVlckluZm8uaWQpXG5cbiAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpXG5cbiAgICAvLyBzdGF0c1xuICAgIHRoaXMuX3N0YXRzID0gbmV3IFN0YXRzKHN0YXRzS2V5cywge1xuICAgICAgZW5hYmxlZDogdGhpcy5fb3B0aW9ucy5zdGF0c0VuYWJsZWQsXG4gICAgICBjb21wdXRlVGhyb3R0bGVUaW1lb3V0OiB0aGlzLl9vcHRpb25zLnN0YXRzQ29tcHV0ZVRocm90dGxlVGltZW91dCxcbiAgICAgIGNvbXB1dGVUaHJvdHRsZU1heFF1ZXVlU2l6ZTogdGhpcy5fb3B0aW9ucy5zdGF0c0NvbXB1dGVUaHJvdHRsZU1heFF1ZXVlU2l6ZVxuICAgIH0pXG5cbiAgICAvLyB0aGUgbmV0d29yayBkZWxpdmVycyBtZXNzYWdlc1xuICAgIHRoaXMubmV0d29yayA9IG5ldyBOZXR3b3JrKGxpYnAycCwgdGhpcywge30sIHRoaXMuX3N0YXRzKVxuXG4gICAgLy8gbG9jYWwgZGF0YWJhc2VcbiAgICB0aGlzLmJsb2Nrc3RvcmUgPSBibG9ja3N0b3JlXG5cbiAgICB0aGlzLmVuZ2luZSA9IG5ldyBEZWNpc2lvbkVuZ2luZSh0aGlzLnBlZXJJbmZvLmlkLCBibG9ja3N0b3JlLCB0aGlzLm5ldHdvcmssIHRoaXMuX3N0YXRzKVxuXG4gICAgLy8gaGFuZGxlIG1lc3NhZ2Ugc2VuZGluZ1xuICAgIHRoaXMud20gPSBuZXcgV2FudE1hbmFnZXIodGhpcy5wZWVySW5mby5pZCwgdGhpcy5uZXR3b3JrLCB0aGlzLl9zdGF0cylcblxuICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IG5ldyBOb3RpZmljYXRpb25zKHRoaXMucGVlckluZm8uaWQpXG4gIH1cblxuICBnZXQgcGVlckluZm8gKCkge1xuICAgIHJldHVybiB0aGlzLl9saWJwMnAucGVlckluZm9cbiAgfVxuXG4gIC8vIGhhbmRsZSBtZXNzYWdlcyByZWNlaXZlZCB0aHJvdWdoIHRoZSBuZXR3b3JrXG4gIF9yZWNlaXZlTWVzc2FnZSAocGVlcklkLCBpbmNvbWluZywgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVuZ2luZS5tZXNzYWdlUmVjZWl2ZWQocGVlcklkLCBpbmNvbWluZywgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBPbmx5IGxvZ2dpbmcgdGhlIGlzc3VlIHRvIHByb2Nlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZVxuICAgICAgICAvLyBvZiB0aGUgbWVzc2FnZS4gQ3VycmVudGx5IGBtZXNzYWdlUmVjZWl2ZWRgIGRvZXMgbm90XG4gICAgICAgIC8vIHJldHVybiBhbnkgZXJyb3JzLCBidXQgdGhpcyBjb3VsZCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgdGhpcy5fbG9nKCdmYWlsZWQgdG8gcmVjZWl2ZSBtZXNzYWdlJywgaW5jb21pbmcpXG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNvbWluZy5ibG9ja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBibG9ja3MgPSBBcnJheS5mcm9tKGluY29taW5nLmJsb2Nrcy52YWx1ZXMoKSlcblxuICAgICAgLy8gcXVpY2tseSBzZW5kIG91dCBjYW5jZWxzLCByZWR1Y2VzIGNoYW5jZXMgb2YgZHVwbGljYXRlIGJsb2NrIHJlY2VpdmVzXG4gICAgICBjb25zdCB3YW50ZWQgPSBibG9ja3NcbiAgICAgICAgLmZpbHRlcigoYikgPT4gdGhpcy53bS53YW50bGlzdC5jb250YWlucyhiLmNpZCkpXG4gICAgICAgIC5tYXAoKGIpID0+IGIuY2lkKVxuXG4gICAgICB0aGlzLndtLmNhbmNlbFdhbnRzKHdhbnRlZClcblxuICAgICAgZWFjaChcbiAgICAgICAgYmxvY2tzLFxuICAgICAgICAoYiwgY2IpID0+IHtcbiAgICAgICAgICBjb25zdCB3YXNXYW50ZWQgPSB3YW50ZWQuaW5jbHVkZXMoYi5jaWQpXG4gICAgICAgICAgdGhpcy5faGFuZGxlUmVjZWl2ZWRCbG9jayhwZWVySWQsIGIsIHdhc1dhbnRlZCwgY2IpXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIF9oYW5kbGVSZWNlaXZlZEJsb2NrIChwZWVySWQsIGJsb2NrLCB3YXNXYW50ZWQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fbG9nKCdyZWNlaXZlZCBibG9jaycpXG5cbiAgICB3YXRlcmZhbGwoW1xuICAgICAgKGNiKSA9PiB0aGlzLmJsb2Nrc3RvcmUuaGFzKGJsb2NrLmNpZCwgY2IpLFxuICAgICAgKGhhcywgY2IpID0+IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUmVjZWl2ZUNvdW50ZXJzKHBlZXJJZC50b0I1OFN0cmluZygpLCBibG9jaywgaGFzKVxuICAgICAgICBpZiAoaGFzIHx8ICF3YXNXYW50ZWQpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dFRpY2soY2IpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wdXRCbG9jayhibG9jaywgY2IpXG4gICAgICB9XG4gICAgXSwgY2FsbGJhY2spXG4gIH1cblxuICBfdXBkYXRlUmVjZWl2ZUNvdW50ZXJzIChwZWVySWQsIGJsb2NrLCBleGlzdHMpIHtcbiAgICB0aGlzLl9zdGF0cy5wdXNoKHBlZXJJZCwgJ2Jsb2Nrc1JlY2VpdmVkJywgMSlcbiAgICB0aGlzLl9zdGF0cy5wdXNoKHBlZXJJZCwgJ2RhdGFSZWNlaXZlZCcsIGJsb2NrLmRhdGEubGVuZ3RoKVxuXG4gICAgaWYgKGV4aXN0cykge1xuICAgICAgdGhpcy5fc3RhdHMucHVzaChwZWVySWQsICdkdXBCbGtzUmVjZWl2ZWQnLCAxKVxuICAgICAgdGhpcy5fc3RhdHMucHVzaChwZWVySWQsICdkdXBEYXRhUmVjZWl2ZWQnLCBibG9jay5kYXRhLmxlbmd0aClcbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgZXJyb3JzIG9uIHRoZSByZWNlaXZpbmcgY2hhbm5lbFxuICBfcmVjZWl2ZUVycm9yIChlcnIpIHtcbiAgICB0aGlzLl9sb2cuZXJyb3IoJ1JlY2VpdmVFcnJvcjogJXMnLCBlcnIubWVzc2FnZSlcbiAgfVxuXG4gIC8vIGhhbmRsZSBuZXcgcGVlcnNcbiAgX29uUGVlckNvbm5lY3RlZCAocGVlcklkKSB7XG4gICAgdGhpcy53bS5jb25uZWN0ZWQocGVlcklkKVxuICB9XG5cbiAgLy8gaGFuZGxlIHBlZXJzIGJlaW5nIGRpc2Nvbm5lY3RlZFxuICBfb25QZWVyRGlzY29ubmVjdGVkIChwZWVySWQpIHtcbiAgICB0aGlzLndtLmRpc2Nvbm5lY3RlZChwZWVySWQpXG4gICAgdGhpcy5lbmdpbmUucGVlckRpc2Nvbm5lY3RlZChwZWVySWQpXG4gICAgdGhpcy5fc3RhdHMuZGlzY29ubmVjdGVkKHBlZXJJZClcbiAgfVxuXG4gIF9wdXRCbG9jayAoYmxvY2ssIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5ibG9ja3N0b3JlLnB1dChibG9jaywgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMuaGFzQmxvY2soYmxvY2spXG4gICAgICB0aGlzLm5ldHdvcmsucHJvdmlkZShibG9jay5jaWQsIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcignRmFpbGVkIHRvIHByb3ZpZGU6ICVzJywgZXJyLm1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuZW5naW5lLnJlY2VpdmVkQmxvY2tzKFtibG9jay5jaWRdKVxuICAgICAgY2FsbGJhY2soKVxuICAgIH0pXG4gIH1cblxuICBlbmFibGVTdGF0cyAoKSB7XG4gICAgdGhpcy5fc3RhdHMuZW5hYmxlKClcbiAgfVxuXG4gIGRpc2FibGVTdGF0cyAoKSB7XG4gICAgdGhpcy5fc3RhdHMuZGlzYWJsZSgpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IHdhbnRsaXN0IGZvciBhIGdpdmVuIGBwZWVySWRgXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlcklkfSBwZWVySWRcbiAgICogQHJldHVybnMge1dhbnRsaXN0fVxuICAgKi9cbiAgd2FudGxpc3RGb3JQZWVyIChwZWVySWQpIHtcbiAgICByZXR1cm4gdGhpcy5lbmdpbmUud2FudGxpc3RGb3JQZWVyKHBlZXJJZClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gbGVkZ2VyIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGBwZWVySWRgXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlcklkfSBwZWVySWRcbiAgICogQHJldHVybnMgez9PYmplY3R9XG4gICAqL1xuICBsZWRnZXJGb3JQZWVyIChwZWVySWQpIHtcbiAgICByZXR1cm4gdGhpcy5lbmdpbmUubGVkZ2VyRm9yUGVlcihwZWVySWQpXG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBnaXZlbiBibG9jayBieSBjaWQuIElmIHRoZSBibG9jayBpcyBpbiB0aGUgbG9jYWxcbiAgICogYmxvY2tzdG9yZSBpdCBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIHRoZSBibG9jayBpcyBhZGRlZCB0byB0aGUgd2FudGxpc3QgYW5kIHJldHVybmVkIG9uY2UgYW5vdGhlciBub2RlIHNlbmRzIGl0IHRvIHVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NJRH0gY2lkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEJsb2NrKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBnZXQgKGNpZCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmdldE1hbnkoW2NpZF0sIChlcnIsIGJsb2NrcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2tzICYmIGJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGJsb2Nrc1swXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdoZW4gYSB1bndhbnQgaGFwcGVuc1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGEgbGlzdCBvZiBibG9ja3MgYnkgY2lkLiBJZiB0aGUgYmxvY2tzIGFyZSBpbiB0aGUgbG9jYWxcbiAgICogYmxvY2tzdG9yZSB0aGV5IGFyZSByZXR1cm5lZCwgb3RoZXJ3aXNlIHRoZSBibG9ja3MgYXJlIGFkZGVkIHRvIHRoZSB3YW50bGlzdCBhbmQgcmV0dXJuZWQgb25jZSBhbm90aGVyIG5vZGUgc2VuZHMgdGhlbSB0byB1cy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxDSUQ+fSBjaWRzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEJsb2Nrcyl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZ2V0TWFueSAoY2lkcywgY2FsbGJhY2spIHtcbiAgICBsZXQgcGVuZGluZ1N0YXJ0ID0gY2lkcy5sZW5ndGhcbiAgICBjb25zdCB3YW50TGlzdCA9IFtdXG4gICAgbGV0IHByb21wdGVkTmV0d29yayA9IGZhbHNlXG5cbiAgICBjb25zdCBnZXRGcm9tT3V0c2lkZSA9IChjaWQsIGNiKSA9PiB7XG4gICAgICB3YW50TGlzdC5wdXNoKGNpZClcblxuICAgICAgdGhpcy5ub3RpZmljYXRpb25zLndhbnRCbG9jayhcbiAgICAgICAgY2lkLFxuICAgICAgICAvLyBjYWxsZWQgb24gYmxvY2sgcmVjZWl2ZVxuICAgICAgICAoYmxvY2spID0+IHtcbiAgICAgICAgICB0aGlzLndtLmNhbmNlbFdhbnRzKFtjaWRdKVxuICAgICAgICAgIGNiKG51bGwsIGJsb2NrKVxuICAgICAgICB9LFxuICAgICAgICAvLyBjYWxsZWQgb24gdW53YW50XG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICB0aGlzLndtLmNhbmNlbFdhbnRzKFtjaWRdKVxuICAgICAgICAgIGNiKG51bGwsIHVuZGVmaW5lZClcbiAgICAgICAgfVxuICAgICAgKVxuXG4gICAgICBpZiAoIXBlbmRpbmdTdGFydCkge1xuICAgICAgICB0aGlzLndtLndhbnRCbG9ja3Mod2FudExpc3QpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbWFwKGNpZHMsIChjaWQsIGNiKSA9PiB7XG4gICAgICB3YXRlcmZhbGwoXG4gICAgICAgIFtcbiAgICAgICAgICAoY2IpID0+IHRoaXMuYmxvY2tzdG9yZS5oYXMoY2lkLCBjYiksXG4gICAgICAgICAgKGhhcywgY2IpID0+IHtcbiAgICAgICAgICAgIHBlbmRpbmdTdGFydC0tXG4gICAgICAgICAgICBpZiAoaGFzKSB7XG4gICAgICAgICAgICAgIGlmICghcGVuZGluZ1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy53bS53YW50QmxvY2tzKHdhbnRMaXN0KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmJsb2Nrc3RvcmUuZ2V0KGNpZCwgY2IpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcHJvbXB0ZWROZXR3b3JrKSB7XG4gICAgICAgICAgICAgIHByb21wdGVkTmV0d29yayA9IHRydWVcbiAgICAgICAgICAgICAgdGhpcy5uZXR3b3JrLmZpbmRBbmRDb25uZWN0KGNpZHNbMF0sIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IoZXJyKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSB0aGUgYmxvY2sgaGVyZVxuICAgICAgICAgICAgZ2V0RnJvbU91dHNpZGUoY2lkLCBjYilcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGNiKVxuICAgIH0sIGNhbGxiYWNrKVxuICB9XG5cbiAgLy8gcmVtb3ZlcyB0aGUgZ2l2ZW4gY2lkcyBmcm9tIHRoZSB3YW50bGlzdCBpbmRlcGVuZGVudCBvZiBhbnkgcmVmIGNvdW50c1xuICB1bndhbnQgKGNpZHMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2lkcykpIHtcbiAgICAgIGNpZHMgPSBbY2lkc11cbiAgICB9XG5cbiAgICB0aGlzLndtLnVud2FudEJsb2NrcyhjaWRzKVxuICAgIGNpZHMuZm9yRWFjaCgoY2lkKSA9PiB0aGlzLm5vdGlmaWNhdGlvbnMudW53YW50QmxvY2soY2lkKSlcbiAgfVxuXG4gIC8vIHJlbW92ZXMgdGhlIGdpdmVuIGtleXMgZnJvbSB0aGUgd2FudCBsaXN0XG4gIGNhbmNlbFdhbnRzIChjaWRzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNpZHMpKSB7XG4gICAgICBjaWRzID0gW2NpZHNdXG4gICAgfVxuICAgIHRoaXMud20uY2FuY2VsV2FudHMoY2lkcylcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXQgdGhlIGdpdmVuIGJsb2NrIHRvIHRoZSB1bmRlcmx5aW5nIGJsb2Nrc3RvcmUgYW5kXG4gICAqIHNlbmQgaXQgdG8gbm9kZXMgdGhhdCBoYXZlIGl0IGluIHRoZWlyIHdhbnRsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9ja1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBwdXQgKGJsb2NrLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2xvZygncHV0dGluZyBibG9jaycpXG5cbiAgICB3YXRlcmZhbGwoW1xuICAgICAgKGNiKSA9PiB0aGlzLmJsb2Nrc3RvcmUuaGFzKGJsb2NrLmNpZCwgY2IpLFxuICAgICAgKGhhcywgY2IpID0+IHtcbiAgICAgICAgaWYgKGhhcykge1xuICAgICAgICAgIHJldHVybiBuZXh0VGljayhjYilcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3B1dEJsb2NrKGJsb2NrLCBjYilcbiAgICAgIH1cbiAgICBdLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXQgdGhlIGdpdmVuIGJsb2NrcyB0byB0aGUgdW5kZXJseWluZyBibG9ja3N0b3JlIGFuZFxuICAgKiBzZW5kIGl0IHRvIG5vZGVzIHRoYXQgaGF2ZSBpdCB0aGVtIHRoZWlyIHdhbnRsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PEJsb2NrPn0gYmxvY2tzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHB1dE1hbnkgKGJsb2NrcywgY2FsbGJhY2spIHtcbiAgICB3YXRlcmZhbGwoW1xuICAgICAgKGNiKSA9PiByZWplY3QoYmxvY2tzLCAoYiwgY2IpID0+IHtcbiAgICAgICAgdGhpcy5ibG9ja3N0b3JlLmhhcyhiLmNpZCwgY2IpXG4gICAgICB9LCBjYiksXG4gICAgICAobmV3QmxvY2tzLCBjYikgPT4gdGhpcy5ibG9ja3N0b3JlLnB1dE1hbnkobmV3QmxvY2tzLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgbmV3QmxvY2tzLmZvckVhY2goKGJsb2NrKSA9PiB7XG4gICAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zLmhhc0Jsb2NrKGJsb2NrKVxuICAgICAgICAgIHRoaXMuZW5naW5lLnJlY2VpdmVkQmxvY2tzKFtibG9jay5jaWRdKVxuICAgICAgICAgIHRoaXMubmV0d29yay5wcm92aWRlKGJsb2NrLmNpZCwgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IoJ0ZhaWxlZCB0byBwcm92aWRlOiAlcycsIGVyci5tZXNzYWdlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIGNiKClcbiAgICAgIH0pXG4gICAgXSwgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGxpc3Qgb2Ygd2FudHMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtJdGVyYXRvcjxXYW50bGlzdEVudHJ5Pn1cbiAgICovXG4gIGdldFdhbnRsaXN0ICgpIHtcbiAgICByZXR1cm4gdGhpcy53bS53YW50bGlzdC5lbnRyaWVzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgbGlzdCBvZiBwYXJ0bmVycy5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5PFBlZXJJZD59XG4gICAqL1xuICBwZWVycyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5naW5lLnBlZXJzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc3RhdHMgYWJvdXQgdGhlIGJpdHN3YXAgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHN0YXQgKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0c1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBiaXRzd2FwIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHN0YXJ0IChjYWxsYmFjaykge1xuICAgIHNlcmllcyhbXG4gICAgICAoY2IpID0+IHRoaXMud20uc3RhcnQoY2IpLFxuICAgICAgKGNiKSA9PiB0aGlzLm5ldHdvcmsuc3RhcnQoY2IpLFxuICAgICAgKGNiKSA9PiB0aGlzLmVuZ2luZS5zdGFydChjYilcbiAgICBdLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBiaXRzd2FwIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHN0b3AgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fc3RhdHMuc3RvcCgpXG4gICAgc2VyaWVzKFtcbiAgICAgIChjYikgPT4gdGhpcy53bS5zdG9wKGNiKSxcbiAgICAgIChjYikgPT4gdGhpcy5uZXR3b3JrLnN0b3AoY2IpLFxuICAgICAgKGNiKSA9PiB0aGlzLmVuZ2luZS5zdG9wKGNiKVxuICAgIF0sIGNhbGxiYWNrKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQml0c3dhcFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgS2V5IH0gPSByZXF1aXJlKCdpbnRlcmZhY2UtZGF0YXN0b3JlJylcbmNvbnN0IHsgUmVjb3JkIH0gPSByZXF1aXJlKCdsaWJwMnAtcmVjb3JkJylcbmNvbnN0IHsgZW5jb2RlQmFzZTMyIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcblxuY29uc3QgZXJyY29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2lwZnM6aXBuczpvZmZsaW5lLWRhdGFzdG9yZScpXG5sb2cuZXJyb3IgPSBkZWJ1ZygnaXBmczppcG5zOm9mZmxpbmUtZGF0YXN0b3JlOmVycm9yJylcblxuLy8gT2ZmbGluZSBkYXRhc3RvcmUgYWltcyB0byBtaW1pYyB0aGUgc2FtZSBlbmNvZGluZyBhcyByb3V0aW5nIHdoZW4gc3RvcmluZyByZWNvcmRzXG4vLyB0byB0aGUgbG9jYWwgZGF0YXN0b3JlXG5jbGFzcyBPZmZsaW5lRGF0YXN0b3JlIHtcbiAgY29uc3RydWN0b3IgKHJlcG8pIHtcbiAgICB0aGlzLl9yZXBvID0gcmVwb1xuICB9XG5cbiAgLyoqXG4gICAqIFB1dCBhIHZhbHVlIHRvIHRoZSBsb2NhbCBkYXRhc3RvcmUgaW5kZXhlZCBieSB0aGUgcmVjZWl2ZWQga2V5IHByb3Blcmx5IGVuY29kZWQuXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBrZXkgaWRlbnRpZmllciBvZiB0aGUgdmFsdWUuXG4gICAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZSB2YWx1ZSB0byBiZSBzdG9yZWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHB1dCAoa2V5LCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihrZXkpKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSBgT2ZmbGluZSBkYXRhc3RvcmUga2V5IG11c3QgYmUgYSBidWZmZXJgXG5cbiAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX0tFWScpKVxuICAgIH1cblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgY29uc3QgZXJyTXNnID0gYE9mZmxpbmUgZGF0YXN0b3JlIHZhbHVlIG11c3QgYmUgYSBidWZmZXJgXG5cbiAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX1ZBTFVFJykpXG4gICAgfVxuXG4gICAgbGV0IHJvdXRpbmdLZXlcblxuICAgIHRyeSB7XG4gICAgICByb3V0aW5nS2V5ID0gdGhpcy5fcm91dGluZ0tleShrZXkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSBgTm90IHBvc3NpYmxlIHRvIGdlbmVyYXRlIHRoZSByb3V0aW5nIGtleWBcblxuICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKG5ldyBFcnJvcihlcnJNc2cpLCAnRVJSX0dFTkVSQVRJTkdfUk9VVElOR19LRVknKSlcbiAgICB9XG5cbiAgICAvLyBNYXJzaGFsIHRvIGxpYnAycCByZWNvcmQgYXMgdGhlIERIVCBkb2VzXG4gICAgY29uc3QgcmVjb3JkID0gbmV3IFJlY29yZChrZXksIHZhbHVlKVxuXG4gICAgdGhpcy5fcmVwby5kYXRhc3RvcmUucHV0KHJvdXRpbmdLZXksIHJlY29yZC5zZXJpYWxpemUoKSwgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdmFsdWUgZnJvbSB0aGUgbG9jYWwgZGF0YXN0b3JlIGluZGV4ZWQgYnkgdGhlIHJlY2VpdmVkIGtleSBwcm9wZXJseSBlbmNvZGVkLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0ga2V5IGlkZW50aWZpZXIgb2YgdGhlIHZhbHVlIHRvIGJlIG9idGFpbmVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCdWZmZXIpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGdldCAoa2V5LCBjYWxsYmFjaykge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGtleSkpIHtcbiAgICAgIGNvbnN0IGVyck1zZyA9IGBPZmZsaW5lIGRhdGFzdG9yZSBrZXkgbXVzdCBiZSBhIGJ1ZmZlcmBcblxuICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKG5ldyBFcnJvcihlcnJNc2cpLCAnRVJSX0lOVkFMSURfS0VZJykpXG4gICAgfVxuXG4gICAgbGV0IHJvdXRpbmdLZXlcblxuICAgIHRyeSB7XG4gICAgICByb3V0aW5nS2V5ID0gdGhpcy5fcm91dGluZ0tleShrZXkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSBgTm90IHBvc3NpYmxlIHRvIGdlbmVyYXRlIHRoZSByb3V0aW5nIGtleWBcblxuICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKG5ldyBFcnJvcihlcnJNc2cpLCAnRVJSX0dFTkVSQVRJTkdfUk9VVElOR19LRVknKSlcbiAgICB9XG5cbiAgICB0aGlzLl9yZXBvLmRhdGFzdG9yZS5nZXQocm91dGluZ0tleSwgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIC8vIFVubWFyc2hhbCBsaWJwMnAgcmVjb3JkIGFzIHRoZSBESFQgZG9lc1xuICAgICAgbGV0IHJlY29yZFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVjb3JkID0gUmVjb3JkLmRlc2VyaWFsaXplKHJlcylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cuZXJyb3IoZXJyKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCByZWNvcmQudmFsdWUpXG4gICAgfSlcbiAgfVxuXG4gIC8vIGVuY29kZSBrZXkgcHJvcGVybHkgLSBiYXNlMzIoL2lwbnMve2NpZH0pXG4gIF9yb3V0aW5nS2V5IChrZXkpIHtcbiAgICByZXR1cm4gbmV3IEtleSgnLycgKyBlbmNvZGVCYXNlMzIoa2V5KSwgZmFsc2UpXG4gIH1cbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gT2ZmbGluZURhdGFzdG9yZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG11bHRpYmFzZSA9IHJlcXVpcmUoJ211bHRpYmFzZScpXG5jb25zdCBpcG5zID0gcmVxdWlyZSgnaXBucycpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNvZGVCYXNlMzI6IChidWYpID0+IHtcbiAgICBjb25zdCBtID0gbXVsdGliYXNlLmVuY29kZSgnYmFzZTMyJywgYnVmKS5zbGljZSgxKSAvLyBzbGljZSBvZmYgbXVsdGliYXNlIGNvZGVjXG5cbiAgICByZXR1cm4gbS50b1N0cmluZygpLnRvVXBwZXJDYXNlKCkgLy8gc2hvdWxkIGJlIHVwcGVyY2FzZSBmb3IgaW50ZXJvcCB3aXRoIGdvXG4gIH0sXG4gIHZhbGlkYXRvcjoge1xuICAgIGZ1bmM6IChrZXksIHJlY29yZCwgY2IpID0+IGlwbnMudmFsaWRhdG9yLnZhbGlkYXRlKHJlY29yZCwga2V5LCBjYilcbiAgfSxcbiAgc2VsZWN0b3I6IChrLCByZWNvcmRzKSA9PiBpcG5zLnZhbGlkYXRvci5zZWxlY3QocmVjb3Jkc1swXSwgcmVjb3Jkc1sxXSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBXUyA9IHJlcXVpcmUoJ2xpYnAycC13ZWJzb2NrZXRzJylcbmNvbnN0IFdlYlJUQ1N0YXIgPSByZXF1aXJlKCdsaWJwMnAtd2VicnRjLXN0YXInKVxuY29uc3QgV2ViU29ja2V0U3Rhck11bHRpID0gcmVxdWlyZSgnbGlicDJwLXdlYnNvY2tldC1zdGFyLW11bHRpJylcbmNvbnN0IE11bHRpcGxleCA9IHJlcXVpcmUoJ3B1bGwtbXBsZXgnKVxuY29uc3QgU0VDSU8gPSByZXF1aXJlKCdsaWJwMnAtc2VjaW8nKVxuY29uc3QgQm9vdHN0cmFwID0gcmVxdWlyZSgnbGlicDJwLWJvb3RzdHJhcCcpXG5jb25zdCBLYWRESFQgPSByZXF1aXJlKCdsaWJwMnAta2FkLWRodCcpXG5jb25zdCBsaWJwMnAgPSByZXF1aXJlKCdsaWJwMnAnKVxuY29uc3QgbWVyZ2VPcHRpb25zID0gcmVxdWlyZSgnbWVyZ2Utb3B0aW9ucycpXG5jb25zdCBtdWx0aWFkZHIgPSByZXF1aXJlKCdtdWx0aWFkZHInKVxuXG5jbGFzcyBOb2RlIGV4dGVuZHMgbGlicDJwIHtcbiAgY29uc3RydWN0b3IgKF9vcHRpb25zKSB7XG4gICAgY29uc3Qgd3J0Y3N0YXIgPSBuZXcgV2ViUlRDU3Rhcih7IGlkOiBfb3B0aW9ucy5wZWVySW5mby5pZCB9KVxuXG4gICAgLy8gdGhpcyBjYW4gYmUgcmVwbGFjZWQgb25jZSBvcHRpb25hbCBsaXN0ZW5pbmcgaXMgc3VwcG9ydGVkIHdpdGggdGhlIGJlbG93IGNvZGUuIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL2xpYnAycC9pbnRlcmZhY2UtdHJhbnNwb3J0L2lzc3Vlcy80MVxuICAgIC8vIGNvbnN0IHdzc3RhciA9IG5ldyBXZWJTb2NrZXRTdGFyKHsgaWQ6IF9vcHRpb25zLnBlZXJJbmZvLmlkIH0pXG4gICAgY29uc3Qgd3NzdGFyU2VydmVycyA9IF9vcHRpb25zLnBlZXJJbmZvLm11bHRpYWRkcnMudG9BcnJheSgpLm1hcChTdHJpbmcpLmZpbHRlcihhZGRyID0+IGFkZHIuaW5jbHVkZXMoJ3AycC13ZWJzb2NrZXQtc3RhcicpKVxuICAgIF9vcHRpb25zLnBlZXJJbmZvLm11bHRpYWRkcnMucmVwbGFjZSh3c3N0YXJTZXJ2ZXJzLm1hcChtdWx0aWFkZHIpLCAnL3AycC13ZWJzb2NrZXQtc3RhcicpIC8vIHRoZSB3cy1zdGFyLW11bHRpIG1vZHVsZSB3aWxsIHJlcGxhY2UgdGhpcyB3aXRoIHRoZSBjaG9zZW4gd3Mtc3RhciBzZXJ2ZXJzXG4gICAgY29uc3Qgd3NzdGFyID0gbmV3IFdlYlNvY2tldFN0YXJNdWx0aSh7IHNlcnZlcnM6IHdzc3RhclNlcnZlcnMsIGlkOiBfb3B0aW9ucy5wZWVySW5mby5pZCwgaWdub3JlX25vX29ubGluZTogIXdzc3RhclNlcnZlcnMubGVuZ3RoIHx8IF9vcHRpb25zLndzU3Rhcklnbm9yZUVycm9ycyB9KVxuXG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICBzd2l0Y2g6IHtcbiAgICAgICAgYmxhY2tsaXN0VFRMOiAyICogNjAgKiAxZTMsIC8vIDIgbWludXRlIGJhc2VcbiAgICAgICAgYmxhY2tMaXN0QXR0ZW1wdHM6IDUsIC8vIGJhY2sgb2ZmIDUgdGltZXNcbiAgICAgICAgbWF4UGFyYWxsZWxEaWFsczogMTAwLFxuICAgICAgICBtYXhDb2xkQ2FsbHM6IDI1LFxuICAgICAgICBkaWFsVGltZW91dDogMjBlM1xuICAgICAgfSxcbiAgICAgIG1vZHVsZXM6IHtcbiAgICAgICAgdHJhbnNwb3J0OiBbXG4gICAgICAgICAgV1MsXG4gICAgICAgICAgd3J0Y3N0YXIsXG4gICAgICAgICAgd3NzdGFyXG4gICAgICAgIF0sXG4gICAgICAgIHN0cmVhbU11eGVyOiBbXG4gICAgICAgICAgTXVsdGlwbGV4XG4gICAgICAgIF0sXG4gICAgICAgIGNvbm5FbmNyeXB0aW9uOiBbXG4gICAgICAgICAgU0VDSU9cbiAgICAgICAgXSxcbiAgICAgICAgcGVlckRpc2NvdmVyeTogW1xuICAgICAgICAgIHdydGNzdGFyLmRpc2NvdmVyeSxcbiAgICAgICAgICB3c3N0YXIuZGlzY292ZXJ5LFxuICAgICAgICAgIEJvb3RzdHJhcFxuICAgICAgICBdLFxuICAgICAgICBkaHQ6IEthZERIVFxuICAgICAgfSxcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBwZWVyRGlzY292ZXJ5OiB7XG4gICAgICAgICAgYXV0b0RpYWw6IHRydWUsXG4gICAgICAgICAgYm9vdHN0cmFwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3ZWJSVENTdGFyOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3ZWJzb2NrZXRTdGFyOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkaHQ6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBFWFBFUklNRU5UQUw6IHtcbiAgICAgICAgICBwdWJzdWI6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBlcihtZXJnZU9wdGlvbnMoZGVmYXVsdHMsIF9vcHRpb25zKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbGYgPT4gcmVxdWlyZSgnLi9hZGQnKShzZWxmKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCdpc28tdXJsJylcbmNvbnN0IGZldGNoID0gcmVxdWlyZSgnLi4vLi4vcnVudGltZS9mZXRjaC1ub2RlanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChzZWxmKSA9PiB7XG4gIHJldHVybiBhc3luYyAodXJsLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICBsZXQgZmlsZXNcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybClcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybClcblxuICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHN0YXR1cyBjb2RlOiAnICsgcmVzLnN0YXR1cylcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogdXNlIHJlcy5ib2R5IHdoZW4gc3VwcG9ydGVkXG4gICAgICBjb25zdCBjb250ZW50ID0gQnVmZmVyLmZyb20oYXdhaXQgcmVzLmFycmF5QnVmZmVyKCkpXG4gICAgICBjb25zdCBwYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnNlZFVybC5wYXRobmFtZS5zcGxpdCgnLycpLnBvcCgpKVxuXG4gICAgICBmaWxlcyA9IGF3YWl0IHNlbGYuYWRkKHsgY29udGVudCwgcGF0aCB9LCBvcHRpb25zKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGZpbGVzKVxuICAgIH1cblxuICAgIHJldHVybiBmaWxlc1xuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtJylcbmNvbnN0IHB1c2hhYmxlID0gcmVxdWlyZSgncHVsbC1wdXNoYWJsZScpXG5jb25zdCBEdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5EdXBsZXhcblxuY2xhc3MgQWRkSGVscGVyIGV4dGVuZHMgRHVwbGV4IHtcbiAgY29uc3RydWN0b3IgKHB1bGxTdHJlYW0sIHB1c2gsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHsgb2JqZWN0TW9kZTogdHJ1ZSB9LCBvcHRpb25zKSlcbiAgICB0aGlzLl9wdWxsU3RyZWFtID0gcHVsbFN0cmVhbVxuICAgIHRoaXMuX3B1c2hhYmxlID0gcHVzaFxuICAgIHRoaXMuX3dhaXRpbmdQdWxsRmx1c2ggPSBbXVxuICB9XG5cbiAgX3JlYWQgKCkge1xuICAgIHRoaXMuX3B1bGxTdHJlYW0obnVsbCwgKGVuZCwgZGF0YSkgPT4ge1xuICAgICAgd2hpbGUgKHRoaXMuX3dhaXRpbmdQdWxsRmx1c2gubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNiID0gdGhpcy5fd2FpdGluZ1B1bGxGbHVzaC5zaGlmdCgpXG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgaWYgKGVuZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVuZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnB1c2gobnVsbClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoKGRhdGEpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIF93cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3dhaXRpbmdQdWxsRmx1c2gucHVzaChjYWxsYmFjaylcbiAgICB0aGlzLl9wdXNoYWJsZS5wdXNoKGNodW5rKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgcmV0dXJuIChvcHRpb25zKSA9PiB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgIGNvbnN0IHAgPSBwdXNoYWJsZSgpXG4gICAgY29uc3QgcyA9IHB1bGwoXG4gICAgICBwLFxuICAgICAgc2VsZi5hZGRQdWxsU3RyZWFtKG9wdGlvbnMpXG4gICAgKVxuXG4gICAgY29uc3QgcmV0U3RyZWFtID0gbmV3IEFkZEhlbHBlcihzLCBwKVxuXG4gICAgcmV0U3RyZWFtLm9uY2UoJ2ZpbmlzaCcsICgpID0+IHAuZW5kKCkpXG5cbiAgICByZXR1cm4gcmV0U3RyZWFtXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwcm9taXNpZnkgPSByZXF1aXJlKCdwcm9taXNpZnktZXM2JylcbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgcmV0dXJuIHByb21pc2lmeSgoaXBmc1BhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cblxuICAgIHB1bGwoXG4gICAgICBzZWxmLmNhdFB1bGxTdHJlYW0oaXBmc1BhdGgsIG9wdGlvbnMpLFxuICAgICAgcHVsbC5jb2xsZWN0KChlcnIsIGJ1ZmZlcnMpID0+IHtcbiAgICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKSB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIEJ1ZmZlci5jb25jYXQoYnVmZmVycykpXG4gICAgICB9KVxuICAgIClcbiAgfSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB0b1N0cmVhbSA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtLXRvLXN0cmVhbScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgcmV0dXJuIChpcGZzUGF0aCwgb3B0aW9ucykgPT4gdG9TdHJlYW0uc291cmNlKHNlbGYuY2F0UHVsbFN0cmVhbShpcGZzUGF0aCwgb3B0aW9ucykpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgncHJvbWlzaWZ5LWVzNicpXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gIHJldHVybiBwcm9taXNpZnkoKGlwZnNQYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgcHVsbChcbiAgICAgIHNlbGYuZ2V0UHVsbFN0cmVhbShpcGZzUGF0aCwgb3B0aW9ucyksXG4gICAgICBwdWxsLmFzeW5jTWFwKChmaWxlLCBjYikgPT4ge1xuICAgICAgICBpZiAoZmlsZS5jb250ZW50KSB7XG4gICAgICAgICAgcHVsbChcbiAgICAgICAgICAgIGZpbGUuY29udGVudCxcbiAgICAgICAgICAgIHB1bGwuY29sbGVjdCgoZXJyLCBidWZmZXJzKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNiKGVycikgfVxuICAgICAgICAgICAgICBmaWxlLmNvbnRlbnQgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpXG4gICAgICAgICAgICAgIGNiKG51bGwsIGZpbGUpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYihudWxsLCBmaWxlKVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHB1bGwuY29sbGVjdChjYWxsYmFjaylcbiAgICApXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtJylcbmNvbnN0IHRvU3RyZWFtID0gcmVxdWlyZSgncHVsbC1zdHJlYW0tdG8tc3RyZWFtJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VsZikge1xuICByZXR1cm4gKGlwZnNQYXRoLCBvcHRpb25zKSA9PiB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgIHJldHVybiB0b1N0cmVhbS5zb3VyY2UoXG4gICAgICBwdWxsKFxuICAgICAgICBzZWxmLmdldFB1bGxTdHJlYW0oaXBmc1BhdGgsIG9wdGlvbnMpLFxuICAgICAgICBwdWxsLm1hcCgoZmlsZSkgPT4ge1xuICAgICAgICAgIGlmIChmaWxlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGZpbGUuY29udGVudCA9IHRvU3RyZWFtLnNvdXJjZShmaWxlLmNvbnRlbnQpXG4gICAgICAgICAgICBmaWxlLmNvbnRlbnQucGF1c2UoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmaWxlXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgncHJvbWlzaWZ5LWVzNicpXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gIHJldHVybiBwcm9taXNpZnkoKGlwZnNQYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgcHVsbChcbiAgICAgIHNlbGYubHNQdWxsU3RyZWFtKGlwZnNQYXRoLCBvcHRpb25zKSxcbiAgICAgIHB1bGwuY29sbGVjdCgoZXJyLCB2YWx1ZXMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdmFsdWVzKVxuICAgICAgfSlcbiAgICApXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdG9TdHJlYW0gPSByZXF1aXJlKCdwdWxsLXN0cmVhbS10by1zdHJlYW0nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gIHJldHVybiAoaXBmc1BhdGgsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gdG9TdHJlYW0uc291cmNlKHNlbGYubHNQdWxsU3RyZWFtKGlwZnNQYXRoLCBvcHRpb25zKSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VsZikge1xuICByZXR1cm4gcHJvbWlzaWZ5KChpcGZzUGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgIHB1bGwoXG4gICAgICBzZWxmLnJlZnNQdWxsU3RyZWFtKGlwZnNQYXRoLCBvcHRpb25zKSxcbiAgICAgIHB1bGwuY29sbGVjdCgoZXJyLCB2YWx1ZXMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdmFsdWVzKVxuICAgICAgfSlcbiAgICApXG4gIH0pXG59XG5cbi8vIFByZXNldCBmb3JtYXQgc3RyaW5nc1xubW9kdWxlLmV4cG9ydHMuRm9ybWF0ID0ge1xuICBkZWZhdWx0OiAnPGRzdD4nLFxuICBlZGdlczogJzxzcmM+IC0+IDxkc3Q+J1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHRvU3RyZWFtID0gcmVxdWlyZSgncHVsbC1zdHJlYW0tdG8tc3RyZWFtJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VsZikge1xuICByZXR1cm4gKGlwZnNQYXRoLCBvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIHRvU3RyZWFtLnNvdXJjZShzZWxmLnJlZnNQdWxsU3RyZWFtKGlwZnNQYXRoLCBvcHRpb25zKSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VsZikge1xuICByZXR1cm4gcHJvbWlzaWZ5KChjYWxsYmFjaykgPT4ge1xuICAgIHB1bGwoXG4gICAgICBzZWxmLnJlZnMubG9jYWxQdWxsU3RyZWFtKCksXG4gICAgICBwdWxsLmNvbGxlY3QoKGVyciwgdmFsdWVzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHZhbHVlcylcbiAgICAgIH0pXG4gICAgKVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHRvU3RyZWFtID0gcmVxdWlyZSgncHVsbC1zdHJlYW0tdG8tc3RyZWFtJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VsZikge1xuICByZXR1cm4gKGlwZnNQYXRoLCBvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIHRvU3RyZWFtLnNvdXJjZShzZWxmLnJlZnMubG9jYWxQdWxsU3RyZWFtKCkpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IGJhc2UzMiA9IHJlcXVpcmUoJ2Jhc2UzMi5qcycpXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0nKVxuY29uc3QgcHVsbERlZmVyID0gcmVxdWlyZSgncHVsbC1kZWZlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IHB1bGxEZWZlci5zb3VyY2UoKVxuXG4gICAgc2VsZi5fcmVwby5ibG9ja3MucXVlcnkoeyBrZXlzT25seTogdHJ1ZSB9LCAoZXJyLCBibG9ja3MpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlc29sdmUocHVsbC5lcnJvcihlcnIpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZWZzID0gYmxvY2tzLm1hcChiID0+IGRzS2V5VG9SZWYoYi5rZXkpKVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZShwdWxsLnZhbHVlcyhyZWZzKSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIGRlZmVycmVkXG4gIH1cbn1cblxuZnVuY3Rpb24gZHNLZXlUb1JlZiAoa2V5KSB7XG4gIHRyeSB7XG4gICAgLy8gQmxvY2sga2V5IGlzIG9mIHRoZSBmb3JtIC88YmFzZTMyIGVuY29kZWQgc3RyaW5nPlxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgYmFzZTMyLkRlY29kZXIoKVxuICAgIGNvbnN0IGJ1ZmYgPSBCdWZmZXIuZnJvbShkZWNvZGVyLndyaXRlKGtleS50b1N0cmluZygpLnNsaWNlKDEpKS5maW5hbGl6ZSgpKVxuICAgIHJldHVybiB7IHJlZjogbmV3IENJRChidWZmKS50b1N0cmluZygpIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHsgZXJyOiBgQ291bGQgbm90IGNvbnZlcnQgYmxvY2sgd2l0aCBrZXkgJyR7a2V5fScgdG8gQ0lEOiAke2Vyci5tZXNzYWdlfWAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtJylcbmNvbnN0IHB1bGxEZWZlciA9IHJlcXVpcmUoJ3B1bGwtZGVmZXInKVxuY29uc3QgcHVsbFRyYXZlcnNlID0gcmVxdWlyZSgncHVsbC10cmF2ZXJzZScpXG5jb25zdCBwdWxsQ2F0ID0gcmVxdWlyZSgncHVsbC1jYXQnKVxuY29uc3QgaXNJcGZzID0gcmVxdWlyZSgnaXMtaXBmcycpXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IHsgREFHTm9kZSB9ID0gcmVxdWlyZSgnaXBsZC1kYWctcGInKVxuY29uc3QgeyBub3JtYWxpemVQYXRoIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IHsgRm9ybWF0IH0gPSByZXF1aXJlKCcuL3JlZnMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXBmc1BhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChvcHRpb25zLm1heERlcHRoID09PSAwKSB7XG4gICAgICByZXR1cm4gcHVsbC5lbXB0eSgpXG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVkZ2VzICYmIG9wdGlvbnMuZm9ybWF0ICYmIG9wdGlvbnMuZm9ybWF0ICE9PSBGb3JtYXQuZGVmYXVsdCkge1xuICAgICAgcmV0dXJuIHB1bGwuZXJyb3IobmV3IEVycm9yKCdDYW5ub3Qgc2V0IGVkZ2VzIHRvIHRydWUgYW5kIGFsc28gc3BlY2lmeSBmb3JtYXQnKSlcbiAgICB9XG5cbiAgICBvcHRpb25zLmZvcm1hdCA9IG9wdGlvbnMuZWRnZXMgPyBGb3JtYXQuZWRnZXMgOiBvcHRpb25zLmZvcm1hdCB8fCBGb3JtYXQuZGVmYXVsdFxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLm1heERlcHRoICE9PSAnbnVtYmVyJykge1xuICAgICAgb3B0aW9ucy5tYXhEZXB0aCA9IG9wdGlvbnMucmVjdXJzaXZlID8gSW5maW5pdHkgOiAxXG4gICAgfVxuXG4gICAgbGV0IHBhdGhzXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhd1BhdGhzID0gQXJyYXkuaXNBcnJheShpcGZzUGF0aCkgPyBpcGZzUGF0aCA6IFtpcGZzUGF0aF1cbiAgICAgIHBhdGhzID0gcmF3UGF0aHMubWFwKHAgPT4gZ2V0RnVsbFBhdGgoc2VsZiwgcCwgb3B0aW9ucykpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gcHVsbC5lcnJvcihlcnIpXG4gICAgfVxuXG4gICAgcmV0dXJuIHB1bGxDYXQocGF0aHMubWFwKHAgPT4gcmVmc1N0cmVhbShzZWxmLCBwLCBvcHRpb25zKSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RnVsbFBhdGggKGlwZnMsIGlwZnNQYXRoLCBvcHRpb25zKSB7XG4gIC8vIG5vcm1hbGl6ZVBhdGgoKSBzdHJpcHMgL2lwZnMvIG9mZiB0aGUgZnJvbnQgb2YgdGhlIHBhdGggc28gdGhlIENJRCB3aWxsXG4gIC8vIGJlIGF0IHRoZSBmcm9udCBvZiB0aGUgcGF0aFxuICBjb25zdCBwYXRoID0gbm9ybWFsaXplUGF0aChpcGZzUGF0aClcbiAgY29uc3QgcGF0aENvbXBvbmVudHMgPSBwYXRoLnNwbGl0KCcvJylcbiAgY29uc3QgY2lkID0gcGF0aENvbXBvbmVudHNbMF1cbiAgaWYgKCFpc0lwZnMuY2lkKGNpZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHJlc29sdmluZyBwYXRoICcke3BhdGh9JzogJyR7Y2lkfScgaXMgbm90IGEgdmFsaWQgQ0lEYClcbiAgfVxuXG4gIGlmIChvcHRpb25zLnByZWxvYWQgIT09IGZhbHNlKSB7XG4gICAgaXBmcy5fcHJlbG9hZChjaWQpXG4gIH1cblxuICByZXR1cm4gJy9pcGZzLycgKyBwYXRoXG59XG5cbi8vIEdldCBhIHN0cmVhbSBvZiByZWZzIGF0IHRoZSBnaXZlbiBwYXRoXG5mdW5jdGlvbiByZWZzU3RyZWFtIChpcGZzLCBwYXRoLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmVycmVkID0gcHVsbERlZmVyLnNvdXJjZSgpXG5cbiAgLy8gUmVzb2x2ZSB0byB0aGUgdGFyZ2V0IENJRCBvZiB0aGUgcGF0aFxuICBpcGZzLnJlc29sdmUocGF0aCwgKGVyciwgcmVzUGF0aCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBkZWZlcnJlZC5yZXNvbHZlKHB1bGwuZXJyb3IoZXJyKSlcbiAgICB9XG5cbiAgICAvLyBwYXRoIGlzIC9pcGZzLzxjaWQ+XG4gICAgY29uc3QgcGFydHMgPSByZXNQYXRoLnNwbGl0KCcvJylcbiAgICBjb25zdCBjaWQgPSBwYXJ0c1syXVxuICAgIGRlZmVycmVkLnJlc29sdmUocHVsbChcbiAgICAgIC8vIFRyYXZlcnNlIHRoZSBEQUcsIGNvbnZlcnRpbmcgaXQgaW50byBhIHN0cmVhbVxuICAgICAgb2JqZWN0U3RyZWFtKGlwZnMsIGNpZCwgb3B0aW9ucy5tYXhEZXB0aCwgb3B0aW9ucy51bmlxdWUpLFxuICAgICAgLy8gUm9vdCBvYmplY3Qgd2lsbCBub3QgaGF2ZSBhIHBhcmVudFxuICAgICAgcHVsbC5maWx0ZXIob2JqID0+IEJvb2xlYW4ob2JqLnBhcmVudCkpLFxuICAgICAgLy8gRmlsdGVyIG91dCBkdXBsaWNhdGVzIChpc0R1cGxpY2F0ZSBmbGFnIGlzIG9ubHkgc2V0IGlmIG9wdGlvbnMudW5pcXVlIGlzIHNldClcbiAgICAgIHB1bGwuZmlsdGVyKG9iaiA9PiAhb2JqLmlzRHVwbGljYXRlKSxcbiAgICAgIC8vIEZvcm1hdCB0aGUgbGlua3NcbiAgICAgIHB1bGwubWFwKG9iaiA9PiBmb3JtYXRMaW5rKG9iai5wYXJlbnQuY2lkLCBvYmoubm9kZS5jaWQsIG9iai5ub2RlLm5hbWUsIG9wdGlvbnMuZm9ybWF0KSksXG4gICAgICAvLyBDbGllbnRzIGV4cGVjdCByZWZzIHRvIGJlIGluIHRoZSBmb3JtYXQgeyByZWY6IDxyZWY+IH1cbiAgICAgIHB1bGwubWFwKHJlZiA9PiAoeyByZWYgfSkpXG4gICAgKSlcbiAgfSlcblxuICByZXR1cm4gZGVmZXJyZWRcbn1cblxuLy8gR2V0IGZvcm1hdHRlZCBsaW5rXG5mdW5jdGlvbiBmb3JtYXRMaW5rIChzcmNDaWQsIGRzdENpZCwgbGlua05hbWUsIGZvcm1hdCkge1xuICBsZXQgb3V0ID0gZm9ybWF0LnJlcGxhY2UoLzxzcmM+L2csIHNyY0NpZC50b1N0cmluZygpKVxuICBvdXQgPSBvdXQucmVwbGFjZSgvPGRzdD4vZywgZHN0Q2lkLnRvU3RyaW5nKCkpXG4gIG91dCA9IG91dC5yZXBsYWNlKC88bGlua25hbWU+L2csIGxpbmtOYW1lKVxuICByZXR1cm4gb3V0XG59XG5cbi8vIERvIGEgZGVwdGggZmlyc3Qgc2VhcmNoIG9mIHRoZSBEQUcsIHN0YXJ0aW5nIGZyb20gdGhlIGdpdmVuIHJvb3QgY2lkXG5mdW5jdGlvbiBvYmplY3RTdHJlYW0gKGlwZnMsIHJvb3RDaWQsIG1heERlcHRoLCBpc1VuaXF1ZSkge1xuICBjb25zdCB1bmlxdWVzID0gbmV3IFNldCgpXG5cbiAgY29uc3Qgcm9vdCA9IHsgbm9kZTogeyBjaWQ6IHJvb3RDaWQgfSwgZGVwdGg6IDAgfVxuICBjb25zdCB0cmF2ZXJzZUxldmVsID0gKG9iaikgPT4ge1xuICAgIGNvbnN0IHsgbm9kZSwgZGVwdGggfSA9IG9ialxuXG4gICAgLy8gQ2hlY2sgdGhlIGRlcHRoXG4gICAgY29uc3QgbmV4dExldmVsRGVwdGggPSBkZXB0aCArIDFcbiAgICBpZiAobmV4dExldmVsRGVwdGggPiBtYXhEZXB0aCkge1xuICAgICAgcmV0dXJuIHB1bGwuZW1wdHkoKVxuICAgIH1cblxuICAgIC8vIElmIHVuaXF1ZSBvcHRpb24gaXMgZW5hYmxlZCwgY2hlY2sgaWYgdGhlIENJRCBoYXMgYmVlbiBzZWVuIGJlZm9yZS5cbiAgICAvLyBOb3RlIHdlIG5lZWQgdG8gZG8gdGhpcyBoZXJlIHJhdGhlciB0aGFuIGJlZm9yZSBhZGRpbmcgdG8gdGhlIHN0cmVhbVxuICAgIC8vIHNvIHRoYXQgdGhlIHVuaXF1ZSBjaGVjayBoYXBwZW5zIGluIHRoZSBvcmRlciB0aGF0IGl0ZW1zIGFyZSBleGFtaW5lZFxuICAgIC8vIGluIHRoZSBEQUcuXG4gICAgaWYgKGlzVW5pcXVlKSB7XG4gICAgICBpZiAodW5pcXVlcy5oYXMobm9kZS5jaWQudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgLy8gTWFyayB0aGlzIG9iamVjdCBhcyBhIGR1cGxpY2F0ZSBzbyB3ZSBjYW4gZmlsdGVyIGl0IG91dCBsYXRlclxuICAgICAgICBvYmouaXNEdXBsaWNhdGUgPSB0cnVlXG4gICAgICAgIHJldHVybiBwdWxsLmVtcHR5KClcbiAgICAgIH1cbiAgICAgIHVuaXF1ZXMuYWRkKG5vZGUuY2lkLnRvU3RyaW5nKCkpXG4gICAgfVxuXG4gICAgY29uc3QgZGVmZXJyZWQgPSBwdWxsRGVmZXIuc291cmNlKClcblxuICAgIC8vIEdldCB0aGlzIG9iamVjdCdzIGxpbmtzXG4gICAgZ2V0TGlua3MoaXBmcywgbm9kZS5jaWQsIChlcnIsIGxpbmtzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgQ291bGQgbm90IGZpbmQgb2JqZWN0IHdpdGggQ0lEOiAke25vZGUuY2lkfWBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVzb2x2ZShwdWxsLmVycm9yKGVycikpXG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0byB0aGUgc3RyZWFtIGVhY2ggbGluaywgcGFyZW50IGFuZCB0aGUgbmV3IGRlcHRoXG4gICAgICBjb25zdCB2YWxzID0gbGlua3MubWFwKGxpbmsgPT4gKHtcbiAgICAgICAgcGFyZW50OiBub2RlLFxuICAgICAgICBub2RlOiBsaW5rLFxuICAgICAgICBkZXB0aDogbmV4dExldmVsRGVwdGhcbiAgICAgIH0pKVxuXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHB1bGwudmFsdWVzKHZhbHMpKVxuICAgIH0pXG5cbiAgICByZXR1cm4gZGVmZXJyZWRcbiAgfVxuXG4gIHJldHVybiBwdWxsVHJhdmVyc2UuZGVwdGhGaXJzdChyb290LCB0cmF2ZXJzZUxldmVsKVxufVxuXG4vLyBGZXRjaCBhIG5vZGUgZnJvbSBJUExEIHRoZW4gZ2V0IGFsbCBpdHMgbGlua3NcbmZ1bmN0aW9uIGdldExpbmtzIChpcGZzLCBjaWQsIGNhbGxiYWNrKSB7XG4gIGlwZnMuX2lwbGQuZ2V0KG5ldyBDSUQoY2lkKSlcbiAgICAudGhlbihub2RlID0+IHtcbiAgICAgIGxldCBsaW5rc1xuICAgICAgaWYgKERBR05vZGUuaXNEQUdOb2RlKG5vZGUpKSB7XG4gICAgICAgIGxpbmtzID0gbm9kZS5MaW5rcy5tYXAoKHsgTmFtZSwgSGFzaCB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHsgbmFtZTogTmFtZSwgY2lkOiBuZXcgQ0lEKEhhc2gpIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmtzID0gZ2V0Tm9kZUxpbmtzKG5vZGUpXG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBsaW5rcylcbiAgICB9KVxuICAgIC5jYXRjaChjYWxsYmFjaylcbn1cblxuLy8gUmVjdXJzaXZlbHkgc2VhcmNoIHRoZSBub2RlIGZvciBDSURzXG5mdW5jdGlvbiBnZXROb2RlTGlua3MgKG5vZGUsIHBhdGggPSAnJykge1xuICBsZXQgbGlua3MgPSBbXVxuICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZSkpIHtcbiAgICBpZiAoQ0lELmlzQ0lEKHZhbHVlKSkge1xuICAgICAgbGlua3MucHVzaCh7XG4gICAgICAgIG5hbWU6IHBhdGggKyBuYW1lLFxuICAgICAgICBjaWQ6IHZhbHVlXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgbGlua3MgPSBsaW5rcy5jb25jYXQoZ2V0Tm9kZUxpbmtzKHZhbHVlLCBwYXRoICsgbmFtZSArICcvJykpXG4gICAgfVxuICB9XG4gIHJldHVybiBsaW5rc1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gKHNlbGYpID0+IHJlcXVpcmUoJy4uLy4uL3J1bnRpbWUvYWRkLWZyb20tZnMtbm9kZWpzJykoc2VsZilcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBleHBvcnRlciA9IHJlcXVpcmUoJ2lwZnMtdW5peGZzLWV4cG9ydGVyJylcbmNvbnN0IHRvUHVsbFN0cmVhbSA9IHJlcXVpcmUoJ2FzeW5jLWl0ZXJhdG9yLXRvLXB1bGwtc3RyZWFtJylcbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vcHVsbCcpXG5jb25zdCBtYXAgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS90aHJvdWdocy9tYXAnKVxuY29uc3QgeyBub3JtYWxpemVQYXRoLCBtYXBGaWxlIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VsZikge1xuICByZXR1cm4gKGlwZnNQYXRoLCBvcHRpb25zKSA9PiB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgIGlmIChvcHRpb25zLnByZWxvYWQgIT09IGZhbHNlKSB7XG4gICAgICBsZXQgcGF0aENvbXBvbmVudHNcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aENvbXBvbmVudHMgPSBub3JtYWxpemVQYXRoKGlwZnNQYXRoKS5zcGxpdCgnLycpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHB1bGwuZXJyb3IoZXJyQ29kZShlcnIsICdFUlJfSU5WQUxJRF9QQVRIJykpXG4gICAgICB9XG5cbiAgICAgIHNlbGYuX3ByZWxvYWQocGF0aENvbXBvbmVudHNbMF0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHB1bGwoXG4gICAgICB0b1B1bGxTdHJlYW0uc291cmNlKGV4cG9ydGVyLnJlY3Vyc2l2ZShpcGZzUGF0aCwgc2VsZi5faXBsZCwgb3B0aW9ucykpLFxuICAgICAgbWFwKG1hcEZpbGUoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBpbmNsdWRlQ29udGVudDogdHJ1ZVxuICAgICAgfSkpXG4gICAgKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZXhwb3J0ZXIgPSByZXF1aXJlKCdpcGZzLXVuaXhmcy1leHBvcnRlcicpXG5jb25zdCBkZWZlcnJlZCA9IHJlcXVpcmUoJ3B1bGwtZGVmZXInKVxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3B1bGwnKVxuY29uc3Qgb25jZSA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3NvdXJjZXMvb25jZScpXG5jb25zdCBtYXAgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS90aHJvdWdocy9tYXAnKVxuY29uc3QgZmlsdGVyID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vdGhyb3VnaHMvZmlsdGVyJylcbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCB0b1B1bGxTdHJlYW0gPSByZXF1aXJlKCdhc3luYy1pdGVyYXRvci10by1wdWxsLXN0cmVhbScpXG5jb25zdCB7IG5vcm1hbGl6ZVBhdGgsIG1hcEZpbGUgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXBmc1BhdGgsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgY29uc3QgcGF0aCA9IG5vcm1hbGl6ZVBhdGgoaXBmc1BhdGgpXG4gICAgY29uc3QgcmVjdXJzaXZlID0gb3B0aW9ucy5yZWN1cnNpdmVcbiAgICBjb25zdCBwYXRoQ29tcG9uZW50cyA9IHBhdGguc3BsaXQoJy8nKVxuXG4gICAgaWYgKG9wdGlvbnMucHJlbG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgIHNlbGYuX3ByZWxvYWQocGF0aENvbXBvbmVudHNbMF0pXG4gICAgfVxuXG4gICAgY29uc3QgZCA9IGRlZmVycmVkLnNvdXJjZSgpXG5cbiAgICBleHBvcnRlcihpcGZzUGF0aCwgc2VsZi5faXBsZCwgb3B0aW9ucylcbiAgICAgIC50aGVuKGZpbGUgPT4ge1xuICAgICAgICBpZiAoIWZpbGUudW5peGZzKSB7XG4gICAgICAgICAgcmV0dXJuIGQuYWJvcnQoZXJyQ29kZShuZXcgRXJyb3IoJ2RhZyBub2RlIHdhcyBub3QgYSBVbml4RlMgbm9kZScpLCAnRU5PVFVOSVhGUycpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbGUudW5peGZzLnR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICAgIHJldHVybiBkLnJlc29sdmUob25jZShtYXBGaWxlKG9wdGlvbnMpKGZpbGUpKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxlLnVuaXhmcy50eXBlLmluY2x1ZGVzKCdkaXInKSkge1xuICAgICAgICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBkLnJlc29sdmUocHVsbChcbiAgICAgICAgICAgICAgdG9QdWxsU3RyZWFtLnNvdXJjZShleHBvcnRlci5yZWN1cnNpdmUoZmlsZS5jaWQsIHNlbGYuX2lwbGQsIG9wdGlvbnMpKSxcbiAgICAgICAgICAgICAgZmlsdGVyKGNoaWxkID0+IGZpbGUuY2lkLnRvQmFzZUVuY29kZWRTdHJpbmcoKSAhPT0gY2hpbGQuY2lkLnRvQmFzZUVuY29kZWRTdHJpbmcoKSksXG4gICAgICAgICAgICAgIG1hcChtYXBGaWxlKG9wdGlvbnMpKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZC5yZXNvbHZlKHB1bGwoXG4gICAgICAgICAgICB0b1B1bGxTdHJlYW0uc291cmNlKGZpbGUuY29udGVudCgpKSxcbiAgICAgICAgICAgIG1hcChtYXBGaWxlKG9wdGlvbnMpKSxcbiAgICAgICAgICAgIG1hcCgoZmlsZSkgPT4ge1xuICAgICAgICAgICAgICBmaWxlLmRlcHRoLS1cblxuICAgICAgICAgICAgICByZXR1cm4gZmlsZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApKVxuICAgICAgICB9XG5cbiAgICAgICAgZC5hYm9ydChlcnJDb2RlKG5ldyBFcnJvcihgVW5rbm93biBVbml4RlMgdHlwZSAke2ZpbGUudW5peGZzLnR5cGV9YCksICdFVU5LTk9XTlVOSVhGU1RZUEUnKSlcbiAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgIGQuYWJvcnQoZXJyKVxuICAgICAgfSlcblxuICAgIHJldHVybiBkXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwcm9taXNpZnkgPSByZXF1aXJlKCdwcm9taXNpZnktZXM2JylcbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbScpXG5jb25zdCBzb3J0ID0gcmVxdWlyZSgncHVsbC1zb3J0JylcbmNvbnN0IGlzU291cmNlID0gcmVxdWlyZSgnaXMtcHVsbC1zdHJlYW0nKS5pc1NvdXJjZVxuY29uc3QgdmFsaWRhdGVBZGRJbnB1dCA9IHJlcXVpcmUoJ2lwZnMtdXRpbHMvc3JjL2ZpbGVzL2FkZC1pbnB1dC12YWxpZGF0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VsZikge1xuICBjb25zdCBhZGQgPSBwcm9taXNpZnkoKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICB0cnkge1xuICAgICAgdmFsaWRhdGVBZGRJbnB1dChkYXRhKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG5cbiAgICBwdWxsKFxuICAgICAgcHVsbC52YWx1ZXMoW2RhdGFdKSxcbiAgICAgIHNlbGYuYWRkUHVsbFN0cmVhbShvcHRpb25zKSxcbiAgICAgIHNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKGEucGF0aCA8IGIucGF0aCkgcmV0dXJuIDFcbiAgICAgICAgaWYgKGEucGF0aCA+IGIucGF0aCkgcmV0dXJuIC0xXG4gICAgICAgIHJldHVybiAwXG4gICAgICB9KSxcbiAgICAgIHB1bGwuY29sbGVjdChjYWxsYmFjaylcbiAgICApXG4gIH0pXG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpXG5cbiAgICAvLyBJZiB3ZSAuYWRkKDxwdWxsIHN0cmVhbT4pLCB0aGVuIHByb21pc2lmeSB0aGlua3MgdGhlIHB1bGwgc3RyZWFtXG4gICAgLy8gaXMgYSBjYWxsYmFjayEgQWRkIGFuIGVtcHR5IG9wdGlvbnMgb2JqZWN0IGluIHRoaXMgY2FzZSBzbyB0aGF0IGFcbiAgICAvLyBwcm9taXNlIGlzIHJldHVybmVkLlxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBpc1NvdXJjZShhcmdzWzBdKSkge1xuICAgICAgYXJncy5wdXNoKHt9KVxuICAgIH1cblxuICAgIHJldHVybiBhZGQuYXBwbHkobnVsbCwgYXJncylcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGV4cG9ydGVyID0gcmVxdWlyZSgnaXBmcy11bml4ZnMtZXhwb3J0ZXInKVxuY29uc3QgZGVmZXJyZWQgPSByZXF1aXJlKCdwdWxsLWRlZmVyJylcbmNvbnN0IHRvUHVsbFN0cmVhbSA9IHJlcXVpcmUoJ2FzeW5jLWl0ZXJhdG9yLXRvLXB1bGwtc3RyZWFtJylcbmNvbnN0IHsgbm9ybWFsaXplUGF0aCB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNhdFB1bGxTdHJlYW0gKGlwZnNQYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBpcGZzUGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzdXBwbHkgYW4gaXBmc1BhdGgnKVxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICBpcGZzUGF0aCA9IG5vcm1hbGl6ZVBhdGgoaXBmc1BhdGgpXG4gICAgY29uc3QgcGF0aENvbXBvbmVudHMgPSBpcGZzUGF0aC5zcGxpdCgnLycpXG5cbiAgICBpZiAob3B0aW9ucy5wcmVsb2FkICE9PSBmYWxzZSkge1xuICAgICAgc2VsZi5fcHJlbG9hZChwYXRoQ29tcG9uZW50c1swXSlcbiAgICB9XG5cbiAgICBjb25zdCBkID0gZGVmZXJyZWQuc291cmNlKClcblxuICAgIGV4cG9ydGVyKGlwZnNQYXRoLCBzZWxmLl9pcGxkLCBvcHRpb25zKVxuICAgICAgLnRoZW4oZmlsZSA9PiB7XG4gICAgICAgIC8vIEZpbGUgbWF5IG5vdCBoYXZlIHVuaXhmcyBwcm9wIGlmIHNtYWxsICYgaW1wb3J0ZWQgd2l0aCByYXdMZWF2ZXMgdHJ1ZVxuICAgICAgICBpZiAoZmlsZS51bml4ZnMgJiYgZmlsZS51bml4ZnMudHlwZS5pbmNsdWRlcygnZGlyJykpIHtcbiAgICAgICAgICByZXR1cm4gZC5hYm9ydChuZXcgRXJyb3IoJ3RoaXMgZGFnIG5vZGUgaXMgYSBkaXJlY3RvcnknKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmlsZS5jb250ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGQuYWJvcnQobmV3IEVycm9yKCd0aGlzIGRhZyBub2RlIGhhcyBubyBjb250ZW50JykpXG4gICAgICAgIH1cblxuICAgICAgICBkLnJlc29sdmUodG9QdWxsU3RyZWFtLnNvdXJjZShmaWxlLmNvbnRlbnQob3B0aW9ucykpKVxuICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgZC5hYm9ydChlcnIpXG4gICAgICB9KVxuXG4gICAgcmV0dXJuIGRcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGltcG9ydGVyID0gcmVxdWlyZSgnaXBmcy11bml4ZnMtaW1wb3J0ZXInKVxuY29uc3Qga2luZE9mID0gcmVxdWlyZSgna2luZC1vZicpXG5jb25zdCB0b0FzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS10by1hc3luYy1pdGVyYXRvcicpXG5jb25zdCB0b1B1bGxTdHJlYW0gPSByZXF1aXJlKCdhc3luYy1pdGVyYXRvci10by1wdWxsLXN0cmVhbScpXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vcHVsbCcpXG5jb25zdCBwdWxsVmFsdWVzID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vc291cmNlcy92YWx1ZXMnKVxuY29uc3QgcHVsbE1hcCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3Rocm91Z2hzL21hcCcpXG5jb25zdCBwdWxsQXN5bmNNYXAgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS90aHJvdWdocy9hc3luYy1tYXAnKVxuY29uc3QgcHVsbEZsYXR0ZW4gPSByZXF1aXJlKCdwdWxsLXN0cmVhbS90aHJvdWdocy9mbGF0dGVuJylcbmNvbnN0IHRvUHVsbCA9IHJlcXVpcmUoJ3N0cmVhbS10by1wdWxsLXN0cmVhbScpXG5jb25zdCB3YXRlcmZhbGwgPSByZXF1aXJlKCdhc3luYy93YXRlcmZhbGwnKVxuY29uc3QgaXNTdHJlYW0gPSByZXF1aXJlKCdpcy1zdHJlYW0nKVxuY29uc3QgeyBpc1NvdXJjZSB9ID0gcmVxdWlyZSgnaXMtcHVsbC1zdHJlYW0nKVxuY29uc3QgeyBwYXJzZUNodW5rZXJTdHJpbmcgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3Qgc3RyZWFtRnJvbUZpbGVSZWFkZXIgPSByZXF1aXJlKCdpcGZzLXV0aWxzL3NyYy9zdHJlYW1zL3N0cmVhbS1mcm9tLWZpbGVyZWFkZXInKVxuY29uc3QgeyBzdXBwb3J0c0ZpbGVSZWFkZXIgfSA9IHJlcXVpcmUoJ2lwZnMtdXRpbHMvc3JjL3N1cHBvcnRzJylcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBwcmVwYXJlRmlsZSAoZmlsZSwgc2VsZiwgb3B0cywgY2FsbGJhY2spIHtcbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBsZXQgY2lkID0gZmlsZS5jaWRcblxuICB3YXRlcmZhbGwoW1xuICAgIChjYikgPT4gb3B0cy5vbmx5SGFzaFxuICAgICAgPyBjYihudWxsLCBmaWxlKVxuICAgICAgOiBzZWxmLm9iamVjdC5nZXQoZmlsZS5jaWQsIE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHsgcHJlbG9hZDogZmFsc2UgfSksIGNiKSxcbiAgICAobm9kZSwgY2IpID0+IHtcbiAgICAgIGlmIChvcHRzLmNpZFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgY2lkID0gY2lkLnRvVjEoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBiNThIYXNoID0gY2lkLnRvQmFzZUVuY29kZWRTdHJpbmcoKVxuICAgICAgbGV0IHNpemUgPSBub2RlLnNpemVcblxuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihub2RlKSkge1xuICAgICAgICBzaXplID0gbm9kZS5sZW5ndGhcbiAgICAgIH1cblxuICAgICAgY2IobnVsbCwge1xuICAgICAgICBwYXRoOiBmaWxlLnBhdGggPT09IHVuZGVmaW5lZCA/IGI1OEhhc2ggOiAoZmlsZS5wYXRoIHx8ICcnKSxcbiAgICAgICAgaGFzaDogYjU4SGFzaCxcbiAgICAgICAgLy8gbXVsdGloYXNoOiBiNThIYXNoLFxuICAgICAgICBzaXplXG4gICAgICB9KVxuICAgIH1cbiAgXSwgY2FsbGJhY2spXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRlbnQgKGNvbnRlbnQsIG9wdHMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRlbnQpKSB7XG4gICAgY29udGVudCA9IFtjb250ZW50XVxuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnQubWFwKChkYXRhKSA9PiB7XG4gICAgaWYgKHN1cHBvcnRzRmlsZVJlYWRlciAmJiBraW5kT2YoZGF0YSkgPT09ICdmaWxlJykge1xuICAgICAgZGF0YSA9IHsgcGF0aDogJycsIGNvbnRlbnQ6IHRvUHVsbC5zb3VyY2Uoc3RyZWFtRnJvbUZpbGVSZWFkZXIoZGF0YSkpIH1cbiAgICB9XG4gICAgLy8gQnVmZmVyIGlucHV0XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgZGF0YSA9IHsgcGF0aDogJycsIGNvbnRlbnQ6IHB1bGxWYWx1ZXMoW2RhdGFdKSB9XG4gICAgfVxuXG4gICAgLy8gUmVhZGFibGUgc3RyZWFtIGlucHV0XG4gICAgaWYgKGlzU3RyZWFtLnJlYWRhYmxlKGRhdGEpKSB7XG4gICAgICBkYXRhID0geyBwYXRoOiAnJywgY29udGVudDogdG9QdWxsLnNvdXJjZShkYXRhKSB9XG4gICAgfVxuXG4gICAgaWYgKGlzU291cmNlKGRhdGEpKSB7XG4gICAgICBkYXRhID0geyBwYXRoOiAnJywgY29udGVudDogZGF0YSB9XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5jb250ZW50ICYmIHR5cGVvZiBkYXRhLmNvbnRlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChzdXBwb3J0c0ZpbGVSZWFkZXIgJiYga2luZE9mKGRhdGEuY29udGVudCkgPT09ICdmaWxlJykge1xuICAgICAgICBkYXRhID0geyBwYXRoOiBkYXRhLnBhdGgsIGNvbnRlbnQ6IHRvUHVsbC5zb3VyY2Uoc3RyZWFtRnJvbUZpbGVSZWFkZXIoZGF0YS5jb250ZW50KSkgfVxuICAgICAgfVxuXG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEuY29udGVudCkpIHtcbiAgICAgICAgZGF0YSA9IHsgcGF0aDogZGF0YS5wYXRoLCBjb250ZW50OiBwdWxsVmFsdWVzKFtkYXRhLmNvbnRlbnRdKSB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmVhbS5yZWFkYWJsZShkYXRhLmNvbnRlbnQpKSB7XG4gICAgICAgIGRhdGEgPSB7IHBhdGg6IGRhdGEucGF0aCwgY29udGVudDogdG9QdWxsLnNvdXJjZShkYXRhLmNvbnRlbnQpIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0cy53cmFwV2l0aERpcmVjdG9yeSAmJiAhZGF0YS5wYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIHBhdGggd2hlbiB3cmFwcGluZyB3aXRoIGEgZGlyZWN0b3J5JylcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9KVxufVxuXG5mdW5jdGlvbiBwcmVsb2FkRmlsZSAoZmlsZSwgc2VsZiwgb3B0cykge1xuICBjb25zdCBpc1Jvb3RGaWxlID0gIWZpbGUucGF0aCB8fCBvcHRzLndyYXBXaXRoRGlyZWN0b3J5XG4gICAgPyBmaWxlLnBhdGggPT09ICcnXG4gICAgOiAhZmlsZS5wYXRoLmluY2x1ZGVzKCcvJylcblxuICBjb25zdCBzaG91bGRQcmVsb2FkID0gaXNSb290RmlsZSAmJiAhb3B0cy5vbmx5SGFzaCAmJiBvcHRzLnByZWxvYWQgIT09IGZhbHNlXG5cbiAgaWYgKHNob3VsZFByZWxvYWQpIHtcbiAgICBzZWxmLl9wcmVsb2FkKGZpbGUuaGFzaClcbiAgfVxuXG4gIHJldHVybiBmaWxlXG59XG5cbmZ1bmN0aW9uIHBpbkZpbGUgKGZpbGUsIHNlbGYsIG9wdHMsIGNiKSB7XG4gIC8vIFBpbiBhIGZpbGUgaWYgaXQgaXMgdGhlIHJvb3QgZGlyIG9mIGEgcmVjdXJzaXZlIGFkZCBvciB0aGUgc2luZ2xlIGZpbGVcbiAgLy8gb2YgYSBkaXJlY3QgYWRkLlxuICBjb25zdCBwaW4gPSAncGluJyBpbiBvcHRzID8gb3B0cy5waW4gOiB0cnVlXG4gIGNvbnN0IGlzUm9vdERpciA9ICFmaWxlLnBhdGguaW5jbHVkZXMoJy8nKVxuICBjb25zdCBzaG91bGRQaW4gPSBwaW4gJiYgaXNSb290RGlyICYmICFvcHRzLm9ubHlIYXNoICYmICFvcHRzLmhhc2hBbGdcbiAgaWYgKHNob3VsZFBpbikge1xuICAgIHJldHVybiBzZWxmLnBpbi5hZGQoZmlsZS5oYXNoLCB7IHByZWxvYWQ6IGZhbHNlIH0sIGVyciA9PiBjYihlcnIsIGZpbGUpKVxuICB9IGVsc2Uge1xuICAgIGNiKG51bGwsIGZpbGUpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VsZikge1xuICAvLyBJbnRlcm5hbCBhZGQgZnVuYyB0aGF0IGdldHMgdXNlZCBieSBhbGwgYWRkIGZ1bmNzXG4gIHJldHVybiBmdW5jdGlvbiBhZGRQdWxsU3RyZWFtIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgIGxldCBjaHVua2VyT3B0aW9uc1xuICAgIHRyeSB7XG4gICAgICBjaHVua2VyT3B0aW9ucyA9IHBhcnNlQ2h1bmtlclN0cmluZyhvcHRpb25zLmNodW5rZXIpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gcHVsbE1hcCgoKSA9PiB7IHRocm93IGVyciB9KVxuICAgIH1cbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgc2hhcmRTcGxpdFRocmVzaG9sZDogc2VsZi5fb3B0aW9ucy5FWFBFUklNRU5UQUwuc2hhcmRpbmdcbiAgICAgICAgPyAxMDAwXG4gICAgICAgIDogSW5maW5pdHlcbiAgICB9LCBvcHRpb25zLCB7XG4gICAgICBjaHVua2VyOiBjaHVua2VyT3B0aW9ucy5jaHVua2VyLFxuICAgICAgY2h1bmtlck9wdGlvbnM6IGNodW5rZXJPcHRpb25zLmNodW5rZXJPcHRpb25zXG4gICAgfSlcblxuICAgIC8vIENJRCB2MCBpcyBmb3IgbXVsdGloYXNoZXMgZW5jb2RlZCB3aXRoIHNoYTItMjU2XG4gICAgaWYgKG9wdHMuaGFzaEFsZyAmJiBvcHRzLmNpZFZlcnNpb24gIT09IDEpIHtcbiAgICAgIG9wdHMuY2lkVmVyc2lvbiA9IDFcbiAgICB9XG5cbiAgICBsZXQgdG90YWwgPSAwXG5cbiAgICBjb25zdCBwcm9nID0gb3B0cy5wcm9ncmVzcyB8fCBub29wXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSAoYnl0ZXMpID0+IHtcbiAgICAgIHRvdGFsICs9IGJ5dGVzXG4gICAgICBwcm9nKHRvdGFsKVxuICAgIH1cblxuICAgIG9wdHMucHJvZ3Jlc3MgPSBwcm9ncmVzc1xuICAgIHJldHVybiBwdWxsKFxuICAgICAgcHVsbE1hcChjb250ZW50ID0+IG5vcm1hbGl6ZUNvbnRlbnQoY29udGVudCwgb3B0cykpLFxuICAgICAgcHVsbEZsYXR0ZW4oKSxcbiAgICAgIHB1bGxNYXAoZmlsZSA9PiAoe1xuICAgICAgICBwYXRoOiBmaWxlLnBhdGggPyBmaWxlLnBhdGggOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbnRlbnQ6IGZpbGUuY29udGVudCA/IHRvQXN5bmNJdGVyYXRvcihmaWxlLmNvbnRlbnQpIDogdW5kZWZpbmVkXG4gICAgICB9KSksXG4gICAgICB0b1B1bGxTdHJlYW0udHJhbnNmb3JtKHNvdXJjZSA9PiBpbXBvcnRlcihzb3VyY2UsIHNlbGYuX2lwbGQsIG9wdHMpKSxcbiAgICAgIHB1bGxBc3luY01hcCgoZmlsZSwgY2IpID0+IHByZXBhcmVGaWxlKGZpbGUsIHNlbGYsIG9wdHMsIGNiKSksXG4gICAgICBwdWxsTWFwKGZpbGUgPT4gcHJlbG9hZEZpbGUoZmlsZSwgc2VsZiwgb3B0cykpLFxuICAgICAgcHVsbEFzeW5jTWFwKChmaWxlLCBjYikgPT4gcGluRmlsZShmaWxlLCBzZWxmLCBvcHRzLCBjYikpXG4gICAgKVxuICB9XG59XG4iLCJmdW5jdGlvbiBjYWxsYmFja2lmeShmbikge1xuICB2YXIgZm5MZW5ndGggPSBmbi5sZW5ndGhcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIHZhciBjdHggPSB0aGlzXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSBmbkxlbmd0aCArIDEgJiZcbiAgICAgICAgdHlwZW9mIGFyZ3NbZm5MZW5ndGhdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBjYWxsYmFjayBtb2RlXG4gICAgICB2YXIgY2IgPSBhcmdzLnBvcCgpXG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAodmFsKSB7IGNiLmNhbGwoY3R4LCBudWxsLCB2YWwpIH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGVycikgeyBjYi5jYWxsKGN0eCwgZXJyKSB9KVxuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcHJvbWlzZSBtb2RlXG4gICAgcmV0dXJuIGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5VmFyaWFkaWMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIHZhciBjdHggPSB0aGlzXG4gICAgaWYgKGFyZ3MubGVuZ3RoID49IDEgJiZcbiAgICAgICAgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gY2FsbGJhY2sgbW9kZVxuICAgICAgdmFyIGNiID0gYXJncy5wb3AoKVxuICAgICAgZm4uYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbCkgeyBjYi5jYWxsKGN0eCwgbnVsbCwgdmFsKSB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHsgY2IuY2FsbChjdHgsIGVycikgfSlcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHByb21pc2UgbW9kZVxuICAgIHJldHVybiBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbGxiYWNraWZ5XG5tb2R1bGUuZXhwb3J0cy52YXJpYWRpYyA9IGNhbGxiYWNraWZ5VmFyaWFkaWM7XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdG9BcnJheSA9IGFzeW5jIChpdGVyYXRvcikgPT4ge1xuICBjb25zdCBhcnIgPSBbXVxuXG4gIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgaXRlcmF0b3IpIHtcbiAgICBhcnIucHVzaChlbnRyeSlcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5XG4iLCJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuICdmdW5jdGlvbicgPT09IHR5cGVvZiBmXG59XG5cbmZ1bmN0aW9uIGlzRHVwbGV4IChkKSB7XG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGQgJiYgaXNTb3VyY2UoZC5zb3VyY2UpICYmIGlzU2luayhkLnNpbmspXG59XG5cbmZ1bmN0aW9uIGlzU291cmNlIChzKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHMpICYmIHMubGVuZ3RoID09PSAyXG59XG5cbmZ1bmN0aW9uIGlzU2luayAocykge1xuICByZXR1cm4gaXNGdW5jdGlvbihzKSAmJiBzLmxlbmd0aCA9PT0gMVxufVxuXG5leHBvcnRzLmlzRHVwbGV4ID0gaXNEdXBsZXhcbmV4cG9ydHMuaXNTb3VyY2UgPSBpc1NvdXJjZVxuZXhwb3J0cy5pc1NpbmsgPSBpc1Npbmtcbi8vY2FuJ3QgZG8gaXMgdGhyb3VnaCwgaXQgd2lsbCBhcHBlYXIgYXMgYSBzaW5rIHRpbCB5b3UgZ2l0IGl0IGEgc291cmNlLlxuXG4iLCJjb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vcHVsbCcpXG5cbm1vZHVsZS5leHBvcnRzID0gc291cmNlID0+IHtcbiAgcmV0dXJuIChhc3luYyBmdW5jdGlvbiAqICgpIHtcbiAgICBsZXQgX3JlYWRcblxuICAgIGNvbnN0IHNpbmsgPSByZWFkID0+IHtcbiAgICAgIF9yZWFkID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZWFkKG51bGwsIChlbmQsIGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoZW5kID09PSB0cnVlKSByZXR1cm4gcmVzb2x2ZSh7IGVuZCB9KVxuICAgICAgICAgIGlmIChlbmQpIHJldHVybiByZWplY3QoZW5kKVxuICAgICAgICAgIHJlc29sdmUoeyBkYXRhIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIHB1bGwoc291cmNlLCBzaW5rKVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZW5kLCBkYXRhIH0gPSBhd2FpdCBfcmVhZCgpXG4gICAgICBpZiAoZW5kKSBicmVha1xuICAgICAgeWllbGQgZGF0YVxuICAgIH1cbiAgfSkoKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIGlkIChlKSB7IHJldHVybiBlIH1cbnZhciBwcm9wID0gcmVxdWlyZSgnLi4vdXRpbC9wcm9wJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXAgKG1hcHBlcikge1xuICBpZighbWFwcGVyKSByZXR1cm4gaWRcbiAgbWFwcGVyID0gcHJvcChtYXBwZXIpXG4gIHJldHVybiBmdW5jdGlvbiAocmVhZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYWJvcnQsIGNiKSB7XG4gICAgICByZWFkKGFib3J0LCBmdW5jdGlvbiAoZW5kLCBkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSAhZW5kID8gbWFwcGVyKGRhdGEpIDogbnVsbFxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZChlcnIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBjYihlbmQsIGRhdGEpXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbmV4cG9ydHMuZmluaXNoZWQgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMnKTtcbmV4cG9ydHMucGlwZWxpbmUgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzJyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuY29uc3QgX3JlcXVpcmUgPSByZXF1aXJlKFwicmVhZGFibGUtc3RyZWFtXCIpLFxuICAgICAgUmVhZGFibGUgPSBfcmVxdWlyZS5SZWFkYWJsZTtcblxuY29uc3QgZ2V0U3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA9PiB7XG4gIGNvbnN0IHN5bWJvbCA9IFN5bWJvbFtuYW1lXTtcbiAgcmV0dXJuIHN5bWJvbCAhPT0gdW5kZWZpbmVkID8gc3ltYm9sIDogYEBAJHtuYW1lfWA7XG59IDogbmFtZSA9PiBgQEAke25hbWV9YDtcbmNvbnN0ICQkYXN5bmNJdGVyYXRvciA9IGFzeW5jSXRlcmF0b3JUb1N0cmVhbS4kJGFzeW5jSXRlcmF0b3IgPSBnZXRTeW1ib2woXCJhc3luY0l0ZXJhdG9yXCIpO1xuY29uc3QgJCRpdGVyYXRvciA9IGFzeW5jSXRlcmF0b3JUb1N0cmVhbS4kJGl0ZXJhdG9yID0gZ2V0U3ltYm9sKFwiaXRlcmF0b3JcIik7XG5cbmNvbnN0IHJlc29sdmVUb0l0ZXJhdG9yID0gdmFsdWUgPT4ge1xuICBsZXQgdG1wO1xuXG4gIGlmICh0eXBlb2YgKHRtcCA9IHZhbHVlWyQkYXN5bmNJdGVyYXRvcl0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdG1wLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiAodG1wID0gdmFsdWVbJCRpdGVyYXRvcl0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdG1wLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuZnVuY3Rpb24gYXN5bmNJdGVyYXRvclRvU3RyZWFtKGl0ZXJhYmxlLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgaXRlcmFibGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXN5bmNJdGVyYXRvclRvU3RyZWFtKGl0ZXJhYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICBjb25zdCB0aGVuID0gaXRlcmFibGUudGhlbjtcblxuICBpZiAodHlwZW9mIHRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB0aGVuLmNhbGwoaXRlcmFibGUsIGl0ZXJhYmxlID0+IGFzeW5jSXRlcmF0b3JUb1N0cmVhbShpdGVyYWJsZSwgb3B0aW9ucykpO1xuICB9XG5cbiAgY29uc3QgaXRlcmF0b3IgPSByZXNvbHZlVG9JdGVyYXRvcihpdGVyYWJsZSk7XG4gIGNvbnN0IGlzR2VuZXJhdG9yID0gXCJyZXR1cm5cIiBpbiBpdGVyYXRvcjtcbiAgY29uc3QgcmVhZGFibGUgPSBvcHRpb25zIGluc3RhbmNlb2YgUmVhZGFibGUgPyBvcHRpb25zIDogbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIGlmIChpc0dlbmVyYXRvcikge1xuICAgIHJlYWRhYmxlLl9kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKGVycm9yLCBjYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIGVycm9yICE9IG51bGwgPyBpdGVyYXRvci50aHJvdyhlcnJvcikgOiBpdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gY2IoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gsIF94Mikge1xuICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9KCk7XG4gIH1cblxuICBsZXQgcnVubmluZyA9IGZhbHNlO1xuXG4gIHJlYWRhYmxlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoc2l6ZSkge1xuICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHZhbHVlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBsZXQgY3Vyc29yID0gaXRlcmF0b3IubmV4dChzaXplKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY3Vyc29yLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY3Vyc29yID0geWllbGQgY3Vyc29yO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5kb25lICYmICh2YWx1ZSA9IGN1cnNvci52YWx1ZSkgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB5aWVsZCB2YWx1ZTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBpdGVyYXRvci50aHJvdyhlcnJvcik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjdXJzb3IgPSBpdGVyYXRvci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3Vyc29yLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkYWJsZS5wdXNoKG51bGwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICB9IHdoaWxlICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHJlYWRhYmxlLnB1c2godmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2socmVhZGFibGUuZW1pdC5iaW5kKHJlYWRhYmxlLCBcImVycm9yXCIsIGVycm9yKSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKF94Mykge1xuICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHJldHVybiByZWFkYWJsZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3luY0l0ZXJhdG9yVG9TdHJlYW07XG5cbmFzeW5jSXRlcmF0b3JUb1N0cmVhbS5vYmogPSAoaXRlcmFibGUsIG9wdGlvbnMpID0+IGFzeW5jSXRlcmF0b3JUb1N0cmVhbShpdGVyYWJsZSwgX2V4dGVuZHMoe1xuICBvYmplY3RNb2RlOiB0cnVlXG59LCBvcHRpb25zKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NyYy9jb3JlJylcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcGVybWlzc2lvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Jlc291cmNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZXJ2aWNlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc25hcHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N1YmplY3QtbWV0YWRhdGFcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhY2thZ2VCdWZmZXIgPSBleHBvcnRzLkJJUDQ0UHVycG9zZU5vZGVUb2tlbiA9IGV4cG9ydHMuTUFYX0JJUF80NF9ERVBUSCA9IGV4cG9ydHMuTUlOX0JJUF80NF9ERVBUSCA9IGV4cG9ydHMuZ2V0QklQNDRBZGRyZXNzS2V5RGVyaXZlciA9IGV4cG9ydHMuZGVyaXZlQklQNDRBZGRyZXNzS2V5ID0gZXhwb3J0cy5CSVBfNDRfQ09JTl9UWVBFX0RFUFRIID0gZXhwb3J0cy5CSVA0NENvaW5UeXBlTm9kZSA9IGV4cG9ydHMuQklQNDROb2RlID0gdm9pZCAwO1xudmFyIEJJUDQ0Tm9kZV8xID0gcmVxdWlyZShcIi4vQklQNDROb2RlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQklQNDROb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCSVA0NE5vZGVfMS5CSVA0NE5vZGU7IH0gfSk7XG52YXIgQklQNDRDb2luVHlwZU5vZGVfMSA9IHJlcXVpcmUoXCIuL0JJUDQ0Q29pblR5cGVOb2RlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQklQNDRDb2luVHlwZU5vZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJJUDQ0Q29pblR5cGVOb2RlXzEuQklQNDRDb2luVHlwZU5vZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCSVBfNDRfQ09JTl9UWVBFX0RFUFRIXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCSVA0NENvaW5UeXBlTm9kZV8xLkJJUF80NF9DT0lOX1RZUEVfREVQVEg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZXJpdmVCSVA0NEFkZHJlc3NLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJJUDQ0Q29pblR5cGVOb2RlXzEuZGVyaXZlQklQNDRBZGRyZXNzS2V5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QklQNDRBZGRyZXNzS2V5RGVyaXZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQklQNDRDb2luVHlwZU5vZGVfMS5nZXRCSVA0NEFkZHJlc3NLZXlEZXJpdmVyOyB9IH0pO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTUlOX0JJUF80NF9ERVBUSFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuTUlOX0JJUF80NF9ERVBUSDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1BWF9CSVBfNDRfREVQVEhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLk1BWF9CSVBfNDRfREVQVEg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCSVA0NFB1cnBvc2VOb2RlVG9rZW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLkJJUDQ0UHVycG9zZU5vZGVUb2tlbjsgfSB9KTtcbi8qKlxuICogVGhlIHtAbGluayBCdWZmZXJ9IGFjY2Vzc2libGUgdG8gYEBtZXRhbWFzay9rZXktdHJlZWAsIHJlLWV4cG9ydGVkIGluIGNhc2VcbiAqIG9mIG1vZHVsZSByZXNvbHV0aW9uIGlzc3Vlcy5cbiAqL1xuZXhwb3J0cy5QYWNrYWdlQnVmZmVyID0gQnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhbmRsZUluc3RhbGxTbmFwcyA9IGV4cG9ydHMucHJlcHJvY2Vzc1JlcXVlc3RlZFBlcm1pc3Npb25zID0gdm9pZCAwO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IHNuYXBfY29udHJvbGxlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc25hcC1jb250cm9sbGVyc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG4vLyBwcmVwcm9jZXNzIHJlcXVlc3RlZCBwZXJtaXNzaW9ucyB0byBzdXBwb3J0ICd3YWxsZXRfc25hcCcgc3ludGFjdGljIHN1Z2FyXG5mdW5jdGlvbiBwcmVwcm9jZXNzUmVxdWVzdGVkUGVybWlzc2lvbnMocmVxdWVzdGVkUGVybWlzc2lvbnMpIHtcbiAgICBpZiAoIXV0aWxzXzEuaXNQbGFpbk9iamVjdChyZXF1ZXN0ZWRQZXJtaXNzaW9ucykpIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRSZXF1ZXN0KHsgZGF0YTogeyByZXF1ZXN0ZWRQZXJtaXNzaW9ucyB9IH0pO1xuICAgIH1cbiAgICAvLyBwYXNzdGhyb3VnaCBpZiAnd2FsbGV0X3NuYXAnIGlzIG5vdCByZXF1ZXN0ZWRcbiAgICBpZiAoIXJlcXVlc3RlZFBlcm1pc3Npb25zLndhbGxldF9zbmFwKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0ZWRQZXJtaXNzaW9ucztcbiAgICB9XG4gICAgLy8gcmV3cml0ZSBwZXJtaXNzaW9ucyByZXF1ZXN0IHBhcmFtZXRlciBieSBkZXN0cnVjdHVyaW5nIHNuYXBzIGludG9cbiAgICAvLyBwcm9wZXIgcGVybWlzc2lvbnMgcHJlZml4ZWQgd2l0aCAnd2FsbGV0X3NuYXBfJ1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXF1ZXN0ZWRQZXJtaXNzaW9ucykucmVkdWNlKChuZXdSZXF1ZXN0ZWRQZXJtaXNzaW9ucywgcGVybU5hbWUpID0+IHtcbiAgICAgICAgaWYgKHBlcm1OYW1lID09PSAnd2FsbGV0X3NuYXAnKSB7XG4gICAgICAgICAgICBpZiAoIXV0aWxzXzEuaXNQbGFpbk9iamVjdChyZXF1ZXN0ZWRQZXJtaXNzaW9uc1twZXJtTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBwYXJhbXMgdG8gJ3dhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnMnYCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyByZXF1ZXN0ZWRQZXJtaXNzaW9ucyB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkU25hcHMgPSByZXF1ZXN0ZWRQZXJtaXNzaW9uc1twZXJtTmFtZV07XG4gICAgICAgICAgICAvLyBkZXN0cnVjdHVyZSAnd2FsbGV0X3NuYXAnIG9iamVjdFxuICAgICAgICAgICAgT2JqZWN0LmtleXMocmVxdWVzdGVkU25hcHMpLmZvckVhY2goKHNuYXBOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc25hcEtleSA9IHNuYXBfY29udHJvbGxlcnNfMS5TTkFQX1BSRUZJWCArIHNuYXBOYW1lO1xuICAgICAgICAgICAgICAgIC8vIGRpc2FsbG93IHJlcXVlc3RpbmcgYSBzbmFwIFggdW5kZXIgJ3dhbGxldF9zbmFwcycgYW5kXG4gICAgICAgICAgICAgICAgLy8gZGlyZWN0bHkgYXMgJ3dhbGxldF9zbmFwX1gnXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RlZFBlcm1pc3Npb25zW3NuYXBLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBTbmFwICcke3NuYXBOYW1lfScgcmVxdWVzdGVkIGJvdGggYXMgZGlyZWN0IHBlcm1pc3Npb24gYW5kIHVuZGVyICd3YWxsZXRfc25hcCcuIFdlIHJlY29tbWVuZCB1c2luZyAnd2FsbGV0X3NuYXAnIG9ubHkuYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgcmVxdWVzdGVkUGVybWlzc2lvbnMgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1JlcXVlc3RlZFBlcm1pc3Npb25zW3NuYXBLZXldID0gcmVxdWVzdGVkU25hcHNbc25hcE5hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIGxlYXZlIHRoaW5ncyBhcyB3ZSBmb3VuZCB0aGVtXG4gICAgICAgICAgICBuZXdSZXF1ZXN0ZWRQZXJtaXNzaW9uc1twZXJtTmFtZV0gPSByZXF1ZXN0ZWRQZXJtaXNzaW9uc1twZXJtTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1JlcXVlc3RlZFBlcm1pc3Npb25zO1xuICAgIH0sIHt9KTtcbn1cbmV4cG9ydHMucHJlcHJvY2Vzc1JlcXVlc3RlZFBlcm1pc3Npb25zID0gcHJlcHJvY2Vzc1JlcXVlc3RlZFBlcm1pc3Npb25zO1xuLyoqXG4gKiBUeXBlY2hlY2tzIHRoZSByZXF1ZXN0ZWQgc25hcHMgYW5kIHBhc3NlcyB0aGVtIHRvIHRoZSBwZXJtaXNzaW9uc1xuICogY29udHJvbGxlciBmb3IgaW5zdGFsbGF0aW9uLlxuICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVJbnN0YWxsU25hcHMocmVxdWVzdGVkU25hcHMsIGluc3RhbGxTbmFwcykge1xuICAgIGlmICghdXRpbHNfMS5pc1BsYWluT2JqZWN0KHJlcXVlc3RlZFNuYXBzKSkge1xuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBzbmFwIGluc3RhbGxhdGlvbiBwYXJhbXMuYCxcbiAgICAgICAgICAgIGRhdGE6IHsgcmVxdWVzdGVkU25hcHMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKE9iamVjdC5rZXlzKHJlcXVlc3RlZFNuYXBzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgbWVzc2FnZTogYE11c3Qgc3BlY2lmeSBhdCBsZWFzdCBvbmUgc25hcCB0byBpbnN0YWxsLmAsXG4gICAgICAgICAgICBkYXRhOiB7IHJlcXVlc3RlZFNuYXBzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBpbnN0YWxsU25hcHMgaXMgYm91bmQgdG8gdGhlIG9yaWdpblxuICAgIHJldHVybiBhd2FpdCBpbnN0YWxsU25hcHMocmVxdWVzdGVkU25hcHMpO1xufVxuZXhwb3J0cy5oYW5kbGVJbnN0YWxsU25hcHMgPSBoYW5kbGVJbnN0YWxsU25hcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbmFwSW5zdGFsbGF0aW9uLmpzLm1hcCIsIi8vIERPIE5PVCBDSEFOR0UgVEhJUyBGSUxFLiBJVCBJUyBHRU5FUkFURUQgQlkgdG9vbHMvdXBkYXRlLXRhYmxlLmpzXG4vKiBlc2xpbnQgcXVvdGUtcHJvcHM6IG9mZiAqL1xuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQHR5cGUge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuTmFtZUNvZGVNYXB9XG4gKi9cbmNvbnN0IGJhc2VUYWJsZSA9IE9iamVjdC5mcmVlemUoe1xuICAnaWRlbnRpdHknOiAweDAwLFxuICAnY2lkdjEnOiAweDAxLFxuICAnY2lkdjInOiAweDAyLFxuICAnY2lkdjMnOiAweDAzLFxuICAnaXA0JzogMHgwNCxcbiAgJ3RjcCc6IDB4MDYsXG4gICdzaGExJzogMHgxMSxcbiAgJ3NoYTItMjU2JzogMHgxMixcbiAgJ3NoYTItNTEyJzogMHgxMyxcbiAgJ3NoYTMtNTEyJzogMHgxNCxcbiAgJ3NoYTMtMzg0JzogMHgxNSxcbiAgJ3NoYTMtMjU2JzogMHgxNixcbiAgJ3NoYTMtMjI0JzogMHgxNyxcbiAgJ3NoYWtlLTEyOCc6IDB4MTgsXG4gICdzaGFrZS0yNTYnOiAweDE5LFxuICAna2VjY2FrLTIyNCc6IDB4MWEsXG4gICdrZWNjYWstMjU2JzogMHgxYixcbiAgJ2tlY2Nhay0zODQnOiAweDFjLFxuICAna2VjY2FrLTUxMic6IDB4MWQsXG4gICdibGFrZTMnOiAweDFlLFxuICAnZGNjcCc6IDB4MjEsXG4gICdtdXJtdXIzLTEyOCc6IDB4MjIsXG4gICdtdXJtdXIzLTMyJzogMHgyMyxcbiAgJ2lwNic6IDB4MjksXG4gICdpcDZ6b25lJzogMHgyYSxcbiAgJ3BhdGgnOiAweDJmLFxuICAnbXVsdGljb2RlYyc6IDB4MzAsXG4gICdtdWx0aWhhc2gnOiAweDMxLFxuICAnbXVsdGlhZGRyJzogMHgzMixcbiAgJ211bHRpYmFzZSc6IDB4MzMsXG4gICdkbnMnOiAweDM1LFxuICAnZG5zNCc6IDB4MzYsXG4gICdkbnM2JzogMHgzNyxcbiAgJ2Ruc2FkZHInOiAweDM4LFxuICAncHJvdG9idWYnOiAweDUwLFxuICAnY2Jvcic6IDB4NTEsXG4gICdyYXcnOiAweDU1LFxuICAnZGJsLXNoYTItMjU2JzogMHg1NixcbiAgJ3JscCc6IDB4NjAsXG4gICdiZW5jb2RlJzogMHg2MyxcbiAgJ2RhZy1wYic6IDB4NzAsXG4gICdkYWctY2Jvcic6IDB4NzEsXG4gICdsaWJwMnAta2V5JzogMHg3MixcbiAgJ2dpdC1yYXcnOiAweDc4LFxuICAndG9ycmVudC1pbmZvJzogMHg3YixcbiAgJ3RvcnJlbnQtZmlsZSc6IDB4N2MsXG4gICdsZW9mY29pbi1ibG9jayc6IDB4ODEsXG4gICdsZW9mY29pbi10eCc6IDB4ODIsXG4gICdsZW9mY29pbi1wcic6IDB4ODMsXG4gICdzY3RwJzogMHg4NCxcbiAgJ2RhZy1qb3NlJzogMHg4NSxcbiAgJ2RhZy1jb3NlJzogMHg4NixcbiAgJ2V0aC1ibG9jayc6IDB4OTAsXG4gICdldGgtYmxvY2stbGlzdCc6IDB4OTEsXG4gICdldGgtdHgtdHJpZSc6IDB4OTIsXG4gICdldGgtdHgnOiAweDkzLFxuICAnZXRoLXR4LXJlY2VpcHQtdHJpZSc6IDB4OTQsXG4gICdldGgtdHgtcmVjZWlwdCc6IDB4OTUsXG4gICdldGgtc3RhdGUtdHJpZSc6IDB4OTYsXG4gICdldGgtYWNjb3VudC1zbmFwc2hvdCc6IDB4OTcsXG4gICdldGgtc3RvcmFnZS10cmllJzogMHg5OCxcbiAgJ2JpdGNvaW4tYmxvY2snOiAweGIwLFxuICAnYml0Y29pbi10eCc6IDB4YjEsXG4gICdiaXRjb2luLXdpdG5lc3MtY29tbWl0bWVudCc6IDB4YjIsXG4gICd6Y2FzaC1ibG9jayc6IDB4YzAsXG4gICd6Y2FzaC10eCc6IDB4YzEsXG4gICdkb2NpZCc6IDB4Y2UsXG4gICdzdGVsbGFyLWJsb2NrJzogMHhkMCxcbiAgJ3N0ZWxsYXItdHgnOiAweGQxLFxuICAnbWQ0JzogMHhkNCxcbiAgJ21kNSc6IDB4ZDUsXG4gICdibXQnOiAweGQ2LFxuICAnZGVjcmVkLWJsb2NrJzogMHhlMCxcbiAgJ2RlY3JlZC10eCc6IDB4ZTEsXG4gICdpcGxkLW5zJzogMHhlMixcbiAgJ2lwZnMtbnMnOiAweGUzLFxuICAnc3dhcm0tbnMnOiAweGU0LFxuICAnaXBucy1ucyc6IDB4ZTUsXG4gICd6ZXJvbmV0JzogMHhlNixcbiAgJ3NlY3AyNTZrMS1wdWInOiAweGU3LFxuICAnYmxzMTJfMzgxLWcxLXB1Yic6IDB4ZWEsXG4gICdibHMxMl8zODEtZzItcHViJzogMHhlYixcbiAgJ3gyNTUxOS1wdWInOiAweGVjLFxuICAnZWQyNTUxOS1wdWInOiAweGVkLFxuICAnYmxzMTJfMzgxLWcxZzItcHViJzogMHhlZSxcbiAgJ2Rhc2gtYmxvY2snOiAweGYwLFxuICAnZGFzaC10eCc6IDB4ZjEsXG4gICdzd2FybS1tYW5pZmVzdCc6IDB4ZmEsXG4gICdzd2FybS1mZWVkJzogMHhmYixcbiAgJ3VkcCc6IDB4MDExMSxcbiAgJ3AycC13ZWJydGMtc3Rhcic6IDB4MDExMyxcbiAgJ3AycC13ZWJydGMtZGlyZWN0JzogMHgwMTE0LFxuICAncDJwLXN0YXJkdXN0JzogMHgwMTE1LFxuICAncDJwLWNpcmN1aXQnOiAweDAxMjIsXG4gICdkYWctanNvbic6IDB4MDEyOSxcbiAgJ3VkdCc6IDB4MDEyZCxcbiAgJ3V0cCc6IDB4MDEyZSxcbiAgJ3VuaXgnOiAweDAxOTAsXG4gICd0aHJlYWQnOiAweDAxOTYsXG4gICdwMnAnOiAweDAxYTUsXG4gICdpcGZzJzogMHgwMWE1LFxuICAnaHR0cHMnOiAweDAxYmIsXG4gICdvbmlvbic6IDB4MDFiYyxcbiAgJ29uaW9uMyc6IDB4MDFiZCxcbiAgJ2dhcmxpYzY0JzogMHgwMWJlLFxuICAnZ2FybGljMzInOiAweDAxYmYsXG4gICd0bHMnOiAweDAxYzAsXG4gICdxdWljJzogMHgwMWNjLFxuICAnd3MnOiAweDAxZGQsXG4gICd3c3MnOiAweDAxZGUsXG4gICdwMnAtd2Vic29ja2V0LXN0YXInOiAweDAxZGYsXG4gICdodHRwJzogMHgwMWUwLFxuICAnanNvbic6IDB4MDIwMCxcbiAgJ21lc3NhZ2VwYWNrJzogMHgwMjAxLFxuICAnbGlicDJwLXBlZXItcmVjb3JkJzogMHgwMzAxLFxuICAnc2hhMi0yNTYtdHJ1bmMyNTQtcGFkZGVkJzogMHgxMDEyLFxuICAncmlwZW1kLTEyOCc6IDB4MTA1MixcbiAgJ3JpcGVtZC0xNjAnOiAweDEwNTMsXG4gICdyaXBlbWQtMjU2JzogMHgxMDU0LFxuICAncmlwZW1kLTMyMCc6IDB4MTA1NSxcbiAgJ3gxMSc6IDB4MTEwMCxcbiAgJ3AyNTYtcHViJzogMHgxMjAwLFxuICAncDM4NC1wdWInOiAweDEyMDEsXG4gICdwNTIxLXB1Yic6IDB4MTIwMixcbiAgJ2VkNDQ4LXB1Yic6IDB4MTIwMyxcbiAgJ3g0NDgtcHViJzogMHgxMjA0LFxuICAnZWQyNTUxOS1wcml2JzogMHgxMzAwLFxuICAna2FuZ2Fyb290d2VsdmUnOiAweDFkMDEsXG4gICdzbTMtMjU2JzogMHg1MzRkLFxuICAnYmxha2UyYi04JzogMHhiMjAxLFxuICAnYmxha2UyYi0xNic6IDB4YjIwMixcbiAgJ2JsYWtlMmItMjQnOiAweGIyMDMsXG4gICdibGFrZTJiLTMyJzogMHhiMjA0LFxuICAnYmxha2UyYi00MCc6IDB4YjIwNSxcbiAgJ2JsYWtlMmItNDgnOiAweGIyMDYsXG4gICdibGFrZTJiLTU2JzogMHhiMjA3LFxuICAnYmxha2UyYi02NCc6IDB4YjIwOCxcbiAgJ2JsYWtlMmItNzInOiAweGIyMDksXG4gICdibGFrZTJiLTgwJzogMHhiMjBhLFxuICAnYmxha2UyYi04OCc6IDB4YjIwYixcbiAgJ2JsYWtlMmItOTYnOiAweGIyMGMsXG4gICdibGFrZTJiLTEwNCc6IDB4YjIwZCxcbiAgJ2JsYWtlMmItMTEyJzogMHhiMjBlLFxuICAnYmxha2UyYi0xMjAnOiAweGIyMGYsXG4gICdibGFrZTJiLTEyOCc6IDB4YjIxMCxcbiAgJ2JsYWtlMmItMTM2JzogMHhiMjExLFxuICAnYmxha2UyYi0xNDQnOiAweGIyMTIsXG4gICdibGFrZTJiLTE1Mic6IDB4YjIxMyxcbiAgJ2JsYWtlMmItMTYwJzogMHhiMjE0LFxuICAnYmxha2UyYi0xNjgnOiAweGIyMTUsXG4gICdibGFrZTJiLTE3Nic6IDB4YjIxNixcbiAgJ2JsYWtlMmItMTg0JzogMHhiMjE3LFxuICAnYmxha2UyYi0xOTInOiAweGIyMTgsXG4gICdibGFrZTJiLTIwMCc6IDB4YjIxOSxcbiAgJ2JsYWtlMmItMjA4JzogMHhiMjFhLFxuICAnYmxha2UyYi0yMTYnOiAweGIyMWIsXG4gICdibGFrZTJiLTIyNCc6IDB4YjIxYyxcbiAgJ2JsYWtlMmItMjMyJzogMHhiMjFkLFxuICAnYmxha2UyYi0yNDAnOiAweGIyMWUsXG4gICdibGFrZTJiLTI0OCc6IDB4YjIxZixcbiAgJ2JsYWtlMmItMjU2JzogMHhiMjIwLFxuICAnYmxha2UyYi0yNjQnOiAweGIyMjEsXG4gICdibGFrZTJiLTI3Mic6IDB4YjIyMixcbiAgJ2JsYWtlMmItMjgwJzogMHhiMjIzLFxuICAnYmxha2UyYi0yODgnOiAweGIyMjQsXG4gICdibGFrZTJiLTI5Nic6IDB4YjIyNSxcbiAgJ2JsYWtlMmItMzA0JzogMHhiMjI2LFxuICAnYmxha2UyYi0zMTInOiAweGIyMjcsXG4gICdibGFrZTJiLTMyMCc6IDB4YjIyOCxcbiAgJ2JsYWtlMmItMzI4JzogMHhiMjI5LFxuICAnYmxha2UyYi0zMzYnOiAweGIyMmEsXG4gICdibGFrZTJiLTM0NCc6IDB4YjIyYixcbiAgJ2JsYWtlMmItMzUyJzogMHhiMjJjLFxuICAnYmxha2UyYi0zNjAnOiAweGIyMmQsXG4gICdibGFrZTJiLTM2OCc6IDB4YjIyZSxcbiAgJ2JsYWtlMmItMzc2JzogMHhiMjJmLFxuICAnYmxha2UyYi0zODQnOiAweGIyMzAsXG4gICdibGFrZTJiLTM5Mic6IDB4YjIzMSxcbiAgJ2JsYWtlMmItNDAwJzogMHhiMjMyLFxuICAnYmxha2UyYi00MDgnOiAweGIyMzMsXG4gICdibGFrZTJiLTQxNic6IDB4YjIzNCxcbiAgJ2JsYWtlMmItNDI0JzogMHhiMjM1LFxuICAnYmxha2UyYi00MzInOiAweGIyMzYsXG4gICdibGFrZTJiLTQ0MCc6IDB4YjIzNyxcbiAgJ2JsYWtlMmItNDQ4JzogMHhiMjM4LFxuICAnYmxha2UyYi00NTYnOiAweGIyMzksXG4gICdibGFrZTJiLTQ2NCc6IDB4YjIzYSxcbiAgJ2JsYWtlMmItNDcyJzogMHhiMjNiLFxuICAnYmxha2UyYi00ODAnOiAweGIyM2MsXG4gICdibGFrZTJiLTQ4OCc6IDB4YjIzZCxcbiAgJ2JsYWtlMmItNDk2JzogMHhiMjNlLFxuICAnYmxha2UyYi01MDQnOiAweGIyM2YsXG4gICdibGFrZTJiLTUxMic6IDB4YjI0MCxcbiAgJ2JsYWtlMnMtOCc6IDB4YjI0MSxcbiAgJ2JsYWtlMnMtMTYnOiAweGIyNDIsXG4gICdibGFrZTJzLTI0JzogMHhiMjQzLFxuICAnYmxha2Uycy0zMic6IDB4YjI0NCxcbiAgJ2JsYWtlMnMtNDAnOiAweGIyNDUsXG4gICdibGFrZTJzLTQ4JzogMHhiMjQ2LFxuICAnYmxha2Uycy01Nic6IDB4YjI0NyxcbiAgJ2JsYWtlMnMtNjQnOiAweGIyNDgsXG4gICdibGFrZTJzLTcyJzogMHhiMjQ5LFxuICAnYmxha2Uycy04MCc6IDB4YjI0YSxcbiAgJ2JsYWtlMnMtODgnOiAweGIyNGIsXG4gICdibGFrZTJzLTk2JzogMHhiMjRjLFxuICAnYmxha2Uycy0xMDQnOiAweGIyNGQsXG4gICdibGFrZTJzLTExMic6IDB4YjI0ZSxcbiAgJ2JsYWtlMnMtMTIwJzogMHhiMjRmLFxuICAnYmxha2Uycy0xMjgnOiAweGIyNTAsXG4gICdibGFrZTJzLTEzNic6IDB4YjI1MSxcbiAgJ2JsYWtlMnMtMTQ0JzogMHhiMjUyLFxuICAnYmxha2Uycy0xNTInOiAweGIyNTMsXG4gICdibGFrZTJzLTE2MCc6IDB4YjI1NCxcbiAgJ2JsYWtlMnMtMTY4JzogMHhiMjU1LFxuICAnYmxha2Uycy0xNzYnOiAweGIyNTYsXG4gICdibGFrZTJzLTE4NCc6IDB4YjI1NyxcbiAgJ2JsYWtlMnMtMTkyJzogMHhiMjU4LFxuICAnYmxha2Uycy0yMDAnOiAweGIyNTksXG4gICdibGFrZTJzLTIwOCc6IDB4YjI1YSxcbiAgJ2JsYWtlMnMtMjE2JzogMHhiMjViLFxuICAnYmxha2Uycy0yMjQnOiAweGIyNWMsXG4gICdibGFrZTJzLTIzMic6IDB4YjI1ZCxcbiAgJ2JsYWtlMnMtMjQwJzogMHhiMjVlLFxuICAnYmxha2Uycy0yNDgnOiAweGIyNWYsXG4gICdibGFrZTJzLTI1Nic6IDB4YjI2MCxcbiAgJ3NrZWluMjU2LTgnOiAweGIzMDEsXG4gICdza2VpbjI1Ni0xNic6IDB4YjMwMixcbiAgJ3NrZWluMjU2LTI0JzogMHhiMzAzLFxuICAnc2tlaW4yNTYtMzInOiAweGIzMDQsXG4gICdza2VpbjI1Ni00MCc6IDB4YjMwNSxcbiAgJ3NrZWluMjU2LTQ4JzogMHhiMzA2LFxuICAnc2tlaW4yNTYtNTYnOiAweGIzMDcsXG4gICdza2VpbjI1Ni02NCc6IDB4YjMwOCxcbiAgJ3NrZWluMjU2LTcyJzogMHhiMzA5LFxuICAnc2tlaW4yNTYtODAnOiAweGIzMGEsXG4gICdza2VpbjI1Ni04OCc6IDB4YjMwYixcbiAgJ3NrZWluMjU2LTk2JzogMHhiMzBjLFxuICAnc2tlaW4yNTYtMTA0JzogMHhiMzBkLFxuICAnc2tlaW4yNTYtMTEyJzogMHhiMzBlLFxuICAnc2tlaW4yNTYtMTIwJzogMHhiMzBmLFxuICAnc2tlaW4yNTYtMTI4JzogMHhiMzEwLFxuICAnc2tlaW4yNTYtMTM2JzogMHhiMzExLFxuICAnc2tlaW4yNTYtMTQ0JzogMHhiMzEyLFxuICAnc2tlaW4yNTYtMTUyJzogMHhiMzEzLFxuICAnc2tlaW4yNTYtMTYwJzogMHhiMzE0LFxuICAnc2tlaW4yNTYtMTY4JzogMHhiMzE1LFxuICAnc2tlaW4yNTYtMTc2JzogMHhiMzE2LFxuICAnc2tlaW4yNTYtMTg0JzogMHhiMzE3LFxuICAnc2tlaW4yNTYtMTkyJzogMHhiMzE4LFxuICAnc2tlaW4yNTYtMjAwJzogMHhiMzE5LFxuICAnc2tlaW4yNTYtMjA4JzogMHhiMzFhLFxuICAnc2tlaW4yNTYtMjE2JzogMHhiMzFiLFxuICAnc2tlaW4yNTYtMjI0JzogMHhiMzFjLFxuICAnc2tlaW4yNTYtMjMyJzogMHhiMzFkLFxuICAnc2tlaW4yNTYtMjQwJzogMHhiMzFlLFxuICAnc2tlaW4yNTYtMjQ4JzogMHhiMzFmLFxuICAnc2tlaW4yNTYtMjU2JzogMHhiMzIwLFxuICAnc2tlaW41MTItOCc6IDB4YjMyMSxcbiAgJ3NrZWluNTEyLTE2JzogMHhiMzIyLFxuICAnc2tlaW41MTItMjQnOiAweGIzMjMsXG4gICdza2VpbjUxMi0zMic6IDB4YjMyNCxcbiAgJ3NrZWluNTEyLTQwJzogMHhiMzI1LFxuICAnc2tlaW41MTItNDgnOiAweGIzMjYsXG4gICdza2VpbjUxMi01Nic6IDB4YjMyNyxcbiAgJ3NrZWluNTEyLTY0JzogMHhiMzI4LFxuICAnc2tlaW41MTItNzInOiAweGIzMjksXG4gICdza2VpbjUxMi04MCc6IDB4YjMyYSxcbiAgJ3NrZWluNTEyLTg4JzogMHhiMzJiLFxuICAnc2tlaW41MTItOTYnOiAweGIzMmMsXG4gICdza2VpbjUxMi0xMDQnOiAweGIzMmQsXG4gICdza2VpbjUxMi0xMTInOiAweGIzMmUsXG4gICdza2VpbjUxMi0xMjAnOiAweGIzMmYsXG4gICdza2VpbjUxMi0xMjgnOiAweGIzMzAsXG4gICdza2VpbjUxMi0xMzYnOiAweGIzMzEsXG4gICdza2VpbjUxMi0xNDQnOiAweGIzMzIsXG4gICdza2VpbjUxMi0xNTInOiAweGIzMzMsXG4gICdza2VpbjUxMi0xNjAnOiAweGIzMzQsXG4gICdza2VpbjUxMi0xNjgnOiAweGIzMzUsXG4gICdza2VpbjUxMi0xNzYnOiAweGIzMzYsXG4gICdza2VpbjUxMi0xODQnOiAweGIzMzcsXG4gICdza2VpbjUxMi0xOTInOiAweGIzMzgsXG4gICdza2VpbjUxMi0yMDAnOiAweGIzMzksXG4gICdza2VpbjUxMi0yMDgnOiAweGIzM2EsXG4gICdza2VpbjUxMi0yMTYnOiAweGIzM2IsXG4gICdza2VpbjUxMi0yMjQnOiAweGIzM2MsXG4gICdza2VpbjUxMi0yMzInOiAweGIzM2QsXG4gICdza2VpbjUxMi0yNDAnOiAweGIzM2UsXG4gICdza2VpbjUxMi0yNDgnOiAweGIzM2YsXG4gICdza2VpbjUxMi0yNTYnOiAweGIzNDAsXG4gICdza2VpbjUxMi0yNjQnOiAweGIzNDEsXG4gICdza2VpbjUxMi0yNzInOiAweGIzNDIsXG4gICdza2VpbjUxMi0yODAnOiAweGIzNDMsXG4gICdza2VpbjUxMi0yODgnOiAweGIzNDQsXG4gICdza2VpbjUxMi0yOTYnOiAweGIzNDUsXG4gICdza2VpbjUxMi0zMDQnOiAweGIzNDYsXG4gICdza2VpbjUxMi0zMTInOiAweGIzNDcsXG4gICdza2VpbjUxMi0zMjAnOiAweGIzNDgsXG4gICdza2VpbjUxMi0zMjgnOiAweGIzNDksXG4gICdza2VpbjUxMi0zMzYnOiAweGIzNGEsXG4gICdza2VpbjUxMi0zNDQnOiAweGIzNGIsXG4gICdza2VpbjUxMi0zNTInOiAweGIzNGMsXG4gICdza2VpbjUxMi0zNjAnOiAweGIzNGQsXG4gICdza2VpbjUxMi0zNjgnOiAweGIzNGUsXG4gICdza2VpbjUxMi0zNzYnOiAweGIzNGYsXG4gICdza2VpbjUxMi0zODQnOiAweGIzNTAsXG4gICdza2VpbjUxMi0zOTInOiAweGIzNTEsXG4gICdza2VpbjUxMi00MDAnOiAweGIzNTIsXG4gICdza2VpbjUxMi00MDgnOiAweGIzNTMsXG4gICdza2VpbjUxMi00MTYnOiAweGIzNTQsXG4gICdza2VpbjUxMi00MjQnOiAweGIzNTUsXG4gICdza2VpbjUxMi00MzInOiAweGIzNTYsXG4gICdza2VpbjUxMi00NDAnOiAweGIzNTcsXG4gICdza2VpbjUxMi00NDgnOiAweGIzNTgsXG4gICdza2VpbjUxMi00NTYnOiAweGIzNTksXG4gICdza2VpbjUxMi00NjQnOiAweGIzNWEsXG4gICdza2VpbjUxMi00NzInOiAweGIzNWIsXG4gICdza2VpbjUxMi00ODAnOiAweGIzNWMsXG4gICdza2VpbjUxMi00ODgnOiAweGIzNWQsXG4gICdza2VpbjUxMi00OTYnOiAweGIzNWUsXG4gICdza2VpbjUxMi01MDQnOiAweGIzNWYsXG4gICdza2VpbjUxMi01MTInOiAweGIzNjAsXG4gICdza2VpbjEwMjQtOCc6IDB4YjM2MSxcbiAgJ3NrZWluMTAyNC0xNic6IDB4YjM2MixcbiAgJ3NrZWluMTAyNC0yNCc6IDB4YjM2MyxcbiAgJ3NrZWluMTAyNC0zMic6IDB4YjM2NCxcbiAgJ3NrZWluMTAyNC00MCc6IDB4YjM2NSxcbiAgJ3NrZWluMTAyNC00OCc6IDB4YjM2NixcbiAgJ3NrZWluMTAyNC01Nic6IDB4YjM2NyxcbiAgJ3NrZWluMTAyNC02NCc6IDB4YjM2OCxcbiAgJ3NrZWluMTAyNC03Mic6IDB4YjM2OSxcbiAgJ3NrZWluMTAyNC04MCc6IDB4YjM2YSxcbiAgJ3NrZWluMTAyNC04OCc6IDB4YjM2YixcbiAgJ3NrZWluMTAyNC05Nic6IDB4YjM2YyxcbiAgJ3NrZWluMTAyNC0xMDQnOiAweGIzNmQsXG4gICdza2VpbjEwMjQtMTEyJzogMHhiMzZlLFxuICAnc2tlaW4xMDI0LTEyMCc6IDB4YjM2ZixcbiAgJ3NrZWluMTAyNC0xMjgnOiAweGIzNzAsXG4gICdza2VpbjEwMjQtMTM2JzogMHhiMzcxLFxuICAnc2tlaW4xMDI0LTE0NCc6IDB4YjM3MixcbiAgJ3NrZWluMTAyNC0xNTInOiAweGIzNzMsXG4gICdza2VpbjEwMjQtMTYwJzogMHhiMzc0LFxuICAnc2tlaW4xMDI0LTE2OCc6IDB4YjM3NSxcbiAgJ3NrZWluMTAyNC0xNzYnOiAweGIzNzYsXG4gICdza2VpbjEwMjQtMTg0JzogMHhiMzc3LFxuICAnc2tlaW4xMDI0LTE5Mic6IDB4YjM3OCxcbiAgJ3NrZWluMTAyNC0yMDAnOiAweGIzNzksXG4gICdza2VpbjEwMjQtMjA4JzogMHhiMzdhLFxuICAnc2tlaW4xMDI0LTIxNic6IDB4YjM3YixcbiAgJ3NrZWluMTAyNC0yMjQnOiAweGIzN2MsXG4gICdza2VpbjEwMjQtMjMyJzogMHhiMzdkLFxuICAnc2tlaW4xMDI0LTI0MCc6IDB4YjM3ZSxcbiAgJ3NrZWluMTAyNC0yNDgnOiAweGIzN2YsXG4gICdza2VpbjEwMjQtMjU2JzogMHhiMzgwLFxuICAnc2tlaW4xMDI0LTI2NCc6IDB4YjM4MSxcbiAgJ3NrZWluMTAyNC0yNzInOiAweGIzODIsXG4gICdza2VpbjEwMjQtMjgwJzogMHhiMzgzLFxuICAnc2tlaW4xMDI0LTI4OCc6IDB4YjM4NCxcbiAgJ3NrZWluMTAyNC0yOTYnOiAweGIzODUsXG4gICdza2VpbjEwMjQtMzA0JzogMHhiMzg2LFxuICAnc2tlaW4xMDI0LTMxMic6IDB4YjM4NyxcbiAgJ3NrZWluMTAyNC0zMjAnOiAweGIzODgsXG4gICdza2VpbjEwMjQtMzI4JzogMHhiMzg5LFxuICAnc2tlaW4xMDI0LTMzNic6IDB4YjM4YSxcbiAgJ3NrZWluMTAyNC0zNDQnOiAweGIzOGIsXG4gICdza2VpbjEwMjQtMzUyJzogMHhiMzhjLFxuICAnc2tlaW4xMDI0LTM2MCc6IDB4YjM4ZCxcbiAgJ3NrZWluMTAyNC0zNjgnOiAweGIzOGUsXG4gICdza2VpbjEwMjQtMzc2JzogMHhiMzhmLFxuICAnc2tlaW4xMDI0LTM4NCc6IDB4YjM5MCxcbiAgJ3NrZWluMTAyNC0zOTInOiAweGIzOTEsXG4gICdza2VpbjEwMjQtNDAwJzogMHhiMzkyLFxuICAnc2tlaW4xMDI0LTQwOCc6IDB4YjM5MyxcbiAgJ3NrZWluMTAyNC00MTYnOiAweGIzOTQsXG4gICdza2VpbjEwMjQtNDI0JzogMHhiMzk1LFxuICAnc2tlaW4xMDI0LTQzMic6IDB4YjM5NixcbiAgJ3NrZWluMTAyNC00NDAnOiAweGIzOTcsXG4gICdza2VpbjEwMjQtNDQ4JzogMHhiMzk4LFxuICAnc2tlaW4xMDI0LTQ1Nic6IDB4YjM5OSxcbiAgJ3NrZWluMTAyNC00NjQnOiAweGIzOWEsXG4gICdza2VpbjEwMjQtNDcyJzogMHhiMzliLFxuICAnc2tlaW4xMDI0LTQ4MCc6IDB4YjM5YyxcbiAgJ3NrZWluMTAyNC00ODgnOiAweGIzOWQsXG4gICdza2VpbjEwMjQtNDk2JzogMHhiMzllLFxuICAnc2tlaW4xMDI0LTUwNCc6IDB4YjM5ZixcbiAgJ3NrZWluMTAyNC01MTInOiAweGIzYTAsXG4gICdza2VpbjEwMjQtNTIwJzogMHhiM2ExLFxuICAnc2tlaW4xMDI0LTUyOCc6IDB4YjNhMixcbiAgJ3NrZWluMTAyNC01MzYnOiAweGIzYTMsXG4gICdza2VpbjEwMjQtNTQ0JzogMHhiM2E0LFxuICAnc2tlaW4xMDI0LTU1Mic6IDB4YjNhNSxcbiAgJ3NrZWluMTAyNC01NjAnOiAweGIzYTYsXG4gICdza2VpbjEwMjQtNTY4JzogMHhiM2E3LFxuICAnc2tlaW4xMDI0LTU3Nic6IDB4YjNhOCxcbiAgJ3NrZWluMTAyNC01ODQnOiAweGIzYTksXG4gICdza2VpbjEwMjQtNTkyJzogMHhiM2FhLFxuICAnc2tlaW4xMDI0LTYwMCc6IDB4YjNhYixcbiAgJ3NrZWluMTAyNC02MDgnOiAweGIzYWMsXG4gICdza2VpbjEwMjQtNjE2JzogMHhiM2FkLFxuICAnc2tlaW4xMDI0LTYyNCc6IDB4YjNhZSxcbiAgJ3NrZWluMTAyNC02MzInOiAweGIzYWYsXG4gICdza2VpbjEwMjQtNjQwJzogMHhiM2IwLFxuICAnc2tlaW4xMDI0LTY0OCc6IDB4YjNiMSxcbiAgJ3NrZWluMTAyNC02NTYnOiAweGIzYjIsXG4gICdza2VpbjEwMjQtNjY0JzogMHhiM2IzLFxuICAnc2tlaW4xMDI0LTY3Mic6IDB4YjNiNCxcbiAgJ3NrZWluMTAyNC02ODAnOiAweGIzYjUsXG4gICdza2VpbjEwMjQtNjg4JzogMHhiM2I2LFxuICAnc2tlaW4xMDI0LTY5Nic6IDB4YjNiNyxcbiAgJ3NrZWluMTAyNC03MDQnOiAweGIzYjgsXG4gICdza2VpbjEwMjQtNzEyJzogMHhiM2I5LFxuICAnc2tlaW4xMDI0LTcyMCc6IDB4YjNiYSxcbiAgJ3NrZWluMTAyNC03MjgnOiAweGIzYmIsXG4gICdza2VpbjEwMjQtNzM2JzogMHhiM2JjLFxuICAnc2tlaW4xMDI0LTc0NCc6IDB4YjNiZCxcbiAgJ3NrZWluMTAyNC03NTInOiAweGIzYmUsXG4gICdza2VpbjEwMjQtNzYwJzogMHhiM2JmLFxuICAnc2tlaW4xMDI0LTc2OCc6IDB4YjNjMCxcbiAgJ3NrZWluMTAyNC03NzYnOiAweGIzYzEsXG4gICdza2VpbjEwMjQtNzg0JzogMHhiM2MyLFxuICAnc2tlaW4xMDI0LTc5Mic6IDB4YjNjMyxcbiAgJ3NrZWluMTAyNC04MDAnOiAweGIzYzQsXG4gICdza2VpbjEwMjQtODA4JzogMHhiM2M1LFxuICAnc2tlaW4xMDI0LTgxNic6IDB4YjNjNixcbiAgJ3NrZWluMTAyNC04MjQnOiAweGIzYzcsXG4gICdza2VpbjEwMjQtODMyJzogMHhiM2M4LFxuICAnc2tlaW4xMDI0LTg0MCc6IDB4YjNjOSxcbiAgJ3NrZWluMTAyNC04NDgnOiAweGIzY2EsXG4gICdza2VpbjEwMjQtODU2JzogMHhiM2NiLFxuICAnc2tlaW4xMDI0LTg2NCc6IDB4YjNjYyxcbiAgJ3NrZWluMTAyNC04NzInOiAweGIzY2QsXG4gICdza2VpbjEwMjQtODgwJzogMHhiM2NlLFxuICAnc2tlaW4xMDI0LTg4OCc6IDB4YjNjZixcbiAgJ3NrZWluMTAyNC04OTYnOiAweGIzZDAsXG4gICdza2VpbjEwMjQtOTA0JzogMHhiM2QxLFxuICAnc2tlaW4xMDI0LTkxMic6IDB4YjNkMixcbiAgJ3NrZWluMTAyNC05MjAnOiAweGIzZDMsXG4gICdza2VpbjEwMjQtOTI4JzogMHhiM2Q0LFxuICAnc2tlaW4xMDI0LTkzNic6IDB4YjNkNSxcbiAgJ3NrZWluMTAyNC05NDQnOiAweGIzZDYsXG4gICdza2VpbjEwMjQtOTUyJzogMHhiM2Q3LFxuICAnc2tlaW4xMDI0LTk2MCc6IDB4YjNkOCxcbiAgJ3NrZWluMTAyNC05NjgnOiAweGIzZDksXG4gICdza2VpbjEwMjQtOTc2JzogMHhiM2RhLFxuICAnc2tlaW4xMDI0LTk4NCc6IDB4YjNkYixcbiAgJ3NrZWluMTAyNC05OTInOiAweGIzZGMsXG4gICdza2VpbjEwMjQtMTAwMCc6IDB4YjNkZCxcbiAgJ3NrZWluMTAyNC0xMDA4JzogMHhiM2RlLFxuICAnc2tlaW4xMDI0LTEwMTYnOiAweGIzZGYsXG4gICdza2VpbjEwMjQtMTAyNCc6IDB4YjNlMCxcbiAgJ3Bvc2VpZG9uLWJsczEyXzM4MS1hMi1mYzEnOiAweGI0MDEsXG4gICdwb3NlaWRvbi1ibHMxMl8zODEtYTItZmMxLXNjJzogMHhiNDAyLFxuICAnemVyb3hjZXJ0LWltcHJpbnQtMjU2JzogMHhjZTExLFxuICAnZmlsLWNvbW1pdG1lbnQtdW5zZWFsZWQnOiAweGYxMDEsXG4gICdmaWwtY29tbWl0bWVudC1zZWFsZWQnOiAweGYxMDIsXG4gICdob2xvY2hhaW4tYWRyLXYwJzogMHg4MDcxMjQsXG4gICdob2xvY2hhaW4tYWRyLXYxJzogMHg4MTcxMjQsXG4gICdob2xvY2hhaW4ta2V5LXYwJzogMHg5NDcxMjQsXG4gICdob2xvY2hhaW4ta2V5LXYxJzogMHg5NTcxMjQsXG4gICdob2xvY2hhaW4tc2lnLXYwJzogMHhhMjcxMjQsXG4gICdob2xvY2hhaW4tc2lnLXYxJzogMHhhMzcxMjQsXG4gICdza3luZXQtbnMnOiAweGIxOTkxMFxufSlcblxubW9kdWxlLmV4cG9ydHMgPSB7IGJhc2VUYWJsZSB9XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlYWRcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgICAgPSAwXG4gICAgLCBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgICwgc2hpZnQgID0gMFxuICAgICwgY291bnRlciA9IG9mZnNldFxuICAgICwgYlxuICAgICwgbCA9IGJ1Zi5sZW5ndGhcblxuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCB8fCBzaGlmdCA+IDQ5KSB7XG4gICAgICByZWFkLmJ5dGVzID0gMFxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50JylcbiAgICB9XG4gICAgYiA9IGJ1Zltjb3VudGVyKytdXG4gICAgcmVzICs9IHNoaWZ0IDwgMjhcbiAgICAgID8gKGIgJiBSRVNUKSA8PCBzaGlmdFxuICAgICAgOiAoYiAmIFJFU1QpICogTWF0aC5wb3coMiwgc2hpZnQpXG4gICAgc2hpZnQgKz0gN1xuICB9IHdoaWxlIChiID49IE1TQilcblxuICByZWFkLmJ5dGVzID0gY291bnRlciAtIG9mZnNldFxuXG4gIHJldHVybiByZXNcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZW5jb2RlXG5cbnZhciBNU0IgPSAweDgwXG4gICwgUkVTVCA9IDB4N0ZcbiAgLCBNU0JBTEwgPSB+UkVTVFxuICAsIElOVCA9IE1hdGgucG93KDIsIDMxKVxuXG5mdW5jdGlvbiBlbmNvZGUobnVtLCBvdXQsIG9mZnNldCkge1xuICBpZiAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgJiYgbnVtID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICBlbmNvZGUuYnl0ZXMgPSAwXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBlbmNvZGUgdmFyaW50JylcbiAgfVxuICBvdXQgPSBvdXQgfHwgW11cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuXG4gIHdoaWxlKG51bSA+PSBJTlQpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCXG4gICAgbnVtIC89IDEyOFxuICB9XG4gIHdoaWxlKG51bSAmIE1TQkFMTCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0JcbiAgICBudW0gPj4+PSA3XG4gIH1cbiAgb3V0W29mZnNldF0gPSBudW0gfCAwXG4gIFxuICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXQgKyAxXG4gIFxuICByZXR1cm4gb3V0XG59XG4iLCJcbnZhciBOMSA9IE1hdGgucG93KDIsICA3KVxudmFyIE4yID0gTWF0aC5wb3coMiwgMTQpXG52YXIgTjMgPSBNYXRoLnBvdygyLCAyMSlcbnZhciBONCA9IE1hdGgucG93KDIsIDI4KVxudmFyIE41ID0gTWF0aC5wb3coMiwgMzUpXG52YXIgTjYgPSBNYXRoLnBvdygyLCA0MilcbnZhciBONyA9IE1hdGgucG93KDIsIDQ5KVxudmFyIE44ID0gTWF0aC5wb3coMiwgNTYpXG52YXIgTjkgPSBNYXRoLnBvdygyLCA2MylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA8IE4xID8gMVxuICA6IHZhbHVlIDwgTjIgPyAyXG4gIDogdmFsdWUgPCBOMyA/IDNcbiAgOiB2YWx1ZSA8IE40ID8gNFxuICA6IHZhbHVlIDwgTjUgPyA1XG4gIDogdmFsdWUgPCBONiA/IDZcbiAgOiB2YWx1ZSA8IE43ID8gN1xuICA6IHZhbHVlIDwgTjggPyA4XG4gIDogdmFsdWUgPCBOOSA/IDlcbiAgOiAgICAgICAgICAgICAgMTBcbiAgKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkNvZGVjRmFjdG9yeX0gQ29kZWNGYWN0b3J5ICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0XG4gKiBAcGFyYW0ge251bWJlcn0gYml0c1BlckNoYXJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBkZWNvZGUgPSAoc3RyaW5nLCBhbHBoYWJldCwgYml0c1BlckNoYXIpID0+IHtcbiAgLy8gQnVpbGQgdGhlIGNoYXJhY3RlciBsb29rdXAgdGFibGU6XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgbnVtYmVyPn0gKi9cbiAgY29uc3QgY29kZXMgPSB7fVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29kZXNbYWxwaGFiZXRbaV1dID0gaVxuICB9XG5cbiAgLy8gQ291bnQgdGhlIHBhZGRpbmcgYnl0ZXM6XG4gIGxldCBlbmQgPSBzdHJpbmcubGVuZ3RoXG4gIHdoaWxlIChzdHJpbmdbZW5kIC0gMV0gPT09ICc9Jykge1xuICAgIC0tZW5kXG4gIH1cblxuICAvLyBBbGxvY2F0ZSB0aGUgb3V0cHV0OlxuICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSgoZW5kICogYml0c1BlckNoYXIgLyA4KSB8IDApXG5cbiAgLy8gUGFyc2UgdGhlIGRhdGE6XG4gIGxldCBiaXRzID0gMCAvLyBOdW1iZXIgb2YgYml0cyBjdXJyZW50bHkgaW4gdGhlIGJ1ZmZlclxuICBsZXQgYnVmZmVyID0gMCAvLyBCaXRzIHdhaXRpbmcgdG8gYmUgd3JpdHRlbiBvdXQsIE1TQiBmaXJzdFxuICBsZXQgd3JpdHRlbiA9IDAgLy8gTmV4dCBieXRlIHRvIHdyaXRlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kOyArK2kpIHtcbiAgICAvLyBSZWFkIG9uZSBjaGFyYWN0ZXIgZnJvbSB0aGUgc3RyaW5nOlxuICAgIGNvbnN0IHZhbHVlID0gY29kZXNbc3RyaW5nW2ldXVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyICcgKyBzdHJpbmdbaV0pXG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIHRoZSBiaXRzIHRvIHRoZSBidWZmZXI6XG4gICAgYnVmZmVyID0gKGJ1ZmZlciA8PCBiaXRzUGVyQ2hhcikgfCB2YWx1ZVxuICAgIGJpdHMgKz0gYml0c1BlckNoYXJcblxuICAgIC8vIFdyaXRlIG91dCBzb21lIGJpdHMgaWYgdGhlIGJ1ZmZlciBoYXMgYSBieXRlJ3Mgd29ydGg6XG4gICAgaWYgKGJpdHMgPj0gOCkge1xuICAgICAgYml0cyAtPSA4XG4gICAgICBvdXRbd3JpdHRlbisrXSA9IDB4ZmYgJiAoYnVmZmVyID4+IGJpdHMpXG4gICAgfVxuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgd2UgaGF2ZSByZWNlaXZlZCBqdXN0IGVub3VnaCBiaXRzOlxuICBpZiAoYml0cyA+PSBiaXRzUGVyQ2hhciB8fCAweGZmICYgKGJ1ZmZlciA8PCAoOCAtIGJpdHMpKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZGF0YScpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgZW5jb2RlID0gKGRhdGEsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcikgPT4ge1xuICBjb25zdCBwYWQgPSBhbHBoYWJldFthbHBoYWJldC5sZW5ndGggLSAxXSA9PT0gJz0nXG4gIGNvbnN0IG1hc2sgPSAoMSA8PCBiaXRzUGVyQ2hhcikgLSAxXG4gIGxldCBvdXQgPSAnJ1xuXG4gIGxldCBiaXRzID0gMCAvLyBOdW1iZXIgb2YgYml0cyBjdXJyZW50bHkgaW4gdGhlIGJ1ZmZlclxuICBsZXQgYnVmZmVyID0gMCAvLyBCaXRzIHdhaXRpbmcgdG8gYmUgd3JpdHRlbiBvdXQsIE1TQiBmaXJzdFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBTbHVycCBkYXRhIGludG8gdGhlIGJ1ZmZlcjpcbiAgICBidWZmZXIgPSAoYnVmZmVyIDw8IDgpIHwgZGF0YVtpXVxuICAgIGJpdHMgKz0gOFxuXG4gICAgLy8gV3JpdGUgb3V0IGFzIG11Y2ggYXMgd2UgY2FuOlxuICAgIHdoaWxlIChiaXRzID4gYml0c1BlckNoYXIpIHtcbiAgICAgIGJpdHMgLT0gYml0c1BlckNoYXJcbiAgICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgKGJ1ZmZlciA+PiBiaXRzKV1cbiAgICB9XG4gIH1cblxuICAvLyBQYXJ0aWFsIGNoYXJhY3RlcjpcbiAgaWYgKGJpdHMpIHtcbiAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIChidWZmZXIgPDwgKGJpdHNQZXJDaGFyIC0gYml0cykpXVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmcgY2hhcmFjdGVycyB1bnRpbCB3ZSBoaXQgYSBieXRlIGJvdW5kYXJ5OlxuICBpZiAocGFkKSB7XG4gICAgd2hpbGUgKChvdXQubGVuZ3RoICogYml0c1BlckNoYXIpICYgNykge1xuICAgICAgb3V0ICs9ICc9J1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBSRkM0NjQ4IEZhY3RvcnlcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYml0c1BlckNoYXJcbiAqIEByZXR1cm5zIHtDb2RlY0ZhY3Rvcnl9XG4gKi9cbmNvbnN0IHJmYzQ2NDggPSAoYml0c1BlckNoYXIpID0+IChhbHBoYWJldCkgPT4ge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGVuY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGRlY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBkZWNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHJmYzQ2NDggfVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZW5jb2RlVGV4dCB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQ29kZWNGYWN0b3J5fSBDb2RlY0ZhY3RvcnkgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXyhcIi4vdHlwZXNcIikuQmFzZU5hbWV9IEJhc2VOYW1lICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oXCIuL3R5cGVzXCIpLkJhc2VDb2RlfSBCYXNlQ29kZSAqL1xuXG4vKipcbiAqIENsYXNzIHRvIGVuY29kZS9kZWNvZGUgaW4gdGhlIHN1cHBvcnRlZCBCYXNlc1xuICpcbiAqL1xuY2xhc3MgQmFzZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jhc2VOYW1lfSBuYW1lXG4gICAqIEBwYXJhbSB7QmFzZUNvZGV9IGNvZGVcbiAgICogQHBhcmFtIHtDb2RlY0ZhY3Rvcnl9IGZhY3RvcnlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAobmFtZSwgY29kZSwgZmFjdG9yeSwgYWxwaGFiZXQpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5jb2RlID0gY29kZVxuICAgIHRoaXMuY29kZUJ1ZiA9IGVuY29kZVRleHQodGhpcy5jb2RlKVxuICAgIHRoaXMuYWxwaGFiZXQgPSBhbHBoYWJldFxuICAgIHRoaXMuY29kZWMgPSBmYWN0b3J5KGFscGhhYmV0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBlbmNvZGUgKGJ1Zikge1xuICAgIHJldHVybiB0aGlzLmNvZGVjLmVuY29kZShidWYpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICovXG4gIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgZm9yIChjb25zdCBjaGFyIG9mIHN0cmluZykge1xuICAgICAgaWYgKHRoaXMuYWxwaGFiZXQgJiYgdGhpcy5hbHBoYWJldC5pbmRleE9mKGNoYXIpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgY2hhcmFjdGVyICcke2NoYXJ9JyBpbiAnJHtzdHJpbmd9J2ApXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvZGVjLmRlY29kZShzdHJpbmcpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlXG4iLCIndXNlIHN0cmljdCdcbi8vIGJhc2UteCBlbmNvZGluZyAvIGRlY29kaW5nXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTggYmFzZS14IGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTggVGhlIEJpdGNvaW4gQ29yZSBkZXZlbG9wZXJzIChiYXNlNTguY3BwKVxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBMSUNFTlNFIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuZnVuY3Rpb24gYmFzZSAoQUxQSEFCRVQpIHtcbiAgaWYgKEFMUEhBQkVULmxlbmd0aCA+PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxwaGFiZXQgdG9vIGxvbmcnKSB9XG4gIHZhciBCQVNFX01BUCA9IG5ldyBVaW50OEFycmF5KDI1NilcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBCQVNFX01BUC5sZW5ndGg7IGorKykge1xuICAgIEJBU0VfTUFQW2pdID0gMjU1XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KGkpXG4gICAgdmFyIHhjID0geC5jaGFyQ29kZUF0KDApXG4gICAgaWYgKEJBU0VfTUFQW3hjXSAhPT0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgYW1iaWd1b3VzJykgfVxuICAgIEJBU0VfTUFQW3hjXSA9IGlcbiAgfVxuICB2YXIgQkFTRSA9IEFMUEhBQkVULmxlbmd0aFxuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApXG4gIHZhciBGQUNUT1IgPSBNYXRoLmxvZyhCQVNFKSAvIE1hdGgubG9nKDI1NikgLy8gbG9nKEJBU0UpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXBcbiAgdmFyIGlGQUNUT1IgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2coQkFTRSkgLy8gbG9nKDI1NikgLyBsb2coQkFTRSksIHJvdW5kZWQgdXBcbiAgZnVuY3Rpb24gZW5jb2RlIChzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlID0gVWludDhBcnJheS5mcm9tKHNvdXJjZSlcbiAgICB9XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJycgfVxuICAgICAgICAvLyBTa2lwICYgY291bnQgbGVhZGluZyB6ZXJvZXMuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHZhciBwYmVnaW4gPSAwXG4gICAgdmFyIHBlbmQgPSBzb3VyY2UubGVuZ3RoXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCAmJiBzb3VyY2VbcGJlZ2luXSA9PT0gMCkge1xuICAgICAgcGJlZ2luKytcbiAgICAgIHplcm9lcysrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlNTggcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKHBlbmQgLSBwYmVnaW4pICogaUZBQ1RPUiArIDEpID4+PiAwXG4gICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGJ5dGVzLlxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtwYmVnaW5dXG4gICAgICAgICAgICAvLyBBcHBseSBcImI1OCA9IGI1OCAqIDI1NiArIGNoXCIuXG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MSAhPT0gLTEpOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9ICgyNTYgKiBiNThbaXQxXSkgPj4+IDBcbiAgICAgICAgYjU4W2l0MV0gPSAoY2FycnkgJSBCQVNFKSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBiZWdpbisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGJhc2U1OCByZXN1bHQuXG4gICAgdmFyIGl0MiA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICBpdDIrK1xuICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIHRoZSByZXN1bHQgaW50byBhIHN0cmluZy5cbiAgICB2YXIgc3RyID0gTEVBREVSLnJlcGVhdCh6ZXJvZXMpXG4gICAgZm9yICg7IGl0MiA8IHNpemU7ICsraXQyKSB7IHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoYjU4W2l0Ml0pIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgU3RyaW5nJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiBuZXcgVWludDhBcnJheSgpIH1cbiAgICB2YXIgcHN6ID0gMFxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgc3BhY2VzLlxuICAgIGlmIChzb3VyY2VbcHN6XSA9PT0gJyAnKSB7IHJldHVybiB9XG4gICAgICAgIC8vIFNraXAgYW5kIGNvdW50IGxlYWRpbmcgJzEncy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTI1NiByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgoKHNvdXJjZS5sZW5ndGggLSBwc3opICogRkFDVE9SKSArIDEpID4+PiAwIC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGNoYXJhY3RlcnMuXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdKSB7XG4gICAgICAgICAgICAvLyBEZWNvZGUgY2hhcmFjdGVyXG4gICAgICB2YXIgY2FycnkgPSBCQVNFX01BUFtzb3VyY2UuY2hhckNvZGVBdChwc3opXVxuICAgICAgICAgICAgLy8gSW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7IHJldHVybiB9XG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMFxuICAgICAgICBiMjU2W2l0M10gPSAoY2FycnkgJSAyNTYpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gMjU2KSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCB0cmFpbGluZyBzcGFjZXMuXG4gICAgaWYgKHNvdXJjZVtwc3pdID09PSAnICcpIHsgcmV0dXJuIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiMjU2LlxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrXG4gICAgfVxuICAgIHZhciB2Y2ggPSBuZXcgVWludDhBcnJheSh6ZXJvZXMgKyAoc2l6ZSAtIGl0NCkpXG4gICAgdmFyIGogPSB6ZXJvZXNcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdXG4gICAgfVxuICAgIHJldHVybiB2Y2hcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIHZhciBidWZmZXIgPSBkZWNvZGVVbnNhZmUoc3RyaW5nKVxuICAgIGlmIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlciB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlXG4iLCIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQ29kZWNGYWN0b3J5fSBDb2RlY0ZhY3RvcnkgKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGRlY29kZSA9IChzdHJpbmcsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcikgPT4ge1xuICAvLyBCdWlsZCB0aGUgY2hhcmFjdGVyIGxvb2t1cCB0YWJsZTpcbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fSAqL1xuICBjb25zdCBjb2RlcyA9IHt9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb2Rlc1thbHBoYWJldFtpXV0gPSBpXG4gIH1cblxuICAvLyBDb3VudCB0aGUgcGFkZGluZyBieXRlczpcbiAgbGV0IGVuZCA9IHN0cmluZy5sZW5ndGhcbiAgd2hpbGUgKHN0cmluZ1tlbmQgLSAxXSA9PT0gJz0nKSB7XG4gICAgLS1lbmRcbiAgfVxuXG4gIC8vIEFsbG9jYXRlIHRoZSBvdXRwdXQ6XG4gIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KChlbmQgKiBiaXRzUGVyQ2hhciAvIDgpIHwgMClcblxuICAvLyBQYXJzZSB0aGUgZGF0YTpcbiAgbGV0IGJpdHMgPSAwIC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gIGxldCBidWZmZXIgPSAwIC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gIGxldCB3cml0dGVuID0gMCAvLyBOZXh0IGJ5dGUgdG8gd3JpdGVcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7ICsraSkge1xuICAgIC8vIFJlYWQgb25lIGNoYXJhY3RlciBmcm9tIHRoZSBzdHJpbmc6XG4gICAgY29uc3QgdmFsdWUgPSBjb2Rlc1tzdHJpbmdbaV1dXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgJyArIHN0cmluZ1tpXSlcbiAgICB9XG5cbiAgICAvLyBBcHBlbmQgdGhlIGJpdHMgdG8gdGhlIGJ1ZmZlcjpcbiAgICBidWZmZXIgPSAoYnVmZmVyIDw8IGJpdHNQZXJDaGFyKSB8IHZhbHVlXG4gICAgYml0cyArPSBiaXRzUGVyQ2hhclxuXG4gICAgLy8gV3JpdGUgb3V0IHNvbWUgYml0cyBpZiB0aGUgYnVmZmVyIGhhcyBhIGJ5dGUncyB3b3J0aDpcbiAgICBpZiAoYml0cyA+PSA4KSB7XG4gICAgICBiaXRzIC09IDhcbiAgICAgIG91dFt3cml0dGVuKytdID0gMHhmZiAmIChidWZmZXIgPj4gYml0cylcbiAgICB9XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCB3ZSBoYXZlIHJlY2VpdmVkIGp1c3QgZW5vdWdoIGJpdHM6XG4gIGlmIChiaXRzID49IGJpdHNQZXJDaGFyIHx8IDB4ZmYgJiAoYnVmZmVyIDw8ICg4IC0gYml0cykpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBkYXRhJylcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBlbmNvZGUgPSAoZGF0YSwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKSA9PiB7XG4gIGNvbnN0IHBhZCA9IGFscGhhYmV0W2FscGhhYmV0Lmxlbmd0aCAtIDFdID09PSAnPSdcbiAgY29uc3QgbWFzayA9ICgxIDw8IGJpdHNQZXJDaGFyKSAtIDFcbiAgbGV0IG91dCA9ICcnXG5cbiAgbGV0IGJpdHMgPSAwIC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gIGxldCBidWZmZXIgPSAwIC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIC8vIFNsdXJwIGRhdGEgaW50byB0aGUgYnVmZmVyOlxuICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgOCkgfCBkYXRhW2ldXG4gICAgYml0cyArPSA4XG5cbiAgICAvLyBXcml0ZSBvdXQgYXMgbXVjaCBhcyB3ZSBjYW46XG4gICAgd2hpbGUgKGJpdHMgPiBiaXRzUGVyQ2hhcikge1xuICAgICAgYml0cyAtPSBiaXRzUGVyQ2hhclxuICAgICAgb3V0ICs9IGFscGhhYmV0W21hc2sgJiAoYnVmZmVyID4+IGJpdHMpXVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnRpYWwgY2hhcmFjdGVyOlxuICBpZiAoYml0cykge1xuICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgKGJ1ZmZlciA8PCAoYml0c1BlckNoYXIgLSBiaXRzKSldXG4gIH1cblxuICAvLyBBZGQgcGFkZGluZyBjaGFyYWN0ZXJzIHVudGlsIHdlIGhpdCBhIGJ5dGUgYm91bmRhcnk6XG4gIGlmIChwYWQpIHtcbiAgICB3aGlsZSAoKG91dC5sZW5ndGggKiBiaXRzUGVyQ2hhcikgJiA3KSB7XG4gICAgICBvdXQgKz0gJz0nXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIFJGQzQ2NDggRmFjdG9yeVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHJldHVybnMge0NvZGVjRmFjdG9yeX1cbiAqL1xuY29uc3QgcmZjNDY0OCA9IChiaXRzUGVyQ2hhcikgPT4gKGFscGhhYmV0KSA9PiB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZW5jb2RlIChpbnB1dCkge1xuICAgICAgcmV0dXJuIGVuY29kZShpbnB1dCwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZGVjb2RlIChpbnB1dCkge1xuICAgICAgcmV0dXJuIGRlY29kZShpbnB1dCwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgcmZjNDY0OCB9XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBlbmNvZGVUZXh0IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5Db2RlY0ZhY3Rvcnl9IENvZGVjRmFjdG9yeSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKFwiLi90eXBlc1wiKS5CYXNlTmFtZX0gQmFzZU5hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXyhcIi4vdHlwZXNcIikuQmFzZUNvZGV9IEJhc2VDb2RlICovXG5cbi8qKlxuICogQ2xhc3MgdG8gZW5jb2RlL2RlY29kZSBpbiB0aGUgc3VwcG9ydGVkIEJhc2VzXG4gKlxuICovXG5jbGFzcyBCYXNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QmFzZU5hbWV9IG5hbWVcbiAgICogQHBhcmFtIHtCYXNlQ29kZX0gY29kZVxuICAgKiBAcGFyYW0ge0NvZGVjRmFjdG9yeX0gZmFjdG9yeVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChuYW1lLCBjb2RlLCBmYWN0b3J5LCBhbHBoYWJldCkge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gICAgdGhpcy5jb2RlQnVmID0gZW5jb2RlVGV4dCh0aGlzLmNvZGUpXG4gICAgdGhpcy5hbHBoYWJldCA9IGFscGhhYmV0XG4gICAgdGhpcy5jb2RlYyA9IGZhY3RvcnkoYWxwaGFiZXQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGVuY29kZSAoYnVmKSB7XG4gICAgcmV0dXJuIHRoaXMuY29kZWMuZW5jb2RlKGJ1ZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cbiAgZGVjb2RlIChzdHJpbmcpIHtcbiAgICBmb3IgKGNvbnN0IGNoYXIgb2Ygc3RyaW5nKSB7XG4gICAgICBpZiAodGhpcy5hbHBoYWJldCAmJiB0aGlzLmFscGhhYmV0LmluZGV4T2YoY2hhcikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBjaGFyYWN0ZXIgJyR7Y2hhcn0nIGluICcke3N0cmluZ30nYClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29kZWMuZGVjb2RlKHN0cmluZylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VcbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBAdHMtaWdub3JlXG5jb25zdCB7IFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciB9ID0gcmVxdWlyZSgnd2ViLWVuY29kaW5nJylcblxuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld3xBcnJheUJ1ZmZlcn0gYnl0ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGRlY29kZVRleHQgPSAoYnl0ZXMpID0+IHRleHREZWNvZGVyLmRlY29kZShieXRlcylcblxuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZVRleHQgPSAodGV4dCkgPT4gdGV4dEVuY29kZXIuZW5jb2RlKHRleHQpXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBVaW50OEFycmF5IGNyZWF0ZWQgYnkgY29uY2F0ZW5hdGluZyB0aGUgcGFzc2VkIEFycmF5c1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXlMaWtlPG51bWJlcj4+fSBhcnJzXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gY29uY2F0IChhcnJzLCBsZW5ndGgpIHtcbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBsZXQgb2Zmc2V0ID0gMFxuXG4gIGZvciAoY29uc3QgYXJyIG9mIGFycnMpIHtcbiAgICBvdXRwdXQuc2V0KGFyciwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBhcnIubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBkZWNvZGVUZXh0LCBlbmNvZGVUZXh0LCBjb25jYXQgfVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJheGlvc1wiLFxuICBcInZlcnNpb25cIjogXCIwLjIxLjRcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlByb21pc2UgYmFzZWQgSFRUUCBjbGllbnQgZm9yIHRoZSBicm93c2VyIGFuZCBub2RlLmpzXCIsXG4gIFwibWFpblwiOiBcImluZGV4LmpzXCIsXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwiZ3J1bnQgdGVzdFwiLFxuICAgIFwic3RhcnRcIjogXCJub2RlIC4vc2FuZGJveC9zZXJ2ZXIuanNcIixcbiAgICBcImJ1aWxkXCI6IFwiTk9ERV9FTlY9cHJvZHVjdGlvbiBncnVudCBidWlsZFwiLFxuICAgIFwicHJldmVyc2lvblwiOiBcIm5wbSB0ZXN0XCIsXG4gICAgXCJ2ZXJzaW9uXCI6IFwibnBtIHJ1biBidWlsZCAmJiBncnVudCB2ZXJzaW9uICYmIGdpdCBhZGQgLUEgZGlzdCAmJiBnaXQgYWRkIENIQU5HRUxPRy5tZCBib3dlci5qc29uIHBhY2thZ2UuanNvblwiLFxuICAgIFwicG9zdHZlcnNpb25cIjogXCJnaXQgcHVzaCAmJiBnaXQgcHVzaCAtLXRhZ3NcIixcbiAgICBcImV4YW1wbGVzXCI6IFwibm9kZSAuL2V4YW1wbGVzL3NlcnZlci5qc1wiLFxuICAgIFwiY292ZXJhbGxzXCI6IFwiY2F0IGNvdmVyYWdlL2xjb3YuaW5mbyB8IC4vbm9kZV9tb2R1bGVzL2NvdmVyYWxscy9iaW4vY292ZXJhbGxzLmpzXCIsXG4gICAgXCJmaXhcIjogXCJlc2xpbnQgLS1maXggbGliLyoqLyouanNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zLmdpdFwiXG4gIH0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwieGhyXCIsXG4gICAgXCJodHRwXCIsXG4gICAgXCJhamF4XCIsXG4gICAgXCJwcm9taXNlXCIsXG4gICAgXCJub2RlXCJcbiAgXSxcbiAgXCJhdXRob3JcIjogXCJNYXR0IFphYnJpc2tpZVwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9heGlvcy9heGlvcy9pc3N1ZXNcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9heGlvcy1odHRwLmNvbVwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJjb3ZlcmFsbHNcIjogXCJeMy4wLjBcIixcbiAgICBcImVzNi1wcm9taXNlXCI6IFwiXjQuMi40XCIsXG4gICAgXCJncnVudFwiOiBcIl4xLjMuMFwiLFxuICAgIFwiZ3J1bnQtYmFubmVyXCI6IFwiXjAuNi4wXCIsXG4gICAgXCJncnVudC1jbGlcIjogXCJeMS4yLjBcIixcbiAgICBcImdydW50LWNvbnRyaWItY2xlYW5cIjogXCJeMS4xLjBcIixcbiAgICBcImdydW50LWNvbnRyaWItd2F0Y2hcIjogXCJeMS4wLjBcIixcbiAgICBcImdydW50LWVzbGludFwiOiBcIl4yMy4wLjBcIixcbiAgICBcImdydW50LWthcm1hXCI6IFwiXjQuMC4wXCIsXG4gICAgXCJncnVudC1tb2NoYS10ZXN0XCI6IFwiXjAuMTMuM1wiLFxuICAgIFwiZ3J1bnQtdHNcIjogXCJeNi4wLjAtYmV0YS4xOVwiLFxuICAgIFwiZ3J1bnQtd2VicGFja1wiOiBcIl40LjAuMlwiLFxuICAgIFwiaXN0YW5idWwtaW5zdHJ1bWVudGVyLWxvYWRlclwiOiBcIl4xLjAuMFwiLFxuICAgIFwiamFzbWluZS1jb3JlXCI6IFwiXjIuNC4xXCIsXG4gICAgXCJrYXJtYVwiOiBcIl42LjMuMlwiLFxuICAgIFwia2FybWEtY2hyb21lLWxhdW5jaGVyXCI6IFwiXjMuMS4wXCIsXG4gICAgXCJrYXJtYS1maXJlZm94LWxhdW5jaGVyXCI6IFwiXjIuMS4wXCIsXG4gICAgXCJrYXJtYS1qYXNtaW5lXCI6IFwiXjEuMS4xXCIsXG4gICAgXCJrYXJtYS1qYXNtaW5lLWFqYXhcIjogXCJeMC4xLjEzXCIsXG4gICAgXCJrYXJtYS1zYWZhcmktbGF1bmNoZXJcIjogXCJeMS4wLjBcIixcbiAgICBcImthcm1hLXNhdWNlLWxhdW5jaGVyXCI6IFwiXjQuMy42XCIsXG4gICAgXCJrYXJtYS1zaW5vblwiOiBcIl4xLjAuNVwiLFxuICAgIFwia2FybWEtc291cmNlbWFwLWxvYWRlclwiOiBcIl4wLjMuOFwiLFxuICAgIFwia2FybWEtd2VicGFja1wiOiBcIl40LjAuMlwiLFxuICAgIFwibG9hZC1ncnVudC10YXNrc1wiOiBcIl4zLjUuMlwiLFxuICAgIFwibWluaW1pc3RcIjogXCJeMS4yLjBcIixcbiAgICBcIm1vY2hhXCI6IFwiXjguMi4xXCIsXG4gICAgXCJzaW5vblwiOiBcIl40LjUuMFwiLFxuICAgIFwidGVyc2VyLXdlYnBhY2stcGx1Z2luXCI6IFwiXjQuMi4zXCIsXG4gICAgXCJ0eXBlc2NyaXB0XCI6IFwiXjQuMC41XCIsXG4gICAgXCJ1cmwtc2VhcmNoLXBhcmFtc1wiOiBcIl4wLjEwLjBcIixcbiAgICBcIndlYnBhY2tcIjogXCJeNC40NC4yXCIsXG4gICAgXCJ3ZWJwYWNrLWRldi1zZXJ2ZXJcIjogXCJeMy4xMS4wXCJcbiAgfSxcbiAgXCJicm93c2VyXCI6IHtcbiAgICBcIi4vbGliL2FkYXB0ZXJzL2h0dHAuanNcIjogXCIuL2xpYi9hZGFwdGVycy94aHIuanNcIlxuICB9LFxuICBcImpzZGVsaXZyXCI6IFwiZGlzdC9heGlvcy5taW4uanNcIixcbiAgXCJ1bnBrZ1wiOiBcImRpc3QvYXhpb3MubWluLmpzXCIsXG4gIFwidHlwaW5nc1wiOiBcIi4vaW5kZXguZC50c1wiLFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJmb2xsb3ctcmVkaXJlY3RzXCI6IFwiXjEuMTQuMFwiXG4gIH0sXG4gIFwiYnVuZGxlc2l6ZVwiOiBbXG4gICAge1xuICAgICAgXCJwYXRoXCI6IFwiLi9kaXN0L2F4aW9zLm1pbi5qc1wiLFxuICAgICAgXCJ0aHJlc2hvbGRcIjogXCI1a0JcIlxuICAgIH1cbiAgXVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICB2YXIgY29udGV4dCA9IHRoaXMgfHwgZGVmYXVsdHM7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuLmNhbGwoY29udGV4dCwgZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG52YXIgUDE2MDBfUk9VTkRfQ09OU1RBTlRTID0gWzEsIDAsIDMyODk4LCAwLCAzMjkwNiwgMjE0NzQ4MzY0OCwgMjE0NzUxNjQxNiwgMjE0NzQ4MzY0OCwgMzI5MDcsIDAsIDIxNDc0ODM2NDksIDAsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyNzc3LCAyMTQ3NDgzNjQ4LCAxMzgsIDAsIDEzNiwgMCwgMjE0NzUxNjQyNSwgMCwgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsIDIxNDc0ODM2NDgsIDMyNzcwLCAyMTQ3NDgzNjQ4LCAxMjgsIDIxNDc0ODM2NDgsIDMyNzc4LCAwLCAyMTQ3NDgzNjU4LCAyMTQ3NDgzNjQ4LCAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjg5NiwgMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0OSwgMCwgMjE0NzUxNjQyNCwgMjE0NzQ4MzY0OF1cblxuZXhwb3J0cy5wMTYwMCA9IGZ1bmN0aW9uIChzKSB7XG4gIGZvciAodmFyIHJvdW5kID0gMDsgcm91bmQgPCAyNDsgKytyb3VuZCkge1xuICAgIC8vIHRoZXRhXG4gICAgdmFyIGxvMCA9IHNbMF0gXiBzWzEwXSBeIHNbMjBdIF4gc1szMF0gXiBzWzQwXVxuICAgIHZhciBoaTAgPSBzWzFdIF4gc1sxMV0gXiBzWzIxXSBeIHNbMzFdIF4gc1s0MV1cbiAgICB2YXIgbG8xID0gc1syXSBeIHNbMTJdIF4gc1syMl0gXiBzWzMyXSBeIHNbNDJdXG4gICAgdmFyIGhpMSA9IHNbM10gXiBzWzEzXSBeIHNbMjNdIF4gc1szM10gXiBzWzQzXVxuICAgIHZhciBsbzIgPSBzWzRdIF4gc1sxNF0gXiBzWzI0XSBeIHNbMzRdIF4gc1s0NF1cbiAgICB2YXIgaGkyID0gc1s1XSBeIHNbMTVdIF4gc1syNV0gXiBzWzM1XSBeIHNbNDVdXG4gICAgdmFyIGxvMyA9IHNbNl0gXiBzWzE2XSBeIHNbMjZdIF4gc1szNl0gXiBzWzQ2XVxuICAgIHZhciBoaTMgPSBzWzddIF4gc1sxN10gXiBzWzI3XSBeIHNbMzddIF4gc1s0N11cbiAgICB2YXIgbG80ID0gc1s4XSBeIHNbMThdIF4gc1syOF0gXiBzWzM4XSBeIHNbNDhdXG4gICAgdmFyIGhpNCA9IHNbOV0gXiBzWzE5XSBeIHNbMjldIF4gc1szOV0gXiBzWzQ5XVxuXG4gICAgdmFyIGxvID0gbG80IF4gKGxvMSA8PCAxIHwgaGkxID4+PiAzMSlcbiAgICB2YXIgaGkgPSBoaTQgXiAoaGkxIDw8IDEgfCBsbzEgPj4+IDMxKVxuICAgIHZhciB0MXNsbzAgPSBzWzBdIF4gbG9cbiAgICB2YXIgdDFzaGkwID0gc1sxXSBeIGhpXG4gICAgdmFyIHQxc2xvNSA9IHNbMTBdIF4gbG9cbiAgICB2YXIgdDFzaGk1ID0gc1sxMV0gXiBoaVxuICAgIHZhciB0MXNsbzEwID0gc1syMF0gXiBsb1xuICAgIHZhciB0MXNoaTEwID0gc1syMV0gXiBoaVxuICAgIHZhciB0MXNsbzE1ID0gc1szMF0gXiBsb1xuICAgIHZhciB0MXNoaTE1ID0gc1szMV0gXiBoaVxuICAgIHZhciB0MXNsbzIwID0gc1s0MF0gXiBsb1xuICAgIHZhciB0MXNoaTIwID0gc1s0MV0gXiBoaVxuICAgIGxvID0gbG8wIF4gKGxvMiA8PCAxIHwgaGkyID4+PiAzMSlcbiAgICBoaSA9IGhpMCBeIChoaTIgPDwgMSB8IGxvMiA+Pj4gMzEpXG4gICAgdmFyIHQxc2xvMSA9IHNbMl0gXiBsb1xuICAgIHZhciB0MXNoaTEgPSBzWzNdIF4gaGlcbiAgICB2YXIgdDFzbG82ID0gc1sxMl0gXiBsb1xuICAgIHZhciB0MXNoaTYgPSBzWzEzXSBeIGhpXG4gICAgdmFyIHQxc2xvMTEgPSBzWzIyXSBeIGxvXG4gICAgdmFyIHQxc2hpMTEgPSBzWzIzXSBeIGhpXG4gICAgdmFyIHQxc2xvMTYgPSBzWzMyXSBeIGxvXG4gICAgdmFyIHQxc2hpMTYgPSBzWzMzXSBeIGhpXG4gICAgdmFyIHQxc2xvMjEgPSBzWzQyXSBeIGxvXG4gICAgdmFyIHQxc2hpMjEgPSBzWzQzXSBeIGhpXG4gICAgbG8gPSBsbzEgXiAobG8zIDw8IDEgfCBoaTMgPj4+IDMxKVxuICAgIGhpID0gaGkxIF4gKGhpMyA8PCAxIHwgbG8zID4+PiAzMSlcbiAgICB2YXIgdDFzbG8yID0gc1s0XSBeIGxvXG4gICAgdmFyIHQxc2hpMiA9IHNbNV0gXiBoaVxuICAgIHZhciB0MXNsbzcgPSBzWzE0XSBeIGxvXG4gICAgdmFyIHQxc2hpNyA9IHNbMTVdIF4gaGlcbiAgICB2YXIgdDFzbG8xMiA9IHNbMjRdIF4gbG9cbiAgICB2YXIgdDFzaGkxMiA9IHNbMjVdIF4gaGlcbiAgICB2YXIgdDFzbG8xNyA9IHNbMzRdIF4gbG9cbiAgICB2YXIgdDFzaGkxNyA9IHNbMzVdIF4gaGlcbiAgICB2YXIgdDFzbG8yMiA9IHNbNDRdIF4gbG9cbiAgICB2YXIgdDFzaGkyMiA9IHNbNDVdIF4gaGlcbiAgICBsbyA9IGxvMiBeIChsbzQgPDwgMSB8IGhpNCA+Pj4gMzEpXG4gICAgaGkgPSBoaTIgXiAoaGk0IDw8IDEgfCBsbzQgPj4+IDMxKVxuICAgIHZhciB0MXNsbzMgPSBzWzZdIF4gbG9cbiAgICB2YXIgdDFzaGkzID0gc1s3XSBeIGhpXG4gICAgdmFyIHQxc2xvOCA9IHNbMTZdIF4gbG9cbiAgICB2YXIgdDFzaGk4ID0gc1sxN10gXiBoaVxuICAgIHZhciB0MXNsbzEzID0gc1syNl0gXiBsb1xuICAgIHZhciB0MXNoaTEzID0gc1syN10gXiBoaVxuICAgIHZhciB0MXNsbzE4ID0gc1szNl0gXiBsb1xuICAgIHZhciB0MXNoaTE4ID0gc1szN10gXiBoaVxuICAgIHZhciB0MXNsbzIzID0gc1s0Nl0gXiBsb1xuICAgIHZhciB0MXNoaTIzID0gc1s0N10gXiBoaVxuICAgIGxvID0gbG8zIF4gKGxvMCA8PCAxIHwgaGkwID4+PiAzMSlcbiAgICBoaSA9IGhpMyBeIChoaTAgPDwgMSB8IGxvMCA+Pj4gMzEpXG4gICAgdmFyIHQxc2xvNCA9IHNbOF0gXiBsb1xuICAgIHZhciB0MXNoaTQgPSBzWzldIF4gaGlcbiAgICB2YXIgdDFzbG85ID0gc1sxOF0gXiBsb1xuICAgIHZhciB0MXNoaTkgPSBzWzE5XSBeIGhpXG4gICAgdmFyIHQxc2xvMTQgPSBzWzI4XSBeIGxvXG4gICAgdmFyIHQxc2hpMTQgPSBzWzI5XSBeIGhpXG4gICAgdmFyIHQxc2xvMTkgPSBzWzM4XSBeIGxvXG4gICAgdmFyIHQxc2hpMTkgPSBzWzM5XSBeIGhpXG4gICAgdmFyIHQxc2xvMjQgPSBzWzQ4XSBeIGxvXG4gICAgdmFyIHQxc2hpMjQgPSBzWzQ5XSBeIGhpXG5cbiAgICAvLyByaG8gJiBwaVxuICAgIHZhciB0MnNsbzAgPSB0MXNsbzBcbiAgICB2YXIgdDJzaGkwID0gdDFzaGkwXG4gICAgdmFyIHQyc2xvMTYgPSAodDFzaGk1IDw8IDQgfCB0MXNsbzUgPj4+IDI4KVxuICAgIHZhciB0MnNoaTE2ID0gKHQxc2xvNSA8PCA0IHwgdDFzaGk1ID4+PiAyOClcbiAgICB2YXIgdDJzbG83ID0gKHQxc2xvMTAgPDwgMyB8IHQxc2hpMTAgPj4+IDI5KVxuICAgIHZhciB0MnNoaTcgPSAodDFzaGkxMCA8PCAzIHwgdDFzbG8xMCA+Pj4gMjkpXG4gICAgdmFyIHQyc2xvMjMgPSAodDFzaGkxNSA8PCA5IHwgdDFzbG8xNSA+Pj4gMjMpXG4gICAgdmFyIHQyc2hpMjMgPSAodDFzbG8xNSA8PCA5IHwgdDFzaGkxNSA+Pj4gMjMpXG4gICAgdmFyIHQyc2xvMTQgPSAodDFzbG8yMCA8PCAxOCB8IHQxc2hpMjAgPj4+IDE0KVxuICAgIHZhciB0MnNoaTE0ID0gKHQxc2hpMjAgPDwgMTggfCB0MXNsbzIwID4+PiAxNClcbiAgICB2YXIgdDJzbG8xMCA9ICh0MXNsbzEgPDwgMSB8IHQxc2hpMSA+Pj4gMzEpXG4gICAgdmFyIHQyc2hpMTAgPSAodDFzaGkxIDw8IDEgfCB0MXNsbzEgPj4+IDMxKVxuICAgIHZhciB0MnNsbzEgPSAodDFzaGk2IDw8IDEyIHwgdDFzbG82ID4+PiAyMClcbiAgICB2YXIgdDJzaGkxID0gKHQxc2xvNiA8PCAxMiB8IHQxc2hpNiA+Pj4gMjApXG4gICAgdmFyIHQyc2xvMTcgPSAodDFzbG8xMSA8PCAxMCB8IHQxc2hpMTEgPj4+IDIyKVxuICAgIHZhciB0MnNoaTE3ID0gKHQxc2hpMTEgPDwgMTAgfCB0MXNsbzExID4+PiAyMilcbiAgICB2YXIgdDJzbG84ID0gKHQxc2hpMTYgPDwgMTMgfCB0MXNsbzE2ID4+PiAxOSlcbiAgICB2YXIgdDJzaGk4ID0gKHQxc2xvMTYgPDwgMTMgfCB0MXNoaTE2ID4+PiAxOSlcbiAgICB2YXIgdDJzbG8yNCA9ICh0MXNsbzIxIDw8IDIgfCB0MXNoaTIxID4+PiAzMClcbiAgICB2YXIgdDJzaGkyNCA9ICh0MXNoaTIxIDw8IDIgfCB0MXNsbzIxID4+PiAzMClcbiAgICB2YXIgdDJzbG8yMCA9ICh0MXNoaTIgPDwgMzAgfCB0MXNsbzIgPj4+IDIpXG4gICAgdmFyIHQyc2hpMjAgPSAodDFzbG8yIDw8IDMwIHwgdDFzaGkyID4+PiAyKVxuICAgIHZhciB0MnNsbzExID0gKHQxc2xvNyA8PCA2IHwgdDFzaGk3ID4+PiAyNilcbiAgICB2YXIgdDJzaGkxMSA9ICh0MXNoaTcgPDwgNiB8IHQxc2xvNyA+Pj4gMjYpXG4gICAgdmFyIHQyc2xvMiA9ICh0MXNoaTEyIDw8IDExIHwgdDFzbG8xMiA+Pj4gMjEpXG4gICAgdmFyIHQyc2hpMiA9ICh0MXNsbzEyIDw8IDExIHwgdDFzaGkxMiA+Pj4gMjEpXG4gICAgdmFyIHQyc2xvMTggPSAodDFzbG8xNyA8PCAxNSB8IHQxc2hpMTcgPj4+IDE3KVxuICAgIHZhciB0MnNoaTE4ID0gKHQxc2hpMTcgPDwgMTUgfCB0MXNsbzE3ID4+PiAxNylcbiAgICB2YXIgdDJzbG85ID0gKHQxc2hpMjIgPDwgMjkgfCB0MXNsbzIyID4+PiAzKVxuICAgIHZhciB0MnNoaTkgPSAodDFzbG8yMiA8PCAyOSB8IHQxc2hpMjIgPj4+IDMpXG4gICAgdmFyIHQyc2xvNSA9ICh0MXNsbzMgPDwgMjggfCB0MXNoaTMgPj4+IDQpXG4gICAgdmFyIHQyc2hpNSA9ICh0MXNoaTMgPDwgMjggfCB0MXNsbzMgPj4+IDQpXG4gICAgdmFyIHQyc2xvMjEgPSAodDFzaGk4IDw8IDIzIHwgdDFzbG84ID4+PiA5KVxuICAgIHZhciB0MnNoaTIxID0gKHQxc2xvOCA8PCAyMyB8IHQxc2hpOCA+Pj4gOSlcbiAgICB2YXIgdDJzbG8xMiA9ICh0MXNsbzEzIDw8IDI1IHwgdDFzaGkxMyA+Pj4gNylcbiAgICB2YXIgdDJzaGkxMiA9ICh0MXNoaTEzIDw8IDI1IHwgdDFzbG8xMyA+Pj4gNylcbiAgICB2YXIgdDJzbG8zID0gKHQxc2xvMTggPDwgMjEgfCB0MXNoaTE4ID4+PiAxMSlcbiAgICB2YXIgdDJzaGkzID0gKHQxc2hpMTggPDwgMjEgfCB0MXNsbzE4ID4+PiAxMSlcbiAgICB2YXIgdDJzbG8xOSA9ICh0MXNoaTIzIDw8IDI0IHwgdDFzbG8yMyA+Pj4gOClcbiAgICB2YXIgdDJzaGkxOSA9ICh0MXNsbzIzIDw8IDI0IHwgdDFzaGkyMyA+Pj4gOClcbiAgICB2YXIgdDJzbG8xNSA9ICh0MXNsbzQgPDwgMjcgfCB0MXNoaTQgPj4+IDUpXG4gICAgdmFyIHQyc2hpMTUgPSAodDFzaGk0IDw8IDI3IHwgdDFzbG80ID4+PiA1KVxuICAgIHZhciB0MnNsbzYgPSAodDFzbG85IDw8IDIwIHwgdDFzaGk5ID4+PiAxMilcbiAgICB2YXIgdDJzaGk2ID0gKHQxc2hpOSA8PCAyMCB8IHQxc2xvOSA+Pj4gMTIpXG4gICAgdmFyIHQyc2xvMjIgPSAodDFzaGkxNCA8PCA3IHwgdDFzbG8xNCA+Pj4gMjUpXG4gICAgdmFyIHQyc2hpMjIgPSAodDFzbG8xNCA8PCA3IHwgdDFzaGkxNCA+Pj4gMjUpXG4gICAgdmFyIHQyc2xvMTMgPSAodDFzbG8xOSA8PCA4IHwgdDFzaGkxOSA+Pj4gMjQpXG4gICAgdmFyIHQyc2hpMTMgPSAodDFzaGkxOSA8PCA4IHwgdDFzbG8xOSA+Pj4gMjQpXG4gICAgdmFyIHQyc2xvNCA9ICh0MXNsbzI0IDw8IDE0IHwgdDFzaGkyNCA+Pj4gMTgpXG4gICAgdmFyIHQyc2hpNCA9ICh0MXNoaTI0IDw8IDE0IHwgdDFzbG8yNCA+Pj4gMTgpXG5cbiAgICAvLyBjaGlcbiAgICBzWzBdID0gdDJzbG8wIF4gKH50MnNsbzEgJiB0MnNsbzIpXG4gICAgc1sxXSA9IHQyc2hpMCBeICh+dDJzaGkxICYgdDJzaGkyKVxuICAgIHNbMTBdID0gdDJzbG81IF4gKH50MnNsbzYgJiB0MnNsbzcpXG4gICAgc1sxMV0gPSB0MnNoaTUgXiAofnQyc2hpNiAmIHQyc2hpNylcbiAgICBzWzIwXSA9IHQyc2xvMTAgXiAofnQyc2xvMTEgJiB0MnNsbzEyKVxuICAgIHNbMjFdID0gdDJzaGkxMCBeICh+dDJzaGkxMSAmIHQyc2hpMTIpXG4gICAgc1szMF0gPSB0MnNsbzE1IF4gKH50MnNsbzE2ICYgdDJzbG8xNylcbiAgICBzWzMxXSA9IHQyc2hpMTUgXiAofnQyc2hpMTYgJiB0MnNoaTE3KVxuICAgIHNbNDBdID0gdDJzbG8yMCBeICh+dDJzbG8yMSAmIHQyc2xvMjIpXG4gICAgc1s0MV0gPSB0MnNoaTIwIF4gKH50MnNoaTIxICYgdDJzaGkyMilcbiAgICBzWzJdID0gdDJzbG8xIF4gKH50MnNsbzIgJiB0MnNsbzMpXG4gICAgc1szXSA9IHQyc2hpMSBeICh+dDJzaGkyICYgdDJzaGkzKVxuICAgIHNbMTJdID0gdDJzbG82IF4gKH50MnNsbzcgJiB0MnNsbzgpXG4gICAgc1sxM10gPSB0MnNoaTYgXiAofnQyc2hpNyAmIHQyc2hpOClcbiAgICBzWzIyXSA9IHQyc2xvMTEgXiAofnQyc2xvMTIgJiB0MnNsbzEzKVxuICAgIHNbMjNdID0gdDJzaGkxMSBeICh+dDJzaGkxMiAmIHQyc2hpMTMpXG4gICAgc1szMl0gPSB0MnNsbzE2IF4gKH50MnNsbzE3ICYgdDJzbG8xOClcbiAgICBzWzMzXSA9IHQyc2hpMTYgXiAofnQyc2hpMTcgJiB0MnNoaTE4KVxuICAgIHNbNDJdID0gdDJzbG8yMSBeICh+dDJzbG8yMiAmIHQyc2xvMjMpXG4gICAgc1s0M10gPSB0MnNoaTIxIF4gKH50MnNoaTIyICYgdDJzaGkyMylcbiAgICBzWzRdID0gdDJzbG8yIF4gKH50MnNsbzMgJiB0MnNsbzQpXG4gICAgc1s1XSA9IHQyc2hpMiBeICh+dDJzaGkzICYgdDJzaGk0KVxuICAgIHNbMTRdID0gdDJzbG83IF4gKH50MnNsbzggJiB0MnNsbzkpXG4gICAgc1sxNV0gPSB0MnNoaTcgXiAofnQyc2hpOCAmIHQyc2hpOSlcbiAgICBzWzI0XSA9IHQyc2xvMTIgXiAofnQyc2xvMTMgJiB0MnNsbzE0KVxuICAgIHNbMjVdID0gdDJzaGkxMiBeICh+dDJzaGkxMyAmIHQyc2hpMTQpXG4gICAgc1szNF0gPSB0MnNsbzE3IF4gKH50MnNsbzE4ICYgdDJzbG8xOSlcbiAgICBzWzM1XSA9IHQyc2hpMTcgXiAofnQyc2hpMTggJiB0MnNoaTE5KVxuICAgIHNbNDRdID0gdDJzbG8yMiBeICh+dDJzbG8yMyAmIHQyc2xvMjQpXG4gICAgc1s0NV0gPSB0MnNoaTIyIF4gKH50MnNoaTIzICYgdDJzaGkyNClcbiAgICBzWzZdID0gdDJzbG8zIF4gKH50MnNsbzQgJiB0MnNsbzApXG4gICAgc1s3XSA9IHQyc2hpMyBeICh+dDJzaGk0ICYgdDJzaGkwKVxuICAgIHNbMTZdID0gdDJzbG84IF4gKH50MnNsbzkgJiB0MnNsbzUpXG4gICAgc1sxN10gPSB0MnNoaTggXiAofnQyc2hpOSAmIHQyc2hpNSlcbiAgICBzWzI2XSA9IHQyc2xvMTMgXiAofnQyc2xvMTQgJiB0MnNsbzEwKVxuICAgIHNbMjddID0gdDJzaGkxMyBeICh+dDJzaGkxNCAmIHQyc2hpMTApXG4gICAgc1szNl0gPSB0MnNsbzE4IF4gKH50MnNsbzE5ICYgdDJzbG8xNSlcbiAgICBzWzM3XSA9IHQyc2hpMTggXiAofnQyc2hpMTkgJiB0MnNoaTE1KVxuICAgIHNbNDZdID0gdDJzbG8yMyBeICh+dDJzbG8yNCAmIHQyc2xvMjApXG4gICAgc1s0N10gPSB0MnNoaTIzIF4gKH50MnNoaTI0ICYgdDJzaGkyMClcbiAgICBzWzhdID0gdDJzbG80IF4gKH50MnNsbzAgJiB0MnNsbzEpXG4gICAgc1s5XSA9IHQyc2hpNCBeICh+dDJzaGkwICYgdDJzaGkxKVxuICAgIHNbMThdID0gdDJzbG85IF4gKH50MnNsbzUgJiB0MnNsbzYpXG4gICAgc1sxOV0gPSB0MnNoaTkgXiAofnQyc2hpNSAmIHQyc2hpNilcbiAgICBzWzI4XSA9IHQyc2xvMTQgXiAofnQyc2xvMTAgJiB0MnNsbzExKVxuICAgIHNbMjldID0gdDJzaGkxNCBeICh+dDJzaGkxMCAmIHQyc2hpMTEpXG4gICAgc1szOF0gPSB0MnNsbzE5IF4gKH50MnNsbzE1ICYgdDJzbG8xNilcbiAgICBzWzM5XSA9IHQyc2hpMTkgXiAofnQyc2hpMTUgJiB0MnNoaTE2KVxuICAgIHNbNDhdID0gdDJzbG8yNCBeICh+dDJzbG8yMCAmIHQyc2xvMjEpXG4gICAgc1s0OV0gPSB0MnNoaTI0IF4gKH50MnNoaTIwICYgdDJzaGkyMSlcblxuICAgIC8vIGlvdGFcbiAgICBzWzBdIF49IFAxNjAwX1JPVU5EX0NPTlNUQU5UU1tyb3VuZCAqIDJdXG4gICAgc1sxXSBePSBQMTYwMF9ST1VORF9DT05TVEFOVFNbcm91bmQgKiAyICsgMV1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS2VjY2FrU3RhdGUpIHtcbiAgZnVuY3Rpb24gS2VjY2FrIChyYXRlLCBjYXBhY2l0eSwgZGVsaW1pdGVkU3VmZml4LCBoYXNoQml0TGVuZ3RoLCBvcHRpb25zKSB7XG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucylcblxuICAgIHRoaXMuX3JhdGUgPSByYXRlXG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eVxuICAgIHRoaXMuX2RlbGltaXRlZFN1ZmZpeCA9IGRlbGltaXRlZFN1ZmZpeFxuICAgIHRoaXMuX2hhc2hCaXRMZW5ndGggPSBoYXNoQml0TGVuZ3RoXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcblxuICAgIHRoaXMuX3N0YXRlID0gbmV3IEtlY2Nha1N0YXRlKClcbiAgICB0aGlzLl9zdGF0ZS5pbml0aWFsaXplKHJhdGUsIGNhcGFjaXR5KVxuICAgIHRoaXMuX2ZpbmFsaXplZCA9IGZhbHNlXG4gIH1cblxuICBpbmhlcml0cyhLZWNjYWssIFRyYW5zZm9ybSlcblxuICBLZWNjYWsucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIHZhciBlcnJvciA9IG51bGxcbiAgICB0cnkge1xuICAgICAgdGhpcy51cGRhdGUoY2h1bmssIGVuY29kaW5nKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3IgPSBlcnJcbiAgICB9XG5cbiAgICBjYWxsYmFjayhlcnJvcilcbiAgfVxuXG4gIEtlY2Nhay5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGVycm9yID0gbnVsbFxuICAgIHRyeSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5kaWdlc3QoKSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9yID0gZXJyXG4gICAgfVxuXG4gICAgY2FsbGJhY2soZXJyb3IpXG4gIH1cblxuICBLZWNjYWsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZykge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpICYmIHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgYnVmZmVyJylcbiAgICBpZiAodGhpcy5fZmluYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoJ0RpZ2VzdCBhbHJlYWR5IGNhbGxlZCcpXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZylcblxuICAgIHRoaXMuX3N0YXRlLmFic29yYihkYXRhKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIEtlY2Nhay5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gICAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgdGhyb3cgbmV3IEVycm9yKCdEaWdlc3QgYWxyZWFkeSBjYWxsZWQnKVxuICAgIHRoaXMuX2ZpbmFsaXplZCA9IHRydWVcblxuICAgIGlmICh0aGlzLl9kZWxpbWl0ZWRTdWZmaXgpIHRoaXMuX3N0YXRlLmFic29yYkxhc3RGZXdCaXRzKHRoaXMuX2RlbGltaXRlZFN1ZmZpeClcbiAgICB2YXIgZGlnZXN0ID0gdGhpcy5fc3RhdGUuc3F1ZWV6ZSh0aGlzLl9oYXNoQml0TGVuZ3RoIC8gOClcbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgZGlnZXN0ID0gZGlnZXN0LnRvU3RyaW5nKGVuY29kaW5nKVxuXG4gICAgdGhpcy5fcmVzZXRTdGF0ZSgpXG5cbiAgICByZXR1cm4gZGlnZXN0XG4gIH1cblxuICAvLyByZW1vdmUgcmVzdWx0IGZyb20gbWVtb3J5XG4gIEtlY2Nhay5wcm90b3R5cGUuX3Jlc2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZSh0aGlzLl9yYXRlLCB0aGlzLl9jYXBhY2l0eSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gYmVjYXVzZSBzb21ldGltZXMgd2UgbmVlZCBoYXNoIHJpZ2h0IG5vdyBhbmQgbGl0dGxlIGxhdGVyXG4gIEtlY2Nhay5wcm90b3R5cGUuX2Nsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbG9uZSA9IG5ldyBLZWNjYWsodGhpcy5fcmF0ZSwgdGhpcy5fY2FwYWNpdHksIHRoaXMuX2RlbGltaXRlZFN1ZmZpeCwgdGhpcy5faGFzaEJpdExlbmd0aCwgdGhpcy5fb3B0aW9ucylcbiAgICB0aGlzLl9zdGF0ZS5jb3B5KGNsb25lLl9zdGF0ZSlcbiAgICBjbG9uZS5fZmluYWxpemVkID0gdGhpcy5fZmluYWxpemVkXG5cbiAgICByZXR1cm4gY2xvbmVcbiAgfVxuXG4gIHJldHVybiBLZWNjYWtcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtlY2Nha1N0YXRlKSB7XG4gIGZ1bmN0aW9uIFNoYWtlIChyYXRlLCBjYXBhY2l0eSwgZGVsaW1pdGVkU3VmZml4LCBvcHRpb25zKSB7XG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucylcblxuICAgIHRoaXMuX3JhdGUgPSByYXRlXG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eVxuICAgIHRoaXMuX2RlbGltaXRlZFN1ZmZpeCA9IGRlbGltaXRlZFN1ZmZpeFxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG5cbiAgICB0aGlzLl9zdGF0ZSA9IG5ldyBLZWNjYWtTdGF0ZSgpXG4gICAgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZShyYXRlLCBjYXBhY2l0eSlcbiAgICB0aGlzLl9maW5hbGl6ZWQgPSBmYWxzZVxuICB9XG5cbiAgaW5oZXJpdHMoU2hha2UsIFRyYW5zZm9ybSlcblxuICBTaGFrZS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGVycm9yID0gbnVsbFxuICAgIHRyeSB7XG4gICAgICB0aGlzLnVwZGF0ZShjaHVuaywgZW5jb2RpbmcpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnJvciA9IGVyclxuICAgIH1cblxuICAgIGNhbGxiYWNrKGVycm9yKVxuICB9XG5cbiAgU2hha2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uICgpIHt9XG5cbiAgU2hha2UucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICB0aGlzLnB1c2godGhpcy5zcXVlZXplKHNpemUpKVxuICB9XG5cbiAgU2hha2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZykge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpICYmIHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgYnVmZmVyJylcbiAgICBpZiAodGhpcy5fZmluYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoJ1NxdWVlemUgYWxyZWFkeSBjYWxsZWQnKVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgZW5jb2RpbmcpXG5cbiAgICB0aGlzLl9zdGF0ZS5hYnNvcmIoZGF0YSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBTaGFrZS5wcm90b3R5cGUuc3F1ZWV6ZSA9IGZ1bmN0aW9uIChkYXRhQnl0ZUxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgICBpZiAoIXRoaXMuX2ZpbmFsaXplZCkge1xuICAgICAgdGhpcy5fZmluYWxpemVkID0gdHJ1ZVxuICAgICAgdGhpcy5fc3RhdGUuYWJzb3JiTGFzdEZld0JpdHModGhpcy5fZGVsaW1pdGVkU3VmZml4KVxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdGhpcy5fc3RhdGUuc3F1ZWV6ZShkYXRhQnl0ZUxlbmd0aClcbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgZGF0YSA9IGRhdGEudG9TdHJpbmcoZW5jb2RpbmcpXG5cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgU2hha2UucHJvdG90eXBlLl9yZXNldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3N0YXRlLmluaXRpYWxpemUodGhpcy5fcmF0ZSwgdGhpcy5fY2FwYWNpdHkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIFNoYWtlLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsb25lID0gbmV3IFNoYWtlKHRoaXMuX3JhdGUsIHRoaXMuX2NhcGFjaXR5LCB0aGlzLl9kZWxpbWl0ZWRTdWZmaXgsIHRoaXMuX29wdGlvbnMpXG4gICAgdGhpcy5fc3RhdGUuY29weShjbG9uZS5fc3RhdGUpXG4gICAgY2xvbmUuX2ZpbmFsaXplZCA9IHRoaXMuX2ZpbmFsaXplZFxuXG4gICAgcmV0dXJuIGNsb25lXG4gIH1cblxuICByZXR1cm4gU2hha2Vcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MgPSBleHBvcnRzLlRXT19QT1cyNTYgPSBleHBvcnRzLk1BWF9JTlRFR0VSID0gdm9pZCAwO1xudmFyIEJOID0gcmVxdWlyZShcImJuLmpzXCIpO1xuLyoqXG4gKiBUaGUgbWF4IGludGVnZXIgdGhhdCB0aGlzIFZNIGNhbiBoYW5kbGVcbiAqL1xuZXhwb3J0cy5NQVhfSU5URUdFUiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsIDE2KTtcbi8qKlxuICogMl4yNTZcbiAqL1xuZXhwb3J0cy5UV09fUE9XMjU2ID0gbmV3IEJOKCcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDE2KTtcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gJ2M1ZDI0NjAxODZmNzIzM2M5MjdlN2RiMmRjYzcwM2MwZTUwMGI2NTNjYTgyMjczYjdiZmFkODA0NWQ4NWE0NzAnO1xuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TLCAnaGV4Jyk7XG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5XG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TID0gJzFkY2M0ZGU4ZGVjNzVkN2FhYjg1YjU2N2I2Y2NkNDFhZDMxMjQ1MWI5NDhhNzQxM2YwYTE0MmZkNDBkNDkzNDcnO1xuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUywgJ2hleCcpO1xuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TID0gJzU2ZTgxZjE3MWJjYzU1YTZmZjgzNDVlNjkyYzBmODZlNWI0OGUwMWI5OTZjYWRjMDAxNjIyZmI1ZTM2M2I0MjEnO1xuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TLCAnaGV4Jyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBleHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBleHBvcnRzLmZyb21ScGNTaWcgPSBleHBvcnRzLnRvUnBjU2lnID0gZXhwb3J0cy5lY3JlY292ZXIgPSBleHBvcnRzLmVjc2lnbiA9IHZvaWQgMDtcbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCcuL3NlY3AyNTZrMXYzLWFkYXB0ZXInKTtcbnZhciBCTiA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG52YXIgaGFzaF8xID0gcmVxdWlyZShcIi4vaGFzaFwiKTtcbi8qKlxuICogUmV0dXJucyB0aGUgRUNEU0Egc2lnbmF0dXJlIG9mIGEgbWVzc2FnZSBoYXNoLlxuICovXG5leHBvcnRzLmVjc2lnbiA9IGZ1bmN0aW9uIChtc2dIYXNoLCBwcml2YXRlS2V5LCBjaGFpbklkKSB7XG4gICAgdmFyIHNpZyA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpO1xuICAgIHZhciByZWNvdmVyeSA9IHNpZy5yZWNvdmVyeTtcbiAgICB2YXIgcmV0ID0ge1xuICAgICAgICByOiBzaWcuc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSxcbiAgICAgICAgczogc2lnLnNpZ25hdHVyZS5zbGljZSgzMiwgNjQpLFxuICAgICAgICB2OiBjaGFpbklkID8gcmVjb3ZlcnkgKyAoY2hhaW5JZCAqIDIgKyAzNSkgOiByZWNvdmVyeSArIDI3LFxuICAgIH07XG4gICAgcmV0dXJuIHJldDtcbn07XG4vKipcbiAqIEVDRFNBIHB1YmxpYyBrZXkgcmVjb3ZlcnkgZnJvbSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBSZWNvdmVyZWQgcHVibGljIGtleVxuICovXG5leHBvcnRzLmVjcmVjb3ZlciA9IGZ1bmN0aW9uIChtc2dIYXNoLCB2LCByLCBzLCBjaGFpbklkKSB7XG4gICAgdmFyIHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW2J5dGVzXzEuc2V0TGVuZ3RoKHIsIDMyKSwgYnl0ZXNfMS5zZXRMZW5ndGgocywgMzIpXSwgNjQpO1xuICAgIHZhciByZWNvdmVyeSA9IGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpO1xuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgICB9XG4gICAgdmFyIHNlbmRlclB1YktleSA9IHNlY3AyNTZrMS5yZWNvdmVyKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpO1xuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChzZW5kZXJQdWJLZXksIGZhbHNlKS5zbGljZSgxKTtcbn07XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIGBldGhfc2lnbmAgUlBDIG1ldGhvZC5cbiAqIEByZXR1cm5zIFNpZ25hdHVyZVxuICovXG5leHBvcnRzLnRvUnBjU2lnID0gZnVuY3Rpb24gKHYsIHIsIHMsIGNoYWluSWQpIHtcbiAgICB2YXIgcmVjb3ZlcnkgPSBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKTtcbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShyZWNvdmVyeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gICAgfVxuICAgIC8vIGdldGggKGFuZCB0aGUgUlBDIGV0aF9zaWduIG1ldGhvZCkgdXNlcyB0aGUgNjUgYnl0ZSBmb3JtYXQgdXNlZCBieSBCaXRjb2luXG4gICAgcmV0dXJuIGJ5dGVzXzEuYnVmZmVyVG9IZXgoQnVmZmVyLmNvbmNhdChbYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KHIsIDMyKSwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KHMsIDMyKSwgYnl0ZXNfMS50b0J1ZmZlcih2KV0pKTtcbn07XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIGZvcm1hdCBvZiB0aGUgYGV0aF9zaWduYCBSUEMgbWV0aG9kIHRvIHNpZ25hdHVyZSBwYXJhbWV0ZXJzXG4gKiBOT1RFOiBhbGwgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBnZXRoOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcbiAqL1xuZXhwb3J0cy5mcm9tUnBjU2lnID0gZnVuY3Rpb24gKHNpZykge1xuICAgIHZhciBidWYgPSBieXRlc18xLnRvQnVmZmVyKHNpZyk7XG4gICAgLy8gTk9URTogd2l0aCBwb3RlbnRpYWwgaW50cm9kdWN0aW9uIG9mIGNoYWluSWQgdGhpcyBtaWdodCBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgICBpZiAoYnVmLmxlbmd0aCAhPT0gNjUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBsZW5ndGgnKTtcbiAgICB9XG4gICAgdmFyIHYgPSBidWZbNjRdO1xuICAgIC8vIHN1cHBvcnQgYm90aCB2ZXJzaW9ucyBvZiBgZXRoX3NpZ25gIHJlc3BvbnNlc1xuICAgIGlmICh2IDwgMjcpIHtcbiAgICAgICAgdiArPSAyNztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdjogdixcbiAgICAgICAgcjogYnVmLnNsaWNlKDAsIDMyKSxcbiAgICAgICAgczogYnVmLnNsaWNlKDMyLCA2NCksXG4gICAgfTtcbn07XG4vKipcbiAqIFZhbGlkYXRlIGEgRUNEU0Egc2lnbmF0dXJlLlxuICogQHBhcmFtIGhvbWVzdGVhZE9yTGF0ZXIgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBiZWluZyB1c2VkIG9uIGVpdGhlciB0aGUgaG9tZXN0ZWFkIGhhcmRmb3JrIG9yIGEgbGF0ZXIgb25lXG4gKi9cbmV4cG9ydHMuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uICh2LCByLCBzLCBob21lc3RlYWRPckxhdGVyLCBjaGFpbklkKSB7XG4gICAgaWYgKGhvbWVzdGVhZE9yTGF0ZXIgPT09IHZvaWQgMCkgeyBob21lc3RlYWRPckxhdGVyID0gdHJ1ZTsgfVxuICAgIHZhciBTRUNQMjU2SzFfTl9ESVZfMiA9IG5ldyBCTignN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY1ZDU3NmU3MzU3YTQ1MDFkZGZlOTJmNDY2ODFiMjBhMCcsIDE2KTtcbiAgICB2YXIgU0VDUDI1NksxX04gPSBuZXcgQk4oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnLCAxNik7XG4gICAgaWYgKHIubGVuZ3RoICE9PSAzMiB8fCBzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgckJOID0gbmV3IEJOKHIpO1xuICAgIHZhciBzQk4gPSBuZXcgQk4ocyk7XG4gICAgaWYgKHJCTi5pc1plcm8oKSB8fCByQk4uZ3QoU0VDUDI1NksxX04pIHx8IHNCTi5pc1plcm8oKSB8fCBzQk4uZ3QoU0VDUDI1NksxX04pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhvbWVzdGVhZE9yTGF0ZXIgJiYgc0JOLmNtcChTRUNQMjU2SzFfTl9ESVZfMikgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGtlY2Nhay0yNTYgaGFzaCBvZiBgbWVzc2FnZWAsIHByZWZpeGVkIHdpdGggdGhlIGhlYWRlciB1c2VkIGJ5IHRoZSBgZXRoX3NpZ25gIFJQQyBjYWxsLlxuICogVGhlIG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBmZWQgaW50byBgZWNzaWduYCB0byBwcm9kdWNlIHRoZSBzYW1lIHNpZ25hdHVyZSBhcyB0aGUgYGV0aF9zaWduYFxuICogY2FsbCBmb3IgYSBnaXZlbiBgbWVzc2FnZWAsIG9yIGZlZCB0byBgZWNyZWNvdmVyYCBhbG9uZyB3aXRoIGEgc2lnbmF0dXJlIHRvIHJlY292ZXIgdGhlIHB1YmxpYyBrZXlcbiAqIHVzZWQgdG8gcHJvZHVjZSB0aGUgc2lnbmF0dXJlLlxuICovXG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHZhciBwcmVmaXggPSBCdWZmZXIuZnJvbShcIlxcdTAwMTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG5cIiArIG1lc3NhZ2UubGVuZ3RoLnRvU3RyaW5nKCksICd1dGYtOCcpO1xuICAgIHJldHVybiBoYXNoXzEua2VjY2FrKEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgbWVzc2FnZV0pKTtcbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKSB7XG4gICAgcmV0dXJuIGNoYWluSWQgPyB2IC0gKDIgKiBjaGFpbklkICsgMzUpIDogdiAtIDI3O1xufVxuZnVuY3Rpb24gaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSB7XG4gICAgcmV0dXJuIHJlY292ZXJ5ID09PSAwIHx8IHJlY292ZXJ5ID09PSAxO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmF0dXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBleHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGV4cG9ydHMucHJpdmF0ZVRvQWRkcmVzcyA9IGV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBleHBvcnRzLmlzVmFsaWRQcml2YXRlID0gZXhwb3J0cy5pc1ByZWNvbXBpbGVkID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MyID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGV4cG9ydHMuemVyb0FkZHJlc3MgPSB2b2lkIDA7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgZXRoanNVdGlsID0gcmVxdWlyZSgnZXRoanMtdXRpbCcpO1xudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxdjMtYWRhcHRlcicpO1xudmFyIEJOID0gcmVxdWlyZShcImJuLmpzXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbnZhciBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGEgemVybyBhZGRyZXNzLlxuICovXG5leHBvcnRzLnplcm9BZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhZGRyZXNzTGVuZ3RoID0gMjA7XG4gICAgdmFyIGFkZHIgPSBieXRlc18xLnplcm9zKGFkZHJlc3NMZW5ndGgpO1xuICAgIHJldHVybiBieXRlc18xLmJ1ZmZlclRvSGV4KGFkZHIpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQuIEFjY2VwdHMgY2hlY2tzdW1tZWQgYWRkcmVzc2VzIHRvby5cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIC9eMHhbMC05YS1mQS1GXXs0MH0kLy50ZXN0KGFkZHJlc3MpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYWRkcmVzcyBpcyBhIHplcm8gYWRkcmVzcy5cbiAqL1xuZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICB2YXIgemVyb0FkZHIgPSBleHBvcnRzLnplcm9BZGRyZXNzKCk7XG4gICAgcmV0dXJuIHplcm9BZGRyID09PSBieXRlc18xLmFkZEhleFByZWZpeChhZGRyZXNzKTtcbn07XG4vKipcbiAqIFJldHVybnMgYSBjaGVja3N1bW1lZCBhZGRyZXNzLlxuICpcbiAqIElmIGEgZWlwMTE5MUNoYWluSWQgaXMgcHJvdmlkZWQsIHRoZSBjaGFpbklkIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGNoZWNrc3VtIGNhbGN1bGF0aW9uLiBUaGlzXG4gKiBoYXMgdGhlIGVmZmVjdCBvZiBjaGVja3N1bW1lZCBhZGRyZXNzZXMgZm9yIG9uZSBjaGFpbiBoYXZpbmcgaW52YWxpZCBjaGVja3N1bXMgZm9yIG90aGVycy5cbiAqIEZvciBtb3JlIGRldGFpbHMsIGNvbnN1bHQgRUlQLTExOTEuXG4gKlxuICogV0FSTklORzogQ2hlY2tzdW1zIHdpdGggYW5kIHdpdGhvdXQgdGhlIGNoYWluSWQgd2lsbCBkaWZmZXIuIEFzIG9mIDIwMTktMDYtMjYsIHRoZSBtb3N0IGNvbW1vbmx5XG4gKiB1c2VkIHZhcmlhdGlvbiBpbiBFdGhlcmV1bSB3YXMgd2l0aG91dCB0aGUgY2hhaW5JZC4gVGhpcyBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gKi9cbmV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcywgZWlwMTE5MUNoYWluSWQpIHtcbiAgICBhZGRyZXNzID0gZXRoanNVdGlsLnN0cmlwSGV4UHJlZml4KGFkZHJlc3MpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHByZWZpeCA9IGVpcDExOTFDaGFpbklkICE9PSB1bmRlZmluZWQgPyBlaXAxMTkxQ2hhaW5JZC50b1N0cmluZygpICsgJzB4JyA6ICcnO1xuICAgIHZhciBoYXNoID0gaGFzaF8xLmtlY2NhayhwcmVmaXggKyBhZGRyZXNzKS50b1N0cmluZygnaGV4Jyk7XG4gICAgdmFyIHJldCA9ICcweCc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwYXJzZUludChoYXNoW2ldLCAxNikgPj0gOCkge1xuICAgICAgICAgICAgcmV0ICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCArPSBhZGRyZXNzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBjaGVja3N1bW1lZCBhZGRyZXNzLlxuICpcbiAqIFNlZSB0b0NoZWNrc3VtQWRkcmVzcycgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscyBhYm91dCB0aGUgZWlwMTE5MUNoYWluSWQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcywgZWlwMTE5MUNoYWluSWQpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSAmJiBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MsIGVpcDExOTFDaGFpbklkKSA9PT0gYWRkcmVzcztcbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdC5cbiAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAqIEBwYXJhbSBub25jZSBUaGUgbm9uY2Ugb2YgdGhlIGZyb20gYWNjb3VudFxuICovXG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzcyA9IGZ1bmN0aW9uIChmcm9tLCBub25jZSkge1xuICAgIGZyb20gPSBieXRlc18xLnRvQnVmZmVyKGZyb20pO1xuICAgIHZhciBub25jZUJOID0gbmV3IEJOKG5vbmNlKTtcbiAgICBpZiAobm9uY2VCTi5pc1plcm8oKSkge1xuICAgICAgICAvLyBpbiBSTFAgd2Ugd2FudCB0byBlbmNvZGUgbnVsbCBpbiB0aGUgY2FzZSBvZiB6ZXJvIG5vbmNlXG4gICAgICAgIC8vIHJlYWQgdGhlIFJMUCBkb2N1bWVudGF0aW9uIGZvciBhbiBhbnN3ZXIgaWYgeW91IGRhcmVcbiAgICAgICAgcmV0dXJuIGhhc2hfMS5ybHBoYXNoKFtmcm9tLCBudWxsXSkuc2xpY2UoLTIwKTtcbiAgICB9XG4gICAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gICAgcmV0dXJuIGhhc2hfMS5ybHBoYXNoKFtmcm9tLCBCdWZmZXIuZnJvbShub25jZUJOLnRvQXJyYXkoKSldKS5zbGljZSgtMjApO1xufTtcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3MgZm9yIGEgY29udHJhY3QgY3JlYXRlZCB1c2luZyBDUkVBVEUyLlxuICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIHNhbHQgQSBzYWx0XG4gKiBAcGFyYW0gaW5pdENvZGUgVGhlIGluaXQgY29kZSBvZiB0aGUgY29udHJhY3QgYmVpbmcgY3JlYXRlZFxuICovXG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzczIgPSBmdW5jdGlvbiAoZnJvbSwgc2FsdCwgaW5pdENvZGUpIHtcbiAgICB2YXIgZnJvbUJ1ZiA9IGJ5dGVzXzEudG9CdWZmZXIoZnJvbSk7XG4gICAgdmFyIHNhbHRCdWYgPSBieXRlc18xLnRvQnVmZmVyKHNhbHQpO1xuICAgIHZhciBpbml0Q29kZUJ1ZiA9IGJ5dGVzXzEudG9CdWZmZXIoaW5pdENvZGUpO1xuICAgIGFzc2VydChmcm9tQnVmLmxlbmd0aCA9PT0gMjApO1xuICAgIGFzc2VydChzYWx0QnVmLmxlbmd0aCA9PT0gMzIpO1xuICAgIHZhciBhZGRyZXNzID0gaGFzaF8xLmtlY2NhazI1NihCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSgnZmYnLCAnaGV4JyksIGZyb21CdWYsIHNhbHRCdWYsIGhhc2hfMS5rZWNjYWsyNTYoaW5pdENvZGVCdWYpXSkpO1xuICAgIHJldHVybiBhZGRyZXNzLnNsaWNlKC0yMCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN1cHBsaWVkIGFkZHJlc3MgYmVsb25ncyB0byBhIHByZWNvbXBpbGVkIGFjY291bnQgKEJ5emFudGl1bSkuXG4gKi9cbmV4cG9ydHMuaXNQcmVjb21waWxlZCA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgdmFyIGEgPSBieXRlc18xLnVucGFkKGFkZHJlc3MpO1xuICAgIHJldHVybiBhLmxlbmd0aCA9PT0gMSAmJiBhWzBdID49IDEgJiYgYVswXSA8PSA4O1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcml2YXRlIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azEuXG4gKi9cbmV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHVibGljIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azFcbiAqIGFuZCB0aGUgcmVxdWlyZW1lbnRzIG9mIEV0aGVyZXVtLlxuICogQHBhcmFtIHB1YmxpY0tleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHNhbml0aXplIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKi9cbmV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNhbml0aXplKSB7XG4gICAgaWYgKHNhbml0aXplID09PSB2b2lkIDApIHsgc2FuaXRpemUgPSBmYWxzZTsgfVxuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAvLyBDb252ZXJ0IHRvIFNFQzEgZm9yIHNlY3AyNTZrMVxuICAgICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbNF0pLCBwdWJsaWNLZXldKSk7XG4gICAgfVxuICAgIGlmICghc2FuaXRpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHB1YmxpYyBrZXkuXG4gKiBBY2NlcHRzIFwiRXRoZXJldW0gcHVibGljIGtleXNcIiBhbmQgU0VDMSBlbmNvZGVkIGtleXMuXG4gKiBAcGFyYW0gcHViS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0gc2FuaXRpemUgQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqL1xuZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHViS2V5LCBzYW5pdGl6ZSkge1xuICAgIGlmIChzYW5pdGl6ZSA9PT0gdm9pZCAwKSB7IHNhbml0aXplID0gZmFsc2U7IH1cbiAgICBwdWJLZXkgPSBieXRlc18xLnRvQnVmZmVyKHB1YktleSk7XG4gICAgaWYgKHNhbml0aXplICYmIHB1YktleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHB1YktleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xuICAgIH1cbiAgICBhc3NlcnQocHViS2V5Lmxlbmd0aCA9PT0gNjQpO1xuICAgIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICAgIHJldHVybiBoYXNoXzEua2VjY2FrKHB1YktleSkuc2xpY2UoLTIwKTtcbn07XG5leHBvcnRzLnB1YmxpY1RvQWRkcmVzcyA9IGV4cG9ydHMucHViVG9BZGRyZXNzO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICovXG5leHBvcnRzLnByaXZhdGVUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyhleHBvcnRzLnByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBwdWJsaWMga2V5IG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICovXG5leHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgcHJpdmF0ZUtleSA9IGJ5dGVzXzEudG9CdWZmZXIocHJpdmF0ZUtleSk7XG4gICAgLy8gc2tpcCB0aGUgdHlwZSBmbGFnIGFuZCB1c2UgdGhlIFgsIFkgcG9pbnRzXG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIHRoZSBFdGhlcmV1bSBmb3JtYXQuXG4gKi9cbmV4cG9ydHMuaW1wb3J0UHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgIHB1YmxpY0tleSA9IGJ5dGVzXzEudG9CdWZmZXIocHVibGljS2V5KTtcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgcHVibGljS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaWNLZXk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjb3VudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFUb0pTT04gPSBleHBvcnRzLmFkZEhleFByZWZpeCA9IGV4cG9ydHMudG9VbnNpZ25lZCA9IGV4cG9ydHMuZnJvbVNpZ25lZCA9IGV4cG9ydHMuYnVmZmVyVG9IZXggPSBleHBvcnRzLmJ1ZmZlclRvSW50ID0gZXhwb3J0cy50b0J1ZmZlciA9IGV4cG9ydHMuc3RyaXBaZXJvcyA9IGV4cG9ydHMudW5wYWQgPSBleHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZXhwb3J0cy5zZXRMZW5ndGggPSBleHBvcnRzLnNldExlbmd0aExlZnQgPSBleHBvcnRzLnplcm9zID0gdm9pZCAwO1xudmFyIGV0aGpzVXRpbCA9IHJlcXVpcmUoJ2V0aGpzLXV0aWwnKTtcbnZhciBCTiA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlciBmaWxsZWQgd2l0aCAwcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgc2hvdWxkIGJlXG4gKi9cbmV4cG9ydHMuemVyb3MgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzKS5maWxsKDApO1xufTtcbi8qKlxuICogTGVmdCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBwYXJhbSBtc2cgdGhlIHZhbHVlIHRvIHBhZCAoQnVmZmVyfEFycmF5KVxuICogQHBhcmFtIGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcGFyYW0gcmlnaHQgd2hldGhlciB0byBzdGFydCBwYWRkaW5nIGZvcm0gdGhlIGxlZnQgb3IgcmlnaHRcbiAqIEByZXR1cm4gKEJ1ZmZlcnxBcnJheSlcbiAqL1xuZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoLCByaWdodCkge1xuICAgIGlmIChyaWdodCA9PT0gdm9pZCAwKSB7IHJpZ2h0ID0gZmFsc2U7IH1cbiAgICB2YXIgYnVmID0gZXhwb3J0cy56ZXJvcyhsZW5ndGgpO1xuICAgIG1zZyA9IGV4cG9ydHMudG9CdWZmZXIobXNnKTtcbiAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIG1zZy5jb3B5KGJ1Zik7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2cuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBtc2cuY29weShidWYsIGxlbmd0aCAtIG1zZy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnLnNsaWNlKC1sZW5ndGgpO1xuICAgIH1cbn07XG5leHBvcnRzLnNldExlbmd0aCA9IGV4cG9ydHMuc2V0TGVuZ3RoTGVmdDtcbi8qKlxuICogUmlnaHQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0gbXNnIHRoZSB2YWx1ZSB0byBwYWQgKEJ1ZmZlcnxBcnJheSlcbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiAoQnVmZmVyfEFycmF5KVxuICovXG5leHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCB0cnVlKTtcbn07XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgIG9yIGFuIGBBcnJheWAuXG4gKiBAcGFyYW0gYSAoQnVmZmVyfEFycmF5fFN0cmluZylcbiAqIEByZXR1cm4gKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKi9cbmV4cG9ydHMudW5wYWQgPSBmdW5jdGlvbiAoYSkge1xuICAgIGEgPSBldGhqc1V0aWwuc3RyaXBIZXhQcmVmaXgoYSk7XG4gICAgdmFyIGZpcnN0ID0gYVswXTtcbiAgICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgICAgICBhID0gYS5zbGljZSgxKTtcbiAgICAgICAgZmlyc3QgPSBhWzBdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5leHBvcnRzLnN0cmlwWmVyb3MgPSBleHBvcnRzLnVucGFkO1xuLyoqXG4gKiBBdHRlbXB0cyB0byB0dXJuIGEgdmFsdWUgaW50byBhIGBCdWZmZXJgLiBBcyBpbnB1dCBpdCBzdXBwb3J0cyBgQnVmZmVyYCwgYFN0cmluZ2AsIGBOdW1iZXJgLCBudWxsL3VuZGVmaW5lZCwgYEJOYCBhbmQgb3RoZXIgb2JqZWN0cyB3aXRoIGEgYHRvQXJyYXkoKWAgbWV0aG9kLlxuICogQHBhcmFtIHYgdGhlIHZhbHVlXG4gKi9cbmV4cG9ydHMudG9CdWZmZXIgPSBmdW5jdGlvbiAodikge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoZXRoanNVdGlsLmlzSGV4U3RyaW5nKHYpKSB7XG4gICAgICAgICAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKGV0aGpzVXRpbC5wYWRUb0V2ZW4oZXRoanNVdGlsLnN0cmlwSGV4UHJlZml4KHYpKSwgJ2hleCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlci4gdG9CdWZmZXIgb25seSBzdXBwb3J0cyAweC1wcmVmaXhlZCBoZXggc3RyaW5ncyBhbmQgdGhpcyBzdHJpbmcgd2FzIGdpdmVuOiBcIiArIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdiA9IGV0aGpzVXRpbC5pbnRUb0J1ZmZlcih2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCTi5pc0JOKHYpKSB7XG4gICAgICAgICAgICB2ID0gdi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYudG9BcnJheSkge1xuICAgICAgICAgICAgLy8gY29udmVydHMgYSBCTiB0byBhIEJ1ZmZlclxuICAgICAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIHRvIGEgYE51bWJlcmAuXG4gKiBAcGFyYW0gYnVmIGBCdWZmZXJgIG9iamVjdCB0byBjb252ZXJ0XG4gKiBAdGhyb3dzIElmIHRoZSBpbnB1dCBudW1iZXIgZXhjZWVkcyA1MyBiaXRzLlxuICovXG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHJldHVybiBuZXcgQk4oZXhwb3J0cy50b0J1ZmZlcihidWYpKS50b051bWJlcigpO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBpbnRvIGEgYDB4YC1wcmVmaXhlZCBoZXggYFN0cmluZ2AuXG4gKiBAcGFyYW0gYnVmIGBCdWZmZXJgIG9iamVjdCB0byBjb252ZXJ0XG4gKi9cbmV4cG9ydHMuYnVmZmVyVG9IZXggPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgYnVmID0gZXhwb3J0cy50b0J1ZmZlcihidWYpO1xuICAgIHJldHVybiAnMHgnICsgYnVmLnRvU3RyaW5nKCdoZXgnKTtcbn07XG4vKipcbiAqIEludGVycHJldHMgYSBgQnVmZmVyYCBhcyBhIHNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGEgYEJOYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXG4gKiBAcGFyYW0gbnVtIFNpZ25lZCBpbnRlZ2VyIHZhbHVlXG4gKi9cbmV4cG9ydHMuZnJvbVNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gbmV3IEJOKG51bSkuZnJvbVR3b3MoMjU2KTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgYEJOYCB0byBhbiB1bnNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0IGFzIGEgYEJ1ZmZlcmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIG51bVxuICovXG5leHBvcnRzLnRvVW5zaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG51bS50b1R3b3MoMjU2KS50b0FycmF5KCkpO1xufTtcbi8qKlxuICogQWRkcyBcIjB4XCIgdG8gYSBnaXZlbiBgU3RyaW5nYCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IHN0YXJ0IHdpdGggXCIweFwiLlxuICovXG5leHBvcnRzLmFkZEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGV0aGpzVXRpbC5pc0hleFByZWZpeGVkKHN0cikgPyBzdHIgOiAnMHgnICsgc3RyO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBvciBgQXJyYXlgIHRvIEpTT04uXG4gKiBAcGFyYW0gYmEgKEJ1ZmZlcnxBcnJheSlcbiAqIEByZXR1cm4gKEFycmF5fFN0cmluZ3xudWxsKVxuICovXG5leHBvcnRzLmJhVG9KU09OID0gZnVuY3Rpb24gKGJhKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIGJhLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyYXkucHVzaChleHBvcnRzLmJhVG9KU09OKGJhW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IHZvaWQgMDtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBldGhqc1V0aWwgPSByZXF1aXJlKCdldGhqcy11dGlsJyk7XG52YXIgcmxwID0gcmVxdWlyZShcInJscFwiKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG4vKipcbiAqIERlZmluZXMgcHJvcGVydGllcyBvbiBhIGBPYmplY3RgLiBJdCBtYWtlIHRoZSBhc3N1bXB0aW9uIHRoYXQgdW5kZXJseWluZyBkYXRhIGlzIGJpbmFyeS5cbiAqIEBwYXJhbSBzZWxmIHRoZSBgT2JqZWN0YCB0byBkZWZpbmUgcHJvcGVydGllcyBvblxuICogQHBhcmFtIGZpZWxkcyBhbiBhcnJheSBmaWVsZHMgdG8gZGVmaW5lLiBGaWVsZHMgY2FuIGNvbnRhaW46XG4gKiAqIGBuYW1lYCAtIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0aWVzXG4gKiAqIGBsZW5ndGhgIC0gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgZmllbGQgY2FuIGhhdmVcbiAqICogYGFsbG93TGVzc2AgLSBpZiB0aGUgZmllbGQgY2FuIGJlIGxlc3MgdGhhbiB0aGUgbGVuZ3RoXG4gKiAqIGBhbGxvd0VtcHR5YFxuICogQHBhcmFtIGRhdGEgZGF0YSB0byBiZSB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgZGVmaW5pdGlvbnNcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChzZWxmLCBmaWVsZHMsIGRhdGEpIHtcbiAgICBzZWxmLnJhdyA9IFtdO1xuICAgIHNlbGYuX2ZpZWxkcyA9IFtdO1xuICAgIC8vIGF0dGFjaCB0aGUgYHRvSlNPTmBcbiAgICBzZWxmLnRvSlNPTiA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICBpZiAobGFiZWwgPT09IHZvaWQgMCkgeyBsYWJlbCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgdmFyIG9ial8xID0ge307XG4gICAgICAgICAgICBzZWxmLl9maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICBvYmpfMVtmaWVsZF0gPSBcIjB4XCIgKyBzZWxmW2ZpZWxkXS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvYmpfMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXNfMS5iYVRvSlNPTihzZWxmLnJhdyk7XG4gICAgfTtcbiAgICBzZWxmLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHJscC5lbmNvZGUoc2VsZi5yYXcpO1xuICAgIH07XG4gICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkLCBpKSB7XG4gICAgICAgIHNlbGYuX2ZpZWxkcy5wdXNoKGZpZWxkLm5hbWUpO1xuICAgICAgICBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5yYXdbaV07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dGVyKHYpIHtcbiAgICAgICAgICAgIHYgPSBieXRlc18xLnRvQnVmZmVyKHYpO1xuICAgICAgICAgICAgaWYgKHYudG9TdHJpbmcoJ2hleCcpID09PSAnMDAnICYmICFmaWVsZC5hbGxvd1plcm8pIHtcbiAgICAgICAgICAgICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpZWxkLmFsbG93TGVzcyAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2ID0gYnl0ZXNfMS5zdHJpcFplcm9zKHYpO1xuICAgICAgICAgICAgICAgIGFzc2VydChmaWVsZC5sZW5ndGggPj0gdi5sZW5ndGgsIFwiVGhlIGZpZWxkIFwiICsgZmllbGQubmFtZSArIFwiIG11c3Qgbm90IGhhdmUgbW9yZSBcIiArIGZpZWxkLmxlbmd0aCArIFwiIGJ5dGVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIShmaWVsZC5hbGxvd1plcm8gJiYgdi5sZW5ndGggPT09IDApICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFzc2VydChmaWVsZC5sZW5ndGggPT09IHYubGVuZ3RoLCBcIlRoZSBmaWVsZCBcIiArIGZpZWxkLm5hbWUgKyBcIiBtdXN0IGhhdmUgYnl0ZSBsZW5ndGggb2YgXCIgKyBmaWVsZC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yYXdbaV0gPSB2O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5uYW1lLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmaWVsZC5kZWZhdWx0KSB7XG4gICAgICAgICAgICBzZWxmW2ZpZWxkLm5hbWVdID0gZmllbGQuZGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhdHRhY2ggYWxpYXNcbiAgICAgICAgaWYgKGZpZWxkLmFsaWFzKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQuYWxpYXMsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgc2V0OiBzZXR0ZXIsXG4gICAgICAgICAgICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGlmIHRoZSBjb25zdHVjdG9yIGlzIHBhc3NlZCBkYXRhXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGV0aGpzVXRpbC5zdHJpcEhleFByZWZpeChkYXRhKSwgJ2hleCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBybHAuZGVjb2RlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiBzZWxmLl9maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBudW1iZXIgb2YgZmllbGRzIGluIGRhdGEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBhbGwgdGhlIGl0ZW1zIGFyZSBidWZmZXJzXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICBzZWxmW3NlbGYuX2ZpZWxkc1tpXV0gPSBieXRlc18xLnRvQnVmZmVyKGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YXIga2V5c18xID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICAgICAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5c18xLmluZGV4T2YoZmllbGQubmFtZSkgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzZWxmW2ZpZWxkLm5hbWVdID0gZGF0YVtmaWVsZC5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5c18xLmluZGV4T2YoZmllbGQuYWxpYXMpICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZltmaWVsZC5hbGlhc10gPSBkYXRhW2ZpZWxkLmFsaWFzXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGEnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJscGhhc2ggPSBleHBvcnRzLnJpcGVtZDE2MCA9IGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5rZWNjYWsyNTYgPSBleHBvcnRzLmtlY2NhayA9IHZvaWQgMDtcbnZhciBfYSA9IHJlcXVpcmUoJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWsnKSwga2VjY2FrMjI0ID0gX2Eua2VjY2FrMjI0LCBrZWNjYWszODQgPSBfYS5rZWNjYWszODQsIGsyNTYgPSBfYS5rZWNjYWsyNTYsIGtlY2NhazUxMiA9IF9hLmtlY2NhazUxMjtcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbnZhciBldGhqc1V0aWwgPSByZXF1aXJlKCdldGhqcy11dGlsJyk7XG52YXIgcmxwID0gcmVxdWlyZShcInJscFwiKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXIpIElmIHRoZSBzdHJpbmcgaXMgYSAweC1wcmVmaXhlZCBoZXggdmFsdWVcbiAqIGl0J3MgaW50ZXJwcmV0ZWQgYXMgaGV4YWRlY2ltYWwsIG90aGVyd2lzZSBhcyB1dGY4LlxuICogQHBhcmFtIGJpdHMgVGhlIEtlY2NhayB3aWR0aFxuICovXG5leHBvcnRzLmtlY2NhayA9IGZ1bmN0aW9uIChhLCBiaXRzKSB7XG4gICAgaWYgKGJpdHMgPT09IHZvaWQgMCkgeyBiaXRzID0gMjU2OyB9XG4gICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyAmJiAhZXRoanNVdGlsLmlzSGV4U3RyaW5nKGEpKSB7XG4gICAgICAgIGEgPSBCdWZmZXIuZnJvbShhLCAndXRmOCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYSA9IGJ5dGVzXzEudG9CdWZmZXIoYSk7XG4gICAgfVxuICAgIGlmICghYml0cylcbiAgICAgICAgYml0cyA9IDI1NjtcbiAgICBzd2l0Y2ggKGJpdHMpIHtcbiAgICAgICAgY2FzZSAyMjQ6IHtcbiAgICAgICAgICAgIHJldHVybiBrZWNjYWsyMjQoYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyNTY6IHtcbiAgICAgICAgICAgIHJldHVybiBrMjU2KGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzg0OiB7XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrMzg0KGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNTEyOiB7XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrNTEyKGEpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsZCBhbGdvcml0aG06IGtlY2Nha1wiICsgYml0cyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBDcmVhdGVzIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgaW5wdXQsIGFsaWFzIGZvciBrZWNjYWsoYSwgMjU2KS5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcilcbiAqL1xuZXhwb3J0cy5rZWNjYWsyNTYgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBleHBvcnRzLmtlY2NhayhhKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgU0hBMjU2IGhhc2ggb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyKVxuICovXG5leHBvcnRzLnNoYTI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgYSA9IGJ5dGVzXzEudG9CdWZmZXIoYSk7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpXG4gICAgICAgIC51cGRhdGUoYSlcbiAgICAgICAgLmRpZ2VzdCgpO1xufTtcbi8qKlxuICogQ3JlYXRlcyBSSVBFTUQxNjAgaGFzaCBvZiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXIpXG4gKiBAcGFyYW0gcGFkZGVkIFdoZXRoZXIgaXQgc2hvdWxkIGJlIHBhZGRlZCB0byAyNTYgYml0cyBvciBub3RcbiAqL1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XG4gICAgYSA9IGJ5dGVzXzEudG9CdWZmZXIoYSk7XG4gICAgdmFyIGhhc2ggPSBjcmVhdGVIYXNoKCdybWQxNjAnKVxuICAgICAgICAudXBkYXRlKGEpXG4gICAgICAgIC5kaWdlc3QoKTtcbiAgICBpZiAocGFkZGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBieXRlc18xLnNldExlbmd0aChoYXNoLCAzMik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG59O1xuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIGhhc2ggb2YgdGhlIFJMUCBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGFcbiAqL1xuZXhwb3J0cy5ybHBoYXNoID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5rZWNjYWsocmxwLmVuY29kZShhKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZWNkaFVuc2FmZSA9IGV4cG9ydHMuZWNkaCA9IGV4cG9ydHMucmVjb3ZlciA9IGV4cG9ydHMudmVyaWZ5ID0gZXhwb3J0cy5zaWduID0gZXhwb3J0cy5zaWduYXR1cmVJbXBvcnRMYXggPSBleHBvcnRzLnNpZ25hdHVyZUltcG9ydCA9IGV4cG9ydHMuc2lnbmF0dXJlRXhwb3J0ID0gZXhwb3J0cy5zaWduYXR1cmVOb3JtYWxpemUgPSBleHBvcnRzLnB1YmxpY0tleUNvbWJpbmUgPSBleHBvcnRzLnB1YmxpY0tleVR3ZWFrTXVsID0gZXhwb3J0cy5wdWJsaWNLZXlUd2Vha0FkZCA9IGV4cG9ydHMucHVibGljS2V5VmVyaWZ5ID0gZXhwb3J0cy5wdWJsaWNLZXlDb252ZXJ0ID0gZXhwb3J0cy5wdWJsaWNLZXlDcmVhdGUgPSBleHBvcnRzLnByaXZhdGVLZXlUd2Vha011bCA9IGV4cG9ydHMucHJpdmF0ZUtleVR3ZWFrQWRkID0gZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGV4cG9ydHMucHJpdmF0ZUtleU5lZ2F0ZSA9IGV4cG9ydHMucHJpdmF0ZUtleUltcG9ydCA9IGV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGV4cG9ydHMucHJpdmF0ZUtleVZlcmlmeSA9IHZvaWQgMDtcbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxJyk7XG52YXIgc2VjcDI1NmsxdjMgPSByZXF1aXJlKCcuL3NlY3AyNTZrMXYzLWxpYi9pbmRleCcpO1xudmFyIGRlciA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxdjMtbGliL2RlcicpO1xuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0EgcHJpdmF0ZUtleVxuICogQG1ldGhvZCBwcml2YXRlS2V5VmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlS2V5VmVyaWZ5ID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwcml2YXRlS2V5IGxlbmd0aCBpcyBub3QgMzJcbiAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSk7XG59O1xuLyoqXG4gKiBFeHBvcnQgYSBwcml2YXRlS2V5IGluIERFUiBmb3JtYXRcbiAqIEBtZXRob2QgcHJpdmF0ZUtleUV4cG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwcml2YXRlS2V5IGxlbmd0aCBpcyBub3QgMzJcbiAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICAgIH1cbiAgICB2YXIgcHVibGljS2V5ID0gc2VjcDI1NmsxdjMucHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBjb21wcmVzc2VkKTtcbiAgICByZXR1cm4gZGVyLnByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgcHVibGljS2V5LCBjb21wcmVzc2VkKTtcbn07XG4vKipcbiAqIEltcG9ydCBhIHByaXZhdGVLZXkgaW4gREVSIGZvcm1hdFxuICogQG1ldGhvZCBwcml2YXRlS2V5SW1wb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnByaXZhdGVLZXlJbXBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIC8vIHByaXZhdGVLZXlJbXBvcnQgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAgIHByaXZhdGVLZXkgPSBkZXIucHJpdmF0ZUtleUltcG9ydChwcml2YXRlS2V5KTtcbiAgICBpZiAocHJpdmF0ZUtleSAhPT0gbnVsbCAmJiBwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIgJiYgZXhwb3J0cy5wcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlS2V5O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBpbXBvcnQgZnJvbSBERVIgZm9ybWF0XCIpO1xufTtcbi8qKlxuICogTmVnYXRlIGEgcHJpdmF0ZUtleSBieSBzdWJ0cmFjdGluZyBpdCBmcm9tIHRoZSBvcmRlciBvZiB0aGUgY3VydmUncyBiYXNlIHBvaW50XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlOZWdhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZUtleU5lZ2F0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5TmVnYXRlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSkpO1xufTtcbi8qKlxuICogQ29tcHV0ZSB0aGUgaW52ZXJzZSBvZiBhIHByaXZhdGVLZXkgKG1vZHVsbyB0aGUgb3JkZXIgb2YgdGhlIGN1cnZlJ3MgYmFzZSBwb2ludCkuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlNb2RJbnZlcnNlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnByaXZhdGVLZXlNb2RJbnZlcnNlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMXYzLnByaXZhdGVLZXlNb2RJbnZlcnNlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSkpO1xufTtcbi8qKlxuICogVHdlYWsgYSBwcml2YXRlS2V5IGJ5IGFkZGluZyB0d2VhayB0byBpdC5cbiAqIEBtZXRob2QgcHJpdmF0ZUtleVR3ZWFrQWRkXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZUtleVR3ZWFrQWRkID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtBZGQoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCB0d2VhaykpO1xufTtcbi8qKlxuICogVHdlYWsgYSBwcml2YXRlS2V5IGJ5IG11bHRpcGx5aW5nIGl0IGJ5IGEgdHdlYWsuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlUd2Vha011bFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnByaXZhdGVLZXlUd2Vha011bCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCB0d2Vhaykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrTXVsKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSkpO1xufTtcbi8qKlxuICogQ29tcHV0ZSB0aGUgcHVibGljIGtleSBmb3IgYSBwcml2YXRlS2V5LlxuICogQG1ldGhvZCBwdWJsaWNLZXlDcmVhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlDcmVhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcbi8qKlxuICogQ29udmVydCBhIHB1YmxpY0tleSB0byBjb21wcmVzc2VkIG9yIHVuY29tcHJlc3NlZCBmb3JtLlxuICogQG1ldGhvZCBwdWJsaWNLZXlDb252ZXJ0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlDb252ZXJ0ID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q29udmVydChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcbi8qKlxuICogVmVyaWZ5IGFuIEVDRFNBIHB1YmxpY0tleS5cbiAqIEBtZXRob2QgcHVibGljS2V5VmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLnB1YmxpY0tleVZlcmlmeSA9IGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwdWJsaWNLZXkgbGVuZ3RoIGlzIG5vdCAzMyBvciA2NVxuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAzMyAmJiBwdWJsaWNLZXkubGVuZ3RoICE9PSA2NSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpKTtcbn07XG4vKipcbiAqIFR3ZWFrIGEgcHVibGljS2V5IGJ5IGFkZGluZyB0d2VhayB0aW1lcyB0aGUgZ2VuZXJhdG9yIHRvIGl0LlxuICogQG1ldGhvZCBwdWJsaWNLZXlUd2Vha0FkZFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlUd2Vha0FkZCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSwgY29tcHJlc3NlZCkpO1xufTtcbi8qKlxuICogVHdlYWsgYSBwdWJsaWNLZXkgYnkgbXVsdGlwbHlpbmcgaXQgYnkgYSB0d2VhayB2YWx1ZVxuICogQG1ldGhvZCBwdWJsaWNLZXlUd2Vha011bFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlUd2Vha011bCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha011bChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSwgY29tcHJlc3NlZCkpO1xufTtcbi8qKlxuICogQWRkIGEgZ2l2ZW4gcHVibGljS2V5cyB0b2dldGhlci5cbiAqIEBtZXRob2QgcHVibGljS2V5Q29tYmluZVxuICogQHBhcmFtIHtBcnJheTxCdWZmZXI+fSBwdWJsaWNLZXlzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlDb21iaW5lID0gZnVuY3Rpb24gKHB1YmxpY0tleXMsIGNvbXByZXNzZWQpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIHB1YmxpY0tleXMuZm9yRWFjaChmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gICAgICAgIGtleXMucHVzaChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDb21iaW5lKGtleXMsIGNvbXByZXNzZWQpKTtcbn07XG4vKipcbiAqIENvbnZlcnQgYSBzaWduYXR1cmUgdG8gYSBub3JtYWxpemVkIGxvd2VyLVMgZm9ybS5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlTm9ybWFsaXplXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2lnbmF0dXJlTm9ybWFsaXplID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuc2lnbmF0dXJlTm9ybWFsaXplKFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpKSk7XG59O1xuLyoqXG4gKiBTZXJpYWxpemUgYW4gRUNEU0Egc2lnbmF0dXJlIGluIERFUiBmb3JtYXQuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUV4cG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNpZ25hdHVyZUV4cG9ydCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZUV4cG9ydChVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcbi8qKlxuICogUGFyc2UgYSBERVIgRUNEU0Egc2lnbmF0dXJlIChmb2xsb3cgYnkgW0JJUDY2XShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY2Lm1lZGlhd2lraSkpLlxuICogQG1ldGhvZCBzaWduYXR1cmVJbXBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5zaWduYXR1cmVJbXBvcnQoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSkpKTtcbn07XG4vKipcbiAqIFBhcnNlIGEgREVSIEVDRFNBIHNpZ25hdHVyZSAobm90IGZvbGxvdyBieSBbQklQNjZdKGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwNjYubWVkaWF3aWtpKSkuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUltcG9ydExheFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgICAvLyBzaWduYXR1cmVJbXBvcnRMYXggbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAgIC8vIGVuc3VyZSB0aGF0IHNpZ25hdHVyZSBpcyBncmVhdGVyIHRoYW4gMFxuICAgIGlmIChzaWduYXR1cmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaWduYXR1cmUgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICB9XG4gICAgdmFyIHNpZ09iaiA9IGRlci5zaWduYXR1cmVJbXBvcnRMYXgoc2lnbmF0dXJlKTtcbiAgICBpZiAoc2lnT2JqID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkbid0IHBhcnNlIERFUiBzaWduYXR1cmVcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWNwMjU2azF2My5zaWduYXR1cmVJbXBvcnQoc2lnT2JqKTtcbn07XG4vKipcbiAqIENyZWF0ZSBhbiBFQ0RTQSBzaWduYXR1cmUuIEFsd2F5cyByZXR1cm4gbG93LVMgc2lnbmF0dXJlLlxuICogQG1ldGhvZCBzaWduXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2lnbiA9IGZ1bmN0aW9uIChtZXNzYWdlLCBwcml2YXRlS2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBzaG91bGQgYmUgYW4gT2JqZWN0Jyk7XG4gICAgfVxuICAgIHZhciBzaWduT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBzaWduT3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy5kYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSBvcHRpb24uZGF0YSBsZW5ndGhcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuZGF0YSBzaG91bGQgYmUgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhLmxlbmd0aCAhPSAzMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvcHRpb25zLmRhdGEgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpZ25PcHRpb25zLmRhdGEgPSBuZXcgVWludDhBcnJheShvcHRpb25zLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMubm9uY2VmbiBzaG91bGQgYmUgYSBGdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4pIHtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgb3B0aW9uLm5vbmNlZm4gZnVuY3Rpb24gc2lnbmF0dXJlXG4gICAgICAgICAgICBzaWduT3B0aW9ucy5ub25jZWZuID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHByaXZhdGVLZXksIGFsZ28sIGRhdGEsIGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyQWxnbyA9IGFsZ28gIT0gbnVsbCA/IEJ1ZmZlci5mcm9tKGFsZ28pIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyRGF0YSA9IGRhdGEgIT0gbnVsbCA/IEJ1ZmZlci5mcm9tKGRhdGEpIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oJycpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gb3B0aW9ucy5ub25jZWZuKEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLCBCdWZmZXIuZnJvbShwcml2YXRlS2V5KSwgYnVmZmVyQWxnbywgYnVmZmVyRGF0YSwgYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2lnID0gc2VjcDI1NmsxLmVjZHNhU2lnbihVaW50OEFycmF5LmZyb20obWVzc2FnZSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgc2lnbk9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpZ25hdHVyZTogQnVmZmVyLmZyb20oc2lnLnNpZ25hdHVyZSksXG4gICAgICAgIHJlY292ZXJ5OiBzaWcucmVjaWQsXG4gICAgfTtcbn07XG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMudmVyaWZ5ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gICAgcmV0dXJuIHNlY3AyNTZrMS5lY2RzYVZlcmlmeShVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSwgVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBwdWJsaWNLZXkpO1xufTtcbi8qKlxuICogUmVjb3ZlciBhbiBFQ0RTQSBwdWJsaWMga2V5IGZyb20gYSBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHJlY292ZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge051bWJlcn0gcmVjaWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJlY292ZXIgPSBmdW5jdGlvbiAobWVzc2FnZSwgc2lnbmF0dXJlLCByZWNpZCwgY29tcHJlc3NlZCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuZWNkc2FSZWNvdmVyKFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpLCByZWNpZCwgVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBjb21wcmVzc2VkKSk7XG59O1xuLyoqXG4gKiBDb21wdXRlIGFuIEVDIERpZmZpZS1IZWxsbWFuIHNlY3JldCBhbmQgYXBwbGllZCBzaGEyNTYgdG8gY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICogQG1ldGhvZCBlY2RoXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmVjZGggPSBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5KSB7XG4gICAgLy8gbm90ZTogc2VjcDI1NmsxIHYzIGRvZXNuJ3QgYWxsb3cgb3B0aW9uYWwgcGFyYW1ldGVyXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5lY2RoKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIHt9KSk7XG59O1xuZXhwb3J0cy5lY2RoVW5zYWZlID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgcHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAgIC8vIGVjZGhVbnNhZmUgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAgIC8vIGVuc3VyZSB2YWxpZCBwdWJsaWNLZXkgbGVuZ3RoXG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMzICYmIHB1YmxpY0tleS5sZW5ndGggIT09IDY1KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwdWJsaWMga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIC8vIGVuc3VyZSB2YWxpZCBwcml2YXRlS2V5IGxlbmd0aFxuICAgIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azF2My5lY2RoVW5zYWZlKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIGNvbXByZXNzZWQpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azF2My1hZGFwdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wMiA9IHZvaWQgMDtcbi8vIDMyLWJpdCBwb3dlcnMgb2YgdHdvIHdvdWxkbid0IGJlIHBvc3NpYmxlIHdpdGggPDxcbmV4cG9ydHMucDIgPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKylcbiAgICBleHBvcnRzLnAyW2ldID0gTWF0aC5wb3coMiwgaSk7XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQmlnbnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJykuQmlnTnVtYmVyXG5cbmV4cG9ydHMuTVQgPSB7XG4gIFBPU19JTlQ6IDAsXG4gIE5FR19JTlQ6IDEsXG4gIEJZVEVfU1RSSU5HOiAyLFxuICBVVEY4X1NUUklORzogMyxcbiAgQVJSQVk6IDQsXG4gIE1BUDogNSxcbiAgVEFHOiA2LFxuICBTSU1QTEVfRkxPQVQ6IDdcbn1cblxuZXhwb3J0cy5UQUcgPSB7XG4gIERBVEVfU1RSSU5HOiAwLFxuICBEQVRFX0VQT0NIOiAxLFxuICBQT1NfQklHSU5UOiAyLFxuICBORUdfQklHSU5UOiAzLFxuICBERUNJTUFMX0ZSQUM6IDQsXG4gIEJJR0ZMT0FUOiA1LFxuICBCQVNFNjRVUkxfRVhQRUNURUQ6IDIxLFxuICBCQVNFNjRfRVhQRUNURUQ6IDIyLFxuICBCQVNFMTZfRVhQRUNURUQ6IDIzLFxuICBDQk9SOiAyNCxcbiAgVVJJOiAzMixcbiAgQkFTRTY0VVJMOiAzMyxcbiAgQkFTRTY0OiAzNCxcbiAgUkVHRVhQOiAzNSxcbiAgTUlNRTogMzZcbn1cblxuZXhwb3J0cy5OVU1CWVRFUyA9IHtcbiAgWkVSTzogMCxcbiAgT05FOiAyNCxcbiAgVFdPOiAyNSxcbiAgRk9VUjogMjYsXG4gIEVJR0hUOiAyNyxcbiAgSU5ERUZJTklURTogMzFcbn1cblxuZXhwb3J0cy5TSU1QTEUgPSB7XG4gIEZBTFNFOiAyMCxcbiAgVFJVRTogMjEsXG4gIE5VTEw6IDIyLFxuICBVTkRFRklORUQ6IDIzXG59XG5cbmV4cG9ydHMuU1lNUyA9IHtcbiAgTlVMTDogU3ltYm9sKCdudWxsJyksXG4gIFVOREVGSU5FRDogU3ltYm9sKCd1bmRlZicpLFxuICBQQVJFTlQ6IFN5bWJvbCgncGFyZW50JyksXG4gIEJSRUFLOiBTeW1ib2woJ2JyZWFrJyksXG4gIFNUUkVBTTogU3ltYm9sKCdzdHJlYW0nKVxufVxuXG5leHBvcnRzLlNISUZUMzIgPSBNYXRoLnBvdygyLCAzMilcbmV4cG9ydHMuU0hJRlQxNiA9IE1hdGgucG93KDIsIDE2KVxuXG5leHBvcnRzLk1BWF9TQUZFX0hJR0ggPSAweDFmZmZmZlxuZXhwb3J0cy5ORUdfT05FID0gbmV3IEJpZ251bWJlcigtMSlcbmV4cG9ydHMuVEVOID0gbmV3IEJpZ251bWJlcigxMClcbmV4cG9ydHMuVFdPID0gbmV3IEJpZ251bWJlcigyKVxuXG5leHBvcnRzLlBBUkVOVCA9IHtcbiAgQVJSQVk6IDAsXG4gIE9CSkVDVDogMSxcbiAgTUFQOiAyLFxuICBUQUc6IDMsXG4gIEJZVEVfU1RSSU5HOiA0LFxuICBVVEY4X1NUUklORzogNVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgQmlnbnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJykuQmlnTnVtYmVyXG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IFNISUZUMzIgPSBjb25zdGFudHMuU0hJRlQzMlxuY29uc3QgU0hJRlQxNiA9IGNvbnN0YW50cy5TSElGVDE2XG5jb25zdCBNQVhfU0FGRV9ISUdIID0gMHgxZmZmZmZcblxuZXhwb3J0cy5wYXJzZUhhbGYgPSBmdW5jdGlvbiBwYXJzZUhhbGYgKGJ1Zikge1xuICB2YXIgZXhwLCBtYW50LCBzaWduXG4gIHNpZ24gPSBidWZbMF0gJiAweDgwID8gLTEgOiAxXG4gIGV4cCA9IChidWZbMF0gJiAweDdDKSA+PiAyXG4gIG1hbnQgPSAoKGJ1ZlswXSAmIDB4MDMpIDw8IDgpIHwgYnVmWzFdXG4gIGlmICghZXhwKSB7XG4gICAgcmV0dXJuIHNpZ24gKiA1Ljk2MDQ2NDQ3NzUzOTA2MjVlLTggKiBtYW50XG4gIH0gZWxzZSBpZiAoZXhwID09PSAweDFmKSB7XG4gICAgcmV0dXJuIHNpZ24gKiAobWFudCA/IDAgLyAwIDogMmUzMDgpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNpZ24gKiBNYXRoLnBvdygyLCBleHAgLSAyNSkgKiAoMTAyNCArIG1hbnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikge1xuICAgIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICB9XG5cbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmV4cG9ydHMuYXJyYXlCdWZmZXJUb0JpZ251bWJlciA9IGZ1bmN0aW9uIChidWYpIHtcbiAgY29uc3QgbGVuID0gYnVmLmJ5dGVMZW5ndGhcbiAgbGV0IHJlcyA9ICcnXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXMgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBCaWdudW1iZXIocmVzLCAxNilcbn1cblxuLy8gY29udmVydCBhbiBPYmplY3QgaW50byBhIE1hcFxuZXhwb3J0cy5idWlsZE1hcCA9IChvYmopID0+IHtcbiAgY29uc3QgcmVzID0gbmV3IE1hcCgpXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICByZXMuc2V0KGtleXNbaV0sIG9ialtrZXlzW2ldXSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmV4cG9ydHMuYnVpbGRJbnQzMiA9IChmLCBnKSA9PiB7XG4gIHJldHVybiBmICogU0hJRlQxNiArIGdcbn1cblxuZXhwb3J0cy5idWlsZEludDY0ID0gKGYxLCBmMiwgZzEsIGcyKSA9PiB7XG4gIGNvbnN0IGYgPSBleHBvcnRzLmJ1aWxkSW50MzIoZjEsIGYyKVxuICBjb25zdCBnID0gZXhwb3J0cy5idWlsZEludDMyKGcxLCBnMilcblxuICBpZiAoZiA+IE1BWF9TQUZFX0hJR0gpIHtcbiAgICByZXR1cm4gbmV3IEJpZ251bWJlcihmKS50aW1lcyhTSElGVDMyKS5wbHVzKGcpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmICogU0hJRlQzMikgKyBnXG4gIH1cbn1cblxuZXhwb3J0cy53cml0ZUhhbGYgPSBmdW5jdGlvbiB3cml0ZUhhbGYgKGJ1ZiwgaGFsZikge1xuICAvLyBhc3N1bWUgMCwgLTAsIE5hTiwgSW5maW5pdHksIGFuZCAtSW5maW5pdHkgaGF2ZSBhbHJlYWR5IGJlZW4gY2F1Z2h0XG5cbiAgLy8gSEFDSzogZXZlcnlvbmUgc2V0dGxlIGluLiAgVGhpcyBpc24ndCBnb2luZyB0byBiZSBwcmV0dHkuXG4gIC8vIFRyYW5zbGF0ZSBjbi1jYm9yJ3MgQyBjb2RlIChmcm9tIENhcnN0ZW4gQm9ybWFuKTpcblxuICAvLyB1aW50MzJfdCBiZTMyO1xuICAvLyB1aW50MTZfdCBiZTE2LCB1MTY7XG4gIC8vIHVuaW9uIHtcbiAgLy8gICBmbG9hdCBmO1xuICAvLyAgIHVpbnQzMl90IHU7XG4gIC8vIH0gdTMyO1xuICAvLyB1MzIuZiA9IGZsb2F0X3ZhbDtcblxuICBjb25zdCB1MzIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNClcbiAgdTMyLndyaXRlRmxvYXRCRShoYWxmLCAwKVxuICBjb25zdCB1ID0gdTMyLnJlYWRVSW50MzJCRSgwKVxuXG4gIC8vIGlmICgodTMyLnUgJiAweDFGRkYpID09IDApIHsgLyogd29ydGggdHJ5aW5nIGhhbGYgKi9cblxuICAvLyBoaWxkamo6IElmIHRoZSBsb3dlciAxMyBiaXRzIGFyZSAwLCB3ZSB3b24ndCBsb3NlIGFueXRoaW5nIGluIHRoZSBjb252ZXJzaW9uXG4gIGlmICgodSAmIDB4MUZGRikgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vICAgaW50IHMxNiA9ICh1MzIudSA+PiAxNikgJiAweDgwMDA7XG4gIC8vICAgaW50IGV4cCA9ICh1MzIudSA+PiAyMykgJiAweGZmO1xuICAvLyAgIGludCBtYW50ID0gdTMyLnUgJiAweDdmZmZmZjtcblxuICB2YXIgczE2ID0gKHUgPj4gMTYpICYgMHg4MDAwIC8vIHRvcCBiaXQgaXMgc2lnblxuICBjb25zdCBleHAgPSAodSA+PiAyMykgJiAweGZmIC8vIHRoZW4gNSBiaXRzIG9mIGV4cG9uZW50XG4gIGNvbnN0IG1hbnQgPSB1ICYgMHg3ZmZmZmZcblxuICAvLyAgIGlmIChleHAgPT0gMCAmJiBtYW50ID09IDApXG4gIC8vICAgICA7ICAgICAgICAgICAgICAvKiAwLjAsIC0wLjAgKi9cblxuICAvLyBoaWxkamo6IHplcm9zIGFscmVhZHkgaGFuZGxlZC4gIEFzc2VydCBpZiB5b3UgZG9uJ3QgYmVsaWV2ZSBtZS5cblxuICAvLyAgIGVsc2UgaWYgKGV4cCA+PSAxMTMgJiYgZXhwIDw9IDE0MikgLyogbm9ybWFsaXplZCAqL1xuICAvLyAgICAgczE2ICs9ICgoZXhwIC0gMTEyKSA8PCAxMCkgKyAobWFudCA+PiAxMyk7XG4gIGlmICgoZXhwID49IDExMykgJiYgKGV4cCA8PSAxNDIpKSB7XG4gICAgczE2ICs9ICgoZXhwIC0gMTEyKSA8PCAxMCkgKyAobWFudCA+PiAxMylcblxuICAvLyAgIGVsc2UgaWYgKGV4cCA+PSAxMDMgJiYgZXhwIDwgMTEzKSB7IC8qIGRlbm9ybSwgZXhwMTYgPSAwICovXG4gIC8vICAgICBpZiAobWFudCAmICgoMSA8PCAoMTI2IC0gZXhwKSkgLSAxKSlcbiAgLy8gICAgICAgZ290byBmbG9hdDMyOyAgICAgICAgIC8qIGxvc3Mgb2YgcHJlY2lzaW9uICovXG4gIC8vICAgICBzMTYgKz0gKChtYW50ICsgMHg4MDAwMDApID4+ICgxMjYgLSBleHApKTtcbiAgfSBlbHNlIGlmICgoZXhwID49IDEwMykgJiYgKGV4cCA8IDExMykpIHtcbiAgICBpZiAobWFudCAmICgoMSA8PCAoMTI2IC0gZXhwKSkgLSAxKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHMxNiArPSAoKG1hbnQgKyAweDgwMDAwMCkgPj4gKDEyNiAtIGV4cCkpXG5cbiAgICAvLyAgIH0gZWxzZSBpZiAoZXhwID09IDI1NSAmJiBtYW50ID09IDApIHsgLyogSW5mICovXG4gICAgLy8gICAgIHMxNiArPSAweDdjMDA7XG5cbiAgICAvLyBoaWxkamo6IEluZmluaXR5IGFscmVhZHkgaGFuZGxlZFxuXG4gIC8vICAgfSBlbHNlXG4gIC8vICAgICBnb3RvIGZsb2F0MzI7ICAgICAgICAgICAvKiBsb3NzIG9mIHJhbmdlICovXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyAgIGVuc3VyZV93cml0YWJsZSgzKTtcbiAgLy8gICB1MTYgPSBzMTY7XG4gIC8vICAgYmUxNiA9IGh0b24xNnAoKGNvbnN0IHVpbnQ4X3QqKSZ1MTYpO1xuICBidWYud3JpdGVVSW50MTZCRShzMTYsIDApXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydHMua2V5U29ydGVyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGxlbkEgPSBhWzBdLmJ5dGVMZW5ndGhcbiAgdmFyIGxlbkIgPSBiWzBdLmJ5dGVMZW5ndGhcblxuICBpZiAobGVuQSA+IGxlbkIpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgaWYgKGxlbkIgPiBsZW5BKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICByZXR1cm4gYVswXS5jb21wYXJlKGJbMF0pXG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBodHRwOi8vd3d3LjJhbGl0eS5jb20vMjAxMi8wMy9zaWduZWR6ZXJvLmh0bWxcbmV4cG9ydHMuaXNOZWdhdGl2ZVplcm8gPSAoeCkgPT4ge1xuICByZXR1cm4geCA9PT0gMCAmJiAoMSAvIHggPCAwKVxufVxuXG5leHBvcnRzLm5leHRQb3dlck9mMiA9IChuKSA9PiB7XG4gIGxldCBjb3VudCA9IDBcbiAgLy8gRmlyc3QgbiBpbiB0aGUgYmVsb3cgY29uZGl0aW9uIGlzIGZvclxuICAvLyB0aGUgY2FzZSB3aGVyZSBuIGlzIDBcbiAgaWYgKG4gJiYgIShuICYgKG4gLSAxKSkpIHtcbiAgICByZXR1cm4gblxuICB9XG5cbiAgd2hpbGUgKG4gIT09IDApIHtcbiAgICBuID4+PSAxXG4gICAgY291bnQgKz0gMVxuICB9XG5cbiAgcmV0dXJuIDEgPDwgY291bnRcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVjb2RlQXNtIChzdGRsaWIsIGZvcmVpZ24sIGJ1ZmZlcikge1xuICAndXNlIGFzbSdcblxuICAvLyAtLSBJbXBvcnRzXG5cbiAgdmFyIGhlYXAgPSBuZXcgc3RkbGliLlVpbnQ4QXJyYXkoYnVmZmVyKVxuICAvLyB2YXIgbG9nID0gZm9yZWlnbi5sb2dcbiAgdmFyIHB1c2hJbnQgPSBmb3JlaWduLnB1c2hJbnRcbiAgdmFyIHB1c2hJbnQzMiA9IGZvcmVpZ24ucHVzaEludDMyXG4gIHZhciBwdXNoSW50MzJOZWcgPSBmb3JlaWduLnB1c2hJbnQzMk5lZ1xuICB2YXIgcHVzaEludDY0ID0gZm9yZWlnbi5wdXNoSW50NjRcbiAgdmFyIHB1c2hJbnQ2NE5lZyA9IGZvcmVpZ24ucHVzaEludDY0TmVnXG4gIHZhciBwdXNoRmxvYXQgPSBmb3JlaWduLnB1c2hGbG9hdFxuICB2YXIgcHVzaEZsb2F0U2luZ2xlID0gZm9yZWlnbi5wdXNoRmxvYXRTaW5nbGVcbiAgdmFyIHB1c2hGbG9hdERvdWJsZSA9IGZvcmVpZ24ucHVzaEZsb2F0RG91YmxlXG4gIHZhciBwdXNoVHJ1ZSA9IGZvcmVpZ24ucHVzaFRydWVcbiAgdmFyIHB1c2hGYWxzZSA9IGZvcmVpZ24ucHVzaEZhbHNlXG4gIHZhciBwdXNoVW5kZWZpbmVkID0gZm9yZWlnbi5wdXNoVW5kZWZpbmVkXG4gIHZhciBwdXNoTnVsbCA9IGZvcmVpZ24ucHVzaE51bGxcbiAgdmFyIHB1c2hJbmZpbml0eSA9IGZvcmVpZ24ucHVzaEluZmluaXR5XG4gIHZhciBwdXNoSW5maW5pdHlOZWcgPSBmb3JlaWduLnB1c2hJbmZpbml0eU5lZ1xuICB2YXIgcHVzaE5hTiA9IGZvcmVpZ24ucHVzaE5hTlxuICB2YXIgcHVzaE5hTk5lZyA9IGZvcmVpZ24ucHVzaE5hTk5lZ1xuXG4gIHZhciBwdXNoQXJyYXlTdGFydCA9IGZvcmVpZ24ucHVzaEFycmF5U3RhcnRcbiAgdmFyIHB1c2hBcnJheVN0YXJ0Rml4ZWQgPSBmb3JlaWduLnB1c2hBcnJheVN0YXJ0Rml4ZWRcbiAgdmFyIHB1c2hBcnJheVN0YXJ0Rml4ZWQzMiA9IGZvcmVpZ24ucHVzaEFycmF5U3RhcnRGaXhlZDMyXG4gIHZhciBwdXNoQXJyYXlTdGFydEZpeGVkNjQgPSBmb3JlaWduLnB1c2hBcnJheVN0YXJ0Rml4ZWQ2NFxuICB2YXIgcHVzaE9iamVjdFN0YXJ0ID0gZm9yZWlnbi5wdXNoT2JqZWN0U3RhcnRcbiAgdmFyIHB1c2hPYmplY3RTdGFydEZpeGVkID0gZm9yZWlnbi5wdXNoT2JqZWN0U3RhcnRGaXhlZFxuICB2YXIgcHVzaE9iamVjdFN0YXJ0Rml4ZWQzMiA9IGZvcmVpZ24ucHVzaE9iamVjdFN0YXJ0Rml4ZWQzMlxuICB2YXIgcHVzaE9iamVjdFN0YXJ0Rml4ZWQ2NCA9IGZvcmVpZ24ucHVzaE9iamVjdFN0YXJ0Rml4ZWQ2NFxuXG4gIHZhciBwdXNoQnl0ZVN0cmluZyA9IGZvcmVpZ24ucHVzaEJ5dGVTdHJpbmdcbiAgdmFyIHB1c2hCeXRlU3RyaW5nU3RhcnQgPSBmb3JlaWduLnB1c2hCeXRlU3RyaW5nU3RhcnRcbiAgdmFyIHB1c2hVdGY4U3RyaW5nID0gZm9yZWlnbi5wdXNoVXRmOFN0cmluZ1xuICB2YXIgcHVzaFV0ZjhTdHJpbmdTdGFydCA9IGZvcmVpZ24ucHVzaFV0ZjhTdHJpbmdTdGFydFxuXG4gIHZhciBwdXNoU2ltcGxlVW5hc3NpZ25lZCA9IGZvcmVpZ24ucHVzaFNpbXBsZVVuYXNzaWduZWRcblxuICB2YXIgcHVzaFRhZ1N0YXJ0ID0gZm9yZWlnbi5wdXNoVGFnU3RhcnRcbiAgdmFyIHB1c2hUYWdTdGFydDQgPSBmb3JlaWduLnB1c2hUYWdTdGFydDRcbiAgdmFyIHB1c2hUYWdTdGFydDggPSBmb3JlaWduLnB1c2hUYWdTdGFydDhcbiAgdmFyIHB1c2hUYWdVbmFzc2lnbmVkID0gZm9yZWlnbi5wdXNoVGFnVW5hc3NpZ25lZFxuXG4gIHZhciBwdXNoQnJlYWsgPSBmb3JlaWduLnB1c2hCcmVha1xuXG4gIHZhciBwb3cgPSBzdGRsaWIuTWF0aC5wb3dcblxuICAvLyAtLSBDb25zdGFudHNcblxuXG4gIC8vIC0tIE11dGFibGUgVmFyaWFibGVzXG5cbiAgdmFyIG9mZnNldCA9IDBcbiAgdmFyIGlucHV0TGVuZ3RoID0gMFxuICB2YXIgY29kZSA9IDBcblxuICAvLyBEZWNvZGUgYSBjYm9yIHN0cmluZyByZXByZXNlbnRlZCBhcyBVaW50OEFycmF5XG4gIC8vIHdoaWNoIGlzIGFsbG9jYXRlZCBvbiB0aGUgaGVhcCBmcm9tIDAgdG8gaW5wdXRMZW5ndGhcbiAgLy9cbiAgLy8gaW5wdXQgLSBJbnRcbiAgLy9cbiAgLy8gUmV0dXJucyBDb2RlIC0gSW50LFxuICAvLyBTdWNjZXNzID0gMFxuICAvLyBFcnJvciA+IDBcbiAgZnVuY3Rpb24gcGFyc2UgKGlucHV0KSB7XG4gICAgaW5wdXQgPSBpbnB1dCB8IDBcblxuICAgIG9mZnNldCA9IDBcbiAgICBpbnB1dExlbmd0aCA9IGlucHV0XG5cbiAgICB3aGlsZSAoKG9mZnNldCB8IDApIDwgKGlucHV0TGVuZ3RoIHwgMCkpIHtcbiAgICAgIGNvZGUgPSBqdW1wVGFibGVbaGVhcFtvZmZzZXRdICYgMjU1XShoZWFwW29mZnNldF0gfCAwKSB8IDBcblxuICAgICAgaWYgKChjb2RlIHwgMCkgPiAwKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvZGUgfCAwXG4gIH1cblxuICAvLyAtLSBIZWxwZXIgRnVuY3Rpb25cblxuICBmdW5jdGlvbiBjaGVja09mZnNldCAobikge1xuICAgIG4gPSBuIHwgMFxuXG4gICAgaWYgKCgoKG9mZnNldCB8IDApICsgKG4gfCAwKSkgfCAwKSA8IChpbnB1dExlbmd0aCB8IDApKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiAxXG4gIH1cblxuICBmdW5jdGlvbiByZWFkVUludDE2IChuKSB7XG4gICAgbiA9IG4gfCAwXG5cbiAgICByZXR1cm4gKFxuICAgICAgKGhlYXBbbiB8IDBdIDw8IDgpIHwgaGVhcFsobiArIDEpIHwgMF1cbiAgICApIHwgMFxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFVJbnQzMiAobikge1xuICAgIG4gPSBuIHwgMFxuXG4gICAgcmV0dXJuIChcbiAgICAgIChoZWFwW24gfCAwXSA8PCAyNCkgfCAoaGVhcFsobiArIDEpIHwgMF0gPDwgMTYpIHwgKGhlYXBbKG4gKyAyKSB8IDBdIDw8IDgpIHwgaGVhcFsobiArIDMpIHwgMF1cbiAgICApIHwgMFxuICB9XG5cbiAgLy8gLS0gSW5pdGlhbCBCeXRlIEhhbmRsZXJzXG5cbiAgZnVuY3Rpb24gSU5UX1AgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hJbnQob2N0ZXQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVJTlRfUF84IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMSkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hJbnQoaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMikgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9QXzE2IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMikgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hJbnQoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAzKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVSU5UX1BfMzIgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEludDMyKFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA1KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVSU5UX1BfNjQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg4KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEludDY0KFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDUpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgOSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gSU5UX04gKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hJbnQoKC0xIC0gKChvY3RldCAtIDMyKSB8IDApKSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9OXzggKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgxKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEludChcbiAgICAgICgtMSAtIChoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMCkpIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAyKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVSU5UX05fMTYgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciB2YWwgPSAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMikgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHZhbCA9IHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgcHVzaEludCgoLTEgLSAodmFsIHwgMCkpIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAzKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVSU5UX05fMzIgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEludDMyTmVnKFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA1KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVSU5UX05fNjQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg4KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEludDY0TmVnKFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDUpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgOSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQllURV9TVFJJTkcgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGFydCA9IDBcbiAgICB2YXIgZW5kID0gMFxuICAgIHZhciBzdGVwID0gMFxuXG4gICAgc3RlcCA9IChvY3RldCAtIDY0KSB8IDBcbiAgICBpZiAoY2hlY2tPZmZzZXQoc3RlcCB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBzdGFydCA9IChvZmZzZXQgKyAxKSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyAxKSB8IDApICsgKHN0ZXAgfCAwKSkgfCAwXG5cbiAgICBwdXNoQnl0ZVN0cmluZyhzdGFydCB8IDAsIGVuZCB8IDApXG5cbiAgICBvZmZzZXQgPSBlbmQgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQllURV9TVFJJTkdfOCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0YXJ0ID0gMFxuICAgIHZhciBlbmQgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcblxuICAgIGlmIChjaGVja09mZnNldCgxKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGVuZ3RoID0gaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDBcbiAgICBzdGFydCA9IChvZmZzZXQgKyAyKSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyAyKSB8IDApICsgKGxlbmd0aCB8IDApKSB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgobGVuZ3RoICsgMSkgfCAwKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEJ5dGVTdHJpbmcoc3RhcnQgfCAwLCBlbmQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gZW5kIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEJZVEVfU1RSSU5HXzE2IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgc3RhcnQgPSAwXG4gICAgdmFyIGVuZCA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBsZW5ndGggPSByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMFxuICAgIHN0YXJ0ID0gKG9mZnNldCArIDMpIHwgMFxuICAgIGVuZCA9ICgoKG9mZnNldCArIDMpIHwgMCkgKyAobGVuZ3RoIHwgMCkpIHwgMFxuXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoKGxlbmd0aCArIDIpIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hCeXRlU3RyaW5nKHN0YXJ0IHwgMCwgZW5kIHwgMClcblxuICAgIG9mZnNldCA9IGVuZCB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBCWVRFX1NUUklOR18zMiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0YXJ0ID0gMFxuICAgIHZhciBlbmQgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGVuZ3RoID0gcmVhZFVJbnQzMigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICBzdGFydCA9IChvZmZzZXQgKyA1KSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyA1KSB8IDApICsgKGxlbmd0aCB8IDApKSB8IDBcblxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KChsZW5ndGggKyA0KSB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoQnl0ZVN0cmluZyhzdGFydCB8IDAsIGVuZCB8IDApXG5cbiAgICBvZmZzZXQgPSBlbmQgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQllURV9TVFJJTkdfNjQgKG9jdGV0KSB7XG4gICAgLy8gTk9UIElNUExFTUVOVEVEXG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHJldHVybiAxXG4gIH1cblxuICBmdW5jdGlvbiBCWVRFX1NUUklOR19CUkVBSyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaEJ5dGVTdHJpbmdTdGFydCgpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVVRGOF9TVFJJTkcgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGFydCA9IDBcbiAgICB2YXIgZW5kID0gMFxuICAgIHZhciBzdGVwID0gMFxuXG4gICAgc3RlcCA9IChvY3RldCAtIDk2KSB8IDBcblxuICAgIGlmIChjaGVja09mZnNldChzdGVwIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHN0YXJ0ID0gKG9mZnNldCArIDEpIHwgMFxuICAgIGVuZCA9ICgoKG9mZnNldCArIDEpIHwgMCkgKyAoc3RlcCB8IDApKSB8IDBcblxuICAgIHB1c2hVdGY4U3RyaW5nKHN0YXJ0IHwgMCwgZW5kIHwgMClcblxuICAgIG9mZnNldCA9IGVuZCB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVVEY4X1NUUklOR184IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgc3RhcnQgPSAwXG4gICAgdmFyIGVuZCA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDEpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBsZW5ndGggPSBoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMFxuICAgIHN0YXJ0ID0gKG9mZnNldCArIDIpIHwgMFxuICAgIGVuZCA9ICgoKG9mZnNldCArIDIpIHwgMCkgKyAobGVuZ3RoIHwgMCkpIHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KChsZW5ndGggKyAxKSB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoVXRmOFN0cmluZyhzdGFydCB8IDAsIGVuZCB8IDApXG5cbiAgICBvZmZzZXQgPSBlbmQgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVVRGOF9TVFJJTkdfMTYgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGFydCA9IDBcbiAgICB2YXIgZW5kID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMikgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGxlbmd0aCA9IHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgc3RhcnQgPSAob2Zmc2V0ICsgMykgfCAwXG4gICAgZW5kID0gKCgob2Zmc2V0ICsgMykgfCAwKSArIChsZW5ndGggfCAwKSkgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoKGxlbmd0aCArIDIpIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hVdGY4U3RyaW5nKHN0YXJ0IHwgMCwgZW5kIHwgMClcblxuICAgIG9mZnNldCA9IGVuZCB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVVEY4X1NUUklOR18zMiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0YXJ0ID0gMFxuICAgIHZhciBlbmQgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGVuZ3RoID0gcmVhZFVJbnQzMigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICBzdGFydCA9IChvZmZzZXQgKyA1KSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyA1KSB8IDApICsgKGxlbmd0aCB8IDApKSB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgobGVuZ3RoICsgNCkgfCAwKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaFV0ZjhTdHJpbmcoc3RhcnQgfCAwLCBlbmQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gZW5kIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVURjhfU1RSSU5HXzY0IChvY3RldCkge1xuICAgIC8vIE5PVCBJTVBMRU1FTlRFRFxuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICByZXR1cm4gMVxuICB9XG5cbiAgZnVuY3Rpb24gVVRGOF9TVFJJTkdfQlJFQUsgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hVdGY4U3RyaW5nU3RhcnQoKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEFSUkFZIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoQXJyYXlTdGFydEZpeGVkKChvY3RldCAtIDEyOCkgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEFSUkFZXzggKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgxKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEFycmF5U3RhcnRGaXhlZChoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAyKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBBUlJBWV8xNiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoQXJyYXlTdGFydEZpeGVkKFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMykgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQVJSQVlfMzIgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEFycmF5U3RhcnRGaXhlZDMyKFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA1KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBBUlJBWV82NCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDgpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoQXJyYXlTdGFydEZpeGVkNjQoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDMpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA3KSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA5KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBBUlJBWV9CUkVBSyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaEFycmF5U3RhcnQoKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIE1BUCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0ZXAgPSAwXG5cbiAgICBzdGVwID0gKG9jdGV0IC0gMTYwKSB8IDBcblxuICAgIGlmIChjaGVja09mZnNldChzdGVwIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hPYmplY3RTdGFydEZpeGVkKHN0ZXAgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIE1BUF84IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMSkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hPYmplY3RTdGFydEZpeGVkKGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDIpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIE1BUF8xNiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDMpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIE1BUF8zMiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDQpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZDMyKFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA1KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBNQVBfNjQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg4KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQ2NChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA1KSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDcpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDkpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIE1BUF9CUkVBSyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaE9iamVjdFN0YXJ0KClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfS05PV04gKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydCgob2N0ZXQgLSAxOTJ8IDApIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfQklHTlVNX1BPUyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfQklHTlVNX05FRyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfRlJBQyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfQklHTlVNX0ZMT0FUIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVGFnU3RhcnQob2N0ZXQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19VTkFTU0lHTkVEIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVGFnU3RhcnQoKG9jdGV0IC0gMTkyfCAwKSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0JBU0U2NF9VUkwgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydChvY3RldCB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0JBU0U2NCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfQkFTRTE2IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVGFnU3RhcnQob2N0ZXQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19NT1JFXzEgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgxKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaFRhZ1N0YXJ0KGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDIgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19NT1JFXzIgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgyKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaFRhZ1N0YXJ0KFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMyB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX01PUkVfNCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDQpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoVGFnU3RhcnQ0KFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA1IHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfTU9SRV84IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoOCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hUYWdTdGFydDgoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDMpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA3KSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA5IHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBTSU1QTEVfVU5BU1NJR05FRCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFNpbXBsZVVuYXNzaWduZWQoKChvY3RldCB8IDApIC0gMjI0KSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX0ZBTFNFIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoRmFsc2UoKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFNJTVBMRV9UUlVFIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVHJ1ZSgpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX05VTEwgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hOdWxsKClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBTSU1QTEVfVU5ERUZJTkVEIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVW5kZWZpbmVkKClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBTSU1QTEVfQllURSAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDEpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoU2ltcGxlVW5hc3NpZ25lZChoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAyKSAgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX0ZMT0FUX0hBTEYgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBmID0gMFxuICAgIHZhciBnID0gMFxuICAgIHZhciBzaWduID0gMS4wXG4gICAgdmFyIGV4cCA9IDAuMFxuICAgIHZhciBtYW50ID0gMC4wXG4gICAgdmFyIHIgPSAwLjBcbiAgICBpZiAoY2hlY2tPZmZzZXQoMikgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGYgPSBoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMFxuICAgIGcgPSBoZWFwWyhvZmZzZXQgKyAyKSB8IDBdIHwgMFxuXG4gICAgaWYgKChmIHwgMCkgJiAweDgwKSB7XG4gICAgICBzaWduID0gLTEuMFxuICAgIH1cblxuICAgIGV4cCA9ICsoKChmIHwgMCkgJiAweDdDKSA+PiAyKVxuICAgIG1hbnQgPSArKCgoKGYgfCAwKSAmIDB4MDMpIDw8IDgpIHwgZylcblxuICAgIGlmICgrZXhwID09IDAuMCkge1xuICAgICAgcHVzaEZsb2F0KCsoXG4gICAgICAgICgrc2lnbikgKiArNS45NjA0NjQ0Nzc1MzkwNjI1ZS04ICogKCttYW50KVxuICAgICAgKSlcbiAgICB9IGVsc2UgaWYgKCtleHAgPT0gMzEuMCkge1xuICAgICAgaWYgKCtzaWduID09IDEuMCkge1xuICAgICAgICBpZiAoK21hbnQgPiAwLjApIHtcbiAgICAgICAgICBwdXNoTmFOKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoSW5maW5pdHkoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoK21hbnQgPiAwLjApIHtcbiAgICAgICAgICBwdXNoTmFOTmVnKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoSW5maW5pdHlOZWcoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hGbG9hdCgrKFxuICAgICAgICArc2lnbiAqIHBvdygrMiwgKygrZXhwIC0gMjUuMCkpICogKygxMDI0LjAgKyBtYW50KVxuICAgICAgKSlcbiAgICB9XG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMykgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX0ZMT0FUX1NJTkdMRSAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDQpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoRmxvYXRTaW5nbGUoXG4gICAgICBoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDIpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgMykgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyA0KSB8IDBdIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA1KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBTSU1QTEVfRkxPQVRfRE9VQkxFIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoOCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hGbG9hdERvdWJsZShcbiAgICAgIGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgMikgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyAzKSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDQpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgNSkgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyA2KSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDcpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgOCkgfCAwXSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgOSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gRVJST1IgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHJldHVybiAxXG4gIH1cblxuICBmdW5jdGlvbiBCUkVBSyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaEJyZWFrKClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICAvLyAtLSBKdW1wIFRhYmxlXG5cbiAgdmFyIGp1bXBUYWJsZSA9IFtcbiAgICAvLyBJbnRlZ2VyIDB4MDAuLjB4MTcgKDAuLjIzKVxuICAgIElOVF9QLCAvLyAweDAwXG4gICAgSU5UX1AsIC8vIDB4MDFcbiAgICBJTlRfUCwgLy8gMHgwMlxuICAgIElOVF9QLCAvLyAweDAzXG4gICAgSU5UX1AsIC8vIDB4MDRcbiAgICBJTlRfUCwgLy8gMHgwNVxuICAgIElOVF9QLCAvLyAweDA2XG4gICAgSU5UX1AsIC8vIDB4MDdcbiAgICBJTlRfUCwgLy8gMHgwOFxuICAgIElOVF9QLCAvLyAweDA5XG4gICAgSU5UX1AsIC8vIDB4MEFcbiAgICBJTlRfUCwgLy8gMHgwQlxuICAgIElOVF9QLCAvLyAweDBDXG4gICAgSU5UX1AsIC8vIDB4MERcbiAgICBJTlRfUCwgLy8gMHgwRVxuICAgIElOVF9QLCAvLyAweDBGXG4gICAgSU5UX1AsIC8vIDB4MTBcbiAgICBJTlRfUCwgLy8gMHgxMVxuICAgIElOVF9QLCAvLyAweDEyXG4gICAgSU5UX1AsIC8vIDB4MTNcbiAgICBJTlRfUCwgLy8gMHgxNFxuICAgIElOVF9QLCAvLyAweDE1XG4gICAgSU5UX1AsIC8vIDB4MTZcbiAgICBJTlRfUCwgLy8gMHgxN1xuICAgIC8vIFVuc2lnbmVkIGludGVnZXIgKG9uZS1ieXRlIHVpbnQ4X3QgZm9sbG93cylcbiAgICBVSU5UX1BfOCwgLy8gMHgxOFxuICAgIC8vIFVuc2lnbmVkIGludGVnZXIgKHR3by1ieXRlIHVpbnQxNl90IGZvbGxvd3MpXG4gICAgVUlOVF9QXzE2LCAvLyAweDE5XG4gICAgLy8gVW5zaWduZWQgaW50ZWdlciAoZm91ci1ieXRlIHVpbnQzMl90IGZvbGxvd3MpXG4gICAgVUlOVF9QXzMyLCAvLyAweDFhXG4gICAgLy8gVW5zaWduZWQgaW50ZWdlciAoZWlnaHQtYnl0ZSB1aW50NjRfdCBmb2xsb3dzKVxuICAgIFVJTlRfUF82NCwgLy8gMHgxYlxuICAgIEVSUk9SLCAvLyAweDFjXG4gICAgRVJST1IsIC8vIDB4MWRcbiAgICBFUlJPUiwgLy8gMHgxZVxuICAgIEVSUk9SLCAvLyAweDFmXG4gICAgLy8gTmVnYXRpdmUgaW50ZWdlciAtMS0weDAwLi4tMS0weDE3ICgtMS4uLTI0KVxuICAgIElOVF9OLCAvLyAweDIwXG4gICAgSU5UX04sIC8vIDB4MjFcbiAgICBJTlRfTiwgLy8gMHgyMlxuICAgIElOVF9OLCAvLyAweDIzXG4gICAgSU5UX04sIC8vIDB4MjRcbiAgICBJTlRfTiwgLy8gMHgyNVxuICAgIElOVF9OLCAvLyAweDI2XG4gICAgSU5UX04sIC8vIDB4MjdcbiAgICBJTlRfTiwgLy8gMHgyOFxuICAgIElOVF9OLCAvLyAweDI5XG4gICAgSU5UX04sIC8vIDB4MkFcbiAgICBJTlRfTiwgLy8gMHgyQlxuICAgIElOVF9OLCAvLyAweDJDXG4gICAgSU5UX04sIC8vIDB4MkRcbiAgICBJTlRfTiwgLy8gMHgyRVxuICAgIElOVF9OLCAvLyAweDJGXG4gICAgSU5UX04sIC8vIDB4MzBcbiAgICBJTlRfTiwgLy8gMHgzMVxuICAgIElOVF9OLCAvLyAweDMyXG4gICAgSU5UX04sIC8vIDB4MzNcbiAgICBJTlRfTiwgLy8gMHgzNFxuICAgIElOVF9OLCAvLyAweDM1XG4gICAgSU5UX04sIC8vIDB4MzZcbiAgICBJTlRfTiwgLy8gMHgzN1xuICAgIC8vIE5lZ2F0aXZlIGludGVnZXIgLTEtbiAob25lLWJ5dGUgdWludDhfdCBmb3IgbiBmb2xsb3dzKVxuICAgIFVJTlRfTl84LCAvLyAweDM4XG4gICAgLy8gTmVnYXRpdmUgaW50ZWdlciAtMS1uICh0d28tYnl0ZSB1aW50MTZfdCBmb3IgbiBmb2xsb3dzKVxuICAgIFVJTlRfTl8xNiwgLy8gMHgzOVxuICAgIC8vIE5lZ2F0aXZlIGludGVnZXIgLTEtbiAoZm91ci1ieXRlIHVpbnQzMl90IGZvciBuZm9sbG93cylcbiAgICBVSU5UX05fMzIsIC8vIDB4M2FcbiAgICAvLyBOZWdhdGl2ZSBpbnRlZ2VyIC0xLW4gKGVpZ2h0LWJ5dGUgdWludDY0X3QgZm9yIG4gZm9sbG93cylcbiAgICBVSU5UX05fNjQsIC8vIDB4M2JcbiAgICBFUlJPUiwgLy8gMHgzY1xuICAgIEVSUk9SLCAvLyAweDNkXG4gICAgRVJST1IsIC8vIDB4M2VcbiAgICBFUlJPUiwgLy8gMHgzZlxuICAgIC8vIGJ5dGUgc3RyaW5nICgweDAwLi4weDE3IGJ5dGVzIGZvbGxvdylcbiAgICBCWVRFX1NUUklORywgLy8gMHg0MFxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQxXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDJcbiAgICBCWVRFX1NUUklORywgLy8gMHg0M1xuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQ0XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDVcbiAgICBCWVRFX1NUUklORywgLy8gMHg0NlxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQ3XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDhcbiAgICBCWVRFX1NUUklORywgLy8gMHg0OVxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDRBXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NEJcbiAgICBCWVRFX1NUUklORywgLy8gMHg0Q1xuICAgIEJZVEVfU1RSSU5HLCAvLyAweDREXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NEVcbiAgICBCWVRFX1NUUklORywgLy8gMHg0RlxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDUwXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NTFcbiAgICBCWVRFX1NUUklORywgLy8gMHg1MlxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDUzXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NTRcbiAgICBCWVRFX1NUUklORywgLy8gMHg1NVxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDU2XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NTdcbiAgICAvLyBieXRlIHN0cmluZyAob25lLWJ5dGUgdWludDhfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgQllURV9TVFJJTkdfOCwgLy8gMHg1OFxuICAgIC8vIGJ5dGUgc3RyaW5nICh0d28tYnl0ZSB1aW50MTZfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgQllURV9TVFJJTkdfMTYsIC8vIDB4NTlcbiAgICAvLyBieXRlIHN0cmluZyAoZm91ci1ieXRlIHVpbnQzMl90IGZvciBuLCBhbmQgdGhlbiBuIGJ5dGVzIGZvbGxvdylcbiAgICBCWVRFX1NUUklOR18zMiwgLy8gMHg1YVxuICAgIC8vIGJ5dGUgc3RyaW5nIChlaWdodC1ieXRlIHVpbnQ2NF90IGZvciBuLCBhbmQgdGhlbiBuIGJ5dGVzIGZvbGxvdylcbiAgICBCWVRFX1NUUklOR182NCwgLy8gMHg1YlxuICAgIEVSUk9SLCAvLyAweDVjXG4gICAgRVJST1IsIC8vIDB4NWRcbiAgICBFUlJPUiwgLy8gMHg1ZVxuICAgIC8vIGJ5dGUgc3RyaW5nLCBieXRlIHN0cmluZ3MgZm9sbG93LCB0ZXJtaW5hdGVkIGJ5IFwiYnJlYWtcIlxuICAgIEJZVEVfU1RSSU5HX0JSRUFLLCAvLyAweDVmXG4gICAgLy8gVVRGLTggc3RyaW5nICgweDAwLi4weDE3IGJ5dGVzIGZvbGxvdylcbiAgICBVVEY4X1NUUklORywgLy8gMHg2MFxuICAgIFVURjhfU1RSSU5HLCAvLyAweDYxXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjJcbiAgICBVVEY4X1NUUklORywgLy8gMHg2M1xuICAgIFVURjhfU1RSSU5HLCAvLyAweDY0XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjVcbiAgICBVVEY4X1NUUklORywgLy8gMHg2NlxuICAgIFVURjhfU1RSSU5HLCAvLyAweDY3XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjhcbiAgICBVVEY4X1NUUklORywgLy8gMHg2OVxuICAgIFVURjhfU1RSSU5HLCAvLyAweDZBXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NkJcbiAgICBVVEY4X1NUUklORywgLy8gMHg2Q1xuICAgIFVURjhfU1RSSU5HLCAvLyAweDZEXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NkVcbiAgICBVVEY4X1NUUklORywgLy8gMHg2RlxuICAgIFVURjhfU1RSSU5HLCAvLyAweDcwXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NzFcbiAgICBVVEY4X1NUUklORywgLy8gMHg3MlxuICAgIFVURjhfU1RSSU5HLCAvLyAweDczXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NzRcbiAgICBVVEY4X1NUUklORywgLy8gMHg3NVxuICAgIFVURjhfU1RSSU5HLCAvLyAweDc2XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NzdcbiAgICAvLyBVVEYtOCBzdHJpbmcgKG9uZS1ieXRlIHVpbnQ4X3QgZm9yIG4sIGFuZCB0aGVuIG4gYnl0ZXMgZm9sbG93KVxuICAgIFVURjhfU1RSSU5HXzgsIC8vIDB4NzhcbiAgICAvLyBVVEYtOCBzdHJpbmcgKHR3by1ieXRlIHVpbnQxNl90IGZvciBuLCBhbmQgdGhlbiBuIGJ5dGVzIGZvbGxvdylcbiAgICBVVEY4X1NUUklOR18xNiwgLy8gMHg3OVxuICAgIC8vIFVURi04IHN0cmluZyAoZm91ci1ieXRlIHVpbnQzMl90IGZvciBuLCBhbmQgdGhlbiBuIGJ5dGVzIGZvbGxvdylcbiAgICBVVEY4X1NUUklOR18zMiwgLy8gMHg3YVxuICAgIC8vIFVURi04IHN0cmluZyAoZWlnaHQtYnl0ZSB1aW50NjRfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgVVRGOF9TVFJJTkdfNjQsIC8vIDB4N2JcbiAgICAvLyBVVEYtOCBzdHJpbmcsIFVURi04IHN0cmluZ3MgZm9sbG93LCB0ZXJtaW5hdGVkIGJ5IFwiYnJlYWtcIlxuICAgIEVSUk9SLCAvLyAweDdjXG4gICAgRVJST1IsIC8vIDB4N2RcbiAgICBFUlJPUiwgLy8gMHg3ZVxuICAgIFVURjhfU1RSSU5HX0JSRUFLLCAvLyAweDdmXG4gICAgLy8gYXJyYXkgKDB4MDAuLjB4MTcgZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgQVJSQVksIC8vIDB4ODBcbiAgICBBUlJBWSwgLy8gMHg4MVxuICAgIEFSUkFZLCAvLyAweDgyXG4gICAgQVJSQVksIC8vIDB4ODNcbiAgICBBUlJBWSwgLy8gMHg4NFxuICAgIEFSUkFZLCAvLyAweDg1XG4gICAgQVJSQVksIC8vIDB4ODZcbiAgICBBUlJBWSwgLy8gMHg4N1xuICAgIEFSUkFZLCAvLyAweDg4XG4gICAgQVJSQVksIC8vIDB4ODlcbiAgICBBUlJBWSwgLy8gMHg4QVxuICAgIEFSUkFZLCAvLyAweDhCXG4gICAgQVJSQVksIC8vIDB4OENcbiAgICBBUlJBWSwgLy8gMHg4RFxuICAgIEFSUkFZLCAvLyAweDhFXG4gICAgQVJSQVksIC8vIDB4OEZcbiAgICBBUlJBWSwgLy8gMHg5MFxuICAgIEFSUkFZLCAvLyAweDkxXG4gICAgQVJSQVksIC8vIDB4OTJcbiAgICBBUlJBWSwgLy8gMHg5M1xuICAgIEFSUkFZLCAvLyAweDk0XG4gICAgQVJSQVksIC8vIDB4OTVcbiAgICBBUlJBWSwgLy8gMHg5NlxuICAgIEFSUkFZLCAvLyAweDk3XG4gICAgLy8gYXJyYXkgKG9uZS1ieXRlIHVpbnQ4X3QgZm8sIGFuZCB0aGVuIG4gZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgQVJSQVlfOCwgLy8gMHg5OFxuICAgIC8vIGFycmF5ICh0d28tYnl0ZSB1aW50MTZfdCBmb3IgbiwgYW5kIHRoZW4gbiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBBUlJBWV8xNiwgLy8gMHg5OVxuICAgIC8vIGFycmF5IChmb3VyLWJ5dGUgdWludDMyX3QgZm9yIG4sIGFuZCB0aGVuIG4gZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgQVJSQVlfMzIsIC8vIDB4OWFcbiAgICAvLyBhcnJheSAoZWlnaHQtYnl0ZSB1aW50NjRfdCBmb3IgbiwgYW5kIHRoZW4gbiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBBUlJBWV82NCwgLy8gMHg5YlxuICAgIC8vIGFycmF5LCBkYXRhIGl0ZW1zIGZvbGxvdywgdGVybWluYXRlZCBieSBcImJyZWFrXCJcbiAgICBFUlJPUiwgLy8gMHg5Y1xuICAgIEVSUk9SLCAvLyAweDlkXG4gICAgRVJST1IsIC8vIDB4OWVcbiAgICBBUlJBWV9CUkVBSywgLy8gMHg5ZlxuICAgIC8vIG1hcCAoMHgwMC4uMHgxNyBwYWlycyBvZiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBNQVAsIC8vIDB4YTBcbiAgICBNQVAsIC8vIDB4YTFcbiAgICBNQVAsIC8vIDB4YTJcbiAgICBNQVAsIC8vIDB4YTNcbiAgICBNQVAsIC8vIDB4YTRcbiAgICBNQVAsIC8vIDB4YTVcbiAgICBNQVAsIC8vIDB4YTZcbiAgICBNQVAsIC8vIDB4YTdcbiAgICBNQVAsIC8vIDB4YThcbiAgICBNQVAsIC8vIDB4YTlcbiAgICBNQVAsIC8vIDB4YUFcbiAgICBNQVAsIC8vIDB4YUJcbiAgICBNQVAsIC8vIDB4YUNcbiAgICBNQVAsIC8vIDB4YURcbiAgICBNQVAsIC8vIDB4YUVcbiAgICBNQVAsIC8vIDB4YUZcbiAgICBNQVAsIC8vIDB4YjBcbiAgICBNQVAsIC8vIDB4YjFcbiAgICBNQVAsIC8vIDB4YjJcbiAgICBNQVAsIC8vIDB4YjNcbiAgICBNQVAsIC8vIDB4YjRcbiAgICBNQVAsIC8vIDB4YjVcbiAgICBNQVAsIC8vIDB4YjZcbiAgICBNQVAsIC8vIDB4YjdcbiAgICAvLyBtYXAgKG9uZS1ieXRlIHVpbnQ4X3QgZm9yIG4sIGFuZCB0aGVuIG4gcGFpcnMgb2YgZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgTUFQXzgsIC8vIDB4YjhcbiAgICAvLyBtYXAgKHR3by1ieXRlIHVpbnQxNl90IGZvciBuLCBhbmQgdGhlbiBuIHBhaXJzIG9mIGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIE1BUF8xNiwgLy8gMHhiOVxuICAgIC8vIG1hcCAoZm91ci1ieXRlIHVpbnQzMl90IGZvciBuLCBhbmQgdGhlbiBuIHBhaXJzIG9mIGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIE1BUF8zMiwgLy8gMHhiYVxuICAgIC8vIG1hcCAoZWlnaHQtYnl0ZSB1aW50NjRfdCBmb3IgbiwgYW5kIHRoZW4gbiBwYWlycyBvZiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBNQVBfNjQsIC8vIDB4YmJcbiAgICBFUlJPUiwgLy8gMHhiY1xuICAgIEVSUk9SLCAvLyAweGJkXG4gICAgRVJST1IsIC8vIDB4YmVcbiAgICAvLyBtYXAsIHBhaXJzIG9mIGRhdGEgaXRlbXMgZm9sbG93LCB0ZXJtaW5hdGVkIGJ5IFwiYnJlYWtcIlxuICAgIE1BUF9CUkVBSywgLy8gMHhiZlxuICAgIC8vIFRleHQtYmFzZWQgZGF0ZS90aW1lIChkYXRhIGl0ZW0gZm9sbG93czsgc2VlIFNlY3Rpb24gMi40LjEpXG4gICAgVEFHX0tOT1dOLCAvLyAweGMwXG4gICAgLy8gRXBvY2gtYmFzZWQgZGF0ZS90aW1lIChkYXRhIGl0ZW0gZm9sbG93czsgc2VlIFNlY3Rpb24gMi40LjEpXG4gICAgVEFHX0tOT1dOLCAvLyAweGMxXG4gICAgLy8gUG9zaXRpdmUgYmlnbnVtIChkYXRhIGl0ZW0gXCJieXRlIHN0cmluZ1wiIGZvbGxvd3MpXG4gICAgVEFHX0tOT1dOLCAvLyAweGMyXG4gICAgLy8gTmVnYXRpdmUgYmlnbnVtIChkYXRhIGl0ZW0gXCJieXRlIHN0cmluZ1wiIGZvbGxvd3MpXG4gICAgVEFHX0tOT1dOLCAvLyAweGMzXG4gICAgLy8gRGVjaW1hbCBGcmFjdGlvbiAoZGF0YSBpdGVtIFwiYXJyYXlcIiBmb2xsb3dzOyBzZWUgU2VjdGlvbiAyLjQuMylcbiAgICBUQUdfS05PV04sIC8vIDB4YzRcbiAgICAvLyBCaWdmbG9hdCAoZGF0YSBpdGVtIFwiYXJyYXlcIiBmb2xsb3dzOyBzZWUgU2VjdGlvbiAyLjQuMylcbiAgICBUQUdfS05PV04sIC8vIDB4YzVcbiAgICAvLyAodGFnZ2VkIGl0ZW0pXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4YzZcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjN1xuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGM4XG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4YzlcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjYVxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGNiXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4Y2NcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjZFxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGNlXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4Y2ZcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhkMFxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGQxXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4ZDJcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhkM1xuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGQ0XG4gICAgLy8gRXhwZWN0ZWQgQ29udmVyc2lvbiAoZGF0YSBpdGVtIGZvbGxvd3M7IHNlZSBTZWN0aW9uIDIuNC40LjIpXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4ZDVcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhkNlxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGQ3XG4gICAgLy8gKG1vcmUgdGFnZ2VkIGl0ZW1zLCAxLzIvNC84IGJ5dGVzIGFuZCB0aGVuIGEgZGF0YSBpdGVtIGZvbGxvdylcbiAgICBUQUdfTU9SRV8xLCAvLyAweGQ4XG4gICAgVEFHX01PUkVfMiwgLy8gMHhkOVxuICAgIFRBR19NT1JFXzQsIC8vIDB4ZGFcbiAgICBUQUdfTU9SRV84LCAvLyAweGRiXG4gICAgRVJST1IsIC8vIDB4ZGNcbiAgICBFUlJPUiwgLy8gMHhkZFxuICAgIEVSUk9SLCAvLyAweGRlXG4gICAgRVJST1IsIC8vIDB4ZGZcbiAgICAvLyAoc2ltcGxlIHZhbHVlKVxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGUwXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZTFcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlMlxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGUzXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZTRcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlNVxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGU2XG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZTdcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlOFxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGU5XG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZWFcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlYlxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGVjXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZWRcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlZVxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGVmXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZjBcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhmMVxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGYyXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZjNcbiAgICAvLyBGYWxzZVxuICAgIFNJTVBMRV9GQUxTRSwgLy8gMHhmNFxuICAgIC8vIFRydWVcbiAgICBTSU1QTEVfVFJVRSwgLy8gMHhmNVxuICAgIC8vIE51bGxcbiAgICBTSU1QTEVfTlVMTCwgLy8gMHhmNlxuICAgIC8vIFVuZGVmaW5lZFxuICAgIFNJTVBMRV9VTkRFRklORUQsIC8vIDB4ZjdcbiAgICAvLyAoc2ltcGxlIHZhbHVlLCBvbmUgYnl0ZSBmb2xsb3dzKVxuICAgIFNJTVBMRV9CWVRFLCAvLyAweGY4XG4gICAgLy8gSGFsZi1QcmVjaXNpb24gRmxvYXQgKHR3by1ieXRlIElFRUUgNzU0KVxuICAgIFNJTVBMRV9GTE9BVF9IQUxGLCAvLyAweGY5XG4gICAgLy8gU2luZ2xlLVByZWNpc2lvbiBGbG9hdCAoZm91ci1ieXRlIElFRUUgNzU0KVxuICAgIFNJTVBMRV9GTE9BVF9TSU5HTEUsIC8vIDB4ZmFcbiAgICAvLyBEb3VibGUtUHJlY2lzaW9uIEZsb2F0IChlaWdodC1ieXRlIElFRUUgNzU0KVxuICAgIFNJTVBMRV9GTE9BVF9ET1VCTEUsIC8vIDB4ZmJcbiAgICBFUlJPUiwgLy8gMHhmY1xuICAgIEVSUk9SLCAvLyAweGZkXG4gICAgRVJST1IsIC8vIDB4ZmVcbiAgICAvLyBcImJyZWFrXCIgc3RvcCBjb2RlXG4gICAgQlJFQUsgLy8gMHhmZlxuICBdXG5cbiAgLy8gLS1cblxuICByZXR1cm4ge1xuICAgIHBhcnNlOiBwYXJzZVxuICB9XG59XG4iLCI7KGZ1bmN0aW9uIChnbG9iYWxPYmplY3QpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4vKlxyXG4gKiAgICAgIGJpZ251bWJlci5qcyB2OS4wLjFcclxuICogICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAyMCBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgICAgIE1JVCBMaWNlbnNlZC5cclxuICpcclxuICogICAgICBCaWdOdW1iZXIucHJvdG90eXBlIG1ldGhvZHMgICAgIHwgIEJpZ051bWJlciBtZXRob2RzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgIGFicyAgICB8ICBjbG9uZVxyXG4gKiAgICAgIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgICAgICAgfCAgY29uZmlnICAgICAgICAgICAgICAgc2V0XHJcbiAqICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgIGRwICAgICB8ICAgICAgREVDSU1BTF9QTEFDRVNcclxuICogICAgICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgZGl2ICAgIHwgICAgICBST1VORElOR19NT0RFXHJcbiAqICAgICAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgIGlkaXYgICB8ICAgICAgRVhQT05FTlRJQUxfQVRcclxuICogICAgICBleHBvbmVudGlhdGVkQnkgICAgICAgICAgcG93ICAgIHwgICAgICBSQU5HRVxyXG4gKiAgICAgIGludGVnZXJWYWx1ZSAgICAgICAgICAgICAgICAgICAgfCAgICAgIENSWVBUT1xyXG4gKiAgICAgIGlzRXF1YWxUbyAgICAgICAgICAgICAgICBlcSAgICAgfCAgICAgIE1PRFVMT19NT0RFXHJcbiAqICAgICAgaXNGaW5pdGUgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgUE9XX1BSRUNJU0lPTlxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW4gICAgICAgICAgICBndCAgICAgfCAgICAgIEZPUk1BVFxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8gICBndGUgICAgfCAgICAgIEFMUEhBQkVUXHJcbiAqICAgICAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgICB8ICBpc0JpZ051bWJlclxyXG4gKiAgICAgIGlzTGVzc1RoYW4gICAgICAgICAgICAgICBsdCAgICAgfCAgbWF4aW11bSAgICAgICAgICAgICAgbWF4XHJcbiAqICAgICAgaXNMZXNzVGhhbk9yRXF1YWxUbyAgICAgIGx0ZSAgICB8ICBtaW5pbXVtICAgICAgICAgICAgICBtaW5cclxuICogICAgICBpc05hTiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJhbmRvbVxyXG4gKiAgICAgIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgICAgICAgfCAgc3VtXHJcbiAqICAgICAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgaXNaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbWludXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbW9kdWxvICAgICAgICAgICAgICAgICAgIG1vZCAgICB8XHJcbiAqICAgICAgbXVsdGlwbGllZEJ5ICAgICAgICAgICAgIHRpbWVzICB8XHJcbiAqICAgICAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcGx1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcHJlY2lzaW9uICAgICAgICAgICAgICAgIHNkICAgICB8XHJcbiAqICAgICAgc2hpZnRlZEJ5ICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgIHNxcnQgICB8XHJcbiAqICAgICAgdG9FeHBvbmVudGlhbCAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GaXhlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9Gb3JtYXQgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GcmFjdGlvbiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9KU09OICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9OdW1iZXIgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9QcmVjaXNpb24gICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbiAgdmFyIEJpZ051bWJlcixcclxuICAgIGlzTnVtZXJpYyA9IC9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cclxuICAgIGJpZ251bWJlckVycm9yID0gJ1tCaWdOdW1iZXIgRXJyb3JdICcsXHJcbiAgICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgICBCQVNFID0gMWUxNCxcclxuICAgIExPR19CQVNFID0gMTQsXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXHJcbiAgICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gICAgLy8gRURJVEFCTEVcclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxyXG4gICAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gICAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xvbmUoY29uZmlnT2JqZWN0KSB7XHJcbiAgICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IEJpZ051bWJlciwgdG9TdHJpbmc6IG51bGwsIHZhbHVlT2Y6IG51bGwgfSxcclxuICAgICAgT05FID0gbmV3IEJpZ051bWJlcigxKSxcclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cclxuICAgICAgLy8gVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5zZXQuXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAgIC8vIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgLy8gRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgLy8gSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAvLyBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzICd0cnVuY2F0ZWQgZGl2aXNpb24nIGFuZCBpc1xyXG4gICAgICAvLyAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cclxuICAgICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgICAgLy8gRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcclxuICAgICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgICAgLy8gQWx0aG91Z2ggdGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvIGJlIHVzZWQsIHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgUE9XX1BSRUNJU0lPTiA9IDAsICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgICBGT1JNQVQgPSB7XHJcbiAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgICAgc3VmZml4OiAnJ1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gVGhlIGFscGhhYmV0IHVzZWQgZm9yIGJhc2UgY29udmVyc2lvbi4gSXQgbXVzdCBiZSBhdCBsZWFzdCAyIGNoYXJhY3RlcnMgbG9uZywgd2l0aCBubyAnKycsXHJcbiAgICAgIC8vICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgIC8vICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJ1xyXG4gICAgICBBTFBIQUJFVCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xyXG5cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUlxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhlIEJpZ051bWJlciBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJpZ051bWJlciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogdiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAqIFtiXSB7bnVtYmVyfSBUaGUgYmFzZSBvZiB2LiBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJpZ051bWJlcih2LCBiKSB7XHJcbiAgICAgIHZhciBhbHBoYWJldCwgYywgY2FzZUNoYW5nZWQsIGUsIGksIGlzTnVtLCBsZW4sIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgYG5ld2AuXHJcbiAgICAgIGlmICghKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpKSByZXR1cm4gbmV3IEJpZ051bWJlcih2LCBiKTtcclxuXHJcbiAgICAgIGlmIChiID09IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHYgJiYgdi5faXNCaWdOdW1iZXIgPT09IHRydWUpIHtcclxuICAgICAgICAgIHgucyA9IHYucztcclxuXHJcbiAgICAgICAgICBpZiAoIXYuYyB8fCB2LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHYuZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5lID0gdi5lO1xyXG4gICAgICAgICAgICB4LmMgPSB2LmMuc2xpY2UoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpICYmIHYgKiAwID09IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBVc2UgYDEgLyBuYCB0byBoYW5kbGUgbWludXMgemVybyBhbHNvLlxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHYgPSAtdiwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGludGVnZXJzLCB3aGVyZSBuIDwgMjE0NzQ4MzY0OCAoMioqMzEpLlxyXG4gICAgICAgICAgaWYgKHYgPT09IH5+dikge1xyXG4gICAgICAgICAgICBmb3IgKGUgPSAwLCBpID0gdjsgaSA+PSAxMDsgaSAvPSAxMCwgZSsrKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgICB4LmMgPSBbdl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBpZiAoIWlzTnVtZXJpYy50ZXN0KHN0ciA9IFN0cmluZyh2KSkpIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSk7XHJcblxyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgICAgICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgICAgICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgICAgIC8vIEludGVnZXIuXHJcbiAgICAgICAgICBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG5cclxuICAgICAgICAvLyBBbGxvdyBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudCwgd2hpbGVcclxuICAgICAgICAvLyBhbHNvIHJvdW5kaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXHJcbiAgICAgICAgaWYgKGIgPT0gMTApIHtcclxuICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHYpO1xyXG4gICAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcblxyXG4gICAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgaWYgKHYgKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICAgIGUgPSBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBzdHIgaXMgYSB2YWxpZCBiYXNlIGIgbnVtYmVyLlxyXG4gICAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcodiksIGlzTnVtLCBiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICAgIGlzTnVtID0gZmFsc2U7XHJcbiAgICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7KTtcclxuXHJcbiAgICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgICAgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgICAgbGVuID4gMTUgJiYgKHYgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHYgIT09IG1hdGhmbG9vcih2KSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7ICAvLyBpIDwgMVxyXG5cclxuICAgICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpID0gTE9HX0JBU0UgLSAoc3RyID0gc3RyLnNsaWNlKGkpKS5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIHguYy5wdXNoKCtzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICAgIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQWNjZXB0IGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyAoaWYgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaXNcclxuICAgICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgICAqXHJcbiAgICAgKiAgIERFQ0lNQUxfUExBQ0VTICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAgICogICBFWFBPTkVOVElBTF9BVCAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAgb3IgIFstTUFYIHRvIDAsIDAgdG8gTUFYXVxyXG4gICAgICogICBSQU5HRSAgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAobm90IHplcm8pICBvciAgWy1NQVggdG8gLTEsIDEgdG8gTUFYXVxyXG4gICAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICAgKiAgIE1PRFVMT19NT0RFICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOVxyXG4gICAgICogICBQT1dfUFJFQ0lTSU9OICAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb250YWluICcuJy5cclxuICAgICAqICAgRk9STUFUICAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggc29tZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cclxuICAgICAqICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGRlY2ltYWxTZXBhcmF0b3IgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAgICogICAgIHN1ZmZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICpcclxuICAgICAqIEUuZy5cclxuICAgICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAgICpcclxuICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCBleGNlcHQgZm9yIEFMUEhBQkVULlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHZhciBwLCB2O1xyXG5cclxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIERFQ0lNQUxfUExBQ0VTIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUk9VTkRJTkdfTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdFWFBPTkVOVElBTF9BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgMCwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtKFRPX0VYUF9QT1MgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JBTkdFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAtMSwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMSwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgICBNQVhfRVhQID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBNSU5fRVhQID0gLShNQVhfRVhQID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGNhbm5vdCBiZSB6ZXJvOiAnICsgdik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIENSWVBUTyBub3QgdHJ1ZSBvciBmYWxzZToge3Z9J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gISF2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9ICF2O1xyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgdHJ1ZSBvciBmYWxzZTogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnTU9EVUxPX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgICAgTU9EVUxPX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFBPV19QUkVDSVNJT04ge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1BPV19QUkVDSVNJT04nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnb2JqZWN0JykgRk9STUFUID0gdjtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IGFuIG9iamVjdDogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQUxQSEFCRVQgaW52YWxpZDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0FMUEhBQkVUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FsbG93IGlmIGxlc3MgdGhhbiB0d28gY2hhcmFjdGVycyxcclxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgY29udGFpbnMgJysnLCAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgYSByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uPyR8WytcXC0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICAgIEFMUEhBQkVUID0gdjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBpbnZhbGlkOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gT2JqZWN0IGV4cGVjdGVkOiB7dn0nXHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdPYmplY3QgZXhwZWN0ZWQ6ICcgKyBvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBERUNJTUFMX1BMQUNFUzogREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgUk9VTkRJTkdfTU9ERTogUk9VTkRJTkdfTU9ERSxcclxuICAgICAgICBFWFBPTkVOVElBTF9BVDogW1RPX0VYUF9ORUcsIFRPX0VYUF9QT1NdLFxyXG4gICAgICAgIFJBTkdFOiBbTUlOX0VYUCwgTUFYX0VYUF0sXHJcbiAgICAgICAgQ1JZUFRPOiBDUllQVE8sXHJcbiAgICAgICAgTU9EVUxPX01PREU6IE1PRFVMT19NT0RFLFxyXG4gICAgICAgIFBPV19QUkVDSVNJT046IFBPV19QUkVDSVNJT04sXHJcbiAgICAgICAgRk9STUFUOiBGT1JNQVQsXHJcbiAgICAgICAgQUxQSEFCRVQ6IEFMUEhBQkVUXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdiBpcyBhIEJpZ051bWJlciBpbnN0YW5jZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBJZiBCaWdOdW1iZXIuREVCVUcgaXMgdHJ1ZSwgdGhyb3cgaWYgYSBCaWdOdW1iZXIgaW5zdGFuY2UgaXMgbm90IHdlbGwtZm9ybWVkLlxyXG4gICAgICpcclxuICAgICAqIHYge2FueX1cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gSW52YWxpZCBCaWdOdW1iZXI6IHt2fSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgaWYgKCF2IHx8IHYuX2lzQmlnTnVtYmVyICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICghQmlnTnVtYmVyLkRFQlVHKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciBpLCBuLFxyXG4gICAgICAgIGMgPSB2LmMsXHJcbiAgICAgICAgZSA9IHYuZSxcclxuICAgICAgICBzID0gdi5zO1xyXG5cclxuICAgICAgb3V0OiBpZiAoe30udG9TdHJpbmcuY2FsbChjKSA9PSAnW29iamVjdCBBcnJheV0nKSB7XHJcblxyXG4gICAgICAgIGlmICgocyA9PT0gMSB8fCBzID09PSAtMSkgJiYgZSA+PSAtTUFYICYmIGUgPD0gTUFYICYmIGUgPT09IG1hdGhmbG9vcihlKSkge1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBlbGVtZW50IGlzIHplcm8sIHRoZSBCaWdOdW1iZXIgdmFsdWUgbXVzdCBiZSB6ZXJvLlxyXG4gICAgICAgICAgaWYgKGNbMF0gPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGUgPT09IDAgJiYgYy5sZW5ndGggPT09IDEpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgdGhhdCBjWzBdIHNob3VsZCBoYXZlLCBiYXNlZCBvbiB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGkgPCAxKSBpICs9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgICAgICAvL2lmIChNYXRoLmNlaWwoTWF0aC5sb2coY1swXSArIDEpIC8gTWF0aC5MTjEwKSA9PSBpKSB7XHJcbiAgICAgICAgICBpZiAoU3RyaW5nKGNbMF0pLmxlbmd0aCA9PSBpKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIG4gPSBjW2ldO1xyXG4gICAgICAgICAgICAgIGlmIChuIDwgMCB8fCBuID49IEJBU0UgfHwgbiAhPT0gbWF0aGZsb29yKG4pKSBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExhc3QgZWxlbWVudCBjYW5ub3QgYmUgemVybywgdW5sZXNzIGl0IGlzIHRoZSBvbmx5IGVsZW1lbnQuXHJcbiAgICAgICAgICAgIGlmIChuICE9PSAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAvLyBJbmZpbml0eS9OYU5cclxuICAgICAgfSBlbHNlIGlmIChjID09PSBudWxsICYmIGUgPT09IG51bGwgJiYgKHMgPT09IG51bGwgfHwgcyA9PT0gMSB8fCBzID09PSAtMSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnSW52YWxpZCBCaWdOdW1iZXI6ICcgKyB2KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1heGltdW0gPSBCaWdOdW1iZXIubWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmx0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1pbmltdW0gPSBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmd0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLFxyXG4gICAgICogYW5kIHdpdGggZHAsIG9yIERFQ0lNQUxfUExBQ0VTIGlmIGRwIGlzIG9taXR0ZWQsIGRlY2ltYWwgcGxhY2VzIChvciBsZXNzIGlmIHRyYWlsaW5nXHJcbiAgICAgKiB6ZXJvcyBhcmUgcHJvZHVjZWQpLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5yYW5kb20gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgcG93Ml81MyA9IDB4MjAwMDAwMDAwMDAwMDA7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gYSA1MyBiaXQgaW50ZWdlciBuLCB3aGVyZSAwIDw9IG4gPCA5MDA3MTk5MjU0NzQwOTkyLlxyXG4gICAgICAvLyBDaGVjayBpZiBNYXRoLnJhbmRvbSgpIHByb2R1Y2VzIG1vcmUgdGhhbiAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXHJcbiAgICAgIC8vIElmIGl0IGRvZXMsIGFzc3VtZSBhdCBsZWFzdCA1MyBiaXRzIGFyZSBwcm9kdWNlZCwgb3RoZXJ3aXNlIGFzc3VtZSBhdCBsZWFzdCAzMCBiaXRzLlxyXG4gICAgICAvLyAweDQwMDAwMDAwIGlzIDJeMzAsIDB4ODAwMDAwIGlzIDJeMjMsIDB4MWZmZmZmIGlzIDJeMjEgLSAxLlxyXG4gICAgICB2YXIgcmFuZG9tNTNiaXRJbnQgPSAoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpICYgMHgxZmZmZmZcclxuICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aGZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKTsgfVxyXG4gICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKE1hdGgucmFuZG9tKCkgKiAweDQwMDAwMDAwIHwgMCkgKiAweDgwMDAwMCkgK1xyXG4gICAgICAgICAoTWF0aC5yYW5kb20oKSAqIDB4ODAwMDAwIHwgMCk7IH07XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRwKSB7XHJcbiAgICAgICAgdmFyIGEsIGIsIGUsIGssIHYsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGMgPSBbXSxcclxuICAgICAgICAgIHJhbmQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAgIGlmIChkcCA9PSBudWxsKSBkcCA9IERFQ0lNQUxfUExBQ0VTO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcblxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChkcCAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgaWYgKENSWVBUTykge1xyXG5cclxuICAgICAgICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICAgICAgICAgIGlmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcblxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoayAqPSAyKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDUzIGJpdHM6XHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSAqIE1hdGgucG93KDIsIDIxKSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTEwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMFxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgPj4+IDExKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMHgyMDAwMCBpcyAyXjIxLlxyXG4gICAgICAgICAgICAgIHYgPSBhW2ldICogMHgyMDAwMCArIChhW2kgKyAxXSA+Pj4gMTEpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBSZWplY3Rpb24gc2FtcGxpbmc6XHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIC8vIFByb2JhYmlsaXR5IHRoYXQgdiA+PSA5ZTE1LCBpc1xyXG4gICAgICAgICAgICAgIC8vIDcxOTkyNTQ3NDA5OTIgLyA5MDA3MTk5MjU0NzQwOTkyIH49IDAuMDAwOCwgaS5lLiAxIGluIDEyNTFcclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBiID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpO1xyXG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbMF07XHJcbiAgICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPD0gODk5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBidWZmZXJcclxuICAgICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDcpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMDAwMDAgaXMgMl40OCwgMHgxMDAwMDAwMDAwMCBpcyAyXjQwXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAgaXMgMl4zMiwgMHgxMDAwMDAwIGlzIDJeMjRcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICB2ID0gKChhW2ldICYgMzEpICogMHgxMDAwMDAwMDAwMDAwKSArIChhW2kgKyAxXSAqIDB4MTAwMDAwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgMl0gKiAweDEwMDAwMDAwMCkgKyAoYVtpICsgM10gKiAweDEwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgNF0gPDwgMTYpICsgKGFbaSArIDVdIDw8IDgpICsgYVtpICsgNl07XHJcblxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KGEsIGkpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSA3O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBDUllQVE8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbS5cclxuICAgICAgICBpZiAoIUNSWVBUTykge1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuICAgICAgICAgICAgdiA9IHJhbmRvbTUzYml0SW50KCk7XHJcbiAgICAgICAgICAgIGlmICh2IDwgOWUxNSkgY1tpKytdID0gdiAlIDFlMTQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBrID0gY1stLWldO1xyXG4gICAgICAgIGRwICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gZHAuXHJcbiAgICAgICAgaWYgKGsgJiYgZHApIHtcclxuICAgICAgICAgIHYgPSBQT1dTX1RFTltMT0dfQkFTRSAtIGRwXTtcclxuICAgICAgICAgIGNbaV0gPSBtYXRoZmxvb3IoayAvIHYpICogdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVyby5cclxuICAgICAgICBmb3IgKDsgY1tpXSA9PT0gMDsgYy5wb3AoKSwgaS0tKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIGMgPSBbZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8gYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGZvciAoZSA9IC0xIDsgY1swXSA9PT0gMDsgYy5zcGxpY2UoMCwgMSksIGUgLT0gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYyB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcywgYW5kLi4uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCB2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICAvLyBhZGp1c3QgdGhlIGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgaWYgKGkgPCBMT0dfQkFTRSkgZSAtPSBMT0dfQkFTRSAtIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByYW5kLmUgPSBlO1xyXG4gICAgICAgIHJhbmQuYyA9IGM7XHJcbiAgICAgICAgcmV0dXJuIHJhbmQ7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuc3VtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgICBzdW0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOykgc3VtID0gc3VtLnBsdXMoYXJnc1tpKytdKTtcclxuICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIFBSSVZBVEUgRlVOQ1RJT05TXHJcblxyXG5cclxuICAgIC8vIENhbGxlZCBieSBCaWdOdW1iZXIgYW5kIEJpZ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcuXHJcbiAgICBjb252ZXJ0QmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBkZWNpbWFsID0gJzAxMjM0NTY3ODknO1xyXG5cclxuICAgICAgLypcclxuICAgICAgICogQ29udmVydCBzdHJpbmcgb2YgYmFzZUluIHRvIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYmFzZU91dC5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGFscGhhYmV0KSB7XHJcbiAgICAgICAgdmFyIGosXHJcbiAgICAgICAgICBhcnIgPSBbMF0sXHJcbiAgICAgICAgICBhcnJMLFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGxlbjspIHtcclxuICAgICAgICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgYXJyW2FyckxdICo9IGJhc2VJbik7XHJcblxyXG4gICAgICAgICAgYXJyWzBdICs9IGFscGhhYmV0LmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcclxuXHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcclxuICAgICAgICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PSBudWxsKSBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyLnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VJbiB0byBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgdG9TdHJpbmcsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZSAxMCB0byBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIEJpZ051bWJlciwgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlSW4gdG8gYmFzZSAxMC5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIsIGJhc2VJbiwgYmFzZU91dCwgc2lnbiwgY2FsbGVySXNUb1N0cmluZykge1xyXG4gICAgICAgIHZhciBhbHBoYWJldCwgZCwgZSwgaywgciwgeCwgeGMsIHksXHJcbiAgICAgICAgICBpID0gc3RyLmluZGV4T2YoJy4nKSxcclxuICAgICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgICBybSA9IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICAgIGsgPSBQT1dfUFJFQ0lTSU9OO1xyXG5cclxuICAgICAgICAgIC8vIFVubGltaXRlZCBwcmVjaXNpb24uXHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gMDtcclxuICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYmFzZUluKTtcclxuICAgICAgICAgIHggPSB5LnBvdyhzdHIubGVuZ3RoIC0gaSk7XHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gaztcclxuXHJcbiAgICAgICAgICAvLyBDb252ZXJ0IHN0ciBhcyBpZiBhbiBpbnRlZ2VyLCB0aGVuIHJlc3RvcmUgdGhlIGZyYWN0aW9uIHBhcnQgYnkgZGl2aWRpbmcgdGhlXHJcbiAgICAgICAgICAvLyByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIuXHJcblxyXG4gICAgICAgICAgeS5jID0gdG9CYXNlT3V0KHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKHguYyksIHguZSwgJzAnKSxcclxuICAgICAgICAgICAxMCwgYmFzZU91dCwgZGVjaW1hbCk7XHJcbiAgICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGludGVnZXIuXHJcblxyXG4gICAgICAgIHhjID0gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBjYWxsZXJJc1RvU3RyaW5nXHJcbiAgICAgICAgID8gKGFscGhhYmV0ID0gQUxQSEFCRVQsIGRlY2ltYWwpXHJcbiAgICAgICAgIDogKGFscGhhYmV0ID0gZGVjaW1hbCwgQUxQSEFCRVQpKTtcclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGFzIGFuIGludGVnZXIgYW5kIGNvbnZlcnRlZCB0byBiYXNlT3V0LiBlIGlzIHRoZSBleHBvbmVudC5cclxuICAgICAgICBlID0gayA9IHhjLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyB4Y1stLWtdID09IDA7IHhjLnBvcCgpKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoIXhjWzBdKSByZXR1cm4gYWxwaGFiZXQuY2hhckF0KDApO1xyXG5cclxuICAgICAgICAvLyBEb2VzIHN0ciByZXByZXNlbnQgYW4gaW50ZWdlcj8gSWYgc28sIG5vIG5lZWQgZm9yIHRoZSBkaXZpc2lvbi5cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIC0tZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5jID0geGM7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG5cclxuICAgICAgICAgIC8vIFRoZSBzaWduIGlzIG5lZWRlZCBmb3IgY29ycmVjdCByb3VuZGluZy5cclxuICAgICAgICAgIHgucyA9IHNpZ247XHJcbiAgICAgICAgICB4ID0gZGl2KHgsIHksIGRwLCBybSwgYmFzZU91dCk7XHJcbiAgICAgICAgICB4YyA9IHguYztcclxuICAgICAgICAgIHIgPSB4LnI7XHJcbiAgICAgICAgICBlID0geC5lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGNvbnZlcnRlZCB0byBiYXNlT3V0LlxyXG5cclxuICAgICAgICAvLyBUSGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgIGQgPSBlICsgZHAgKyAxO1xyXG5cclxuICAgICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQ6IHRoZSBkaWdpdCB0byB0aGUgcmlnaHQgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgaSA9IHhjW2RdO1xyXG5cclxuICAgICAgICAvLyBMb29rIGF0IHRoZSByb3VuZGluZyBkaWdpdHMgYW5kIG1vZGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcm91bmQgdXAuXHJcblxyXG4gICAgICAgIGsgPSBiYXNlT3V0IC8gMjtcclxuICAgICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgciA9IHJtIDwgNCA/IChpICE9IG51bGwgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgICAgOiBpID4gayB8fCBpID09IGsgJiYocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiYgeGNbZCAtIDFdICYgMSB8fFxyXG4gICAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgbm90IGdyZWF0ZXIgdGhhbiB6ZXJvLCBvciB4YyByZXByZXNlbnRzXHJcbiAgICAgICAgLy8gemVybywgdGhlbiB0aGUgcmVzdWx0IG9mIHRoZSBiYXNlIGNvbnZlcnNpb24gaXMgemVybyBvciwgaWYgcm91bmRpbmcgdXAsIGEgdmFsdWVcclxuICAgICAgICAvLyBzdWNoIGFzIDAuMDAwMDEuXHJcbiAgICAgICAgaWYgKGQgPCAxIHx8ICF4Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIDFeLWRwIG9yIDBcclxuICAgICAgICAgIHN0ciA9IHIgPyB0b0ZpeGVkUG9pbnQoYWxwaGFiZXQuY2hhckF0KDEpLCAtZHAsIGFscGhhYmV0LmNoYXJBdCgwKSkgOiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBUcnVuY2F0ZSB4YyB0byB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgeGMubGVuZ3RoID0gZDtcclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxyXG4gICAgICAgICAgICBmb3IgKC0tYmFzZU91dDsgKyt4Y1stLWRdID4gYmFzZU91dDspIHtcclxuICAgICAgICAgICAgICB4Y1tkXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgIGlmICghZCkge1xyXG4gICAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgICAgeGMgPSBbMV0uY29uY2F0KHhjKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGsgPSB4Yy5sZW5ndGg7ICF4Y1stLWtdOyk7XHJcblxyXG4gICAgICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cclxuICAgICAgICAgIGZvciAoaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBhbHBoYWJldC5jaGFyQXQoeGNbaSsrXSkpO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm9zLCBkZWNpbWFsIHBvaW50IGFuZCB0cmFpbGluZyB6ZXJvcyBhcyByZXF1aXJlZC5cclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsIGFscGhhYmV0LmNoYXJBdCgwKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgYWRkIHRoZSBzaWduLlxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvLyBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS4gQ2FsbGVkIGJ5IGRpdiBhbmQgY29udmVydEJhc2UuXHJcbiAgICBkaXYgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgLy8gQXNzdW1lIG5vbi16ZXJvIHggYW5kIGsuXHJcbiAgICAgIGZ1bmN0aW9uIG11bHRpcGx5KHgsIGssIGJhc2UpIHtcclxuICAgICAgICB2YXIgbSwgdGVtcCwgeGxvLCB4aGksXHJcbiAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICBpID0geC5sZW5ndGgsXHJcbiAgICAgICAgICBrbG8gPSBrICUgU1FSVF9CQVNFLFxyXG4gICAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoeCA9IHguc2xpY2UoKTsgaS0tOykge1xyXG4gICAgICAgICAgeGxvID0geFtpXSAlIFNRUlRfQkFTRTtcclxuICAgICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xyXG4gICAgICAgICAgbSA9IGtoaSAqIHhsbyArIHhoaSAqIGtsbztcclxuICAgICAgICAgIHRlbXAgPSBrbG8gKiB4bG8gKyAoKG0gJSBTUVJUX0JBU0UpICogU1FSVF9CQVNFKSArIGNhcnJ5O1xyXG4gICAgICAgICAgY2FycnkgPSAodGVtcCAvIGJhc2UgfCAwKSArIChtIC8gU1FSVF9CQVNFIHwgMCkgKyBraGkgKiB4aGk7XHJcbiAgICAgICAgICB4W2ldID0gdGVtcCAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2FycnkpIHggPSBbY2FycnldLmNvbmNhdCh4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XHJcbiAgICAgICAgdmFyIGksIGNtcDtcclxuXHJcbiAgICAgICAgaWYgKGFMICE9IGJMKSB7XHJcbiAgICAgICAgICBjbXAgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgZm9yIChpID0gY21wID0gMDsgaSA8IGFMOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgICAgICBjbXAgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IGIgZnJvbSBhLlxyXG4gICAgICAgIGZvciAoOyBhTC0tOykge1xyXG4gICAgICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XHJcbiAgICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc3BsaWNlKDAsIDEpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geDogZGl2aWRlbmQsIHk6IGRpdmlzb3IuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgZHAsIHJtLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgICAgeUwsIHl6LFxyXG4gICAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICAgIGlmICgheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcclxuXHJcbiAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXHJcbiAgICAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4YyA/IHljICYmIHhjWzBdID09IHljWzBdIDogIXljKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgwrEwIG9yIHkgaXMgwrFJbmZpbml0eSwgb3IgcmV0dXJuIMKxSW5maW5pdHkgYXMgeSBpcyDCsTAuXHJcbiAgICAgICAgICAgIHhjICYmIHhjWzBdID09IDAgfHwgIXljID8gcyAqIDAgOiBzIC8gMFxyXG4gICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcSA9IG5ldyBCaWdOdW1iZXIocyk7XHJcbiAgICAgICAgcWMgPSBxLmMgPSBbXTtcclxuICAgICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgICAgIHMgPSBkcCArIGUgKyAxO1xyXG5cclxuICAgICAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSAtIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgICAgIHMgPSBzIC8gTE9HX0JBU0UgfCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIGUuXHJcbiAgICAgICAgLy8gVGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgQmlnTnVtYmVycyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoaSA9IDA7IHljW2ldID09ICh4Y1tpXSB8fCAwKTsgaSsrKTtcclxuXHJcbiAgICAgICAgaWYgKHljW2ldID4gKHhjW2ldIHx8IDApKSBlLS07XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCkge1xyXG4gICAgICAgICAgcWMucHVzaCgxKTtcclxuICAgICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICBzICs9IDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9ybWFsaXNlIHhjIGFuZCB5YyBzbyBoaWdoZXN0IG9yZGVyIGRpZ2l0IG9mIHljIGlzID49IGJhc2UgLyAyLlxyXG5cclxuICAgICAgICAgIG4gPSBtYXRoZmxvb3IoYmFzZSAvICh5Y1swXSArIDEpKTtcclxuXHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gaGFuZGxlIG9kZCBiYXNlcyB3aGVyZSB5Y1swXSA9PSAoYmFzZSAvIDIpIC0gMS5cclxuICAgICAgICAgIC8vIGlmIChuID4gMSB8fCBuKysgPT0gMSAmJiB5Y1swXSA8IGJhc2UgLyAyKSB7XHJcbiAgICAgICAgICBpZiAobiA+IDEpIHtcclxuICAgICAgICAgICAgeWMgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHhjID0gbXVsdGlwbHkoeGMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICAgIHJlbSA9IHhjLnNsaWNlKDAsIHlMKTtcclxuICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOyByZW1bcmVtTCsrXSA9IDApO1xyXG4gICAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgeXogPSBbMF0uY29uY2F0KHl6KTtcclxuICAgICAgICAgIHljMCA9IHljWzBdO1xyXG4gICAgICAgICAgaWYgKHljWzFdID49IGJhc2UgLyAyKSB5YzArKztcclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAgIC8vIGVsc2UgaWYgKGJhc2UgPT0gMyAmJiB5YzAgPT0gMSkgeWMwID0gMSArIDFlLTE1O1xyXG5cclxuICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbiA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgY21wID0gY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIG4uXHJcblxyXG4gICAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgICAgaWYgKHlMICE9IHJlbUwpIHJlbTAgPSByZW0wICogYmFzZSArIChyZW1bMV0gfHwgMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG4gaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBuID0gbWF0aGZsb29yKHJlbTAgLyB5YzApO1xyXG5cclxuICAgICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAgIC8vICBwcm9kdWN0ID0gZGl2aXNvciBtdWx0aXBsaWVkIGJ5IHRyaWFsIGRpZ2l0IChuKS5cclxuICAgICAgICAgICAgICAvLyAgQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3QgaXMgZ3JlYXRlciB0aGFuIHJlbWFpbmRlcjpcclxuICAgICAgICAgICAgICAvLyAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdCwgZGVjcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIC8vICBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IHdhcyBsZXNzIHRoYW4gcmVtYWluZGVyIGF0IHRoZSBsYXN0IGNvbXBhcmU6XHJcbiAgICAgICAgICAgICAgLy8gICAgQ29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yLlxyXG4gICAgICAgICAgICAgIC8vICAgIElmIHJlbWFpbmRlciBpcyBncmVhdGVyIHRoYW4gZGl2aXNvcjpcclxuICAgICAgICAgICAgICAvLyAgICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIsIGluY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuXHJcbiAgICAgICAgICAgICAgaWYgKG4gPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBtYXkgYmUgPiBiYXNlIG9ubHkgd2hlbiBiYXNlIGlzIDMuXHJcbiAgICAgICAgICAgICAgICBpZiAobiA+PSBiYXNlKSBuID0gYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0ID4gcmVtYWluZGVyIHRoZW4gdHJpYWwgZGlnaXQgbiB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gaGlnaCBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIGlzIG5vdCBrbm93biB0byBoYXZlXHJcbiAgICAgICAgICAgICAgICAvLyBldmVyIGJlZW4gbW9yZSB0aGFuIDEgdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4tLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5YywgcHJvZEwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICBjbXAgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byBjb21wYXJlIHljIGFuZCByZW0gYWdhaW4gYmVsb3csXHJcbiAgICAgICAgICAgICAgICAvLyBzbyBjaGFuZ2UgY21wIHRvIDEgdG8gYXZvaWQgaXQuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICBpZiAobiA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgcmVtYWluZGVyLCBzbyBuIG11c3QgYmUgYXQgbGVhc3QgMS5cclxuICAgICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3JcclxuICAgICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QgPSBbMF0uY29uY2F0KHByb2QpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbisrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCB5TCA8IHJlbUwgPyB5eiA6IHljLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgICByZW0gPSBbMF07XHJcbiAgICAgICAgICAgIH0gLy8gZWxzZSBjbXAgPT09IDEgYW5kIG4gd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgIHFjW2krK10gPSBuO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChyZW1bMF0pIHtcclxuICAgICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhjW3hpXSB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlbSA9IFt4Y1t4aV1dO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsKSAmJiBzLS0pO1xyXG5cclxuICAgICAgICAgIG1vcmUgPSByZW1bMF0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgICAgICBpZiAoIXFjWzBdKSBxYy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYmFzZSA9PSBCQVNFKSB7XHJcblxyXG4gICAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFjWzBdLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgcyA9IHFjWzBdOyBzID49IDEwOyBzIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIHJvdW5kKHEsIGRwICsgKHEuZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSArIDEsIHJtLCBtb3JlKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbGVyIGlzIGNvbnZlcnRCYXNlLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBxLmUgPSBlO1xyXG4gICAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcTtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAgICogbm90YXRpb24gcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIGRlY2ltYWwgcGxhY2VzIG9yIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAqXHJcbiAgICAgKiBuOiBhIEJpZ051bWJlci5cclxuICAgICAqIGk6IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBkaWdpdCByZXF1aXJlZCAoaS5lLiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cCkuXHJcbiAgICAgKiBybTogdGhlIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgKiBpZDogMSAodG9FeHBvbmVudGlhbCkgb3IgMiAodG9QcmVjaXNpb24pLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmb3JtYXQobiwgaSwgcm0sIGlkKSB7XHJcbiAgICAgIHZhciBjMCwgZSwgbmUsIGxlbiwgc3RyO1xyXG5cclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICBpZiAoIW4uYykgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIGMwID0gbi5jWzBdO1xyXG4gICAgICBuZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChpID09IG51bGwpIHtcclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgc3RyID0gaWQgPT0gMSB8fCBpZCA9PSAyICYmIChuZSA8PSBUT19FWFBfTkVHIHx8IG5lID49IFRPX0VYUF9QT1MpXHJcbiAgICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIG5lKVxyXG4gICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIG5lLCAnMCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBpLCBybSk7XHJcblxyXG4gICAgICAgIC8vIG4uZSBtYXkgaGF2ZSBjaGFuZ2VkIGlmIHRoZSB2YWx1ZSB3YXMgcm91bmRlZCB1cC5cclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICAgIC8vIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlclxyXG4gICAgICAgIC8vIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICBpZiAoaWQgPT0gMSB8fCBpZCA9PSAyICYmIChpIDw9IGUgfHwgZSA8PSBUT19FWFBfTkVHKSkge1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGZvciAoOyBsZW4gPCBpOyBzdHIgKz0gJzAnLCBsZW4rKyk7XHJcbiAgICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKHN0ciwgZSk7XHJcblxyXG4gICAgICAgIC8vIEZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpIC09IG5lO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBpZiAoZSArIDEgPiBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKC0taSA+IDApIGZvciAoc3RyICs9ICcuJzsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgKz0gZSAtIGxlbjtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGUgKyAxID09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSBCaWdOdW1iZXIubWF4IGFuZCBCaWdOdW1iZXIubWluLlxyXG4gICAgZnVuY3Rpb24gbWF4T3JNaW4oYXJncywgbWV0aG9kKSB7XHJcbiAgICAgIHZhciBuLFxyXG4gICAgICAgIGkgPSAxLFxyXG4gICAgICAgIG0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIoYXJnc1tpXSk7XHJcblxyXG4gICAgICAgIC8vIElmIGFueSBudW1iZXIgaXMgTmFOLCByZXR1cm4gTmFOLlxyXG4gICAgICAgIGlmICghbi5zKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kLmNhbGwobSwgbikpIHtcclxuICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBTdHJpcCB0cmFpbGluZyB6ZXJvcywgY2FsY3VsYXRlIGJhc2UgMTAgZXhwb25lbnQgYW5kIGNoZWNrIGFnYWluc3QgTUlOX0VYUCBhbmQgTUFYX0VYUC5cclxuICAgICAqIENhbGxlZCBieSBtaW51cywgcGx1cyBhbmQgdGltZXMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGlzZShuLCBjLCBlKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBqID0gYy5sZW5ndGg7XHJcblxyXG4gICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgIWNbLS1qXTsgYy5wb3AoKSk7XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQuIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICBmb3IgKGogPSBjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgIGlmICgoZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgbi5jID0gbi5lID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIG4uYyA9IFtuLmUgPSAwXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuLmUgPSBlO1xyXG4gICAgICAgIG4uYyA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgdmFsdWVzIHRoYXQgZmFpbCB0aGUgdmFsaWRpdHkgdGVzdCBpbiBCaWdOdW1iZXIuXHJcbiAgICBwYXJzZU51bWVyaWMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2ksXHJcbiAgICAgICAgZG90QWZ0ZXIgPSAvXihbXi5dKylcXC4kLyxcclxuICAgICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcclxuICAgICAgICBpc0luZmluaXR5T3JOYU4gPSAvXi0/KEluZmluaXR5fE5hTikkLyxcclxuICAgICAgICB3aGl0ZXNwYWNlT3JQbHVzID0gL15cXHMqXFwrKD89W1xcdy5dKXxeXFxzK3xcXHMrJC9nO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBzdHIsIGlzTnVtLCBiKSB7XHJcbiAgICAgICAgdmFyIGJhc2UsXHJcbiAgICAgICAgICBzID0gaXNOdW0gPyBzdHIgOiBzdHIucmVwbGFjZSh3aGl0ZXNwYWNlT3JQbHVzLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAgICBpZiAoaXNJbmZpbml0eU9yTmFOLnRlc3QocykpIHtcclxuICAgICAgICAgIHgucyA9IGlzTmFOKHMpID8gbnVsbCA6IHMgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoIWlzTnVtKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaVxyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGJhc2VQcmVmaXgsIGZ1bmN0aW9uIChtLCBwMSwgcDIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gKHAyID0gcDIudG9Mb3dlckNhc2UoKSkgPT0gJ3gnID8gMTYgOiBwMiA9PSAnYicgPyAyIDogODtcclxuICAgICAgICAgICAgICByZXR1cm4gIWIgfHwgYiA9PSBiYXNlID8gcDEgOiBtO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IGI7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEUuZy4gJzEuJyB0byAnMScsICcuMScgdG8gJzAuMSdcclxuICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGRvdEFmdGVyLCAnJDEnKS5yZXBsYWNlKGRvdEJlZm9yZSwgJzAuJDEnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHN0ciAhPSBzKSByZXR1cm4gbmV3IEJpZ051bWJlcihzLCBiYXNlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ05vdCBhJyArIChiID8gJyBiYXNlICcgKyBiIDogJycpICsgJyBudW1iZXI6ICcgKyBzdHIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE5hTlxyXG4gICAgICAgICAgeC5zID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSb3VuZCB4IHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gICAgICogSWYgciBpcyB0cnV0aHksIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgYXJlIG1vcmUgZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcm91bmQoeCwgc2QsIHJtLCByKSB7XHJcbiAgICAgIHZhciBkLCBpLCBqLCBrLCBuLCBuaSwgcmQsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgcG93czEwID0gUE9XU19URU47XHJcblxyXG4gICAgICAvLyBpZiB4IGlzIG5vdCBJbmZpbml0eSBvciBOYU4uLi5cclxuICAgICAgaWYgKHhjKSB7XHJcblxyXG4gICAgICAgIC8vIHJkIGlzIHRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgLy8gbiBpcyBhIGJhc2UgMWUxNCBudW1iZXIsIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBvZiBhcnJheSB4LmMgY29udGFpbmluZyByZC5cclxuICAgICAgICAvLyBuaSBpcyB0aGUgaW5kZXggb2YgbiB3aXRoaW4geC5jLlxyXG4gICAgICAgIC8vIGQgaXMgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAvLyBpIGlzIHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiBpbmNsdWRpbmcgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAvLyBqIGlzIHRoZSBhY3R1YWwgaW5kZXggb2YgcmQgd2l0aGluIG4gKGlmIDwgMCwgcmQgaXMgYSBsZWFkaW5nIHplcm8pLlxyXG4gICAgICAgIG91dDoge1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy5cclxuICAgICAgICAgIGZvciAoZCA9IDEsIGsgPSB4Y1swXTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuICAgICAgICAgIGkgPSBzZCAtIGQ7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgICAgaSArPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgaiA9IHNkO1xyXG4gICAgICAgICAgICBuID0geGNbbmkgPSAwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICByZCA9IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5pID0gbWF0aGNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuaSA+PSB4Yy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cclxuICAgICAgICAgICAgICAgIGZvciAoOyB4Yy5sZW5ndGggPD0gbmk7IHhjLnB1c2goMCkpO1xyXG4gICAgICAgICAgICAgICAgbiA9IHJkID0gMDtcclxuICAgICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG4gPSBrID0geGNbbmldO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAgICAgICBmb3IgKGQgPSAxOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLlxyXG4gICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuIGlzIGdpdmVuIGJ5IExPR19CQVNFIC0gZC5cclxuICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcclxuXHJcbiAgICAgICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICAgICAgICAvLyBUaGUgZXhwcmVzc2lvbiAgbiAlIHBvd3MxMFtkIC0gaiAtIDFdICByZXR1cm5zIGFsbCBkaWdpdHMgb2YgbiB0byB0aGUgcmlnaHRcclxuICAgICAgICAgIC8vIG9mIHRoZSBkaWdpdCBhdCBqLCBlLmcuIGlmIG4gaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uIGdpdmVzIDcxNC5cclxuICAgICAgICAgICB4Y1tuaSArIDFdICE9IG51bGwgfHwgKGogPCAwID8gbiA6IG4gJSBwb3dzMTBbZCAtIGogLSAxXSk7XHJcblxyXG4gICAgICAgICAgciA9IHJtIDwgNFxyXG4gICAgICAgICAgID8gKHJkIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxyXG4gICAgICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwW2QgLSBqXSA6IDAgOiB4Y1tuaSAtIDFdKSAlIDEwKSAmIDEgfHxcclxuICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgICBpZiAoc2QgPCAxIHx8ICF4Y1swXSkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29udmVydCBzZCB0byBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0gcG93czEwWyhMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0VdO1xyXG4gICAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0geC5lID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGV4Y2VzcyBkaWdpdHMuXHJcbiAgICAgICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xyXG4gICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgbmktLTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pICsgMTtcclxuICAgICAgICAgICAgayA9IHBvd3MxMFtMT0dfQkFTRSAtIGldO1xyXG5cclxuICAgICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygbi5cclxuICAgICAgICAgICAgeGNbbmldID0gaiA+IDAgPyBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gal0gJSBwb3dzMTBbal0pICogayA6IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgICAgICBpZiAobmkgPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhjWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IHhjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG4gICAgICAgICAgICAgICAgaiA9IHhjWzBdICs9IGs7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKyspO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoeGNbMF0gPT0gQkFTRSkgeGNbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaV0gKz0gaztcclxuICAgICAgICAgICAgICAgIGlmICh4Y1tuaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaS0tXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGkgPSB4Yy5sZW5ndGg7IHhjWy0taV0gPT09IDA7IHhjLnBvcCgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE92ZXJmbG93PyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93PyBaZXJvLlxyXG4gICAgICAgIH0gZWxzZSBpZiAoeC5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHZhbHVlT2Yobikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuXHJcbiAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBlKVxyXG4gICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBQUk9UT1RZUEUvSU5TVEFOQ0UgTUVUSE9EU1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXHJcbiAgICAgKi9cclxuICAgIFAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmICh4LnMgPCAwKSB4LnMgPSAxO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm5cclxuICAgICAqICAgMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIC0xIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAgICAgKiAgIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBpcyBOYU4uXHJcbiAgICAgKi9cclxuICAgIFAuY29tcGFyZWRUbyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIGRwIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9mIHRoZVxyXG4gICAgICogdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgZHAgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXM6IGludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICBuID0gKCh2ID0gYy5sZW5ndGggLSAxKSAtIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSkgKiBMT0dfQkFTRTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgbnVtYmVyLlxyXG4gICAgICBpZiAodiA9IGNbdl0pIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuICAgICAgaWYgKG4gPCAwKSBuID0gMDtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC8gMCA9IElcclxuICAgICAqICBuIC8gTiA9IE5cclxuICAgICAqICBuIC8gSSA9IDBcclxuICAgICAqICAwIC8gbiA9IDBcclxuICAgICAqICAwIC8gMCA9IE5cclxuICAgICAqICAwIC8gTiA9IE5cclxuICAgICAqICAwIC8gSSA9IDBcclxuICAgICAqICBOIC8gbiA9IE5cclxuICAgICAqICBOIC8gMCA9IE5cclxuICAgICAqICBOIC8gTiA9IE5cclxuICAgICAqICBOIC8gSSA9IE5cclxuICAgICAqICBJIC8gbiA9IElcclxuICAgICAqICBJIC8gMCA9IElcclxuICAgICAqICBJIC8gTiA9IE5cclxuICAgICAqICBJIC8gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgREVDSU1BTF9QTEFDRVMsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIGJ5IHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5pZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCAwLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGV4cG9uZW50aWF0ZWQgYnkgbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBtIGlzIHByZXNlbnQsIHJldHVybiB0aGUgcmVzdWx0IG1vZHVsbyBtLlxyXG4gICAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vbi16ZXJvIGFuZCBtIGlzIG5vdCBwcmVzZW50LCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIG1vZHVsYXIgcG93ZXIgb3BlcmF0aW9uIHdvcmtzIGVmZmljaWVudGx5IHdoZW4geCwgbiwgYW5kIG0gYXJlIGludGVnZXJzLCBvdGhlcndpc2UgaXRcclxuICAgICAqIGlzIGVxdWl2YWxlbnQgdG8gY2FsY3VsYXRpbmcgeC5leHBvbmVudGlhdGVkQnkobikubW9kdWxvKG0pIHdpdGggYSBQT1dfUFJFQ0lTSU9OIG9mIDAuXHJcbiAgICAgKlxyXG4gICAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBleHBvbmVudC4gQW4gaW50ZWdlci5cclxuICAgICAqIFttXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBtb2R1bHVzLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBFeHBvbmVudCBub3QgYW4gaW50ZWdlcjoge259J1xyXG4gICAgICovXHJcbiAgICBQLmV4cG9uZW50aWF0ZWRCeSA9IFAucG93ID0gZnVuY3Rpb24gKG4sIG0pIHtcclxuICAgICAgdmFyIGhhbGYsIGlzTW9kRXhwLCBpLCBrLCBtb3JlLCBuSXNCaWcsIG5Jc05lZywgbklzT2RkLCB5LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobik7XHJcblxyXG4gICAgICAvLyBBbGxvdyBOYU4gYW5kIMKxSW5maW5pdHksIGJ1dCBub3Qgb3RoZXIgbm9uLWludGVnZXJzLlxyXG4gICAgICBpZiAobi5jICYmICFuLmlzSW50ZWdlcigpKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogJyArIHZhbHVlT2YobikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobSAhPSBudWxsKSBtID0gbmV3IEJpZ051bWJlcihtKTtcclxuXHJcbiAgICAgIC8vIEV4cG9uZW50IG9mIE1BWF9TQUZFX0lOVEVHRVIgaXMgMTUuXHJcbiAgICAgIG5Jc0JpZyA9IG4uZSA+IDE0O1xyXG5cclxuICAgICAgLy8gSWYgeCBpcyBOYU4sIMKxSW5maW5pdHksIMKxMCBvciDCsTEsIG9yIG4gaXMgwrFJbmZpbml0eSwgTmFOIG9yIMKxMC5cclxuICAgICAgaWYgKCF4LmMgfHwgIXguY1swXSB8fCB4LmNbMF0gPT0gMSAmJiAheC5lICYmIHguYy5sZW5ndGggPT0gMSB8fCAhbi5jIHx8ICFuLmNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gVGhlIHNpZ24gb2YgdGhlIHJlc3VsdCBvZiBwb3cgd2hlbiB4IGlzIG5lZ2F0aXZlIGRlcGVuZHMgb24gdGhlIGV2ZW5uZXNzIG9mIG4uXHJcbiAgICAgICAgLy8gSWYgK24gb3ZlcmZsb3dzIHRvIMKxSW5maW5pdHksIHRoZSBldmVubmVzcyBvZiBuIHdvdWxkIGJlIG5vdCBiZSBrbm93bi5cclxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihNYXRoLnBvdygrdmFsdWVPZih4KSwgbklzQmlnID8gMiAtIGlzT2RkKG4pIDogK3ZhbHVlT2YobikpKTtcclxuICAgICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogeTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbklzTmVnID0gbi5zIDwgMDtcclxuXHJcbiAgICAgIGlmIChtKSB7XHJcblxyXG4gICAgICAgIC8vIHggJSBtIHJldHVybnMgTmFOIGlmIGFicyhtKSBpcyB6ZXJvLCBvciBtIGlzIE5hTi5cclxuICAgICAgICBpZiAobS5jID8gIW0uY1swXSA6ICFtLnMpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAgIGlzTW9kRXhwID0gIW5Jc05lZyAmJiB4LmlzSW50ZWdlcigpICYmIG0uaXNJbnRlZ2VyKCk7XHJcblxyXG4gICAgICAgIGlmIChpc01vZEV4cCkgeCA9IHgubW9kKG0pO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3cgdG8gwrFJbmZpbml0eTogPj0yKioxZTEwIG9yID49MS4wMDAwMDI0KioxZTE1LlxyXG4gICAgICAvLyBVbmRlcmZsb3cgdG8gwrEwOiA8PTAuNzkqKjFlMTAgb3IgPD0wLjk5OTk5NzUqKjFlMTUuXHJcbiAgICAgIH0gZWxzZSBpZiAobi5lID4gOSAmJiAoeC5lID4gMCB8fCB4LmUgPCAtMSB8fCAoeC5lID09IDBcclxuICAgICAgICAvLyBbMSwgMjQwMDAwMDAwXVxyXG4gICAgICAgID8geC5jWzBdID4gMSB8fCBuSXNCaWcgJiYgeC5jWzFdID49IDI0ZTdcclxuICAgICAgICAvLyBbODAwMDAwMDAwMDAwMDBdICBbOTk5OTk3NTAwMDAwMDBdXHJcbiAgICAgICAgOiB4LmNbMF0gPCA4ZTEzIHx8IG5Jc0JpZyAmJiB4LmNbMF0gPD0gOTk5OTk3NWU3KSkpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgeCBpcyBuZWdhdGl2ZSBhbmQgbiBpcyBvZGQsIGsgPSAtMCwgZWxzZSBrID0gMC5cclxuICAgICAgICBrID0geC5zIDwgMCAmJiBpc09kZChuKSA/IC0wIDogMDtcclxuXHJcbiAgICAgICAgLy8gSWYgeCA+PSAxLCBrID0gwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gLTEpIGsgPSAxIC8gaztcclxuXHJcbiAgICAgICAgLy8gSWYgbiBpcyBuZWdhdGl2ZSByZXR1cm4gwrEwLCBlbHNlIHJldHVybiDCsUluZmluaXR5LlxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG5Jc05lZyA/IDEgLyBrIDogayk7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKFBPV19QUkVDSVNJT04pIHtcclxuXHJcbiAgICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgIC8vIGVxdWF0ZXMgdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLFxyXG4gICAgICAgIC8vIGkuZS4gdGhlcmUgd2lsbCBiZSBhIG1pbmltdW0gb2YgMjggZ3VhcmQgZGlnaXRzIHJldGFpbmVkLlxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5Jc0JpZykge1xyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKDAuNSk7XHJcbiAgICAgICAgaWYgKG5Jc05lZykgbi5zID0gMTtcclxuICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpID0gTWF0aC5hYnMoK3ZhbHVlT2YobikpO1xyXG4gICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgLy8gUGVyZm9ybXMgNTQgbG9vcCBpdGVyYXRpb25zIGZvciBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEuXHJcbiAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgIGlmIChuSXNPZGQpIHtcclxuICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgICAgaWYgKCF5LmMpIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICAgIGlmICh5LmMubGVuZ3RoID4gaykgeS5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICAgIHkgPSB5Lm1vZChtKTsgICAgLy95ID0geS5taW51cyhkaXYoeSwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgICBpID0gbWF0aGZsb29yKGkgLyAyKTtcclxuICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gbi50aW1lcyhoYWxmKTtcclxuICAgICAgICAgIHJvdW5kKG4sIG4uZSArIDEsIDEpO1xyXG5cclxuICAgICAgICAgIGlmIChuLmUgPiAxNCkge1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgPSArdmFsdWVPZihuKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggPSB4LnRpbWVzKHgpO1xyXG5cclxuICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgaWYgKHguYyAmJiB4LmMubGVuZ3RoID4gaykgeC5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgeCA9IHgubW9kKG0pOyAgICAvL3ggPSB4Lm1pbnVzKGRpdih4LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzTW9kRXhwKSByZXR1cm4geTtcclxuICAgICAgaWYgKG5Jc05lZykgeSA9IE9ORS5kaXYoeSk7XHJcblxyXG4gICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogayA/IHJvdW5kKHksIFBPV19QUkVDSVNJT04sIFJPVU5ESU5HX01PREUsIG1vcmUpIDogeTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGFuIGludGVnZXJcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtybX0nXHJcbiAgICAgKi9cclxuICAgIFAuaW50ZWdlclZhbHVlID0gZnVuY3Rpb24gKHJtKSB7XHJcbiAgICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcbiAgICAgIHJldHVybiByb3VuZChuLCBuLmUgKyAxLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRXF1YWxUbyA9IFAuZXEgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAxIHx8IGIgPT09IDA7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzSW50ZWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuYy5sZW5ndGggLSAyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gLTEgfHwgYiA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMucztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIHBvc2l0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC0gMCA9IG5cclxuICAgICAqICBuIC0gTiA9IE5cclxuICAgICAqICBuIC0gSSA9IC1JXHJcbiAgICAgKiAgMCAtIG4gPSAtblxyXG4gICAgICogIDAgLSAwID0gMFxyXG4gICAgICogIDAgLSBOID0gTlxyXG4gICAgICogIDAgLSBJID0gLUlcclxuICAgICAqICBOIC0gbiA9IE5cclxuICAgICAqICBOIC0gMCA9IE5cclxuICAgICAqICBOIC0gTiA9IE5cclxuICAgICAqICBOIC0gSSA9IE5cclxuICAgICAqICBJIC0gbiA9IElcclxuICAgICAqICBJIC0gMCA9IElcclxuICAgICAqICBJIC0gTiA9IE5cclxuICAgICAqICBJIC0gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5taW51cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBpLCBqLCB0LCB4TFR5LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiB4YyA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHljID8geCA6IE5hTik7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICByZXR1cm4geWNbMF0gPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOlxyXG5cclxuICAgICAgICAgICAvLyBJRUVFIDc1NCAoMjAwOCkgNi4zOiBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5XHJcbiAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSAzID8gLTAgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICAgICAgaWYgKHhMVHkgPSBhIDwgMCkge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICAgIGZvciAoYiA9IGE7IGItLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgICBqID0gKHhMVHkgPSAoYSA9IHhjLmxlbmd0aCkgPCAoYiA9IHljLmxlbmd0aCkpID8gYSA6IGI7XHJcblxyXG4gICAgICAgIGZvciAoYSA9IGIgPSAwOyBiIDwgajsgYisrKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmICh4TFR5KSB0ID0geGMsIHhjID0geWMsIHljID0gdCwgeS5zID0gLXkucztcclxuXHJcbiAgICAgIGIgPSAoaiA9IHljLmxlbmd0aCkgLSAoaSA9IHhjLmxlbmd0aCk7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgICAgaWYgKGIgPiAwKSBmb3IgKDsgYi0tOyB4Y1tpKytdID0gMCk7XHJcbiAgICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgIGZvciAoOyBqID4gYTspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAgIC0teGNbaV07XHJcbiAgICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGNbal0gLT0geWNbal07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgIGZvciAoOyB4Y1swXSA9PSAwOyB4Yy5zcGxpY2UoMCwgMSksIC0teWUpO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBGb2xsb3dpbmcgSUVFRSA3NTQgKDIwMDgpIDYuMyxcclxuICAgICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgIHkuYyA9IFt5LmUgPSAwXTtcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICAgbiAlIDAgPSAgTlxyXG4gICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgKiAgIG4gJSBJID0gIG5cclxuICAgICAqICAgMCAlIG4gPSAgMFxyXG4gICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgKiAgIDAgJSAwID0gIE5cclxuICAgICAqICAgMCAlIE4gPSAgTlxyXG4gICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgKiAgIE4gJSBuID0gIE5cclxuICAgICAqICAgTiAlIDAgPSAgTlxyXG4gICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgKiAgIE4gJSBJID0gIE5cclxuICAgICAqICAgSSAlIG4gPSAgTlxyXG4gICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgKiAgIEkgJSBOID0gIE5cclxuICAgICAqICAgSSAlIEkgPSAgTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgICBpZiAoIXguYyB8fCAheS5zIHx8IHkuYyAmJiAheS5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKCF5LmMgfHwgeC5jICYmICF4LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKE1PRFVMT19NT0RFID09IDkpIHtcclxuXHJcbiAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgcyA9IHkucztcclxuICAgICAgICB5LnMgPSAxO1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgICAgeS5zID0gcztcclxuICAgICAgICBxLnMgKj0gcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIE1PRFVMT19NT0RFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgICAvLyBUbyBtYXRjaCBKYXZhU2NyaXB0ICUsIGVuc3VyZSBzaWduIG9mIHplcm8gaXMgc2lnbiBvZiBkaXZpZGVuZC5cclxuICAgICAgaWYgKCF5LmNbMF0gJiYgTU9EVUxPX01PREUgPT0gMSkgeS5zID0geC5zO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKiAwID0gMFxyXG4gICAgICogIG4gKiBOID0gTlxyXG4gICAgICogIG4gKiBJID0gSVxyXG4gICAgICogIDAgKiBuID0gMFxyXG4gICAgICogIDAgKiAwID0gMFxyXG4gICAgICogIDAgKiBOID0gTlxyXG4gICAgICogIDAgKiBJID0gTlxyXG4gICAgICogIE4gKiBuID0gTlxyXG4gICAgICogIE4gKiAwID0gTlxyXG4gICAgICogIE4gKiBOID0gTlxyXG4gICAgICogIE4gKiBJID0gTlxyXG4gICAgICogIEkgKiBuID0gSVxyXG4gICAgICogIEkgKiAwID0gTlxyXG4gICAgICogIEkgKiBOID0gTlxyXG4gICAgICogIEkgKiBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlXHJcbiAgICAgKiBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubXVsdGlwbGllZEJ5ID0gUC50aW1lcyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcclxuICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIMKxSW5maW5pdHkgb3IgwrEwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeS5zICo9IHgucztcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICAgIHkuYyA9IHkuZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeS5jID0gWzBdO1xyXG4gICAgICAgICAgICB5LmUgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgIHkucyAqPSB4LnM7XHJcbiAgICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgICAgeWNMID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHhjIHBvaW50cyB0byBsb25nZXIgYXJyYXkgYW5kIHhjTCB0byBpdHMgbGVuZ3RoLlxyXG4gICAgICBpZiAoeGNMIDwgeWNMKSB6YyA9IHhjLCB4YyA9IHljLCB5YyA9IHpjLCBpID0geGNMLCB4Y0wgPSB5Y0wsIHljTCA9IGk7XHJcblxyXG4gICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgICAgZm9yIChpID0geGNMICsgeWNMLCB6YyA9IFtdOyBpLS07IHpjLnB1c2goMCkpO1xyXG5cclxuICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgICAgZm9yIChpID0geWNMOyAtLWkgPj0gMDspIHtcclxuICAgICAgICBjID0gMDtcclxuICAgICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHloaSA9IHljW2ldIC8gc3FydEJhc2UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgICB4aGkgPSB4Y1trXSAvIHNxcnRCYXNlIHwgMDtcclxuICAgICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoKG0gJSBzcXJ0QmFzZSkgKiBzcXJ0QmFzZSkgKyB6Y1tqXSArIGM7XHJcbiAgICAgICAgICBjID0gKHhsbyAvIGJhc2UgfCAwKSArIChtIC8gc3FydEJhc2UgfCAwKSArIHloaSAqIHhoaTtcclxuICAgICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgemNbal0gPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYykge1xyXG4gICAgICAgICsrZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgKi9cclxuICAgIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICB4LnMgPSAteC5zIHx8IG51bGw7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICsgMCA9IG5cclxuICAgICAqICBuICsgTiA9IE5cclxuICAgICAqICBuICsgSSA9IElcclxuICAgICAqICAwICsgbiA9IG5cclxuICAgICAqICAwICsgMCA9IDBcclxuICAgICAqICAwICsgTiA9IE5cclxuICAgICAqICAwICsgSSA9IElcclxuICAgICAqICBOICsgbiA9IE5cclxuICAgICAqICBOICsgMCA9IE5cclxuICAgICAqICBOICsgTiA9IE5cclxuICAgICAqICBOICsgSSA9IE5cclxuICAgICAqICBJICsgbiA9IElcclxuICAgICAqICBJICsgMCA9IElcclxuICAgICAqICBJICsgTiA9IE5cclxuICAgICAqICBJICsgSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLnBsdXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYSAvIDApO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuIHljWzBdID8geSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDogYSAqIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcbiAgICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICBmb3IgKDsgYS0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhID0geGMubGVuZ3RoO1xyXG4gICAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheSwgYW5kIGIgdG8gdGhlIHNob3J0ZXIgbGVuZ3RoLlxyXG4gICAgICBpZiAoYSAtIGIgPCAwKSB0ID0geWMsIHljID0geGMsIHhjID0gdCwgYiA9IGE7XHJcblxyXG4gICAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cclxuICAgICAgZm9yIChhID0gMDsgYjspIHtcclxuICAgICAgICBhID0gKHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSkgLyBCQVNFIHwgMDtcclxuICAgICAgICB4Y1tiXSA9IEJBU0UgPT09IHhjW2JdID8gMCA6IHhjW2JdICUgQkFTRTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGEpIHtcclxuICAgICAgICB4YyA9IFthXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICsreWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgICAgLy8geWUgPSBNQVhfRVhQICsgMSBwb3NzaWJsZVxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgc2QgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mXHJcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICogSWYgc2QgaXMgdHJ1ZSBpbmNsdWRlIGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgY291bnQuXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBzZCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIHNkIHtudW1iZXJ8Ym9vbGVhbn0gbnVtYmVyOiBzaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogd2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoc2QgIT0gbnVsbCAmJiBzZCAhPT0gISFzZCkge1xyXG4gICAgICAgIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBzZCwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIHYgPSBjLmxlbmd0aCAtIDE7XHJcbiAgICAgIG4gPSB2ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSB7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBuKyspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2QgJiYgeC5lICsgMSA+IG4pIG4gPSB4LmUgKyAxO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xyXG4gICAgICogKHBvd2VycyBvZiAxMCkuIFNoaWZ0IHRvIHRoZSByaWdodCBpZiBuID4gMCwgYW5kIHRvIHRoZSBsZWZ0IGlmIG4gPCAwLlxyXG4gICAgICpcclxuICAgICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtrfSdcclxuICAgICAqL1xyXG4gICAgUC5zaGlmdGVkQnkgPSBmdW5jdGlvbiAoaykge1xyXG4gICAgICBpbnRDaGVjayhrLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUik7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWVzKCcxZScgKyBrKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAgICogIHNxcnQoTikgPSAgTlxyXG4gICAgICogIHNxcnQoLUkpID0gIE5cclxuICAgICAqICBzcXJ0KEkpID0gIElcclxuICAgICAqICBzcXJ0KDApID0gIDBcclxuICAgICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxyXG4gICAgICogcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBjID0geC5jLFxyXG4gICAgICAgIHMgPSB4LnMsXHJcbiAgICAgICAgZSA9IHguZSxcclxuICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTICsgNCxcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XHJcblxyXG4gICAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgICAgaWYgKHMgIT09IDEgfHwgIWMgfHwgIWNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcighcyB8fCBzIDwgMCAmJiAoIWMgfHwgY1swXSkgPyBOYU4gOiBjID8geCA6IDEgLyAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgICAgcyA9IE1hdGguc3FydCgrdmFsdWVPZih4KSk7XHJcblxyXG4gICAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcclxuICAgICAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApIG4gKz0gJzAnO1xyXG4gICAgICAgIHMgPSBNYXRoLnNxcnQoK24pO1xyXG4gICAgICAgIGUgPSBiaXRGbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICAgICAgbiA9ICc1ZScgKyBlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKHMgKyAnJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciB6ZXJvLlxyXG4gICAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXHJcbiAgICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXHJcbiAgICAgIGlmIChyLmNbMF0pIHtcclxuICAgICAgICBlID0gci5lO1xyXG4gICAgICAgIHMgPSBlICsgZHA7XHJcbiAgICAgICAgaWYgKHMgPCAzKSBzID0gMDtcclxuXHJcbiAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgICB0ID0gcjtcclxuICAgICAgICAgIHIgPSBoYWxmLnRpbWVzKHQucGx1cyhkaXYoeCwgdCwgZHAsIDEpKSk7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZWZmVG9TdHJpbmcodC5jKS5zbGljZSgwLCBzKSA9PT0gKG4gPSBjb2VmZlRvU3RyaW5nKHIuYykpLnNsaWNlKDAsIHMpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXHJcbiAgICAgICAgICAgIC8vIGUuZyAwLjAwMDk5OTkgKGUtNCkgLS0gPiAwLjAwMSAoZS0zKSwgc28gYWRqdXN0IHMgc28gdGhlIHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgaW5kZXhlZCBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgIGlmIChyLmUgPCBlKSAtLXM7XHJcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKHMgLSAzLCBzICsgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIDk5OTkgb3IgNDk5OSAoaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5KSBjb250aW51ZSB0aGVcclxuICAgICAgICAgICAgLy8gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgICAgICAgcm91bmQodCwgdC5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBkcCArPSA0O1xyXG4gICAgICAgICAgICAgIHMgKz0gNDtcclxuICAgICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcclxuICAgICAgICAgICAgICAvLyByZXN1bHQuIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXHJcbiAgICAgICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAxKTtcclxuICAgICAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbiBhbmRcclxuICAgICAqIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCsrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xyXG4gICAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxyXG4gICAgICogYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHAgPSBkcCArIHRoaXMuZSArIDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kZWRcclxuICAgICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBvZiB0aGUgZm9ybWF0IG9yIEZPUk1BVCBvYmplY3QgKHNlZSBCaWdOdW1iZXIuc2V0KS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZm9ybWF0dGluZyBvYmplY3QgbWF5IGNvbnRhaW4gc29tZSBvciBhbGwgb2YgdGhlIHByb3BlcnRpZXMgc2hvd24gYmVsb3cuXHJcbiAgICAgKlxyXG4gICAgICogRk9STUFUID0ge1xyXG4gICAgICogICBwcmVmaXg6ICcnLFxyXG4gICAgICogICBncm91cFNpemU6IDMsXHJcbiAgICAgKiAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAqICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAqICAgc3VmZml4OiAnJ1xyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbZm9ybWF0XSB7b2JqZWN0fSBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZSBGT1JNQVQgcGJqZWN0IGFib3ZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IG5vdCBhbiBvYmplY3Q6IHtmb3JtYXR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRm9ybWF0ID0gZnVuY3Rpb24gKGRwLCBybSwgZm9ybWF0KSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICBpZiAoZHAgIT0gbnVsbCAmJiBybSAmJiB0eXBlb2Ygcm0gPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IHJtO1xyXG4gICAgICAgICAgcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHAgJiYgdHlwZW9mIGRwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBkcDtcclxuICAgICAgICAgIGRwID0gcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBGT1JNQVQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT0gJ29iamVjdCcpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50IG5vdCBhbiBvYmplY3Q6ICcgKyBmb3JtYXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSB4LnRvRml4ZWQoZHAsIHJtKTtcclxuXHJcbiAgICAgIGlmICh4LmMpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLicpLFxyXG4gICAgICAgICAgZzEgPSArZm9ybWF0Lmdyb3VwU2l6ZSxcclxuICAgICAgICAgIGcyID0gK2Zvcm1hdC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgICBncm91cFNlcGFyYXRvciA9IGZvcm1hdC5ncm91cFNlcGFyYXRvciB8fCAnJyxcclxuICAgICAgICAgIGludFBhcnQgPSBhcnJbMF0sXHJcbiAgICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICAgICAgICBpbnREaWdpdHMgPSBpc05lZyA/IGludFBhcnQuc2xpY2UoMSkgOiBpbnRQYXJ0LFxyXG4gICAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKGcyKSBpID0gZzEsIGcxID0gZzIsIGcyID0gaSwgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIGlmIChnMSA+IDAgJiYgbGVuID4gMCkge1xyXG4gICAgICAgICAgaSA9IGxlbiAlIGcxIHx8IGcxO1xyXG4gICAgICAgICAgaW50UGFydCA9IGludERpZ2l0cy5zdWJzdHIoMCwgaSk7XHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSBnMSkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zdWJzdHIoaSwgZzEpO1xyXG4gICAgICAgICAgaWYgKGcyID4gMCkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zbGljZShpKTtcclxuICAgICAgICAgIGlmIChpc05lZykgaW50UGFydCA9ICctJyArIGludFBhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBmcmFjdGlvblBhcnRcclxuICAgICAgICAgPyBpbnRQYXJ0ICsgKGZvcm1hdC5kZWNpbWFsU2VwYXJhdG9yIHx8ICcnKSArICgoZzIgPSArZm9ybWF0LmZyYWN0aW9uR3JvdXBTaXplKVxyXG4gICAgICAgICAgPyBmcmFjdGlvblBhcnQucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcZHsnICsgZzIgKyAnfVxcXFxCJywgJ2cnKSxcclxuICAgICAgICAgICAnJCYnICsgKGZvcm1hdC5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHx8ICcnKSlcclxuICAgICAgICAgIDogZnJhY3Rpb25QYXJ0KVxyXG4gICAgICAgICA6IGludFBhcnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAoZm9ybWF0LnByZWZpeCB8fCAnJykgKyBzdHIgKyAoZm9ybWF0LnN1ZmZpeCB8fCAnJyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHR3byBCaWdOdW1iZXJzIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgYXMgYSBzaW1wbGVcclxuICAgICAqIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlciBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuXHJcbiAgICAgKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKiBtYXhpbXVtIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmVcclxuICAgICAqIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogW21kXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEludGVnZXIgPj0gMSwgb3IgSW5maW5pdHkuIFRoZSBtYXhpbXVtIGRlbm9taW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfSA6IHttZH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtZCkge1xyXG4gICAgICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgZXhwLCBuLCBuMCwgbjEsIHEsIHIsIHMsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmM7XHJcblxyXG4gICAgICBpZiAobWQgIT0gbnVsbCkge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG1kKTtcclxuXHJcbiAgICAgICAgLy8gVGhyb3cgaWYgbWQgaXMgbGVzcyB0aGFuIG9uZSBvciBpcyBub3QgYW4gaW50ZWdlciwgdW5sZXNzIGl0IGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICghbi5pc0ludGVnZXIoKSAmJiAobi5jIHx8IG4ucyAhPT0gMSkgfHwgbi5sdChPTkUpKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgJyArXHJcbiAgICAgICAgICAgICAgKG4uaXNJbnRlZ2VyKCkgPyAnb3V0IG9mIHJhbmdlOiAnIDogJ25vdCBhbiBpbnRlZ2VyOiAnKSArIHZhbHVlT2YobikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF4YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcblxyXG4gICAgICBkID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBuMSA9IGQwID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBzID0gY29lZmZUb1N0cmluZyh4Yyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBkZW5vbWluYXRvci5cclxuICAgICAgLy8gZCBpcyBhIHBvd2VyIG9mIDEwIGFuZCB0aGUgbWluaW11bSBtYXggZGVub21pbmF0b3IgdGhhdCBzcGVjaWZpZXMgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICAgIGUgPSBkLmUgPSBzLmxlbmd0aCAtIHguZSAtIDE7XHJcbiAgICAgIGQuY1swXSA9IFBPV1NfVEVOWyhleHAgPSBlICUgTE9HX0JBU0UpIDwgMCA/IExPR19CQVNFICsgZXhwIDogZXhwXTtcclxuICAgICAgbWQgPSAhbWQgfHwgbi5jb21wYXJlZFRvKGQpID4gMCA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG5cclxuICAgICAgZXhwID0gTUFYX0VYUDtcclxuICAgICAgTUFYX0VYUCA9IDEgLyAwO1xyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihzKTtcclxuXHJcbiAgICAgIC8vIG4wID0gZDEgPSAwXHJcbiAgICAgIG4wLmNbMF0gPSAwO1xyXG5cclxuICAgICAgZm9yICg7IDspICB7XHJcbiAgICAgICAgcSA9IGRpdihuLCBkLCAwLCAxKTtcclxuICAgICAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgICAgIGlmIChkMi5jb21wYXJlZFRvKG1kKSA9PSAxKSBicmVhaztcclxuICAgICAgICBkMCA9IGQxO1xyXG4gICAgICAgIGQxID0gZDI7XHJcbiAgICAgICAgbjEgPSBuMC5wbHVzKHEudGltZXMoZDIgPSBuMSkpO1xyXG4gICAgICAgIG4wID0gZDI7XHJcbiAgICAgICAgZCA9IG4ubWludXMocS50aW1lcyhkMiA9IGQpKTtcclxuICAgICAgICBuID0gZDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGQyID0gZGl2KG1kLm1pbnVzKGQwKSwgZDEsIDAsIDEpO1xyXG4gICAgICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICAgICAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XHJcbiAgICAgIG4wLnMgPSBuMS5zID0geC5zO1xyXG4gICAgICBlID0gZSAqIDI7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZnJhY3Rpb24gaXMgY2xvc2VyIHRvIHgsIG4wL2QwIG9yIG4xL2QxXHJcbiAgICAgIHIgPSBkaXYobjEsIGQxLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKS5jb21wYXJlZFRvKFxyXG4gICAgICAgICAgZGl2KG4wLCBkMCwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkpIDwgMSA/IFtuMSwgZDFdIDogW24wLCBkMF07XHJcblxyXG4gICAgICBNQVhfRVhQID0gZXhwO1xyXG5cclxuICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAgICovXHJcbiAgICBQLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gK3ZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0gb3IgUk9VTkRJTkdfTU9ERS4gSWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzXHJcbiAgICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxyXG4gICAgICogZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgaWYgKHNkICE9IG51bGwpIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIHNkLCBybSwgMik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgICAqIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLCByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kXHJcbiAgICAgKiBST1VORElOR19NT0RFLiBJZiBhIGJhc2UgaXMgbm90IHNwZWNpZmllZCwgYW5kIHRoaXMgQmlnTnVtYmVyIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogVE9fRVhQX05FRywgcmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICovXHJcbiAgICBQLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBuID0gdGhpcyxcclxuICAgICAgICBzID0gbi5zLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eSBvciBOYU4/XHJcbiAgICAgIGlmIChlID09PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgIHN0ciA9ICdJbmZpbml0eSc7XHJcbiAgICAgICAgICBpZiAocyA8IDApIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RyID0gJ05hTic7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChiID09IG51bGwpIHtcclxuICAgICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgICA/IHRvRXhwb25lbnRpYWwoY29lZmZUb1N0cmluZyhuLmMpLCBlKVxyXG4gICAgICAgICAgIDogdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDEwKSB7XHJcbiAgICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgREVDSU1BTF9QTEFDRVMgKyBlICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBuLmUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyksIDEwLCBiLCBzLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCAmJiBuLmNbMF0pIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudCwgYW5kIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24gZm9yXHJcbiAgICAgKiBuZWdhdGl2ZSB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBQLl9pc0JpZ051bWJlciA9IHRydWU7XHJcblxyXG4gICAgaWYgKGNvbmZpZ09iamVjdCAhPSBudWxsKSBCaWdOdW1iZXIuc2V0KGNvbmZpZ09iamVjdCk7XHJcblxyXG4gICAgcmV0dXJuIEJpZ051bWJlcjtcclxuICB9XHJcblxyXG5cclxuICAvLyBQUklWQVRFIEhFTFBFUiBGVU5DVElPTlNcclxuXHJcbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRvbid0IG5lZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyxcclxuICAvLyBlLmcuIERFQ0lNQUxfUExBQ0VTLCBpbiB0aGUgc2NvcGUgb2YgdGhlIGBjbG9uZWAgZnVuY3Rpb24gYWJvdmUuXHJcblxyXG5cclxuICBmdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgICB2YXIgaSA9IG4gfCAwO1xyXG4gICAgcmV0dXJuIG4gPiAwIHx8IG4gPT09IGkgPyBpIDogaSAtIDE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbiAgZnVuY3Rpb24gY29lZmZUb1N0cmluZyhhKSB7XHJcbiAgICB2YXIgcywgeixcclxuICAgICAgaSA9IDEsXHJcbiAgICAgIGogPSBhLmxlbmd0aCxcclxuICAgICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgICBmb3IgKDsgaSA8IGo7KSB7XHJcbiAgICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoOyB6LS07IHMgPSAnMCcgKyBzKTtcclxuICAgICAgciArPSBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7KTtcclxuXHJcbiAgICByZXR1cm4gci5zbGljZSgwLCBqICsgMSB8fCAxKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbiAgZnVuY3Rpb24gY29tcGFyZSh4LCB5KSB7XHJcbiAgICB2YXIgYSwgYixcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jLFxyXG4gICAgICBpID0geC5zLFxyXG4gICAgICBqID0geS5zLFxyXG4gICAgICBrID0geC5lLFxyXG4gICAgICBsID0geS5lO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICBpZiAoIWkgfHwgIWopIHJldHVybiBudWxsO1xyXG5cclxuICAgIGEgPSB4YyAmJiAheGNbMF07XHJcbiAgICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgaWYgKGEgfHwgYikgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgICBhID0gaSA8IDA7XHJcbiAgICBiID0gayA9PSBsO1xyXG5cclxuICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gICAgaWYgKCFiKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDaGVjayB0aGF0IG4gaXMgYSBwcmltaXRpdmUgbnVtYmVyLCBhbiBpbnRlZ2VyLCBhbmQgaW4gcmFuZ2UsIG90aGVyd2lzZSB0aHJvdy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBpbnRDaGVjayhuLCBtaW4sIG1heCwgbmFtZSkge1xyXG4gICAgaWYgKG4gPCBtaW4gfHwgbiA+IG1heCB8fCBuICE9PSBtYXRoZmxvb3IobikpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgIChiaWdudW1iZXJFcnJvciArIChuYW1lIHx8ICdBcmd1bWVudCcpICsgKHR5cGVvZiBuID09ICdudW1iZXInXHJcbiAgICAgICAgID8gbiA8IG1pbiB8fCBuID4gbWF4ID8gJyBvdXQgb2YgcmFuZ2U6ICcgOiAnIG5vdCBhbiBpbnRlZ2VyOiAnXHJcbiAgICAgICAgIDogJyBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiAnKSArIFN0cmluZyhuKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQXNzdW1lcyBmaW5pdGUgbi5cclxuICBmdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgICB2YXIgayA9IG4uYy5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIGJpdEZsb29yKG4uZSAvIExPR19CQVNFKSA9PSBrICYmIG4uY1trXSAlIDIgIT0gMDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0V4cG9uZW50aWFsKHN0ciwgZSkge1xyXG4gICAgcmV0dXJuIChzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIpICtcclxuICAgICAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9GaXhlZFBvaW50KHN0ciwgZSwgeikge1xyXG4gICAgdmFyIGxlbiwgenM7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgICBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICAgIGZvciAoenMgPSB6ICsgJy4nOyArK2U7IHpzICs9IHopO1xyXG4gICAgICBzdHIgPSB6cyArIHN0cjtcclxuXHJcbiAgICAvLyBQb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgaWYgKCsrZSA+IGxlbikge1xyXG4gICAgICAgIGZvciAoenMgPSB6LCBlIC09IGxlbjsgLS1lOyB6cyArPSB6KTtcclxuICAgICAgICBzdHIgKz0genM7XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IGxlbikge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gRVhQT1JUXHJcblxyXG5cclxuICBCaWdOdW1iZXIgPSBjbG9uZSgpO1xyXG4gIEJpZ051bWJlclsnZGVmYXVsdCddID0gQmlnTnVtYmVyLkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQU1ELlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZ051bWJlcjsgfSk7XHJcblxyXG4gIC8vIE5vZGUuanMgYW5kIG90aGVyIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQnJvd3Nlci5cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFnbG9iYWxPYmplY3QpIHtcclxuICAgICAgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiA/IHNlbGYgOiB3aW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgZ2xvYmFsT2JqZWN0LkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuICB9XHJcbn0pKHRoaXMpO1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcbiAgICBVUkxXaXRoTGVnYWN5U3VwcG9ydCxcbiAgICBmb3JtYXQsXG4gICAgVVJMU2VhcmNoUGFyYW1zLFxuICAgIGRlZmF1bHRCYXNlXG59ID0gcmVxdWlyZSgnLi9zcmMvdXJsJyk7XG5jb25zdCByZWxhdGl2ZSA9IHJlcXVpcmUoJy4vc3JjL3JlbGF0aXZlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFVSTDogVVJMV2l0aExlZ2FjeVN1cHBvcnQsXG4gICAgVVJMU2VhcmNoUGFyYW1zLFxuICAgIGZvcm1hdCxcbiAgICByZWxhdGl2ZSxcbiAgICBkZWZhdWx0QmFzZVxufTtcbiIsInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSBvcHRpb25zID09PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyArK2lpKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWQocm5kcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZyb21RdW9ydW1XYWxsZXQgPSBleHBvcnRzLmZyb21LcnlwdG9LaXQgPSBleHBvcnRzLmZyb21FdGhlckNhbXAgPSBleHBvcnRzLmZyb21FdGhlcldhbGxldCA9IHZvaWQgMDtcbnZhciBjcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xudmFyIGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbnZhciBzY3J5cHRfanNfMSA9IHJlcXVpcmUoXCJzY3J5cHQtanNcIik7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xudmFyIHV0ZjggPSByZXF1aXJlKCd1dGY4Jyk7XG52YXIgYWVzanMgPSByZXF1aXJlKCdhZXMtanMnKTtcbmZ1bmN0aW9uIHJ1bkNpcGhlckJ1ZmZlcihjaXBoZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbY2lwaGVyLnVwZGF0ZShkYXRhKSwgY2lwaGVyLmZpbmFsKCldKTtcbn1cbnZhciBldnBLZGZEZWZhdWx0cyA9IHtcbiAgICBjb3VudDogMSxcbiAgICBrZXlzaXplOiAxNixcbiAgICBpdnNpemU6IDE2LFxuICAgIGRpZ2VzdDogJ21kNScsXG59O1xuZnVuY3Rpb24gbWVyZ2VFdnBLZGZPcHRzV2l0aERlZmF1bHRzKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGV2cEtkZkRlZmF1bHRzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjb3VudDogb3B0cy5jb3VudCB8fCBldnBLZGZEZWZhdWx0cy5jb3VudCxcbiAgICAgICAga2V5c2l6ZTogb3B0cy5rZXlzaXplIHx8IGV2cEtkZkRlZmF1bHRzLmtleXNpemUsXG4gICAgICAgIGl2c2l6ZTogb3B0cy5pdnNpemUgfHwgZXZwS2RmRGVmYXVsdHMuaXZzaXplLFxuICAgICAgICBkaWdlc3Q6IG9wdHMuZGlnZXN0IHx8IGV2cEtkZkRlZmF1bHRzLmRpZ2VzdCxcbiAgICB9O1xufVxuLypcbiAqIG9wdHM6XG4gKiAtIGRpZ2VzdCAtIGRpZ2VzdCBhbGdvcml0aG0sIGRlZmF1bHRzIHRvIG1kNVxuICogLSBjb3VudCAtIGhhc2ggaXRlcmF0aW9uc1xuICogLSBrZXlzaXplIC0gZGVzaXJlZCBrZXkgc2l6ZVxuICogLSBpdnNpemUgLSBkZXNpcmVkIElWIHNpemVcbiAqXG4gKiBBbGdvcml0aG0gZm9ybSBodHRwczovL3d3dy5vcGVuc3NsLm9yZy9kb2NzL21hbm1hc3Rlci9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuICpcbiAqIEZJWE1FOiBub3Qgb3B0aW1pc2VkIGF0IGFsbFxuICovXG5mdW5jdGlvbiBldnBfa2RmKGRhdGEsIHNhbHQsIG9wdHMpIHtcbiAgICB2YXIgcGFyYW1zID0gbWVyZ2VFdnBLZGZPcHRzV2l0aERlZmF1bHRzKG9wdHMpO1xuICAgIC8vIEEgc2luZ2xlIEVWUCBpdGVyYXRpb24sIHJldHVybnMgYERfaWAsIHdoZXJlIGJsb2NrIGVxdWxhcyB0byBgRF8oaS0xKWBcbiAgICBmdW5jdGlvbiBpdGVyKGJsb2NrKSB7XG4gICAgICAgIHZhciBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2gocGFyYW1zLmRpZ2VzdCk7XG4gICAgICAgIGhhc2gudXBkYXRlKGJsb2NrKTtcbiAgICAgICAgaGFzaC51cGRhdGUoZGF0YSk7XG4gICAgICAgIGhhc2gudXBkYXRlKHNhbHQpO1xuICAgICAgICBibG9jayA9IGhhc2guZGlnZXN0KCk7XG4gICAgICAgIGZvciAodmFyIGlfMSA9IDEsIGxlbiA9IHBhcmFtcy5jb3VudDsgaV8xIDwgbGVuOyBpXzErKykge1xuICAgICAgICAgICAgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKHBhcmFtcy5kaWdlc3QpO1xuICAgICAgICAgICAgaGFzaC51cGRhdGUoYmxvY2spO1xuICAgICAgICAgICAgYmxvY2sgPSBoYXNoLmRpZ2VzdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoQnVmZmVyLmNvbmNhdChyZXQpLmxlbmd0aCA8IHBhcmFtcy5rZXlzaXplICsgcGFyYW1zLml2c2l6ZSkge1xuICAgICAgICByZXRbaV0gPSBpdGVyKGkgPT09IDAgPyBCdWZmZXIuYWxsb2MoMCkgOiByZXRbaSAtIDFdKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICB2YXIgdG1wID0gQnVmZmVyLmNvbmNhdChyZXQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleTogdG1wLnNsaWNlKDAsIHBhcmFtcy5rZXlzaXplKSxcbiAgICAgICAgaXY6IHRtcC5zbGljZShwYXJhbXMua2V5c2l6ZSwgcGFyYW1zLmtleXNpemUgKyBwYXJhbXMuaXZzaXplKSxcbiAgICB9O1xufVxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTI4ODMxMS9jcnlwdG9qcy1hZXMtcGF0dGVybi1hbHdheXMtZW5kcy13aXRoXG5mdW5jdGlvbiBkZWNvZGVDcnlwdG9qc1NhbHQoaW5wdXQpIHtcbiAgICB2YXIgY2lwaGVydGV4dCA9IEJ1ZmZlci5mcm9tKGlucHV0LCAnYmFzZTY0Jyk7XG4gICAgaWYgKGNpcGhlcnRleHQuc2xpY2UoMCwgOCkudG9TdHJpbmcoKSA9PT0gJ1NhbHRlZF9fJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2FsdDogY2lwaGVydGV4dC5zbGljZSg4LCAxNiksXG4gICAgICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LnNsaWNlKDE2KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCB9O1xufVxuLypcbiAqIFRoaXJkIFBhcnR5IEFQSTogSW1wb3J0IGEgd2FsbGV0IGdlbmVyYXRlZCBieSBFdGhlcldhbGxldFxuICogVGhpcyB3YWxsZXQgZm9ybWF0IGlzIGNyZWF0ZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL1NpbGVudENpY2Vyby9ldGhlcmV1bWpzLWFjY291bnRzXG4gKiBhbmQgdXNlZCBvbiBodHRwczovL3d3dy5teWV0aGVyd2FsbGV0LmNvbS9cbiAqL1xuZnVuY3Rpb24gZnJvbUV0aGVyV2FsbGV0KGlucHV0LCBwYXNzd29yZCkge1xuICAgIHZhciBqc29uID0gdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyA/IGlucHV0IDogSlNPTi5wYXJzZShpbnB1dCk7XG4gICAgdmFyIHByaXZhdGVLZXk7XG4gICAgaWYgKCFqc29uLmxvY2tlZCkge1xuICAgICAgICBpZiAoanNvbi5wcml2YXRlLmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcml2YXRlIGtleSBsZW5ndGgnKTtcbiAgICAgICAgfVxuICAgICAgICBwcml2YXRlS2V5ID0gQnVmZmVyLmZyb20oanNvbi5wcml2YXRlLCAnaGV4Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXNzd29yZCByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXNzd29yZC5sZW5ndGggPCA3KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3N3b3JkIG11c3QgYmUgYXQgbGVhc3QgNyBjaGFyYWN0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIFwiZW5jcnlwdGVkXCIgdmVyc2lvbiBoYXMgdGhlIGxvdyA0IGJ5dGVzXG4gICAgICAgIC8vIG9mIHRoZSBoYXNoIG9mIHRoZSBhZGRyZXNzIGFwcGVuZGVkXG4gICAgICAgIHZhciBoYXNoID0ganNvbi5lbmNyeXB0ZWQgPyBqc29uLnByaXZhdGUuc2xpY2UoMCwgMTI4KSA6IGpzb24ucHJpdmF0ZTtcbiAgICAgICAgLy8gZGVjb2RlIG9wZW5zc2wgY2lwaGVydGV4dCArIHNhbHQgZW5jb2RpbmdcbiAgICAgICAgdmFyIGNpcGhlciA9IGRlY29kZUNyeXB0b2pzU2FsdChoYXNoKTtcbiAgICAgICAgaWYgKCFjaXBoZXIuc2FsdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBFdGhlcldhbGxldCBrZXkgZm9ybWF0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVyaXZlIGtleS9pdiB1c2luZyBPcGVuU1NMIEVWUCBhcyBpbXBsZW1lbnRlZCBpbiBDcnlwdG9KU1xuICAgICAgICB2YXIgZXZwID0gZXZwX2tkZihCdWZmZXIuZnJvbShwYXNzd29yZCksIGNpcGhlci5zYWx0LCB7IGtleXNpemU6IDMyLCBpdnNpemU6IDE2IH0pO1xuICAgICAgICB2YXIgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTI1Ni1jYmMnLCBldnAua2V5LCBldnAuaXYpO1xuICAgICAgICBwcml2YXRlS2V5ID0gcnVuQ2lwaGVyQnVmZmVyKGRlY2lwaGVyLCBCdWZmZXIuZnJvbShjaXBoZXIuY2lwaGVydGV4dCkpO1xuICAgICAgICAvLyBOT1RFOiB5ZXMsIHRoZXkndmUgcnVuIGl0IHRocm91Z2ggVVRGOFxuICAgICAgICBwcml2YXRlS2V5ID0gQnVmZmVyLmZyb20odXRmOC5kZWNvZGUocHJpdmF0ZUtleS50b1N0cmluZygpKSwgJ2hleCcpO1xuICAgIH1cbiAgICB2YXIgd2FsbGV0ID0gbmV3IGluZGV4XzEuZGVmYXVsdChwcml2YXRlS2V5KTtcbiAgICBpZiAod2FsbGV0LmdldEFkZHJlc3NTdHJpbmcoKSAhPT0ganNvbi5hZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcml2YXRlIGtleSBvciBhZGRyZXNzJyk7XG4gICAgfVxuICAgIHJldHVybiB3YWxsZXQ7XG59XG5leHBvcnRzLmZyb21FdGhlcldhbGxldCA9IGZyb21FdGhlcldhbGxldDtcbi8qKlxuICogVGhpcmQgUGFydHkgQVBJOiBJbXBvcnQgYSBicmFpbiB3YWxsZXQgdXNlZCBieSBFdGhlci5DYW1wXG4gKi9cbmZ1bmN0aW9uIGZyb21FdGhlckNhbXAocGFzc3BocmFzZSkge1xuICAgIHJldHVybiBuZXcgaW5kZXhfMS5kZWZhdWx0KGV0aGVyZXVtanNfdXRpbF8xLmtlY2NhazI1NihCdWZmZXIuZnJvbShwYXNzcGhyYXNlKSkpO1xufVxuZXhwb3J0cy5mcm9tRXRoZXJDYW1wID0gZnJvbUV0aGVyQ2FtcDtcbi8qKlxuICogVGhpcmQgUGFydHkgQVBJOiBJbXBvcnQgYSB3YWxsZXQgZnJvbSBhIEtyeXB0b0tpdCBzZWVkXG4gKi9cbmZ1bmN0aW9uIGZyb21LcnlwdG9LaXQoZW50cm9weSwgcGFzc3dvcmQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGtyeXB0b0tpdEJyb2tlblNjcnlwdFNlZWQoYnVmKSB7XG4gICAgICAgICAgICAvLyBqcy1zY3J5cHQgY2FsbHMgYEJ1ZmZlci5mcm9tKFN0cmluZyhzYWx0KSwgJ3V0ZjgnKWAgb24gdGhlIHNlZWQgZXZlbiB0aG91Z2ggaXQgaXMgYSBidWZmZXJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgYGJ1ZmZlcmBgIGltcGxlbWVudGF0aW9uIHVzZWQgZG9lcyB0aGUgYmVsb3cgdHJhbnNmb3JtYXRpb24gKGRvZXNuJ3QgbWF0Y2hlcyB0aGUgY3VycmVudCB2ZXJzaW9uKTpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjdjNjExODFiOTM4YjE3ZDEwZGJmYzBhNTQ1ZjcxM2I4YmQ1OWRlOC9pbmRleC5qc1xuICAgICAgICAgICAgZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIoc3RyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZmZmZCk7IC8vIFVURiA4IGludmFsaWQgY2hhclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXMgPSAnJywgdG1wID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChidWZbaV0gPD0gMHg3Zikge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocmVzICsgZGVjb2RlVXRmOENoYXIodG1wKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUsIHByaXZhdGVLZXksIGVuY3J5cHRlZFNlZWQsIGNoZWNrc3VtLCBzYWx0LCBhZXNLZXksIGRlY2lwaGVyO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cm9weVswXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyb3B5ID0gZW50cm9weS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gZW50cm9weVswXTtcbiAgICAgICAgICAgICAgICAgICAgZW50cm9weSA9IGVudHJvcHkuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGUgPT09ICdkJykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBwcml2YXRlS2V5ID0gZXRoZXJldW1qc191dGlsXzEuc2hhMjU2KGV0aGVyZXVtanNfdXRpbF8xLnRvQnVmZmVyKGVudHJvcHkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0eXBlID09PSAncScpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFzc3dvcmQgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbmNyeXB0ZWRTZWVkID0gZXRoZXJldW1qc191dGlsXzEuc2hhMjU2KEJ1ZmZlci5mcm9tKGVudHJvcHkuc2xpY2UoMCwgMzApKSk7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrc3VtID0gZW50cm9weS5zbGljZSgzMCwgNDYpO1xuICAgICAgICAgICAgICAgICAgICBzYWx0ID0ga3J5cHRvS2l0QnJva2VuU2NyeXB0U2VlZChlbmNyeXB0ZWRTZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2NyeXB0X2pzXzEuc2NyeXB0KEJ1ZmZlci5mcm9tKHBhc3N3b3JkLCAndXRmOCcpLCBzYWx0LCAxNjM4NCwgOCwgMSwgMzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBGSVhNRTogdHJ5IHRvIHVzZSBgY3J5cHRvYCBpbnN0ZWFkIG9mIGBhZXNqc2BcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBFQ0IgZG9lc24ndCB1c2UgdGhlIElWLCBzbyBpdCBjYW4gYmUgYW55dGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KFwiYWVzLTI1Ni1lY2JcIiwgYWVzS2V5LCBCdWZmZXIuZnJvbSgwKSlcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogdGhpcyBpcyBhIGNsZWFyIGFidXNlLCBidXQgc2VlbXMgdG8gbWF0Y2ggaG93IEVDQiBpbiBhZXNqcyB3b3Jrc1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpdktleSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNpcGhlci51cGRhdGUoZW5jcnlwdGVkU2VlZCkuc2xpY2UoMCwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNpcGhlci51cGRhdGUoZW5jcnlwdGVkU2VlZCkuc2xpY2UoMCwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBhZXNLZXkgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGRlY2lwaGVyID0gbmV3IGFlc2pzLk1vZGVPZk9wZXJhdGlvbi5lY2IoYWVzS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgLyogZGVjcnlwdCByZXR1cm5zIGFuIFVpbnQ4QXJyYXksIHBlcmhhcHMgdGhlcmUgaXMgYSBiZXR0ZXIgd2F5IHRvIGNvbmNhdGVuYXRlICovXG4gICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXkgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGRlY2lwaGVyLmRlY3J5cHQoZW5jcnlwdGVkU2VlZC5zbGljZSgwLCAxNikpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGRlY2lwaGVyLmRlY3J5cHQoZW5jcnlwdGVkU2VlZC5zbGljZSgxNiwgMzIpKSksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tzdW0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrc3VtICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV0aGVyZXVtanNfdXRpbF8xLnNoYTI1NihldGhlcmV1bWpzX3V0aWxfMS5zaGEyNTYocHJpdmF0ZUtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCA4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoJ2hleCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjcnlwdCBpbnB1dCAtIHBvc3NpYmx5IGludmFsaWQgcGFzc3BocmFzZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIGVudHJvcHkgdHlwZScpO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBpbmRleF8xLmRlZmF1bHQocHJpdmF0ZUtleSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZnJvbUtyeXB0b0tpdCA9IGZyb21LcnlwdG9LaXQ7XG4vKipcbiAqIFRoaXJkIFBhcnR5IEFQSTogSW1wb3J0IGEgYnJhaW4gd2FsbGV0IHVzZWQgYnkgUXVvcnVtIFdhbGxldFxuICovXG5mdW5jdGlvbiBmcm9tUXVvcnVtV2FsbGV0KHBhc3NwaHJhc2UsIHVzZXJpZCkge1xuICAgIGlmIChwYXNzcGhyYXNlLmxlbmd0aCA8IDEwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGFzc3BocmFzZSBtdXN0IGJlIGF0IGxlYXN0IDEwIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gICAgaWYgKHVzZXJpZC5sZW5ndGggPCAxMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgaWQgbXVzdCBiZSBhdCBsZWFzdCAxMCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICAgIHZhciBtZXJnZWQgPSBwYXNzcGhyYXNlICsgdXNlcmlkO1xuICAgIHZhciBzZWVkID0gY3J5cHRvLnBia2RmMlN5bmMobWVyZ2VkLCBtZXJnZWQsIDIwMDAsIDMyLCAnc2hhMjU2Jyk7XG4gICAgcmV0dXJuIG5ldyBpbmRleF8xLmRlZmF1bHQoc2VlZCk7XG59XG5leHBvcnRzLmZyb21RdW9ydW1XYWxsZXQgPSBmcm9tUXVvcnVtV2FsbGV0O1xudmFyIFRoaXJkcGFydHkgPSB7XG4gICAgZnJvbUV0aGVyV2FsbGV0OiBmcm9tRXRoZXJXYWxsZXQsXG4gICAgZnJvbUV0aGVyQ2FtcDogZnJvbUV0aGVyQ2FtcCxcbiAgICBmcm9tS3J5cHRvS2l0OiBmcm9tS3J5cHRvS2l0LFxuICAgIGZyb21RdW9ydW1XYWxsZXQ6IGZyb21RdW9ydW1XYWxsZXQsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gVGhpcmRwYXJ0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRoaXJkcGFydHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xudmFyIGhka2V5XzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2hka2V5XCIpO1xudmFyIEV0aGVyZXVtSERLZXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXRoZXJldW1IREtleShfaGRrZXkpIHtcbiAgICAgICAgdGhpcy5faGRrZXkgPSBfaGRrZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2UgYmFzZWQgb24gYSBzZWVkLlxuICAgICAqXG4gICAgICogRm9yIHRoZSBzZWVkIHdlIHN1Z2dlc3QgdG8gdXNlIFtiaXAzOV0oaHR0cHM6Ly9ucG1qcy5vcmcvcGFja2FnZS9iaXAzOSkgdG9cbiAgICAgKiBjcmVhdGUgb25lIGZyb20gYSBCSVAzOSBtbmVtb25pYy5cbiAgICAgKi9cbiAgICBFdGhlcmV1bUhES2V5LmZyb21NYXN0ZXJTZWVkID0gZnVuY3Rpb24gKHNlZWRCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFdGhlcmV1bUhES2V5KGhka2V5XzEuSERLZXkuZnJvbU1hc3RlclNlZWQoc2VlZEJ1ZmZlcikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIGJhc2VkIG9uIGEgQklQMzIgZXh0ZW5kZWQgcHJpdmF0ZSBvciBwdWJsaWMga2V5LlxuICAgICAqL1xuICAgIEV0aGVyZXVtSERLZXkuZnJvbUV4dGVuZGVkS2V5ID0gZnVuY3Rpb24gKGJhc2U1OEtleSkge1xuICAgICAgICByZXR1cm4gbmV3IEV0aGVyZXVtSERLZXkoaGRrZXlfMS5IREtleS5mcm9tRXh0ZW5kZWRLZXkoYmFzZTU4S2V5KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQklQMzIgZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgKHhwcnYpXG4gICAgICovXG4gICAgRXRoZXJldW1IREtleS5wcm90b3R5cGUucHJpdmF0ZUV4dGVuZGVkS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2hka2V5LnByaXZhdGVFeHRlbmRlZEtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGlzIGEgcHVibGljIGtleSBvbmx5IHdhbGxldCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oZGtleS5wcml2YXRlRXh0ZW5kZWRLZXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBCSVAzMiBleHRlbmRlZCBwdWJsaWMga2V5ICh4cHViKVxuICAgICAqL1xuICAgIEV0aGVyZXVtSERLZXkucHJvdG90eXBlLnB1YmxpY0V4dGVuZGVkS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGRrZXkucHVibGljRXh0ZW5kZWRLZXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXJpdmVzIGEgbm9kZSBiYXNlZCBvbiBhIHBhdGggKGUuZy4gbS80NCcvMCcvMC8xKVxuICAgICAqL1xuICAgIEV0aGVyZXVtSERLZXkucHJvdG90eXBlLmRlcml2ZVBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gbmV3IEV0aGVyZXVtSERLZXkodGhpcy5faGRrZXkuZGVyaXZlKHBhdGgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlcml2ZSBhIG5vZGUgYmFzZWQgb24gYSBjaGlsZCBpbmRleFxuICAgICAqL1xuICAgIEV0aGVyZXVtSERLZXkucHJvdG90eXBlLmRlcml2ZUNoaWxkID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgRXRoZXJldW1IREtleSh0aGlzLl9oZGtleS5kZXJpdmVDaGlsZChpbmRleCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgYFdhbGxldGAgaW5zdGFuY2UgYXMgc2VlbiBhYm92ZVxuICAgICAqL1xuICAgIEV0aGVyZXVtSERLZXkucHJvdG90eXBlLmdldFdhbGxldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hka2V5Ll9wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhfMS5kZWZhdWx0LmZyb21Qcml2YXRlS2V5KHRoaXMuX2hka2V5Ll9wcml2YXRlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXhfMS5kZWZhdWx0LmZyb21QdWJsaWNLZXkodGhpcy5faGRrZXkuX3B1YmxpY0tleSwgdHJ1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRXRoZXJldW1IREtleTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFdGhlcmV1bUhES2V5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGRrZXkuanMubWFwIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIjFcIjogXCIweDQ0NjkxQjM5ZDFhNzVkQzRFMEEwMzQ2Q0JCMTVFMzEwZTZFRDFFODZcIlxufVxuIiwibW9kdWxlLmV4cG9ydHM9W3tcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiX25ld1wiLFwidHlwZVwiOlwiYWRkcmVzc1wifV0sXCJuYW1lXCI6XCJzZXRPd25lclwiLFwib3V0cHV0c1wiOltdLFwicGF5YWJsZVwiOmZhbHNlLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiY29uc3RhbnRcIjp0cnVlLFwiaW5wdXRzXCI6W10sXCJuYW1lXCI6XCJ0b3RhbFNpZ25hdHVyZXNcIixcIm91dHB1dHNcIjpbe1wibmFtZVwiOlwiXCIsXCJ0eXBlXCI6XCJ1aW50MjU2XCJ9XSxcInBheWFibGVcIjpmYWxzZSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6dHJ1ZSxcImlucHV0c1wiOltdLFwibmFtZVwiOlwib3duZXJcIixcIm91dHB1dHNcIjpbe1wibmFtZVwiOlwiXCIsXCJ0eXBlXCI6XCJhZGRyZXNzXCJ9XSxcInBheWFibGVcIjpmYWxzZSxcInR5cGVcIjpcImZ1bmN0aW9uXCJ9LHtcImNvbnN0YW50XCI6ZmFsc2UsXCJpbnB1dHNcIjpbXSxcIm5hbWVcIjpcImRyYWluXCIsXCJvdXRwdXRzXCI6W10sXCJwYXlhYmxlXCI6ZmFsc2UsXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOnRydWUsXCJpbnB1dHNcIjpbe1wibmFtZVwiOlwiXCIsXCJ0eXBlXCI6XCJieXRlczRcIn1dLFwibmFtZVwiOlwiZW50cmllc1wiLFwib3V0cHV0c1wiOlt7XCJuYW1lXCI6XCJcIixcInR5cGVcIjpcInN0cmluZ1wifV0sXCJwYXlhYmxlXCI6ZmFsc2UsXCJ0eXBlXCI6XCJmdW5jdGlvblwifSx7XCJjb25zdGFudFwiOmZhbHNlLFwiaW5wdXRzXCI6W3tcIm5hbWVcIjpcIl9tZXRob2RcIixcInR5cGVcIjpcInN0cmluZ1wifV0sXCJuYW1lXCI6XCJyZWdpc3RlclwiLFwib3V0cHV0c1wiOlt7XCJuYW1lXCI6XCJcIixcInR5cGVcIjpcImJvb2xcIn1dLFwicGF5YWJsZVwiOmZhbHNlLFwidHlwZVwiOlwiZnVuY3Rpb25cIn0se1wiaW5wdXRzXCI6W10sXCJ0eXBlXCI6XCJjb25zdHJ1Y3RvclwifSx7XCJhbm9ueW1vdXNcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcImNyZWF0b3JcIixcInR5cGVcIjpcImFkZHJlc3NcIn0se1wiaW5kZXhlZFwiOnRydWUsXCJuYW1lXCI6XCJzaWduYXR1cmVcIixcInR5cGVcIjpcImJ5dGVzNFwifSx7XCJpbmRleGVkXCI6ZmFsc2UsXCJuYW1lXCI6XCJtZXRob2RcIixcInR5cGVcIjpcInN0cmluZ1wifV0sXCJuYW1lXCI6XCJSZWdpc3RlcmVkXCIsXCJ0eXBlXCI6XCJldmVudFwifSx7XCJhbm9ueW1vdXNcIjpmYWxzZSxcImlucHV0c1wiOlt7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcIm9sZFwiLFwidHlwZVwiOlwiYWRkcmVzc1wifSx7XCJpbmRleGVkXCI6dHJ1ZSxcIm5hbWVcIjpcImN1cnJlbnRcIixcInR5cGVcIjpcImFkZHJlc3NcIn1dLFwibmFtZVwiOlwiTmV3T3duZXJcIixcInR5cGVcIjpcImV2ZW50XCJ9XSIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV0aFF1ZXJ5ID0gcmVxdWlyZSgnZXRoanMtcXVlcnknKTtcbnZhciBFdGhGaWx0ZXIgPSByZXF1aXJlKCdldGhqcy1maWx0ZXInKTtcbnZhciBFdGhDb250cmFjdCA9IHJlcXVpcmUoJ2V0aGpzLWNvbnRyYWN0Jyk7XG52YXIgSHR0cFByb3ZpZGVyID0gcmVxdWlyZSgnZXRoanMtcHJvdmlkZXItaHR0cCcpO1xudmFyIGFiaSA9IHJlcXVpcmUoJ2V0aGpzLWFiaScpO1xuLy8gY29uc3QgZ2V0VHhTdWNjZXNzID0gcmVxdWlyZSgnZXRoanMtdHJhbnNhY3Rpb24tc3VjY2VzcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG52YXIgdW5pdCA9IHJlcXVpcmUoJ2V0aGpzLXVuaXQnKTtcbnZhciBrZWNjYWsyNTYgPSByZXF1aXJlKCdqcy1zaGEzJykua2VjY2FrXzI1NjtcbnZhciB0b0JOID0gcmVxdWlyZSgnbnVtYmVyLXRvLWJuJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnZXRoanMtdXRpbCcpO1xudmFyIGdldFRyYW5zYWN0aW9uU3VjY2VzcyA9IHJlcXVpcmUoJy4vbGliL2dldFRyYW5zYWN0aW9uU3VjY2Vzcy5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV0aDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhqcyBFdGggaW5zdGFuY2UuXG4gKlxuICogQG1ldGhvZCBFdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBjcHJvdmlkZXIgdGhlIHdlYjMgc3RhbmRhcmQgcHJvdmlkZXIgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgRXRoIG9wdGlvbnMgb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBldGggRXRoIG9iamVjdCBpbnN0YW5jZVxuICogQHRocm93cyBpZiB0aGUgbmV3IGZsYWcgaXMgbm90IHVzZWQgaW4gY29uc3RydWN0aW9uXG4gKi9cblxuZnVuY3Rpb24gRXRoKGNwcm92aWRlciwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzXSB0aGUgRXRoIG9iamVjdCByZXF1aXJlcyB5b3UgY29uc3RydWN0IGl0IHdpdGggdGhlIFwibmV3XCIgZmxhZyAoaS5lLiBgY29uc3QgZXRoID0gbmV3IEV0aCguLi4pO2ApLicpO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHF1ZXJ5ID0gbmV3IEV0aFF1ZXJ5KGNwcm92aWRlciwgc2VsZi5vcHRpb25zLnF1ZXJ5KTtcbiAgT2JqZWN0LmtleXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKHF1ZXJ5KSkuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHNlbGZbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcXVlcnlbbWV0aG9kTmFtZV0uYXBwbHkocXVlcnksIGFyZ3MpO1xuICAgIH07XG4gIH0pO1xuICBzZWxmLmZpbHRlciA9IG5ldyBFdGhGaWx0ZXIocXVlcnksIHNlbGYub3B0aW9ucy5xdWVyeSk7XG4gIHNlbGYuY29udHJhY3QgPSBuZXcgRXRoQ29udHJhY3QocXVlcnksIHNlbGYub3B0aW9ucy5xdWVyeSk7XG4gIHNlbGYuY3VycmVudFByb3ZpZGVyID0gcXVlcnkucnBjLmN1cnJlbnRQcm92aWRlcjtcbiAgc2VsZi5zZXRQcm92aWRlciA9IHF1ZXJ5LnNldFByb3ZpZGVyO1xuICBzZWxmLmdldFRyYW5zYWN0aW9uU3VjY2VzcyA9IGdldFRyYW5zYWN0aW9uU3VjY2VzcyhzZWxmKTtcbn1cblxuRXRoLkJOID0gQk47XG5FdGguaXNBZGRyZXNzID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdXRpbHMuaXNIZXhTdHJpbmcodmFsLCAyMCk7XG59O1xuRXRoLmtlY2NhazI1NiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICcweCcgKyBrZWNjYWsyNTYodmFsKTtcbn07XG5FdGguQnVmZmVyID0gQnVmZmVyO1xuRXRoLmlzSGV4U3RyaW5nID0gdXRpbHMuaXNIZXhTdHJpbmc7XG5FdGguZnJvbVdlaSA9IHVuaXQuZnJvbVdlaTtcbkV0aC50b1dlaSA9IHVuaXQudG9XZWk7XG5FdGgudG9CTiA9IHRvQk47XG5FdGguYWJpID0gYWJpO1xuRXRoLmZyb21Bc2NpaSA9IHV0aWxzLmZyb21Bc2NpaTtcbkV0aC50b0FzY2lpID0gdXRpbHMudG9Bc2NpaTtcbkV0aC5mcm9tVXRmOCA9IHV0aWxzLmZyb21VdGY4O1xuRXRoLnRvVXRmOCA9IHV0aWxzLnRvVXRmODtcbkV0aC5IdHRwUHJvdmlkZXIgPSBIdHRwUHJvdmlkZXI7IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gKGl0ZXJhYmxlLCBtYXBwZXIsIG9wdHMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0b3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGNvbmN1cnJlbmN5OiBJbmZpbml0eVxuXHR9LCBvcHRzKTtcblxuXHRpZiAodHlwZW9mIG1hcHBlciAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ01hcHBlciBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xuXHR9XG5cblx0Y29uc3QgY29uY3VycmVuY3kgPSBvcHRzLmNvbmN1cnJlbmN5O1xuXG5cdGlmICghKHR5cGVvZiBjb25jdXJyZW5jeSA9PT0gJ251bWJlcicgJiYgY29uY3VycmVuY3kgPj0gMSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBjb25jdXJyZW5jeVxcYCB0byBiZSBhIG51bWJlciBmcm9tIDEgYW5kIHVwLCBnb3QgXFxgJHtjb25jdXJyZW5jeX1cXGAgKCR7dHlwZW9mIGNvbmN1cnJlbmN5fSlgKTtcblx0fVxuXG5cdGNvbnN0IHJldCA9IFtdO1xuXHRjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKTtcblx0bGV0IGlzUmVqZWN0ZWQgPSBmYWxzZTtcblx0bGV0IGl0ZXJhYmxlRG9uZSA9IGZhbHNlO1xuXHRsZXQgcmVzb2x2aW5nQ291bnQgPSAwO1xuXHRsZXQgY3VycmVudElkeCA9IDA7XG5cblx0Y29uc3QgbmV4dCA9ICgpID0+IHtcblx0XHRpZiAoaXNSZWplY3RlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IG5leHRJdGVtID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdGNvbnN0IGkgPSBjdXJyZW50SWR4O1xuXHRcdGN1cnJlbnRJZHgrKztcblxuXHRcdGlmIChuZXh0SXRlbS5kb25lKSB7XG5cdFx0XHRpdGVyYWJsZURvbmUgPSB0cnVlO1xuXG5cdFx0XHRpZiAocmVzb2x2aW5nQ291bnQgPT09IDApIHtcblx0XHRcdFx0cmVzb2x2ZShyZXQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmVzb2x2aW5nQ291bnQrKztcblxuXHRcdFByb21pc2UucmVzb2x2ZShuZXh0SXRlbS52YWx1ZSlcblx0XHRcdC50aGVuKGVsID0+IG1hcHBlcihlbCwgaSkpXG5cdFx0XHQudGhlbihcblx0XHRcdFx0dmFsID0+IHtcblx0XHRcdFx0XHRyZXRbaV0gPSB2YWw7XG5cdFx0XHRcdFx0cmVzb2x2aW5nQ291bnQtLTtcblx0XHRcdFx0XHRuZXh0KCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVyciA9PiB7XG5cdFx0XHRcdFx0aXNSZWplY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdH07XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb25jdXJyZW5jeTsgaSsrKSB7XG5cdFx0bmV4dCgpO1xuXG5cdFx0aWYgKGl0ZXJhYmxlRG9uZSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgd3JhcCA9IGZuID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRyZXNvbHZlKGZuKCkpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGNvbmRpdGlvbiwgYWN0aW9uKSA9PiB3cmFwKGZ1bmN0aW9uIGxvb3AoKSB7XG5cdGlmIChjb25kaXRpb24oKSkge1xuXHRcdHJldHVybiB3cmFwKGFjdGlvbikudGhlbihsb29wKTtcblx0fVxufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3BhY2U6ICcnLFxuICBjeWNsZXM6IGZhbHNlLFxuICByZXBsYWNlcjogKGssIHYpID0+IHYsXG4gIHN0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogQXJyYXkuaXNBcnJheSxcbiAgYXNzaWduOiBPYmplY3QuYXNzaWduLFxuICBpc09iamVjdDogdiA9PiB0eXBlb2YgdiA9PT0gJ29iamVjdCcsXG4gIGlzRnVuY3Rpb246IHYgPT4gdHlwZW9mIHYgPT09ICdmdW5jdGlvbicsXG4gIGlzQm9vbGVhbjogdiA9PiB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nLFxuICBpc1JlZ2V4OiB2ID0+IHYgaW5zdGFuY2VvZiBSZWdFeHAsXG4gIGtleXM6IE9iamVjdC5rZXlzXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG5mdW5jdGlvbiBwYWRTdHJpbmcoaW5wdXQpIHtcbiAgICB2YXIgc2VnbWVudExlbmd0aCA9IDQ7XG4gICAgdmFyIHN0cmluZ0xlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICB2YXIgZGlmZiA9IHN0cmluZ0xlbmd0aCAlIHNlZ21lbnRMZW5ndGg7XG4gICAgaWYgKCFkaWZmKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgdmFyIHBvc2l0aW9uID0gc3RyaW5nTGVuZ3RoO1xuICAgIHZhciBwYWRMZW5ndGggPSBzZWdtZW50TGVuZ3RoIC0gZGlmZjtcbiAgICB2YXIgcGFkZGVkU3RyaW5nTGVuZ3RoID0gc3RyaW5nTGVuZ3RoICsgcGFkTGVuZ3RoO1xuICAgIHZhciBidWZmZXIgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MocGFkZGVkU3RyaW5nTGVuZ3RoKTtcbiAgICBidWZmZXIud3JpdGUoaW5wdXQpO1xuICAgIHdoaWxlIChwYWRMZW5ndGgtLSkge1xuICAgICAgICBidWZmZXIud3JpdGUoXCI9XCIsIHBvc2l0aW9uKyspO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwYWRTdHJpbmc7XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IGlzRGVmaW5lZCA9IChhcmcpID0+IGFyZyAhPT0gdW5kZWZpbmVkICYmIGFyZyAhPT0gbnVsbFxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRGVmaW5lZFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIElkZW50aXR5UHJvdmlkZXIge1xuICAvKiBSZXR1cm4gaWQgb2YgaWRlbnRpdHkgKHRvIGJlIHNpZ25lZCBieSBvcmJpdC1kYiBwdWJsaWMga2V5KSAqL1xuICBhc3luYyBnZXRJZCAob3B0aW9ucykge31cblxuICAvKiBSZXR1cm4gc2lnbmF0dXJlIG9mIE9yYml0REIgcHVibGljIGtleSBzaWduYXR1cmUgKi9cbiAgYXN5bmMgc2lnbklkZW50aXR5IChkYXRhLCBvcHRpb25zKSB7fVxuXG4gIC8qIFZlcmlmeSBhIHNpZ25hdHVyZSBvZiBPcmJpdERCIHB1YmxpYyBrZXkgc2lnbmF0dXJlICovXG4gIHN0YXRpYyBhc3luYyB2ZXJpZnlJZGVudGl0eSAoaWRlbnRpdHkpIHt9XG5cbiAgLyogUmV0dXJuIHRoZSB0eXBlIGZvciB0aGlzIGlkZW50aXR5IHByb3ZpZGVyICovXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnc3RhdGljIGdldCB0eXBlICgpJyBuZWVkcyB0byBiZSBkZWZpbmVkIGluIHRoZSBpbmhlcml0aW5nIGNsYXNzYClcbiAgfVxuXG4gIC8qXG4gICAgUmV0dXJuIHRoZSB0eXBlIGZvciB0aGlzIGlkZW50aXR5LXByb2NpZGVyXG4gICAgTk9URSEgVGhpcyBpcyB0aGUgb25seSBwcm9wZXJ0eSBvZiB0aGUgaW50ZXJmYWNlIHRoYXRcbiAgICBzaG91bGRuJ3QgYmUgb3ZlcnJpZGRlbiBpbiB0aGUgaW5oZXJpdGVkIElkZW50aXR5UHJvdmlkZXJcbiAgKi9cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnR5cGVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IElkZW50aXR5UHJvdmlkZXJcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gcGFkU3RyaW5nKGlucHV0KSB7XG4gICAgdmFyIHNlZ21lbnRMZW5ndGggPSA0O1xuICAgIHZhciBzdHJpbmdMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgdmFyIGRpZmYgPSBzdHJpbmdMZW5ndGggJSBzZWdtZW50TGVuZ3RoO1xuICAgIGlmICghZGlmZikge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIHZhciBwb3NpdGlvbiA9IHN0cmluZ0xlbmd0aDtcbiAgICB2YXIgcGFkTGVuZ3RoID0gc2VnbWVudExlbmd0aCAtIGRpZmY7XG4gICAgdmFyIHBhZGRlZFN0cmluZ0xlbmd0aCA9IHN0cmluZ0xlbmd0aCArIHBhZExlbmd0aDtcbiAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKHBhZGRlZFN0cmluZ0xlbmd0aCk7XG4gICAgYnVmZmVyLndyaXRlKGlucHV0KTtcbiAgICB3aGlsZSAocGFkTGVuZ3RoLS0pIHtcbiAgICAgICAgYnVmZmVyLndyaXRlKFwiPVwiLCBwb3NpdGlvbisrKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcGFkU3RyaW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNoYTI1NiA9IHNoYTI1NjtcbmV4cG9ydHMua2VjY2FrID0ga2VjY2FrO1xuZXhwb3J0cy50b0V0aGVyZXVtQWRkcmVzcyA9IHRvRXRoZXJldW1BZGRyZXNzO1xuXG52YXIgX2pzU2hhID0gcmVxdWlyZShcImpzLXNoYTI1NlwiKTtcblxudmFyIF9qc1NoYTIgPSByZXF1aXJlKFwianMtc2hhM1wiKTtcblxudmFyIF9idWZmZXIgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5mdW5jdGlvbiBzaGEyNTYocGF5bG9hZCkge1xuICByZXR1cm4gX2J1ZmZlci5CdWZmZXIuZnJvbShfanNTaGEuc2hhMjU2LmFycmF5QnVmZmVyKHBheWxvYWQpKTtcbn1cblxuZnVuY3Rpb24ga2VjY2FrKGRhdGEpIHtcbiAgcmV0dXJuIF9idWZmZXIuQnVmZmVyLmZyb20oX2pzU2hhMi5rZWNjYWtfMjU2LmJ1ZmZlcihkYXRhKSk7XG59XG5cbmZ1bmN0aW9uIHRvRXRoZXJldW1BZGRyZXNzKGhleFB1YmxpY0tleSkge1xuICByZXR1cm4gXCIweFwiLmNvbmNhdChrZWNjYWsoX2J1ZmZlci5CdWZmZXIuZnJvbShoZXhQdWJsaWNLZXkuc2xpY2UoMiksICdoZXgnKSkuc2xpY2UoLTIwKS50b1N0cmluZygnaGV4JykpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudG9TaWduYXR1cmVPYmplY3QgPSB0b1NpZ25hdHVyZU9iamVjdDtcbmV4cG9ydHMudmVyaWZ5RVMyNTZLID0gdmVyaWZ5RVMyNTZLO1xuZXhwb3J0cy52ZXJpZnlSZWNvdmVyYWJsZUVTMjU2SyA9IHZlcmlmeVJlY292ZXJhYmxlRVMyNTZLO1xuZXhwb3J0cy52ZXJpZnlFZDI1NTE5ID0gdmVyaWZ5RWQyNTUxOTtcblxudmFyIF9lbGxpcHRpYyA9IHJlcXVpcmUoXCJlbGxpcHRpY1wiKTtcblxudmFyIF9EaWdlc3QgPSByZXF1aXJlKFwiLi9EaWdlc3RcIik7XG5cbnZhciBfYmFzZTY0dXJsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYmFzZTY0dXJsXCIpKTtcblxudmFyIF90d2VldG5hY2wgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJ0d2VldG5hY2xcIikpO1xuXG52YXIgX3R3ZWV0bmFjbFV0aWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJ0d2VldG5hY2wtdXRpbFwiKSk7XG5cbnZhciBzZWNwMjU2azEgPSBuZXcgX2VsbGlwdGljLmVjKCdzZWNwMjU2azEnKTsgLy8gY29udmVydHMgYSBKT1NFIHNpZ25hdHVyZSB0byBpdCdzIGNvbXBvbmVudHNcblxuZnVuY3Rpb24gdG9TaWduYXR1cmVPYmplY3Qoc2lnbmF0dXJlKSB7XG4gIHZhciByZWNvdmVyYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIHJhd3NpZyA9IF9iYXNlNjR1cmwuZGVmYXVsdC50b0J1ZmZlcihzaWduYXR1cmUpO1xuXG4gIGlmIChyYXdzaWcubGVuZ3RoICE9PSAocmVjb3ZlcmFibGUgPyA2NSA6IDY0KSkgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gIHZhciByID0gcmF3c2lnLnNsaWNlKDAsIDMyKS50b1N0cmluZygnaGV4Jyk7XG4gIHZhciBzID0gcmF3c2lnLnNsaWNlKDMyLCA2NCkudG9TdHJpbmcoJ2hleCcpO1xuICB2YXIgc2lnT2JqID0ge1xuICAgIHI6IHIsXG4gICAgczogc1xuICB9O1xuXG4gIGlmIChyZWNvdmVyYWJsZSkge1xuICAgIHNpZ09iai5yZWNvdmVyeVBhcmFtID0gcmF3c2lnWzY0XTtcbiAgfVxuXG4gIHJldHVybiBzaWdPYmo7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeUVTMjU2SyhkYXRhLCBzaWduYXR1cmUsIGF1dGhlbnRpY2F0b3JzKSB7XG4gIHZhciBoYXNoID0gKDAsIF9EaWdlc3Quc2hhMjU2KShkYXRhKTtcbiAgdmFyIHNpZ09iaiA9IHRvU2lnbmF0dXJlT2JqZWN0KHNpZ25hdHVyZSk7XG4gIHZhciBzaWduZXIgPSBhdXRoZW50aWNhdG9ycy5maW5kKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIHB1YmxpY0tleUhleCA9IF9yZWYucHVibGljS2V5SGV4O1xuICAgIHJldHVybiBzZWNwMjU2azEua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXlIZXgsICdoZXgnKS52ZXJpZnkoaGFzaCwgc2lnT2JqKTtcbiAgfSk7XG4gIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25hdHVyZSBpbnZhbGlkIGZvciBKV1QnKTtcbiAgcmV0dXJuIHNpZ25lcjtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5UmVjb3ZlcmFibGVFUzI1NksoZGF0YSwgc2lnbmF0dXJlLCBhdXRoZW50aWNhdG9ycykge1xuICB2YXIgc2lnT2JqID0gdG9TaWduYXR1cmVPYmplY3Qoc2lnbmF0dXJlLCB0cnVlKTtcbiAgdmFyIGhhc2ggPSAoMCwgX0RpZ2VzdC5zaGEyNTYpKGRhdGEpO1xuICB2YXIgcmVjb3ZlcmVkS2V5ID0gc2VjcDI1NmsxLnJlY292ZXJQdWJLZXkoaGFzaCwgc2lnT2JqLCBzaWdPYmoucmVjb3ZlcnlQYXJhbSk7XG4gIHZhciByZWNvdmVyZWRQdWJsaWNLZXlIZXggPSByZWNvdmVyZWRLZXkuZW5jb2RlKCdoZXgnKTtcbiAgdmFyIHJlY292ZXJlZENvbXByZXNzZWRQdWJsaWNLZXlIZXggPSByZWNvdmVyZWRLZXkuZW5jb2RlKCdoZXgnLCB0cnVlKTtcbiAgdmFyIHJlY292ZXJlZEFkZHJlc3MgPSAoMCwgX0RpZ2VzdC50b0V0aGVyZXVtQWRkcmVzcykocmVjb3ZlcmVkUHVibGljS2V5SGV4KTtcbiAgdmFyIHNpZ25lciA9IGF1dGhlbnRpY2F0b3JzLmZpbmQoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHB1YmxpY0tleUhleCA9IF9yZWYyLnB1YmxpY0tleUhleCxcbiAgICAgICAgZXRoZXJldW1BZGRyZXNzID0gX3JlZjIuZXRoZXJldW1BZGRyZXNzO1xuICAgIHJldHVybiBwdWJsaWNLZXlIZXggPT09IHJlY292ZXJlZFB1YmxpY0tleUhleCB8fCBwdWJsaWNLZXlIZXggPT09IHJlY292ZXJlZENvbXByZXNzZWRQdWJsaWNLZXlIZXggfHwgZXRoZXJldW1BZGRyZXNzID09PSByZWNvdmVyZWRBZGRyZXNzO1xuICB9KTtcbiAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIGludmFsaWQgZm9yIEpXVCcpO1xuICByZXR1cm4gc2lnbmVyO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlFZDI1NTE5KGRhdGEsIHNpZ25hdHVyZSwgYXV0aGVudGljYXRvcnMpIHtcbiAgdmFyIGNsZWFyID0gX3R3ZWV0bmFjbFV0aWwuZGVmYXVsdC5kZWNvZGVVVEY4KGRhdGEpO1xuXG4gIHZhciBzaWcgPSBfdHdlZXRuYWNsVXRpbC5kZWZhdWx0LmRlY29kZUJhc2U2NChfYmFzZTY0dXJsLmRlZmF1bHQudG9CYXNlNjQoc2lnbmF0dXJlKSk7XG5cbiAgdmFyIHNpZ25lciA9IGF1dGhlbnRpY2F0b3JzLmZpbmQoZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgdmFyIHB1YmxpY0tleUJhc2U2NCA9IF9yZWYzLnB1YmxpY0tleUJhc2U2NDtcbiAgICByZXR1cm4gX3R3ZWV0bmFjbC5kZWZhdWx0LnNpZ24uZGV0YWNoZWQudmVyaWZ5KGNsZWFyLCBzaWcsIF90d2VldG5hY2xVdGlsLmRlZmF1bHQuZGVjb2RlQmFzZTY0KHB1YmxpY0tleUJhc2U2NCkpO1xuICB9KTtcbiAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIGludmFsaWQgZm9yIEpXVCcpO1xuICByZXR1cm4gc2lnbmVyO1xufVxuXG52YXIgYWxnb3JpdGhtcyA9IHtcbiAgRVMyNTZLOiB2ZXJpZnlFUzI1NkssXG4gICdFUzI1NkstUic6IHZlcmlmeVJlY292ZXJhYmxlRVMyNTZLLFxuICAnRWQyNTUxOSc6IHZlcmlmeUVkMjU1MTlcbn07XG5cbmZ1bmN0aW9uIFZlcmlmaWVyQWxnb3JpdGhtKGFsZykge1xuICB2YXIgaW1wbCA9IGFsZ29yaXRobXNbYWxnXTtcbiAgaWYgKCFpbXBsKSB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBhbGdvcml0aG0gXCIuY29uY2F0KGFsZykpO1xuICByZXR1cm4gaW1wbDtcbn1cblxuVmVyaWZpZXJBbGdvcml0aG0udG9TaWduYXR1cmVPYmplY3QgPSB0b1NpZ25hdHVyZU9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gVmVyaWZpZXJBbGdvcml0aG07IiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4vZGVmaW5lUHJvcGVydHkuanNcIik7XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gT2JqZWN0KGFyZ3VtZW50c1tpXSkgOiB7fTtcbiAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG93bktleXMucHVzaC5hcHBseShvd25LZXlzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RTcHJlYWQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5FUzI1NktTaWduZXIgPSBFUzI1NktTaWduZXI7XG5leHBvcnRzLkVkMjU1MTlTaWduZXIgPSBFZDI1NTE5U2lnbmVyO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9iYXNlNjR1cmwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJiYXNlNjR1cmxcIikpO1xuXG52YXIgX2J1ZmZlciA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG5cbmZ1bmN0aW9uIEVTMjU2S1NpZ25lcigpIHtcbiAgdmFyIHJlY292ZXJhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICBmdW5jdGlvbiB0b0pvc2UoX3JlZikge1xuICAgIHZhciByID0gX3JlZi5yLFxuICAgICAgICBzID0gX3JlZi5zLFxuICAgICAgICByZWNvdmVyeVBhcmFtID0gX3JlZi5yZWNvdmVyeVBhcmFtO1xuXG4gICAgdmFyIGpvc2UgPSBfYnVmZmVyLkJ1ZmZlci5hbGxvYyhyZWNvdmVyYWJsZSA/IDY1IDogNjQpO1xuXG4gICAgX2J1ZmZlci5CdWZmZXIuZnJvbShyLCAnaGV4JykuY29weShqb3NlLCAwKTtcblxuICAgIF9idWZmZXIuQnVmZmVyLmZyb20ocywgJ2hleCcpLmNvcHkoam9zZSwgMzIpO1xuXG4gICAgaWYgKHJlY292ZXJhYmxlKSB7XG4gICAgICBpZiAocmVjb3ZlcnlQYXJhbSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25lciBkaWQgbm90IHJldHVybiBhIHJlY292ZXJ5UGFyYW0nKTtcbiAgICAgIGpvc2VbNjRdID0gcmVjb3ZlcnlQYXJhbTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Jhc2U2NHVybC5kZWZhdWx0LmVuY29kZShqb3NlKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2lnbiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocGF5bG9hZCwgc2lnbmVyKSB7XG4gICAgICAgIHZhciBzaWduYXR1cmU7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduZXIocGF5bG9hZCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB0b0pvc2Uoc2lnbmF0dXJlKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzaWduKF94LCBfeDIpIHtcbiAgICAgICAgcmV0dXJuIF9zaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaWduO1xuICAgIH0oKVxuICApO1xufVxuXG5mdW5jdGlvbiBFZDI1NTE5U2lnbmVyKCkge1xuICByZXR1cm4gKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3NpZ24yID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIocGF5bG9hZCwgc2lnbmVyKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBzaWduZXIocGF5bG9hZCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzaWduKF94MywgX3g0KSB7XG4gICAgICAgIHJldHVybiBfc2lnbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNpZ247XG4gICAgfSgpXG4gICk7XG59XG5cbnZhciBhbGdvcml0aG1zID0ge1xuICBFUzI1Nks6IEVTMjU2S1NpZ25lcigpLFxuICAnRVMyNTZLLVInOiBFUzI1NktTaWduZXIodHJ1ZSksXG4gICdFZDI1NTE5JzogRWQyNTUxOVNpZ25lcigpXG59O1xuXG5mdW5jdGlvbiBTaWduZXJBbGdvcml0aG0oYWxnKSB7XG4gIHZhciBpbXBsID0gYWxnb3JpdGhtc1thbGddO1xuICBpZiAoIWltcGwpIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGFsZ29yaXRobSBcIi5jb25jYXQoYWxnKSk7XG4gIHJldHVybiBpbXBsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25lckFsZ29yaXRobTsiLCIndXNlIHN0cmljdCdcblxuY29uc3QgaXNWYWxpZEV0aEFkZHJlc3MgPSAod2ViMywgYWRkcmVzcykgPT4ge1xuICByZXR1cm4gd2ViMy51dGlscy5pc0FkZHJlc3MoYWRkcmVzcylcbn1cbm1vZHVsZS5leHBvcnRzID0gaXNWYWxpZEV0aEFkZHJlc3NcbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgaW8gPSByZXF1aXJlKCdvcmJpdC1kYi1pbycpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZWFkOiBhc3luYyAoaXBmcywgY2lkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCBhY2Nlc3MgPSBhd2FpdCBpby5yZWFkKGlwZnMsIGNpZCwgb3B0aW9ucylcbiAgICByZXR1cm4gKHR5cGVvZiBhY2Nlc3Mud3JpdGUgPT09ICdzdHJpbmcnKSA/IEpTT04ucGFyc2UoYWNjZXNzLndyaXRlKSA6IGFjY2Vzcy53cml0ZSAvL3YwIGFjY2Vzcy53cml0ZSBub3Qgc3RyaW5naWZpZWRcbiAgfSxcbiAgd3JpdGU6IGlvLndyaXRlXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBNYXAgPSAoaXRlcmFibGUsIG1hcHBlciwgb3B0aW9ucykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0Y29uY3VycmVuY3k6IEluZmluaXR5XG5cdH0sIG9wdGlvbnMpO1xuXG5cdGlmICh0eXBlb2YgbWFwcGVyICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignTWFwcGVyIGZ1bmN0aW9uIGlzIHJlcXVpcmVkJyk7XG5cdH1cblxuXHRjb25zdCB7Y29uY3VycmVuY3l9ID0gb3B0aW9ucztcblxuXHRpZiAoISh0eXBlb2YgY29uY3VycmVuY3kgPT09ICdudW1iZXInICYmIGNvbmN1cnJlbmN5ID49IDEpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgY29uY3VycmVuY3lcXGAgdG8gYmUgYSBudW1iZXIgZnJvbSAxIGFuZCB1cCwgZ290IFxcYCR7Y29uY3VycmVuY3l9XFxgICgke3R5cGVvZiBjb25jdXJyZW5jeX0pYCk7XG5cdH1cblxuXHRjb25zdCByZXQgPSBbXTtcblx0Y29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG5cdGxldCBpc1JlamVjdGVkID0gZmFsc2U7XG5cdGxldCBpc0l0ZXJhYmxlRG9uZSA9IGZhbHNlO1xuXHRsZXQgcmVzb2x2aW5nQ291bnQgPSAwO1xuXHRsZXQgY3VycmVudEluZGV4ID0gMDtcblxuXHRjb25zdCBuZXh0ID0gKCkgPT4ge1xuXHRcdGlmIChpc1JlamVjdGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgbmV4dEl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG5cdFx0Y29uc3QgaSA9IGN1cnJlbnRJbmRleDtcblx0XHRjdXJyZW50SW5kZXgrKztcblxuXHRcdGlmIChuZXh0SXRlbS5kb25lKSB7XG5cdFx0XHRpc0l0ZXJhYmxlRG9uZSA9IHRydWU7XG5cblx0XHRcdGlmIChyZXNvbHZpbmdDb3VudCA9PT0gMCkge1xuXHRcdFx0XHRyZXNvbHZlKHJldCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRyZXNvbHZpbmdDb3VudCsrO1xuXG5cdFx0UHJvbWlzZS5yZXNvbHZlKG5leHRJdGVtLnZhbHVlKVxuXHRcdFx0LnRoZW4oZWxlbWVudCA9PiBtYXBwZXIoZWxlbWVudCwgaSkpXG5cdFx0XHQudGhlbihcblx0XHRcdFx0dmFsdWUgPT4ge1xuXHRcdFx0XHRcdHJldFtpXSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJlc29sdmluZ0NvdW50LS07XG5cdFx0XHRcdFx0bmV4dCgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvciA9PiB7XG5cdFx0XHRcdFx0aXNSZWplY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0fTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbmN1cnJlbmN5OyBpKyspIHtcblx0XHRuZXh0KCk7XG5cblx0XHRpZiAoaXNJdGVyYWJsZURvbmUpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcE1hcDtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcE1hcDtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCJcbmV4cG9ydHMuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgaWYoQnVmZmVyLmlzQnVmZmVyKGEpKSB7XG4gICAgdmFyIGwgPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNtcCA9IGFbaV0gLSBiW2ldXG4gICAgICBpZihjbXApIHJldHVybiBjbXBcbiAgICB9XG4gICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMFxufVxuXG4vLyB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgYWJzdHJhY3QtbGV2ZWxkb3duIHRlc3RzXG4vLyBudWxsaXNoIG9yIGVtcHR5IHN0cmluZ3MuXG4vLyBJIGNvdWxkIHVzZSAhIXZhbCBidXQgSSB3YW50IHRvIHBlcm1pdCBudW1iZXJzIGFuZCBib29sZWFucyxcbi8vIGlmIHBvc3NpYmxlLlxuXG5mdW5jdGlvbiBpc0RlZiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09ICcnXG59XG5cbmZ1bmN0aW9uIGhhcyAocmFuZ2UsIG5hbWUpIHtcbiAgcmV0dXJuIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJhbmdlLCBuYW1lKVxufVxuXG5mdW5jdGlvbiBoYXNLZXkocmFuZ2UsIG5hbWUpIHtcbiAgcmV0dXJuIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJhbmdlLCBuYW1lKSAmJiBuYW1lXG59XG5cbnZhciBsb3dlckJvdW5kS2V5ID0gZXhwb3J0cy5sb3dlckJvdW5kS2V5ID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICBoYXNLZXkocmFuZ2UsICdndCcpXG4gICAgfHwgaGFzS2V5KHJhbmdlLCAnZ3RlJylcbiAgICB8fCBoYXNLZXkocmFuZ2UsICdtaW4nKVxuICAgIHx8IChyYW5nZS5yZXZlcnNlID8gaGFzS2V5KHJhbmdlLCAnZW5kJykgOiBoYXNLZXkocmFuZ2UsICdzdGFydCcpKVxuICAgIHx8IHVuZGVmaW5lZFxuICAgIClcbn1cblxudmFyIGxvd2VyQm91bmQgPSBleHBvcnRzLmxvd2VyQm91bmQgPSBmdW5jdGlvbiAocmFuZ2UsIGRlZikge1xuICB2YXIgayA9IGxvd2VyQm91bmRLZXkocmFuZ2UpXG4gIHJldHVybiBrID8gcmFuZ2Vba10gOiBkZWZcbn1cblxudmFyIGxvd2VyQm91bmRJbmNsdXNpdmUgPSBleHBvcnRzLmxvd2VyQm91bmRJbmNsdXNpdmUgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgcmV0dXJuIGhhcyhyYW5nZSwgJ2d0JykgPyBmYWxzZSA6IHRydWVcbn1cblxudmFyIHVwcGVyQm91bmRJbmNsdXNpdmUgPSBleHBvcnRzLnVwcGVyQm91bmRJbmNsdXNpdmUgPVxuICBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICByZXR1cm4gKGhhcyhyYW5nZSwgJ2x0JykgLyomJiAhcmFuZ2UubWF4RXgqLykgPyBmYWxzZSA6IHRydWVcbiAgfVxuXG52YXIgbG93ZXJCb3VuZEV4Y2x1c2l2ZSA9IGV4cG9ydHMubG93ZXJCb3VuZEV4Y2x1c2l2ZSA9XG4gIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIHJldHVybiAhbG93ZXJCb3VuZEluY2x1c2l2ZShyYW5nZSlcbiAgfVxuXG52YXIgdXBwZXJCb3VuZEV4Y2x1c2l2ZSA9IGV4cG9ydHMudXBwZXJCb3VuZEV4Y2x1c2l2ZSA9XG4gIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIHJldHVybiAhdXBwZXJCb3VuZEluY2x1c2l2ZShyYW5nZSlcbiAgfVxuXG52YXIgdXBwZXJCb3VuZEtleSA9IGV4cG9ydHMudXBwZXJCb3VuZEtleSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIHJldHVybiAoXG4gICAgICAgaGFzS2V5KHJhbmdlLCAnbHQnKVxuICAgIHx8IGhhc0tleShyYW5nZSwgJ2x0ZScpXG4gICAgfHwgaGFzS2V5KHJhbmdlLCAnbWF4JylcbiAgICB8fCAocmFuZ2UucmV2ZXJzZSA/IGhhc0tleShyYW5nZSwgJ3N0YXJ0JykgOiBoYXNLZXkocmFuZ2UsICdlbmQnKSlcbiAgICB8fCB1bmRlZmluZWRcbiAgICApXG59XG5cbnZhciB1cHBlckJvdW5kID0gZXhwb3J0cy51cHBlckJvdW5kID0gZnVuY3Rpb24gKHJhbmdlLCBkZWYpIHtcbiAgdmFyIGsgPSB1cHBlckJvdW5kS2V5KHJhbmdlKVxuICByZXR1cm4gayA/IHJhbmdlW2tdIDogZGVmXG59XG5cbmV4cG9ydHMuc3RhcnQgPSBmdW5jdGlvbiAocmFuZ2UsIGRlZikge1xuICByZXR1cm4gcmFuZ2UucmV2ZXJzZSA/IHVwcGVyQm91bmQocmFuZ2UsIGRlZikgOiBsb3dlckJvdW5kKHJhbmdlLCBkZWYpXG59XG5leHBvcnRzLmVuZCA9IGZ1bmN0aW9uIChyYW5nZSwgZGVmKSB7XG4gIHJldHVybiByYW5nZS5yZXZlcnNlID8gbG93ZXJCb3VuZChyYW5nZSwgZGVmKSA6IHVwcGVyQm91bmQocmFuZ2UsIGRlZilcbn1cbmV4cG9ydHMuc3RhcnRJbmNsdXNpdmUgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgcmV0dXJuIChcbiAgICByYW5nZS5yZXZlcnNlXG4gID8gdXBwZXJCb3VuZEluY2x1c2l2ZShyYW5nZSlcbiAgOiBsb3dlckJvdW5kSW5jbHVzaXZlKHJhbmdlKVxuICApXG59XG5leHBvcnRzLmVuZEluY2x1c2l2ZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICByZXR1cm4gKFxuICAgIHJhbmdlLnJldmVyc2VcbiAgPyBsb3dlckJvdW5kSW5jbHVzaXZlKHJhbmdlKVxuICA6IHVwcGVyQm91bmRJbmNsdXNpdmUocmFuZ2UpXG4gIClcbn1cblxuZnVuY3Rpb24gaWQgKGUpIHsgcmV0dXJuIGUgfVxuXG5leHBvcnRzLnRvTHRndCA9IGZ1bmN0aW9uIChyYW5nZSwgX3JhbmdlLCBtYXAsIGxvd2VyLCB1cHBlcikge1xuICBfcmFuZ2UgPSBfcmFuZ2UgfHwge31cbiAgbWFwID0gbWFwIHx8IGlkXG4gIHZhciBkZWZhdWx0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzXG4gIHZhciBsYiA9IGV4cG9ydHMubG93ZXJCb3VuZEtleShyYW5nZSlcbiAgdmFyIHViID0gZXhwb3J0cy51cHBlckJvdW5kS2V5KHJhbmdlKVxuICBpZihsYikge1xuICAgIGlmKGxiID09PSAnZ3QnKSBfcmFuZ2UuZ3QgPSBtYXAocmFuZ2UuZ3QsIGZhbHNlKVxuICAgIGVsc2UgICAgICAgICAgICBfcmFuZ2UuZ3RlID0gbWFwKHJhbmdlW2xiXSwgZmFsc2UpXG4gIH1cbiAgZWxzZSBpZihkZWZhdWx0cylcbiAgICBfcmFuZ2UuZ3RlID0gbWFwKGxvd2VyLCBmYWxzZSlcblxuICBpZih1Yikge1xuICAgIGlmKHViID09PSAnbHQnKSBfcmFuZ2UubHQgPSBtYXAocmFuZ2UubHQsIHRydWUpXG4gICAgZWxzZSAgICAgICAgICAgIF9yYW5nZS5sdGUgPSBtYXAocmFuZ2VbdWJdLCB0cnVlKVxuICB9XG4gIGVsc2UgaWYoZGVmYXVsdHMpXG4gICAgX3JhbmdlLmx0ZSA9IG1hcCh1cHBlciwgdHJ1ZSlcblxuICBpZihyYW5nZS5yZXZlcnNlICE9IG51bGwpXG4gICAgX3JhbmdlLnJldmVyc2UgPSAhIXJhbmdlLnJldmVyc2VcblxuICAvL2lmIHJhbmdlIHdhcyB1c2VkIG11dGFibHlcbiAgLy8oaW4gbGV2ZWwtc3VibGV2ZWwgaXQncyBwYXJ0IG9mIGFuIG9wdGlvbnMgb2JqZWN0XG4gIC8vdGhhdCBoYXMgbW9yZSBwcm9wZXJ0aWVzIG9uIGl0LilcbiAgaWYoaGFzKF9yYW5nZSwgJ21heCcpKSAgIGRlbGV0ZSBfcmFuZ2UubWF4XG4gIGlmKGhhcyhfcmFuZ2UsICdtaW4nKSkgICBkZWxldGUgX3JhbmdlLm1pblxuICBpZihoYXMoX3JhbmdlLCAnc3RhcnQnKSkgZGVsZXRlIF9yYW5nZS5zdGFydFxuICBpZihoYXMoX3JhbmdlLCAnZW5kJykpICAgZGVsZXRlIF9yYW5nZS5lbmRcblxuICByZXR1cm4gX3JhbmdlXG59XG5cbmV4cG9ydHMuY29udGFpbnMgPSBmdW5jdGlvbiAocmFuZ2UsIGtleSwgY29tcGFyZSkge1xuICBjb21wYXJlID0gY29tcGFyZSB8fCBleHBvcnRzLmNvbXBhcmVcblxuICB2YXIgbGIgPSBsb3dlckJvdW5kKHJhbmdlKVxuICBpZihpc0RlZihsYikpIHtcbiAgICB2YXIgY21wID0gY29tcGFyZShrZXksIGxiKVxuICAgIGlmKGNtcCA8IDAgfHwgKGNtcCA9PT0gMCAmJiBsb3dlckJvdW5kRXhjbHVzaXZlKHJhbmdlKSkpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHZhciB1YiA9IHVwcGVyQm91bmQocmFuZ2UpXG4gIGlmKGlzRGVmKHViKSkge1xuICAgIHZhciBjbXAgPSBjb21wYXJlKGtleSwgdWIpXG4gICAgaWYoY21wID4gMCB8fCAoY21wID09PSAwKSAmJiB1cHBlckJvdW5kRXhjbHVzaXZlKHJhbmdlKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0cy5maWx0ZXIgPSBmdW5jdGlvbiAocmFuZ2UsIGNvbXBhcmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5jb250YWlucyhyYW5nZSwga2V5LCBjb21wYXJlKVxuICB9XG59XG5cblxuIiwiZnVuY3Rpb24gQWJzdHJhY3RDaGFpbmVkQmF0Y2ggKGRiKSB7XG4gIGlmICh0eXBlb2YgZGIgIT09ICdvYmplY3QnIHx8IGRiID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBhYnN0cmFjdC1sZXZlbGRvd24gY29tcGxpYW50IHN0b3JlJylcbiAgfVxuXG4gIHRoaXMuZGIgPSBkYlxuICB0aGlzLl9vcGVyYXRpb25zID0gW11cbiAgdGhpcy5fd3JpdHRlbiA9IGZhbHNlXG59XG5cbkFic3RyYWN0Q2hhaW5lZEJhdGNoLnByb3RvdHlwZS5fY2hlY2tXcml0dGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fd3JpdHRlbikge1xuICAgIHRocm93IG5ldyBFcnJvcignd3JpdGUoKSBhbHJlYWR5IGNhbGxlZCBvbiB0aGlzIGJhdGNoJylcbiAgfVxufVxuXG5BYnN0cmFjdENoYWluZWRCYXRjaC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdGhpcy5fY2hlY2tXcml0dGVuKClcblxuICB2YXIgZXJyID0gdGhpcy5kYi5fY2hlY2tLZXkoa2V5KSB8fCB0aGlzLmRiLl9jaGVja1ZhbHVlKHZhbHVlKVxuICBpZiAoZXJyKSB0aHJvdyBlcnJcblxuICBrZXkgPSB0aGlzLmRiLl9zZXJpYWxpemVLZXkoa2V5KVxuICB2YWx1ZSA9IHRoaXMuZGIuX3NlcmlhbGl6ZVZhbHVlKHZhbHVlKVxuXG4gIHRoaXMuX3B1dChrZXksIHZhbHVlKVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkFic3RyYWN0Q2hhaW5lZEJhdGNoLnByb3RvdHlwZS5fcHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdGhpcy5fb3BlcmF0aW9ucy5wdXNoKHsgdHlwZTogJ3B1dCcsIGtleToga2V5LCB2YWx1ZTogdmFsdWUgfSlcbn1cblxuQWJzdHJhY3RDaGFpbmVkQmF0Y2gucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdGhpcy5fY2hlY2tXcml0dGVuKClcblxuICB2YXIgZXJyID0gdGhpcy5kYi5fY2hlY2tLZXkoa2V5KVxuICBpZiAoZXJyKSB0aHJvdyBlcnJcblxuICBrZXkgPSB0aGlzLmRiLl9zZXJpYWxpemVLZXkoa2V5KVxuICB0aGlzLl9kZWwoa2V5KVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkFic3RyYWN0Q2hhaW5lZEJhdGNoLnByb3RvdHlwZS5fZGVsID0gZnVuY3Rpb24gKGtleSkge1xuICB0aGlzLl9vcGVyYXRpb25zLnB1c2goeyB0eXBlOiAnZGVsJywga2V5OiBrZXkgfSlcbn1cblxuQWJzdHJhY3RDaGFpbmVkQmF0Y2gucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9jaGVja1dyaXR0ZW4oKVxuICB0aGlzLl9jbGVhcigpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQWJzdHJhY3RDaGFpbmVkQmF0Y2gucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fb3BlcmF0aW9ucyA9IFtdXG59XG5cbkFic3RyYWN0Q2hhaW5lZEJhdGNoLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICB0aGlzLl9jaGVja1dyaXR0ZW4oKVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykgeyBjYWxsYmFjayA9IG9wdGlvbnMgfVxuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3cml0ZSgpIHJlcXVpcmVzIGEgY2FsbGJhY2sgYXJndW1lbnQnKVxuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgdGhpcy5fd3JpdHRlbiA9IHRydWVcbiAgdGhpcy5fd3JpdGUob3B0aW9ucywgY2FsbGJhY2spXG59XG5cbkFic3RyYWN0Q2hhaW5lZEJhdGNoLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdGhpcy5kYi5fYmF0Y2godGhpcy5fb3BlcmF0aW9ucywgb3B0aW9ucywgY2FsbGJhY2spXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RDaGFpbmVkQmF0Y2hcbiIsImZ1bmN0aW9uIEFic3RyYWN0SXRlcmF0b3IgKGRiKSB7XG4gIGlmICh0eXBlb2YgZGIgIT09ICdvYmplY3QnIHx8IGRiID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBhYnN0cmFjdC1sZXZlbGRvd24gY29tcGxpYW50IHN0b3JlJylcbiAgfVxuXG4gIHRoaXMuZGIgPSBkYlxuICB0aGlzLl9lbmRlZCA9IGZhbHNlXG4gIHRoaXMuX25leHRpbmcgPSBmYWxzZVxufVxuXG5BYnN0cmFjdEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25leHQoKSByZXF1aXJlcyBhIGNhbGxiYWNrIGFyZ3VtZW50JylcbiAgfVxuXG4gIGlmIChzZWxmLl9lbmRlZCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBFcnJvcignY2Fubm90IGNhbGwgbmV4dCgpIGFmdGVyIGVuZCgpJykpXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIGlmIChzZWxmLl9uZXh0aW5nKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgbmV3IEVycm9yKCdjYW5ub3QgY2FsbCBuZXh0KCkgYmVmb3JlIHByZXZpb3VzIG5leHQoKSBoYXMgY29tcGxldGVkJykpXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYuX25leHRpbmcgPSB0cnVlXG4gIHNlbGYuX25leHQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX25leHRpbmcgPSBmYWxzZVxuICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgfSlcblxuICByZXR1cm4gc2VsZlxufVxuXG5BYnN0cmFjdEl0ZXJhdG9yLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKVxufVxuXG5BYnN0cmFjdEl0ZXJhdG9yLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICBpZiAodGhpcy5fZW5kZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjYWxsIHNlZWsoKSBhZnRlciBlbmQoKScpXG4gIH1cbiAgaWYgKHRoaXMuX25leHRpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjYWxsIHNlZWsoKSBiZWZvcmUgbmV4dCgpIGhhcyBjb21wbGV0ZWQnKVxuICB9XG5cbiAgdGFyZ2V0ID0gdGhpcy5kYi5fc2VyaWFsaXplS2V5KHRhcmdldClcbiAgdGhpcy5fc2Vlayh0YXJnZXQpXG59XG5cbkFic3RyYWN0SXRlcmF0b3IucHJvdG90eXBlLl9zZWVrID0gZnVuY3Rpb24gKHRhcmdldCkge31cblxuQWJzdHJhY3RJdGVyYXRvci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZCgpIHJlcXVpcmVzIGEgY2FsbGJhY2sgYXJndW1lbnQnKVxuICB9XG5cbiAgaWYgKHRoaXMuX2VuZGVkKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBFcnJvcignZW5kKCkgYWxyZWFkeSBjYWxsZWQgb24gaXRlcmF0b3InKSlcbiAgfVxuXG4gIHRoaXMuX2VuZGVkID0gdHJ1ZVxuICB0aGlzLl9lbmQoY2FsbGJhY2spXG59XG5cbkFic3RyYWN0SXRlcmF0b3IucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdEl0ZXJhdG9yXG4iLCJ2YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgQWJzdHJhY3RJdGVyYXRvciA9IHJlcXVpcmUoJy4vYWJzdHJhY3QtaXRlcmF0b3InKVxudmFyIEFic3RyYWN0Q2hhaW5lZEJhdGNoID0gcmVxdWlyZSgnLi9hYnN0cmFjdC1jaGFpbmVkLWJhdGNoJylcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbnZhciByYW5nZU9wdGlvbnMgPSAnc3RhcnQgZW5kIGd0IGd0ZSBsdCBsdGUnLnNwbGl0KCcgJylcblxuZnVuY3Rpb24gQWJzdHJhY3RMZXZlbERPV04gKCkge1xuICB0aGlzLnN0YXR1cyA9ICduZXcnXG59XG5cbkFic3RyYWN0TGV2ZWxET1dOLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgb2xkU3RhdHVzID0gdGhpcy5zdGF0dXNcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrID0gb3B0aW9uc1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29wZW4oKSByZXF1aXJlcyBhIGNhbGxiYWNrIGFyZ3VtZW50JylcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbCkgb3B0aW9ucyA9IHt9XG5cbiAgb3B0aW9ucy5jcmVhdGVJZk1pc3NpbmcgPSBvcHRpb25zLmNyZWF0ZUlmTWlzc2luZyAhPT0gZmFsc2VcbiAgb3B0aW9ucy5lcnJvcklmRXhpc3RzID0gISFvcHRpb25zLmVycm9ySWZFeGlzdHNcblxuICB0aGlzLnN0YXR1cyA9ICdvcGVuaW5nJ1xuICB0aGlzLl9vcGVuKG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzZWxmLnN0YXR1cyA9IG9sZFN0YXR1c1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG4gICAgc2VsZi5zdGF0dXMgPSAnb3BlbidcbiAgICBjYWxsYmFjaygpXG4gIH0pXG59XG5cbkFic3RyYWN0TGV2ZWxET1dOLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKVxufVxuXG5BYnN0cmFjdExldmVsRE9XTi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBvbGRTdGF0dXMgPSB0aGlzLnN0YXR1c1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsb3NlKCkgcmVxdWlyZXMgYSBjYWxsYmFjayBhcmd1bWVudCcpXG4gIH1cblxuICB0aGlzLnN0YXR1cyA9ICdjbG9zaW5nJ1xuICB0aGlzLl9jbG9zZShmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgc2VsZi5zdGF0dXMgPSBvbGRTdGF0dXNcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuICAgIHNlbGYuc3RhdHVzID0gJ2Nsb3NlZCdcbiAgICBjYWxsYmFjaygpXG4gIH0pXG59XG5cbkFic3RyYWN0TGV2ZWxET1dOLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaylcbn1cblxuQWJzdHJhY3RMZXZlbERPV04ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2sgPSBvcHRpb25zXG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2V0KCkgcmVxdWlyZXMgYSBjYWxsYmFjayBhcmd1bWVudCcpXG4gIH1cblxuICB2YXIgZXJyID0gdGhpcy5fY2hlY2tLZXkoa2V5KVxuICBpZiAoZXJyKSByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgZXJyKVxuXG4gIGtleSA9IHRoaXMuX3NlcmlhbGl6ZUtleShrZXkpXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSBvcHRpb25zID0ge31cblxuICBvcHRpb25zLmFzQnVmZmVyID0gb3B0aW9ucy5hc0J1ZmZlciAhPT0gZmFsc2VcblxuICB0aGlzLl9nZXQoa2V5LCBvcHRpb25zLCBjYWxsYmFjaylcbn1cblxuQWJzdHJhY3RMZXZlbERPV04ucHJvdG90eXBlLl9nZXQgPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgY2FsbGJhY2sobmV3IEVycm9yKCdOb3RGb3VuZCcpKSB9KVxufVxuXG5BYnN0cmFjdExldmVsRE9XTi5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2sgPSBvcHRpb25zXG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcigncHV0KCkgcmVxdWlyZXMgYSBjYWxsYmFjayBhcmd1bWVudCcpXG4gIH1cblxuICB2YXIgZXJyID0gdGhpcy5fY2hlY2tLZXkoa2V5KSB8fCB0aGlzLl9jaGVja1ZhbHVlKHZhbHVlKVxuICBpZiAoZXJyKSByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgZXJyKVxuXG4gIGtleSA9IHRoaXMuX3NlcmlhbGl6ZUtleShrZXkpXG4gIHZhbHVlID0gdGhpcy5fc2VyaWFsaXplVmFsdWUodmFsdWUpXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSBvcHRpb25zID0ge31cblxuICB0aGlzLl9wdXQoa2V5LCB2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spXG59XG5cbkFic3RyYWN0TGV2ZWxET1dOLnByb3RvdHlwZS5fcHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spXG59XG5cbkFic3RyYWN0TGV2ZWxET1dOLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrID0gb3B0aW9uc1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlbCgpIHJlcXVpcmVzIGEgY2FsbGJhY2sgYXJndW1lbnQnKVxuICB9XG5cbiAgdmFyIGVyciA9IHRoaXMuX2NoZWNrS2V5KGtleSlcbiAgaWYgKGVycikgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIGVycilcblxuICBrZXkgPSB0aGlzLl9zZXJpYWxpemVLZXkoa2V5KVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbCkgb3B0aW9ucyA9IHt9XG5cbiAgdGhpcy5fZGVsKGtleSwgb3B0aW9ucywgY2FsbGJhY2spXG59XG5cbkFic3RyYWN0TGV2ZWxET1dOLnByb3RvdHlwZS5fZGVsID0gZnVuY3Rpb24gKGtleSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaylcbn1cblxuQWJzdHJhY3RMZXZlbERPV04ucHJvdG90eXBlLmJhdGNoID0gZnVuY3Rpb24gKGFycmF5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9jaGFpbmVkQmF0Y2goKVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2sgPSBvcHRpb25zXG5cbiAgaWYgKHR5cGVvZiBhcnJheSA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2sgPSBhcnJheVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhdGNoKGFycmF5KSByZXF1aXJlcyBhIGNhbGxiYWNrIGFyZ3VtZW50JylcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgbmV3IEVycm9yKCdiYXRjaChhcnJheSkgcmVxdWlyZXMgYW4gYXJyYXkgYXJndW1lbnQnKSlcbiAgfVxuXG4gIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaylcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbCkgb3B0aW9ucyA9IHt9XG5cbiAgdmFyIHNlcmlhbGl6ZWQgPSBuZXcgQXJyYXkoYXJyYXkubGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIGFycmF5W2ldICE9PSAnb2JqZWN0JyB8fCBhcnJheVtpXSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBFcnJvcignYmF0Y2goYXJyYXkpIGVsZW1lbnQgbXVzdCBiZSBhbiBvYmplY3QgYW5kIG5vdCBgbnVsbGAnKSlcbiAgICB9XG5cbiAgICB2YXIgZSA9IHh0ZW5kKGFycmF5W2ldKVxuXG4gICAgaWYgKGUudHlwZSAhPT0gJ3B1dCcgJiYgZS50eXBlICE9PSAnZGVsJykge1xuICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBFcnJvcihcImB0eXBlYCBtdXN0IGJlICdwdXQnIG9yICdkZWwnXCIpKVxuICAgIH1cblxuICAgIHZhciBlcnIgPSB0aGlzLl9jaGVja0tleShlLmtleSlcbiAgICBpZiAoZXJyKSByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgZXJyKVxuXG4gICAgZS5rZXkgPSB0aGlzLl9zZXJpYWxpemVLZXkoZS5rZXkpXG5cbiAgICBpZiAoZS50eXBlID09PSAncHV0Jykge1xuICAgICAgdmFyIHZhbHVlRXJyID0gdGhpcy5fY2hlY2tWYWx1ZShlLnZhbHVlKVxuICAgICAgaWYgKHZhbHVlRXJyKSByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgdmFsdWVFcnIpXG5cbiAgICAgIGUudmFsdWUgPSB0aGlzLl9zZXJpYWxpemVWYWx1ZShlLnZhbHVlKVxuICAgIH1cblxuICAgIHNlcmlhbGl6ZWRbaV0gPSBlXG4gIH1cblxuICB0aGlzLl9iYXRjaChzZXJpYWxpemVkLCBvcHRpb25zLCBjYWxsYmFjaylcbn1cblxuQWJzdHJhY3RMZXZlbERPV04ucHJvdG90eXBlLl9iYXRjaCA9IGZ1bmN0aW9uIChhcnJheSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaylcbn1cblxuQWJzdHJhY3RMZXZlbERPV04ucHJvdG90eXBlLl9zZXR1cEl0ZXJhdG9yT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBjbGVhblJhbmdlT3B0aW9ucyh0aGlzLCBvcHRpb25zKVxuXG4gIG9wdGlvbnMucmV2ZXJzZSA9ICEhb3B0aW9ucy5yZXZlcnNlXG4gIG9wdGlvbnMua2V5cyA9IG9wdGlvbnMua2V5cyAhPT0gZmFsc2VcbiAgb3B0aW9ucy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcyAhPT0gZmFsc2VcbiAgb3B0aW9ucy5saW1pdCA9ICdsaW1pdCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMubGltaXQgOiAtMVxuICBvcHRpb25zLmtleUFzQnVmZmVyID0gb3B0aW9ucy5rZXlBc0J1ZmZlciAhPT0gZmFsc2VcbiAgb3B0aW9ucy52YWx1ZUFzQnVmZmVyID0gb3B0aW9ucy52YWx1ZUFzQnVmZmVyICE9PSBmYWxzZVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIGNsZWFuUmFuZ2VPcHRpb25zIChkYiwgb3B0aW9ucykge1xuICB2YXIgcmVzdWx0ID0ge31cblxuICBmb3IgKHZhciBrIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgaykpIGNvbnRpbnVlXG5cbiAgICB2YXIgb3B0ID0gb3B0aW9uc1trXVxuXG4gICAgaWYgKGlzUmFuZ2VPcHRpb24oaykpIHtcbiAgICAgIC8vIE5vdGUgdGhhdCB3ZSBkb24ndCByZWplY3QgbnVsbGlzaCBhbmQgZW1wdHkgb3B0aW9ucyBoZXJlLiBXaGlsZVxuICAgICAgLy8gdGhvc2UgdHlwZXMgYXJlIGludmFsaWQgYXMga2V5cywgdGhleSBhcmUgdmFsaWQgYXMgcmFuZ2Ugb3B0aW9ucy5cbiAgICAgIG9wdCA9IGRiLl9zZXJpYWxpemVLZXkob3B0KVxuICAgIH1cblxuICAgIHJlc3VsdFtrXSA9IG9wdFxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBpc1JhbmdlT3B0aW9uIChrKSB7XG4gIHJldHVybiByYW5nZU9wdGlvbnMuaW5kZXhPZihrKSAhPT0gLTFcbn1cblxuQWJzdHJhY3RMZXZlbERPV04ucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSBvcHRpb25zID0ge31cbiAgb3B0aW9ucyA9IHRoaXMuX3NldHVwSXRlcmF0b3JPcHRpb25zKG9wdGlvbnMpXG4gIHJldHVybiB0aGlzLl9pdGVyYXRvcihvcHRpb25zKVxufVxuXG5BYnN0cmFjdExldmVsRE9XTi5wcm90b3R5cGUuX2l0ZXJhdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBBYnN0cmFjdEl0ZXJhdG9yKHRoaXMpXG59XG5cbkFic3RyYWN0TGV2ZWxET1dOLnByb3RvdHlwZS5fY2hhaW5lZEJhdGNoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IEFic3RyYWN0Q2hhaW5lZEJhdGNoKHRoaXMpXG59XG5cbkFic3RyYWN0TGV2ZWxET1dOLnByb3RvdHlwZS5fc2VyaWFsaXplS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5XG59XG5cbkFic3RyYWN0TGV2ZWxET1dOLnByb3RvdHlwZS5fc2VyaWFsaXplVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlXG59XG5cbkFic3RyYWN0TGV2ZWxET1dOLnByb3RvdHlwZS5fY2hlY2tLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IG51bGwgfHwga2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdrZXkgY2Fubm90IGJlIGBudWxsYCBvciBgdW5kZWZpbmVkYCcpXG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGtleSkgJiYga2V5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ2tleSBjYW5ub3QgYmUgYW4gZW1wdHkgQnVmZmVyJylcbiAgfSBlbHNlIGlmIChrZXkgPT09ICcnKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcigna2V5IGNhbm5vdCBiZSBhbiBlbXB0eSBTdHJpbmcnKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSAmJiBrZXkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcigna2V5IGNhbm5vdCBiZSBhbiBlbXB0eSBBcnJheScpXG4gIH1cbn1cblxuQWJzdHJhY3RMZXZlbERPV04ucHJvdG90eXBlLl9jaGVja1ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcigndmFsdWUgY2Fubm90IGJlIGBudWxsYCBvciBgdW5kZWZpbmVkYCcpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdExldmVsRE9XTlxuIiwiLyoqXG4gKiBDb252ZXJ0IGEgdHlwZWQgYXJyYXkgdG8gYSBCdWZmZXIgd2l0aG91dCBhIGNvcHlcbiAqXG4gKiBBdXRob3I6ICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogTGljZW5zZTogIE1JVFxuICpcbiAqIGBucG0gaW5zdGFsbCB0eXBlZGFycmF5LXRvLWJ1ZmZlcmBcbiAqL1xuXG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWRhcnJheScpLnN0cmljdFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHR5cGVkYXJyYXlUb0J1ZmZlciAoYXJyKSB7XG4gIGlmIChpc1R5cGVkQXJyYXkoYXJyKSkge1xuICAgIC8vIFRvIGF2b2lkIGEgY29weSwgdXNlIHRoZSB0eXBlZCBhcnJheSdzIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIgdG8gYmFjayBuZXcgQnVmZmVyXG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5mcm9tKGFyci5idWZmZXIpXG4gICAgaWYgKGFyci5ieXRlTGVuZ3RoICE9PSBhcnIuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIC8vIFJlc3BlY3QgdGhlIFwidmlld1wiLCBpLmUuIGJ5dGVPZmZzZXQgYW5kIGJ5dGVMZW5ndGgsIHdpdGhvdXQgZG9pbmcgYSBjb3B5XG4gICAgICBidWYgPSBidWYuc2xpY2UoYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlT2Zmc2V0ICsgYXJyLmJ5dGVMZW5ndGgpXG4gICAgfVxuICAgIHJldHVybiBidWZcbiAgfSBlbHNlIHtcbiAgICAvLyBQYXNzIHRocm91Z2ggYWxsIG90aGVyIHR5cGVzIHRvIGBCdWZmZXIuZnJvbWBcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdHlwZXMgPSBbXG4gIHJlcXVpcmUoJy4vbmV4dFRpY2snKSxcbiAgcmVxdWlyZSgnLi9tdXRhdGlvbi5qcycpLFxuICByZXF1aXJlKCcuL21lc3NhZ2VDaGFubmVsJyksXG4gIHJlcXVpcmUoJy4vc3RhdGVDaGFuZ2UnKSxcbiAgcmVxdWlyZSgnLi90aW1lb3V0Jylcbl07XG52YXIgZHJhaW5pbmc7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIHNjaGVkdWxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgfVxuICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgbmV4dFRpY2soKTtcbiAgfVxufVxuXG4vL25hbWVkIG5leHRUaWNrIGZvciBsZXNzIGNvbmZ1c2luZyBzdGFjayB0cmFjZXNcbmZ1bmN0aW9uIG5leHRUaWNrKCkge1xuICBpZiAoZHJhaW5pbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2NoZWR1bGVkID0gZmFsc2U7XG4gIGRyYWluaW5nID0gdHJ1ZTtcbiAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gIHdoaWxlIChsZW4pIHtcbiAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IFtdO1xuICAgIHdoaWxlIChjdXJyZW50UXVldWUgJiYgKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgfVxuICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIH1cbiAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgcXVldWVJbmRleCA9IC0xO1xuICBkcmFpbmluZyA9IGZhbHNlO1xuICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG52YXIgc2NoZWR1bGVEcmFpbjtcbnZhciBpID0gLTE7XG52YXIgbGVuID0gdHlwZXMubGVuZ3RoO1xud2hpbGUgKCsraSA8IGxlbikge1xuICBpZiAodHlwZXNbaV0gJiYgdHlwZXNbaV0udGVzdCAmJiB0eXBlc1tpXS50ZXN0KCkpIHtcbiAgICBzY2hlZHVsZURyYWluID0gdHlwZXNbaV0uaW5zdGFsbChuZXh0VGljayk7XG4gICAgYnJlYWs7XG4gIH1cbn1cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICB0aGlzLmZ1biA9IGZ1bjtcbiAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZnVuID0gdGhpcy5mdW47XG4gIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gIHN3aXRjaCAoYXJyYXkubGVuZ3RoKSB7XG4gIGNhc2UgMDpcbiAgICByZXR1cm4gZnVuKCk7XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gZnVuKGFycmF5WzBdKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBmdW4oYXJyYXlbMF0sIGFycmF5WzFdKTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBmdW4oYXJyYXlbMF0sIGFycmF5WzFdLCBhcnJheVsyXSk7XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIGZ1bi5hcHBseShudWxsLCBhcnJheSk7XG4gIH1cblxufTtcbm1vZHVsZS5leHBvcnRzID0gaW1tZWRpYXRlO1xuZnVuY3Rpb24gaW1tZWRpYXRlKHRhc2spIHtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICB9XG4gIHF1ZXVlLnB1c2gobmV3IEl0ZW0odGFzaywgYXJncykpO1xuICBpZiAoIXNjaGVkdWxlZCAmJiAhZHJhaW5pbmcpIHtcbiAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgIHNjaGVkdWxlRHJhaW4oKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lY1xuY29uc3QgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2ZXJpZnk6IGFzeW5jIChzaWduYXR1cmUsIHB1YmxpY0tleSwgZGF0YSkgPT4ge1xuICAgIGlmICghc2lnbmF0dXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZSBnaXZlbicpXG4gICAgfVxuICAgIGlmICghcHVibGljS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHB1YmxpY0tleSB3YXMgdW5kZWZpbmVkJylcbiAgICB9XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIGlucHV0IGRhdGEgd2FzIHVuZGVmaW5lZCcpXG4gICAgfVxuICAgIGxldCByZXMgPSBmYWxzZVxuICAgIGNvbnN0IGtleSA9IGVjLmtleVBhaXIoe1xuICAgICAgcHViOiBwdWJsaWNLZXksXG4gICAgICBwdWJFbmM6ICdoZXgnXG4gICAgfSlcbiAgICB0cnkge1xuICAgICAgcmVzID0gZWMudmVyaWZ5KGRhdGEsIHNpZ25hdHVyZSwga2V5KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIENhdGNoZXMgJ0Vycm9yOiBTaWduYXR1cmUgd2l0aG91dCByIG9yIHMnXG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2xpYnAycC1jcnlwdG8nKVxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXIvJykuQnVmZmVyXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2ZXJpZnk6IGFzeW5jIChzaWduYXR1cmUsIHB1YmxpY0tleSwgZGF0YSkgPT4ge1xuICAgIGlmICghc2lnbmF0dXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZSBnaXZlbicpXG4gICAgfVxuICAgIGlmICghcHVibGljS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHB1YmxpY0tleSB3YXMgdW5kZWZpbmVkJylcbiAgICB9XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIGlucHV0IGRhdGEgd2FzIHVuZGVmaW5lZCcpXG4gICAgfVxuXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKVxuICAgIH1cblxuICAgIGNvbnN0IGlzVmFsaWQgPSAoa2V5LCBtc2csIHNpZykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAga2V5LnZlcmlmeShtc2csIHNpZywgKGVyciwgdmFsaWQpID0+IHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICByZXNvbHZlKHZhbGlkKVxuICAgICAgICB9XG4gICAgICAgIHJlamVjdCh2YWxpZClcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGxldCByZXMgPSBmYWxzZVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwdWJLZXkgPSBjcnlwdG8ua2V5cy5zdXBwb3J0ZWRLZXlzLnNlY3AyNTZrMS51bm1hcnNoYWxTZWNwMjU2azFQdWJsaWNLZXkoQnVmZmVyLmZyb20ocHVibGljS2V5LCAnaGV4JykpXG4gICAgICByZXMgPSBhd2FpdCBpc1ZhbGlkKHB1YktleSwgZGF0YSwgQnVmZmVyLmZyb20oc2lnbmF0dXJlLCAnaGV4JykpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gQ2F0Y2ggZXJyb3I6IHNpZyBsZW5ndGggd3JvbmdcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXMpXG4gIH1cbn1cbiIsImV4cG9ydHMuZ2V0Q2FsbGJhY2sgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucyA6IGNhbGxiYWNrXG59XG5cbmV4cG9ydHMuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCA/IG9wdGlvbnMgOiB7fVxufVxuIiwiZnVuY3Rpb24gcHJvbWlzaWZ5ICgpIHtcbiAgdmFyIGNhbGxiYWNrXG4gIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2sgKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpXG4gICAgICBlbHNlIHJlc29sdmUodmFsdWUpXG4gICAgfVxuICB9KVxuICBjYWxsYmFjay5wcm9taXNlID0gcHJvbWlzZVxuICByZXR1cm4gY2FsbGJhY2tcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9taXNpZnlcbiIsInZhciBXcml0ZUVycm9yID0gcmVxdWlyZSgnbGV2ZWwtZXJyb3JzJykuV3JpdGVFcnJvclxudmFyIHByb21pc2lmeSA9IHJlcXVpcmUoJy4vcHJvbWlzaWZ5JylcbnZhciBnZXRDYWxsYmFjayA9IHJlcXVpcmUoJy4vY29tbW9uJykuZ2V0Q2FsbGJhY2tcbnZhciBnZXRPcHRpb25zID0gcmVxdWlyZSgnLi9jb21tb24nKS5nZXRPcHRpb25zXG5cbmZ1bmN0aW9uIEJhdGNoIChsZXZlbHVwKSB7XG4gIHRoaXMuX2xldmVsdXAgPSBsZXZlbHVwXG4gIHRoaXMuYmF0Y2ggPSBsZXZlbHVwLmRiLmJhdGNoKClcbiAgdGhpcy5vcHMgPSBbXVxuICB0aGlzLmxlbmd0aCA9IDBcbn1cblxuQmF0Y2gucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgdGhpcy5iYXRjaC5wdXQoa2V5LCB2YWx1ZSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBXcml0ZUVycm9yKGUpXG4gIH1cblxuICB0aGlzLm9wcy5wdXNoKHsgdHlwZTogJ3B1dCcsIGtleToga2V5LCB2YWx1ZTogdmFsdWUgfSlcbiAgdGhpcy5sZW5ndGgrK1xuXG4gIHJldHVybiB0aGlzXG59XG5cbkJhdGNoLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5iYXRjaC5kZWwoa2V5KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgV3JpdGVFcnJvcihlcnIpXG4gIH1cblxuICB0aGlzLm9wcy5wdXNoKHsgdHlwZTogJ2RlbCcsIGtleToga2V5IH0pXG4gIHRoaXMubGVuZ3RoKytcblxuICByZXR1cm4gdGhpc1xufVxuXG5CYXRjaC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgdGhpcy5iYXRjaC5jbGVhcigpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBXcml0ZUVycm9yKGVycilcbiAgfVxuXG4gIHRoaXMub3BzID0gW11cbiAgdGhpcy5sZW5ndGggPSAwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQmF0Y2gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBsZXZlbHVwID0gdGhpcy5fbGV2ZWx1cFxuICB2YXIgb3BzID0gdGhpcy5vcHNcbiAgdmFyIHByb21pc2VcblxuICBjYWxsYmFjayA9IGdldENhbGxiYWNrKG9wdGlvbnMsIGNhbGxiYWNrKVxuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IHByb21pc2lmeSgpXG4gICAgcHJvbWlzZSA9IGNhbGxiYWNrLnByb21pc2VcbiAgfVxuXG4gIG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpXG5cbiAgdHJ5IHtcbiAgICB0aGlzLmJhdGNoLndyaXRlKG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKG5ldyBXcml0ZUVycm9yKGVycikpIH1cbiAgICAgIGxldmVsdXAuZW1pdCgnYmF0Y2gnLCBvcHMpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IFdyaXRlRXJyb3IoZXJyKVxuICB9XG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYXRjaFxuIiwidmFyIEFic3RyYWN0TGV2ZWxET1dOID0gcmVxdWlyZSgnYWJzdHJhY3QtbGV2ZWxkb3duJykuQWJzdHJhY3RMZXZlbERPV05cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBEZWZlcnJlZEl0ZXJhdG9yID0gcmVxdWlyZSgnLi9kZWZlcnJlZC1pdGVyYXRvcicpXG52YXIgZGVmZXJyYWJsZXMgPSAncHV0IGdldCBkZWwgYmF0Y2gnLnNwbGl0KCcgJylcblxuZnVuY3Rpb24gRGVmZXJyZWRMZXZlbERPV04gKGRiKSB7XG4gIEFic3RyYWN0TGV2ZWxET1dOLmNhbGwodGhpcywgJycpXG4gIHRoaXMuX2RiID0gZGJcbiAgdGhpcy5fb3BlcmF0aW9ucyA9IFtdXG4gIHRoaXMuX2l0ZXJhdG9ycyA9IFtdXG4gIGNsb3NlZCh0aGlzKVxufVxuXG5pbmhlcml0cyhEZWZlcnJlZExldmVsRE9XTiwgQWJzdHJhY3RMZXZlbERPV04pXG5cbkRlZmVycmVkTGV2ZWxET1dOLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB0aGlzLl9kYi5vcGVuKG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuXG4gICAgc2VsZi5fb3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkge1xuICAgICAgc2VsZi5fZGJbb3AubWV0aG9kXS5hcHBseShzZWxmLl9kYiwgb3AuYXJncylcbiAgICB9KVxuICAgIHNlbGYuX29wZXJhdGlvbnMgPSBbXVxuICAgIHNlbGYuX2l0ZXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChpdCkge1xuICAgICAgaXQuc2V0RGIoc2VsZi5fZGIpXG4gICAgfSlcbiAgICBzZWxmLl9pdGVyYXRvcnMgPSBbXVxuICAgIG9wZW4oc2VsZilcbiAgICBjYWxsYmFjaygpXG4gIH0pXG59XG5cbkRlZmVycmVkTGV2ZWxET1dOLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdGhpcy5fZGIuY2xvc2UoZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgY2xvc2VkKHNlbGYpXG4gICAgY2FsbGJhY2soKVxuICB9KVxufVxuXG5mdW5jdGlvbiBvcGVuIChzZWxmKSB7XG4gIGRlZmVycmFibGVzLmNvbmNhdCgnaXRlcmF0b3InKS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgc2VsZlsnXycgKyBtXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYlttXS5hcHBseSh0aGlzLl9kYiwgYXJndW1lbnRzKVxuICAgIH1cbiAgfSlcbiAgaWYgKHNlbGYuX2RiLmFwcHJveGltYXRlU2l6ZSkge1xuICAgIHNlbGYuYXBwcm94aW1hdGVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RiLmFwcHJveGltYXRlU2l6ZS5hcHBseSh0aGlzLl9kYiwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9zZWQgKHNlbGYpIHtcbiAgZGVmZXJyYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIHNlbGZbJ18nICsgbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vcGVyYXRpb25zLnB1c2goeyBtZXRob2Q6IG0sIGFyZ3M6IGFyZ3VtZW50cyB9KVxuICAgIH1cbiAgfSlcbiAgaWYgKHR5cGVvZiBzZWxmLl9kYi5hcHByb3hpbWF0ZVNpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzZWxmLmFwcHJveGltYXRlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX29wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgIG1ldGhvZDogJ2FwcHJveGltYXRlU2l6ZScsXG4gICAgICAgIGFyZ3M6IGFyZ3VtZW50c1xuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgc2VsZi5faXRlcmF0b3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBpdCA9IG5ldyBEZWZlcnJlZEl0ZXJhdG9yKG9wdGlvbnMpXG4gICAgdGhpcy5faXRlcmF0b3JzLnB1c2goaXQpXG4gICAgcmV0dXJuIGl0XG4gIH1cbn1cblxuRGVmZXJyZWRMZXZlbERPV04ucHJvdG90eXBlLl9zZXJpYWxpemVLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlcbn1cblxuRGVmZXJyZWRMZXZlbERPV04ucHJvdG90eXBlLl9zZXJpYWxpemVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEZWZlcnJlZExldmVsRE9XTlxubW9kdWxlLmV4cG9ydHMuRGVmZXJyZWRJdGVyYXRvciA9IERlZmVycmVkSXRlcmF0b3JcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IExldmVsVVAgY29udHJpYnV0b3JzXG4gKiBTZWUgbGlzdCBhdCA8aHR0cHM6Ly9naXRodWIuY29tL3J2YWdnL25vZGUtbGV2ZWx1cCNjb250cmlidXRpbmc+XG4gKiBNSVQgTGljZW5zZVxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9ydmFnZy9ub2RlLWxldmVsdXAvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZD5cbiAqL1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCdlcnJubycpLmNyZWF0ZVxudmFyIExldmVsVVBFcnJvciA9IGNyZWF0ZUVycm9yKCdMZXZlbFVQRXJyb3InKVxudmFyIE5vdEZvdW5kRXJyb3IgPSBjcmVhdGVFcnJvcignTm90Rm91bmRFcnJvcicsIExldmVsVVBFcnJvcilcblxuTm90Rm91bmRFcnJvci5wcm90b3R5cGUubm90Rm91bmQgPSB0cnVlXG5Ob3RGb3VuZEVycm9yLnByb3RvdHlwZS5zdGF0dXMgPSA0MDRcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIExldmVsVVBFcnJvcjogTGV2ZWxVUEVycm9yLFxuICBJbml0aWFsaXphdGlvbkVycm9yOiBjcmVhdGVFcnJvcignSW5pdGlhbGl6YXRpb25FcnJvcicsIExldmVsVVBFcnJvciksXG4gIE9wZW5FcnJvcjogY3JlYXRlRXJyb3IoJ09wZW5FcnJvcicsIExldmVsVVBFcnJvciksXG4gIFJlYWRFcnJvcjogY3JlYXRlRXJyb3IoJ1JlYWRFcnJvcicsIExldmVsVVBFcnJvciksXG4gIFdyaXRlRXJyb3I6IGNyZWF0ZUVycm9yKCdXcml0ZUVycm9yJywgTGV2ZWxVUEVycm9yKSxcbiAgTm90Rm91bmRFcnJvcjogTm90Rm91bmRFcnJvcixcbiAgRW5jb2RpbmdFcnJvcjogY3JlYXRlRXJyb3IoJ0VuY29kaW5nRXJyb3InLCBMZXZlbFVQRXJyb3IpXG59XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5SZWFkYWJsZVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkU3RyZWFtXG5pbmhlcml0cyhSZWFkU3RyZWFtLCBSZWFkYWJsZSlcblxuZnVuY3Rpb24gUmVhZFN0cmVhbSAoaXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pKSByZXR1cm4gbmV3IFJlYWRTdHJlYW0oaXRlcmF0b3IsIG9wdGlvbnMpXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICBvYmplY3RNb2RlOiB0cnVlXG4gIH0pKVxuICB0aGlzLl9pdGVyYXRvciA9IGl0ZXJhdG9yXG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gIHRoaXMub24oJ2VuZCcsIHRoaXMuZGVzdHJveS5iaW5kKHRoaXMsIG51bGwsIG51bGwpKVxufVxuXG5SZWFkU3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9uc1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHRoaXMuX2l0ZXJhdG9yLm5leHQoZnVuY3Rpb24gKGVyciwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKGVycikgcmV0dXJuIHNlbGYuZGVzdHJveShlcnIpXG5cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VsZi5wdXNoKG51bGwpXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmtleXMgIT09IGZhbHNlICYmIG9wdGlvbnMudmFsdWVzID09PSBmYWxzZSkge1xuICAgICAgc2VsZi5wdXNoKGtleSlcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMua2V5cyA9PT0gZmFsc2UgJiYgb3B0aW9ucy52YWx1ZXMgIT09IGZhbHNlKSB7XG4gICAgICBzZWxmLnB1c2godmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYucHVzaCh7IGtleToga2V5LCB2YWx1ZTogdmFsdWUgfSlcbiAgICB9XG4gIH0pXG59XG5cblJlYWRTdHJlYW0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2FsbGJhY2spIHtcbiAgdGhpcy5faXRlcmF0b3IuZW5kKGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2FsbGJhY2soZXJyIHx8IGVycjIpXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkcmFpbiAob3AsIGRvbmUpIHtcbiAgdmFyIHJlYWQsIGFib3J0XG5cbiAgZnVuY3Rpb24gc2luayAoX3JlYWQpIHtcbiAgICByZWFkID0gX3JlYWRcbiAgICBpZihhYm9ydCkgcmV0dXJuIHNpbmsuYWJvcnQoKVxuICAgIC8vdGhpcyBmdW5jdGlvbiBpcyBtdWNoIHNpbXBsZXIgdG8gd3JpdGUgaWYgeW91XG4gICAgLy9qdXN0IHVzZSByZWN1cnNpb24sIGJ1dCBieSB1c2luZyBhIHdoaWxlIGxvb3BcbiAgICAvL3dlIGRvIG5vdCBibG93IHRoZSBzdGFjayBpZiB0aGUgc3RyZWFtIGhhcHBlbnMgdG8gYmUgc3luYy5cbiAgICA7KGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBsb29wID0gdHJ1ZSwgY2JlZCA9IGZhbHNlXG4gICAgICAgIHdoaWxlKGxvb3ApIHtcbiAgICAgICAgICBjYmVkID0gZmFsc2VcbiAgICAgICAgICByZWFkKG51bGwsIGZ1bmN0aW9uIChlbmQsIGRhdGEpIHtcbiAgICAgICAgICAgIGNiZWQgPSB0cnVlXG4gICAgICAgICAgICBpZihlbmQgPSBlbmQgfHwgYWJvcnQpIHtcbiAgICAgICAgICAgICAgbG9vcCA9IGZhbHNlXG4gICAgICAgICAgICAgIGlmKGRvbmUpIGRvbmUoZW5kID09PSB0cnVlID8gbnVsbCA6IGVuZClcbiAgICAgICAgICAgICAgZWxzZSBpZihlbmQgJiYgZW5kICE9PSB0cnVlKVxuICAgICAgICAgICAgICAgIHRocm93IGVuZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihvcCAmJiBmYWxzZSA9PT0gb3AoZGF0YSkgfHwgYWJvcnQpIHtcbiAgICAgICAgICAgICAgbG9vcCA9IGZhbHNlXG4gICAgICAgICAgICAgIHJlYWQoYWJvcnQgfHwgdHJ1ZSwgZG9uZSB8fCBmdW5jdGlvbiAoKSB7fSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoIWxvb3Ape1xuICAgICAgICAgICAgICBuZXh0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIGlmKCFjYmVkKSB7XG4gICAgICAgICAgICBsb29wID0gZmFsc2VcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkoKVxuICB9XG5cbiAgc2luay5hYm9ydCA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gICAgaWYoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZXJyKVxuICAgICAgY2IgPSBlcnIsIGVyciA9IHRydWVcbiAgICBhYm9ydCA9IGVyciB8fCB0cnVlXG4gICAgaWYocmVhZCkgcmV0dXJuIHJlYWQoYWJvcnQsIGNiIHx8IGZ1bmN0aW9uICgpIHt9KVxuICB9XG5cbiAgcmV0dXJuIHNpbmtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9lYWNoT2ZMaW1pdCA9IHJlcXVpcmUoJy4vZWFjaE9mTGltaXQnKTtcblxudmFyIF9lYWNoT2ZMaW1pdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoT2ZMaW1pdCk7XG5cbnZhciBfZG9MaW1pdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvZG9MaW1pdCcpO1xuXG52YXIgX2RvTGltaXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9MaW1pdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BlYWNoT2ZgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZWFjaE9mU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5lYWNoT2Zde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9XG4gKiBAYWxpYXMgZm9yRWFjaE9mU2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfZG9MaW1pdDIuZGVmYXVsdCkoX2VhY2hPZkxpbWl0Mi5kZWZhdWx0LCAxKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGlzUGxhaW5PYmogPSByZXF1aXJlKCdpcy1wbGFpbi1vYmonKTtcblxubW9kdWxlLmV4cG9ydHMgPSAob2JqLCBvcHRzKSA9PiB7XG5cdGlmICghaXNQbGFpbk9iaihvYmopKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBwbGFpbiBvYmplY3QnKTtcblx0fVxuXG5cdG9wdHMgPSBvcHRzIHx8IHt9O1xuXG5cdC8vIERFUFJFQ0FURURcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignU3BlY2lmeSB0aGUgY29tcGFyZSBmdW5jdGlvbiBhcyBhbiBvcHRpb24gaW5zdGVhZCcpO1xuXHR9XG5cblx0Y29uc3QgZGVlcCA9IG9wdHMuZGVlcDtcblx0Y29uc3Qgc2VlbklucHV0ID0gW107XG5cdGNvbnN0IHNlZW5PdXRwdXQgPSBbXTtcblxuXHRjb25zdCBzb3J0S2V5cyA9IHggPT4ge1xuXHRcdGNvbnN0IHNlZW5JbmRleCA9IHNlZW5JbnB1dC5pbmRleE9mKHgpO1xuXG5cdFx0aWYgKHNlZW5JbmRleCAhPT0gLTEpIHtcblx0XHRcdHJldHVybiBzZWVuT3V0cHV0W3NlZW5JbmRleF07XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmV0ID0ge307XG5cdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHgpLnNvcnQob3B0cy5jb21wYXJlKTtcblxuXHRcdHNlZW5JbnB1dC5wdXNoKHgpO1xuXHRcdHNlZW5PdXRwdXQucHVzaChyZXQpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0Y29uc3QgdmFsID0geFtrZXldO1xuXG5cdFx0XHRpZiAoZGVlcCAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcblx0XHRcdFx0Y29uc3QgcmV0QXJyID0gW107XG5cblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCB2YWwubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRyZXRBcnJbal0gPSBpc1BsYWluT2JqKHZhbFtqXSkgPyBzb3J0S2V5cyh2YWxbal0pIDogdmFsW2pdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0W2tleV0gPSByZXRBcnI7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXRba2V5XSA9IGRlZXAgJiYgaXNQbGFpbk9iaih2YWwpID8gc29ydEtleXModmFsKSA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xuXG5cdHJldHVybiBzb3J0S2V5cyhvYmopO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gc2V0O1xuXG4vKlxuICB2YXIgb2JqMSA9IHt9O1xuICBzZXQob2JqMSwgJ2EuYWEuYWFhJywgNCk7IC8vIHRydWVcbiAgb2JqMTsgLy8ge2E6IHthYToge2FhYTogNH19fVxuXG4gIHZhciBvYmoyID0ge307XG4gIHNldChvYmoyLCBbJ2EnLCAnYWEnLCAnYWFhJ10sIDQpOyAvLyB0cnVlXG4gIG9iajI7IC8vIHthOiB7YWE6IHthYWE6IDR9fX1cblxuICB2YXIgb2JqMyA9IHthOiB7YWE6IHthYWE6IDJ9fX07XG4gIHNldChvYmozLCAnYS5hYS5hYWEnLCAzKTsgLy8gdHJ1ZVxuICBvYmozOyAvLyB7YToge2FhOiB7YWFhOiAzfX19XG5cbiAgLy8gZG9uJ3QgY2xvYmJlciBleGlzdGluZ1xuICB2YXIgb2JqNCA9IHthOiB7YWE6IHthYWE6IDJ9fX07XG4gIHNldChvYmo0LCAnYS5hYScsIHtiYmI6IDd9KTsgLy8gZmFsc2VcblxuICBjb25zdCBvYmo1ID0ge2E6IHt9fTtcbiAgY29uc3Qgc3ltID0gU3ltYm9sKCk7XG4gIHNldChvYmo1LmEsIHN5bSwgNyk7IC8vIHRydWVcbiAgb2JqNTsgLy8ge2E6IHtTeW1ib2woKTogN319XG4qL1xuXG5mdW5jdGlvbiBzZXQob2JqLCBwcm9wc0FyZywgdmFsdWUpIHtcbiAgdmFyIHByb3BzLCBsYXN0UHJvcDtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHNBcmcpKSB7XG4gICAgcHJvcHMgPSBwcm9wc0FyZy5zbGljZSgwKTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3BzQXJnID09ICdzdHJpbmcnKSB7XG4gICAgcHJvcHMgPSBwcm9wc0FyZy5zcGxpdCgnLicpO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvcHNBcmcgPT0gJ3N5bWJvbCcpIHtcbiAgICBwcm9wcyA9IFtwcm9wc0FyZ107XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvcHMgYXJnIG11c3QgYmUgYW4gYXJyYXksIGEgc3RyaW5nIG9yIGEgc3ltYm9sJyk7XG4gIH1cbiAgbGFzdFByb3AgPSBwcm9wcy5wb3AoKTtcbiAgaWYgKCFsYXN0UHJvcCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwcm90b3R5cGVDaGVjayhsYXN0UHJvcCk7XG4gIHZhciB0aGlzUHJvcDtcbiAgd2hpbGUgKCh0aGlzUHJvcCA9IHByb3BzLnNoaWZ0KCkpKSB7XG4gICAgcHJvdG90eXBlQ2hlY2sodGhpc1Byb3ApO1xuICAgIGlmICh0eXBlb2Ygb2JqW3RoaXNQcm9wXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgb2JqW3RoaXNQcm9wXSA9IHt9O1xuICAgIH1cbiAgICBvYmogPSBvYmpbdGhpc1Byb3BdO1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgb2JqW2xhc3RQcm9wXSA9IHZhbHVlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcHJvdG90eXBlQ2hlY2socHJvcCkge1xuICBpZiAocHJvcCA9PT0gJ19fcHJvdG9fXycgfHwgcHJvcCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBwcm9wID09PSAncHJvdG90eXBlJykge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0dGluZyBvZiBwcm90b3R5cGUgdmFsdWVzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xuICB2YXIgX3dvcmtlciA9ICgwLCBfd3JhcEFzeW5jMi5kZWZhdWx0KSh3b3JrZXIpO1xuICByZXR1cm4gKDAsIF9xdWV1ZTIuZGVmYXVsdCkoZnVuY3Rpb24gKGl0ZW1zLCBjYikge1xuICAgIF93b3JrZXIoaXRlbXNbMF0sIGNiKTtcbiAgfSwgY29uY3VycmVuY3ksIDEpO1xufTtcblxudmFyIF9xdWV1ZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcXVldWUnKTtcblxudmFyIF9xdWV1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWV1ZSk7XG5cbnZhciBfd3JhcEFzeW5jID0gcmVxdWlyZSgnLi9pbnRlcm5hbC93cmFwQXN5bmMnKTtcblxudmFyIF93cmFwQXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd3JhcEFzeW5jKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKlxuICogQSBxdWV1ZSBvZiB0YXNrcyBmb3IgdGhlIHdvcmtlciBmdW5jdGlvbiB0byBjb21wbGV0ZS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFF1ZXVlT2JqZWN0XG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBsZW5ndGggLSBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIGl0ZW1zXG4gKiB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLmxlbmd0aCgpYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3RhcnRlZCAtIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IGFueVxuICogaXRlbXMgaGF2ZSBiZWVuIHB1c2hlZCBhbmQgcHJvY2Vzc2VkIGJ5IHRoZSBxdWV1ZS5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJ1bm5pbmcgLSBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIGl0ZW1zXG4gKiBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkLiBJbnZva2Ugd2l0aCBgcXVldWUucnVubmluZygpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHdvcmtlcnNMaXN0IC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGFycmF5IG9mIGl0ZW1zXG4gKiBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkLiBJbnZva2Ugd2l0aCBgcXVldWUud29ya2Vyc0xpc3QoKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpZGxlIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgZmFsc2UgaWYgdGhlcmUgYXJlIGl0ZW1zXG4gKiB3YWl0aW5nIG9yIGJlaW5nIHByb2Nlc3NlZCwgb3IgdHJ1ZSBpZiBub3QuIEludm9rZSB3aXRoIGBxdWV1ZS5pZGxlKClgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbmN1cnJlbmN5IC0gYW4gaW50ZWdlciBmb3IgZGV0ZXJtaW5pbmcgaG93IG1hbnkgYHdvcmtlcmBcbiAqIGZ1bmN0aW9ucyBzaG91bGQgYmUgcnVuIGluIHBhcmFsbGVsLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBjaGFuZ2VkIGFmdGVyIGFcbiAqIGBxdWV1ZWAgaXMgY3JlYXRlZCB0byBhbHRlciB0aGUgY29uY3VycmVuY3kgb24tdGhlLWZseS5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHB1c2ggLSBhZGQgYSBuZXcgdGFzayB0byB0aGUgYHF1ZXVlYC4gQ2FsbHMgYGNhbGxiYWNrYFxuICogb25jZSB0aGUgYHdvcmtlcmAgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcgdGhlIHRhc2suIEluc3RlYWQgb2YgYSBzaW5nbGUgdGFzayxcbiAqIGEgYHRhc2tzYCBhcnJheSBjYW4gYmUgc3VibWl0dGVkLiBUaGUgcmVzcGVjdGl2ZSBjYWxsYmFjayBpcyB1c2VkIGZvciBldmVyeVxuICogdGFzayBpbiB0aGUgbGlzdC4gSW52b2tlIHdpdGggYHF1ZXVlLnB1c2godGFzaywgW2NhbGxiYWNrXSlgLFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdW5zaGlmdCAtIGFkZCBhIG5ldyB0YXNrIHRvIHRoZSBmcm9udCBvZiB0aGUgYHF1ZXVlYC5cbiAqIEludm9rZSB3aXRoIGBxdWV1ZS51bnNoaWZ0KHRhc2ssIFtjYWxsYmFja10pYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJlbW92ZSAtIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBxdWV1ZSB0aGF0IG1hdGNoIGEgdGVzdFxuICogZnVuY3Rpb24uICBUaGUgdGVzdCBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBhbiBvYmplY3Qgd2l0aCBhIGBkYXRhYCBwcm9wZXJ0eSxcbiAqIGFuZCBhIGBwcmlvcml0eWAgcHJvcGVydHksIGlmIHRoaXMgaXMgYVxuICogW3ByaW9yaXR5UXVldWVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wcmlvcml0eVF1ZXVlfSBvYmplY3QuXG4gKiBJbnZva2VkIHdpdGggYHF1ZXVlLnJlbW92ZSh0ZXN0Rm4pYCwgd2hlcmUgYHRlc3RGbmAgaXMgb2YgdGhlIGZvcm1cbiAqIGBmdW5jdGlvbiAoe2RhdGEsIHByaW9yaXR5fSkge31gIGFuZCByZXR1cm5zIGEgQm9vbGVhbi5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHNhdHVyYXRlZCAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbnVtYmVyIG9mXG4gKiBydW5uaW5nIHdvcmtlcnMgaGl0cyB0aGUgYGNvbmN1cnJlbmN5YCBsaW1pdCwgYW5kIGZ1cnRoZXIgdGFza3Mgd2lsbCBiZVxuICogcXVldWVkLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdW5zYXR1cmF0ZWQgLSBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIG51bWJlclxuICogb2YgcnVubmluZyB3b3JrZXJzIGlzIGxlc3MgdGhhbiB0aGUgYGNvbmN1cnJlbmN5YCAmIGBidWZmZXJgIGxpbWl0cywgYW5kXG4gKiBmdXJ0aGVyIHRhc2tzIHdpbGwgbm90IGJlIHF1ZXVlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBidWZmZXIgLSBBIG1pbmltdW0gdGhyZXNob2xkIGJ1ZmZlciBpbiBvcmRlciB0byBzYXkgdGhhdFxuICogdGhlIGBxdWV1ZWAgaXMgYHVuc2F0dXJhdGVkYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVtcHR5IC0gYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBsYXN0IGl0ZW1cbiAqIGZyb20gdGhlIGBxdWV1ZWAgaXMgZ2l2ZW4gdG8gYSBgd29ya2VyYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRyYWluIC0gYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBsYXN0IGl0ZW1cbiAqIGZyb20gdGhlIGBxdWV1ZWAgaGFzIHJldHVybmVkIGZyb20gdGhlIGB3b3JrZXJgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZXJyb3IgLSBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSB0YXNrIGVycm9ycy5cbiAqIEhhcyB0aGUgc2lnbmF0dXJlIGBmdW5jdGlvbihlcnJvciwgdGFzaylgLlxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXVzZWQgLSBhIGJvb2xlYW4gZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIHF1ZXVlIGlzXG4gKiBpbiBhIHBhdXNlZCBzdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHBhdXNlIC0gYSBmdW5jdGlvbiB0aGF0IHBhdXNlcyB0aGUgcHJvY2Vzc2luZyBvZiB0YXNrc1xuICogdW50aWwgYHJlc3VtZSgpYCBpcyBjYWxsZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5wYXVzZSgpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJlc3VtZSAtIGEgZnVuY3Rpb24gdGhhdCByZXN1bWVzIHRoZSBwcm9jZXNzaW5nIG9mXG4gKiBxdWV1ZWQgdGFza3Mgd2hlbiB0aGUgcXVldWUgaXMgcGF1c2VkLiBJbnZva2Ugd2l0aCBgcXVldWUucmVzdW1lKClgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0ga2lsbCAtIGEgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZSBgZHJhaW5gIGNhbGxiYWNrIGFuZFxuICogZW1wdGllcyByZW1haW5pbmcgdGFza3MgZnJvbSB0aGUgcXVldWUgZm9yY2luZyBpdCB0byBnbyBpZGxlLiBObyBtb3JlIHRhc2tzXG4gKiBzaG91bGQgYmUgcHVzaGVkIHRvIHRoZSBxdWV1ZSBhZnRlciBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uIEludm9rZSB3aXRoIGBxdWV1ZS5raWxsKClgLlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIGBxdWV1ZWAgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBgY29uY3VycmVuY3lgLiBUYXNrcyBhZGRlZCB0byB0aGVcbiAqIGBxdWV1ZWAgYXJlIHByb2Nlc3NlZCBpbiBwYXJhbGxlbCAodXAgdG8gdGhlIGBjb25jdXJyZW5jeWAgbGltaXQpLiBJZiBhbGxcbiAqIGB3b3JrZXJgcyBhcmUgaW4gcHJvZ3Jlc3MsIHRoZSB0YXNrIGlzIHF1ZXVlZCB1bnRpbCBvbmUgYmVjb21lcyBhdmFpbGFibGUuXG4gKiBPbmNlIGEgYHdvcmtlcmAgY29tcGxldGVzIGEgYHRhc2tgLCB0aGF0IGB0YXNrYCdzIGNhbGxiYWNrIGlzIGNhbGxlZC5cbiAqXG4gKiBAbmFtZSBxdWV1ZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luYyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlZCB0YXNrLlxuICogSWYgeW91IHdhbnQgdG8gaGFuZGxlIGVycm9ycyBmcm9tIGFuIGluZGl2aWR1YWwgdGFzaywgcGFzcyBhIGNhbGxiYWNrIHRvXG4gKiBgcS5wdXNoKClgLiBJbnZva2VkIHdpdGggKHRhc2ssIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVuY3k9MV0gLSBBbiBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nIGhvdyBtYW55XG4gKiBgd29ya2VyYCBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gIElmIG9taXR0ZWQsIHRoZSBjb25jdXJyZW5jeVxuICogZGVmYXVsdHMgdG8gYDFgLiAgSWYgdGhlIGNvbmN1cnJlbmN5IGlzIGAwYCwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5RdWV1ZU9iamVjdH0gQSBxdWV1ZSBvYmplY3QgdG8gbWFuYWdlIHRoZSB0YXNrcy4gQ2FsbGJhY2tzIGNhblxuICogYXR0YWNoZWQgYXMgY2VydGFpbiBwcm9wZXJ0aWVzIHRvIGxpc3RlbiBmb3Igc3BlY2lmaWMgZXZlbnRzIGR1cmluZyB0aGVcbiAqIGxpZmVjeWNsZSBvZiB0aGUgcXVldWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGNyZWF0ZSBhIHF1ZXVlIG9iamVjdCB3aXRoIGNvbmN1cnJlbmN5IDJcbiAqIHZhciBxID0gYXN5bmMucXVldWUoZnVuY3Rpb24odGFzaywgY2FsbGJhY2spIHtcbiAqICAgICBjb25zb2xlLmxvZygnaGVsbG8gJyArIHRhc2submFtZSk7XG4gKiAgICAgY2FsbGJhY2soKTtcbiAqIH0sIDIpO1xuICpcbiAqIC8vIGFzc2lnbiBhIGNhbGxiYWNrXG4gKiBxLmRyYWluID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2FsbCBpdGVtcyBoYXZlIGJlZW4gcHJvY2Vzc2VkJyk7XG4gKiB9O1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zIHRvIHRoZSBxdWV1ZVxuICogcS5wdXNoKHtuYW1lOiAnZm9vJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpO1xuICogfSk7XG4gKiBxLnB1c2goe25hbWU6ICdiYXInfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICogfSk7XG4gKlxuICogLy8gYWRkIHNvbWUgaXRlbXMgdG8gdGhlIHF1ZXVlIChiYXRjaC13aXNlKVxuICogcS5wdXNoKFt7bmFtZTogJ2Jheid9LHtuYW1lOiAnYmF5J30se25hbWU6ICdiYXgnfV0sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGl0ZW0nKTtcbiAqIH0pO1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zIHRvIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcbiAqIHEudW5zaGlmdCh7bmFtZTogJ2Jhcid9LCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmFyJyk7XG4gKiB9KTtcbiAqLyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgY2hhcmFjdGVyIG1hcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldCBlLmcuIFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjdcIlxuICogQHBhcmFtIHtvYmplY3R9IG1hcHBpbmdzIG1hcCBvdmVycmlkZXMgZnJvbSBrZXkgdG8gdmFsdWVcbiAqIEBtZXRob2RcbiAqL1xuXG52YXIgY2hhcm1hcCA9IGZ1bmN0aW9uIChhbHBoYWJldCwgbWFwcGluZ3MpIHtcbiAgbWFwcGluZ3MgfHwgKG1hcHBpbmdzID0ge30pO1xuICBhbHBoYWJldC5zcGxpdChcIlwiKS5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgaWYgKCEoYyBpbiBtYXBwaW5ncykpIG1hcHBpbmdzW2NdID0gaTtcbiAgfSk7XG4gIHJldHVybiBtYXBwaW5ncztcbn1cblxuLyoqXG4gKiBUaGUgUkZDIDQ2NDggYmFzZSAzMiBhbHBoYWJldCBhbmQgY2hhcmFjdGVyIG1hcC5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0NjQ4fVxuICovXG5cbnZhciByZmM0NjQ4ID0ge1xuICBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2N1wiLFxuICBjaGFybWFwOiB7XG4gICAgMDogMTQsXG4gICAgMTogOFxuICB9XG59O1xuXG5yZmM0NjQ4LmNoYXJtYXAgPSBjaGFybWFwKHJmYzQ2NDguYWxwaGFiZXQsIHJmYzQ2NDguY2hhcm1hcCk7XG5cbi8qKlxuICogVGhlIENyb2NrZm9yZCBiYXNlIDMyIGFscGhhYmV0IGFuZCBjaGFyYWN0ZXIgbWFwLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5jcm9ja2ZvcmQuY29tL3dybWcvYmFzZTMyLmh0bWx9XG4gKi9cblxudmFyIGNyb2NrZm9yZCA9IHtcbiAgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVpcIixcbiAgY2hhcm1hcDoge1xuICAgIE86IDAsXG4gICAgSTogMSxcbiAgICBMOiAxXG4gIH1cbn07XG5cbmNyb2NrZm9yZC5jaGFybWFwID0gY2hhcm1hcChjcm9ja2ZvcmQuYWxwaGFiZXQsIGNyb2NrZm9yZC5jaGFybWFwKTtcblxuLyoqXG4gKiBiYXNlMzJoZXhcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2UzMiNiYXNlMzJoZXh9XG4gKi9cblxudmFyIGJhc2UzMmhleCA9IHtcbiAgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZcIixcbiAgY2hhcm1hcDoge31cbn07XG5cbmJhc2UzMmhleC5jaGFybWFwID0gY2hhcm1hcChiYXNlMzJoZXguYWxwaGFiZXQsIGJhc2UzMmhleC5jaGFybWFwKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYERlY29kZXJgIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogICBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIFN1cHBvcnRlZCBCYXNlLTMyIHZhcmlhbnRzIGFyZSBcInJmYzQ2NDhcIiBhbmRcbiAqICAgICBcImNyb2NrZm9yZFwiLlxuICogICBAcGFyYW0ge29iamVjdH0gW2NoYXJtYXBdIE92ZXJyaWRlIHRoZSBjaGFyYWN0ZXIgbWFwIHVzZWQgaW4gZGVjb2RpbmcuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBEZWNvZGVyIChvcHRpb25zKSB7XG4gIHRoaXMuYnVmID0gW107XG4gIHRoaXMuc2hpZnQgPSA4O1xuICB0aGlzLmNhcnJ5ID0gMDtcblxuICBpZiAob3B0aW9ucykge1xuXG4gICAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJyZmM0NjQ4XCI6XG4gICAgICAgIHRoaXMuY2hhcm1hcCA9IGV4cG9ydHMucmZjNDY0OC5jaGFybWFwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjcm9ja2ZvcmRcIjpcbiAgICAgICAgdGhpcy5jaGFybWFwID0gZXhwb3J0cy5jcm9ja2ZvcmQuY2hhcm1hcDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmFzZTMyaGV4XCI6XG4gICAgICAgIHRoaXMuY2hhcm1hcCA9IGV4cG9ydHMuYmFzZTMyaGV4LmNoYXJtYXA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0eXBlXCIpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNoYXJtYXApIHRoaXMuY2hhcm1hcCA9IG9wdGlvbnMuY2hhcm1hcDtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGNoYXJhY3RlciBtYXAgY29yZXNwb25kcyB0byBSRkM0NjQ4LlxuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmNoYXJtYXAgPSByZmM0NjQ4LmNoYXJtYXA7XG5cbi8qKlxuICogRGVjb2RlIGEgc3RyaW5nLCBjb250aW51aW5nIGZyb20gdGhlIHByZXZpb3VzIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0RlY29kZXJ9IHRoaXNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGNoYXJtYXAgPSB0aGlzLmNoYXJtYXA7XG4gIHZhciBidWYgPSB0aGlzLmJ1ZjtcbiAgdmFyIHNoaWZ0ID0gdGhpcy5zaGlmdDtcbiAgdmFyIGNhcnJ5ID0gdGhpcy5jYXJyeTtcblxuICAvLyBkZWNvZGUgc3RyaW5nXG4gIHN0ci50b1VwcGVyQ2FzZSgpLnNwbGl0KFwiXCIpLmZvckVhY2goZnVuY3Rpb24gKGNoYXIpIHtcblxuICAgIC8vIGlnbm9yZSBwYWRkaW5nXG4gICAgaWYgKGNoYXIgPT0gXCI9XCIpIHJldHVybjtcblxuICAgIC8vIGxvb2t1cCBzeW1ib2xcbiAgICB2YXIgc3ltYm9sID0gY2hhcm1hcFtjaGFyXSAmIDB4ZmY7XG5cbiAgICAvLyAxOiAwMDAwMCAwMDBcbiAgICAvLyAyOiAgICAgICAgICAwMCAwMDAwMCAwXG4gICAgLy8gMzogICAgICAgICAgICAgICAgICAgIDAwMDAgMDAwMFxuICAgIC8vIDQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwIDAwMDAwIDAwXG4gICAgLy8gNTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwMDAgMDAwMDBcbiAgICAvLyA2OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAwMDAwIDAwMFxuICAgIC8vIDc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAgMDAwMDAgMFxuXG4gICAgc2hpZnQgLT0gNTtcbiAgICBpZiAoc2hpZnQgPiAwKSB7XG4gICAgICBjYXJyeSB8PSBzeW1ib2wgPDwgc2hpZnQ7XG4gICAgfSBlbHNlIGlmIChzaGlmdCA8IDApIHtcbiAgICAgIGJ1Zi5wdXNoKGNhcnJ5IHwgKHN5bWJvbCA+PiAtc2hpZnQpKTtcbiAgICAgIHNoaWZ0ICs9IDg7XG4gICAgICBjYXJyeSA9IChzeW1ib2wgPDwgc2hpZnQpICYgMHhmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLnB1c2goY2FycnkgfCBzeW1ib2wpO1xuICAgICAgc2hpZnQgPSA4O1xuICAgICAgY2FycnkgPSAwO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gc2F2ZSBzdGF0ZVxuICB0aGlzLnNoaWZ0ID0gc2hpZnQ7XG4gIHRoaXMuY2FycnkgPSBjYXJyeTtcblxuICAvLyBmb3IgY2hhaW5pbmdcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZpbmlzaCBkZWNvZGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cl0gVGhlIGZpbmFsIHN0cmluZyB0byBkZWNvZGUuXG4gKiBAcmV0dXJuIHtBcnJheX0gRGVjb2RlZCBieXRlIGFycmF5LlxuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKHN0cikge1xuICBpZiAoc3RyKSB7XG4gICAgdGhpcy53cml0ZShzdHIpO1xuICB9XG4gIGlmICh0aGlzLnNoaWZ0ICE9PSA4ICYmIHRoaXMuY2FycnkgIT09IDApIHtcbiAgICB0aGlzLmJ1Zi5wdXNoKHRoaXMuY2FycnkpO1xuICAgIHRoaXMuc2hpZnQgPSA4O1xuICAgIHRoaXMuY2FycnkgPSAwO1xuICB9XG4gIHJldHVybiB0aGlzLmJ1Zjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGBFbmNvZGVyYCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqICAgQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBTdXBwb3J0ZWQgQmFzZS0zMiB2YXJpYW50cyBhcmUgXCJyZmM0NjQ4XCIgYW5kXG4gKiAgICAgXCJjcm9ja2ZvcmRcIi5cbiAqICAgQHBhcmFtIHtvYmplY3R9IFthbHBoYWJldF0gT3ZlcnJpZGUgdGhlIGFscGhhYmV0IHVzZWQgaW4gZW5jb2RpbmcuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBFbmNvZGVyIChvcHRpb25zKSB7XG4gIHRoaXMuYnVmID0gXCJcIjtcbiAgdGhpcy5zaGlmdCA9IDM7XG4gIHRoaXMuY2FycnkgPSAwO1xuXG4gIGlmIChvcHRpb25zKSB7XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgICAgY2FzZSBcInJmYzQ2NDhcIjpcbiAgICAgICAgdGhpcy5hbHBoYWJldCA9IGV4cG9ydHMucmZjNDY0OC5hbHBoYWJldDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY3JvY2tmb3JkXCI6XG4gICAgICAgIHRoaXMuYWxwaGFiZXQgPSBleHBvcnRzLmNyb2NrZm9yZC5hbHBoYWJldDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmFzZTMyaGV4XCI6XG4gICAgICAgIHRoaXMuYWxwaGFiZXQgPSBleHBvcnRzLmJhc2UzMmhleC5hbHBoYWJldDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR5cGVcIik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxwaGFiZXQpIHRoaXMuYWxwaGFiZXQgPSBvcHRpb25zLmFscGhhYmV0O1xuICAgIGVsc2UgaWYgKG9wdGlvbnMubGMpIHRoaXMuYWxwaGFiZXQgPSB0aGlzLmFscGhhYmV0LnRvTG93ZXJDYXNlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBhbHBoYWJldCBjb3Jlc3BvbmRzIHRvIFJGQzQ2NDguXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuYWxwaGFiZXQgPSByZmM0NjQ4LmFscGhhYmV0O1xuXG4vKipcbiAqIEVuY29kZSBhIGJ5dGUgYXJyYXksIGNvbnRpbnVpbmcgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUuXG4gKlxuICogQHBhcmFtIHtieXRlW119IGJ1ZiBUaGUgYnl0ZSBhcnJheSB0byBlbmNvZGUuXG4gKiBAcmV0dXJuIHtFbmNvZGVyfSB0aGlzXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHZhciBzaGlmdCA9IHRoaXMuc2hpZnQ7XG4gIHZhciBjYXJyeSA9IHRoaXMuY2Fycnk7XG4gIHZhciBzeW1ib2w7XG4gIHZhciBieXRlO1xuICB2YXIgaTtcblxuICAvLyBlbmNvZGUgZWFjaCBieXRlIGluIGJ1ZlxuICBmb3IgKGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZSA9IGJ1ZltpXTtcblxuICAgIC8vIDE6IDAwMDAwIDAwMFxuICAgIC8vIDI6ICAgICAgICAgIDAwIDAwMDAwIDBcbiAgICAvLyAzOiAgICAgICAgICAgICAgICAgICAgMDAwMCAwMDAwXG4gICAgLy8gNDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgMDAwMDAgMDBcbiAgICAvLyA1OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAwMCAwMDAwMFxuICAgIC8vIDY6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAwMDAgMDAwXG4gICAgLy8gNzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwMCAwMDAwMCAwXG5cbiAgICBzeW1ib2wgPSBjYXJyeSB8IChieXRlID4+IHNoaWZ0KTtcbiAgICB0aGlzLmJ1ZiArPSB0aGlzLmFscGhhYmV0W3N5bWJvbCAmIDB4MWZdO1xuXG4gICAgaWYgKHNoaWZ0ID4gNSkge1xuICAgICAgc2hpZnQgLT0gNTtcbiAgICAgIHN5bWJvbCA9IGJ5dGUgPj4gc2hpZnQ7XG4gICAgICB0aGlzLmJ1ZiArPSB0aGlzLmFscGhhYmV0W3N5bWJvbCAmIDB4MWZdO1xuICAgIH1cblxuICAgIHNoaWZ0ID0gNSAtIHNoaWZ0O1xuICAgIGNhcnJ5ID0gYnl0ZSA8PCBzaGlmdDtcbiAgICBzaGlmdCA9IDggLSBzaGlmdDtcbiAgfVxuXG4gIC8vIHNhdmUgc3RhdGVcbiAgdGhpcy5zaGlmdCA9IHNoaWZ0O1xuICB0aGlzLmNhcnJ5ID0gY2Fycnk7XG5cbiAgLy8gZm9yIGNoYWluaW5nXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaW5pc2ggZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHtieXRlW119IFtidWZdIFRoZSBmaW5hbCBieXRlIGFycmF5IHRvIGVuY29kZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGVuY29kZWQgYnl0ZSBhcnJheS5cbiAqL1xuXG5FbmNvZGVyLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zikge1xuICAgIHRoaXMud3JpdGUoYnVmKTtcbiAgfVxuICBpZiAodGhpcy5zaGlmdCAhPT0gMykge1xuICAgIHRoaXMuYnVmICs9IHRoaXMuYWxwaGFiZXRbdGhpcy5jYXJyeSAmIDB4MWZdO1xuICAgIHRoaXMuc2hpZnQgPSAzO1xuICAgIHRoaXMuY2FycnkgPSAwO1xuICB9XG4gIHJldHVybiB0aGlzLmJ1Zjtcbn07XG5cbi8qKlxuICogQ29udmVuaWVuY2UgZW5jb2Rlci5cbiAqXG4gKiBAcGFyYW0ge2J5dGVbXX0gYnVmIFRoZSBieXRlIGFycmF5IHRvIGVuY29kZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBlbmNvZGVyLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKi9cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgRW5jb2RlcihvcHRpb25zKS5maW5hbGl6ZShidWYpO1xufTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBkZWNvZGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgZGVjb2Rlci5cbiAqIEByZXR1cm4ge2J5dGVbXX0gVGhlIGRlY29kZWQgYnl0ZSBhcnJheS5cbiAqL1xuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBEZWNvZGVyKG9wdGlvbnMpLmZpbmFsaXplKHN0cik7XG59O1xuXG4vLyBFeHBvcnRzLlxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5leHBvcnRzLmNoYXJtYXAgPSBjaGFybWFwO1xuZXhwb3J0cy5jcm9ja2ZvcmQgPSBjcm9ja2ZvcmQ7XG5leHBvcnRzLnJmYzQ2NDggPSByZmM0NjQ4O1xuZXhwb3J0cy5iYXNlMzJoZXggPSBiYXNlMzJoZXg7XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHJlZHVjZSA9IHJlcXVpcmUoJy4vcmVkdWNlJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb2xsZWN0IChjYikge1xuICByZXR1cm4gcmVkdWNlKGZ1bmN0aW9uIChhcnIsIGl0ZW0pIHtcbiAgICBhcnIucHVzaChpdGVtKVxuICAgIHJldHVybiBhcnJcbiAgfSwgW10sIGNiKVxufVxuIiwiLyogQGZsb3cgKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBLZXl0cmFuc2Zvcm1EYXRhc3RvcmUgPSByZXF1aXJlKCcuL2tleXRyYW5zZm9ybScpXG5jb25zdCBTaGFyZGluZ0RhdGFzdG9yZSA9IHJlcXVpcmUoJy4vc2hhcmRpbmcnKVxuY29uc3QgTW91bnREYXRhc3RvcmUgPSByZXF1aXJlKCcuL21vdW50JylcbmNvbnN0IFRpZXJlZERhdGFzdG9yZSA9IHJlcXVpcmUoJy4vdGllcmVkJylcbmNvbnN0IE5hbWVzcGFjZURhdGFzdG9yZSA9IHJlcXVpcmUoJy4vbmFtZXNwYWNlJylcbmNvbnN0IHNoYXJkID0gcmVxdWlyZSgnLi9zaGFyZCcpXG5cbmV4cG9ydHMuS2V5dHJhbnNmb3JtRGF0YXN0b3JlID0gS2V5dHJhbnNmb3JtRGF0YXN0b3JlXG5leHBvcnRzLlNoYXJkaW5nRGF0YXN0b3JlID0gU2hhcmRpbmdEYXRhc3RvcmVcbmV4cG9ydHMuTW91bnREYXRhc3RvcmUgPSBNb3VudERhdGFzdG9yZVxuZXhwb3J0cy5UaWVyZWREYXRhc3RvcmUgPSBUaWVyZWREYXRhc3RvcmVcbmV4cG9ydHMuTmFtZXNwYWNlRGF0YXN0b3JlID0gTmFtZXNwYWNlRGF0YXN0b3JlXG5leHBvcnRzLnNoYXJkID0gc2hhcmRcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWplY3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3JlamVjdCcpO1xuXG52YXIgX3JlamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWplY3QpO1xuXG52YXIgX2RvUGFyYWxsZWwgPSByZXF1aXJlKCcuL2ludGVybmFsL2RvUGFyYWxsZWwnKTtcblxudmFyIF9kb1BhcmFsbGVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvUGFyYWxsZWwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9LiBSZW1vdmVzIHZhbHVlcyB0aGF0IHBhc3MgYW4gYGFzeW5jYCB0cnV0aCB0ZXN0LlxuICpcbiAqIEBuYW1lIHJlamVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIGByZXN1bHRgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5yZWplY3QoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycilcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgbm93IGVxdWFscyBhbiBhcnJheSBvZiBtaXNzaW5nIGZpbGVzXG4gKiAgICAgY3JlYXRlRmlsZXMocmVzdWx0cyk7XG4gKiB9KTtcbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9kb1BhcmFsbGVsMi5kZWZhdWx0KShfcmVqZWN0Mi5kZWZhdWx0KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qIEBmbG93ICovXG4ndXNlIHN0cmljdCdcblxuLyogOjogaW1wb3J0IHR5cGUge0NhbGxiYWNrLCBCYXRjaCwgUXVlcnksIFF1ZXJ5UmVzdWx0LCBRdWVyeUVudHJ5fSBmcm9tICdpbnRlcmZhY2UtZGF0YXN0b3JlJyAqL1xuXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0nKVxuY29uc3QgbGV2ZWx1cCA9IHJlcXVpcmUoJ2xldmVsdXAnKVxuXG5jb25zdCBhc3luY0ZpbHRlciA9IHJlcXVpcmUoJ2ludGVyZmFjZS1kYXRhc3RvcmUnKS51dGlscy5hc3luY0ZpbHRlclxuY29uc3QgYXN5bmNTb3J0ID0gcmVxdWlyZSgnaW50ZXJmYWNlLWRhdGFzdG9yZScpLnV0aWxzLmFzeW5jU29ydFxuY29uc3QgS2V5ID0gcmVxdWlyZSgnaW50ZXJmYWNlLWRhdGFzdG9yZScpLktleVxuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnaW50ZXJmYWNlLWRhdGFzdG9yZScpLkVycm9yc1xuY29uc3QgZW5jb2RlID0gcmVxdWlyZSgnZW5jb2RpbmctZG93bicpXG5cbi8qKlxuICogQSBkYXRhc3RvcmUgYmFja2VkIGJ5IGxldmVsZGIuXG4gKi9cbi8qIDo6IGV4cG9ydCB0eXBlIExldmVsT3B0aW9ucyA9IHtcbiAgY3JlYXRlSWZNaXNzaW5nPzogYm9vbCxcbiAgZXJyb3JJZkV4aXN0cz86IGJvb2wsXG4gIGNvbXByZXNzaW9uPzogYm9vbCxcbiAgY2FjaGVTaXplPzogbnVtYmVyLFxuICBkYj86IE9iamVjdFxufSAqL1xuY2xhc3MgTGV2ZWxEYXRhc3RvcmUge1xuICAvKiA6OiBkYjogbGV2ZWx1cCAqL1xuXG4gIGNvbnN0cnVjdG9yIChwYXRoIC8qIDogc3RyaW5nICovLCBvcHRzIC8qIDogP0xldmVsT3B0aW9ucyAqLykge1xuICAgIGxldCBkYXRhYmFzZVxuXG4gICAgaWYgKG9wdHMgJiYgb3B0cy5kYikge1xuICAgICAgZGF0YWJhc2UgPSBvcHRzLmRiXG4gICAgICBkZWxldGUgb3B0cy5kYlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IHRvIGxldmVsZG93biBkYlxuICAgICAgZGF0YWJhc2UgPSByZXF1aXJlKCdsZXZlbGRvd24nKVxuICAgIH1cblxuICAgIHRoaXMuZGIgPSBsZXZlbHVwKFxuICAgICAgZW5jb2RlKGRhdGFiYXNlKHBhdGgpLCB7IHZhbHVlRW5jb2Rpbmc6ICdiaW5hcnknIH0pLFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge1xuICAgICAgICBjb21wcmVzc2lvbjogZmFsc2UgLy8gc2FtZSBkZWZhdWx0IGFzIGdvXG4gICAgICB9KSxcbiAgICAgIChlcnIpID0+IHtcbiAgICAgICAgLy8gUHJldmVudCBhbiB1bmNhdWdodCBleGNlcHRpb24gZXJyb3Igb24gZHVwbGljYXRlIGxvY2tzXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG9wZW4gKGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8dm9pZD4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgdGhpcy5kYi5vcGVuKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9ycy5kYk9wZW5GYWlsZWRFcnJvcihlcnIpKVxuICAgICAgfVxuICAgICAgY2FsbGJhY2soKVxuICAgIH0pXG4gIH1cblxuICBwdXQgKGtleSAvKiA6IEtleSAqLywgdmFsdWUgLyogOiBCdWZmZXIgKi8sIGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8dm9pZD4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgdGhpcy5kYi5wdXQoa2V5LnRvU3RyaW5nKCksIHZhbHVlLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvcnMuZGJXcml0ZUZhaWxlZEVycm9yKGVycikpXG4gICAgICB9XG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIGdldCAoa2V5IC8qIDogS2V5ICovLCBjYWxsYmFjayAvKiA6IENhbGxiYWNrPEJ1ZmZlcj4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgdGhpcy5kYi5nZXQoa2V5LnRvU3RyaW5nKCksIChlcnIsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9ycy5ub3RGb3VuZEVycm9yKGVycikpXG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKVxuICAgIH0pXG4gIH1cblxuICBoYXMgKGtleSAvKiA6IEtleSAqLywgY2FsbGJhY2sgLyogOiBDYWxsYmFjazxib29sPiAqLykgLyogOiB2b2lkICovIHtcbiAgICB0aGlzLmRiLmdldChrZXkudG9TdHJpbmcoKSwgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIubm90Rm91bmQpIHtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBmYWxzZSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCB0cnVlKVxuICAgIH0pXG4gIH1cblxuICBkZWxldGUgKGtleSAvKiA6IEtleSAqLywgY2FsbGJhY2sgLyogOiBDYWxsYmFjazx2b2lkPiAqLykgLyogOiB2b2lkICovIHtcbiAgICB0aGlzLmRiLmRlbChrZXkudG9TdHJpbmcoKSwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JzLmRiRGVsZXRlRmFpbGVkRXJyb3IoZXJyKSlcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKClcbiAgICB9KVxuICB9XG5cbiAgY2xvc2UgKGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8dm9pZD4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgdGhpcy5kYi5jbG9zZShjYWxsYmFjaylcbiAgfVxuXG4gIGJhdGNoICgpIC8qIDogQmF0Y2g8QnVmZmVyPiAqLyB7XG4gICAgY29uc3Qgb3BzID0gW11cbiAgICByZXR1cm4ge1xuICAgICAgcHV0OiAoa2V5IC8qIDogS2V5ICovLCB2YWx1ZSAvKiA6IEJ1ZmZlciAqLykgLyogOiB2b2lkICovID0+IHtcbiAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdwdXQnLFxuICAgICAgICAgIGtleToga2V5LnRvU3RyaW5nKCksXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgZGVsZXRlOiAoa2V5IC8qIDogS2V5ICovKSAvKiA6IHZvaWQgKi8gPT4ge1xuICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2RlbCcsXG4gICAgICAgICAga2V5OiBrZXkudG9TdHJpbmcoKVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIGNvbW1pdDogKGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8dm9pZD4gKi8pIC8qIDogdm9pZCAqLyA9PiB7XG4gICAgICAgIHRoaXMuZGIuYmF0Y2gob3BzLCBjYWxsYmFjaylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBxdWVyeSAocSAvKiA6IFF1ZXJ5PEJ1ZmZlcj4gKi8pIC8qIDogUXVlcnlSZXN1bHQ8QnVmZmVyPiAqLyB7XG4gICAgbGV0IHZhbHVlcyA9IHRydWVcbiAgICBpZiAocS5rZXlzT25seSAhPSBudWxsKSB7XG4gICAgICB2YWx1ZXMgPSAhcS5rZXlzT25seVxuICAgIH1cblxuICAgIGNvbnN0IGl0ZXIgPSB0aGlzLmRiLmRiLml0ZXJhdG9yKHtcbiAgICAgIGtleXM6IHRydWUsXG4gICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgIGtleUFzQnVmZmVyOiB0cnVlXG4gICAgfSlcblxuICAgIGNvbnN0IHJhd1N0cmVhbSA9IChlbmQsIGNiKSA9PiB7XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIHJldHVybiBpdGVyLmVuZCgoZXJyKSA9PiB7XG4gICAgICAgICAgY2IoZXJyIHx8IGVuZClcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaXRlci5uZXh0KChlcnIsIGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyID09IG51bGwgJiYga2V5ID09IG51bGwgJiYgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBpdGVyLmVuZCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBjYihlcnIgfHwgdHJ1ZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzIC8qIDogUXVlcnlFbnRyeTxCdWZmZXI+ICovID0ge1xuICAgICAgICAgIGtleTogbmV3IEtleShrZXksIGZhbHNlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgIHJlcy52YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgY2IobnVsbCwgcmVzKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBsZXQgdGFza3MgPSBbcmF3U3RyZWFtXVxuICAgIGxldCBmaWx0ZXJzID0gW11cblxuICAgIGlmIChxLnByZWZpeCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBxLnByZWZpeFxuICAgICAgZmlsdGVycy5wdXNoKChlLCBjYikgPT4gY2IobnVsbCwgZS5rZXkudG9TdHJpbmcoKS5zdGFydHNXaXRoKHByZWZpeCkpKVxuICAgIH1cblxuICAgIGlmIChxLmZpbHRlcnMgIT0gbnVsbCkge1xuICAgICAgZmlsdGVycyA9IGZpbHRlcnMuY29uY2F0KHEuZmlsdGVycylcbiAgICB9XG5cbiAgICB0YXNrcyA9IHRhc2tzLmNvbmNhdChmaWx0ZXJzLm1hcChmID0+IGFzeW5jRmlsdGVyKGYpKSlcblxuICAgIGlmIChxLm9yZGVycyAhPSBudWxsKSB7XG4gICAgICB0YXNrcyA9IHRhc2tzLmNvbmNhdChxLm9yZGVycy5tYXAobyA9PiBhc3luY1NvcnQobykpKVxuICAgIH1cblxuICAgIGlmIChxLm9mZnNldCAhPSBudWxsKSB7XG4gICAgICBsZXQgaSA9IDBcbiAgICAgIHRhc2tzLnB1c2gocHVsbC5maWx0ZXIoKCkgPT4gaSsrID49IHEub2Zmc2V0KSlcbiAgICB9XG5cbiAgICBpZiAocS5saW1pdCAhPSBudWxsKSB7XG4gICAgICB0YXNrcy5wdXNoKHB1bGwudGFrZShxLmxpbWl0KSlcbiAgICB9XG5cbiAgICByZXR1cm4gcHVsbC5hcHBseShudWxsLCB0YXNrcylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExldmVsRGF0YXN0b3JlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbXVsdGloYXNoID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnLi9jcnlwdG8nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IE11bHRpaGFzaGluZ1xuXG4vKipcbiAqIEhhc2ggdGhlIGdpdmVuIGBidWZgIHVzaW5nIHRoZSBhbGdvcml0aG0gc3BlY2lmaWVkXG4gKiBieSBgZnVuY2AuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIFRoZSB2YWx1ZSB0byBoYXNoLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBmdW5jIC0gVGhlIGFsZ29yaXRobSB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gLSBPcHRpb25hbGx5IHRyaW0gdGhlIHJlc3VsdCB0byB0aGlzIGxlbmd0aC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEJ1ZmZlcil9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBNdWx0aWhhc2hpbmcgKGJ1ZiwgZnVuYywgbGVuZ3RoLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNhbGxiYWNrJylcbiAgfVxuXG4gIE11bHRpaGFzaGluZy5kaWdlc3QoYnVmLCBmdW5jLCBsZW5ndGgsIChlcnIsIGRpZ2VzdCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgbXVsdGloYXNoLmVuY29kZShkaWdlc3QsIGZ1bmMsIGxlbmd0aCkpXG4gIH0pXG59XG5cbi8qKlxuICogVGhlIGBidWZmZXJgIG1vZHVsZSBmb3IgZWFzeSB1c2UgaW4gdGhlIGJyb3dzZXIuXG4gKlxuICogQHR5cGUge0J1ZmZlcn1cbiAqL1xuTXVsdGloYXNoaW5nLkJ1ZmZlciA9IEJ1ZmZlciAvLyBmb3IgYnJvd3NlciB0aGluZ3NcblxuLyoqXG4gKiBFeHBvc2UgbXVsdGloYXNoIGl0c2VsZiwgdG8gYXZvaWQgc2lsbHkgZG91YmxlIHJlcXVpcmVzLlxuICovXG5NdWx0aWhhc2hpbmcubXVsdGloYXNoID0gbXVsdGloYXNoXG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIFRoZSB2YWx1ZSB0byBoYXNoLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBmdW5jIC0gVGhlIGFsZ29yaXRobSB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gLSBPcHRpb25hbGx5IHRyaW0gdGhlIHJlc3VsdCB0byB0aGlzIGxlbmd0aC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEJ1ZmZlcil9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5NdWx0aWhhc2hpbmcuZGlnZXN0ID0gZnVuY3Rpb24gKGJ1ZiwgZnVuYywgbGVuZ3RoLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNhbGxiYWNrJylcbiAgfVxuXG4gIGxldCBjYiA9IGNhbGxiYWNrXG4gIGlmIChsZW5ndGgpIHtcbiAgICBjYiA9IChlcnIsIGRpZ2VzdCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkaWdlc3Quc2xpY2UoMCwgbGVuZ3RoKSlcbiAgICB9XG4gIH1cblxuICBsZXQgaGFzaFxuICB0cnkge1xuICAgIGhhc2ggPSBNdWx0aWhhc2hpbmcuY3JlYXRlSGFzaChmdW5jKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gY2IoZXJyKVxuICB9XG5cbiAgaGFzaChidWYsIGNiKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZnVuY1xuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gLSBUaGUgdG8gYGZ1bmNgIGNvcnJlc3BvbmRpbmcgaGFzaCBmdW5jdGlvbi5cbiAqL1xuTXVsdGloYXNoaW5nLmNyZWF0ZUhhc2ggPSBmdW5jdGlvbiAoZnVuYykge1xuICBmdW5jID0gbXVsdGloYXNoLmNvZXJjZUNvZGUoZnVuYylcbiAgaWYgKCFNdWx0aWhhc2hpbmcuZnVuY3Rpb25zW2Z1bmNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggZnVuY3Rpb24gJyArIGZ1bmMgKyAnIG5vdCB5ZXQgc3VwcG9ydGVkJylcbiAgfVxuXG4gIHJldHVybiBNdWx0aWhhc2hpbmcuZnVuY3Rpb25zW2Z1bmNdXG59XG5cbi8qKlxuICogTWFwcGluZyBvZiBtdWx0aWhhc2ggY29kZXMgdG8gdGhlaXIgaGFzaGluZyBmdW5jdGlvbnMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5NdWx0aWhhc2hpbmcuZnVuY3Rpb25zID0ge1xuICAvLyBzaGExXG4gIDB4MTE6IGNyeXB0by5zaGExLFxuICAvLyBzaGEyLTI1NlxuICAweDEyOiBjcnlwdG8uc2hhMjI1NixcbiAgLy8gc2hhMi01MTJcbiAgMHgxMzogY3J5cHRvLnNoYTI1MTIsXG4gIC8vIHNoYTMtNTEyXG4gIDB4MTQ6IGNyeXB0by5zaGEzNTEyLFxuICAvLyBzaGEzLTM4NFxuICAweDE1OiBjcnlwdG8uc2hhMzM4NCxcbiAgLy8gc2hhMy0yNTZcbiAgMHgxNjogY3J5cHRvLnNoYTMyNTYsXG4gIC8vIHNoYTMtMjI0XG4gIDB4MTc6IGNyeXB0by5zaGEzMjI0LFxuICAvLyBzaGFrZS0xMjhcbiAgMHgxODogY3J5cHRvLnNoYWtlMTI4LFxuICAvLyBzaGFrZS0yNTZcbiAgMHgxOTogY3J5cHRvLnNoYWtlMjU2LFxuICAvLyBrZWNjYWstMjI0XG4gIDB4MUE6IGNyeXB0by5rZWNjYWsyMjQsXG4gIC8vIGtlY2Nhay0yNTZcbiAgMHgxQjogY3J5cHRvLmtlY2NhazI1NixcbiAgLy8ga2VjY2FrLTM4NFxuICAweDFDOiBjcnlwdG8ua2VjY2FrMzg0LFxuICAvLyBrZWNjYWstNTEyXG4gIDB4MUQ6IGNyeXB0by5rZWNjYWs1MTIsXG4gIC8vIG11cm11cjMtMTI4XG4gIDB4MjI6IGNyeXB0by5tdXJtdXIzMTI4LFxuICAvLyBtdXJtdXIzLTMyXG4gIDB4MjM6IGNyeXB0by5tdXJtdXIzMzIsXG4gIC8vIGRibC1zaGEyLTI1NlxuICAweDU2OiBjcnlwdG8uZGJsU2hhMjI1NlxufVxuXG4vLyBhZGQgYmxha2UgZnVuY3Rpb25zXG5jcnlwdG8uYWRkQmxha2UoTXVsdGloYXNoaW5nLmZ1bmN0aW9ucylcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBuYWNsID0gcmVxdWlyZSgndHdlZXRuYWNsJylcbmNvbnN0IG5leHRUaWNrID0gcmVxdWlyZSgnYXN5bmMvbmV4dFRpY2snKVxuXG5leHBvcnRzLnB1YmxpY0tleUxlbmd0aCA9IG5hY2wuc2lnbi5wdWJsaWNLZXlMZW5ndGhcbmV4cG9ydHMucHJpdmF0ZUtleUxlbmd0aCA9IG5hY2wuc2lnbi5zZWNyZXRLZXlMZW5ndGhcblxuZXhwb3J0cy5nZW5lcmF0ZUtleSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBuZXh0VGljaygoKSA9PiB7XG4gICAgbGV0IHJlc3VsdFxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBuYWNsLnNpZ24ua2V5UGFpcigpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpXG4gIH0pXG59XG5cbi8vIHNlZWQgc2hvdWxkIGJlIGEgMzIgYnl0ZSB1aW50OGFycmF5XG5leHBvcnRzLmdlbmVyYXRlS2V5RnJvbVNlZWQgPSBmdW5jdGlvbiAoc2VlZCwgY2FsbGJhY2spIHtcbiAgbmV4dFRpY2soKCkgPT4ge1xuICAgIGxldCByZXN1bHRcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQoc2VlZClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgfSlcbn1cblxuZXhwb3J0cy5oYXNoQW5kU2lnbiA9IGZ1bmN0aW9uIChrZXksIG1zZywgY2FsbGJhY2spIHtcbiAgbmV4dFRpY2soKCkgPT4ge1xuICAgIGNhbGxiYWNrKG51bGwsIEJ1ZmZlci5mcm9tKG5hY2wuc2lnbi5kZXRhY2hlZChtc2csIGtleSkpKVxuICB9KVxufVxuXG5leHBvcnRzLmhhc2hBbmRWZXJpZnkgPSBmdW5jdGlvbiAoa2V5LCBzaWcsIG1zZywgY2FsbGJhY2spIHtcbiAgbmV4dFRpY2soKCkgPT4ge1xuICAgIGxldCByZXN1bHRcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gbmFjbC5zaWduLmRldGFjaGVkLnZlcmlmeShtc2csIHNpZywga2V5KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHdoaWxzdDtcblxudmFyIF9ub29wID0gcmVxdWlyZSgnbG9kYXNoL25vb3AnKTtcblxudmFyIF9ub29wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25vb3ApO1xuXG52YXIgX3NsaWNlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zbGljZScpO1xuXG52YXIgX3NsaWNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NsaWNlKTtcblxudmFyIF9vbmx5T25jZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvb25seU9uY2UnKTtcblxudmFyIF9vbmx5T25jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vbmx5T25jZSk7XG5cbnZhciBfd3JhcEFzeW5jID0gcmVxdWlyZSgnLi9pbnRlcm5hbC93cmFwQXN5bmMnKTtcblxudmFyIF93cmFwQXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd3JhcEFzeW5jKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBSZXBlYXRlZGx5IGNhbGwgYGl0ZXJhdGVlYCwgd2hpbGUgYHRlc3RgIHJldHVybnMgYHRydWVgLiBDYWxscyBgY2FsbGJhY2tgIHdoZW5cbiAqIHN0b3BwZWQsIG9yIGFuIGVycm9yIG9jY3Vycy5cbiAqXG4gKiBAbmFtZSB3aGlsc3RcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3QgLSBzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYmVmb3JlIGVhY2hcbiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKCkuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZVxuICogYHRlc3RgIHBhc3Nlcy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3RcbiAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLiBgY2FsbGJhY2tgXG4gKiB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZpbmFsIGBpdGVyYXRlZWAnc1xuICogY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pO1xuICogQHJldHVybnMgdW5kZWZpbmVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBjb3VudCA9IDA7XG4gKiBhc3luYy53aGlsc3QoXG4gKiAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBjb3VudCA8IDU7IH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgY291bnQrKztcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNvdW50KTtcbiAqICAgICAgICAgfSwgMTAwMCk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbiAoZXJyLCBuKSB7XG4gKiAgICAgICAgIC8vIDUgc2Vjb25kcyBoYXZlIHBhc3NlZCwgbiA9IDVcbiAqICAgICB9XG4gKiApO1xuICovXG5mdW5jdGlvbiB3aGlsc3QodGVzdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSAoMCwgX29ubHlPbmNlMi5kZWZhdWx0KShjYWxsYmFjayB8fCBfbm9vcDIuZGVmYXVsdCk7XG4gICAgdmFyIF9pdGVyYXRlZSA9ICgwLCBfd3JhcEFzeW5jMi5kZWZhdWx0KShpdGVyYXRlZSk7XG4gICAgaWYgKCF0ZXN0KCkpIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIChlcnIgLyosIC4uLmFyZ3MqLykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgaWYgKHRlc3QoKSkgcmV0dXJuIF9pdGVyYXRlZShuZXh0KTtcbiAgICAgICAgdmFyIGFyZ3MgPSAoMCwgX3NsaWNlMi5kZWZhdWx0KShhcmd1bWVudHMsIDEpO1xuICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBbbnVsbF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9O1xuICAgIF9pdGVyYXRlZShuZXh0KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qKlxuICogT2JqZWN0IElEcyBmb3IgQVNOLjEuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5cbmZvcmdlLnBraSA9IGZvcmdlLnBraSB8fCB7fTtcbnZhciBvaWRzID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2kub2lkcyA9IGZvcmdlLm9pZHMgPSBmb3JnZS5vaWRzIHx8IHt9O1xuXG4vLyBzZXQgaWQgdG8gbmFtZSBtYXBwaW5nIGFuZCBuYW1lIHRvIGlkIG1hcHBpbmdcbmZ1bmN0aW9uIF9JTihpZCwgbmFtZSkge1xuICBvaWRzW2lkXSA9IG5hbWU7XG4gIG9pZHNbbmFtZV0gPSBpZDtcbn1cbi8vIHNldCBpZCB0byBuYW1lIG1hcHBpbmcgb25seVxuZnVuY3Rpb24gX0lfKGlkLCBuYW1lKSB7XG4gIG9pZHNbaWRdID0gbmFtZTtcbn1cblxuLy8gYWxnb3JpdGhtIE9JRHNcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjEnLCAncnNhRW5jcnlwdGlvbicpO1xuLy8gTm90ZTogbWQyICYgbWQ0IG5vdCBpbXBsZW1lbnRlZFxuLy9fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4yJywgJ21kMldpdGhSU0FFbmNyeXB0aW9uJyk7XG4vL19JTignMS4yLjg0MC4xMTM1NDkuMS4xLjMnLCAnbWQ0V2l0aFJTQUVuY3J5cHRpb24nKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjQnLCAnbWQ1V2l0aFJTQUVuY3J5cHRpb24nKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjUnLCAnc2hhMVdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS43JywgJ1JTQUVTLU9BRVAnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjgnLCAnbWdmMScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuOScsICdwU3BlY2lmaWVkJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xMCcsICdSU0FTU0EtUFNTJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xMScsICdzaGEyNTZXaXRoUlNBRW5jcnlwdGlvbicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTInLCAnc2hhMzg0V2l0aFJTQUVuY3J5cHRpb24nKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjEzJywgJ3NoYTUxMldpdGhSU0FFbmNyeXB0aW9uJyk7XG4vLyBFZHdhcmRzLWN1cnZlIERpZ2l0YWwgU2lnbmF0dXJlIEFsZ29yaXRobSAoRWREU0EpIEVkMjU1MTlcbl9JTignMS4zLjEwMS4xMTInLCAnRWREU0EyNTUxOScpO1xuXG5fSU4oJzEuMi44NDAuMTAwNDAuNC4zJywgJ2RzYS13aXRoLXNoYTEnKTtcblxuX0lOKCcxLjMuMTQuMy4yLjcnLCAnZGVzQ0JDJyk7XG5cbl9JTignMS4zLjE0LjMuMi4yNicsICdzaGExJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjEnLCAnc2hhMjU2Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjInLCAnc2hhMzg0Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjMnLCAnc2hhNTEyJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuNScsICdtZDUnKTtcblxuLy8gcGtjcyM3IGNvbnRlbnQgdHlwZXNcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjEnLCAnZGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuMicsICdzaWduZWREYXRhJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuNy4zJywgJ2VudmVsb3BlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjQnLCAnc2lnbmVkQW5kRW52ZWxvcGVkRGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuNScsICdkaWdlc3RlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjYnLCAnZW5jcnlwdGVkRGF0YScpO1xuXG4vLyBwa2NzIzkgb2lkc1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMScsICdlbWFpbEFkZHJlc3MnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjInLCAndW5zdHJ1Y3R1cmVkTmFtZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMycsICdjb250ZW50VHlwZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuNCcsICdtZXNzYWdlRGlnZXN0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS41JywgJ3NpZ25pbmdUaW1lJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS42JywgJ2NvdW50ZXJTaWduYXR1cmUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjcnLCAnY2hhbGxlbmdlUGFzc3dvcmQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjgnLCAndW5zdHJ1Y3R1cmVkQWRkcmVzcycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMTQnLCAnZXh0ZW5zaW9uUmVxdWVzdCcpO1xuXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS4yMCcsICdmcmllbmRseU5hbWUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjIxJywgJ2xvY2FsS2V5SWQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjIyLjEnLCAneDUwOUNlcnRpZmljYXRlJyk7XG5cbi8vIHBrY3MjMTIgc2FmZSBiYWdzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4xJywgJ2tleUJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuMicsICdwa2NzOFNocm91ZGVkS2V5QmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4zJywgJ2NlcnRCYWcnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjQnLCAnY3JsQmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS41JywgJ3NlY3JldEJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuNicsICdzYWZlQ29udGVudHNCYWcnKTtcblxuLy8gcGFzc3dvcmQtYmFzZWQtZW5jcnlwdGlvbiBmb3IgcGtjcyMxMlxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjUuMTMnLCAncGtjczVQQkVTMicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjUuMTInLCAncGtjczVQQktERjInKTtcblxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMScsICdwYmVXaXRoU0hBQW5kMTI4Qml0UkM0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS4yJywgJ3BiZVdpdGhTSEFBbmQ0MEJpdFJDNCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMycsICdwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS40JywgJ3BiZVdpdGhTSEFBbmQyLUtleVRyaXBsZURFUy1DQkMnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjUnLCAncGJlV2l0aFNIQUFuZDEyOEJpdFJDMi1DQkMnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjYnLCAncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQycpO1xuXG4vLyBobWFjIE9JRHNcbl9JTignMS4yLjg0MC4xMTM1NDkuMi43JywgJ2htYWNXaXRoU0hBMScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4yLjgnLCAnaG1hY1dpdGhTSEEyMjQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi45JywgJ2htYWNXaXRoU0hBMjU2Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuMTAnLCAnaG1hY1dpdGhTSEEzODQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi4xMScsICdobWFjV2l0aFNIQTUxMicpO1xuXG4vLyBzeW1tZXRyaWMga2V5IGFsZ29yaXRobSBvaWRzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjMuNycsICdkZXMtRURFMy1DQkMnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjEuMicsICdhZXMxMjgtQ0JDJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4xLjIyJywgJ2FlczE5Mi1DQkMnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjEuNDInLCAnYWVzMjU2LUNCQycpO1xuXG4vLyBjZXJ0aWZpY2F0ZSBpc3N1ZXIvc3ViamVjdCBPSURzXG5fSU4oJzIuNS40LjMnLCAnY29tbW9uTmFtZScpO1xuX0lOKCcyLjUuNC41JywgJ3NlcmlhbE5hbWUnKTtcbl9JTignMi41LjQuNicsICdjb3VudHJ5TmFtZScpO1xuX0lOKCcyLjUuNC43JywgJ2xvY2FsaXR5TmFtZScpO1xuX0lOKCcyLjUuNC44JywgJ3N0YXRlT3JQcm92aW5jZU5hbWUnKTtcbl9JTignMi41LjQuOScsICdzdHJlZXRBZGRyZXNzJyk7XG5fSU4oJzIuNS40LjEwJywgJ29yZ2FuaXphdGlvbk5hbWUnKTtcbl9JTignMi41LjQuMTEnLCAnb3JnYW5pemF0aW9uYWxVbml0TmFtZScpO1xuX0lOKCcyLjUuNC4xMycsICdkZXNjcmlwdGlvbicpO1xuX0lOKCcyLjUuNC4xNScsICdidXNpbmVzc0NhdGVnb3J5Jyk7XG5fSU4oJzIuNS40LjE3JywgJ3Bvc3RhbENvZGUnKTtcbl9JTignMS4zLjYuMS40LjEuMzExLjYwLjIuMS4yJywgJ2p1cmlzZGljdGlvbk9mSW5jb3Jwb3JhdGlvblN0YXRlT3JQcm92aW5jZU5hbWUnKTtcbl9JTignMS4zLjYuMS40LjEuMzExLjYwLjIuMS4zJywgJ2p1cmlzZGljdGlvbk9mSW5jb3Jwb3JhdGlvbkNvdW50cnlOYW1lJyk7XG5cbi8vIFguNTA5IGV4dGVuc2lvbiBPSURzXG5fSU4oJzIuMTYuODQwLjEuMTEzNzMwLjEuMScsICduc0NlcnRUeXBlJyk7XG5fSU4oJzIuMTYuODQwLjEuMTEzNzMwLjEuMTMnLCAnbnNDb21tZW50Jyk7IC8vIGRlcHJlY2F0ZWQgaW4gdGhlb3J5OyBzdGlsbCB3aWRlbHkgdXNlZFxuX0lfKCcyLjUuMjkuMScsICdhdXRob3JpdHlLZXlJZGVudGlmaWVyJyk7IC8vIGRlcHJlY2F0ZWQsIHVzZSAuMzVcbl9JXygnMi41LjI5LjInLCAna2V5QXR0cmlidXRlcycpOyAvLyBvYnNvbGV0ZSB1c2UgLjM3IG9yIC4xNVxuX0lfKCcyLjUuMjkuMycsICdjZXJ0aWZpY2F0ZVBvbGljaWVzJyk7IC8vIGRlcHJlY2F0ZWQsIHVzZSAuMzJcbl9JXygnMi41LjI5LjQnLCAna2V5VXNhZ2VSZXN0cmljdGlvbicpOyAvLyBvYnNvbGV0ZSB1c2UgLjM3IG9yIC4xNVxuX0lfKCcyLjUuMjkuNScsICdwb2xpY3lNYXBwaW5nJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4zM1xuX0lfKCcyLjUuMjkuNicsICdzdWJ0cmVlc0NvbnN0cmFpbnQnKTsgLy8gb2Jzb2xldGUgdXNlIC4zMFxuX0lfKCcyLjUuMjkuNycsICdzdWJqZWN0QWx0TmFtZScpOyAvLyBkZXByZWNhdGVkIHVzZSAuMTdcbl9JXygnMi41LjI5LjgnLCAnaXNzdWVyQWx0TmFtZScpOyAvLyBkZXByZWNhdGVkIHVzZSAuMThcbl9JXygnMi41LjI5LjknLCAnc3ViamVjdERpcmVjdG9yeUF0dHJpYnV0ZXMnKTtcbl9JXygnMi41LjI5LjEwJywgJ2Jhc2ljQ29uc3RyYWludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjE5XG5fSV8oJzIuNS4yOS4xMScsICduYW1lQ29uc3RyYWludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjMwXG5fSV8oJzIuNS4yOS4xMicsICdwb2xpY3lDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzZcbl9JXygnMi41LjI5LjEzJywgJ2Jhc2ljQ29uc3RyYWludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjE5XG5fSU4oJzIuNS4yOS4xNCcsICdzdWJqZWN0S2V5SWRlbnRpZmllcicpO1xuX0lOKCcyLjUuMjkuMTUnLCAna2V5VXNhZ2UnKTtcbl9JXygnMi41LjI5LjE2JywgJ3ByaXZhdGVLZXlVc2FnZVBlcmlvZCcpO1xuX0lOKCcyLjUuMjkuMTcnLCAnc3ViamVjdEFsdE5hbWUnKTtcbl9JTignMi41LjI5LjE4JywgJ2lzc3VlckFsdE5hbWUnKTtcbl9JTignMi41LjI5LjE5JywgJ2Jhc2ljQ29uc3RyYWludHMnKTtcbl9JXygnMi41LjI5LjIwJywgJ2NSTE51bWJlcicpO1xuX0lfKCcyLjUuMjkuMjEnLCAnY1JMUmVhc29uJyk7XG5fSV8oJzIuNS4yOS4yMicsICdleHBpcmF0aW9uRGF0ZScpO1xuX0lfKCcyLjUuMjkuMjMnLCAnaW5zdHJ1Y3Rpb25Db2RlJyk7XG5fSV8oJzIuNS4yOS4yNCcsICdpbnZhbGlkaXR5RGF0ZScpO1xuX0lfKCcyLjUuMjkuMjUnLCAnY1JMRGlzdHJpYnV0aW9uUG9pbnRzJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4zMVxuX0lfKCcyLjUuMjkuMjYnLCAnaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50Jyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4yOFxuX0lfKCcyLjUuMjkuMjcnLCAnZGVsdGFDUkxJbmRpY2F0b3InKTtcbl9JXygnMi41LjI5LjI4JywgJ2lzc3VpbmdEaXN0cmlidXRpb25Qb2ludCcpO1xuX0lfKCcyLjUuMjkuMjknLCAnY2VydGlmaWNhdGVJc3N1ZXInKTtcbl9JXygnMi41LjI5LjMwJywgJ25hbWVDb25zdHJhaW50cycpO1xuX0lOKCcyLjUuMjkuMzEnLCAnY1JMRGlzdHJpYnV0aW9uUG9pbnRzJyk7XG5fSU4oJzIuNS4yOS4zMicsICdjZXJ0aWZpY2F0ZVBvbGljaWVzJyk7XG5fSV8oJzIuNS4yOS4zMycsICdwb2xpY3lNYXBwaW5ncycpO1xuX0lfKCcyLjUuMjkuMzQnLCAncG9saWN5Q29uc3RyYWludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjM2XG5fSU4oJzIuNS4yOS4zNScsICdhdXRob3JpdHlLZXlJZGVudGlmaWVyJyk7XG5fSV8oJzIuNS4yOS4zNicsICdwb2xpY3lDb25zdHJhaW50cycpO1xuX0lOKCcyLjUuMjkuMzcnLCAnZXh0S2V5VXNhZ2UnKTtcbl9JXygnMi41LjI5LjQ2JywgJ2ZyZXNoZXN0Q1JMJyk7XG5fSV8oJzIuNS4yOS41NCcsICdpbmhpYml0QW55UG9saWN5Jyk7XG5cbi8vIGV4dEtleVVzYWdlIHB1cnBvc2VzXG5fSU4oJzEuMy42LjEuNC4xLjExMTI5LjIuNC4yJywgJ3RpbWVzdGFtcExpc3QnKTtcbl9JTignMS4zLjYuMS41LjUuNy4xLjEnLCAnYXV0aG9yaXR5SW5mb0FjY2VzcycpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuMScsICdzZXJ2ZXJBdXRoJyk7XG5fSU4oJzEuMy42LjEuNS41LjcuMy4yJywgJ2NsaWVudEF1dGgnKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjMnLCAnY29kZVNpZ25pbmcnKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjQnLCAnZW1haWxQcm90ZWN0aW9uJyk7XG5fSU4oJzEuMy42LjEuNS41LjcuMy44JywgJ3RpbWVTdGFtcGluZycpO1xuIiwiLyoqXG4gKiBOb2RlLmpzIG1vZHVsZSBmb3IgRm9yZ2UgbWVzc2FnZSBkaWdlc3RzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IDIwMTEtMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UubWQgPSBmb3JnZS5tZCB8fCB7fTtcbmZvcmdlLm1kLmFsZ29yaXRobXMgPSBmb3JnZS5tZC5hbGdvcml0aG1zIHx8IHt9O1xuIiwiLyoqXG4gKiBBZHZhbmNlZCBFbmNyeXB0aW9uIFN0YW5kYXJkIChBRVMpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIHB1YmxpYyBkb21haW4gbGlicmFyeSAnanNjcnlwdG8nIHdoaWNoXG4gKiB3YXMgd3JpdHRlbiBieTpcbiAqXG4gKiBFbWlseSBTdGFyayAoZXN0YXJrQHN0YW5mb3JkLmVkdSlcbiAqIE1pa2UgSGFtYnVyZyAobWhhbWJ1cmdAc3RhbmZvcmQuZWR1KVxuICogRGFuIEJvbmVoIChkYWJvQGNzLnN0YW5mb3JkLmVkdSlcbiAqXG4gKiBQYXJ0cyBvZiB0aGlzIGNvZGUgYXJlIGJhc2VkIG9uIHRoZSBPcGVuU1NMIGltcGxlbWVudGF0aW9uIG9mIEFFUzpcbiAqIGh0dHA6Ly93d3cub3BlbnNzbC5vcmdcbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vY2lwaGVyJyk7XG5yZXF1aXJlKCcuL2NpcGhlck1vZGVzJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuLyogQUVTIEFQSSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5hZXMgPSBmb3JnZS5hZXMgfHwge307XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqIGNpcGhlci5zdGFydCh7aXY6IGl2fSk7XG4gKlxuICogQ3JlYXRlcyBhbiBBRVMgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKiBUaGUgb3V0cHV0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSAnb3V0cHV0JyBtZW1iZXIgb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5IG9mIGJ5dGVzLFxuICogYSBieXRlIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLlxuICogQHBhcmFtIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuc3RhcnRFbmNyeXB0aW5nID0gZnVuY3Rpb24oa2V5LCBpdiwgb3V0cHV0LCBtb2RlKSB7XG4gIHZhciBjaXBoZXIgPSBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICBkZWNyeXB0OiBmYWxzZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xuICBjaXBoZXIuc3RhcnQoaXYpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcywgYVxuICogYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBjaXBoZXIgbW9kZSB0byB1c2UgKGRlZmF1bHQ6ICdDQkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBtb2RlKSB7XG4gIHJldHVybiBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG51bGwsXG4gICAgZGVjcnlwdDogZmFsc2UsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBkZWNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignQUVTLTxtb2RlPicsIGtleSk7XG4gKiBkZWNpcGhlci5zdGFydCh7aXY6IGl2fSk7XG4gKlxuICogQ3JlYXRlcyBhbiBBRVMgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKiBUaGUgb3V0cHV0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSAnb3V0cHV0JyBtZW1iZXIgb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5IG9mIGJ5dGVzLFxuICogYSBieXRlIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLlxuICogQHBhcmFtIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuc3RhcnREZWNyeXB0aW5nID0gZnVuY3Rpb24oa2V5LCBpdiwgb3V0cHV0LCBtb2RlKSB7XG4gIHZhciBjaXBoZXIgPSBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICBkZWNyeXB0OiB0cnVlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgZGVjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcywgYVxuICogYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBjaXBoZXIgbW9kZSB0byB1c2UgKGRlZmF1bHQ6ICdDQkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBtb2RlKSB7XG4gIHJldHVybiBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG51bGwsXG4gICAgZGVjcnlwdDogdHJ1ZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEFFUyBjaXBoZXIgYWxnb3JpdGhtIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYWxnb3JpdGhtLlxuICogQHBhcmFtIG1vZGUgdGhlIG1vZGUgZmFjdG9yeSBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBRVMgYWxnb3JpdGhtIG9iamVjdC5cbiAqL1xuZm9yZ2UuYWVzLkFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUsIG1vZGUpIHtcbiAgaWYoIWluaXQpIHtcbiAgICBpbml0aWFsaXplKCk7XG4gIH1cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm5hbWUgPSBuYW1lO1xuICBzZWxmLm1vZGUgPSBuZXcgbW9kZSh7XG4gICAgYmxvY2tTaXplOiAxNixcbiAgICBjaXBoZXI6IHtcbiAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uKGluQmxvY2ssIG91dEJsb2NrKSB7XG4gICAgICAgIHJldHVybiBfdXBkYXRlQmxvY2soc2VsZi5fdywgaW5CbG9jaywgb3V0QmxvY2ssIGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBkZWNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX3csIGluQmxvY2ssIG91dEJsb2NrLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBzZWxmLl9pbml0ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoaXMgQUVTIGFsZ29yaXRobSBieSBleHBhbmRpbmcgaXRzIGtleS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBrZXkgdGhlIGtleSB0byB1c2Ugd2l0aCB0aGlzIGFsZ29yaXRobS5cbiAqICAgICAgICAgIGRlY3J5cHQgdHJ1ZSBpZiB0aGUgYWxnb3JpdGhtIHNob3VsZCBiZSBpbml0aWFsaXplZCBmb3IgZGVjcnlwdGlvbixcbiAqICAgICAgICAgICAgZmFsc2UgZm9yIGVuY3J5cHRpb24uXG4gKi9cbmZvcmdlLmFlcy5BbGdvcml0aG0ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmKHRoaXMuX2luaXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gIHZhciB0bXA7XG5cbiAgLyogTm90ZTogVGhlIGtleSBtYXkgYmUgYSBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5IG9mIGJ5dGVzLCBhIGJ5dGVcbiAgICBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCBpbnRlZ2Vycy4gSWYgdGhlIGtleSBpcyBpbiBieXRlcywgdGhlblxuICAgIGl0IG11c3QgYmUgMTYsIDI0LCBvciAzMiBieXRlcyBpbiBsZW5ndGguIElmIGl0IGlzIGluIDMyLWJpdFxuICAgIGludGVnZXJzLCBpdCBtdXN0IGJlIDQsIDYsIG9yIDggaW50ZWdlcnMgbG9uZy4gKi9cblxuICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJlxuICAgIChrZXkubGVuZ3RoID09PSAxNiB8fCBrZXkubGVuZ3RoID09PSAyNCB8fCBrZXkubGVuZ3RoID09PSAzMikpIHtcbiAgICAvLyBjb252ZXJ0IGtleSBzdHJpbmcgaW50byBieXRlIGJ1ZmZlclxuICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGtleSk7XG4gIH0gZWxzZSBpZihmb3JnZS51dGlsLmlzQXJyYXkoa2V5KSAmJlxuICAgIChrZXkubGVuZ3RoID09PSAxNiB8fCBrZXkubGVuZ3RoID09PSAyNCB8fCBrZXkubGVuZ3RoID09PSAzMikpIHtcbiAgICAvLyBjb252ZXJ0IGtleSBpbnRlZ2VyIGFycmF5IGludG8gYnl0ZSBidWZmZXJcbiAgICB0bXAgPSBrZXk7XG4gICAga2V5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXkucHV0Qnl0ZSh0bXBbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbnZlcnQga2V5IGJ5dGUgYnVmZmVyIGludG8gMzItYml0IGludGVnZXIgYXJyYXlcbiAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShrZXkpKSB7XG4gICAgdG1wID0ga2V5O1xuICAgIGtleSA9IFtdO1xuXG4gICAgLy8ga2V5IGxlbmd0aHMgb2YgMTYsIDI0LCAzMiBieXRlcyBhbGxvd2VkXG4gICAgdmFyIGxlbiA9IHRtcC5sZW5ndGgoKTtcbiAgICBpZihsZW4gPT09IDE2IHx8IGxlbiA9PT0gMjQgfHwgbGVuID09PSAzMikge1xuICAgICAgbGVuID0gbGVuID4+PiAyO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGtleS5wdXNoKHRtcC5nZXRJbnQzMigpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZXkgbXVzdCBiZSBhbiBhcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMgYnkgbm93XG4gIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkoa2V5KSB8fFxuICAgICEoa2V5Lmxlbmd0aCA9PT0gNCB8fCBrZXkubGVuZ3RoID09PSA2IHx8IGtleS5sZW5ndGggPT09IDgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBwYXJhbWV0ZXIuJyk7XG4gIH1cblxuICAvLyBlbmNyeXB0aW9uIG9wZXJhdGlvbiBpcyBhbHdheXMgdXNlZCBmb3IgdGhlc2UgbW9kZXNcbiAgdmFyIG1vZGUgPSB0aGlzLm1vZGUubmFtZTtcbiAgdmFyIGVuY3J5cHRPcCA9IChbJ0NGQicsICdPRkInLCAnQ1RSJywgJ0dDTSddLmluZGV4T2YobW9kZSkgIT09IC0xKTtcblxuICAvLyBkbyBrZXkgZXhwYW5zaW9uXG4gIHRoaXMuX3cgPSBfZXhwYW5kS2V5KGtleSwgb3B0aW9ucy5kZWNyeXB0ICYmICFlbmNyeXB0T3ApO1xuICB0aGlzLl9pbml0ID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogRXhwYW5kcyBhIGtleS4gVHlwaWNhbGx5IG9ubHkgdXNlZCBmb3IgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIGV4cGFuZCwgYXMgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBleHBhbmQgZm9yIGRlY3J5cHRpb24sIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIGV4cGFuZGVkIGtleS5cbiAqL1xuZm9yZ2UuYWVzLl9leHBhbmRLZXkgPSBmdW5jdGlvbihrZXksIGRlY3J5cHQpIHtcbiAgaWYoIWluaXQpIHtcbiAgICBpbml0aWFsaXplKCk7XG4gIH1cbiAgcmV0dXJuIF9leHBhbmRLZXkoa2V5LCBkZWNyeXB0KTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyBhIHNpbmdsZSBibG9jay4gVHlwaWNhbGx5IG9ubHkgdXNlZCBmb3IgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0gdyB0aGUgZXhwYW5kZWQga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpbnB1dCBhbiBhcnJheSBvZiBibG9jay1zaXplIDMyLWJpdCB3b3Jkcy5cbiAqIEBwYXJhbSBvdXRwdXQgYW4gYXJyYXkgb2YgYmxvY2stc2l6ZSAzMi1iaXQgd29yZHMuXG4gKiBAcGFyYW0gZGVjcnlwdCB0cnVlIHRvIGRlY3J5cHQsIGZhbHNlIHRvIGVuY3J5cHQuXG4gKi9cbmZvcmdlLmFlcy5fdXBkYXRlQmxvY2sgPSBfdXBkYXRlQmxvY2s7XG5cbi8qKiBSZWdpc3RlciBBRVMgYWxnb3JpdGhtcyAqKi9cblxucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1FQ0InLCBmb3JnZS5jaXBoZXIubW9kZXMuZWNiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtQ0JDJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmNiYyk7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUNGQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1PRkInLCBmb3JnZS5jaXBoZXIubW9kZXMub2ZiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtQ1RSJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmN0cik7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUdDTScsIGZvcmdlLmNpcGhlci5tb2Rlcy5nY20pO1xuXG5mdW5jdGlvbiByZWdpc3RlckFsZ29yaXRobShuYW1lLCBtb2RlKSB7XG4gIHZhciBmYWN0b3J5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBmb3JnZS5hZXMuQWxnb3JpdGhtKG5hbWUsIG1vZGUpO1xuICB9O1xuICBmb3JnZS5jaXBoZXIucmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgZmFjdG9yeSk7XG59XG5cbi8qKiBBRVMgaW1wbGVtZW50YXRpb24gKiovXG5cbnZhciBpbml0ID0gZmFsc2U7IC8vIG5vdCB5ZXQgaW5pdGlhbGl6ZWRcbnZhciBOYiA9IDQ7ICAgICAgIC8vIG51bWJlciBvZiB3b3JkcyBjb21wcmlzaW5nIHRoZSBzdGF0ZSAoQUVTID0gNClcbnZhciBzYm94OyAgICAgICAgIC8vIG5vbi1saW5lYXIgc3Vic3RpdHV0aW9uIHRhYmxlIHVzZWQgaW4ga2V5IGV4cGFuc2lvblxudmFyIGlzYm94OyAgICAgICAgLy8gaW52ZXJzaW9uIG9mIHNib3hcbnZhciByY29uOyAgICAgICAgIC8vIHJvdW5kIGNvbnN0YW50IHdvcmQgYXJyYXlcbnZhciBtaXg7ICAgICAgICAgIC8vIG1peC1jb2x1bW5zIHRhYmxlXG52YXIgaW1peDsgICAgICAgICAvLyBpbnZlcnNlIG1peC1jb2x1bW5zIHRhYmxlXG5cbi8qKlxuICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24sIGllOiBwcmVjb21wdXRlcyB0YWJsZXMgdG8gb3B0aW1pemUgZm9yIHNwZWVkLlxuICpcbiAqIE9uZSB3YXkgdG8gdW5kZXJzdGFuZCBob3cgQUVTIHdvcmtzIGlzIHRvIGltYWdpbmUgdGhhdCAnYWRkaXRpb24nIGFuZFxuICogJ211bHRpcGxpY2F0aW9uJyBhcmUgaW50ZXJmYWNlcyB0aGF0IHJlcXVpcmUgY2VydGFpbiBtYXRoZW1hdGljYWxcbiAqIHByb3BlcnRpZXMgdG8gaG9sZCB0cnVlIChpZTogdGhleSBhcmUgYXNzb2NpYXRpdmUpIGJ1dCB0aGV5IG1pZ2h0IGhhdmVcbiAqIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvbnMgYW5kIHByb2R1Y2UgZGlmZmVyZW50IGtpbmRzIG9mIHJlc3VsdHMgLi4uXG4gKiBwcm92aWRlZCB0aGF0IHRoZWlyIG1hdGhlbWF0aWNhbCBwcm9wZXJ0aWVzIHJlbWFpbiB0cnVlLiBBRVMgZGVmaW5lc1xuICogaXRzIG93biBtZXRob2RzIG9mIGFkZGl0aW9uIGFuZCBtdWx0aXBsaWNhdGlvbiBidXQga2VlcHMgc29tZSBpbXBvcnRhbnRcbiAqIHByb3BlcnRpZXMgdGhlIHNhbWUsIGllOiBhc3NvY2lhdGl2aXR5IGFuZCBkaXN0cmlidXRpdml0eS4gVGhlXG4gKiBleHBsYW5hdGlvbiBiZWxvdyB0cmllcyB0byBzaGVkIHNvbWUgbGlnaHQgb24gaG93IEFFUyBkZWZpbmVzIGFkZGl0aW9uXG4gKiBhbmQgbXVsdGlwbGljYXRpb24gb2YgYnl0ZXMgYW5kIDMyLWJpdCB3b3JkcyBpbiBvcmRlciB0byBwZXJmb3JtIGl0c1xuICogZW5jcnlwdGlvbiBhbmQgZGVjcnlwdGlvbiBhbGdvcml0aG1zLlxuICpcbiAqIFRoZSBiYXNpY3M6XG4gKlxuICogVGhlIEFFUyBhbGdvcml0aG0gdmlld3MgYnl0ZXMgYXMgYmluYXJ5IHJlcHJlc2VudGF0aW9ucyBvZiBwb2x5bm9taWFsc1xuICogdGhhdCBoYXZlIGVpdGhlciAxIG9yIDAgYXMgdGhlIGNvZWZmaWNpZW50cy4gSXQgZGVmaW5lcyB0aGUgYWRkaXRpb25cbiAqIG9yIHN1YnRyYWN0aW9uIG9mIHR3byBieXRlcyBhcyB0aGUgWE9SIG9wZXJhdGlvbi4gSXQgYWxzbyBkZWZpbmVzIHRoZVxuICogbXVsdGlwbGljYXRpb24gb2YgdHdvIGJ5dGVzIGFzIGEgZmluaXRlIGZpZWxkIHJlZmVycmVkIHRvIGFzIEdGKDJeOClcbiAqIChOb3RlOiAnR0YnIG1lYW5zIFwiR2Fsb2lzIEZpZWxkXCIgd2hpY2ggaXMgYSBmaWVsZCB0aGF0IGNvbnRhaW5zIGEgZmluaXRlXG4gKiBudW1iZXIgb2YgZWxlbWVudHMgc28gR0YoMl44KSBoYXMgMjU2IGVsZW1lbnRzKS5cbiAqXG4gKiBUaGlzIG1lYW5zIHRoYXQgYW55IHR3byBieXRlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYmluYXJ5IHBvbHlub21pYWxzO1xuICogd2hlbiB0aGV5IG11bHRpcGxpZWQgdG9nZXRoZXIgYW5kIG1vZHVsYXJseSByZWR1Y2VkIGJ5IGFuIGlycmVkdWNpYmxlXG4gKiBwb2x5bm9taWFsIG9mIHRoZSA4dGggZGVncmVlLCB0aGUgcmVzdWx0cyBhcmUgdGhlIGZpZWxkIEdGKDJeOCkuIFRoZVxuICogc3BlY2lmaWMgaXJyZWR1Y2libGUgcG9seW5vbWlhbCB0aGF0IEFFUyB1c2VzIGluIGhleGFkZWNpbWFsIGlzIDB4MTFiLlxuICogVGhpcyBtdWx0aXBsaWNhdGlvbiBpcyBhc3NvY2lhdGl2ZSB3aXRoIDB4MDEgYXMgdGhlIGlkZW50aXR5OlxuICpcbiAqIChiICogMHgwMSA9IEdGKGIsIDB4MDEpID0gYikuXG4gKlxuICogVGhlIG9wZXJhdGlvbiBHRihiLCAweDAyKSBjYW4gYmUgcGVyZm9ybWVkIGF0IHRoZSBieXRlIGxldmVsIGJ5IGxlZnRcbiAqIHNoaWZ0aW5nIGIgb25jZSBhbmQgdGhlbiBYT1InaW5nIGl0ICh0byBwZXJmb3JtIHRoZSBtb2R1bGFyIHJlZHVjdGlvbilcbiAqIHdpdGggMHgxMWIgaWYgYiBpcyA+PSAxMjguIFJlcGVhdGVkIGFwcGxpY2F0aW9uIG9mIHRoZSBtdWx0aXBsaWNhdGlvblxuICogb2YgMHgwMiBjYW4gYmUgdXNlZCB0byBpbXBsZW1lbnQgdGhlIG11bHRpcGxpY2F0aW9uIG9mIGFueSB0d28gYnl0ZXMuXG4gKlxuICogRm9yIGluc3RhbmNlLCBtdWx0aXBseWluZyAweDU3IGFuZCAweDEzLCBkZW5vdGVkIGFzIEdGKDB4NTcsIDB4MTMpLCBjYW5cbiAqIGJlIHBlcmZvcm1lZCBieSBmYWN0b3JpbmcgMHgxMyBpbnRvIDB4MDEsIDB4MDIsIGFuZCAweDEwLiBUaGVuIHRoZXNlXG4gKiBmYWN0b3JzIGNhbiBlYWNoIGJlIG11bHRpcGxpZWQgYnkgMHg1NyBhbmQgdGhlbiBhZGRlZCB0b2dldGhlci4gVG8gZG9cbiAqIHRoZSBtdWx0aXBsaWNhdGlvbiwgdmFsdWVzIGZvciAweDU3IG11bHRpcGxpZWQgYnkgZWFjaCBvZiB0aGVzZSAzIGZhY3RvcnNcbiAqIGNhbiBiZSBwcmVjb21wdXRlZCBhbmQgc3RvcmVkIGluIGEgdGFibGUuIFRvIGFkZCB0aGVtLCB0aGUgdmFsdWVzIGZyb21cbiAqIHRoZSB0YWJsZSBhcmUgWE9SJ2QgdG9nZXRoZXIuXG4gKlxuICogQUVTIGFsc28gZGVmaW5lcyBhZGRpdGlvbiBhbmQgbXVsdGlwbGljYXRpb24gb2Ygd29yZHMsIHRoYXQgaXMgNC1ieXRlXG4gKiBudW1iZXJzIHJlcHJlc2VudGVkIGFzIHBvbHlub21pYWxzIG9mIDMgZGVncmVlcyB3aGVyZSB0aGUgY29lZmZpY2llbnRzXG4gKiBhcmUgdGhlIHZhbHVlcyBvZiB0aGUgYnl0ZXMuXG4gKlxuICogVGhlIHdvcmQgW2EwLCBhMSwgYTIsIGEzXSBpcyBhIHBvbHlub21pYWwgYTN4XjMgKyBhMnheMiArIGExeCArIGEwLlxuICpcbiAqIEFkZGl0aW9uIGlzIHBlcmZvcm1lZCBieSBYT1InaW5nIGxpa2UgcG93ZXJzIG9mIHguIE11bHRpcGxpY2F0aW9uXG4gKiBpcyBwZXJmb3JtZWQgaW4gdHdvIHN0ZXBzLCB0aGUgZmlyc3QgaXMgYW4gYWxnZWJyaWFjIGV4cGFuc2lvbiBhc1xuICogeW91IHdvdWxkIGRvIG5vcm1hbGx5ICh3aGVyZSBhZGRpdGlvbiBpcyBYT1IpLiBCdXQgdGhlIHJlc3VsdCBpc1xuICogYSBwb2x5bm9taWFsIGxhcmdlciB0aGFuIDMgZGVncmVlcyBhbmQgdGh1cyBpdCBjYW5ub3QgZml0IGluIGEgd29yZC4gU29cbiAqIG5leHQgdGhlIHJlc3VsdCBpcyBtb2R1bGFybHkgcmVkdWNlZCBieSBhbiBBRVMtc3BlY2lmaWMgcG9seW5vbWlhbCBvZlxuICogZGVncmVlIDQgd2hpY2ggd2lsbCBhbHdheXMgcHJvZHVjZSBhIHBvbHlub21pYWwgb2YgbGVzcyB0aGFuIDQgZGVncmVlc1xuICogc3VjaCB0aGF0IGl0IHdpbGwgZml0IGluIGEgd29yZC4gSW4gQUVTLCB0aGlzIHBvbHlub21pYWwgaXMgeF40ICsgMS5cbiAqXG4gKiBUaGUgbW9kdWxhciBwcm9kdWN0IG9mIHR3byBwb2x5bm9taWFscyAnYScgYW5kICdiJyBpcyB0aHVzOlxuICpcbiAqIGQoeCkgPSBkM3heMyArIGQyeF4yICsgZDF4ICsgZDBcbiAqIHdpdGhcbiAqIGQwID0gR0YoYTAsIGIwKSBeIEdGKGEzLCBiMSkgXiBHRihhMiwgYjIpIF4gR0YoYTEsIGIzKVxuICogZDEgPSBHRihhMSwgYjApIF4gR0YoYTAsIGIxKSBeIEdGKGEzLCBiMikgXiBHRihhMiwgYjMpXG4gKiBkMiA9IEdGKGEyLCBiMCkgXiBHRihhMSwgYjEpIF4gR0YoYTAsIGIyKSBeIEdGKGEzLCBiMylcbiAqIGQzID0gR0YoYTMsIGIwKSBeIEdGKGEyLCBiMSkgXiBHRihhMSwgYjIpIF4gR0YoYTAsIGIzKVxuICpcbiAqIEFzIGEgbWF0cml4OlxuICpcbiAqIFtkMF0gPSBbYTAgYTMgYTIgYTFdW2IwXVxuICogW2QxXSAgIFthMSBhMCBhMyBhMl1bYjFdXG4gKiBbZDJdICAgW2EyIGExIGEwIGEzXVtiMl1cbiAqIFtkM10gICBbYTMgYTIgYTEgYTBdW2IzXVxuICpcbiAqIFNwZWNpYWwgcG9seW5vbWlhbHMgZGVmaW5lZCBieSBBRVMgKDB4MDIgPT0gezAyfSk6XG4gKiBhKHgpICAgID0gezAzfXheMyArIHswMX14XjIgKyB7MDF9eCArIHswMn1cbiAqIGFeLTEoeCkgPSB7MGJ9eF4zICsgezBkfXheMiArIHswOX14ICsgezBlfS5cbiAqXG4gKiBUaGVzZSBwb2x5bm9taWFscyBhcmUgdXNlZCBpbiB0aGUgTWl4Q29sdW1ucygpIGFuZCBJbnZlcnNlTWl4Q29sdW1ucygpXG4gKiBvcGVyYXRpb25zLCByZXNwZWN0aXZlbHksIHRvIGNhdXNlIGVhY2ggZWxlbWVudCBpbiB0aGUgc3RhdGUgdG8gYWZmZWN0XG4gKiB0aGUgb3V0cHV0IChyZWZlcnJlZCB0byBhcyBkaWZmdXNpbmcpLlxuICpcbiAqIFJvdFdvcmQoKSB1c2VzOiBhMCA9IGExID0gYTIgPSB7MDB9IGFuZCBhMyA9IHswMX0sIHdoaWNoIGlzIHRoZVxuICogcG9seW5vbWlhbCB4My5cbiAqXG4gKiBUaGUgU2hpZnRSb3dzKCkgbWV0aG9kIG1vZGlmaWVzIHRoZSBsYXN0IDMgcm93cyBpbiB0aGUgc3RhdGUgKHdoZXJlXG4gKiB0aGUgc3RhdGUgaXMgNCB3b3JkcyB3aXRoIDQgYnl0ZXMgcGVyIHdvcmQpIGJ5IHNoaWZ0aW5nIGJ5dGVzIGN5Y2xpY2FsbHkuXG4gKiBUaGUgMXN0IGJ5dGUgaW4gdGhlIHNlY29uZCByb3cgaXMgbW92ZWQgdG8gdGhlIGVuZCBvZiB0aGUgcm93LiBUaGUgMXN0XG4gKiBhbmQgMm5kIGJ5dGVzIGluIHRoZSB0aGlyZCByb3cgYXJlIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhlIHJvdy4gVGhlIDFzdCxcbiAqIDJuZCwgYW5kIDNyZCBieXRlcyBhcmUgbW92ZWQgaW4gdGhlIGZvdXJ0aCByb3cuXG4gKlxuICogTW9yZSBkZXRhaWxzIG9uIGhvdyBBRVMgYXJpdGhtZXRpYyB3b3JrczpcbiAqXG4gKiBJbiB0aGUgcG9seW5vbWlhbCByZXByZXNlbnRhdGlvbiBvZiBiaW5hcnkgbnVtYmVycywgWE9SIHBlcmZvcm1zIGFkZGl0aW9uXG4gKiBhbmQgc3VidHJhY3Rpb24gYW5kIG11bHRpcGxpY2F0aW9uIGluIEdGKDJeOCkgZGVub3RlZCBhcyBHRihhLCBiKVxuICogY29ycmVzcG9uZHMgd2l0aCB0aGUgbXVsdGlwbGljYXRpb24gb2YgcG9seW5vbWlhbHMgbW9kdWxvIGFuIGlycmVkdWNpYmxlXG4gKiBwb2x5bm9taWFsIG9mIGRlZ3JlZSA4LiBJbiBvdGhlciB3b3JkcywgZm9yIEFFUywgR0YoYSwgYikgd2lsbCBtdWx0aXBseVxuICogcG9seW5vbWlhbCAnYScgd2l0aCBwb2x5bm9taWFsICdiJyBhbmQgdGhlbiBkbyBhIG1vZHVsYXIgcmVkdWN0aW9uIGJ5XG4gKiBhbiBBRVMtc3BlY2lmaWMgaXJyZWR1Y2libGUgcG9seW5vbWlhbCBvZiBkZWdyZWUgOC5cbiAqXG4gKiBBIHBvbHlub21pYWwgaXMgaXJyZWR1Y2libGUgaWYgaXRzIG9ubHkgZGl2aXNvcnMgYXJlIG9uZSBhbmQgaXRzZWxmLiBGb3JcbiAqIHRoZSBBRVMgYWxnb3JpdGhtLCB0aGlzIGlycmVkdWNpYmxlIHBvbHlub21pYWwgaXM6XG4gKlxuICogbSh4KSA9IHheOCArIHheNCArIHheMyArIHggKyAxLFxuICpcbiAqIG9yIHswMX17MWJ9IGluIGhleGFkZWNpbWFsIG5vdGF0aW9uLCB3aGVyZSBlYWNoIGNvZWZmaWNpZW50IGlzIGEgYml0OlxuICogMTAwMDExMDExID0gMjgzID0gMHgxMWIuXG4gKlxuICogRm9yIGV4YW1wbGUsIEdGKDB4NTcsIDB4ODMpID0gMHhjMSBiZWNhdXNlXG4gKlxuICogMHg1NyA9IDg3ICA9IDAxMDEwMTExID0geF42ICsgeF40ICsgeF4yICsgeCArIDFcbiAqIDB4ODUgPSAxMzEgPSAxMDAwMDEwMSA9IHheNyArIHggKyAxXG4gKlxuICogKHheNiArIHheNCArIHheMiArIHggKyAxKSAqICh4XjcgKyB4ICsgMSlcbiAqID0gIHheMTMgKyB4XjExICsgeF45ICsgeF44ICsgeF43ICtcbiAqICAgIHheNyArIHheNSArIHheMyArIHheMiArIHggK1xuICogICAgeF42ICsgeF40ICsgeF4yICsgeCArIDFcbiAqID0gIHheMTMgKyB4XjExICsgeF45ICsgeF44ICsgeF42ICsgeF41ICsgeF40ICsgeF4zICsgMSA9IHlcbiAqICAgIHkgbW9kdWxvICh4XjggKyB4XjQgKyB4XjMgKyB4ICsgMSlcbiAqID0gIHheNyArIHheNiArIDEuXG4gKlxuICogVGhlIG1vZHVsYXIgcmVkdWN0aW9uIGJ5IG0oeCkgZ3VhcmFudGVlcyB0aGUgcmVzdWx0IHdpbGwgYmUgYSBiaW5hcnlcbiAqIHBvbHlub21pYWwgb2YgbGVzcyB0aGFuIGRlZ3JlZSA4LCBzbyB0aGF0IGl0IGNhbiBmaXQgaW4gYSBieXRlLlxuICpcbiAqIFRoZSBvcGVyYXRpb24gdG8gbXVsdGlwbHkgYSBiaW5hcnkgcG9seW5vbWlhbCBiIHdpdGggeCAodGhlIHBvbHlub21pYWxcbiAqIHggaW4gYmluYXJ5IHJlcHJlc2VudGF0aW9uIGlzIDAwMDAwMDEwKSBpczpcbiAqXG4gKiBiXzd4XjggKyBiXzZ4XjcgKyBiXzV4XjYgKyBiXzR4XjUgKyBiXzN4XjQgKyBiXzJ4XjMgKyBiXzF4XjIgKyBiXzB4XjFcbiAqXG4gKiBUbyBnZXQgR0YoYiwgeCkgd2UgbXVzdCByZWR1Y2UgdGhhdCBieSBtKHgpLiBJZiBiXzcgaXMgMCAodGhhdCBpcyB0aGVcbiAqIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGlzIDAgaW4gYikgdGhlbiB0aGUgcmVzdWx0IGlzIGFscmVhZHkgcmVkdWNlZC4gSWZcbiAqIGl0IGlzIDEsIHRoZW4gd2UgY2FuIHJlZHVjZSBpdCBieSBzdWJ0cmFjdGluZyBtKHgpIHZpYSBhbiBYT1IuXG4gKlxuICogSXQgZm9sbG93cyB0aGF0IG11bHRpcGxpY2F0aW9uIGJ5IHggKDAwMDAwMDEwIG9yIDB4MDIpIGNhbiBiZSBpbXBsZW1lbnRlZFxuICogYnkgcGVyZm9ybWluZyBhIGxlZnQgc2hpZnQgZm9sbG93ZWQgYnkgYSBjb25kaXRpb25hbCBiaXR3aXNlIFhPUiB3aXRoXG4gKiAweDFiLiBUaGlzIG9wZXJhdGlvbiBvbiBieXRlcyBpcyBkZW5vdGVkIGJ5IHh0aW1lKCkuIE11bHRpcGxpY2F0aW9uIGJ5XG4gKiBoaWdoZXIgcG93ZXJzIG9mIHggY2FuIGJlIGltcGxlbWVudGVkIGJ5IHJlcGVhdGVkIGFwcGxpY2F0aW9uIG9mIHh0aW1lKCkuXG4gKlxuICogQnkgYWRkaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLCBtdWx0aXBsaWNhdGlvbiBieSBhbnkgY29uc3RhbnQgY2FuIGJlXG4gKiBpbXBsZW1lbnRlZC4gRm9yIGluc3RhbmNlOlxuICpcbiAqIEdGKDB4NTcsIDB4MTMpID0gMHhmZSBiZWNhdXNlOlxuICpcbiAqIHh0aW1lKGIpID0gKGIgJiAxMjgpID8gKGIgPDwgMSBeIDB4MTFiKSA6IChiIDw8IDEpXG4gKlxuICogTm90ZTogV2UgWE9SIHdpdGggMHgxMWIgaW5zdGVhZCBvZiAweDFiIGJlY2F1c2UgaW4gamF2YXNjcmlwdCBvdXJcbiAqIGRhdGF0eXBlIGZvciBiIGNhbiBiZSBsYXJnZXIgdGhhbiAxIGJ5dGUsIHNvIGEgbGVmdCBzaGlmdCB3aWxsIG5vdFxuICogYXV0b21hdGljYWxseSBlbGltaW5hdGUgYml0cyB0aGF0IG92ZXJmbG93IGEgYnl0ZSAuLi4gYnkgWE9SJ2luZyB0aGVcbiAqIG92ZXJmbG93IGJpdCB3aXRoIDEgKHRoZSBleHRyYSBvbmUgZnJvbSAweDExYikgd2UgemVybyBpdCBvdXQuXG4gKlxuICogR0YoMHg1NywgMHgwMikgPSB4dGltZSgweDU3KSA9IDB4YWVcbiAqIEdGKDB4NTcsIDB4MDQpID0geHRpbWUoMHhhZSkgPSAweDQ3XG4gKiBHRigweDU3LCAweDA4KSA9IHh0aW1lKDB4NDcpID0gMHg4ZVxuICogR0YoMHg1NywgMHgxMCkgPSB4dGltZSgweDhlKSA9IDB4MDdcbiAqXG4gKiBHRigweDU3LCAweDEzKSA9IEdGKDB4NTcsICgweDAxIF4gMHgwMiBeIDB4MTApKVxuICpcbiAqIEFuZCBieSB0aGUgZGlzdHJpYnV0aXZlIHByb3BlcnR5IChzaW5jZSBYT1IgaXMgYWRkaXRpb24gYW5kIEdGKCkgaXNcbiAqIG11bHRpcGxpY2F0aW9uKTpcbiAqXG4gKiA9IEdGKDB4NTcsIDB4MDEpIF4gR0YoMHg1NywgMHgwMikgXiBHRigweDU3LCAweDEwKVxuICogPSAweDU3IF4gMHhhZSBeIDB4MDdcbiAqID0gMHhmZS5cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgaW5pdCA9IHRydWU7XG5cbiAgLyogUG9wdWxhdGUgdGhlIFJjb24gdGFibGUuIFRoZXNlIGFyZSB0aGUgdmFsdWVzIGdpdmVuIGJ5XG4gICAgW3heKGktMSksezAwfSx7MDB9LHswMH1dIHdoZXJlIHheKGktMSkgYXJlIHBvd2VycyBvZiB4IChhbmQgeCA9IDB4MDIpXG4gICAgaW4gdGhlIGZpZWxkIG9mIEdGKDJeOCksIHdoZXJlIGkgc3RhcnRzIGF0IDEuXG5cbiAgICByY29uWzBdID0gWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdXG4gICAgcmNvblsxXSA9IFsweDAxLCAweDAwLCAweDAwLCAweDAwXSAyXigxLTEpID0gMl4wID0gMVxuICAgIHJjb25bMl0gPSBbMHgwMiwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oMi0xKSA9IDJeMSA9IDJcbiAgICAuLi5cbiAgICByY29uWzldICA9IFsweDFCLCAweDAwLCAweDAwLCAweDAwXSAyXig5LTEpICA9IDJeOCA9IDB4MUJcbiAgICByY29uWzEwXSA9IFsweDM2LCAweDAwLCAweDAwLCAweDAwXSAyXigxMC0xKSA9IDJeOSA9IDB4MzZcblxuICAgIFdlIG9ubHkgc3RvcmUgdGhlIGZpcnN0IGJ5dGUgYmVjYXVzZSBpdCBpcyB0aGUgb25seSBvbmUgdXNlZC5cbiAgKi9cbiAgcmNvbiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFCLCAweDM2XTtcblxuICAvLyBjb21wdXRlIHh0aW1lIHRhYmxlIHdoaWNoIG1hcHMgaSBvbnRvIEdGKGksIDB4MDIpXG4gIHZhciB4dGltZSA9IG5ldyBBcnJheSgyNTYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMTI4OyArK2kpIHtcbiAgICB4dGltZVtpXSA9IGkgPDwgMTtcbiAgICB4dGltZVtpICsgMTI4XSA9IChpICsgMTI4KSA8PCAxIF4gMHgxMUI7XG4gIH1cblxuICAvLyBjb21wdXRlIGFsbCBvdGhlciB0YWJsZXNcbiAgc2JveCA9IG5ldyBBcnJheSgyNTYpO1xuICBpc2JveCA9IG5ldyBBcnJheSgyNTYpO1xuICBtaXggPSBuZXcgQXJyYXkoNCk7XG4gIGltaXggPSBuZXcgQXJyYXkoNCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICBtaXhbaV0gPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBpbWl4W2ldID0gbmV3IEFycmF5KDI1Nik7XG4gIH1cbiAgdmFyIGUgPSAwLCBlaSA9IDAsIGUyLCBlNCwgZTgsIHN4LCBzeDIsIG1lLCBpbWU7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgIC8qIFdlIG5lZWQgdG8gZ2VuZXJhdGUgdGhlIFN1YkJ5dGVzKCkgc2JveCBhbmQgaXNib3ggdGFibGVzIHNvIHRoYXRcbiAgICAgIHdlIGNhbiBwZXJmb3JtIGJ5dGUgc3Vic3RpdHV0aW9ucy4gVGhpcyByZXF1aXJlcyB1cyB0byB0cmF2ZXJzZVxuICAgICAgYWxsIG9mIHRoZSBlbGVtZW50cyBpbiBHRiwgZmluZCB0aGVpciBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlcyxcbiAgICAgIGFuZCBhcHBseSB0byBlYWNoIHRoZSBmb2xsb3dpbmcgYWZmaW5lIHRyYW5zZm9ybWF0aW9uOlxuXG4gICAgICBiaScgPSBiaSBeIGIoaSArIDQpIG1vZCA4IF4gYihpICsgNSkgbW9kIDggXiBiKGkgKyA2KSBtb2QgOCBeXG4gICAgICAgICAgICBiKGkgKyA3KSBtb2QgOCBeIGNpXG4gICAgICBmb3IgMCA8PSBpIDwgOCwgd2hlcmUgYmkgaXMgdGhlIGl0aCBiaXQgb2YgdGhlIGJ5dGUsIGFuZCBjaSBpcyB0aGVcbiAgICAgIGl0aCBiaXQgb2YgYSBieXRlIGMgd2l0aCB0aGUgdmFsdWUgezYzfSBvciB7MDExMDAwMTF9LlxuXG4gICAgICBJdCBpcyBwb3NzaWJsZSB0byB0cmF2ZXJzZSBldmVyeSBwb3NzaWJsZSB2YWx1ZSBpbiBhIEdhbG9pcyBmaWVsZFxuICAgICAgdXNpbmcgd2hhdCBpcyByZWZlcnJlZCB0byBhcyBhICdnZW5lcmF0b3InLiBUaGVyZSBhcmUgbWFueVxuICAgICAgZ2VuZXJhdG9ycyAoMTI4IG91dCBvZiAyNTYpOiAzLDUsNiw5LDExLDgyIHRvIG5hbWUgYSBmZXcuIFRvIGZ1bGx5XG4gICAgICB0cmF2ZXJzZSBHRiB3ZSBpdGVyYXRlIDI1NSB0aW1lcywgbXVsdGlwbHlpbmcgYnkgb3VyIGdlbmVyYXRvclxuICAgICAgZWFjaCB0aW1lLlxuXG4gICAgICBPbiBlYWNoIGl0ZXJhdGlvbiB3ZSBjYW4gZGV0ZXJtaW5lIHRoZSBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIGZvclxuICAgICAgdGhlIGN1cnJlbnQgZWxlbWVudC5cblxuICAgICAgU3VwcG9zZSB0aGVyZSBpcyBhbiBlbGVtZW50IGluIEdGICdlJy4gRm9yIGEgZ2l2ZW4gZ2VuZXJhdG9yICdnJyxcbiAgICAgIGUgPSBnXnguIFRoZSBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIG9mIGUgaXMgZ14oMjU1IC0geCkuIEl0IHR1cm5zXG4gICAgICBvdXQgdGhhdCBpZiB1c2UgdGhlIGludmVyc2Ugb2YgYSBnZW5lcmF0b3IgYXMgYW5vdGhlciBnZW5lcmF0b3JcbiAgICAgIGl0IHdpbGwgcHJvZHVjZSBhbGwgb2YgdGhlIGNvcnJlc3BvbmRpbmcgbXVsdGlwbGljYXRpdmUgaW52ZXJzZXNcbiAgICAgIGF0IHRoZSBzYW1lIHRpbWUuIEZvciB0aGlzIHJlYXNvbiwgd2UgY2hvb3NlIDUgYXMgb3VyIGludmVyc2VcbiAgICAgIGdlbmVyYXRvciBiZWNhdXNlIGl0IG9ubHkgcmVxdWlyZXMgMiBtdWx0aXBsaWVzIGFuZCAxIGFkZCBhbmQgaXRzXG4gICAgICBpbnZlcnNlLCA4MiwgcmVxdWlyZXMgcmVsYXRpdmVseSBmZXcgb3BlcmF0aW9ucyBhcyB3ZWxsLlxuXG4gICAgICBJbiBvcmRlciB0byBhcHBseSB0aGUgYWZmaW5lIHRyYW5zZm9ybWF0aW9uLCB0aGUgbXVsdGlwbGljYXRpdmVcbiAgICAgIGludmVyc2UgJ2VpJyBvZiAnZScgY2FuIGJlIHJlcGVhdGVkbHkgWE9SJ2QgKDQgdGltZXMpIHdpdGggYVxuICAgICAgYml0LWN5Y2xpbmcgb2YgJ2VpJy4gVG8gZG8gdGhpcyAnZWknIGlzIGZpcnN0IHN0b3JlZCBpbiAncycgYW5kXG4gICAgICAneCcuIFRoZW4gJ3MnIGlzIGxlZnQgc2hpZnRlZCBhbmQgdGhlIGhpZ2ggYml0IG9mICdzJyBpcyBtYWRlIHRoZVxuICAgICAgbG93IGJpdC4gVGhlIHJlc3VsdGluZyB2YWx1ZSBpcyBzdG9yZWQgaW4gJ3MnLiBUaGVuICd4JyBpcyBYT1InZFxuICAgICAgd2l0aCAncycgYW5kIHN0b3JlZCBpbiAneCcuIE9uIGVhY2ggc3Vic2VxdWVudCBpdGVyYXRpb24gdGhlIHNhbWVcbiAgICAgIG9wZXJhdGlvbiBpcyBwZXJmb3JtZWQuIFdoZW4gNCBpdGVyYXRpb25zIGFyZSBjb21wbGV0ZSwgJ3gnIGlzXG4gICAgICBYT1InZCB3aXRoICdjJyAoMHg2MykgYW5kIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBpcyBzdG9yZWQgaW4gJ3gnLlxuICAgICAgRm9yIGV4YW1wbGU6XG5cbiAgICAgIHMgPSAwMTAwMDAwMVxuICAgICAgeCA9IDAxMDAwMDAxXG5cbiAgICAgIGl0ZXJhdGlvbiAxOiBzID0gMTAwMDAwMTAsIHggXj0gc1xuICAgICAgaXRlcmF0aW9uIDI6IHMgPSAwMDAwMDEwMSwgeCBePSBzXG4gICAgICBpdGVyYXRpb24gMzogcyA9IDAwMDAxMDEwLCB4IF49IHNcbiAgICAgIGl0ZXJhdGlvbiA0OiBzID0gMDAwMTAxMDAsIHggXj0gc1xuICAgICAgeCBePSAweDYzXG5cbiAgICAgIFRoaXMgY2FuIGJlIGRvbmUgd2l0aCBhIGxvb3Agd2hlcmUgcyA9IChzIDw8IDEpIHwgKHMgPj4gNykuIEhvd2V2ZXIsXG4gICAgICBpdCBjYW4gYWxzbyBiZSBkb25lIGJ5IHVzaW5nIGEgc2luZ2xlIDE2LWJpdCAoaW4gdGhpcyBjYXNlIDMyLWJpdClcbiAgICAgIG51bWJlciAnc3gnLiBTaW5jZSBYT1IgaXMgYW4gYXNzb2NpYXRpdmUgb3BlcmF0aW9uLCB3ZSBjYW4gc2V0ICdzeCdcbiAgICAgIHRvICdlaScgYW5kIHRoZW4gWE9SIGl0IHdpdGggJ3N4JyBsZWZ0LXNoaWZ0ZWQgMSwyLDMsIGFuZCA0IHRpbWVzLlxuICAgICAgVGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0cyB3aWxsIGZsb3cgaW50byB0aGUgaGlnaCA4IGJpdCBwb3NpdGlvbnNcbiAgICAgIGFuZCBiZSBjb3JyZWN0bHkgWE9SJ2Qgd2l0aCBvbmUgYW5vdGhlci4gQWxsIHRoYXQgcmVtYWlucyB3aWxsIGJlXG4gICAgICB0byBjeWNsZSB0aGUgaGlnaCA4IGJpdHMgYnkgWE9SJ2luZyB0aGVtIGFsbCB3aXRoIHRoZSBsb3dlciA4IGJpdHNcbiAgICAgIGFmdGVyd2FyZHMuXG5cbiAgICAgIEF0IHRoZSBzYW1lIHRpbWUgd2UncmUgcG9wdWxhdGluZyBzYm94IGFuZCBpc2JveCB3ZSBjYW4gcHJlY29tcHV0ZVxuICAgICAgdGhlIG11bHRpcGxpY2F0aW9uIHdlJ2xsIG5lZWQgdG8gZG8gdG8gZG8gTWl4Q29sdW1ucygpIGxhdGVyLlxuICAgICovXG5cbiAgICAvLyBhcHBseSBhZmZpbmUgdHJhbnNmb3JtYXRpb25cbiAgICBzeCA9IGVpIF4gKGVpIDw8IDEpIF4gKGVpIDw8IDIpIF4gKGVpIDw8IDMpIF4gKGVpIDw8IDQpO1xuICAgIHN4ID0gKHN4ID4+IDgpIF4gKHN4ICYgMjU1KSBeIDB4NjM7XG5cbiAgICAvLyB1cGRhdGUgdGFibGVzXG4gICAgc2JveFtlXSA9IHN4O1xuICAgIGlzYm94W3N4XSA9IGU7XG5cbiAgICAvKiBNaXhpbmcgY29sdW1ucyBpcyBkb25lIHVzaW5nIG1hdHJpeCBtdWx0aXBsaWNhdGlvbi4gVGhlIGNvbHVtbnNcbiAgICAgIHRoYXQgYXJlIHRvIGJlIG1peGVkIGFyZSBlYWNoIGEgc2luZ2xlIHdvcmQgaW4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICBUaGUgc3RhdGUgaGFzIE5iIGNvbHVtbnMgKDQgY29sdW1ucykuIFRoZXJlZm9yZSBlYWNoIGNvbHVtbiBpcyBhXG4gICAgICA0IGJ5dGUgd29yZC4gU28gdG8gbWl4IHRoZSBjb2x1bW5zIGluIGEgc2luZ2xlIGNvbHVtbiAnYycgd2hlcmVcbiAgICAgIGl0cyByb3dzIGFyZSByMCwgcjEsIHIyLCBhbmQgcjMsIHdlIHVzZSB0aGUgZm9sbG93aW5nIG1hdHJpeFxuICAgICAgbXVsdGlwbGljYXRpb246XG5cbiAgICAgIFsyIDMgMSAxXSpbcjAsY109W3InMCxjXVxuICAgICAgWzEgMiAzIDFdIFtyMSxjXSBbcicxLGNdXG4gICAgICBbMSAxIDIgM10gW3IyLGNdIFtyJzIsY11cbiAgICAgIFszIDEgMSAyXSBbcjMsY10gW3InMyxjXVxuXG4gICAgICByMCwgcjEsIHIyLCBhbmQgcjMgYXJlIGVhY2ggMSBieXRlIG9mIG9uZSBvZiB0aGUgd29yZHMgaW4gdGhlXG4gICAgICBzdGF0ZSAoYSBjb2x1bW4pLiBUbyBkbyBtYXRyaXggbXVsdGlwbGljYXRpb24gZm9yIGVhY2ggbWl4ZWRcbiAgICAgIGNvbHVtbiBjJyB3ZSBtdWx0aXBseSB0aGUgY29ycmVzcG9uZGluZyByb3cgZnJvbSB0aGUgbGVmdCBtYXRyaXhcbiAgICAgIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgY29sdW1uIGZyb20gdGhlIHJpZ2h0IG1hdHJpeC4gSW4gdG90YWwsIHdlXG4gICAgICBnZXQgNCBlcXVhdGlvbnM6XG5cbiAgICAgIHIwLGMnID0gMipyMCxjICsgMypyMSxjICsgMSpyMixjICsgMSpyMyxjXG4gICAgICByMSxjJyA9IDEqcjAsYyArIDIqcjEsYyArIDMqcjIsYyArIDEqcjMsY1xuICAgICAgcjIsYycgPSAxKnIwLGMgKyAxKnIxLGMgKyAyKnIyLGMgKyAzKnIzLGNcbiAgICAgIHIzLGMnID0gMypyMCxjICsgMSpyMSxjICsgMSpyMixjICsgMipyMyxjXG5cbiAgICAgIEFzIHVzdWFsLCB0aGUgbXVsdGlwbGljYXRpb24gaXMgYXMgcHJldmlvdXNseSBkZWZpbmVkIGFuZCB0aGVcbiAgICAgIGFkZGl0aW9uIGlzIFhPUi4gSW4gb3JkZXIgdG8gb3B0aW1pemUgbWl4aW5nIGNvbHVtbnMgd2UgY2FuIHN0b3JlXG4gICAgICB0aGUgbXVsdGlwbGljYXRpb24gcmVzdWx0cyBpbiB0YWJsZXMuIElmIHlvdSB0aGluayBvZiB0aGUgd2hvbGVcbiAgICAgIGNvbHVtbiBhcyBhIHdvcmQgKGl0IG1pZ2h0IGhlbHAgdG8gdmlzdWFsaXplIGJ5IG1lbnRhbGx5IHJvdGF0aW5nXG4gICAgICB0aGUgZXF1YXRpb25zIGFib3ZlIGJ5IGNvdW50ZXJjbG9ja3dpc2UgOTAgZGVncmVlcykgdGhlbiB5b3UgY2FuXG4gICAgICBzZWUgdGhhdCBpdCB3b3VsZCBiZSB1c2VmdWwgdG8gbWFwIHRoZSBtdWx0aXBsaWNhdGlvbnMgcGVyZm9ybWVkIG9uXG4gICAgICBlYWNoIGJ5dGUgKHIwLCByMSwgcjIsIHIzKSBvbnRvIGEgd29yZCBhcyB3ZWxsLiBGb3IgaW5zdGFuY2UsIHdlXG4gICAgICBjb3VsZCBtYXAgMipyMCwxKnIwLDEqcjAsMypyMCBvbnRvIGEgd29yZCBieSBzdG9yaW5nIDIqcjAgaW4gdGhlXG4gICAgICBoaWdoZXN0IDggYml0cyBhbmQgMypyMCBpbiB0aGUgbG93ZXN0IDggYml0cyAod2l0aCB0aGUgb3RoZXIgdHdvXG4gICAgICByZXNwZWN0aXZlbHkgaW4gdGhlIG1pZGRsZSkuIFRoaXMgbWVhbnMgdGhhdCBhIHRhYmxlIGNhbiBiZVxuICAgICAgY29uc3RydWN0ZWQgdGhhdCB1c2VzIHIwIGFzIGFuIGluZGV4IHRvIHRoZSB3b3JkLiBXZSBjYW4gZG8gdGhlXG4gICAgICBzYW1lIHdpdGggcjEsIHIyLCBhbmQgcjMsIGNyZWF0aW5nIGEgdG90YWwgb2YgNCB0YWJsZXMuXG5cbiAgICAgIFRvIGNvbnN0cnVjdCBhIGZ1bGwgYycsIHdlIGNhbiBqdXN0IGxvb2sgdXAgZWFjaCBieXRlIG9mIGMgaW5cbiAgICAgIHRoZWlyIHJlc3BlY3RpdmUgdGFibGVzIGFuZCBYT1IgdGhlIHJlc3VsdHMgdG9nZXRoZXIuXG5cbiAgICAgIEFsc28sIHRvIGJ1aWxkIGVhY2ggdGFibGUgd2Ugb25seSBoYXZlIHRvIGNhbGN1bGF0ZSB0aGUgd29yZFxuICAgICAgZm9yIDIsMSwxLDMgZm9yIGV2ZXJ5IGJ5dGUgLi4uIHdoaWNoIHdlIGNhbiBkbyBvbiBlYWNoIGl0ZXJhdGlvblxuICAgICAgb2YgdGhpcyBsb29wIHNpbmNlIHdlIHdpbGwgaXRlcmF0ZSBvdmVyIGV2ZXJ5IGJ5dGUuIEFmdGVyIHdlIGhhdmVcbiAgICAgIGNhbGN1bGF0ZWQgMiwxLDEsMyB3ZSBjYW4gZ2V0IHRoZSByZXN1bHRzIGZvciB0aGUgb3RoZXIgdGFibGVzXG4gICAgICBieSBjeWNsaW5nIHRoZSBieXRlIGF0IHRoZSBlbmQgdG8gdGhlIGJlZ2lubmluZy4gRm9yIGluc3RhbmNlXG4gICAgICB3ZSBjYW4gdGFrZSB0aGUgcmVzdWx0IG9mIHRhYmxlIDIsMSwxLDMgYW5kIHByb2R1Y2UgdGFibGUgMywyLDEsMVxuICAgICAgYnkgbW92aW5nIHRoZSByaWdodCBtb3N0IGJ5dGUgdG8gdGhlIGxlZnQgbW9zdCBwb3NpdGlvbiBqdXN0IGxpa2VcbiAgICAgIGhvdyB5b3UgY2FuIGltYWdpbmUgdGhlIDMgbW92ZWQgb3V0IG9mIDIsMSwxLDMgYW5kIHRvIHRoZSBmcm9udFxuICAgICAgdG8gcHJvZHVjZSAzLDIsMSwxLlxuXG4gICAgICBUaGVyZSBpcyBhbm90aGVyIG9wdGltaXphdGlvbiBpbiB0aGF0IHRoZSBzYW1lIG11bHRpcGxlcyBvZlxuICAgICAgdGhlIGN1cnJlbnQgZWxlbWVudCB3ZSBuZWVkIGluIG9yZGVyIHRvIGFkdmFuY2Ugb3VyIGdlbmVyYXRvclxuICAgICAgdG8gdGhlIG5leHQgaXRlcmF0aW9uIGNhbiBiZSByZXVzZWQgaW4gcGVyZm9ybWluZyB0aGUgMiwxLDEsM1xuICAgICAgY2FsY3VsYXRpb24uIFdlIGFsc28gY2FsY3VsYXRlIHRoZSBpbnZlcnNlIG1peCBjb2x1bW4gdGFibGVzLFxuICAgICAgd2l0aCBlLDksZCxiIGJlaW5nIHRoZSBpbnZlcnNlIG9mIDIsMSwxLDMuXG5cbiAgICAgIFdoZW4gd2UncmUgZG9uZSwgYW5kIHdlIG5lZWQgdG8gYWN0dWFsbHkgbWl4IGNvbHVtbnMsIHRoZSBmaXJzdFxuICAgICAgYnl0ZSBvZiBlYWNoIHN0YXRlIHdvcmQgc2hvdWxkIGJlIHB1dCB0aHJvdWdoIG1peFswXSAoMiwxLDEsMyksXG4gICAgICB0aGUgc2Vjb25kIHRocm91Z2ggbWl4WzFdICgzLDIsMSwxKSBhbmQgc28gZm9ydGguIFRoZW4gdGhleSBzaG91bGRcbiAgICAgIGJlIFhPUidkIHRvZ2V0aGVyIHRvIHByb2R1Y2UgdGhlIGZ1bGx5IG1peGVkIGNvbHVtbi5cbiAgICAqL1xuXG4gICAgLy8gY2FsY3VsYXRlIG1peCBhbmQgaW1peCB0YWJsZSB2YWx1ZXNcbiAgICBzeDIgPSB4dGltZVtzeF07XG4gICAgZTIgPSB4dGltZVtlXTtcbiAgICBlNCA9IHh0aW1lW2UyXTtcbiAgICBlOCA9IHh0aW1lW2U0XTtcbiAgICBtZSA9XG4gICAgICAoc3gyIDw8IDI0KSBeICAvLyAyXG4gICAgICAoc3ggPDwgMTYpIF4gICAvLyAxXG4gICAgICAoc3ggPDwgOCkgXiAgICAvLyAxXG4gICAgICAoc3ggXiBzeDIpOyAgICAvLyAzXG4gICAgaW1lID1cbiAgICAgIChlMiBeIGU0IF4gZTgpIDw8IDI0IF4gIC8vIEUgKDE0KVxuICAgICAgKGUgXiBlOCkgPDwgMTYgXiAgICAgICAgLy8gOVxuICAgICAgKGUgXiBlNCBeIGU4KSA8PCA4IF4gICAgLy8gRCAoMTMpXG4gICAgICAoZSBeIGUyIF4gZTgpOyAgICAgICAgICAvLyBCICgxMSlcbiAgICAvLyBwcm9kdWNlIGVhY2ggb2YgdGhlIG1peCB0YWJsZXMgYnkgcm90YXRpbmcgdGhlIDIsMSwxLDMgdmFsdWVcbiAgICBmb3IodmFyIG4gPSAwOyBuIDwgNDsgKytuKSB7XG4gICAgICBtaXhbbl1bZV0gPSBtZTtcbiAgICAgIGltaXhbbl1bc3hdID0gaW1lO1xuICAgICAgLy8gY3ljbGUgdGhlIHJpZ2h0IG1vc3QgYnl0ZSB0byB0aGUgbGVmdCBtb3N0IHBvc2l0aW9uXG4gICAgICAvLyBpZTogMiwxLDEsMyBiZWNvbWVzIDMsMiwxLDFcbiAgICAgIG1lID0gbWUgPDwgMjQgfCBtZSA+Pj4gODtcbiAgICAgIGltZSA9IGltZSA8PCAyNCB8IGltZSA+Pj4gODtcbiAgICB9XG5cbiAgICAvLyBnZXQgbmV4dCBlbGVtZW50IGFuZCBpbnZlcnNlXG4gICAgaWYoZSA9PT0gMCkge1xuICAgICAgLy8gMSBpcyB0aGUgaW52ZXJzZSBvZiAxXG4gICAgICBlID0gZWkgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlID0gMmUgKyAyKjIqMiooMTBlKSkgPSBtdWx0aXBseSBlIGJ5IDgyIChjaG9zZW4gZ2VuZXJhdG9yKVxuICAgICAgLy8gZWkgPSBlaSArIDIqMiplaSA9IG11bHRpcGx5IGVpIGJ5IDUgKGludmVyc2UgZ2VuZXJhdG9yKVxuICAgICAgZSA9IGUyIF4geHRpbWVbeHRpbWVbeHRpbWVbZTIgXiBlOF1dXTtcbiAgICAgIGVpIF49IHh0aW1lW3h0aW1lW2VpXV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEga2V5IHNjaGVkdWxlIHVzaW5nIHRoZSBBRVMga2V5IGV4cGFuc2lvbiBhbGdvcml0aG0uXG4gKlxuICogVGhlIEFFUyBhbGdvcml0aG0gdGFrZXMgdGhlIENpcGhlciBLZXksIEssIGFuZCBwZXJmb3JtcyBhIEtleSBFeHBhbnNpb25cbiAqIHJvdXRpbmUgdG8gZ2VuZXJhdGUgYSBrZXkgc2NoZWR1bGUuIFRoZSBLZXkgRXhwYW5zaW9uIGdlbmVyYXRlcyBhIHRvdGFsXG4gKiBvZiBOYiooTnIgKyAxKSB3b3JkczogdGhlIGFsZ29yaXRobSByZXF1aXJlcyBhbiBpbml0aWFsIHNldCBvZiBOYiB3b3JkcyxcbiAqIGFuZCBlYWNoIG9mIHRoZSBOciByb3VuZHMgcmVxdWlyZXMgTmIgd29yZHMgb2Yga2V5IGRhdGEuIFRoZSByZXN1bHRpbmdcbiAqIGtleSBzY2hlZHVsZSBjb25zaXN0cyBvZiBhIGxpbmVhciBhcnJheSBvZiA0LWJ5dGUgd29yZHMsIGRlbm90ZWQgW3dpIF0sXG4gKiB3aXRoIGkgaW4gdGhlIHJhbmdlIDAgPD0gaSA8IE5iKE5yICsgMSkuXG4gKlxuICogS2V5RXhwYW5zaW9uKGJ5dGUga2V5WzQqTmtdLCB3b3JkIHdbTmIqKE5yKzEpXSwgTmspXG4gKiBBRVMtMTI4IChOYj00LCBOaz00LCBOcj0xMClcbiAqIEFFUy0xOTIgKE5iPTQsIE5rPTYsIE5yPTEyKVxuICogQUVTLTI1NiAoTmI9NCwgTms9OCwgTnI9MTQpXG4gKiBOb3RlOiBOcj1Oays2LlxuICpcbiAqIE5iIGlzIHRoZSBudW1iZXIgb2YgY29sdW1ucyAoMzItYml0IHdvcmRzKSBjb21wcmlzaW5nIHRoZSBTdGF0ZSAob3JcbiAqIG51bWJlciBvZiBieXRlcyBpbiBhIGJsb2NrKS4gRm9yIEFFUywgTmI9NC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gc2NoZWR1bGUgKGFzIGFuIGFycmF5IG9mIDMyLWJpdCB3b3JkcykuXG4gKiBAcGFyYW0gZGVjcnlwdCB0cnVlIHRvIG1vZGlmeSB0aGUga2V5IHNjaGVkdWxlIHRvIGRlY3J5cHQsIGZhbHNlIG5vdCB0by5cbiAqXG4gKiBAcmV0dXJuIHRoZSBnZW5lcmF0ZWQga2V5IHNjaGVkdWxlLlxuICovXG5mdW5jdGlvbiBfZXhwYW5kS2V5KGtleSwgZGVjcnlwdCkge1xuICAvLyBjb3B5IHRoZSBrZXkncyB3b3JkcyB0byBpbml0aWFsaXplIHRoZSBrZXkgc2NoZWR1bGVcbiAgdmFyIHcgPSBrZXkuc2xpY2UoMCk7XG5cbiAgLyogUm90V29yZCgpIHdpbGwgcm90YXRlIGEgd29yZCwgbW92aW5nIHRoZSBmaXJzdCBieXRlIHRvIHRoZSBsYXN0XG4gICAgYnl0ZSdzIHBvc2l0aW9uIChzaGlmdGluZyB0aGUgb3RoZXIgYnl0ZXMgbGVmdCkuXG5cbiAgICBXZSB3aWxsIGJlIGdldHRpbmcgdGhlIHZhbHVlIG9mIFJjb24gYXQgaSAvIE5rLiAnaScgd2lsbCBpdGVyYXRlXG4gICAgZnJvbSBOayB0byAoTmIgKiBOcisxKS4gTmsgPSA0ICg0IGJ5dGUga2V5KSwgTmIgPSA0ICg0IHdvcmRzIGluXG4gICAgYSBibG9jayksIE5yID0gTmsgKyA2ICgxMCkuIFRoZXJlZm9yZSAnaScgd2lsbCBpdGVyYXRlIGZyb21cbiAgICA0IHRvIDQ0IChleGNsdXNpdmUpLiBFYWNoIHRpbWUgd2UgaXRlcmF0ZSA0IHRpbWVzLCBpIC8gTmsgd2lsbFxuICAgIGluY3JlYXNlIGJ5IDEuIFdlIHVzZSBhIGNvdW50ZXIgaU5rIHRvIGtlZXAgdHJhY2sgb2YgdGhpcy5cbiAgICovXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgcm91bmRzIGV4cGFuZGluZyB0aGUga2V5XG4gIHZhciB0ZW1wLCBpTmsgPSAxO1xuICB2YXIgTmsgPSB3Lmxlbmd0aDtcbiAgdmFyIE5yMSA9IE5rICsgNiArIDE7XG4gIHZhciBlbmQgPSBOYiAqIE5yMTtcbiAgZm9yKHZhciBpID0gTms7IGkgPCBlbmQ7ICsraSkge1xuICAgIHRlbXAgPSB3W2kgLSAxXTtcbiAgICBpZihpICUgTmsgPT09IDApIHtcbiAgICAgIC8vIHRlbXAgPSBTdWJXb3JkKFJvdFdvcmQodGVtcCkpIF4gUmNvbltpIC8gTmtdXG4gICAgICB0ZW1wID1cbiAgICAgICAgc2JveFt0ZW1wID4+PiAxNiAmIDI1NV0gPDwgMjQgXlxuICAgICAgICBzYm94W3RlbXAgPj4+IDggJiAyNTVdIDw8IDE2IF5cbiAgICAgICAgc2JveFt0ZW1wICYgMjU1XSA8PCA4IF5cbiAgICAgICAgc2JveFt0ZW1wID4+PiAyNF0gXiAocmNvbltpTmtdIDw8IDI0KTtcbiAgICAgIGlOaysrO1xuICAgIH0gZWxzZSBpZihOayA+IDYgJiYgKGkgJSBOayA9PT0gNCkpIHtcbiAgICAgIC8vIHRlbXAgPSBTdWJXb3JkKHRlbXApXG4gICAgICB0ZW1wID1cbiAgICAgICAgc2JveFt0ZW1wID4+PiAyNF0gPDwgMjQgXlxuICAgICAgICBzYm94W3RlbXAgPj4+IDE2ICYgMjU1XSA8PCAxNiBeXG4gICAgICAgIHNib3hbdGVtcCA+Pj4gOCAmIDI1NV0gPDwgOCBeXG4gICAgICAgIHNib3hbdGVtcCAmIDI1NV07XG4gICAgfVxuICAgIHdbaV0gPSB3W2kgLSBOa10gXiB0ZW1wO1xuICB9XG5cbiAgLyogV2hlbiB3ZSBhcmUgdXBkYXRpbmcgYSBjaXBoZXIgYmxvY2sgd2UgYWx3YXlzIHVzZSB0aGUgY29kZSBwYXRoIGZvclxuICAgICBlbmNyeXB0aW9uIHdoZXRoZXIgd2UgYXJlIGRlY3J5cHRpbmcgb3Igbm90ICh0byBzaG9ydGVuIGNvZGUgYW5kXG4gICAgIHNpbXBsaWZ5IHRoZSBnZW5lcmF0aW9uIG9mIGxvb2sgdXAgdGFibGVzKS4gSG93ZXZlciwgYmVjYXVzZSB0aGVyZVxuICAgICBhcmUgZGlmZmVyZW5jZXMgaW4gdGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtLCBvdGhlciB0aGFuIGp1c3Qgc3dhcHBpbmdcbiAgICAgaW4gZGlmZmVyZW50IGxvb2sgdXAgdGFibGVzLCB3ZSBtdXN0IHRyYW5zZm9ybSBvdXIga2V5IHNjaGVkdWxlIHRvXG4gICAgIGFjY291bnQgZm9yIHRoZXNlIGNoYW5nZXM6XG5cbiAgICAgMS4gVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtIGdldHMgaXRzIGtleSByb3VuZHMgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgMi4gVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtIGFkZHMgdGhlIHJvdW5kIGtleSBiZWZvcmUgbWl4aW5nIGNvbHVtbnNcbiAgICAgICBpbnN0ZWFkIG9mIGFmdGVyd2FyZHMuXG5cbiAgICAgV2UgZG9uJ3QgbmVlZCB0byBtb2RpZnkgb3VyIGtleSBzY2hlZHVsZSB0byBoYW5kbGUgdGhlIGZpcnN0IGNhc2UsXG4gICAgIHdlIGNhbiBqdXN0IHRyYXZlcnNlIHRoZSBrZXkgc2NoZWR1bGUgaW4gcmV2ZXJzZSBvcmRlciB3aGVuIGRlY3J5cHRpbmcuXG5cbiAgICAgVGhlIHNlY29uZCBjYXNlIHJlcXVpcmVzIGEgbGl0dGxlIHdvcmsuXG5cbiAgICAgVGhlIHRhYmxlcyB3ZSBidWlsdCBmb3IgcGVyZm9ybWluZyByb3VuZHMgd2lsbCB0YWtlIGFuIGlucHV0IGFuZCB0aGVuXG4gICAgIHBlcmZvcm0gU3ViQnl0ZXMoKSBhbmQgTWl4Q29sdW1ucygpIG9yLCBmb3IgdGhlIGRlY3J5cHQgdmVyc2lvbixcbiAgICAgSW52U3ViQnl0ZXMoKSBhbmQgSW52TWl4Q29sdW1ucygpLiBCdXQgdGhlIGRlY3J5cHQgYWxnb3JpdGhtIHJlcXVpcmVzXG4gICAgIHVzIHRvIEFkZFJvdW5kS2V5KCkgYmVmb3JlIEludk1peENvbHVtbnMoKS4gVGhpcyBtZWFucyB3ZSdsbCBuZWVkIHRvXG4gICAgIGFwcGx5IHNvbWUgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSByb3VuZCBrZXkgdG8gaW52ZXJzZS1taXggaXRzIGNvbHVtbnNcbiAgICAgc28gdGhleSdsbCBiZSBjb3JyZWN0IGZvciBtb3ZpbmcgQWRkUm91bmRLZXkoKSB0byBhZnRlciB0aGUgc3RhdGUgaGFzXG4gICAgIGhhZCBpdHMgY29sdW1ucyBpbnZlcnNlLW1peGVkLlxuXG4gICAgIFRvIGludmVyc2UtbWl4IHRoZSBjb2x1bW5zIG9mIHRoZSBzdGF0ZSB3aGVuIHdlJ3JlIGRlY3J5cHRpbmcgd2UgdXNlIGFcbiAgICAgbG9va3VwIHRhYmxlIHRoYXQgd2lsbCBhcHBseSBJbnZTdWJCeXRlcygpIGFuZCBJbnZNaXhDb2x1bW5zKCkgYXQgdGhlXG4gICAgIHNhbWUgdGltZS4gSG93ZXZlciwgdGhlIHJvdW5kIGtleSdzIGJ5dGVzIGFyZSBub3QgaW52ZXJzZS1zdWJzdGl0dXRlZFxuICAgICBpbiB0aGUgZGVjcnlwdGlvbiBhbGdvcml0aG0uIFRvIGdldCBhcm91bmQgdGhpcyBwcm9ibGVtLCB3ZSBjYW4gZmlyc3RcbiAgICAgc3Vic3RpdHV0ZSB0aGUgYnl0ZXMgaW4gdGhlIHJvdW5kIGtleSBzbyB0aGF0IHdoZW4gd2UgYXBwbHkgdGhlXG4gICAgIHRyYW5zZm9ybWF0aW9uIHZpYSB0aGUgSW52U3ViQnl0ZXMoKStJbnZNaXhDb2x1bW5zKCkgdGFibGUsIGl0IHdpbGxcbiAgICAgdW5kbyBvdXIgc3Vic3RpdHV0aW9uIGxlYXZpbmcgdXMgd2l0aCB0aGUgb3JpZ2luYWwgdmFsdWUgdGhhdCB3ZVxuICAgICB3YW50IC0tIGFuZCB0aGVuIGludmVyc2UtbWl4IHRoYXQgdmFsdWUuXG5cbiAgICAgVGhpcyBjaGFuZ2Ugd2lsbCBjb3JyZWN0bHkgYWx0ZXIgb3VyIGtleSBzY2hlZHVsZSBzbyB0aGF0IHdlIGNhbiBYT1JcbiAgICAgZWFjaCByb3VuZCBrZXkgd2l0aCBvdXIgYWxyZWFkeSB0cmFuc2Zvcm1lZCBkZWNyeXB0aW9uIHN0YXRlLiBUaGlzXG4gICAgIGFsbG93cyB1cyB0byB1c2UgdGhlIHNhbWUgY29kZSBwYXRoIGFzIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobS5cblxuICAgICBXZSBtYWtlIG9uZSBtb3JlIGNoYW5nZSB0byB0aGUgZGVjcnlwdGlvbiBrZXkuIFNpbmNlIHRoZSBkZWNyeXB0aW9uXG4gICAgIGFsZ29yaXRobSBydW5zIGluIHJldmVyc2UgZnJvbSB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0sIHdlIHJldmVyc2VcbiAgICAgdGhlIG9yZGVyIG9mIHRoZSByb3VuZCBrZXlzIHRvIGF2b2lkIGhhdmluZyB0byBpdGVyYXRlIG92ZXIgdGhlIGtleVxuICAgICBzY2hlZHVsZSBiYWNrd2FyZHMgd2hlbiBydW5uaW5nIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSBsYXRlciBpblxuICAgICBkZWNyeXB0aW9uIG1vZGUuIEluIGFkZGl0aW9uIHRvIHJldmVyc2luZyB0aGUgb3JkZXIgb2YgdGhlIHJvdW5kIGtleXMsXG4gICAgIHdlIGFsc28gc3dhcCBlYWNoIHJvdW5kIGtleSdzIDJuZCBhbmQgNHRoIHJvd3MuIFNlZSB0aGUgY29tbWVudHNcbiAgICAgc2VjdGlvbiB3aGVyZSByb3VuZHMgYXJlIHBlcmZvcm1lZCBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHdoeSB0aGlzIGlzXG4gICAgIGRvbmUuIFRoZXNlIGNoYW5nZXMgYXJlIGRvbmUgaW5saW5lIHdpdGggdGhlIG90aGVyIHN1YnN0aXR1dGlvblxuICAgICBkZXNjcmliZWQgYWJvdmUuXG4gICovXG4gIGlmKGRlY3J5cHQpIHtcbiAgICB2YXIgdG1wO1xuICAgIHZhciBtMCA9IGltaXhbMF07XG4gICAgdmFyIG0xID0gaW1peFsxXTtcbiAgICB2YXIgbTIgPSBpbWl4WzJdO1xuICAgIHZhciBtMyA9IGltaXhbM107XG4gICAgdmFyIHduZXcgPSB3LnNsaWNlKDApO1xuICAgIGVuZCA9IHcubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIHdpID0gZW5kIC0gTmI7IGkgPCBlbmQ7IGkgKz0gTmIsIHdpIC09IE5iKSB7XG4gICAgICAvLyBkbyBub3Qgc3ViIHRoZSBmaXJzdCBvciBsYXN0IHJvdW5kIGtleSAocm91bmQga2V5cyBhcmUgTmJcbiAgICAgIC8vIHdvcmRzKSBhcyBubyBjb2x1bW4gbWl4aW5nIGlzIHBlcmZvcm1lZCBiZWZvcmUgdGhleSBhcmUgYWRkZWQsXG4gICAgICAvLyBidXQgZG8gY2hhbmdlIHRoZSBrZXkgb3JkZXJcbiAgICAgIGlmKGkgPT09IDAgfHwgaSA9PT0gKGVuZCAtIE5iKSkge1xuICAgICAgICB3bmV3W2ldID0gd1t3aV07XG4gICAgICAgIHduZXdbaSArIDFdID0gd1t3aSArIDNdO1xuICAgICAgICB3bmV3W2kgKyAyXSA9IHdbd2kgKyAyXTtcbiAgICAgICAgd25ld1tpICsgM10gPSB3W3dpICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdWJzdGl0dXRlIGVhY2ggcm91bmQga2V5IGJ5dGUgYmVjYXVzZSB0aGUgaW52ZXJzZS1taXhcbiAgICAgICAgLy8gdGFibGUgd2lsbCBpbnZlcnNlLXN1YnN0aXR1dGUgaXQgKGVmZmVjdGl2ZWx5IGNhbmNlbCB0aGVcbiAgICAgICAgLy8gc3Vic3RpdHV0aW9uIGJlY2F1c2Ugcm91bmQga2V5IGJ5dGVzIGFyZW4ndCBzdWInZCBpblxuICAgICAgICAvLyBkZWNyeXB0aW9uIG1vZGUpIGFuZCBzd2FwIGluZGV4ZXMgMyBhbmQgMVxuICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgTmI7ICsrbikge1xuICAgICAgICAgIHRtcCA9IHdbd2kgKyBuXTtcbiAgICAgICAgICB3bmV3W2kgKyAoMyYtbildID1cbiAgICAgICAgICAgIG0wW3Nib3hbdG1wID4+PiAyNF1dIF5cbiAgICAgICAgICAgIG0xW3Nib3hbdG1wID4+PiAxNiAmIDI1NV1dIF5cbiAgICAgICAgICAgIG0yW3Nib3hbdG1wID4+PiA4ICYgMjU1XV0gXlxuICAgICAgICAgICAgbTNbc2JveFt0bXAgJiAyNTVdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB3ID0gd25ldztcbiAgfVxuXG4gIHJldHVybiB3O1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2sgKDE2IGJ5dGVzKSB1c2luZyBBRVMuIFRoZSB1cGRhdGUgd2lsbCBlaXRoZXJcbiAqIGVuY3J5cHQgb3IgZGVjcnlwdCB0aGUgYmxvY2suXG4gKlxuICogQHBhcmFtIHcgdGhlIGtleSBzY2hlZHVsZS5cbiAqIEBwYXJhbSBpbnB1dCB0aGUgaW5wdXQgYmxvY2sgKGFuIGFycmF5IG9mIDMyLWJpdCB3b3JkcykuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSB1cGRhdGVkIG91dHB1dCBibG9jay5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gZGVjcnlwdCB0aGUgYmxvY2ssIGZhbHNlIHRvIGVuY3J5cHQgaXQuXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGVCbG9jayh3LCBpbnB1dCwgb3V0cHV0LCBkZWNyeXB0KSB7XG4gIC8qXG4gIENpcGhlcihieXRlIGluWzQqTmJdLCBieXRlIG91dFs0Kk5iXSwgd29yZCB3W05iKihOcisxKV0pXG4gIGJlZ2luXG4gICAgYnl0ZSBzdGF0ZVs0LE5iXVxuICAgIHN0YXRlID0gaW5cbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICBmb3Igcm91bmQgPSAxIHN0ZXAgMSB0byBOci0xXG4gICAgICBTdWJCeXRlcyhzdGF0ZSlcbiAgICAgIFNoaWZ0Um93cyhzdGF0ZSlcbiAgICAgIE1peENvbHVtbnMoc3RhdGUpXG4gICAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tyb3VuZCpOYiwgKHJvdW5kKzEpKk5iLTFdKVxuICAgIGVuZCBmb3JcbiAgICBTdWJCeXRlcyhzdGF0ZSlcbiAgICBTaGlmdFJvd3Moc3RhdGUpXG4gICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbTnIqTmIsIChOcisxKSpOYi0xXSlcbiAgICBvdXQgPSBzdGF0ZVxuICBlbmRcblxuICBJbnZDaXBoZXIoYnl0ZSBpbls0Kk5iXSwgYnl0ZSBvdXRbNCpOYl0sIHdvcmQgd1tOYiooTnIrMSldKVxuICBiZWdpblxuICAgIGJ5dGUgc3RhdGVbNCxOYl1cbiAgICBzdGF0ZSA9IGluXG4gICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbTnIqTmIsIChOcisxKSpOYi0xXSlcbiAgICBmb3Igcm91bmQgPSBOci0xIHN0ZXAgLTEgZG93bnRvIDFcbiAgICAgIEludlNoaWZ0Um93cyhzdGF0ZSlcbiAgICAgIEludlN1YkJ5dGVzKHN0YXRlKVxuICAgICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbcm91bmQqTmIsIChyb3VuZCsxKSpOYi0xXSlcbiAgICAgIEludk1peENvbHVtbnMoc3RhdGUpXG4gICAgZW5kIGZvclxuICAgIEludlNoaWZ0Um93cyhzdGF0ZSlcbiAgICBJbnZTdWJCeXRlcyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICBvdXQgPSBzdGF0ZVxuICBlbmRcbiAgKi9cblxuICAvLyBFbmNyeXB0OiBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgLy8gRGVjcnlwdDogQWRkUm91bmRLZXkoc3RhdGUsIHdbTnIqTmIsIChOcisxKSpOYi0xXSlcbiAgdmFyIE5yID0gdy5sZW5ndGggLyA0IC0gMTtcbiAgdmFyIG0wLCBtMSwgbTIsIG0zLCBzdWI7XG4gIGlmKGRlY3J5cHQpIHtcbiAgICBtMCA9IGltaXhbMF07XG4gICAgbTEgPSBpbWl4WzFdO1xuICAgIG0yID0gaW1peFsyXTtcbiAgICBtMyA9IGltaXhbM107XG4gICAgc3ViID0gaXNib3g7XG4gIH0gZWxzZSB7XG4gICAgbTAgPSBtaXhbMF07XG4gICAgbTEgPSBtaXhbMV07XG4gICAgbTIgPSBtaXhbMl07XG4gICAgbTMgPSBtaXhbM107XG4gICAgc3ViID0gc2JveDtcbiAgfVxuICB2YXIgYSwgYiwgYywgZCwgYTIsIGIyLCBjMjtcbiAgYSA9IGlucHV0WzBdIF4gd1swXTtcbiAgYiA9IGlucHV0W2RlY3J5cHQgPyAzIDogMV0gXiB3WzFdO1xuICBjID0gaW5wdXRbMl0gXiB3WzJdO1xuICBkID0gaW5wdXRbZGVjcnlwdCA/IDEgOiAzXSBeIHdbM107XG4gIHZhciBpID0gMztcblxuICAvKiBJbiBvcmRlciB0byBzaGFyZSBjb2RlIHdlIGZvbGxvdyB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0gd2hlbiBib3RoXG4gICAgZW5jcnlwdGluZyBhbmQgZGVjcnlwdGluZy4gVG8gYWNjb3VudCBmb3IgdGhlIGNoYW5nZXMgcmVxdWlyZWQgaW4gdGhlXG4gICAgZGVjcnlwdGlvbiBhbGdvcml0aG0sIHdlIHVzZSBkaWZmZXJlbnQgbG9va3VwIHRhYmxlcyB3aGVuIGRlY3J5cHRpbmdcbiAgICBhbmQgdXNlIGEgbW9kaWZpZWQga2V5IHNjaGVkdWxlIHRvIGFjY291bnQgZm9yIHRoZSBkaWZmZXJlbmNlIGluIHRoZVxuICAgIG9yZGVyIG9mIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkIHdoZW4gcGVyZm9ybWluZyByb3VuZHMuIFdlIGFsc28gZ2V0XG4gICAga2V5IHJvdW5kcyBpbiByZXZlcnNlIG9yZGVyIChyZWxhdGl2ZSB0byBlbmNyeXB0aW9uKS4gKi9cbiAgZm9yKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgTnI7ICsrcm91bmQpIHtcbiAgICAvKiBBcyBkZXNjcmliZWQgYWJvdmUsIHdlJ2xsIGJlIHVzaW5nIHRhYmxlIGxvb2t1cHMgdG8gcGVyZm9ybSB0aGVcbiAgICAgIGNvbHVtbiBtaXhpbmcuIEVhY2ggY29sdW1uIGlzIHN0b3JlZCBhcyBhIHdvcmQgaW4gdGhlIHN0YXRlICh0aGVcbiAgICAgIGFycmF5ICdpbnB1dCcgaGFzIG9uZSBjb2x1bW4gYXMgYSB3b3JkIGF0IGVhY2ggaW5kZXgpLiBJbiBvcmRlciB0b1xuICAgICAgbWl4IGEgY29sdW1uLCB3ZSBwZXJmb3JtIHRoZXNlIHRyYW5zZm9ybWF0aW9ucyBvbiBlYWNoIHJvdyBpbiBjLFxuICAgICAgd2hpY2ggaXMgMSBieXRlIGluIGVhY2ggd29yZC4gVGhlIG5ldyBjb2x1bW4gZm9yIGMwIGlzIGMnMDpcblxuICAgICAgICAgICAgICAgbTAgICAgICBtMSAgICAgIG0yICAgICAgbTNcbiAgICAgIHIwLGMnMCA9IDIqcjAsYzAgKyAzKnIxLGMwICsgMSpyMixjMCArIDEqcjMsYzBcbiAgICAgIHIxLGMnMCA9IDEqcjAsYzAgKyAyKnIxLGMwICsgMypyMixjMCArIDEqcjMsYzBcbiAgICAgIHIyLGMnMCA9IDEqcjAsYzAgKyAxKnIxLGMwICsgMipyMixjMCArIDMqcjMsYzBcbiAgICAgIHIzLGMnMCA9IDMqcjAsYzAgKyAxKnIxLGMwICsgMSpyMixjMCArIDIqcjMsYzBcblxuICAgICAgU28gdXNpbmcgbWl4IHRhYmxlcyB3aGVyZSBjMCBpcyBhIHdvcmQgd2l0aCByMCBiZWluZyBpdHMgdXBwZXJcbiAgICAgIDggYml0cyBhbmQgcjMgYmVpbmcgaXRzIGxvd2VyIDggYml0czpcblxuICAgICAgbTBbYzAgPj4gMjRdIHdpbGwgeWllbGQgdGhpcyB3b3JkOiBbMipyMCwxKnIwLDEqcjAsMypyMF1cbiAgICAgIC4uLlxuICAgICAgbTNbYzAgJiAyNTVdIHdpbGwgeWllbGQgdGhpcyB3b3JkOiBbMSpyMywxKnIzLDMqcjMsMipyM11cblxuICAgICAgVGhlcmVmb3JlIHRvIG1peCB0aGUgY29sdW1ucyBpbiBlYWNoIHdvcmQgaW4gdGhlIHN0YXRlIHdlXG4gICAgICBkbyB0aGUgZm9sbG93aW5nICgmIDI1NSBvbWl0dGVkIGZvciBicmV2aXR5KTpcbiAgICAgIGMnMCxyMCA9IG0wW2MwID4+IDI0XSBeIG0xW2MxID4+IDE2XSBeIG0yW2MyID4+IDhdIF4gbTNbYzNdXG4gICAgICBjJzAscjEgPSBtMFtjMCA+PiAyNF0gXiBtMVtjMSA+PiAxNl0gXiBtMltjMiA+PiA4XSBeIG0zW2MzXVxuICAgICAgYycwLHIyID0gbTBbYzAgPj4gMjRdIF4gbTFbYzEgPj4gMTZdIF4gbTJbYzIgPj4gOF0gXiBtM1tjM11cbiAgICAgIGMnMCxyMyA9IG0wW2MwID4+IDI0XSBeIG0xW2MxID4+IDE2XSBeIG0yW2MyID4+IDhdIF4gbTNbYzNdXG5cbiAgICAgIEhvd2V2ZXIsIGJlZm9yZSBtaXhpbmcsIHRoZSBhbGdvcml0aG0gcmVxdWlyZXMgdXMgdG8gcGVyZm9ybVxuICAgICAgU2hpZnRSb3dzKCkuIFRoZSBTaGlmdFJvd3MoKSB0cmFuc2Zvcm1hdGlvbiBjeWNsaWNhbGx5IHNoaWZ0cyB0aGVcbiAgICAgIGxhc3QgMyByb3dzIG9mIHRoZSBzdGF0ZSBvdmVyIGRpZmZlcmVudCBvZmZzZXRzLiBUaGUgZmlyc3Qgcm93XG4gICAgICAociA9IDApIGlzIG5vdCBzaGlmdGVkLlxuXG4gICAgICBzJ19yLGMgPSBzX3IsKGMgKyBzaGlmdChyLCBOYikgbW9kIE5iXG4gICAgICBmb3IgMCA8IHIgPCA0IGFuZCAwIDw9IGMgPCBOYiBhbmRcbiAgICAgIHNoaWZ0KDEsIDQpID0gMVxuICAgICAgc2hpZnQoMiwgNCkgPSAyXG4gICAgICBzaGlmdCgzLCA0KSA9IDMuXG5cbiAgICAgIFRoaXMgY2F1c2VzIHRoZSBmaXJzdCBieXRlIGluIHIgPSAxIHRvIGJlIG1vdmVkIHRvIHRoZSBlbmQgb2ZcbiAgICAgIHRoZSByb3csIHRoZSBmaXJzdCAyIGJ5dGVzIGluIHIgPSAyIHRvIGJlIG1vdmVkIHRvIHRoZSBlbmQgb2ZcbiAgICAgIHRoZSByb3csIHRoZSBmaXJzdCAzIGJ5dGVzIGluIHIgPSAzIHRvIGJlIG1vdmVkIHRvIHRoZSBlbmQgb2ZcbiAgICAgIHRoZSByb3c6XG5cbiAgICAgIHIxOiBbYzAgYzEgYzIgYzNdID0+IFtjMSBjMiBjMyBjMF1cbiAgICAgIHIyOiBbYzAgYzEgYzIgYzNdICAgIFtjMiBjMyBjMCBjMV1cbiAgICAgIHIzOiBbYzAgYzEgYzIgYzNdICAgIFtjMyBjMCBjMSBjMl1cblxuICAgICAgV2UgY2FuIG1ha2UgdGhlc2Ugc3Vic3RpdHV0aW9ucyBpbmxpbmUgd2l0aCBvdXIgY29sdW1uIG1peGluZyB0b1xuICAgICAgZ2VuZXJhdGUgYW4gdXBkYXRlZCBzZXQgb2YgZXF1YXRpb25zIHRvIHByb2R1Y2UgZWFjaCB3b3JkIGluIHRoZVxuICAgICAgc3RhdGUgKG5vdGUgdGhlIGNvbHVtbnMgaGF2ZSBjaGFuZ2VkIHBvc2l0aW9ucyk6XG5cbiAgICAgIGMwIGMxIGMyIGMzID0+IGMwIGMxIGMyIGMzXG4gICAgICBjMCBjMSBjMiBjMyAgICBjMSBjMiBjMyBjMCAgKGN5Y2xlZCAxIGJ5dGUpXG4gICAgICBjMCBjMSBjMiBjMyAgICBjMiBjMyBjMCBjMSAgKGN5Y2xlZCAyIGJ5dGVzKVxuICAgICAgYzAgYzEgYzIgYzMgICAgYzMgYzAgYzEgYzIgIChjeWNsZWQgMyBieXRlcylcblxuICAgICAgVGhlcmVmb3JlOlxuXG4gICAgICBjJzAgPSAyKnIwLGMwICsgMypyMSxjMSArIDEqcjIsYzIgKyAxKnIzLGMzXG4gICAgICBjJzAgPSAxKnIwLGMwICsgMipyMSxjMSArIDMqcjIsYzIgKyAxKnIzLGMzXG4gICAgICBjJzAgPSAxKnIwLGMwICsgMSpyMSxjMSArIDIqcjIsYzIgKyAzKnIzLGMzXG4gICAgICBjJzAgPSAzKnIwLGMwICsgMSpyMSxjMSArIDEqcjIsYzIgKyAyKnIzLGMzXG5cbiAgICAgIGMnMSA9IDIqcjAsYzEgKyAzKnIxLGMyICsgMSpyMixjMyArIDEqcjMsYzBcbiAgICAgIGMnMSA9IDEqcjAsYzEgKyAyKnIxLGMyICsgMypyMixjMyArIDEqcjMsYzBcbiAgICAgIGMnMSA9IDEqcjAsYzEgKyAxKnIxLGMyICsgMipyMixjMyArIDMqcjMsYzBcbiAgICAgIGMnMSA9IDMqcjAsYzEgKyAxKnIxLGMyICsgMSpyMixjMyArIDIqcjMsYzBcblxuICAgICAgLi4uIGFuZCBzbyBmb3J0aCBmb3IgYycyIGFuZCBjJzMuIFRoZSBpbXBvcnRhbnQgZGlzdGluY3Rpb24gaXNcbiAgICAgIHRoYXQgdGhlIGNvbHVtbnMgYXJlIGN5Y2xpbmcsIHdpdGggYzAgYmVpbmcgdXNlZCB3aXRoIHRoZSBtMFxuICAgICAgbWFwIHdoZW4gY2FsY3VsYXRpbmcgYzAsIGJ1dCBjMSBiZWluZyB1c2VkIHdpdGggdGhlIG0wIG1hcCB3aGVuXG4gICAgICBjYWxjdWxhdGluZyBjMSAuLi4gYW5kIHNvIGZvcnRoLlxuXG4gICAgICBXaGVuIHBlcmZvcm1pbmcgdGhlIGludmVyc2Ugd2UgdHJhbnNmb3JtIHRoZSBtaXJyb3IgaW1hZ2UgYW5kXG4gICAgICBza2lwIHRoZSBib3R0b20gcm93LCBpbnN0ZWFkIG9mIHRoZSB0b3Agb25lLCBhbmQgbW92ZSB1cHdhcmRzOlxuXG4gICAgICBjMyBjMiBjMSBjMCA9PiBjMCBjMyBjMiBjMSAgKGN5Y2xlZCAzIGJ5dGVzKSAqc2FtZSBhcyBlbmNyeXB0aW9uXG4gICAgICBjMyBjMiBjMSBjMCAgICBjMSBjMCBjMyBjMiAgKGN5Y2xlZCAyIGJ5dGVzKVxuICAgICAgYzMgYzIgYzEgYzAgICAgYzIgYzEgYzAgYzMgIChjeWNsZWQgMSBieXRlKSAgKnNhbWUgYXMgZW5jcnlwdGlvblxuICAgICAgYzMgYzIgYzEgYzAgICAgYzMgYzIgYzEgYzBcblxuICAgICAgSWYgeW91IGNvbXBhcmUgdGhlIHJlc3VsdGluZyBtYXRyaWNlcyBmb3IgU2hpZnRSb3dzKCkrTWl4Q29sdW1ucygpXG4gICAgICBhbmQgZm9yIEludlNoaWZ0Um93cygpK0ludk1peENvbHVtbnMoKSB0aGUgMm5kIGFuZCA0dGggY29sdW1ucyBhcmVcbiAgICAgIGRpZmZlcmVudCAoaW4gZW5jcnlwdCBtb2RlIHZzLiBkZWNyeXB0IG1vZGUpLiBTbyBpbiBvcmRlciB0byB1c2VcbiAgICAgIHRoZSBzYW1lIGNvZGUgdG8gaGFuZGxlIGJvdGggZW5jcnlwdGlvbiBhbmQgZGVjcnlwdGlvbiwgd2Ugd2lsbFxuICAgICAgbmVlZCB0byBkbyBzb21lIG1hcHBpbmcuXG5cbiAgICAgIElmIGluIGVuY3J5cHRpb24gbW9kZSB3ZSBsZXQgYT1jMCwgYj1jMSwgYz1jMiwgZD1jMywgYW5kIHI8Tj4gYmVcbiAgICAgIGEgcm93IG51bWJlciBpbiB0aGUgc3RhdGUsIHRoZW4gdGhlIHJlc3VsdGluZyBtYXRyaXggaW4gZW5jcnlwdGlvblxuICAgICAgbW9kZSBmb3IgYXBwbHlpbmcgdGhlIGFib3ZlIHRyYW5zZm9ybWF0aW9ucyB3b3VsZCBiZTpcblxuICAgICAgcjE6IGEgYiBjIGRcbiAgICAgIHIyOiBiIGMgZCBhXG4gICAgICByMzogYyBkIGEgYlxuICAgICAgcjQ6IGQgYSBiIGNcblxuICAgICAgSWYgd2UgZGlkIHRoZSBzYW1lIGluIGRlY3J5cHRpb24gbW9kZSB3ZSB3b3VsZCBnZXQ6XG5cbiAgICAgIHIxOiBhIGQgYyBiXG4gICAgICByMjogYiBhIGQgY1xuICAgICAgcjM6IGMgYiBhIGRcbiAgICAgIHI0OiBkIGMgYiBhXG5cbiAgICAgIElmIGluc3RlYWQgd2Ugc3dhcCBkIGFuZCBiIChzZXQgYj1jMyBhbmQgZD1jMSksIHRoZW4gd2UgZ2V0OlxuXG4gICAgICByMTogYSBiIGMgZFxuICAgICAgcjI6IGQgYSBiIGNcbiAgICAgIHIzOiBjIGQgYSBiXG4gICAgICByNDogYiBjIGQgYVxuXG4gICAgICBOb3cgdGhlIDFzdCBhbmQgM3JkIHJvd3MgYXJlIHRoZSBzYW1lIGFzIHRoZSBlbmNyeXB0aW9uIG1hdHJpeC4gQWxsXG4gICAgICB3ZSBuZWVkIHRvIGRvIHRoZW4gdG8gbWFrZSB0aGUgbWFwcGluZyBleGFjdGx5IHRoZSBzYW1lIGlzIHRvIHN3YXBcbiAgICAgIHRoZSAybmQgYW5kIDR0aCByb3dzIHdoZW4gaW4gZGVjcnlwdGlvbiBtb2RlLiBUbyBkbyB0aGlzIHdpdGhvdXRcbiAgICAgIGhhdmluZyB0byBkbyBpdCBvbiBlYWNoIGl0ZXJhdGlvbiwgd2Ugc3dhcHBlZCB0aGUgMm5kIGFuZCA0dGggcm93c1xuICAgICAgaW4gdGhlIGRlY3J5cHRpb24ga2V5IHNjaGVkdWxlLiBXZSBhbHNvIGhhdmUgdG8gZG8gdGhlIHN3YXAgYWJvdmVcbiAgICAgIHdoZW4gd2UgZmlyc3QgcHVsbCBpbiB0aGUgaW5wdXQgYW5kIHdoZW4gd2Ugc2V0IHRoZSBmaW5hbCBvdXRwdXQuICovXG4gICAgYTIgPVxuICAgICAgbTBbYSA+Pj4gMjRdIF5cbiAgICAgIG0xW2IgPj4+IDE2ICYgMjU1XSBeXG4gICAgICBtMltjID4+PiA4ICYgMjU1XSBeXG4gICAgICBtM1tkICYgMjU1XSBeIHdbKytpXTtcbiAgICBiMiA9XG4gICAgICBtMFtiID4+PiAyNF0gXlxuICAgICAgbTFbYyA+Pj4gMTYgJiAyNTVdIF5cbiAgICAgIG0yW2QgPj4+IDggJiAyNTVdIF5cbiAgICAgIG0zW2EgJiAyNTVdIF4gd1srK2ldO1xuICAgIGMyID1cbiAgICAgIG0wW2MgPj4+IDI0XSBeXG4gICAgICBtMVtkID4+PiAxNiAmIDI1NV0gXlxuICAgICAgbTJbYSA+Pj4gOCAmIDI1NV0gXlxuICAgICAgbTNbYiAmIDI1NV0gXiB3WysraV07XG4gICAgZCA9XG4gICAgICBtMFtkID4+PiAyNF0gXlxuICAgICAgbTFbYSA+Pj4gMTYgJiAyNTVdIF5cbiAgICAgIG0yW2IgPj4+IDggJiAyNTVdIF5cbiAgICAgIG0zW2MgJiAyNTVdIF4gd1srK2ldO1xuICAgIGEgPSBhMjtcbiAgICBiID0gYjI7XG4gICAgYyA9IGMyO1xuICB9XG5cbiAgLypcbiAgICBFbmNyeXB0OlxuICAgIFN1YkJ5dGVzKHN0YXRlKVxuICAgIFNoaWZ0Um93cyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuXG4gICAgRGVjcnlwdDpcbiAgICBJbnZTaGlmdFJvd3Moc3RhdGUpXG4gICAgSW52U3ViQnl0ZXMoc3RhdGUpXG4gICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbMCwgTmItMV0pXG4gICAqL1xuICAvLyBOb3RlOiByb3dzIGFyZSBzaGlmdGVkIGlubGluZVxuICBvdXRwdXRbMF0gPVxuICAgIChzdWJbYSA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltiID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2MgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2QgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0W2RlY3J5cHQgPyAzIDogMV0gPVxuICAgIChzdWJbYiA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltjID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2QgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2EgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0WzJdID1cbiAgICAoc3ViW2MgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbZCA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YlthID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltiICYgMjU1XSkgXiB3WysraV07XG4gIG91dHB1dFtkZWNyeXB0ID8gMSA6IDNdID1cbiAgICAoc3ViW2QgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbYSA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YltiID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltjICYgMjU1XSkgXiB3WysraV07XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGEgZGVwcmVjYXRlZCBBRVMgY2lwaGVyIG9iamVjdC4gVGhpcyBvYmplY3QncyBtb2RlIHdpbGwgZGVmYXVsdCB0b1xuICogQ0JDIChjaXBoZXItYmxvY2stY2hhaW5pbmcpLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqICAgICAgICAgIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLlxuICogICAgICAgICAgZGVjcnlwdCB0cnVlIGZvciBkZWNyeXB0aW9uLCBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqICAgICAgICAgIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUNpcGhlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbW9kZSA9IChvcHRpb25zLm1vZGUgfHwgJ0NCQycpLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBhbGdvcml0aG0gPSAnQUVTLScgKyBtb2RlO1xuXG4gIHZhciBjaXBoZXI7XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCkge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcihhbGdvcml0aG0sIG9wdGlvbnMua2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9XG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdGlibGUgc3RhcnQgQVBJXG4gIHZhciBzdGFydCA9IGNpcGhlci5zdGFydDtcbiAgY2lwaGVyLnN0YXJ0ID0gZnVuY3Rpb24oaXYsIG9wdGlvbnMpIHtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogc3VwcG9ydCBzZWNvbmQgYXJnIGFzIG91dHB1dCBidWZmZXJcbiAgICB2YXIgb3V0cHV0ID0gbnVsbDtcbiAgICBpZihvcHRpb25zIGluc3RhbmNlb2YgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKSB7XG4gICAgICBvdXRwdXQgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLm91dHB1dCA9IG91dHB1dDtcbiAgICBvcHRpb25zLml2ID0gaXY7XG4gICAgc3RhcnQuY2FsbChjaXBoZXIsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBjaXBoZXI7XG59XG4iLCIvKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYmFzaWMgUEVNIChQcml2YWN5IEVuaGFuY2VkIE1haWwpIGFsZ29yaXRobXMuXG4gKlxuICogU2VlOiBSRkMgMTQyMS5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKlxuICogQSBGb3JnZSBQRU0gb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAqXG4gKiB0eXBlOiBpZGVudGlmaWVzIHRoZSB0eXBlIG9mIG1lc3NhZ2UgKGVnOiBcIlJTQSBQUklWQVRFIEtFWVwiKS5cbiAqXG4gKiBwcm9jVHlwZTogaWRlbnRpZmllcyB0aGUgdHlwZSBvZiBwcm9jZXNzaW5nIHBlcmZvcm1lZCBvbiB0aGUgbWVzc2FnZSxcbiAqICAgaXQgaGFzIHR3byBzdWJmaWVsZHM6IHZlcnNpb24gYW5kIHR5cGUsIGVnOiA0LEVOQ1JZUFRFRC5cbiAqXG4gKiBjb250ZW50RG9tYWluOiBpZGVudGlmaWVzIHRoZSB0eXBlIG9mIGNvbnRlbnQgaW4gdGhlIG1lc3NhZ2UsIHR5cGljYWxseVxuICogICBvbmx5IHVzZXMgdGhlIHZhbHVlOiBcIlJGQzgyMlwiLlxuICpcbiAqIGRla0luZm86IGlkZW50aWZpZXMgdGhlIG1lc3NhZ2UgZW5jcnlwdGlvbiBhbGdvcml0aG0gYW5kIG1vZGUgYW5kIGluY2x1ZGVzXG4gKiAgIGFueSBwYXJhbWV0ZXJzIGZvciB0aGUgYWxnb3JpdGhtLCBpdCBoYXMgdHdvIHN1YmZpZWxkczogYWxnb3JpdGhtIGFuZFxuICogICBwYXJhbWV0ZXJzLCBlZzogREVTLUNCQyxGODE0M0VERTU5NjBDNTk3LlxuICpcbiAqIGhlYWRlcnM6IGNvbnRhaW5zIGFsbCBvdGhlciBQRU0gZW5jYXBzdWxhdGVkIGhlYWRlcnMgLS0gd2hlcmUgb3JkZXIgaXNcbiAqICAgc2lnbmlmaWNhbnQgKGZvciBwYWlyaW5nIGRhdGEgbGlrZSByZWNpcGllbnQgSUQgKyBrZXkgaW5mbykuXG4gKlxuICogYm9keTogdGhlIGJpbmFyeS1lbmNvZGVkIGJvZHkuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBzaG9ydGN1dCBmb3IgcGVtIEFQSVxudmFyIHBlbSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGVtID0gZm9yZ2UucGVtIHx8IHt9O1xuXG4vKipcbiAqIEVuY29kZXMgKHNlcmlhbGl6ZXMpIHRoZSBnaXZlbiBQRU0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBtc2cgdGhlIFBFTSBtZXNzYWdlIG9iamVjdCB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBtYXhsaW5lIHRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUgZm9yIHRoZSBib2R5LCAoZGVmYXVsdDogNjQpLlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTS1mb3JtYXR0ZWQgc3RyaW5nLlxuICovXG5wZW0uZW5jb2RlID0gZnVuY3Rpb24obXNnLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcnZhbCA9ICctLS0tLUJFR0lOICcgKyBtc2cudHlwZSArICctLS0tLVxcclxcbic7XG5cbiAgLy8gZW5jb2RlIHNwZWNpYWwgaGVhZGVyc1xuICB2YXIgaGVhZGVyO1xuICBpZihtc2cucHJvY1R5cGUpIHtcbiAgICBoZWFkZXIgPSB7XG4gICAgICBuYW1lOiAnUHJvYy1UeXBlJyxcbiAgICAgIHZhbHVlczogW1N0cmluZyhtc2cucHJvY1R5cGUudmVyc2lvbiksIG1zZy5wcm9jVHlwZS50eXBlXVxuICAgIH07XG4gICAgcnZhbCArPSBmb2xkSGVhZGVyKGhlYWRlcik7XG4gIH1cbiAgaWYobXNnLmNvbnRlbnREb21haW4pIHtcbiAgICBoZWFkZXIgPSB7bmFtZTogJ0NvbnRlbnQtRG9tYWluJywgdmFsdWVzOiBbbXNnLmNvbnRlbnREb21haW5dfTtcbiAgICBydmFsICs9IGZvbGRIZWFkZXIoaGVhZGVyKTtcbiAgfVxuICBpZihtc2cuZGVrSW5mbykge1xuICAgIGhlYWRlciA9IHtuYW1lOiAnREVLLUluZm8nLCB2YWx1ZXM6IFttc2cuZGVrSW5mby5hbGdvcml0aG1dfTtcbiAgICBpZihtc2cuZGVrSW5mby5wYXJhbWV0ZXJzKSB7XG4gICAgICBoZWFkZXIudmFsdWVzLnB1c2gobXNnLmRla0luZm8ucGFyYW1ldGVycyk7XG4gICAgfVxuICAgIHJ2YWwgKz0gZm9sZEhlYWRlcihoZWFkZXIpO1xuICB9XG5cbiAgaWYobXNnLmhlYWRlcnMpIHtcbiAgICAvLyBlbmNvZGUgYWxsIG90aGVyIGhlYWRlcnNcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbXNnLmhlYWRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJ2YWwgKz0gZm9sZEhlYWRlcihtc2cuaGVhZGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGVybWluYXRlIGhlYWRlclxuICBpZihtc2cucHJvY1R5cGUpIHtcbiAgICBydmFsICs9ICdcXHJcXG4nO1xuICB9XG5cbiAgLy8gYWRkIGJvZHlcbiAgcnZhbCArPSBmb3JnZS51dGlsLmVuY29kZTY0KG1zZy5ib2R5LCBvcHRpb25zLm1heGxpbmUgfHwgNjQpICsgJ1xcclxcbic7XG5cbiAgcnZhbCArPSAnLS0tLS1FTkQgJyArIG1zZy50eXBlICsgJy0tLS0tXFxyXFxuJztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIERlY29kZXMgKGRlc2VyaWFsaXplcykgYWxsIFBFTSBtZXNzYWdlcyBmb3VuZCBpbiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIFBFTS1mb3JtYXR0ZWQgc3RyaW5nIHRvIGRlY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0gbWVzc2FnZSBvYmplY3RzIGluIGFuIGFycmF5LlxuICovXG5wZW0uZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBydmFsID0gW107XG5cbiAgLy8gc3BsaXQgc3RyaW5nIGludG8gUEVNIG1lc3NhZ2VzIChiZSBsZW5pZW50IHcvRU9GIG9uIEJFR0lOIGxpbmUpXG4gIHZhciByTWVzc2FnZSA9IC9cXHMqLS0tLS1CRUdJTiAoW0EtWjAtOS0gXSspLS0tLS1cXHI/XFxuPyhbXFx4MjEtXFx4N2VcXHNdKz8oPzpcXHI/XFxuXFxyP1xcbikpPyhbOkEtWmEtejAtOStcXC89XFxzXSs/KS0tLS0tRU5EIFxcMS0tLS0tL2c7XG4gIHZhciBySGVhZGVyID0gLyhbXFx4MjEtXFx4N2VdKyk6XFxzKihbXFx4MjEtXFx4N2VcXHNeOl0rKS87XG4gIHZhciByQ1JMRiA9IC9cXHI/XFxuLztcbiAgdmFyIG1hdGNoO1xuICB3aGlsZSh0cnVlKSB7XG4gICAgbWF0Y2ggPSByTWVzc2FnZS5leGVjKHN0cik7XG4gICAgaWYoIW1hdGNoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgbXNnID0ge1xuICAgICAgdHlwZTogbWF0Y2hbMV0sXG4gICAgICBwcm9jVHlwZTogbnVsbCxcbiAgICAgIGNvbnRlbnREb21haW46IG51bGwsXG4gICAgICBkZWtJbmZvOiBudWxsLFxuICAgICAgaGVhZGVyczogW10sXG4gICAgICBib2R5OiBmb3JnZS51dGlsLmRlY29kZTY0KG1hdGNoWzNdKVxuICAgIH07XG4gICAgcnZhbC5wdXNoKG1zZyk7XG5cbiAgICAvLyBubyBoZWFkZXJzXG4gICAgaWYoIW1hdGNoWzJdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBoZWFkZXJzXG4gICAgdmFyIGxpbmVzID0gbWF0Y2hbMl0uc3BsaXQockNSTEYpO1xuICAgIHZhciBsaSA9IDA7XG4gICAgd2hpbGUobWF0Y2ggJiYgbGkgPCBsaW5lcy5sZW5ndGgpIHtcbiAgICAgIC8vIGdldCBsaW5lLCB0cmltIGFueSByaHMgd2hpdGVzcGFjZVxuICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsaV0ucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG5cbiAgICAgIC8vIFJGQzI4MjIgdW5mb2xkIGFueSBmb2xsb3dpbmcgZm9sZGVkIGxpbmVzXG4gICAgICBmb3IodmFyIG5sID0gbGkgKyAxOyBubCA8IGxpbmVzLmxlbmd0aDsgKytubCkge1xuICAgICAgICB2YXIgbmV4dCA9IGxpbmVzW25sXTtcbiAgICAgICAgaWYoIS9cXHMvLnRlc3QobmV4dFswXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsaW5lICs9IG5leHQ7XG4gICAgICAgIGxpID0gbmw7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIGhlYWRlclxuICAgICAgbWF0Y2ggPSBsaW5lLm1hdGNoKHJIZWFkZXIpO1xuICAgICAgaWYobWF0Y2gpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IHtuYW1lOiBtYXRjaFsxXSwgdmFsdWVzOiBbXX07XG4gICAgICAgIHZhciB2YWx1ZXMgPSBtYXRjaFsyXS5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IodmFyIHZpID0gMDsgdmkgPCB2YWx1ZXMubGVuZ3RoOyArK3ZpKSB7XG4gICAgICAgICAgaGVhZGVyLnZhbHVlcy5wdXNoKGx0cmltKHZhbHVlc1t2aV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb2MtVHlwZSBtdXN0IGJlIHRoZSBmaXJzdCBoZWFkZXJcbiAgICAgICAgaWYoIW1zZy5wcm9jVHlwZSkge1xuICAgICAgICAgIGlmKGhlYWRlci5uYW1lICE9PSAnUHJvYy1UeXBlJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4gVGhlIGZpcnN0ICcgK1xuICAgICAgICAgICAgICAnZW5jYXBzdWxhdGVkIGhlYWRlciBtdXN0IGJlIFwiUHJvYy1UeXBlXCIuJyk7XG4gICAgICAgICAgfSBlbHNlIGlmKGhlYWRlci52YWx1ZXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLiBUaGUgXCJQcm9jLVR5cGVcIiAnICtcbiAgICAgICAgICAgICAgJ2hlYWRlciBtdXN0IGhhdmUgdHdvIHN1YmZpZWxkcy4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbXNnLnByb2NUeXBlID0ge3ZlcnNpb246IHZhbHVlc1swXSwgdHlwZTogdmFsdWVzWzFdfTtcbiAgICAgICAgfSBlbHNlIGlmKCFtc2cuY29udGVudERvbWFpbiAmJiBoZWFkZXIubmFtZSA9PT0gJ0NvbnRlbnQtRG9tYWluJykge1xuICAgICAgICAgIC8vIHNwZWNpYWwtY2FzZSBDb250ZW50LURvbWFpblxuICAgICAgICAgIG1zZy5jb250ZW50RG9tYWluID0gdmFsdWVzWzBdIHx8ICcnO1xuICAgICAgICB9IGVsc2UgaWYoIW1zZy5kZWtJbmZvICYmIGhlYWRlci5uYW1lID09PSAnREVLLUluZm8nKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbC1jYXNlIERFSy1JbmZvXG4gICAgICAgICAgaWYoaGVhZGVyLnZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBcIkRFSy1JbmZvXCIgJyArXG4gICAgICAgICAgICAgICdoZWFkZXIgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzdWJmaWVsZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbXNnLmRla0luZm8gPSB7YWxnb3JpdGhtOiB2YWx1ZXNbMF0sIHBhcmFtZXRlcnM6IHZhbHVlc1sxXSB8fCBudWxsfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtc2cuaGVhZGVycy5wdXNoKGhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgKytsaTtcbiAgICB9XG5cbiAgICBpZihtc2cucHJvY1R5cGUgPT09ICdFTkNSWVBURUQnICYmICFtc2cuZGVrSW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4gVGhlIFwiREVLLUluZm9cIiAnICtcbiAgICAgICAgJ2hlYWRlciBtdXN0IGJlIHByZXNlbnQgaWYgXCJQcm9jLVR5cGVcIiBpcyBcIkVOQ1JZUFRFRFwiLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmKHJ2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4nKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuZnVuY3Rpb24gZm9sZEhlYWRlcihoZWFkZXIpIHtcbiAgdmFyIHJ2YWwgPSBoZWFkZXIubmFtZSArICc6ICc7XG5cbiAgLy8gZW5zdXJlIHZhbHVlcyB3aXRoIENSTEYgYXJlIGZvbGRlZFxuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciBpbnNlcnRTcGFjZSA9IGZ1bmN0aW9uKG1hdGNoLCAkMSkge1xuICAgIHJldHVybiAnICcgKyAkMTtcbiAgfTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGhlYWRlci52YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YWx1ZXMucHVzaChoZWFkZXIudmFsdWVzW2ldLnJlcGxhY2UoL14oXFxTK1xcclxcbikvLCBpbnNlcnRTcGFjZSkpO1xuICB9XG4gIHJ2YWwgKz0gdmFsdWVzLmpvaW4oJywnKSArICdcXHJcXG4nO1xuXG4gIC8vIGRvIGZvbGRpbmdcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBjYW5kaWRhdGUgPSAtMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHJ2YWwubGVuZ3RoOyArK2ksICsrbGVuZ3RoKSB7XG4gICAgaWYobGVuZ3RoID4gNjUgJiYgY2FuZGlkYXRlICE9PSAtMSkge1xuICAgICAgdmFyIGluc2VydCA9IHJ2YWxbY2FuZGlkYXRlXTtcbiAgICAgIGlmKGluc2VydCA9PT0gJywnKSB7XG4gICAgICAgICsrY2FuZGlkYXRlO1xuICAgICAgICBydmFsID0gcnZhbC5zdWJzdHIoMCwgY2FuZGlkYXRlKSArICdcXHJcXG4gJyArIHJ2YWwuc3Vic3RyKGNhbmRpZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsID0gcnZhbC5zdWJzdHIoMCwgY2FuZGlkYXRlKSArXG4gICAgICAgICAgJ1xcclxcbicgKyBpbnNlcnQgKyBydmFsLnN1YnN0cihjYW5kaWRhdGUgKyAxKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IChpIC0gY2FuZGlkYXRlIC0gMSk7XG4gICAgICBjYW5kaWRhdGUgPSAtMTtcbiAgICAgICsraTtcbiAgICB9IGVsc2UgaWYocnZhbFtpXSA9PT0gJyAnIHx8IHJ2YWxbaV0gPT09ICdcXHQnIHx8IHJ2YWxbaV0gPT09ICcsJykge1xuICAgICAgY2FuZGlkYXRlID0gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn1cblxuZnVuY3Rpb24gbHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccysvLCAnJyk7XG59XG4iLCIvKipcbiAqIFJDMiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIEluZm9ybWF0aW9uIG9uIHRoZSBSQzIgY2lwaGVyIGlzIGF2YWlsYWJsZSBmcm9tIFJGQyAjMjI2OCxcbiAqIGh0dHA6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzIyNjgudHh0XG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgcGlUYWJsZSA9IFtcbiAgMHhkOSwgMHg3OCwgMHhmOSwgMHhjNCwgMHgxOSwgMHhkZCwgMHhiNSwgMHhlZCwgMHgyOCwgMHhlOSwgMHhmZCwgMHg3OSwgMHg0YSwgMHhhMCwgMHhkOCwgMHg5ZCxcbiAgMHhjNiwgMHg3ZSwgMHgzNywgMHg4MywgMHgyYiwgMHg3NiwgMHg1MywgMHg4ZSwgMHg2MiwgMHg0YywgMHg2NCwgMHg4OCwgMHg0NCwgMHg4YiwgMHhmYiwgMHhhMixcbiAgMHgxNywgMHg5YSwgMHg1OSwgMHhmNSwgMHg4NywgMHhiMywgMHg0ZiwgMHgxMywgMHg2MSwgMHg0NSwgMHg2ZCwgMHg4ZCwgMHgwOSwgMHg4MSwgMHg3ZCwgMHgzMixcbiAgMHhiZCwgMHg4ZiwgMHg0MCwgMHhlYiwgMHg4NiwgMHhiNywgMHg3YiwgMHgwYiwgMHhmMCwgMHg5NSwgMHgyMSwgMHgyMiwgMHg1YywgMHg2YiwgMHg0ZSwgMHg4MixcbiAgMHg1NCwgMHhkNiwgMHg2NSwgMHg5MywgMHhjZSwgMHg2MCwgMHhiMiwgMHgxYywgMHg3MywgMHg1NiwgMHhjMCwgMHgxNCwgMHhhNywgMHg4YywgMHhmMSwgMHhkYyxcbiAgMHgxMiwgMHg3NSwgMHhjYSwgMHgxZiwgMHgzYiwgMHhiZSwgMHhlNCwgMHhkMSwgMHg0MiwgMHgzZCwgMHhkNCwgMHgzMCwgMHhhMywgMHgzYywgMHhiNiwgMHgyNixcbiAgMHg2ZiwgMHhiZiwgMHgwZSwgMHhkYSwgMHg0NiwgMHg2OSwgMHgwNywgMHg1NywgMHgyNywgMHhmMiwgMHgxZCwgMHg5YiwgMHhiYywgMHg5NCwgMHg0MywgMHgwMyxcbiAgMHhmOCwgMHgxMSwgMHhjNywgMHhmNiwgMHg5MCwgMHhlZiwgMHgzZSwgMHhlNywgMHgwNiwgMHhjMywgMHhkNSwgMHgyZiwgMHhjOCwgMHg2NiwgMHgxZSwgMHhkNyxcbiAgMHgwOCwgMHhlOCwgMHhlYSwgMHhkZSwgMHg4MCwgMHg1MiwgMHhlZSwgMHhmNywgMHg4NCwgMHhhYSwgMHg3MiwgMHhhYywgMHgzNSwgMHg0ZCwgMHg2YSwgMHgyYSxcbiAgMHg5NiwgMHgxYSwgMHhkMiwgMHg3MSwgMHg1YSwgMHgxNSwgMHg0OSwgMHg3NCwgMHg0YiwgMHg5ZiwgMHhkMCwgMHg1ZSwgMHgwNCwgMHgxOCwgMHhhNCwgMHhlYyxcbiAgMHhjMiwgMHhlMCwgMHg0MSwgMHg2ZSwgMHgwZiwgMHg1MSwgMHhjYiwgMHhjYywgMHgyNCwgMHg5MSwgMHhhZiwgMHg1MCwgMHhhMSwgMHhmNCwgMHg3MCwgMHgzOSxcbiAgMHg5OSwgMHg3YywgMHgzYSwgMHg4NSwgMHgyMywgMHhiOCwgMHhiNCwgMHg3YSwgMHhmYywgMHgwMiwgMHgzNiwgMHg1YiwgMHgyNSwgMHg1NSwgMHg5NywgMHgzMSxcbiAgMHgyZCwgMHg1ZCwgMHhmYSwgMHg5OCwgMHhlMywgMHg4YSwgMHg5MiwgMHhhZSwgMHgwNSwgMHhkZiwgMHgyOSwgMHgxMCwgMHg2NywgMHg2YywgMHhiYSwgMHhjOSxcbiAgMHhkMywgMHgwMCwgMHhlNiwgMHhjZiwgMHhlMSwgMHg5ZSwgMHhhOCwgMHgyYywgMHg2MywgMHgxNiwgMHgwMSwgMHgzZiwgMHg1OCwgMHhlMiwgMHg4OSwgMHhhOSxcbiAgMHgwZCwgMHgzOCwgMHgzNCwgMHgxYiwgMHhhYiwgMHgzMywgMHhmZiwgMHhiMCwgMHhiYiwgMHg0OCwgMHgwYywgMHg1ZiwgMHhiOSwgMHhiMSwgMHhjZCwgMHgyZSxcbiAgMHhjNSwgMHhmMywgMHhkYiwgMHg0NywgMHhlNSwgMHhhNSwgMHg5YywgMHg3NywgMHgwYSwgMHhhNiwgMHgyMCwgMHg2OCwgMHhmZSwgMHg3ZiwgMHhjMSwgMHhhZFxuXTtcblxudmFyIHMgPSBbMSwgMiwgMywgNV07XG5cbi8qKlxuICogUm90YXRlIGEgd29yZCBsZWZ0IGJ5IGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICpcbiAqIEJpdHMgdGhhdCBhcmUgc2hpZnRlZCBvdXQgb24gdGhlIGxlZnQgYXJlIHB1dCBiYWNrIGluIG9uIHRoZSByaWdodFxuICogaGFuZCBzaWRlLlxuICpcbiAqIEBwYXJhbSB3b3JkIFRoZSB3b3JkIHRvIHNoaWZ0IGxlZnQuXG4gKiBAcGFyYW0gYml0cyBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQgYnkuXG4gKiBAcmV0dXJuIFRoZSByb3RhdGVkIHdvcmQuXG4gKi9cbnZhciByb2wgPSBmdW5jdGlvbih3b3JkLCBiaXRzKSB7XG4gIHJldHVybiAoKHdvcmQgPDwgYml0cykgJiAweGZmZmYpIHwgKCh3b3JkICYgMHhmZmZmKSA+PiAoMTYgLSBiaXRzKSk7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHdvcmQgcmlnaHQgYnkgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogQml0cyB0aGF0IGFyZSBzaGlmdGVkIG91dCBvbiB0aGUgcmlnaHQgYXJlIHB1dCBiYWNrIGluIG9uIHRoZSBsZWZ0XG4gKiBoYW5kIHNpZGUuXG4gKlxuICogQHBhcmFtIHdvcmQgVGhlIHdvcmQgdG8gc2hpZnQgcmlnaHQuXG4gKiBAcGFyYW0gYml0cyBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQgYnkuXG4gKiBAcmV0dXJuIFRoZSByb3RhdGVkIHdvcmQuXG4gKi9cbnZhciByb3IgPSBmdW5jdGlvbih3b3JkLCBiaXRzKSB7XG4gIHJldHVybiAoKHdvcmQgJiAweGZmZmYpID4+IGJpdHMpIHwgKCh3b3JkIDw8ICgxNiAtIGJpdHMpKSAmIDB4ZmZmZik7XG59O1xuXG4vKiBSQzIgQVBJICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnJjMiA9IGZvcmdlLnJjMiB8fCB7fTtcblxuLyoqXG4gKiBQZXJmb3JtIFJDMiBrZXkgZXhwYW5zaW9uIGFzIHBlciBSRkMgIzIyNjgsIHNlY3Rpb24gMi5cbiAqXG4gKiBAcGFyYW0ga2V5IHZhcmlhYmxlLWxlbmd0aCB1c2VyIGtleSAoYmV0d2VlbiAxIGFuZCAxMjggYnl0ZXMpXG4gKiBAcGFyYW0gZWZmS2V5Qml0cyBudW1iZXIgb2YgZWZmZWN0aXZlIGtleSBiaXRzIChkZWZhdWx0OiAxMjgpXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBSQzIga2V5IChCeXRlQnVmZmVyIG9mIDEyOCBieXRlcylcbiAqL1xuZm9yZ2UucmMyLmV4cGFuZEtleSA9IGZ1bmN0aW9uKGtleSwgZWZmS2V5Qml0cykge1xuICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGtleSk7XG4gIH1cbiAgZWZmS2V5Qml0cyA9IGVmZktleUJpdHMgfHwgMTI4O1xuXG4gIC8qIGludHJvZHVjZSB2YXJpYWJsZXMgdGhhdCBtYXRjaCB0aGUgbmFtZXMgdXNlZCBpbiBSRkMgIzIyNjggKi9cbiAgdmFyIEwgPSBrZXk7XG4gIHZhciBUID0ga2V5Lmxlbmd0aCgpO1xuICB2YXIgVDEgPSBlZmZLZXlCaXRzO1xuICB2YXIgVDggPSBNYXRoLmNlaWwoVDEgLyA4KTtcbiAgdmFyIFRNID0gMHhmZiA+PiAoVDEgJiAweDA3KTtcbiAgdmFyIGk7XG5cbiAgZm9yKGkgPSBUOyBpIDwgMTI4OyBpKyspIHtcbiAgICBMLnB1dEJ5dGUocGlUYWJsZVsoTC5hdChpIC0gMSkgKyBMLmF0KGkgLSBUKSkgJiAweGZmXSk7XG4gIH1cblxuICBMLnNldEF0KDEyOCAtIFQ4LCBwaVRhYmxlW0wuYXQoMTI4IC0gVDgpICYgVE1dKTtcblxuICBmb3IoaSA9IDEyNyAtIFQ4OyBpID49IDA7IGktLSkge1xuICAgIEwuc2V0QXQoaSwgcGlUYWJsZVtMLmF0KGkgKyAxKSBeIEwuYXQoaSArIFQ4KV0pO1xuICB9XG5cbiAgcmV0dXJuIEw7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBSQzIgY2lwaGVyIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoYXMgYmFzZSBmb3Iga2V5IGdlbmVyYXRpb24pLlxuICogQHBhcmFtIGJpdHMgdGhlIG51bWJlciBvZiBlZmZlY3RpdmUga2V5IGJpdHMuXG4gKiBAcGFyYW0gZW5jcnlwdCBmYWxzZSBmb3IgZGVjcnlwdGlvbiwgdHJ1ZSBmb3IgZW5jcnlwdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbnZhciBjcmVhdGVDaXBoZXIgPSBmdW5jdGlvbihrZXksIGJpdHMsIGVuY3J5cHQpIHtcbiAgdmFyIF9maW5pc2ggPSBmYWxzZSwgX2lucHV0ID0gbnVsbCwgX291dHB1dCA9IG51bGwsIF9pdiA9IG51bGw7XG4gIHZhciBtaXhSb3VuZCwgbWFzaFJvdW5kO1xuICB2YXIgaSwgaiwgSyA9IFtdO1xuXG4gIC8qIEV4cGFuZCBrZXkgYW5kIGZpbGwgaW50byBLW10gQXJyYXkgKi9cbiAga2V5ID0gZm9yZ2UucmMyLmV4cGFuZEtleShrZXksIGJpdHMpO1xuICBmb3IoaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgSy5wdXNoKGtleS5nZXRJbnQxNkxlKCkpO1xuICB9XG5cbiAgaWYoZW5jcnlwdCkge1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gb25lIG1peGluZyByb3VuZCBcImluIHBsYWNlXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gUiBBcnJheSBvZiBmb3VyIHdvcmRzIHRvIHBlcmZvcm0gbWl4aW5nIG9uLlxuICAgICAqL1xuICAgIG1peFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIFJbaV0gKz0gS1tqXSArIChSWyhpICsgMykgJSA0XSAmIFJbKGkgKyAyKSAlIDRdKSArXG4gICAgICAgICAgKCh+UlsoaSArIDMpICUgNF0pICYgUlsoaSArIDEpICUgNF0pO1xuICAgICAgICBSW2ldID0gcm9sKFJbaV0sIHNbaV0pO1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gb25lIG1hc2hpbmcgcm91bmQgXCJpbiBwbGFjZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIFIgQXJyYXkgb2YgZm91ciB3b3JkcyB0byBwZXJmb3JtIG1hc2hpbmcgb24uXG4gICAgICovXG4gICAgbWFzaFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIFJbaV0gKz0gS1tSWyhpICsgMykgJSA0XSAmIDYzXTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gb25lIHItbWl4aW5nIHJvdW5kIFwiaW4gcGxhY2VcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBSIEFycmF5IG9mIGZvdXIgd29yZHMgdG8gcGVyZm9ybSBtaXhpbmcgb24uXG4gICAgICovXG4gICAgbWl4Um91bmQgPSBmdW5jdGlvbihSKSB7XG4gICAgICBmb3IoaSA9IDM7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIFJbaV0gPSByb3IoUltpXSwgc1tpXSk7XG4gICAgICAgIFJbaV0gLT0gS1tqXSArIChSWyhpICsgMykgJSA0XSAmIFJbKGkgKyAyKSAlIDRdKSArXG4gICAgICAgICAgKCh+UlsoaSArIDMpICUgNF0pICYgUlsoaSArIDEpICUgNF0pO1xuICAgICAgICBqLS07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gb25lIHItbWFzaGluZyByb3VuZCBcImluIHBsYWNlXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gUiBBcnJheSBvZiBmb3VyIHdvcmRzIHRvIHBlcmZvcm0gbWFzaGluZyBvbi5cbiAgICAgKi9cbiAgICBtYXNoUm91bmQgPSBmdW5jdGlvbihSKSB7XG4gICAgICBmb3IoaSA9IDM7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIFJbaV0gLT0gS1tSWyhpICsgMykgJSA0XSAmIDYzXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biB0aGUgc3BlY2lmaWVkIGNpcGhlciBleGVjdXRpb24gcGxhbi5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBmb3VyIHdvcmRzIGZyb20gdGhlIGlucHV0IGJ1ZmZlciwgYXBwbGllcyB0aGUgSVYgb25cbiAgICogaXQgKGlmIHJlcXVlc3RlZCkgYW5kIHJ1bnMgdGhlIHByb3ZpZGVkIGV4ZWN1dGlvbiBwbGFuLlxuICAgKlxuICAgKiBUaGUgcGxhbiBtdXN0IGJlIHB1dCB0b2dldGhlciBpbiBmb3JtIG9mIGEgYXJyYXkgb2YgYXJyYXlzLiAgV2hlcmUgdGhlXG4gICAqIG91dGVyIG9uZSBpcyBzaW1wbHkgYSBsaXN0IG9mIHN0ZXBzIHRvIHBlcmZvcm0gYW5kIHRoZSBpbm5lciBvbmUgbmVlZHNcbiAgICogdG8gaGF2ZSB0d28gZWxlbWVudHM6IHRoZSBmaXJzdCBvbmUgdGVsbGluZyBob3cgbWFueSByb3VuZHMgdG8gcGVyZm9ybSxcbiAgICogdGhlIHNlY29uZCBvbmUgdGVsbGluZyB3aGF0IHRvIGRvIChpLmUuIHRoZSBmdW5jdGlvbiB0byBjYWxsKS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcGxhbiBUaGUgcGxhbiB0byBleGVjdXRlLlxuICAgKi9cbiAgdmFyIHJ1blBsYW4gPSBmdW5jdGlvbihwbGFuKSB7XG4gICAgdmFyIFIgPSBbXTtcblxuICAgIC8qIEdldCBkYXRhIGZyb20gaW5wdXQgYnVmZmVyIGFuZCBmaWxsIHRoZSBmb3VyIHdvcmRzIGludG8gUiAqL1xuICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgdmFyIHZhbCA9IF9pbnB1dC5nZXRJbnQxNkxlKCk7XG5cbiAgICAgIGlmKF9pdiAhPT0gbnVsbCkge1xuICAgICAgICBpZihlbmNyeXB0KSB7XG4gICAgICAgICAgLyogV2UncmUgZW5jcnlwdGluZywgYXBwbHkgdGhlIElWIGZpcnN0LiAqL1xuICAgICAgICAgIHZhbCBePSBfaXYuZ2V0SW50MTZMZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIFdlJ3JlIGRlY3J5cHRpb24sIGtlZXAgY2lwaGVyIHRleHQgZm9yIG5leHQgYmxvY2suICovXG4gICAgICAgICAgX2l2LnB1dEludDE2TGUodmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBSLnB1c2godmFsICYgMHhmZmZmKTtcbiAgICB9XG5cbiAgICAvKiBSZXNldCBnbG9iYWwgXCJqXCIgdmFyaWFibGUgYXMgcGVyIHNwZWMuICovXG4gICAgaiA9IGVuY3J5cHQgPyAwIDogNjM7XG5cbiAgICAvKiBSdW4gZXhlY3V0aW9uIHBsYW4uICovXG4gICAgZm9yKHZhciBwdHIgPSAwOyBwdHIgPCBwbGFuLmxlbmd0aDsgcHRyKyspIHtcbiAgICAgIGZvcih2YXIgY3RyID0gMDsgY3RyIDwgcGxhbltwdHJdWzBdOyBjdHIrKykge1xuICAgICAgICBwbGFuW3B0cl1bMV0oUik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogV3JpdGUgYmFjayByZXN1bHQgdG8gb3V0cHV0IGJ1ZmZlci4gKi9cbiAgICBmb3IoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIGlmKF9pdiAhPT0gbnVsbCkge1xuICAgICAgICBpZihlbmNyeXB0KSB7XG4gICAgICAgICAgLyogV2UncmUgZW5jcnlwdGluZyBpbiBDQkMtbW9kZSwgZmVlZCBiYWNrIGVuY3J5cHRlZCBieXRlcyBpbnRvXG4gICAgICAgICAgICAgSVYgYnVmZmVyIHRvIGNhcnJ5IGl0IGZvcndhcmQgdG8gbmV4dCBibG9jay4gKi9cbiAgICAgICAgICBfaXYucHV0SW50MTZMZShSW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSW2ldIF49IF9pdi5nZXRJbnQxNkxlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX291dHB1dC5wdXRJbnQxNkxlKFJbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvKiBDcmVhdGUgY2lwaGVyIG9iamVjdCAqL1xuICB2YXIgY2lwaGVyID0gbnVsbDtcbiAgY2lwaGVyID0ge1xuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBvciByZXN0YXJ0cyB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHByb2Nlc3MsIHdoaWNoZXZlclxuICAgICAqIHdhcyBwcmV2aW91c2x5IGNvbmZpZ3VyZWQuXG4gICAgICpcbiAgICAgKiBUbyB1c2UgdGhlIGNpcGhlciBpbiBDQkMgbW9kZSwgaXYgbWF5IGJlIGdpdmVuIGVpdGhlciBhcyBhIHN0cmluZ1xuICAgICAqIG9mIGJ5dGVzLCBvciBhcyBhIGJ5dGUgYnVmZmVyLiAgRm9yIEVDQiBtb2RlLCBnaXZlIG51bGwgYXMgaXYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UsIG51bGwgZm9yIEVDQiBtb2RlLlxuICAgICAqIEBwYXJhbSBvdXRwdXQgdGhlIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gICAgICovXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKGl2LCBvdXRwdXQpIHtcbiAgICAgIGlmKGl2KSB7XG4gICAgICAgIC8qIENCQyBtb2RlICovXG4gICAgICAgIGlmKHR5cGVvZiBpdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpdiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGl2KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfZmluaXNoID0gZmFsc2U7XG4gICAgICBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgX291dHB1dCA9IG91dHB1dCB8fCBuZXcgZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIF9pdiA9IGl2O1xuXG4gICAgICBjaXBoZXIub3V0cHV0ID0gX291dHB1dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbmV4dCBibG9jay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCB0aGUgYnVmZmVyIHRvIHJlYWQgZnJvbS5cbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICBpZighX2ZpbmlzaCkge1xuICAgICAgICAvLyBub3QgZmluaXNoaW5nLCBzbyBmaWxsIHRoZSBpbnB1dCBidWZmZXIgd2l0aCBtb3JlIGlucHV0XG4gICAgICAgIF9pbnB1dC5wdXRCdWZmZXIoaW5wdXQpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZShfaW5wdXQubGVuZ3RoKCkgPj0gOCkge1xuICAgICAgICBydW5QbGFuKFtcbiAgICAgICAgICAgIFsgNSwgbWl4Um91bmQgXSxcbiAgICAgICAgICAgIFsgMSwgbWFzaFJvdW5kIF0sXG4gICAgICAgICAgICBbIDYsIG1peFJvdW5kIF0sXG4gICAgICAgICAgICBbIDEsIG1hc2hSb3VuZCBdLFxuICAgICAgICAgICAgWyA1LCBtaXhSb3VuZCBdXG4gICAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmlzaGVzIGVuY3J5cHRpbmcgb3IgZGVjcnlwdGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWQgYSBwYWRkaW5nIGZ1bmN0aW9uIHRvIHVzZSwgbnVsbCBmb3IgUEtDUyM3IHBhZGRpbmcsXG4gICAgICogICAgICAgICAgIHNpZ25hdHVyZShibG9ja1NpemUsIGJ1ZmZlciwgZGVjcnlwdCkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRydWUgaWYgc3VjY2Vzc2Z1bCwgZmFsc2Ugb24gZXJyb3IuXG4gICAgICovXG4gICAgZmluaXNoOiBmdW5jdGlvbihwYWQpIHtcbiAgICAgIHZhciBydmFsID0gdHJ1ZTtcblxuICAgICAgaWYoZW5jcnlwdCkge1xuICAgICAgICBpZihwYWQpIHtcbiAgICAgICAgICBydmFsID0gcGFkKDgsIF9pbnB1dCwgIWVuY3J5cHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFkZCBQS0NTIzcgcGFkZGluZyB0byBibG9jayAoZWFjaCBwYWQgYnl0ZSBpcyB0aGVcbiAgICAgICAgICAvLyB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIHBhZCBieXRlcylcbiAgICAgICAgICB2YXIgcGFkZGluZyA9IChfaW5wdXQubGVuZ3RoKCkgPT09IDgpID8gOCA6ICg4IC0gX2lucHV0Lmxlbmd0aCgpKTtcbiAgICAgICAgICBfaW5wdXQuZmlsbFdpdGhCeXRlKHBhZGRpbmcsIHBhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHJ2YWwpIHtcbiAgICAgICAgLy8gZG8gZmluYWwgdXBkYXRlXG4gICAgICAgIF9maW5pc2ggPSB0cnVlO1xuICAgICAgICBjaXBoZXIudXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCFlbmNyeXB0KSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBlcnJvcjogaW5wdXQgZGF0YSBub3QgYSBtdWx0aXBsZSBvZiBibG9jayBzaXplXG4gICAgICAgIHJ2YWwgPSAoX2lucHV0Lmxlbmd0aCgpID09PSAwKTtcbiAgICAgICAgaWYocnZhbCkge1xuICAgICAgICAgIGlmKHBhZCkge1xuICAgICAgICAgICAgcnZhbCA9IHBhZCg4LCBfb3V0cHV0LCAhZW5jcnlwdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBwYWRkaW5nIGJ5dGUgY291bnQgaXMgdmFsaWRcbiAgICAgICAgICAgIHZhciBsZW4gPSBfb3V0cHV0Lmxlbmd0aCgpO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gX291dHB1dC5hdChsZW4gLSAxKTtcblxuICAgICAgICAgICAgaWYoY291bnQgPiBsZW4pIHtcbiAgICAgICAgICAgICAgcnZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gdHJpbSBvZmYgcGFkZGluZyBieXRlc1xuICAgICAgICAgICAgICBfb3V0cHV0LnRydW5jYXRlKGNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUkMyIGNpcGhlciBvYmplY3QgdG8gZW5jcnlwdCBkYXRhIGluIEVDQiBvciBDQkMgbW9kZSB1c2luZyB0aGVcbiAqIGdpdmVuIHN5bW1ldHJpYyBrZXkuIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlclxuICogb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqIFRoZSBjaXBoZXIgaXMgaW5pdGlhbGl6ZWQgdG8gdXNlIDEyOCBlZmZlY3RpdmUga2V5IGJpdHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5zdGFydEVuY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQpIHtcbiAgdmFyIGNpcGhlciA9IGZvcmdlLnJjMi5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyKGtleSwgMTI4KTtcbiAgY2lwaGVyLnN0YXJ0KGl2LCBvdXRwdXQpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJDMiBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSBpbiBFQ0Igb3IgQ0JDIG1vZGUgdXNpbmcgdGhlXG4gKiBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogVG8gc3RhcnQgZW5jcnlwdGluZyBjYWxsIHN0YXJ0KCkgb24gdGhlIGNpcGhlciB3aXRoIGFuIGl2IGFuZCBvcHRpb25hbFxuICogb3V0cHV0IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBiaXRzKSB7XG4gIHJldHVybiBjcmVhdGVDaXBoZXIoa2V5LCBiaXRzLCB0cnVlKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSQzIgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgaW4gRUNCIG9yIENCQyBtb2RlIHVzaW5nIHRoZVxuICogZ2l2ZW4gc3ltbWV0cmljIGtleS4gVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyXG4gKiBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcyBvciBhIGJ5dGUgYnVmZmVyLlxuICogVGhlIGNpcGhlciBpcyBpbml0aWFsaXplZCB0byB1c2UgMTI4IGVmZmVjdGl2ZSBrZXkgYml0cy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UucmMyLnN0YXJ0RGVjcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCkge1xuICB2YXIgY2lwaGVyID0gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCAxMjgpO1xuICBjaXBoZXIuc3RhcnQoaXYsIG91dHB1dCk7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUkMyIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIGluIEVDQiBvciBDQkMgbW9kZSB1c2luZyB0aGVcbiAqIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBUbyBzdGFydCBkZWNyeXB0aW5nIGNhbGwgc3RhcnQoKSBvbiB0aGUgY2lwaGVyIHdpdGggYW4gaXYgYW5kIG9wdGlvbmFsXG4gKiBvdXRwdXQgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIGJpdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZUNpcGhlcihrZXksIGJpdHMsIGZhbHNlKTtcbn07XG4iLCIvKipcbiAqIERFUyAoRGF0YSBFbmNyeXB0aW9uIFN0YW5kYXJkKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIHN1cHBvcnRzIERFUyBhcyB3ZWxsIGFzIDNERVMtRURFIGluIEVDQiBhbmQgQ0JDIG1vZGUuXG4gKiBJdCBpcyBiYXNlZCBvbiB0aGUgQlNELWxpY2Vuc2VkIGltcGxlbWVudGF0aW9uIGJ5IFBhdWwgVGVybzpcbiAqXG4gKiBQYXVsIFRlcm8sIEp1bHkgMjAwMVxuICogaHR0cDovL3d3dy50ZXJvLmNvLnVrL2Rlcy9cbiAqXG4gKiBPcHRpbWlzZWQgZm9yIHBlcmZvcm1hbmNlIHdpdGggbGFyZ2UgYmxvY2tzIGJ5XG4gKiBNaWNoYWVsIEhheXdvcnRoLCBOb3ZlbWJlciAyMDAxXG4gKiBodHRwOi8vd3d3Lm5ldGRlYWxpbmcuY29tXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRVxuICogRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAqIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gKiBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTilcbiAqIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUXG4gKiBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZXG4gKiBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gKiBTVUNIIERBTUFHRS5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vY2lwaGVyJyk7XG5yZXF1aXJlKCcuL2NpcGhlck1vZGVzJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuLyogREVTIEFQSSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5kZXMgPSBmb3JnZS5kZXMgfHwge307XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqIGNpcGhlci5zdGFydCh7aXY6IGl2fSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKiBUaGUgb3V0cHV0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSAnb3V0cHV0JyBtZW1iZXIgb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYmluYXJ5LWVuY29kZWQgc3RyaW5ncyBvZiBieXRlcyBvclxuICogYnl0ZSBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlICg2NCBvciAxOTIgYml0cykuXG4gKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBjaXBoZXIgbW9kZSB0byB1c2UgKGRlZmF1bHQ6ICdDQkMnIGlmIElWIGlzXG4gKiAgICAgICAgICBnaXZlbiwgJ0VDQicgaWYgbnVsbCkuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5kZXMuc3RhcnRFbmNyeXB0aW5nID0gZnVuY3Rpb24oa2V5LCBpdiwgb3V0cHV0LCBtb2RlKSB7XG4gIHZhciBjaXBoZXIgPSBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICBkZWNyeXB0OiBmYWxzZSxcbiAgICBtb2RlOiBtb2RlIHx8IChpdiA9PT0gbnVsbCA/ICdFQ0InIDogJ0NCQycpXG4gIH0pO1xuICBjaXBoZXIuc3RhcnQoaXYpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICpcbiAqIENyZWF0ZXMgYW4gREVTIGNpcGhlciBvYmplY3QgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBjaXBoZXIgbW9kZSB0byB1c2UgKGRlZmF1bHQ6ICdDQkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBtb2RlKSB7XG4gIHJldHVybiBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG51bGwsXG4gICAgZGVjcnlwdDogZmFsc2UsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBkZWNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKiBkZWNpcGhlci5zdGFydCh7aXY6IGl2fSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKiBUaGUgb3V0cHV0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSAnb3V0cHV0JyBtZW1iZXIgb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYmluYXJ5LWVuY29kZWQgc3RyaW5ncyBvZiBieXRlcyBvclxuICogYnl0ZSBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlICg2NCBvciAxOTIgYml0cykuXG4gKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBjaXBoZXIgbW9kZSB0byB1c2UgKGRlZmF1bHQ6ICdDQkMnIGlmIElWIGlzXG4gKiAgICAgICAgICBnaXZlbiwgJ0VDQicgaWYgbnVsbCkuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5kZXMuc3RhcnREZWNyeXB0aW5nID0gZnVuY3Rpb24oa2V5LCBpdiwgb3V0cHV0LCBtb2RlKSB7XG4gIHZhciBjaXBoZXIgPSBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICBkZWNyeXB0OiB0cnVlLFxuICAgIG1vZGU6IG1vZGUgfHwgKGl2ID09PSBudWxsID8gJ0VDQicgOiAnQ0JDJylcbiAgfSk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgZGVjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICpcbiAqIENyZWF0ZXMgYW4gREVTIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBjaXBoZXIgbW9kZSB0byB1c2UgKGRlZmF1bHQ6ICdDQkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBtb2RlKSB7XG4gIHJldHVybiBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG51bGwsXG4gICAgZGVjcnlwdDogdHJ1ZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IERFUyBjaXBoZXIgYWxnb3JpdGhtIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYWxnb3JpdGhtLlxuICogQHBhcmFtIG1vZGUgdGhlIG1vZGUgZmFjdG9yeSBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBERVMgYWxnb3JpdGhtIG9iamVjdC5cbiAqL1xuZm9yZ2UuZGVzLkFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUsIG1vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm5hbWUgPSBuYW1lO1xuICBzZWxmLm1vZGUgPSBuZXcgbW9kZSh7XG4gICAgYmxvY2tTaXplOiA4LFxuICAgIGNpcGhlcjoge1xuICAgICAgZW5jcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmLl9rZXlzLCBpbkJsb2NrLCBvdXRCbG9jaywgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uKGluQmxvY2ssIG91dEJsb2NrKSB7XG4gICAgICAgIHJldHVybiBfdXBkYXRlQmxvY2soc2VsZi5fa2V5cywgaW5CbG9jaywgb3V0QmxvY2ssIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHNlbGYuX2luaXQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhpcyBERVMgYWxnb3JpdGhtIGJ5IGV4cGFuZGluZyBpdHMga2V5LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZS5cbiAqICAgICAgICAgIGtleSB0aGUga2V5IHRvIHVzZSB3aXRoIHRoaXMgYWxnb3JpdGhtLlxuICogICAgICAgICAgZGVjcnlwdCB0cnVlIGlmIHRoZSBhbGdvcml0aG0gc2hvdWxkIGJlIGluaXRpYWxpemVkIGZvciBkZWNyeXB0aW9uLFxuICogICAgICAgICAgICBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqL1xuZm9yZ2UuZGVzLkFsZ29yaXRobS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYodGhpcy5faW5pdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihvcHRpb25zLmtleSk7XG4gIGlmKHRoaXMubmFtZS5pbmRleE9mKCczREVTJykgPT09IDApIHtcbiAgICBpZihrZXkubGVuZ3RoKCkgIT09IDI0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVHJpcGxlLURFUyBrZXkgc2l6ZTogJyArIGtleS5sZW5ndGgoKSAqIDgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRvIGtleSBleHBhbnNpb24gdG8gMTYgb3IgNDggc3Via2V5cyAoc2luZ2xlIG9yIHRyaXBsZSBERVMpXG4gIHRoaXMuX2tleXMgPSBfY3JlYXRlS2V5cyhrZXkpO1xuICB0aGlzLl9pbml0ID0gdHJ1ZTtcbn07XG5cbi8qKiBSZWdpc3RlciBERVMgYWxnb3JpdGhtcyAqKi9cblxucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1FQ0InLCBmb3JnZS5jaXBoZXIubW9kZXMuZWNiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdERVMtQ0JDJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmNiYyk7XG5yZWdpc3RlckFsZ29yaXRobSgnREVTLUNGQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1PRkInLCBmb3JnZS5jaXBoZXIubW9kZXMub2ZiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdERVMtQ1RSJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmN0cik7XG5cbnJlZ2lzdGVyQWxnb3JpdGhtKCczREVTLUVDQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5lY2IpO1xucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtQ0JDJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmNiYyk7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DRkInLCBmb3JnZS5jaXBoZXIubW9kZXMuY2ZiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCczREVTLU9GQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5vZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtQ1RSJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmN0cik7XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIG1vZGUpIHtcbiAgdmFyIGZhY3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IGZvcmdlLmRlcy5BbGdvcml0aG0obmFtZSwgbW9kZSk7XG4gIH07XG4gIGZvcmdlLmNpcGhlci5yZWdpc3RlckFsZ29yaXRobShuYW1lLCBmYWN0b3J5KTtcbn1cblxuLyoqIERFUyBpbXBsZW1lbnRhdGlvbiAqKi9cblxudmFyIHNwZnVuY3Rpb24xID0gWzB4MTAxMDQwMCwwLDB4MTAwMDAsMHgxMDEwNDA0LDB4MTAxMDAwNCwweDEwNDA0LDB4NCwweDEwMDAwLDB4NDAwLDB4MTAxMDQwMCwweDEwMTA0MDQsMHg0MDAsMHgxMDAwNDA0LDB4MTAxMDAwNCwweDEwMDAwMDAsMHg0LDB4NDA0LDB4MTAwMDQwMCwweDEwMDA0MDAsMHgxMDQwMCwweDEwNDAwLDB4MTAxMDAwMCwweDEwMTAwMDAsMHgxMDAwNDA0LDB4MTAwMDQsMHgxMDAwMDA0LDB4MTAwMDAwNCwweDEwMDA0LDAsMHg0MDQsMHgxMDQwNCwweDEwMDAwMDAsMHgxMDAwMCwweDEwMTA0MDQsMHg0LDB4MTAxMDAwMCwweDEwMTA0MDAsMHgxMDAwMDAwLDB4MTAwMDAwMCwweDQwMCwweDEwMTAwMDQsMHgxMDAwMCwweDEwNDAwLDB4MTAwMDAwNCwweDQwMCwweDQsMHgxMDAwNDA0LDB4MTA0MDQsMHgxMDEwNDA0LDB4MTAwMDQsMHgxMDEwMDAwLDB4MTAwMDQwNCwweDEwMDAwMDQsMHg0MDQsMHgxMDQwNCwweDEwMTA0MDAsMHg0MDQsMHgxMDAwNDAwLDB4MTAwMDQwMCwwLDB4MTAwMDQsMHgxMDQwMCwwLDB4MTAxMDAwNF07XG52YXIgc3BmdW5jdGlvbjIgPSBbLTB4N2ZlZjdmZTAsLTB4N2ZmZjgwMDAsMHg4MDAwLDB4MTA4MDIwLDB4MTAwMDAwLDB4MjAsLTB4N2ZlZmZmZTAsLTB4N2ZmZjdmZTAsLTB4N2ZmZmZmZTAsLTB4N2ZlZjdmZTAsLTB4N2ZlZjgwMDAsLTB4ODAwMDAwMDAsLTB4N2ZmZjgwMDAsMHgxMDAwMDAsMHgyMCwtMHg3ZmVmZmZlMCwweDEwODAwMCwweDEwMDAyMCwtMHg3ZmZmN2ZlMCwwLC0weDgwMDAwMDAwLDB4ODAwMCwweDEwODAyMCwtMHg3ZmYwMDAwMCwweDEwMDAyMCwtMHg3ZmZmZmZlMCwwLDB4MTA4MDAwLDB4ODAyMCwtMHg3ZmVmODAwMCwtMHg3ZmYwMDAwMCwweDgwMjAsMCwweDEwODAyMCwtMHg3ZmVmZmZlMCwweDEwMDAwMCwtMHg3ZmZmN2ZlMCwtMHg3ZmYwMDAwMCwtMHg3ZmVmODAwMCwweDgwMDAsLTB4N2ZmMDAwMDAsLTB4N2ZmZjgwMDAsMHgyMCwtMHg3ZmVmN2ZlMCwweDEwODAyMCwweDIwLDB4ODAwMCwtMHg4MDAwMDAwMCwweDgwMjAsLTB4N2ZlZjgwMDAsMHgxMDAwMDAsLTB4N2ZmZmZmZTAsMHgxMDAwMjAsLTB4N2ZmZjdmZTAsLTB4N2ZmZmZmZTAsMHgxMDAwMjAsMHgxMDgwMDAsMCwtMHg3ZmZmODAwMCwweDgwMjAsLTB4ODAwMDAwMDAsLTB4N2ZlZmZmZTAsLTB4N2ZlZjdmZTAsMHgxMDgwMDBdO1xudmFyIHNwZnVuY3Rpb24zID0gWzB4MjA4LDB4ODAyMDIwMCwwLDB4ODAyMDAwOCwweDgwMDAyMDAsMCwweDIwMjA4LDB4ODAwMDIwMCwweDIwMDA4LDB4ODAwMDAwOCwweDgwMDAwMDgsMHgyMDAwMCwweDgwMjAyMDgsMHgyMDAwOCwweDgwMjAwMDAsMHgyMDgsMHg4MDAwMDAwLDB4OCwweDgwMjAyMDAsMHgyMDAsMHgyMDIwMCwweDgwMjAwMDAsMHg4MDIwMDA4LDB4MjAyMDgsMHg4MDAwMjA4LDB4MjAyMDAsMHgyMDAwMCwweDgwMDAyMDgsMHg4LDB4ODAyMDIwOCwweDIwMCwweDgwMDAwMDAsMHg4MDIwMjAwLDB4ODAwMDAwMCwweDIwMDA4LDB4MjA4LDB4MjAwMDAsMHg4MDIwMjAwLDB4ODAwMDIwMCwwLDB4MjAwLDB4MjAwMDgsMHg4MDIwMjA4LDB4ODAwMDIwMCwweDgwMDAwMDgsMHgyMDAsMCwweDgwMjAwMDgsMHg4MDAwMjA4LDB4MjAwMDAsMHg4MDAwMDAwLDB4ODAyMDIwOCwweDgsMHgyMDIwOCwweDIwMjAwLDB4ODAwMDAwOCwweDgwMjAwMDAsMHg4MDAwMjA4LDB4MjA4LDB4ODAyMDAwMCwweDIwMjA4LDB4OCwweDgwMjAwMDgsMHgyMDIwMF07XG52YXIgc3BmdW5jdGlvbjQgPSBbMHg4MDIwMDEsMHgyMDgxLDB4MjA4MSwweDgwLDB4ODAyMDgwLDB4ODAwMDgxLDB4ODAwMDAxLDB4MjAwMSwwLDB4ODAyMDAwLDB4ODAyMDAwLDB4ODAyMDgxLDB4ODEsMCwweDgwMDA4MCwweDgwMDAwMSwweDEsMHgyMDAwLDB4ODAwMDAwLDB4ODAyMDAxLDB4ODAsMHg4MDAwMDAsMHgyMDAxLDB4MjA4MCwweDgwMDA4MSwweDEsMHgyMDgwLDB4ODAwMDgwLDB4MjAwMCwweDgwMjA4MCwweDgwMjA4MSwweDgxLDB4ODAwMDgwLDB4ODAwMDAxLDB4ODAyMDAwLDB4ODAyMDgxLDB4ODEsMCwwLDB4ODAyMDAwLDB4MjA4MCwweDgwMDA4MCwweDgwMDA4MSwweDEsMHg4MDIwMDEsMHgyMDgxLDB4MjA4MSwweDgwLDB4ODAyMDgxLDB4ODEsMHgxLDB4MjAwMCwweDgwMDAwMSwweDIwMDEsMHg4MDIwODAsMHg4MDAwODEsMHgyMDAxLDB4MjA4MCwweDgwMDAwMCwweDgwMjAwMSwweDgwLDB4ODAwMDAwLDB4MjAwMCwweDgwMjA4MF07XG52YXIgc3BmdW5jdGlvbjUgPSBbMHgxMDAsMHgyMDgwMTAwLDB4MjA4MDAwMCwweDQyMDAwMTAwLDB4ODAwMDAsMHgxMDAsMHg0MDAwMDAwMCwweDIwODAwMDAsMHg0MDA4MDEwMCwweDgwMDAwLDB4MjAwMDEwMCwweDQwMDgwMTAwLDB4NDIwMDAxMDAsMHg0MjA4MDAwMCwweDgwMTAwLDB4NDAwMDAwMDAsMHgyMDAwMDAwLDB4NDAwODAwMDAsMHg0MDA4MDAwMCwwLDB4NDAwMDAxMDAsMHg0MjA4MDEwMCwweDQyMDgwMTAwLDB4MjAwMDEwMCwweDQyMDgwMDAwLDB4NDAwMDAxMDAsMCwweDQyMDAwMDAwLDB4MjA4MDEwMCwweDIwMDAwMDAsMHg0MjAwMDAwMCwweDgwMTAwLDB4ODAwMDAsMHg0MjAwMDEwMCwweDEwMCwweDIwMDAwMDAsMHg0MDAwMDAwMCwweDIwODAwMDAsMHg0MjAwMDEwMCwweDQwMDgwMTAwLDB4MjAwMDEwMCwweDQwMDAwMDAwLDB4NDIwODAwMDAsMHgyMDgwMTAwLDB4NDAwODAxMDAsMHgxMDAsMHgyMDAwMDAwLDB4NDIwODAwMDAsMHg0MjA4MDEwMCwweDgwMTAwLDB4NDIwMDAwMDAsMHg0MjA4MDEwMCwweDIwODAwMDAsMCwweDQwMDgwMDAwLDB4NDIwMDAwMDAsMHg4MDEwMCwweDIwMDAxMDAsMHg0MDAwMDEwMCwweDgwMDAwLDAsMHg0MDA4MDAwMCwweDIwODAxMDAsMHg0MDAwMDEwMF07XG52YXIgc3BmdW5jdGlvbjYgPSBbMHgyMDAwMDAxMCwweDIwNDAwMDAwLDB4NDAwMCwweDIwNDA0MDEwLDB4MjA0MDAwMDAsMHgxMCwweDIwNDA0MDEwLDB4NDAwMDAwLDB4MjAwMDQwMDAsMHg0MDQwMTAsMHg0MDAwMDAsMHgyMDAwMDAxMCwweDQwMDAxMCwweDIwMDA0MDAwLDB4MjAwMDAwMDAsMHg0MDEwLDAsMHg0MDAwMTAsMHgyMDAwNDAxMCwweDQwMDAsMHg0MDQwMDAsMHgyMDAwNDAxMCwweDEwLDB4MjA0MDAwMTAsMHgyMDQwMDAxMCwwLDB4NDA0MDEwLDB4MjA0MDQwMDAsMHg0MDEwLDB4NDA0MDAwLDB4MjA0MDQwMDAsMHgyMDAwMDAwMCwweDIwMDA0MDAwLDB4MTAsMHgyMDQwMDAxMCwweDQwNDAwMCwweDIwNDA0MDEwLDB4NDAwMDAwLDB4NDAxMCwweDIwMDAwMDEwLDB4NDAwMDAwLDB4MjAwMDQwMDAsMHgyMDAwMDAwMCwweDQwMTAsMHgyMDAwMDAxMCwweDIwNDA0MDEwLDB4NDA0MDAwLDB4MjA0MDAwMDAsMHg0MDQwMTAsMHgyMDQwNDAwMCwwLDB4MjA0MDAwMTAsMHgxMCwweDQwMDAsMHgyMDQwMDAwMCwweDQwNDAxMCwweDQwMDAsMHg0MDAwMTAsMHgyMDAwNDAxMCwwLDB4MjA0MDQwMDAsMHgyMDAwMDAwMCwweDQwMDAxMCwweDIwMDA0MDEwXTtcbnZhciBzcGZ1bmN0aW9uNyA9IFsweDIwMDAwMCwweDQyMDAwMDIsMHg0MDAwODAyLDAsMHg4MDAsMHg0MDAwODAyLDB4MjAwODAyLDB4NDIwMDgwMCwweDQyMDA4MDIsMHgyMDAwMDAsMCwweDQwMDAwMDIsMHgyLDB4NDAwMDAwMCwweDQyMDAwMDIsMHg4MDIsMHg0MDAwODAwLDB4MjAwODAyLDB4MjAwMDAyLDB4NDAwMDgwMCwweDQwMDAwMDIsMHg0MjAwMDAwLDB4NDIwMDgwMCwweDIwMDAwMiwweDQyMDAwMDAsMHg4MDAsMHg4MDIsMHg0MjAwODAyLDB4MjAwODAwLDB4MiwweDQwMDAwMDAsMHgyMDA4MDAsMHg0MDAwMDAwLDB4MjAwODAwLDB4MjAwMDAwLDB4NDAwMDgwMiwweDQwMDA4MDIsMHg0MjAwMDAyLDB4NDIwMDAwMiwweDIsMHgyMDAwMDIsMHg0MDAwMDAwLDB4NDAwMDgwMCwweDIwMDAwMCwweDQyMDA4MDAsMHg4MDIsMHgyMDA4MDIsMHg0MjAwODAwLDB4ODAyLDB4NDAwMDAwMiwweDQyMDA4MDIsMHg0MjAwMDAwLDB4MjAwODAwLDAsMHgyLDB4NDIwMDgwMiwwLDB4MjAwODAyLDB4NDIwMDAwMCwweDgwMCwweDQwMDAwMDIsMHg0MDAwODAwLDB4ODAwLDB4MjAwMDAyXTtcbnZhciBzcGZ1bmN0aW9uOCA9IFsweDEwMDAxMDQwLDB4MTAwMCwweDQwMDAwLDB4MTAwNDEwNDAsMHgxMDAwMDAwMCwweDEwMDAxMDQwLDB4NDAsMHgxMDAwMDAwMCwweDQwMDQwLDB4MTAwNDAwMDAsMHgxMDA0MTA0MCwweDQxMDAwLDB4MTAwNDEwMDAsMHg0MTA0MCwweDEwMDAsMHg0MCwweDEwMDQwMDAwLDB4MTAwMDAwNDAsMHgxMDAwMTAwMCwweDEwNDAsMHg0MTAwMCwweDQwMDQwLDB4MTAwNDAwNDAsMHgxMDA0MTAwMCwweDEwNDAsMCwwLDB4MTAwNDAwNDAsMHgxMDAwMDA0MCwweDEwMDAxMDAwLDB4NDEwNDAsMHg0MDAwMCwweDQxMDQwLDB4NDAwMDAsMHgxMDA0MTAwMCwweDEwMDAsMHg0MCwweDEwMDQwMDQwLDB4MTAwMCwweDQxMDQwLDB4MTAwMDEwMDAsMHg0MCwweDEwMDAwMDQwLDB4MTAwNDAwMDAsMHgxMDA0MDA0MCwweDEwMDAwMDAwLDB4NDAwMDAsMHgxMDAwMTA0MCwwLDB4MTAwNDEwNDAsMHg0MDA0MCwweDEwMDAwMDQwLDB4MTAwNDAwMDAsMHgxMDAwMTAwMCwweDEwMDAxMDQwLDAsMHgxMDA0MTA0MCwweDQxMDAwLDB4NDEwMDAsMHgxMDQwLDB4MTA0MCwweDQwMDQwLDB4MTAwMDAwMDAsMHgxMDA0MTAwMF07XG5cbi8qKlxuICogQ3JlYXRlIG5lY2Vzc2FyeSBzdWIga2V5cy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSA2NC1iaXQgb3IgMTkyLWJpdCBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgZXhwYW5kZWQga2V5cy5cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUtleXMoa2V5KSB7XG4gIHZhciBwYzJieXRlczAgID0gWzAsMHg0LDB4MjAwMDAwMDAsMHgyMDAwMDAwNCwweDEwMDAwLDB4MTAwMDQsMHgyMDAxMDAwMCwweDIwMDEwMDA0LDB4MjAwLDB4MjA0LDB4MjAwMDAyMDAsMHgyMDAwMDIwNCwweDEwMjAwLDB4MTAyMDQsMHgyMDAxMDIwMCwweDIwMDEwMjA0XSxcbiAgICAgIHBjMmJ5dGVzMSAgPSBbMCwweDEsMHgxMDAwMDAsMHgxMDAwMDEsMHg0MDAwMDAwLDB4NDAwMDAwMSwweDQxMDAwMDAsMHg0MTAwMDAxLDB4MTAwLDB4MTAxLDB4MTAwMTAwLDB4MTAwMTAxLDB4NDAwMDEwMCwweDQwMDAxMDEsMHg0MTAwMTAwLDB4NDEwMDEwMV0sXG4gICAgICBwYzJieXRlczIgID0gWzAsMHg4LDB4ODAwLDB4ODA4LDB4MTAwMDAwMCwweDEwMDAwMDgsMHgxMDAwODAwLDB4MTAwMDgwOCwwLDB4OCwweDgwMCwweDgwOCwweDEwMDAwMDAsMHgxMDAwMDA4LDB4MTAwMDgwMCwweDEwMDA4MDhdLFxuICAgICAgcGMyYnl0ZXMzICA9IFswLDB4MjAwMDAwLDB4ODAwMDAwMCwweDgyMDAwMDAsMHgyMDAwLDB4MjAyMDAwLDB4ODAwMjAwMCwweDgyMDIwMDAsMHgyMDAwMCwweDIyMDAwMCwweDgwMjAwMDAsMHg4MjIwMDAwLDB4MjIwMDAsMHgyMjIwMDAsMHg4MDIyMDAwLDB4ODIyMjAwMF0sXG4gICAgICBwYzJieXRlczQgID0gWzAsMHg0MDAwMCwweDEwLDB4NDAwMTAsMCwweDQwMDAwLDB4MTAsMHg0MDAxMCwweDEwMDAsMHg0MTAwMCwweDEwMTAsMHg0MTAxMCwweDEwMDAsMHg0MTAwMCwweDEwMTAsMHg0MTAxMF0sXG4gICAgICBwYzJieXRlczUgID0gWzAsMHg0MDAsMHgyMCwweDQyMCwwLDB4NDAwLDB4MjAsMHg0MjAsMHgyMDAwMDAwLDB4MjAwMDQwMCwweDIwMDAwMjAsMHgyMDAwNDIwLDB4MjAwMDAwMCwweDIwMDA0MDAsMHgyMDAwMDIwLDB4MjAwMDQyMF0sXG4gICAgICBwYzJieXRlczYgID0gWzAsMHgxMDAwMDAwMCwweDgwMDAwLDB4MTAwODAwMDAsMHgyLDB4MTAwMDAwMDIsMHg4MDAwMiwweDEwMDgwMDAyLDAsMHgxMDAwMDAwMCwweDgwMDAwLDB4MTAwODAwMDAsMHgyLDB4MTAwMDAwMDIsMHg4MDAwMiwweDEwMDgwMDAyXSxcbiAgICAgIHBjMmJ5dGVzNyAgPSBbMCwweDEwMDAwLDB4ODAwLDB4MTA4MDAsMHgyMDAwMDAwMCwweDIwMDEwMDAwLDB4MjAwMDA4MDAsMHgyMDAxMDgwMCwweDIwMDAwLDB4MzAwMDAsMHgyMDgwMCwweDMwODAwLDB4MjAwMjAwMDAsMHgyMDAzMDAwMCwweDIwMDIwODAwLDB4MjAwMzA4MDBdLFxuICAgICAgcGMyYnl0ZXM4ICA9IFswLDB4NDAwMDAsMCwweDQwMDAwLDB4MiwweDQwMDAyLDB4MiwweDQwMDAyLDB4MjAwMDAwMCwweDIwNDAwMDAsMHgyMDAwMDAwLDB4MjA0MDAwMCwweDIwMDAwMDIsMHgyMDQwMDAyLDB4MjAwMDAwMiwweDIwNDAwMDJdLFxuICAgICAgcGMyYnl0ZXM5ICA9IFswLDB4MTAwMDAwMDAsMHg4LDB4MTAwMDAwMDgsMCwweDEwMDAwMDAwLDB4OCwweDEwMDAwMDA4LDB4NDAwLDB4MTAwMDA0MDAsMHg0MDgsMHgxMDAwMDQwOCwweDQwMCwweDEwMDAwNDAwLDB4NDA4LDB4MTAwMDA0MDhdLFxuICAgICAgcGMyYnl0ZXMxMCA9IFswLDB4MjAsMCwweDIwLDB4MTAwMDAwLDB4MTAwMDIwLDB4MTAwMDAwLDB4MTAwMDIwLDB4MjAwMCwweDIwMjAsMHgyMDAwLDB4MjAyMCwweDEwMjAwMCwweDEwMjAyMCwweDEwMjAwMCwweDEwMjAyMF0sXG4gICAgICBwYzJieXRlczExID0gWzAsMHgxMDAwMDAwLDB4MjAwLDB4MTAwMDIwMCwweDIwMDAwMCwweDEyMDAwMDAsMHgyMDAyMDAsMHgxMjAwMjAwLDB4NDAwMDAwMCwweDUwMDAwMDAsMHg0MDAwMjAwLDB4NTAwMDIwMCwweDQyMDAwMDAsMHg1MjAwMDAwLDB4NDIwMDIwMCwweDUyMDAyMDBdLFxuICAgICAgcGMyYnl0ZXMxMiA9IFswLDB4MTAwMCwweDgwMDAwMDAsMHg4MDAxMDAwLDB4ODAwMDAsMHg4MTAwMCwweDgwODAwMDAsMHg4MDgxMDAwLDB4MTAsMHgxMDEwLDB4ODAwMDAxMCwweDgwMDEwMTAsMHg4MDAxMCwweDgxMDEwLDB4ODA4MDAxMCwweDgwODEwMTBdLFxuICAgICAgcGMyYnl0ZXMxMyA9IFswLDB4NCwweDEwMCwweDEwNCwwLDB4NCwweDEwMCwweDEwNCwweDEsMHg1LDB4MTAxLDB4MTA1LDB4MSwweDUsMHgxMDEsMHgxMDVdO1xuXG4gIC8vIGhvdyBtYW55IGl0ZXJhdGlvbnMgKDEgZm9yIGRlcywgMyBmb3IgdHJpcGxlIGRlcylcbiAgLy8gY2hhbmdlZCBieSBQYXVsIDE2LzYvMjAwNyB0byB1c2UgVHJpcGxlIERFUyBmb3IgOSsgYnl0ZSBrZXlzXG4gIHZhciBpdGVyYXRpb25zID0ga2V5Lmxlbmd0aCgpID4gOCA/IDMgOiAxO1xuXG4gIC8vIHN0b3JlcyB0aGUgcmV0dXJuIGtleXNcbiAgdmFyIGtleXMgPSBbXTtcblxuICAvLyBub3cgZGVmaW5lIHRoZSBsZWZ0IHNoaWZ0cyB3aGljaCBuZWVkIHRvIGJlIGRvbmVcbiAgdmFyIHNoaWZ0cyA9IFswLCAwLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAxLCAxLCAxLCAxLCAxLCAxLCAwXTtcblxuICB2YXIgbiA9IDAsIHRtcDtcbiAgZm9yKHZhciBqID0gMDsgaiA8IGl0ZXJhdGlvbnM7IGorKykge1xuICAgIHZhciBsZWZ0ID0ga2V5LmdldEludDMyKCk7XG4gICAgdmFyIHJpZ2h0ID0ga2V5LmdldEludDMyKCk7XG5cbiAgICB0bXAgPSAoKGxlZnQgPj4+IDQpIF4gcmlnaHQpICYgMHgwZjBmMGYwZjtcbiAgICByaWdodCBePSB0bXA7XG4gICAgbGVmdCBePSAodG1wIDw8IDQpO1xuXG4gICAgdG1wID0gKChyaWdodCA+Pj4gLTE2KSBeIGxlZnQpICYgMHgwMDAwZmZmZjtcbiAgICBsZWZ0IF49IHRtcDtcbiAgICByaWdodCBePSAodG1wIDw8IC0xNik7XG5cbiAgICB0bXAgPSAoKGxlZnQgPj4+IDIpIF4gcmlnaHQpICYgMHgzMzMzMzMzMztcbiAgICByaWdodCBePSB0bXA7XG4gICAgbGVmdCBePSAodG1wIDw8IDIpO1xuXG4gICAgdG1wID0gKChyaWdodCA+Pj4gLTE2KSBeIGxlZnQpICYgMHgwMDAwZmZmZjtcbiAgICBsZWZ0IF49IHRtcDtcbiAgICByaWdodCBePSAodG1wIDw8IC0xNik7XG5cbiAgICB0bXAgPSAoKGxlZnQgPj4+IDEpIF4gcmlnaHQpICYgMHg1NTU1NTU1NTtcbiAgICByaWdodCBePSB0bXA7XG4gICAgbGVmdCBePSAodG1wIDw8IDEpO1xuXG4gICAgdG1wID0gKChyaWdodCA+Pj4gOCkgXiBsZWZ0KSAmIDB4MDBmZjAwZmY7XG4gICAgbGVmdCBePSB0bXA7XG4gICAgcmlnaHQgXj0gKHRtcCA8PCA4KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMSkgXiByaWdodCkgJiAweDU1NTU1NTU1O1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgICAvLyByaWdodCBuZWVkcyB0byBiZSBzaGlmdGVkIGFuZCBPUidkIHdpdGggbGFzdCBmb3VyIGJpdHMgb2YgbGVmdFxuICAgIHRtcCA9IChsZWZ0IDw8IDgpIHwgKChyaWdodCA+Pj4gMjApICYgMHgwMDAwMDBmMCk7XG5cbiAgICAvLyBsZWZ0IG5lZWRzIHRvIGJlIHB1dCB1cHNpZGUgZG93blxuICAgIGxlZnQgPSAoKHJpZ2h0IDw8IDI0KSB8ICgocmlnaHQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgKChyaWdodCA+Pj4gOCkgJiAweGZmMDApIHwgKChyaWdodCA+Pj4gMjQpICYgMHhmMCkpO1xuICAgIHJpZ2h0ID0gdG1wO1xuXG4gICAgLy8gbm93IGdvIHRocm91Z2ggYW5kIHBlcmZvcm0gdGhlc2Ugc2hpZnRzIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBrZXlzXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNoaWZ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgLy9zaGlmdCB0aGUga2V5cyBlaXRoZXIgb25lIG9yIHR3byBiaXRzIHRvIHRoZSBsZWZ0XG4gICAgICBpZihzaGlmdHNbaV0pIHtcbiAgICAgICAgbGVmdCA9IChsZWZ0IDw8IDIpIHwgKGxlZnQgPj4+IDI2KTtcbiAgICAgICAgcmlnaHQgPSAocmlnaHQgPDwgMikgfCAocmlnaHQgPj4+IDI2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgPSAobGVmdCA8PCAxKSB8IChsZWZ0ID4+PiAyNyk7XG4gICAgICAgIHJpZ2h0ID0gKHJpZ2h0IDw8IDEpIHwgKHJpZ2h0ID4+PiAyNyk7XG4gICAgICB9XG4gICAgICBsZWZ0ICY9IC0weGY7XG4gICAgICByaWdodCAmPSAtMHhmO1xuXG4gICAgICAvLyBub3cgYXBwbHkgUEMtMiwgaW4gc3VjaCBhIHdheSB0aGF0IEUgaXMgZWFzaWVyIHdoZW4gZW5jcnlwdGluZyBvclxuICAgICAgLy8gZGVjcnlwdGluZyB0aGlzIGNvbnZlcnNpb24gd2lsbCBsb29rIGxpa2UgUEMtMiBleGNlcHQgb25seSB0aGUgbGFzdCA2XG4gICAgICAvLyBiaXRzIG9mIGVhY2ggYnl0ZSBhcmUgdXNlZCByYXRoZXIgdGhhbiA0OCBjb25zZWN1dGl2ZSBiaXRzIGFuZCB0aGVcbiAgICAgIC8vIG9yZGVyIG9mIGxpbmVzIHdpbGwgYmUgYWNjb3JkaW5nIHRvIGhvdyB0aGUgUyBzZWxlY3Rpb24gZnVuY3Rpb25zIHdpbGxcbiAgICAgIC8vIGJlIGFwcGxpZWQ6IFMyLCBTNCwgUzYsIFM4LCBTMSwgUzMsIFM1LCBTN1xuICAgICAgdmFyIGxlZnR0bXAgPSAoXG4gICAgICAgIHBjMmJ5dGVzMFtsZWZ0ID4+PiAyOF0gfCBwYzJieXRlczFbKGxlZnQgPj4+IDI0KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczJbKGxlZnQgPj4+IDIwKSAmIDB4Zl0gfCBwYzJieXRlczNbKGxlZnQgPj4+IDE2KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczRbKGxlZnQgPj4+IDEyKSAmIDB4Zl0gfCBwYzJieXRlczVbKGxlZnQgPj4+IDgpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzNlsobGVmdCA+Pj4gNCkgJiAweGZdKTtcbiAgICAgIHZhciByaWdodHRtcCA9IChcbiAgICAgICAgcGMyYnl0ZXM3W3JpZ2h0ID4+PiAyOF0gfCBwYzJieXRlczhbKHJpZ2h0ID4+PiAyNCkgJiAweGZdIHxcbiAgICAgICAgcGMyYnl0ZXM5WyhyaWdodCA+Pj4gMjApICYgMHhmXSB8IHBjMmJ5dGVzMTBbKHJpZ2h0ID4+PiAxNikgJiAweGZdIHxcbiAgICAgICAgcGMyYnl0ZXMxMVsocmlnaHQgPj4+IDEyKSAmIDB4Zl0gfCBwYzJieXRlczEyWyhyaWdodCA+Pj4gOCkgJiAweGZdIHxcbiAgICAgICAgcGMyYnl0ZXMxM1socmlnaHQgPj4+IDQpICYgMHhmXSk7XG4gICAgICB0bXAgPSAoKHJpZ2h0dG1wID4+PiAxNikgXiBsZWZ0dG1wKSAmIDB4MDAwMGZmZmY7XG4gICAgICBrZXlzW24rK10gPSBsZWZ0dG1wIF4gdG1wO1xuICAgICAga2V5c1tuKytdID0gcmlnaHR0bXAgXiAodG1wIDw8IDE2KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGEgc2luZ2xlIGJsb2NrICgxIGJ5dGUpIHVzaW5nIERFUy4gVGhlIHVwZGF0ZSB3aWxsIGVpdGhlclxuICogZW5jcnlwdCBvciBkZWNyeXB0IHRoZSBibG9jay5cbiAqXG4gKiBAcGFyYW0ga2V5cyB0aGUgZXhwYW5kZWQga2V5cy5cbiAqIEBwYXJhbSBpbnB1dCB0aGUgaW5wdXQgYmxvY2sgKGFuIGFycmF5IG9mIDMyLWJpdCB3b3JkcykuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSB1cGRhdGVkIG91dHB1dCBibG9jay5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gZGVjcnlwdCB0aGUgYmxvY2ssIGZhbHNlIHRvIGVuY3J5cHQgaXQuXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGVCbG9jayhrZXlzLCBpbnB1dCwgb3V0cHV0LCBkZWNyeXB0KSB7XG4gIC8vIHNldCB1cCBsb29wcyBmb3Igc2luZ2xlIG9yIHRyaXBsZSBERVNcbiAgdmFyIGl0ZXJhdGlvbnMgPSBrZXlzLmxlbmd0aCA9PT0gMzIgPyAzIDogOTtcbiAgdmFyIGxvb3Bpbmc7XG4gIGlmKGl0ZXJhdGlvbnMgPT09IDMpIHtcbiAgICBsb29waW5nID0gZGVjcnlwdCA/IFszMCwgLTIsIC0yXSA6IFswLCAzMiwgMl07XG4gIH0gZWxzZSB7XG4gICAgbG9vcGluZyA9IChkZWNyeXB0ID9cbiAgICAgIFs5NCwgNjIsIC0yLCAzMiwgNjQsIDIsIDMwLCAtMiwgLTJdIDpcbiAgICAgIFswLCAzMiwgMiwgNjIsIDMwLCAtMiwgNjQsIDk2LCAyXSk7XG4gIH1cblxuICB2YXIgdG1wO1xuXG4gIHZhciBsZWZ0ID0gaW5wdXRbMF07XG4gIHZhciByaWdodCA9IGlucHV0WzFdO1xuXG4gIC8vIGZpcnN0IGVhY2ggNjQgYml0IGNodW5rIG9mIHRoZSBtZXNzYWdlIG11c3QgYmUgcGVybXV0ZWQgYWNjb3JkaW5nIHRvIElQXG4gIHRtcCA9ICgobGVmdCA+Pj4gNCkgXiByaWdodCkgJiAweDBmMGYwZjBmO1xuICByaWdodCBePSB0bXA7XG4gIGxlZnQgXj0gKHRtcCA8PCA0KTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDE2KSBeIHJpZ2h0KSAmIDB4MDAwMGZmZmY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDE2KTtcblxuICB0bXAgPSAoKHJpZ2h0ID4+PiAyKSBeIGxlZnQpICYgMHgzMzMzMzMzMztcbiAgbGVmdCBePSB0bXA7XG4gIHJpZ2h0IF49ICh0bXAgPDwgMik7XG5cbiAgdG1wID0gKChyaWdodCA+Pj4gOCkgXiBsZWZ0KSAmIDB4MDBmZjAwZmY7XG4gIGxlZnQgXj0gdG1wO1xuICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gIHRtcCA9ICgobGVmdCA+Pj4gMSkgXiByaWdodCkgJiAweDU1NTU1NTU1O1xuICByaWdodCBePSB0bXA7XG4gIGxlZnQgXj0gKHRtcCA8PCAxKTtcblxuICAvLyByb3RhdGUgbGVmdCAxIGJpdFxuICBsZWZ0ID0gKChsZWZ0IDw8IDEpIHwgKGxlZnQgPj4+IDMxKSk7XG4gIHJpZ2h0ID0gKChyaWdodCA8PCAxKSB8IChyaWdodCA+Pj4gMzEpKTtcblxuICBmb3IodmFyIGogPSAwOyBqIDwgaXRlcmF0aW9uczsgaiArPSAzKSB7XG4gICAgdmFyIGVuZGxvb3AgPSBsb29waW5nW2ogKyAxXTtcbiAgICB2YXIgbG9vcGluYyA9IGxvb3BpbmdbaiArIDJdO1xuXG4gICAgLy8gbm93IGdvIHRocm91Z2ggYW5kIHBlcmZvcm0gdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvblxuICAgIGZvcih2YXIgaSA9IGxvb3Bpbmdbal07IGkgIT0gZW5kbG9vcDsgaSArPSBsb29waW5jKSB7XG4gICAgICB2YXIgcmlnaHQxID0gcmlnaHQgXiBrZXlzW2ldO1xuICAgICAgdmFyIHJpZ2h0MiA9ICgocmlnaHQgPj4+IDQpIHwgKHJpZ2h0IDw8IDI4KSkgXiBrZXlzW2kgKyAxXTtcblxuICAgICAgLy8gcGFzc2luZyB0aGVzZSBieXRlcyB0aHJvdWdoIHRoZSBTIHNlbGVjdGlvbiBmdW5jdGlvbnNcbiAgICAgIHRtcCA9IGxlZnQ7XG4gICAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgICByaWdodCA9IHRtcCBeIChcbiAgICAgICAgc3BmdW5jdGlvbjJbKHJpZ2h0MSA+Pj4gMjQpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uNFsocmlnaHQxID4+PiAxNikgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb242WyhyaWdodDEgPj4+ICA4KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjhbcmlnaHQxICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uMVsocmlnaHQyID4+PiAyNCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb24zWyhyaWdodDIgPj4+IDE2KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjVbKHJpZ2h0MiA+Pj4gIDgpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uN1tyaWdodDIgJiAweDNmXSk7XG4gICAgfVxuICAgIC8vIHVucmV2ZXJzZSBsZWZ0IGFuZCByaWdodFxuICAgIHRtcCA9IGxlZnQ7XG4gICAgbGVmdCA9IHJpZ2h0O1xuICAgIHJpZ2h0ID0gdG1wO1xuICB9XG5cbiAgLy8gcm90YXRlIHJpZ2h0IDEgYml0XG4gIGxlZnQgPSAoKGxlZnQgPj4+IDEpIHwgKGxlZnQgPDwgMzEpKTtcbiAgcmlnaHQgPSAoKHJpZ2h0ID4+PiAxKSB8IChyaWdodCA8PCAzMSkpO1xuXG4gIC8vIG5vdyBwZXJmb3JtIElQLTEsIHdoaWNoIGlzIElQIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDEpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDgpIF4gbGVmdCkgJiAweDAwZmYwMGZmO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCA4KTtcblxuICB0bXAgPSAoKHJpZ2h0ID4+PiAyKSBeIGxlZnQpICYgMHgzMzMzMzMzMztcbiAgbGVmdCBePSB0bXA7XG4gIHJpZ2h0IF49ICh0bXAgPDwgMik7XG5cbiAgdG1wID0gKChsZWZ0ID4+PiAxNikgXiByaWdodCkgJiAweDAwMDBmZmZmO1xuICByaWdodCBePSB0bXA7XG4gIGxlZnQgXj0gKHRtcCA8PCAxNik7XG5cbiAgdG1wID0gKChsZWZ0ID4+PiA0KSBeIHJpZ2h0KSAmIDB4MGYwZjBmMGY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDQpO1xuXG4gIG91dHB1dFswXSA9IGxlZnQ7XG4gIG91dHB1dFsxXSA9IHJpZ2h0O1xufVxuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhIGRlcHJlY2F0ZWQgREVTIGNpcGhlciBvYmplY3QuIFRoaXMgb2JqZWN0J3MgbW9kZSB3aWxsIGRlZmF1bHQgdG9cbiAqIENCQyAoY2lwaGVyLWJsb2NrLWNoYWluaW5nKS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcyBvciBhIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZS5cbiAqICAgICAgICAgIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqICAgICAgICAgIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLlxuICogICAgICAgICAgZGVjcnlwdCB0cnVlIGZvciBkZWNyeXB0aW9uLCBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqICAgICAgICAgIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUNpcGhlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbW9kZSA9IChvcHRpb25zLm1vZGUgfHwgJ0NCQycpLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBhbGdvcml0aG0gPSAnREVTLScgKyBtb2RlO1xuXG4gIHZhciBjaXBoZXI7XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCkge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcihhbGdvcml0aG0sIG9wdGlvbnMua2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9XG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdGlibGUgc3RhcnQgQVBJXG4gIHZhciBzdGFydCA9IGNpcGhlci5zdGFydDtcbiAgY2lwaGVyLnN0YXJ0ID0gZnVuY3Rpb24oaXYsIG9wdGlvbnMpIHtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogc3VwcG9ydCBzZWNvbmQgYXJnIGFzIG91dHB1dCBidWZmZXJcbiAgICB2YXIgb3V0cHV0ID0gbnVsbDtcbiAgICBpZihvcHRpb25zIGluc3RhbmNlb2YgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKSB7XG4gICAgICBvdXRwdXQgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLm91dHB1dCA9IG91dHB1dDtcbiAgICBvcHRpb25zLml2ID0gaXY7XG4gICAgc3RhcnQuY2FsbChjaXBoZXIsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBjaXBoZXI7XG59XG4iLCIvKipcbiAqIEFuIEFQSSBmb3IgZ2V0dGluZyBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIGJ5dGVzLiBUaGUgYnl0ZXMgYXJlXG4gKiBnZW5lcmF0ZWQgdXNpbmcgdGhlIEZvcnR1bmEgYWxnb3JpdGhtIGRldmlzZWQgYnkgQnJ1Y2UgU2NobmVpZXIgYW5kXG4gKiBOaWVscyBGZXJndXNvbi5cbiAqXG4gKiBHZXR0aW5nIHN0cm9uZyByYW5kb20gYnl0ZXMgaXMgbm90IHlldCBlYXN5IHRvIGRvIGluIGphdmFzY3JpcHQuIFRoZSBvbmx5XG4gKiB0cnVpc2ggcmFuZG9tIGVudHJvcHkgdGhhdCBjYW4gYmUgY29sbGVjdGVkIGlzIGZyb20gdGhlIG1vdXNlLCBrZXlib2FyZCwgb3JcbiAqIGZyb20gdGltaW5nIHdpdGggcmVzcGVjdCB0byBwYWdlIGxvYWRzLCBldGMuIFRoaXMgZ2VuZXJhdG9yIG1ha2VzIGEgcG9vclxuICogYXR0ZW1wdCBhdCBwcm92aWRpbmcgcmFuZG9tIGJ5dGVzIHdoZW4gdGhvc2Ugc291cmNlcyBoYXZlbid0IHlldCBwcm92aWRlZFxuICogZW5vdWdoIGVudHJvcHkgdG8gaW5pdGlhbGx5IHNlZWQgb3IgdG8gcmVzZWVkIHRoZSBQUk5HLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9hZXMnKTtcbnJlcXVpcmUoJy4vc2hhMjU2Jyk7XG5yZXF1aXJlKCcuL3BybmcnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8vIGZvcmdlLnJhbmRvbSBhbHJlYWR5IGRlZmluZWRcbmlmKGZvcmdlLnJhbmRvbSAmJiBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYW5kb207XG4gIHJldHVybjtcbn1cblxuKGZ1bmN0aW9uKGpRdWVyeSkge1xuXG4vLyB0aGUgZGVmYXVsdCBwcm5nIHBsdWdpbiwgdXNlcyBBRVMtMTI4XG52YXIgcHJuZ19hZXMgPSB7fTtcbnZhciBfcHJuZ19hZXNfb3V0cHV0ID0gbmV3IEFycmF5KDQpO1xudmFyIF9wcm5nX2Flc19idWZmZXIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xucHJuZ19hZXMuZm9ybWF0S2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIC8vIGNvbnZlcnQgdGhlIGtleSBpbnRvIDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgdG1wID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoa2V5KTtcbiAga2V5ID0gbmV3IEFycmF5KDQpO1xuICBrZXlbMF0gPSB0bXAuZ2V0SW50MzIoKTtcbiAga2V5WzFdID0gdG1wLmdldEludDMyKCk7XG4gIGtleVsyXSA9IHRtcC5nZXRJbnQzMigpO1xuICBrZXlbM10gPSB0bXAuZ2V0SW50MzIoKTtcblxuICAvLyByZXR1cm4gdGhlIGV4cGFuZGVkIGtleVxuICByZXR1cm4gZm9yZ2UuYWVzLl9leHBhbmRLZXkoa2V5LCBmYWxzZSk7XG59O1xucHJuZ19hZXMuZm9ybWF0U2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgLy8gY29udmVydCBzZWVkIGludG8gMzItYml0IGludGVnZXJzXG4gIHZhciB0bXAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihzZWVkKTtcbiAgc2VlZCA9IG5ldyBBcnJheSg0KTtcbiAgc2VlZFswXSA9IHRtcC5nZXRJbnQzMigpO1xuICBzZWVkWzFdID0gdG1wLmdldEludDMyKCk7XG4gIHNlZWRbMl0gPSB0bXAuZ2V0SW50MzIoKTtcbiAgc2VlZFszXSA9IHRtcC5nZXRJbnQzMigpO1xuICByZXR1cm4gc2VlZDtcbn07XG5wcm5nX2Flcy5jaXBoZXIgPSBmdW5jdGlvbihrZXksIHNlZWQpIHtcbiAgZm9yZ2UuYWVzLl91cGRhdGVCbG9jayhrZXksIHNlZWQsIF9wcm5nX2Flc19vdXRwdXQsIGZhbHNlKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzBdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzFdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzJdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzNdKTtcbiAgcmV0dXJuIF9wcm5nX2Flc19idWZmZXIuZ2V0Qnl0ZXMoKTtcbn07XG5wcm5nX2Flcy5pbmNyZW1lbnQgPSBmdW5jdGlvbihzZWVkKSB7XG4gIC8vIEZJWE1FOiBkbyB3ZSBjYXJlIGFib3V0IGNhcnJ5IG9yIHNpZ25lZCBpc3N1ZXM/XG4gICsrc2VlZFszXTtcbiAgcmV0dXJuIHNlZWQ7XG59O1xucHJuZ19hZXMubWQgPSBmb3JnZS5tZC5zaGEyNTY7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQUk5HLlxuICovXG5mdW5jdGlvbiBzcGF3blBybmcoKSB7XG4gIHZhciBjdHggPSBmb3JnZS5wcm5nLmNyZWF0ZShwcm5nX2Flcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgcmFuZG9tIGJ5dGVzLiBJZiBhIG5hdGl2ZSBzZWN1cmUgY3J5cHRvIEFQSSBpcyB1bmF2YWlsYWJsZSwgdGhpc1xuICAgKiBtZXRob2QgdHJpZXMgdG8gbWFrZSB0aGUgYnl0ZXMgbW9yZSB1bnByZWRpY3RhYmxlIGJ5IGRyYXdpbmcgZnJvbSBkYXRhIHRoYXRcbiAgICogY2FuIGJlIGNvbGxlY3RlZCBmcm9tIHRoZSB1c2VyIG9mIHRoZSBicm93c2VyLCBlZzogbW91c2UgbW92ZW1lbnQuXG4gICAqXG4gICAqIElmIGEgY2FsbGJhY2sgaXMgZ2l2ZW4sIHRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2V0LlxuICAgKiBAcGFyYW0gW2NhbGxiYWNrKGVyciwgYnl0ZXMpXSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAgICpcbiAgICogQHJldHVybiB0aGUgcmFuZG9tIGJ5dGVzIGluIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdldEJ5dGVzID0gZnVuY3Rpb24oY291bnQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGN0eC5nZW5lcmF0ZShjb3VudCwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHJhbmRvbSBieXRlcyBhc3luY2hyb25vdXNseS4gSWYgYSBuYXRpdmUgc2VjdXJlIGNyeXB0byBBUEkgaXNcbiAgICogdW5hdmFpbGFibGUsIHRoaXMgbWV0aG9kIHRyaWVzIHRvIG1ha2UgdGhlIGJ5dGVzIG1vcmUgdW5wcmVkaWN0YWJsZSBieVxuICAgKiBkcmF3aW5nIGZyb20gZGF0YSB0aGF0IGNhbiBiZSBjb2xsZWN0ZWQgZnJvbSB0aGUgdXNlciBvZiB0aGUgYnJvd3NlcixcbiAgICogZWc6IG1vdXNlIG1vdmVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByYW5kb20gYnl0ZXMgaW4gYSBzdHJpbmcuXG4gICAqL1xuICBjdHguZ2V0Qnl0ZXNTeW5jID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICByZXR1cm4gY3R4LmdlbmVyYXRlKGNvdW50KTtcbiAgfTtcblxuICByZXR1cm4gY3R4O1xufVxuXG4vLyBjcmVhdGUgZGVmYXVsdCBwcm5nIGNvbnRleHRcbnZhciBfY3R4ID0gc3Bhd25Qcm5nKCk7XG5cbi8vIGFkZCBvdGhlciBzb3VyY2VzIG9mIGVudHJvcHkgb25seSBpZiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBpcyBub3Rcbi8vIGF2YWlsYWJsZSAtLSBvdGhlcndpc2UgdGhpcyBzb3VyY2Ugd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHVzZWQgYnkgdGhlIHBybmdcbnZhciBnZXRSYW5kb21WYWx1ZXMgPSBudWxsO1xudmFyIGdsb2JhbFNjb3BlID0gZm9yZ2UudXRpbC5nbG9iYWxTY29wZTtcbnZhciBfY3J5cHRvID0gZ2xvYmFsU2NvcGUuY3J5cHRvIHx8IGdsb2JhbFNjb3BlLm1zQ3J5cHRvO1xuaWYoX2NyeXB0byAmJiBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICBnZXRSYW5kb21WYWx1ZXMgPSBmdW5jdGlvbihhcnIpIHtcbiAgICByZXR1cm4gX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgfTtcbn1cblxuaWYoZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCB8fFxuICAoIWZvcmdlLnV0aWwuaXNOb2RlanMgJiYgIWdldFJhbmRvbVZhbHVlcykpIHtcbiAgLy8gaWYgdGhpcyBpcyBhIHdlYiB3b3JrZXIsIGRvIG5vdCB1c2Ugd2VhayBlbnRyb3B5LCBpbnN0ZWFkIHJlZ2lzdGVyIHRvXG4gIC8vIHJlY2VpdmUgc3Ryb25nIGVudHJvcHkgYXN5bmNocm9ub3VzbHkgZnJvbSB0aGUgbWFpbiB0aHJlYWRcbiAgaWYodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgd2luZG93LmRvY3VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBGSVhNRTpcbiAgfVxuXG4gIC8vIGdldCBsb2FkIHRpbWUgZW50cm9weVxuICBfY3R4LmNvbGxlY3RJbnQoK25ldyBEYXRlKCksIDMyKTtcblxuICAvLyBhZGQgc29tZSBlbnRyb3B5IGZyb20gbmF2aWdhdG9yIG9iamVjdFxuICBpZih0eXBlb2YobmF2aWdhdG9yKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgX25hdkJ5dGVzID0gJyc7XG4gICAgZm9yKHZhciBrZXkgaW4gbmF2aWdhdG9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZih0eXBlb2YobmF2aWdhdG9yW2tleV0pID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgX25hdkJ5dGVzICs9IG5hdmlnYXRvcltrZXldO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgLyogU29tZSBuYXZpZ2F0b3Iga2V5cyBtaWdodCBub3QgYmUgYWNjZXNzaWJsZSwgZS5nLiB0aGUgZ2VvbG9jYXRpb25cbiAgICAgICAgICBhdHRyaWJ1dGUgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0b3VjaGVkIGluIE1vemlsbGEgY2hyb21lOi8vXG4gICAgICAgICAgY29udGV4dC5cblxuICAgICAgICAgIFNpbGVudGx5IGlnbm9yZSB0aGlzIGFuZCBqdXN0IGRvbid0IHVzZSB0aGlzIGFzIGEgc291cmNlIG9mXG4gICAgICAgICAgZW50cm9weS4gKi9cbiAgICAgIH1cbiAgICB9XG4gICAgX2N0eC5jb2xsZWN0KF9uYXZCeXRlcyk7XG4gICAgX25hdkJ5dGVzID0gbnVsbDtcbiAgfVxuXG4gIC8vIGFkZCBtb3VzZSBhbmQga2V5Ym9hcmQgY29sbGVjdG9ycyBpZiBqcXVlcnkgaXMgYXZhaWxhYmxlXG4gIGlmKGpRdWVyeSkge1xuICAgIC8vIHNldCB1cCBtb3VzZSBlbnRyb3B5IGNhcHR1cmVcbiAgICBqUXVlcnkoKS5tb3VzZW1vdmUoZnVuY3Rpb24oZSkge1xuICAgICAgLy8gYWRkIG1vdXNlIGNvb3Jkc1xuICAgICAgX2N0eC5jb2xsZWN0SW50KGUuY2xpZW50WCwgMTYpO1xuICAgICAgX2N0eC5jb2xsZWN0SW50KGUuY2xpZW50WSwgMTYpO1xuICAgIH0pO1xuXG4gICAgLy8gc2V0IHVwIGtleWJvYXJkIGVudHJvcHkgY2FwdHVyZVxuICAgIGpRdWVyeSgpLmtleXByZXNzKGZ1bmN0aW9uKGUpIHtcbiAgICAgIF9jdHguY29sbGVjdEludChlLmNoYXJDb2RlLCA4KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKiBSYW5kb20gQVBJICovXG5pZighZm9yZ2UucmFuZG9tKSB7XG4gIGZvcmdlLnJhbmRvbSA9IF9jdHg7XG59IGVsc2Uge1xuICAvLyBleHRlbmQgZm9yZ2UucmFuZG9tIHdpdGggX2N0eFxuICBmb3IodmFyIGtleSBpbiBfY3R4KSB7XG4gICAgZm9yZ2UucmFuZG9tW2tleV0gPSBfY3R4W2tleV07XG4gIH1cbn1cblxuLy8gZXhwb3NlIHNwYXduIFBSTkdcbmZvcmdlLnJhbmRvbS5jcmVhdGVJbnN0YW5jZSA9IHNwYXduUHJuZztcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYW5kb207XG5cbn0pKHR5cGVvZihqUXVlcnkpICE9PSAndW5kZWZpbmVkJyA/IGpRdWVyeSA6IG51bGwpO1xuXG59KSgpO1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDA1ICBUb20gV3Vcbi8vIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTZWUgXCJMSUNFTlNFXCIgZm9yIGRldGFpbHMuXG5cbi8vIEJhc2ljIEphdmFTY3JpcHQgQk4gbGlicmFyeSAtIHN1YnNldCB1c2VmdWwgZm9yIFJTQSBlbmNyeXB0aW9uLlxuXG4vKlxuTGljZW5zaW5nIChMSUNFTlNFKVxuLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5UaGlzIHNvZnR3YXJlIGlzIGNvdmVyZWQgdW5kZXIgdGhlIGZvbGxvd2luZyBjb3B5cmlnaHQ6XG4qL1xuLypcbiAqIENvcHlyaWdodCAoYykgMjAwMy0yMDA1ICBUb20gV3VcbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4gKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMtSVNcIiBBTkQgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MsIElNUExJRUQgT1IgT1RIRVJXSVNFLCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OLCBBTllcbiAqIFdBUlJBTlRZIE9GIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS5cbiAqXG4gKiBJTiBOTyBFVkVOVCBTSEFMTCBUT00gV1UgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgSU5DSURFTlRBTCxcbiAqIElORElSRUNUIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPRiBBTlkgS0lORCwgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUlxuICogUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBPUiBOT1QgQURWSVNFRCBPRlxuICogVEhFIFBPU1NJQklMSVRZIE9GIERBTUFHRSwgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBBUklTSU5HIE9VVFxuICogT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqXG4gKiBJbiBhZGRpdGlvbiwgdGhlIGZvbGxvd2luZyBjb25kaXRpb24gYXBwbGllczpcbiAqXG4gKiBBbGwgcmVkaXN0cmlidXRpb25zIG11c3QgcmV0YWluIGFuIGludGFjdCBjb3B5IG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZVxuICogYW5kIGRpc2NsYWltZXIuXG4gKi9cbi8qXG5BZGRyZXNzIGFsbCBxdWVzdGlvbnMgcmVnYXJkaW5nIHRoaXMgbGljZW5zZSB0bzpcblxuICBUb20gV3VcbiAgdGp3QGNzLlN0YW5mb3JkLkVEVVxuKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5qc2JuID0gZm9yZ2UuanNibiB8fCB7fTtcblxuLy8gQml0cyBwZXIgZGlnaXRcbnZhciBkYml0cztcblxuLy8gSmF2YVNjcmlwdCBlbmdpbmUgYW5hbHlzaXNcbnZhciBjYW5hcnkgPSAweGRlYWRiZWVmY2FmZTtcbnZhciBqX2xtID0gKChjYW5hcnkmMHhmZmZmZmYpPT0weGVmY2FmZSk7XG5cbi8vIChwdWJsaWMpIENvbnN0cnVjdG9yXG5mdW5jdGlvbiBCaWdJbnRlZ2VyKGEsYixjKSB7XG4gIHRoaXMuZGF0YSA9IFtdO1xuICBpZihhICE9IG51bGwpXG4gICAgaWYoXCJudW1iZXJcIiA9PSB0eXBlb2YgYSkgdGhpcy5mcm9tTnVtYmVyKGEsYixjKTtcbiAgICBlbHNlIGlmKGIgPT0gbnVsbCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBhKSB0aGlzLmZyb21TdHJpbmcoYSwyNTYpO1xuICAgIGVsc2UgdGhpcy5mcm9tU3RyaW5nKGEsYik7XG59XG5mb3JnZS5qc2JuLkJpZ0ludGVnZXIgPSBCaWdJbnRlZ2VyO1xuXG4vLyByZXR1cm4gbmV3LCB1bnNldCBCaWdJbnRlZ2VyXG5mdW5jdGlvbiBuYmkoKSB7IHJldHVybiBuZXcgQmlnSW50ZWdlcihudWxsKTsgfVxuXG4vLyBhbTogQ29tcHV0ZSB3X2ogKz0gKHgqdGhpc19pKSwgcHJvcGFnYXRlIGNhcnJpZXMsXG4vLyBjIGlzIGluaXRpYWwgY2FycnksIHJldHVybnMgZmluYWwgY2FycnkuXG4vLyBjIDwgMypkdmFsdWUsIHggPCAyKmR2YWx1ZSwgdGhpc19pIDwgZHZhbHVlXG4vLyBXZSBuZWVkIHRvIHNlbGVjdCB0aGUgZmFzdGVzdCBvbmUgdGhhdCB3b3JrcyBpbiB0aGlzIGVudmlyb25tZW50LlxuXG4vLyBhbTE6IHVzZSBhIHNpbmdsZSBtdWx0IGFuZCBkaXZpZGUgdG8gZ2V0IHRoZSBoaWdoIGJpdHMsXG4vLyBtYXggZGlnaXQgYml0cyBzaG91bGQgYmUgMjYgYmVjYXVzZVxuLy8gbWF4IGludGVybmFsIHZhbHVlID0gMipkdmFsdWVeMi0yKmR2YWx1ZSAoPCAyXjUzKVxuZnVuY3Rpb24gYW0xKGkseCx3LGosYyxuKSB7XG4gIHdoaWxlKC0tbiA+PSAwKSB7XG4gICAgdmFyIHYgPSB4KnRoaXMuZGF0YVtpKytdK3cuZGF0YVtqXStjO1xuICAgIGMgPSBNYXRoLmZsb29yKHYvMHg0MDAwMDAwKTtcbiAgICB3LmRhdGFbaisrXSA9IHYmMHgzZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuLy8gYW0yIGF2b2lkcyBhIGJpZyBtdWx0LWFuZC1leHRyYWN0IGNvbXBsZXRlbHkuXG4vLyBNYXggZGlnaXQgYml0cyBzaG91bGQgYmUgPD0gMzAgYmVjYXVzZSB3ZSBkbyBiaXR3aXNlIG9wc1xuLy8gb24gdmFsdWVzIHVwIHRvIDIqaGR2YWx1ZV4yLWhkdmFsdWUtMSAoPCAyXjMxKVxuZnVuY3Rpb24gYW0yKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHg3ZmZmLCB4aCA9IHg+PjE1O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpcy5kYXRhW2ldJjB4N2ZmZjtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdPj4xNTtcbiAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICBsID0geGwqbCsoKG0mMHg3ZmZmKTw8MTUpK3cuZGF0YVtqXSsoYyYweDNmZmZmZmZmKTtcbiAgICBjID0gKGw+Pj4zMCkrKG0+Pj4xNSkreGgqaCsoYz4+PjMwKTtcbiAgICB3LmRhdGFbaisrXSA9IGwmMHgzZmZmZmZmZjtcbiAgfVxuICByZXR1cm4gYztcbn1cbi8vIEFsdGVybmF0ZWx5LCBzZXQgbWF4IGRpZ2l0IGJpdHMgdG8gMjggc2luY2Ugc29tZVxuLy8gYnJvd3NlcnMgc2xvdyBkb3duIHdoZW4gZGVhbGluZyB3aXRoIDMyLWJpdCBudW1iZXJzLlxuZnVuY3Rpb24gYW0zKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHgzZmZmLCB4aCA9IHg+PjE0O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpcy5kYXRhW2ldJjB4M2ZmZjtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdPj4xNDtcbiAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICBsID0geGwqbCsoKG0mMHgzZmZmKTw8MTQpK3cuZGF0YVtqXStjO1xuICAgIGMgPSAobD4+MjgpKyhtPj4xNCkreGgqaDtcbiAgICB3LmRhdGFbaisrXSA9IGwmMHhmZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG4vLyBub2RlLmpzIChubyBicm93c2VyKVxuaWYodHlwZW9mKG5hdmlnYXRvcikgPT09ICd1bmRlZmluZWQnKVxue1xuICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gICBkYml0cyA9IDI4O1xufSBlbHNlIGlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIpKSB7XG4gIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0yO1xuICBkYml0cyA9IDMwO1xufSBlbHNlIGlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lICE9IFwiTmV0c2NhcGVcIikpIHtcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTE7XG4gIGRiaXRzID0gMjY7XG59IGVsc2UgeyAvLyBNb3ppbGxhL05ldHNjYXBlIHNlZW1zIHRvIHByZWZlciBhbTNcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gIGRiaXRzID0gMjg7XG59XG5cbkJpZ0ludGVnZXIucHJvdG90eXBlLkRCID0gZGJpdHM7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ETSA9ICgoMTw8ZGJpdHMpLTEpO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRFYgPSAoMTw8ZGJpdHMpO1xuXG52YXIgQklfRlAgPSA1MjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkZWID0gTWF0aC5wb3coMixCSV9GUCk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMSA9IEJJX0ZQLWRiaXRzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyKmRiaXRzLUJJX0ZQO1xuXG4vLyBEaWdpdCBjb252ZXJzaW9uc1xudmFyIEJJX1JNID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbnZhciBCSV9SQyA9IG5ldyBBcnJheSgpO1xudmFyIHJyLHZ2O1xucnIgPSBcIjBcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMDsgdnYgPD0gOTsgKyt2dikgQklfUkNbcnIrK10gPSB2djtcbnJyID0gXCJhXCIuY2hhckNvZGVBdCgwKTtcbmZvcih2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2O1xucnIgPSBcIkFcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnY7XG5cbmZ1bmN0aW9uIGludDJjaGFyKG4pIHsgcmV0dXJuIEJJX1JNLmNoYXJBdChuKTsgfVxuZnVuY3Rpb24gaW50QXQocyxpKSB7XG4gIHZhciBjID0gQklfUkNbcy5jaGFyQ29kZUF0KGkpXTtcbiAgcmV0dXJuIChjPT1udWxsKT8tMTpjO1xufVxuXG4vLyAocHJvdGVjdGVkKSBjb3B5IHRoaXMgdG8gclxuZnVuY3Rpb24gYm5wQ29weVRvKHIpIHtcbiAgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByLmRhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gIHIudCA9IHRoaXMudDtcbiAgci5zID0gdGhpcy5zO1xufVxuXG4vLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcbmZ1bmN0aW9uIGJucEZyb21JbnQoeCkge1xuICB0aGlzLnQgPSAxO1xuICB0aGlzLnMgPSAoeDwwKT8tMTowO1xuICBpZih4ID4gMCkgdGhpcy5kYXRhWzBdID0geDtcbiAgZWxzZSBpZih4IDwgLTEpIHRoaXMuZGF0YVswXSA9IHgrdGhpcy5EVjtcbiAgZWxzZSB0aGlzLnQgPSAwO1xufVxuXG4vLyByZXR1cm4gYmlnaW50IGluaXRpYWxpemVkIHRvIHZhbHVlXG5mdW5jdGlvbiBuYnYoaSkgeyB2YXIgciA9IG5iaSgpOyByLmZyb21JbnQoaSk7IHJldHVybiByOyB9XG5cbi8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcbmZ1bmN0aW9uIGJucEZyb21TdHJpbmcocyxiKSB7XG4gIHZhciBrO1xuICBpZihiID09IDE2KSBrID0gNDtcbiAgZWxzZSBpZihiID09IDgpIGsgPSAzO1xuICBlbHNlIGlmKGIgPT0gMjU2KSBrID0gODsgLy8gYnl0ZSBhcnJheVxuICBlbHNlIGlmKGIgPT0gMikgayA9IDE7XG4gIGVsc2UgaWYoYiA9PSAzMikgayA9IDU7XG4gIGVsc2UgaWYoYiA9PSA0KSBrID0gMjtcbiAgZWxzZSB7IHRoaXMuZnJvbVJhZGl4KHMsYik7IHJldHVybjsgfVxuICB0aGlzLnQgPSAwO1xuICB0aGlzLnMgPSAwO1xuICB2YXIgaSA9IHMubGVuZ3RoLCBtaSA9IGZhbHNlLCBzaCA9IDA7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgdmFyIHggPSAoaz09OCk/c1tpXSYweGZmOmludEF0KHMsaSk7XG4gICAgaWYoeCA8IDApIHtcbiAgICAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiKSBtaSA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbWkgPSBmYWxzZTtcbiAgICBpZihzaCA9PSAwKVxuICAgICAgdGhpcy5kYXRhW3RoaXMudCsrXSA9IHg7XG4gICAgZWxzZSBpZihzaCtrID4gdGhpcy5EQikge1xuICAgICAgdGhpcy5kYXRhW3RoaXMudC0xXSB8PSAoeCYoKDE8PCh0aGlzLkRCLXNoKSktMSkpPDxzaDtcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAoeD4+KHRoaXMuREItc2gpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQtMV0gfD0geDw8c2g7XG4gICAgc2ggKz0gaztcbiAgICBpZihzaCA+PSB0aGlzLkRCKSBzaCAtPSB0aGlzLkRCO1xuICB9XG4gIGlmKGsgPT0gOCAmJiAoc1swXSYweDgwKSAhPSAwKSB7XG4gICAgdGhpcy5zID0gLTE7XG4gICAgaWYoc2ggPiAwKSB0aGlzLmRhdGFbdGhpcy50LTFdIHw9ICgoMTw8KHRoaXMuREItc2gpKS0xKTw8c2g7XG4gIH1cbiAgdGhpcy5jbGFtcCgpO1xuICBpZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIGNsYW1wIG9mZiBleGNlc3MgaGlnaCB3b3Jkc1xuZnVuY3Rpb24gYm5wQ2xhbXAoKSB7XG4gIHZhciBjID0gdGhpcy5zJnRoaXMuRE07XG4gIHdoaWxlKHRoaXMudCA+IDAgJiYgdGhpcy5kYXRhW3RoaXMudC0xXSA9PSBjKSAtLXRoaXMudDtcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuZnVuY3Rpb24gYm5Ub1N0cmluZyhiKSB7XG4gIGlmKHRoaXMucyA8IDApIHJldHVybiBcIi1cIit0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKGIpO1xuICB2YXIgaztcbiAgaWYoYiA9PSAxNikgayA9IDQ7XG4gIGVsc2UgaWYoYiA9PSA4KSBrID0gMztcbiAgZWxzZSBpZihiID09IDIpIGsgPSAxO1xuICBlbHNlIGlmKGIgPT0gMzIpIGsgPSA1O1xuICBlbHNlIGlmKGIgPT0gNCkgayA9IDI7XG4gIGVsc2UgcmV0dXJuIHRoaXMudG9SYWRpeChiKTtcbiAgdmFyIGttID0gKDE8PGspLTEsIGQsIG0gPSBmYWxzZSwgciA9IFwiXCIsIGkgPSB0aGlzLnQ7XG4gIHZhciBwID0gdGhpcy5EQi0oaSp0aGlzLkRCKSVrO1xuICBpZihpLS0gPiAwKSB7XG4gICAgaWYocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzLmRhdGFbaV0+PnApID4gMCkgeyBtID0gdHJ1ZTsgciA9IGludDJjaGFyKGQpOyB9XG4gICAgd2hpbGUoaSA+PSAwKSB7XG4gICAgICBpZihwIDwgaykge1xuICAgICAgICBkID0gKHRoaXMuZGF0YVtpXSYoKDE8PHApLTEpKTw8KGstcCk7XG4gICAgICAgIGQgfD0gdGhpcy5kYXRhWy0taV0+PihwKz10aGlzLkRCLWspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZCA9ICh0aGlzLmRhdGFbaV0+PihwLT1rKSkma207XG4gICAgICAgIGlmKHAgPD0gMCkgeyBwICs9IHRoaXMuREI7IC0taTsgfVxuICAgICAgfVxuICAgICAgaWYoZCA+IDApIG0gPSB0cnVlO1xuICAgICAgaWYobSkgciArPSBpbnQyY2hhcihkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG0/cjpcIjBcIjtcbn1cblxuLy8gKHB1YmxpYykgLXRoaXNcbmZ1bmN0aW9uIGJuTmVnYXRlKCkgeyB2YXIgciA9IG5iaSgpOyBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcyxyKTsgcmV0dXJuIHI7IH1cblxuLy8gKHB1YmxpYykgfHRoaXN8XG5mdW5jdGlvbiBibkFicygpIHsgcmV0dXJuICh0aGlzLnM8MCk/dGhpcy5uZWdhdGUoKTp0aGlzOyB9XG5cbi8vIChwdWJsaWMpIHJldHVybiArIGlmIHRoaXMgPiBhLCAtIGlmIHRoaXMgPCBhLCAwIGlmIGVxdWFsXG5mdW5jdGlvbiBibkNvbXBhcmVUbyhhKSB7XG4gIHZhciByID0gdGhpcy5zLWEucztcbiAgaWYociAhPSAwKSByZXR1cm4gcjtcbiAgdmFyIGkgPSB0aGlzLnQ7XG4gIHIgPSBpLWEudDtcbiAgaWYociAhPSAwKSByZXR1cm4gKHRoaXMuczwwKT8tcjpyO1xuICB3aGlsZSgtLWkgPj0gMCkgaWYoKHI9dGhpcy5kYXRhW2ldLWEuZGF0YVtpXSkgIT0gMCkgcmV0dXJuIHI7XG4gIHJldHVybiAwO1xufVxuXG4vLyByZXR1cm5zIGJpdCBsZW5ndGggb2YgdGhlIGludGVnZXIgeFxuZnVuY3Rpb24gbmJpdHMoeCkge1xuICB2YXIgciA9IDEsIHQ7XG4gIGlmKCh0PXg+Pj4xNikgIT0gMCkgeyB4ID0gdDsgciArPSAxNjsgfVxuICBpZigodD14Pj44KSAhPSAwKSB7IHggPSB0OyByICs9IDg7IH1cbiAgaWYoKHQ9eD4+NCkgIT0gMCkgeyB4ID0gdDsgciArPSA0OyB9XG4gIGlmKCh0PXg+PjIpICE9IDApIHsgeCA9IHQ7IHIgKz0gMjsgfVxuICBpZigodD14Pj4xKSAhPSAwKSB7IHggPSB0OyByICs9IDE7IH1cbiAgcmV0dXJuIHI7XG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gXCJ0aGlzXCJcbmZ1bmN0aW9uIGJuQml0TGVuZ3RoKCkge1xuICBpZih0aGlzLnQgPD0gMCkgcmV0dXJuIDA7XG4gIHJldHVybiB0aGlzLkRCKih0aGlzLnQtMSkrbmJpdHModGhpcy5kYXRhW3RoaXMudC0xXV4odGhpcy5zJnRoaXMuRE0pKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgbipEQlxuZnVuY3Rpb24gYm5wRExTaGlmdFRvKG4scikge1xuICB2YXIgaTtcbiAgZm9yKGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpK25dID0gdGhpcy5kYXRhW2ldO1xuICBmb3IoaSA9IG4tMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpXSA9IDA7XG4gIHIudCA9IHRoaXMudCtuO1xuICByLnMgPSB0aGlzLnM7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG4qREJcbmZ1bmN0aW9uIGJucERSU2hpZnRUbyhuLHIpIHtcbiAgZm9yKHZhciBpID0gbjsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaS1uXSA9IHRoaXMuZGF0YVtpXTtcbiAgci50ID0gTWF0aC5tYXgodGhpcy50LW4sMCk7XG4gIHIucyA9IHRoaXMucztcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgblxuZnVuY3Rpb24gYm5wTFNoaWZ0VG8obixyKSB7XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxjYnMpLTE7XG4gIHZhciBkcyA9IE1hdGguZmxvb3Iobi90aGlzLkRCKSwgYyA9ICh0aGlzLnM8PGJzKSZ0aGlzLkRNLCBpO1xuICBmb3IoaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkge1xuICAgIHIuZGF0YVtpK2RzKzFdID0gKHRoaXMuZGF0YVtpXT4+Y2JzKXxjO1xuICAgIGMgPSAodGhpcy5kYXRhW2ldJmJtKTw8YnM7XG4gIH1cbiAgZm9yKGkgPSBkcy0xOyBpID49IDA7IC0taSkgci5kYXRhW2ldID0gMDtcbiAgci5kYXRhW2RzXSA9IGM7XG4gIHIudCA9IHRoaXMudCtkcysxO1xuICByLnMgPSB0aGlzLnM7XG4gIHIuY2xhbXAoKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gblxuZnVuY3Rpb24gYm5wUlNoaWZ0VG8obixyKSB7XG4gIHIucyA9IHRoaXMucztcbiAgdmFyIGRzID0gTWF0aC5mbG9vcihuL3RoaXMuREIpO1xuICBpZihkcyA+PSB0aGlzLnQpIHsgci50ID0gMDsgcmV0dXJuOyB9XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxicyktMTtcbiAgci5kYXRhWzBdID0gdGhpcy5kYXRhW2RzXT4+YnM7XG4gIGZvcih2YXIgaSA9IGRzKzE7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgIHIuZGF0YVtpLWRzLTFdIHw9ICh0aGlzLmRhdGFbaV0mYm0pPDxjYnM7XG4gICAgci5kYXRhW2ktZHNdID0gdGhpcy5kYXRhW2ldPj5icztcbiAgfVxuICBpZihicyA+IDApIHIuZGF0YVt0aGlzLnQtZHMtMV0gfD0gKHRoaXMucyZibSk8PGNicztcbiAgci50ID0gdGhpcy50LWRzO1xuICByLmNsYW1wKCk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIC0gYVxuZnVuY3Rpb24gYm5wU3ViVG8oYSxyKSB7XG4gIHZhciBpID0gMCwgYyA9IDAsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbiAgd2hpbGUoaSA8IG0pIHtcbiAgICBjICs9IHRoaXMuZGF0YVtpXS1hLmRhdGFbaV07XG4gICAgci5kYXRhW2krK10gPSBjJnRoaXMuRE07XG4gICAgYyA+Pj0gdGhpcy5EQjtcbiAgfVxuICBpZihhLnQgPCB0aGlzLnQpIHtcbiAgICBjIC09IGEucztcbiAgICB3aGlsZShpIDwgdGhpcy50KSB7XG4gICAgICBjICs9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICB9XG4gICAgYyArPSB0aGlzLnM7XG4gIH0gZWxzZSB7XG4gICAgYyArPSB0aGlzLnM7XG4gICAgd2hpbGUoaSA8IGEudCkge1xuICAgICAgYyAtPSBhLmRhdGFbaV07XG4gICAgICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgfVxuICAgIGMgLT0gYS5zO1xuICB9XG4gIHIucyA9IChjPDApPy0xOjA7XG4gIGlmKGMgPCAtMSkgci5kYXRhW2krK10gPSB0aGlzLkRWK2M7XG4gIGVsc2UgaWYoYyA+IDApIHIuZGF0YVtpKytdID0gYztcbiAgci50ID0gaTtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyAqIGEsIHIgIT0gdGhpcyxhIChIQUMgMTQuMTIpXG4vLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVRvKGEscikge1xuICB2YXIgeCA9IHRoaXMuYWJzKCksIHkgPSBhLmFicygpO1xuICB2YXIgaSA9IHgudDtcbiAgci50ID0gaSt5LnQ7XG4gIHdoaWxlKC0taSA+PSAwKSByLmRhdGFbaV0gPSAwO1xuICBmb3IoaSA9IDA7IGkgPCB5LnQ7ICsraSkgci5kYXRhW2kreC50XSA9IHguYW0oMCx5LmRhdGFbaV0scixpLDAseC50KTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xuICBpZih0aGlzLnMgIT0gYS5zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXNeMiwgciAhPSB0aGlzIChIQUMgMTQuMTYpXG5mdW5jdGlvbiBibnBTcXVhcmVUbyhyKSB7XG4gIHZhciB4ID0gdGhpcy5hYnMoKTtcbiAgdmFyIGkgPSByLnQgPSAyKngudDtcbiAgd2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG4gIGZvcihpID0gMDsgaSA8IHgudC0xOyArK2kpIHtcbiAgICB2YXIgYyA9IHguYW0oaSx4LmRhdGFbaV0sciwyKmksMCwxKTtcbiAgICBpZigoci5kYXRhW2kreC50XSs9eC5hbShpKzEsMip4LmRhdGFbaV0sciwyKmkrMSxjLHgudC1pLTEpKSA+PSB4LkRWKSB7XG4gICAgICByLmRhdGFbaSt4LnRdIC09IHguRFY7XG4gICAgICByLmRhdGFbaSt4LnQrMV0gPSAxO1xuICAgIH1cbiAgfVxuICBpZihyLnQgPiAwKSByLmRhdGFbci50LTFdICs9IHguYW0oaSx4LmRhdGFbaV0sciwyKmksMCwxKTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSBkaXZpZGUgdGhpcyBieSBtLCBxdW90aWVudCBhbmQgcmVtYWluZGVyIHRvIHEsIHIgKEhBQyAxNC4yMClcbi8vIHIgIT0gcSwgdGhpcyAhPSBtLiAgcSBvciByIG1heSBiZSBudWxsLlxuZnVuY3Rpb24gYm5wRGl2UmVtVG8obSxxLHIpIHtcbiAgdmFyIHBtID0gbS5hYnMoKTtcbiAgaWYocG0udCA8PSAwKSByZXR1cm47XG4gIHZhciBwdCA9IHRoaXMuYWJzKCk7XG4gIGlmKHB0LnQgPCBwbS50KSB7XG4gICAgaWYocSAhPSBudWxsKSBxLmZyb21JbnQoMCk7XG4gICAgaWYociAhPSBudWxsKSB0aGlzLmNvcHlUbyhyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYociA9PSBudWxsKSByID0gbmJpKCk7XG4gIHZhciB5ID0gbmJpKCksIHRzID0gdGhpcy5zLCBtcyA9IG0ucztcbiAgdmFyIG5zaCA9IHRoaXMuREItbmJpdHMocG0uZGF0YVtwbS50LTFdKTtcdC8vIG5vcm1hbGl6ZSBtb2R1bHVzXG4gIGlmKG5zaCA+IDApIHsgcG0ubFNoaWZ0VG8obnNoLHkpOyBwdC5sU2hpZnRUbyhuc2gscik7IH0gZWxzZSB7IHBtLmNvcHlUbyh5KTsgcHQuY29weVRvKHIpOyB9XG4gIHZhciB5cyA9IHkudDtcbiAgdmFyIHkwID0geS5kYXRhW3lzLTFdO1xuICBpZih5MCA9PSAwKSByZXR1cm47XG4gIHZhciB5dCA9IHkwKigxPDx0aGlzLkYxKSsoKHlzPjEpP3kuZGF0YVt5cy0yXT4+dGhpcy5GMjowKTtcbiAgdmFyIGQxID0gdGhpcy5GVi95dCwgZDIgPSAoMTw8dGhpcy5GMSkveXQsIGUgPSAxPDx0aGlzLkYyO1xuICB2YXIgaSA9IHIudCwgaiA9IGkteXMsIHQgPSAocT09bnVsbCk/bmJpKCk6cTtcbiAgeS5kbFNoaWZ0VG8oaix0KTtcbiAgaWYoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgIHIuZGF0YVtyLnQrK10gPSAxO1xuICAgIHIuc3ViVG8odCxyKTtcbiAgfVxuICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oeXMsdCk7XG4gIHQuc3ViVG8oeSx5KTtcdC8vIFwibmVnYXRpdmVcIiB5IHNvIHdlIGNhbiByZXBsYWNlIHN1YiB3aXRoIGFtIGxhdGVyXG4gIHdoaWxlKHkudCA8IHlzKSB5LmRhdGFbeS50KytdID0gMDtcbiAgd2hpbGUoLS1qID49IDApIHtcbiAgICAvLyBFc3RpbWF0ZSBxdW90aWVudCBkaWdpdFxuICAgIHZhciBxZCA9IChyLmRhdGFbLS1pXT09eTApP3RoaXMuRE06TWF0aC5mbG9vcihyLmRhdGFbaV0qZDErKHIuZGF0YVtpLTFdK2UpKmQyKTtcbiAgICBpZigoci5kYXRhW2ldKz15LmFtKDAscWQscixqLDAseXMpKSA8IHFkKSB7XHQvLyBUcnkgaXQgb3V0XG4gICAgICB5LmRsU2hpZnRUbyhqLHQpO1xuICAgICAgci5zdWJUbyh0LHIpO1xuICAgICAgd2hpbGUoci5kYXRhW2ldIDwgLS1xZCkgci5zdWJUbyh0LHIpO1xuICAgIH1cbiAgfVxuICBpZihxICE9IG51bGwpIHtcbiAgICByLmRyU2hpZnRUbyh5cyxxKTtcbiAgICBpZih0cyAhPSBtcykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEscSk7XG4gIH1cbiAgci50ID0geXM7XG4gIHIuY2xhbXAoKTtcbiAgaWYobnNoID4gMCkgci5yU2hpZnRUbyhuc2gscik7XHQvLyBEZW5vcm1hbGl6ZSByZW1haW5kZXJcbiAgaWYodHMgPCAwKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHB1YmxpYykgdGhpcyBtb2QgYVxuZnVuY3Rpb24gYm5Nb2QoYSkge1xuICB2YXIgciA9IG5iaSgpO1xuICB0aGlzLmFicygpLmRpdlJlbVRvKGEsbnVsbCxyKTtcbiAgaWYodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgYS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gTW9kdWxhciByZWR1Y3Rpb24gdXNpbmcgXCJjbGFzc2ljXCIgYWxnb3JpdGhtXG5mdW5jdGlvbiBDbGFzc2ljKG0pIHsgdGhpcy5tID0gbTsgfVxuZnVuY3Rpb24gY0NvbnZlcnQoeCkge1xuICBpZih4LnMgPCAwIHx8IHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gIGVsc2UgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBjUmV2ZXJ0KHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIGNSZWR1Y2UoeCkgeyB4LmRpdlJlbVRvKHRoaXMubSxudWxsLHgpOyB9XG5mdW5jdGlvbiBjTXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG5mdW5jdGlvbiBjU3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbkNsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydDtcbkNsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGNSZXZlcnQ7XG5DbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBjUmVkdWNlO1xuQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBjTXVsVG87XG5DbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGNTcXJUbztcblxuLy8gKHByb3RlY3RlZCkgcmV0dXJuIFwiLTEvdGhpcyAlIDJeREJcIjsgdXNlZnVsIGZvciBNb250LiByZWR1Y3Rpb25cbi8vIGp1c3RpZmljYXRpb246XG4vLyAgICAgICAgIHh5ID09IDEgKG1vZCBtKVxuLy8gICAgICAgICB4eSA9ICAxK2ttXG4vLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXG4vLyB4W3koMi14eSldID0gMS1rXjJtXjJcbi8vIHhbeSgyLXh5KV0gPT0gMSAobW9kIG1eMilcbi8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcbi8vIHNob3VsZCByZWR1Y2UgeCBhbmQgeSgyLXh5KSBieSBtXjIgYXQgZWFjaCBzdGVwIHRvIGtlZXAgc2l6ZSBib3VuZGVkLlxuLy8gSlMgbXVsdGlwbHkgXCJvdmVyZmxvd3NcIiBkaWZmZXJlbnRseSBmcm9tIEMvQysrLCBzbyBjYXJlIGlzIG5lZWRlZCBoZXJlLlxuZnVuY3Rpb24gYm5wSW52RGlnaXQoKSB7XG4gIGlmKHRoaXMudCA8IDEpIHJldHVybiAwO1xuICB2YXIgeCA9IHRoaXMuZGF0YVswXTtcbiAgaWYoKHgmMSkgPT0gMCkgcmV0dXJuIDA7XG4gIHZhciB5ID0geCYzO1x0XHQvLyB5ID09IDEveCBtb2QgMl4yXG4gIHkgPSAoeSooMi0oeCYweGYpKnkpKSYweGY7XHQvLyB5ID09IDEveCBtb2QgMl40XG4gIHkgPSAoeSooMi0oeCYweGZmKSp5KSkmMHhmZjtcdC8vIHkgPT0gMS94IG1vZCAyXjhcbiAgeSA9ICh5KigyLSgoKHgmMHhmZmZmKSp5KSYweGZmZmYpKSkmMHhmZmZmO1x0Ly8geSA9PSAxL3ggbW9kIDJeMTZcbiAgLy8gbGFzdCBzdGVwIC0gY2FsY3VsYXRlIGludmVyc2UgbW9kIERWIGRpcmVjdGx5O1xuICAvLyBhc3N1bWVzIDE2IDwgREIgPD0gMzIgYW5kIGFzc3VtZXMgYWJpbGl0eSB0byBoYW5kbGUgNDgtYml0IGludHNcbiAgeSA9ICh5KigyLXgqeSV0aGlzLkRWKSkldGhpcy5EVjtcdFx0Ly8geSA9PSAxL3ggbW9kIDJeZGJpdHNcbiAgLy8gd2UgcmVhbGx5IHdhbnQgdGhlIG5lZ2F0aXZlIGludmVyc2UsIGFuZCAtRFYgPCB5IDwgRFZcbiAgcmV0dXJuICh5PjApP3RoaXMuRFYteToteTtcbn1cblxuLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cbmZ1bmN0aW9uIE1vbnRnb21lcnkobSkge1xuICB0aGlzLm0gPSBtO1xuICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpO1xuICB0aGlzLm1wbCA9IHRoaXMubXAmMHg3ZmZmO1xuICB0aGlzLm1waCA9IHRoaXMubXA+PjE1O1xuICB0aGlzLnVtID0gKDE8PChtLkRCLTE1KSktMTtcbiAgdGhpcy5tdDIgPSAyKm0udDtcbn1cblxuLy8geFIgbW9kIG1cbmZ1bmN0aW9uIG1vbnRDb252ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5hYnMoKS5kbFNoaWZ0VG8odGhpcy5tLnQscik7XG4gIHIuZGl2UmVtVG8odGhpcy5tLG51bGwscik7XG4gIGlmKHgucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIHRoaXMubS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geC9SIG1vZCBtXG5mdW5jdGlvbiBtb250UmV2ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5jb3B5VG8ocik7XG4gIHRoaXMucmVkdWNlKHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geCA9IHgvUiBtb2QgbSAoSEFDIDE0LjMyKVxuZnVuY3Rpb24gbW9udFJlZHVjZSh4KSB7XG4gIHdoaWxlKHgudCA8PSB0aGlzLm10MilcdC8vIHBhZCB4IHNvIGFtIGhhcyBlbm91Z2ggcm9vbSBsYXRlclxuICAgIHguZGF0YVt4LnQrK10gPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5tLnQ7ICsraSkge1xuICAgIC8vIGZhc3RlciB3YXkgb2YgY2FsY3VsYXRpbmcgdTAgPSB4LmRhdGFbaV0qbXAgbW9kIERWXG4gICAgdmFyIGogPSB4LmRhdGFbaV0mMHg3ZmZmO1xuICAgIHZhciB1MCA9IChqKnRoaXMubXBsKygoKGoqdGhpcy5tcGgrKHguZGF0YVtpXT4+MTUpKnRoaXMubXBsKSZ0aGlzLnVtKTw8MTUpKSZ4LkRNO1xuICAgIC8vIHVzZSBhbSB0byBjb21iaW5lIHRoZSBtdWx0aXBseS1zaGlmdC1hZGQgaW50byBvbmUgY2FsbFxuICAgIGogPSBpK3RoaXMubS50O1xuICAgIHguZGF0YVtqXSArPSB0aGlzLm0uYW0oMCx1MCx4LGksMCx0aGlzLm0udCk7XG4gICAgLy8gcHJvcGFnYXRlIGNhcnJ5XG4gICAgd2hpbGUoeC5kYXRhW2pdID49IHguRFYpIHsgeC5kYXRhW2pdIC09IHguRFY7IHguZGF0YVsrK2pdKys7IH1cbiAgfVxuICB4LmNsYW1wKCk7XG4gIHguZHJTaGlmdFRvKHRoaXMubS50LHgpO1xuICBpZih4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHguc3ViVG8odGhpcy5tLHgpO1xufVxuXG4vLyByID0gXCJ4XjIvUiBtb2QgbVwiOyB4ICE9IHJcbmZ1bmN0aW9uIG1vbnRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy8gciA9IFwieHkvUiBtb2QgbVwiOyB4LHkgIT0gclxuZnVuY3Rpb24gbW9udE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5Nb250Z29tZXJ5LnByb3RvdHlwZS5jb252ZXJ0ID0gbW9udENvbnZlcnQ7XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBtb250UmV2ZXJ0O1xuTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gbW9udFJlZHVjZTtcbk1vbnRnb21lcnkucHJvdG90eXBlLm11bFRvID0gbW9udE11bFRvO1xuTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBtb250U3FyVG87XG5cbi8vIChwcm90ZWN0ZWQpIHRydWUgaWZmIHRoaXMgaXMgZXZlblxuZnVuY3Rpb24gYm5wSXNFdmVuKCkgeyByZXR1cm4gKCh0aGlzLnQ+MCk/KHRoaXMuZGF0YVswXSYxKTp0aGlzLnMpID09IDA7IH1cblxuLy8gKHByb3RlY3RlZCkgdGhpc15lLCBlIDwgMl4zMiwgZG9pbmcgc3FyIGFuZCBtdWwgd2l0aCBcInJcIiAoSEFDIDE0Ljc5KVxuZnVuY3Rpb24gYm5wRXhwKGUseikge1xuICBpZihlID4gMHhmZmZmZmZmZiB8fCBlIDwgMSkgcmV0dXJuIEJpZ0ludGVnZXIuT05FO1xuICB2YXIgciA9IG5iaSgpLCByMiA9IG5iaSgpLCBnID0gei5jb252ZXJ0KHRoaXMpLCBpID0gbmJpdHMoZSktMTtcbiAgZy5jb3B5VG8ocik7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgei5zcXJUbyhyLHIyKTtcbiAgICBpZigoZSYoMTw8aSkpID4gMCkgei5tdWxUbyhyMixnLHIpO1xuICAgIGVsc2UgeyB2YXIgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gIH1cbiAgcmV0dXJuIHoucmV2ZXJ0KHIpO1xufVxuXG4vLyAocHVibGljKSB0aGlzXmUgJSBtLCAwIDw9IGUgPCAyXjMyXG5mdW5jdGlvbiBibk1vZFBvd0ludChlLG0pIHtcbiAgdmFyIHo7XG4gIGlmKGUgPCAyNTYgfHwgbS5pc0V2ZW4oKSkgeiA9IG5ldyBDbGFzc2ljKG0pOyBlbHNlIHogPSBuZXcgTW9udGdvbWVyeShtKTtcbiAgcmV0dXJuIHRoaXMuZXhwKGUseik7XG59XG5cbi8vIHByb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY29weVRvID0gYm5wQ29weVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbUludCA9IGJucEZyb21JbnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gYm5wRnJvbVN0cmluZztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNsYW1wID0gYm5wQ2xhbXA7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kclNoaWZ0VG8gPSBibnBEUlNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5sU2hpZnRUbyA9IGJucExTaGlmdFRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuclNoaWZ0VG8gPSBibnBSU2hpZnRUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnN1YlRvID0gYm5wU3ViVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZVRvID0gYm5wU3F1YXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZSZW1UbyA9IGJucERpdlJlbVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBibnBJbnZEaWdpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGJucElzRXZlbjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmV4cCA9IGJucEV4cDtcblxuLy8gcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGJuVG9TdHJpbmc7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBibk5lZ2F0ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGJuQWJzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gYm5Db21wYXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBibkJpdExlbmd0aDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGJuTW9kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93SW50ID0gYm5Nb2RQb3dJbnQ7XG5cbi8vIFwiY29uc3RhbnRzXCJcbkJpZ0ludGVnZXIuWkVSTyA9IG5idigwKTtcbkJpZ0ludGVnZXIuT05FID0gbmJ2KDEpO1xuXG4vLyBqc2JuMiBsaWJcblxuLy9Db3B5cmlnaHQgKGMpIDIwMDUtMjAwOSAgVG9tIFd1XG4vL0FsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1NlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscyAoU2VlIGpzYm4uanMgZm9yIExJQ0VOU0UpLlxuXG4vL0V4dGVuZGVkIEphdmFTY3JpcHQgQk4gZnVuY3Rpb25zLCByZXF1aXJlZCBmb3IgUlNBIHByaXZhdGUgb3BzLlxuXG4vL1ZlcnNpb24gMS4xOiBuZXcgQmlnSW50ZWdlcihcIjBcIiwgMTApIHJldHVybnMgXCJwcm9wZXJcIiB6ZXJvXG5cbi8vKHB1YmxpYylcbmZ1bmN0aW9uIGJuQ2xvbmUoKSB7IHZhciByID0gbmJpKCk7IHRoaXMuY29weVRvKHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBpbnRlZ2VyXG5mdW5jdGlvbiBibkludFZhbHVlKCkge1xuaWYodGhpcy5zIDwgMCkge1xuIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhWzBdLXRoaXMuRFY7XG4gZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIC0xO1xufSBlbHNlIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhWzBdO1xuZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIDA7XG4vLyBhc3N1bWVzIDE2IDwgREIgPCAzMlxucmV0dXJuICgodGhpcy5kYXRhWzFdJigoMTw8KDMyLXRoaXMuREIpKS0xKSk8PHRoaXMuREIpfHRoaXMuZGF0YVswXTtcbn1cblxuLy8ocHVibGljKSByZXR1cm4gdmFsdWUgYXMgYnl0ZVxuZnVuY3Rpb24gYm5CeXRlVmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXMuZGF0YVswXTw8MjQpPj4yNDsgfVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBzaG9ydCAoYXNzdW1lcyBEQj49MTYpXG5mdW5jdGlvbiBiblNob3J0VmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXMuZGF0YVswXTw8MTYpPj4xNjsgfVxuXG4vLyhwcm90ZWN0ZWQpIHJldHVybiB4IHMudC4gcl54IDwgRFZcbmZ1bmN0aW9uIGJucENodW5rU2l6ZShyKSB7IHJldHVybiBNYXRoLmZsb29yKE1hdGguTE4yKnRoaXMuREIvTWF0aC5sb2cocikpOyB9XG5cbi8vKHB1YmxpYykgMCBpZiB0aGlzID09IDAsIDEgaWYgdGhpcyA+IDBcbmZ1bmN0aW9uIGJuU2lnTnVtKCkge1xuaWYodGhpcy5zIDwgMCkgcmV0dXJuIC0xO1xuZWxzZSBpZih0aGlzLnQgPD0gMCB8fCAodGhpcy50ID09IDEgJiYgdGhpcy5kYXRhWzBdIDw9IDApKSByZXR1cm4gMDtcbmVsc2UgcmV0dXJuIDE7XG59XG5cbi8vKHByb3RlY3RlZCkgY29udmVydCB0byByYWRpeCBzdHJpbmdcbmZ1bmN0aW9uIGJucFRvUmFkaXgoYikge1xuaWYoYiA9PSBudWxsKSBiID0gMTA7XG5pZih0aGlzLnNpZ251bSgpID09IDAgfHwgYiA8IDIgfHwgYiA+IDM2KSByZXR1cm4gXCIwXCI7XG52YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKTtcbnZhciBhID0gTWF0aC5wb3coYixjcyk7XG52YXIgZCA9IG5idihhKSwgeSA9IG5iaSgpLCB6ID0gbmJpKCksIHIgPSBcIlwiO1xudGhpcy5kaXZSZW1UbyhkLHkseik7XG53aGlsZSh5LnNpZ251bSgpID4gMCkge1xuIHIgPSAoYSt6LmludFZhbHVlKCkpLnRvU3RyaW5nKGIpLnN1YnN0cigxKSArIHI7XG4geS5kaXZSZW1UbyhkLHkseik7XG59XG5yZXR1cm4gei5pbnRWYWx1ZSgpLnRvU3RyaW5nKGIpICsgcjtcbn1cblxuLy8ocHJvdGVjdGVkKSBjb252ZXJ0IGZyb20gcmFkaXggc3RyaW5nXG5mdW5jdGlvbiBibnBGcm9tUmFkaXgocyxiKSB7XG50aGlzLmZyb21JbnQoMCk7XG5pZihiID09IG51bGwpIGIgPSAxMDtcbnZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpO1xudmFyIGQgPSBNYXRoLnBvdyhiLGNzKSwgbWkgPSBmYWxzZSwgaiA9IDAsIHcgPSAwO1xuZm9yKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiB2YXIgeCA9IGludEF0KHMsaSk7XG4gaWYoeCA8IDApIHtcbiAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiICYmIHRoaXMuc2lnbnVtKCkgPT0gMCkgbWkgPSB0cnVlO1xuICAgY29udGludWU7XG4gfVxuIHcgPSBiKncreDtcbiBpZigrK2ogPj0gY3MpIHtcbiAgIHRoaXMuZE11bHRpcGx5KGQpO1xuICAgdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG4gICBqID0gMDtcbiAgIHcgPSAwO1xuIH1cbn1cbmlmKGogPiAwKSB7XG4gdGhpcy5kTXVsdGlwbHkoTWF0aC5wb3coYixqKSk7XG4gdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG59XG5pZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG59XG5cbi8vKHByb3RlY3RlZCkgYWx0ZXJuYXRlIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBibnBGcm9tTnVtYmVyKGEsYixjKSB7XG5pZihcIm51bWJlclwiID09IHR5cGVvZiBiKSB7XG4gLy8gbmV3IEJpZ0ludGVnZXIoaW50LGludCxSTkcpXG4gaWYoYSA8IDIpIHRoaXMuZnJvbUludCgxKTtcbiBlbHNlIHtcbiAgIHRoaXMuZnJvbU51bWJlcihhLGMpO1xuICAgaWYoIXRoaXMudGVzdEJpdChhLTEpKSAgLy8gZm9yY2UgTVNCIHNldFxuICAgICB0aGlzLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYS0xKSxvcF9vcix0aGlzKTtcbiAgIGlmKHRoaXMuaXNFdmVuKCkpIHRoaXMuZEFkZE9mZnNldCgxLDApOyAvLyBmb3JjZSBvZGRcbiAgIHdoaWxlKCF0aGlzLmlzUHJvYmFibGVQcmltZShiKSkge1xuICAgICB0aGlzLmRBZGRPZmZzZXQoMiwwKTtcbiAgICAgaWYodGhpcy5iaXRMZW5ndGgoKSA+IGEpIHRoaXMuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEtMSksdGhpcyk7XG4gICB9XG4gfVxufSBlbHNlIHtcbiAvLyBuZXcgQmlnSW50ZWdlcihpbnQsUk5HKVxuIHZhciB4ID0gbmV3IEFycmF5KCksIHQgPSBhJjc7XG4geC5sZW5ndGggPSAoYT4+MykrMTtcbiBiLm5leHRCeXRlcyh4KTtcbiBpZih0ID4gMCkgeFswXSAmPSAoKDE8PHQpLTEpOyBlbHNlIHhbMF0gPSAwO1xuIHRoaXMuZnJvbVN0cmluZyh4LDI1Nik7XG59XG59XG5cbi8vKHB1YmxpYykgY29udmVydCB0byBiaWdlbmRpYW4gYnl0ZSBhcnJheVxuZnVuY3Rpb24gYm5Ub0J5dGVBcnJheSgpIHtcbnZhciBpID0gdGhpcy50LCByID0gbmV3IEFycmF5KCk7XG5yWzBdID0gdGhpcy5zO1xudmFyIHAgPSB0aGlzLkRCLShpKnRoaXMuREIpJTgsIGQsIGsgPSAwO1xuaWYoaS0tID4gMCkge1xuIGlmKHAgPCB0aGlzLkRCICYmIChkID0gdGhpcy5kYXRhW2ldPj5wKSAhPSAodGhpcy5zJnRoaXMuRE0pPj5wKVxuICAgcltrKytdID0gZHwodGhpcy5zPDwodGhpcy5EQi1wKSk7XG4gd2hpbGUoaSA+PSAwKSB7XG4gICBpZihwIDwgOCkge1xuICAgICBkID0gKHRoaXMuZGF0YVtpXSYoKDE8PHApLTEpKTw8KDgtcCk7XG4gICAgIGQgfD0gdGhpcy5kYXRhWy0taV0+PihwKz10aGlzLkRCLTgpO1xuICAgfSBlbHNlIHtcbiAgICAgZCA9ICh0aGlzLmRhdGFbaV0+PihwLT04KSkmMHhmZjtcbiAgICAgaWYocCA8PSAwKSB7IHAgKz0gdGhpcy5EQjsgLS1pOyB9XG4gICB9XG4gICBpZigoZCYweDgwKSAhPSAwKSBkIHw9IC0yNTY7XG4gICBpZihrID09IDAgJiYgKHRoaXMucyYweDgwKSAhPSAoZCYweDgwKSkgKytrO1xuICAgaWYoayA+IDAgfHwgZCAhPSB0aGlzLnMpIHJbaysrXSA9IGQ7XG4gfVxufVxucmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJuRXF1YWxzKGEpIHsgcmV0dXJuKHRoaXMuY29tcGFyZVRvKGEpPT0wKTsgfVxuZnVuY3Rpb24gYm5NaW4oYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk8MCk/dGhpczphOyB9XG5mdW5jdGlvbiBibk1heChhKSB7IHJldHVybih0aGlzLmNvbXBhcmVUbyhhKT4wKT90aGlzOmE7IH1cblxuLy8ocHJvdGVjdGVkKSByID0gdGhpcyBvcCBhIChiaXR3aXNlKVxuZnVuY3Rpb24gYm5wQml0d2lzZVRvKGEsb3Ascikge1xudmFyIGksIGYsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbmZvcihpID0gMDsgaSA8IG07ICsraSkgci5kYXRhW2ldID0gb3AodGhpcy5kYXRhW2ldLGEuZGF0YVtpXSk7XG5pZihhLnQgPCB0aGlzLnQpIHtcbiBmID0gYS5zJnRoaXMuRE07XG4gZm9yKGkgPSBtOyBpIDwgdGhpcy50OyArK2kpIHIuZGF0YVtpXSA9IG9wKHRoaXMuZGF0YVtpXSxmKTtcbiByLnQgPSB0aGlzLnQ7XG59IGVsc2Uge1xuIGYgPSB0aGlzLnMmdGhpcy5ETTtcbiBmb3IoaSA9IG07IGkgPCBhLnQ7ICsraSkgci5kYXRhW2ldID0gb3AoZixhLmRhdGFbaV0pO1xuIHIudCA9IGEudDtcbn1cbnIucyA9IG9wKHRoaXMucyxhLnMpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgJiBhXG5mdW5jdGlvbiBvcF9hbmQoeCx5KSB7IHJldHVybiB4Jnk7IH1cbmZ1bmN0aW9uIGJuQW5kKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9hbmQscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyB8IGFcbmZ1bmN0aW9uIG9wX29yKHgseSkgeyByZXR1cm4geHx5OyB9XG5mdW5jdGlvbiBibk9yKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9vcixyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB0aGlzIF4gYVxuZnVuY3Rpb24gb3BfeG9yKHgseSkgeyByZXR1cm4geF55OyB9XG5mdW5jdGlvbiBiblhvcihhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3BfeG9yLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgJiB+YVxuZnVuY3Rpb24gb3BfYW5kbm90KHgseSkgeyByZXR1cm4geCZ+eTsgfVxuZnVuY3Rpb24gYm5BbmROb3QoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX2FuZG5vdCxyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB+dGhpc1xuZnVuY3Rpb24gYm5Ob3QoKSB7XG52YXIgciA9IG5iaSgpO1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaV0gPSB0aGlzLkRNJn50aGlzLmRhdGFbaV07XG5yLnQgPSB0aGlzLnQ7XG5yLnMgPSB+dGhpcy5zO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyA8PCBuXG5mdW5jdGlvbiBiblNoaWZ0TGVmdChuKSB7XG52YXIgciA9IG5iaSgpO1xuaWYobiA8IDApIHRoaXMuclNoaWZ0VG8oLW4scik7IGVsc2UgdGhpcy5sU2hpZnRUbyhuLHIpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyA+PiBuXG5mdW5jdGlvbiBiblNoaWZ0UmlnaHQobikge1xudmFyIHIgPSBuYmkoKTtcbmlmKG4gPCAwKSB0aGlzLmxTaGlmdFRvKC1uLHIpOyBlbHNlIHRoaXMuclNoaWZ0VG8obixyKTtcbnJldHVybiByO1xufVxuXG4vL3JldHVybiBpbmRleCBvZiBsb3dlc3QgMS1iaXQgaW4geCwgeCA8IDJeMzFcbmZ1bmN0aW9uIGxiaXQoeCkge1xuaWYoeCA9PSAwKSByZXR1cm4gLTE7XG52YXIgciA9IDA7XG5pZigoeCYweGZmZmYpID09IDApIHsgeCA+Pj0gMTY7IHIgKz0gMTY7IH1cbmlmKCh4JjB4ZmYpID09IDApIHsgeCA+Pj0gODsgciArPSA4OyB9XG5pZigoeCYweGYpID09IDApIHsgeCA+Pj0gNDsgciArPSA0OyB9XG5pZigoeCYzKSA9PSAwKSB7IHggPj49IDI7IHIgKz0gMjsgfVxuaWYoKHgmMSkgPT0gMCkgKytyO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgcmV0dXJucyBpbmRleCBvZiBsb3dlc3QgMS1iaXQgKG9yIC0xIGlmIG5vbmUpXG5mdW5jdGlvbiBibkdldExvd2VzdFNldEJpdCgpIHtcbmZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSlcbiBpZih0aGlzLmRhdGFbaV0gIT0gMCkgcmV0dXJuIGkqdGhpcy5EQitsYml0KHRoaXMuZGF0YVtpXSk7XG5pZih0aGlzLnMgPCAwKSByZXR1cm4gdGhpcy50KnRoaXMuREI7XG5yZXR1cm4gLTE7XG59XG5cbi8vcmV0dXJuIG51bWJlciBvZiAxIGJpdHMgaW4geFxuZnVuY3Rpb24gY2JpdCh4KSB7XG52YXIgciA9IDA7XG53aGlsZSh4ICE9IDApIHsgeCAmPSB4LTE7ICsrcjsgfVxucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgcmV0dXJuIG51bWJlciBvZiBzZXQgYml0c1xuZnVuY3Rpb24gYm5CaXRDb3VudCgpIHtcbnZhciByID0gMCwgeCA9IHRoaXMucyZ0aGlzLkRNO1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByICs9IGNiaXQodGhpcy5kYXRhW2ldXngpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdHJ1ZSBpZmYgbnRoIGJpdCBpcyBzZXRcbmZ1bmN0aW9uIGJuVGVzdEJpdChuKSB7XG52YXIgaiA9IE1hdGguZmxvb3Iobi90aGlzLkRCKTtcbmlmKGogPj0gdGhpcy50KSByZXR1cm4odGhpcy5zIT0wKTtcbnJldHVybigodGhpcy5kYXRhW2pdJigxPDwobiV0aGlzLkRCKSkpIT0wKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzIG9wICgxPDxuKVxuZnVuY3Rpb24gYm5wQ2hhbmdlQml0KG4sb3ApIHtcbnZhciByID0gQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KG4pO1xudGhpcy5iaXR3aXNlVG8ocixvcCxyKTtcbnJldHVybiByO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgfCAoMTw8bilcbmZ1bmN0aW9uIGJuU2V0Qml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3Bfb3IpOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAmIH4oMTw8bilcbmZ1bmN0aW9uIGJuQ2xlYXJCaXQobikgeyByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF9hbmRub3QpOyB9XG5cbi8vKHB1YmxpYykgdGhpcyBeICgxPDxuKVxuZnVuY3Rpb24gYm5GbGlwQml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3BfeG9yKTsgfVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSB0aGlzICsgYVxuZnVuY3Rpb24gYm5wQWRkVG8oYSxyKSB7XG52YXIgaSA9IDAsIGMgPSAwLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG53aGlsZShpIDwgbSkge1xuIGMgKz0gdGhpcy5kYXRhW2ldK2EuZGF0YVtpXTtcbiByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiBjID4+PSB0aGlzLkRCO1xufVxuaWYoYS50IDwgdGhpcy50KSB7XG4gYyArPSBhLnM7XG4gd2hpbGUoaSA8IHRoaXMudCkge1xuICAgYyArPSB0aGlzLmRhdGFbaV07XG4gICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgIGMgPj49IHRoaXMuREI7XG4gfVxuIGMgKz0gdGhpcy5zO1xufSBlbHNlIHtcbiBjICs9IHRoaXMucztcbiB3aGlsZShpIDwgYS50KSB7XG4gICBjICs9IGEuZGF0YVtpXTtcbiAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgYyA+Pj0gdGhpcy5EQjtcbiB9XG4gYyArPSBhLnM7XG59XG5yLnMgPSAoYzwwKT8tMTowO1xuaWYoYyA+IDApIHIuZGF0YVtpKytdID0gYztcbmVsc2UgaWYoYyA8IC0xKSByLmRhdGFbaSsrXSA9IHRoaXMuRFYrYztcbnIudCA9IGk7XG5yLmNsYW1wKCk7XG59XG5cbi8vKHB1YmxpYykgdGhpcyArIGFcbmZ1bmN0aW9uIGJuQWRkKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5hZGRUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgLSBhXG5mdW5jdGlvbiBiblN1YnRyYWN0KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5zdWJUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgKiBhXG5mdW5jdGlvbiBibk11bHRpcGx5KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5tdWx0aXBseVRvKGEscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAvIGFcbmZ1bmN0aW9uIGJuRGl2aWRlKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLHIsbnVsbCk7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAlIGFcbmZ1bmN0aW9uIGJuUmVtYWluZGVyKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLG51bGwscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgW3RoaXMvYSx0aGlzJWFdXG5mdW5jdGlvbiBibkRpdmlkZUFuZFJlbWFpbmRlcihhKSB7XG52YXIgcSA9IG5iaSgpLCByID0gbmJpKCk7XG50aGlzLmRpdlJlbVRvKGEscSxyKTtcbnJldHVybiBuZXcgQXJyYXkocSxyKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzICo9IG4sIHRoaXMgPj0gMCwgMSA8IG4gPCBEVlxuZnVuY3Rpb24gYm5wRE11bHRpcGx5KG4pIHtcbnRoaXMuZGF0YVt0aGlzLnRdID0gdGhpcy5hbSgwLG4tMSx0aGlzLDAsMCx0aGlzLnQpO1xuKyt0aGlzLnQ7XG50aGlzLmNsYW1wKCk7XG59XG5cbi8vKHByb3RlY3RlZCkgdGhpcyArPSBuIDw8IHcgd29yZHMsIHRoaXMgPj0gMFxuZnVuY3Rpb24gYm5wREFkZE9mZnNldChuLHcpIHtcbmlmKG4gPT0gMCkgcmV0dXJuO1xud2hpbGUodGhpcy50IDw9IHcpIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xudGhpcy5kYXRhW3ddICs9IG47XG53aGlsZSh0aGlzLmRhdGFbd10gPj0gdGhpcy5EVikge1xuIHRoaXMuZGF0YVt3XSAtPSB0aGlzLkRWO1xuIGlmKCsrdyA+PSB0aGlzLnQpIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xuICsrdGhpcy5kYXRhW3ddO1xufVxufVxuXG4vL0EgXCJudWxsXCIgcmVkdWNlclxuZnVuY3Rpb24gTnVsbEV4cCgpIHt9XG5mdW5jdGlvbiBuTm9wKHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIG5NdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgfVxuZnVuY3Rpb24gblNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB9XG5cbk51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBuTm9wO1xuTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gbk5vcDtcbk51bGxFeHAucHJvdG90eXBlLm11bFRvID0gbk11bFRvO1xuTnVsbEV4cC5wcm90b3R5cGUuc3FyVG8gPSBuU3FyVG87XG5cbi8vKHB1YmxpYykgdGhpc15lXG5mdW5jdGlvbiBiblBvdyhlKSB7IHJldHVybiB0aGlzLmV4cChlLG5ldyBOdWxsRXhwKCkpOyB9XG5cbi8vKHByb3RlY3RlZCkgciA9IGxvd2VyIG4gd29yZHMgb2YgXCJ0aGlzICogYVwiLCBhLnQgPD0gblxuLy9cInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseUxvd2VyVG8oYSxuLHIpIHtcbnZhciBpID0gTWF0aC5taW4odGhpcy50K2EudCxuKTtcbnIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbnIudCA9IGk7XG53aGlsZShpID4gMCkgci5kYXRhWy0taV0gPSAwO1xudmFyIGo7XG5mb3IoaiA9IHIudC10aGlzLnQ7IGkgPCBqOyArK2kpIHIuZGF0YVtpK3RoaXMudF0gPSB0aGlzLmFtKDAsYS5kYXRhW2ldLHIsaSwwLHRoaXMudCk7XG5mb3IoaiA9IE1hdGgubWluKGEudCxuKTsgaSA8IGo7ICsraSkgdGhpcy5hbSgwLGEuZGF0YVtpXSxyLGksMCxuLWkpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSBcInRoaXMgKiBhXCIgd2l0aG91dCBsb3dlciBuIHdvcmRzLCBuID4gMFxuLy9cInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVVwcGVyVG8oYSxuLHIpIHtcbi0tbjtcbnZhciBpID0gci50ID0gdGhpcy50K2EudC1uO1xuci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxud2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG5mb3IoaSA9IE1hdGgubWF4KG4tdGhpcy50LDApOyBpIDwgYS50OyArK2kpXG4gci5kYXRhW3RoaXMudCtpLW5dID0gdGhpcy5hbShuLWksYS5kYXRhW2ldLHIsMCwwLHRoaXMudCtpLW4pO1xuci5jbGFtcCgpO1xuci5kclNoaWZ0VG8oMSxyKTtcbn1cblxuLy9CYXJyZXR0IG1vZHVsYXIgcmVkdWN0aW9uXG5mdW5jdGlvbiBCYXJyZXR0KG0pIHtcbi8vIHNldHVwIEJhcnJldHRcbnRoaXMucjIgPSBuYmkoKTtcbnRoaXMucTMgPSBuYmkoKTtcbkJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbygyKm0udCx0aGlzLnIyKTtcbnRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKTtcbnRoaXMubSA9IG07XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRDb252ZXJ0KHgpIHtcbmlmKHgucyA8IDAgfHwgeC50ID4gMip0aGlzLm0udCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG5lbHNlIGlmKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKSByZXR1cm4geDtcbmVsc2UgeyB2YXIgciA9IG5iaSgpOyB4LmNvcHlUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IHJldHVybiByOyB9XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRSZXZlcnQoeCkgeyByZXR1cm4geDsgfVxuXG4vL3ggPSB4IG1vZCBtIChIQUMgMTQuNDIpXG5mdW5jdGlvbiBiYXJyZXR0UmVkdWNlKHgpIHtcbnguZHJTaGlmdFRvKHRoaXMubS50LTEsdGhpcy5yMik7XG5pZih4LnQgPiB0aGlzLm0udCsxKSB7IHgudCA9IHRoaXMubS50KzE7IHguY2xhbXAoKTsgfVxudGhpcy5tdS5tdWx0aXBseVVwcGVyVG8odGhpcy5yMix0aGlzLm0udCsxLHRoaXMucTMpO1xudGhpcy5tLm11bHRpcGx5TG93ZXJUbyh0aGlzLnEzLHRoaXMubS50KzEsdGhpcy5yMik7XG53aGlsZSh4LmNvbXBhcmVUbyh0aGlzLnIyKSA8IDApIHguZEFkZE9mZnNldCgxLHRoaXMubS50KzEpO1xueC5zdWJUbyh0aGlzLnIyLHgpO1xud2hpbGUoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB4LnN1YlRvKHRoaXMubSx4KTtcbn1cblxuLy9yID0geF4yIG1vZCBtOyB4ICE9IHJcbmZ1bmN0aW9uIGJhcnJldHRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy9yID0geCp5IG1vZCBtOyB4LHkgIT0gclxuZnVuY3Rpb24gYmFycmV0dE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5CYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gYmFycmV0dENvbnZlcnQ7XG5CYXJyZXR0LnByb3RvdHlwZS5yZXZlcnQgPSBiYXJyZXR0UmV2ZXJ0O1xuQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gYmFycmV0dFJlZHVjZTtcbkJhcnJldHQucHJvdG90eXBlLm11bFRvID0gYmFycmV0dE11bFRvO1xuQmFycmV0dC5wcm90b3R5cGUuc3FyVG8gPSBiYXJyZXR0U3FyVG87XG5cbi8vKHB1YmxpYykgdGhpc15lICUgbSAoSEFDIDE0Ljg1KVxuZnVuY3Rpb24gYm5Nb2RQb3coZSxtKSB7XG52YXIgaSA9IGUuYml0TGVuZ3RoKCksIGssIHIgPSBuYnYoMSksIHo7XG5pZihpIDw9IDApIHJldHVybiByO1xuZWxzZSBpZihpIDwgMTgpIGsgPSAxO1xuZWxzZSBpZihpIDwgNDgpIGsgPSAzO1xuZWxzZSBpZihpIDwgMTQ0KSBrID0gNDtcbmVsc2UgaWYoaSA8IDc2OCkgayA9IDU7XG5lbHNlIGsgPSA2O1xuaWYoaSA8IDgpXG4geiA9IG5ldyBDbGFzc2ljKG0pO1xuZWxzZSBpZihtLmlzRXZlbigpKVxuIHogPSBuZXcgQmFycmV0dChtKTtcbmVsc2VcbiB6ID0gbmV3IE1vbnRnb21lcnkobSk7XG5cbi8vIHByZWNvbXB1dGF0aW9uXG52YXIgZyA9IG5ldyBBcnJheSgpLCBuID0gMywgazEgPSBrLTEsIGttID0gKDE8PGspLTE7XG5nWzFdID0gei5jb252ZXJ0KHRoaXMpO1xuaWYoayA+IDEpIHtcbiB2YXIgZzIgPSBuYmkoKTtcbiB6LnNxclRvKGdbMV0sZzIpO1xuIHdoaWxlKG4gPD0ga20pIHtcbiAgIGdbbl0gPSBuYmkoKTtcbiAgIHoubXVsVG8oZzIsZ1tuLTJdLGdbbl0pO1xuICAgbiArPSAyO1xuIH1cbn1cblxudmFyIGogPSBlLnQtMSwgdywgaXMxID0gdHJ1ZSwgcjIgPSBuYmkoKSwgdDtcbmkgPSBuYml0cyhlLmRhdGFbal0pLTE7XG53aGlsZShqID49IDApIHtcbiBpZihpID49IGsxKSB3ID0gKGUuZGF0YVtqXT4+KGktazEpKSZrbTtcbiBlbHNlIHtcbiAgIHcgPSAoZS5kYXRhW2pdJigoMTw8KGkrMSkpLTEpKTw8KGsxLWkpO1xuICAgaWYoaiA+IDApIHcgfD0gZS5kYXRhW2otMV0+Pih0aGlzLkRCK2ktazEpO1xuIH1cblxuIG4gPSBrO1xuIHdoaWxlKCh3JjEpID09IDApIHsgdyA+Pj0gMTsgLS1uOyB9XG4gaWYoKGkgLT0gbikgPCAwKSB7IGkgKz0gdGhpcy5EQjsgLS1qOyB9XG4gaWYoaXMxKSB7ICAvLyByZXQgPT0gMSwgZG9uJ3QgYm90aGVyIHNxdWFyaW5nIG9yIG11bHRpcGx5aW5nIGl0XG4gICBnW3ddLmNvcHlUbyhyKTtcbiAgIGlzMSA9IGZhbHNlO1xuIH0gZWxzZSB7XG4gICB3aGlsZShuID4gMSkgeyB6LnNxclRvKHIscjIpOyB6LnNxclRvKHIyLHIpOyBuIC09IDI7IH1cbiAgIGlmKG4gPiAwKSB6LnNxclRvKHIscjIpOyBlbHNlIHsgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gICB6Lm11bFRvKHIyLGdbd10scik7XG4gfVxuXG4gd2hpbGUoaiA+PSAwICYmIChlLmRhdGFbal0mKDE8PGkpKSA9PSAwKSB7XG4gICB6LnNxclRvKHIscjIpOyB0ID0gcjsgciA9IHIyOyByMiA9IHQ7XG4gICBpZigtLWkgPCAwKSB7IGkgPSB0aGlzLkRCLTE7IC0tajsgfVxuIH1cbn1cbnJldHVybiB6LnJldmVydChyKTtcbn1cblxuLy8ocHVibGljKSBnY2QodGhpcyxhKSAoSEFDIDE0LjU0KVxuZnVuY3Rpb24gYm5HQ0QoYSkge1xudmFyIHggPSAodGhpcy5zPDApP3RoaXMubmVnYXRlKCk6dGhpcy5jbG9uZSgpO1xudmFyIHkgPSAoYS5zPDApP2EubmVnYXRlKCk6YS5jbG9uZSgpO1xuaWYoeC5jb21wYXJlVG8oeSkgPCAwKSB7IHZhciB0ID0geDsgeCA9IHk7IHkgPSB0OyB9XG52YXIgaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCksIGcgPSB5LmdldExvd2VzdFNldEJpdCgpO1xuaWYoZyA8IDApIHJldHVybiB4O1xuaWYoaSA8IGcpIGcgPSBpO1xuaWYoZyA+IDApIHtcbiB4LnJTaGlmdFRvKGcseCk7XG4geS5yU2hpZnRUbyhnLHkpO1xufVxud2hpbGUoeC5zaWdudW0oKSA+IDApIHtcbiBpZigoaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkgeC5yU2hpZnRUbyhpLHgpO1xuIGlmKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB5LnJTaGlmdFRvKGkseSk7XG4gaWYoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgeC5zdWJUbyh5LHgpO1xuICAgeC5yU2hpZnRUbygxLHgpO1xuIH0gZWxzZSB7XG4gICB5LnN1YlRvKHgseSk7XG4gICB5LnJTaGlmdFRvKDEseSk7XG4gfVxufVxuaWYoZyA+IDApIHkubFNoaWZ0VG8oZyx5KTtcbnJldHVybiB5O1xufVxuXG4vLyhwcm90ZWN0ZWQpIHRoaXMgJSBuLCBuIDwgMl4yNlxuZnVuY3Rpb24gYm5wTW9kSW50KG4pIHtcbmlmKG4gPD0gMCkgcmV0dXJuIDA7XG52YXIgZCA9IHRoaXMuRFYlbiwgciA9ICh0aGlzLnM8MCk/bi0xOjA7XG5pZih0aGlzLnQgPiAwKVxuIGlmKGQgPT0gMCkgciA9IHRoaXMuZGF0YVswXSVuO1xuIGVsc2UgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByID0gKGQqcit0aGlzLmRhdGFbaV0pJW47XG5yZXR1cm4gcjtcbn1cblxuLy8ocHVibGljKSAxL3RoaXMgJSBtIChIQUMgMTQuNjEpXG5mdW5jdGlvbiBibk1vZEludmVyc2UobSkge1xudmFyIGFjID0gbS5pc0V2ZW4oKTtcbmlmKCh0aGlzLmlzRXZlbigpICYmIGFjKSB8fCBtLnNpZ251bSgpID09IDApIHJldHVybiBCaWdJbnRlZ2VyLlpFUk87XG52YXIgdSA9IG0uY2xvbmUoKSwgdiA9IHRoaXMuY2xvbmUoKTtcbnZhciBhID0gbmJ2KDEpLCBiID0gbmJ2KDApLCBjID0gbmJ2KDApLCBkID0gbmJ2KDEpO1xud2hpbGUodS5zaWdudW0oKSAhPSAwKSB7XG4gd2hpbGUodS5pc0V2ZW4oKSkge1xuICAgdS5yU2hpZnRUbygxLHUpO1xuICAgaWYoYWMpIHtcbiAgICAgaWYoIWEuaXNFdmVuKCkgfHwgIWIuaXNFdmVuKCkpIHsgYS5hZGRUbyh0aGlzLGEpOyBiLnN1YlRvKG0sYik7IH1cbiAgICAgYS5yU2hpZnRUbygxLGEpO1xuICAgfSBlbHNlIGlmKCFiLmlzRXZlbigpKSBiLnN1YlRvKG0sYik7XG4gICBiLnJTaGlmdFRvKDEsYik7XG4gfVxuIHdoaWxlKHYuaXNFdmVuKCkpIHtcbiAgIHYuclNoaWZ0VG8oMSx2KTtcbiAgIGlmKGFjKSB7XG4gICAgIGlmKCFjLmlzRXZlbigpIHx8ICFkLmlzRXZlbigpKSB7IGMuYWRkVG8odGhpcyxjKTsgZC5zdWJUbyhtLGQpOyB9XG4gICAgIGMuclNoaWZ0VG8oMSxjKTtcbiAgIH0gZWxzZSBpZighZC5pc0V2ZW4oKSkgZC5zdWJUbyhtLGQpO1xuICAgZC5yU2hpZnRUbygxLGQpO1xuIH1cbiBpZih1LmNvbXBhcmVUbyh2KSA+PSAwKSB7XG4gICB1LnN1YlRvKHYsdSk7XG4gICBpZihhYykgYS5zdWJUbyhjLGEpO1xuICAgYi5zdWJUbyhkLGIpO1xuIH0gZWxzZSB7XG4gICB2LnN1YlRvKHUsdik7XG4gICBpZihhYykgYy5zdWJUbyhhLGMpO1xuICAgZC5zdWJUbyhiLGQpO1xuIH1cbn1cbmlmKHYuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuaWYoZC5jb21wYXJlVG8obSkgPj0gMCkgcmV0dXJuIGQuc3VidHJhY3QobSk7XG5pZihkLnNpZ251bSgpIDwgMCkgZC5hZGRUbyhtLGQpOyBlbHNlIHJldHVybiBkO1xuaWYoZC5zaWdudW0oKSA8IDApIHJldHVybiBkLmFkZChtKTsgZWxzZSByZXR1cm4gZDtcbn1cblxudmFyIGxvd3ByaW1lcyA9IFsyLDMsNSw3LDExLDEzLDE3LDE5LDIzLDI5LDMxLDM3LDQxLDQzLDQ3LDUzLDU5LDYxLDY3LDcxLDczLDc5LDgzLDg5LDk3LDEwMSwxMDMsMTA3LDEwOSwxMTMsMTI3LDEzMSwxMzcsMTM5LDE0OSwxNTEsMTU3LDE2MywxNjcsMTczLDE3OSwxODEsMTkxLDE5MywxOTcsMTk5LDIxMSwyMjMsMjI3LDIyOSwyMzMsMjM5LDI0MSwyNTEsMjU3LDI2MywyNjksMjcxLDI3NywyODEsMjgzLDI5MywzMDcsMzExLDMxMywzMTcsMzMxLDMzNywzNDcsMzQ5LDM1MywzNTksMzY3LDM3MywzNzksMzgzLDM4OSwzOTcsNDAxLDQwOSw0MTksNDIxLDQzMSw0MzMsNDM5LDQ0Myw0NDksNDU3LDQ2MSw0NjMsNDY3LDQ3OSw0ODcsNDkxLDQ5OSw1MDMsNTA5XTtcbnZhciBscGxpbSA9ICgxPDwyNikvbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV07XG5cbi8vKHB1YmxpYykgdGVzdCBwcmltYWxpdHkgd2l0aCBjZXJ0YWludHkgPj0gMS0uNV50XG5mdW5jdGlvbiBibklzUHJvYmFibGVQcmltZSh0KSB7XG52YXIgaSwgeCA9IHRoaXMuYWJzKCk7XG5pZih4LnQgPT0gMSAmJiB4LmRhdGFbMF0gPD0gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV0pIHtcbiBmb3IoaSA9IDA7IGkgPCBsb3dwcmltZXMubGVuZ3RoOyArK2kpXG4gICBpZih4LmRhdGFbMF0gPT0gbG93cHJpbWVzW2ldKSByZXR1cm4gdHJ1ZTtcbiByZXR1cm4gZmFsc2U7XG59XG5pZih4LmlzRXZlbigpKSByZXR1cm4gZmFsc2U7XG5pID0gMTtcbndoaWxlKGkgPCBsb3dwcmltZXMubGVuZ3RoKSB7XG4gdmFyIG0gPSBsb3dwcmltZXNbaV0sIGogPSBpKzE7XG4gd2hpbGUoaiA8IGxvd3ByaW1lcy5sZW5ndGggJiYgbSA8IGxwbGltKSBtICo9IGxvd3ByaW1lc1tqKytdO1xuIG0gPSB4Lm1vZEludChtKTtcbiB3aGlsZShpIDwgaikgaWYobSVsb3dwcmltZXNbaSsrXSA9PSAwKSByZXR1cm4gZmFsc2U7XG59XG5yZXR1cm4geC5taWxsZXJSYWJpbih0KTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0cnVlIGlmIHByb2JhYmx5IHByaW1lIChIQUMgNC4yNCwgTWlsbGVyLVJhYmluKVxuZnVuY3Rpb24gYm5wTWlsbGVyUmFiaW4odCkge1xudmFyIG4xID0gdGhpcy5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG52YXIgayA9IG4xLmdldExvd2VzdFNldEJpdCgpO1xuaWYoayA8PSAwKSByZXR1cm4gZmFsc2U7XG52YXIgciA9IG4xLnNoaWZ0UmlnaHQoayk7XG52YXIgcHJuZyA9IGJuR2V0UHJuZygpO1xudmFyIGE7XG5mb3IodmFyIGkgPSAwOyBpIDwgdDsgKytpKSB7XG4gLy8gc2VsZWN0IHdpdG5lc3MgJ2EnIGF0IHJhbmRvbSBmcm9tIGJldHdlZW4gMSBhbmQgbjFcbiBkbyB7XG4gICBhID0gbmV3IEJpZ0ludGVnZXIodGhpcy5iaXRMZW5ndGgoKSwgcHJuZyk7XG4gfVxuIHdoaWxlKGEuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA8PSAwIHx8IGEuY29tcGFyZVRvKG4xKSA+PSAwKTtcbiB2YXIgeSA9IGEubW9kUG93KHIsdGhpcyk7XG4gaWYoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDAgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgIHZhciBqID0gMTtcbiAgIHdoaWxlKGorKyA8IGsgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgeSA9IHkubW9kUG93SW50KDIsdGhpcyk7XG4gICAgIGlmKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICB9XG4gICBpZih5LmNvbXBhcmVUbyhuMSkgIT0gMCkgcmV0dXJuIGZhbHNlO1xuIH1cbn1cbnJldHVybiB0cnVlO1xufVxuXG4vLyBnZXQgcHNldWRvIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG5mdW5jdGlvbiBibkdldFBybmcoKSB7XG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgcmV0dXJuIHtcbiAgICAvLyB4IGlzIGFuIGFycmF5IHRvIGZpbGwgd2l0aCBieXRlc1xuICAgIG5leHRCeXRlczogZnVuY3Rpb24oeCkge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeFtpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MDEwMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vL3Byb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY2h1bmtTaXplID0gYm5wQ2h1bmtTaXplO1xuQmlnSW50ZWdlci5wcm90b3R5cGUudG9SYWRpeCA9IGJucFRvUmFkaXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tUmFkaXggPSBibnBGcm9tUmFkaXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gYm5wRnJvbU51bWJlcjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmJpdHdpc2VUbyA9IGJucEJpdHdpc2VUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNoYW5nZUJpdCA9IGJucENoYW5nZUJpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFkZFRvID0gYm5wQWRkVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kTXVsdGlwbHkgPSBibnBETXVsdGlwbHk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kQWRkT2Zmc2V0ID0gYm5wREFkZE9mZnNldDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGJucE11bHRpcGx5TG93ZXJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VXBwZXJUbyA9IGJucE11bHRpcGx5VXBwZXJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludCA9IGJucE1vZEludDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1pbGxlclJhYmluID0gYm5wTWlsbGVyUmFiaW47XG5cbi8vcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbG9uZSA9IGJuQ2xvbmU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGJuSW50VmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ieXRlVmFsdWUgPSBibkJ5dGVWYWx1ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBiblNob3J0VmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaWdudW0gPSBiblNpZ051bTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5ID0gYm5Ub0J5dGVBcnJheTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IGJuRXF1YWxzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubWluID0gYm5NaW47XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBibk1heDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGJuQW5kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBibk9yO1xuQmlnSW50ZWdlci5wcm90b3R5cGUueG9yID0gYm5Yb3I7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmROb3QgPSBibkFuZE5vdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGJuTm90O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gYm5TaGlmdExlZnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gYm5TaGlmdFJpZ2h0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZ2V0TG93ZXN0U2V0Qml0ID0gYm5HZXRMb3dlc3RTZXRCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRDb3VudCA9IGJuQml0Q291bnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50ZXN0Qml0ID0gYm5UZXN0Qml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2V0Qml0ID0gYm5TZXRCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGVhckJpdCA9IGJuQ2xlYXJCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gYm5GbGlwQml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gYm5BZGQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGJuU3VidHJhY3Q7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGJuTXVsdGlwbHk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBibkRpdmlkZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGJuUmVtYWluZGVyO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gYm5EaXZpZGVBbmRSZW1haW5kZXI7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBibk1vZFBvdztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBibk1vZEludmVyc2U7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBiblBvdztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmdjZCA9IGJuR0NEO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gYm5Jc1Byb2JhYmxlUHJpbWU7XG5cbi8vQmlnSW50ZWdlciBpbnRlcmZhY2VzIG5vdCBpbXBsZW1lbnRlZCBpbiBqc2JuOlxuXG4vL0JpZ0ludGVnZXIoaW50IHNpZ251bSwgYnl0ZVtdIG1hZ25pdHVkZSlcbi8vZG91YmxlIGRvdWJsZVZhbHVlKClcbi8vZmxvYXQgZmxvYXRWYWx1ZSgpXG4vL2ludCBoYXNoQ29kZSgpXG4vL2xvbmcgbG9uZ1ZhbHVlKClcbi8vc3RhdGljIEJpZ0ludGVnZXIgdmFsdWVPZihsb25nIHZhbClcbiIsIi8qKlxuICogUHJpbWUgbnVtYmVyIGdlbmVyYXRpb24gQVBJLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xucmVxdWlyZSgnLi9qc2JuJyk7XG5yZXF1aXJlKCcuL3JhbmRvbScpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8vIGZvcmdlLnByaW1lIGFscmVhZHkgZGVmaW5lZFxuaWYoZm9yZ2UucHJpbWUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wcmltZTtcbiAgcmV0dXJuO1xufVxuXG4vKiBQUklNRSBBUEkgKi9cbnZhciBwcmltZSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHJpbWUgPSBmb3JnZS5wcmltZSB8fCB7fTtcblxudmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG5cbi8vIHByaW1lcyBhcmUgMzBrK2kgZm9yIGkgPSAxLCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5XG52YXIgR0NEXzMwX0RFTFRBID0gWzYsIDQsIDIsIDQsIDIsIDQsIDYsIDJdO1xudmFyIFRISVJUWSA9IG5ldyBCaWdJbnRlZ2VyKG51bGwpO1xuVEhJUlRZLmZyb21JbnQoMzApO1xudmFyIG9wX29yID0gZnVuY3Rpb24oeCwgeSkge3JldHVybiB4fHk7fTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gcHJvYmFibGUgcHJpbWUgd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogQWx0ZXJuYXRpdmUgYWxnb3JpdGhtcyBjYW4gYmUgc3BlY2lmaWVkIGJ5IG5hbWUgYXMgYSBzdHJpbmcgb3IgYXMgYW5cbiAqIG9iamVjdCB3aXRoIGN1c3RvbSBvcHRpb25zIGxpa2Ugc286XG4gKlxuICoge1xuICogICBuYW1lOiAnUFJJTUVJTkMnLFxuICogICBvcHRpb25zOiB7XG4gKiAgICAgbWF4QmxvY2tUaW1lOiA8dGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gYmxvY2sgdGhlIG1haW5cbiAqICAgICAgIHRocmVhZCBiZWZvcmUgYWxsb3dpbmcgSS9PIG90aGVyIEpTIHRvIHJ1bj4sXG4gKiAgICAgbWlsbGVyUmFiaW5UZXN0czogPHRoZSBudW1iZXIgb2YgbWlsbGVyLXJhYmluIHRlc3RzIHRvIHJ1bj4sXG4gKiAgICAgd29ya2VyU2NyaXB0OiA8dGhlIHdvcmtlciBzY3JpcHQgVVJMPixcbiAqICAgICB3b3JrZXJzOiA8dGhlIG51bWJlciBvZiB3ZWIgd29ya2VycyAoaWYgc3VwcG9ydGVkKSB0byB1c2UsXG4gKiAgICAgICAtMSB0byB1c2UgZXN0aW1hdGVkIGNvcmVzIG1pbnVzIG9uZT4uXG4gKiAgICAgd29ya0xvYWQ6IHRoZSBzaXplIG9mIHRoZSB3b3JrIGxvYWQsIGllOiBudW1iZXIgb2YgcG9zc2libGUgcHJpbWVcbiAqICAgICAgIG51bWJlcnMgZm9yIGVhY2ggd2ViIHdvcmtlciB0byBjaGVjayBwZXIgd29yayBhc3NpZ25tZW50LFxuICogICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgbnVtYmVyIG9mIGJpdHMgZm9yIHRoZSBwcmltZSBudW1iZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBbYWxnb3JpdGhtXSB0aGUgYWxnb3JpdGhtIHRvIHVzZSAoZGVmYXVsdDogJ1BSSU1FSU5DJykuXG4gKiAgICAgICAgICBbcHJuZ10gYSBjdXN0b20gY3J5cHRvLXNlY3VyZSBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgdG8gdXNlLFxuICogICAgICAgICAgICB0aGF0IG11c3QgZGVmaW5lIFwiZ2V0Qnl0ZXNTeW5jXCIuXG4gKlxuICogQHJldHVybiBjYWxsYmFjayhlcnIsIG51bSkgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbnByaW1lLmdlbmVyYXRlUHJvYmFibGVQcmltZSA9IGZ1bmN0aW9uKGJpdHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBkZWZhdWx0IHRvIFBSSU1FSU5DIGFsZ29yaXRobVxuICB2YXIgYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJztcbiAgaWYodHlwZW9mIGFsZ29yaXRobSA9PT0gJ3N0cmluZycpIHtcbiAgICBhbGdvcml0aG0gPSB7bmFtZTogYWxnb3JpdGhtfTtcbiAgfVxuICBhbGdvcml0aG0ub3B0aW9ucyA9IGFsZ29yaXRobS5vcHRpb25zIHx8IHt9O1xuXG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgdmFyIHBybmcgPSBvcHRpb25zLnBybmcgfHwgZm9yZ2UucmFuZG9tO1xuICB2YXIgcm5nID0ge1xuICAgIC8vIHggaXMgYW4gYXJyYXkgdG8gZmlsbCB3aXRoIGJ5dGVzXG4gICAgbmV4dEJ5dGVzOiBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgYiA9IHBybmcuZ2V0Qnl0ZXNTeW5jKHgubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHhbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmKGFsZ29yaXRobS5uYW1lID09PSAnUFJJTUVJTkMnKSB7XG4gICAgcmV0dXJuIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgYWxnb3JpdGhtLm9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmltZSBnZW5lcmF0aW9uIGFsZ29yaXRobTogJyArIGFsZ29yaXRobS5uYW1lKTtcbn07XG5cbmZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYoJ3dvcmtlcnMnIGluIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRoV29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIGluaXRpYWxpemUgcmFuZG9tIG51bWJlclxuICB2YXIgbnVtID0gZ2VuZXJhdGVSYW5kb20oYml0cywgcm5nKTtcblxuICAvKiBOb3RlOiBBbGwgcHJpbWVzIGFyZSBvZiB0aGUgZm9ybSAzMGsraSBmb3IgaSA8IDMwIGFuZCBnY2QoMzAsIGkpPTEuIFRoZVxuICBudW1iZXIgd2UgYXJlIGdpdmVuIGlzIGFsd2F5cyBhbGlnbmVkIGF0IDMwayArIDEuIEVhY2ggdGltZSB0aGUgbnVtYmVyIGlzXG4gIGRldGVybWluZWQgbm90IHRvIGJlIHByaW1lIHdlIGFkZCB0byBnZXQgdG8gdGhlIG5leHQgJ2knLCBlZzogaWYgdGhlIG51bWJlclxuICB3YXMgYXQgMzBrICsgMSB3ZSBhZGQgNi4gKi9cbiAgdmFyIGRlbHRhSWR4ID0gMDtcblxuICAvLyBnZXQgcmVxdWlyZWQgbnVtYmVyIG9mIE1SIHRlc3RzXG4gIHZhciBtclRlc3RzID0gZ2V0TWlsbGVyUmFiaW5UZXN0cyhudW0uYml0TGVuZ3RoKCkpO1xuICBpZignbWlsbGVyUmFiaW5UZXN0cycgaW4gb3B0aW9ucykge1xuICAgIG1yVGVzdHMgPSBvcHRpb25zLm1pbGxlclJhYmluVGVzdHM7XG4gIH1cblxuICAvLyBmaW5kIHByaW1lIG5lYXJlc3QgdG8gJ251bScgZm9yIG1heEJsb2NrVGltZSBtc1xuICAvLyAxMCBtcyBnaXZlcyA1bXMgb2YgbGVld2F5IGZvciBvdGhlciBjYWxjdWxhdGlvbnMgYmVmb3JlIGRyb3BwaW5nXG4gIC8vIGJlbG93IDYwZnBzICgxMDAwLzYwID09IDE2LjY3KSwgYnV0IGluIHJlYWxpdHksIHRoZSBudW1iZXIgd2lsbFxuICAvLyBsaWtlbHkgYmUgaGlnaGVyIGR1ZSB0byBhbiAnYXRvbWljJyBiaWcgaW50IG1vZFBvd1xuICB2YXIgbWF4QmxvY2tUaW1lID0gMTA7XG4gIGlmKCdtYXhCbG9ja1RpbWUnIGluIG9wdGlvbnMpIHtcbiAgICBtYXhCbG9ja1RpbWUgPSBvcHRpb25zLm1heEJsb2NrVGltZTtcbiAgfVxuXG4gIF9wcmltZWluYyhudW0sIGJpdHMsIHJuZywgZGVsdGFJZHgsIG1yVGVzdHMsIG1heEJsb2NrVGltZSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBzdGFydCA9ICtuZXcgRGF0ZSgpO1xuICBkbyB7XG4gICAgLy8gb3ZlcmZsb3csIHJlZ2VuZXJhdGUgcmFuZG9tIG51bWJlclxuICAgIGlmKG51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgfVxuICAgIC8vIGRvIHByaW1hbGl0eSB0ZXN0XG4gICAgaWYobnVtLmlzUHJvYmFibGVQcmltZShtclRlc3RzKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bSk7XG4gICAgfVxuICAgIC8vIGdldCBuZXh0IHBvdGVudGlhbCBwcmltZVxuICAgIG51bS5kQWRkT2Zmc2V0KEdDRF8zMF9ERUxUQVtkZWx0YUlkeCsrICUgOF0sIDApO1xuICB9IHdoaWxlKG1heEJsb2NrVGltZSA8IDAgfHwgKCtuZXcgRGF0ZSgpIC0gc3RhcnQgPCBtYXhCbG9ja1RpbWUpKTtcblxuICAvLyBrZWVwIHRyeWluZyBsYXRlclxuICBmb3JnZS51dGlsLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbi8vIE5PVEU6IFRoaXMgYWxnb3JpdGhtIGlzIGluZGV0ZXJtaW5hdGUgaW4gbmF0dXJlIGJlY2F1c2Ugd29ya2Vyc1xuLy8gcnVuIGluIHBhcmFsbGVsIGxvb2tpbmcgYXQgZGlmZmVyZW50IHNlZ21lbnRzIG9mIG51bWJlcnMuIEV2ZW4gaWYgdGhpc1xuLy8gYWxnb3JpdGhtIGlzIHJ1biB0d2ljZSB3aXRoIHRoZSBzYW1lIGlucHV0IGZyb20gYSBwcmVkaWN0YWJsZSBSTkcsIGl0XG4vLyBtYXkgcHJvZHVjZSBkaWZmZXJlbnQgb3V0cHV0cy5cbmZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lV2l0aFdvcmtlcnMoYml0cywgcm5nLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyB3ZWIgd29ya2VycyB1bmF2YWlsYWJsZVxuICBpZih0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBwcmltZWluY0ZpbmRQcmltZVdpdGhvdXRXb3JrZXJzKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSByYW5kb20gbnVtYmVyXG4gIHZhciBudW0gPSBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpO1xuXG4gIC8vIHVzZSB3ZWIgd29ya2VycyB0byBnZW5lcmF0ZSBrZXlzXG4gIHZhciBudW1Xb3JrZXJzID0gb3B0aW9ucy53b3JrZXJzO1xuICB2YXIgd29ya0xvYWQgPSBvcHRpb25zLndvcmtMb2FkIHx8IDEwMDtcbiAgdmFyIHJhbmdlID0gd29ya0xvYWQgKiAzMCAvIDg7XG4gIHZhciB3b3JrZXJTY3JpcHQgPSBvcHRpb25zLndvcmtlclNjcmlwdCB8fCAnZm9yZ2UvcHJpbWUud29ya2VyLmpzJztcbiAgaWYobnVtV29ya2VycyA9PT0gLTEpIHtcbiAgICByZXR1cm4gZm9yZ2UudXRpbC5lc3RpbWF0ZUNvcmVzKGZ1bmN0aW9uKGVyciwgY29yZXMpIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICAvLyBkZWZhdWx0IHRvIDJcbiAgICAgICAgY29yZXMgPSAyO1xuICAgICAgfVxuICAgICAgbnVtV29ya2VycyA9IGNvcmVzIC0gMTtcbiAgICAgIGdlbmVyYXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2VuZXJhdGUoKTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAvLyByZXF1aXJlIGF0IGxlYXN0IDEgd29ya2VyXG4gICAgbnVtV29ya2VycyA9IE1hdGgubWF4KDEsIG51bVdvcmtlcnMpO1xuXG4gICAgLy8gVE9ETzogY29uc2lkZXIgb3B0aW1pemluZyBieSBzdGFydGluZyB3b3JrZXJzIG91dHNpZGUgZ2V0UHJpbWUoKSAuLi5cbiAgICAvLyBub3RlIHRoYXQgaW4gb3JkZXIgdG8gY2xlYW4gdXAgdGhleSB3aWxsIGhhdmUgdG8gYmUgbWFkZSBpbnRlcm5hbGx5XG4gICAgLy8gYXN5bmNocm9ub3VzIHdoaWNoIG1heSBhY3R1YWxseSBiZSBzbG93ZXJcblxuICAgIC8vIHN0YXJ0IHdvcmtlcnMgaW1tZWRpYXRlbHlcbiAgICB2YXIgd29ya2VycyA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgIC8vIEZJWE1FOiBmaXggcGF0aCBvciB1c2UgYmxvYiBVUkxzXG4gICAgICB3b3JrZXJzW2ldID0gbmV3IFdvcmtlcih3b3JrZXJTY3JpcHQpO1xuICAgIH1cbiAgICB2YXIgcnVubmluZyA9IG51bVdvcmtlcnM7XG5cbiAgICAvLyBsaXN0ZW4gZm9yIHJlcXVlc3RzIGZyb20gd29ya2VycyBhbmQgYXNzaWduIHJhbmdlcyB0byBmaW5kIHByaW1lXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgd29ya2Vyc1tpXS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgd29ya2VyTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyogTm90ZTogVGhlIGRpc3RyaWJ1dGlvbiBvZiByYW5kb20gbnVtYmVycyBpcyB1bmtub3duLiBUaGVyZWZvcmUsIGVhY2hcbiAgICB3ZWIgd29ya2VyIGlzIGNvbnRpbnVvdXNseSBhbGxvY2F0ZWQgYSByYW5nZSBvZiBudW1iZXJzIHRvIGNoZWNrIGZvciBhXG4gICAgcmFuZG9tIG51bWJlciB1bnRpbCBvbmUgaXMgZm91bmQuXG5cbiAgICBFdmVyeSAzMCBudW1iZXJzIHdpbGwgYmUgY2hlY2tlZCBqdXN0IDggdGltZXMsIGJlY2F1c2UgcHJpbWUgbnVtYmVyc1xuICAgIGhhdmUgdGhlIGZvcm06XG5cbiAgICAzMGsraSwgZm9yIGkgPCAzMCBhbmQgZ2NkKDMwLCBpKT0xICh0aGVyZSBhcmUgOCB2YWx1ZXMgb2YgaSBmb3IgdGhpcylcblxuICAgIFRoZXJlZm9yZSwgaWYgd2Ugd2FudCBhIHdlYiB3b3JrZXIgdG8gcnVuIE4gY2hlY2tzIGJlZm9yZSBhc2tpbmcgZm9yXG4gICAgYSBuZXcgcmFuZ2Ugb2YgbnVtYmVycywgZWFjaCByYW5nZSBtdXN0IGNvbnRhaW4gTiozMC84IG51bWJlcnMuXG5cbiAgICBGb3IgMTAwIGNoZWNrcyAod29ya0xvYWQpLCB0aGlzIGlzIGEgcmFuZ2Ugb2YgMzc1LiAqL1xuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gd29ya2VyTWVzc2FnZShlKSB7XG4gICAgICAvLyBpZ25vcmUgbWVzc2FnZSwgcHJpbWUgYWxyZWFkeSBmb3VuZFxuICAgICAgaWYoZm91bmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAtLXJ1bm5pbmc7XG4gICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgIGlmKGRhdGEuZm91bmQpIHtcbiAgICAgICAgLy8gdGVybWluYXRlIGFsbCB3b3JrZXJzXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB3b3JrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgd29ya2Vyc1tpXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBuZXcgQmlnSW50ZWdlcihkYXRhLnByaW1lLCAxNikpO1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVyZmxvdywgcmVnZW5lcmF0ZSByYW5kb20gbnVtYmVyXG4gICAgICBpZihudW0uYml0TGVuZ3RoKCkgPiBiaXRzKSB7XG4gICAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFzc2lnbiBuZXcgcmFuZ2UgdG8gY2hlY2tcbiAgICAgIHZhciBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuXG4gICAgICAvLyBzdGFydCBwcmltZSBzZWFyY2hcbiAgICAgIGUudGFyZ2V0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaGV4OiBoZXgsXG4gICAgICAgIHdvcmtMb2FkOiB3b3JrTG9hZFxuICAgICAgfSk7XG5cbiAgICAgIG51bS5kQWRkT2Zmc2V0KHJhbmdlLCAwKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIHVzaW5nIHRoZSBnaXZlbiBudW1iZXIgb2YgYml0cyBhbmQgUk5HLlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBudW1iZXIgb2YgYml0cyBmb3IgdGhlIG51bWJlci5cbiAqIEBwYXJhbSBybmcgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByYW5kb20gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpIHtcbiAgdmFyIG51bSA9IG5ldyBCaWdJbnRlZ2VyKGJpdHMsIHJuZyk7XG4gIC8vIGZvcmNlIE1TQiBzZXRcbiAgdmFyIGJpdHMxID0gYml0cyAtIDE7XG4gIGlmKCFudW0udGVzdEJpdChiaXRzMSkpIHtcbiAgICBudW0uYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChiaXRzMSksIG9wX29yLCBudW0pO1xuICB9XG4gIC8vIGFsaWduIG51bWJlciBvbiAzMGsrMSBib3VuZGFyeVxuICBudW0uZEFkZE9mZnNldCgzMSAtIG51bS5tb2QoVEhJUlRZKS5ieXRlVmFsdWUoKSwgMCk7XG4gIHJldHVybiBudW07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIE1pbGxlci1SYWJpbiB0ZXN0cyB0byBnZW5lcmF0ZSBhXG4gKiBwcmltZSB3aXRoIGFuIGVycm9yIHByb2JhYmlsaXR5IG9mICgxLzIpXjgwLlxuICpcbiAqIFNlZSBIYW5kYm9vayBvZiBBcHBsaWVkIENyeXB0b2dyYXBoeSBDaGFwdGVyIDQsIFRhYmxlIDQuNC5cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUuXG4gKlxuICogQHJldHVybiB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGdldE1pbGxlclJhYmluVGVzdHMoYml0cykge1xuICBpZihiaXRzIDw9IDEwMCkgcmV0dXJuIDI3O1xuICBpZihiaXRzIDw9IDE1MCkgcmV0dXJuIDE4O1xuICBpZihiaXRzIDw9IDIwMCkgcmV0dXJuIDE1O1xuICBpZihiaXRzIDw9IDI1MCkgcmV0dXJuIDEyO1xuICBpZihiaXRzIDw9IDMwMCkgcmV0dXJuIDk7XG4gIGlmKGJpdHMgPD0gMzUwKSByZXR1cm4gODtcbiAgaWYoYml0cyA8PSA0MDApIHJldHVybiA3O1xuICBpZihiaXRzIDw9IDUwMCkgcmV0dXJuIDY7XG4gIGlmKGJpdHMgPD0gNjAwKSByZXR1cm4gNTtcbiAgaWYoYml0cyA8PSA4MDApIHJldHVybiA0O1xuICBpZihiaXRzIDw9IDEyNTApIHJldHVybiAzO1xuICByZXR1cm4gMjtcbn1cblxufSkoKTtcbiIsIi8qKlxuICogUGFydGlhbCBpbXBsZW1lbnRhdGlvbiBvZiBQS0NTIzEgdjIuMjogUlNBLU9FQVBcbiAqXG4gKiBNb2RpZmllZCBidXQgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBNSVQgYW5kIEJTRCBsaWNlbnNlZCBjb2RlOlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ranVyL2pzandzL2Jsb2IvbWFzdGVyL3JzYS5qczpcbiAqXG4gKiBUaGUgJ2pzandzJyhKU09OIFdlYiBTaWduYXR1cmUgSmF2YVNjcmlwdCBMaWJyYXJ5KSBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIEtlbmppIFVydXNoaW1hXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiBodHRwOi8vd2VicnNhLmN2cy5zb3VyY2Vmb3JnZS5uZXQvdmlld3ZjL3dlYnJzYS9DbGllbnQvUlNBRVMtT0FFUC5qcz9jb250ZW50LXR5cGU9dGV4dCUyRnBsYWluOlxuICpcbiAqIFJTQUVTLU9BRVAuanNcbiAqICRJZDogUlNBRVMtT0FFUC5qcyx2IDEuMS4xLjEgMjAwMy8wMy8xOSAxNTozNzoyMCBlbGxpc3ByaXRjaGFyZCBFeHAgJFxuICogSmF2YVNjcmlwdCBJbXBsZW1lbnRhdGlvbiBvZiBQS0NTICMxIHYyLjEgUlNBIENSWVBUT0dSQVBIWSBTVEFOREFSRCAoUlNBIExhYm9yYXRvcmllcywgSnVuZSAxNCwgMjAwMilcbiAqIENvcHlyaWdodCAoQykgRWxsaXMgUHJpdGNoYXJkLCBHdWFyZGlhbiBVbmxpbWl0ZWQgMjAwMy5cbiAqIENvbnRhY3Q6IGVsbGlzQG51a2luZXRpY3MuY29tXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG4gKlxuICogT2ZmaWNpYWwgZG9jdW1lbnRhdGlvbjogaHR0cDovL3d3dy5yc2EuY29tL3JzYWxhYnMvbm9kZS5hc3A/aWQ9MjEyNVxuICpcbiAqIEBhdXRob3IgRXZhbiBKb25lcyAoaHR0cDovL2V2YW5qb25lcy5jYS8pXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xucmVxdWlyZSgnLi9yYW5kb20nKTtcbnJlcXVpcmUoJy4vc2hhMScpO1xuXG4vLyBzaG9ydGN1dCBmb3IgUEtDUyMxIEFQSVxudmFyIHBrY3MxID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2NzMSA9IGZvcmdlLnBrY3MxIHx8IHt9O1xuXG4vKipcbiAqIEVuY29kZSB0aGUgZ2l2ZW4gUlNBRVMtT0FFUCBtZXNzYWdlIChNKSB1c2luZyBrZXksIHdpdGggb3B0aW9uYWwgbGFiZWwgKEwpXG4gKiBhbmQgc2VlZC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBwZXJmb3JtIFJTQSBlbmNyeXB0aW9uLCBpdCBvbmx5IGVuY29kZXMgdGhlIG1lc3NhZ2VcbiAqIHVzaW5nIFJTQUVTLU9BRVAuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBsYWJlbCBhbiBvcHRpb25hbCBsYWJlbCB0byB1c2UuXG4gKiAgICAgICAgICBzZWVkIHRoZSBzZWVkIHRvIHVzZS5cbiAqICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlLCB1bmRlZmluZWQgZm9yIFNIQS0xLlxuICogICAgICAgICAgbWdmMSBvcHRpb25hbCBtZ2YxIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIGZvciBNR0YxLlxuICpcbiAqIEByZXR1cm4gdGhlIGVuY29kZWQgbWVzc2FnZSBieXRlcy5cbiAqL1xucGtjczEuZW5jb2RlX3JzYV9vYWVwID0gZnVuY3Rpb24oa2V5LCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gIC8vIHBhcnNlIGFyZ3VtZW50c1xuICB2YXIgbGFiZWw7XG4gIHZhciBzZWVkO1xuICB2YXIgbWQ7XG4gIHZhciBtZ2YxTWQ7XG4gIC8vIGxlZ2FjeSBhcmdzIChsYWJlbCwgc2VlZCwgbWQpXG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIGxhYmVsID0gb3B0aW9ucztcbiAgICBzZWVkID0gYXJndW1lbnRzWzNdIHx8IHVuZGVmaW5lZDtcbiAgICBtZCA9IGFyZ3VtZW50c1s0XSB8fCB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZihvcHRpb25zKSB7XG4gICAgbGFiZWwgPSBvcHRpb25zLmxhYmVsIHx8IHVuZGVmaW5lZDtcbiAgICBzZWVkID0gb3B0aW9ucy5zZWVkIHx8IHVuZGVmaW5lZDtcbiAgICBtZCA9IG9wdGlvbnMubWQgfHwgdW5kZWZpbmVkO1xuICAgIGlmKG9wdGlvbnMubWdmMSAmJiBvcHRpb25zLm1nZjEubWQpIHtcbiAgICAgIG1nZjFNZCA9IG9wdGlvbnMubWdmMS5tZDtcbiAgICB9XG4gIH1cblxuICAvLyBkZWZhdWx0IE9BRVAgdG8gU0hBLTEgbWVzc2FnZSBkaWdlc3RcbiAgaWYoIW1kKSB7XG4gICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICB9IGVsc2Uge1xuICAgIG1kLnN0YXJ0KCk7XG4gIH1cblxuICAvLyBkZWZhdWx0IE1HRi0xIHRvIHNhbWUgYXMgT0FFUFxuICBpZighbWdmMU1kKSB7XG4gICAgbWdmMU1kID0gbWQ7XG4gIH1cblxuICAvLyBjb21wdXRlIGxlbmd0aCBpbiBieXRlcyBhbmQgY2hlY2sgb3V0cHV0XG4gIHZhciBrZXlMZW5ndGggPSBNYXRoLmNlaWwoa2V5Lm4uYml0TGVuZ3RoKCkgLyA4KTtcbiAgdmFyIG1heExlbmd0aCA9IGtleUxlbmd0aCAtIDIgKiBtZC5kaWdlc3RMZW5ndGggLSAyO1xuICBpZihtZXNzYWdlLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignUlNBRVMtT0FFUCBpbnB1dCBtZXNzYWdlIGxlbmd0aCBpcyB0b28gbG9uZy4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBtZXNzYWdlLmxlbmd0aDtcbiAgICBlcnJvci5tYXhMZW5ndGggPSBtYXhMZW5ndGg7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZighbGFiZWwpIHtcbiAgICBsYWJlbCA9ICcnO1xuICB9XG4gIG1kLnVwZGF0ZShsYWJlbCwgJ3JhdycpO1xuICB2YXIgbEhhc2ggPSBtZC5kaWdlc3QoKTtcblxuICB2YXIgUFMgPSAnJztcbiAgdmFyIFBTX2xlbmd0aCA9IG1heExlbmd0aCAtIG1lc3NhZ2UubGVuZ3RoO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgUFNfbGVuZ3RoOyBpKyspIHtcbiAgICBQUyArPSAnXFx4MDAnO1xuICB9XG5cbiAgdmFyIERCID0gbEhhc2guZ2V0Qnl0ZXMoKSArIFBTICsgJ1xceDAxJyArIG1lc3NhZ2U7XG5cbiAgaWYoIXNlZWQpIHtcbiAgICBzZWVkID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzKG1kLmRpZ2VzdExlbmd0aCk7XG4gIH0gZWxzZSBpZihzZWVkLmxlbmd0aCAhPT0gbWQuZGlnZXN0TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkIFJTQUVTLU9BRVAgc2VlZC4gVGhlIHNlZWQgbGVuZ3RoIG11c3QgJyArXG4gICAgICAnbWF0Y2ggdGhlIGRpZ2VzdCBsZW5ndGguJyk7XG4gICAgZXJyb3Iuc2VlZExlbmd0aCA9IHNlZWQubGVuZ3RoO1xuICAgIGVycm9yLmRpZ2VzdExlbmd0aCA9IG1kLmRpZ2VzdExlbmd0aDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBkYk1hc2sgPSByc2FfbWdmMShzZWVkLCBrZXlMZW5ndGggLSBtZC5kaWdlc3RMZW5ndGggLSAxLCBtZ2YxTWQpO1xuICB2YXIgbWFza2VkREIgPSBmb3JnZS51dGlsLnhvckJ5dGVzKERCLCBkYk1hc2ssIERCLmxlbmd0aCk7XG5cbiAgdmFyIHNlZWRNYXNrID0gcnNhX21nZjEobWFza2VkREIsIG1kLmRpZ2VzdExlbmd0aCwgbWdmMU1kKTtcbiAgdmFyIG1hc2tlZFNlZWQgPSBmb3JnZS51dGlsLnhvckJ5dGVzKHNlZWQsIHNlZWRNYXNrLCBzZWVkLmxlbmd0aCk7XG5cbiAgLy8gcmV0dXJuIGVuY29kZWQgbWVzc2FnZVxuICByZXR1cm4gJ1xceDAwJyArIG1hc2tlZFNlZWQgKyBtYXNrZWREQjtcbn07XG5cbi8qKlxuICogRGVjb2RlIHRoZSBnaXZlbiBSU0FFUy1PQUVQIGVuY29kZWQgbWVzc2FnZSAoRU0pIHVzaW5nIGtleSwgd2l0aCBvcHRpb25hbFxuICogbGFiZWwgKEwpLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHBlcmZvcm0gUlNBIGRlY3J5cHRpb24sIGl0IG9ubHkgZGVjb2RlcyB0aGUgbWVzc2FnZVxuICogdXNpbmcgUlNBRVMtT0FFUC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBlbSB0aGUgZW5jb2RlZCBtZXNzYWdlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIGxhYmVsIGFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZS5cbiAqICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIGZvciBPQUVQLCB1bmRlZmluZWQgZm9yIFNIQS0xLlxuICogICAgICAgICAgbWdmMSBvcHRpb25hbCBtZ2YxIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIGZvciBNR0YxLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlY29kZWQgbWVzc2FnZSBieXRlcy5cbiAqL1xucGtjczEuZGVjb2RlX3JzYV9vYWVwID0gZnVuY3Rpb24oa2V5LCBlbSwgb3B0aW9ucykge1xuICAvLyBwYXJzZSBhcmdzXG4gIHZhciBsYWJlbDtcbiAgdmFyIG1kO1xuICB2YXIgbWdmMU1kO1xuICAvLyBsZWdhY3kgYXJnc1xuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnM7XG4gICAgbWQgPSBhcmd1bWVudHNbM10gfHwgdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYob3B0aW9ucykge1xuICAgIGxhYmVsID0gb3B0aW9ucy5sYWJlbCB8fCB1bmRlZmluZWQ7XG4gICAgbWQgPSBvcHRpb25zLm1kIHx8IHVuZGVmaW5lZDtcbiAgICBpZihvcHRpb25zLm1nZjEgJiYgb3B0aW9ucy5tZ2YxLm1kKSB7XG4gICAgICBtZ2YxTWQgPSBvcHRpb25zLm1nZjEubWQ7XG4gICAgfVxuICB9XG5cbiAgLy8gY29tcHV0ZSBsZW5ndGggaW4gYnl0ZXNcbiAgdmFyIGtleUxlbmd0aCA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIGlmKGVtLmxlbmd0aCAhPT0ga2V5TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdSU0FFUy1PQUVQIGVuY29kZWQgbWVzc2FnZSBsZW5ndGggaXMgaW52YWxpZC4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBlbS5sZW5ndGg7XG4gICAgZXJyb3IuZXhwZWN0ZWRMZW5ndGggPSBrZXlMZW5ndGg7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBkZWZhdWx0IE9BRVAgdG8gU0hBLTEgbWVzc2FnZSBkaWdlc3RcbiAgaWYobWQgPT09IHVuZGVmaW5lZCkge1xuICAgIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICBtZC5zdGFydCgpO1xuICB9XG5cbiAgLy8gZGVmYXVsdCBNR0YtMSB0byBzYW1lIGFzIE9BRVBcbiAgaWYoIW1nZjFNZCkge1xuICAgIG1nZjFNZCA9IG1kO1xuICB9XG5cbiAgaWYoa2V5TGVuZ3RoIDwgMiAqIG1kLmRpZ2VzdExlbmd0aCArIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JTQUVTLU9BRVAga2V5IGlzIHRvbyBzaG9ydCBmb3IgdGhlIGhhc2ggZnVuY3Rpb24uJyk7XG4gIH1cblxuICBpZighbGFiZWwpIHtcbiAgICBsYWJlbCA9ICcnO1xuICB9XG4gIG1kLnVwZGF0ZShsYWJlbCwgJ3JhdycpO1xuICB2YXIgbEhhc2ggPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gIC8vIHNwbGl0IHRoZSBtZXNzYWdlIGludG8gaXRzIHBhcnRzXG4gIHZhciB5ID0gZW0uY2hhckF0KDApO1xuICB2YXIgbWFza2VkU2VlZCA9IGVtLnN1YnN0cmluZygxLCBtZC5kaWdlc3RMZW5ndGggKyAxKTtcbiAgdmFyIG1hc2tlZERCID0gZW0uc3Vic3RyaW5nKDEgKyBtZC5kaWdlc3RMZW5ndGgpO1xuXG4gIHZhciBzZWVkTWFzayA9IHJzYV9tZ2YxKG1hc2tlZERCLCBtZC5kaWdlc3RMZW5ndGgsIG1nZjFNZCk7XG4gIHZhciBzZWVkID0gZm9yZ2UudXRpbC54b3JCeXRlcyhtYXNrZWRTZWVkLCBzZWVkTWFzaywgbWFza2VkU2VlZC5sZW5ndGgpO1xuXG4gIHZhciBkYk1hc2sgPSByc2FfbWdmMShzZWVkLCBrZXlMZW5ndGggLSBtZC5kaWdlc3RMZW5ndGggLSAxLCBtZ2YxTWQpO1xuICB2YXIgZGIgPSBmb3JnZS51dGlsLnhvckJ5dGVzKG1hc2tlZERCLCBkYk1hc2ssIG1hc2tlZERCLmxlbmd0aCk7XG5cbiAgdmFyIGxIYXNoUHJpbWUgPSBkYi5zdWJzdHJpbmcoMCwgbWQuZGlnZXN0TGVuZ3RoKTtcblxuICAvLyBjb25zdGFudCB0aW1lIGNoZWNrIHRoYXQgYWxsIHZhbHVlcyBtYXRjaCB3aGF0IGlzIGV4cGVjdGVkXG4gIHZhciBlcnJvciA9ICh5ICE9PSAnXFx4MDAnKTtcblxuICAvLyBjb25zdGFudCB0aW1lIGNoZWNrIGxIYXNoIHZzIGxIYXNoUHJpbWVcbiAgZm9yKHZhciBpID0gMDsgaSA8IG1kLmRpZ2VzdExlbmd0aDsgKytpKSB7XG4gICAgZXJyb3IgfD0gKGxIYXNoLmNoYXJBdChpKSAhPT0gbEhhc2hQcmltZS5jaGFyQXQoaSkpO1xuICB9XG5cbiAgLy8gXCJjb25zdGFudCB0aW1lXCIgZmluZCB0aGUgMHgxIGJ5dGUgc2VwYXJhdGluZyB0aGUgcGFkZGluZyAoemVyb3MpIGZyb20gdGhlXG4gIC8vIG1lc3NhZ2VcbiAgLy8gVE9ETzogSXQgbXVzdCBiZSBwb3NzaWJsZSB0byBkbyB0aGlzIGluIGEgYmV0dGVyL3NtYXJ0ZXIgd2F5P1xuICB2YXIgaW5fcHMgPSAxO1xuICB2YXIgaW5kZXggPSBtZC5kaWdlc3RMZW5ndGg7XG4gIGZvcih2YXIgaiA9IG1kLmRpZ2VzdExlbmd0aDsgaiA8IGRiLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIGNvZGUgPSBkYi5jaGFyQ29kZUF0KGopO1xuXG4gICAgdmFyIGlzXzAgPSAoY29kZSAmIDB4MSkgXiAweDE7XG5cbiAgICAvLyBub24temVybyBpZiBub3QgMCBvciAxIGluIHRoZSBwcyBzZWN0aW9uXG4gICAgdmFyIGVycm9yX21hc2sgPSBpbl9wcyA/IDB4ZmZmZSA6IDB4MDAwMDtcbiAgICBlcnJvciB8PSAoY29kZSAmIGVycm9yX21hc2spO1xuXG4gICAgLy8gbGF0Y2ggaW5fcHMgdG8gemVybyBhZnRlciB3ZSBmaW5kIDB4MVxuICAgIGluX3BzID0gaW5fcHMgJiBpc18wO1xuICAgIGluZGV4ICs9IGluX3BzO1xuICB9XG5cbiAgaWYoZXJyb3IgfHwgZGIuY2hhckNvZGVBdChpbmRleCkgIT09IDB4MSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSU0FFUy1PQUVQIHBhZGRpbmcuJyk7XG4gIH1cblxuICByZXR1cm4gZGIuc3Vic3RyaW5nKGluZGV4ICsgMSk7XG59O1xuXG5mdW5jdGlvbiByc2FfbWdmMShzZWVkLCBtYXNrTGVuZ3RoLCBoYXNoKSB7XG4gIC8vIGRlZmF1bHQgdG8gU0hBLTEgbWVzc2FnZSBkaWdlc3RcbiAgaWYoIWhhc2gpIHtcbiAgICBoYXNoID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfVxuICB2YXIgdCA9ICcnO1xuICB2YXIgY291bnQgPSBNYXRoLmNlaWwobWFza0xlbmd0aCAvIGhhc2guZGlnZXN0TGVuZ3RoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICB2YXIgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAoaSA+PiAyNCkgJiAweEZGLCAoaSA+PiAxNikgJiAweEZGLCAoaSA+PiA4KSAmIDB4RkYsIGkgJiAweEZGKTtcbiAgICBoYXNoLnN0YXJ0KCk7XG4gICAgaGFzaC51cGRhdGUoc2VlZCArIGMpO1xuICAgIHQgKz0gaGFzaC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICB9XG4gIHJldHVybiB0LnN1YnN0cmluZygwLCBtYXNrTGVuZ3RoKTtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBub2RlaWZ5ID0gcmVxdWlyZSgnLi4vbm9kZWlmeScpXG5jb25zdCB3ZWJjcnlwdG8gPSByZXF1aXJlKCcuLi93ZWJjcnlwdG8nKVxuY29uc3QgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCcuLi9yYW5kb20tYnl0ZXMnKVxuXG5leHBvcnRzLnV0aWxzID0gcmVxdWlyZSgnLi9yc2EtdXRpbHMnKVxuXG5leHBvcnRzLmdlbmVyYXRlS2V5ID0gZnVuY3Rpb24gKGJpdHMsIGNhbGxiYWNrKSB7XG4gIG5vZGVpZnkod2ViY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleShcbiAgICB7XG4gICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgbW9kdWx1c0xlbmd0aDogYml0cyxcbiAgICAgIHB1YmxpY0V4cG9uZW50OiBuZXcgVWludDhBcnJheShbMHgwMSwgMHgwMCwgMHgwMV0pLFxuICAgICAgaGFzaDogeyBuYW1lOiAnU0hBLTI1NicgfVxuICAgIH0sXG4gICAgdHJ1ZSxcbiAgICBbJ3NpZ24nLCAndmVyaWZ5J11cbiAgKVxuICAgIC50aGVuKGV4cG9ydEtleSlcbiAgICAudGhlbigoa2V5cykgPT4gKHtcbiAgICAgIHByaXZhdGVLZXk6IGtleXNbMF0sXG4gICAgICBwdWJsaWNLZXk6IGtleXNbMV1cbiAgICB9KSksIGNhbGxiYWNrKVxufVxuXG4vLyBUYWtlcyBhIGp3ayBrZXlcbmV4cG9ydHMudW5tYXJzaGFsUHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHByaXZhdGVLZXkgPSB3ZWJjcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAnandrJyxcbiAgICBrZXksXG4gICAge1xuICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH1cbiAgICB9LFxuICAgIHRydWUsXG4gICAgWydzaWduJ11cbiAgKVxuXG4gIG5vZGVpZnkoUHJvbWlzZS5hbGwoW1xuICAgIHByaXZhdGVLZXksXG4gICAgZGVyaXZlUHVibGljRnJvbVByaXZhdGUoa2V5KVxuICBdKS50aGVuKChrZXlzKSA9PiBleHBvcnRLZXkoe1xuICAgIHByaXZhdGVLZXk6IGtleXNbMF0sXG4gICAgcHVibGljS2V5OiBrZXlzWzFdXG4gIH0pKS50aGVuKChrZXlzKSA9PiAoe1xuICAgIHByaXZhdGVLZXk6IGtleXNbMF0sXG4gICAgcHVibGljS2V5OiBrZXlzWzFdXG4gIH0pKSwgY2FsbGJhY2spXG59XG5cbmV4cG9ydHMuZ2V0UmFuZG9tVmFsdWVzID0gcmFuZG9tQnl0ZXNcblxuZXhwb3J0cy5oYXNoQW5kU2lnbiA9IGZ1bmN0aW9uIChrZXksIG1zZywgY2FsbGJhY2spIHtcbiAgbm9kZWlmeSh3ZWJjcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAnandrJyxcbiAgICBrZXksXG4gICAge1xuICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH1cbiAgICB9LFxuICAgIGZhbHNlLFxuICAgIFsnc2lnbiddXG4gICkudGhlbigocHJpdmF0ZUtleSkgPT4ge1xuICAgIHJldHVybiB3ZWJjcnlwdG8uc3VidGxlLnNpZ24oXG4gICAgICB7IG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScgfSxcbiAgICAgIHByaXZhdGVLZXksXG4gICAgICBVaW50OEFycmF5LmZyb20obXNnKVxuICAgIClcbiAgfSkudGhlbigoc2lnKSA9PiBCdWZmZXIuZnJvbShzaWcpKSwgY2FsbGJhY2spXG59XG5cbmV4cG9ydHMuaGFzaEFuZFZlcmlmeSA9IGZ1bmN0aW9uIChrZXksIHNpZywgbXNnLCBjYWxsYmFjaykge1xuICBub2RlaWZ5KHdlYmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICdqd2snLFxuICAgIGtleSxcbiAgICB7XG4gICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgaGFzaDogeyBuYW1lOiAnU0hBLTI1NicgfVxuICAgIH0sXG4gICAgZmFsc2UsXG4gICAgWyd2ZXJpZnknXVxuICApLnRoZW4oKHB1YmxpY0tleSkgPT4ge1xuICAgIHJldHVybiB3ZWJjcnlwdG8uc3VidGxlLnZlcmlmeShcbiAgICAgIHsgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyB9LFxuICAgICAgcHVibGljS2V5LFxuICAgICAgc2lnLFxuICAgICAgbXNnXG4gICAgKVxuICB9KSwgY2FsbGJhY2spXG59XG5cbmZ1bmN0aW9uIGV4cG9ydEtleSAocGFpcikge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIHdlYmNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdqd2snLCBwYWlyLnByaXZhdGVLZXkpLFxuICAgIHdlYmNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdqd2snLCBwYWlyLnB1YmxpY0tleSlcbiAgXSlcbn1cblxuZnVuY3Rpb24gZGVyaXZlUHVibGljRnJvbVByaXZhdGUgKGp3S2V5KSB7XG4gIHJldHVybiB3ZWJjcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAnandrJyxcbiAgICB7XG4gICAgICBrdHk6IGp3S2V5Lmt0eSxcbiAgICAgIG46IGp3S2V5Lm4sXG4gICAgICBlOiBqd0tleS5lXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgaGFzaDogeyBuYW1lOiAnU0hBLTI1NicgfVxuICAgIH0sXG4gICAgdHJ1ZSxcbiAgICBbJ3ZlcmlmeSddXG4gIClcbn1cbiIsIi8qKlxuICogU2VjdXJlIEhhc2ggQWxnb3JpdGhtIHdpdGggYSAxMDI0LWJpdCBibG9jayBzaXplIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRoaXMgaW5jbHVkZXM6IFNIQS01MTIsIFNIQS0zODQsIFNIQS01MTIvMjI0LCBhbmQgU0hBLTUxMi8yNTYuIEZvclxuICogU0hBLTI1NiAoYmxvY2sgc2l6ZSA1MTIgYml0cyksIHNlZSBzaGEyNTYuanMuXG4gKlxuICogU2VlIEZJUFMgMTgwLTQgZm9yIGRldGFpbHMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL21kJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHNoYTUxMiA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2Uuc2hhNTEyID0gZm9yZ2Uuc2hhNTEyIHx8IHt9O1xuXG4vLyBTSEEtNTEyXG5mb3JnZS5tZC5zaGE1MTIgPSBmb3JnZS5tZC5hbGdvcml0aG1zLnNoYTUxMiA9IHNoYTUxMjtcblxuLy8gU0hBLTM4NFxudmFyIHNoYTM4NCA9IGZvcmdlLnNoYTM4NCA9IGZvcmdlLnNoYTUxMi5zaGEzODQgPSBmb3JnZS5zaGE1MTIuc2hhMzg0IHx8IHt9O1xuc2hhMzg0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gc2hhNTEyLmNyZWF0ZSgnU0hBLTM4NCcpO1xufTtcbmZvcmdlLm1kLnNoYTM4NCA9IGZvcmdlLm1kLmFsZ29yaXRobXMuc2hhMzg0ID0gc2hhMzg0O1xuXG4vLyBTSEEtNTEyLzI1NlxuZm9yZ2Uuc2hhNTEyLnNoYTI1NiA9IGZvcmdlLnNoYTUxMi5zaGEyNTYgfHwge1xuICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzaGE1MTIuY3JlYXRlKCdTSEEtNTEyLzI1NicpO1xuICB9XG59O1xuZm9yZ2UubWRbJ3NoYTUxMi8yNTYnXSA9IGZvcmdlLm1kLmFsZ29yaXRobXNbJ3NoYTUxMi8yNTYnXSA9XG4gIGZvcmdlLnNoYTUxMi5zaGEyNTY7XG5cbi8vIFNIQS01MTIvMjI0XG5mb3JnZS5zaGE1MTIuc2hhMjI0ID0gZm9yZ2Uuc2hhNTEyLnNoYTIyNCB8fCB7XG4gIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNoYTUxMi5jcmVhdGUoJ1NIQS01MTIvMjI0Jyk7XG4gIH1cbn07XG5mb3JnZS5tZFsnc2hhNTEyLzIyNCddID0gZm9yZ2UubWQuYWxnb3JpdGhtc1snc2hhNTEyLzIyNCddID1cbiAgZm9yZ2Uuc2hhNTEyLnNoYTIyNDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU0hBLTIgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhbGdvcml0aG0gdGhlIGFsZ29yaXRobSB0byB1c2UgKFNIQS01MTIsIFNIQS0zODQsIFNIQS01MTIvMjI0LFxuICogICAgICAgICAgU0hBLTUxMi8yNTYpLlxuICpcbiAqIEByZXR1cm4gYSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKi9cbnNoYTUxMi5jcmVhdGUgPSBmdW5jdGlvbihhbGdvcml0aG0pIHtcbiAgLy8gZG8gaW5pdGlhbGl6YXRpb24gYXMgbmVjZXNzYXJ5XG4gIGlmKCFfaW5pdGlhbGl6ZWQpIHtcbiAgICBfaW5pdCgpO1xuICB9XG5cbiAgaWYodHlwZW9mIGFsZ29yaXRobSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhbGdvcml0aG0gPSAnU0hBLTUxMic7XG4gIH1cblxuICBpZighKGFsZ29yaXRobSBpbiBfc3RhdGVzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBTSEEtNTEyIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICAvLyBTSEEtNTEyIHN0YXRlIGNvbnRhaW5zIGVpZ2h0IDY0LWJpdCBpbnRlZ2VycyAoZWFjaCBhcyB0d28gMzItYml0IGludHMpXG4gIHZhciBfc3RhdGUgPSBfc3RhdGVzW2FsZ29yaXRobV07XG4gIHZhciBfaCA9IG51bGw7XG5cbiAgLy8gaW5wdXQgYnVmZmVyXG4gIHZhciBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIHVzZWQgZm9yIDY0LWJpdCB3b3JkIHN0b3JhZ2VcbiAgdmFyIF93ID0gbmV3IEFycmF5KDgwKTtcbiAgZm9yKHZhciB3aSA9IDA7IHdpIDwgODA7ICsrd2kpIHtcbiAgICBfd1t3aV0gPSBuZXcgQXJyYXkoMik7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgZGlnZXN0IGxlbmd0aCBieSBhbGdvcml0aG0gbmFtZSAoZGVmYXVsdClcbiAgdmFyIGRpZ2VzdExlbmd0aCA9IDY0O1xuICBzd2l0Y2goYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnU0hBLTM4NCc6XG4gICAgICBkaWdlc3RMZW5ndGggPSA0ODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1NIQS01MTIvMjU2JzpcbiAgICAgIGRpZ2VzdExlbmd0aCA9IDMyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnU0hBLTUxMi8yMjQnOlxuICAgICAgZGlnZXN0TGVuZ3RoID0gMjg7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIG1lc3NhZ2UgZGlnZXN0IG9iamVjdFxuICB2YXIgbWQgPSB7XG4gICAgLy8gU0hBLTUxMiA9PiBzaGE1MTJcbiAgICBhbGdvcml0aG06IGFsZ29yaXRobS5yZXBsYWNlKCctJywgJycpLnRvTG93ZXJDYXNlKCksXG4gICAgYmxvY2tMZW5ndGg6IDEyOCxcbiAgICBkaWdlc3RMZW5ndGg6IGRpZ2VzdExlbmd0aCxcbiAgICAvLyA1Ni1iaXQgbGVuZ3RoIG9mIG1lc3NhZ2Ugc28gZmFyIChkb2VzIG5vdCBpbmNsdWRpbmcgcGFkZGluZylcbiAgICBtZXNzYWdlTGVuZ3RoOiAwLFxuICAgIC8vIHRydWUgbWVzc2FnZSBsZW5ndGhcbiAgICBmdWxsTWVzc2FnZUxlbmd0aDogbnVsbCxcbiAgICAvLyBzaXplIG9mIG1lc3NhZ2UgbGVuZ3RoIGluIGJ5dGVzXG4gICAgbWVzc2FnZUxlbmd0aFNpemU6IDE2XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgZGlnZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdXAgdG8gNTYtYml0IG1lc3NhZ2UgbGVuZ3RoIGZvciBjb252ZW5pZW5jZVxuICAgIG1kLm1lc3NhZ2VMZW5ndGggPSAwO1xuXG4gICAgLy8gZnVsbCBtZXNzYWdlIGxlbmd0aCAoc2V0IG1kLm1lc3NhZ2VMZW5ndGgxMjggZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5KVxuICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoID0gbWQubWVzc2FnZUxlbmd0aDEyOCA9IFtdO1xuICAgIHZhciBpbnQzMnMgPSBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSAvIDQ7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGludDMyczsgKytpKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aC5wdXNoKDApO1xuICAgIH1cbiAgICBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIF9oID0gbmV3IEFycmF5KF9zdGF0ZS5sZW5ndGgpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBfc3RhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgIF9oW2ldID0gX3N0YXRlW2ldLnNsaWNlKDApO1xuICAgIH1cbiAgICByZXR1cm4gbWQ7XG4gIH07XG4gIC8vIHN0YXJ0IGRpZ2VzdCBhdXRvbWF0aWNhbGx5IGZvciBmaXJzdCB0aW1lXG4gIG1kLnN0YXJ0KCk7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGRpZ2VzdCB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGlucHV0LiBUaGUgZ2l2ZW4gaW5wdXQgY2FuXG4gICAqIHRyZWF0ZWQgYXMgcmF3IGlucHV0IChubyBlbmNvZGluZyB3aWxsIGJlIGFwcGxpZWQpIG9yIGFuIGVuY29kaW5nIG9mXG4gICAqICd1dGY4JyBtYXliZSBnaXZlbiB0byBlbmNvZGUgdGhlIGlucHV0IHVzaW5nIFVURi04LlxuICAgKlxuICAgKiBAcGFyYW0gbXNnIHRoZSBtZXNzYWdlIGlucHV0IHRvIHVwZGF0ZSB3aXRoLlxuICAgKiBAcGFyYW0gZW5jb2RpbmcgdGhlIGVuY29kaW5nIHRvIHVzZSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnVwZGF0ZSA9IGZ1bmN0aW9uKG1zZywgZW5jb2RpbmcpIHtcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICBtc2cgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgobXNnKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgbWVzc2FnZSBsZW5ndGhcbiAgICB2YXIgbGVuID0gbXNnLmxlbmd0aDtcbiAgICBtZC5tZXNzYWdlTGVuZ3RoICs9IGxlbjtcbiAgICBsZW4gPSBbKGxlbiAvIDB4MTAwMDAwMDAwKSA+Pj4gMCwgbGVuID4+PiAwXTtcbiAgICBmb3IodmFyIGkgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gKz0gbGVuWzFdO1xuICAgICAgbGVuWzFdID0gbGVuWzBdICsgKChtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID4+PiAwO1xuICAgICAgbGVuWzBdID0gKChsZW5bMV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgIH1cblxuICAgIC8vIGFkZCBieXRlcyB0byBpbnB1dCBidWZmZXJcbiAgICBfaW5wdXQucHV0Qnl0ZXMobXNnKTtcblxuICAgIC8vIHByb2Nlc3MgYnl0ZXNcbiAgICBfdXBkYXRlKF9oLCBfdywgX2lucHV0KTtcblxuICAgIC8vIGNvbXBhY3QgaW5wdXQgYnVmZmVyIGV2ZXJ5IDJLIG9yIGlmIGVtcHR5XG4gICAgaWYoX2lucHV0LnJlYWQgPiAyMDQ4IHx8IF9pbnB1dC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgX2lucHV0LmNvbXBhY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gYSBieXRlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBkaWdlc3QgdmFsdWUuXG4gICAqL1xuICBtZC5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBOb3RlOiBIZXJlIHdlIGNvcHkgdGhlIHJlbWFpbmluZyBieXRlcyBpbiB0aGUgaW5wdXQgYnVmZmVyIGFuZFxuICAgIGFkZCB0aGUgYXBwcm9wcmlhdGUgU0hBLTUxMiBwYWRkaW5nLiBUaGVuIHdlIGRvIHRoZSBmaW5hbCB1cGRhdGVcbiAgICBvbiBhIGNvcHkgb2YgdGhlIHN0YXRlIHNvIHRoYXQgaWYgdGhlIHVzZXIgd2FudHMgdG8gZ2V0XG4gICAgaW50ZXJtZWRpYXRlIGRpZ2VzdHMgdGhleSBjYW4gZG8gc28uICovXG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBieXRlcyB0aGF0IG11c3QgYmUgYWRkZWQgdG8gdGhlIG1lc3NhZ2VcbiAgICB0byBlbnN1cmUgaXRzIGxlbmd0aCBpcyBjb25ncnVlbnQgdG8gODk2IG1vZCAxMDI0LiBJbiBvdGhlciB3b3JkcyxcbiAgICB0aGUgZGF0YSB0byBiZSBkaWdlc3RlZCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTAyNCBiaXRzIChvciAxMjggYnl0ZXMpLlxuICAgIFRoaXMgZGF0YSBpbmNsdWRlcyB0aGUgbWVzc2FnZSwgc29tZSBwYWRkaW5nLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBtZXNzYWdlLiBTaW5jZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIHdpbGwgYmUgZW5jb2RlZCBhcyAxNiBieXRlcyAoMTI4XG4gICAgYml0cyksIHRoYXQgbWVhbnMgdGhhdCB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBkYXRhIG11c3QgaGF2ZSAxMTIgYnl0ZXNcbiAgICAoODk2IGJpdHMpIG9mIG1lc3NhZ2UgYW5kIHBhZGRpbmcuIFRoZXJlZm9yZSwgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZVxuICAgIHBsdXMgdGhlIHBhZGRpbmcgbXVzdCBiZSBjb25ncnVlbnQgdG8gODk2IG1vZCAxMDI0IGJlY2F1c2VcbiAgICAxMDI0IC0gMTI4ID0gODk2LlxuXG4gICAgSW4gb3JkZXIgdG8gZmlsbCB1cCB0aGUgbWVzc2FnZSBsZW5ndGggaXQgbXVzdCBiZSBmaWxsZWQgd2l0aFxuICAgIHBhZGRpbmcgdGhhdCBiZWdpbnMgd2l0aCAxIGJpdCBmb2xsb3dlZCBieSBhbGwgMCBiaXRzLiBQYWRkaW5nXG4gICAgbXVzdCAqYWx3YXlzKiBiZSBwcmVzZW50LCBzbyBpZiB0aGUgbWVzc2FnZSBsZW5ndGggaXMgYWxyZWFkeVxuICAgIGNvbmdydWVudCB0byA4OTYgbW9kIDEwMjQsIHRoZW4gMTAyNCBwYWRkaW5nIGJpdHMgbXVzdCBiZSBhZGRlZC4gKi9cblxuICAgIHZhciBmaW5hbEJsb2NrID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmaW5hbEJsb2NrLnB1dEJ5dGVzKF9pbnB1dC5ieXRlcygpKTtcblxuICAgIC8vIGNvbXB1dGUgcmVtYWluaW5nIHNpemUgdG8gYmUgZGlnZXN0ZWQgKGluY2x1ZGUgbWVzc2FnZSBsZW5ndGggc2l6ZSlcbiAgICB2YXIgcmVtYWluaW5nID0gKFxuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMV0gK1xuICAgICAgbWQubWVzc2FnZUxlbmd0aFNpemUpO1xuXG4gICAgLy8gYWRkIHBhZGRpbmcgZm9yIG92ZXJmbG93IGJsb2NrU2l6ZSAtIG92ZXJmbG93XG4gICAgLy8gX3BhZGRpbmcgc3RhcnRzIHdpdGggMSBieXRlIHdpdGggZmlyc3QgYml0IGlzIHNldCAoYnl0ZSB2YWx1ZSAxMjgpLCB0aGVuXG4gICAgLy8gdGhlcmUgbWF5IGJlIHVwIHRvIChibG9ja1NpemUgLSAxKSBvdGhlciBwYWQgYnl0ZXNcbiAgICB2YXIgb3ZlcmZsb3cgPSByZW1haW5pbmcgJiAobWQuYmxvY2tMZW5ndGggLSAxKTtcbiAgICBmaW5hbEJsb2NrLnB1dEJ5dGVzKF9wYWRkaW5nLnN1YnN0cigwLCBtZC5ibG9ja0xlbmd0aCAtIG92ZXJmbG93KSk7XG5cbiAgICAvLyBzZXJpYWxpemUgbWVzc2FnZSBsZW5ndGggaW4gYml0cyBpbiBiaWctZW5kaWFuIG9yZGVyOyBzaW5jZSBsZW5ndGhcbiAgICAvLyBpcyBzdG9yZWQgaW4gYnl0ZXMgd2UgbXVsdGlwbHkgYnkgOCBhbmQgYWRkIGNhcnJ5IGZyb20gbmV4dCBpbnRcbiAgICB2YXIgbmV4dCwgY2Fycnk7XG4gICAgdmFyIGJpdHMgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFswXSAqIDg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgbmV4dCA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2kgKyAxXSAqIDg7XG4gICAgICBjYXJyeSA9IChuZXh0IC8gMHgxMDAwMDAwMDApID4+PiAwO1xuICAgICAgYml0cyArPSBjYXJyeTtcbiAgICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyA+Pj4gMCk7XG4gICAgICBiaXRzID0gbmV4dCA+Pj4gMDtcbiAgICB9XG4gICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzKTtcblxuICAgIHZhciBoID0gbmV3IEFycmF5KF9oLmxlbmd0aCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IF9oLmxlbmd0aDsgKytpKSB7XG4gICAgICBoW2ldID0gX2hbaV0uc2xpY2UoMCk7XG4gICAgfVxuICAgIF91cGRhdGUoaCwgX3csIGZpbmFsQmxvY2spO1xuICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB2YXIgaGxlbjtcbiAgICBpZihhbGdvcml0aG0gPT09ICdTSEEtNTEyJykge1xuICAgICAgaGxlbiA9IGgubGVuZ3RoO1xuICAgIH0gZWxzZSBpZihhbGdvcml0aG0gPT09ICdTSEEtMzg0Jykge1xuICAgICAgaGxlbiA9IGgubGVuZ3RoIC0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgaGxlbiA9IGgubGVuZ3RoIC0gNDtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGhsZW47ICsraSkge1xuICAgICAgcnZhbC5wdXRJbnQzMihoW2ldWzBdKTtcbiAgICAgIGlmKGkgIT09IGhsZW4gLSAxIHx8IGFsZ29yaXRobSAhPT0gJ1NIQS01MTIvMjI0Jykge1xuICAgICAgICBydmFsLnB1dEludDMyKGhbaV1bMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gbWQ7XG59O1xuXG4vLyBzaGEtNTEyIHBhZGRpbmcgYnl0ZXMgbm90IGluaXRpYWxpemVkIHlldFxudmFyIF9wYWRkaW5nID0gbnVsbDtcbnZhciBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLy8gdGFibGUgb2YgY29uc3RhbnRzXG52YXIgX2sgPSBudWxsO1xuXG4vLyBpbml0aWFsIGhhc2ggc3RhdGVzXG52YXIgX3N0YXRlcyA9IG51bGw7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbnN0YW50IHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gX2luaXQoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nXG4gIF9wYWRkaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjgpO1xuICBfcGFkZGluZyArPSBmb3JnZS51dGlsLmZpbGxTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgweDAwKSwgMTI4KTtcblxuICAvLyBjcmVhdGUgSyB0YWJsZSBmb3IgU0hBLTUxMlxuICBfayA9IFtcbiAgICBbMHg0MjhhMmY5OCwgMHhkNzI4YWUyMl0sIFsweDcxMzc0NDkxLCAweDIzZWY2NWNkXSxcbiAgICBbMHhiNWMwZmJjZiwgMHhlYzRkM2IyZl0sIFsweGU5YjVkYmE1LCAweDgxODlkYmJjXSxcbiAgICBbMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOF0sIFsweDU5ZjExMWYxLCAweGI2MDVkMDE5XSxcbiAgICBbMHg5MjNmODJhNCwgMHhhZjE5NGY5Yl0sIFsweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4XSxcbiAgICBbMHhkODA3YWE5OCwgMHhhMzAzMDI0Ml0sIFsweDEyODM1YjAxLCAweDQ1NzA2ZmJlXSxcbiAgICBbMHgyNDMxODViZSwgMHg0ZWU0YjI4Y10sIFsweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyXSxcbiAgICBbMHg3MmJlNWQ3NCwgMHhmMjdiODk2Zl0sIFsweDgwZGViMWZlLCAweDNiMTY5NmIxXSxcbiAgICBbMHg5YmRjMDZhNywgMHgyNWM3MTIzNV0sIFsweGMxOWJmMTc0LCAweGNmNjkyNjk0XSxcbiAgICBbMHhlNDliNjljMSwgMHg5ZWYxNGFkMl0sIFsweGVmYmU0Nzg2LCAweDM4NGYyNWUzXSxcbiAgICBbMHgwZmMxOWRjNiwgMHg4YjhjZDViNV0sIFsweDI0MGNhMWNjLCAweDc3YWM5YzY1XSxcbiAgICBbMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NV0sIFsweDRhNzQ4NGFhLCAweDZlYTZlNDgzXSxcbiAgICBbMHg1Y2IwYTlkYywgMHhiZDQxZmJkNF0sIFsweDc2Zjk4OGRhLCAweDgzMTE1M2I1XSxcbiAgICBbMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYl0sIFsweGE4MzFjNjZkLCAweDJkYjQzMjEwXSxcbiAgICBbMHhiMDAzMjdjOCwgMHg5OGZiMjEzZl0sIFsweGJmNTk3ZmM3LCAweGJlZWYwZWU0XSxcbiAgICBbMHhjNmUwMGJmMywgMHgzZGE4OGZjMl0sIFsweGQ1YTc5MTQ3LCAweDkzMGFhNzI1XSxcbiAgICBbMHgwNmNhNjM1MSwgMHhlMDAzODI2Zl0sIFsweDE0MjkyOTY3LCAweDBhMGU2ZTcwXSxcbiAgICBbMHgyN2I3MGE4NSwgMHg0NmQyMmZmY10sIFsweDJlMWIyMTM4LCAweDVjMjZjOTI2XSxcbiAgICBbMHg0ZDJjNmRmYywgMHg1YWM0MmFlZF0sIFsweDUzMzgwZDEzLCAweDlkOTViM2RmXSxcbiAgICBbMHg2NTBhNzM1NCwgMHg4YmFmNjNkZV0sIFsweDc2NmEwYWJiLCAweDNjNzdiMmE4XSxcbiAgICBbMHg4MWMyYzkyZSwgMHg0N2VkYWVlNl0sIFsweDkyNzIyYzg1LCAweDE0ODIzNTNiXSxcbiAgICBbMHhhMmJmZThhMSwgMHg0Y2YxMDM2NF0sIFsweGE4MWE2NjRiLCAweGJjNDIzMDAxXSxcbiAgICBbMHhjMjRiOGI3MCwgMHhkMGY4OTc5MV0sIFsweGM3NmM1MWEzLCAweDA2NTRiZTMwXSxcbiAgICBbMHhkMTkyZTgxOSwgMHhkNmVmNTIxOF0sIFsweGQ2OTkwNjI0LCAweDU1NjVhOTEwXSxcbiAgICBbMHhmNDBlMzU4NSwgMHg1NzcxMjAyYV0sIFsweDEwNmFhMDcwLCAweDMyYmJkMWI4XSxcbiAgICBbMHgxOWE0YzExNiwgMHhiOGQyZDBjOF0sIFsweDFlMzc2YzA4LCAweDUxNDFhYjUzXSxcbiAgICBbMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OV0sIFsweDM0YjBiY2I1LCAweGUxOWI0OGE4XSxcbiAgICBbMHgzOTFjMGNiMywgMHhjNWM5NWE2M10sIFsweDRlZDhhYTRhLCAweGUzNDE4YWNiXSxcbiAgICBbMHg1YjljY2E0ZiwgMHg3NzYzZTM3M10sIFsweDY4MmU2ZmYzLCAweGQ2YjJiOGEzXSxcbiAgICBbMHg3NDhmODJlZSwgMHg1ZGVmYjJmY10sIFsweDc4YTU2MzZmLCAweDQzMTcyZjYwXSxcbiAgICBbMHg4NGM4NzgxNCwgMHhhMWYwYWI3Ml0sIFsweDhjYzcwMjA4LCAweDFhNjQzOWVjXSxcbiAgICBbMHg5MGJlZmZmYSwgMHgyMzYzMWUyOF0sIFsweGE0NTA2Y2ViLCAweGRlODJiZGU5XSxcbiAgICBbMHhiZWY5YTNmNywgMHhiMmM2NzkxNV0sIFsweGM2NzE3OGYyLCAweGUzNzI1MzJiXSxcbiAgICBbMHhjYTI3M2VjZSwgMHhlYTI2NjE5Y10sIFsweGQxODZiOGM3LCAweDIxYzBjMjA3XSxcbiAgICBbMHhlYWRhN2RkNiwgMHhjZGUwZWIxZV0sIFsweGY1N2Q0ZjdmLCAweGVlNmVkMTc4XSxcbiAgICBbMHgwNmYwNjdhYSwgMHg3MjE3NmZiYV0sIFsweDBhNjM3ZGM1LCAweGEyYzg5OGE2XSxcbiAgICBbMHgxMTNmOTgwNCwgMHhiZWY5MGRhZV0sIFsweDFiNzEwYjM1LCAweDEzMWM0NzFiXSxcbiAgICBbMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NF0sIFsweDMyY2FhYjdiLCAweDQwYzcyNDkzXSxcbiAgICBbMHgzYzllYmUwYSwgMHgxNWM5YmViY10sIFsweDQzMWQ2N2M0LCAweDljMTAwZDRjXSxcbiAgICBbMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNl0sIFsweDU5N2YyOTljLCAweGZjNjU3ZTJhXSxcbiAgICBbMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlY10sIFsweDZjNDQxOThjLCAweDRhNDc1ODE3XVxuICBdO1xuXG4gIC8vIGluaXRpYWwgaGFzaCBzdGF0ZXNcbiAgX3N0YXRlcyA9IHt9O1xuICBfc3RhdGVzWydTSEEtNTEyJ10gPSBbXG4gICAgWzB4NmEwOWU2NjcsIDB4ZjNiY2M5MDhdLFxuICAgIFsweGJiNjdhZTg1LCAweDg0Y2FhNzNiXSxcbiAgICBbMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYl0sXG4gICAgWzB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjFdLFxuICAgIFsweDUxMGU1MjdmLCAweGFkZTY4MmQxXSxcbiAgICBbMHg5YjA1Njg4YywgMHgyYjNlNmMxZl0sXG4gICAgWzB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmJdLFxuICAgIFsweDViZTBjZDE5LCAweDEzN2UyMTc5XVxuICBdO1xuICBfc3RhdGVzWydTSEEtMzg0J10gPSBbXG4gICAgWzB4Y2JiYjlkNWQsIDB4YzEwNTllZDhdLFxuICAgIFsweDYyOWEyOTJhLCAweDM2N2NkNTA3XSxcbiAgICBbMHg5MTU5MDE1YSwgMHgzMDcwZGQxN10sXG4gICAgWzB4MTUyZmVjZDgsIDB4ZjcwZTU5MzldLFxuICAgIFsweDY3MzMyNjY3LCAweGZmYzAwYjMxXSxcbiAgICBbMHg4ZWI0NGE4NywgMHg2ODU4MTUxMV0sXG4gICAgWzB4ZGIwYzJlMGQsIDB4NjRmOThmYTddLFxuICAgIFsweDQ3YjU0ODFkLCAweGJlZmE0ZmE0XVxuICBdO1xuICBfc3RhdGVzWydTSEEtNTEyLzI1NiddID0gW1xuICAgIFsweDIyMzEyMTk0LCAweEZDMkJGNzJDXSxcbiAgICBbMHg5RjU1NUZBMywgMHhDODRDNjRDMl0sXG4gICAgWzB4MjM5M0I4NkIsIDB4NkY1M0IxNTFdLFxuICAgIFsweDk2Mzg3NzE5LCAweDU5NDBFQUJEXSxcbiAgICBbMHg5NjI4M0VFMiwgMHhBODhFRkZFM10sXG4gICAgWzB4QkU1RTFFMjUsIDB4NTM4NjM5OTJdLFxuICAgIFsweDJCMDE5OUZDLCAweDJDODVCOEFBXSxcbiAgICBbMHgwRUI3MkREQywgMHg4MUM1MkNBMl1cbiAgXTtcbiAgX3N0YXRlc1snU0hBLTUxMi8yMjQnXSA9IFtcbiAgICBbMHg4QzNEMzdDOCwgMHgxOTU0NERBMl0sXG4gICAgWzB4NzNFMTk5NjYsIDB4ODlEQ0Q0RDZdLFxuICAgIFsweDFERkFCN0FFLCAweDMyRkY5QzgyXSxcbiAgICBbMHg2NzlERDUxNCwgMHg1ODJGOUZDRl0sXG4gICAgWzB4MEY2RDJCNjksIDB4N0JENDREQThdLFxuICAgIFsweDc3RTM2RjczLCAweDA0QzQ4OTQyXSxcbiAgICBbMHgzRjlEODVBOCwgMHg2QTFEMzZDOF0sXG4gICAgWzB4MTExMkU2QUQsIDB4OTFENjkyQTFdXG4gIF07XG5cbiAgLy8gbm93IGluaXRpYWxpemVkXG4gIF9pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIFNIQS01MTIgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHMgdGhlIFNIQS01MTIgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICgxMjggYnl0ZSkgY2h1bmtzXG4gIHZhciB0MV9oaSwgdDFfbG87XG4gIHZhciB0Ml9oaSwgdDJfbG87XG4gIHZhciBzMF9oaSwgczBfbG87XG4gIHZhciBzMV9oaSwgczFfbG87XG4gIHZhciBjaF9oaSwgY2hfbG87XG4gIHZhciBtYWpfaGksIG1hal9sbztcbiAgdmFyIGFfaGksIGFfbG87XG4gIHZhciBiX2hpLCBiX2xvO1xuICB2YXIgY19oaSwgY19sbztcbiAgdmFyIGRfaGksIGRfbG87XG4gIHZhciBlX2hpLCBlX2xvO1xuICB2YXIgZl9oaSwgZl9sbztcbiAgdmFyIGdfaGksIGdfbG87XG4gIHZhciBoX2hpLCBoX2xvO1xuICB2YXIgaSwgaGksIGxvLCB3MiwgdzcsIHcxNSwgdzE2O1xuICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoKCk7XG4gIHdoaWxlKGxlbiA+PSAxMjgpIHtcbiAgICAvLyB0aGUgdyBhcnJheSB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIHNpeHRlZW4gNjQtYml0IGJpZy1lbmRpYW4gd29yZHNcbiAgICAvLyBhbmQgdGhlbiBleHRlbmRlZCBpbnRvIDY0IDY0LWJpdCB3b3JkcyBhY2NvcmRpbmcgdG8gU0hBLTUxMlxuICAgIGZvcihpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIHdbaV1bMF0gPSBieXRlcy5nZXRJbnQzMigpID4+PiAwO1xuICAgICAgd1tpXVsxXSA9IGJ5dGVzLmdldEludDMyKCkgPj4+IDA7XG4gICAgfVxuICAgIGZvcig7IGkgPCA4MDsgKytpKSB7XG4gICAgICAvLyBmb3Igd29yZCAyIHdvcmRzIGFnbzogUk9UUiAxOSh4KSBeIFJPVFIgNjEoeCkgXiBTSFIgNih4KVxuICAgICAgdzIgPSB3W2kgLSAyXTtcbiAgICAgIGhpID0gdzJbMF07XG4gICAgICBsbyA9IHcyWzFdO1xuXG4gICAgICAvLyBoaWdoIGJpdHNcbiAgICAgIHQxX2hpID0gKFxuICAgICAgICAoKGhpID4+PiAxOSkgfCAobG8gPDwgMTMpKSBeIC8vIFJPVFIgMTlcbiAgICAgICAgKChsbyA+Pj4gMjkpIHwgKGhpIDw8IDMpKSBeIC8vIFJPVFIgNjEvKHN3YXAgKyBST1RSIDI5KVxuICAgICAgICAoaGkgPj4+IDYpKSA+Pj4gMDsgLy8gU0hSIDZcbiAgICAgIC8vIGxvdyBiaXRzXG4gICAgICB0MV9sbyA9IChcbiAgICAgICAgKChoaSA8PCAxMykgfCAobG8gPj4+IDE5KSkgXiAvLyBST1RSIDE5XG4gICAgICAgICgobG8gPDwgMykgfCAoaGkgPj4+IDI5KSkgXiAvLyBST1RSIDYxLyhzd2FwICsgUk9UUiAyOSlcbiAgICAgICAgKChoaSA8PCAyNikgfCAobG8gPj4+IDYpKSkgPj4+IDA7IC8vIFNIUiA2XG5cbiAgICAgIC8vIGZvciB3b3JkIDE1IHdvcmRzIGFnbzogUk9UUiAxKHgpIF4gUk9UUiA4KHgpIF4gU0hSIDcoeClcbiAgICAgIHcxNSA9IHdbaSAtIDE1XTtcbiAgICAgIGhpID0gdzE1WzBdO1xuICAgICAgbG8gPSB3MTVbMV07XG5cbiAgICAgIC8vIGhpZ2ggYml0c1xuICAgICAgdDJfaGkgPSAoXG4gICAgICAgICgoaGkgPj4+IDEpIHwgKGxvIDw8IDMxKSkgXiAvLyBST1RSIDFcbiAgICAgICAgKChoaSA+Pj4gOCkgfCAobG8gPDwgMjQpKSBeIC8vIFJPVFIgOFxuICAgICAgICAoaGkgPj4+IDcpKSA+Pj4gMDsgLy8gU0hSIDdcbiAgICAgIC8vIGxvdyBiaXRzXG4gICAgICB0Ml9sbyA9IChcbiAgICAgICAgKChoaSA8PCAzMSkgfCAobG8gPj4+IDEpKSBeIC8vIFJPVFIgMVxuICAgICAgICAoKGhpIDw8IDI0KSB8IChsbyA+Pj4gOCkpIF4gLy8gUk9UUiA4XG4gICAgICAgICgoaGkgPDwgMjUpIHwgKGxvID4+PiA3KSkpID4+PiAwOyAvLyBTSFIgN1xuXG4gICAgICAvLyBzdW0odDEsIHdvcmQgNyBhZ28sIHQyLCB3b3JkIDE2IGFnbykgbW9kdWxvIDJeNjQgKGNhcnJ5IGxvIG92ZXJmbG93KVxuICAgICAgdzcgPSB3W2kgLSA3XTtcbiAgICAgIHcxNiA9IHdbaSAtIDE2XTtcbiAgICAgIGxvID0gKHQxX2xvICsgdzdbMV0gKyB0Ml9sbyArIHcxNlsxXSk7XG4gICAgICB3W2ldWzBdID0gKHQxX2hpICsgdzdbMF0gKyB0Ml9oaSArIHcxNlswXSArXG4gICAgICAgICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICAgIHdbaV1bMV0gPSBsbyA+Pj4gMDtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIGhhc2ggdmFsdWUgZm9yIHRoaXMgY2h1bmtcbiAgICBhX2hpID0gc1swXVswXTtcbiAgICBhX2xvID0gc1swXVsxXTtcbiAgICBiX2hpID0gc1sxXVswXTtcbiAgICBiX2xvID0gc1sxXVsxXTtcbiAgICBjX2hpID0gc1syXVswXTtcbiAgICBjX2xvID0gc1syXVsxXTtcbiAgICBkX2hpID0gc1szXVswXTtcbiAgICBkX2xvID0gc1szXVsxXTtcbiAgICBlX2hpID0gc1s0XVswXTtcbiAgICBlX2xvID0gc1s0XVsxXTtcbiAgICBmX2hpID0gc1s1XVswXTtcbiAgICBmX2xvID0gc1s1XVsxXTtcbiAgICBnX2hpID0gc1s2XVswXTtcbiAgICBnX2xvID0gc1s2XVsxXTtcbiAgICBoX2hpID0gc1s3XVswXTtcbiAgICBoX2xvID0gc1s3XVsxXTtcblxuICAgIC8vIHJvdW5kIGZ1bmN0aW9uXG4gICAgZm9yKGkgPSAwOyBpIDwgODA7ICsraSkge1xuICAgICAgLy8gU3VtMShlKSA9IFJPVFIgMTQoZSkgXiBST1RSIDE4KGUpIF4gUk9UUiA0MShlKVxuICAgICAgczFfaGkgPSAoXG4gICAgICAgICgoZV9oaSA+Pj4gMTQpIHwgKGVfbG8gPDwgMTgpKSBeIC8vIFJPVFIgMTRcbiAgICAgICAgKChlX2hpID4+PiAxOCkgfCAoZV9sbyA8PCAxNCkpIF4gLy8gUk9UUiAxOFxuICAgICAgICAoKGVfbG8gPj4+IDkpIHwgKGVfaGkgPDwgMjMpKSkgPj4+IDA7IC8vIFJPVFIgNDEvKHN3YXAgKyBST1RSIDkpXG4gICAgICBzMV9sbyA9IChcbiAgICAgICAgKChlX2hpIDw8IDE4KSB8IChlX2xvID4+PiAxNCkpIF4gLy8gUk9UUiAxNFxuICAgICAgICAoKGVfaGkgPDwgMTQpIHwgKGVfbG8gPj4+IDE4KSkgXiAvLyBST1RSIDE4XG4gICAgICAgICgoZV9sbyA8PCAyMykgfCAoZV9oaSA+Pj4gOSkpKSA+Pj4gMDsgLy8gUk9UUiA0MS8oc3dhcCArIFJPVFIgOSlcblxuICAgICAgLy8gQ2goZSwgZiwgZykgKG9wdGltaXplZCB0aGUgc2FtZSB3YXkgYXMgU0hBLTEpXG4gICAgICBjaF9oaSA9IChnX2hpIF4gKGVfaGkgJiAoZl9oaSBeIGdfaGkpKSkgPj4+IDA7XG4gICAgICBjaF9sbyA9IChnX2xvIF4gKGVfbG8gJiAoZl9sbyBeIGdfbG8pKSkgPj4+IDA7XG5cbiAgICAgIC8vIFN1bTAoYSkgPSBST1RSIDI4KGEpIF4gUk9UUiAzNChhKSBeIFJPVFIgMzkoYSlcbiAgICAgIHMwX2hpID0gKFxuICAgICAgICAoKGFfaGkgPj4+IDI4KSB8IChhX2xvIDw8IDQpKSBeIC8vIFJPVFIgMjhcbiAgICAgICAgKChhX2xvID4+PiAyKSB8IChhX2hpIDw8IDMwKSkgXiAvLyBST1RSIDM0Lyhzd2FwICsgUk9UUiAyKVxuICAgICAgICAoKGFfbG8gPj4+IDcpIHwgKGFfaGkgPDwgMjUpKSkgPj4+IDA7IC8vIFJPVFIgMzkvKHN3YXAgKyBST1RSIDcpXG4gICAgICBzMF9sbyA9IChcbiAgICAgICAgKChhX2hpIDw8IDQpIHwgKGFfbG8gPj4+IDI4KSkgXiAvLyBST1RSIDI4XG4gICAgICAgICgoYV9sbyA8PCAzMCkgfCAoYV9oaSA+Pj4gMikpIF4gLy8gUk9UUiAzNC8oc3dhcCArIFJPVFIgMilcbiAgICAgICAgKChhX2xvIDw8IDI1KSB8IChhX2hpID4+PiA3KSkpID4+PiAwOyAvLyBST1RSIDM5Lyhzd2FwICsgUk9UUiA3KVxuXG4gICAgICAvLyBNYWooYSwgYiwgYykgKG9wdGltaXplZCB0aGUgc2FtZSB3YXkgYXMgU0hBLTEpXG4gICAgICBtYWpfaGkgPSAoKGFfaGkgJiBiX2hpKSB8IChjX2hpICYgKGFfaGkgXiBiX2hpKSkpID4+PiAwO1xuICAgICAgbWFqX2xvID0gKChhX2xvICYgYl9sbykgfCAoY19sbyAmIChhX2xvIF4gYl9sbykpKSA+Pj4gMDtcblxuICAgICAgLy8gbWFpbiBhbGdvcml0aG1cbiAgICAgIC8vIHQxID0gKGggKyBzMSArIGNoICsgX2tbaV0gKyBfd1tpXSkgbW9kdWxvIDJeNjQgKGNhcnJ5IGxvIG92ZXJmbG93KVxuICAgICAgbG8gPSAoaF9sbyArIHMxX2xvICsgY2hfbG8gKyBfa1tpXVsxXSArIHdbaV1bMV0pO1xuICAgICAgdDFfaGkgPSAoaF9oaSArIHMxX2hpICsgY2hfaGkgKyBfa1tpXVswXSArIHdbaV1bMF0gK1xuICAgICAgICAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgICB0MV9sbyA9IGxvID4+PiAwO1xuXG4gICAgICAvLyB0MiA9IHMwICsgbWFqIG1vZHVsbyAyXjY0IChjYXJyeSBsbyBvdmVyZmxvdylcbiAgICAgIGxvID0gczBfbG8gKyBtYWpfbG87XG4gICAgICB0Ml9oaSA9IChzMF9oaSArIG1hal9oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICAgIHQyX2xvID0gbG8gPj4+IDA7XG5cbiAgICAgIGhfaGkgPSBnX2hpO1xuICAgICAgaF9sbyA9IGdfbG87XG5cbiAgICAgIGdfaGkgPSBmX2hpO1xuICAgICAgZ19sbyA9IGZfbG87XG5cbiAgICAgIGZfaGkgPSBlX2hpO1xuICAgICAgZl9sbyA9IGVfbG87XG5cbiAgICAgIC8vIGUgPSAoZCArIHQxKSBtb2R1bG8gMl42NCAoY2FycnkgbG8gb3ZlcmZsb3cpXG4gICAgICBsbyA9IGRfbG8gKyB0MV9sbztcbiAgICAgIGVfaGkgPSAoZF9oaSArIHQxX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgICAgZV9sbyA9IGxvID4+PiAwO1xuXG4gICAgICBkX2hpID0gY19oaTtcbiAgICAgIGRfbG8gPSBjX2xvO1xuXG4gICAgICBjX2hpID0gYl9oaTtcbiAgICAgIGNfbG8gPSBiX2xvO1xuXG4gICAgICBiX2hpID0gYV9oaTtcbiAgICAgIGJfbG8gPSBhX2xvO1xuXG4gICAgICAvLyBhID0gKHQxICsgdDIpIG1vZHVsbyAyXjY0IChjYXJyeSBsbyBvdmVyZmxvdylcbiAgICAgIGxvID0gdDFfbG8gKyB0Ml9sbztcbiAgICAgIGFfaGkgPSAodDFfaGkgKyB0Ml9oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICAgIGFfbG8gPSBsbyA+Pj4gMDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgaGFzaCBzdGF0ZSAoYWRkaXRpb25hbCBtb2R1bG8gMl42NClcbiAgICBsbyA9IHNbMF1bMV0gKyBhX2xvO1xuICAgIHNbMF1bMF0gPSAoc1swXVswXSArIGFfaGkgKyAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgc1swXVsxXSA9IGxvID4+PiAwO1xuXG4gICAgbG8gPSBzWzFdWzFdICsgYl9sbztcbiAgICBzWzFdWzBdID0gKHNbMV1bMF0gKyBiX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgIHNbMV1bMV0gPSBsbyA+Pj4gMDtcblxuICAgIGxvID0gc1syXVsxXSArIGNfbG87XG4gICAgc1syXVswXSA9IChzWzJdWzBdICsgY19oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICBzWzJdWzFdID0gbG8gPj4+IDA7XG5cbiAgICBsbyA9IHNbM11bMV0gKyBkX2xvO1xuICAgIHNbM11bMF0gPSAoc1szXVswXSArIGRfaGkgKyAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgc1szXVsxXSA9IGxvID4+PiAwO1xuXG4gICAgbG8gPSBzWzRdWzFdICsgZV9sbztcbiAgICBzWzRdWzBdID0gKHNbNF1bMF0gKyBlX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgIHNbNF1bMV0gPSBsbyA+Pj4gMDtcblxuICAgIGxvID0gc1s1XVsxXSArIGZfbG87XG4gICAgc1s1XVswXSA9IChzWzVdWzBdICsgZl9oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICBzWzVdWzFdID0gbG8gPj4+IDA7XG5cbiAgICBsbyA9IHNbNl1bMV0gKyBnX2xvO1xuICAgIHNbNl1bMF0gPSAoc1s2XVswXSArIGdfaGkgKyAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgc1s2XVsxXSA9IGxvID4+PiAwO1xuXG4gICAgbG8gPSBzWzddWzFdICsgaF9sbztcbiAgICBzWzddWzBdID0gKHNbN11bMF0gKyBoX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgIHNbN11bMV0gPSBsbyA+Pj4gMDtcblxuICAgIGxlbiAtPSAxMjg7XG4gIH1cbn1cbiIsInZhciBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxudmFyIHN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5JylcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZVxubW9kdWxlLmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGVuY29kaW5ncyA9IHJlcXVpcmUoJy4vZW5jb2RpbmdzJylcbnZhciBjb21waWxlRGVjb2RlID0gcmVxdWlyZSgnLi9kZWNvZGUnKVxudmFyIGNvbXBpbGVFbmNvZGUgPSByZXF1aXJlKCcuL2VuY29kZScpXG52YXIgY29tcGlsZUVuY29kaW5nTGVuZ3RoID0gcmVxdWlyZSgnLi9lbmNvZGluZy1sZW5ndGgnKVxudmFyIHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5cbnZhciBmbGF0dGVuID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICBpZiAoIXZhbHVlcykgcmV0dXJuIG51bGxcbiAgdmFyIHJlc3VsdCA9IHt9XG4gIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHJlc3VsdFtrXSA9IHZhbHVlc1trXS52YWx1ZVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaGVtYSwgZXh0cmFFbmNvZGluZ3MpIHtcbiAgdmFyIG1lc3NhZ2VzID0ge31cbiAgdmFyIGVudW1zID0ge31cbiAgdmFyIGNhY2hlID0ge31cblxuICB2YXIgdmlzaXQgPSBmdW5jdGlvbiAoc2NoZW1hLCBwcmVmaXgpIHtcbiAgICBpZiAoc2NoZW1hLmVudW1zKSB7XG4gICAgICBzY2hlbWEuZW51bXMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLmlkID0gcHJlZml4ICsgKHByZWZpeCA/ICcuJyA6ICcnKSArIGUubmFtZVxuICAgICAgICBlbnVtc1tlLmlkXSA9IGVcbiAgICAgICAgdmlzaXQoZSwgZS5pZClcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChzY2hlbWEubWVzc2FnZXMpIHtcbiAgICAgIHNjaGVtYS5tZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIG0uaWQgPSBwcmVmaXggKyAocHJlZml4ID8gJy4nIDogJycpICsgbS5uYW1lXG4gICAgICAgIG1lc3NhZ2VzW20uaWRdID0gbVxuICAgICAgICBtLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgaWYgKCFmLm1hcCkgcmV0dXJuXG5cbiAgICAgICAgICB2YXIgbmFtZSA9ICdNYXBfJyArIGYubWFwLmZyb20gKyAnXycgKyBmLm1hcC50b1xuICAgICAgICAgIHZhciBtYXAgPSB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgZW51bXM6IFtdLFxuICAgICAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICAgICAgZmllbGRzOiBbe1xuICAgICAgICAgICAgICBuYW1lOiAna2V5JyxcbiAgICAgICAgICAgICAgdHlwZTogZi5tYXAuZnJvbSxcbiAgICAgICAgICAgICAgdGFnOiAxLFxuICAgICAgICAgICAgICByZXBlYXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICAgICAgICAgIHR5cGU6IGYubWFwLnRvLFxuICAgICAgICAgICAgICB0YWc6IDIsXG4gICAgICAgICAgICAgIHJlcGVhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IG51bGwsXG4gICAgICAgICAgICBpZDogcHJlZml4ICsgKHByZWZpeCA/ICcuJyA6ICcnKSArIG5hbWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW1lc3NhZ2VzW21hcC5pZF0pIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzW21hcC5pZF0gPSBtYXBcbiAgICAgICAgICAgIHNjaGVtYS5tZXNzYWdlcy5wdXNoKG1hcClcbiAgICAgICAgICB9XG4gICAgICAgICAgZi50eXBlID0gbmFtZVxuICAgICAgICAgIGYucmVwZWF0ZWQgPSB0cnVlXG4gICAgICAgIH0pXG4gICAgICAgIHZpc2l0KG0sIG0uaWQpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZpc2l0KHNjaGVtYSwgJycpXG5cbiAgdmFyIGNvbXBpbGVFbnVtID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgdmFsdWVzID0gT2JqZWN0LmtleXMoZS52YWx1ZXMgfHwgW10pLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGUudmFsdWVzW2tdLnZhbHVlLCAxMClcbiAgICB9KVxuXG4gICAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZSAodmFsLCBidWYsIG9mZnNldCkge1xuICAgICAgaWYgKCF2YWx1ZXMubGVuZ3RoIHx8IHZhbHVlcy5pbmRleE9mKHZhbCkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbnVtIHZhbHVlOiAnICsgdmFsKVxuICAgICAgfVxuICAgICAgdmFyaW50LmVuY29kZSh2YWwsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgZW5jb2RlLmJ5dGVzID0gdmFyaW50LmVuY29kZS5ieXRlc1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIHZhciBkZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUgKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgICB2YXIgdmFsID0gdmFyaW50LmRlY29kZShidWYsIG9mZnNldClcbiAgICAgIGlmICghdmFsdWVzLmxlbmd0aCB8fCB2YWx1ZXMuaW5kZXhPZih2YWwpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW51bSB2YWx1ZTogJyArIHZhbClcbiAgICAgIH1cbiAgICAgIGRlY29kZS5ieXRlcyA9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RpbmdzLm1ha2UoMCwgZW5jb2RlLCBkZWNvZGUsIHZhcmludC5lbmNvZGluZ0xlbmd0aClcbiAgfVxuXG4gIHZhciBjb21waWxlTWVzc2FnZSA9IGZ1bmN0aW9uIChtLCBleHBvcnRzKSB7XG4gICAgbS5tZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZXN0ZWQpIHtcbiAgICAgIGV4cG9ydHNbbmVzdGVkLm5hbWVdID0gcmVzb2x2ZShuZXN0ZWQubmFtZSwgbS5pZClcbiAgICB9KVxuXG4gICAgbS5lbnVtcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIGV4cG9ydHNbdmFsLm5hbWVdID0gZmxhdHRlbih2YWwudmFsdWVzKVxuICAgIH0pXG5cbiAgICBleHBvcnRzLnR5cGUgPSAyXG4gICAgZXhwb3J0cy5tZXNzYWdlID0gdHJ1ZVxuICAgIGV4cG9ydHMubmFtZSA9IG0ubmFtZVxuXG4gICAgdmFyIG9uZW9mcyA9IHt9XG5cbiAgICBtLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICBpZiAoIWYub25lb2YpIHJldHVyblxuICAgICAgaWYgKCFvbmVvZnNbZi5vbmVvZl0pIG9uZW9mc1tmLm9uZW9mXSA9IFtdXG4gICAgICBvbmVvZnNbZi5vbmVvZl0ucHVzaChmLm5hbWUpXG4gICAgfSlcblxuICAgIHZhciBlbmMgPSBtLmZpZWxkcy5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKGYudHlwZSwgbS5pZClcbiAgICB9KVxuXG4gICAgdmFyIGVuY29kaW5nTGVuZ3RoID0gY29tcGlsZUVuY29kaW5nTGVuZ3RoKG0sIGVuYywgb25lb2ZzKVxuICAgIHZhciBlbmNvZGUgPSBjb21waWxlRW5jb2RlKG0sIHJlc29sdmUsIGVuYywgb25lb2ZzLCBlbmNvZGluZ0xlbmd0aClcbiAgICB2YXIgZGVjb2RlID0gY29tcGlsZURlY29kZShtLCByZXNvbHZlLCBlbmMpXG5cbiAgICAvLyBlbmQgb2YgY29tcGlsYXRpb24gLSByZXR1cm4gYWxsIHRoZSB0aGluZ3NcblxuICAgIGVuY29kZS5ieXRlcyA9IGRlY29kZS5ieXRlcyA9IDBcblxuICAgIGV4cG9ydHMuYnVmZmVyID0gdHJ1ZVxuICAgIGV4cG9ydHMuZW5jb2RlID0gZW5jb2RlXG4gICAgZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGVcbiAgICBleHBvcnRzLmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGhcblxuICAgIHJldHVybiBleHBvcnRzXG4gIH1cblxuICB2YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uIChuYW1lLCBmcm9tLCBjb21waWxlKSB7XG4gICAgaWYgKGV4dHJhRW5jb2RpbmdzICYmIGV4dHJhRW5jb2RpbmdzW25hbWVdKSByZXR1cm4gZXh0cmFFbmNvZGluZ3NbbmFtZV1cbiAgICBpZiAoZW5jb2RpbmdzW25hbWVdKSByZXR1cm4gZW5jb2RpbmdzW25hbWVdXG5cbiAgICB2YXIgbSA9IChmcm9tID8gZnJvbSArICcuJyArIG5hbWUgOiBuYW1lKS5zcGxpdCgnLicpXG4gICAgICAubWFwKGZ1bmN0aW9uIChwYXJ0LCBpLCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBsaXN0LnNsaWNlKDAsIGkpLmNvbmNhdChuYW1lKS5qb2luKCcuJylcbiAgICAgIH0pXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGlkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgbWVzc2FnZXNbaWRdIHx8IGVudW1zW2lkXVxuICAgICAgfSwgbnVsbClcblxuICAgIGlmIChjb21waWxlID09PSBmYWxzZSkgcmV0dXJuIG1cbiAgICBpZiAoIW0pIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlc29sdmUgJyArIG5hbWUpXG5cbiAgICBpZiAobS52YWx1ZXMpIHJldHVybiBjb21waWxlRW51bShtKVxuICAgIHZhciByZXMgPSBjYWNoZVttLmlkXSB8fCBjb21waWxlTWVzc2FnZShtLCBjYWNoZVttLmlkXSA9IHt9KVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIHJldHVybiAoc2NoZW1hLmVudW1zIHx8IFtdKS5jb25jYXQoKHNjaGVtYS5tZXNzYWdlcyB8fCBbXSkubWFwKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHJlc29sdmUobWVzc2FnZS5pZClcbiAgfSkpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qgd2ViY3J5cHRvID0gcmVxdWlyZSgnLi4vd2ViY3J5cHRvJylcbmNvbnN0IG5vZGVpZnkgPSByZXF1aXJlKCcuLi9ub2RlaWZ5JylcbmNvbnN0IEJOID0gcmVxdWlyZSgnYXNuMS5qcycpLmJpZ251bVxuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG5jb25zdCB0b0Jhc2U2NCA9IHV0aWwudG9CYXNlNjRcbmNvbnN0IHRvQm4gPSB1dGlsLnRvQm5cblxuY29uc3QgYml0cyA9IHtcbiAgJ1AtMjU2JzogMjU2LFxuICAnUC0zODQnOiAzODQsXG4gICdQLTUyMSc6IDUyMVxufVxuXG5leHBvcnRzLmdlbmVyYXRlRXBobWVyYWxLZXlQYWlyID0gZnVuY3Rpb24gKGN1cnZlLCBjYWxsYmFjaykge1xuICBub2RlaWZ5KHdlYmNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoXG4gICAge1xuICAgICAgbmFtZTogJ0VDREgnLFxuICAgICAgbmFtZWRDdXJ2ZTogY3VydmVcbiAgICB9LFxuICAgIHRydWUsXG4gICAgWydkZXJpdmVCaXRzJ11cbiAgKS50aGVuKChwYWlyKSA9PiB7XG4gICAgLy8gZm9yY2VQcml2YXRlIGlzIHVzZWQgZm9yIHRlc3Rpbmcgb25seVxuICAgIGNvbnN0IGdlblNoYXJlZEtleSA9ICh0aGVpclB1YiwgZm9yY2VQcml2YXRlLCBjYikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBmb3JjZVByaXZhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2IgPSBmb3JjZVByaXZhdGVcbiAgICAgICAgZm9yY2VQcml2YXRlID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGxldCBwcml2YXRlS2V5XG5cbiAgICAgIGlmIChmb3JjZVByaXZhdGUpIHtcbiAgICAgICAgcHJpdmF0ZUtleSA9IHdlYmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICAgICAgICdqd2snLFxuICAgICAgICAgIHVubWFyc2hhbFByaXZhdGVLZXkoY3VydmUsIGZvcmNlUHJpdmF0ZSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0VDREgnLFxuICAgICAgICAgICAgbmFtZWRDdXJ2ZTogY3VydmVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFsnZGVyaXZlQml0cyddXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByaXZhdGVLZXkgPSBQcm9taXNlLnJlc29sdmUocGFpci5wcml2YXRlS2V5KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXlzID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICB3ZWJjcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAgICAgICAnandrJyxcbiAgICAgICAgICB1bm1hcnNoYWxQdWJsaWNLZXkoY3VydmUsIHRoZWlyUHViKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnRUNESCcsXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiBjdXJ2ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgW11cbiAgICAgICAgKSxcbiAgICAgICAgcHJpdmF0ZUtleVxuICAgICAgXSlcblxuICAgICAgbm9kZWlmeShrZXlzLnRoZW4oKGtleXMpID0+IHdlYmNyeXB0by5zdWJ0bGUuZGVyaXZlQml0cyhcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdFQ0RIJyxcbiAgICAgICAgICBuYW1lZEN1cnZlOiBjdXJ2ZSxcbiAgICAgICAgICBwdWJsaWM6IGtleXNbMF1cbiAgICAgICAgfSxcbiAgICAgICAga2V5c1sxXSxcbiAgICAgICAgYml0c1tjdXJ2ZV1cbiAgICAgICkpLnRoZW4oKGJpdHMpID0+IEJ1ZmZlci5mcm9tKGJpdHMpKSwgY2IpXG4gICAgfVxuXG4gICAgcmV0dXJuIHdlYmNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdqd2snLCBwYWlyLnB1YmxpY0tleSlcbiAgICAgIC50aGVuKChwdWJsaWNLZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXk6IG1hcnNoYWxQdWJsaWNLZXkocHVibGljS2V5KSxcbiAgICAgICAgICBnZW5TaGFyZWRLZXlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfSksIGNhbGxiYWNrKVxufVxuXG5jb25zdCBjdXJ2ZUxlbmd0aHMgPSB7XG4gICdQLTI1Nic6IDMyLFxuICAnUC0zODQnOiA0OCxcbiAgJ1AtNTIxJzogNjZcbn1cblxuLy8gTWFyc2hhbCBjb252ZXJ0cyBhIGp3ayBlbmNvZGVjIEVDREggcHVibGljIGtleSBpbnRvIHRoZVxuLy8gZm9ybSBzcGVjaWZpZWQgaW4gc2VjdGlvbiA0LjMuNiBvZiBBTlNJIFg5LjYyLiAoVGhpcyBpcyB0aGUgZm9ybWF0XG4vLyBnby1pcGZzIHVzZXMpXG5mdW5jdGlvbiBtYXJzaGFsUHVibGljS2V5IChqd2spIHtcbiAgY29uc3QgYnl0ZUxlbiA9IGN1cnZlTGVuZ3Roc1tqd2suY3J2XVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtcbiAgICBCdWZmZXIuZnJvbShbNF0pLCAvLyB1bmNvbXByZXNzZWQgcG9pbnRcbiAgICB0b0JuKGp3ay54KS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIGJ5dGVMZW4pLFxuICAgIHRvQm4oandrLnkpLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgYnl0ZUxlbilcbiAgXSwgMSArIGJ5dGVMZW4gKiAyKVxufVxuXG4vLyBVbm1hcnNoYWwgY29udmVydHMgYSBwb2ludCwgc2VyaWFsaXplZCBieSBNYXJzaGFsLCBpbnRvIGFuIGp3ayBlbmNvZGVkIGtleVxuZnVuY3Rpb24gdW5tYXJzaGFsUHVibGljS2V5IChjdXJ2ZSwga2V5KSB7XG4gIGNvbnN0IGJ5dGVMZW4gPSBjdXJ2ZUxlbmd0aHNbY3VydmVdXG5cbiAgaWYgKCFrZXkuc2xpY2UoMCwgMSkuZXF1YWxzKEJ1ZmZlci5mcm9tKFs0XSkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBmb3JtYXQnKVxuICB9XG4gIGNvbnN0IHggPSBuZXcgQk4oa2V5LnNsaWNlKDEsIGJ5dGVMZW4gKyAxKSlcbiAgY29uc3QgeSA9IG5ldyBCTihrZXkuc2xpY2UoMSArIGJ5dGVMZW4pKVxuXG4gIHJldHVybiB7XG4gICAga3R5OiAnRUMnLFxuICAgIGNydjogY3VydmUsXG4gICAgeDogdG9CYXNlNjQoeCwgYnl0ZUxlbiksXG4gICAgeTogdG9CYXNlNjQoeSwgYnl0ZUxlbiksXG4gICAgZXh0OiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gdW5tYXJzaGFsUHJpdmF0ZUtleSAoY3VydmUsIGtleSkge1xuICBjb25zdCByZXN1bHQgPSB1bm1hcnNoYWxQdWJsaWNLZXkoY3VydmUsIGtleS5wdWJsaWMpXG4gIHJlc3VsdC5kID0gdG9CYXNlNjQobmV3IEJOKGtleS5wcml2YXRlKSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG11bHRpaGFzaCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJy4vY3J5cHRvJylcblxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aWhhc2hpbmdcblxuLyoqXG4gKiBIYXNoIHRoZSBnaXZlbiBgYnVmYCB1c2luZyB0aGUgYWxnb3JpdGhtIHNwZWNpZmllZFxuICogYnkgYGZ1bmNgLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgLSBUaGUgdmFsdWUgdG8gaGFzaC5cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gZnVuYyAtIFRoZSBhbGdvcml0aG0gdG8gdXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIC0gT3B0aW9uYWxseSB0cmltIHRoZSByZXN1bHQgdG8gdGhpcyBsZW5ndGguXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCdWZmZXIpfSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gTXVsdGloYXNoaW5nIChidWYsIGZ1bmMsIGxlbmd0aCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBjYWxsYmFjaycpXG4gIH1cblxuICBNdWx0aWhhc2hpbmcuZGlnZXN0KGJ1ZiwgZnVuYywgbGVuZ3RoLCAoZXJyLCBkaWdlc3QpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIG11bHRpaGFzaC5lbmNvZGUoZGlnZXN0LCBmdW5jLCBsZW5ndGgpKVxuICB9KVxufVxuXG4vKipcbiAqIFRoZSBgYnVmZmVyYCBtb2R1bGUgZm9yIGVhc3kgdXNlIGluIHRoZSBicm93c2VyLlxuICpcbiAqIEB0eXBlIHtCdWZmZXJ9XG4gKi9cbk11bHRpaGFzaGluZy5CdWZmZXIgPSBCdWZmZXIgLy8gZm9yIGJyb3dzZXIgdGhpbmdzXG5cbi8qKlxuICogRXhwb3NlIG11bHRpaGFzaCBpdHNlbGYsIHRvIGF2b2lkIHNpbGx5IGRvdWJsZSByZXF1aXJlcy5cbiAqL1xuTXVsdGloYXNoaW5nLm11bHRpaGFzaCA9IG11bHRpaGFzaFxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgLSBUaGUgdmFsdWUgdG8gaGFzaC5cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gZnVuYyAtIFRoZSBhbGdvcml0aG0gdG8gdXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIC0gT3B0aW9uYWxseSB0cmltIHRoZSByZXN1bHQgdG8gdGhpcyBsZW5ndGguXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCdWZmZXIpfSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuTXVsdGloYXNoaW5nLmRpZ2VzdCA9IGZ1bmN0aW9uIChidWYsIGZ1bmMsIGxlbmd0aCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBjYWxsYmFjaycpXG4gIH1cblxuICBsZXQgY2IgPSBjYWxsYmFja1xuICBpZiAobGVuZ3RoKSB7XG4gICAgY2IgPSAoZXJyLCBkaWdlc3QpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGlnZXN0LnNsaWNlKDAsIGxlbmd0aCkpXG4gICAgfVxuICB9XG5cbiAgbGV0IGhhc2hcbiAgdHJ5IHtcbiAgICBoYXNoID0gTXVsdGloYXNoaW5nLmNyZWF0ZUhhc2goZnVuYylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGNiKGVycilcbiAgfVxuXG4gIGhhc2goYnVmLCBjYilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGZ1bmNcbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IC0gVGhlIHRvIGBmdW5jYCBjb3JyZXNwb25kaW5nIGhhc2ggZnVuY3Rpb24uXG4gKi9cbk11bHRpaGFzaGluZy5jcmVhdGVIYXNoID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgZnVuYyA9IG11bHRpaGFzaC5jb2VyY2VDb2RlKGZ1bmMpXG4gIGlmICghTXVsdGloYXNoaW5nLmZ1bmN0aW9uc1tmdW5jXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIGZ1bmN0aW9uICcgKyBmdW5jICsgJyBub3QgeWV0IHN1cHBvcnRlZCcpXG4gIH1cblxuICByZXR1cm4gTXVsdGloYXNoaW5nLmZ1bmN0aW9uc1tmdW5jXVxufVxuXG4vKipcbiAqIE1hcHBpbmcgb2YgbXVsdGloYXNoIGNvZGVzIHRvIHRoZWlyIGhhc2hpbmcgZnVuY3Rpb25zLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuTXVsdGloYXNoaW5nLmZ1bmN0aW9ucyA9IHtcbiAgLy8gc2hhMVxuICAweDExOiBjcnlwdG8uc2hhMSxcbiAgLy8gc2hhMi0yNTZcbiAgMHgxMjogY3J5cHRvLnNoYTIyNTYsXG4gIC8vIHNoYTItNTEyXG4gIDB4MTM6IGNyeXB0by5zaGEyNTEyLFxuICAvLyBzaGEzLTUxMlxuICAweDE0OiBjcnlwdG8uc2hhMzUxMixcbiAgLy8gc2hhMy0zODRcbiAgMHgxNTogY3J5cHRvLnNoYTMzODQsXG4gIC8vIHNoYTMtMjU2XG4gIDB4MTY6IGNyeXB0by5zaGEzMjU2LFxuICAvLyBzaGEzLTIyNFxuICAweDE3OiBjcnlwdG8uc2hhMzIyNCxcbiAgLy8gc2hha2UtMTI4XG4gIDB4MTg6IGNyeXB0by5zaGFrZTEyOCxcbiAgLy8gc2hha2UtMjU2XG4gIDB4MTk6IGNyeXB0by5zaGFrZTI1NixcbiAgLy8ga2VjY2FrLTIyNFxuICAweDFBOiBjcnlwdG8ua2VjY2FrMjI0LFxuICAvLyBrZWNjYWstMjU2XG4gIDB4MUI6IGNyeXB0by5rZWNjYWsyNTYsXG4gIC8vIGtlY2Nhay0zODRcbiAgMHgxQzogY3J5cHRvLmtlY2NhazM4NCxcbiAgLy8ga2VjY2FrLTUxMlxuICAweDFEOiBjcnlwdG8ua2VjY2FrNTEyLFxuICAvLyBtdXJtdXIzLTEyOFxuICAweDIyOiBjcnlwdG8ubXVybXVyMzEyOCxcbiAgLy8gbXVybXVyMy0zMlxuICAweDIzOiBjcnlwdG8ubXVybXVyMzMyLFxuICAvLyBkYmwtc2hhMi0yNTZcbiAgMHg1NjogY3J5cHRvLmRibFNoYTIyNTZcbn1cblxuLy8gYWRkIGJsYWtlIGZ1bmN0aW9uc1xuY3J5cHRvLmFkZEJsYWtlKE11bHRpaGFzaGluZy5mdW5jdGlvbnMpXG5cbk11bHRpaGFzaGluZy52YWxpZGF0ZSA9IChkYXRhLCBoYXNoLCBjYWxsYmFjaykgPT4ge1xuICBsZXQgYWxnbyA9IG11bHRpaGFzaC5kZWNvZGUoaGFzaCkubmFtZVxuICBNdWx0aWhhc2hpbmcoZGF0YSwgYWxnbywgKGVyciwgbmV3SGFzaCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgY2FsbGJhY2soZXJyLCBCdWZmZXIuY29tcGFyZShoYXNoLCBuZXdIYXNoKSA9PT0gMClcbiAgfSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzZWNwMjU2azEgPSByZXF1aXJlKCdzZWNwMjU2azEnKVxuY29uc3QgbXVsdGloYXNoaW5nID0gcmVxdWlyZSgnbXVsdGloYXNoaW5nLWFzeW5jJylcbmNvbnN0IHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ2FzeW5jL3NldEltbWVkaWF0ZScpXG5cbmNvbnN0IEhBU0hfQUxHT1JJVEhNID0gJ3NoYTItMjU2J1xuXG5tb2R1bGUuZXhwb3J0cyA9IChyYW5kb21CeXRlcykgPT4ge1xuICBjb25zdCBwcml2YXRlS2V5TGVuZ3RoID0gMzJcblxuICBmdW5jdGlvbiBnZW5lcmF0ZUtleSAoY2FsbGJhY2spIHtcbiAgICBjb25zdCBkb25lID0gKGVyciwgcmVzKSA9PiBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2soZXJyLCByZXMpKVxuXG4gICAgbGV0IHByaXZhdGVLZXlcbiAgICBkbyB7XG4gICAgICBwcml2YXRlS2V5ID0gcmFuZG9tQnl0ZXMoMzIpXG4gICAgfSB3aGlsZSAoIXNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpKVxuXG4gICAgZG9uZShudWxsLCBwcml2YXRlS2V5KVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzaEFuZFNpZ24gKGtleSwgbXNnLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRvbmUgPSAoZXJyLCByZXMpID0+IHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhlcnIsIHJlcykpXG5cbiAgICBtdWx0aWhhc2hpbmcuZGlnZXN0KG1zZywgSEFTSF9BTEdPUklUSE0sIChlcnIsIGRpZ2VzdCkgPT4ge1xuICAgICAgaWYgKGVycikgeyByZXR1cm4gZG9uZShlcnIpIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2lnID0gc2VjcDI1NmsxLnNpZ24oZGlnZXN0LCBrZXkpXG4gICAgICAgIGNvbnN0IHNpZ0RFUiA9IHNlY3AyNTZrMS5zaWduYXR1cmVFeHBvcnQoc2lnLnNpZ25hdHVyZSlcbiAgICAgICAgcmV0dXJuIGRvbmUobnVsbCwgc2lnREVSKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7IGRvbmUoZXJyKSB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc2hBbmRWZXJpZnkgKGtleSwgc2lnLCBtc2csIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZG9uZSA9IChlcnIsIHJlcykgPT4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVyciwgcmVzKSlcblxuICAgIG11bHRpaGFzaGluZy5kaWdlc3QobXNnLCBIQVNIX0FMR09SSVRITSwgKGVyciwgZGlnZXN0KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7IHJldHVybiBkb25lKGVycikgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2lnID0gc2VjcDI1NmsxLnNpZ25hdHVyZUltcG9ydChzaWcpXG4gICAgICAgIGNvbnN0IHZhbGlkID0gc2VjcDI1NmsxLnZlcmlmeShkaWdlc3QsIHNpZywga2V5KVxuICAgICAgICByZXR1cm4gZG9uZShudWxsLCB2YWxpZClcbiAgICAgIH0gY2F0Y2ggKGVycikgeyBkb25lKGVycikgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb21wcmVzc1B1YmxpY0tleSAoa2V5KSB7XG4gICAgaWYgKCFzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwdWJsaWMga2V5JylcbiAgICB9XG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KGtleSwgdHJ1ZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29tcHJlc3NQdWJsaWNLZXkgKGtleSkge1xuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChrZXksIGZhbHNlKVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVQcml2YXRlS2V5IChrZXkpIHtcbiAgICBpZiAoIXNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcml2YXRlIGtleScpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVQdWJsaWNLZXkgKGtleSkge1xuICAgIGlmICghc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHVibGljIGtleScpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZVB1YmxpY0tleSAocHJpdmF0ZUtleSkge1xuICAgIHZhbGlkYXRlUHJpdmF0ZUtleShwcml2YXRlS2V5KVxuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXkpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdlbmVyYXRlS2V5OiBnZW5lcmF0ZUtleSxcbiAgICBwcml2YXRlS2V5TGVuZ3RoOiBwcml2YXRlS2V5TGVuZ3RoLFxuICAgIGhhc2hBbmRTaWduOiBoYXNoQW5kU2lnbixcbiAgICBoYXNoQW5kVmVyaWZ5OiBoYXNoQW5kVmVyaWZ5LFxuICAgIGNvbXByZXNzUHVibGljS2V5OiBjb21wcmVzc1B1YmxpY0tleSxcbiAgICBkZWNvbXByZXNzUHVibGljS2V5OiBkZWNvbXByZXNzUHVibGljS2V5LFxuICAgIHZhbGlkYXRlUHJpdmF0ZUtleTogdmFsaWRhdGVQcml2YXRlS2V5LFxuICAgIHZhbGlkYXRlUHVibGljS2V5OiB2YWxpZGF0ZVB1YmxpY0tleSxcbiAgICBjb21wdXRlUHVibGljS2V5OiBjb21wdXRlUHVibGljS2V5XG4gIH1cbn1cbiIsInZhciBOb2RlID0gcmVxdWlyZSgnLi9saWIvbm9kZScpXG5cbm1vZHVsZS5leHBvcnRzID0gaXNDaXJjdWxhclxuXG4vKipcbiAqIGNoZWNrcyB3aGV0aGVyIHRoZSBvYmplY3QgaXMgY2lyY3VsYXJcbiAqIEBwYXJhbSAge29iamVjdH0gIG9iaiAtIG9iamVjdCB0byBjaGVjayBjaXJjdWxhcml0eSBmb3JcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqIGlzIGNpcmN1bGFyLCBmYWxzZSBpZiBpdCBpcyBub3RcbiAqL1xuZnVuY3Rpb24gaXNDaXJjdWxhciAob2JqKSB7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9ialwiIG11c3QgYmUgYW4gb2JqZWN0IChvciBpbmhlcml0IGZyb20gaXQpJylcbiAgfVxuICByZXR1cm4gX2lzQ2lyY3VsYXIob2JqKVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjaGVja3Mgd2hldGhlciB0aGUgb2JqZWN0IGlzIGNpcmN1bGFyXG4gKiBAcGFyYW0gIHtvYmplY3R9ICBvYmogLSBvYmplY3QgdG8gY2hlY2sgY2lyY3VsYXJpdHkgZm9yXG4gKiBAcGFyYW0gIHtOb2RlfSAgICBwYXJlbnRMaXN0IC0gbGlua2VkLWxpc3QgdGhhdCBjb250YWlucyBhbGwgdGhlIG9iamVjdCdzIHBhcmVudHNcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqIGlzIGNpcmN1bGFyLCBmYWxzZSBpZiBpdCBpcyBub3RcbiAqL1xuZnVuY3Rpb24gX2lzQ2lyY3VsYXIgKG9iaiwgcGFyZW50TGlzdCkge1xuICBwYXJlbnRMaXN0ID0gbmV3IE5vZGUob2JqLCBwYXJlbnRMaXN0KVxuXG4gIC8vIGJyZWFkdGgtZmlyc3Qgc2VhcmNoIGZvciBjaXJjdWxhciBvYmplY3RcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHZhciB2YWwgPSBvYmpba2V5XVxuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIGlmIChwYXJlbnRMaXN0LmNvbnRhaW5zKHZhbCkgfHwgX2lzQ2lyY3VsYXIodmFsLCBwYXJlbnRMaXN0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYC8vIEFuIElQRlMgTWVya2xlREFHIExpbmtcbm1lc3NhZ2UgUEJMaW5rIHtcblxuICAvLyBtdWx0aWhhc2ggb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9uYWwgYnl0ZXMgSGFzaCA9IDE7XG5cbiAgLy8gdXRmIHN0cmluZyBuYW1lLiBzaG91bGQgYmUgdW5pcXVlIHBlciBvYmplY3RcbiAgb3B0aW9uYWwgc3RyaW5nIE5hbWUgPSAyO1xuXG4gIC8vIGN1bXVsYXRpdmUgc2l6ZSBvZiB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbmFsIHVpbnQ2NCBUc2l6ZSA9IDM7XG59XG5cbi8vIEFuIElQRlMgTWVya2xlREFHIE5vZGVcbm1lc3NhZ2UgUEJOb2RlIHtcblxuICAvLyByZWZzIHRvIG90aGVyIG9iamVjdHNcbiAgcmVwZWF0ZWQgUEJMaW5rIExpbmtzID0gMjtcblxuICAvLyBvcGFxdWUgdXNlciBkYXRhXG4gIG9wdGlvbmFsIGJ5dGVzIERhdGEgPSAxO1xufWBcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1ha2UgY2VydGFpbiBnZXR0ZXJzIGVudW1uZXJhYmxlXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBhZGQgYWRkaXRpb25hbCBnZXR0ZXJzIHRoYXQgYXJlIGVudW1lcmFibGUgYW5kIGhlbmNlXG4gKiBzaG93IHVwIG9uIGFuIGBPYmplY3Qua2V5cygpYCBjYWxsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IGl0IHNob3VsZCBiZSBhcHBsaWVkIHRvXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBmaWVsZHMgLSBUaGUgZmllbGRzIHRoYXQgc2hvdWxkIGJlIG1hZGUgZW51bW5lcmFibGVcbiAqL1xuY29uc3QgYWRkRW51bWVyYWJsZUdldHRlcnMgPSAob2JqZWN0LCBmaWVsZHMpID0+IHtcbiAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICBsZXQgcHJvcFxuICAgIGxldCBwcm90byA9IG9iamVjdFxuICAgIC8vIFdhbGsgdXAgdGhlIHByb290dHlwZSBjaGFpbiB1bnRpbCBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG5hbWUgaXNcbiAgICAvLyBmb3VuZFxuICAgIHdoaWxlIChwcm9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKVxuICAgICAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gZ2V0dGVyIG5hbWVkICcke2ZpZWxkfScgZm91bmRgKVxuICAgICAgfVxuICAgICAgcHJvcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGZpZWxkKVxuICAgIH1cblxuICAgIC8vIFRoZXJlIGlzIGEgcHJvcGVydHkgd2l0aCB0aGUgY29ycmVjdCBuYW1lLCBidXQgaXQncyBub3QgYSBnZXR0ZXJcbiAgICBpZiAocHJvcC5nZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBnZXR0ZXIgbmFtZWQgJyR7ZmllbGR9JyBmb3VuZGApXG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGZpZWxkLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBwcm9wLmdldFxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBNYWtlcyBhbGwgcHJvcGVydGllcyB3aXRoIGEgbGVhZGluZyB1bmRlcnNjb3JlIG5vbi1lbnVtZXJhYmxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IGl0IHNob3VsZCBiZSBhcHBsaWVkIHRvXG4gKi9cbmNvbnN0IGhpZGVQcml2YXRlRmllbGRzID0gKG9iamVjdCkgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoa2V5WzBdID09PSAnXycpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwgeyBlbnVtZXJhYmxlOiBmYWxzZSB9KVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkRW51bWVyYWJsZUdldHRlcnMsXG4gIGhpZGVQcml2YXRlRmllbGRzXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgREFHTGluayA9IHJlcXVpcmUoJy4vaW5kZXgnKVxuXG5mdW5jdGlvbiBjcmVhdGVEYWdMaW5rRnJvbUI1OEVuY29kZWRIYXNoIChsaW5rKSB7XG4gIHJldHVybiBuZXcgREFHTGluayhcbiAgICBsaW5rLk5hbWUgfHwgbGluay5uYW1lIHx8ICcnLFxuICAgIGxpbmsuVHNpemUgfHwgbGluay5TaXplIHx8IGxpbmsuc2l6ZSB8fCAwLFxuICAgIGxpbmsuSGFzaCB8fCBsaW5rLmhhc2ggfHwgbGluay5tdWx0aWhhc2ggfHwgbGluay5jaWRcbiAgKVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHNcbmV4cG9ydHMuY3JlYXRlRGFnTGlua0Zyb21CNThFbmNvZGVkSGFzaCA9IGNyZWF0ZURhZ0xpbmtGcm9tQjU4RW5jb2RlZEhhc2hcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEFkZHMgYSBsaW5rIHdpdGggaXRzIG5hbWUgYXMgcHJvcGVydHkgdG8gYW4gb2JqZWN0LlxuICpcbiAqIFRoZSBsaW5rIHdvbid0IGJlIGFkZGVkIGlmIGl0cyBuYW1lIGlzIGVtcHR5IG9yIG1hdGNoZXMgb25lIG9mIHRoZSBleGlzdGluZ1xuICogcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGxpbmtzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBsaW5rIHRvIGFkZFxuICogQHBhcmFtIHtudW1uZXJ9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXJyYXkgb2YgbGlua3NcbiAqL1xuY29uc3QgYWRkTmFtZWRMaW5rID0gKG9iamVjdCwgbmFtZSwgcG9zaXRpb24pID0+IHtcbiAgY29uc3Qgc2tpcE5hbWVzID0gWycnLCAuLi5PYmplY3Qua2V5cyhvYmplY3QpXVxuICBpZiAoc2tpcE5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogKCkgPT4gb2JqZWN0Ll9saW5rc1twb3NpdGlvbl0uSGFzaFxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZE5hbWVkTGlua1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRhZ05vZGVVdGlsID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IGNsb25lTGlua3MgPSBkYWdOb2RlVXRpbC5jbG9uZUxpbmtzXG5jb25zdCBjbG9uZURhdGEgPSBkYWdOb2RlVXRpbC5jbG9uZURhdGFcbmNvbnN0IGNyZWF0ZSA9IHJlcXVpcmUoJy4vY3JlYXRlJylcblxuZnVuY3Rpb24gY2xvbmUgKGRhZ05vZGUpIHtcbiAgY29uc3QgZGF0YSA9IGNsb25lRGF0YShkYWdOb2RlKVxuICBjb25zdCBsaW5rcyA9IGNsb25lTGlua3MoZGFnTm9kZSlcbiAgcmV0dXJuIGNyZWF0ZShkYXRhLCBsaW5rcylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRhZ05vZGVVdGlsID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IGNsb25lTGlua3MgPSBkYWdOb2RlVXRpbC5jbG9uZUxpbmtzXG5jb25zdCBjbG9uZURhdGEgPSBkYWdOb2RlVXRpbC5jbG9uZURhdGFcbmNvbnN0IHRvREFHTGluayA9IGRhZ05vZGVVdGlsLnRvREFHTGlua1xuY29uc3QgREFHTGluayA9IHJlcXVpcmUoJy4uL2RhZy1saW5rJylcbmNvbnN0IERBR05vZGUgPSByZXF1aXJlKCcuL2luZGV4JylcbmNvbnN0IGNyZWF0ZSA9IHJlcXVpcmUoJy4vY3JlYXRlJylcblxuY29uc3QgYXNEQUdMaW5rID0gYXN5bmMgKGxpbmspID0+IHtcbiAgaWYgKERBR0xpbmsuaXNEQUdMaW5rKGxpbmspKSB7XG4gICAgLy8gSXQncyBhIERBR0xpbmsgaW5zdGFuY2VcbiAgICAvLyBubyBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgcmV0dXJuIGxpbmtcbiAgfVxuXG4gIGlmIChEQUdOb2RlLmlzREFHTm9kZShsaW5rKSkge1xuICAgIC8vIEl0J3MgYSBEQUdOb2RlIGluc3RhbmNlXG4gICAgLy8gY29udmVydCB0byBsaW5rXG4gICAgcmV0dXJuIHRvREFHTGluayhsaW5rLCB7fSlcbiAgfVxuXG4gIC8vIEl0J3MgYSBPYmplY3Qgd2l0aCBuYW1lLCBtdWx0aWhhc2gvaGFzaC9jaWQgYW5kIHNpemVcbiAgcmV0dXJuIG5ldyBEQUdMaW5rKGxpbmsuTmFtZSB8fCBsaW5rLm5hbWUsIGxpbmsuVHNpemUgfHwgbGluay5zaXplLCBsaW5rLkhhc2ggfHwgbGluay5tdWx0aWhhc2ggfHwgbGluay5oYXNoIHx8IGxpbmsuY2lkKVxufVxuXG5jb25zdCBhZGRMaW5rID0gYXN5bmMgKG5vZGUsIGxpbmspID0+IHtcbiAgY29uc3QgbGlua3MgPSBjbG9uZUxpbmtzKG5vZGUpXG4gIGNvbnN0IGRhdGEgPSBjbG9uZURhdGEobm9kZSlcblxuICBjb25zdCBkYWdMaW5rID0gYXdhaXQgYXNEQUdMaW5rKGxpbmspXG4gIGxpbmtzLnB1c2goZGFnTGluaylcbiAgcmV0dXJuIGNyZWF0ZShkYXRhLCBsaW5rcylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGRMaW5rXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZGFnTm9kZVV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgY2xvbmVMaW5rcyA9IGRhZ05vZGVVdGlsLmNsb25lTGlua3NcbmNvbnN0IGNsb25lRGF0YSA9IGRhZ05vZGVVdGlsLmNsb25lRGF0YVxuY29uc3QgY3JlYXRlID0gcmVxdWlyZSgnLi9jcmVhdGUnKVxuY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpXG5cbmNvbnN0IHJtTGluayA9IChkYWdOb2RlLCBuYW1lT3JDaWQpID0+IHtcbiAgY29uc3QgZGF0YSA9IGNsb25lRGF0YShkYWdOb2RlKVxuICBsZXQgbGlua3MgPSBjbG9uZUxpbmtzKGRhZ05vZGUpXG5cbiAgaWYgKHR5cGVvZiBuYW1lT3JDaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbGlua3MgPSBsaW5rcy5maWx0ZXIoKGxpbmspID0+IGxpbmsuTmFtZSAhPT0gbmFtZU9yQ2lkKVxuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihuYW1lT3JDaWQpIHx8IENJRC5pc0NJRChuYW1lT3JDaWQpKSB7XG4gICAgbGlua3MgPSBsaW5rcy5maWx0ZXIoKGxpbmspID0+ICFsaW5rLkhhc2guZXF1YWxzKG5hbWVPckNpZCkpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJnIG5lZWRzIHRvIGJlIGEgbmFtZSBvciBDSUQnKVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZShkYXRhLCBsaW5rcylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBybUxpbmtcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzb3J0ID0gcmVxdWlyZSgnc3RhYmxlJylcbmNvbnN0IHtcbiAgc2VyaWFsaXplXG59ID0gcmVxdWlyZSgnLi4vdXRpbC5qcycpXG5jb25zdCBkYWdOb2RlVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC5qcycpXG5jb25zdCBsaW5rU29ydCA9IGRhZ05vZGVVdGlsLmxpbmtTb3J0XG5jb25zdCBEQUdOb2RlID0gcmVxdWlyZSgnLi9pbmRleC5qcycpXG5jb25zdCBEQUdMaW5rID0gcmVxdWlyZSgnLi4vZGFnLWxpbmsnKVxuXG5jb25zdCBjcmVhdGUgPSAoZGF0YSwgbGlua3MgPSBbXSkgPT4ge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFzc2VkIFxcJ2RhdGFcXCcgaXMgbm90IGEgYnVmZmVyIG9yIGEgc3RyaW5nIScpXG4gIH1cbiAgbGlua3MgPSBsaW5rcy5tYXAoKGxpbmspID0+IHtcbiAgICByZXR1cm4gREFHTGluay5pc0RBR0xpbmsobGluaykgPyBsaW5rIDogREFHTGluay51dGlsLmNyZWF0ZURhZ0xpbmtGcm9tQjU4RW5jb2RlZEhhc2gobGluaylcbiAgfSlcbiAgbGlua3MgPSBzb3J0KGxpbmtzLCBsaW5rU29ydClcblxuICBjb25zdCBzZXJpYWxpemVkID0gc2VyaWFsaXplKHtcbiAgICBEYXRhOiBkYXRhLFxuICAgIExpbmtzOiBsaW5rc1xuICB9KVxuXG4gIHJldHVybiBuZXcgREFHTm9kZShkYXRhLCBsaW5rcywgc2VyaWFsaXplZC5sZW5ndGgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBzaGEzID0gcmVxdWlyZSgnanMtc2hhMycpXG5jb25zdCBtdXIgPSByZXF1aXJlKCdtdXJtdXJoYXNoM2pzLXJldmlzaXRlZCcpXG5jb25zdCBzaGEgPSByZXF1aXJlKCcuL3NoYScpXG5jb25zdCB7IGZyb21OdW1iZXJUbzMyQml0QnVmIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcblxuLy8gTm90ZSB0aGF0IGFsdGhvdWdoIHRoaXMgZnVuY3Rpb24gZG9lc24ndCBkbyBhbnkgYXN5bmNocm9ub3VzIHdvcmssIHdlIG1hcmtcbi8vIHRoZSBmdW5jdGlvbiBhcyBhc3luYyBiZWNhdXNlIGl0IG11c3QgcmV0dXJuIGEgUHJvbWlzZSB0byBtYXRjaCB0aGUgQVBJXG4vLyBmb3Igb3RoZXIgZnVuY3Rpb25zIHRoYXQgZG8gcGVyZm9ybSBhc3luY2hyb25vdXMgd29yayAoc2VlIHNoYS5icm93c2VyLmpzKVxuY29uc3QgaGFzaCA9IChhbGdvcml0aG0pID0+IGFzeW5jIChkYXRhKSA9PiB7XG4gIHN3aXRjaCAoYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnc2hhMy0yMjQnOlxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNoYTMuc2hhM18yMjQuYXJyYXlCdWZmZXIoZGF0YSkpXG4gICAgY2FzZSAnc2hhMy0yNTYnOlxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNoYTMuc2hhM18yNTYuYXJyYXlCdWZmZXIoZGF0YSkpXG4gICAgY2FzZSAnc2hhMy0zODQnOlxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNoYTMuc2hhM18zODQuYXJyYXlCdWZmZXIoZGF0YSkpXG4gICAgY2FzZSAnc2hhMy01MTInOlxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNoYTMuc2hhM181MTIuYXJyYXlCdWZmZXIoZGF0YSkpXG4gICAgY2FzZSAnc2hha2UtMTI4JzpcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzaGEzLnNoYWtlMTI4LmNyZWF0ZSgxMjgpLnVwZGF0ZShkYXRhKS5hcnJheUJ1ZmZlcigpKVxuICAgIGNhc2UgJ3NoYWtlLTI1Nic6XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oc2hhMy5zaGFrZTI1Ni5jcmVhdGUoMjU2KS51cGRhdGUoZGF0YSkuYXJyYXlCdWZmZXIoKSlcbiAgICBjYXNlICdrZWNjYWstMjI0JzpcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzaGEzLmtlY2NhazIyNC5hcnJheUJ1ZmZlcihkYXRhKSlcbiAgICBjYXNlICdrZWNjYWstMjU2JzpcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzaGEzLmtlY2NhazI1Ni5hcnJheUJ1ZmZlcihkYXRhKSlcbiAgICBjYXNlICdrZWNjYWstMzg0JzpcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzaGEzLmtlY2NhazM4NC5hcnJheUJ1ZmZlcihkYXRhKSlcbiAgICBjYXNlICdrZWNjYWstNTEyJzpcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzaGEzLmtlY2NhazUxMi5hcnJheUJ1ZmZlcihkYXRhKSlcbiAgICBjYXNlICdtdXJtdXIzLTEyOCc6XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20obXVyLng2NC5oYXNoMTI4KGRhdGEpLCAnaGV4JylcbiAgICBjYXNlICdtdXJtdXIzLTMyJzpcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyVG8zMkJpdEJ1ZihtdXIueDg2Lmhhc2gzMihkYXRhKSlcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2FsZ29yaXRobX0gaXMgbm90IGEgc3VwcG9ydGVkIGFsZ29yaXRobWApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNoYTE6IHNoYSgnc2hhMScpLFxuICBzaGEyMjU2OiBzaGEoJ3NoYTItMjU2JyksXG4gIHNoYTI1MTI6IHNoYSgnc2hhMi01MTInKSxcbiAgZGJsU2hhMjI1Njogc2hhKCdkYmwtc2hhMi0yNTYnKSxcbiAgc2hhMzIyNDogaGFzaCgnc2hhMy0yMjQnKSxcbiAgc2hhMzI1NjogaGFzaCgnc2hhMy0yNTYnKSxcbiAgc2hhMzM4NDogaGFzaCgnc2hhMy0zODQnKSxcbiAgc2hhMzUxMjogaGFzaCgnc2hhMy01MTInKSxcbiAgc2hha2UxMjg6IGhhc2goJ3NoYWtlLTEyOCcpLFxuICBzaGFrZTI1NjogaGFzaCgnc2hha2UtMjU2JyksXG4gIGtlY2NhazIyNDogaGFzaCgna2VjY2FrLTIyNCcpLFxuICBrZWNjYWsyNTY6IGhhc2goJ2tlY2Nhay0yNTYnKSxcbiAga2VjY2FrMzg0OiBoYXNoKCdrZWNjYWstMzg0JyksXG4gIGtlY2NhazUxMjogaGFzaCgna2VjY2FrLTUxMicpLFxuICBtdXJtdXIzMTI4OiBoYXNoKCdtdXJtdXIzLTEyOCcpLFxuICBtdXJtdXIzMzI6IGhhc2goJ211cm11cjMtMzInKSxcbiAgYWRkQmxha2U6IHJlcXVpcmUoJy4vYmxha2UnKVxufVxuIiwiLypcbiAqIFtoaS1iYXNlMzJde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lbW4xNzgvaGktYmFzZTMyfVxuICpcbiAqIEB2ZXJzaW9uIDAuNS4wXG4gKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxuICogQGNvcHlyaWdodCBDaGVuLCBZaS1DeXVhbiAyMDE1LTIwMThcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG4oZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHJvb3QgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyA/IHdpbmRvdyA6IHt9O1xuICB2YXIgTk9ERV9KUyA9ICFyb290LkhJX0JBU0UzMl9OT19OT0RFX0pTICYmIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcbiAgaWYgKE5PREVfSlMpIHtcbiAgICByb290ID0gZ2xvYmFsO1xuICB9XG4gIHZhciBDT01NT05fSlMgPSAhcm9vdC5ISV9CQVNFMzJfTk9fQ09NTU9OX0pTICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzO1xuICB2YXIgQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kO1xuICB2YXIgQkFTRTMyX0VOQ09ERV9DSEFSID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3Jy5zcGxpdCgnJyk7XG4gIHZhciBCQVNFMzJfREVDT0RFX0NIQVIgPSB7XG4gICAgJ0EnOiAwLCAnQic6IDEsICdDJzogMiwgJ0QnOiAzLCAnRSc6IDQsICdGJzogNSwgJ0cnOiA2LCAnSCc6IDcsICdJJzogOCxcbiAgICAnSic6IDksICdLJzogMTAsICdMJzogMTEsICdNJzogMTIsICdOJzogMTMsICdPJzogMTQsICdQJzogMTUsICdRJzogMTYsXG4gICAgJ1InOiAxNywgJ1MnOiAxOCwgJ1QnOiAxOSwgJ1UnOiAyMCwgJ1YnOiAyMSwgJ1cnOiAyMiwgJ1gnOiAyMywgJ1knOiAyNCxcbiAgICAnWic6IDI1LCAnMic6IDI2LCAnMyc6IDI3LCAnNCc6IDI4LCAnNSc6IDI5LCAnNic6IDMwLCAnNyc6IDMxXG4gIH07XG5cbiAgdmFyIGJsb2NrcyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcblxuICB2YXIgdGhyb3dJbnZhbGlkVXRmOCA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgcGFydGlhbCkge1xuICAgIGlmIChwYXJ0aWFsLmxlbmd0aCA+IDEwKSB7XG4gICAgICBwYXJ0aWFsID0gJy4uLicgKyBwYXJ0aWFsLnN1YnN0cigtMTApO1xuICAgIH1cbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdEZWNvZGVkIGRhdGEgaXMgbm90IHZhbGlkIFVURi04LidcbiAgICAgICsgJyBNYXliZSB0cnkgYmFzZTMyLmRlY29kZS5hc0J5dGVzKCk/J1xuICAgICAgKyAnIFBhcnRpYWwgZGF0YSBhZnRlciByZWFkaW5nICcgKyBwb3NpdGlvbiArICcgYnl0ZXM6ICcgKyBwYXJ0aWFsICsgJyA8LScpO1xuICAgIGVyci5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHRocm93IGVycjtcbiAgfTtcblxuICB2YXIgdG9VdGY4U3RyaW5nID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgdmFyIHN0ciA9ICcnLCBsZW5ndGggPSBieXRlcy5sZW5ndGgsIGkgPSAwLCBmb2xsb3dpbmdDaGFycyA9IDAsIGIsIGM7XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgIGIgPSBieXRlc1tpKytdO1xuICAgICAgaWYgKGIgPD0gMHg3Rikge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGIgPiAweEJGICYmIGIgPD0gMHhERikge1xuICAgICAgICBjID0gYiAmIDB4MUY7XG4gICAgICAgIGZvbGxvd2luZ0NoYXJzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoYiA8PSAweEVGKSB7XG4gICAgICAgIGMgPSBiICYgMHgwRjtcbiAgICAgICAgZm9sbG93aW5nQ2hhcnMgPSAyO1xuICAgICAgfSBlbHNlIGlmIChiIDw9IDB4RjcpIHtcbiAgICAgICAgYyA9IGIgJiAweDA3O1xuICAgICAgICBmb2xsb3dpbmdDaGFycyA9IDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0ludmFsaWRVdGY4KGksIHN0cik7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZm9sbG93aW5nQ2hhcnM7ICsraikge1xuICAgICAgICBiID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgaWYgKGIgPCAweDgwIHx8IGIgPiAweEJGKSB7XG4gICAgICAgICAgdGhyb3dJbnZhbGlkVXRmOChpLCBzdHIpO1xuICAgICAgICB9XG4gICAgICAgIGMgPDw9IDY7XG4gICAgICAgIGMgKz0gYiAmIDB4M0Y7XG4gICAgICB9XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERGRkYpIHtcbiAgICAgICAgdGhyb3dJbnZhbGlkVXRmOChpLCBzdHIpO1xuICAgICAgfVxuICAgICAgaWYgKGMgPiAweDEwRkZGRikge1xuICAgICAgICB0aHJvd0ludmFsaWRVdGY4KGksIHN0cik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjIDw9IDB4RkZGRikge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgPj4gMTApICsgMHhEODAwKTtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAweDNGRikgKyAweERDMDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHZhciBkZWNvZGVBc0J5dGVzID0gZnVuY3Rpb24gKGJhc2UzMlN0cikge1xuICAgIGlmICghL15bQS1aMi03PV0rJC8udGVzdChiYXNlMzJTdHIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmFzZTMyIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gICAgYmFzZTMyU3RyID0gYmFzZTMyU3RyLnJlcGxhY2UoLz0vZywgJycpO1xuICAgIHZhciB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIGJ5dGVzID0gW10sIGluZGV4ID0gMCwgbGVuZ3RoID0gYmFzZTMyU3RyLmxlbmd0aDtcblxuICAgIC8vIDQgY2hhciB0byAzIGJ5dGVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGNvdW50ID0gbGVuZ3RoID4+IDMgPDwgMzsgaSA8IGNvdW50Oykge1xuICAgICAgdjEgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHYyID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MyA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjQgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY1ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2NiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjcgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY4ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICBieXRlc1tpbmRleCsrXSA9ICh2MSA8PCAzIHwgdjIgPj4+IDIpICYgMjU1O1xuICAgICAgYnl0ZXNbaW5kZXgrK10gPSAodjIgPDwgNiB8IHYzIDw8IDEgfCB2NCA+Pj4gNCkgJiAyNTU7XG4gICAgICBieXRlc1tpbmRleCsrXSA9ICh2NCA8PCA0IHwgdjUgPj4+IDEpICYgMjU1O1xuICAgICAgYnl0ZXNbaW5kZXgrK10gPSAodjUgPDwgNyB8IHY2IDw8IDIgfCB2NyA+Pj4gMykgJiAyNTU7XG4gICAgICBieXRlc1tpbmRleCsrXSA9ICh2NyA8PCA1IHwgdjgpICYgMjU1O1xuICAgIH1cblxuICAgIC8vIHJlbWFpbiBieXRlc1xuICAgIHZhciByZW1haW4gPSBsZW5ndGggLSBjb3VudDtcbiAgICBpZiAocmVtYWluID09PSAyKSB7XG4gICAgICB2MSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjIgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIGJ5dGVzW2luZGV4KytdID0gKHYxIDw8IDMgfCB2MiA+Pj4gMikgJiAyNTU7XG4gICAgfSBlbHNlIGlmIChyZW1haW4gPT09IDQpIHtcbiAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICBieXRlc1tpbmRleCsrXSA9ICh2MSA8PCAzIHwgdjIgPj4+IDIpICYgMjU1O1xuICAgICAgYnl0ZXNbaW5kZXgrK10gPSAodjIgPDwgNiB8IHYzIDw8IDEgfCB2NCA+Pj4gNCkgJiAyNTU7XG4gICAgfSBlbHNlIGlmIChyZW1haW4gPT09IDUpIHtcbiAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2NSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgYnl0ZXNbaW5kZXgrK10gPSAodjEgPDwgMyB8IHYyID4+PiAyKSAmIDI1NTtcbiAgICAgIGJ5dGVzW2luZGV4KytdID0gKHYyIDw8IDYgfCB2MyA8PCAxIHwgdjQgPj4+IDQpICYgMjU1O1xuICAgICAgYnl0ZXNbaW5kZXgrK10gPSAodjQgPDwgNCB8IHY1ID4+PiAxKSAmIDI1NTtcbiAgICB9IGVsc2UgaWYgKHJlbWFpbiA9PT0gNykge1xuICAgICAgdjEgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHYyID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MyA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjQgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY1ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2NiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjcgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIGJ5dGVzW2luZGV4KytdID0gKHYxIDw8IDMgfCB2MiA+Pj4gMikgJiAyNTU7XG4gICAgICBieXRlc1tpbmRleCsrXSA9ICh2MiA8PCA2IHwgdjMgPDwgMSB8IHY0ID4+PiA0KSAmIDI1NTtcbiAgICAgIGJ5dGVzW2luZGV4KytdID0gKHY0IDw8IDQgfCB2NSA+Pj4gMSkgJiAyNTU7XG4gICAgICBieXRlc1tpbmRleCsrXSA9ICh2NSA8PCA3IHwgdjYgPDwgMiB8IHY3ID4+PiAzKSAmIDI1NTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xuXG4gIHZhciBlbmNvZGVBc2NpaSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgdjEsIHYyLCB2MywgdjQsIHY1LCBiYXNlMzJTdHIgPSAnJywgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgY291bnQgPSBwYXJzZUludChsZW5ndGggLyA1KSAqIDU7IGkgPCBjb3VudDspIHtcbiAgICAgIHYxID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHYyID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHYzID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHY0ID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHY1ID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MSA8PCAyIHwgdjIgPj4+IDYpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA+Pj4gMSkgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyIDw8IDQgfCB2MyA+Pj4gNCkgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYzIDw8IDEgfCB2NCA+Pj4gNykgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHY0ID4+PiAyKSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjQgPDwgMyB8IHY1ID4+PiA1KSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlt2NSAmIDMxXTtcbiAgICB9XG5cbiAgICAvLyByZW1haW4gY2hhclxuICAgIHZhciByZW1haW4gPSBsZW5ndGggLSBjb3VudDtcbiAgICBpZiAocmVtYWluID09PSAxKSB7XG4gICAgICB2MSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYxIDw8IDIpICYgMzFdICtcbiAgICAgICAgJz09PT09PSc7XG4gICAgfSBlbHNlIGlmIChyZW1haW4gPT09IDIpIHtcbiAgICAgIHYxID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHYyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjEgPDwgMiB8IHYyID4+PiA2KSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjIgPj4+IDEpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA8PCA0KSAmIDMxXSArXG4gICAgICAgICc9PT09JztcbiAgICB9IGVsc2UgaWYgKHJlbWFpbiA9PT0gMykge1xuICAgICAgdjEgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgdjIgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgdjMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MSA8PCAyIHwgdjIgPj4+IDYpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA+Pj4gMSkgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyIDw8IDQgfCB2MyA+Pj4gNCkgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYzIDw8IDEpICYgMzFdICtcbiAgICAgICAgJz09PSc7XG4gICAgfSBlbHNlIGlmIChyZW1haW4gPT09IDQpIHtcbiAgICAgIHYxID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHYyID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHYzID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIHY0ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjEgPDwgMiB8IHYyID4+PiA2KSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjIgPj4+IDEpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA8PCA0IHwgdjMgPj4+IDQpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MyA8PCAxIHwgdjQgPj4+IDcpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2NCA+Pj4gMikgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHY0IDw8IDMpICYgMzFdICtcbiAgICAgICAgJz0nO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTMyU3RyO1xuICB9O1xuXG4gIHZhciBlbmNvZGVVdGY4ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciB2MSwgdjIsIHYzLCB2NCwgdjUsIGNvZGUsIGVuZCA9IGZhbHNlLCBiYXNlMzJTdHIgPSAnJyxcbiAgICAgIGluZGV4ID0gMCwgaSwgc3RhcnQgPSAwLCBieXRlcyA9IDAsIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgZG8ge1xuICAgICAgYmxvY2tzWzBdID0gYmxvY2tzWzVdO1xuICAgICAgYmxvY2tzWzFdID0gYmxvY2tzWzZdO1xuICAgICAgYmxvY2tzWzJdID0gYmxvY2tzWzddO1xuICAgICAgZm9yIChpID0gc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA1OyArK2luZGV4KSB7XG4gICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgIGJsb2Nrc1tpKytdID0gY29kZTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICBibG9ja3NbaSsrXSA9IDB4YzAgfCAoY29kZSA+PiA2KTtcbiAgICAgICAgICBibG9ja3NbaSsrXSA9IDB4ODAgfCAoY29kZSAmIDB4M2YpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweGQ4MDAgfHwgY29kZSA+PSAweGUwMDApIHtcbiAgICAgICAgICBibG9ja3NbaSsrXSA9IDB4ZTAgfCAoY29kZSA+PiAxMik7XG4gICAgICAgICAgYmxvY2tzW2krK10gPSAweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZik7XG4gICAgICAgICAgYmxvY2tzW2krK10gPSAweDgwIHwgKGNvZGUgJiAweDNmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcbiAgICAgICAgICBibG9ja3NbaSsrXSA9IDB4ZjAgfCAoY29kZSA+PiAxOCk7XG4gICAgICAgICAgYmxvY2tzW2krK10gPSAweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpO1xuICAgICAgICAgIGJsb2Nrc1tpKytdID0gMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpO1xuICAgICAgICAgIGJsb2Nrc1tpKytdID0gMHg4MCB8IChjb2RlICYgMHgzZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ5dGVzICs9IGkgLSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gaSAtIDU7XG4gICAgICBpZiAoaW5kZXggPT09IGxlbmd0aCkge1xuICAgICAgICArK2luZGV4O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoICYmIGkgPCA2KSB7XG4gICAgICAgIGVuZCA9IHRydWU7XG4gICAgICB9XG4gICAgICB2MSA9IGJsb2Nrc1swXTtcbiAgICAgIGlmIChpID4gNCkge1xuICAgICAgICB2MiA9IGJsb2Nrc1sxXTtcbiAgICAgICAgdjMgPSBibG9ja3NbMl07XG4gICAgICAgIHY0ID0gYmxvY2tzWzNdO1xuICAgICAgICB2NSA9IGJsb2Nrc1s0XTtcbiAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gK1xuICAgICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjEgPDwgMiB8IHYyID4+PiA2KSAmIDMxXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA+Pj4gMSkgJiAzMV0gK1xuICAgICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjIgPDwgNCB8IHYzID4+PiA0KSAmIDMxXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MyA8PCAxIHwgdjQgPj4+IDcpICYgMzFdICtcbiAgICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHY0ID4+PiAyKSAmIDMxXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2NCA8PCAzIHwgdjUgPj4+IDUpICYgMzFdICtcbiAgICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbdjUgJiAzMV07XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gK1xuICAgICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjEgPDwgMikgJiAzMV0gK1xuICAgICAgICAgICc9PT09PT0nO1xuICAgICAgfSBlbHNlIGlmIChpID09PSAyKSB7XG4gICAgICAgIHYyID0gYmxvY2tzWzFdO1xuICAgICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MSA8PCAyIHwgdjIgPj4+IDYpICYgMzFdICtcbiAgICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyID4+PiAxKSAmIDMxXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA8PCA0KSAmIDMxXSArXG4gICAgICAgICAgJz09PT0nO1xuICAgICAgfSBlbHNlIGlmIChpID09PSAzKSB7XG4gICAgICAgIHYyID0gYmxvY2tzWzFdO1xuICAgICAgICB2MyA9IGJsb2Nrc1syXTtcbiAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gK1xuICAgICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjEgPDwgMiB8IHYyID4+PiA2KSAmIDMxXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA+Pj4gMSkgJiAzMV0gK1xuICAgICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjIgPDwgNCB8IHYzID4+PiA0KSAmIDMxXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MyA8PCAxKSAmIDMxXSArXG4gICAgICAgICAgJz09PSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2MiA9IGJsb2Nrc1sxXTtcbiAgICAgICAgdjMgPSBibG9ja3NbMl07XG4gICAgICAgIHY0ID0gYmxvY2tzWzNdO1xuICAgICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MSA8PCAyIHwgdjIgPj4+IDYpICYgMzFdICtcbiAgICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyID4+PiAxKSAmIDMxXSArXG4gICAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA8PCA0IHwgdjMgPj4+IDQpICYgMzFdICtcbiAgICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYzIDw8IDEgfCB2NCA+Pj4gNykgJiAzMV0gK1xuICAgICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjQgPj4+IDIpICYgMzFdICtcbiAgICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHY0IDw8IDMpICYgMzFdICtcbiAgICAgICAgICAnPSc7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoIWVuZCk7XG4gICAgcmV0dXJuIGJhc2UzMlN0cjtcbiAgfTtcblxuICB2YXIgZW5jb2RlQnl0ZXMgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICB2YXIgdjEsIHYyLCB2MywgdjQsIHY1LCBiYXNlMzJTdHIgPSAnJywgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBjb3VudCA9IHBhcnNlSW50KGxlbmd0aCAvIDUpICogNTsgaSA8IGNvdW50Oykge1xuICAgICAgdjEgPSBieXRlc1tpKytdO1xuICAgICAgdjIgPSBieXRlc1tpKytdO1xuICAgICAgdjMgPSBieXRlc1tpKytdO1xuICAgICAgdjQgPSBieXRlc1tpKytdO1xuICAgICAgdjUgPSBieXRlc1tpKytdO1xuICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYxIDw8IDIgfCB2MiA+Pj4gNikgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyID4+PiAxKSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjIgPDwgNCB8IHYzID4+PiA0KSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjMgPDwgMSB8IHY0ID4+PiA3KSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjQgPj4+IDIpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2NCA8PCAzIHwgdjUgPj4+IDUpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSW3Y1ICYgMzFdO1xuICAgIH1cblxuICAgIC8vIHJlbWFpbiBjaGFyXG4gICAgdmFyIHJlbWFpbiA9IGxlbmd0aCAtIGNvdW50O1xuICAgIGlmIChyZW1haW4gPT09IDEpIHtcbiAgICAgIHYxID0gYnl0ZXNbaV07XG4gICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjEgPDwgMikgJiAzMV0gK1xuICAgICAgICAnPT09PT09JztcbiAgICB9IGVsc2UgaWYgKHJlbWFpbiA9PT0gMikge1xuICAgICAgdjEgPSBieXRlc1tpKytdO1xuICAgICAgdjIgPSBieXRlc1tpXTtcbiAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MSA8PCAyIHwgdjIgPj4+IDYpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA+Pj4gMSkgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyIDw8IDQpICYgMzFdICtcbiAgICAgICAgJz09PT0nO1xuICAgIH0gZWxzZSBpZiAocmVtYWluID09PSAzKSB7XG4gICAgICB2MSA9IGJ5dGVzW2krK107XG4gICAgICB2MiA9IGJ5dGVzW2krK107XG4gICAgICB2MyA9IGJ5dGVzW2ldO1xuICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYxIDw8IDIgfCB2MiA+Pj4gNikgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyID4+PiAxKSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjIgPDwgNCB8IHYzID4+PiA0KSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjMgPDwgMSkgJiAzMV0gK1xuICAgICAgICAnPT09JztcbiAgICB9IGVsc2UgaWYgKHJlbWFpbiA9PT0gNCkge1xuICAgICAgdjEgPSBieXRlc1tpKytdO1xuICAgICAgdjIgPSBieXRlc1tpKytdO1xuICAgICAgdjMgPSBieXRlc1tpKytdO1xuICAgICAgdjQgPSBieXRlc1tpXTtcbiAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MSA8PCAyIHwgdjIgPj4+IDYpICYgMzFdICtcbiAgICAgICAgQkFTRTMyX0VOQ09ERV9DSEFSWyh2MiA+Pj4gMSkgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYyIDw8IDQgfCB2MyA+Pj4gNCkgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHYzIDw8IDEgfCB2NCA+Pj4gNykgJiAzMV0gK1xuICAgICAgICBCQVNFMzJfRU5DT0RFX0NIQVJbKHY0ID4+PiAyKSAmIDMxXSArXG4gICAgICAgIEJBU0UzMl9FTkNPREVfQ0hBUlsodjQgPDwgMykgJiAzMV0gK1xuICAgICAgICAnPSc7XG4gICAgfVxuICAgIHJldHVybiBiYXNlMzJTdHI7XG4gIH07XG5cbiAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uIChpbnB1dCwgYXNjaWlPbmx5KSB7XG4gICAgdmFyIG5vdFN0cmluZyA9IHR5cGVvZihpbnB1dCkgIT09ICdzdHJpbmcnO1xuICAgIGlmIChub3RTdHJpbmcgJiYgaW5wdXQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICBpbnB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9XG4gICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgcmV0dXJuIGVuY29kZUJ5dGVzKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKGFzY2lpT25seSkge1xuICAgICAgcmV0dXJuIGVuY29kZUFzY2lpKGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVuY29kZVV0ZjgoaW5wdXQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZGVjb2RlID0gZnVuY3Rpb24gKGJhc2UzMlN0ciwgYXNjaWlPbmx5KSB7XG4gICAgaWYgKCFhc2NpaU9ubHkpIHtcbiAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoZGVjb2RlQXNCeXRlcyhiYXNlMzJTdHIpKTtcbiAgICB9XG4gICAgaWYgKCEvXltBLVoyLTc9XSskLy50ZXN0KGJhc2UzMlN0cikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYXNlMzIgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgICB2YXIgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCBzdHIgPSAnJywgbGVuZ3RoID0gYmFzZTMyU3RyLmluZGV4T2YoJz0nKTtcbiAgICBpZiAobGVuZ3RoID09PSAtMSkge1xuICAgICAgbGVuZ3RoID0gYmFzZTMyU3RyLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyA4IGNoYXIgdG8gNSBieXRlc1xuICAgIGZvciAodmFyIGkgPSAwLCBjb3VudCA9IGxlbmd0aCA+PiAzIDw8IDM7IGkgPCBjb3VudDspIHtcbiAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2NSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjYgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY3ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2OCA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKHYxIDw8IDMgfCB2MiA+Pj4gMikgJiAyNTUpICtcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgodjIgPDwgNiB8IHYzIDw8IDEgfCB2NCA+Pj4gNCkgJiAyNTUpICtcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgodjQgPDwgNCB8IHY1ID4+PiAxKSAmIDI1NSkgK1xuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCh2NSA8PCA3IHwgdjYgPDwgMiB8IHY3ID4+PiAzKSAmIDI1NSkgK1xuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCh2NyA8PCA1IHwgdjgpICYgMjU1KTtcbiAgICB9XG5cbiAgICAvLyByZW1haW4gYnl0ZXNcbiAgICB2YXIgcmVtYWluID0gbGVuZ3RoIC0gY291bnQ7XG4gICAgaWYgKHJlbWFpbiA9PT0gMikge1xuICAgICAgdjEgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHYyID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgodjEgPDwgMyB8IHYyID4+PiAyKSAmIDI1NSk7XG4gICAgfSBlbHNlIGlmIChyZW1haW4gPT09IDQpIHtcbiAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgodjEgPDwgMyB8IHYyID4+PiAyKSAmIDI1NSkgK1xuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCh2MiA8PCA2IHwgdjMgPDwgMSB8IHY0ID4+PiA0KSAmIDI1NSk7XG4gICAgfSBlbHNlIGlmIChyZW1haW4gPT09IDUpIHtcbiAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2NSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKHYxIDw8IDMgfCB2MiA+Pj4gMikgJiAyNTUpICtcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgodjIgPDwgNiB8IHYzIDw8IDEgfCB2NCA+Pj4gNCkgJiAyNTUpICtcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgodjQgPDwgNCB8IHY1ID4+PiAxKSAmIDI1NSk7XG4gICAgfSBlbHNlIGlmIChyZW1haW4gPT09IDcpIHtcbiAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICB2NSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgdjYgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgIHY3ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgodjEgPDwgMyB8IHYyID4+PiAyKSAmIDI1NSkgK1xuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCh2MiA8PCA2IHwgdjMgPDwgMSB8IHY0ID4+PiA0KSAmIDI1NSkgK1xuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCh2NCA8PCA0IHwgdjUgPj4+IDEpICYgMjU1KSArXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoKHY1IDw8IDcgfCB2NiA8PCAyIHwgdjcgPj4+IDMpICYgMjU1KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICB2YXIgZXhwb3J0cyA9IHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9O1xuICBkZWNvZGUuYXNCeXRlcyA9IGRlY29kZUFzQnl0ZXM7XG5cbiAgaWYgKENPTU1PTl9KUykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiAgfSBlbHNlIHtcbiAgICByb290LmJhc2UzMiA9IGV4cG9ydHM7XG4gICAgaWYgKEFNRCkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlwID0gZXhwb3J0cztcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgb3MgPSByZXF1aXJlKCdvcycpO1xuXG5pcC50b0J1ZmZlciA9IGZ1bmN0aW9uKGlwLCBidWZmLCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gfn5vZmZzZXQ7XG5cbiAgdmFyIHJlc3VsdDtcblxuICBpZiAodGhpcy5pc1Y0Rm9ybWF0KGlwKSkge1xuICAgIHJlc3VsdCA9IGJ1ZmYgfHwgbmV3IEJ1ZmZlcihvZmZzZXQgKyA0KTtcbiAgICBpcC5zcGxpdCgvXFwuL2cpLm1hcChmdW5jdGlvbihieXRlKSB7XG4gICAgICByZXN1bHRbb2Zmc2V0KytdID0gcGFyc2VJbnQoYnl0ZSwgMTApICYgMHhmZjtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzVjZGb3JtYXQoaXApKSB7XG4gICAgdmFyIHNlY3Rpb25zID0gaXAuc3BsaXQoJzonLCA4KTtcblxuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlzdjQgPSB0aGlzLmlzVjRGb3JtYXQoc2VjdGlvbnNbaV0pO1xuICAgICAgdmFyIHY0QnVmZmVyO1xuXG4gICAgICBpZiAoaXN2NCkge1xuICAgICAgICB2NEJ1ZmZlciA9IHRoaXMudG9CdWZmZXIoc2VjdGlvbnNbaV0pO1xuICAgICAgICBzZWN0aW9uc1tpXSA9IHY0QnVmZmVyLnNsaWNlKDAsIDIpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHY0QnVmZmVyICYmICsraSA8IDgpIHtcbiAgICAgICAgc2VjdGlvbnMuc3BsaWNlKGksIDAsIHY0QnVmZmVyLnNsaWNlKDIsIDQpLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlY3Rpb25zWzBdID09PSAnJykge1xuICAgICAgd2hpbGUgKHNlY3Rpb25zLmxlbmd0aCA8IDgpIHNlY3Rpb25zLnVuc2hpZnQoJzAnKTtcbiAgICB9IGVsc2UgaWYgKHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgd2hpbGUgKHNlY3Rpb25zLmxlbmd0aCA8IDgpIHNlY3Rpb25zLnB1c2goJzAnKTtcbiAgICB9IGVsc2UgaWYgKHNlY3Rpb25zLmxlbmd0aCA8IDgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGggJiYgc2VjdGlvbnNbaV0gIT09ICcnOyBpKyspO1xuICAgICAgdmFyIGFyZ3YgPSBbIGksIDEgXTtcbiAgICAgIGZvciAoaSA9IDkgLSBzZWN0aW9ucy5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgYXJndi5wdXNoKCcwJyk7XG4gICAgICB9XG4gICAgICBzZWN0aW9ucy5zcGxpY2UuYXBwbHkoc2VjdGlvbnMsIGFyZ3YpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IGJ1ZmYgfHwgbmV3IEJ1ZmZlcihvZmZzZXQgKyAxNik7XG4gICAgZm9yIChpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd29yZCA9IHBhcnNlSW50KHNlY3Rpb25zW2ldLCAxNik7XG4gICAgICByZXN1bHRbb2Zmc2V0KytdID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgICAgcmVzdWx0W29mZnNldCsrXSA9IHdvcmQgJiAweGZmO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgaXAgYWRkcmVzczogJyArIGlwKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5pcC50b1N0cmluZyA9IGZ1bmN0aW9uKGJ1ZmYsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IH5+b2Zmc2V0O1xuICBsZW5ndGggPSBsZW5ndGggfHwgKGJ1ZmYubGVuZ3RoIC0gb2Zmc2V0KTtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChsZW5ndGggPT09IDQpIHtcbiAgICAvLyBJUHY0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goYnVmZltvZmZzZXQgKyBpXSk7XG4gICAgfVxuICAgIHJlc3VsdCA9IHJlc3VsdC5qb2luKCcuJyk7XG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSAxNikge1xuICAgIC8vIElQdjZcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICByZXN1bHQucHVzaChidWZmLnJlYWRVSW50MTZCRShvZmZzZXQgKyBpKS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICByZXN1bHQgPSByZXN1bHQuam9pbignOicpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC8oXnw6KTAoOjApKjowKDp8JCkvLCAnJDE6OiQzJyk7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoLzp7Myw0fS8sICc6OicpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBpcHY0UmVnZXggPSAvXihcXGR7MSwzfVxcLil7MywzfVxcZHsxLDN9JC87XG52YXIgaXB2NlJlZ2V4ID1cbiAgICAvXig6Oik/KCgoXFxkezEsM31cXC4pezN9KFxcZHsxLDN9KXsxfSk/KFswLTlhLWZdKXswLDR9OnswLDJ9KXsxLDh9KDo6KT8kL2k7XG5cbmlwLmlzVjRGb3JtYXQgPSBmdW5jdGlvbihpcCkge1xuICByZXR1cm4gaXB2NFJlZ2V4LnRlc3QoaXApO1xufTtcblxuaXAuaXNWNkZvcm1hdCA9IGZ1bmN0aW9uKGlwKSB7XG4gIHJldHVybiBpcHY2UmVnZXgudGVzdChpcCk7XG59O1xuZnVuY3Rpb24gX25vcm1hbGl6ZUZhbWlseShmYW1pbHkpIHtcbiAgcmV0dXJuIGZhbWlseSA/IGZhbWlseS50b0xvd2VyQ2FzZSgpIDogJ2lwdjQnO1xufVxuXG5pcC5mcm9tUHJlZml4TGVuID0gZnVuY3Rpb24ocHJlZml4bGVuLCBmYW1pbHkpIHtcbiAgaWYgKHByZWZpeGxlbiA+IDMyKSB7XG4gICAgZmFtaWx5ID0gJ2lwdjYnO1xuICB9IGVsc2Uge1xuICAgIGZhbWlseSA9IF9ub3JtYWxpemVGYW1pbHkoZmFtaWx5KTtcbiAgfVxuXG4gIHZhciBsZW4gPSA0O1xuICBpZiAoZmFtaWx5ID09PSAnaXB2NicpIHtcbiAgICBsZW4gPSAxNjtcbiAgfVxuICB2YXIgYnVmZiA9IG5ldyBCdWZmZXIobGVuKTtcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IGJ1ZmYubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgdmFyIGJpdHMgPSA4O1xuICAgIGlmIChwcmVmaXhsZW4gPCA4KSB7XG4gICAgICBiaXRzID0gcHJlZml4bGVuO1xuICAgIH1cbiAgICBwcmVmaXhsZW4gLT0gYml0cztcblxuICAgIGJ1ZmZbaV0gPSB+KDB4ZmYgPj4gYml0cykgJiAweGZmO1xuICB9XG5cbiAgcmV0dXJuIGlwLnRvU3RyaW5nKGJ1ZmYpO1xufTtcblxuaXAubWFzayA9IGZ1bmN0aW9uKGFkZHIsIG1hc2spIHtcbiAgYWRkciA9IGlwLnRvQnVmZmVyKGFkZHIpO1xuICBtYXNrID0gaXAudG9CdWZmZXIobWFzayk7XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBCdWZmZXIoTWF0aC5tYXgoYWRkci5sZW5ndGgsIG1hc2subGVuZ3RoKSk7XG5cbiAgdmFyIGkgPSAwO1xuICAvLyBTYW1lIHByb3RvY29sIC0gZG8gYml0d2lzZSBhbmRcbiAgaWYgKGFkZHIubGVuZ3RoID09PSBtYXNrLmxlbmd0aCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBhZGRyLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBhZGRyW2ldICYgbWFza1tpXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobWFzay5sZW5ndGggPT09IDQpIHtcbiAgICAvLyBJUHY2IGFkZHJlc3MgYW5kIElQdjQgbWFza1xuICAgIC8vIChNYXNrIGxvdyBiaXRzKVxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBhZGRyW2FkZHIubGVuZ3RoIC0gNCAgKyBpXSAmIG1hc2tbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElQdjYgbWFzayBhbmQgSVB2NCBhZGRyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoIC0gNjsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSAwO1xuICAgIH1cblxuICAgIC8vIDo6ZmZmZjppcHY0XG4gICAgcmVzdWx0WzEwXSA9IDB4ZmY7XG4gICAgcmVzdWx0WzExXSA9IDB4ZmY7XG4gICAgZm9yIChpID0gMDsgaSA8IGFkZHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpICsgMTJdID0gYWRkcltpXSAmIG1hc2tbaSArIDEyXTtcbiAgICB9XG4gICAgaSA9IGkgKyAxMjtcbiAgfVxuICBmb3IgKDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKylcbiAgICByZXN1bHRbaV0gPSAwO1xuXG4gIHJldHVybiBpcC50b1N0cmluZyhyZXN1bHQpO1xufTtcblxuaXAuY2lkciA9IGZ1bmN0aW9uKGNpZHJTdHJpbmcpIHtcbiAgdmFyIGNpZHJQYXJ0cyA9IGNpZHJTdHJpbmcuc3BsaXQoJy8nKTtcblxuICB2YXIgYWRkciA9IGNpZHJQYXJ0c1swXTtcbiAgaWYgKGNpZHJQYXJ0cy5sZW5ndGggIT09IDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIENJRFIgc3VibmV0OiAnICsgYWRkcik7XG5cbiAgdmFyIG1hc2sgPSBpcC5mcm9tUHJlZml4TGVuKHBhcnNlSW50KGNpZHJQYXJ0c1sxXSwgMTApKTtcblxuICByZXR1cm4gaXAubWFzayhhZGRyLCBtYXNrKTtcbn07XG5cbmlwLnN1Ym5ldCA9IGZ1bmN0aW9uKGFkZHIsIG1hc2spIHtcbiAgdmFyIG5ldHdvcmtBZGRyZXNzID0gaXAudG9Mb25nKGlwLm1hc2soYWRkciwgbWFzaykpO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgbWFzaydzIGxlbmd0aC5cbiAgdmFyIG1hc2tCdWZmZXIgPSBpcC50b0J1ZmZlcihtYXNrKTtcbiAgdmFyIG1hc2tMZW5ndGggPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFza0J1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtYXNrQnVmZmVyW2ldID09PSAweGZmKSB7XG4gICAgICBtYXNrTGVuZ3RoICs9IDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvY3RldCA9IG1hc2tCdWZmZXJbaV0gJiAweGZmO1xuICAgICAgd2hpbGUgKG9jdGV0KSB7XG4gICAgICAgIG9jdGV0ID0gKG9jdGV0IDw8IDEpICYgMHhmZjtcbiAgICAgICAgbWFza0xlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBudW1iZXJPZkFkZHJlc3NlcyA9IE1hdGgucG93KDIsIDMyIC0gbWFza0xlbmd0aCk7XG5cbiAgcmV0dXJuIHtcbiAgICBuZXR3b3JrQWRkcmVzczogaXAuZnJvbUxvbmcobmV0d29ya0FkZHJlc3MpLFxuICAgIGZpcnN0QWRkcmVzczogbnVtYmVyT2ZBZGRyZXNzZXMgPD0gMiA/XG4gICAgICAgICAgICAgICAgICAgIGlwLmZyb21Mb25nKG5ldHdvcmtBZGRyZXNzKSA6XG4gICAgICAgICAgICAgICAgICAgIGlwLmZyb21Mb25nKG5ldHdvcmtBZGRyZXNzICsgMSksXG4gICAgbGFzdEFkZHJlc3M6IG51bWJlck9mQWRkcmVzc2VzIDw9IDIgP1xuICAgICAgICAgICAgICAgICAgICBpcC5mcm9tTG9uZyhuZXR3b3JrQWRkcmVzcyArIG51bWJlck9mQWRkcmVzc2VzIC0gMSkgOlxuICAgICAgICAgICAgICAgICAgICBpcC5mcm9tTG9uZyhuZXR3b3JrQWRkcmVzcyArIG51bWJlck9mQWRkcmVzc2VzIC0gMiksXG4gICAgYnJvYWRjYXN0QWRkcmVzczogaXAuZnJvbUxvbmcobmV0d29ya0FkZHJlc3MgKyBudW1iZXJPZkFkZHJlc3NlcyAtIDEpLFxuICAgIHN1Ym5ldE1hc2s6IG1hc2ssXG4gICAgc3VibmV0TWFza0xlbmd0aDogbWFza0xlbmd0aCxcbiAgICBudW1Ib3N0czogbnVtYmVyT2ZBZGRyZXNzZXMgPD0gMiA/XG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZBZGRyZXNzZXMgOiBudW1iZXJPZkFkZHJlc3NlcyAtIDIsXG4gICAgbGVuZ3RoOiBudW1iZXJPZkFkZHJlc3NlcyxcbiAgICBjb250YWluczogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIHJldHVybiBuZXR3b3JrQWRkcmVzcyA9PT0gaXAudG9Mb25nKGlwLm1hc2sob3RoZXIsIG1hc2spKTtcbiAgICB9XG4gIH07XG59O1xuXG5pcC5jaWRyU3VibmV0ID0gZnVuY3Rpb24oY2lkclN0cmluZykge1xuICB2YXIgY2lkclBhcnRzID0gY2lkclN0cmluZy5zcGxpdCgnLycpO1xuXG4gIHZhciBhZGRyID0gY2lkclBhcnRzWzBdO1xuICBpZiAoY2lkclBhcnRzLmxlbmd0aCAhPT0gMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgQ0lEUiBzdWJuZXQ6ICcgKyBhZGRyKTtcblxuICB2YXIgbWFzayA9IGlwLmZyb21QcmVmaXhMZW4ocGFyc2VJbnQoY2lkclBhcnRzWzFdLCAxMCkpO1xuXG4gIHJldHVybiBpcC5zdWJuZXQoYWRkciwgbWFzayk7XG59O1xuXG5pcC5ub3QgPSBmdW5jdGlvbihhZGRyKSB7XG4gIHZhciBidWZmID0gaXAudG9CdWZmZXIoYWRkcik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZi5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZbaV0gPSAweGZmIF4gYnVmZltpXTtcbiAgfVxuICByZXR1cm4gaXAudG9TdHJpbmcoYnVmZik7XG59O1xuXG5pcC5vciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgYSA9IGlwLnRvQnVmZmVyKGEpO1xuICBiID0gaXAudG9CdWZmZXIoYik7XG5cbiAgLy8gc2FtZSBwcm90b2NvbFxuICBpZiAoYS5sZW5ndGggPT09IGIubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICBhW2ldIHw9IGJbaV07XG4gICAgfVxuICAgIHJldHVybiBpcC50b1N0cmluZyhhKTtcblxuICAvLyBtaXhlZCBwcm90b2NvbHNcbiAgfSBlbHNlIHtcbiAgICB2YXIgYnVmZiA9IGE7XG4gICAgdmFyIG90aGVyID0gYjtcbiAgICBpZiAoYi5sZW5ndGggPiBhLmxlbmd0aCkge1xuICAgICAgYnVmZiA9IGI7XG4gICAgICBvdGhlciA9IGE7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldCA9IGJ1ZmYubGVuZ3RoIC0gb3RoZXIubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBidWZmLmxlbmd0aDsgKytpKSB7XG4gICAgICBidWZmW2ldIHw9IG90aGVyW2kgLSBvZmZzZXRdO1xuICAgIH1cblxuICAgIHJldHVybiBpcC50b1N0cmluZyhidWZmKTtcbiAgfVxufTtcblxuaXAuaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgYSA9IGlwLnRvQnVmZmVyKGEpO1xuICBiID0gaXAudG9CdWZmZXIoYik7XG5cbiAgLy8gU2FtZSBwcm90b2NvbFxuICBpZiAoYS5sZW5ndGggPT09IGIubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFN3YXBcbiAgaWYgKGIubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIHQgPSBiO1xuICAgIGIgPSBhO1xuICAgIGEgPSB0O1xuICB9XG5cbiAgLy8gYSAtIElQdjQsIGIgLSBJUHY2XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGlmIChiW2ldICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgd29yZCA9IGIucmVhZFVJbnQxNkJFKDEwKTtcbiAgaWYgKHdvcmQgIT09IDAgJiYgd29yZCAhPT0gMHhmZmZmKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpICsgMTJdKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmlwLmlzUHJpdmF0ZSA9IGZ1bmN0aW9uKGFkZHIpIHtcbiAgcmV0dXJuIC9eKDo6Zns0fTopPzEwXFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pJC9pXG4gICAgICAudGVzdChhZGRyKSB8fFxuICAgIC9eKDo6Zns0fTopPzE5MlxcLjE2OFxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KSQvaS50ZXN0KGFkZHIpIHx8XG4gICAgL14oOjpmezR9Oik/MTcyXFwuKDFbNi05XXwyXFxkfDMwfDMxKVxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KSQvaVxuICAgICAgLnRlc3QoYWRkcikgfHxcbiAgICAvXig6OmZ7NH06KT8xMjdcXC4oWzAtOV17MSwzfSlcXC4oWzAtOV17MSwzfSlcXC4oWzAtOV17MSwzfSkkL2kudGVzdChhZGRyKSB8fFxuICAgIC9eKDo6Zns0fTopPzE2OVxcLjI1NFxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KSQvaS50ZXN0KGFkZHIpIHx8XG4gICAgL15mW2NkXVswLTlhLWZdezJ9Oi9pLnRlc3QoYWRkcikgfHxcbiAgICAvXmZlODA6L2kudGVzdChhZGRyKSB8fFxuICAgIC9eOjoxJC8udGVzdChhZGRyKSB8fFxuICAgIC9eOjokLy50ZXN0KGFkZHIpO1xufTtcblxuaXAuaXNQdWJsaWMgPSBmdW5jdGlvbihhZGRyKSB7XG4gIHJldHVybiAhaXAuaXNQcml2YXRlKGFkZHIpO1xufTtcblxuaXAuaXNMb29wYmFjayA9IGZ1bmN0aW9uKGFkZHIpIHtcbiAgcmV0dXJuIC9eKDo6Zns0fTopPzEyN1xcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KS9cbiAgICAgIC50ZXN0KGFkZHIpIHx8XG4gICAgL15mZTgwOjoxJC8udGVzdChhZGRyKSB8fFxuICAgIC9eOjoxJC8udGVzdChhZGRyKSB8fFxuICAgIC9eOjokLy50ZXN0KGFkZHIpO1xufTtcblxuaXAubG9vcGJhY2sgPSBmdW5jdGlvbihmYW1pbHkpIHtcbiAgLy9cbiAgLy8gRGVmYXVsdCB0byBgaXB2NGBcbiAgLy9cbiAgZmFtaWx5ID0gX25vcm1hbGl6ZUZhbWlseShmYW1pbHkpO1xuXG4gIGlmIChmYW1pbHkgIT09ICdpcHY0JyAmJiBmYW1pbHkgIT09ICdpcHY2Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignZmFtaWx5IG11c3QgYmUgaXB2NCBvciBpcHY2Jyk7XG4gIH1cblxuICByZXR1cm4gZmFtaWx5ID09PSAnaXB2NCcgPyAnMTI3LjAuMC4xJyA6ICdmZTgwOjoxJztcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gYWRkcmVzcyAobmFtZSwgZmFtaWx5KVxuLy8gIyMjIyBAbmFtZSB7c3RyaW5nfCdwdWJsaWMnfCdwcml2YXRlJ30gKipPcHRpb25hbCoqIE5hbWUgb3Igc2VjdXJpdHlcbi8vICAgICAgb2YgdGhlIG5ldHdvcmsgaW50ZXJmYWNlLlxuLy8gIyMjIyBAZmFtaWx5IHtpcHY0fGlwdjZ9ICoqT3B0aW9uYWwqKiBJUCBmYW1pbHkgb2YgdGhlIGFkZHJlc3MgKGRlZmF1bHRzXG4vLyAgICAgIHRvIGlwdjQpLlxuLy9cbi8vIFJldHVybnMgdGhlIGFkZHJlc3MgZm9yIHRoZSBuZXR3b3JrIGludGVyZmFjZSBvbiB0aGUgY3VycmVudCBzeXN0ZW0gd2l0aFxuLy8gdGhlIHNwZWNpZmllZCBgbmFtZWA6XG4vLyAgICogU3RyaW5nOiBGaXJzdCBgZmFtaWx5YCBhZGRyZXNzIG9mIHRoZSBpbnRlcmZhY2UuXG4vLyAgICAgICAgICAgICBJZiBub3QgZm91bmQgc2VlIGB1bmRlZmluZWRgLlxuLy8gICAqICdwdWJsaWMnOiB0aGUgZmlyc3QgcHVibGljIGlwIGFkZHJlc3Mgb2YgZmFtaWx5LlxuLy8gICAqICdwcml2YXRlJzogdGhlIGZpcnN0IHByaXZhdGUgaXAgYWRkcmVzcyBvZiBmYW1pbHkuXG4vLyAgICogdW5kZWZpbmVkOiBGaXJzdCBhZGRyZXNzIHdpdGggYGlwdjRgIG9yIGxvb3BiYWNrIGFkZHJlc3MgYDEyNy4wLjAuMWAuXG4vL1xuaXAuYWRkcmVzcyA9IGZ1bmN0aW9uKG5hbWUsIGZhbWlseSkge1xuICB2YXIgaW50ZXJmYWNlcyA9IG9zLm5ldHdvcmtJbnRlcmZhY2VzKCk7XG4gIHZhciBhbGw7XG5cbiAgLy9cbiAgLy8gRGVmYXVsdCB0byBgaXB2NGBcbiAgLy9cbiAgZmFtaWx5ID0gX25vcm1hbGl6ZUZhbWlseShmYW1pbHkpO1xuXG4gIC8vXG4gIC8vIElmIGEgc3BlY2lmaWMgbmV0d29yayBpbnRlcmZhY2UgaGFzIGJlZW4gbmFtZWQsXG4gIC8vIHJldHVybiB0aGUgYWRkcmVzcy5cbiAgLy9cbiAgaWYgKG5hbWUgJiYgbmFtZSAhPT0gJ3ByaXZhdGUnICYmIG5hbWUgIT09ICdwdWJsaWMnKSB7XG4gICAgdmFyIHJlcyA9IGludGVyZmFjZXNbbmFtZV0uZmlsdGVyKGZ1bmN0aW9uKGRldGFpbHMpIHtcbiAgICAgIHZhciBpdGVtRmFtaWx5ID0gZGV0YWlscy5mYW1pbHkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBpdGVtRmFtaWx5ID09PSBmYW1pbHk7XG4gICAgfSk7XG4gICAgaWYgKHJlcy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXNbMF0uYWRkcmVzcztcbiAgfVxuXG4gIHZhciBhbGwgPSBPYmplY3Qua2V5cyhpbnRlcmZhY2VzKS5tYXAoZnVuY3Rpb24gKG5pYykge1xuICAgIC8vXG4gICAgLy8gTm90ZTogbmFtZSB3aWxsIG9ubHkgYmUgYHB1YmxpY2Agb3IgYHByaXZhdGVgXG4gICAgLy8gd2hlbiB0aGlzIGlzIGNhbGxlZC5cbiAgICAvL1xuICAgIHZhciBhZGRyZXNzZXMgPSBpbnRlcmZhY2VzW25pY10uZmlsdGVyKGZ1bmN0aW9uIChkZXRhaWxzKSB7XG4gICAgICBkZXRhaWxzLmZhbWlseSA9IGRldGFpbHMuZmFtaWx5LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoZGV0YWlscy5mYW1pbHkgIT09IGZhbWlseSB8fCBpcC5pc0xvb3BiYWNrKGRldGFpbHMuYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghbmFtZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWUgPT09ICdwdWJsaWMnID8gaXAuaXNQcml2YXRlKGRldGFpbHMuYWRkcmVzcykgOlxuICAgICAgICAgIGlwLmlzUHVibGljKGRldGFpbHMuYWRkcmVzcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYWRkcmVzc2VzLmxlbmd0aCA/IGFkZHJlc3Nlc1swXS5hZGRyZXNzIDogdW5kZWZpbmVkO1xuICB9KS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgcmV0dXJuICFhbGwubGVuZ3RoID8gaXAubG9vcGJhY2soZmFtaWx5KSA6IGFsbFswXTtcbn07XG5cbmlwLnRvTG9uZyA9IGZ1bmN0aW9uKGlwKSB7XG4gIHZhciBpcGwgPSAwO1xuICBpcC5zcGxpdCgnLicpLmZvckVhY2goZnVuY3Rpb24ob2N0ZXQpIHtcbiAgICBpcGwgPDw9IDg7XG4gICAgaXBsICs9IHBhcnNlSW50KG9jdGV0KTtcbiAgfSk7XG4gIHJldHVybihpcGwgPj4+IDApO1xufTtcblxuaXAuZnJvbUxvbmcgPSBmdW5jdGlvbihpcGwpIHtcbiAgcmV0dXJuICgoaXBsID4+PiAyNCkgKyAnLicgK1xuICAgICAgKGlwbCA+PiAxNiAmIDI1NSkgKyAnLicgK1xuICAgICAgKGlwbCA+PiA4ICYgMjU1KSArICcuJyArXG4gICAgICAoaXBsICYgMjU1KSApO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGlwUmVnZXggPSByZXF1aXJlKCdpcC1yZWdleCcpO1xuXG5jb25zdCBpc0lwID0gbW9kdWxlLmV4cG9ydHMgPSB4ID0+IGlwUmVnZXgoe2V4YWN0OiB0cnVlfSkudGVzdCh4KTtcbmlzSXAudjQgPSB4ID0+IGlwUmVnZXgudjQoe2V4YWN0OiB0cnVlfSkudGVzdCh4KTtcbmlzSXAudjYgPSB4ID0+IGlwUmVnZXgudjYoe2V4YWN0OiB0cnVlfSkudGVzdCh4KTtcbiIsIi8qIGpzaGludCAtVzA4NjogdHJ1ZSAqL1xuLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4vLyB8IG11cm11ckhhc2gzanMuanMgdjMuMC4xIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waWQvbXVybXVySGFzaDNqc1xuLy8gfCBBIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgTXVybXVySGFzaDMncyB4ODYgaGFzaGluZyBhbGdvcml0aG1zLiB8XG4vLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbi8vIHwgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTUgS2FyYW4gTHlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4vLyB8IGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJhbmx5b25zL211cm11ckhhc2gzLmpzL2Jsb2IvYzE3NzhmNzU3OTJhYmVmN2JkZDc0YmM4NWQyZDRlMWEzZDI1Y2ZlOS9tdXJtdXJIYXNoMy5qcyB8XG4vLyB8IEZyZWVseSBkaXN0cmlidXRhYmxlIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gICAgICAgICAgICAgICAgICAgICAgICAgIHxcbi8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuXG47KGZ1bmN0aW9uIChyb290LCB1bmRlZmluZWQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBDcmVhdGUgYSBsb2NhbCBvYmplY3QgdGhhdCdsbCBiZSBleHBvcnRlZCBvciByZWZlcmVuY2VkIGdsb2JhbGx5LlxuICAgIHZhciBsaWJyYXJ5ID0ge1xuICAgICAgICAndmVyc2lvbic6ICczLjAuMScsXG4gICAgICAgICd4ODYnOiB7fSxcbiAgICAgICAgJ3g2NCc6IHt9XG4gICAgfTtcblxuICAgIC8vIFBSSVZBVEUgRlVOQ1RJT05TXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZ1bmN0aW9uIF94ODZNdWx0aXBseShtLCBuKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIHR3byAzMmJpdCBpbnRzLCByZXR1cm5zIHRoZSB0d28gbXVsdGlwbGllZCB0b2dldGhlciBhcyBhXG4gICAgICAgIC8vIDMyYml0IGludC5cbiAgICAgICAgLy9cblxuICAgICAgICByZXR1cm4gKChtICYgMHhmZmZmKSAqIG4pICsgKCgoKG0gPj4+IDE2KSAqIG4pICYgMHhmZmZmKSA8PCAxNik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3g4NlJvdGwobSwgbikge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHaXZlbiBhIDMyYml0IGludCBhbmQgYW4gaW50IHJlcHJlc2VudGluZyBhIG51bWJlciBvZiBiaXQgcG9zaXRpb25zLFxuICAgICAgICAvLyByZXR1cm5zIHRoZSAzMmJpdCBpbnQgcm90YXRlZCBsZWZ0IGJ5IHRoYXQgbnVtYmVyIG9mIHBvc2l0aW9ucy5cbiAgICAgICAgLy9cblxuICAgICAgICByZXR1cm4gKG0gPDwgbikgfCAobSA+Pj4gKDMyIC0gbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94ODZGbWl4KGgpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSBibG9jaywgcmV0dXJucyBtdXJtdXJIYXNoMydzIGZpbmFsIHg4NiBtaXggb2YgdGhhdCBibG9jay5cbiAgICAgICAgLy9cblxuICAgICAgICBoIF49IGggPj4+IDE2O1xuICAgICAgICBoID0gX3g4Nk11bHRpcGx5KGgsIDB4ODVlYmNhNmIpO1xuICAgICAgICBoIF49IGggPj4+IDEzO1xuICAgICAgICBoID0gX3g4Nk11bHRpcGx5KGgsIDB4YzJiMmFlMzUpO1xuICAgICAgICBoIF49IGggPj4+IDE2O1xuXG4gICAgICAgIHJldHVybiBoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94NjRBZGQobSwgbikge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHaXZlbiB0d28gNjRiaXQgaW50cyAoYXMgYW4gYXJyYXkgb2YgdHdvIDMyYml0IGludHMpIHJldHVybnMgdGhlIHR3b1xuICAgICAgICAvLyBhZGRlZCB0b2dldGhlciBhcyBhIDY0Yml0IGludCAoYXMgYW4gYXJyYXkgb2YgdHdvIDMyYml0IGludHMpLlxuICAgICAgICAvL1xuXG4gICAgICAgIG0gPSBbbVswXSA+Pj4gMTYsIG1bMF0gJiAweGZmZmYsIG1bMV0gPj4+IDE2LCBtWzFdICYgMHhmZmZmXTtcbiAgICAgICAgbiA9IFtuWzBdID4+PiAxNiwgblswXSAmIDB4ZmZmZiwgblsxXSA+Pj4gMTYsIG5bMV0gJiAweGZmZmZdO1xuICAgICAgICB2YXIgbyA9IFswLCAwLCAwLCAwXTtcblxuICAgICAgICBvWzNdICs9IG1bM10gKyBuWzNdO1xuICAgICAgICBvWzJdICs9IG9bM10gPj4+IDE2O1xuICAgICAgICBvWzNdICY9IDB4ZmZmZjtcblxuICAgICAgICBvWzJdICs9IG1bMl0gKyBuWzJdO1xuICAgICAgICBvWzFdICs9IG9bMl0gPj4+IDE2O1xuICAgICAgICBvWzJdICY9IDB4ZmZmZjtcblxuICAgICAgICBvWzFdICs9IG1bMV0gKyBuWzFdO1xuICAgICAgICBvWzBdICs9IG9bMV0gPj4+IDE2O1xuICAgICAgICBvWzFdICY9IDB4ZmZmZjtcblxuICAgICAgICBvWzBdICs9IG1bMF0gKyBuWzBdO1xuICAgICAgICBvWzBdICY9IDB4ZmZmZjtcblxuICAgICAgICByZXR1cm4gWyhvWzBdIDw8IDE2KSB8IG9bMV0sIChvWzJdIDw8IDE2KSB8IG9bM11dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94NjRNdWx0aXBseShtLCBuKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIHR3byA2NGJpdCBpbnRzIChhcyBhbiBhcnJheSBvZiB0d28gMzJiaXQgaW50cykgcmV0dXJucyB0aGUgdHdvXG4gICAgICAgIC8vIG11bHRpcGxpZWQgdG9nZXRoZXIgYXMgYSA2NGJpdCBpbnQgKGFzIGFuIGFycmF5IG9mIHR3byAzMmJpdCBpbnRzKS5cbiAgICAgICAgLy9cblxuICAgICAgICBtID0gW21bMF0gPj4+IDE2LCBtWzBdICYgMHhmZmZmLCBtWzFdID4+PiAxNiwgbVsxXSAmIDB4ZmZmZl07XG4gICAgICAgIG4gPSBbblswXSA+Pj4gMTYsIG5bMF0gJiAweGZmZmYsIG5bMV0gPj4+IDE2LCBuWzFdICYgMHhmZmZmXTtcbiAgICAgICAgdmFyIG8gPSBbMCwgMCwgMCwgMF07XG5cbiAgICAgICAgb1szXSArPSBtWzNdICogblszXTtcbiAgICAgICAgb1syXSArPSBvWzNdID4+PiAxNjtcbiAgICAgICAgb1szXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1syXSArPSBtWzJdICogblszXTtcbiAgICAgICAgb1sxXSArPSBvWzJdID4+PiAxNjtcbiAgICAgICAgb1syXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1syXSArPSBtWzNdICogblsyXTtcbiAgICAgICAgb1sxXSArPSBvWzJdID4+PiAxNjtcbiAgICAgICAgb1syXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1sxXSArPSBtWzFdICogblszXTtcbiAgICAgICAgb1swXSArPSBvWzFdID4+PiAxNjtcbiAgICAgICAgb1sxXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1sxXSArPSBtWzJdICogblsyXTtcbiAgICAgICAgb1swXSArPSBvWzFdID4+PiAxNjtcbiAgICAgICAgb1sxXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1sxXSArPSBtWzNdICogblsxXTtcbiAgICAgICAgb1swXSArPSBvWzFdID4+PiAxNjtcbiAgICAgICAgb1sxXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1swXSArPSAobVswXSAqIG5bM10pICsgKG1bMV0gKiBuWzJdKSArIChtWzJdICogblsxXSkgKyAobVszXSAqIG5bMF0pO1xuICAgICAgICBvWzBdICY9IDB4ZmZmZjtcblxuICAgICAgICByZXR1cm4gWyhvWzBdIDw8IDE2KSB8IG9bMV0sIChvWzJdIDw8IDE2KSB8IG9bM11dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94NjRSb3RsKG0sIG4pIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSA2NGJpdCBpbnQgKGFzIGFuIGFycmF5IG9mIHR3byAzMmJpdCBpbnRzKSBhbmQgYW4gaW50XG4gICAgICAgIC8vIHJlcHJlc2VudGluZyBhIG51bWJlciBvZiBiaXQgcG9zaXRpb25zLCByZXR1cm5zIHRoZSA2NGJpdCBpbnQgKGFzIGFuXG4gICAgICAgIC8vIGFycmF5IG9mIHR3byAzMmJpdCBpbnRzKSByb3RhdGVkIGxlZnQgYnkgdGhhdCBudW1iZXIgb2YgcG9zaXRpb25zLlxuICAgICAgICAvL1xuXG4gICAgICAgIG4gJT0gNjQ7XG5cbiAgICAgICAgaWYgKG4gPT09IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gW21bMV0sIG1bMF1dO1xuICAgICAgICB9IGVsc2UgaWYgKG4gPCAzMikge1xuICAgICAgICAgICAgcmV0dXJuIFsobVswXSA8PCBuKSB8IChtWzFdID4+PiAoMzIgLSBuKSksIChtWzFdIDw8IG4pIHwgKG1bMF0gPj4+ICgzMiAtIG4pKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuIC09IDMyO1xuICAgICAgICAgICAgcmV0dXJuIFsobVsxXSA8PCBuKSB8IChtWzBdID4+PiAoMzIgLSBuKSksIChtWzBdIDw8IG4pIHwgKG1bMV0gPj4+ICgzMiAtIG4pKV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeDY0TGVmdFNoaWZ0KG0sIG4pIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSA2NGJpdCBpbnQgKGFzIGFuIGFycmF5IG9mIHR3byAzMmJpdCBpbnRzKSBhbmQgYW4gaW50XG4gICAgICAgIC8vIHJlcHJlc2VudGluZyBhIG51bWJlciBvZiBiaXQgcG9zaXRpb25zLCByZXR1cm5zIHRoZSA2NGJpdCBpbnQgKGFzIGFuXG4gICAgICAgIC8vIGFycmF5IG9mIHR3byAzMmJpdCBpbnRzKSBzaGlmdGVkIGxlZnQgYnkgdGhhdCBudW1iZXIgb2YgcG9zaXRpb25zLlxuICAgICAgICAvL1xuXG4gICAgICAgIG4gJT0gNjQ7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9IGVsc2UgaWYgKG4gPCAzMikge1xuICAgICAgICAgICAgcmV0dXJuIFsobVswXSA8PCBuKSB8IChtWzFdID4+PiAoMzIgLSBuKSksIG1bMV0gPDwgbl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW21bMV0gPDwgKG4gLSAzMiksIDBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3g2NFhvcihtLCBuKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIHR3byA2NGJpdCBpbnRzIChhcyBhbiBhcnJheSBvZiB0d28gMzJiaXQgaW50cykgcmV0dXJucyB0aGUgdHdvXG4gICAgICAgIC8vIHhvcmVkIHRvZ2V0aGVyIGFzIGEgNjRiaXQgaW50IChhcyBhbiBhcnJheSBvZiB0d28gMzJiaXQgaW50cykuXG4gICAgICAgIC8vXG5cbiAgICAgICAgcmV0dXJuIFttWzBdIF4gblswXSwgbVsxXSBeIG5bMV1dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94NjRGbWl4KGgpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSBibG9jaywgcmV0dXJucyBtdXJtdXJIYXNoMydzIGZpbmFsIHg2NCBtaXggb2YgdGhhdCBibG9jay5cbiAgICAgICAgLy8gKGBbMCwgaFswXSA+Pj4gMV1gIGlzIGEgMzMgYml0IHVuc2lnbmVkIHJpZ2h0IHNoaWZ0LiBUaGlzIGlzIHRoZVxuICAgICAgICAvLyBvbmx5IHBsYWNlIHdoZXJlIHdlIG5lZWQgdG8gcmlnaHQgc2hpZnQgNjRiaXQgaW50cy4pXG4gICAgICAgIC8vXG5cbiAgICAgICAgaCA9IF94NjRYb3IoaCwgWzAsIGhbMF0gPj4+IDFdKTtcbiAgICAgICAgaCA9IF94NjRNdWx0aXBseShoLCBbMHhmZjUxYWZkNywgMHhlZDU1OGNjZF0pO1xuICAgICAgICBoID0gX3g2NFhvcihoLCBbMCwgaFswXSA+Pj4gMV0pO1xuICAgICAgICBoID0gX3g2NE11bHRpcGx5KGgsIFsweGM0Y2ViOWZlLCAweDFhODVlYzUzXSk7XG4gICAgICAgIGggPSBfeDY0WG9yKGgsIFswLCBoWzBdID4+PiAxXSk7XG5cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfVxuXG4gICAgLy8gUFVCTElDIEZVTkNUSU9OU1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxpYnJhcnkueDg2Lmhhc2gzMiA9IGZ1bmN0aW9uIChrZXksIHNlZWQpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSBzdHJpbmcgYW5kIGFuIG9wdGlvbmFsIHNlZWQgYXMgYW4gaW50LCByZXR1cm5zIGEgMzIgYml0IGhhc2hcbiAgICAgICAgLy8gdXNpbmcgdGhlIHg4NiBmbGF2b3Igb2YgTXVybXVySGFzaDMsIGFzIGFuIHVuc2lnbmVkIGludC5cbiAgICAgICAgLy9cblxuICAgICAgICBrZXkgPSBrZXkgfHwgJyc7XG4gICAgICAgIHNlZWQgPSBzZWVkIHx8IDA7XG5cbiAgICAgICAgdmFyIHJlbWFpbmRlciA9IGtleS5sZW5ndGggJSA0O1xuICAgICAgICB2YXIgYnl0ZXMgPSBrZXkubGVuZ3RoIC0gcmVtYWluZGVyO1xuXG4gICAgICAgIHZhciBoMSA9IHNlZWQ7XG5cbiAgICAgICAgdmFyIGsxID0gMDtcblxuICAgICAgICB2YXIgYzEgPSAweGNjOWUyZDUxO1xuICAgICAgICB2YXIgYzIgPSAweDFiODczNTkzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkgPSBpICsgNCkge1xuICAgICAgICAgICAgazEgPSAoKGtleS5jaGFyQ29kZUF0KGkpICYgMHhmZikpIHwgKChrZXkuY2hhckNvZGVBdChpICsgMSkgJiAweGZmKSA8PCA4KSB8ICgoa2V5LmNoYXJDb2RlQXQoaSArIDIpICYgMHhmZikgPDwgMTYpIHwgKChrZXkuY2hhckNvZGVBdChpICsgMykgJiAweGZmKSA8PCAyNCk7XG5cbiAgICAgICAgICAgIGsxID0gX3g4Nk11bHRpcGx5KGsxLCBjMSk7XG4gICAgICAgICAgICBrMSA9IF94ODZSb3RsKGsxLCAxNSk7XG4gICAgICAgICAgICBrMSA9IF94ODZNdWx0aXBseShrMSwgYzIpO1xuXG4gICAgICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgICAgIGgxID0gX3g4NlJvdGwoaDEsIDEzKTtcbiAgICAgICAgICAgIGgxID0gX3g4Nk11bHRpcGx5KGgxLCA1KSArIDB4ZTY1NDZiNjQ7XG4gICAgICAgIH1cblxuICAgICAgICBrMSA9IDA7XG5cbiAgICAgICAgc3dpdGNoIChyZW1haW5kZXIpIHtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBrMSBePSAoa2V5LmNoYXJDb2RlQXQoaSArIDIpICYgMHhmZikgPDwgMTY7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBrMSBePSAoa2V5LmNoYXJDb2RlQXQoaSArIDEpICYgMHhmZikgPDwgODtcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGsxIF49IChrZXkuY2hhckNvZGVBdChpKSAmIDB4ZmYpO1xuICAgICAgICAgICAgICAgIGsxID0gX3g4Nk11bHRpcGx5KGsxLCBjMSk7XG4gICAgICAgICAgICAgICAgazEgPSBfeDg2Um90bChrMSwgMTUpO1xuICAgICAgICAgICAgICAgIGsxID0gX3g4Nk11bHRpcGx5KGsxLCBjMik7XG4gICAgICAgICAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIH1cblxuICAgICAgICBoMSBePSBrZXkubGVuZ3RoO1xuICAgICAgICBoMSA9IF94ODZGbWl4KGgxKTtcblxuICAgICAgICByZXR1cm4gaDEgPj4+IDA7XG4gICAgfTtcblxuICAgIGxpYnJhcnkueDg2Lmhhc2gxMjggPSBmdW5jdGlvbiAoa2V5LCBzZWVkKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIGEgc3RyaW5nIGFuZCBhbiBvcHRpb25hbCBzZWVkIGFzIGFuIGludCwgcmV0dXJucyBhIDEyOCBiaXRcbiAgICAgICAgLy8gaGFzaCB1c2luZyB0aGUgeDg2IGZsYXZvciBvZiBNdXJtdXJIYXNoMywgYXMgYW4gdW5zaWduZWQgaGV4LlxuICAgICAgICAvL1xuXG4gICAgICAgIGtleSA9IGtleSB8fCAnJztcbiAgICAgICAgc2VlZCA9IHNlZWQgfHwgMDtcblxuICAgICAgICB2YXIgcmVtYWluZGVyID0ga2V5Lmxlbmd0aCAlIDE2O1xuICAgICAgICB2YXIgYnl0ZXMgPSBrZXkubGVuZ3RoIC0gcmVtYWluZGVyO1xuXG4gICAgICAgIHZhciBoMSA9IHNlZWQ7XG4gICAgICAgIHZhciBoMiA9IHNlZWQ7XG4gICAgICAgIHZhciBoMyA9IHNlZWQ7XG4gICAgICAgIHZhciBoNCA9IHNlZWQ7XG5cbiAgICAgICAgdmFyIGsxID0gMDtcbiAgICAgICAgdmFyIGsyID0gMDtcbiAgICAgICAgdmFyIGszID0gMDtcbiAgICAgICAgdmFyIGs0ID0gMDtcblxuICAgICAgICB2YXIgYzEgPSAweDIzOWI5NjFiO1xuICAgICAgICB2YXIgYzIgPSAweGFiMGU5Nzg5O1xuICAgICAgICB2YXIgYzMgPSAweDM4YjM0YWU1O1xuICAgICAgICB2YXIgYzQgPSAweGExZTM4YjkzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkgPSBpICsgMTYpIHtcbiAgICAgICAgICAgIGsxID0gKChrZXkuY2hhckNvZGVBdChpKSAmIDB4ZmYpKSB8ICgoa2V5LmNoYXJDb2RlQXQoaSArIDEpICYgMHhmZikgPDwgOCkgfCAoKGtleS5jaGFyQ29kZUF0KGkgKyAyKSAmIDB4ZmYpIDw8IDE2KSB8ICgoa2V5LmNoYXJDb2RlQXQoaSArIDMpICYgMHhmZikgPDwgMjQpO1xuICAgICAgICAgICAgazIgPSAoKGtleS5jaGFyQ29kZUF0KGkgKyA0KSAmIDB4ZmYpKSB8ICgoa2V5LmNoYXJDb2RlQXQoaSArIDUpICYgMHhmZikgPDwgOCkgfCAoKGtleS5jaGFyQ29kZUF0KGkgKyA2KSAmIDB4ZmYpIDw8IDE2KSB8ICgoa2V5LmNoYXJDb2RlQXQoaSArIDcpICYgMHhmZikgPDwgMjQpO1xuICAgICAgICAgICAgazMgPSAoKGtleS5jaGFyQ29kZUF0KGkgKyA4KSAmIDB4ZmYpKSB8ICgoa2V5LmNoYXJDb2RlQXQoaSArIDkpICYgMHhmZikgPDwgOCkgfCAoKGtleS5jaGFyQ29kZUF0KGkgKyAxMCkgJiAweGZmKSA8PCAxNikgfCAoKGtleS5jaGFyQ29kZUF0KGkgKyAxMSkgJiAweGZmKSA8PCAyNCk7XG4gICAgICAgICAgICBrNCA9ICgoa2V5LmNoYXJDb2RlQXQoaSArIDEyKSAmIDB4ZmYpKSB8ICgoa2V5LmNoYXJDb2RlQXQoaSArIDEzKSAmIDB4ZmYpIDw8IDgpIHwgKChrZXkuY2hhckNvZGVBdChpICsgMTQpICYgMHhmZikgPDwgMTYpIHwgKChrZXkuY2hhckNvZGVBdChpICsgMTUpICYgMHhmZikgPDwgMjQpO1xuXG4gICAgICAgICAgICBrMSA9IF94ODZNdWx0aXBseShrMSwgYzEpO1xuICAgICAgICAgICAgazEgPSBfeDg2Um90bChrMSwgMTUpO1xuICAgICAgICAgICAgazEgPSBfeDg2TXVsdGlwbHkoazEsIGMyKTtcbiAgICAgICAgICAgIGgxIF49IGsxO1xuXG4gICAgICAgICAgICBoMSA9IF94ODZSb3RsKGgxLCAxOSk7XG4gICAgICAgICAgICBoMSArPSBoMjtcbiAgICAgICAgICAgIGgxID0gX3g4Nk11bHRpcGx5KGgxLCA1KSArIDB4NTYxY2NkMWI7XG5cbiAgICAgICAgICAgIGsyID0gX3g4Nk11bHRpcGx5KGsyLCBjMik7XG4gICAgICAgICAgICBrMiA9IF94ODZSb3RsKGsyLCAxNik7XG4gICAgICAgICAgICBrMiA9IF94ODZNdWx0aXBseShrMiwgYzMpO1xuICAgICAgICAgICAgaDIgXj0gazI7XG5cbiAgICAgICAgICAgIGgyID0gX3g4NlJvdGwoaDIsIDE3KTtcbiAgICAgICAgICAgIGgyICs9IGgzO1xuICAgICAgICAgICAgaDIgPSBfeDg2TXVsdGlwbHkoaDIsIDUpICsgMHgwYmNhYTc0NztcblxuICAgICAgICAgICAgazMgPSBfeDg2TXVsdGlwbHkoazMsIGMzKTtcbiAgICAgICAgICAgIGszID0gX3g4NlJvdGwoazMsIDE3KTtcbiAgICAgICAgICAgIGszID0gX3g4Nk11bHRpcGx5KGszLCBjNCk7XG4gICAgICAgICAgICBoMyBePSBrMztcblxuICAgICAgICAgICAgaDMgPSBfeDg2Um90bChoMywgMTUpO1xuICAgICAgICAgICAgaDMgKz0gaDQ7XG4gICAgICAgICAgICBoMyA9IF94ODZNdWx0aXBseShoMywgNSkgKyAweDk2Y2QxYzM1O1xuXG4gICAgICAgICAgICBrNCA9IF94ODZNdWx0aXBseShrNCwgYzQpO1xuICAgICAgICAgICAgazQgPSBfeDg2Um90bChrNCwgMTgpO1xuICAgICAgICAgICAgazQgPSBfeDg2TXVsdGlwbHkoazQsIGMxKTtcbiAgICAgICAgICAgIGg0IF49IGs0O1xuXG4gICAgICAgICAgICBoNCA9IF94ODZSb3RsKGg0LCAxMyk7XG4gICAgICAgICAgICBoNCArPSBoMTtcbiAgICAgICAgICAgIGg0ID0gX3g4Nk11bHRpcGx5KGg0LCA1KSArIDB4MzJhYzNiMTc7XG4gICAgICAgIH1cblxuICAgICAgICBrMSA9IDA7XG4gICAgICAgIGsyID0gMDtcbiAgICAgICAgazMgPSAwO1xuICAgICAgICBrNCA9IDA7XG5cbiAgICAgICAgc3dpdGNoIChyZW1haW5kZXIpIHtcbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgazQgXj0ga2V5LmNoYXJDb2RlQXQoaSArIDE0KSA8PCAxNjtcblxuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBrNCBePSBrZXkuY2hhckNvZGVBdChpICsgMTMpIDw8IDg7XG5cbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgazQgXj0ga2V5LmNoYXJDb2RlQXQoaSArIDEyKTtcbiAgICAgICAgICAgICAgICBrNCA9IF94ODZNdWx0aXBseShrNCwgYzQpO1xuICAgICAgICAgICAgICAgIGs0ID0gX3g4NlJvdGwoazQsIDE4KTtcbiAgICAgICAgICAgICAgICBrNCA9IF94ODZNdWx0aXBseShrNCwgYzEpO1xuICAgICAgICAgICAgICAgIGg0IF49IGs0O1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIGszIF49IGtleS5jaGFyQ29kZUF0KGkgKyAxMSkgPDwgMjQ7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgazMgXj0ga2V5LmNoYXJDb2RlQXQoaSArIDEwKSA8PCAxNjtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBrMyBePSBrZXkuY2hhckNvZGVBdChpICsgOSkgPDwgODtcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIGszIF49IGtleS5jaGFyQ29kZUF0KGkgKyA4KTtcbiAgICAgICAgICAgICAgICBrMyA9IF94ODZNdWx0aXBseShrMywgYzMpO1xuICAgICAgICAgICAgICAgIGszID0gX3g4NlJvdGwoazMsIDE3KTtcbiAgICAgICAgICAgICAgICBrMyA9IF94ODZNdWx0aXBseShrMywgYzQpO1xuICAgICAgICAgICAgICAgIGgzIF49IGszO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgazIgXj0ga2V5LmNoYXJDb2RlQXQoaSArIDcpIDw8IDI0O1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgazIgXj0ga2V5LmNoYXJDb2RlQXQoaSArIDYpIDw8IDE2O1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgazIgXj0ga2V5LmNoYXJDb2RlQXQoaSArIDUpIDw8IDg7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBrMiBePSBrZXkuY2hhckNvZGVBdChpICsgNCk7XG4gICAgICAgICAgICAgICAgazIgPSBfeDg2TXVsdGlwbHkoazIsIGMyKTtcbiAgICAgICAgICAgICAgICBrMiA9IF94ODZSb3RsKGsyLCAxNik7XG4gICAgICAgICAgICAgICAgazIgPSBfeDg2TXVsdGlwbHkoazIsIGMzKTtcbiAgICAgICAgICAgICAgICBoMiBePSBrMjtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGsxIF49IGtleS5jaGFyQ29kZUF0KGkgKyAzKSA8PCAyNDtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGsxIF49IGtleS5jaGFyQ29kZUF0KGkgKyAyKSA8PCAxNjtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGsxIF49IGtleS5jaGFyQ29kZUF0KGkgKyAxKSA8PCA4O1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgazEgXj0ga2V5LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgazEgPSBfeDg2TXVsdGlwbHkoazEsIGMxKTtcbiAgICAgICAgICAgICAgICBrMSA9IF94ODZSb3RsKGsxLCAxNSk7XG4gICAgICAgICAgICAgICAgazEgPSBfeDg2TXVsdGlwbHkoazEsIGMyKTtcbiAgICAgICAgICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxIF49IGtleS5sZW5ndGg7XG4gICAgICAgIGgyIF49IGtleS5sZW5ndGg7XG4gICAgICAgIGgzIF49IGtleS5sZW5ndGg7XG4gICAgICAgIGg0IF49IGtleS5sZW5ndGg7XG5cbiAgICAgICAgaDEgKz0gaDI7XG4gICAgICAgIGgxICs9IGgzO1xuICAgICAgICBoMSArPSBoNDtcbiAgICAgICAgaDIgKz0gaDE7XG4gICAgICAgIGgzICs9IGgxO1xuICAgICAgICBoNCArPSBoMTtcblxuICAgICAgICBoMSA9IF94ODZGbWl4KGgxKTtcbiAgICAgICAgaDIgPSBfeDg2Rm1peChoMik7XG4gICAgICAgIGgzID0gX3g4NkZtaXgoaDMpO1xuICAgICAgICBoNCA9IF94ODZGbWl4KGg0KTtcblxuICAgICAgICBoMSArPSBoMjtcbiAgICAgICAgaDEgKz0gaDM7XG4gICAgICAgIGgxICs9IGg0O1xuICAgICAgICBoMiArPSBoMTtcbiAgICAgICAgaDMgKz0gaDE7XG4gICAgICAgIGg0ICs9IGgxO1xuXG4gICAgICAgIHJldHVybiAoXCIwMDAwMDAwMFwiICsgKGgxID4+PiAwKS50b1N0cmluZygxNikpLnNsaWNlKC04KSArIChcIjAwMDAwMDAwXCIgKyAoaDIgPj4+IDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTgpICsgKFwiMDAwMDAwMDBcIiArIChoMyA+Pj4gMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtOCkgKyAoXCIwMDAwMDAwMFwiICsgKGg0ID4+PiAwKS50b1N0cmluZygxNikpLnNsaWNlKC04KTtcbiAgICB9O1xuXG4gICAgbGlicmFyeS54NjQuaGFzaDEyOCA9IGZ1bmN0aW9uIChrZXksIHNlZWQpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSBzdHJpbmcgYW5kIGFuIG9wdGlvbmFsIHNlZWQgYXMgYW4gaW50LCByZXR1cm5zIGEgMTI4IGJpdFxuICAgICAgICAvLyBoYXNoIHVzaW5nIHRoZSB4NjQgZmxhdm9yIG9mIE11cm11ckhhc2gzLCBhcyBhbiB1bnNpZ25lZCBoZXguXG4gICAgICAgIC8vXG5cbiAgICAgICAga2V5ID0ga2V5IHx8ICcnO1xuICAgICAgICBzZWVkID0gc2VlZCB8fCAwO1xuXG4gICAgICAgIHZhciByZW1haW5kZXIgPSBrZXkubGVuZ3RoICUgMTY7XG4gICAgICAgIHZhciBieXRlcyA9IGtleS5sZW5ndGggLSByZW1haW5kZXI7XG5cbiAgICAgICAgdmFyIGgxID0gWzAsIHNlZWRdO1xuICAgICAgICB2YXIgaDIgPSBbMCwgc2VlZF07XG5cbiAgICAgICAgdmFyIGsxID0gWzAsIDBdO1xuICAgICAgICB2YXIgazIgPSBbMCwgMF07XG5cbiAgICAgICAgdmFyIGMxID0gWzB4ODdjMzdiOTEsIDB4MTE0MjUzZDVdO1xuICAgICAgICB2YXIgYzIgPSBbMHg0Y2Y1YWQ0MywgMHgyNzQ1OTM3Zl07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlczsgaSA9IGkgKyAxNikge1xuICAgICAgICAgICAgazEgPSBbKChrZXkuY2hhckNvZGVBdChpICsgNCkgJiAweGZmKSkgfCAoKGtleS5jaGFyQ29kZUF0KGkgKyA1KSAmIDB4ZmYpIDw8IDgpIHwgKChrZXkuY2hhckNvZGVBdChpICsgNikgJiAweGZmKSA8PCAxNikgfCAoKGtleS5jaGFyQ29kZUF0KGkgKyA3KSAmIDB4ZmYpIDw8IDI0KSwgKChrZXkuY2hhckNvZGVBdChpKSAmIDB4ZmYpKSB8ICgoa2V5LmNoYXJDb2RlQXQoaSArIDEpICZcbiAgICAgICAgICAgICAgICAweGZmKSA8PCA4KSB8ICgoa2V5LmNoYXJDb2RlQXQoaSArIDIpICYgMHhmZikgPDwgMTYpIHwgKChrZXkuY2hhckNvZGVBdChpICsgMykgJiAweGZmKSA8PCAyNCldO1xuICAgICAgICAgICAgazIgPSBbKChrZXkuY2hhckNvZGVBdChpICsgMTIpICYgMHhmZikpIHwgKChrZXkuY2hhckNvZGVBdChpICsgMTMpICYgMHhmZikgPDwgOCkgfCAoKGtleS5jaGFyQ29kZUF0KGkgKyAxNCkgJiAweGZmKSA8PCAxNikgfCAoKGtleS5jaGFyQ29kZUF0KGkgKyAxNSkgJiAweGZmKSA8PCAyNCksICgoa2V5LmNoYXJDb2RlQXQoaSArIDgpICYgMHhmZikpIHwgKChrZXkuY2hhckNvZGVBdChpICtcbiAgICAgICAgICAgICAgICA5KSAmIDB4ZmYpIDw8IDgpIHwgKChrZXkuY2hhckNvZGVBdChpICsgMTApICYgMHhmZikgPDwgMTYpIHwgKChrZXkuY2hhckNvZGVBdChpICsgMTEpICYgMHhmZikgPDwgMjQpXTtcblxuICAgICAgICAgICAgazEgPSBfeDY0TXVsdGlwbHkoazEsIGMxKTtcbiAgICAgICAgICAgIGsxID0gX3g2NFJvdGwoazEsIDMxKTtcbiAgICAgICAgICAgIGsxID0gX3g2NE11bHRpcGx5KGsxLCBjMik7XG4gICAgICAgICAgICBoMSA9IF94NjRYb3IoaDEsIGsxKTtcblxuICAgICAgICAgICAgaDEgPSBfeDY0Um90bChoMSwgMjcpO1xuICAgICAgICAgICAgaDEgPSBfeDY0QWRkKGgxLCBoMik7XG4gICAgICAgICAgICBoMSA9IF94NjRBZGQoX3g2NE11bHRpcGx5KGgxLCBbMCwgNV0pLCBbMCwgMHg1MmRjZTcyOV0pO1xuXG4gICAgICAgICAgICBrMiA9IF94NjRNdWx0aXBseShrMiwgYzIpO1xuICAgICAgICAgICAgazIgPSBfeDY0Um90bChrMiwgMzMpO1xuICAgICAgICAgICAgazIgPSBfeDY0TXVsdGlwbHkoazIsIGMxKTtcbiAgICAgICAgICAgIGgyID0gX3g2NFhvcihoMiwgazIpO1xuXG4gICAgICAgICAgICBoMiA9IF94NjRSb3RsKGgyLCAzMSk7XG4gICAgICAgICAgICBoMiA9IF94NjRBZGQoaDIsIGgxKTtcbiAgICAgICAgICAgIGgyID0gX3g2NEFkZChfeDY0TXVsdGlwbHkoaDIsIFswLCA1XSksIFswLCAweDM4NDk1YWI1XSk7XG4gICAgICAgIH1cblxuICAgICAgICBrMSA9IFswLCAwXTtcbiAgICAgICAgazIgPSBbMCwgMF07XG5cbiAgICAgICAgc3dpdGNoIChyZW1haW5kZXIpIHtcbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgazIgPSBfeDY0WG9yKGsyLCBfeDY0TGVmdFNoaWZ0KFswLCBrZXkuY2hhckNvZGVBdChpICsgMTQpXSwgNDgpKTtcblxuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRYb3IoazIsIF94NjRMZWZ0U2hpZnQoWzAsIGtleS5jaGFyQ29kZUF0KGkgKyAxMyldLCA0MCkpO1xuXG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgIGsyID0gX3g2NFhvcihrMiwgX3g2NExlZnRTaGlmdChbMCwga2V5LmNoYXJDb2RlQXQoaSArIDEyKV0sIDMyKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgazIgPSBfeDY0WG9yKGsyLCBfeDY0TGVmdFNoaWZ0KFswLCBrZXkuY2hhckNvZGVBdChpICsgMTEpXSwgMjQpKTtcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRYb3IoazIsIF94NjRMZWZ0U2hpZnQoWzAsIGtleS5jaGFyQ29kZUF0KGkgKyAxMCldLCAxNikpO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIGsyID0gX3g2NFhvcihrMiwgX3g2NExlZnRTaGlmdChbMCwga2V5LmNoYXJDb2RlQXQoaSArIDkpXSwgOCkpO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgazIgPSBfeDY0WG9yKGsyLCBbMCwga2V5LmNoYXJDb2RlQXQoaSArIDgpXSk7XG4gICAgICAgICAgICAgICAgazIgPSBfeDY0TXVsdGlwbHkoazIsIGMyKTtcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRSb3RsKGsyLCAzMyk7XG4gICAgICAgICAgICAgICAgazIgPSBfeDY0TXVsdGlwbHkoazIsIGMxKTtcbiAgICAgICAgICAgICAgICBoMiA9IF94NjRYb3IoaDIsIGsyKTtcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGsxID0gX3g2NFhvcihrMSwgX3g2NExlZnRTaGlmdChbMCwga2V5LmNoYXJDb2RlQXQoaSArIDcpXSwgNTYpKTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGsxID0gX3g2NFhvcihrMSwgX3g2NExlZnRTaGlmdChbMCwga2V5LmNoYXJDb2RlQXQoaSArIDYpXSwgNDgpKTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGsxID0gX3g2NFhvcihrMSwgX3g2NExlZnRTaGlmdChbMCwga2V5LmNoYXJDb2RlQXQoaSArIDUpXSwgNDApKTtcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGsxID0gX3g2NFhvcihrMSwgX3g2NExlZnRTaGlmdChbMCwga2V5LmNoYXJDb2RlQXQoaSArIDQpXSwgMzIpKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGsxID0gX3g2NFhvcihrMSwgX3g2NExlZnRTaGlmdChbMCwga2V5LmNoYXJDb2RlQXQoaSArIDMpXSwgMjQpKTtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGsxID0gX3g2NFhvcihrMSwgX3g2NExlZnRTaGlmdChbMCwga2V5LmNoYXJDb2RlQXQoaSArIDIpXSwgMTYpKTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGsxID0gX3g2NFhvcihrMSwgX3g2NExlZnRTaGlmdChbMCwga2V5LmNoYXJDb2RlQXQoaSArIDEpXSwgOCkpO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBbMCwga2V5LmNoYXJDb2RlQXQoaSldKTtcbiAgICAgICAgICAgICAgICBrMSA9IF94NjRNdWx0aXBseShrMSwgYzEpO1xuICAgICAgICAgICAgICAgIGsxID0gX3g2NFJvdGwoazEsIDMxKTtcbiAgICAgICAgICAgICAgICBrMSA9IF94NjRNdWx0aXBseShrMSwgYzIpO1xuICAgICAgICAgICAgICAgIGgxID0gX3g2NFhvcihoMSwgazEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaDEgPSBfeDY0WG9yKGgxLCBbMCwga2V5Lmxlbmd0aF0pO1xuICAgICAgICBoMiA9IF94NjRYb3IoaDIsIFswLCBrZXkubGVuZ3RoXSk7XG5cbiAgICAgICAgaDEgPSBfeDY0QWRkKGgxLCBoMik7XG4gICAgICAgIGgyID0gX3g2NEFkZChoMiwgaDEpO1xuXG4gICAgICAgIGgxID0gX3g2NEZtaXgoaDEpO1xuICAgICAgICBoMiA9IF94NjRGbWl4KGgyKTtcblxuICAgICAgICBoMSA9IF94NjRBZGQoaDEsIGgyKTtcbiAgICAgICAgaDIgPSBfeDY0QWRkKGgyLCBoMSk7XG5cbiAgICAgICAgcmV0dXJuIChcIjAwMDAwMDAwXCIgKyAoaDFbMF0gPj4+IDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTgpICsgKFwiMDAwMDAwMDBcIiArIChoMVsxXSA+Pj4gMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtOCkgKyAoXCIwMDAwMDAwMFwiICsgKGgyWzBdID4+PiAwKS50b1N0cmluZygxNikpLnNsaWNlKC04KSArIChcIjAwMDAwMDAwXCIgKyAoaDJbMV0gPj4+IDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTgpO1xuICAgIH07XG5cbiAgICAvLyBJTklUSUFMSVpBVElPTlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBFeHBvcnQgbXVybXVySGFzaDMgZm9yIENvbW1vbkpTLCBlaXRoZXIgYXMgYW4gQU1EIG1vZHVsZSBvciBqdXN0IGFzIHBhcnRcbiAgICAvLyBvZiB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBsaWJyYXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwb3J0cy5tdXJtdXJIYXNoMyA9IGxpYnJhcnk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpYnJhcnk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gVXNlIG11cm11ckhhc2gzLm5vQ29uZmxpY3QgdG8gcmVzdG9yZSBgbXVybXVySGFzaDNgIGJhY2sgdG8gaXRzXG4gICAgICAgIC8vIG9yaWdpbmFsIHZhbHVlLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBsaWJyYXJ5IG9iamVjdCwgdG8gYWxsb3dcbiAgICAgICAgLy8gaXQgdG8gYmUgdXNlZCB1bmRlciBhIGRpZmZlcmVudCBuYW1lLlxuICAgICAgICBsaWJyYXJ5Ll9tdXJtdXJIYXNoMyA9IHJvb3QubXVybXVySGFzaDM7XG5cbiAgICAgICAgbGlicmFyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcm9vdC5tdXJtdXJIYXNoMyA9IGxpYnJhcnkuX211cm11ckhhc2gzO1xuICAgICAgICAgICAgbGlicmFyeS5fbXVybXVySGFzaDMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsaWJyYXJ5Lm5vQ29uZmxpY3QgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHJldHVybiBsaWJyYXJ5O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJvb3QubXVybXVySGFzaDMgPSBsaWJyYXJ5O1xuICAgIH1cbn0pKHRoaXMpO1xuIiwidmFyIGIyYiA9IHJlcXVpcmUoJy4vYmxha2UyYicpXG52YXIgYjJzID0gcmVxdWlyZSgnLi9ibGFrZTJzJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJsYWtlMmI6IGIyYi5ibGFrZTJiLFxuICBibGFrZTJiSGV4OiBiMmIuYmxha2UyYkhleCxcbiAgYmxha2UyYkluaXQ6IGIyYi5ibGFrZTJiSW5pdCxcbiAgYmxha2UyYlVwZGF0ZTogYjJiLmJsYWtlMmJVcGRhdGUsXG4gIGJsYWtlMmJGaW5hbDogYjJiLmJsYWtlMmJGaW5hbCxcbiAgYmxha2UyczogYjJzLmJsYWtlMnMsXG4gIGJsYWtlMnNIZXg6IGIycy5ibGFrZTJzSGV4LFxuICBibGFrZTJzSW5pdDogYjJzLmJsYWtlMnNJbml0LFxuICBibGFrZTJzVXBkYXRlOiBiMnMuYmxha2Uyc1VwZGF0ZSxcbiAgYmxha2Uyc0ZpbmFsOiBiMnMuYmxha2Uyc0ZpbmFsXG59XG4iLCJ2YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ3Byb21pc2UnKTtcbnZhciBpc1Byb21pc2UgPSByZXF1aXJlKCdpcy1wcm9taXNlJyk7XG5cbnZhciBuZXh0VGljaztcbmlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSBuZXh0VGljayA9IHNldEltbWVkaWF0ZVxuZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5uZXh0VGljaykgbmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrXG5lbHNlIG5leHRUaWNrID0gZnVuY3Rpb24gKGNiKSB7IHNldFRpbWVvdXQoY2IsIDApIH1cblxubW9kdWxlLmV4cG9ydHMgPSBub2RlaWZ5O1xuZnVuY3Rpb24gbm9kZWlmeShwcm9taXNlLCBjYikge1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gcHJvbWlzZTtcbiAgcmV0dXJuIHByb21pc2VcbiAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNiKG51bGwsIHJlcyk7XG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vZGVpZnlUaGlzKGNiKSB7XG4gIHJldHVybiBub2RlaWZ5KHRoaXMsIGNiKTtcbn1cblxubm9kZWlmeS5leHRlbmQgPSBleHRlbmQ7XG5ub2RlaWZ5LlByb21pc2UgPSBOb2RlaWZ5UHJvbWlzZTtcblxuZnVuY3Rpb24gZXh0ZW5kKHByb20pIHtcbiAgaWYgKHByb20gJiYgaXNQcm9taXNlKHByb20pKSB7XG4gICAgcHJvbS5ub2RlaWZ5ID0gbm9kZWlmeVRoaXM7XG4gICAgdmFyIHRoZW4gPSBwcm9tLnRoZW47XG4gICAgcHJvbS50aGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgcmV0dXJuIHByb207XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb20gPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9tLnByb3RvdHlwZS5ub2RlaWZ5ID0gbm9kZWlmeVRoaXM7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IG5vZGVpZnlUaGlzO1xuICB9XG59XG5cbmZ1bmN0aW9uIE5vZGVpZnlQcm9taXNlKGZuKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOb2RlaWZ5UHJvbWlzZSkpIHtcbiAgICByZXR1cm4gbmV3IE5vZGVpZnlQcm9taXNlKGZuKTtcbiAgfVxuICBQcm9taXNlLmNhbGwodGhpcywgZm4pO1xuICBleHRlbmQodGhpcyk7XG59XG5cbk5vZGVpZnlQcm9taXNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuTm9kZWlmeVByb21pc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTm9kZWlmeVByb21pc2U7IiwiLyoqXG4gKiBIYXNoLWJhc2VkIE1lc3NhZ2UgQXV0aGVudGljYXRpb24gQ29kZSBpbXBsZW1lbnRhdGlvbi4gUmVxdWlyZXMgYSBtZXNzYWdlXG4gKiBkaWdlc3Qgb2JqZWN0IHRoYXQgY2FuIGJlIG9idGFpbmVkLCBmb3IgZXhhbXBsZSwgZnJvbSBmb3JnZS5tZC5zaGExIG9yXG4gKiBmb3JnZS5tZC5tZDUuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMiBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL21kJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuLyogSE1BQyBBUEkgKi9cbnZhciBobWFjID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5obWFjID0gZm9yZ2UuaG1hYyB8fCB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIEhNQUMgb2JqZWN0IHRoYXQgdXNlcyB0aGUgZ2l2ZW4gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICpcbiAqIEByZXR1cm4gYW4gSE1BQyBvYmplY3QuXG4gKi9cbmhtYWMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIHRoZSBobWFjIGtleSB0byB1c2VcbiAgdmFyIF9rZXkgPSBudWxsO1xuXG4gIC8vIHRoZSBtZXNzYWdlIGRpZ2VzdCB0byB1c2VcbiAgdmFyIF9tZCA9IG51bGw7XG5cbiAgLy8gdGhlIGlubmVyIHBhZGRpbmdcbiAgdmFyIF9pcGFkZGluZyA9IG51bGw7XG5cbiAgLy8gdGhlIG91dGVyIHBhZGRpbmdcbiAgdmFyIF9vcGFkZGluZyA9IG51bGw7XG5cbiAgLy8gaG1hYyBjb250ZXh0XG4gIHZhciBjdHggPSB7fTtcblxuICAvKipcbiAgICogU3RhcnRzIG9yIHJlc3RhcnRzIHRoZSBITUFDIHdpdGggdGhlIGdpdmVuIGtleSBhbmQgbWVzc2FnZSBkaWdlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3QgdG8gdXNlLCBudWxsIHRvIHJldXNlIHRoZSBwcmV2aW91cyBvbmUsXG4gICAqICAgICAgICAgICBhIHN0cmluZyB0byB1c2UgYnVpbHRpbiAnc2hhMScsICdtZDUnLCAnc2hhMjU2Jy5cbiAgICogQHBhcmFtIGtleSB0aGUga2V5IHRvIHVzZSBhcyBhIHN0cmluZywgYXJyYXkgb2YgYnl0ZXMsIGJ5dGUgYnVmZmVyLFxuICAgKiAgICAgICAgICAgb3IgbnVsbCB0byByZXVzZSB0aGUgcHJldmlvdXMga2V5LlxuICAgKi9cbiAgY3R4LnN0YXJ0ID0gZnVuY3Rpb24obWQsIGtleSkge1xuICAgIGlmKG1kICE9PSBudWxsKSB7XG4gICAgICBpZih0eXBlb2YgbWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBidWlsdGluIG1lc3NhZ2UgZGlnZXN0XG4gICAgICAgIG1kID0gbWQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYobWQgaW4gZm9yZ2UubWQuYWxnb3JpdGhtcykge1xuICAgICAgICAgIF9tZCA9IGZvcmdlLm1kLmFsZ29yaXRobXNbbWRdLmNyZWF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBoYXNoIGFsZ29yaXRobSBcIicgKyBtZCArICdcIicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdG9yZSBtZXNzYWdlIGRpZ2VzdFxuICAgICAgICBfbWQgPSBtZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihrZXkgPT09IG51bGwpIHtcbiAgICAgIC8vIHJldXNlIHByZXZpb3VzIGtleVxuICAgICAga2V5ID0gX2tleTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gY29udmVydCBzdHJpbmcgaW50byBieXRlIGJ1ZmZlclxuICAgICAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICAgICAgfSBlbHNlIGlmKGZvcmdlLnV0aWwuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgYnl0ZSBhcnJheSBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgICAgIHZhciB0bXAgPSBrZXk7XG4gICAgICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkucHV0Qnl0ZSh0bXBbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGtleSBpcyBsb25nZXIgdGhhbiBibG9ja3NpemUsIGhhc2ggaXRcbiAgICAgIHZhciBrZXlsZW4gPSBrZXkubGVuZ3RoKCk7XG4gICAgICBpZihrZXlsZW4gPiBfbWQuYmxvY2tMZW5ndGgpIHtcbiAgICAgICAgX21kLnN0YXJ0KCk7XG4gICAgICAgIF9tZC51cGRhdGUoa2V5LmJ5dGVzKCkpO1xuICAgICAgICBrZXkgPSBfbWQuZGlnZXN0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1peCBrZXkgaW50byBpbm5lciBhbmQgb3V0ZXIgcGFkZGluZ1xuICAgICAgLy8gaXBhZGRpbmcgPSBbMHgzNiAqIGJsb2Nrc2l6ZV0gXiBrZXlcbiAgICAgIC8vIG9wYWRkaW5nID0gWzB4NUMgKiBibG9ja3NpemVdIF4ga2V5XG4gICAgICBfaXBhZGRpbmcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgX29wYWRkaW5nID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGtleWxlbiA9IGtleS5sZW5ndGgoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBrZXlsZW47ICsraSkge1xuICAgICAgICB2YXIgdG1wID0ga2V5LmF0KGkpO1xuICAgICAgICBfaXBhZGRpbmcucHV0Qnl0ZSgweDM2IF4gdG1wKTtcbiAgICAgICAgX29wYWRkaW5nLnB1dEJ5dGUoMHg1QyBeIHRtcCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGtleSBpcyBzaG9ydGVyIHRoYW4gYmxvY2tzaXplLCBhZGQgYWRkaXRpb25hbCBwYWRkaW5nXG4gICAgICBpZihrZXlsZW4gPCBfbWQuYmxvY2tMZW5ndGgpIHtcbiAgICAgICAgdmFyIHRtcCA9IF9tZC5ibG9ja0xlbmd0aCAtIGtleWxlbjtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcDsgKytpKSB7XG4gICAgICAgICAgX2lwYWRkaW5nLnB1dEJ5dGUoMHgzNik7XG4gICAgICAgICAgX29wYWRkaW5nLnB1dEJ5dGUoMHg1Qyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9rZXkgPSBrZXk7XG4gICAgICBfaXBhZGRpbmcgPSBfaXBhZGRpbmcuYnl0ZXMoKTtcbiAgICAgIF9vcGFkZGluZyA9IF9vcGFkZGluZy5ieXRlcygpO1xuICAgIH1cblxuICAgIC8vIGRpZ2VzdCBpcyBkb25lIGxpa2Ugc286IGhhc2gob3BhZGRpbmcgfCBoYXNoKGlwYWRkaW5nIHwgbWVzc2FnZSkpXG5cbiAgICAvLyBwcmVwYXJlIHRvIGRvIGlubmVyIGhhc2hcbiAgICAvLyBoYXNoKGlwYWRkaW5nIHwgbWVzc2FnZSlcbiAgICBfbWQuc3RhcnQoKTtcbiAgICBfbWQudXBkYXRlKF9pcGFkZGluZyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIEhNQUMgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byB1cGRhdGUgd2l0aC5cbiAgICovXG4gIGN0eC51cGRhdGUgPSBmdW5jdGlvbihieXRlcykge1xuICAgIF9tZC51cGRhdGUoYnl0ZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyB0aGUgTWVzc2FnZSBBdXRoZW50aWNhdGlvbiBDb2RlIChNQUMpLlxuICAgKlxuICAgKiBAcmV0dXJuIGEgYnl0ZSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0IHZhbHVlLlxuICAgKi9cbiAgY3R4LmdldE1hYyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGRpZ2VzdCBpcyBkb25lIGxpa2Ugc286IGhhc2gob3BhZGRpbmcgfCBoYXNoKGlwYWRkaW5nIHwgbWVzc2FnZSkpXG4gICAgLy8gaGVyZSB3ZSBkbyB0aGUgb3V0ZXIgaGFzaGluZ1xuICAgIHZhciBpbm5lciA9IF9tZC5kaWdlc3QoKS5ieXRlcygpO1xuICAgIF9tZC5zdGFydCgpO1xuICAgIF9tZC51cGRhdGUoX29wYWRkaW5nKTtcbiAgICBfbWQudXBkYXRlKGlubmVyKTtcbiAgICByZXR1cm4gX21kLmRpZ2VzdCgpO1xuICB9O1xuICAvLyBhbGlhcyBmb3IgZ2V0TWFjXG4gIGN0eC5kaWdlc3QgPSBjdHguZ2V0TWFjO1xuXG4gIHJldHVybiBjdHg7XG59O1xuIiwiLyoqXG4gKiBCYXNlLU4vQmFzZS1YIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBPcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBmcm9tIGJhc2UteDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYmFzZS14XG4gKlxuICogV2hpY2ggaXMgTUlUIGxpY2Vuc2VkOlxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCBiYXNlLXggY29udHJpYnV0b3JzIChjKSAyMDE2XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xudmFyIGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8vIGJhc2VOIGFscGhhYmV0IGluZGV4ZXNcbnZhciBfcmV2ZXJzZUFscGhhYmV0cyA9IHt9O1xuXG4vKipcbiAqIEJhc2VOLWVuY29kZXMgYSBVaW50OEFycmF5IHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2VOLWVuY29kZWQgb3V0cHV0IHN0cmluZy5cbiAqL1xuYXBpLmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBhbHBoYWJldCwgbWF4bGluZSkge1xuICBpZih0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cbiAgaWYobWF4bGluZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBtYXhsaW5lICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibWF4bGluZVwiIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gIH1cblxuICB2YXIgb3V0cHV0ID0gJyc7XG5cbiAgaWYoIShpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgLy8gYXNzdW1lIGZvcmdlIGJ5dGUgYnVmZmVyXG4gICAgb3V0cHV0ID0gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgICB2YXIgZGlnaXRzID0gWzBdO1xuICAgIGZvcihpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0W2ldOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4O1xuICAgICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIGJhc2U7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgICAgfVxuXG4gICAgICB3aGlsZShjYXJyeSA+IDApIHtcbiAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBiYXNlKSB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICBmb3IoaSA9IDA7IGlucHV0W2ldID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG91dHB1dCArPSBmaXJzdDtcbiAgICB9XG4gICAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgICBmb3IoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgb3V0cHV0ICs9IGFscGhhYmV0W2RpZ2l0c1tpXV07XG4gICAgfVxuICB9XG5cbiAgaWYobWF4bGluZSkge1xuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJy57MSwnICsgbWF4bGluZSArICd9JywgJ2cnKTtcbiAgICBvdXRwdXQgPSBvdXRwdXQubWF0Y2gocmVnZXgpLmpvaW4oJ1xcclxcbicpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJhc2VOLWVuY29kZWQgKHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldCkgc3RyaW5nIHRvIGFcbiAqIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlTi1lbmNvZGVkIGlucHV0IHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5LlxuICovXG5hcGkuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIGFscGhhYmV0KSB7XG4gIGlmKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlucHV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgfVxuICBpZih0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICB2YXIgdGFibGUgPSBfcmV2ZXJzZUFscGhhYmV0c1thbHBoYWJldF07XG4gIGlmKCF0YWJsZSkge1xuICAgIC8vIGNvbXB1dGUgcmV2ZXJzZSBhbHBoYWJldFxuICAgIHRhYmxlID0gX3JldmVyc2VBbHBoYWJldHNbYWxwaGFiZXRdID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB0YWJsZVthbHBoYWJldC5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgdmFyIGJhc2UgPSBhbHBoYWJldC5sZW5ndGg7XG4gIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgdmFyIGJ5dGVzID0gWzBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsdWUgPSB0YWJsZVtpbnB1dC5jaGFyQ29kZUF0KGkpXTtcbiAgICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yKHZhciBqID0gMCwgY2FycnkgPSB2YWx1ZTsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjYXJyeSArPSBieXRlc1tqXSAqIGJhc2U7XG4gICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZjtcbiAgICAgIGNhcnJ5ID4+PSA4O1xuICAgIH1cblxuICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpO1xuICAgICAgY2FycnkgPj49IDg7XG4gICAgfVxuICB9XG5cbiAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgZm9yKHZhciBrID0gMDsgaW5wdXRba10gPT09IGZpcnN0ICYmIGsgPCBpbnB1dC5sZW5ndGggLSAxOyArK2spIHtcbiAgICBieXRlcy5wdXNoKDApO1xuICB9XG5cbiAgaWYodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMucmV2ZXJzZSgpKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcy5yZXZlcnNlKCkpO1xufTtcblxuZnVuY3Rpb24gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCkge1xuICB2YXIgaSA9IDA7XG4gIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICB2YXIgZmlyc3QgPSBhbHBoYWJldC5jaGFyQXQoMCk7XG4gIHZhciBkaWdpdHMgPSBbMF07XG4gIGZvcihpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCgpOyArK2kpIHtcbiAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0LmF0KGkpOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgODtcbiAgICAgIGRpZ2l0c1tqXSA9IGNhcnJ5ICUgYmFzZTtcbiAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgIH1cblxuICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXQgPSAnJztcblxuICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICBmb3IoaSA9IDA7IGlucHV0LmF0KGkpID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGgoKSAtIDE7ICsraSkge1xuICAgIG91dHB1dCArPSBmaXJzdDtcbiAgfVxuICAvLyBjb252ZXJ0IGRpZ2l0cyB0byBhIHN0cmluZ1xuICBmb3IoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIG91dHB1dCArPSBhbHBoYWJldFtkaWdpdHNbaV1dO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJhaW46IHJlcXVpcmUoJy4vZHJhaW4nKSxcbiAgb25FbmQ6IHJlcXVpcmUoJy4vb24tZW5kJyksXG4gIGxvZzogcmVxdWlyZSgnLi9sb2cnKSxcbiAgZmluZDogcmVxdWlyZSgnLi9maW5kJyksXG4gIHJlZHVjZTogcmVxdWlyZSgnLi9yZWR1Y2UnKSxcbiAgY29sbGVjdDogcmVxdWlyZSgnLi9jb2xsZWN0JyksXG4gIGNvbmNhdDogcmVxdWlyZSgnLi9jb25jYXQnKVxufVxuXG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0ge1xuICBrZXlzOiByZXF1aXJlKCcuL2tleXMnKSxcbiAgb25jZTogcmVxdWlyZSgnLi9vbmNlJyksXG4gIHZhbHVlczogcmVxdWlyZSgnLi92YWx1ZXMnKSxcbiAgY291bnQ6IHJlcXVpcmUoJy4vY291bnQnKSxcbiAgaW5maW5pdGU6IHJlcXVpcmUoJy4vaW5maW5pdGUnKSxcbiAgZW1wdHk6IHJlcXVpcmUoJy4vZW1wdHknKSxcbiAgZXJyb3I6IHJlcXVpcmUoJy4vZXJyb3InKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYXA6IHJlcXVpcmUoJy4vbWFwJyksXG4gIGFzeW5jTWFwOiByZXF1aXJlKCcuL2FzeW5jLW1hcCcpLFxuICBmaWx0ZXI6IHJlcXVpcmUoJy4vZmlsdGVyJyksXG4gIGZpbHRlck5vdDogcmVxdWlyZSgnLi9maWx0ZXItbm90JyksXG4gIHRocm91Z2g6IHJlcXVpcmUoJy4vdGhyb3VnaCcpLFxuICB0YWtlOiByZXF1aXJlKCcuL3Rha2UnKSxcbiAgdW5pcXVlOiByZXF1aXJlKCcuL3VuaXF1ZScpLFxuICBub25VbmlxdWU6IHJlcXVpcmUoJy4vbm9uLXVuaXF1ZScpLFxuICBmbGF0dGVuOiByZXF1aXJlKCcuL2ZsYXR0ZW4nKVxufVxuXG5cblxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYG1lc3NhZ2UgRGF0YSB7XG4gIGVudW0gRGF0YVR5cGUge1xuICAgIFJhdyA9IDA7XG4gICAgRGlyZWN0b3J5ID0gMTtcbiAgICBGaWxlID0gMjtcbiAgICBNZXRhZGF0YSA9IDM7XG4gICAgU3ltbGluayA9IDQ7XG4gICAgSEFNVFNoYXJkID0gNTtcbiAgfVxuXG4gIHJlcXVpcmVkIERhdGFUeXBlIFR5cGUgPSAxO1xuICBvcHRpb25hbCBieXRlcyBEYXRhID0gMjtcbiAgb3B0aW9uYWwgdWludDY0IGZpbGVzaXplID0gMztcbiAgcmVwZWF0ZWQgdWludDY0IGJsb2Nrc2l6ZXMgPSA0O1xuXG4gIG9wdGlvbmFsIHVpbnQ2NCBoYXNoVHlwZSA9IDU7XG4gIG9wdGlvbmFsIHVpbnQ2NCBmYW5vdXQgPSA2O1xufVxuXG5tZXNzYWdlIE1ldGFkYXRhIHtcbiAgb3B0aW9uYWwgc3RyaW5nIE1pbWVUeXBlID0gMTtcbn1gXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9jcmVhdGVUZXN0ZXI7XG5cbnZhciBfbm9vcCA9IHJlcXVpcmUoJ2xvZGFzaC9ub29wJyk7XG5cbnZhciBfbm9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub29wKTtcblxudmFyIF9icmVha0xvb3AgPSByZXF1aXJlKCcuL2JyZWFrTG9vcCcpO1xuXG52YXIgX2JyZWFrTG9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9icmVha0xvb3ApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlVGVzdGVyKGNoZWNrLCBnZXRSZXN1bHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2IpIHtcbiAgICAgICAgY2IgPSBjYiB8fCBfbm9vcDIuZGVmYXVsdDtcbiAgICAgICAgdmFyIHRlc3RQYXNzZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRlc3RSZXN1bHQ7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh2YWx1ZSwgXywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlKHZhbHVlLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGVjayhyZXN1bHQpICYmICF0ZXN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RQYXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0ZXN0UmVzdWx0ID0gZ2V0UmVzdWx0KHRydWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgX2JyZWFrTG9vcDIuZGVmYXVsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiKG51bGwsIHRlc3RQYXNzZWQgPyB0ZXN0UmVzdWx0IDogZ2V0UmVzdWx0KGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbm90SWQ7XG5mdW5jdGlvbiBub3RJZCh2KSB7XG4gICAgcmV0dXJuICF2O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCIvLyBJZiB0aGUgcGFzc2VkIG9iamVjdCBpcyBhbiAoYXN5bmMpIGl0ZXJhYmxlLCB0aGVuIGdldCB0aGUgaXRlcmF0b3Jcbi8vIElmIGl0J3MgcHJvYmFibHkgYW4gaXRlcmF0b3IgYWxyZWFkeSAoaS5lLiBoYXMgbmV4dCBmdW5jdGlvbikgcmV0dXJuIGl0XG4vLyBlbHNlIHRocm93XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEl0ZXJhdG9yIChvYmopIHtcbiAgaWYgKG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBvYmpbU3ltYm9sLml0ZXJhdG9yXSgpXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iai5uZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gb2JqIC8vIHByb2JhYmx5IGFuIGl0ZXJhdG9yXG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcignYXJndW1lbnQgaXMgbm90IGFuIGl0ZXJhdG9yIG9yIGl0ZXJhYmxlJylcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9kb1BhcmFsbGVsTGltaXQgPSByZXF1aXJlKCcuL2ludGVybmFsL2RvUGFyYWxsZWxMaW1pdCcpO1xuXG52YXIgX2RvUGFyYWxsZWxMaW1pdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kb1BhcmFsbGVsTGltaXQpO1xuXG52YXIgX21hcCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvbWFwJyk7XG5cbnZhciBfbWFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hcCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BtYXBgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBtYXBMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMubWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgaXRlbS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXkgb2YgdGhlXG4gKiB0cmFuc2Zvcm1lZCBpdGVtcyBmcm9tIHRoZSBgY29sbGAuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9kb1BhcmFsbGVsTGltaXQyLmRlZmF1bHQpKF9tYXAyLmRlZmF1bHQpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGVycmNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5cbm1vZHVsZS5leHBvcnRzLmRiT3BlbkZhaWxlZEVycm9yID0gKGVycikgPT4ge1xuICBlcnIgPSBlcnIgfHwgbmV3IEVycm9yKCdDYW5ub3Qgb3BlbiBkYXRhYmFzZScpXG4gIHJldHVybiBlcnJjb2RlKGVyciwgJ0VSUl9EQl9PUEVOX0ZBSUxFRCcpXG59XG5cbm1vZHVsZS5leHBvcnRzLmRiRGVsZXRlRmFpbGVkRXJyb3IgPSAoZXJyKSA9PiB7XG4gIGVyciA9IGVyciB8fCBuZXcgRXJyb3IoJ0RlbGV0ZSBmYWlsZWQnKVxuICByZXR1cm4gZXJyY29kZShlcnIsICdFUlJfREJfREVMRVRFX0ZBSUxFRCcpXG59XG5cbm1vZHVsZS5leHBvcnRzLmRiV3JpdGVGYWlsZWRFcnJvciA9IChlcnIpID0+IHtcbiAgZXJyID0gZXJyIHx8IG5ldyBFcnJvcignV3JpdGUgZmFpbGVkJylcbiAgcmV0dXJuIGVycmNvZGUoZXJyLCAnRVJSX0RCX1dSSVRFX0ZBSUxFRCcpXG59XG5cbm1vZHVsZS5leHBvcnRzLm5vdEZvdW5kRXJyb3IgPSAoZXJyKSA9PiB7XG4gIGVyciA9IGVyciB8fCBuZXcgRXJyb3IoJ05vdCBGb3VuZCcpXG4gIHJldHVybiBlcnJjb2RlKGVyciwgJ0VSUl9OT1RfRk9VTkQnKVxufVxuIiwiLyogQGZsb3cgKi9cbid1c2Ugc3RyaWN0J1xuXG4vKiA6OiBpbXBvcnQgdHlwZSB7QmF0Y2gsIFF1ZXJ5LCBRdWVyeVJlc3VsdCwgQ2FsbGJhY2t9IGZyb20gJy4vJyAqL1xuXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0nKVxuY29uc3Qgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnYXN5bmMvc2V0SW1tZWRpYXRlJylcblxuY29uc3QgYXN5bmNGaWx0ZXIgPSByZXF1aXJlKCcuL3V0aWxzJykuYXN5bmNGaWx0ZXJcbmNvbnN0IGFzeW5jU29ydCA9IHJlcXVpcmUoJy4vdXRpbHMnKS5hc3luY1NvcnRcbmNvbnN0IEtleSA9IHJlcXVpcmUoJy4va2V5JylcblxuLy8gRXJyb3JzXG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpXG5cbmNsYXNzIE1lbW9yeURhdGFzdG9yZSB7XG4gIC8qIDo6IGRhdGE6IHtba2V5OiBzdHJpbmddOiBCdWZmZXJ9ICovXG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuZGF0YSA9IHt9XG4gIH1cblxuICBvcGVuIChjYWxsYmFjayAvKiA6IENhbGxiYWNrPHZvaWQ+ICovKSAvKiA6IHZvaWQgKi8ge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjaylcbiAgfVxuXG4gIHB1dCAoa2V5IC8qIDogS2V5ICovLCB2YWwgLyogOiBCdWZmZXIgKi8sIGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8dm9pZD4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgdGhpcy5kYXRhW2tleS50b1N0cmluZygpXSA9IHZhbFxuXG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKVxuICB9XG5cbiAgZ2V0IChrZXkgLyogOiBLZXkgKi8sIGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8QnVmZmVyPiAqLykgLyogOiB2b2lkICovIHtcbiAgICB0aGlzLmhhcyhrZXksIChlcnIsIGV4aXN0cykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JzLm5vdEZvdW5kRXJyb3IoKSlcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgdGhpcy5kYXRhW2tleS50b1N0cmluZygpXSlcbiAgICB9KVxuICB9XG5cbiAgaGFzIChrZXkgLyogOiBLZXkgKi8sIGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8Ym9vbD4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHRoaXMuZGF0YVtrZXkudG9TdHJpbmcoKV0gIT09IHVuZGVmaW5lZClcbiAgICB9KVxuICB9XG5cbiAgZGVsZXRlIChrZXkgLyogOiBLZXkgKi8sIGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8dm9pZD4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgZGVsZXRlIHRoaXMuZGF0YVtrZXkudG9TdHJpbmcoKV1cblxuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIGJhdGNoICgpIC8qIDogQmF0Y2g8QnVmZmVyPiAqLyB7XG4gICAgbGV0IHB1dHMgPSBbXVxuICAgIGxldCBkZWxzID0gW11cblxuICAgIHJldHVybiB7XG4gICAgICBwdXQgKGtleSAvKiA6IEtleSAqLywgdmFsdWUgLyogOiBCdWZmZXIgKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgICAgIHB1dHMucHVzaChba2V5LCB2YWx1ZV0pXG4gICAgICB9LFxuICAgICAgZGVsZXRlIChrZXkgLyogOiBLZXkgKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgICAgIGRlbHMucHVzaChrZXkpXG4gICAgICB9LFxuICAgICAgY29tbWl0OiAoY2FsbGJhY2sgLyogOiBDYWxsYmFjazx2b2lkPiAqLykgLyogOiB2b2lkICovID0+IHtcbiAgICAgICAgcHV0cy5mb3JFYWNoKHYgPT4ge1xuICAgICAgICAgIHRoaXMuZGF0YVt2WzBdLnRvU3RyaW5nKCldID0gdlsxXVxuICAgICAgICB9KVxuXG4gICAgICAgIHB1dHMgPSBbXVxuICAgICAgICBkZWxzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5kYXRhW2tleS50b1N0cmluZygpXVxuICAgICAgICB9KVxuICAgICAgICBkZWxzID0gW11cblxuICAgICAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcXVlcnkgKHEgLyogOiBRdWVyeTxCdWZmZXI+ICovKSAvKiA6IFF1ZXJ5UmVzdWx0PEJ1ZmZlcj4gKi8ge1xuICAgIGxldCB0YXNrcyA9IFtwdWxsLmtleXModGhpcy5kYXRhKSwgcHVsbC5tYXAoayA9PiAoe1xuICAgICAga2V5OiBuZXcgS2V5KGspLFxuICAgICAgdmFsdWU6IHRoaXMuZGF0YVtrXVxuICAgIH0pKV1cblxuICAgIGxldCBmaWx0ZXJzID0gW11cblxuICAgIGlmIChxLnByZWZpeCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBxLnByZWZpeFxuICAgICAgZmlsdGVycy5wdXNoKChlLCBjYikgPT4gY2IobnVsbCwgZS5rZXkudG9TdHJpbmcoKS5zdGFydHNXaXRoKHByZWZpeCkpKVxuICAgIH1cblxuICAgIGlmIChxLmZpbHRlcnMgIT0gbnVsbCkge1xuICAgICAgZmlsdGVycyA9IGZpbHRlcnMuY29uY2F0KHEuZmlsdGVycylcbiAgICB9XG5cbiAgICB0YXNrcyA9IHRhc2tzLmNvbmNhdChmaWx0ZXJzLm1hcChmID0+IGFzeW5jRmlsdGVyKGYpKSlcblxuICAgIGlmIChxLm9yZGVycyAhPSBudWxsKSB7XG4gICAgICB0YXNrcyA9IHRhc2tzLmNvbmNhdChxLm9yZGVycy5tYXAobyA9PiBhc3luY1NvcnQobykpKVxuICAgIH1cblxuICAgIGlmIChxLm9mZnNldCAhPSBudWxsKSB7XG4gICAgICBsZXQgaSA9IDBcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIHRhc2tzLnB1c2gocHVsbC5maWx0ZXIoKCkgPT4gaSsrID49IHEub2Zmc2V0KSlcbiAgICB9XG5cbiAgICBpZiAocS5saW1pdCAhPSBudWxsKSB7XG4gICAgICB0YXNrcy5wdXNoKHB1bGwudGFrZShxLmxpbWl0KSlcbiAgICB9XG5cbiAgICBpZiAocS5rZXlzT25seSA9PT0gdHJ1ZSkge1xuICAgICAgdGFza3MucHVzaChwdWxsLm1hcChlID0+ICh7IGtleTogZS5rZXkgfSkpKVxuICAgIH1cblxuICAgIHJldHVybiBwdWxsLmFwcGx5KG51bGwsIHRhc2tzKVxuICB9XG5cbiAgY2xvc2UgKGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8dm9pZD4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVtb3J5RGF0YXN0b3JlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtJylcbmNvbnN0IFNvdXJjZSA9IHJlcXVpcmUoJ3B1bGwtZGVmZXIvc291cmNlJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKVxuY29uc3QgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjQnKVxuXG5leHBvcnRzLmFzeW5jRmlsdGVyID0gZnVuY3Rpb24gKHRlc3QpIHtcbiAgbGV0IGJ1c3kgPSBmYWxzZVxuICBsZXQgYWJvcnRDYlxuICBsZXQgYWJvcnRlZFxuXG4gIHJldHVybiBmdW5jdGlvbiAocmVhZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0IChhYm9ydCwgY2IpIHtcbiAgICAgIGlmIChhYm9ydGVkKSByZXR1cm4gY2IoYWJvcnRlZClcbiAgICAgIGlmIChhYm9ydCkge1xuICAgICAgICBhYm9ydGVkID0gYWJvcnRcbiAgICAgICAgaWYgKCFidXN5KSB7XG4gICAgICAgICAgcmVhZChhYm9ydCwgY2IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVhZChhYm9ydCwgKCkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIHN0aWxsIGJ1c3ksIHdhaXQgZm9yIHRoZSB0ZXN0IHRvIGNvbXBsZXRlLlxuICAgICAgICAgICAgaWYgKGJ1c3kpIGFib3J0Q2IgPSBjYjsgZWxzZSBjYihhYm9ydClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWFkKG51bGwsIChlbmQsIGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoZW5kKSBjYihlbmQpOyBlbHNlIGlmIChhYm9ydGVkKSBjYihhYm9ydGVkKTsgZWxzZSB7XG4gICAgICAgICAgICBidXN5ID0gdHJ1ZVxuICAgICAgICAgICAgdGVzdChkYXRhLCAoZXJyLCB2YWxpZCkgPT4ge1xuICAgICAgICAgICAgICBidXN5ID0gZmFsc2VcbiAgICAgICAgICAgICAgaWYgKGFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBjYihhYm9ydGVkKVxuICAgICAgICAgICAgICAgIGFib3J0Q2IoYWJvcnRlZClcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBuZXh0KGVyciwgY2IpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgICBjYihudWxsLCBkYXRhKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHQobnVsbCwgY2IpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLmFzeW5jU29ydCA9IGZ1bmN0aW9uIChzb3J0ZXIpIHtcbiAgY29uc3Qgc291cmNlID0gU291cmNlKClcblxuICBjb25zdCBzaW5rID0gcHVsbC5jb2xsZWN0KChlcnIsIGFyeSkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBzb3VyY2UuYWJvcnQoZXJyKVxuICAgIH1cbiAgICBzb3J0ZXIoYXJ5LCAoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5hYm9ydChlcnIpXG4gICAgICB9XG4gICAgICBzb3VyY2UucmVzb2x2ZShwdWxsLnZhbHVlcyhhcnkpKVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZWFkKSB7XG4gICAgc2luayhyZWFkKVxuICAgIHJldHVybiBzb3VyY2VcbiAgfVxufVxuXG5leHBvcnRzLnJlcGxhY2VTdGFydFdpdGggPSBmdW5jdGlvbiAocywgcikge1xuICBjb25zdCBtYXRjaGVyID0gbmV3IFJlZ0V4cCgnXicgKyByKVxuICByZXR1cm4gcy5yZXBsYWNlKG1hdGNoZXIsICcnKVxufVxuXG5leHBvcnRzLnRtcGRpciA9ICgpID0+IHtcbiAgcmV0dXJuIHBhdGguam9pbihvcy50bXBkaXIoKSwgdXVpZCgpKVxufVxuIiwiLyogQGZsb3cgKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1dWlkID0gcmVxdWlyZSgndXVpZC92NCcpXG5jb25zdCB3aXRoSXMgPSByZXF1aXJlKCdjbGFzcy1pcycpXG5cbmNvbnN0IHBhdGhTZXBTID0gJy8nXG5jb25zdCBwYXRoU2VwQiA9IEJ1ZmZlci5mcm9tKHBhdGhTZXBTKVxuY29uc3QgcGF0aFNlcCA9IHBhdGhTZXBCWzBdXG5cbi8qKlxuICogQSBLZXkgcmVwcmVzZW50cyB0aGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgYW4gb2JqZWN0LlxuICogT3VyIEtleSBzY2hlbWUgaXMgaW5zcGlyZWQgYnkgZmlsZSBzeXN0ZW1zIGFuZCBHb29nbGUgQXBwIEVuZ2luZSBrZXkgbW9kZWwuXG4gKiBLZXlzIGFyZSBtZWFudCB0byBiZSB1bmlxdWUgYWNyb3NzIGEgc3lzdGVtLiBLZXlzIGFyZSBoaWVyYXJjaGljYWwsXG4gKiBpbmNvcnBvcmF0aW5nIG1vcmUgYW5kIG1vcmUgc3BlY2lmaWMgbmFtZXNwYWNlcy4gVGh1cyBrZXlzIGNhbiBiZSBkZWVtZWRcbiAqICdjaGlsZHJlbicgb3IgJ2FuY2VzdG9ycycgb2Ygb3RoZXIga2V5czpcbiAqIC0gYG5ldyBLZXkoJy9Db21lZHknKWBcbiAqIC0gYG5ldyBLZXkoJy9Db21lZHkvTW9udHlQeXRob24nKWBcbiAqIEFsc28sIGV2ZXJ5IG5hbWVzcGFjZSBjYW4gYmUgcGFyYW1ldHJpemVkIHRvIGVtYmVkIHJlbGV2YW50IG9iamVjdFxuICogaW5mb3JtYXRpb24uIEZvciBleGFtcGxlLCB0aGUgS2V5IGBuYW1lYCAobW9zdCBzcGVjaWZpYyBuYW1lc3BhY2UpIGNvdWxkXG4gKiBpbmNsdWRlIHRoZSBvYmplY3QgdHlwZTpcbiAqIC0gYG5ldyBLZXkoJy9Db21lZHkvTW9udHlQeXRob24vQWN0b3I6Sm9obkNsZWVzZScpYFxuICogLSBgbmV3IEtleSgnL0NvbWVkeS9Nb250eVB5dGhvbi9Ta2V0Y2g6Q2hlZXNlU2hvcCcpYFxuICogLSBgbmV3IEtleSgnL0NvbWVkeS9Nb250eVB5dGhvbi9Ta2V0Y2g6Q2hlZXNlU2hvcC9DaGFyYWN0ZXI6TW91c2ViZW5kZXInKWBcbiAqXG4gKi9cbmNsYXNzIEtleSB7XG4gIC8qIDo6IF9idWY6IEJ1ZmZlciAqL1xuXG4gIGNvbnN0cnVjdG9yIChzIC8qIDogc3RyaW5nfEJ1ZmZlciAqLywgY2xlYW4gLyogOiA/Ym9vbCAqLykge1xuICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2J1ZiA9IEJ1ZmZlci5mcm9tKHMpXG4gICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIocykpIHtcbiAgICAgIHRoaXMuX2J1ZiA9IHNcbiAgICB9XG5cbiAgICBpZiAoY2xlYW4gPT0gbnVsbCkge1xuICAgICAgY2xlYW4gPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGNsZWFuKSB7XG4gICAgICB0aGlzLmNsZWFuKClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYnVmLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9idWZbMF0gIT09IHBhdGhTZXApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBrZXk6ICR7dGhpcy50b1N0cmluZygpfWApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J11cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nIChlbmNvZGluZy8qIDogP2J1ZmZlciRFbmNvZGluZyAqLykvKiA6IHN0cmluZyAqLyB7XG4gICAgcmV0dXJuIHRoaXMuX2J1Zi50b1N0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBidWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGtleVxuICAgKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfVxuICAgKi9cbiAgdG9CdWZmZXIgKCkgLyogOiBCdWZmZXIgKi8ge1xuICAgIHJldHVybiB0aGlzLl9idWZcbiAgfVxuXG4gIC8vIHdhaXRpbmcgb24gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzIyODZcbiAgLy8gJEZsb3dGaXhNZVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10gKCkgLyogOiBzdHJpbmcgKi8ge1xuICAgIHJldHVybiBgW0tleSAke3RoaXMudG9TdHJpbmcoKX1dYFxuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBrZXkgb3V0IG9mIGEgbmFtZXNwYWNlIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGxpc3RcbiAgICogQHJldHVybnMge0tleX1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogS2V5LndpdGhOYW1lc3BhY2VzKFsnb25lJywgJ3R3byddKVxuICAgKiAvLyA9PiBLZXkoJy9vbmUvdHdvJylcbiAgICpcbiAgICovXG4gIHN0YXRpYyB3aXRoTmFtZXNwYWNlcyAobGlzdCAvKiA6IEFycmF5PHN0cmluZz4gKi8pIC8qIDogS2V5ICovIHtcbiAgICByZXR1cm4gbmV3IF9LZXkobGlzdC5qb2luKHBhdGhTZXBTKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmFuZG9tbHkgKHV1aWQpIGdlbmVyYXRlZCBrZXkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtLZXl9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIEtleS5yYW5kb20oKVxuICAgKiAvLyA9PiBLZXkoJy9mOTg3MTllYTA4NjM0M2Y3YjcxZjMyZWE5ZDlkNTIxZCcpXG4gICAqXG4gICAqL1xuICBzdGF0aWMgcmFuZG9tICgpIC8qIDogS2V5ICovIHtcbiAgICByZXR1cm4gbmV3IF9LZXkodXVpZCgpLnJlcGxhY2UoLy0vZywgJycpKVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFudXAgdGhlIGN1cnJlbnQga2V5XG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgY2xlYW4gKCkge1xuICAgIGlmICghdGhpcy5fYnVmIHx8IHRoaXMuX2J1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2J1ZiA9IEJ1ZmZlci5mcm9tKHBhdGhTZXBTKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9idWZbMF0gIT09IHBhdGhTZXApIHtcbiAgICAgIHRoaXMuX2J1ZiA9IEJ1ZmZlci5jb25jYXQoW3BhdGhTZXBCLCB0aGlzLl9idWZdKVxuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSBkb2VzIG5vdCByZW1vdmUgdHJhaWxpbmcgc2xhc2hlc1xuICAgIHdoaWxlICh0aGlzLl9idWYubGVuZ3RoID4gMSAmJiB0aGlzLl9idWZbdGhpcy5fYnVmLmxlbmd0aCAtIDFdID09PSBwYXRoU2VwKSB7XG4gICAgICB0aGlzLl9idWYgPSB0aGlzLl9idWYuc2xpY2UoMCwgLTEpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiBrZXkgaXMgc29ydGVkIGxvd2VyIHRoYW4gb3Vyc2VsZi5cbiAgICpcbiAgICogQHBhcmFtIHtLZXl9IGtleVxuICAgKiBAcmV0dXJucyB7Ym9vbH1cbiAgICovXG4gIGxlc3MgKGtleSAvKiA6IEtleSAqLykgLyogOiBib29sICovIHtcbiAgICBjb25zdCBsaXN0MSA9IHRoaXMubGlzdCgpXG4gICAgY29uc3QgbGlzdDIgPSBrZXkubGlzdCgpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdDIubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGMxID0gbGlzdDFbaV1cbiAgICAgIGNvbnN0IGMyID0gbGlzdDJbaV1cblxuICAgICAgaWYgKGMxIDwgYzIpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gZWxzZSBpZiAoYzEgPiBjMikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDEubGVuZ3RoIDwgbGlzdDIubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5IHdpdGggYWxsIHBhcnRzIGluIHJldmVyc2VkIG9yZGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5fVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgS2V5KCcvQ29tZWR5L01vbnR5UHl0aG9uL0FjdG9yOkpvaG5DbGVlc2UnKS5yZXZlcnNlKClcbiAgICogLy8gPT4gS2V5KCcvQWN0b3I6Sm9obkNsZWVzZS9Nb250eVB5dGhvbi9Db21lZHknKVxuICAgKi9cbiAgcmV2ZXJzZSAoKSAvKiA6IEtleSAqLyB7XG4gICAgcmV0dXJuIEtleS53aXRoTmFtZXNwYWNlcyh0aGlzLmxpc3QoKS5zbGljZSgpLnJldmVyc2UoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgbmFtZXNwYWNlc2AgbWFraW5nIHVwIHRoaXMgS2V5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn1cbiAgICovXG4gIG5hbWVzcGFjZXMgKCkgLyogOiBBcnJheTxzdHJpbmc+ICovIHtcbiAgICByZXR1cm4gdGhpcy5saXN0KClcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRoZSBcImJhc2VcIiBuYW1lc3BhY2Ugb2YgdGhpcyBrZXkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBLZXkoJy9Db21lZHkvTW9udHlQeXRob24vQWN0b3I6Sm9obkNsZWVzZScpLmJhc2VOYW1lc3BhY2UoKVxuICAgKiAvLyA9PiAnQWN0b3I6Sm9obkNsZWVzZSdcbiAgICpcbiAgICovXG4gIGJhc2VOYW1lc3BhY2UgKCkgLyogOiBzdHJpbmcgKi8ge1xuICAgIGNvbnN0IG5zID0gdGhpcy5uYW1lc3BhY2VzKClcbiAgICByZXR1cm4gbnNbbnMubGVuZ3RoIC0gMV1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgbGlzdGAgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBrZXkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgS2V5KCcvQ29tZWR5L01vbnR5UHl0aG9uL0FjdG9yOkpvaG5DbGVlc2UnKS5saXN0KClcbiAgICogLy8gPT4gWydDb21lZHknLCAnTW9udHlQeXRob25nJywgJ0FjdG9yOkpvaG5DbGVlc2UnXVxuICAgKlxuICAgKi9cbiAgbGlzdCAoKSAvKiA6IEFycmF5PHN0cmluZz4gKi8ge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCkuc3BsaXQocGF0aFNlcFMpLnNsaWNlKDEpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgXCJ0eXBlXCIgb2YgdGhpcyBrZXkgKHZhbHVlIG9mIGxhc3QgbmFtZXNwYWNlKS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IEtleSgnL0NvbWVkeS9Nb250eVB5dGhvbi9BY3RvcjpKb2huQ2xlZXNlJykudHlwZSgpXG4gICAqIC8vID0+ICdBY3RvcidcbiAgICpcbiAgICovXG4gIHR5cGUgKCkgLyogOiBzdHJpbmcgKi8ge1xuICAgIHJldHVybiBuYW1lc3BhY2VUeXBlKHRoaXMuYmFzZU5hbWVzcGFjZSgpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFwibmFtZVwiIG9mIHRoaXMga2V5IChmaWVsZCBvZiBsYXN0IG5hbWVzcGFjZSkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBLZXkoJy9Db21lZHkvTW9udHlQeXRob24vQWN0b3I6Sm9obkNsZWVzZScpLm5hbWUoKVxuICAgKiAvLyA9PiAnSm9obkNsZWVzZSdcbiAgICovXG4gIG5hbWUgKCkgLyogOiBzdHJpbmcgKi8ge1xuICAgIHJldHVybiBuYW1lc3BhY2VWYWx1ZSh0aGlzLmJhc2VOYW1lc3BhY2UoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIFwiaW5zdGFuY2VcIiBvZiB0aGlzIHR5cGUga2V5IChhcHBlbmRzIHZhbHVlIHRvIG5hbWVzcGFjZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAqIEByZXR1cm5zIHtLZXl9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBLZXkoJy9Db21lZHkvTW9udHlQeXRob24vQWN0b3InKS5pbnN0YW5jZSgnSm9obkNsZXNzZScpXG4gICAqIC8vID0+IEtleSgnL0NvbWVkeS9Nb250eVB5dGhvbi9BY3RvcjpKb2huQ2xlZXNlJylcbiAgICovXG4gIGluc3RhbmNlIChzIC8qIDogc3RyaW5nICovKSAvKiA6IEtleSAqLyB7XG4gICAgcmV0dXJuIG5ldyBfS2V5KHRoaXMudG9TdHJpbmcoKSArICc6JyArIHMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgXCJwYXRoXCIgb2YgdGhpcyBrZXkgKHBhcmVudCArIHR5cGUpLlxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5fVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgS2V5KCcvQ29tZWR5L01vbnR5UHl0aG9uL0FjdG9yOkpvaG5DbGVlc2UnKS5wYXRoKClcbiAgICogLy8gPT4gS2V5KCcvQ29tZWR5L01vbnR5UHl0aG9uL0FjdG9yJylcbiAgICpcbiAgICovXG4gIHBhdGggKCkgLyogOiBLZXkgKi8ge1xuICAgIGxldCBwID0gdGhpcy5wYXJlbnQoKS50b1N0cmluZygpXG4gICAgaWYgKCFwLmVuZHNXaXRoKHBhdGhTZXBTKSkge1xuICAgICAgcCArPSBwYXRoU2VwU1xuICAgIH1cbiAgICBwICs9IHRoaXMudHlwZSgpXG4gICAgcmV0dXJuIG5ldyBfS2V5KHApXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYHBhcmVudGAgS2V5IG9mIHRoaXMgS2V5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5fVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgS2V5KFwiL0NvbWVkeS9Nb250eVB5dGhvbi9BY3RvcjpKb2huQ2xlZXNlXCIpLnBhcmVudCgpXG4gICAqIC8vID0+IEtleShcIi9Db21lZHkvTW9udHlQeXRob25cIilcbiAgICpcbiAgICovXG4gIHBhcmVudCAoKSAvKiA6IEtleSAqLyB7XG4gICAgY29uc3QgbGlzdCA9IHRoaXMubGlzdCgpXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IF9LZXkocGF0aFNlcFMpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBfS2V5KGxpc3Quc2xpY2UoMCwgLTEpLmpvaW4ocGF0aFNlcFMpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBjaGlsZGAgS2V5IG9mIHRoaXMgS2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge0tleX0ga2V5XG4gICAqIEByZXR1cm5zIHtLZXl9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBLZXkoJy9Db21lZHkvTW9udHlQeXRob24nKS5jaGlsZChuZXcgS2V5KCdBY3RvcjpKb2huQ2xlZXNlJykpXG4gICAqIC8vID0+IEtleSgnL0NvbWVkeS9Nb250eVB5dGhvbi9BY3RvcjpKb2huQ2xlZXNlJylcbiAgICpcbiAgICovXG4gIGNoaWxkIChrZXkgLyogOiBLZXkgKi8pIC8qIDogS2V5ICovIHtcbiAgICBpZiAodGhpcy50b1N0cmluZygpID09PSBwYXRoU2VwUykge1xuICAgICAgcmV0dXJuIGtleVxuICAgIH0gZWxzZSBpZiAoa2V5LnRvU3RyaW5nKCkgPT09IHBhdGhTZXBTKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgX0tleSh0aGlzLnRvU3RyaW5nKCkgKyBrZXkudG9TdHJpbmcoKSwgZmFsc2UpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMga2V5IGlzIGEgcHJlZml4IG9mIGBvdGhlcmBcbiAgICpcbiAgICogQHBhcmFtIHtLZXl9IG90aGVyXG4gICAqIEByZXR1cm5zIHtib29sfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgS2V5KCcvQ29tZWR5JykuaXNBbmNlc3Rvck9mKCcvQ29tZWR5L01vbnR5UHl0aG9uJylcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKi9cbiAgaXNBbmNlc3Rvck9mIChvdGhlciAvKiA6IEtleSAqLykgLyogOiBib29sICovIHtcbiAgICBpZiAob3RoZXIudG9TdHJpbmcoKSA9PT0gdGhpcy50b1N0cmluZygpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gb3RoZXIudG9TdHJpbmcoKS5zdGFydHNXaXRoKHRoaXMudG9TdHJpbmcoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBrZXkgaXMgYSBjb250YWlucyBhbm90aGVyIGFzIHByZWZpeC5cbiAgICpcbiAgICogQHBhcmFtIHtLZXl9IG90aGVyXG4gICAqIEByZXR1cm5zIHtib29sfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgS2V5KCcvQ29tZWR5L01vbnR5UHl0aG9uJykuaXNEZWNlbmRhbnRPZignL0NvbWVkeScpXG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICovXG4gIGlzRGVjZW5kYW50T2YgKG90aGVyIC8qIDogS2V5ICovKSAvKiA6IGJvb2wgKi8ge1xuICAgIGlmIChvdGhlci50b1N0cmluZygpID09PSB0aGlzLnRvU3RyaW5nKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCkuc3RhcnRzV2l0aChvdGhlci50b1N0cmluZygpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2V0aGVyIHRoaXMga2V5IGhhcyBvbmx5IG9uZSBuYW1lc3BhY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sfVxuICAgKlxuICAgKi9cbiAgaXNUb3BMZXZlbCAoKSAvKiA6IGJvb2wgKi8ge1xuICAgIHJldHVybiB0aGlzLmxpc3QoKS5sZW5ndGggPT09IDFcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBmaXJzdCBjb21wb25lbnQgb2YgYSBuYW1lc3BhY2UuIGBmb29gIGluIGBmb286YmFyYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbmFtZXNwYWNlVHlwZSAobnMgLyogOiBzdHJpbmcgKi8pIC8qIDogc3RyaW5nICovIHtcbiAgY29uc3QgcGFydHMgPSBucy5zcGxpdCgnOicpXG4gIGlmIChwYXJ0cy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbiAgcmV0dXJuIHBhcnRzLnNsaWNlKDAsIC0xKS5qb2luKCc6Jylcbn1cblxuLyoqXG4gKiBUaGUgbGFzdCBjb21wb25lbnQgb2YgYSBuYW1lc3BhY2UsIGBiYXpgIGluIGBmb286YmFyOmJhemAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5zXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBuYW1lc3BhY2VWYWx1ZSAobnMgLyogOiBzdHJpbmcgKi8pIC8qIDogc3RyaW5nICovIHtcbiAgY29uc3QgcGFydHMgPSBucy5zcGxpdCgnOicpXG4gIHJldHVybiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXVxufVxuXG5jb25zdCBfS2V5ID0gd2l0aElzKEtleSwgeyBjbGFzc05hbWU6ICdLZXknLCBzeW1ib2xOYW1lOiAnQGlwZnMvaW50ZXJmYWNlLWRhdGFzdG9yZS9rZXknIH0pXG5cbm1vZHVsZS5leHBvcnRzID0gX0tleVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9maW5kR2V0UmVzdWx0O1xuZnVuY3Rpb24gX2ZpbmRHZXRSZXN1bHQodiwgeCkge1xuICAgIHJldHVybiB4O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRvUGFyYWxsZWxMaW1pdDtcblxudmFyIF9lYWNoT2ZMaW1pdCA9IHJlcXVpcmUoJy4vZWFjaE9mTGltaXQnKTtcblxudmFyIF9lYWNoT2ZMaW1pdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoT2ZMaW1pdCk7XG5cbnZhciBfd3JhcEFzeW5jID0gcmVxdWlyZSgnLi93cmFwQXN5bmMnKTtcblxudmFyIF93cmFwQXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd3JhcEFzeW5jKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZG9QYXJhbGxlbExpbWl0KGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZuKCgwLCBfZWFjaE9mTGltaXQyLmRlZmF1bHQpKGxpbWl0KSwgb2JqLCAoMCwgX3dyYXBBc3luYzIuZGVmYXVsdCkoaXRlcmF0ZWUpLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFByb3RvYnVmIGludGVyZmFjZVxuICogZnJvbSBnby1pcGZzL3Bpbi9pbnRlcm5hbC9wYi9oZWFkZXIucHJvdG9cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBgXG4gIHN5bnRheCA9IFwicHJvdG8yXCI7XG5cbiAgcGFja2FnZSBpcGZzLnBpbjtcblxuICBvcHRpb24gZ29fcGFja2FnZSA9IFwicGJcIjtcblxuICBtZXNzYWdlIFNldCB7XG4gICAgb3B0aW9uYWwgdWludDMyIHZlcnNpb24gPSAxO1xuICAgIG9wdGlvbmFsIHVpbnQzMiBmYW5vdXQgPSAyO1xuICAgIG9wdGlvbmFsIGZpeGVkMzIgc2VlZCA9IDM7XG4gIH1cbmBcbiIsIi8qKlxuICogQ3JlYXRlZCBieSBzY2h3YXJ6a29wZmIgb24gMTUvMTEvMTcuXG4gKi9cblxuLyoqXG4gKiBGTlYtMWEgaGFzaCBnZW5lcmF0aW9uIGluaXQgdmFsdWUuXG4gKiBJdCdzIGV4cG9zZWQsIGJlY2F1c2UgdGhpcyBhbGxvd3MgdXNlciB0byBvdmVycmlkZSBpdC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5oYXNoLkJBU0UgPSAweDgxMWM5ZGM1XG5cbi8qKlxuICogR2VuZXJhdGVzIDMyIGJpdCBGTlYtMWEgaGFzaCBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuXG4gKiBBcyBleHBsYWluZWQgaGVyZTogaHR0cDovL2lzdGhlLmNvbS9jaG9uZ28vdGVjaC9jb21wL2Zudi9cbiAqXG4gKiBAcGFyYW0gcyB7c3RyaW5nfSBTdHJpbmcgdG8gZ2VuZXJhdGUgaGFzaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIHJlc3VsdCBpbnRlZ2VyIGhhc2guXG4gKi9cbmZ1bmN0aW9uIGhhc2gocykge1xuICAgIHZhciBoID0gaGFzaC5CQVNFXG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGggXj0gcy5jaGFyQ29kZUF0KGkpXG4gICAgICAgIGggKz0gKGggPDwgMSkgKyAoaCA8PCA0KSArIChoIDw8IDcpICsgKGggPDwgOCkgKyAoaCA8PCAyNClcbiAgICB9XG5cbiAgICByZXR1cm4gaCA+Pj4gMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zb21lTGltaXQgPSByZXF1aXJlKCcuL3NvbWVMaW1pdCcpO1xuXG52YXIgX3NvbWVMaW1pdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zb21lTGltaXQpO1xuXG52YXIgX2RvTGltaXQgPSByZXF1aXJlKCcuL2ludGVybmFsL2RvTGltaXQnKTtcblxudmFyIF9kb0xpbWl0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvTGltaXQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgc29tZWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5zb21lfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgc29tZVNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuc29tZV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9XG4gKiBAYWxpYXMgYW55U2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbnMgaW4gc2VyaWVzLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiBgcmVzdWx0YCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9kb0xpbWl0Mi5kZWZhdWx0KShfc29tZUxpbWl0Mi5kZWZhdWx0LCAxKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBpcG5zID0gcmVxdWlyZSgnaXBucycpXG5jb25zdCB7IGZyb21CNThTdHJpbmcsIHRvQjU4U3RyaW5nIH0gPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpXG5jb25zdCBQdWJzdWJEYXRhc3RvcmUgPSByZXF1aXJlKCdkYXRhc3RvcmUtcHVic3ViJylcblxuY29uc3Qgd2l0aElzID0gcmVxdWlyZSgnY2xhc3MtaXMnKVxuXG5jb25zdCBlcnJjb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBsb2cgPSBkZWJ1ZygnaXBmczppcG5zOnB1YnN1YicpXG5sb2cuZXJyb3IgPSBkZWJ1ZygnaXBmczppcG5zOnB1YnN1YjplcnJvcicpXG5cbi8vIFB1YnN1YiBkYXRhc3RvcmUgYWltcyB0byBtYW5hZ2UgdGhlIHB1YnN1YiBzdWJzY3JpcHRpb25zIGZvciBJUE5TXG5jbGFzcyBJcG5zUHVic3ViRGF0YXN0b3JlIHtcbiAgY29uc3RydWN0b3IgKHB1YnN1YiwgbG9jYWxEYXRhc3RvcmUsIHBlZXJJZCkge1xuICAgIHRoaXMuX3B1YnN1YiA9IHB1YnN1YlxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSB7fVxuXG4gICAgLy8gQmluZCBfaGFuZGxlU3Vic2NyaXB0aW9uS2V5IGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgYnkgUHVic3ViRGF0YXN0b3JlLlxuICAgIHRoaXMuX2hhbmRsZVN1YnNjcmlwdGlvbktleSA9IHRoaXMuX2hhbmRsZVN1YnNjcmlwdGlvbktleS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcHVic3ViRHMgPSBuZXcgUHVic3ViRGF0YXN0b3JlKHB1YnN1YiwgbG9jYWxEYXRhc3RvcmUsIHBlZXJJZCwgaXBucy52YWxpZGF0b3IsIHRoaXMuX2hhbmRsZVN1YnNjcmlwdGlvbktleSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXQgYSB2YWx1ZSB0byB0aGUgcHVic3ViIGRhdGFzdG9yZSBpbmRleGVkIGJ5IHRoZSByZWNlaXZlZCBrZXkgcHJvcGVybHkgZW5jb2RlZC5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IGtleSBpZGVudGlmaWVyIG9mIHRoZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlIHZhbHVlIHRvIGJlIHN0b3JlZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcHV0IChrZXksIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3B1YnN1YkRzLnB1dChrZXksIHZhbHVlLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YWx1ZSBmcm9tIHRoZSBwdWJzdWIgZGF0YXN0b3JlIGluZGV4ZWQgYnkgdGhlIHJlY2VpdmVkIGtleSBwcm9wZXJseSBlbmNvZGVkLlxuICAgKiBNb3Jlb3ZlciwgdGhlIGlkZW50aWZpZXIgdG9waWMgaXMgc3Vic2NyaWJlZCBhbmQgdGhlIHB1YnN1YiBkYXRhc3RvcmUgcmVjb3JkcyB3aWxsIGJlXG4gICAqIHVwZGF0ZWQgb25jZSBuZXcgcHVibGlzaGVzIG9jY3VyLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0ga2V5IGlkZW50aWZpZXIgb2YgdGhlIHZhbHVlIHRvIGJlIG9idGFpbmVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCdWZmZXIpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGdldCAoa2V5LCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3B1YnN1YkRzLmdldChrZXksIChlcnIsIHJlcykgPT4ge1xuICAgICAgLy8gQWRkIHRvcGljIHN1YnNjcmliZWRcbiAgICAgIGNvbnN0IG5zID0ga2V5LnNsaWNlKDAsIGlwbnMubmFtZXNwYWNlTGVuZ3RoKVxuXG4gICAgICBpZiAobnMudG9TdHJpbmcoKSA9PT0gaXBucy5uYW1lc3BhY2UpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRUb3BpYyA9IGtleS50b1N0cmluZygpXG4gICAgICAgIGNvbnN0IGlkID0gdG9CNThTdHJpbmcoa2V5LnNsaWNlKGlwbnMubmFtZXNwYWNlTGVuZ3RoKSlcblxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3N0cmluZ2lmaWVkVG9waWNdID0gaWRcblxuICAgICAgICBsb2coYHN1YnNjcmliZWQgcHVic3ViICR7c3RyaW5naWZpZWRUb3BpY306ICR7aWR9YClcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gZGF0YSB3YXMgb2J0YWluZWQsIGFmdGVyIHN0b3JpbmcgdGhlIHN1YnNjcmlwdGlvbiwgcmV0dXJuIHRoZSBlcnJvci5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKVxuICAgIH0pXG4gIH1cblxuICAvLyBNb2RpZnkgc3Vic2NyaXB0aW9uIGtleSB0byBoYXZlIGEgcHJvcGVyIGVuY29kaW5nXG4gIF9oYW5kbGVTdWJzY3JpcHRpb25LZXkgKGtleSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzdWJzY3JpYmVyID0gdGhpcy5fc3Vic2NyaXB0aW9uc1trZXldXG5cbiAgICBpZiAoIXN1YnNjcmliZXIpIHtcbiAgICAgIGNvbnN0IGVyck1zZyA9IGBrZXkgJHtrZXl9IGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gYSBzdWJzY3JpcHRpb25gXG5cbiAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX0tFWScpKVxuICAgIH1cblxuICAgIGxldCBrZXlzXG4gICAgdHJ5IHtcbiAgICAgIGtleXMgPSBpcG5zLmdldElkS2V5cyhmcm9tQjU4U3RyaW5nKHN1YnNjcmliZXIpKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLmVycm9yKGVycilcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwga2V5cy5yb3V0aW5nS2V5LnRvQnVmZmVyKCkpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHB1YnN1YiBzdWJzY3JpcHRpb25zIHJlbGF0ZWQgdG8gaXBucy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgT2JqZWN0KX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBnZXRTdWJzY3JpcHRpb25zIChjYWxsYmFjaykge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMuX3N1YnNjcmlwdGlvbnMpLmZpbHRlcihCb29sZWFuKVxuXG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHN1YnNjcmlwdGlvbnMubWFwKChzdWIpID0+IGAke2lwbnMubmFtZXNwYWNlfSR7c3VifWApKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBwdWJzdWIgc3Vic2NyaXB0aW9ucyByZWxhdGVkIHRvIGlwbnMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGlwbnMgcGF0aCB0byBjYW5jZWwgdGhlIHB1YnN1YiBzdWJzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIE9iamVjdCl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgY2FuY2VsIChuYW1lLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGVyck1zZyA9IGByZWNlaXZlZCBzdWJzY3JpcHRpb24gbmFtZSBpcyBub3QgdmFsaWRgXG5cbiAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX1NVQlNDUklQVElPTl9OQU1FJykpXG4gICAgfVxuXG4gICAgLy8gVHJpbSAvaXBucy8gcHJlZml4IGZyb20gdGhlIG5hbWVcbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKGlwbnMubmFtZXNwYWNlKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKGlwbnMubmFtZXNwYWNlTGVuZ3RoKVxuICAgIH1cblxuICAgIGNvbnN0IHN0cmluZ2lmaWVkVG9waWMgPSBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zKS5maW5kKChrZXkpID0+IHRoaXMuX3N1YnNjcmlwdGlvbnNba2V5XSA9PT0gbmFtZSlcblxuICAgIC8vIE5vdCBmb3VuZCB0b3BpY1xuICAgIGlmICghc3RyaW5naWZpZWRUb3BpYykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgY2FuY2VsZWQ6IGZhbHNlXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIFVuc3Vic2NyaWJlIHRvcGljXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJ1ZlRvcGljID0gQnVmZmVyLmZyb20oc3RyaW5naWZpZWRUb3BpYylcblxuICAgICAgdGhpcy5fcHVic3ViRHMudW5zdWJzY3JpYmUoYnVmVG9waWMpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cblxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNbc3RyaW5naWZpZWRUb3BpY10gPSB1bmRlZmluZWRcbiAgICBsb2coYHVuc3Vic2NyaWJlZCBwdWJzdWIgJHtzdHJpbmdpZmllZFRvcGljfTogJHtuYW1lfWApXG5cbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICBjYW5jZWxlZDogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gd2l0aElzKElwbnNQdWJzdWJEYXRhc3RvcmUsIHsgY2xhc3NOYW1lOiAnSXBuc1B1YnN1YkRhdGFzdG9yZScsIHN5bWJvbE5hbWU6ICdAanMtaXBmcy9pcG5zL0lwbnNQdWJzdWJEYXRhc3RvcmUnIH0pXG4iLCIvKiBlc2xpbnQgbWF4LW5lc3RlZC1jYWxsYmFja3M6IFtcImVycm9yXCIsIDVdICovXG4ndXNlIHN0cmljdCdcblxuY29uc3Qgc2FuaXRpemUgPSByZXF1aXJlKCdzYW5pdGl6ZS1maWxlbmFtZScpXG5jb25zdCBtZXJnZU9wdGlvbnMgPSByZXF1aXJlKCdtZXJnZS1vcHRpb25zJylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2xpYnAycC1jcnlwdG8nKVxuY29uc3QgRFMgPSByZXF1aXJlKCdpbnRlcmZhY2UtZGF0YXN0b3JlJylcbmNvbnN0IGNvbGxlY3QgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9zaW5rcy9jb2xsZWN0JylcbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9wdWxsJylcbmNvbnN0IENNUyA9IHJlcXVpcmUoJy4vY21zJylcbmNvbnN0IGVycmNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5cbmNvbnN0IGtleVByZWZpeCA9ICcvcGtjczgvJ1xuY29uc3QgaW5mb1ByZWZpeCA9ICcvaW5mby8nXG5cbi8vIE5JU1QgU1AgODAwLTEzMlxuY29uc3QgTklTVCA9IHtcbiAgbWluS2V5TGVuZ3RoOiAxMTIgLyA4LFxuICBtaW5TYWx0TGVuZ3RoOiAxMjggLyA4LFxuICBtaW5JdGVyYXRpb25Db3VudDogMTAwMFxufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gU2VlIGh0dHBzOi8vY3J5cHRvc2Vuc2UuY29tL3BhcmFtZXRlc3ItY2hvaWNlLWZvci1wYmtkZjIvXG4gIGRlazoge1xuICAgIGtleUxlbmd0aDogNTEyIC8gOCxcbiAgICBpdGVyYXRpb25Db3VudDogMTAwMDAsXG4gICAgc2FsdDogJ3lvdSBzaG91bGQgb3ZlcnJpZGUgdGhpcyB2YWx1ZSB3aXRoIGEgY3J5cHRvIHNlY3VyZSByYW5kb20gbnVtYmVyJyxcbiAgICBoYXNoOiAnc2hhMi01MTInXG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVLZXlOYW1lIChuYW1lKSB7XG4gIGlmICghbmFtZSkgcmV0dXJuIGZhbHNlXG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZVxuICByZXR1cm4gbmFtZSA9PT0gc2FuaXRpemUobmFtZS50cmltKCkpXG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBlcnJvciB0byB0aGUgY2FsbGVyLCBhZnRlciBhIGRlbGF5XG4gKlxuICogVGhpcyBhc3N1bWVzIHRoYW4gYW4gZXJyb3IgaW5kaWNhdGVzIHRoYXQgdGhlIGtleWNoYWluIGlzIHVuZGVyIGF0dGFjay4gRGVsYXkgcmV0dXJuaW5nIGFuXG4gKiBlcnJvciB0byBtYWtlIGJydXRlIGZvcmNlIGF0dGFja3MgaGFyZGVyLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayAtIFRoZSBjYWxsZXJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgRXJyb3J9IGVyciAtIFRoZSBlcnJvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9lcnJvciAoY2FsbGJhY2ssIGVycikge1xuICBjb25zdCBtaW4gPSAyMDBcbiAgY29uc3QgbWF4ID0gMTAwMFxuICBjb25zdCBkZWxheSA9IE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pblxuXG4gIHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5LCBlcnIsIG51bGwpXG59XG5cbi8qKlxuICogQ29udmVydHMgYSBrZXkgbmFtZSBpbnRvIGEgZGF0YXN0b3JlIG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtEUy5LZXl9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBEc05hbWUgKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBEUy5LZXkoa2V5UHJlZml4ICsgbmFtZSlcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGtleSBuYW1lIGludG8gYSBkYXRhc3RvcmUgaW5mbyBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7RFMuS2V5fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRHNJbmZvTmFtZSAobmFtZSkge1xuICByZXR1cm4gbmV3IERTLktleShpbmZvUHJlZml4ICsgbmFtZSlcbn1cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCBhIGtleS5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBLZXlJbmZvXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXZlcnNhbGx5IHVuaXF1ZSBrZXkgaWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBsb2NhbCBrZXkgbmFtZS5cbiAqL1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIGxpZmVjeWNsZSBvZiBhIGtleS4gS2V5cyBhcmUgZW5jcnlwdGVkIGF0IHJlc3QgdXNpbmcgUEtDUyAjOC5cbiAqXG4gKiBBIGtleSBpbiB0aGUgc3RvcmUgaGFzIHR3byBlbnRyaWVzXG4gKiAtICcvaW5mby8qa2V5LW5hbWUqJywgY29udGFpbnMgdGhlIEtleUluZm8gZm9yIHRoZSBrZXlcbiAqIC0gJy9wa2NzOC8qa2V5LW5hbWUqJywgY29udGFpbnMgdGhlIFBLQ1MgIzggZm9yIHRoZSBrZXlcbiAqXG4gKi9cbmNsYXNzIEtleWNoYWluIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBrZXkgY2hhaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7RFN9IHN0b3JlIC0gd2hlcmUgdGhlIGtleSBhcmUuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gPz8/XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc3RvcmUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXN0b3JlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0b3JlIGlzIHJlcXVpcmVkJylcbiAgICB9XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlXG5cbiAgICBjb25zdCBvcHRzID0gbWVyZ2VPcHRpb25zKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuXG4gICAgLy8gRW5mb3JjZSBOSVNUIFNQIDgwMC0xMzJcbiAgICBpZiAoIW9wdHMucGFzc1BocmFzZSB8fCBvcHRzLnBhc3NQaHJhc2UubGVuZ3RoIDwgMjApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFzc1BocmFzZSBtdXN0IGJlIGxlYXN0IDIwIGNoYXJhY3RlcnMnKVxuICAgIH1cbiAgICBpZiAob3B0cy5kZWsua2V5TGVuZ3RoIDwgTklTVC5taW5LZXlMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZGVrLmtleUxlbmd0aCBtdXN0IGJlIGxlYXN0ICR7TklTVC5taW5LZXlMZW5ndGh9IGJ5dGVzYClcbiAgICB9XG4gICAgaWYgKG9wdHMuZGVrLnNhbHQubGVuZ3RoIDwgTklTVC5taW5TYWx0TGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGRlay5zYWx0TGVuZ3RoIG11c3QgYmUgbGVhc3QgJHtOSVNULm1pblNhbHRMZW5ndGh9IGJ5dGVzYClcbiAgICB9XG4gICAgaWYgKG9wdHMuZGVrLml0ZXJhdGlvbkNvdW50IDwgTklTVC5taW5JdGVyYXRpb25Db3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBkZWsuaXRlcmF0aW9uQ291bnQgbXVzdCBiZSBsZWFzdCAke05JU1QubWluSXRlcmF0aW9uQ291bnR9YClcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIGRlcml2ZWQgZW5jcnlwdGluZyBrZXlcbiAgICBjb25zdCBkZWsgPSBjcnlwdG8ucGJrZGYyKFxuICAgICAgb3B0cy5wYXNzUGhyYXNlLFxuICAgICAgb3B0cy5kZWsuc2FsdCxcbiAgICAgIG9wdHMuZGVrLml0ZXJhdGlvbkNvdW50LFxuICAgICAgb3B0cy5kZWsua2V5TGVuZ3RoLFxuICAgICAgb3B0cy5kZWsuaGFzaClcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ18nLCB7IHZhbHVlOiAoKSA9PiBkZWsgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCB0aGF0IGNhbiBlbmNyeXB0L2RlY3J5cHQgcHJvdGVjdGVkIGRhdGFcbiAgICogdXNpbmcgdGhlIENyeXB0b2dyYXBoaWMgTWVzc2FnZSBTeW50YXggKENNUykuXG4gICAqXG4gICAqIENNUyBkZXNjcmliZXMgYW4gZW5jYXBzdWxhdGlvbiBzeW50YXggZm9yIGRhdGEgcHJvdGVjdGlvbi4gSXRcbiAgICogaXMgdXNlZCB0byBkaWdpdGFsbHkgc2lnbiwgZGlnZXN0LCBhdXRoZW50aWNhdGUsIG9yIGVuY3J5cHRcbiAgICogYXJiaXRyYXJ5IG1lc3NhZ2UgY29udGVudC5cbiAgICpcbiAgICogQHJldHVybnMge0NNU31cbiAgICovXG4gIGdldCBjbXMgKCkge1xuICAgIHJldHVybiBuZXcgQ01TKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBvcHRpb25zIGZvciBhIGtleWNoYWluLiAgQSByYW5kb20gc2FsdCBpcyBwcm9kdWNlZC5cbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZU9wdGlvbnMgKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucylcbiAgICBjb25zdCBzYWx0TGVuZ3RoID0gTWF0aC5jZWlsKE5JU1QubWluU2FsdExlbmd0aCAvIDMpICogMyAvLyBubyBiYXNlNjQgcGFkZGluZ1xuICAgIG9wdGlvbnMuZGVrLnNhbHQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoc2FsdExlbmd0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCB0aGF0IGNhbiBlbmNyeXB0L2RlY3J5cHQgcHJvdGVjdGVkIGRhdGEuXG4gICAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIGEga2V5Y2hhaW4uXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IG9wdGlvbnMgKCkge1xuICAgIHJldHVybiBkZWZhdWx0T3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGxvY2FsIGtleSBuYW1lOyBjYW5ub3QgYWxyZWFkeSBleGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBPbmUgb2YgdGhlIGtleSB0eXBlczsgJ3JzYScuXG4gICAqIEBwYXJhbSB7aW50fSBzaXplIC0gVGhlIGtleSBzaXplIGluIGJpdHMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEtleUluZm8pfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgY3JlYXRlS2V5IChuYW1lLCB0eXBlLCBzaXplLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgICBpZiAoIXZhbGlkYXRlS2V5TmFtZShuYW1lKSB8fCBuYW1lID09PSAnc2VsZicpIHtcbiAgICAgIHJldHVybiBfZXJyb3IoY2FsbGJhY2ssIGVycmNvZGUobmV3IEVycm9yKGBJbnZhbGlkIGtleSBuYW1lICcke25hbWV9J2ApLCAnRVJSX0lOVkFMSURfS0VZX05BTUUnKSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnJjb2RlKG5ldyBFcnJvcihgSW52YWxpZCBrZXkgdHlwZSAnJHt0eXBlfSdgKSwgJ0VSUl9JTlZBTElEX0tFWV9UWVBFJykpXG4gICAgfVxuXG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihzaXplKSkge1xuICAgICAgcmV0dXJuIF9lcnJvcihjYWxsYmFjaywgZXJyY29kZShuZXcgRXJyb3IoYEludmFsaWQga2V5IHNpemUgJyR7c2l6ZX0nYCksICdFUlJfSU5WQUxJRF9LRVlfU0laRScpKVxuICAgIH1cblxuICAgIGNvbnN0IGRzbmFtZSA9IERzTmFtZShuYW1lKVxuICAgIHNlbGYuc3RvcmUuaGFzKGRzbmFtZSwgKGVyciwgZXhpc3RzKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnIpXG4gICAgICBpZiAoZXhpc3RzKSByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnJjb2RlKG5ldyBFcnJvcihgS2V5ICcke25hbWV9JyBhbHJlYWR5IGV4aXN0c2ApLCAnRVJSX0tFWV9BTFJFQURZX0VYSVNUUycpKVxuXG4gICAgICBzd2l0Y2ggKHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdyc2EnOlxuICAgICAgICAgIGlmIChzaXplIDwgMjA0OCkge1xuICAgICAgICAgICAgcmV0dXJuIF9lcnJvcihjYWxsYmFjaywgZXJyY29kZShuZXcgRXJyb3IoYEludmFsaWQgUlNBIGtleSBzaXplICR7c2l6ZX1gKSwgJ0VSUl9JTlZBTElEX0tFWV9TSVpFJykpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY3J5cHRvLmtleXMuZ2VuZXJhdGVLZXlQYWlyKHR5cGUsIHNpemUsIChlcnIsIGtleXBhaXIpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIF9lcnJvcihjYWxsYmFjaywgZXJyKVxuICAgICAgICBrZXlwYWlyLmlkKChlcnIsIGtpZCkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBfZXJyb3IoY2FsbGJhY2ssIGVycilcbiAgICAgICAgICBrZXlwYWlyLmV4cG9ydCh0aGlzLl8oKSwgKGVyciwgcGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnIpXG4gICAgICAgICAgICBjb25zdCBrZXlJbmZvID0ge1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpZDoga2lkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IHNlbGYuc3RvcmUuYmF0Y2goKVxuICAgICAgICAgICAgYmF0Y2gucHV0KGRzbmFtZSwgcGVtKVxuICAgICAgICAgICAgYmF0Y2gucHV0KERzSW5mb05hbWUobmFtZSksIEpTT04uc3RyaW5naWZ5KGtleUluZm8pKVxuICAgICAgICAgICAgYmF0Y2guY29tbWl0KChlcnIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIF9lcnJvcihjYWxsYmFjaywgZXJyKVxuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGtleUluZm8pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogTGlzdCBhbGwgdGhlIGtleXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEtleUluZm9bXSl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBsaXN0S2V5cyAoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIGNvbnN0IHF1ZXJ5ID0ge1xuICAgICAgcHJlZml4OiBpbmZvUHJlZml4XG4gICAgfVxuICAgIHB1bGwoXG4gICAgICBzZWxmLnN0b3JlLnF1ZXJ5KHF1ZXJ5KSxcbiAgICAgIGNvbGxlY3QoKGVyciwgcmVzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBfZXJyb3IoY2FsbGJhY2ssIGVycilcblxuICAgICAgICBjb25zdCBpbmZvID0gcmVzLm1hcChyID0+IEpTT04ucGFyc2Uoci52YWx1ZSkpXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGluZm8pXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGEga2V5IGJ5IGl0J3MgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSB1bml2ZXJzYWxseSB1bmlxdWUga2V5IGlkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEtleUluZm8pfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZmluZEtleUJ5SWQgKGlkLCBjYWxsYmFjaykge1xuICAgIHRoaXMubGlzdEtleXMoKGVyciwga2V5cykgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIF9lcnJvcihjYWxsYmFjaywgZXJyKVxuXG4gICAgICBjb25zdCBrZXkgPSBrZXlzLmZpbmQoKGspID0+IGsuaWQgPT09IGlkKVxuICAgICAgY2FsbGJhY2sobnVsbCwga2V5KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRmluZCBhIGtleSBieSBpdCdzIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGxvY2FsIGtleSBuYW1lLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBLZXlJbmZvKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGZpbmRLZXlCeU5hbWUgKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF2YWxpZGF0ZUtleU5hbWUobmFtZSkpIHtcbiAgICAgIHJldHVybiBfZXJyb3IoY2FsbGJhY2ssIGVycmNvZGUobmV3IEVycm9yKGBJbnZhbGlkIGtleSBuYW1lICcke25hbWV9J2ApLCAnRVJSX0lOVkFMSURfS0VZX05BTUUnKSlcbiAgICB9XG5cbiAgICBjb25zdCBkc25hbWUgPSBEc0luZm9OYW1lKG5hbWUpXG4gICAgdGhpcy5zdG9yZS5nZXQoZHNuYW1lLCAoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIF9lcnJvcihjYWxsYmFjaywgZXJyY29kZShuZXcgRXJyb3IoYEtleSAnJHtuYW1lfScgZG9lcyBub3QgZXhpc3QuICR7ZXJyLm1lc3NhZ2V9YCksICdFUlJfS0VZX05PVF9GT1VORCcpKVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBKU09OLnBhcnNlKHJlcy50b1N0cmluZygpKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBleGlzdGluZyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGxvY2FsIGtleSBuYW1lOyBtdXN0IGFscmVhZHkgZXhpc3QuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEtleUluZm8pfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgcmVtb3ZlS2V5IChuYW1lLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgaWYgKCF2YWxpZGF0ZUtleU5hbWUobmFtZSkgfHwgbmFtZSA9PT0gJ3NlbGYnKSB7XG4gICAgICByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnJjb2RlKG5ldyBFcnJvcihgSW52YWxpZCBrZXkgbmFtZSAnJHtuYW1lfSdgKSwgJ0VSUl9JTlZBTElEX0tFWV9OQU1FJykpXG4gICAgfVxuICAgIGNvbnN0IGRzbmFtZSA9IERzTmFtZShuYW1lKVxuICAgIHNlbGYuZmluZEtleUJ5TmFtZShuYW1lLCAoZXJyLCBrZXlpbmZvKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnIpXG4gICAgICBjb25zdCBiYXRjaCA9IHNlbGYuc3RvcmUuYmF0Y2goKVxuICAgICAgYmF0Y2guZGVsZXRlKGRzbmFtZSlcbiAgICAgIGJhdGNoLmRlbGV0ZShEc0luZm9OYW1lKG5hbWUpKVxuICAgICAgYmF0Y2guY29tbWl0KChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIF9lcnJvcihjYWxsYmFjaywgZXJyKVxuICAgICAgICBjYWxsYmFjayhudWxsLCBrZXlpbmZvKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmFtZSBhIGtleVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkTmFtZSAtIFRoZSBvbGQgbG9jYWwga2V5IG5hbWU7IG11c3QgYWxyZWFkeSBleGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld05hbWUgLSBUaGUgbmV3IGxvY2FsIGtleSBuYW1lOyBtdXN0IG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBLZXlJbmZvKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHJlbmFtZUtleSAob2xkTmFtZSwgbmV3TmFtZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIGlmICghdmFsaWRhdGVLZXlOYW1lKG9sZE5hbWUpIHx8IG9sZE5hbWUgPT09ICdzZWxmJykge1xuICAgICAgcmV0dXJuIF9lcnJvcihjYWxsYmFjaywgZXJyY29kZShuZXcgRXJyb3IoYEludmFsaWQgb2xkIGtleSBuYW1lICcke29sZE5hbWV9J2ApLCAnRVJSX09MRF9LRVlfTkFNRV9JTlZBTElEJykpXG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVLZXlOYW1lKG5ld05hbWUpIHx8IG5ld05hbWUgPT09ICdzZWxmJykge1xuICAgICAgcmV0dXJuIF9lcnJvcihjYWxsYmFjaywgZXJyY29kZShuZXcgRXJyb3IoYEludmFsaWQgbmV3IGtleSBuYW1lICcke25ld05hbWV9J2ApLCAnRVJSX05FV19LRVlfTkFNRV9JTlZBTElEJykpXG4gICAgfVxuICAgIGNvbnN0IG9sZERzbmFtZSA9IERzTmFtZShvbGROYW1lKVxuICAgIGNvbnN0IG5ld0RzbmFtZSA9IERzTmFtZShuZXdOYW1lKVxuICAgIGNvbnN0IG9sZEluZm9OYW1lID0gRHNJbmZvTmFtZShvbGROYW1lKVxuICAgIGNvbnN0IG5ld0luZm9OYW1lID0gRHNJbmZvTmFtZShuZXdOYW1lKVxuICAgIHRoaXMuc3RvcmUuZ2V0KG9sZERzbmFtZSwgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBfZXJyb3IoY2FsbGJhY2ssIGVycmNvZGUobmV3IEVycm9yKGBLZXkgJyR7b2xkTmFtZX0nIGRvZXMgbm90IGV4aXN0LiAke2Vyci5tZXNzYWdlfWApLCAnRVJSX0tFWV9OT1RfRk9VTkQnKSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBlbSA9IHJlcy50b1N0cmluZygpXG4gICAgICBzZWxmLnN0b3JlLmhhcyhuZXdEc25hbWUsIChlcnIsIGV4aXN0cykgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnIpXG4gICAgICAgIGlmIChleGlzdHMpIHJldHVybiBfZXJyb3IoY2FsbGJhY2ssIGVycmNvZGUobmV3IEVycm9yKGBLZXkgJyR7bmV3TmFtZX0nIGFscmVhZHkgZXhpc3RzYCksICdFUlJfS0VZX0FMUkVBRFlfRVhJU1RTJykpXG5cbiAgICAgICAgc2VsZi5zdG9yZS5nZXQob2xkSW5mb05hbWUsIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBfZXJyb3IoY2FsbGJhY2ssIGVycilcblxuICAgICAgICAgIGNvbnN0IGtleUluZm8gPSBKU09OLnBhcnNlKHJlcy50b1N0cmluZygpKVxuICAgICAgICAgIGtleUluZm8ubmFtZSA9IG5ld05hbWVcbiAgICAgICAgICBjb25zdCBiYXRjaCA9IHNlbGYuc3RvcmUuYmF0Y2goKVxuICAgICAgICAgIGJhdGNoLnB1dChuZXdEc25hbWUsIHBlbSlcbiAgICAgICAgICBiYXRjaC5wdXQobmV3SW5mb05hbWUsIEpTT04uc3RyaW5naWZ5KGtleUluZm8pKVxuICAgICAgICAgIGJhdGNoLmRlbGV0ZShvbGREc25hbWUpXG4gICAgICAgICAgYmF0Y2guZGVsZXRlKG9sZEluZm9OYW1lKVxuICAgICAgICAgIGJhdGNoLmNvbW1pdCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnIpXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBrZXlJbmZvKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRXhwb3J0IGFuIGV4aXN0aW5nIGtleSBhcyBhIFBFTSBlbmNyeXB0ZWQgUEtDUyAjOCBzdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbG9jYWwga2V5IG5hbWU7IG11c3QgYWxyZWFkeSBleGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVGhlIHBhc3N3b3JkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIHN0cmluZyl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBleHBvcnRLZXkgKG5hbWUsIHBhc3N3b3JkLCBjYWxsYmFjaykge1xuICAgIGlmICghdmFsaWRhdGVLZXlOYW1lKG5hbWUpKSB7XG4gICAgICByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnJjb2RlKG5ldyBFcnJvcihgSW52YWxpZCBrZXkgbmFtZSAnJHtuYW1lfSdgKSwgJ0VSUl9JTlZBTElEX0tFWV9OQU1FJykpXG4gICAgfVxuICAgIGlmICghcGFzc3dvcmQpIHtcbiAgICAgIHJldHVybiBfZXJyb3IoY2FsbGJhY2ssIGVycmNvZGUobmV3IEVycm9yKCdQYXNzd29yZCBpcyByZXF1aXJlZCcpLCAnRVJSX1BBU1NXT1JEX1JFUVVJUkVEJykpXG4gICAgfVxuXG4gICAgY29uc3QgZHNuYW1lID0gRHNOYW1lKG5hbWUpXG4gICAgdGhpcy5zdG9yZS5nZXQoZHNuYW1lLCAoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIF9lcnJvcihjYWxsYmFjaywgZXJyY29kZShuZXcgRXJyb3IoYEtleSAnJHtuYW1lfScgZG9lcyBub3QgZXhpc3QuICR7ZXJyLm1lc3NhZ2V9YCksICdFUlJfS0VZX05PVF9GT1VORCcpKVxuICAgICAgfVxuICAgICAgY29uc3QgcGVtID0gcmVzLnRvU3RyaW5nKClcbiAgICAgIGNyeXB0by5rZXlzLl9faW1wb3J0X18ocGVtLCB0aGlzLl8oKSwgKGVyciwgcHJpdmF0ZUtleSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnIpXG4gICAgICAgIHByaXZhdGVLZXkuZXhwb3J0KHBhc3N3b3JkLCBjYWxsYmFjaylcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBvcnQgYSBuZXcga2V5IGZyb20gYSBQRU0gZW5jb2RlZCBQS0NTICM4IHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBsb2NhbCBrZXkgbmFtZTsgbXVzdCBub3QgYWxyZWFkeSBleGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBlbSAtIFRoZSBQRU0gZW5jb2RlZCBQS0NTICM4IHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBUaGUgcGFzc3dvcmQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEtleUluZm8pfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgaW1wb3J0S2V5IChuYW1lLCBwZW0sIHBhc3N3b3JkLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgaWYgKCF2YWxpZGF0ZUtleU5hbWUobmFtZSkgfHwgbmFtZSA9PT0gJ3NlbGYnKSB7XG4gICAgICByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnJjb2RlKG5ldyBFcnJvcihgSW52YWxpZCBrZXkgbmFtZSAnJHtuYW1lfSdgKSwgJ0VSUl9JTlZBTElEX0tFWV9OQU1FJykpXG4gICAgfVxuICAgIGlmICghcGVtKSB7XG4gICAgICByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCAnUEVNIGVuY29kZWQga2V5IGlzIHJlcXVpcmVkJylcbiAgICB9XG4gICAgY29uc3QgZHNuYW1lID0gRHNOYW1lKG5hbWUpXG4gICAgc2VsZi5zdG9yZS5oYXMoZHNuYW1lLCAoZXJyLCBleGlzdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBfZXJyb3IoY2FsbGJhY2ssIGVycilcbiAgICAgIGlmIChleGlzdHMpIHJldHVybiBfZXJyb3IoY2FsbGJhY2ssIGVycmNvZGUobmV3IEVycm9yKGBLZXkgJyR7bmFtZX0nIGFscmVhZHkgZXhpc3RzYCksICdFUlJfS0VZX0FMUkVBRFlfRVhJU1RTJykpXG4gICAgICBjcnlwdG8ua2V5cy5fX2ltcG9ydF9fKHBlbSwgcGFzc3dvcmQsIChlcnIsIHByaXZhdGVLZXkpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIF9lcnJvcihjYWxsYmFjaywgZXJyY29kZShuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHRoZSBrZXksIG1vc3QgbGlrZWx5IHRoZSBwYXNzd29yZCBpcyB3cm9uZycpLCAnRVJSX0NBTk5PVF9SRUFEX0tFWScpKVxuICAgICAgICBwcml2YXRlS2V5LmlkKChlcnIsIGtpZCkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBfZXJyb3IoY2FsbGJhY2ssIGVycilcbiAgICAgICAgICBwcml2YXRlS2V5LmV4cG9ydCh0aGlzLl8oKSwgKGVyciwgcGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnIpXG4gICAgICAgICAgICBjb25zdCBrZXlJbmZvID0ge1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpZDoga2lkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IHNlbGYuc3RvcmUuYmF0Y2goKVxuICAgICAgICAgICAgYmF0Y2gucHV0KGRzbmFtZSwgcGVtKVxuICAgICAgICAgICAgYmF0Y2gucHV0KERzSW5mb05hbWUobmFtZSksIEpTT04uc3RyaW5naWZ5KGtleUluZm8pKVxuICAgICAgICAgICAgYmF0Y2guY29tbWl0KChlcnIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIF9lcnJvcihjYWxsYmFjaywgZXJyKVxuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGtleUluZm8pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBpbXBvcnRQZWVyIChuYW1lLCBwZWVyLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgaWYgKCF2YWxpZGF0ZUtleU5hbWUobmFtZSkpIHtcbiAgICAgIHJldHVybiBfZXJyb3IoY2FsbGJhY2ssIGVycmNvZGUobmV3IEVycm9yKGBJbnZhbGlkIGtleSBuYW1lICcke25hbWV9J2ApLCAnRVJSX0lOVkFMSURfS0VZX05BTUUnKSlcbiAgICB9XG4gICAgaWYgKCFwZWVyIHx8ICFwZWVyLnByaXZLZXkpIHtcbiAgICAgIHJldHVybiBfZXJyb3IoY2FsbGJhY2ssIGVycmNvZGUobmV3IEVycm9yKCdQZWVyLnByaXZLZXkgaXMgcmVxdWlyZWQnKSwgJ0VSUl9NSVNTSU5HX1BSSVZBVEVfS0VZJykpXG4gICAgfVxuXG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IHBlZXIucHJpdktleVxuICAgIGNvbnN0IGRzbmFtZSA9IERzTmFtZShuYW1lKVxuICAgIHNlbGYuc3RvcmUuaGFzKGRzbmFtZSwgKGVyciwgZXhpc3RzKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnIpXG4gICAgICBpZiAoZXhpc3RzKSByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnJjb2RlKG5ldyBFcnJvcihgS2V5ICcke25hbWV9JyBhbHJlYWR5IGV4aXN0c2ApLCAnRVJSX0tFWV9BTFJFQURZX0VYSVNUUycpKVxuXG4gICAgICBwcml2YXRlS2V5LmlkKChlcnIsIGtpZCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnIpXG4gICAgICAgIHByaXZhdGVLZXkuZXhwb3J0KHRoaXMuXygpLCAoZXJyLCBwZW0pID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnIpXG4gICAgICAgICAgY29uc3Qga2V5SW5mbyA9IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpZDoga2lkXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGJhdGNoID0gc2VsZi5zdG9yZS5iYXRjaCgpXG4gICAgICAgICAgYmF0Y2gucHV0KGRzbmFtZSwgcGVtKVxuICAgICAgICAgIGJhdGNoLnB1dChEc0luZm9OYW1lKG5hbWUpLCBKU09OLnN0cmluZ2lmeShrZXlJbmZvKSlcbiAgICAgICAgICBiYXRjaC5jb21taXQoKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIF9lcnJvcihjYWxsYmFjaywgZXJyKVxuXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBrZXlJbmZvKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcHJpdmF0ZSBrZXkgYXMgUEVNIGVuY29kZWQgUEtDUyAjOCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIHN0cmluZyl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0UHJpdmF0ZUtleSAobmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXZhbGlkYXRlS2V5TmFtZShuYW1lKSkge1xuICAgICAgcmV0dXJuIF9lcnJvcihjYWxsYmFjaywgZXJyY29kZShuZXcgRXJyb3IoYEludmFsaWQga2V5IG5hbWUgJyR7bmFtZX0nYCksICdFUlJfSU5WQUxJRF9LRVlfTkFNRScpKVxuICAgIH1cbiAgICB0aGlzLnN0b3JlLmdldChEc05hbWUobmFtZSksIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gX2Vycm9yKGNhbGxiYWNrLCBlcnJjb2RlKG5ldyBFcnJvcihgS2V5ICcke25hbWV9JyBkb2VzIG5vdCBleGlzdC4gJHtlcnIubWVzc2FnZX1gKSwgJ0VSUl9LRVlfTk9UX0ZPVU5EJykpXG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCByZXMudG9TdHJpbmcoKSlcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5Y2hhaW5cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBpcG5zID0gcmVxdWlyZSgnaXBucycpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdsaWJwMnAtY3J5cHRvJylcbmNvbnN0IFBlZXJJZCA9IHJlcXVpcmUoJ3BlZXItaWQnKVxuY29uc3QgZXJyY29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBsb2cgPSBkZWJ1ZygnaXBmczppcG5zOnJlc29sdmVyJylcbmxvZy5lcnJvciA9IGRlYnVnKCdpcGZzOmlwbnM6cmVzb2x2ZXI6ZXJyb3InKVxuXG5jb25zdCBkZWZhdWx0TWF4aW11bVJlY3Vyc2l2ZURlcHRoID0gMzJcblxuY2xhc3MgSXBuc1Jlc29sdmVyIHtcbiAgY29uc3RydWN0b3IgKHJvdXRpbmcpIHtcbiAgICB0aGlzLl9yb3V0aW5nID0gcm91dGluZ1xuICB9XG5cbiAgcmVzb2x2ZSAobmFtZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZXJyTXNnID0gYG9uZSBvciBtb3JlIG9mIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXJzIGFyZSBub3QgdmFsaWRgXG5cbiAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX1BBUkFNRVRFUicpKVxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgY29uc3QgcmVjdXJzaXZlID0gb3B0aW9ucy5yZWN1cnNpdmUgJiYgb3B0aW9ucy5yZWN1cnNpdmUudG9TdHJpbmcoKSA9PT0gJ3RydWUnXG5cbiAgICBjb25zdCBuYW1lU2VnbWVudHMgPSBuYW1lLnNwbGl0KCcvJylcblxuICAgIGlmIChuYW1lU2VnbWVudHMubGVuZ3RoICE9PSAzIHx8IG5hbWVTZWdtZW50c1swXSAhPT0gJycpIHtcbiAgICAgIGNvbnN0IGVyck1zZyA9IGBpbnZhbGlkIG5hbWUgc3ludGF4IGZvciAke25hbWV9YFxuXG4gICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfSU5WQUxJRF9OQU1FX1NZTlRBWCcpKVxuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IG5hbWVTZWdtZW50c1syXVxuXG4gICAgLy8gRGVmaW5lIGEgbWF4aW11bSBkZXB0aCBpZiByZWN1cnNpdmUgb3B0aW9uIGVuYWJsZWRcbiAgICBsZXQgZGVwdGhcblxuICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgIGRlcHRoID0gZGVmYXVsdE1heGltdW1SZWN1cnNpdmVEZXB0aFxuICAgIH1cblxuICAgIHRoaXMucmVzb2x2ZXIoa2V5LCBkZXB0aCwgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGxvZyhgJHtuYW1lfSB3YXMgbG9jYWxseSByZXNvbHZlZCBjb3JyZWN0bHlgKVxuICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKVxuICAgIH0pXG4gIH1cblxuICAvLyBSZWN1cnNpdmUgcmVzb2x2ZXIgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZGVwdGhcbiAgcmVzb2x2ZXIgKG5hbWUsIGRlcHRoLCBjYWxsYmFjaykge1xuICAgIC8vIEV4Y2VlZGVkIHJlY3Vyc2l2ZSBtYXhpbXVtIGRlcHRoXG4gICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSBgY291bGQgbm90IHJlc29sdmUgbmFtZSAocmVjdXJzaW9uIGxpbWl0IG9mICR7ZGVmYXVsdE1heGltdW1SZWN1cnNpdmVEZXB0aH0gZXhjZWVkZWQpYFxuXG4gICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfUkVTT0xWRV9SRUNVUlNJT05fTElNSVQnKSlcbiAgICB9XG5cbiAgICB0aGlzLl9yZXNvbHZlTmFtZShuYW1lLCAoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmFtZVNlZ21lbnRzID0gcmVzLnNwbGl0KCcvJylcblxuICAgICAgLy8gSWYgb2J0YWluZWQgYSBpcGZzIGNpZCBvciByZWN1cnNpdmUgb3B0aW9uIGlzIGRpc2FibGVkXG4gICAgICBpZiAobmFtZVNlZ21lbnRzWzFdID09PSAnaXBmcycgfHwgIWRlcHRoKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXMpXG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnRpbnVlIHJlY3Vyc2l2ZWx5IHVudGlsIGRlcHRoIGVxdWFscyAwXG4gICAgICB0aGlzLnJlc29sdmVyKG5hbWVTZWdtZW50c1syXSwgZGVwdGggLSAxLCBjYWxsYmFjaylcbiAgICB9KVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBpcG5zIGVudHJpZXMgZnJvbSB0aGUgcHJvdmlkZWQgcm91dGluZ1xuICBfcmVzb2x2ZU5hbWUgKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHBlZXJJZFxuXG4gICAgdHJ5IHtcbiAgICAgIHBlZXJJZCA9IFBlZXJJZC5jcmVhdGVGcm9tQjU4U3RyaW5nKG5hbWUpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cblxuICAgIGNvbnN0IHsgcm91dGluZ0tleSwgcm91dGluZ1B1YktleSB9ID0gaXBucy5nZXRJZEtleXMocGVlcklkLnRvQnl0ZXMoKSlcblxuICAgIHRoaXMuX3JvdXRpbmcuZ2V0KHJvdXRpbmdLZXkudG9CdWZmZXIoKSwgKGVyciwgcmVjb3JkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VSUl9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgY29uc3QgZXJyTXNnID0gYHVuZXhwZWN0ZWQgZXJyb3IgZ2V0dGluZyB0aGUgaXBucyByZWNvcmQgJHtwZWVySWQuaWR9YFxuXG4gICAgICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9VTkVYUEVDVEVEX0VSUk9SX0dFVFRJTkdfUkVDT1JEJykpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyTXNnID0gYHJlY29yZCByZXF1ZXN0ZWQgd2FzIG5vdCBmb3VuZCBmb3IgJHtuYW1lfSAoJHtyb3V0aW5nS2V5fSkgaW4gdGhlIG5ldHdvcmtgXG5cbiAgICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfTk9fUkVDT1JEX0ZPVU5EJykpXG4gICAgICB9XG5cbiAgICAgIC8vIElQTlMgZW50cnlcbiAgICAgIGxldCBpcG5zRW50cnlcbiAgICAgIHRyeSB7XG4gICAgICAgIGlwbnNFbnRyeSA9IGlwbnMudW5tYXJzaGFsKHJlY29yZClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJNc2cgPSBgZm91bmQgaXBucyByZWNvcmQgdGhhdCB3ZSBjb3VsZG4ndCBjb252ZXJ0IHRvIGEgdmFsdWVgXG5cbiAgICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfSU5WQUxJRF9SRUNPUkRfUkVDRUlWRUQnKSlcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIHJlY29yZCBoYXMgYSBwdWJsaWMga2V5IHZhbGlkYXRlIGl0XG4gICAgICBpZiAoaXBuc0VudHJ5LnB1YktleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGVSZWNvcmQocGVlcklkLCBpcG5zRW50cnksIGNhbGxiYWNrKVxuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIHRyeSB0byBnZXQgdGhlIHB1YmxpYyBrZXkgZnJvbSByb3V0aW5nXG4gICAgICB0aGlzLl9yb3V0aW5nLmdldChyb3V0aW5nS2V5LnRvQnVmZmVyKCksIChlcnIsIHB1YktleSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyci5jb2RlICE9PSAnRVJSX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGB1bmV4cGVjdGVkIGVycm9yIGdldHRpbmcgdGhlIHB1YmxpYyBrZXkgZm9yIHRoZSBpcG5zIHJlY29yZCAke3BlZXJJZC5pZH1gXG5cbiAgICAgICAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9VTkVYUEVDVEVEX0VSUk9SX0dFVFRJTkdfUFVCX0tFWScpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBlcnJNc2cgPSBgcHVibGljIGtleSByZXF1ZXN0ZWQgd2FzIG5vdCBmb3VuZCBmb3IgJHtuYW1lfSAoJHtyb3V0aW5nUHViS2V5fSkgaW4gdGhlIG5ldHdvcmtgXG5cbiAgICAgICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKG5ldyBFcnJvcihlcnJNc2cpLCAnRVJSX05PX1JFQ09SRF9GT1VORCcpKVxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJbnNlcnQgaXQgaW50byB0aGUgcGVlciBpZCwgaW4gb3JkZXIgdG8gYmUgdmFsaWRhdGVkIGJ5IElQTlMgdmFsaWRhdG9yXG4gICAgICAgICAgcGVlcklkLnB1YktleSA9IGNyeXB0by5rZXlzLnVubWFyc2hhbFB1YmxpY0tleShwdWJLZXkpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGBmb3VuZCBwdWJsaWMga2V5IHJlY29yZCB0aGF0IHdlIGNvdWxkbid0IGNvbnZlcnQgdG8gYSB2YWx1ZWBcblxuICAgICAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfSU5WQUxJRF9QVUJfS0VZX1JFQ0VJVkVEJykpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl92YWxpZGF0ZVJlY29yZChwZWVySWQsIGlwbnNFbnRyeSwgY2FsbGJhY2spXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyB2YWxpZGF0ZSBhIHJlc29sdmVkIHJlY29yZFxuICBfdmFsaWRhdGVSZWNvcmQgKHBlZXJJZCwgaXBuc0VudHJ5LCBjYWxsYmFjaykge1xuICAgIGlwbnMuZXh0cmFjdFB1YmxpY0tleShwZWVySWQsIGlwbnNFbnRyeSwgKGVyciwgcHViS2V5KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIC8vIElQTlMgZW50cnkgdmFsaWRhdGlvblxuICAgICAgaXBucy52YWxpZGF0ZShwdWJLZXksIGlwbnNFbnRyeSwgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGlwbnNFbnRyeS52YWx1ZS50b1N0cmluZygpKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IElwbnNSZXNvbHZlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gUmVjZXB0YWNsZVxudmFyIHRvTVMgPSByZXF1aXJlKCdtcycpXG52YXIgY2FjaGUgPSBSZWNlcHRhY2xlLnByb3RvdHlwZVxudmFyIGNvdW50ZXIgPSBuZXcgRGF0ZSgpICUgMWU5XG5cbmZ1bmN0aW9uIGdldFVJRCAoKSB7IHJldHVybiAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCkgKyAoY291bnRlcisrKSB9XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNhY2hlIHdpdGggYSBtYXhpbXVtIGtleSBzaXplLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXg9SW5maW5pdHldIHRoZSBtYXhpbXVtIG51bWJlciBvZiBrZXlzIGFsbG93ZWQgaW4gdGhlIGNhY2hlIChscnUpLlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuaXRlbXM9W11dIHRoZSBkZWZhdWx0IGl0ZW1zIGluIHRoZSBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gUmVjZXB0YWNsZSAob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB0aGlzLmlkID0gb3B0aW9ucy5pZCB8fCBnZXRVSUQoKVxuICB0aGlzLm1heCA9IG9wdGlvbnMubWF4IHx8IEluZmluaXR5XG4gIHRoaXMuaXRlbXMgPSBvcHRpb25zLml0ZW1zIHx8IFtdXG4gIHRoaXMuX2xvb2t1cCA9IHt9XG4gIHRoaXMuc2l6ZSA9IHRoaXMuaXRlbXMubGVuZ3RoXG4gIHRoaXMubGFzdE1vZGlmaWVkID0gbmV3IERhdGUob3B0aW9ucy5sYXN0TW9kaWZpZWQgfHwgbmV3IERhdGUoKSlcblxuICAvLyBTZXR1cCBpbml0aWFsIHRpbWVycyBhbmQgaW5kZXhlcyBmb3IgdGhlIGNhY2hlLlxuICBmb3IgKHZhciBpdGVtLCB0dGwsIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaS0tOykge1xuICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2ldXG4gICAgdHRsID0gbmV3IERhdGUoaXRlbS5leHBpcmVzKSAtIG5ldyBEYXRlKClcbiAgICB0aGlzLl9sb29rdXBbaXRlbS5rZXldID0gaXRlbVxuICAgIGlmICh0dGwgPiAwKSB0aGlzLmV4cGlyZShpdGVtLmtleSwgdHRsKVxuICAgIGVsc2UgaWYgKHR0bCA8PSAwKSB0aGlzLmRlbGV0ZShpdGVtLmtleSlcbiAgfVxufVxuXG4vKipcbiAqIFRlc3RzIGlmIGEga2V5IGlzIGN1cnJlbnRseSBpbiB0aGUgY2FjaGUuXG4gKiBEb2VzIG5vdCBjaGVjayBpZiBzbG90IGlzIGVtcHR5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSB0aGUga2V5IHRvIHJldHJpZXZlIGZyb20gdGhlIGNhY2hlLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuY2FjaGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5IGluIHRoaXMuX2xvb2t1cFxufVxuXG4vKipcbiAqIFJldHJpZXZlcyBhIGtleSBmcm9tIHRoZSBjYWNoZSBhbmQgbWFya3MgaXQgYXMgcmVjZW50bHkgdXNlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gdGhlIGtleSB0byByZXRyaWV2ZSBmcm9tIHRoZSBjYWNoZS5cbiAqIEByZXR1cm4geyp9XG4gKi9cbmNhY2hlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKCF0aGlzLmhhcyhrZXkpKSByZXR1cm4gbnVsbFxuICB2YXIgcmVjb3JkID0gdGhpcy5fbG9va3VwW2tleV1cbiAgLy8gVXBkYXRlIGV4cGlyeSBmb3IgXCJyZWZyZXNoXCIga2V5c1xuICBpZiAocmVjb3JkLnJlZnJlc2gpIHRoaXMuZXhwaXJlKGtleSwgcmVjb3JkLnJlZnJlc2gpXG4gIC8vIE1vdmUgdG8gZnJvbnQgb2YgdGhlIGxpbmUuXG4gIHRoaXMuaXRlbXMuc3BsaWNlKHRoaXMuaXRlbXMuaW5kZXhPZihyZWNvcmQpLCAxKVxuICB0aGlzLml0ZW1zLnB1c2gocmVjb3JkKVxuICByZXR1cm4gcmVjb3JkLnZhbHVlXG59XG5cbi8qKlxuICogUmV0cmlldmVzIHVzZXIgbWV0YSBkYXRhIGZvciBhIGNhY2hlZCBpdGVtLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSB0aGUga2V5IHRvIHJldHJpZXZlIG1ldGEgZGF0YSBmcm9tIHRoZSBjYWNoZS5cbiAqIEByZXR1cm4geyp9XG4gKi9cbmNhY2hlLm1ldGEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICghdGhpcy5oYXMoa2V5KSkgcmV0dXJuIG51bGxcbiAgdmFyIHJlY29yZCA9IHRoaXMuX2xvb2t1cFtrZXldXG4gIGlmICghKCdtZXRhJyBpbiByZWNvcmQpKSByZXR1cm4gbnVsbFxuICByZXR1cm4gcmVjb3JkLm1ldGFcbn1cblxuLyoqXG4gKiBQdXRzIGEga2V5IGludG8gdGhlIGNhY2hlIHdpdGggYW4gb3B0aW9uYWwgZXhwaXJ5IHRpbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIHRoZSBrZXkgZm9yIHRoZSB2YWx1ZSBpbiB0aGUgY2FjaGUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIHBsYWNlIGF0IHRoZSBrZXkuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudHRsXSAtIGEgdGltZSBhZnRlciB3aGljaCB0aGUga2V5IHdpbGwgYmUgcmVtb3ZlZC5cbiAqIEByZXR1cm4ge1JlY2VwdGFjbGV9XG4gKi9cbmNhY2hlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBvbGRSZWNvcmQgPSB0aGlzLl9sb29rdXBba2V5XVxuICB2YXIgcmVjb3JkID0gdGhpcy5fbG9va3VwW2tleV0gPSB7IGtleToga2V5LCB2YWx1ZTogdmFsdWUgfVxuICAvLyBNYXJrIGNhY2hlIGFzIG1vZGlmaWVkLlxuICB0aGlzLmxhc3RNb2RpZmllZCA9IG5ldyBEYXRlKClcblxuICBpZiAob2xkUmVjb3JkKSB7XG4gICAgLy8gUmVwbGFjZSBhbiBvbGQga2V5LlxuICAgIGNsZWFyVGltZW91dChvbGRSZWNvcmQudGltZW91dClcbiAgICB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2Yob2xkUmVjb3JkKSwgMSwgcmVjb3JkKVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbW92ZSBsZWFzdCB1c2VkIGl0ZW0gaWYgbmVlZGVkLlxuICAgIGlmICh0aGlzLnNpemUgPj0gdGhpcy5tYXgpIHRoaXMuZGVsZXRlKHRoaXMuaXRlbXNbMF0ua2V5KVxuICAgIC8vIEFkZCBhIG5ldyBrZXkuXG4gICAgdGhpcy5pdGVtcy5wdXNoKHJlY29yZClcbiAgICB0aGlzLnNpemUrK1xuICB9XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICAvLyBTZXR1cCBrZXkgZXhwaXJ5LlxuICAgIGlmICgndHRsJyBpbiBvcHRpb25zKSB0aGlzLmV4cGlyZShrZXksIG9wdGlvbnMudHRsKVxuICAgIC8vIFN0b3JlIHVzZXIgb3B0aW9ucyBpbiB0aGUgcmVjb3JkLlxuICAgIGlmICgnbWV0YScgaW4gb3B0aW9ucykgcmVjb3JkLm1ldGEgPSBvcHRpb25zLm1ldGFcbiAgICAvLyBNYXJrIGEgYXV0byByZWZyZXNoIGtleS5cbiAgICBpZiAob3B0aW9ucy5yZWZyZXNoKSByZWNvcmQucmVmcmVzaCA9IG9wdGlvbnMudHRsXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIERlbGV0ZXMgYW4gaXRlbSBmcm9tIHRoZSBjYWNoZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gdGhlIGtleSB0byByZW1vdmUuXG4gKiBAcmV0dXJuIHtSZWNlcHRhY2xlfVxuICovXG5jYWNoZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciByZWNvcmQgPSB0aGlzLl9sb29rdXBba2V5XVxuICBpZiAoIXJlY29yZCkgcmV0dXJuIGZhbHNlXG4gIHRoaXMubGFzdE1vZGlmaWVkID0gbmV3IERhdGUoKVxuICB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YocmVjb3JkKSwgMSlcbiAgY2xlYXJUaW1lb3V0KHJlY29yZC50aW1lb3V0KVxuICBkZWxldGUgdGhpcy5fbG9va3VwW2tleV1cbiAgdGhpcy5zaXplLS1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHRvIHJlZ2lzdGVyIGEga2V5IHRoYXQgd2lsbCBiZSByZW1vdmVkIGFmdGVyIHNvbWUgdGltZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gdGhlIGtleSB0byByZW1vdmUuXG4gKiBAcGFyYW0ge051bWJlcn0gW21zXSAtIHRoZSB0aW1lb3V0IGJlZm9yZSByZW1vdmFsLlxuICogQHJldHVybiB7UmVjZXB0YWNsZX1cbiAqL1xuY2FjaGUuZXhwaXJlID0gZnVuY3Rpb24gKGtleSwgdHRsKSB7XG4gIHZhciBtcyA9IHR0bCB8fCAwXG4gIHZhciByZWNvcmQgPSB0aGlzLl9sb29rdXBba2V5XVxuICBpZiAoIXJlY29yZCkgcmV0dXJuIHRoaXNcbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIG1zID0gdG9NUyh0dGwpXG4gIGlmICh0eXBlb2YgbXMgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBpcmF0aW9uIHRpbWUgbXVzdCBiZSBhIHN0cmluZyBvciBudW1iZXIuJylcbiAgY2xlYXJUaW1lb3V0KHJlY29yZC50aW1lb3V0KVxuICByZWNvcmQudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5kZWxldGUuYmluZCh0aGlzLCByZWNvcmQua2V5KSwgbXMpXG4gIHJlY29yZC5leHBpcmVzID0gTnVtYmVyKG5ldyBEYXRlKCkpICsgbXNcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBEZWxldGVzIGFsbCBpdGVtcyBmcm9tIHRoZSBjYWNoZS5cbiAqIEByZXR1cm4ge1JlY2VwdGFjbGV9XG4gKi9cbmNhY2hlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5pdGVtcy5sZW5ndGg7IGktLTspIHRoaXMuZGVsZXRlKHRoaXMuaXRlbXNbaV0ua2V5KVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEZpeGVzIHNlcmlhbGl6YXRpb24gaXNzdWVzIGluIHBvbHlmaWxsZWQgZW52aXJvbm1lbnRzLlxuICogRW5zdXJlcyBub24tY3ljbGljYWwgc2VyaWFsaXplZCBvYmplY3QuXG4gKi9cbmNhY2hlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGl0ZW1zID0gbmV3IEFycmF5KHRoaXMuaXRlbXMubGVuZ3RoKVxuICB2YXIgaXRlbVxuICBmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoOyBpLS07KSB7XG4gICAgaXRlbSA9IHRoaXMuaXRlbXNbaV1cbiAgICBpdGVtc1tpXSA9IHtcbiAgICAgIGtleTogaXRlbS5rZXksXG4gICAgICBtZXRhOiBpdGVtLm1ldGEsXG4gICAgICB2YWx1ZTogaXRlbS52YWx1ZSxcbiAgICAgIGV4cGlyZXM6IGl0ZW0uZXhwaXJlcyxcbiAgICAgIHJlZnJlc2g6IGl0ZW0ucmVmcmVzaFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaWQ6IHRoaXMuaWQsXG4gICAgbWF4OiBpc0Zpbml0ZSh0aGlzLm1heCkgPyB0aGlzLm1heCA6IHVuZGVmaW5lZCxcbiAgICBsYXN0TW9kaWZpZWQ6IHRoaXMubGFzdE1vZGlmaWVkLFxuICAgIGl0ZW1zOiBpdGVtc1xuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgUGVlcklkID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCB7IEtleSB9ID0gcmVxdWlyZSgnaW50ZXJmYWNlLWRhdGFzdG9yZScpXG5jb25zdCBzZXJpZXMgPSByZXF1aXJlKCdhc3luYy9zZXJpZXMnKVxuY29uc3QgZXJyY29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBsb2cgPSBkZWJ1ZygnaXBmczppcG5zOnB1Ymxpc2hlcicpXG5sb2cuZXJyb3IgPSBkZWJ1ZygnaXBmczppcG5zOnB1Ymxpc2hlcjplcnJvcicpXG5cbmNvbnN0IGlwbnMgPSByZXF1aXJlKCdpcG5zJylcblxuY29uc3QgZGVmYXVsdFJlY29yZFR0bCA9IDYwICogNjAgKiAxMDAwXG5cbi8vIElwbnNQdWJsaXNoZXIgaXMgY2FwYWJsZSBvZiBwdWJsaXNoaW5nIGFuZCByZXNvbHZpbmcgbmFtZXMgdG8gdGhlIElQRlMgcm91dGluZyBzeXN0ZW0uXG5jbGFzcyBJcG5zUHVibGlzaGVyIHtcbiAgY29uc3RydWN0b3IgKHJvdXRpbmcsIGRhdGFzdG9yZSkge1xuICAgIHRoaXMuX3JvdXRpbmcgPSByb3V0aW5nXG4gICAgdGhpcy5fZGF0YXN0b3JlID0gZGF0YXN0b3JlXG4gIH1cblxuICAvLyBwdWJsaXNoIHJlY29yZCB3aXRoIGEgZW9sXG4gIHB1Ymxpc2hXaXRoRU9MIChwcml2S2V5LCB2YWx1ZSwgbGlmZXRpbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFwcml2S2V5IHx8ICFwcml2S2V5LmJ5dGVzKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSBgb25lIG9yIG1vcmUgb2YgdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMgYXJlIG5vdCBkZWZpbmVkYFxuXG4gICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfVU5ERUZJTkVEX1BBUkFNRVRFUicpKVxuICAgIH1cblxuICAgIFBlZXJJZC5jcmVhdGVGcm9tUHJpdktleShwcml2S2V5LmJ5dGVzLCAoZXJyLCBwZWVySWQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdXBkYXRlT3JDcmVhdGVSZWNvcmQocHJpdktleSwgdmFsdWUsIGxpZmV0aW1lLCBwZWVySWQsIChlcnIsIHJlY29yZCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3B1dFJlY29yZFRvUm91dGluZyhyZWNvcmQsIHBlZXJJZCwgY2FsbGJhY2spXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBBY2NlcHRzIGEga2V5cGFpciwgYXMgd2VsbCBhcyBhIHZhbHVlIChpcGZzUGF0aCksIGFuZCBwdWJsaXNoZXMgaXQgb3V0IHRvIHRoZSByb3V0aW5nIHN5c3RlbVxuICBwdWJsaXNoIChwcml2S2V5LCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnB1Ymxpc2hXaXRoRU9MKHByaXZLZXksIHZhbHVlLCBkZWZhdWx0UmVjb3JkVHRsLCBjYWxsYmFjaylcbiAgfVxuXG4gIF9wdXRSZWNvcmRUb1JvdXRpbmcgKHJlY29yZCwgcGVlcklkLCBjYWxsYmFjaykge1xuICAgIGlmICghKFBlZXJJZC5pc1BlZXJJZChwZWVySWQpKSkge1xuICAgICAgY29uc3QgZXJyTXNnID0gYHBlZXJJZCByZWNlaXZlZCBpcyBub3QgdmFsaWRgXG5cbiAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX1BFRVJfSUQnKSlcbiAgICB9XG4gICAgY29uc3QgcHVibGljS2V5ID0gcGVlcklkLl9wdWJLZXlcblxuICAgIGlwbnMuZW1iZWRQdWJsaWNLZXkocHVibGljS2V5LCByZWNvcmQsIChlcnIsIGVtYmVkUHVibGljS2V5UmVjb3JkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGxldCBrZXlzXG4gICAgICB0cnkge1xuICAgICAgICBrZXlzID0gaXBucy5nZXRJZEtleXMocGVlcklkLnRvQnl0ZXMoKSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cuZXJyb3IoZXJyKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBzZXJpZXMoW1xuICAgICAgICAoY2IpID0+IHRoaXMuX3B1Ymxpc2hFbnRyeShrZXlzLnJvdXRpbmdLZXksIGVtYmVkUHVibGljS2V5UmVjb3JkIHx8IHJlY29yZCwgcGVlcklkLCBjYiksXG4gICAgICAgIC8vIFB1Ymxpc2ggdGhlIHB1YmxpYyBrZXkgdG8gc3VwcG9ydCBvbGQgZ28taXBmcyBub2RlcyB0aGF0IGFyZSBsb29raW5nIGZvciBpdCBpbiB0aGUgcm91dGluZ1xuICAgICAgICAvLyBXZSB3aWxsIGJlIGFibGUgdG8gZGVwcmVjYXRlIHRoaXMgcGFydCBpbiB0aGUgZnV0dXJlLCBzaW5jZSB0aGUgcHVibGljIGtleXMgd2lsbCBiZSBvbmx5XG4gICAgICAgIC8vIGluIElQTlMgcmVjb3JkIGFuZCB0aGUgcGVlcklkLlxuICAgICAgICAoY2IpID0+IHRoaXMuX3B1Ymxpc2hQdWJsaWNLZXkoa2V5cy5yb3V0aW5nUHViS2V5LCBwdWJsaWNLZXksIHBlZXJJZCwgY2IpXG4gICAgICBdLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBsb2cuZXJyb3IoZXJyKVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCBlbWJlZFB1YmxpY0tleVJlY29yZCB8fCByZWNvcmQpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBfcHVibGlzaEVudHJ5IChrZXksIGVudHJ5LCBwZWVySWQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCEoS2V5LmlzS2V5KGtleSkpKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSBgZGF0YXN0b3JlIGtleSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgZm9ybWF0YFxuXG4gICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfSU5WQUxJRF9EQVRBU1RPUkVfS0VZJykpXG4gICAgfVxuXG4gICAgbGV0IGVudHJ5RGF0YVxuICAgIHRyeSB7XG4gICAgICAvLyBNYXJzaGFsIHJlY29yZFxuICAgICAgZW50cnlEYXRhID0gaXBucy5tYXJzaGFsKGVudHJ5KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLmVycm9yKGVycilcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgLy8gQWRkIHJlY29yZCB0byByb3V0aW5nIChidWZmZXIga2V5KVxuICAgIHRoaXMuX3JvdXRpbmcucHV0KGtleS50b0J1ZmZlcigpLCBlbnRyeURhdGEsIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjb25zdCBlcnJNc2cgPSBgaXBucyByZWNvcmQgZm9yICR7a2V5LnRvU3RyaW5nKCl9IGNvdWxkIG5vdCBiZSBzdG9yZWQgaW4gdGhlIHJvdXRpbmdgXG5cbiAgICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfUFVUVElOR19UT19ST1VUSU5HJykpXG4gICAgICB9XG5cbiAgICAgIGxvZyhgaXBucyByZWNvcmQgZm9yICR7a2V5LnRvU3RyaW5nKCl9IHdhcyBzdG9yZWQgaW4gdGhlIHJvdXRpbmdgKVxuICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKVxuICAgIH0pXG4gIH1cblxuICBfcHVibGlzaFB1YmxpY0tleSAoa2V5LCBwdWJsaWNLZXksIHBlZXJJZCwgY2FsbGJhY2spIHtcbiAgICBpZiAoKCFLZXkuaXNLZXkoa2V5KSkpIHtcbiAgICAgIGNvbnN0IGVyck1zZyA9IGBkYXRhc3RvcmUga2V5IGRvZXMgbm90IGhhdmUgYSB2YWxpZCBmb3JtYXRgXG5cbiAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX0RBVEFTVE9SRV9LRVknKSlcbiAgICB9XG5cbiAgICBpZiAoIXB1YmxpY0tleSB8fCAhcHVibGljS2V5LmJ5dGVzKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSBgb25lIG9yIG1vcmUgb2YgdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMgYXJlIG5vdCBkZWZpbmVkYFxuXG4gICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfVU5ERUZJTkVEX1BBUkFNRVRFUicpKVxuICAgIH1cblxuICAgIC8vIEFkZCBwdWJsaWMga2V5IHRvIHJvdXRpbmcgKGJ1ZmZlciBrZXkpXG4gICAgdGhpcy5fcm91dGluZy5wdXQoa2V5LnRvQnVmZmVyKCksIHB1YmxpY0tleS5ieXRlcywgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IGBwdWJsaWMga2V5IGZvciAke2tleS50b1N0cmluZygpfSBjb3VsZCBub3QgYmUgc3RvcmVkIGluIHRoZSByb3V0aW5nYFxuXG4gICAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKG5ldyBFcnJvcihlcnJNc2cpLCAnRVJSX1BVVFRJTkdfVE9fUk9VVElORycpKVxuICAgICAgfVxuXG4gICAgICBsb2coYHB1YmxpYyBrZXkgZm9yICR7a2V5LnRvU3RyaW5nKCl9IHdhcyBzdG9yZWQgaW4gdGhlIHJvdXRpbmdgKVxuICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKVxuICAgIH0pXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSByZWNvcmQgdGhpcyBub2RlIGhhcyBwdWJsaXNoZWQgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gcGVlciBJRC5cbiAgLy8gSWYgYGNoZWNrUm91dGluZ2AgaXMgdHJ1ZSBhbmQgd2UgaGF2ZSBubyBleGlzdGluZyByZWNvcmQsIHRoaXMgbWV0aG9kIHdpbGwgY2hlY2sgdGhlIHJvdXRpbmcgc3lzdGVtIGZvciBhbnkgZXhpc3RpbmcgcmVjb3Jkcy5cbiAgX2dldFB1Ymxpc2hlZCAocGVlcklkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICghKFBlZXJJZC5pc1BlZXJJZChwZWVySWQpKSkge1xuICAgICAgY29uc3QgZXJyTXNnID0gYHBlZXJJZCByZWNlaXZlZCBpcyBub3QgdmFsaWRgXG5cbiAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX1BFRVJfSUQnKSlcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIGNvbnN0IGNoZWNrUm91dGluZyA9IG9wdGlvbnMuY2hlY2tSb3V0aW5nICE9PSBmYWxzZVxuXG4gICAgdGhpcy5fZGF0YXN0b3JlLmdldChpcG5zLmdldExvY2FsS2V5KHBlZXJJZC5pZCksIChlcnIsIGRzVmFsKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VSUl9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgY29uc3QgZXJyTXNnID0gYHVuZXhwZWN0ZWQgZXJyb3IgZ2V0dGluZyB0aGUgaXBucyByZWNvcmQgJHtwZWVySWQuaWR9IGZyb20gZGF0YXN0b3JlYFxuXG4gICAgICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9VTkVYUEVDVEVEX0RBVEFTVE9SRV9SRVNQT05TRScpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjaGVja1JvdXRpbmcpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKGVycmNvZGUoZXJyKSkpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcnkgdG8gZ2V0IGZyb20gcm91dGluZ1xuICAgICAgICBsZXQga2V5c1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGtleXMgPSBpcG5zLmdldElkS2V5cyhwZWVySWQudG9CeXRlcygpKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBsb2cuZXJyb3IoZXJyKVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yb3V0aW5nLmdldChrZXlzLnJvdXRpbmdLZXkudG9CdWZmZXIoKSwgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1bm1hcnNoYWwgZGF0YVxuICAgICAgICAgIHRoaXMuX3VubWFyc2hhbERhdGEocmVzLCBjYWxsYmFjaylcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVubWFyc2hhbCBkYXRhXG4gICAgICAgIHRoaXMuX3VubWFyc2hhbERhdGEoZHNWYWwsIGNhbGxiYWNrKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBfdW5tYXJzaGFsRGF0YSAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICBsZXQgcmVzdWx0XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGlwbnMudW5tYXJzaGFsKGRhdGEpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUoZXJyLCAnRVJSX0lOVkFMSURfUkVDT1JEX0RBVEEnKSlcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpXG4gIH1cblxuICBfdXBkYXRlT3JDcmVhdGVSZWNvcmQgKHByaXZLZXksIHZhbHVlLCB2YWxpZGl0eSwgcGVlcklkLCBjYWxsYmFjaykge1xuICAgIGlmICghKFBlZXJJZC5pc1BlZXJJZChwZWVySWQpKSkge1xuICAgICAgY29uc3QgZXJyTXNnID0gYHBlZXJJZCByZWNlaXZlZCBpcyBub3QgdmFsaWRgXG5cbiAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX1BFRVJfSUQnKSlcbiAgICB9XG5cbiAgICBjb25zdCBnZXRQdWJsaXNoZWRPcHRpb25zID0ge1xuICAgICAgY2hlY2tSb3V0aW5nOiB0cnVlXG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0UHVibGlzaGVkKHBlZXJJZCwgZ2V0UHVibGlzaGVkT3B0aW9ucywgKGVyciwgcmVjb3JkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VSUl9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgY29uc3QgZXJyTXNnID0gYHVuZXhwZWN0ZWQgZXJyb3Igd2hlbiBkZXRlcm1pbmluZyB0aGUgbGFzdCBwdWJsaXNoZWQgSVBOUyByZWNvcmQgZm9yICR7cGVlcklkLmlkfWBcblxuICAgICAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfREVURVJNSU5JTkdfUFVCTElTSEVEX1JFQ09SRCcpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERldGVybWluYXRlIHRoZSByZWNvcmQgc2VxdWVuY2UgbnVtYmVyXG4gICAgICBsZXQgc2VxTnVtYmVyID0gMFxuICAgICAgaWYgKHJlY29yZCAmJiByZWNvcmQuc2VxdWVuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXFOdW1iZXIgPSByZWNvcmQudmFsdWUudG9TdHJpbmcoKSAhPT0gdmFsdWUgPyByZWNvcmQuc2VxdWVuY2UgKyAxIDogcmVjb3JkLnNlcXVlbmNlXG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSByZWNvcmRcbiAgICAgIGlwbnMuY3JlYXRlKHByaXZLZXksIHZhbHVlLCBzZXFOdW1iZXIsIHZhbGlkaXR5LCAoZXJyLCBlbnRyeURhdGEpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGBpcG5zIHJlY29yZCBmb3IgJHt2YWx1ZX0gY291bGQgbm90IGJlIGNyZWF0ZWRgXG5cbiAgICAgICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKG5ldyBFcnJvcihlcnJNc2cpLCAnRVJSX0NSRUFUSU5HX0lQTlNfUkVDT1JEJykpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPIElNUFJPVkVNRU5UIC0gc2V0IHR0bCAoc3RpbGwgZXhwZXJpbWVudGFsIGZlYXR1cmUgZm9yIGdvKVxuXG4gICAgICAgIC8vIE1hcnNoYWwgcmVjb3JkXG4gICAgICAgIGNvbnN0IGRhdGEgPSBpcG5zLm1hcnNoYWwoZW50cnlEYXRhKVxuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBuZXcgcmVjb3JkXG4gICAgICAgIHRoaXMuX2RhdGFzdG9yZS5wdXQoaXBucy5nZXRMb2NhbEtleShwZWVySWQuaWQpLCBkYXRhLCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJNc2cgPSBgaXBucyByZWNvcmQgZm9yICR7dmFsdWV9IGNvdWxkIG5vdCBiZSBzdG9yZWQgaW4gdGhlIGRhdGFzdG9yZWBcblxuICAgICAgICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKG5ldyBFcnJvcihlcnJNc2cpLCAnRVJSX1NUT1JJTkdfSU5fREFUQVNUT1JFJykpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbG9nKGBpcG5zIHJlY29yZCBmb3IgJHt2YWx1ZX0gd2FzIHN0b3JlZCBpbiB0aGUgZGF0YXN0b3JlYClcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBlbnRyeURhdGEpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSXBuc1B1Ymxpc2hlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGlwbnMgPSByZXF1aXJlKCdpcG5zJylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2xpYnAycC1jcnlwdG8nKVxuY29uc3QgUGVlcklkID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCBlcnJjb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IGVhY2ggPSByZXF1aXJlKCdhc3luYy9lYWNoJylcbmNvbnN0IHdhdGVyZmFsbCA9IHJlcXVpcmUoJ2FzeW5jL3dhdGVyZmFsbCcpXG5jb25zdCBsb2cgPSBkZWJ1ZygnaXBmczppcG5zOnJlcHVibGlzaGVyJylcbmxvZy5lcnJvciA9IGRlYnVnKCdpcGZzOmlwbnM6cmVwdWJsaXNoZXI6ZXJyb3InKVxuXG5jb25zdCBtaW51dGUgPSA2MCAqIDEwMDBcbmNvbnN0IGhvdXIgPSA2MCAqIG1pbnV0ZVxuXG5jb25zdCBkZWZhdWx0QnJvYWRjYXN0SW50ZXJ2YWwgPSA0ICogaG91clxuY29uc3QgZGVmYXVsdFJlY29yZExpZmV0aW1lID0gMjQgKiBob3VyXG5cbmNsYXNzIElwbnNSZXB1Ymxpc2hlciB7XG4gIGNvbnN0cnVjdG9yIChwdWJsaXNoZXIsIGRhdGFzdG9yZSwgcGVlckluZm8sIGtleWNoYWluLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fcHVibGlzaGVyID0gcHVibGlzaGVyXG4gICAgdGhpcy5fZGF0YXN0b3JlID0gZGF0YXN0b3JlXG4gICAgdGhpcy5fcGVlckluZm8gPSBwZWVySW5mb1xuICAgIHRoaXMuX2tleWNoYWluID0ga2V5Y2hhaW5cbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuX3JlcHVibGlzaEhhbmRsZSA9IG51bGxcbiAgfVxuXG4gIHN0YXJ0ICgpIHtcbiAgICBpZiAodGhpcy5fcmVwdWJsaXNoSGFuZGxlKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSAnYWxyZWFkeSBydW5uaW5nJ1xuXG4gICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgdGhyb3cgZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9SRVBVQkxJU0hfQUxSRUFEWV9SVU5OSU5HJylcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0aGlzIGhhbmRsZXIgc2hvdWxkIGJlIGlzb2xhdGVkIGluIGFub3RoZXIgbW9kdWxlXG4gICAgY29uc3QgcmVwdWJsaXNoSGFuZGxlID0ge1xuICAgICAgX29uQ2FuY2VsOiBudWxsLFxuICAgICAgX3RpbWVvdXRJZDogbnVsbCxcbiAgICAgIHJ1blBlcmlvZGljYWxseTogKGZuLCBwZXJpb2QpID0+IHtcbiAgICAgICAgcmVwdWJsaXNoSGFuZGxlLl90aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZXB1Ymxpc2hIYW5kbGUuX3RpbWVvdXRJZCA9IG51bGxcblxuICAgICAgICAgIGZuKChuZXh0UGVyaW9kKSA9PiB7XG4gICAgICAgICAgICAvLyBXYXMgcmVwdWJsaXNoIGNhbmNlbGxlZCB3aGlsZSBmbiB3YXMgYmVpbmcgY2FsbGVkP1xuICAgICAgICAgICAgaWYgKHJlcHVibGlzaEhhbmRsZS5fb25DYW5jZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcHVibGlzaEhhbmRsZS5fb25DYW5jZWwoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgbmV4dFxuICAgICAgICAgICAgcmVwdWJsaXNoSGFuZGxlLnJ1blBlcmlvZGljYWxseShmbiwgbmV4dFBlcmlvZCB8fCBwZXJpb2QpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSwgcGVyaW9kKVxuICAgICAgfSxcbiAgICAgIGNhbmNlbDogKGNiKSA9PiB7XG4gICAgICAgIC8vIE5vdCBjdXJyZW50bHkgcnVubmluZyBhIHJlcHVibGlzaCwgY2FuIGNhbGxiYWNrIGltbWVkaWF0ZWx5XG4gICAgICAgIGlmIChyZXB1Ymxpc2hIYW5kbGUuX3RpbWVvdXRJZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChyZXB1Ymxpc2hIYW5kbGUuX3RpbWVvdXRJZClcbiAgICAgICAgICByZXR1cm4gY2IoKVxuICAgICAgICB9XG4gICAgICAgIC8vIFdhaXQgZm9yIHJlcHVibGlzaCB0byBmaW5pc2ggdGhlbiBjYWxsIGNhbGxiYWNrXG4gICAgICAgIHJlcHVibGlzaEhhbmRsZS5fb25DYW5jZWwgPSBjYlxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHsgcHJpdktleSB9ID0gdGhpcy5fcGVlckluZm8uaWRcbiAgICBjb25zdCB7IHBhc3MgfSA9IHRoaXMuX29wdGlvbnNcblxuICAgIHJlcHVibGlzaEhhbmRsZS5ydW5QZXJpb2RpY2FsbHkoKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX3JlcHVibGlzaEVudHJpZXMocHJpdktleSwgcGFzcywgKCkgPT4gZG9uZShkZWZhdWx0QnJvYWRjYXN0SW50ZXJ2YWwpKVxuICAgIH0sIG1pbnV0ZSlcblxuICAgIHRoaXMuX3JlcHVibGlzaEhhbmRsZSA9IHJlcHVibGlzaEhhbmRsZVxuICB9XG5cbiAgc3RvcCAoY2FsbGJhY2spIHtcbiAgICBjb25zdCByZXB1Ymxpc2hIYW5kbGUgPSB0aGlzLl9yZXB1Ymxpc2hIYW5kbGVcblxuICAgIGlmICghcmVwdWJsaXNoSGFuZGxlKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSAnbm90IHJ1bm5pbmcnXG5cbiAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9SRVBVQkxJU0hfTk9UX1JVTk5JTkcnKSlcbiAgICB9XG5cbiAgICB0aGlzLl9yZXB1Ymxpc2hIYW5kbGUgPSBudWxsXG4gICAgcmVwdWJsaXNoSGFuZGxlLmNhbmNlbChjYWxsYmFjaylcbiAgfVxuXG4gIF9yZXB1Ymxpc2hFbnRyaWVzIChwcml2YXRlS2V5LCBwYXNzLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IFNob3VsZCB1c2UgbGlzdCBvZiBwdWJsaXNoZWQgZW50cmllcy5cbiAgICAvLyBXZSBjYW4ndCBjdXJyZW50bHkgKmRvKiB0aGF0IGJlY2F1c2UgZ28gdXNlcyB0aGlzIG1ldGhvZCBmb3Igbm93LlxuICAgIHRoaXMuX3JlcHVibGlzaEVudHJ5KHByaXZhdGVLZXksIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gJ2Nhbm5vdCByZXB1Ymxpc2ggZW50cnkgZm9yIHRoZSBub2RlXFwncyBwcml2YXRlIGtleSdcblxuICAgICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8ga2V5Y2hhaW4gbmVlZHMgcGFzcyB0byBnZXQgdGhlIGNyeXB0b2dyYXBoaWMga2V5c1xuICAgICAgaWYgKHBhc3MpIHtcbiAgICAgICAgdGhpcy5fa2V5Y2hhaW4ubGlzdEtleXMoKGVyciwgbGlzdCkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihlcnIpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlYWNoKGxpc3QsIChrZXksIGNiKSA9PiB7XG4gICAgICAgICAgICB3YXRlcmZhbGwoW1xuICAgICAgICAgICAgICAoY2IpID0+IHRoaXMuX2tleWNoYWluLmV4cG9ydEtleShrZXkubmFtZSwgcGFzcywgY2IpLFxuICAgICAgICAgICAgICAocGVtLCBjYikgPT4gY3J5cHRvLmtleXMuX19pbXBvcnRfXyhwZW0sIHBhc3MsIGNiKVxuICAgICAgICAgICAgXSwgKGVyciwgcHJpdktleSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKGVycilcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuX3JlcHVibGlzaEVudHJ5KHByaXZLZXksIGNiKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIGxvZy5lcnJvcihlcnIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhudWxsKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBfcmVwdWJsaXNoRW50cnkgKHByaXZhdGVLZXksIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFwcml2YXRlS2V5IHx8ICFwcml2YXRlS2V5LmJ5dGVzKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSBgb25lIG9yIG1vcmUgb2YgdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMgYXJlIG5vdCBkZWZpbmVkYFxuXG4gICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfVU5ERUZJTkVEX1BBUkFNRVRFUicpKVxuICAgIH1cblxuICAgIHdhdGVyZmFsbChbXG4gICAgICAoY2IpID0+IFBlZXJJZC5jcmVhdGVGcm9tUHJpdktleShwcml2YXRlS2V5LmJ5dGVzLCBjYiksXG4gICAgICAocGVlcklkLCBjYikgPT4gdGhpcy5fZ2V0UHJldmlvdXNWYWx1ZShwZWVySWQsIGNiKVxuICAgIF0sIChlcnIsIHZhbHVlKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIuY29kZSA9PT0gJ0VSUl9OT19FTlRSWV9GT1VORCcgPyBudWxsIDogZXJyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wdWJsaXNoZXIucHVibGlzaFdpdGhFT0wocHJpdmF0ZUtleSwgdmFsdWUsIGRlZmF1bHRSZWNvcmRMaWZldGltZSwgY2FsbGJhY2spXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRQcmV2aW91c1ZhbHVlIChwZWVySWQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCEoUGVlcklkLmlzUGVlcklkKHBlZXJJZCkpKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSBgcGVlcklkIHJlY2VpdmVkIGlzIG5vdCB2YWxpZGBcblxuICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKG5ldyBFcnJvcihlcnJNc2cpLCAnRVJSX0lOVkFMSURfUEVFUl9JRCcpKVxuICAgIH1cblxuICAgIHRoaXMuX2RhdGFzdG9yZS5nZXQoaXBucy5nZXRMb2NhbEtleShwZWVySWQuaWQpLCAoZXJyLCBkc1ZhbCkgPT4ge1xuICAgICAgLy8gZXJyb3IgaGFuZGxpbmdcbiAgICAgIC8vIG5vIG5lZWQgdG8gcmVwdWJsaXNoXG4gICAgICBpZiAoZXJyICYmIGVyci5ub3RGb3VuZCkge1xuICAgICAgICBjb25zdCBlcnJNc2cgPSBgbm8gcHJldmlvdXMgZW50cnkgZm9yIHJlY29yZCB3aXRoIGlkOiAke3BlZXJJZC5pZH1gXG5cbiAgICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfTk9fRU5UUllfRk9VTkQnKSlcbiAgICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRzVmFsKSkge1xuICAgICAgICBjb25zdCBlcnJNc2cgPSBgZm91bmQgaXBucyByZWNvcmQgdGhhdCB3ZSBjb3VsZG4ndCBwcm9jZXNzYFxuXG4gICAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKG5ldyBFcnJvcihlcnJNc2cpLCAnRVJSX0lOVkFMSURfSVBOU19SRUNPUkQnKSlcbiAgICAgIH1cblxuICAgICAgLy8gdW5tYXJzaGFsIGRhdGFcbiAgICAgIGxldCByZWNvcmRcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlY29yZCA9IGlwbnMudW5tYXJzaGFsKGRzVmFsKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IGBmb3VuZCBpcG5zIHJlY29yZCB0aGF0IHdlIGNvdWxkbid0IGNvbnZlcnQgdG8gYSB2YWx1ZWBcblxuICAgICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX0lQTlNfUkVDT1JEJykpXG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlY29yZC52YWx1ZSlcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IElwbnNSZXB1Ymxpc2hlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuXG5jb25zdCBDT05TVEFOVFMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuL3V0aWxzJykubG9nZ2VyXG5cbmNvbnN0IHVud2FudEV2ZW50ID0gKGMpID0+IGB1bndhbnQ6JHtjfWBcbmNvbnN0IGJsb2NrRXZlbnQgPSAoYykgPT4gYGJsb2NrOiR7Y31gXG5cbi8qKlxuICogSW50ZXJuYWwgbW9kdWxlIHVzZWQgdG8gdHJhY2sgZXZlbnRzIGFib3V0IGluY29taW5nIGJsb2NrcyxcbiAqIHdhbnRzIGFuZCB1bndhbnRzLlxuICpcbiAqIEBwYXJhbSB7UGVlcklkfSBwZWVySWRcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIE5vdGlmaWNhdGlvbnMgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAocGVlcklkKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoQ09OU1RBTlRTLm1heExpc3RlbmVycylcblxuICAgIHRoaXMuX2xvZyA9IGxvZ2dlcihwZWVySWQsICdub3RpZicpXG5cbiAgICB0aGlzLl91bndhbnRMaXN0ZW5lcnMgPSB7fVxuICAgIHRoaXMuX2Jsb2NrTGlzdGVuZXJzID0ge31cbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduYWwgdGhlIHN5c3RlbSB0aGF0IHdlIHJlY2VpdmVkIGBibG9ja2AuXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBoYXNCbG9jayAoYmxvY2spIHtcbiAgICBjb25zdCBzdHIgPSBgYmxvY2s6JHtibG9jay5jaWQuYnVmZmVyLnRvU3RyaW5nKCl9YFxuICAgIHRoaXMuX2xvZyhzdHIpXG4gICAgdGhpcy5lbWl0KHN0ciwgYmxvY2spXG4gIH1cblxuICAvKipcbiAgICogU2lnbmFsIHRoZSBzeXN0ZW0gdGhhdCB3ZSBhcmUgd2FpdGluZyB0byByZWNlaXZlIHRoZVxuICAgKiBibG9jayBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGBjaWRgLlxuICAgKlxuICAgKiBAcGFyYW0ge0NJRH0gY2lkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQmxvY2spfSBvbkJsb2NrIC0gY2FsbGVkIHdoZW4gdGhlIGJsb2NrIGlzIHJlY2VpdmVkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gb25VbndhbnQgLSBjYWxsZWQgd2hlbiB0aGUgYmxvY2sgaXMgdW53YW50ZWRcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICB3YW50QmxvY2sgKGNpZCwgb25CbG9jaywgb25VbndhbnQpIHtcbiAgICBjb25zdCBjaWRTdHIgPSBjaWQuYnVmZmVyLnRvU3RyaW5nKClcbiAgICB0aGlzLl9sb2coYHdhbnRCbG9jazoke2NpZFN0cn1gKVxuXG4gICAgdGhpcy5fdW53YW50TGlzdGVuZXJzW2NpZFN0cl0gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9sb2coYG1hbnVhbCB1bndhbnQ6ICR7Y2lkU3RyfWApXG4gICAgICB0aGlzLl9jbGVhbnVwKGNpZFN0cilcbiAgICAgIG9uVW53YW50KClcbiAgICB9XG5cbiAgICB0aGlzLl9ibG9ja0xpc3RlbmVyc1tjaWRTdHJdID0gKGJsb2NrKSA9PiB7XG4gICAgICB0aGlzLl9jbGVhbnVwKGNpZFN0cilcbiAgICAgIG9uQmxvY2soYmxvY2spXG4gICAgfVxuXG4gICAgdGhpcy5vbmNlKFxuICAgICAgdW53YW50RXZlbnQoY2lkU3RyKSxcbiAgICAgIHRoaXMuX3Vud2FudExpc3RlbmVyc1tjaWRTdHJdXG4gICAgKVxuICAgIHRoaXMub25jZShcbiAgICAgIGJsb2NrRXZlbnQoY2lkU3RyKSxcbiAgICAgIHRoaXMuX2Jsb2NrTGlzdGVuZXJzW2NpZFN0cl1cbiAgICApXG4gIH1cblxuICAvKipcbiAgICogU2lnbmFsIHRoYXQgdGhlIGJsb2NrIGlzIG5vdCB3YW50ZWQgYW55bW9yZS5cbiAgICpcbiAgICogQHBhcmFtIHtDSUR9IGNpZCAtIHRoZSBDSUQgb2YgdGhlIGJsb2NrIHRoYXQgaXMgbm90IHdhbnRlZCBhbnltb3JlLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHVud2FudEJsb2NrIChjaWQpIHtcbiAgICBjb25zdCBzdHIgPSBgdW53YW50OiR7Y2lkLmJ1ZmZlci50b1N0cmluZygpfWBcbiAgICB0aGlzLl9sb2coc3RyKVxuICAgIHRoaXMuZW1pdChzdHIpXG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGNsZWFuIHVwIG9uY2UgYSBibG9jayB3YXMgcmVjZWl2ZWQgb3IgdW53YW50ZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY2lkU3RyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX2NsZWFudXAgKGNpZFN0cikge1xuICAgIGlmICh0aGlzLl91bndhbnRMaXN0ZW5lcnNbY2lkU3RyXSkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcbiAgICAgICAgdW53YW50RXZlbnQoY2lkU3RyKSxcbiAgICAgICAgdGhpcy5fdW53YW50TGlzdGVuZXJzW2NpZFN0cl1cbiAgICAgIClcbiAgICAgIGRlbGV0ZSB0aGlzLl91bndhbnRMaXN0ZW5lcnNbY2lkU3RyXVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ibG9ja0xpc3RlbmVyc1tjaWRTdHJdKSB7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFxuICAgICAgICBibG9ja0V2ZW50KGNpZFN0ciksXG4gICAgICAgIHRoaXMuX2Jsb2NrTGlzdGVuZXJzW2NpZFN0cl1cbiAgICAgIClcbiAgICAgIGRlbGV0ZSB0aGlzLl9ibG9ja0xpc3RlbmVyc1tjaWRTdHJdXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTm90aWZpY2F0aW9uc1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuXG4vKipcbiAqIENyZWF0ZXMgYSBsb2dnZXIgZm9yIHRoZSBnaXZlbiBzdWJzeXN0ZW1cbiAqXG4gKiBAcGFyYW0ge1BlZXJJZH0gW2lkXVxuICogQHBhcmFtIHtzdHJpbmd9IFtzdWJzeXN0ZW1dXG4gKiBAcmV0dXJucyB7ZGVidWd9XG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgbG9nZ2VyID0gKGlkLCBzdWJzeXN0ZW0pID0+IHtcbiAgY29uc3QgbmFtZSA9IFsnYml0c3dhcCddXG4gIGlmIChzdWJzeXN0ZW0pIHtcbiAgICBuYW1lLnB1c2goc3Vic3lzdGVtKVxuICB9XG4gIGlmIChpZCkge1xuICAgIG5hbWUucHVzaChgJHtpZC50b0I1OFN0cmluZygpLnNsaWNlKDAsIDgpfWApXG4gIH1cbiAgY29uc3QgbG9nZ2VyID0gZGVidWcobmFtZS5qb2luKCc6JykpXG4gIGxvZ2dlci5lcnJvciA9IGRlYnVnKG5hbWUuY29uY2F0KFsnZXJyb3InXSkuam9pbignOicpKVxuXG4gIHJldHVybiBsb2dnZXJcbn1cblxuY29uc3QgaW5jbHVkZXNXaXRoID0gKHByZWQsIHgsIGxpc3QpID0+IHtcbiAgbGV0IGlkeCA9IDBcbiAgY29uc3QgbGVuID0gbGlzdC5sZW5ndGhcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGlmIChwcmVkKHgsIGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlkeCArPSAxXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmNvbnN0IHVuaXFXaXRoID0gKHByZWQsIGxpc3QpID0+IHtcbiAgbGV0IGlkeCA9IDBcbiAgY29uc3QgbGVuID0gbGlzdC5sZW5ndGhcbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgbGV0IGl0ZW1cblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgaXRlbSA9IGxpc3RbaWR4XVxuICAgIGlmICghaW5jbHVkZXNXaXRoKHByZWQsIGl0ZW0sIHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGl0ZW1cbiAgICB9XG4gICAgaWR4ICs9IDFcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmNvbnN0IGdyb3VwQnkgPSAocHJlZCwgbGlzdCkgPT4ge1xuICByZXR1cm4gbGlzdC5yZWR1Y2UoKGFjYywgdikgPT4ge1xuICAgIGNvbnN0IGsgPSBwcmVkKHYpXG5cbiAgICBpZiAoYWNjW2tdKSB7XG4gICAgICBhY2Nba10ucHVzaCh2KVxuICAgIH0gZWxzZSB7XG4gICAgICBhY2Nba10gPSBbdl1cbiAgICB9XG4gICAgcmV0dXJuIGFjY1xuICB9LCB7fSlcbn1cblxuY29uc3QgcHVsbEFsbFdpdGggPSAocHJlZCwgbGlzdCwgdmFsdWVzKSA9PiB7XG4gIHJldHVybiBsaXN0LmZpbHRlcihpID0+IHtcbiAgICByZXR1cm4gIWluY2x1ZGVzV2l0aChwcmVkLCBpLCB2YWx1ZXMpXG4gIH0pXG59XG5cbmNvbnN0IHNvcnRCeSA9IChmbiwgbGlzdCkgPT4ge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGFhID0gZm4oYSlcbiAgICBjb25zdCBiYiA9IGZuKGIpXG4gICAgcmV0dXJuIGFhIDwgYmIgPyAtMSA6IGFhID4gYmIgPyAxIDogMFxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbG9nZ2VyLFxuICBpbmNsdWRlc1dpdGgsXG4gIHVuaXFXaXRoLFxuICBncm91cEJ5LFxuICBwdWxsQWxsV2l0aCxcbiAgc29ydEJ5XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZWFjaCA9IHJlcXVpcmUoJ2FzeW5jL2VhY2gnKVxuY29uc3QgZWFjaFNlcmllcyA9IHJlcXVpcmUoJ2FzeW5jL2VhY2hTZXJpZXMnKVxuY29uc3Qgd2F0ZXJmYWxsID0gcmVxdWlyZSgnYXN5bmMvd2F0ZXJmYWxsJylcbmNvbnN0IG5leHRUaWNrID0gcmVxdWlyZSgnYXN5bmMvbmV4dFRpY2snKVxuXG5jb25zdCBtYXAgPSByZXF1aXJlKCdhc3luYy9tYXAnKVxuY29uc3QgZGVib3VuY2UgPSByZXF1aXJlKCdqdXN0LWRlYm91bmNlLWl0JylcblxuY29uc3QgTWVzc2FnZSA9IHJlcXVpcmUoJy4uL3R5cGVzL21lc3NhZ2UnKVxuY29uc3QgV2FudGxpc3QgPSByZXF1aXJlKCcuLi90eXBlcy93YW50bGlzdCcpXG5jb25zdCBMZWRnZXIgPSByZXF1aXJlKCcuL2xlZGdlcicpXG5jb25zdCB7IGxvZ2dlciwgZ3JvdXBCeSwgcHVsbEFsbFdpdGgsIHVuaXFXaXRoIH0gPSByZXF1aXJlKCcuLi91dGlscycpXG5cbmNvbnN0IE1BWF9NRVNTQUdFX1NJWkUgPSA1MTIgKiAxMDI0XG5cbmNsYXNzIERlY2lzaW9uRW5naW5lIHtcbiAgY29uc3RydWN0b3IgKHBlZXJJZCwgYmxvY2tzdG9yZSwgbmV0d29yaywgc3RhdHMpIHtcbiAgICB0aGlzLl9sb2cgPSBsb2dnZXIocGVlcklkLCAnZW5naW5lJylcbiAgICB0aGlzLmJsb2Nrc3RvcmUgPSBibG9ja3N0b3JlXG4gICAgdGhpcy5uZXR3b3JrID0gbmV0d29ya1xuICAgIHRoaXMuX3N0YXRzID0gc3RhdHNcblxuICAgIC8vIEEgbGlzdCBvZiBvZiBsZWRnZXJzIGJ5IHRoZWlyIHBhcnRuZXIgaWRcbiAgICB0aGlzLmxlZGdlck1hcCA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZVxuXG4gICAgLy8gTGlzdCBvZiB0YXNrcyB0byBiZSBwcm9jZXNzZWRcbiAgICB0aGlzLl90YXNrcyA9IFtdXG5cbiAgICB0aGlzLl9vdXRib3ggPSBkZWJvdW5jZSh0aGlzLl9wcm9jZXNzVGFza3MuYmluZCh0aGlzKSwgMTAwKVxuICB9XG5cbiAgX3NlbmRCbG9ja3MgKHBlZXIsIGJsb2NrcywgY2IpIHtcbiAgICAvLyBzcGxpdCBpbnRvIG1lc3NnZXMgb2YgbWF4IDUxMiAqIDEwMjQgYnl0ZXNcbiAgICBjb25zdCB0b3RhbCA9IGJsb2Nrcy5yZWR1Y2UoKGFjYywgYikgPT4ge1xuICAgICAgcmV0dXJuIGFjYyArIGIuZGF0YS5ieXRlTGVuZ3RoXG4gICAgfSwgMClcblxuICAgIGlmICh0b3RhbCA8IE1BWF9NRVNTQUdFX1NJWkUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZW5kU2FmZUJsb2NrcyhwZWVyLCBibG9ja3MsIGNiKVxuICAgIH1cblxuICAgIGxldCBzaXplID0gMFxuICAgIGxldCBiYXRjaCA9IFtdXG4gICAgbGV0IG91dHN0YW5kaW5nID0gYmxvY2tzLmxlbmd0aFxuXG4gICAgZWFjaFNlcmllcyhibG9ja3MsIChiLCBjYikgPT4ge1xuICAgICAgb3V0c3RhbmRpbmctLVxuICAgICAgYmF0Y2gucHVzaChiKVxuICAgICAgc2l6ZSArPSBiLmRhdGEuYnl0ZUxlbmd0aFxuXG4gICAgICBpZiAoc2l6ZSA+PSBNQVhfTUVTU0FHRV9TSVpFIHx8XG4gICAgICAgICAgLy8gbmVlZCB0byBlbnN1cmUgdGhlIGxhc3QgcmVtYWluaW5nIGl0ZW1zIGdldCBzZW50XG4gICAgICAgICAgb3V0c3RhbmRpbmcgPT09IDApIHtcbiAgICAgICAgc2l6ZSA9IDBcbiAgICAgICAgY29uc3QgbmV4dEJhdGNoID0gYmF0Y2guc2xpY2UoKVxuICAgICAgICBiYXRjaCA9IFtdXG4gICAgICAgIHRoaXMuX3NlbmRTYWZlQmxvY2tzKHBlZXIsIG5leHRCYXRjaCwgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnc2VuZGJsb2NrIGVycm9yOiAlcycsIGVyci5tZXNzYWdlKVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBub3QgcmV0dXJuaW5nIHRoZSBlcnJvciwgc28gd2Ugc2VuZCBhcyBtdWNoIGFzIHdlIGNhblxuICAgICAgICAgIC8vIGFzIG90aGVyd2lzZSBgZWFjaFNlcmllc2Agd291bGQgY2FuY2VsXG4gICAgICAgICAgY2IoKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFRpY2soY2IpXG4gICAgICB9XG4gICAgfSwgY2IpXG4gIH1cblxuICBfc2VuZFNhZmVCbG9ja3MgKHBlZXIsIGJsb2NrcywgY2IpIHtcbiAgICBjb25zdCBtc2cgPSBuZXcgTWVzc2FnZShmYWxzZSlcbiAgICBibG9ja3MuZm9yRWFjaCgoYikgPT4gbXNnLmFkZEJsb2NrKGIpKVxuXG4gICAgdGhpcy5uZXR3b3JrLnNlbmRNZXNzYWdlKHBlZXIsIG1zZywgY2IpXG4gIH1cblxuICBfcHJvY2Vzc1Rhc2tzICgpIHtcbiAgICBpZiAoIXRoaXMuX3J1bm5pbmcgfHwgIXRoaXMuX3Rhc2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdGFza3MgPSB0aGlzLl90YXNrc1xuICAgIHRoaXMuX3Rhc2tzID0gW11cbiAgICBjb25zdCBlbnRyaWVzID0gdGFza3MubWFwKCh0KSA9PiB0LmVudHJ5KVxuICAgIGNvbnN0IGNpZHMgPSBlbnRyaWVzLm1hcCgoZSkgPT4gZS5jaWQpXG4gICAgY29uc3QgdW5pcUNpZHMgPSB1bmlxV2l0aCgoYSwgYikgPT4gYS5lcXVhbHMoYiksIGNpZHMpXG4gICAgY29uc3QgZ3JvdXBlZFRhc2tzID0gZ3JvdXBCeSh0YXNrID0+IHRhc2sudGFyZ2V0LnRvQjU4U3RyaW5nKCksIHRhc2tzKVxuXG4gICAgd2F0ZXJmYWxsKFtcbiAgICAgIChjYWxsYmFjaykgPT4gbWFwKHVuaXFDaWRzLCAoY2lkLCBjYikgPT4ge1xuICAgICAgICB0aGlzLmJsb2Nrc3RvcmUuZ2V0KGNpZCwgY2IpXG4gICAgICB9LCBjYWxsYmFjayksXG4gICAgICAoYmxvY2tzLCBjYWxsYmFjaykgPT4gZWFjaChPYmplY3QudmFsdWVzKGdyb3VwZWRUYXNrcyksICh0YXNrcywgY2IpID0+IHtcbiAgICAgICAgLy8gYWxsIHRhc2tzIGhhdmUgdGhlIHNhbWUgdGFyZ2V0XG4gICAgICAgIGNvbnN0IHBlZXIgPSB0YXNrc1swXS50YXJnZXRcbiAgICAgICAgY29uc3QgYmxvY2tMaXN0ID0gY2lkcy5tYXAoKGNpZCkgPT4ge1xuICAgICAgICAgIHJldHVybiBibG9ja3MuZmluZChiID0+IGIuY2lkLmVxdWFscyhjaWQpKVxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuX3NlbmRCbG9ja3MocGVlciwgYmxvY2tMaXN0LCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgLy8gYF9zZW5kQmxvY2tzYCBhY3R1YWxseSBkb2Vzbid0IHJldHVybiBhbnkgZXJyb3JzXG4gICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IoJ3Nob3VsZCBuZXZlciBoYXBwZW46ICcsIGVycilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmxvY2tMaXN0LmZvckVhY2goKGJsb2NrKSA9PiB0aGlzLm1lc3NhZ2VTZW50KHBlZXIsIGJsb2NrKSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYigpXG4gICAgICAgIH0pXG4gICAgICB9LCBjYWxsYmFjaylcbiAgICBdLCAoZXJyKSA9PiB7XG4gICAgICB0aGlzLl90YXNrcyA9IFtdXG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5fbG9nLmVycm9yKGVycilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgd2FudGxpc3RGb3JQZWVyIChwZWVySWQpIHtcbiAgICBjb25zdCBwZWVySWRTdHIgPSBwZWVySWQudG9CNThTdHJpbmcoKVxuICAgIGlmICghdGhpcy5sZWRnZXJNYXAuaGFzKHBlZXJJZFN0cikpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sZWRnZXJNYXAuZ2V0KHBlZXJJZFN0cikud2FudGxpc3Quc29ydGVkRW50cmllcygpXG4gIH1cblxuICBsZWRnZXJGb3JQZWVyIChwZWVySWQpIHtcbiAgICBjb25zdCBwZWVySWRTdHIgPSBwZWVySWQudG9CNThTdHJpbmcoKVxuXG4gICAgY29uc3QgbGVkZ2VyID0gdGhpcy5sZWRnZXJNYXAuZ2V0KHBlZXJJZFN0cilcbiAgICBpZiAoIWxlZGdlcikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBlZXI6IGxlZGdlci5wYXJ0bmVyLnRvUHJpbnQoKSxcbiAgICAgIHZhbHVlOiBsZWRnZXIuZGVidFJhdGlvKCksXG4gICAgICBzZW50OiBsZWRnZXIuYWNjb3VudGluZy5ieXRlc1NlbnQsXG4gICAgICByZWN2OiBsZWRnZXIuYWNjb3VudGluZy5ieXRlc1JlY3YsXG4gICAgICBleGNoYW5nZWQ6IGxlZGdlci5leGNoYW5nZUNvdW50XG4gICAgfVxuICB9XG5cbiAgcGVlcnMgKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubGVkZ2VyTWFwLnZhbHVlcygpKS5tYXAoKGwpID0+IGwucGFydG5lcilcbiAgfVxuXG4gIHJlY2VpdmVkQmxvY2tzIChjaWRzKSB7XG4gICAgaWYgKCFjaWRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIENoZWNrIGFsbCBjb25uZWN0ZWQgcGVlcnMgaWYgdGhleSB3YW50IHRoZSBibG9jayB3ZSByZWNlaXZlZFxuICAgIHRoaXMubGVkZ2VyTWFwLmZvckVhY2goKGxlZGdlcikgPT4ge1xuICAgICAgY2lkc1xuICAgICAgICAubWFwKChjaWQpID0+IGxlZGdlci53YW50bGlzdENvbnRhaW5zKGNpZCkpXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgdGhpcy5fdGFza3MucHVzaCh7XG4gICAgICAgICAgICBlbnRyeTogZW50cnksXG4gICAgICAgICAgICB0YXJnZXQ6IGxlZGdlci5wYXJ0bmVyXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9KVxuICAgIHRoaXMuX291dGJveCgpXG4gIH1cblxuICAvLyBIYW5kbGUgaW5jb21pbmcgbWVzc2FnZXNcbiAgbWVzc2FnZVJlY2VpdmVkIChwZWVySWQsIG1zZywgY2IpIHtcbiAgICBjb25zdCBsZWRnZXIgPSB0aGlzLl9maW5kT3JDcmVhdGUocGVlcklkKVxuXG4gICAgaWYgKG1zZy5lbXB0eSkge1xuICAgICAgcmV0dXJuIG5leHRUaWNrKGNiKVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBtZXNzYWdlIHdhcyBhIGZ1bGwgd2FudGxpc3QgY2xlYXIgdGhlIGN1cnJlbnQgb25lXG4gICAgaWYgKG1zZy5mdWxsKSB7XG4gICAgICBsZWRnZXIud2FudGxpc3QgPSBuZXcgV2FudGxpc3QoKVxuICAgIH1cblxuICAgIHRoaXMuX3Byb2Nlc3NCbG9ja3MobXNnLmJsb2NrcywgbGVkZ2VyKVxuXG4gICAgaWYgKG1zZy53YW50bGlzdC5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV4dFRpY2soY2IpXG4gICAgfVxuXG4gICAgbGV0IGNhbmNlbHMgPSBbXVxuICAgIGxldCB3YW50cyA9IFtdXG4gICAgbXNnLndhbnRsaXN0LmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICBpZiAoZW50cnkuY2FuY2VsKSB7XG4gICAgICAgIGxlZGdlci5jYW5jZWxXYW50KGVudHJ5LmNpZClcbiAgICAgICAgY2FuY2Vscy5wdXNoKGVudHJ5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVkZ2VyLndhbnRzKGVudHJ5LmNpZCwgZW50cnkucHJpb3JpdHkpXG4gICAgICAgIHdhbnRzLnB1c2goZW50cnkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuX2NhbmNlbFdhbnRzKGxlZGdlciwgcGVlcklkLCBjYW5jZWxzKVxuICAgIHRoaXMuX2FkZFdhbnRzKGxlZGdlciwgcGVlcklkLCB3YW50cywgY2IpXG4gIH1cblxuICBfY2FuY2VsV2FudHMgKGxlZGdlciwgcGVlcklkLCBlbnRyaWVzKSB7XG4gICAgY29uc3QgaWQgPSBwZWVySWQudG9CNThTdHJpbmcoKVxuXG4gICAgdGhpcy5fdGFza3MgPSBwdWxsQWxsV2l0aCgodCwgZSkgPT4ge1xuICAgICAgY29uc3Qgc2FtZVRhcmdldCA9IHQudGFyZ2V0LnRvQjU4U3RyaW5nKCkgPT09IGlkXG4gICAgICBjb25zdCBzYW1lQ2lkID0gdC5lbnRyeS5jaWQuZXF1YWxzKGUuY2lkKVxuICAgICAgcmV0dXJuIHNhbWVUYXJnZXQgJiYgc2FtZUNpZFxuICAgIH0sIHRoaXMuX3Rhc2tzLCBlbnRyaWVzKVxuICB9XG5cbiAgX2FkZFdhbnRzIChsZWRnZXIsIHBlZXJJZCwgZW50cmllcywgY2FsbGJhY2spIHtcbiAgICBlYWNoKGVudHJpZXMsIChlbnRyeSwgY2IpID0+IHtcbiAgICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgYmxvY2ssIHNlcnZlIGl0XG4gICAgICB0aGlzLmJsb2Nrc3RvcmUuaGFzKGVudHJ5LmNpZCwgKGVyciwgZXhpc3RzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IoJ2ZhaWxlZCBleGlzdGVuY2UgY2hlY2snKVxuICAgICAgICB9IGVsc2UgaWYgKGV4aXN0cykge1xuICAgICAgICAgIHRoaXMuX3Rhc2tzLnB1c2goe1xuICAgICAgICAgICAgZW50cnk6IGVudHJ5LmVudHJ5LFxuICAgICAgICAgICAgdGFyZ2V0OiBwZWVySWRcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGNiKClcbiAgICAgIH0pXG4gICAgfSwgKCkgPT4ge1xuICAgICAgdGhpcy5fb3V0Ym94KClcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9KVxuICB9XG5cbiAgX3Byb2Nlc3NCbG9ja3MgKGJsb2NrcywgbGVkZ2VyLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGNpZHMgPSBbXVxuICAgIGJsb2Nrcy5mb3JFYWNoKChiLCBjaWRTdHIpID0+IHtcbiAgICAgIHRoaXMuX2xvZygnZ290IGJsb2NrICglcyBieXRlcyknLCBiLmRhdGEubGVuZ3RoKVxuICAgICAgbGVkZ2VyLnJlY2VpdmVkQnl0ZXMoYi5kYXRhLmxlbmd0aClcbiAgICAgIGNpZHMucHVzaChiLmNpZClcbiAgICB9KVxuXG4gICAgdGhpcy5yZWNlaXZlZEJsb2NrcyhjaWRzKVxuICB9XG5cbiAgLy8gQ2xlYXIgdXAgYWxsIGFjY291bnRpbmcgdGhpbmdzIGFmdGVyIG1lc3NhZ2Ugd2FzIHNlbnRcbiAgbWVzc2FnZVNlbnQgKHBlZXJJZCwgYmxvY2spIHtcbiAgICBjb25zdCBsZWRnZXIgPSB0aGlzLl9maW5kT3JDcmVhdGUocGVlcklkKVxuICAgIGxlZGdlci5zZW50Qnl0ZXMoYmxvY2sgPyBibG9jay5kYXRhLmxlbmd0aCA6IDApXG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLmNpZCkge1xuICAgICAgbGVkZ2VyLndhbnRsaXN0LnJlbW92ZShibG9jay5jaWQpXG4gICAgfVxuICB9XG5cbiAgbnVtQnl0ZXNTZW50VG8gKHBlZXJJZCkge1xuICAgIHJldHVybiB0aGlzLl9maW5kT3JDcmVhdGUocGVlcklkKS5hY2NvdW50aW5nLmJ5dGVzU2VudFxuICB9XG5cbiAgbnVtQnl0ZXNSZWNlaXZlZEZyb20gKHBlZXJJZCkge1xuICAgIHJldHVybiB0aGlzLl9maW5kT3JDcmVhdGUocGVlcklkKS5hY2NvdW50aW5nLmJ5dGVzUmVjdlxuICB9XG5cbiAgcGVlckRpc2Nvbm5lY3RlZCAocGVlcklkKSB7XG4gICAgLy8gaWYgKHRoaXMubGVkZ2VyTWFwLmhhcyhwZWVySWQudG9CNThTdHJpbmcoKSkpIHtcbiAgICAvLyAgIHRoaXMubGVkZ2VyTWFwLmRlbGV0ZShwZWVySWQudG9CNThTdHJpbmcoKSlcbiAgICAvLyB9XG4gICAgLy9cbiAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IGhvdyB0byByZW1vdmUgYWxsIG90aGVyIHJlZmVyZW5jZXNcbiAgICAvLyBpbiB0aGUgcGVlciByZXF1ZXN0IHF1ZXVlXG4gIH1cblxuICBfZmluZE9yQ3JlYXRlIChwZWVySWQpIHtcbiAgICBjb25zdCBwZWVySWRTdHIgPSBwZWVySWQudG9CNThTdHJpbmcoKVxuICAgIGlmICh0aGlzLmxlZGdlck1hcC5oYXMocGVlcklkU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMubGVkZ2VyTWFwLmdldChwZWVySWRTdHIpXG4gICAgfVxuXG4gICAgY29uc3QgbCA9IG5ldyBMZWRnZXIocGVlcklkKVxuXG4gICAgdGhpcy5sZWRnZXJNYXAuc2V0KHBlZXJJZFN0ciwgbClcbiAgICBpZiAodGhpcy5fc3RhdHMpIHtcbiAgICAgIHRoaXMuX3N0YXRzLnB1c2gocGVlcklkU3RyLCAncGVlckNvdW50JywgMSlcbiAgICB9XG5cbiAgICByZXR1cm4gbFxuICB9XG5cbiAgc3RhcnQgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWVcbiAgICBuZXh0VGljaygoKSA9PiBjYWxsYmFjaygpKVxuICB9XG5cbiAgc3RvcCAoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2VcbiAgICBuZXh0VGljaygoKSA9PiBjYWxsYmFjaygpKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGVjaXNpb25FbmdpbmVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgU3RhdCA9IHJlcXVpcmUoJy4vc3RhdCcpXG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBtb3ZpbmdBdmVyYWdlSW50ZXJ2YWxzOiBbXG4gICAgNjAgKiAxMDAwLCAvLyAxIG1pbnV0ZVxuICAgIDUgKiA2MCAqIDEwMDAsIC8vIDUgbWludXRlc1xuICAgIDE1ICogNjAgKiAxMDAwIC8vIDE1IG1pbnV0ZXNcbiAgXVxufVxuXG5jbGFzcyBTdGF0cyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChpbml0aWFsQ291bnRlcnMsIF9vcHRpb25zKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBfb3B0aW9ucylcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21wdXRlVGhyb3R0bGVUaW1lb3V0ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkIGNvbXB1dGVUaHJvdHRsZVRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21wdXRlVGhyb3R0bGVNYXhRdWV1ZVNpemUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWQgY29tcHV0ZVRocm90dGxlTWF4UXVldWVTaXplJylcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsQ291bnRlcnMgPSBpbml0aWFsQ291bnRlcnNcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuX2VuYWJsZWQgPSB0aGlzLl9vcHRpb25zLmVuYWJsZWRcblxuICAgIHRoaXMuX2dsb2JhbCA9IG5ldyBTdGF0KGluaXRpYWxDb3VudGVycywgb3B0aW9ucylcbiAgICB0aGlzLl9nbG9iYWwub24oJ3VwZGF0ZScsIChzdGF0cykgPT4gdGhpcy5lbWl0KCd1cGRhdGUnLCBzdGF0cykpXG5cbiAgICB0aGlzLl9wZWVycyA9IG5ldyBNYXAoKVxuICB9XG5cbiAgZW5hYmxlICgpIHtcbiAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZVxuICAgIHRoaXMuX29wdGlvbnMuZW5hYmxlZCA9IHRydWVcbiAgICB0aGlzLl9nbG9iYWwuZW5hYmxlKClcbiAgfVxuXG4gIGRpc2FibGUgKCkge1xuICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZVxuICAgIHRoaXMuX29wdGlvbnMuZW5hYmxlZCA9IGZhbHNlXG4gICAgdGhpcy5fZ2xvYmFsLmRpc2FibGUoKVxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlXG4gICAgdGhpcy5fZ2xvYmFsLnN0b3AoKVxuICAgIGZvciAobGV0IHBlZXJTdGF0IG9mIHRoaXMuX3BlZXJzKSB7XG4gICAgICBwZWVyU3RhdFsxXS5zdG9wKClcbiAgICB9XG4gIH1cblxuICBnZXQgc25hcHNob3QgKCkge1xuICAgIHJldHVybiB0aGlzLl9nbG9iYWwuc25hcHNob3RcbiAgfVxuXG4gIGdldCBtb3ZpbmdBdmVyYWdlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dsb2JhbC5tb3ZpbmdBdmVyYWdlc1xuICB9XG5cbiAgZm9yUGVlciAocGVlcklkKSB7XG4gICAgaWYgKHBlZXJJZC50b0I1OFN0cmluZykge1xuICAgICAgcGVlcklkID0gcGVlcklkLnRvQjU4U3RyaW5nKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJzLmdldChwZWVySWQpXG4gIH1cblxuICBwdXNoIChwZWVyLCBjb3VudGVyLCBpbmMpIHtcbiAgICBpZiAodGhpcy5fZW5hYmxlZCkge1xuICAgICAgdGhpcy5fZ2xvYmFsLnB1c2goY291bnRlciwgaW5jKVxuXG4gICAgICBpZiAocGVlcikge1xuICAgICAgICBsZXQgcGVlclN0YXRzID0gdGhpcy5fcGVlcnMuZ2V0KHBlZXIpXG4gICAgICAgIGlmICghcGVlclN0YXRzKSB7XG4gICAgICAgICAgcGVlclN0YXRzID0gbmV3IFN0YXQodGhpcy5faW5pdGlhbENvdW50ZXJzLCB0aGlzLl9vcHRpb25zKVxuICAgICAgICAgIHRoaXMuX3BlZXJzLnNldChwZWVyLCBwZWVyU3RhdHMpXG4gICAgICAgIH1cblxuICAgICAgICBwZWVyU3RhdHMucHVzaChjb3VudGVyLCBpbmMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkIChwZWVyKSB7XG4gICAgY29uc3QgcGVlcklkID0gcGVlci50b0I1OFN0cmluZygpXG4gICAgY29uc3QgcGVlclN0YXRzID0gdGhpcy5fcGVlcnMuZ2V0KHBlZXJJZClcbiAgICBpZiAocGVlclN0YXRzKSB7XG4gICAgICBwZWVyU3RhdHMuc3RvcCgpXG4gICAgICB0aGlzLl9wZWVycy5kZWxldGUocGVlcklkKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRzXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbmV4dFRpY2sgPSByZXF1aXJlKCdhc3luYy9uZXh0VGljaycpXG5jb25zdCBNZXNzYWdlID0gcmVxdWlyZSgnLi4vdHlwZXMvbWVzc2FnZScpXG5jb25zdCBXYW50bGlzdCA9IHJlcXVpcmUoJy4uL3R5cGVzL3dhbnRsaXN0JylcbmNvbnN0IENPTlNUQU5UUyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpXG5jb25zdCBNc2dRdWV1ZSA9IHJlcXVpcmUoJy4vbXNnLXF1ZXVlJylcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4uL3V0aWxzJykubG9nZ2VyXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgV2FudE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvciAocGVlcklkLCBuZXR3b3JrLCBzdGF0cykge1xuICAgIHRoaXMucGVlcnMgPSBuZXcgTWFwKClcbiAgICB0aGlzLndhbnRsaXN0ID0gbmV3IFdhbnRsaXN0KHN0YXRzKVxuXG4gICAgdGhpcy5uZXR3b3JrID0gbmV0d29ya1xuICAgIHRoaXMuX3N0YXRzID0gc3RhdHNcblxuICAgIHRoaXMuX3BlZXJJZCA9IHBlZXJJZFxuICAgIHRoaXMuX2xvZyA9IGxvZ2dlcihwZWVySWQsICd3YW50JylcbiAgfVxuXG4gIF9hZGRFbnRyaWVzIChjaWRzLCBjYW5jZWwsIGZvcmNlKSB7XG4gICAgY29uc3QgZW50cmllcyA9IGNpZHMubWFwKChjaWQsIGkpID0+IHtcbiAgICAgIHJldHVybiBuZXcgTWVzc2FnZS5FbnRyeShjaWQsIENPTlNUQU5UUy5rTWF4UHJpb3JpdHkgLSBpLCBjYW5jZWwpXG4gICAgfSlcblxuICAgIGVudHJpZXMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgLy8gYWRkIGNoYW5nZXMgdG8gb3VyIHdhbnRsaXN0XG4gICAgICBpZiAoZS5jYW5jZWwpIHtcbiAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgdGhpcy53YW50bGlzdC5yZW1vdmVGb3JjZShlLmNpZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndhbnRsaXN0LnJlbW92ZShlLmNpZClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbG9nKCdhZGRpbmcgdG8gd2wnKVxuICAgICAgICB0aGlzLndhbnRsaXN0LmFkZChlLmNpZCwgZS5wcmlvcml0eSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gYnJvYWRjYXN0IGNoYW5nZXNcbiAgICBmb3IgKGxldCBwIG9mIHRoaXMucGVlcnMudmFsdWVzKCkpIHtcbiAgICAgIHAuYWRkRW50cmllcyhlbnRyaWVzKVxuICAgIH1cbiAgfVxuXG4gIF9zdGFydFBlZXJIYW5kbGVyIChwZWVySWQpIHtcbiAgICBsZXQgbXEgPSB0aGlzLnBlZXJzLmdldChwZWVySWQudG9CNThTdHJpbmcoKSlcblxuICAgIGlmIChtcSkge1xuICAgICAgbXEucmVmY250KytcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIG1xID0gbmV3IE1zZ1F1ZXVlKHRoaXMuX3BlZXJJZCwgcGVlcklkLCB0aGlzLm5ldHdvcmspXG5cbiAgICAvLyBuZXcgcGVlciwgZ2l2ZSB0aGVtIHRoZSBmdWxsIHdhbnRsaXN0XG4gICAgY29uc3QgZnVsbHdhbnRsaXN0ID0gbmV3IE1lc3NhZ2UodHJ1ZSlcblxuICAgIGZvciAobGV0IGVudHJ5IG9mIHRoaXMud2FudGxpc3QuZW50cmllcygpKSB7XG4gICAgICBmdWxsd2FudGxpc3QuYWRkRW50cnkoZW50cnlbMV0uY2lkLCBlbnRyeVsxXS5wcmlvcml0eSlcbiAgICB9XG5cbiAgICBtcS5hZGRNZXNzYWdlKGZ1bGx3YW50bGlzdClcblxuICAgIHRoaXMucGVlcnMuc2V0KHBlZXJJZC50b0I1OFN0cmluZygpLCBtcSlcbiAgICByZXR1cm4gbXFcbiAgfVxuXG4gIF9zdG9wUGVlckhhbmRsZXIgKHBlZXJJZCkge1xuICAgIGNvbnN0IG1xID0gdGhpcy5wZWVycy5nZXQocGVlcklkLnRvQjU4U3RyaW5nKCkpXG5cbiAgICBpZiAoIW1xKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBtcS5yZWZjbnQtLVxuICAgIGlmIChtcS5yZWZjbnQgPiAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnBlZXJzLmRlbGV0ZShwZWVySWQudG9CNThTdHJpbmcoKSlcbiAgfVxuXG4gIC8vIGFkZCBhbGwgdGhlIGNpZHMgdG8gdGhlIHdhbnRsaXN0XG4gIHdhbnRCbG9ja3MgKGNpZHMpIHtcbiAgICB0aGlzLl9hZGRFbnRyaWVzKGNpZHMsIGZhbHNlKVxuICB9XG5cbiAgLy8gcmVtb3ZlIGJsb2NrcyBvZiBhbGwgdGhlIGdpdmVuIGtleXMgd2l0aG91dCByZXNwZWN0aW5nIHJlZmNvdW50c1xuICB1bndhbnRCbG9ja3MgKGNpZHMpIHtcbiAgICB0aGlzLl9sb2coJ3Vud2FudCBibG9ja3M6ICVzJywgY2lkcy5sZW5ndGgpXG4gICAgdGhpcy5fYWRkRW50cmllcyhjaWRzLCB0cnVlLCB0cnVlKVxuICB9XG5cbiAgLy8gY2FuY2VsIHdhbnRpbmcgYWxsIG9mIHRoZSBnaXZlbiBrZXlzXG4gIGNhbmNlbFdhbnRzIChjaWRzKSB7XG4gICAgdGhpcy5fbG9nKCdjYW5jZWwgd2FudHM6ICVzJywgY2lkcy5sZW5ndGgpXG4gICAgdGhpcy5fYWRkRW50cmllcyhjaWRzLCB0cnVlKVxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGxpc3Qgb2YgYWxsIGN1cnJlbnRseSBjb25uZWN0ZWQgcGVlcnNcbiAgY29ubmVjdGVkUGVlcnMgKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucGVlcnMua2V5cygpKVxuICB9XG5cbiAgY29ubmVjdGVkIChwZWVySWQpIHtcbiAgICB0aGlzLl9zdGFydFBlZXJIYW5kbGVyKHBlZXJJZClcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZCAocGVlcklkKSB7XG4gICAgdGhpcy5fc3RvcFBlZXJIYW5kbGVyKHBlZXJJZClcbiAgfVxuXG4gIHN0YXJ0IChjYWxsYmFjaykge1xuICAgIC8vIHJlc2VuZCBlbnRpcmUgd2FudGxpc3QgZXZlcnkgc28gb2Z0ZW5cbiAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5fbG9nKCdyZXNlbmQgZnVsbC13YW50bGlzdCcpXG4gICAgICBjb25zdCBmdWxsd2FudGxpc3QgPSBuZXcgTWVzc2FnZSh0cnVlKVxuICAgICAgdGhpcy53YW50bGlzdC5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICBmdWxsd2FudGxpc3QuYWRkRW50cnkoZW50cnkuY2lkLCBlbnRyeS5wcmlvcml0eSlcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMucGVlcnMuZm9yRWFjaCgocCkgPT4gcC5hZGRNZXNzYWdlKGZ1bGx3YW50bGlzdCkpXG4gICAgfSwgNjAgKiAxMDAwKVxuXG4gICAgbmV4dFRpY2soKCkgPT4gY2FsbGJhY2soKSlcbiAgfVxuXG4gIHN0b3AgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wZWVycy5mb3JFYWNoKChtcSkgPT4gdGhpcy5kaXNjb25uZWN0ZWQobXEucGVlcklkKSlcblxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcilcbiAgICBuZXh0VGljaygoKSA9PiBjYWxsYmFjaygpKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbHAgPSByZXF1aXJlKCdwdWxsLWxlbmd0aC1wcmVmaXhlZCcpXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0nKVxuY29uc3Qgd2F0ZXJmYWxsID0gcmVxdWlyZSgnYXN5bmMvd2F0ZXJmYWxsJylcbmNvbnN0IGVhY2ggPSByZXF1aXJlKCdhc3luYy9lYWNoJylcbmNvbnN0IG5leHRUaWNrID0gcmVxdWlyZSgnYXN5bmMvbmV4dFRpY2snKVxuXG5jb25zdCBNZXNzYWdlID0gcmVxdWlyZSgnLi90eXBlcy9tZXNzYWdlJylcbmNvbnN0IENPTlNUQU5UUyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4vdXRpbHMnKS5sb2dnZXJcblxuY29uc3QgQklUU1dBUDEwMCA9ICcvaXBmcy9iaXRzd2FwLzEuMC4wJ1xuY29uc3QgQklUU1dBUDExMCA9ICcvaXBmcy9iaXRzd2FwLzEuMS4wJ1xuXG5jbGFzcyBOZXR3b3JrIHtcbiAgY29uc3RydWN0b3IgKGxpYnAycCwgYml0c3dhcCwgb3B0aW9ucywgc3RhdHMpIHtcbiAgICB0aGlzLl9sb2cgPSBsb2dnZXIobGlicDJwLnBlZXJJbmZvLmlkLCAnbmV0d29yaycpXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB0aGlzLmxpYnAycCA9IGxpYnAycFxuICAgIHRoaXMuYml0c3dhcCA9IGJpdHN3YXBcbiAgICB0aGlzLmIxMDBPbmx5ID0gb3B0aW9ucy5iMTAwT25seSB8fCBmYWxzZVxuXG4gICAgdGhpcy5fc3RhdHMgPSBzdGF0c1xuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZVxuICB9XG5cbiAgc3RhcnQgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWVcbiAgICAvLyBiaW5kIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMuX29uUGVlckNvbm5lY3QgPSB0aGlzLl9vblBlZXJDb25uZWN0LmJpbmQodGhpcylcbiAgICB0aGlzLl9vblBlZXJEaXNjb25uZWN0ID0gdGhpcy5fb25QZWVyRGlzY29ubmVjdC5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9vbkNvbm5lY3Rpb24gPSB0aGlzLl9vbkNvbm5lY3Rpb24uYmluZCh0aGlzKVxuICAgIHRoaXMubGlicDJwLmhhbmRsZShCSVRTV0FQMTAwLCB0aGlzLl9vbkNvbm5lY3Rpb24pXG4gICAgaWYgKCF0aGlzLmIxMDBPbmx5KSB7IHRoaXMubGlicDJwLmhhbmRsZShCSVRTV0FQMTEwLCB0aGlzLl9vbkNvbm5lY3Rpb24pIH1cblxuICAgIHRoaXMubGlicDJwLm9uKCdwZWVyOmNvbm5lY3QnLCB0aGlzLl9vblBlZXJDb25uZWN0KVxuICAgIHRoaXMubGlicDJwLm9uKCdwZWVyOmRpc2Nvbm5lY3QnLCB0aGlzLl9vblBlZXJEaXNjb25uZWN0KVxuXG4gICAgLy8gQWxsIGV4aXN0aW5nIGNvbm5lY3Rpb25zIGFyZSBsaWtlIG5ldyBvbmVzIGZvciB1c1xuICAgIHRoaXMubGlicDJwLnBlZXJCb29rXG4gICAgICAuZ2V0QWxsQXJyYXkoKVxuICAgICAgLmZpbHRlcigocGVlcikgPT4gcGVlci5pc0Nvbm5lY3RlZCgpKVxuICAgICAgLmZvckVhY2goKHBlZXIpID0+IHRoaXMuX29uUGVlckNvbm5lY3QoKHBlZXIpKSlcblxuICAgIG5leHRUaWNrKCgpID0+IGNhbGxiYWNrKCkpXG4gIH1cblxuICBzdG9wIChjYWxsYmFjaykge1xuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZVxuXG4gICAgdGhpcy5saWJwMnAudW5oYW5kbGUoQklUU1dBUDEwMClcbiAgICBpZiAoIXRoaXMuYjEwME9ubHkpIHsgdGhpcy5saWJwMnAudW5oYW5kbGUoQklUU1dBUDExMCkgfVxuXG4gICAgdGhpcy5saWJwMnAucmVtb3ZlTGlzdGVuZXIoJ3BlZXI6Y29ubmVjdCcsIHRoaXMuX29uUGVlckNvbm5lY3QpXG4gICAgdGhpcy5saWJwMnAucmVtb3ZlTGlzdGVuZXIoJ3BlZXI6ZGlzY29ubmVjdCcsIHRoaXMuX29uUGVlckRpc2Nvbm5lY3QpXG5cbiAgICBuZXh0VGljaygoKSA9PiBjYWxsYmFjaygpKVxuICB9XG5cbiAgLy8gSGFuZGxlcyBib3RoIHR5cGVzIG9mIGJpdHN3YXAgbWVzc2dhZ2VzXG4gIF9vbkNvbm5lY3Rpb24gKHByb3RvY29sLCBjb25uKSB7XG4gICAgaWYgKCF0aGlzLl9ydW5uaW5nKSB7IHJldHVybiB9XG4gICAgdGhpcy5fbG9nKCdpbmNvbW1pbmcgbmV3IGJpdHN3YXAgY29ubmVjdGlvbjogJXMnLCBwcm90b2NvbClcblxuICAgIHB1bGwoXG4gICAgICBjb25uLFxuICAgICAgbHAuZGVjb2RlKCksXG4gICAgICBwdWxsLmFzeW5jTWFwKChkYXRhLCBjYikgPT4gTWVzc2FnZS5kZXNlcmlhbGl6ZShkYXRhLCBjYikpLFxuICAgICAgcHVsbC5hc3luY01hcCgobXNnLCBjYikgPT4ge1xuICAgICAgICBjb25uLmdldFBlZXJJbmZvKChlcnIsIHBlZXJJbmZvKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikgeyByZXR1cm4gY2IoZXJyKSB9XG5cbiAgICAgICAgICAvLyB0aGlzLl9sb2coJ2RhdGEgZnJvbScsIHBlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKCkpXG4gICAgICAgICAgdGhpcy5iaXRzd2FwLl9yZWNlaXZlTWVzc2FnZShwZWVySW5mby5pZCwgbXNnLCBjYilcbiAgICAgICAgfSlcbiAgICAgIH0pLFxuICAgICAgcHVsbC5vbkVuZCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuX2xvZygnZW5kaW5nIGNvbm5lY3Rpb24nKVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdGhpcy5iaXRzd2FwLl9yZWNlaXZlRXJyb3IoZXJyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIF9vblBlZXJDb25uZWN0IChwZWVySW5mbykge1xuICAgIGlmICghdGhpcy5fcnVubmluZykgeyByZXR1cm4gfVxuXG4gICAgdGhpcy5iaXRzd2FwLl9vblBlZXJDb25uZWN0ZWQocGVlckluZm8uaWQpXG4gIH1cblxuICBfb25QZWVyRGlzY29ubmVjdCAocGVlckluZm8pIHtcbiAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHsgcmV0dXJuIH1cblxuICAgIHRoaXMuYml0c3dhcC5fb25QZWVyRGlzY29ubmVjdGVkKHBlZXJJbmZvLmlkKVxuICB9XG5cbiAgZmluZFByb3ZpZGVycyAoY2lkLCBtYXhQcm92aWRlcnMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5saWJwMnAuY29udGVudFJvdXRpbmcuZmluZFByb3ZpZGVycyhjaWQsIHtcbiAgICAgIG1heFRpbWVvdXQ6IENPTlNUQU5UUy5wcm92aWRlclJlcXVlc3RUaW1lb3V0LFxuICAgICAgbWF4TnVtUHJvdmlkZXJzOiBtYXhQcm92aWRlcnNcbiAgICB9LCBjYWxsYmFjaylcbiAgfVxuXG4gIGZpbmRBbmRDb25uZWN0IChjaWQsIGNhbGxiYWNrKSB7XG4gICAgd2F0ZXJmYWxsKFtcbiAgICAgIChjYikgPT4gdGhpcy5maW5kUHJvdmlkZXJzKGNpZCwgQ09OU1RBTlRTLm1heFByb3ZpZGVyc1BlclJlcXVlc3QsIGNiKSxcbiAgICAgIChwcm92cywgY2IpID0+IHtcbiAgICAgICAgdGhpcy5fbG9nKCdjb25uZWN0aW5nIHRvIHByb3ZpZGVycycsIHByb3ZzLm1hcCgocCkgPT4gcC5pZC50b0I1OFN0cmluZygpKSlcbiAgICAgICAgZWFjaChwcm92cywgKHAsIGNiKSA9PiB0aGlzLmNvbm5lY3RUbyhwLCBjYikpXG4gICAgICB9XG4gICAgXSwgY2FsbGJhY2spXG4gIH1cblxuICBwcm92aWRlIChjaWQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5saWJwMnAuY29udGVudFJvdXRpbmcucHJvdmlkZShjaWQsIGNhbGxiYWNrKVxuICB9XG5cbiAgLy8gQ29ubmVjdCB0byB0aGUgZ2l2ZW4gcGVlclxuICAvLyBTZW5kIHRoZSBnaXZlbiBtc2cgKGluc3RhbmNlIG9mIE1lc3NhZ2UpIHRvIHRoZSBnaXZlbiBwZWVyXG4gIHNlbmRNZXNzYWdlIChwZWVyLCBtc2csIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9ydW5uaW5nKSB7IHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoYG5ldHdvcmsgaXNuJ3QgcnVubmluZ2ApKSB9XG5cbiAgICBjb25zdCBzdHJpbmdJZCA9IHBlZXIudG9CNThTdHJpbmcoKSA/IHBlZXIudG9CNThTdHJpbmcoKSA6IHBlZXIuaWQudG9CNThTdHJpbmcoKVxuICAgIHRoaXMuX2xvZygnc2VuZE1lc3NhZ2UgdG8gJXMnLCBzdHJpbmdJZCwgbXNnKVxuXG4gICAgdGhpcy5fZGlhbFBlZXIocGVlciwgKGVyciwgY29ubiwgcHJvdG9jb2wpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgbGV0IHNlcmlhbGl6ZWRcbiAgICAgIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICAgICAgY2FzZSBCSVRTV0FQMTAwOlxuICAgICAgICAgIHNlcmlhbGl6ZWQgPSBtc2cuc2VyaWFsaXplVG9CaXRzd2FwMTAwKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIEJJVFNXQVAxMTA6XG4gICAgICAgICAgc2VyaWFsaXplZCA9IG1zZy5zZXJpYWxpemVUb0JpdHN3YXAxMTAoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignVW5rb3duIHByb3RvY29sOiAnICsgcHJvdG9jb2wpKVxuICAgICAgfVxuICAgICAgLy8gVE9ETzogd2h5IGRvZXNuJ3QgdGhlIGVycm9yIGdldCBwcm9wYWdldGVkIGJhY2s/P1xuICAgICAgd3JpdGVNZXNzYWdlKGNvbm4sIHNlcmlhbGl6ZWQsIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihlcnIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBjYWxsYmFjaygpXG4gICAgICB0aGlzLl91cGRhdGVTZW50U3RhdHMocGVlciwgbXNnLmJsb2NrcylcbiAgICB9KVxuICB9XG5cbiAgY29ubmVjdFRvIChwZWVyLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fcnVubmluZykgeyByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKGBuZXR3b3JrIGlzbid0IHJ1bm5pbmdgKSkgfVxuXG4gICAgdGhpcy5saWJwMnAuZGlhbChwZWVyLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8vIERpYWwgdG8gdGhlIHBlZXIgYW5kIHRyeSB0byB1c2UgdGhlIG1vc3QgcmVjZW50IEJpdHN3YXBcbiAgX2RpYWxQZWVyIChwZWVyLCBjYWxsYmFjaykge1xuICAgIC8vIEF0dGVtcHQgQml0c3dhcCAxLjEuMFxuICAgIHRoaXMubGlicDJwLmRpYWxQcm90b2NvbChwZWVyLCBCSVRTV0FQMTEwLCAoZXJyLCBjb25uKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIEF0dGVtcHQgQml0c3dhcCAxLjAuMFxuICAgICAgICB0aGlzLmxpYnAycC5kaWFsUHJvdG9jb2wocGVlciwgQklUU1dBUDEwMCwgKGVyciwgY29ubikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycikgfVxuXG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgY29ubiwgQklUU1dBUDEwMClcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgY29ubiwgQklUU1dBUDExMClcbiAgICB9KVxuICB9XG5cbiAgX3VwZGF0ZVNlbnRTdGF0cyAocGVlciwgYmxvY2tzKSB7XG4gICAgY29uc3QgcGVlcklkID0gcGVlci50b0I1OFN0cmluZygpXG4gICAgaWYgKHRoaXMuX3N0YXRzKSB7XG4gICAgICBibG9ja3MuZm9yRWFjaCgoYmxvY2spID0+IHRoaXMuX3N0YXRzLnB1c2gocGVlcklkLCAnZGF0YVNlbnQnLCBibG9jay5kYXRhLmxlbmd0aCkpXG4gICAgICB0aGlzLl9zdGF0cy5wdXNoKHBlZXJJZCwgJ2Jsb2Nrc1NlbnQnLCBibG9ja3Muc2l6ZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGVNZXNzYWdlIChjb25uLCBtc2csIGNhbGxiYWNrKSB7XG4gIHB1bGwoXG4gICAgcHVsbC52YWx1ZXMoW21zZ10pLFxuICAgIGxwLmVuY29kZSgpLFxuICAgIGNvbm4sXG4gICAgcHVsbC5vbkVuZChjYWxsYmFjaylcbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5ldHdvcmtcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUmVjb3JkOiByZXF1aXJlKCcuL3JlY29yZCcpLFxuICB2YWxpZGF0b3I6IHJlcXVpcmUoJy4vdmFsaWRhdG9yJyksXG4gIHNlbGVjdGlvbjogcmVxdWlyZSgnLi9zZWxlY3Rpb24nKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2UzMkVuY29kZSA9IHJlcXVpcmUoJ2Jhc2UzMi1lbmNvZGUnKVxuY29uc3QgTmFub0RhdGUgPSByZXF1aXJlKCd0aW1lc3RhbXAtbmFubycpXG5jb25zdCB7IEtleSB9ID0gcmVxdWlyZSgnaW50ZXJmYWNlLWRhdGFzdG9yZScpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdsaWJwMnAtY3J5cHRvJylcbmNvbnN0IFBlZXJJZCA9IHJlcXVpcmUoJ3BlZXItaWQnKVxuY29uc3QgbXVsdGloYXNoID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IGxvZyA9IGRlYnVnKCdqc2lwbnMnKVxubG9nLmVycm9yID0gZGVidWcoJ2pzaXBuczplcnJvcicpXG5cbmNvbnN0IGlwbnNFbnRyeVByb3RvID0gcmVxdWlyZSgnLi9wYi9pcG5zLnByb3RvJylcbmNvbnN0IHsgcGFyc2VSRkMzMzM5IH0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IEVSUk9SUyA9IHJlcXVpcmUoJy4vZXJyb3JzJylcblxuY29uc3QgSURfTVVMVElIQVNIX0NPREUgPSBtdWx0aWhhc2gubmFtZXMuaWRcblxuY29uc3QgbmFtZXNwYWNlID0gJy9pcG5zLydcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlwbnMgZW50cnkgYW5kIHNpZ25zIGl0IHdpdGggdGhlIGdpdmVuIHByaXZhdGUga2V5LlxuICogVGhlIGlwbnMgZW50cnkgdmFsaWRpdHkgc2hvdWxkIGZvbGxvdyB0aGUgW1JGQzMzMzlde0BsaW5rIGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMzMzM5LnR4dH0gd2l0aCBuYW5vc2Vjb25kcyBwcmVjaXNpb24uXG4gKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGVtYmVkIHRoZSBwdWJsaWMga2V5LiBJZiB5b3Ugd2FudCB0byBkbyB0aGF0LCB1c2UgYEVtYmVkUHVibGljS2V5YC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJpdmF0ZUtleSBwcml2YXRlIGtleSBmb3Igc2lnbmluZyB0aGUgcmVjb3JkLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHZhbHVlIHRvIGJlIHN0b3JlZCBpbiB0aGUgcmVjb3JkLlxuICogQHBhcmFtIHtudW1iZXJ9IHNlcSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIHJlY29yZC5cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbGlmZXRpbWUgbGlmZXRpbWUgb2YgdGhlIHJlY29yZCAoaW4gbWlsbGlzZWNvbmRzKS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIGVudHJ5KX0gW2NhbGxiYWNrXVxuICovXG5jb25zdCBjcmVhdGUgPSAocHJpdmF0ZUtleSwgdmFsdWUsIHNlcSwgbGlmZXRpbWUsIGNhbGxiYWNrKSA9PiB7XG4gIC8vIFZhbGlkaXR5IGluIElTT1N0cmluZyB3aXRoIG5hbm9zZWNvbmRzIHByZWNpc2lvbiBhbmQgdmFsaWRpdHkgdHlwZSBFT0xcbiAgY29uc3QgaXNvVmFsaWRpdHkgPSBuZXcgTmFub0RhdGUoRGF0ZS5ub3coKSArIE51bWJlcihsaWZldGltZSkpLnRvU3RyaW5nKClcbiAgY29uc3QgdmFsaWRpdHlUeXBlID0gaXBuc0VudHJ5UHJvdG8uVmFsaWRpdHlUeXBlLkVPTFxuICBfY3JlYXRlKHByaXZhdGVLZXksIHZhbHVlLCBzZXEsIGlzb1ZhbGlkaXR5LCB2YWxpZGl0eVR5cGUsIGNhbGxiYWNrKVxufVxuXG4vKipcbiAqIFNhbWUgYXMgY3JlYXRlKCksIGJ1dCBpbnN0ZWFkIG9mIGdlbmVyYXRpbmcgYSBuZXcgRGF0ZSwgaXQgcmVjZWl2ZXMgdGhlIGludGVuZGVkIGV4cGlyYXRpb24gdGltZVxuICogV0FSTklORzogbmFubyBwcmVjaXNpb24gaXMgbm90IHN0YW5kYXJkLCBtYWtlIHN1cmUgdGhlIHZhbHVlIGluIHNlY29uZHMgaXMgOSBvcmRlcnMgb2YgbWFnbml0dWRlIGxlc3NlciB0aGFuIHRoZSBvbmUgcHJvdmlkZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJpdmF0ZUtleSBwcml2YXRlIGtleSBmb3Igc2lnbmluZyB0aGUgcmVjb3JkLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHZhbHVlIHRvIGJlIHN0b3JlZCBpbiB0aGUgcmVjb3JkLlxuICogQHBhcmFtIHtudW1iZXJ9IHNlcSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIHJlY29yZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBleHBpcmF0aW9uIGV4cGlyYXRpb24gZGF0ZXRpbWUgZm9yIHJlY29yZCBpbiB0aGUgW1JGQzMzMzlde0BsaW5rIGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMzMzM5LnR4dH0gd2l0aCBuYW5vc2Vjb25kcyBwcmVjaXNpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBlbnRyeSl9IFtjYWxsYmFja11cbiAqL1xuY29uc3QgY3JlYXRlV2l0aEV4cGlyYXRpb24gPSAocHJpdmF0ZUtleSwgdmFsdWUsIHNlcSwgZXhwaXJhdGlvbiwgY2FsbGJhY2spID0+IHtcbiAgY29uc3QgdmFsaWRpdHlUeXBlID0gaXBuc0VudHJ5UHJvdG8uVmFsaWRpdHlUeXBlLkVPTFxuICBfY3JlYXRlKHByaXZhdGVLZXksIHZhbHVlLCBzZXEsIGV4cGlyYXRpb24sIHZhbGlkaXR5VHlwZSwgY2FsbGJhY2spXG59XG5cbmNvbnN0IF9jcmVhdGUgPSAocHJpdmF0ZUtleSwgdmFsdWUsIHNlcSwgaXNvVmFsaWRpdHksIHZhbGlkaXR5VHlwZSwgY2FsbGJhY2spID0+IHtcbiAgc2lnbihwcml2YXRlS2V5LCB2YWx1ZSwgdmFsaWRpdHlUeXBlLCBpc29WYWxpZGl0eSwgKGVycm9yLCBzaWduYXR1cmUpID0+IHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcigncmVjb3JkIHNpZ25hdHVyZSBjcmVhdGlvbiBmYWlsZWQnKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdyZWNvcmQgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQnKSwgeyBjb2RlOiBFUlJPUlMuRVJSX1NJR05BVFVSRV9DUkVBVElPTiB9KSlcbiAgICB9XG5cbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgdmFsaWRpdHlUeXBlOiB2YWxpZGl0eVR5cGUsXG4gICAgICB2YWxpZGl0eTogaXNvVmFsaWRpdHksXG4gICAgICBzZXF1ZW5jZTogc2VxXG4gICAgfVxuXG4gICAgbG9nKGBpcG5zIGVudHJ5IGZvciAke3ZhbHVlfSBjcmVhdGVkYClcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZW50cnkpXG4gIH0pXG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBnaXZlbiBpcG5zIGVudHJ5IGFnYWluc3QgdGhlIGdpdmVuIHB1YmxpYyBrZXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHB1YmxpY0tleSBwdWJsaWMga2V5IGZvciB2YWxpZGF0aW5nIHRoZSByZWNvcmQuXG4gKiBAcGFyYW0ge09iamVjdH0gZW50cnkgaXBucyBlbnRyeSByZWNvcmQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gW2NhbGxiYWNrXVxuICovXG5jb25zdCB2YWxpZGF0ZSA9IChwdWJsaWNLZXksIGVudHJ5LCBjYWxsYmFjaykgPT4ge1xuICBjb25zdCB7IHZhbHVlLCB2YWxpZGl0eVR5cGUsIHZhbGlkaXR5IH0gPSBlbnRyeVxuICBjb25zdCBkYXRhRm9yU2lnbmF0dXJlID0gaXBuc0VudHJ5RGF0YUZvclNpZyh2YWx1ZSwgdmFsaWRpdHlUeXBlLCB2YWxpZGl0eSlcblxuICAvLyBWYWxpZGF0ZSBTaWduYXR1cmVcbiAgcHVibGljS2V5LnZlcmlmeShkYXRhRm9yU2lnbmF0dXJlLCBlbnRyeS5zaWduYXR1cmUsIChlcnIsIGlzVmFsaWQpID0+IHtcbiAgICBpZiAoZXJyIHx8ICFpc1ZhbGlkKSB7XG4gICAgICBsb2cuZXJyb3IoJ3JlY29yZCBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZCcpXG4gICAgICByZXR1cm4gY2FsbGJhY2soT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ3JlY29yZCBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZCcpLCB7IGNvZGU6IEVSUk9SUy5FUlJfU0lHTkFUVVJFX1ZFUklGSUNBVElPTiB9KSlcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBhY2NvcmRpbmcgdG8gdGhlIHZhbGlkaXR5IHR5cGVcbiAgICBpZiAodmFsaWRpdHlUeXBlID09PSBpcG5zRW50cnlQcm90by5WYWxpZGl0eVR5cGUuRU9MKSB7XG4gICAgICBsZXQgdmFsaWRpdHlEYXRlXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbGlkaXR5RGF0ZSA9IHBhcnNlUkZDMzMzOSh2YWxpZGl0eS50b1N0cmluZygpKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cuZXJyb3IoJ3VucmVjb2duaXplZCB2YWxpZGl0eSBmb3JtYXQgKG5vdCBhbiByZmMzMzM5IGZvcm1hdCknKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ3VucmVjb2duaXplZCB2YWxpZGl0eSBmb3JtYXQgKG5vdCBhbiByZmMzMzM5IGZvcm1hdCknKSwgeyBjb2RlOiBFUlJPUlMuRVJSX1VOUkVDT0dOSVpFRF9GT1JNQVQgfSkpXG4gICAgICB9XG5cbiAgICAgIGlmICh2YWxpZGl0eURhdGUgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgIGxvZy5lcnJvcigncmVjb3JkIGhhcyBleHBpcmVkJylcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdyZWNvcmQgaGFzIGV4cGlyZWQnKSwgeyBjb2RlOiBFUlJPUlMuRVJSX0lQTlNfRVhQSVJFRF9SRUNPUkQgfSkpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWxpZGl0eVR5cGUpIHtcbiAgICAgIGxvZy5lcnJvcigndW5yZWNvZ25pemVkIHZhbGlkaXR5IHR5cGUnKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCd1bnJlY29nbml6ZWQgdmFsaWRpdHkgdHlwZScpLCB7IGNvZGU6IEVSUk9SUy5FUlJfVU5SRUNPR05JWkVEX1ZBTElESVRZIH0pKVxuICAgIH1cblxuICAgIGxvZyhgaXBucyBlbnRyeSBmb3IgJHt2YWx1ZX0gaXMgdmFsaWRgKVxuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKVxuICB9KVxufVxuXG4vKipcbiAqIEVtYmVkIHRoZSBnaXZlbiBwdWJsaWMga2V5IGluIHRoZSBnaXZlbiBlbnRyeS4gV2hpbGUgbm90IHN0cmljdGx5IHJlcXVpcmVkLFxuICogc29tZSBub2RlcyAoZWcuIERIVCBzZXJ2ZXJzKSBtYXkgcmVqZWN0IElQTlMgZW50cmllcyB0aGF0IGRvbid0IGVtYmVkIHRoZWlyXG4gKiBwdWJsaWMga2V5cyBhcyB0aGV5IG1heSBub3QgYmUgYWJsZSB0byB2YWxpZGF0ZSB0aGVtIGVmZmljaWVudGx5LlxuICogQXMgYSBjb25zZXF1ZW5jZSBvZiBub2RlcyBuZWVkaW5nIHRvIHZhbGlkYWRlIGEgcmVjb3JkIHVwb24gcmVjZWlwdCwgdGhleSBuZWVkXG4gKiB0aGUgcHVibGljIGtleSBhc3NvY2lhdGVkIHdpdGggaXQuIEZvciBvbGRlIFJTQSBrZXlzLCBpdCBpcyBlYXNpZXIgaWYgd2UganVzdFxuICogc2VuZCB0aGlzIGFzIHBhcnQgb2YgdGhlIHJlY29yZCBpdHNlbGYuIEZvciBuZXdlciBlZDI1NTE5IGtleXMsIHRoZSBwdWJsaWMga2V5XG4gKiBjYW4gYmUgZW1iZWRkZWQgaW4gdGhlIHBlZXJJZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHVibGljS2V5IHB1YmxpYyBrZXkgdG8gZW1iZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gZW50cnkgaXBucyBlbnRyeSByZWNvcmQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gW2NhbGxiYWNrXVxuICogQHJldHVybiB7Vm9pZH1cbiAqL1xuY29uc3QgZW1iZWRQdWJsaWNLZXkgPSAocHVibGljS2V5LCBlbnRyeSwgY2FsbGJhY2spID0+IHtcbiAgaWYgKCFwdWJsaWNLZXkgfHwgIXB1YmxpY0tleS5ieXRlcyB8fCAhZW50cnkpIHtcbiAgICBjb25zdCBlcnJvciA9ICdvbmUgb3IgbW9yZSBvZiB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycyBhcmUgbm90IGRlZmluZWQnXG5cbiAgICBsb2cuZXJyb3IoZXJyb3IpXG4gICAgcmV0dXJuIGNhbGxiYWNrKE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGVycm9yKSwgeyBjb2RlOiBFUlJPUlMuRVJSX1VOREVGSU5FRF9QQVJBTUVURVIgfSkpXG4gIH1cblxuICAvLyBDcmVhdGUgYSBwZWVyIGlkIGZyb20gdGhlIHB1YmxpYyBrZXkuXG4gIFBlZXJJZC5jcmVhdGVGcm9tUHViS2V5KHB1YmxpY0tleS5ieXRlcywgKGVyciwgcGVlcklkKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgbG9nLmVycm9yKGVycilcbiAgICAgIHJldHVybiBjYWxsYmFjayhPYmplY3QuYXNzaWduKG5ldyBFcnJvcihlcnIpLCB7IGNvZGU6IEVSUk9SUy5FUlJfUEVFUl9JRF9GUk9NX1BVQkxJQ19LRVkgfSkpXG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIGV4dHJhY3QgdGhlIHB1YmxpYyBrZXkgZnJvbSB0aGUgSUQuIElmIHdlIGNhbiwgbm8gbmVlZCB0byBlbWJlZCBpdFxuICAgIGxldCBleHRyYWN0ZWRQdWJsaWNLZXlcbiAgICB0cnkge1xuICAgICAgZXh0cmFjdGVkUHVibGljS2V5ID0gZXh0cmFjdFB1YmxpY0tleUZyb21JZChwZWVySWQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGVyciksIHsgY29kZTogRVJST1JTLkVSUl9QVUJMSUNfS0VZX0ZST01fSUQgfSkpXG4gICAgfVxuXG4gICAgaWYgKGV4dHJhY3RlZFB1YmxpY0tleSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bGwpXG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZmFpbGVkIHRvIGV4dHJhY3QgdGhlIHB1YmxpYyBrZXkgZnJvbSB0aGUgcGVlciBJRCwgZW1iZWQgaXQgaW4gdGhlIHJlY29yZC5cbiAgICB0cnkge1xuICAgICAgZW50cnkucHViS2V5ID0gY3J5cHRvLmtleXMubWFyc2hhbFB1YmxpY0tleShwdWJsaWNLZXkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgZW50cnkpXG4gIH0pXG59XG5cbi8qKlxuICogRXh0cmFjdHMgYSBwdWJsaWMga2V5IG1hdGNoaW5nIGBwaWRgIGZyb20gdGhlIGlwbnMgcmVjb3JkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwZWVySWQgcGVlciBpZGVudGlmaWVyIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSBpcG5zIGVudHJ5IHJlY29yZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBbY2FsbGJhY2tdXG4gKiBAcmV0dXJuIHtWb2lkfVxuICovXG5jb25zdCBleHRyYWN0UHVibGljS2V5ID0gKHBlZXJJZCwgZW50cnksIGNhbGxiYWNrKSA9PiB7XG4gIGlmICghZW50cnkgfHwgIXBlZXJJZCkge1xuICAgIGNvbnN0IGVycm9yID0gJ29uZSBvciBtb3JlIG9mIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXJzIGFyZSBub3QgZGVmaW5lZCdcblxuICAgIGxvZy5lcnJvcihlcnJvcilcbiAgICByZXR1cm4gY2FsbGJhY2soT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoZXJyb3IpLCB7IGNvZGU6IEVSUk9SUy5FUlJfVU5ERUZJTkVEX1BBUkFNRVRFUiB9KSlcbiAgfVxuXG4gIGlmIChlbnRyeS5wdWJLZXkpIHtcbiAgICBsZXQgcHViS2V5XG4gICAgdHJ5IHtcbiAgICAgIHB1YktleSA9IGNyeXB0by5rZXlzLnVubWFyc2hhbFB1YmxpY0tleShlbnRyeS5wdWJLZXkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHB1YktleSlcbiAgfVxuXG4gIGlmIChwZWVySWQucHViS2V5KSB7XG4gICAgY2FsbGJhY2sobnVsbCwgcGVlcklkLnB1YktleSlcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjayhPYmplY3QuYXNzaWduKG5ldyBFcnJvcignbm8gcHVibGljIGtleSBpcyBhdmFpbGFibGUnKSwgeyBjb2RlOiBFUlJPUlMuRVJSX1VOREVGSU5FRF9QQVJBTUVURVIgfSkpXG4gIH1cbn1cblxuLy8gcmF3U3RkRW5jb2Rpbmcgd2l0aCBSRkM0NjQ4XG5jb25zdCByYXdTdGRFbmNvZGluZyA9IChrZXkpID0+IGJhc2UzMkVuY29kZShrZXksICdSRkM0NjQ4JywgeyBwYWRkaW5nOiBmYWxzZSB9KVxuXG4vKipcbiAqIEdldCBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlY29yZCBsb2NhbGx5LlxuICogRm9ybWF0OiAvaXBucy8ke2Jhc2UzMig8SEFTSD4pfVxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBrZXkgcGVlciBpZGVudGlmaWVyIG9iamVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGdldExvY2FsS2V5ID0gKGtleSkgPT4gbmV3IEtleShgL2lwbnMvJHtyYXdTdGRFbmNvZGluZyhrZXkpfWApXG5cbi8qKlxuICogR2V0IGtleSBmb3Igc2hhcmluZyB0aGUgcmVjb3JkIGluIHRoZSByb3V0aW5nIG1lY2hhbmlzbS5cbiAqIEZvcm1hdDogJHtiYXNlMzIoL2lwbnMvPEhBU0g+KX0sICR7YmFzZTMyKC9way88SEFTSD4pfVxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBwaWQgcGVlciBpZGVudGlmaWVyIHJlcHJlc2VudGVkIGJ5IHRoZSBtdWx0aWhhc2ggb2YgdGhlIHB1YmxpYyBrZXkgYXMgQnVmZmVyLlxuICogQHJldHVybnMge09iamVjdH0gY29udGFpbmluZyB0aGUgYG5hbWVLZXlgIGFuZCB0aGUgYGlwbnNLZXlgLlxuICovXG5jb25zdCBnZXRJZEtleXMgPSAocGlkKSA9PiB7XG4gIGNvbnN0IHBrQnVmZmVyID0gQnVmZmVyLmZyb20oJy9way8nKVxuICBjb25zdCBpcG5zQnVmZmVyID0gQnVmZmVyLmZyb20oJy9pcG5zLycpXG5cbiAgcmV0dXJuIHtcbiAgICByb3V0aW5nUHViS2V5OiBuZXcgS2V5KEJ1ZmZlci5jb25jYXQoW3BrQnVmZmVyLCBwaWRdKSksIC8vIEFkZGVkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9pcGZzL2pzLWlwbnMvcHVsbC84I2lzc3VlLTIxMzg1Nzg3NiAocGtLZXkgd2lsbCBiZSBkZXByZWNhdGVkIGluIGEgZnV0dXJlIHJlbGVhc2UpXG4gICAgcGtLZXk6IG5ldyBLZXkocmF3U3RkRW5jb2RpbmcoQnVmZmVyLmNvbmNhdChbcGtCdWZmZXIsIHBpZF0pKSksXG4gICAgcm91dGluZ0tleTogbmV3IEtleShCdWZmZXIuY29uY2F0KFtpcG5zQnVmZmVyLCBwaWRdKSksIC8vIEFkZGVkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9pcGZzL2pzLWlwbnMvcHVsbC82I2lzc3VlLTIxMzYzMTQ2MSAoaXBuc0tleSB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZSlcbiAgICBpcG5zS2V5OiBuZXcgS2V5KHJhd1N0ZEVuY29kaW5nKEJ1ZmZlci5jb25jYXQoW2lwbnNCdWZmZXIsIHBpZF0pKSlcbiAgfVxufVxuXG4vLyBTaWduIGlwbnMgcmVjb3JkIGRhdGFcbmNvbnN0IHNpZ24gPSAocHJpdmF0ZUtleSwgdmFsdWUsIHZhbGlkaXR5VHlwZSwgdmFsaWRpdHksIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGRhdGFGb3JTaWduYXR1cmUgPSBpcG5zRW50cnlEYXRhRm9yU2lnKHZhbHVlLCB2YWxpZGl0eVR5cGUsIHZhbGlkaXR5KVxuXG4gIHByaXZhdGVLZXkuc2lnbihkYXRhRm9yU2lnbmF0dXJlLCAoZXJyLCBzaWduYXR1cmUpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgc2lnbmF0dXJlKVxuICB9KVxufVxuXG4vLyBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSB2YWxpZGl0eSB0eXBlIGNvZGUgbmFtZSBvZiBhIHZhbGlkaXR5XG5jb25zdCBnZXRWYWxpZGl0eVR5cGUgPSAodmFsaWRpdHlUeXBlKSA9PiB7XG4gIGlmICh2YWxpZGl0eVR5cGUudG9TdHJpbmcoKSA9PT0gJzAnKSB7XG4gICAgcmV0dXJuICdFT0wnXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZXJyb3IgPSBgdW5yZWNvZ25pemVkIHZhbGlkaXR5IHR5cGUgJHt2YWxpZGl0eVR5cGUudG9TdHJpbmcoKX1gXG4gICAgbG9nLmVycm9yKGVycm9yKVxuICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGVycm9yKSwgeyBjb2RlOiBFUlJPUlMuRVJSX1VOUkVDT0dOSVpFRF9WQUxJRElUWSB9KVxuICB9XG59XG5cbi8vIFV0aWxpdHkgZm9yIGNyZWF0aW5nIHRoZSByZWNvcmQgZGF0YSBmb3IgYmVpbmcgc2lnbmVkXG5jb25zdCBpcG5zRW50cnlEYXRhRm9yU2lnID0gKHZhbHVlLCB2YWxpZGl0eVR5cGUsIHZhbGlkaXR5KSA9PiB7XG4gIGNvbnN0IHZhbHVlQnVmZmVyID0gQnVmZmVyLmZyb20odmFsdWUpXG4gIGNvbnN0IHZhbGlkaXR5VHlwZUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGdldFZhbGlkaXR5VHlwZSh2YWxpZGl0eVR5cGUpKVxuICBjb25zdCB2YWxpZGl0eUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHZhbGlkaXR5KVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFt2YWx1ZUJ1ZmZlciwgdmFsaWRpdHlCdWZmZXIsIHZhbGlkaXR5VHlwZUJ1ZmZlcl0pXG59XG5cbi8vIFV0aWxpdHkgZm9yIGV4dHJhY3RpbmcgdGhlIHB1YmxpYyBrZXkgZnJvbSBhIHBlZXItaWRcbmNvbnN0IGV4dHJhY3RQdWJsaWNLZXlGcm9tSWQgPSAocGVlcklkKSA9PiB7XG4gIGNvbnN0IGRlY29kZWRJZCA9IG11bHRpaGFzaC5kZWNvZGUocGVlcklkLmlkKVxuXG4gIGlmIChkZWNvZGVkSWQuY29kZSAhPT0gSURfTVVMVElIQVNIX0NPREUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIGNyeXB0by5rZXlzLnVubWFyc2hhbFB1YmxpY0tleShkZWNvZGVkSWQuZGlnZXN0KVxufVxuXG5jb25zdCBtYXJzaGFsID0gaXBuc0VudHJ5UHJvdG8uZW5jb2RlXG5cbmNvbnN0IHVubWFyc2hhbCA9IGlwbnNFbnRyeVByb3RvLmRlY29kZVxuXG5jb25zdCB2YWxpZGF0b3IgPSB7XG4gIHZhbGlkYXRlOiAobWFyc2hhbGxlZERhdGEsIGtleSwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCByZWNlaXZlZEVudHJ5ID0gdW5tYXJzaGFsKG1hcnNoYWxsZWREYXRhKVxuICAgIGNvbnN0IGJ1ZmZlcklkID0ga2V5LnNsaWNlKCcvaXBucy8nLmxlbmd0aClcbiAgICBsZXQgcGVlcklkXG5cbiAgICB0cnkge1xuICAgICAgcGVlcklkID0gUGVlcklkLmNyZWF0ZUZyb21CeXRlcyhidWZmZXJJZClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgLy8gZXh0cmFjdCBwdWJsaWMga2V5XG4gICAgZXh0cmFjdFB1YmxpY0tleShwZWVySWQsIHJlY2VpdmVkRW50cnksIChlcnIsIHB1YktleSkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICAvLyBSZWNvcmQgdmFsaWRhdGlvblxuICAgICAgdmFsaWRhdGUocHViS2V5LCByZWNlaXZlZEVudHJ5LCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcbiAgc2VsZWN0OiAoZGF0YUEsIGRhdGFCLCBjYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IGVudHJ5QSA9IHVubWFyc2hhbChkYXRhQSlcbiAgICBjb25zdCBlbnRyeUIgPSB1bm1hcnNoYWwoZGF0YUIpXG5cbiAgICBjb25zdCBpbmRleCA9IGVudHJ5QS5zZXF1ZW5jZSA+IGVudHJ5Qi5zZXF1ZW5jZSA/IDAgOiAxXG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaW5kZXhcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBpbmRleClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gY3JlYXRlIGlwbnMgZW50cnkgcmVjb3JkXG4gIGNyZWF0ZSxcbiAgLy8gY3JlYXRlIGlwbnMgZW50cnkgcmVjb3JkIHNwZWNpZnlpbmcgdGhlIGV4cGlyYXRpb24gdGltZVxuICBjcmVhdGVXaXRoRXhwaXJhdGlvbixcbiAgLy8gdmFsaWRhdGUgaXBucyBlbnRyeSByZWNvcmRcbiAgdmFsaWRhdGUsXG4gIC8vIGVtYmVkIHB1YmxpYyBrZXkgaW4gdGhlIHJlY29yZFxuICBlbWJlZFB1YmxpY0tleSxcbiAgLy8gZXh0cmFjdCBwdWJsaWMga2V5IGZyb20gdGhlIHJlY29yZFxuICBleHRyYWN0UHVibGljS2V5LFxuICAvLyBnZXQga2V5IGZvciBzdG9yaW5nIHRoZSBlbnRyeSBsb2NhbGx5XG4gIGdldExvY2FsS2V5LFxuICAvLyBnZXQga2V5cyBmb3Igcm91dGluZ1xuICBnZXRJZEtleXMsXG4gIC8vIG1hcnNoYWxcbiAgbWFyc2hhbCxcbiAgLy8gdW5tYXJzaGFsXG4gIHVubWFyc2hhbCxcbiAgLy8gdmFsaWRhdG9yXG4gIHZhbGlkYXRvcixcbiAgLy8gbmFtZXNwYWNlXG4gIG5hbWVzcGFjZSxcbiAgbmFtZXNwYWNlTGVuZ3RoOiBuYW1lc3BhY2UubGVuZ3RoXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgUGVlcklkID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCBQZWVySW5mbyA9IHJlcXVpcmUoJ3BlZXItaW5mbycpXG5jb25zdCBtdWx0aWFkZHIgPSByZXF1aXJlKCdtdWx0aWFkZHInKVxuY29uc3QgbWFmbXQgPSByZXF1aXJlKCdtYWZtdCcpXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbmV4dFRpY2sgPSByZXF1aXJlKCdhc3luYy9uZXh0VGljaycpXG5cbmNvbnN0IGxvZyA9IGRlYnVnKCdsaWJwMnA6Ym9vdHN0cmFwJylcbmxvZy5lcnJvciA9IGRlYnVnKCdsaWJwMnA6Ym9vdHN0cmFwOmVycm9yJylcblxuZnVuY3Rpb24gaXNJUEZTIChhZGRyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG1hZm10LklQRlMubWF0Y2hlcyhhZGRyKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuY2xhc3MgQm9vdHN0cmFwIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fbGlzdCA9IG9wdGlvbnMubGlzdFxuICAgIHRoaXMuX2ludGVydmFsID0gb3B0aW9ucy5pbnRlcnZhbCB8fCAxMDAwMFxuICAgIHRoaXMuX3RpbWVyID0gbnVsbFxuICB9XG5cbiAgc3RhcnQgKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgICByZXR1cm4gbmV4dFRpY2soKCkgPT4gY2FsbGJhY2soKSlcbiAgICB9XG5cbiAgICB0aGlzLl90aW1lciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX2Rpc2NvdmVyQm9vdHN0cmFwUGVlcnMoKSwgdGhpcy5faW50ZXJ2YWwpXG5cbiAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICB0aGlzLl9kaXNjb3ZlckJvb3RzdHJhcFBlZXJzKClcbiAgICB9KVxuICB9XG5cbiAgX2Rpc2NvdmVyQm9vdHN0cmFwUGVlcnMgKCkge1xuICAgIHRoaXMuX2xpc3QuZm9yRWFjaCgoY2FuZGlkYXRlKSA9PiB7XG4gICAgICBpZiAoIWlzSVBGUyhjYW5kaWRhdGUpKSB7IHJldHVybiBsb2cuZXJyb3IoJ0ludmFsaWQgbXVsdGlhZGRyJykgfVxuXG4gICAgICBjb25zdCBtYSA9IG11bHRpYWRkcihjYW5kaWRhdGUpXG5cbiAgICAgIGNvbnN0IHBlZXJJZCA9IFBlZXJJZC5jcmVhdGVGcm9tQjU4U3RyaW5nKG1hLmdldFBlZXJJZCgpKVxuXG4gICAgICBQZWVySW5mby5jcmVhdGUocGVlcklkLCAoZXJyLCBwZWVySW5mbykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBsb2cuZXJyb3IoJ0ludmFsaWQgYm9vdHN0cmFwIHBlZXIgaWQnLCBlcnIpIH1cbiAgICAgICAgcGVlckluZm8ubXVsdGlhZGRycy5hZGQobWEpXG4gICAgICAgIHRoaXMuZW1pdCgncGVlcicsIHBlZXJJbmZvKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgc3RvcCAoY2FsbGJhY2spIHtcbiAgICBuZXh0VGljayhjYWxsYmFjaylcblxuICAgIGlmICh0aGlzLl90aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl90aW1lcilcbiAgICAgIHRoaXMuX3RpbWVyID0gbnVsbFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBCb290c3RyYXBcbmV4cG9ydHMudGFnID0gJ2Jvb3RzdHJhcCdcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhYm9ydGFibGUgPSByZXF1aXJlKCdwdWxsLWFib3J0YWJsZScpXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0nKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5cbmNvbnN0IE1VTFRJUExFWF9DT0RFQyA9IHJlcXVpcmUoJy4vY29kZWMnKVxuY29uc3QgTXBsZXggPSByZXF1aXJlKCcuL21wbGV4JylcbmNvbnN0IE11eGVyID0gcmVxdWlyZSgnLi9tdXhlcicpXG5cbmNvbnN0IGxvZyA9IGRlYnVnKCdwdWxsLXBsZXgnKVxubG9nLmVyciA9IGRlYnVnKCdwdWxsLXBsZXg6ZXJyJylcblxuLyoqXG4gKiBXcmFwcyBgY29ubmAgd2l0aCBhIGBTdHJlYW1NdXhlcmAgYW5kIHJldHVybnMgdGhlIGBTdHJlYW1NdXhlcmBcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiBBbiBgaW50ZXJmYWNlLWNvbm5lY3Rpb25gIGNvbXBsaWFudCBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzTGlzdGVuZXIgV2hldGhlciBvciBub3QgdGhlIG11eGVyIGlzIHRoZSBsaXN0ZW5lclxuICogQHJldHVybnMge1N0cmVhbU11eGVyfVxuICovXG5mdW5jdGlvbiBjcmVhdGUgKGNvbm4sIGlzTGlzdGVuZXIpIHtcbiAgY29uc3QgbXB4ID0gbmV3IE1wbGV4KCFpc0xpc3RlbmVyKVxuICBjb25zdCBhYm9ydGVyID0gYWJvcnRhYmxlKClcblxuICBwdWxsKFxuICAgIGNvbm4sXG4gICAgbXB4LFxuICAgIGFib3J0ZXIsXG4gICAgY29ublxuICApXG5cbiAgY29uc3QgbXV4ZXIgPSBuZXcgTXV4ZXIoY29ubiwgbXB4KVxuICBtdXhlci5vbmNlKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBsb2cuZXJyKCdnb3QgZXJyb3InLCBlcnIpXG4gICAgYWJvcnRlci5hYm9ydChlcnIpIC8vIFRPRE86IHNob3VsZCB3ZSBkbyB0aGUgYWJvcnQgaGVyZSBvciBqdXN0IGlnbm9yZT9cbiAgfSlcblxuICBtdXhlci5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgbG9nKCdjbG9zaW5nIG11eGVyJylcbiAgICBhYm9ydGVyLmFib3J0KClcbiAgfSlcblxuICByZXR1cm4gbXV4ZXJcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlXG5leHBvcnRzLnB1bGxNcGxleCA9IE1wbGV4XG5leHBvcnRzLm11bHRpY29kZWMgPSBNVUxUSVBMRVhfQ09ERUNcbmV4cG9ydHMuZGlhbGVyID0gKGNvbm4pID0+IGNyZWF0ZShjb25uLCBmYWxzZSlcbmV4cG9ydHMubGlzdGVuZXIgPSAoY29ubikgPT4gY3JlYXRlKGNvbm4sIHRydWUpXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgY29ubmVjdCA9IHJlcXVpcmUoJ3B1bGwtd3MvY2xpZW50JylcbmNvbnN0IG1hZm10ID0gcmVxdWlyZSgnbWFmbXQnKVxuY29uc3Qgd2l0aElzID0gcmVxdWlyZSgnY2xhc3MtaXMnKVxuY29uc3QgQ29ubmVjdGlvbiA9IHJlcXVpcmUoJ2ludGVyZmFjZS1jb25uZWN0aW9uJykuQ29ubmVjdGlvblxuXG5jb25zdCB0b1VyaSA9IHJlcXVpcmUoJ211bHRpYWRkci10by11cmknKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBsb2cgPSBkZWJ1ZygnbGlicDJwOndlYnNvY2tldHM6ZGlhbGVyJylcblxuY29uc3QgY3JlYXRlTGlzdGVuZXIgPSByZXF1aXJlKCcuL2xpc3RlbmVyJylcblxuY2xhc3MgV2ViU29ja2V0cyB7XG4gIGRpYWwgKG1hLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHsgfVxuXG4gICAgY29uc3QgdXJsID0gdG9VcmkobWEpXG4gICAgbG9nKCdkaWFsaW5nICVzJywgdXJsKVxuICAgIGNvbnN0IHNvY2tldCA9IGNvbm5lY3QodXJsLCB7XG4gICAgICBiaW5hcnk6IHRydWUsXG4gICAgICBvbkNvbm5lY3Q6IChlcnIpID0+IHtcbiAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBjb25uID0gbmV3IENvbm5lY3Rpb24oc29ja2V0KVxuICAgIGNvbm4uZ2V0T2JzZXJ2ZWRBZGRycyA9IChjYikgPT4gY2IobnVsbCwgW21hXSlcbiAgICBjb25uLmNsb3NlID0gKGNiKSA9PiBzb2NrZXQuY2xvc2UoY2IpXG5cbiAgICByZXR1cm4gY29ublxuICB9XG5cbiAgY3JlYXRlTGlzdGVuZXIgKG9wdGlvbnMsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGhhbmRsZXIgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlTGlzdGVuZXIob3B0aW9ucywgaGFuZGxlcilcbiAgfVxuXG4gIGZpbHRlciAobXVsdGlhZGRycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShtdWx0aWFkZHJzKSkge1xuICAgICAgbXVsdGlhZGRycyA9IFttdWx0aWFkZHJzXVxuICAgIH1cblxuICAgIHJldHVybiBtdWx0aWFkZHJzLmZpbHRlcigobWEpID0+IHtcbiAgICAgIGlmIChtYS5wcm90b05hbWVzKCkuaW5jbHVkZXMoJ3AycC1jaXJjdWl0JykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChtYS5wcm90b05hbWVzKCkuaW5jbHVkZXMoJ2lwZnMnKSkge1xuICAgICAgICBtYSA9IG1hLmRlY2Fwc3VsYXRlKCdpcGZzJylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hZm10LldlYlNvY2tldHMubWF0Y2hlcyhtYSkgfHxcbiAgICAgICAgbWFmbXQuV2ViU29ja2V0c1NlY3VyZS5tYXRjaGVzKG1hKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aXRoSXMoV2ViU29ja2V0cywgeyBjbGFzc05hbWU6ICdXZWJTb2NrZXRzJywgc3ltYm9sTmFtZTogJ0BsaWJwMnAvanMtbGlicDJwLXdlYnNvY2tldHMvd2Vic29ja2V0cycgfSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IGxpYnAycFJlY29yZCA9IHJlcXVpcmUoJ2xpYnAycC1yZWNvcmQnKVxuY29uc3QgTWVtb3J5U3RvcmUgPSByZXF1aXJlKCdpbnRlcmZhY2UtZGF0YXN0b3JlJykuTWVtb3J5RGF0YXN0b3JlXG5jb25zdCB3YXRlcmZhbGwgPSByZXF1aXJlKCdhc3luYy93YXRlcmZhbGwnKVxuY29uc3QgZWFjaCA9IHJlcXVpcmUoJ2FzeW5jL2VhY2gnKVxuY29uc3QgZmlsdGVyID0gcmVxdWlyZSgnYXN5bmMvZmlsdGVyJylcbmNvbnN0IHRpbWVvdXQgPSByZXF1aXJlKCdhc3luYy90aW1lb3V0JylcbmNvbnN0IFBlZXJJZCA9IHJlcXVpcmUoJ3BlZXItaWQnKVxuY29uc3QgUGVlckluZm8gPSByZXF1aXJlKCdwZWVyLWluZm8nKVxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnbGlicDJwLWNyeXB0bycpXG5jb25zdCBwcm9taXNlVG9DYWxsYmFjayA9IHJlcXVpcmUoJ3Byb21pc2UtdG8tY2FsbGJhY2snKVxuXG5jb25zdCBlcnJjb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG5jb25zdCBSb3V0aW5nVGFibGUgPSByZXF1aXJlKCcuL3JvdXRpbmcnKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IGMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKVxuY29uc3QgTmV0d29yayA9IHJlcXVpcmUoJy4vbmV0d29yaycpXG5jb25zdCBwcml2YXRlQXBpID0gcmVxdWlyZSgnLi9wcml2YXRlJylcbmNvbnN0IFByb3ZpZGVycyA9IHJlcXVpcmUoJy4vcHJvdmlkZXJzJylcbmNvbnN0IE1lc3NhZ2UgPSByZXF1aXJlKCcuL21lc3NhZ2UnKVxuY29uc3QgUmFuZG9tV2FsayA9IHJlcXVpcmUoJy4vcmFuZG9tLXdhbGsnKVxuY29uc3QgUXVlcnlNYW5hZ2VyID0gcmVxdWlyZSgnLi9xdWVyeS1tYW5hZ2VyJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbi8qKlxuICogQSBESFQgaW1wbGVtZW50YXRpb24gbW9kZWxlZCBhZnRlciBLYWRlbWxpYSB3aXRoIFMvS2FkZW1saWEgbW9kaWZpY2F0aW9ucy5cbiAqXG4gKiBPcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBpbiBnbzogaHR0cHM6Ly9naXRodWIuY29tL2xpYnAycC9nby1saWJwMnAta2FkLWRodC5cbiAqL1xuY2xhc3MgS2FkREhUIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIFJhbmRvbSB3YWxrIG9wdGlvbnNcbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gcmFuZG9tV2Fsa09wdGlvbnNcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBlbmFibGVkIGRpc2NvdmVyeSBlbmFibGVkIChkZWZhdWx0OiB0cnVlKVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gcXVlcmllc1BlclBlcmlvZCBob3cgbWFueSBxdWVyaWVzIHRvIHJ1biBwZXIgcGVyaW9kIChkZWZhdWx0OiAxKVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gaW50ZXJ2YWwgaG93IG9mdGVuIHRvIHJ1biB0aGUgdGhlIHJhbmRvbS13YWxrIHByb2Nlc3MsIGluIG1pbGxpc2Vjb25kcyAoZGVmYXVsdDogMzAwMDAwKVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZW91dCBob3cgbG9uZyB0byB3YWl0IGZvciB0aGUgdGhlIHJhbmRvbS13YWxrIHF1ZXJ5IHRvIHJ1biwgaW4gbWlsbGlzZWNvbmRzIChkZWZhdWx0OiAzMDAwMClcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRlbGF5IGhvdyBsb25nIHRvIHdhaXQgYmVmb3JlIHN0YXJ0aW5nIHRoZSBmaXJzdCByYW5kb20gd2FsaywgaW4gbWlsbGlzZWNvbmRzIChkZWZhdWx0OiAxMDAwMClcbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBLYWRESFQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3dpdGNofSBzdyBsaWJwMnAtc3dpdGNoIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIERIVCBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmtCdWNrZXRTaXplIGstYnVja2V0IHNpemUgKGRlZmF1bHQgMjApXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNvbmN1cnJlbmN5IGFscGhhIGNvbmN1cnJlbmN5IG9mIHF1ZXJpZXMgKGRlZmF1bHQgMylcbiAgICogQHBhcmFtIHtEYXRhc3RvcmV9IG9wdGlvbnMuZGF0YXN0b3JlIGRhdGFzdG9yZSAoZGVmYXVsdCBNZW1vcnlEYXRhc3RvcmUpXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnZhbGlkYXRvcnMgdmFsaWRhdG9ycyBvYmplY3Qgd2l0aCBuYW1lc3BhY2UgYXMga2V5cyBhbmQgZnVuY3Rpb24oa2V5LCByZWNvcmQsIGNhbGxiYWNrKVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5zZWxlY3RvcnMgc2VsZWN0b3JzIG9iamVjdCB3aXRoIG5hbWVzcGFjZSBhcyBrZXlzIGFuZCBmdW5jdGlvbihrZXksIHJlY29yZHMpXG4gICAqIEBwYXJhbSB7cmFuZG9tV2Fsa09wdGlvbnN9IG9wdGlvbnMucmFuZG9tV2FsayByYW5kb21XYWxrIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdywgb3B0aW9ucykge1xuICAgIHN1cGVyKClcbiAgICBhc3NlcnQoc3csICdsaWJwMnAta2FkLWRodCByZXF1aXJlcyBhIGluc3RhbmNlIG9mIFN3aXRjaCcpXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICBvcHRpb25zLnZhbGlkYXRvcnMgPSBvcHRpb25zLnZhbGlkYXRvcnMgfHwge31cbiAgICBvcHRpb25zLnNlbGVjdG9ycyA9IG9wdGlvbnMuc2VsZWN0b3JzIHx8IHt9XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbCByZWZlcmVuY2UgdG8gdGhlIGxpYnAycC1zd2l0Y2ggaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTd2l0Y2h9XG4gICAgICovXG4gICAgdGhpcy5zd2l0Y2ggPSBzd1xuXG4gICAgLyoqXG4gICAgICogay1idWNrZXQgc2l6ZSwgZGVmYXVsdHMgdG8gMjBcbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5rQnVja2V0U2l6ZSA9IG9wdGlvbnMua0J1Y2tldFNpemUgfHwgYy5LXG5cbiAgICAvKipcbiAgICAgKiBBTFBIQSBjb25jdXJyZW5jeSBhdCB3aGljaCBlYWNoIHF1ZXJ5IHBhdGggd2l0aCBydW4sIGRlZmF1bHRzIHRvIDNcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY29uY3VycmVuY3kgPSBvcHRpb25zLmNvbmN1cnJlbmN5IHx8IGMuQUxQSEFcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBkaXNqb2ludCBxdWVyeSBwYXRocyB0byB1c2VcbiAgICAgKiBUaGlzIGlzIHNldCB0byBga0J1Y2tldFNpemVgLzIgcGVyIHRoZSBTL0thZGVtbGlhIHBhcGVyXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRpc2pvaW50UGF0aHMgPSBNYXRoLmNlaWwodGhpcy5rQnVja2V0U2l6ZSAvIDIpXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm91dGluZyB0YWJsZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtSb3V0aW5nVGFibGV9XG4gICAgICovXG4gICAgdGhpcy5yb3V0aW5nVGFibGUgPSBuZXcgUm91dGluZ1RhYmxlKHRoaXMucGVlckluZm8uaWQsIHRoaXMua0J1Y2tldFNpemUpXG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGRhdGFzdG9yZSwgdXNlcyBhbiBpbi1tZW1vcnkgc3RvcmUgaWYgbm9uZSBnaXZlbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtEYXRhc3RvcmV9XG4gICAgICovXG4gICAgdGhpcy5kYXRhc3RvcmUgPSBvcHRpb25zLmRhdGFzdG9yZSB8fCBuZXcgTWVtb3J5U3RvcmUoKVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXIgbWFuYWdlbWVudFxuICAgICAqXG4gICAgICogQHR5cGUge1Byb3ZpZGVyc31cbiAgICAgKi9cbiAgICB0aGlzLnByb3ZpZGVycyA9IG5ldyBQcm92aWRlcnModGhpcy5kYXRhc3RvcmUsIHRoaXMucGVlckluZm8uaWQpXG5cbiAgICB0aGlzLnZhbGlkYXRvcnMgPSB7XG4gICAgICBwazogbGlicDJwUmVjb3JkLnZhbGlkYXRvci52YWxpZGF0b3JzLnBrLFxuICAgICAgLi4ub3B0aW9ucy52YWxpZGF0b3JzXG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RvcnMgPSB7XG4gICAgICBwazogbGlicDJwUmVjb3JkLnNlbGVjdGlvbi5zZWxlY3RvcnMucGssXG4gICAgICAuLi5vcHRpb25zLnNlbGVjdG9yc1xuICAgIH1cblxuICAgIHRoaXMubmV0d29yayA9IG5ldyBOZXR3b3JrKHRoaXMpXG5cbiAgICB0aGlzLl9sb2cgPSB1dGlscy5sb2dnZXIodGhpcy5wZWVySW5mby5pZClcblxuICAgIC8vIEluamVjdCBwcml2YXRlIGFwaXMgc28gd2UgZG9uJ3QgY2x1dHRlciB1cCB0aGlzIGZpbGVcbiAgICBjb25zdCBwYSA9IHByaXZhdGVBcGkodGhpcylcbiAgICBPYmplY3Qua2V5cyhwYSkuZm9yRWFjaCgobmFtZSkgPT4geyB0aGlzW25hbWVdID0gcGFbbmFtZV0gfSlcblxuICAgIC8qKlxuICAgICAqIFJhbmRvbSB3YWxrIG1hbmFnZW1lbnRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtSYW5kb21XYWxrfVxuICAgICAqL1xuICAgIHRoaXMucmFuZG9tV2FsayA9IG5ldyBSYW5kb21XYWxrKHRoaXMsIG9wdGlvbnMucmFuZG9tV2FsaylcblxuICAgIC8qKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHJ1bm5pbmcgcXVlcmllc1xuICAgICAqXG4gICAgICogQHR5cGUge1F1ZXJ5TWFuYWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9xdWVyeU1hbmFnZXIgPSBuZXcgUXVlcnlNYW5hZ2VyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGlzIERIVCBydW5uaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbH1cbiAgICovXG4gIGdldCBpc1N0YXJ0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9ydW5uaW5nXG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgbGlzdGVuaW5nIHRvIGluY29taW5nIGNvbm5lY3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzdGFydCAoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZVxuICAgIHRoaXMuX3F1ZXJ5TWFuYWdlci5zdGFydCgpXG4gICAgdGhpcy5uZXR3b3JrLnN0YXJ0KChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgLy8gU3RhcnQgcmFuZG9tIHdhbGssIGl0IHdpbGwgbm90IHJ1biBpZiBpdCdzIGRpc2FibGVkXG4gICAgICB0aGlzLnJhbmRvbVdhbGsuc3RhcnQoKVxuICAgICAgY2FsbGJhY2soKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU3RvcCBhY2NlcHRpbmcgaW5jb21pbmcgY29ubmVjdGlvbnMgYW5kIHNlbmRpbmcgb3V0Z29pbmdcbiAgICogbWVzc2FnZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHN0b3AgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlXG4gICAgdGhpcy5yYW5kb21XYWxrLnN0b3AoKVxuICAgIHRoaXMucHJvdmlkZXJzLnN0b3AoKVxuICAgIHRoaXMuX3F1ZXJ5TWFuYWdlci5zdG9wKClcbiAgICB0aGlzLm5ldHdvcmsuc3RvcChjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NhbCBwZWVyICh5b3Vyc2VsZilcbiAgICpcbiAgICogQHR5cGUge1BlZXJJbmZvfVxuICAgKi9cbiAgZ2V0IHBlZXJJbmZvICgpIHtcbiAgICByZXR1cm4gdGhpcy5zd2l0Y2guX3BlZXJJbmZvXG4gIH1cblxuICBnZXQgcGVlckJvb2sgKCkge1xuICAgIHJldHVybiB0aGlzLnN3aXRjaC5fcGVlckJvb2tcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZSB0aGUgZ2l2ZW4ga2V5L3ZhbHVlICBwYWlyIGluIHRoZSBESFQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBrZXlcbiAgICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gZ2V0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWluUGVlcnMgLSBtaW5pbXVtIHBlZXJzIHRoYXQgbXVzdCBiZSBwdXQgdG8gdG8gY29uc2lkZXIgdGhpcyBhIHN1Y2Nlc3NmdWwgb3BlcmF0aW9uXG4gICAqIChkZWZhdWx0OiBjbG9zZXN0UGVlcnMubGVuZ3RoKVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBwdXQgKGtleSwgdmFsdWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIH1cblxuICAgIHRoaXMuX2xvZygnUHV0VmFsdWUgJWInLCBrZXkpXG5cbiAgICB3YXRlcmZhbGwoW1xuICAgICAgKGNiKSA9PiB1dGlscy5jcmVhdGVQdXRSZWNvcmQoa2V5LCB2YWx1ZSwgY2IpLFxuICAgICAgKHJlYywgY2IpID0+IHdhdGVyZmFsbChbXG4gICAgICAgIChjYikgPT4gdGhpcy5fcHV0TG9jYWwoa2V5LCByZWMsIGNiKSxcbiAgICAgICAgKGNiKSA9PiB0aGlzLmdldENsb3Nlc3RQZWVycyhrZXksIHsgc2hhbGxvdzogdHJ1ZSB9LCBjYiksXG4gICAgICAgIChwZWVycywgY2IpID0+IHtcbiAgICAgICAgICAvLyBFbnN1cmUgd2UgaGF2ZSBhIGRlZmF1bHQgYG1pblBlZXJzYFxuICAgICAgICAgIG9wdGlvbnMubWluUGVlcnMgPSBvcHRpb25zLm1pblBlZXJzIHx8IHBlZXJzLmxlbmd0aFxuICAgICAgICAgIC8vIGZpbHRlciBvdXQgdGhlIHN1Y2Nlc3NmdWwgcHV0c1xuICAgICAgICAgIGZpbHRlcihwZWVycywgKHBlZXIsIGNiKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wdXRWYWx1ZVRvUGVlcihrZXksIHJlYywgcGVlciwgKGVycikgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKCdGYWlsZWQgdG8gcHV0IHRvIHBlZXIgKCViKTogJXMnLCBwZWVyLmlkLCBlcnIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIGZhbHNlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNiKG51bGwsIHRydWUpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sIChlcnIsIHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICAgICAgICAgIC8vIERpZCB3ZSBwdXQgdG8gZW5vdWdoIHBlZXJzP1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWluUGVlcnMgPiByZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGVycmNvZGUobmV3IEVycm9yKCdGYWlsZWQgdG8gcHV0IHZhbHVlIHRvIGVub3VnaCBwZWVycycpLCAnRVJSX05PVF9FTk9VR0hfUFVUX1BFRVJTJylcbiAgICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKGVycm9yKVxuICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyb3IpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNiKClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICBdLCBjYilcbiAgICBdLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIHRvIHRoZSBnaXZlbiBrZXkuXG4gICAqIFRpbWVzIG91dCBhZnRlciAxIG1pbnV0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGtleVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGdldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbWVvdXQgLSBvcHRpb25hbCB0aW1lb3V0IChkZWZhdWx0OiA2MDAwMClcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQnVmZmVyKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBnZXQgKGtleSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm1heFRpbWVvdXQgJiYgIW9wdGlvbnMudGltZW91dCkge1xuICAgICAgb3B0aW9ucy50aW1lb3V0ID0gYy5taW51dGUgLy8gZGVmYXVsdFxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5tYXhUaW1lb3V0ICYmICFvcHRpb25zLnRpbWVvdXQpIHsgLy8gVE9ETyB0aGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiBhIG5leHQgcmVsZWFzZVxuICAgICAgb3B0aW9ucy50aW1lb3V0ID0gb3B0aW9ucy5tYXhUaW1lb3V0XG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0KGtleSwgb3B0aW9ucywgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBgbmAgdmFsdWVzIHRvIHRoZSBnaXZlbiBrZXkgd2l0aG91dCBzb3J0aW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0ga2V5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudmFsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGdldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbWVvdXQgLSBvcHRpb25hbCB0aW1lb3V0IChkZWZhdWx0OiA2MDAwMClcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQXJyYXk8e2Zyb206IFBlZXJJZCwgdmFsOiBCdWZmZXJ9Pil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZ2V0TWFueSAoa2V5LCBudmFscywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm1heFRpbWVvdXQgJiYgIW9wdGlvbnMudGltZW91dCkge1xuICAgICAgb3B0aW9ucy50aW1lb3V0ID0gYy5taW51dGUgLy8gZGVmYXVsdFxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5tYXhUaW1lb3V0ICYmICFvcHRpb25zLnRpbWVvdXQpIHsgLy8gVE9ETyB0aGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiBhIG5leHQgcmVsZWFzZVxuICAgICAgb3B0aW9ucy50aW1lb3V0ID0gb3B0aW9ucy5tYXhUaW1lb3V0XG4gICAgfVxuXG4gICAgdGhpcy5fbG9nKCdnZXRNYW55ICViICglcyknLCBrZXksIG52YWxzKVxuICAgIGxldCB2YWxzID0gW11cblxuICAgIHRoaXMuX2dldExvY2FsKGtleSwgKGVyciwgbG9jYWxSZWMpID0+IHtcbiAgICAgIGlmIChlcnIgJiYgbnZhbHMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgaWYgKGVyciA9PSBudWxsKSB7XG4gICAgICAgIHZhbHMucHVzaCh7XG4gICAgICAgICAgdmFsOiBsb2NhbFJlYy52YWx1ZSxcbiAgICAgICAgICBmcm9tOiB0aGlzLnBlZXJJbmZvLmlkXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmICh2YWxzLmxlbmd0aCA+PSBudmFscykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdmFscylcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGF0aHMgPSBbXVxuICAgICAgd2F0ZXJmYWxsKFtcbiAgICAgICAgKGNiKSA9PiB1dGlscy5jb252ZXJ0QnVmZmVyKGtleSwgY2IpLFxuICAgICAgICAoaWQsIGNiKSA9PiB7XG4gICAgICAgICAgY29uc3QgcnRwID0gdGhpcy5yb3V0aW5nVGFibGUuY2xvc2VzdFBlZXJzKGlkLCB0aGlzLmtCdWNrZXRTaXplKVxuXG4gICAgICAgICAgdGhpcy5fbG9nKCdwZWVycyBpbiBydDogJWQnLCBydHAubGVuZ3RoKVxuICAgICAgICAgIGlmIChydHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnRmFpbGVkIHRvIGxvb2t1cCBrZXkhIE5vIHBlZXJzIGZyb20gcm91dGluZyB0YWJsZSEnXG5cbiAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihlcnJNc2cpXG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9OT19QRUVSU19JTl9ST1VUSU5HX1RBQkxFJykpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gd2UgaGF2ZSBwZWVycywgbGV0cyBkbyB0aGUgYWN0dWFsIHF1ZXJ5IHRvIHRoZW1cbiAgICAgICAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeSh0aGlzLCBrZXksIChwYXRoSW5kZXgsIG51bVBhdGhzKSA9PiB7XG4gICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGJvZHkgcnVucyBvbmNlIHBlciBkaXNqb2ludCBwYXRoXG4gICAgICAgICAgICBjb25zdCBwYXRoU2l6ZSA9IHV0aWxzLnBhdGhTaXplKG52YWxzIC0gdmFscy5sZW5ndGgsIG51bVBhdGhzKVxuICAgICAgICAgICAgY29uc3QgcGF0aFZhbHMgPSBbXVxuICAgICAgICAgICAgcGF0aHMucHVzaChwYXRoVmFscylcblxuICAgICAgICAgICAgLy8gSGVyZSB3ZSByZXR1cm4gdGhlIHF1ZXJ5IGZ1bmN0aW9uIHRvIHVzZSBvbiB0aGlzIHBhcnRpY3VsYXIgZGlzam9pbnQgcGF0aFxuICAgICAgICAgICAgcmV0dXJuIGFzeW5jIChwZWVyKSA9PiB7XG4gICAgICAgICAgICAgIGxldCByZWMsIHBlZXJzLCBsb29rdXBFcnJcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5fZ2V0VmFsdWVPclBlZXJzQXN5bmMocGVlciwga2V5KVxuICAgICAgICAgICAgICAgIHJlYyA9IHJlc3VsdHMucmVjb3JkXG4gICAgICAgICAgICAgICAgcGVlcnMgPSByZXN1bHRzLnBlZXJzXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gaW52YWxpZCByZWNvcmQgd2UganVzdCB3YW50IHRvIGNvbnRpbnVlIGFuZCBmZXRjaCBhIG5ldyBvbmUuXG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlICE9PSAnRVJSX0lOVkFMSURfUkVDT1JEJykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvb2t1cEVyciA9IGVyclxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgcmVzID0geyBjbG9zZXJQZWVyczogcGVlcnMgfVxuXG4gICAgICAgICAgICAgIGlmICgocmVjICYmIHJlYy52YWx1ZSkgfHwgbG9va3VwRXJyKSB7XG4gICAgICAgICAgICAgICAgcGF0aFZhbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICB2YWw6IHJlYyAmJiByZWMudmFsdWUsXG4gICAgICAgICAgICAgICAgICBmcm9tOiBwZWVyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGVub3VnaCBpcyBlbm91Z2hcbiAgICAgICAgICAgICAgaWYgKHBhdGhWYWxzLmxlbmd0aCA+PSBwYXRoU2l6ZSkge1xuICAgICAgICAgICAgICAgIHJlcy5wYXRoQ29tcGxldGUgPSB0cnVlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIC8vIHJ1biBvdXIgcXVlcnlcbiAgICAgICAgICB0aW1lb3V0KChfY2IpID0+IHtcbiAgICAgICAgICAgIHByb21pc2VUb0NhbGxiYWNrKHF1ZXJ5LnJ1bihydHApKShfY2IpXG4gICAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KSgoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgIHF1ZXJ5LnN0b3AoKVxuICAgICAgICAgICAgY2IoZXJyLCByZXMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgXSwgKGVycikgPT4ge1xuICAgICAgICAvLyBjb21iaW5lIHZhbHMgZnJvbSBlYWNoIHBhdGhcbiAgICAgICAgdmFscyA9IFtdLmNvbmNhdC5hcHBseSh2YWxzLCBwYXRocykuc2xpY2UoMCwgbnZhbHMpXG5cbiAgICAgICAgaWYgKGVyciAmJiB2YWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCB2YWxzKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEthZGVtbGlhICdub2RlIGxvb2t1cCcgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0ga2V5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zaGFsbG93IHNoYWxsb3cgcXVlcnlcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQXJyYXk8UGVlcklkPil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZ2V0Q2xvc2VzdFBlZXJzIChrZXksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fbG9nKCdnZXRDbG9zZXN0UGVlcnMgdG8gJWInLCBrZXkpXG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlscy5jb252ZXJ0QnVmZmVyKGtleSwgKGVyciwgaWQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFibGVQZWVycyA9IHRoaXMucm91dGluZ1RhYmxlLmNsb3Nlc3RQZWVycyhpZCwgdGhpcy5rQnVja2V0U2l6ZSlcblxuICAgICAgY29uc3QgcSA9IG5ldyBRdWVyeSh0aGlzLCBrZXksICgpID0+IHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gZGlzdGluY3Rpb24gYmV0d2VlbiB0aGUgZGlzam9pbnQgcGF0aHMsXG4gICAgICAgIC8vIHNvIHRoZXJlIGFyZSBubyBwZXItcGF0aCB2YXJpYWJsZXMgaW4gdGhpcyBzY29wZS5cbiAgICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIGFjdHVhbCBxdWVyeSBmdW5jdGlvbi5cbiAgICAgICAgcmV0dXJuIGFzeW5jIChwZWVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2xvc2VyID0gYXdhaXQgdGhpcy5fY2xvc2VyUGVlcnNTaW5nbGVBc3luYyhrZXksIHBlZXIpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsb3NlclBlZXJzOiBjbG9zZXIsXG4gICAgICAgICAgICBwYXRoQ29tcGxldGU6IG9wdGlvbnMuc2hhbGxvdyA/IHRydWUgOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHByb21pc2VUb0NhbGxiYWNrKHEucnVuKHRhYmxlUGVlcnMpKSgoZXJyLCByZXMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlcyB8fCAhcmVzLmZpbmFsU2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFtdKVxuICAgICAgICB9XG5cbiAgICAgICAgd2F0ZXJmYWxsKFtcbiAgICAgICAgICAoY2IpID0+IHV0aWxzLnNvcnRDbG9zZXN0UGVlcnMoQXJyYXkuZnJvbShyZXMuZmluYWxTZXQpLCBpZCwgY2IpLFxuICAgICAgICAgIChzb3J0ZWQsIGNiKSA9PiBjYihudWxsLCBzb3J0ZWQuc2xpY2UoMCwgdGhpcy5rQnVja2V0U2l6ZSkpXG4gICAgICAgIF0sIGNhbGxiYWNrKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljIGtleSBmb3IgdGhlIGdpdmVuIHBlZXIgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlcklkfSBwZWVyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIFB1YktleSl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZ2V0UHVibGljS2V5IChwZWVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2xvZygnZ2V0UHVibGljS2V5ICVzJywgcGVlci50b0I1OFN0cmluZygpKVxuICAgIC8vIGxvY2FsIGNoZWNrXG4gICAgbGV0IGluZm9cbiAgICBpZiAodGhpcy5wZWVyQm9vay5oYXMocGVlcikpIHtcbiAgICAgIGluZm8gPSB0aGlzLnBlZXJCb29rLmdldChwZWVyKVxuXG4gICAgICBpZiAoaW5mbyAmJiBpbmZvLmlkLnB1YktleSkge1xuICAgICAgICB0aGlzLl9sb2coJ2dldFB1YmxpY0tleTogZm91bmQgbG9jYWwgY29weScpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBpbmZvLmlkLnB1YktleSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyA9IHRoaXMucGVlckJvb2sucHV0KG5ldyBQZWVySW5mbyhwZWVyKSlcbiAgICB9XG4gICAgLy8gdHJ5IHRoZSBub2RlIGRpcmVjdGx5XG4gICAgdGhpcy5fZ2V0UHVibGljS2V5RnJvbU5vZGUocGVlciwgKGVyciwgcGspID0+IHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIGluZm8uaWQgPSBuZXcgUGVlcklkKHBlZXIuaWQsIG51bGwsIHBrKVxuICAgICAgICB0aGlzLnBlZXJCb29rLnB1dChpbmZvKVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBwaylcbiAgICAgIH1cblxuICAgICAgLy8gZGh0IGRpcmVjdGx5XG4gICAgICBjb25zdCBwa0tleSA9IHV0aWxzLmtleUZvclB1YmxpY0tleShwZWVyKVxuICAgICAgdGhpcy5nZXQocGtLZXksIChlcnIsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGsgPSBjcnlwdG8udW5tYXJzaGFsUHVibGljS2V5KHZhbHVlKVxuICAgICAgICBpbmZvLmlkID0gbmV3IFBlZXJJZChwZWVyLCBudWxsLCBwaylcbiAgICAgICAgdGhpcy5wZWVyQm9vay5wdXQoaW5mbylcblxuICAgICAgICBjYWxsYmFjayhudWxsLCBwaylcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIGlmIHdlIGFyZSBjb25uZWN0ZWQgdG8gYSBwZWVyIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKiBSZXR1cm5zIHRoZSBgUGVlckluZm9gIGZvciBpdCwgaWYgZm91bmQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySWR9IHBlZXJcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgUGVlckluZm8pfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZpbmRQZWVyTG9jYWwgKHBlZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fbG9nKCdmaW5kUGVlckxvY2FsICVzJywgcGVlci50b0I1OFN0cmluZygpKVxuICAgIHRoaXMucm91dGluZ1RhYmxlLmZpbmQocGVlciwgKGVyciwgcCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgICAgaWYgKCFwIHx8ICF0aGlzLnBlZXJCb29rLmhhcyhwKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgdGhpcy5wZWVyQm9vay5nZXQocCkpXG4gICAgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tIENvbnRlbnQgUm91dGluZ1xuXG4gIC8qKlxuICAgKiBBbm5vdW5jZSB0byB0aGUgbmV0d29yayB0aGF0IHdlIGNhbiBwcm92aWRlIGdpdmVuIGtleSdzIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0NJRH0ga2V5XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHByb3ZpZGUgKGtleSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9sb2coJ3Byb3ZpZGU6ICVzJywga2V5LnRvQmFzZUVuY29kZWRTdHJpbmcoKSlcblxuICAgIGNvbnN0IGVycm9ycyA9IFtdXG4gICAgd2F0ZXJmYWxsKFtcbiAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRoaXMgaW4gbWV0aG9kIGluIGFzeW5jIGFuZCByZW1vdmUgdGhpcyB3cmFwcGVyXG4gICAgICAoY2IpID0+IHByb21pc2VUb0NhbGxiYWNrKHRoaXMucHJvdmlkZXJzLmFkZFByb3ZpZGVyKGtleSwgdGhpcy5wZWVySW5mby5pZCkpKGVyciA9PiBjYihlcnIpKSxcbiAgICAgIChjYikgPT4gdGhpcy5nZXRDbG9zZXN0UGVlcnMoa2V5LmJ1ZmZlciwgY2IpLFxuICAgICAgKHBlZXJzLCBjYikgPT4ge1xuICAgICAgICBjb25zdCBtc2cgPSBuZXcgTWVzc2FnZShNZXNzYWdlLlRZUEVTLkFERF9QUk9WSURFUiwga2V5LmJ1ZmZlciwgMClcbiAgICAgICAgbXNnLnByb3ZpZGVyUGVlcnMgPSBbdGhpcy5wZWVySW5mb11cblxuICAgICAgICBlYWNoKHBlZXJzLCAocGVlciwgY2IpID0+IHtcbiAgICAgICAgICB0aGlzLl9sb2coJ3B1dFByb3ZpZGVyICVzIHRvICVzJywga2V5LnRvQmFzZUVuY29kZWRTdHJpbmcoKSwgcGVlci50b0I1OFN0cmluZygpKVxuICAgICAgICAgIHRoaXMubmV0d29yay5zZW5kTWVzc2FnZShwZWVyLCBtc2csIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIGVycm9ycy5wdXNoKGVycilcbiAgICAgICAgICAgIGNiKClcbiAgICAgICAgICB9KVxuICAgICAgICB9LCBjYilcbiAgICAgIH1cbiAgICBdLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBpbmZyZXF1ZW50LiBUaGlzIG1lYW5zIGEgcGVlciB3ZSBwcmV2aW91c2x5IGNvbm5lY3RlZFxuICAgICAgICAvLyB0byBmYWlsZWQgdG8gZXhjaGFuZ2UgdGhlIHByb3ZpZGUgbWVzc2FnZS4gSWYgZ2V0Q2xvc2VzdFBlZXJzIHdhcyBhblxuICAgICAgICAvLyBpdGVyYXRvciwgd2UgY291bGQgY29udGludWUgdG8gcHVsbCB1bnRpbCB3ZSBhbm5vdW5jZSB0byBrQnVja2V0U2l6ZSBwZWVycy5cbiAgICAgICAgZXJyID0gZXJyY29kZShgRmFpbGVkIHRvIHByb3ZpZGUgdG8gJHtlcnJvcnMubGVuZ3RofSBvZiAke3RoaXMua0J1Y2tldFNpemV9IHBlZXJzYCwgJ0VSUl9TT01FX1BST1ZJREVTX0ZBSUxFRCcsIHsgZXJyb3JzIH0pXG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggdGhlIGRodCBmb3IgdXAgdG8gYEtgIHByb3ZpZGVycyBvZiB0aGUgZ2l2ZW4gQ0lELlxuICAgKlxuICAgKiBAcGFyYW0ge0NJRH0ga2V5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gZmluZFByb3ZpZGVycyBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbWVvdXQgLSBob3cgbG9uZyB0aGUgcXVlcnkgc2hvdWxkIG1heGltYWxseSBydW4sIGluIG1pbGxpc2Vjb25kcyAoZGVmYXVsdDogNjAwMDApXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heE51bVByb3ZpZGVycyAtIG1heGltdW0gbnVtYmVyIG9mIHByb3ZpZGVycyB0byBmaW5kXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEFycmF5PFBlZXJJbmZvPil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZmluZFByb3ZpZGVycyAoa2V5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMubWF4VGltZW91dCAmJiAhb3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICBvcHRpb25zLnRpbWVvdXQgPSBjLm1pbnV0ZSAvLyBkZWZhdWx0XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm1heFRpbWVvdXQgJiYgIW9wdGlvbnMudGltZW91dCkgeyAvLyBUT0RPIHRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGluIGEgbmV4dCByZWxlYXNlXG4gICAgICBvcHRpb25zLnRpbWVvdXQgPSBvcHRpb25zLm1heFRpbWVvdXRcbiAgICB9XG5cbiAgICBvcHRpb25zLm1heE51bVByb3ZpZGVycyA9IG9wdGlvbnMubWF4TnVtUHJvdmlkZXJzIHx8IGMuS1xuXG4gICAgdGhpcy5fbG9nKCdmaW5kUHJvdmlkZXJzICVzJywga2V5LnRvQmFzZUVuY29kZWRTdHJpbmcoKSlcbiAgICB0aGlzLl9maW5kTlByb3ZpZGVycyhrZXksIG9wdGlvbnMudGltZW91dCwgb3B0aW9ucy5tYXhOdW1Qcm92aWRlcnMsIGNhbGxiYWNrKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0gUGVlciBSb3V0aW5nXG5cbiAgLyoqXG4gICAqIFNlYXJjaCBmb3IgYSBwZWVyIHdpdGggdGhlIGdpdmVuIElELlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJZH0gaWRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBmaW5kUGVlciBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbWVvdXQgLSBob3cgbG9uZyB0aGUgcXVlcnkgc2hvdWxkIG1heGltYWxseSBydW4sIGluIG1pbGxpc2Vjb25kcyAoZGVmYXVsdDogNjAwMDApXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIFBlZXJJbmZvKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmaW5kUGVlciAoaWQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tYXhUaW1lb3V0ICYmICFvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgIG9wdGlvbnMudGltZW91dCA9IGMubWludXRlIC8vIGRlZmF1bHRcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMubWF4VGltZW91dCAmJiAhb3B0aW9ucy50aW1lb3V0KSB7IC8vIFRPRE8gdGhpcyB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gYSBuZXh0IHJlbGVhc2VcbiAgICAgIG9wdGlvbnMudGltZW91dCA9IG9wdGlvbnMubWF4VGltZW91dFxuICAgIH1cblxuICAgIHRoaXMuX2xvZygnZmluZFBlZXIgJXMnLCBpZC50b0I1OFN0cmluZygpKVxuXG4gICAgdGhpcy5maW5kUGVlckxvY2FsKGlkLCAoZXJyLCBwaSkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICAvLyBhbHJlYWR5IGdvdCBpdFxuICAgICAgaWYgKHBpICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fbG9nKCdmb3VuZCBsb2NhbCcpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBwaSlcbiAgICAgIH1cblxuICAgICAgd2F0ZXJmYWxsKFtcbiAgICAgICAgKGNiKSA9PiB1dGlscy5jb252ZXJ0UGVlcklkKGlkLCBjYiksXG4gICAgICAgIChrZXksIGNiKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGVlcnMgPSB0aGlzLnJvdXRpbmdUYWJsZS5jbG9zZXN0UGVlcnMoa2V5LCB0aGlzLmtCdWNrZXRTaXplKVxuXG4gICAgICAgICAgaWYgKHBlZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycmNvZGUobmV3IEVycm9yKCdQZWVyIGxvb2t1cCBmYWlsZWQnKSwgJ0VSUl9MT09LVVBfRkFJTEVEJykpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc2FuaXR5IGNoZWNrXG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBwZWVycy5maW5kKChwKSA9PiBwLmlzRXF1YWwoaWQpKVxuICAgICAgICAgIGlmIChtYXRjaCAmJiB0aGlzLnBlZXJCb29rLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnZm91bmQgaW4gcGVlcmJvb2snKVxuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHRoaXMucGVlckJvb2suZ2V0KGlkKSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBxdWVyeSB0aGUgbmV0d29ya1xuICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KHRoaXMsIGlkLmlkLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBkaXN0aW5jdGlvbiBiZXR3ZWVuIHRoZSBkaXNqb2ludCBwYXRocyxcbiAgICAgICAgICAgIC8vIHNvIHRoZXJlIGFyZSBubyBwZXItcGF0aCB2YXJpYWJsZXMgaW4gdGhpcyBzY29wZS5cbiAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSBhY3R1YWwgcXVlcnkgZnVuY3Rpb24uXG4gICAgICAgICAgICByZXR1cm4gYXN5bmMgKHBlZXIpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbXNnID0gYXdhaXQgdGhpcy5fZmluZFBlZXJTaW5nbGVBc3luYyhwZWVyLCBpZClcbiAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBtc2cuY2xvc2VyUGVlcnMuZmluZCgocCkgPT4gcC5pZC5pc0VxdWFsKGlkKSlcblxuICAgICAgICAgICAgICAvLyBmb3VuZCBpdFxuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgcGVlcjogbWF0Y2gsXG4gICAgICAgICAgICAgICAgICBxdWVyeUNvbXBsZXRlOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjbG9zZXJQZWVyczogbXNnLmNsb3NlclBlZXJzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgdGltZW91dCgoX2NiKSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlVG9DYWxsYmFjayhxdWVyeS5ydW4ocGVlcnMpKShfY2IpXG4gICAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KSgoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgIHF1ZXJ5LnN0b3AoKVxuICAgICAgICAgICAgY2IoZXJyLCByZXMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgKHJlc3VsdCwgY2IpID0+IHtcbiAgICAgICAgICBsZXQgc3VjY2VzcyA9IGZhbHNlXG4gICAgICAgICAgcmVzdWx0LnBhdGhzLmZvckVhY2goKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlXG4gICAgICAgICAgICAgIHRoaXMucGVlckJvb2sucHV0KHJlc3VsdC5wZWVyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy5fbG9nKCdmaW5kUGVlciAlczogJXMnLCBpZC50b0I1OFN0cmluZygpLCBzdWNjZXNzKVxuICAgICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycmNvZGUobmV3IEVycm9yKCdObyBwZWVyIGZvdW5kJyksICdFUlJfTk9UX0ZPVU5EJykpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNiKG51bGwsIHRoaXMucGVlckJvb2suZ2V0KGlkKSlcbiAgICAgICAgfVxuICAgICAgXSwgY2FsbGJhY2spXG4gICAgfSlcbiAgfVxuXG4gIF9wZWVyRGlzY292ZXJlZCAocGVlckluZm8pIHtcbiAgICB0aGlzLmVtaXQoJ3BlZXInLCBwZWVySW5mbylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEthZERIVFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9wdWxsJylcbmNvbnN0IENvbm5lY3Rpb24gPSByZXF1aXJlKCdpbnRlcmZhY2UtY29ubmVjdGlvbicpLkNvbm5lY3Rpb25cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBQZWVySW5mbyA9IHJlcXVpcmUoJ3BlZXItaW5mbycpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IG9uY2UgPSByZXF1aXJlKCdvbmNlJylcbmNvbnN0IGxvZyA9IGRlYnVnKCdsaWJwMnA6c2VjaW8nKVxubG9nLmVycm9yID0gZGVidWcoJ2xpYnAycDpzZWNpbzplcnJvcicpXG5cbmNvbnN0IGhhbmRzaGFrZSA9IHJlcXVpcmUoJy4vaGFuZHNoYWtlJylcbmNvbnN0IFN0YXRlID0gcmVxdWlyZSgnLi9zdGF0ZScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0YWc6ICcvc2VjaW8vMS4wLjAnLFxuICBlbmNyeXB0IChsb2NhbElkLCBjb25uLCByZW1vdGVJZCwgY2FsbGJhY2spIHtcbiAgICBhc3NlcnQobG9jYWxJZCwgJ25vIGxvY2FsIHByaXZhdGUga2V5IHByb3ZpZGVkJylcbiAgICBhc3NlcnQoY29ubiwgJ25vIGNvbm5lY3Rpb24gZm9yIHRoZSBoYW5kc2hha2UgIHByb3ZpZGVkJylcblxuICAgIGlmICh0eXBlb2YgcmVtb3RlSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gcmVtb3RlSWRcbiAgICAgIHJlbW90ZUlkID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHsgbG9nLmVycm9yKGVycikgfVxuICAgIH0pXG5cbiAgICBjb25zdCB0aW1lb3V0ID0gNjAgKiAxMDAwICogNVxuXG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgU3RhdGUobG9jYWxJZCwgcmVtb3RlSWQsIHRpbWVvdXQsIGNhbGxiYWNrKVxuXG4gICAgZnVuY3Rpb24gZmluaXNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycikgfVxuXG4gICAgICBjb25uLmdldFBlZXJJbmZvKChlcnIsIHBlZXJJbmZvKSA9PiB7XG4gICAgICAgIGVuY3J5cHRlZENvbm5lY3Rpb24uc2V0SW5uZXJDb25uKG5ldyBDb25uZWN0aW9uKHN0YXRlLnNlY3VyZSwgY29ubikpXG5cbiAgICAgICAgaWYgKGVycikgeyAvLyBubyBwZWVySW5mbyB5ZXQsIG1lYW5zIEknbSB0aGUgcmVjZWl2ZXJcbiAgICAgICAgICBlbmNyeXB0ZWRDb25uZWN0aW9uLnNldFBlZXJJbmZvKG5ldyBQZWVySW5mbyhzdGF0ZS5pZC5yZW1vdGUpKVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBlbmNyeXB0ZWRDb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24odW5kZWZpbmVkLCBjb25uKVxuXG4gICAgcHVsbChcbiAgICAgIGNvbm4sXG4gICAgICBoYW5kc2hha2Uoc3RhdGUsIGZpbmlzaCksXG4gICAgICBjb25uXG4gICAgKVxuXG4gICAgcmV0dXJuIGVuY3J5cHRlZENvbm5lY3Rpb25cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycDp3ZWJzb2NrZXQtc3RhcjptdWx0aScpXG5jb25zdCBvbmNlID0gcmVxdWlyZSgnb25jZScpXG5cbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBtYXAgPSByZXF1aXJlKCdhc3luYy9tYXAnKVxuY29uc3QgcGFyYWxsZWwgPSByZXF1aXJlKCdhc3luYy9wYXJhbGxlbCcpXG5jb25zdCBtdWx0aWFkZHIgPSByZXF1aXJlKCdtdWx0aWFkZHInKVxuY29uc3QgbWFmbXQgPSByZXF1aXJlKCdtYWZtdCcpXG5cbmNvbnN0IFdTU3RhciA9IHJlcXVpcmUoJ2xpYnAycC13ZWJzb2NrZXQtc3RhcicpXG5jbGFzcyBXZWJzb2NrZXRTdGFyTXVsdGkgeyAvLyBsaXN0ZW4gb24gbXVsdGlwbGUgd2Vic29ja2V0IHN0YXIgc2VydmVycyB3aXRob3V0IGhhdmluZyB0byB3b3JyeSBhYm91dCBvbmUgYmVpbmcgZG93bi5cbiAgLy8gTk9URTogaWYgbm8gc2VydmVycyBhcmUgcmVhY2hhYmxlIG9yIHByb3ZpZGVkIGFuIGVycm9yIGlzIHRocm93blxuICBjb25zdHJ1Y3RvciAob3B0KSB7XG4gICAgdGhpcy5vcHQgPSBvcHQgfHwge31cbiAgICB0aGlzLnNlcnZlcnMgPSBvcHQuc2VydmVycyB8fCBbXVxuICAgIHRoaXMud3MgPSBuZXcgV1NTdGFyKHRoaXMub3B0KVxuICAgIHRoaXMuZGlzY292ZXJ5ID0gdGhpcy53cy5kaXNjb3ZlcnlcbiAgfVxuICBkaWFsIChtYSwgb3B0LCBjYikge1xuICAgIGxvZygnZGlhbCcsIG1hKVxuICAgIHJldHVybiB0aGlzLndzLmRpYWwobWEsIG9wdCwgY2IpXG4gIH1cbiAgY3JlYXRlTGlzdGVuZXIgKG9wdGlvbnMsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGhhbmRsZXIgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9IG5ldyBFRSgpXG4gICAgbGlzdGVuZXIuc2VydmVycyA9IHt9XG4gICAgbGlzdGVuZXIub25saW5lID0gW11cbiAgICB0aGlzLnNlcnZlcnMuZm9yRWFjaChzZXIgPT4ge1xuICAgICAgY29uc3QgcyA9IHRoaXMud3MuY3JlYXRlTGlzdGVuZXIob3B0aW9ucywgaGFuZGxlcilcbiAgICAgIHMub25jZSgnZXJyb3InLCAoKSA9PiB7fSlcbiAgICAgIHMudXJsID0gc2VyXG4gICAgICBsaXN0ZW5lci5zZXJ2ZXJzW3Nlcl0gPSBzXG4gICAgfSlcblxuICAgIGxpc3RlbmVyLmxpc3RlbiA9IChtYSwgY2IpID0+IHtcbiAgICAgIGNvbnN0IGlkID0gbWEudG9TdHJpbmcoKS5zcGxpdCgnaXBmcy8nKS5wb3AoKVxuICAgICAgbG9nKCdsaXN0ZW4gb24gJXMgc2VydmVyKHMpIHdpdGggaWQgJXMnLCB0aGlzLnNlcnZlcnMubGVuZ3RoLCBpZClcbiAgICAgIHBhcmFsbGVsKHRoaXMuc2VydmVycy5tYXAodXJsID0+IGxpc3RlbmVyLnNlcnZlcnNbdXJsXSkubWFwKHNlcnZlciA9PlxuICAgICAgICBjYiA9PiB7XG4gICAgICAgICAgbG9nKCdsaXN0ZW4gJXMnLCBzZXJ2ZXIudXJsKVxuICAgICAgICAgIGNvbnN0IG5leHQgPSBvbmNlKGVyciA9PiB7XG4gICAgICAgICAgICBsb2coJ2xpc3RlbiAlcyBvayAlcycsIHNlcnZlci51cmwsICFlcnIpXG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IobG9nKGVycikpXG4gICAgICAgICAgICBsaXN0ZW5lci5vbmxpbmUucHVzaChzZXJ2ZXIpXG4gICAgICAgICAgICByZXR1cm4gY2IoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgc2V0VGltZW91dChuZXh0LCB0aGlzLm9wdC50aW1lb3V0IHx8IDUwMDAsIG5ldyBFcnJvcignVGltZW91dCcpKVxuICAgICAgICAgIHNlcnZlci5saXN0ZW4obXVsdGlhZGRyKHNlcnZlci51cmwpLmVuY2Fwc3VsYXRlKCcvaXBmcy8nICsgaWQpLCBuZXh0KVxuICAgICAgICB9KSwgKCkgPT4ge1xuICAgICAgICBpZiAoIWxpc3RlbmVyLm9ubGluZS5sZW5ndGggJiYgIXRoaXMub3B0Lmlnbm9yZV9ub19vbmxpbmUpIHtcbiAgICAgICAgICBjb25zdCBlID0gbmV3IEVycm9yKFwiQ291bGRuJ3QgbGlzdGVuIG9uIGFueSBvZiB0aGUgc2VydmVyc1wiKVxuICAgICAgICAgIGxpc3RlbmVyLmVtaXQoJ2Vycm9yJywgZSlcbiAgICAgICAgICBjYihlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpc3RlbmVyLmVtaXQoJ2xpc3RlbmluZycpXG4gICAgICAgICAgY2IoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGxpc3RlbmVyLmNsb3NlID0gY2IgPT5cbiAgICAgIHBhcmFsbGVsKGxpc3RlbmVyLm9ubGluZS5tYXAocyA9PiBjYiA9PiBzLmNsb3NlKGNiKSksIGVyciA9PiBjYihlcnIsIChsaXN0ZW5lci5vbmxpbmUgPSBbXSkpKVxuXG4gICAgbGlzdGVuZXIuZ2V0QWRkcnMgPSBjYiA9PiBtYXAobGlzdGVuZXIub25saW5lLCAocywgbikgPT4gcy5nZXRBZGRycyhuKSwgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIGNiKG51bGwsIHJlcy5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSkpXG4gICAgfSlcblxuICAgIHJldHVybiBsaXN0ZW5lclxuICB9XG5cbiAgZmlsdGVyIChtYSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShtYSkpIG1hID0gW21hXVxuICAgIHJldHVybiBtYS5maWx0ZXIobWEgPT4gbWEudG9TdHJpbmcoKS5zdGFydHNXaXRoKCcvcDJwLXdlYnNvY2tldC1zdGFyJykgfHwgbWFmbXQuV2ViU29ja2V0U3Rhci5tYXRjaGVzKG1hKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYnNvY2tldFN0YXJNdWx0aVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycDp3ZWJydGMtc3RhcicpXG5jb25zdCBtdWx0aWFkZHIgPSByZXF1aXJlKCdtdWx0aWFkZHInKVxuY29uc3QgbWFmbXQgPSByZXF1aXJlKCdtYWZtdCcpXG5jb25zdCB3aXRoSXMgPSByZXF1aXJlKCdjbGFzcy1pcycpXG5jb25zdCBpbyA9IHJlcXVpcmUoJ3NvY2tldC5pby1jbGllbnQnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbmNvbnN0IFNpbXBsZVBlZXIgPSByZXF1aXJlKCdzaW1wbGUtcGVlcicpXG5jb25zdCBQZWVySWQgPSByZXF1aXJlKCdwZWVyLWlkJylcbmNvbnN0IFBlZXJJbmZvID0gcmVxdWlyZSgncGVlci1pbmZvJylcbmNvbnN0IENvbm5lY3Rpb24gPSByZXF1aXJlKCdpbnRlcmZhY2UtY29ubmVjdGlvbicpLkNvbm5lY3Rpb25cbmNvbnN0IHRvUHVsbCA9IHJlcXVpcmUoJ3N0cmVhbS10by1wdWxsLXN0cmVhbScpXG5jb25zdCBvbmNlID0gcmVxdWlyZSgnb25jZScpXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuY29uc3Qgd2VicnRjU3VwcG9ydCA9IHJlcXVpcmUoJ3dlYnJ0Y3N1cHBvcnQnKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IGNsZWFuVXJsU0lPID0gdXRpbHMuY2xlYW5VcmxTSU9cbmNvbnN0IGNsZWFuTXVsdGlhZGRyID0gdXRpbHMuY2xlYW5NdWx0aWFkZHJcblxuY29uc3Qgbm9vcCA9IG9uY2UoKCkgPT4ge30pXG5cbmNvbnN0IHNpb09wdGlvbnMgPSB7XG4gIHRyYW5zcG9ydHM6IFsnd2Vic29ja2V0J10sXG4gICdmb3JjZSBuZXcgY29ubmVjdGlvbic6IHRydWVcbn1cblxuY2xhc3MgV2ViUlRDU3RhciB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgIHRoaXMubWFTZWxmID0gdW5kZWZpbmVkXG5cbiAgICB0aGlzLnNpb09wdGlvbnMgPSB7XG4gICAgICB0cmFuc3BvcnRzOiBbJ3dlYnNvY2tldCddLFxuICAgICAgJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJzogdHJ1ZVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLndydGMpIHtcbiAgICAgIHRoaXMud3J0YyA9IG9wdGlvbnMud3J0Y1xuICAgIH1cblxuICAgIHRoaXMuZGlzY292ZXJ5ID0gbmV3IEVFKClcbiAgICB0aGlzLmRpc2NvdmVyeS50YWcgPSAnd2ViUlRDU3RhcidcbiAgICB0aGlzLmRpc2NvdmVyeS5faXNTdGFydGVkID0gZmFsc2VcbiAgICB0aGlzLmRpc2NvdmVyeS5zdGFydCA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgdGhpcy5kaXNjb3ZlcnkuX2lzU3RhcnRlZCA9IHRydWVcbiAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjaylcbiAgICB9XG4gICAgdGhpcy5kaXNjb3Zlcnkuc3RvcCA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgdGhpcy5kaXNjb3ZlcnkuX2lzU3RhcnRlZCA9IGZhbHNlXG4gICAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spXG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lcnNSZWZzID0ge31cbiAgICB0aGlzLl9wZWVyRGlzY292ZXJlZCA9IHRoaXMuX3BlZXJEaXNjb3ZlcmVkLmJpbmQodGhpcylcbiAgfVxuXG4gIGRpYWwgKG1hLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gb25jZShjYWxsYmFjaykgOiBub29wXG5cbiAgICBjb25zdCBpbnRlbnRJZCA9ICh+fihNYXRoLnJhbmRvbSgpICogMWU5KSkudG9TdHJpbmcoMzYpICsgRGF0ZS5ub3coKVxuXG4gICAgY29uc3Qgc2lvQ2xpZW50ID0gdGhpc1xuICAgICAgLmxpc3RlbmVyc1JlZnNbT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnNSZWZzKVswXV0uaW9cblxuICAgIGNvbnN0IHNwT3B0aW9ucyA9IHsgaW5pdGlhdG9yOiB0cnVlLCB0cmlja2xlOiBmYWxzZSB9XG5cbiAgICAvLyBVc2UgY3VzdG9tIFdlYlJUQyBpbXBsZW1lbnRhdGlvblxuICAgIGlmICh0aGlzLndydGMpIHsgc3BPcHRpb25zLndydGMgPSB0aGlzLndydGMgfVxuXG4gICAgbGV0IGNoYW5uZWxcbiAgICB0cnkge1xuICAgICAgY2hhbm5lbCA9IG5ldyBTaW1wbGVQZWVyKHNwT3B0aW9ucylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZygnQ291bGQgbm90IGNyZWF0ZSBjb25uZWN0aW9uOicsIGVycilcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgY29uc3QgY29ubiA9IG5ldyBDb25uZWN0aW9uKHRvUHVsbC5kdXBsZXgoY2hhbm5lbCkpXG4gICAgbGV0IGNvbm5lY3RlZCA9IGZhbHNlXG5cbiAgICBjaGFubmVsLm9uKCdzaWduYWwnLCAoc2lnbmFsKSA9PiB7XG4gICAgICBzaW9DbGllbnQuZW1pdCgnc3MtaGFuZHNoYWtlJywge1xuICAgICAgICBpbnRlbnRJZDogaW50ZW50SWQsXG4gICAgICAgIHNyY011bHRpYWRkcjogdGhpcy5tYVNlbGYudG9TdHJpbmcoKSxcbiAgICAgICAgZHN0TXVsdGlhZGRyOiBtYS50b1N0cmluZygpLFxuICAgICAgICBzaWduYWw6IHNpZ25hbFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY2hhbm5lbC5vbmNlKCd0aW1lb3V0JywgKCkgPT4gY2FsbGJhY2sobmV3IEVycm9yKCd0aW1lb3V0JykpKVxuXG4gICAgY2hhbm5lbC5vbmNlKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgIGlmICghY29ubmVjdGVkKSB7IGNhbGxiYWNrKGVycikgfVxuICAgIH0pXG5cbiAgICAvLyBOT1RFOiBhZWdpciBzZWdmYXVsdHMgaWYgd2UgZG8gLm9uY2Ugb24gdGhlIHNvY2tldC5pbyBldmVudCBlbWl0dGVyIGFuZCB3ZVxuICAgIC8vIGFyZSBjbHVlbGVzcyBhcyB0byB3aHkuXG4gICAgc2lvQ2xpZW50Lm9uKCd3cy1oYW5kc2hha2UnLCAob2ZmZXIpID0+IHtcbiAgICAgIGlmIChvZmZlci5pbnRlbnRJZCA9PT0gaW50ZW50SWQgJiYgb2ZmZXIuZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3Iob2ZmZXIuZXJyKSlcbiAgICAgIH1cblxuICAgICAgaWYgKG9mZmVyLmludGVudElkICE9PSBpbnRlbnRJZCB8fCAhb2ZmZXIuYW5zd2VyKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjaGFubmVsLm9uY2UoJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGNvbm5lY3RlZCA9IHRydWVcbiAgICAgICAgY29ubi5kZXN0cm95ID0gY2hhbm5lbC5kZXN0cm95LmJpbmQoY2hhbm5lbClcblxuICAgICAgICBjaGFubmVsLm9uY2UoJ2Nsb3NlJywgKCkgPT4gY29ubi5kZXN0cm95KCkpXG5cbiAgICAgICAgY29ubi5nZXRPYnNlcnZlZEFkZHJzID0gKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhudWxsLCBbbWFdKVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNvbm4pXG4gICAgICB9KVxuXG4gICAgICBjaGFubmVsLnNpZ25hbChvZmZlci5zaWduYWwpXG4gICAgfSlcblxuICAgIHJldHVybiBjb25uXG4gIH1cblxuICBjcmVhdGVMaXN0ZW5lciAob3B0aW9ucywgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaGFuZGxlciA9IG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cblxuICAgIGNvbnN0IGxpc3RlbmVyID0gbmV3IEVFKClcblxuICAgIGxpc3RlbmVyLmxpc3RlbiA9IChtYSwgY2FsbGJhY2spID0+IHtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBvbmNlKGNhbGxiYWNrKSA6IG5vb3BcblxuICAgICAgaWYgKCF3ZWJydGNTdXBwb3J0LnN1cHBvcnQgJiYgIXRoaXMud3J0Yykge1xuICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKG5ldyBFcnJvcignbm8gV2ViUlRDIHN1cHBvcnQnKSkpXG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFTZWxmID0gbWFcblxuICAgICAgY29uc3Qgc2lvVXJsID0gY2xlYW5VcmxTSU8obWEpXG5cbiAgICAgIGxvZygnRGlhbGluZyB0byBTaWduYWxsaW5nIFNlcnZlciBvbjogJyArIHNpb1VybClcblxuICAgICAgbGlzdGVuZXIuaW8gPSBpby5jb25uZWN0KHNpb1VybCwgc2lvT3B0aW9ucylcblxuICAgICAgbGlzdGVuZXIuaW8ub25jZSgnY29ubmVjdF9lcnJvcicsIGNhbGxiYWNrKVxuICAgICAgbGlzdGVuZXIuaW8ub25jZSgnZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgICBsaXN0ZW5lci5lbWl0KCdjbG9zZScpXG4gICAgICB9KVxuXG4gICAgICBsaXN0ZW5lci5pby5vbignd3MtaGFuZHNoYWtlJywgaW5jb21taW5nRGlhbClcbiAgICAgIGxpc3RlbmVyLmlvLm9uKCd3cy1wZWVyJywgdGhpcy5fcGVlckRpc2NvdmVyZWQpXG5cbiAgICAgIGxpc3RlbmVyLmlvLm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lci5pby5lbWl0KCdzcy1qb2luJywgbWEudG9TdHJpbmcoKSlcbiAgICAgIH0pXG5cbiAgICAgIGxpc3RlbmVyLmlvLm9uY2UoJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyLmVtaXQoJ2xpc3RlbmluZycpXG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgICBmdW5jdGlvbiBpbmNvbW1pbmdEaWFsIChvZmZlcikge1xuICAgICAgICBpZiAob2ZmZXIuYW5zd2VyIHx8IG9mZmVyLmVycikge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3BPcHRpb25zID0geyB0cmlja2xlOiBmYWxzZSB9XG5cbiAgICAgICAgLy8gVXNlIGN1c3RvbSBXZWJSVEMgaW1wbGVtZW50YXRpb25cbiAgICAgICAgaWYgKHNlbGYud3J0YykgeyBzcE9wdGlvbnMud3J0YyA9IHNlbGYud3J0YyB9XG5cbiAgICAgICAgbGV0IGNoYW5uZWxcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjaGFubmVsID0gbmV3IFNpbXBsZVBlZXIoc3BPcHRpb25zKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBsb2coJ0NvdWxkIG5vdCBjcmVhdGUgaW5jb21pbmcgY29ubmVjdGlvbjonLCBlcnIpXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbm4gPSBuZXcgQ29ubmVjdGlvbih0b1B1bGwuZHVwbGV4KGNoYW5uZWwpKVxuXG4gICAgICAgIGNoYW5uZWwub25jZSgnY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICBjb25uLmdldE9ic2VydmVkQWRkcnMgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbb2ZmZXIuc3JjTXVsdGlhZGRyXSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lci5lbWl0KCdjb25uZWN0aW9uJywgY29ubilcbiAgICAgICAgICBoYW5kbGVyKGNvbm4pXG4gICAgICAgIH0pXG5cbiAgICAgICAgY2hhbm5lbC5vbmNlKCdzaWduYWwnLCAoc2lnbmFsKSA9PiB7XG4gICAgICAgICAgb2ZmZXIuc2lnbmFsID0gc2lnbmFsXG4gICAgICAgICAgb2ZmZXIuYW5zd2VyID0gdHJ1ZVxuICAgICAgICAgIGxpc3RlbmVyLmlvLmVtaXQoJ3NzLWhhbmRzaGFrZScsIG9mZmVyKVxuICAgICAgICB9KVxuXG4gICAgICAgIGNoYW5uZWwuc2lnbmFsKG9mZmVyLnNpZ25hbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0ZW5lci5jbG9zZSA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IG9uY2UoY2FsbGJhY2spIDogbm9vcFxuXG4gICAgICBsaXN0ZW5lci5pby5lbWl0KCdzcy1sZWF2ZScpXG5cbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyLmVtaXQoJ2Nsb3NlJylcbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBsaXN0ZW5lci5nZXRBZGRycyA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKG51bGwsIFt0aGlzLm1hU2VsZl0pKVxuICAgIH1cblxuICAgIHRoaXMubGlzdGVuZXJzUmVmc1ttdWx0aWFkZHIudG9TdHJpbmcoKV0gPSBsaXN0ZW5lclxuICAgIHJldHVybiBsaXN0ZW5lclxuICB9XG5cbiAgZmlsdGVyIChtdWx0aWFkZHJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG11bHRpYWRkcnMpKSB7XG4gICAgICBtdWx0aWFkZHJzID0gW211bHRpYWRkcnNdXG4gICAgfVxuXG4gICAgcmV0dXJuIG11bHRpYWRkcnMuZmlsdGVyKChtYSkgPT4ge1xuICAgICAgaWYgKG1hLnByb3RvTmFtZXMoKS5pbmRleE9mKCdwMnAtY2lyY3VpdCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYWZtdC5XZWJSVENTdGFyLm1hdGNoZXMobWEpXG4gICAgfSlcbiAgfVxuXG4gIF9wZWVyRGlzY292ZXJlZCAobWFTdHIpIHtcbiAgICBpZiAoIXRoaXMuZGlzY292ZXJ5Ll9pc1N0YXJ0ZWQpIHJldHVyblxuXG4gICAgbG9nKCdQZWVyIERpc2NvdmVyZWQ6JywgbWFTdHIpXG4gICAgbWFTdHIgPSBjbGVhbk11bHRpYWRkcihtYVN0cilcblxuICAgIGNvbnN0IHNwbGl0ID0gbWFTdHIuc3BsaXQoJy9pcGZzLycpXG4gICAgY29uc3QgcGVlcklkU3RyID0gc3BsaXRbc3BsaXQubGVuZ3RoIC0gMV1cbiAgICBjb25zdCBwZWVySWQgPSBQZWVySWQuY3JlYXRlRnJvbUI1OFN0cmluZyhwZWVySWRTdHIpXG4gICAgY29uc3QgcGVlckluZm8gPSBuZXcgUGVlckluZm8ocGVlcklkKVxuICAgIHBlZXJJbmZvLm11bHRpYWRkcnMuYWRkKG11bHRpYWRkcihtYVN0cikpXG4gICAgdGhpcy5kaXNjb3ZlcnkuZW1pdCgncGVlcicsIHBlZXJJbmZvKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2l0aElzKFdlYlJUQ1N0YXIsIHsgY2xhc3NOYW1lOiAnV2ViUlRDU3RhcicsIHN5bWJvbE5hbWU6ICdAbGlicDJwL2pzLWxpYnAycC13ZWJydGMtc3Rhci93ZWJydGNzdGFyJyB9KVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEZTTSA9IHJlcXVpcmUoJ2ZzbS1ldmVudCcpXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycCcpXG5sb2cuZXJyb3IgPSBkZWJ1ZygnbGlicDJwOmVycm9yJylcbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5cbmNvbnN0IGVhY2ggPSByZXF1aXJlKCdhc3luYy9lYWNoJylcbmNvbnN0IHNlcmllcyA9IHJlcXVpcmUoJ2FzeW5jL3NlcmllcycpXG5jb25zdCBwYXJhbGxlbCA9IHJlcXVpcmUoJ2FzeW5jL3BhcmFsbGVsJylcbmNvbnN0IG5leHRUaWNrID0gcmVxdWlyZSgnYXN5bmMvbmV4dFRpY2snKVxuXG5jb25zdCBQZWVyQm9vayA9IHJlcXVpcmUoJ3BlZXItYm9vaycpXG5jb25zdCBQZWVySW5mbyA9IHJlcXVpcmUoJ3BlZXItaW5mbycpXG5jb25zdCBTd2l0Y2ggPSByZXF1aXJlKCdsaWJwMnAtc3dpdGNoJylcbmNvbnN0IFBpbmcgPSByZXF1aXJlKCdsaWJwMnAtcGluZycpXG5jb25zdCBXZWJTb2NrZXRzID0gcmVxdWlyZSgnbGlicDJwLXdlYnNvY2tldHMnKVxuY29uc3QgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKCdsaWJwMnAtY29ubmVjdGlvbi1tYW5hZ2VyJylcblxuY29uc3QgeyBlbWl0Rmlyc3QgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCBwZWVyUm91dGluZyA9IHJlcXVpcmUoJy4vcGVlci1yb3V0aW5nJylcbmNvbnN0IGNvbnRlbnRSb3V0aW5nID0gcmVxdWlyZSgnLi9jb250ZW50LXJvdXRpbmcnKVxuY29uc3QgZGh0ID0gcmVxdWlyZSgnLi9kaHQnKVxuY29uc3QgcHVic3ViID0gcmVxdWlyZSgnLi9wdWJzdWInKVxuY29uc3QgZ2V0UGVlckluZm8gPSByZXF1aXJlKCcuL2dldC1wZWVyLWluZm8nKVxuY29uc3QgdmFsaWRhdGVDb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpLnZhbGlkYXRlXG5jb25zdCB7IGNvZGVzIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5cbmNvbnN0IG5vdFN0YXJ0ZWQgPSAoYWN0aW9uLCBzdGF0ZSkgPT4ge1xuICByZXR1cm4gZXJyQ29kZShcbiAgICBuZXcgRXJyb3IoYGxpYnAycCBjYW5ub3QgJHthY3Rpb259IHdoZW4gbm90IHN0YXJ0ZWQ7IHN0YXRlIGlzICR7c3RhdGV9YCksXG4gICAgY29kZXMuRVJSX05PREVfTk9UX1NUQVJURURcbiAgKVxufVxuXG4vKipcbiAqIEBmaXJlcyBMaWJwMnAjZXJyb3IgRW1pdHRlZCB3aGVuIGFuIGVycm9yIG9jY3Vyc1xuICogQGZpcmVzIExpYnAycCNwZWVyOmNvbm5lY3QgRW1pdHRlZCB3aGVuIGEgcGVlciBpcyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlXG4gKiBAZmlyZXMgTGlicDJwI3BlZXI6ZGlzY29ubmVjdCBFbWl0dGVkIHdoZW4gYSBwZWVyIGRpc2Nvbm5lY3RzIGZyb20gdGhpcyBub2RlXG4gKiBAZmlyZXMgTGlicDJwI3BlZXI6ZGlzY292ZXJ5IEVtaXR0ZWQgd2hlbiBhIHBlZXIgaXMgZGlzY292ZXJlZFxuICogQGZpcmVzIExpYnAycCNzdGFydCBFbWl0dGVkIHdoZW4gdGhlIG5vZGUgYW5kIGl0cyBzZXJ2aWNlcyBoYXMgc3RhcnRlZFxuICogQGZpcmVzIExpYnAycCNzdG9wIEVtaXR0ZWQgd2hlbiB0aGUgbm9kZSBhbmQgaXRzIHNlcnZpY2VzIGhhcyBzdG9wcGVkXG4gKi9cbmNsYXNzIExpYnAycCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChfb3B0aW9ucykge1xuICAgIHN1cGVyKClcbiAgICAvLyB2YWxpZGF0ZUNvbmZpZyB3aWxsIGVuc3VyZSB0aGUgY29uZmlnIGlzIGNvcnJlY3QsXG4gICAgLy8gYW5kIGFkZCBkZWZhdWx0IHZhbHVlcyB3aGVyZSBhcHByb3ByaWF0ZVxuICAgIHRoaXMuX29wdGlvbnMgPSB2YWxpZGF0ZUNvbmZpZyhfb3B0aW9ucylcblxuICAgIHRoaXMuZGF0YXN0b3JlID0gdGhpcy5fb3B0aW9ucy5kYXRhc3RvcmVcbiAgICB0aGlzLnBlZXJJbmZvID0gdGhpcy5fb3B0aW9ucy5wZWVySW5mb1xuICAgIHRoaXMucGVlckJvb2sgPSB0aGlzLl9vcHRpb25zLnBlZXJCb29rIHx8IG5ldyBQZWVyQm9vaygpXG5cbiAgICB0aGlzLl9tb2R1bGVzID0gdGhpcy5fb3B0aW9ucy5tb2R1bGVzXG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fb3B0aW9ucy5jb25maWdcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBbXSAvLyBUcmFuc3BvcnQgaW5zdGFuY2VzL3JlZmVyZW5jZXNcbiAgICB0aGlzLl9kaXNjb3ZlcnkgPSBbXSAvLyBEaXNjb3Zlcnkgc2VydmljZSBpbnN0YW5jZXMvcmVmZXJlbmNlc1xuXG4gICAgLy8gY3JlYXRlIHRoZSBzd2l0Y2gsIGFuZCBsaXN0ZW4gZm9yIGVycm9yc1xuICAgIHRoaXMuX3N3aXRjaCA9IG5ldyBTd2l0Y2godGhpcy5wZWVySW5mbywgdGhpcy5wZWVyQm9vaywgdGhpcy5fb3B0aW9ucy5zd2l0Y2gpXG4gICAgdGhpcy5fc3dpdGNoLm9uKCdlcnJvcicsICguLi5hcmdzKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgLi4uYXJncykpXG5cbiAgICB0aGlzLnN0YXRzID0gdGhpcy5fc3dpdGNoLnN0YXRzXG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcih0aGlzLCB0aGlzLl9vcHRpb25zLmNvbm5lY3Rpb25NYW5hZ2VyKVxuXG4gICAgLy8gQXR0YWNoIHN0cmVhbSBtdWx0aXBsZXhlcnNcbiAgICBpZiAodGhpcy5fbW9kdWxlcy5zdHJlYW1NdXhlcikge1xuICAgICAgbGV0IG11eGVycyA9IHRoaXMuX21vZHVsZXMuc3RyZWFtTXV4ZXJcbiAgICAgIG11eGVycy5mb3JFYWNoKChtdXhlcikgPT4gdGhpcy5fc3dpdGNoLmNvbm5lY3Rpb24uYWRkU3RyZWFtTXV4ZXIobXV4ZXIpKVxuXG4gICAgICAvLyBJZiBtdXhlciBleGlzdHNcbiAgICAgIC8vICAgd2UgY2FuIHVzZSBJZGVudGlmeVxuICAgICAgdGhpcy5fc3dpdGNoLmNvbm5lY3Rpb24ucmV1c2UoKVxuICAgICAgLy8gICB3ZSBjYW4gdXNlIFJlbGF5IGZvciBsaXN0ZW5pbmcvZGlhbGluZ1xuICAgICAgdGhpcy5fc3dpdGNoLmNvbm5lY3Rpb24uZW5hYmxlQ2lyY3VpdFJlbGF5KHRoaXMuX2NvbmZpZy5yZWxheSlcblxuICAgICAgLy8gUmVjZWl2ZWQgaW5jb21taW5nIGRpYWwgYW5kIG11eGVyIHVwZ3JhZGUgaGFwcGVuZWQsXG4gICAgICAvLyByZXVzZSB0aGlzIG11eGVkIGNvbm5lY3Rpb25cbiAgICAgIHRoaXMuX3N3aXRjaC5vbigncGVlci1tdXgtZXN0YWJsaXNoZWQnLCAocGVlckluZm8pID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCdwZWVyOmNvbm5lY3QnLCBwZWVySW5mbylcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuX3N3aXRjaC5vbigncGVlci1tdXgtY2xvc2VkJywgKHBlZXJJbmZvKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdCgncGVlcjpkaXNjb25uZWN0JywgcGVlckluZm8pXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIEV2ZW50cyBmb3IgYW55dGltZSBjb25uZWN0aW9ucyBhcmUgY3JlYXRlZC9yZW1vdmVkXG4gICAgdGhpcy5fc3dpdGNoLm9uKCdjb25uZWN0aW9uOnN0YXJ0JywgKHBlZXJJbmZvKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3Rpb246c3RhcnQnLCBwZWVySW5mbylcbiAgICB9KVxuICAgIHRoaXMuX3N3aXRjaC5vbignY29ubmVjdGlvbjplbmQnLCAocGVlckluZm8pID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbjplbmQnLCBwZWVySW5mbylcbiAgICB9KVxuXG4gICAgLy8gQXR0YWNoIGNyeXB0byBjaGFubmVsc1xuICAgIGlmICh0aGlzLl9tb2R1bGVzLmNvbm5FbmNyeXB0aW9uKSB7XG4gICAgICBsZXQgY3J5cHRvcyA9IHRoaXMuX21vZHVsZXMuY29ubkVuY3J5cHRpb25cbiAgICAgIGNyeXB0b3MuZm9yRWFjaCgoY3J5cHRvKSA9PiB7XG4gICAgICAgIHRoaXMuX3N3aXRjaC5jb25uZWN0aW9uLmNyeXB0byhjcnlwdG8udGFnLCBjcnlwdG8uZW5jcnlwdClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gQXR0YWNoIHByaXZhdGUgbmV0d29yayBwcm90ZWN0b3JcbiAgICBpZiAodGhpcy5fbW9kdWxlcy5jb25uUHJvdGVjdG9yKSB7XG4gICAgICB0aGlzLl9zd2l0Y2gucHJvdGVjdG9yID0gdGhpcy5fbW9kdWxlcy5jb25uUHJvdGVjdG9yXG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5MSUJQMlBfRk9SQ0VfUE5FVCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcml2YXRlIG5ldHdvcmsgaXMgZW5mb3JjZWQsIGJ1dCBubyBwcm90ZWN0b3Igd2FzIHByb3ZpZGVkJylcbiAgICB9XG5cbiAgICAvLyBkaHQgcHJvdmlkZWQgY29tcG9uZW50cyAocGVlclJvdXRpbmcsIGNvbnRlbnRSb3V0aW5nLCBkaHQpXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5kaHQuZW5hYmxlZCkge1xuICAgICAgY29uc3QgREhUID0gdGhpcy5fbW9kdWxlcy5kaHRcblxuICAgICAgdGhpcy5fZGh0ID0gbmV3IERIVCh0aGlzLl9zd2l0Y2gsIHtcbiAgICAgICAgZGF0YXN0b3JlOiB0aGlzLmRhdGFzdG9yZSxcbiAgICAgICAgLi4udGhpcy5fY29uZmlnLmRodFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBlbmFibGUvZGlzYWJsZSBwdWJzdWJcbiAgICBpZiAodGhpcy5fY29uZmlnLkVYUEVSSU1FTlRBTC5wdWJzdWIpIHtcbiAgICAgIHRoaXMucHVic3ViID0gcHVic3ViKHRoaXMpXG4gICAgfVxuXG4gICAgLy8gQXR0YWNoIHJlbWFpbmluZyBBUElzXG4gICAgLy8gcGVlciBhbmQgY29udGVudCByb3V0aW5nIHdpbGwgYXV0b21hdGljYWxseSBnZXQgbW9kdWxlcyBmcm9tIF9tb2R1bGVzIGFuZCBfZGh0XG4gICAgdGhpcy5wZWVyUm91dGluZyA9IHBlZXJSb3V0aW5nKHRoaXMpXG4gICAgdGhpcy5jb250ZW50Um91dGluZyA9IGNvbnRlbnRSb3V0aW5nKHRoaXMpXG4gICAgdGhpcy5kaHQgPSBkaHQodGhpcylcblxuICAgIHRoaXMuX2dldFBlZXJJbmZvID0gZ2V0UGVlckluZm8odGhpcylcblxuICAgIC8vIE1vdW50IGRlZmF1bHQgcHJvdG9jb2xzXG4gICAgUGluZy5tb3VudCh0aGlzLl9zd2l0Y2gpXG5cbiAgICB0aGlzLnN0YXRlID0gbmV3IEZTTSgnU1RPUFBFRCcsIHtcbiAgICAgIFNUT1BQRUQ6IHtcbiAgICAgICAgc3RhcnQ6ICdTVEFSVElORycsXG4gICAgICAgIHN0b3A6ICdTVE9QUEVEJ1xuICAgICAgfSxcbiAgICAgIFNUQVJUSU5HOiB7XG4gICAgICAgIGRvbmU6ICdTVEFSVEVEJyxcbiAgICAgICAgYWJvcnQ6ICdTVE9QUEVEJyxcbiAgICAgICAgc3RvcDogJ1NUT1BQSU5HJ1xuICAgICAgfSxcbiAgICAgIFNUQVJURUQ6IHtcbiAgICAgICAgc3RvcDogJ1NUT1BQSU5HJyxcbiAgICAgICAgc3RhcnQ6ICdTVEFSVEVEJ1xuICAgICAgfSxcbiAgICAgIFNUT1BQSU5HOiB7XG4gICAgICAgIHN0b3A6ICdTVE9QUElORycsXG4gICAgICAgIGRvbmU6ICdTVE9QUEVEJ1xuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5zdGF0ZS5vbignU1RBUlRJTkcnLCAoKSA9PiB7XG4gICAgICBsb2coJ2xpYnAycCBpcyBzdGFydGluZycpXG4gICAgICB0aGlzLl9vblN0YXJ0aW5nKClcbiAgICB9KVxuICAgIHRoaXMuc3RhdGUub24oJ1NUT1BQSU5HJywgKCkgPT4ge1xuICAgICAgbG9nKCdsaWJwMnAgaXMgc3RvcHBpbmcnKVxuICAgICAgdGhpcy5fb25TdG9wcGluZygpXG4gICAgfSlcbiAgICB0aGlzLnN0YXRlLm9uKCdTVEFSVEVEJywgKCkgPT4ge1xuICAgICAgbG9nKCdsaWJwMnAgaGFzIHN0YXJ0ZWQnKVxuICAgICAgdGhpcy5lbWl0KCdzdGFydCcpXG4gICAgfSlcbiAgICB0aGlzLnN0YXRlLm9uKCdTVE9QUEVEJywgKCkgPT4ge1xuICAgICAgbG9nKCdsaWJwMnAgaGFzIHN0b3BwZWQnKVxuICAgICAgdGhpcy5lbWl0KCdzdG9wJylcbiAgICB9KVxuICAgIHRoaXMuc3RhdGUub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgbG9nLmVycm9yKGVycilcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfSlcblxuICAgIC8vIE9uY2Ugd2Ugc3RhcnQsIGVtaXQgYW5kIGRpYWwgYW55IHBlZXJzIHdlIG1heSBoYXZlIGFscmVhZHkgZGlzY292ZXJlZFxuICAgIHRoaXMuc3RhdGUub24oJ1NUQVJURUQnLCAoKSA9PiB7XG4gICAgICB0aGlzLnBlZXJCb29rLmdldEFsbEFycmF5KCkuZm9yRWFjaCgocGVlckluZm8pID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCdwZWVyOmRpc2NvdmVyeScsIHBlZXJJbmZvKVxuICAgICAgICB0aGlzLl9tYXliZUNvbm5lY3QocGVlckluZm8pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLl9wZWVyRGlzY292ZXJlZCA9IHRoaXMuX3BlZXJEaXNjb3ZlcmVkLmJpbmQodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgRXZlbnRFbWl0dGVyLmVtaXQgdG8gY29uZGl0aW9uYWxseSBlbWl0IGVycm9yc1xuICAgKiBpZiB0aGVyZSBpcyBhIGhhbmRsZXIuIElmIG5vdCwgZXJyb3JzIHdpbGwgYmUgbG9nZ2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGVtaXQgKGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgIGlmIChldmVudE5hbWUgPT09ICdlcnJvcicgJiYgIXRoaXMuX2V2ZW50cy5lcnJvcikge1xuICAgICAgbG9nLmVycm9yKC4uLmFyZ3MpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGxpYnAycCBub2RlIGFuZCBhbGwgc3ViIHNlcnZpY2VzXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHN0YXJ0IChjYWxsYmFjayA9ICgpID0+IHt9KSB7XG4gICAgZW1pdEZpcnN0KHRoaXMsIFsnZXJyb3InLCAnc3RhcnQnXSwgY2FsbGJhY2spXG4gICAgdGhpcy5zdGF0ZSgnc3RhcnQnKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIGxpYnAycCBub2RlIGJ5IGNsb3NpbmcgaXRzIGxpc3RlbmVycyBhbmQgb3BlbiBjb25uZWN0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzdG9wIChjYWxsYmFjayA9ICgpID0+IHt9KSB7XG4gICAgZW1pdEZpcnN0KHRoaXMsIFsnZXJyb3InLCAnc3RvcCddLCBjYWxsYmFjaylcbiAgICB0aGlzLnN0YXRlKCdzdG9wJylcbiAgfVxuXG4gIGlzU3RhcnRlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPyB0aGlzLnN0YXRlLl9zdGF0ZSA9PT0gJ1NUQVJURUQnIDogZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBEaWFscyB0byB0aGUgcHJvdmlkZWQgcGVlci4gSWYgc3VjY2Vzc2Z1bCwgdGhlIGBQZWVySW5mb2Agb2YgdGhlXG4gICAqIHBlZXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgbm9kZXMgYFBlZXJCb29rYFxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJbmZvfFBlZXJJZHxNdWx0aWFkZHJ8c3RyaW5nfSBwZWVyIFRoZSBwZWVyIHRvIGRpYWxcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZGlhbCAocGVlciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmRpYWxQcm90b2NvbChwZWVyLCBudWxsLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBEaWFscyB0byB0aGUgcHJvdmlkZWQgcGVlciBhbmQgaGFuZHNoYWtlcyB3aXRoIHRoZSBnaXZlbiBwcm90b2NvbC5cbiAgICogSWYgc3VjY2Vzc2Z1bCwgdGhlIGBQZWVySW5mb2Agb2YgdGhlIHBlZXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgbm9kZXMgYFBlZXJCb29rYCxcbiAgICogYW5kIHRoZSBgQ29ubmVjdGlvbmAgd2lsbCBiZSBzZW50IGluIHRoZSBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJbmZvfFBlZXJJZHxNdWx0aWFkZHJ8c3RyaW5nfSBwZWVyIFRoZSBwZWVyIHRvIGRpYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIENvbm5lY3Rpb24pfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGRpYWxQcm90b2NvbCAocGVlciwgcHJvdG9jb2wsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCgpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobm90U3RhcnRlZCgnZGlhbCcsIHRoaXMuc3RhdGUuX3N0YXRlKSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb3RvY29sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IHByb3RvY29sXG4gICAgICBwcm90b2NvbCA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHRoaXMuX2dldFBlZXJJbmZvKHBlZXIsIChlcnIsIHBlZXJJbmZvKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpIH1cblxuICAgICAgdGhpcy5fc3dpdGNoLmRpYWwocGVlckluZm8sIHByb3RvY29sLCBjYWxsYmFjaylcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNpbWlsYXIgdG8gYGRpYWxgIGFuZCBgZGlhbFByb3RvY29sYCwgYnV0IHRoZSBjYWxsYmFjayB3aWxsIGNvbnRhaW4gYVxuICAgKiBDb25uZWN0aW9uIFN0YXRlIE1hY2hpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlckluZm98UGVlcklkfE11bHRpYWRkcnxzdHJpbmd9IHBlZXIgVGhlIHBlZXIgdG8gZGlhbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQ29ubmVjdGlvbkZTTSl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZGlhbEZTTSAocGVlciwgcHJvdG9jb2wsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCgpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobm90U3RhcnRlZCgnZGlhbCcsIHRoaXMuc3RhdGUuX3N0YXRlKSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb3RvY29sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IHByb3RvY29sXG4gICAgICBwcm90b2NvbCA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHRoaXMuX2dldFBlZXJJbmZvKHBlZXIsIChlcnIsIHBlZXJJbmZvKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpIH1cblxuICAgICAgdGhpcy5fc3dpdGNoLmRpYWxGU00ocGVlckluZm8sIHByb3RvY29sLCBjYWxsYmFjaylcbiAgICB9KVxuICB9XG5cbiAgaGFuZ1VwIChwZWVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2dldFBlZXJJbmZvKHBlZXIsIChlcnIsIHBlZXJJbmZvKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpIH1cblxuICAgICAgdGhpcy5fc3dpdGNoLmhhbmdVcChwZWVySW5mbywgY2FsbGJhY2spXG4gICAgfSlcbiAgfVxuXG4gIHBpbmcgKHBlZXIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCgpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobm90U3RhcnRlZCgncGluZycsIHRoaXMuc3RhdGUuX3N0YXRlKSlcbiAgICB9XG5cbiAgICB0aGlzLl9nZXRQZWVySW5mbyhwZWVyLCAoZXJyLCBwZWVySW5mbykgPT4ge1xuICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKSB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIG5ldyBQaW5nKHRoaXMuX3N3aXRjaCwgcGVlckluZm8pKVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGUgKHByb3RvY29sLCBoYW5kbGVyRnVuYywgbWF0Y2hGdW5jKSB7XG4gICAgdGhpcy5fc3dpdGNoLmhhbmRsZShwcm90b2NvbCwgaGFuZGxlckZ1bmMsIG1hdGNoRnVuYylcbiAgfVxuXG4gIHVuaGFuZGxlIChwcm90b2NvbCkge1xuICAgIHRoaXMuX3N3aXRjaC51bmhhbmRsZShwcm90b2NvbClcbiAgfVxuXG4gIF9vblN0YXJ0aW5nICgpIHtcbiAgICBpZiAoIXRoaXMuX21vZHVsZXMudHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB0cmFuc3BvcnRzIHdlcmUgcHJlc2VudCcpKVxuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUoJ2Fib3J0JylcbiAgICB9XG5cbiAgICBsZXQgd3NcblxuICAgIC8vIHNvIHRoYXQgd2UgY2FuIGhhdmUgd2VicnRjLXN0YXIgYWRkcnMgd2l0aG91dCBhZGRpbmcgbWFudWFsbHkgdGhlIGlkXG4gICAgY29uc3QgbWFPbGQgPSBbXVxuICAgIGNvbnN0IG1hTmV3ID0gW11cbiAgICB0aGlzLnBlZXJJbmZvLm11bHRpYWRkcnMudG9BcnJheSgpLmZvckVhY2goKG1hKSA9PiB7XG4gICAgICBpZiAoIW1hLmdldFBlZXJJZCgpKSB7XG4gICAgICAgIG1hT2xkLnB1c2gobWEpXG4gICAgICAgIG1hTmV3LnB1c2gobWEuZW5jYXBzdWxhdGUoJy9wMnAvJyArIHRoaXMucGVlckluZm8uaWQudG9CNThTdHJpbmcoKSkpXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLnBlZXJJbmZvLm11bHRpYWRkcnMucmVwbGFjZShtYU9sZCwgbWFOZXcpXG5cbiAgICBjb25zdCBtdWx0aWFkZHJzID0gdGhpcy5wZWVySW5mby5tdWx0aWFkZHJzLnRvQXJyYXkoKVxuXG4gICAgdGhpcy5fbW9kdWxlcy50cmFuc3BvcnQuZm9yRWFjaCgoVHJhbnNwb3J0KSA9PiB7XG4gICAgICBsZXQgdFxuXG4gICAgICBpZiAodHlwZW9mIFRyYW5zcG9ydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0ID0gbmV3IFRyYW5zcG9ydCh7IGxpYnAycDogdGhpcyB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IFRyYW5zcG9ydFxuICAgICAgfVxuXG4gICAgICBpZiAodC5maWx0ZXIobXVsdGlhZGRycykubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl9zd2l0Y2gudHJhbnNwb3J0LmFkZCh0LnRhZyB8fCB0W1N5bWJvbC50b1N0cmluZ1RhZ10sIHQpXG4gICAgICB9IGVsc2UgaWYgKFdlYlNvY2tldHMuaXNXZWJTb2NrZXRzKHQpKSB7XG4gICAgICAgIC8vIFRPRE8gZmluZCBhIGNsZWFuZXIgd2F5IHRvIHNpZ25hbCB0aGF0IGEgdHJhbnNwb3J0IGlzIGFsd2F5cyB1c2VkXG4gICAgICAgIC8vIGZvciBkaWFsaW5nLCBldmVuIGlmIG5vIGxpc3RlbmVyXG4gICAgICAgIHdzID0gdFxuICAgICAgfVxuICAgICAgdGhpcy5fdHJhbnNwb3J0LnB1c2godClcbiAgICB9KVxuXG4gICAgc2VyaWVzKFtcbiAgICAgIChjYikgPT4ge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0KClcbiAgICAgICAgdGhpcy5fc3dpdGNoLnN0YXJ0KGNiKVxuICAgICAgfSxcbiAgICAgIChjYikgPT4ge1xuICAgICAgICBpZiAod3MpIHtcbiAgICAgICAgICAvLyBhbHdheXMgYWRkIGRpYWxpbmcgb24gd2Vic29ja2V0c1xuICAgICAgICAgIHRoaXMuX3N3aXRjaC50cmFuc3BvcnQuYWRkKHdzLnRhZyB8fCB3cy5jb25zdHJ1Y3Rvci5uYW1lLCB3cylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRldGVjdCB3aGljaCBtdWx0aWFkZHJzIHdlIGRvbid0IGhhdmUgYSB0cmFuc3BvcnQgZm9yIGFuZCByZW1vdmUgdGhlbVxuICAgICAgICBjb25zdCBtdWx0aWFkZHJzID0gdGhpcy5wZWVySW5mby5tdWx0aWFkZHJzLnRvQXJyYXkoKVxuXG4gICAgICAgIG11bHRpYWRkcnMuZm9yRWFjaCgobXVsdGlhZGRyKSA9PiB7XG4gICAgICAgICAgaWYgKCFtdWx0aWFkZHIudG9TdHJpbmcoKS5tYXRjaCgvXFwvcDJwLWNpcmN1aXQoJHxcXC8pLykgJiZcbiAgICAgICAgICAgICAgIXRoaXMuX3RyYW5zcG9ydC5maW5kKCh0cmFuc3BvcnQpID0+IHRyYW5zcG9ydC5maWx0ZXIobXVsdGlhZGRyKS5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgdGhpcy5wZWVySW5mby5tdWx0aWFkZHJzLmRlbGV0ZShtdWx0aWFkZHIpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBjYigpXG4gICAgICB9LFxuICAgICAgKGNiKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9kaHQpIHtcbiAgICAgICAgICB0aGlzLl9kaHQuc3RhcnQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGh0Lm9uKCdwZWVyJywgdGhpcy5fcGVlckRpc2NvdmVyZWQpXG4gICAgICAgICAgICBjYigpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYigpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoY2IpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2Zsb29kU3ViKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Zsb29kU3ViLnN0YXJ0KGNiKVxuICAgICAgICB9XG4gICAgICAgIGNiKClcbiAgICAgIH0sXG4gICAgICAvLyBQZWVyIERpc2NvdmVyeVxuICAgICAgKGNiKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9tb2R1bGVzLnBlZXJEaXNjb3ZlcnkpIHtcbiAgICAgICAgICB0aGlzLl9zZXR1cFBlZXJEaXNjb3ZlcnkoY2IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXSwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2cuZXJyb3IoZXJyKVxuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSgnc3RvcCcpXG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlKCdkb25lJylcbiAgICB9KVxuICB9XG5cbiAgX29uU3RvcHBpbmcgKCkge1xuICAgIHNlcmllcyhbXG4gICAgICAoY2IpID0+IHtcbiAgICAgICAgLy8gc3RvcCBhbGwgZGlzY292ZXJpZXMgYmVmb3JlIGNvbnRpbnVpbmcgd2l0aCBzaHV0ZG93blxuICAgICAgICBwYXJhbGxlbChcbiAgICAgICAgICB0aGlzLl9kaXNjb3ZlcnkubWFwKChkKSA9PiB7XG4gICAgICAgICAgICBkLnJlbW92ZUxpc3RlbmVyKCdwZWVyJywgdGhpcy5fcGVlckRpc2NvdmVyZWQpXG4gICAgICAgICAgICByZXR1cm4gKF9jYikgPT4gZC5zdG9wKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgbG9nLmVycm9yKCdhbiBlcnJvciBvY2N1cnJlZCBzdG9wcGluZyB0aGUgZGlzY292ZXJ5IHNlcnZpY2UnLCBlcnIpXG4gICAgICAgICAgICAgIF9jYigpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNiXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICAoY2IpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2Zsb29kU3ViKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Zsb29kU3ViLnN0b3AoY2IpXG4gICAgICAgIH1cbiAgICAgICAgY2IoKVxuICAgICAgfSxcbiAgICAgIChjYikgPT4ge1xuICAgICAgICBpZiAodGhpcy5fZGh0KSB7XG4gICAgICAgICAgdGhpcy5fZGh0LnJlbW92ZUxpc3RlbmVyKCdwZWVyJywgdGhpcy5fcGVlckRpc2NvdmVyZWQpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RodC5zdG9wKGNiKVxuICAgICAgICB9XG4gICAgICAgIGNiKClcbiAgICAgIH0sXG4gICAgICAoY2IpID0+IHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdG9wKClcbiAgICAgICAgdGhpcy5fc3dpdGNoLnN0b3AoY2IpXG4gICAgICB9LFxuICAgICAgKGNiKSA9PiB7XG4gICAgICAgIC8vIEVuc3VyZXMgaWRlbXBvdGVudCByZXN0YXJ0cywgaWdub3JlIGFueSBlcnJvcnNcbiAgICAgICAgLy8gZnJvbSByZW1vdmVBbGwsIHRoZXkncmUgbm90IHVzZWZ1bCBhdCB0aGlzIHBvaW50XG4gICAgICAgIHRoaXMuX3N3aXRjaC50cmFuc3BvcnQucmVtb3ZlQWxsKCgpID0+IGNiKCkpXG4gICAgICB9XG4gICAgXSwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2cuZXJyb3IoZXJyKVxuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSgnZG9uZScpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGRpc2NvdmVyZWQgcGVlcnMuIEVhY2ggZGlzY292ZXJlZCBwZWVyIHdpbGwgYmUgZW1pdHRlZCB2aWFcbiAgICogdGhlIGBwZWVyOmRpc2NvdmVyeWAgZXZlbnQuIElmIGF1dG8gZGlhbCBpcyBlbmFibGVkIGZvciBsaWJwMnBcbiAgICogYW5kIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gY291bnQgaXMgdW5kZXIgdGhlIGxvdyB3YXRlcm1hcmssIHRoZVxuICAgKiBwZWVyIHdpbGwgYmUgZGlhbGVkLlxuICAgKlxuICAgKiBUT0RPOiBJZiBgcGVlckJvb2sucHV0YCBiZWNvbWVzIGNlbnRyYWxpemVkLCBodHRwczovL2dpdGh1Yi5jb20vbGlicDJwL2pzLWxpYnAycC9pc3N1ZXMvMzQ1LFxuICAgKiBpdCB3b3VsZCBiZSBpZGVhbCBpZiBvbmx5IG5ldyBwZWVycyB3ZXJlIGVtaXR0ZWQuIEN1cnJlbnRseSwgd2l0aFxuICAgKiBvdGhlciBtb2R1bGVzIGFkZGluZyBwZWVycyB0byB0aGUgYFBlZXJCb29rYCB3ZSBoYXZlIG5vIHdheSBvZiBrbm93aW5nXG4gICAqIGlmIGEgcGVlciBpcyBuZXcgb3Igbm90LCBzbyBpdCBoYXMgdG8gYmUgZW1pdHRlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlckluZm9cbiAgICovXG4gIF9wZWVyRGlzY292ZXJlZCAocGVlckluZm8pIHtcbiAgICBpZiAocGVlckluZm8uaWQudG9CNThTdHJpbmcoKSA9PT0gdGhpcy5wZWVySW5mby5pZC50b0I1OFN0cmluZygpKSB7XG4gICAgICBsb2cuZXJyb3IobmV3IEVycm9yKGNvZGVzLkVSUl9ESVNDT1ZFUkVEX1NFTEYpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHBlZXJJbmZvID0gdGhpcy5wZWVyQm9vay5wdXQocGVlckluZm8pXG5cbiAgICBpZiAoIXRoaXMuaXNTdGFydGVkKCkpIHJldHVyblxuXG4gICAgdGhpcy5lbWl0KCdwZWVyOmRpc2NvdmVyeScsIHBlZXJJbmZvKVxuICAgIHRoaXMuX21heWJlQ29ubmVjdChwZWVySW5mbylcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIGRpYWwgdG8gdGhlIGdpdmVuIGBwZWVySW5mb2AgaWYgdGhlIGN1cnJlbnQgbnVtYmVyIG9mXG4gICAqIGNvbm5lY3RlZCBwZWVycyBpcyBsZXNzIHRoYW4gdGhlIGNvbmZpZ3VyZWQgYENvbm5lY3Rpb25NYW5hZ2VyYFxuICAgKiBtaW5QZWVycy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlckluZm9cbiAgICovXG4gIF9tYXliZUNvbm5lY3QgKHBlZXJJbmZvKSB7XG4gICAgLy8gSWYgYXV0byBkaWFsaW5nIGlzIG9uLCBjaGVjayBpZiB3ZSBzaG91bGQgZGlhbFxuICAgIGlmICh0aGlzLl9jb25maWcucGVlckRpc2NvdmVyeS5hdXRvRGlhbCA9PT0gdHJ1ZSAmJiAhcGVlckluZm8uaXNDb25uZWN0ZWQoKSkge1xuICAgICAgY29uc3QgbWluUGVlcnMgPSB0aGlzLl9vcHRpb25zLmNvbm5lY3Rpb25NYW5hZ2VyLm1pblBlZXJzIHx8IDBcbiAgICAgIGlmIChtaW5QZWVycyA+IE9iamVjdC5rZXlzKHRoaXMuX3N3aXRjaC5jb25uZWN0aW9uLmNvbm5lY3Rpb25zKS5sZW5ndGgpIHtcbiAgICAgICAgbG9nKCdjb25uZWN0aW5nIHRvIGRpc2NvdmVyZWQgcGVlcicpXG4gICAgICAgIHRoaXMuX3N3aXRjaC5kaWFsZXIuY29ubmVjdChwZWVySW5mbywgKGVycikgPT4ge1xuICAgICAgICAgIGVyciAmJiBsb2cuZXJyb3IoJ2NvdWxkIG5vdCBjb25uZWN0IHRvIGRpc2NvdmVyZWQgcGVlcicsIGVycilcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYW5kIHN0YXJ0cyBwZWVyIGRpc2NvdmVyeSBzZXJ2aWNlc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICovXG4gIF9zZXR1cFBlZXJEaXNjb3ZlcnkgKGNhbGxiYWNrKSB7XG4gICAgZm9yIChjb25zdCBEaXNjb3ZlcnlTZXJ2aWNlIG9mIHRoaXMuX21vZHVsZXMucGVlckRpc2NvdmVyeSkge1xuICAgICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSAvLyBvbiBieSBkZWZhdWx0XG4gICAgICB9XG5cbiAgICAgIGlmIChEaXNjb3ZlcnlTZXJ2aWNlLnRhZyAmJlxuICAgICAgICB0aGlzLl9jb25maWcucGVlckRpc2NvdmVyeSAmJlxuICAgICAgICB0aGlzLl9jb25maWcucGVlckRpc2NvdmVyeVtEaXNjb3ZlcnlTZXJ2aWNlLnRhZ10pIHtcbiAgICAgICAgY29uZmlnID0geyAuLi5jb25maWcsIC4uLnRoaXMuX2NvbmZpZy5wZWVyRGlzY292ZXJ5W0Rpc2NvdmVyeVNlcnZpY2UudGFnXSB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuZW5hYmxlZCkge1xuICAgICAgICBsZXQgZGlzY292ZXJ5U2VydmljZVxuXG4gICAgICAgIGlmICh0eXBlb2YgRGlzY292ZXJ5U2VydmljZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRpc2NvdmVyeVNlcnZpY2UgPSBuZXcgRGlzY292ZXJ5U2VydmljZShPYmplY3QuYXNzaWduKHt9LCBjb25maWcsIHsgcGVlckluZm86IHRoaXMucGVlckluZm8gfSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzY292ZXJ5U2VydmljZSA9IERpc2NvdmVyeVNlcnZpY2VcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc2NvdmVyeVNlcnZpY2Uub24oJ3BlZXInLCB0aGlzLl9wZWVyRGlzY292ZXJlZClcbiAgICAgICAgdGhpcy5fZGlzY292ZXJ5LnB1c2goZGlzY292ZXJ5U2VydmljZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlYWNoKHRoaXMuX2Rpc2NvdmVyeSwgKGQsIGNiKSA9PiB7XG4gICAgICBkLnN0YXJ0KGNiKVxuICAgIH0sIGNhbGxiYWNrKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGlicDJwXG4vKipcbiAqIExpa2UgYG5ldyBMaWJwMnAob3B0aW9ucylgIGV4Y2VwdCBpdCB3aWxsIGNyZWF0ZSBhIGBQZWVySW5mb2BcbiAqIGluc3RhbmNlIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQgaW4gb3B0aW9ucy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIExpYnAycCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIExpYnAycCl9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xubW9kdWxlLmV4cG9ydHMuY3JlYXRlTGlicDJwID0gKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGlmIChvcHRpb25zLnBlZXJJbmZvKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGNhbGxiYWNrLCBudWxsLCBuZXcgTGlicDJwKG9wdGlvbnMpKVxuICB9XG4gIFBlZXJJbmZvLmNyZWF0ZSgoZXJyLCBwZWVySW5mbykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgb3B0aW9ucy5wZWVySW5mbyA9IHBlZXJJbmZvXG4gICAgY2FsbGJhY2sobnVsbCwgbmV3IExpYnAycChvcHRpb25zKSlcbiAgfSlcbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IGZldGNoXG4iLCJcbmV4cG9ydHMuc291cmNlID0gcmVxdWlyZSgnLi9zb3VyY2UnKVxuZXhwb3J0cy50aHJvdWdoID0gcmVxdWlyZSgnLi90aHJvdWdoJylcbmV4cG9ydHMuc2luayA9IHJlcXVpcmUoJy4vc2luaycpXG5leHBvcnRzLmR1cGxleCA9IHJlcXVpcmUoJy4vZHVwbGV4JylcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgeyBjaWRUb1N0cmluZyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvY2lkJylcbmNvbnN0IHRvUHVsbFN0cmVhbSA9IHJlcXVpcmUoJ2FzeW5jLWl0ZXJhdG9yLXRvLXB1bGwtc3RyZWFtJylcblxuY29uc3Qgbm9ybWFsaXplUGF0aCA9IChwYXRoKSA9PiB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIocGF0aCkpIHtcbiAgICByZXR1cm4gbmV3IENJRChwYXRoKS50b1N0cmluZygpXG4gIH1cbiAgaWYgKENJRC5pc0NJRChwYXRoKSkge1xuICAgIHJldHVybiBwYXRoLnRvU3RyaW5nKClcbiAgfVxuICBpZiAocGF0aC5pbmRleE9mKCcvaXBmcy8nKSA9PT0gMCkge1xuICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygnL2lwZnMvJy5sZW5ndGgpXG4gIH1cbiAgaWYgKHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJykge1xuICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDEpXG4gIH1cbiAgcmV0dXJuIHBhdGhcbn1cblxuLyoqXG4gKiBQYXJzZXMgY2h1bmtlciBzdHJpbmcgaW50byBvcHRpb25zIHVzZWQgYnkgREFHQnVpbGRlciBpbiBpcGZzLXVuaXhmcy1lbmdpbmVcbiAqXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSAgIGNodW5rZXIgQ2h1bmtlciBhbGdvcml0aG0gc3VwcG9ydGVkIGZvcm1hdHM6XG4gKiAgICAgICAgICAgICAgICAgICAgXCJzaXplLXtzaXplfVwiXG4gKiAgICAgICAgICAgICAgICAgICAgXCJyYWJpblwiXG4gKiAgICAgICAgICAgICAgICAgICAgXCJyYWJpbi17YXZnfVwiXG4gKiAgICAgICAgICAgICAgICAgICAgXCJyYWJpbi17bWlufS17YXZnfS17bWF4fVwiXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSAgIENodW5rZXIgb3B0aW9ucyBmb3IgREFHQnVpbGRlclxuICovXG5jb25zdCBwYXJzZUNodW5rZXJTdHJpbmcgPSAoY2h1bmtlcikgPT4ge1xuICBpZiAoIWNodW5rZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2h1bmtlcjogJ2ZpeGVkJ1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaHVua2VyLnN0YXJ0c1dpdGgoJ3NpemUtJykpIHtcbiAgICBjb25zdCBzaXplU3RyID0gY2h1bmtlci5zcGxpdCgnLScpWzFdXG4gICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KHNpemVTdHIpXG4gICAgaWYgKGlzTmFOKHNpemUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NodW5rZXIgcGFyYW1ldGVyIHNpemUgbXVzdCBiZSBhbiBpbnRlZ2VyJylcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNodW5rZXI6ICdmaXhlZCcsXG4gICAgICBjaHVua2VyT3B0aW9uczoge1xuICAgICAgICBtYXhDaHVua1NpemU6IHNpemVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoY2h1bmtlci5zdGFydHNXaXRoKCdyYWJpbicpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNodW5rZXI6ICdyYWJpbicsXG4gICAgICBjaHVua2VyT3B0aW9uczogcGFyc2VSYWJpblN0cmluZyhjaHVua2VyKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBjaHVua2VyIG9wdGlvbjogJHtjaHVua2VyfWApXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZXMgcmFiaW4gY2h1bmtlciBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgY2h1bmtlciBDaHVua2VyIGFsZ29yaXRobSBzdXBwb3J0ZWQgZm9ybWF0czpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmFiaW5cIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyYWJpbi17YXZnfVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInJhYmluLXttaW59LXthdmd9LXttYXh9XCJcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgcmFiaW4gY2h1bmtlciBvcHRpb25zXG4gKi9cbmNvbnN0IHBhcnNlUmFiaW5TdHJpbmcgPSAoY2h1bmtlcikgPT4ge1xuICBjb25zdCBvcHRpb25zID0ge31cbiAgY29uc3QgcGFydHMgPSBjaHVua2VyLnNwbGl0KCctJylcbiAgc3dpdGNoIChwYXJ0cy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICBvcHRpb25zLmF2Z0NodW5rU2l6ZSA9IDI2MjE0NFxuICAgICAgYnJlYWtcbiAgICBjYXNlIDI6XG4gICAgICBvcHRpb25zLmF2Z0NodW5rU2l6ZSA9IHBhcnNlQ2h1bmtTaXplKHBhcnRzWzFdLCAnYXZnJylcbiAgICAgIGJyZWFrXG4gICAgY2FzZSA0OlxuICAgICAgb3B0aW9ucy5taW5DaHVua1NpemUgPSBwYXJzZUNodW5rU2l6ZShwYXJ0c1sxXSwgJ21pbicpXG4gICAgICBvcHRpb25zLmF2Z0NodW5rU2l6ZSA9IHBhcnNlQ2h1bmtTaXplKHBhcnRzWzJdLCAnYXZnJylcbiAgICAgIG9wdGlvbnMubWF4Q2h1bmtTaXplID0gcGFyc2VDaHVua1NpemUocGFydHNbM10sICdtYXgnKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgY2h1bmtlciBmb3JtYXQgKGV4cGVjdGVkIFwicmFiaW5cIiBcInJhYmluLVthdmddXCIgb3IgXCJyYWJpbi1bbWluXS1bYXZnXS1bbWF4XVwiJylcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5cbmNvbnN0IHBhcnNlQ2h1bmtTaXplID0gKHN0ciwgbmFtZSkgPT4ge1xuICBsZXQgc2l6ZSA9IHBhcnNlSW50KHN0cilcbiAgaWYgKGlzTmFOKHNpemUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDaHVua2VyIHBhcmFtZXRlciAke25hbWV9IG11c3QgYmUgYW4gaW50ZWdlcmApXG4gIH1cblxuICByZXR1cm4gc2l6ZVxufVxuXG5jb25zdCBtYXBGaWxlID0gKG9wdGlvbnMgPSB7fSkgPT4ge1xuICByZXR1cm4gKGZpbGUpID0+IHtcbiAgICBsZXQgc2l6ZSA9IDBcbiAgICBsZXQgdHlwZSA9ICdkaXInXG5cbiAgICBpZiAoZmlsZS51bml4ZnMgJiYgZmlsZS51bml4ZnMudHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICBzaXplID0gZmlsZS51bml4ZnMuZmlsZVNpemUoKVxuICAgICAgdHlwZSA9ICdmaWxlJ1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIGhhc2g6IGNpZFRvU3RyaW5nKGZpbGUuY2lkLCB7IGJhc2U6IG9wdGlvbnMuY2lkQmFzZSB9KSxcbiAgICAgIHBhdGg6IGZpbGUucGF0aCxcbiAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgIGRlcHRoOiBmaWxlLnBhdGguc3BsaXQoJy8nKS5sZW5ndGgsXG4gICAgICBzaXplLFxuICAgICAgdHlwZVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluY2x1ZGVDb250ZW50ICYmIGZpbGUudW5peGZzICYmIGZpbGUudW5peGZzLnR5cGUgPT09ICdmaWxlJykge1xuICAgICAgb3V0cHV0LmNvbnRlbnQgPSB0b1B1bGxTdHJlYW0uc291cmNlKGZpbGUuY29udGVudCgpKVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbm9ybWFsaXplUGF0aCxcbiAgcGFyc2VDaHVua1NpemUsXG4gIHBhcnNlUmFiaW5TdHJpbmcsXG4gIHBhcnNlQ2h1bmtlclN0cmluZyxcbiAgbWFwRmlsZVxufVxuIiwiXG52YXIgb25jZSA9IGV4cG9ydHMub25jZSA9XG5mdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhYm9ydCwgY2IpIHtcbiAgICBpZihhYm9ydCkgcmV0dXJuIGNiKGFib3J0KVxuICAgIGlmKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciBfdmFsdWUgPSB2YWx1ZTsgdmFsdWUgPSBudWxsXG4gICAgICBjYihudWxsLCBfdmFsdWUpXG4gICAgfSBlbHNlXG4gICAgICBjYih0cnVlKVxuICB9XG59XG5cbnZhciBkZXB0aEZpcnN0ID0gZXhwb3J0cy5kZXB0aEZpcnN0ID1cbmZ1bmN0aW9uIChzdGFydCwgY3JlYXRlU3RyZWFtKSB7XG4gIHZhciByZWFkcyA9IFtdLCBlbmRlZFxuXG4gIHJlYWRzLnVuc2hpZnQob25jZShzdGFydCkpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIG5leHQgKGVuZCwgY2IpIHtcbiAgICBpZighcmVhZHMubGVuZ3RoKVxuICAgICAgcmV0dXJuIGNiKHRydWUpXG4gICAgaWYoZW5kZWQpXG4gICAgICByZXR1cm4gY2IoZW5kZWQpXG5cbiAgICByZWFkc1swXShlbmQsIGZ1bmN0aW9uIChlbmQsIGRhdGEpIHtcbiAgICAgIGlmKGVuZCkge1xuICAgICAgICBpZihlbmQgIT09IHRydWUpIHtcbiAgICAgICAgICBlbmRlZCA9IGVuZFxuICAgICAgICAgIHJlYWRzLnNoaWZ0KClcblxuICAgICAgICAgIHdoaWxlKHJlYWRzLmxlbmd0aClcbiAgICAgICAgICAgIHJlYWRzLnNoaWZ0KCkoZW5kLCBmdW5jdGlvbiAoKSB7fSlcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gY2IoZW5kKVxuICAgICAgICB9XG4gICAgICAgIC8vaWYgdGhpcyBzdHJlYW0gaGFzIGVuZGVkLCBnbyB0byB0aGUgbmV4dCBxdWV1ZVxuICAgICAgICByZWFkcy5zaGlmdCgpXG4gICAgICAgIHJldHVybiBuZXh0KG51bGwsIGNiKVxuICAgICAgfVxuICAgICAgcmVhZHMudW5zaGlmdChjcmVhdGVTdHJlYW0oZGF0YSkpXG4gICAgICBjYihlbmQsIGRhdGEpXG4gICAgfSlcbiAgfVxufVxuLy93aWR0aCBmaXJzdCBpcyBqdXN0IGxpa2UgZGVwdGggZmlyc3QsXG4vL2J1dCBwdXNoIGVhY2ggbmV3IHN0cmVhbSBvbnRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG52YXIgd2lkdGhGaXJzdCA9IGV4cG9ydHMud2lkdGhGaXJzdCA9IFxuZnVuY3Rpb24gKHN0YXJ0LCBjcmVhdGVTdHJlYW0pIHtcbiAgdmFyIHJlYWRzID0gW11cblxuICByZWFkcy5wdXNoKG9uY2Uoc3RhcnQpKVxuXG4gIHJldHVybiBmdW5jdGlvbiBuZXh0IChlbmQsIGNiKSB7XG4gICAgaWYoIXJlYWRzLmxlbmd0aClcbiAgICAgIHJldHVybiBjYih0cnVlKVxuICAgIHJlYWRzWzBdKGVuZCwgZnVuY3Rpb24gKGVuZCwgZGF0YSkge1xuICAgICAgaWYoZW5kKSB7XG4gICAgICAgIHJlYWRzLnNoaWZ0KClcbiAgICAgICAgcmV0dXJuIG5leHQobnVsbCwgY2IpXG4gICAgICB9XG4gICAgICByZWFkcy5wdXNoKGNyZWF0ZVN0cmVhbShkYXRhKSlcbiAgICAgIGNiKGVuZCwgZGF0YSlcbiAgICB9KVxuICB9XG59XG5cbi8vdGhpcyBjYW1lIG91dCBkaWZmZXJlbnQgdG8gdGhlIGZpcnN0IChzdHJtKVxuLy9hdHRlbXB0IGF0IGxlYWZGaXJzdCwgYnV0IGl0J3Mgc3RpbGwgYSB2YWxpZFxuLy90b3BvbG9naWNhbCBzb3J0LlxudmFyIGxlYWZGaXJzdCA9IGV4cG9ydHMubGVhZkZpcnN0ID0gXG5mdW5jdGlvbiAoc3RhcnQsIGNyZWF0ZVN0cmVhbSkge1xuICB2YXIgcmVhZHMgPSBbXVxuICB2YXIgb3V0cHV0ID0gW11cbiAgcmVhZHMucHVzaChvbmNlKHN0YXJ0KSlcbiAgXG4gIHJldHVybiBmdW5jdGlvbiBuZXh0IChlbmQsIGNiKSB7XG4gICAgcmVhZHNbMF0oZW5kLCBmdW5jdGlvbiAoZW5kLCBkYXRhKSB7XG4gICAgICBpZihlbmQpIHtcbiAgICAgICAgcmVhZHMuc2hpZnQoKVxuICAgICAgICBpZighb3V0cHV0Lmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gY2IodHJ1ZSlcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIG91dHB1dC5zaGlmdCgpKVxuICAgICAgfVxuICAgICAgcmVhZHMudW5zaGlmdChjcmVhdGVTdHJlYW0oZGF0YSkpXG4gICAgICBvdXRwdXQudW5zaGlmdChkYXRhKVxuICAgICAgbmV4dChudWxsLCBjYilcbiAgICB9KVxuICB9XG59XG5cbiIsInZhciBub29wID0gZnVuY3Rpb24gKCkge31cblxuZnVuY3Rpb24gYWJvcnRBbGwoYXJ5LCBhYm9ydCwgY2IpIHtcbiAgdmFyIG4gPSBhcnkubGVuZ3RoXG4gIGlmKCFuKSByZXR1cm4gY2IoYWJvcnQpXG4gIGFyeS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgaWYoZikgZihhYm9ydCwgbmV4dClcbiAgICBlbHNlIG5leHQoKVxuICB9KVxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYoLS1uKSByZXR1cm5cbiAgICBjYihhYm9ydClcbiAgfVxuICBpZighbikgbmV4dCgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmVhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhYm9ydCwgY2IpIHtcbiAgICA7KGZ1bmN0aW9uIG5leHQgKCkge1xuICAgICAgaWYoYWJvcnQpXG4gICAgICAgIGFib3J0QWxsKHN0cmVhbXMsIGFib3J0LCBjYilcbiAgICAgIGVsc2UgaWYoIXN0cmVhbXMubGVuZ3RoKVxuICAgICAgICBjYih0cnVlKVxuICAgICAgZWxzZSBpZighc3RyZWFtc1swXSlcbiAgICAgICAgc3RyZWFtcy5zaGlmdCgpLCBuZXh0KClcbiAgICAgIGVsc2VcbiAgICAgICAgc3RyZWFtc1swXShudWxsLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgaWYoZXJyKSB7XG4gICAgICAgICAgICBzdHJlYW1zLnNoaWZ0KCkgLy9kcm9wIHRoZSBmaXJzdCwgaGFzIGFscmVhZHkgZW5kZWQuXG4gICAgICAgICAgICBpZihlcnIgPT09IHRydWUpIG5leHQoKVxuICAgICAgICAgICAgZWxzZSAgICAgICAgICAgICBhYm9ydEFsbChzdHJlYW1zLCBlcnIsIGNiKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYihudWxsLCBkYXRhKVxuICAgICAgICB9KVxuICAgIH0pKClcbiAgfVxufVxuXG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwcm9taXNpZnkgPSByZXF1aXJlKCdwcm9taXNpZnktZXM2JylcblxubW9kdWxlLmV4cG9ydHMgPSBzZWxmID0+IHtcbiAgcmV0dXJuIHByb21pc2lmeSgoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gYXJncy5wb3AoKVxuICAgIGNhbGxiYWNrKG5ldyBFcnJvcignbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3NlcicpKVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IHJlc29sdmUgPSByZXF1aXJlKCcuL3Jlc29sdmVycycpXG5jb25zdCBsYXN0ID0gcmVxdWlyZSgnYXN5bmMtaXRlcmF0b3ItbGFzdCcpXG5cbmNvbnN0IHRvUGF0aENvbXBvbmVudHMgPSAocGF0aCA9ICcnKSA9PiB7XG4gIC8vIHNwbGl0IG9uIC8gdW5sZXNzIGVzY2FwZWQgd2l0aCBcXFxuICByZXR1cm4gKHBhdGhcbiAgICAudHJpbSgpXG4gICAgLm1hdGNoKC8oW15cXFxcXi9dfFxcXFxcXC8pKy9nKSB8fCBbXSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pXG59XG5cbmNvbnN0IGNpZEFuZFJlc3QgPSAocGF0aCkgPT4ge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBhdGgpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNpZDogbmV3IENJRChwYXRoKSxcbiAgICAgIHRvUmVzb2x2ZTogW11cbiAgICB9XG4gIH1cblxuICBpZiAoQ0lELmlzQ0lEKHBhdGgpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNpZDogcGF0aCxcbiAgICAgIHRvUmVzb2x2ZTogW11cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHBhdGguaW5kZXhPZignL2lwZnMvJykgPT09IDApIHtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZyg2KVxuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dCA9IHRvUGF0aENvbXBvbmVudHMocGF0aClcblxuICAgIHJldHVybiB7XG4gICAgICBjaWQ6IG5ldyBDSUQob3V0cHV0WzBdKSxcbiAgICAgIHRvUmVzb2x2ZTogb3V0cHV0LnNsaWNlKDEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYFVua25vd24gcGF0aCB0eXBlICR7cGF0aH1gKSwgJ0VSUl9CQURfUEFUSCcpXG59XG5cbmNvbnN0IHdhbGtQYXRoID0gYXN5bmMgZnVuY3Rpb24gKiAocGF0aCwgaXBsZCkge1xuICBsZXQge1xuICAgIGNpZCxcbiAgICB0b1Jlc29sdmVcbiAgfSA9IGNpZEFuZFJlc3QocGF0aClcbiAgbGV0IG5hbWUgPSBjaWQudG9CYXNlRW5jb2RlZFN0cmluZygpXG4gIGxldCBlbnRyeVBhdGggPSBuYW1lXG4gIGNvbnN0IHN0YXJ0aW5nRGVwdGggPSB0b1Jlc29sdmUubGVuZ3RoXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvbHZlKGNpZCwgbmFtZSwgZW50cnlQYXRoLCB0b1Jlc29sdmUsIHN0YXJ0aW5nRGVwdGgsIGlwbGQpXG5cbiAgICBpZiAoIXJlc3VsdC5lbnRyeSAmJiAhcmVzdWx0Lm5leHQpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSAke3BhdGh9YCksICdFUlJfTk9UX0ZPVU5EJylcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmVudHJ5KSB7XG4gICAgICB5aWVsZCByZXN1bHQuZW50cnlcbiAgICB9XG5cbiAgICBpZiAoIXJlc3VsdC5uZXh0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXNvbHZlIGZ1cnRoZXIgcGFydHNcbiAgICB0b1Jlc29sdmUgPSByZXN1bHQubmV4dC50b1Jlc29sdmVcbiAgICBjaWQgPSByZXN1bHQubmV4dC5jaWRcbiAgICBuYW1lID0gcmVzdWx0Lm5leHQubmFtZVxuICAgIGVudHJ5UGF0aCA9IHJlc3VsdC5uZXh0LnBhdGhcbiAgfVxufVxuXG5jb25zdCBleHBvcnRlciA9IChwYXRoLCBpcGxkKSA9PiB7XG4gIHJldHVybiBsYXN0KHdhbGtQYXRoKHBhdGgsIGlwbGQpKVxufVxuXG5jb25zdCByZWN1cnNpdmUgPSBhc3luYyBmdW5jdGlvbiAqIChwYXRoLCBpcGxkKSB7XG4gIGNvbnN0IG5vZGUgPSBhd2FpdCBleHBvcnRlcihwYXRoLCBpcGxkKVxuXG4gIHlpZWxkIG5vZGVcblxuICBpZiAobm9kZS51bml4ZnMgJiYgbm9kZS51bml4ZnMudHlwZS5pbmNsdWRlcygnZGlyJykpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNoaWxkIG9mIHJlY3Vyc2Uobm9kZSkpIHtcbiAgICAgIHlpZWxkIGNoaWxkXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gKiByZWN1cnNlIChub2RlKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBmaWxlIG9mIG5vZGUuY29udGVudCgpKSB7XG4gICAgICB5aWVsZCBmaWxlXG5cbiAgICAgIGlmIChmaWxlLnVuaXhmcy50eXBlLmluY2x1ZGVzKCdkaXInKSkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHN1YkZpbGUgb2YgcmVjdXJzZShmaWxlKSkge1xuICAgICAgICAgIHlpZWxkIHN1YkZpbGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVyXG5tb2R1bGUuZXhwb3J0cy5wYXRoID0gd2Fsa1BhdGhcbm1vZHVsZS5leHBvcnRzLnJlY3Vyc2l2ZSA9IHJlY3Vyc2l2ZVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgYWJvcnRDYiA9IHJlcXVpcmUoJy4uL3V0aWwvYWJvcnQtY2InKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG9uY2UgKHZhbHVlLCBvbkFib3J0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYWJvcnQsIGNiKSB7XG4gICAgaWYoYWJvcnQpXG4gICAgICByZXR1cm4gYWJvcnRDYihjYiwgYWJvcnQsIG9uQWJvcnQpXG4gICAgaWYodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIF92YWx1ZSA9IHZhbHVlOyB2YWx1ZSA9IG51bGxcbiAgICAgIGNiKG51bGwsIF92YWx1ZSlcbiAgICB9IGVsc2VcbiAgICAgIGNiKHRydWUpXG4gIH1cbn1cblxuXG4iLCIndXNlIHN0cmljdCdcblxudmFyIHRlc3RlciA9IHJlcXVpcmUoJy4uL3V0aWwvdGVzdGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaWx0ZXIgKHRlc3QpIHtcbiAgLy9yZWdleHBcbiAgdGVzdCA9IHRlc3Rlcih0ZXN0KVxuICByZXR1cm4gZnVuY3Rpb24gKHJlYWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCAoZW5kLCBjYikge1xuICAgICAgdmFyIHN5bmMsIGxvb3AgPSB0cnVlXG4gICAgICB3aGlsZShsb29wKSB7XG4gICAgICAgIGxvb3AgPSBmYWxzZVxuICAgICAgICBzeW5jID0gdHJ1ZVxuICAgICAgICByZWFkKGVuZCwgZnVuY3Rpb24gKGVuZCwgZGF0YSkge1xuICAgICAgICAgIGlmKCFlbmQgJiYgIXRlc3QoZGF0YSkpXG4gICAgICAgICAgICByZXR1cm4gc3luYyA/IGxvb3AgPSB0cnVlIDogbmV4dChlbmQsIGNiKVxuICAgICAgICAgIGNiKGVuZCwgZGF0YSlcbiAgICAgICAgfSlcbiAgICAgICAgc3luYyA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbiIsIlxudmFyIFNvdXJjZSA9IHJlcXVpcmUoJ3B1bGwtZGVmZXIvc291cmNlJylcbnZhciBlcnJvciA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3NvdXJjZXMvZXJyb3InKVxudmFyIHZhbHVlcyA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3NvdXJjZXMvdmFsdWVzJylcbnZhciBjb2xsZWN0ID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vc2lua3MvY29sbGVjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbXBhcmUpIHtcbiAgdmFyIHNvdXJjZSA9IFNvdXJjZSgpXG5cbiAgdmFyIHNpbmsgPSBjb2xsZWN0KGZ1bmN0aW9uIChlcnIsIGFyeSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBzb3VyY2UucmVzb2x2ZShlcnJvcihlcnIpKVxuICAgIH1cblxuICAgIHNvdXJjZS5yZXNvbHZlKHZhbHVlcyhhcnkuc29ydChjb21wYXJlKSkpXG4gIH0pXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZWFkKSB7XG4gICAgc2luayhyZWFkKVxuICAgIHJldHVybiBzb3VyY2VcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGtpbmRPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKVxuY29uc3QgaXNTdHJlYW0gPSByZXF1aXJlKCdpcy1zdHJlYW0nKVxuY29uc3QgeyBpc1NvdXJjZSB9ID0gcmVxdWlyZSgnaXMtcHVsbC1zdHJlYW0nKVxuY29uc3QgaXNCdWZmZXIgPSByZXF1aXJlKCdpcy1idWZmZXInKVxuXG5jb25zdCB2YWxpZGF0ZUFkZElucHV0ID0gKGlucHV0KSA9PiB7XG4gIC8vIEJ1ZmZlcnxSZWFkYWJsZVN0cmVhbXxQdWxsU3RyZWFtfEZpbGVcbiAgY29uc3QgaXNQcmltaXRpdmUgPSBvYmogPT4gaXNCdWZmZXIob2JqKSB8fCBpc1N0cmVhbS5yZWFkYWJsZShvYmopIHx8IGlzU291cmNlKG9iaikgfHwga2luZE9mKG9iaikgPT09ICdmaWxlJ1xuXG4gIC8vIEFuIG9iamVjdCBsaWtlIHsgY29udGVudD8sIHBhdGg/IH0sIHdoZXJlIGNvbnRlbnQgaXNCdWZmZXJPclN0cmVhbSBhbmQgcGF0aCBpc1N0cmluZ1xuICBjb25zdCBpc0NvbnRlbnRPYmplY3QgPSBvYmogPT4ge1xuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlXG4gICAgLy8gcGF0aCBpcyBvcHRpb25hbCBpZiBjb250ZW50IGlzIHByZXNlbnRcbiAgICBpZiAob2JqLmNvbnRlbnQpIHJldHVybiBpc1ByaW1pdGl2ZShvYmouY29udGVudClcbiAgICAvLyBwYXRoIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIGlmIG5vIGNvbnRlbnRcbiAgICByZXR1cm4gQm9vbGVhbihvYmoucGF0aCkgJiYgdHlwZW9mIG9iai5wYXRoID09PSAnc3RyaW5nJ1xuICB9XG5cbiAgLy8gQW4gaW5wdXQgYXRvbTogYSBidWZmZXIsIHN0cmVhbSBvciBjb250ZW50IG9iamVjdFxuICBjb25zdCBpc0lucHV0ID0gb2JqID0+IGlzUHJpbWl0aXZlKG9iaikgfHwgaXNDb250ZW50T2JqZWN0KG9iailcblxuICBpZiAoaXNJbnB1dChpbnB1dCkgfHwgKEFycmF5LmlzQXJyYXkoaW5wdXQpICYmIGlucHV0LmV2ZXJ5KGlzSW5wdXQpKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBub3Qgc3VwcG9ydGVkLiBFeHBlY3RlZCBCdWZmZXJ8UmVhZGFibGVTdHJlYW18UHVsbFN0cmVhbXxGaWxlfEFycmF5PE9iamVjdD4gZ290ICR7a2luZE9mKGlucHV0KX0uIENoZWNrIHRoZSBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGluZm8gaHR0cHM6Ly9naXRodWIuY29tL2lwZnMvaW50ZXJmYWNlLWpzLWlwZnMtY29yZS9ibG9iL21hc3Rlci9TUEVDL0ZJTEVTLm1kI2FkZGApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZUFkZElucHV0XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzU3RyZWFtID0gc3RyZWFtID0+XG5cdHN0cmVhbSAhPT0gbnVsbCAmJlxuXHR0eXBlb2Ygc3RyZWFtID09PSAnb2JqZWN0JyAmJlxuXHR0eXBlb2Ygc3RyZWFtLnBpcGUgPT09ICdmdW5jdGlvbic7XG5cbmlzU3RyZWFtLndyaXRhYmxlID0gc3RyZWFtID0+XG5cdGlzU3RyZWFtKHN0cmVhbSkgJiZcblx0c3RyZWFtLndyaXRhYmxlICE9PSBmYWxzZSAmJlxuXHR0eXBlb2Ygc3RyZWFtLl93cml0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHR0eXBlb2Ygc3RyZWFtLl93cml0YWJsZVN0YXRlID09PSAnb2JqZWN0JztcblxuaXNTdHJlYW0ucmVhZGFibGUgPSBzdHJlYW0gPT5cblx0aXNTdHJlYW0oc3RyZWFtKSAmJlxuXHRzdHJlYW0ucmVhZGFibGUgIT09IGZhbHNlICYmXG5cdHR5cGVvZiBzdHJlYW0uX3JlYWQgPT09ICdmdW5jdGlvbicgJiZcblx0dHlwZW9mIHN0cmVhbS5fcmVhZGFibGVTdGF0ZSA9PT0gJ29iamVjdCc7XG5cbmlzU3RyZWFtLmR1cGxleCA9IHN0cmVhbSA9PlxuXHRpc1N0cmVhbS53cml0YWJsZShzdHJlYW0pICYmXG5cdGlzU3RyZWFtLnJlYWRhYmxlKHN0cmVhbSk7XG5cbmlzU3RyZWFtLnRyYW5zZm9ybSA9IHN0cmVhbSA9PlxuXHRpc1N0cmVhbS5kdXBsZXgoc3RyZWFtKSAmJlxuXHR0eXBlb2Ygc3RyZWFtLl90cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicgJiZcblx0dHlwZW9mIHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUgPT09ICdvYmplY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyZWFtO1xuIiwidmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBraW5kT2YodmFsKSB7XG4gIGlmICh2YWwgPT09IHZvaWQgMCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdib29sZWFuJykgcmV0dXJuICdib29sZWFuJztcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSByZXR1cm4gJ3N0cmluZyc7XG4gIGlmICh0eXBlID09PSAnbnVtYmVyJykgcmV0dXJuICdudW1iZXInO1xuICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHJldHVybiAnc3ltYm9sJztcbiAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXNHZW5lcmF0b3JGbih2YWwpID8gJ2dlbmVyYXRvcmZ1bmN0aW9uJyA6ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoaXNBcnJheSh2YWwpKSByZXR1cm4gJ2FycmF5JztcbiAgaWYgKGlzQnVmZmVyKHZhbCkpIHJldHVybiAnYnVmZmVyJztcbiAgaWYgKGlzQXJndW1lbnRzKHZhbCkpIHJldHVybiAnYXJndW1lbnRzJztcbiAgaWYgKGlzRGF0ZSh2YWwpKSByZXR1cm4gJ2RhdGUnO1xuICBpZiAoaXNFcnJvcih2YWwpKSByZXR1cm4gJ2Vycm9yJztcbiAgaWYgKGlzUmVnZXhwKHZhbCkpIHJldHVybiAncmVnZXhwJztcblxuICBzd2l0Y2ggKGN0b3JOYW1lKHZhbCkpIHtcbiAgICBjYXNlICdTeW1ib2wnOiByZXR1cm4gJ3N5bWJvbCc7XG4gICAgY2FzZSAnUHJvbWlzZSc6IHJldHVybiAncHJvbWlzZSc7XG5cbiAgICAvLyBTZXQsIE1hcCwgV2Vha1NldCwgV2Vha01hcFxuICAgIGNhc2UgJ1dlYWtNYXAnOiByZXR1cm4gJ3dlYWttYXAnO1xuICAgIGNhc2UgJ1dlYWtTZXQnOiByZXR1cm4gJ3dlYWtzZXQnO1xuICAgIGNhc2UgJ01hcCc6IHJldHVybiAnbWFwJztcbiAgICBjYXNlICdTZXQnOiByZXR1cm4gJ3NldCc7XG5cbiAgICAvLyA4LWJpdCB0eXBlZCBhcnJheXNcbiAgICBjYXNlICdJbnQ4QXJyYXknOiByZXR1cm4gJ2ludDhhcnJheSc7XG4gICAgY2FzZSAnVWludDhBcnJheSc6IHJldHVybiAndWludDhhcnJheSc7XG4gICAgY2FzZSAnVWludDhDbGFtcGVkQXJyYXknOiByZXR1cm4gJ3VpbnQ4Y2xhbXBlZGFycmF5JztcblxuICAgIC8vIDE2LWJpdCB0eXBlZCBhcnJheXNcbiAgICBjYXNlICdJbnQxNkFycmF5JzogcmV0dXJuICdpbnQxNmFycmF5JztcbiAgICBjYXNlICdVaW50MTZBcnJheSc6IHJldHVybiAndWludDE2YXJyYXknO1xuXG4gICAgLy8gMzItYml0IHR5cGVkIGFycmF5c1xuICAgIGNhc2UgJ0ludDMyQXJyYXknOiByZXR1cm4gJ2ludDMyYXJyYXknO1xuICAgIGNhc2UgJ1VpbnQzMkFycmF5JzogcmV0dXJuICd1aW50MzJhcnJheSc7XG4gICAgY2FzZSAnRmxvYXQzMkFycmF5JzogcmV0dXJuICdmbG9hdDMyYXJyYXknO1xuICAgIGNhc2UgJ0Zsb2F0NjRBcnJheSc6IHJldHVybiAnZmxvYXQ2NGFycmF5JztcbiAgfVxuXG4gIGlmIChpc0dlbmVyYXRvck9iaih2YWwpKSB7XG4gICAgcmV0dXJuICdnZW5lcmF0b3InO1xuICB9XG5cbiAgLy8gTm9uLXBsYWluIG9iamVjdHNcbiAgdHlwZSA9IHRvU3RyaW5nLmNhbGwodmFsKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnW29iamVjdCBPYmplY3RdJzogcmV0dXJuICdvYmplY3QnO1xuICAgIC8vIGl0ZXJhdG9yc1xuICAgIGNhc2UgJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc6IHJldHVybiAnbWFwaXRlcmF0b3InO1xuICAgIGNhc2UgJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc6IHJldHVybiAnc2V0aXRlcmF0b3InO1xuICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nIEl0ZXJhdG9yXSc6IHJldHVybiAnc3RyaW5naXRlcmF0b3InO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJyYXkgSXRlcmF0b3JdJzogcmV0dXJuICdhcnJheWl0ZXJhdG9yJztcbiAgfVxuXG4gIC8vIG90aGVyXG4gIHJldHVybiB0eXBlLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG59O1xuXG5mdW5jdGlvbiBjdG9yTmFtZSh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgPyB2YWwuY29uc3RydWN0b3IubmFtZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpO1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBFcnJvciB8fCAodHlwZW9mIHZhbC5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiB2YWwuY29uc3RydWN0b3IgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5zdGFja1RyYWNlTGltaXQgPT09ICdudW1iZXInKTtcbn1cblxuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0eXBlb2YgdmFsLnRvRGF0ZVN0cmluZyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiB2YWwuZ2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiB2YWwuc2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNSZWdleHAodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIHZhbC5mbGFncyA9PT0gJ3N0cmluZydcbiAgICAmJiB0eXBlb2YgdmFsLmlnbm9yZUNhc2UgPT09ICdib29sZWFuJ1xuICAgICYmIHR5cGVvZiB2YWwubXVsdGlsaW5lID09PSAnYm9vbGVhbidcbiAgICAmJiB0eXBlb2YgdmFsLmdsb2JhbCA9PT0gJ2Jvb2xlYW4nO1xufVxuXG5mdW5jdGlvbiBpc0dlbmVyYXRvckZuKG5hbWUsIHZhbCkge1xuICByZXR1cm4gY3Rvck5hbWUobmFtZSkgPT09ICdHZW5lcmF0b3JGdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbC50aHJvdyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiB2YWwucmV0dXJuID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIHZhbC5uZXh0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWwpIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHZhbC5sZW5ndGggPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWwuY2FsbGVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdjYWxsZWUnKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBTYWZhcmkgNS03ICg4LTEwIHlyLW9sZCBicm93c2VyKSxcbiAqIHRha2UgYSBsb29rIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaXMtYnVmZmVyXG4gKi9cblxuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIGlmICh2YWwuY29uc3RydWN0b3IgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iXSwicHJlRXhpc3RpbmdDb21tZW50IjoiLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic3RyZWFtLmpzLm1hcCJ9
